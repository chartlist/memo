From tensiam at hotmail.com  Thu Aug  1 10:17:56 2019
From: tensiam at hotmail.com (Kenshiro [])
Date: Thu, 1 Aug 2019 10:17:56 +0000
Subject: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol
In-Reply-To: <2084819.YBhD99MD1N@dprfs-d5766>
References: <DB6PR10MB1832329BC8D151DC18F1E6CEA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<DB6PR10MB1832F1E966CD83BC662985BDA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<DB6PR10MB183271245AAE84FB9AC96474A6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>,
	<2084819.YBhD99MD1N@dprfs-d5766>
Message-ID: <DB6PR10MB1832679F3A195358D234111CA6DE0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>

mm you are right, then the "moving checkpoint" rule needs to have some limits to allow the network self-heal instead of requiring humans detecting the splits or stopping nodes.

Let's suppose than a 51% attack can be detected and the developers can release a new version of the software with a new mining protocol in about 3 days. Then the complementary rule could be something like this:

- If 2 forks have a block height difference of 432 blocks (about 3 days) or more, then the moving checkpoint rule is ignored and everything works as with the current protocol. With this rule, the network can self-heal in a 100% automated way.

This would prevent a history rewrite of more than 24 hours during a 51% attack during 3 days, which should give enough time to change the protocol. If instead of a 51% attack what happens is a network split, then nodes should converge to the longest chain in a few days.

But maybe I'm missing something here, I'm still learning.

Regards,



________________________________
From: Alistair Mann <al at pectw.net>
Sent: Thursday, August 1, 2019 1:28
To: Kenshiro [] <tensiam at hotmail.com>
Cc: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

On Wednesday 31 Jul 2019 14:53:25 Kenshiro [] wrote:
>> How would a (potentially, state-sponsored) netsplit lasting longer than
>> N be handled?
>
> It would be detected by the community much before reaching the reorg limit
> of N blocks (it's 24 hours) so nodes could stop until the netsplit is
> fixed.

A netsplit cannot be detected but merely be suspected where the p2p protocol
does allow arbitrary connecting/disconnecting of any peer: there's no
difference between a remote net being split off, that net having nothing to
say, and that net choosing to disconnect. Detection then mandates manual, out-
of-band communications, which is error prone and centralising.

I also observe 'stopping nodes' during netsplits introduces several attack
vectors. Among them: create a netsplit, which stops the nodes, turn off the
netsplit, repeat. A sequence of 365 actors causing their own small netsplits
could effectively stop Bitcoin at the cost (to them) of no Internet for one
day a year as the rolling netsplit could never be fixed.

> In the extreme case no one notice the network split during more than N
> blocks (24 hours) and there are 2 permanent forks longer than N, nodes from
> one branch could delete their local history so they would join the other
> branch.
>
> P.S.: To be clearer, in this example I set an N value of 144 blocks, which
> is approximately 24 hours.

I've seen estimates of China hosting more than 51% of hashpower. Say they
conduct a netsplit. Does your suggestion mean that it's the rest of the world
that has to delete their local history because they lack the hashpower to
assert themselves as the proper branch? If so, I think having to delete actual
history everywhere across the globe but China is not a price worth paying to
limit reorgs to 24 hours.

I am unconvinced that the moving checkpoint you describe would improve
Bitcoin.
--
Alistair Mann
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/c201578b/attachment.html>

From snigirev.stepan at gmail.com  Thu Aug  1 13:50:47 2019
From: snigirev.stepan at gmail.com (Stepan Snigirev)
Date: Thu, 1 Aug 2019 09:50:47 -0400
Subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future
	Extensibility
In-Reply-To: <mailman.437.1564598007.27056.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.437.1564598007.27056.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CACL8y1tOn_U2YjpzGuRebv=2=tvaEYwR2yMCK_4girJ4WtZ1Ug@mail.gmail.com>

> why not use Bitcoin compact uint, which most PSBT consumers already
implement?

I totally agree with that, compact int parsing is already implemented in
all bitcoin applications, wallets and libraries. Also, for certain (mb
proprietary) applications I will be willing to use multi-byte keys where
the first byte defines the application type and next bytes define
application-specific fields.

I would suggest to set proprietary bytes to 0xF0-0xFC or to 0xE0-0xEF then
(E for Enterprise?).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/ce1e063c/attachment.html>

From achow101-lists at achow101.com  Thu Aug  1 17:57:26 2019
From: achow101-lists at achow101.com (Andrew Chow)
Date: Thu, 01 Aug 2019 17:57:26 +0000
Subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future
	Extensibility
In-Reply-To: <CACL8y1tOn_U2YjpzGuRebv=2=tvaEYwR2yMCK_4girJ4WtZ1Ug@mail.gmail.com>
References: <mailman.437.1564598007.27056.bitcoin-dev@lists.linuxfoundation.org>
	<CACL8y1tOn_U2YjpzGuRebv=2=tvaEYwR2yMCK_4girJ4WtZ1Ug@mail.gmail.com>
Message-ID: <I3Yq3q73tNvEF-Ubis-0A_OPB84-NdRMLUMmMPnQMEazrWw3Q25yGNHVUt5nMOtdD3ISlJj3efNJaLwQjTsvQI1ToF7stRabWo1SYiZjg9U=@achow101.com>

It seems like the consensus is that we should use Compact Size Unsigned
Integers for the field types, so we will do that. The types will be
minimally encoded CSUints.

For the proprietary types, I will use Dimitry's and Andrew Poelstra's
(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016713.html)
suggestion. There will be one proprietary type, 0xFC. This will be
followed by a variable length string that is a vendor specific prefix
that serves as a unique identifier to help with preventing usage of
proprietary types outside of private contexts. This will then be
followed by the actual type for the data, as defined by the user of the
proprietary type.

The prefix will just be a string, prefixed with a compact size unsigned
integer. If no prefix is wanted, then a single 0x00 byte can be used.

For public software, there is no need to handle these proprietary types
at all so they do not need to check the string or the data type. It is
not necessary to enforce the above rules about proprietary types except
that they use the proprietary type value.


Andrew Chow


From achow101-lists at achow101.com  Thu Aug  1 19:01:06 2019
From: achow101-lists at achow101.com (Andrew Chow)
Date: Thu, 01 Aug 2019 19:01:06 +0000
Subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future
	Extensibility
In-Reply-To: <I3Yq3q73tNvEF-Ubis-0A_OPB84-NdRMLUMmMPnQMEazrWw3Q25yGNHVUt5nMOtdD3ISlJj3efNJaLwQjTsvQI1ToF7stRabWo1SYiZjg9U=@achow101.com>
References: <mailman.437.1564598007.27056.bitcoin-dev@lists.linuxfoundation.org>
	<CACL8y1tOn_U2YjpzGuRebv=2=tvaEYwR2yMCK_4girJ4WtZ1Ug@mail.gmail.com>
	<I3Yq3q73tNvEF-Ubis-0A_OPB84-NdRMLUMmMPnQMEazrWw3Q25yGNHVUt5nMOtdD3ISlJj3efNJaLwQjTsvQI1ToF7stRabWo1SYiZjg9U=@achow101.com>
Message-ID: <YgIGlecoK1dbkfdP7mhW_qtJfGfamClPl_0ALhGovnXTPfcQlQDqAiMgeUvSIUVfzblz8oh4zix90pxIj0j3ppvQxDOpCJztJ62vvXn1yO4=@achow101.com>

I spoke to some people OOB and they said that they didn't really like
the idea of having a prefix string (partially because they've already
implemented some proprietary types by simply squatting on unused types).
Matching the prefix string adds additional complexity to the parser
code. The main concern is that people won't want to actually follow the
spec for proprietary types and instead just use some unused type value.
So I think instead we should do:

{0xFC}|{private_type}

and the prefix string can be optional (and strongly recommended) after that.

Since public parsers won't really be enforcing the rules for proprietary
types, I don't think it really makes sense to specify and enforce how
they should be. After all, the key is really just an opaque data blob.

In the same vein, it would probably be useful to allow multiple types
for proprietary use as originally proposed to make implementation of
these easier. If more type are needed, then the private type
construction can be used.


Andrew

On 8/1/19 1:57 PM, Andrew Chow wrote:
> 
> It seems like the consensus is that we should use Compact Size Unsigned
> Integers for the field types, so we will do that. The types will be
> minimally encoded CSUints.
> 
> For the proprietary types, I will use Dimitry's and Andrew Poelstra's
> (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-March/016713.html)
> suggestion. There will be one proprietary type, 0xFC. This will be
> followed by a variable length string that is a vendor specific prefix
> that serves as a unique identifier to help with preventing usage of
> proprietary types outside of private contexts. This will then be
> followed by the actual type for the data, as defined by the user of the
> proprietary type.
> 
> The prefix will just be a string, prefixed with a compact size unsigned
> integer. If no prefix is wanted, then a single 0x00 byte can be used.
> 
> For public software, there is no need to handle these proprietary types
> at all so they do not need to check the string or the data type. It is
> not necessary to enforce the above rules about proprietary types except
> that they use the proprietary type value.
> 
> 
> Andrew Chow
> 


From me at emilengler.com  Thu Aug  1 19:47:40 2019
From: me at emilengler.com (Emil Engler)
Date: Thu, 1 Aug 2019 21:47:40 +0200
Subject: [bitcoin-dev] [Meta] bitcoin-dev moderation
Message-ID: <53b75074-59ff-9890-419d-d5e6fcb44a7c@emilengler.com>

In the last #bitcoin-core-dev IRC meeting, the mailing list moderation
was slightly discussed. It was decided to do this discussion mainly on
this mailing list (which makes sense).

The current situation is that the moderation is slow and takes around
>24h for a E-Mail to be on the mailing list.

Jonas Schnelli proposed: "I propose that we add more moderators to
shorten the moderation lag which has been between >24h, thus makes
debates cumbersome"

Beside this I had the idea of people who already contributed n e-mails
to the mailing list don't need an approval for any e-mail anymore (Where
n is the number of previous e-mails). Does this exists already?

Greetings,
Emil Engler
-------------- next part --------------
A non-text attachment was scrubbed...
Name: pEpkey.asc
Type: application/pgp-keys
Size: 3147 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/a78795b7/attachment.bin>

From belcher at riseup.net  Fri Aug  2 09:21:57 2019
From: belcher at riseup.net (Chris Belcher)
Date: Fri, 2 Aug 2019 10:21:57 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <20190731205018.10ed4302@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
Message-ID: <ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>

On 31/07/2019 16:50, Dmitry Petukhov wrote:
> ? Tue, 30 Jul 2019 22:39:14 +0100
> Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> wrote:
> 
>> This is where a sacrifice of V bitcoins creates a
>> bond of value V^2. The formula provides a strong incentive for
>> profit-motivated makers to use all their fidelity bond coins with just
>> one maker, not spread them out over many makers.
> 
> The attacker derives additional value from the use of
> locked utxo - the deanonimyzation capabilities.
> 
> An entity M can use all of its locked coins to run a maker, and then
> earn value X. It will also incur some operational expenses in the course
> of running the maker, so the profit will be less than X.
> 
> If these locked coins are given to the attacker A as a package, an
> attacker can derive a value of X+D where D is a value of increased
> deanonymization capabilities for an attacker. Operational expenses
> for an attacker are the same as before (without timelocked bonds),
> because they need to operate a lot of makers either way.
> 
> If M is profit-driven and non-ideological, it can rent out all of its
> coins to A as a package, for the price X, and get the same value without
> running a maker and dedicating any resources and time to it, not
> incurring any operatinal expenses (thus having a bigger profit in the
> end).
> 
> Attacker A will run a maker with M's coins, get profit X, pay X to M,
> get increased deanonymization capabilities. 
> 
> If renting out of utxo is done in a way that the owner always gets X
> after the lock expires, the operation will be riskless for the owner.
> The attacker will need to lock amount X along with owner's coins, but
> hopefully makes X back by running a maker operation. 
> 
> The price for renting out the coins will be determined on the size of
> the 'coin package', so it will not be feasible for the owners of the
> coins to rent them out separately.
> 
> An attacker can even rent coins from several entities and combine them
> to create a more 'powerful' maker. If I understand correctly, such
> 'powerful' maker can have bigger profit than two less 'powerful'
> makers. It seems like a centralization risk to me.
> 

There's a few different issues here.

Yes TXO fidelity bonds can be rented out, but that doesn't make a sybil
attack cheaper. The aim of the fidelity bond scheme is to require makers
to sacrifice value, renting out their fidelity bond coins doesn't avoid
that sacrifice because the sacrifice is the paid rent. Because of the
maths and market forces the rent paid by the attacker should be about
the same as the cost of just buying the bitcoins and locking them.

Centralization and decentralization are not ends in themselves, the main
aim in JoinMarket is to improve privacy while keeping the other
properties of bitcoin (e.g. censorship resistance). A single maker can
never deanonoymize coinjoins no matter how valuable their bond is,
because takers always choose multiple makers, and all of them need to be
controlled by the sybil attacker for the attack to succeed. If a sybil
attacker splits up their fidelity bonds (rented or not) amongst multiple
maker bots then they reduce the value of their bonds because of the V^2
term.

Rented TXOs does destroy the effect of "A long-term holder probably
won't want to attack a system like JoinMarket which makes his own
investment coins more private and more fungible". However this is not
the main effect which would protect JoinMarket's privacy. The main
effect is the cost which for real-life numbers would be about 45-120
bitcoin sent to burner outputs.

Perhaps then rented TXOs is an argument against using coin age as a way
to create fidelity bonds. Hodlers would be far less likely to rent out
their coins if they have to specifically move them to a special
time-locked address. Another point is that for privacy reasons creators
of fidelity bonds should mix their coins before and after using them,
because those TXOs are revealed to the world. So it's likely that
fidelity bonds creators will need to install and run JoinMarket anyway.


From dp at simplexum.com  Fri Aug  2 09:18:36 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Fri, 2 Aug 2019 14:18:36 +0500
Subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future
 Extensibility
In-Reply-To: <YgIGlecoK1dbkfdP7mhW_qtJfGfamClPl_0ALhGovnXTPfcQlQDqAiMgeUvSIUVfzblz8oh4zix90pxIj0j3ppvQxDOpCJztJ62vvXn1yO4=@achow101.com>
References: <mailman.437.1564598007.27056.bitcoin-dev@lists.linuxfoundation.org>
	<CACL8y1tOn_U2YjpzGuRebv=2=tvaEYwR2yMCK_4girJ4WtZ1Ug@mail.gmail.com>
	<I3Yq3q73tNvEF-Ubis-0A_OPB84-NdRMLUMmMPnQMEazrWw3Q25yGNHVUt5nMOtdD3ISlJj3efNJaLwQjTsvQI1ToF7stRabWo1SYiZjg9U=@achow101.com>
	<YgIGlecoK1dbkfdP7mhW_qtJfGfamClPl_0ALhGovnXTPfcQlQDqAiMgeUvSIUVfzblz8oh4zix90pxIj0j3ppvQxDOpCJztJ62vvXn1yO4=@achow101.com>
Message-ID: <20190802141836.15771ad6@simplexum.com>

? Thu, 01 Aug 2019 19:01:06 +0000
Andrew Chow <achow101-lists at achow101.com> wrote:

> I spoke to some people OOB and they said that they didn't really like
> the idea of having a prefix string (partially because they've already
> implemented some proprietary types by simply squatting on unused
> types). Matching the prefix string adds additional complexity to the
> parser code.

I do not oppose the idea of "{0xFC}|{private_type}" strongly, but I
would like to note that for those who do not want to deal with
additional complexity of handling a prefixed string, they can simply
not use it at all. Since this is a private construction, and their
private format specifies 'no prefix', they can just ignore everything
that does not start with "{0xFC}|{0x00}", thus any further complexity
regarding the prefix is also ignored. The only added complexity is one
condition check: second_byte_of_the_key != 0 

My other argument for conflict-avoidance prefix as a first thing after
0xFC is that the set of future users of PSBT and private types is
most likely much larger than the current set of those who already
implemented proprietary types on their own, and thus the overall benefit
for the whole industry will likely be bigger when 'i do not want
conflict avoidance' decision have to be explicit, by setting the prefix
to 0x00, and the set of possible conflicting types are limited only to
those entities that made this explicit decision.

Regarding the 'squatted' types, it seems to me that this only matters
in the discussed context if they squatted on 0xFC type in particular.
In other cases, they will need to implement changes anyway, to be
compatible with the BIP. Maybe they could consider that one additional
condition check is a small burden, and maybe they can tolerate that,
for the benefit of reducing possibility of interoperability problems
between other future PSBT/private types implementors.


From kanzure at gmail.com  Fri Aug  2 11:43:27 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Fri, 2 Aug 2019 06:43:27 -0500
Subject: [bitcoin-dev] [Meta] bitcoin-dev moderation
In-Reply-To: <53b75074-59ff-9890-419d-d5e6fcb44a7c@emilengler.com>
References: <53b75074-59ff-9890-419d-d5e6fcb44a7c@emilengler.com>
Message-ID: <CABaSBay1w6ncJX2wVKWotp-FkzkDH4Nkve=QBz90S1G_-SzpZA@mail.gmail.com>

On Thu, Aug 1, 2019 at 10:50 PM Emil Engler via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The current situation is that the moderation is slow and takes around
> >24h for a E-Mail to be on the mailing list

It really shouldn't be 24 hours. Our strategy was to have a few
moderators in different timezones to cover sleep shifts or other
disruptions of service. Evidently this has not been adequate.

> Jonas Schnelli proposed: "I propose that we add more moderators to
> shorten the moderation lag which has been between >24h, thus makes
> debates cumbersome"

Makes sense. I'll go find a few people.

> Beside this I had the idea of people who already contributed n e-mails
> to the mailing list don't need an approval for any e-mail anymore (Where
> n is the number of previous e-mails). Does this exists already?

There is an active software vulnerability which requires moderation to
be enabled. This version of mailman is unmaintained, and Linux
Foundation is migrating away from or abandoning the email protocol so
they are less willing to do backend infrastructure work. This
manifests in other ways, like downtime, but also weird situations like
missing emails that never hit the moderation queue. I get pings from
different people about two times a year where they report an email
that they think I missed, but in fact it never hit the moderation
queue at all. Email clearly isn't the greatest protocol.

- Bryan
http://heybryan.org/
1 512 203 0507

From eth3rs at gmail.com  Fri Aug  2 12:19:03 2019
From: eth3rs at gmail.com (Ethan Heilman)
Date: Fri, 2 Aug 2019 08:19:03 -0400
Subject: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol
In-Reply-To: <DB6PR10MB183271245AAE84FB9AC96474A6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
References: <DB6PR10MB1832329BC8D151DC18F1E6CEA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<28454621.Lge63Ifvux@dprfs-d5766>
	<DB6PR10MB1832F1E966CD83BC662985BDA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<DB6PR10MB183271245AAE84FB9AC96474A6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
Message-ID: <CAEM=y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg@mail.gmail.com>

Attack 1:
I partition (i.e. eclipse) a bunch of nodes from the network this partition
contains no mining power . I then mine 145 blocks for this partition. I
don't even need 51% of the mining power because I'm not competing with any
other miners. Under this rule this partition will hardfork from the network
permanently. Under current rules this partition will be able to rejoin the
network as the least weight chain will be orphaned.

Attack 2:
I pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I
feed it 145 blocks which fork off from the consensus chain. I have 24+24
hours to mine these 145 blocks so I should be able to do this with 25% of
the current hash rate at the time the node went offline. Under your rule
each of these offline-->online nodes I attack this way will hardfork
themselves from the rest of the network.

I believe a moving-checkpoint rule as describe above would make Bitcoin
more vulnerable to 51% attacks.

A safer rule would be if a node detects a fork with both sides of the split
having  length > 144 blocks, it halts and requests user intervention to
determine which chain to follow.  I don't think 144 blocks is a great
number to use here as 24 hours is very short. I suspect you could improve
the security of the rule by making the number of blocks a fork most reach
to halt the network proportional to the difference in time between the
timestamp in the block prior to the fork and the current time. I am **NOT**
proposing Bitcoin adopt such a rule.

NXT has a fundamentally different security model as it uses Proof-of-stake
rather than Proof-of-Work.

On Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> P.S.: To be clearer, in this example I set an N value of 144 blocks, which
> is approximately 24 hours.
>
> ------------------------------
> *From:* Kenshiro [] <tensiam at hotmail.com>
> *Sent:* Wednesday, July 31, 2019 16:40
> *To:* Alistair Mann <al at pectw.net>; Bitcoin Protocol Discussion <
> bitcoin-dev at lists.linuxfoundation.org>
> *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin
> protocol
>
> >>> How would a (potentially, state-sponsored) netsplit lasting longer
> than N be
> handled?
>
> It would be detected by the community much before reaching the reorg limit
> of N blocks (it's 24 hours) so nodes could stop until the netsplit is
> fixed.
>
> In the extreme case no one notice the network split during more than N
> blocks (24 hours) and there are 2 permanent forks longer than N, nodes
> from one branch could delete their local history so they would join the
> other branch.
>
> Regards,
>
>
> ------------------------------
> *From:* Alistair Mann <al at pectw.net>
> *Sent:* Wednesday, July 31, 2019 15:59
> *To:* Kenshiro [] <tensiam at hotmail.com>; Bitcoin Protocol Discussion <
> bitcoin-dev at lists.linuxfoundation.org>
> *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin
> protocol
>
> On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:
>
> > I would like to propose that a "moving checkpoint" is added to the
> Bitcoin
> > protocol. It's a very simple rule already implemented in NXT coin:
> >
> > - A node will ignore any new block under nodeBlockHeight - N, so the
> > blockchain becomes truly immutable after N blocks, even during a 51%
> attack
> > which thanks to the moving checkpoint can't rewrite history older than
> the
> > last N blocks.
>
> How would a (potentially, state-sponsored) netsplit lasting longer than N
> be
> handled?
> --
> Alistair Mann
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/9071fcc3/attachment-0001.html>

From ekaggata at gmail.com  Fri Aug  2 14:24:11 2019
From: ekaggata at gmail.com (Adam Gibson)
Date: Fri, 2 Aug 2019 15:24:11 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
Message-ID: <CAN2_kKQGOoFz6tfrO7s9ULS61R5Hs+KVwFcShXXvSikFuSrirA@mail.gmail.com>

reposted due to wrong email address:

I'd just like to repeat something I said years ago but is undoubtedly lost
now:

>
> ### Today's low cost for sybil attacks
>
> A paper on JoinMarket [M?ser, Malte and Rainer B?hme. ?Join Me on a
> Market for Anonymity.? (2016).] calculates the requirement of such a
> sybil attack in 2016 to be just 32,000 USD. According to the paper such
> an attack would succeed 90% of the time and the investment is
> recoverable afterwards so that figure for the requirement isn't even a
> true cost.
>
> JoinMarket has been improved since 2016 and more makers have joined, so
> the true requirement is perhaps 2x or 3x higher today, but it is still
> relatively low.
>
> Even with future improvements like fixing issue #693 [2] the requirement
> of a sybil attack would probably only rise another 2x.
>

I criticised this point from the Moser paper at the time, in particular
because it was the headline grabbing result and in my opinion was only half
the truth, at best:

The $32K figure came from the assumption that swamping the bottom of the
order book (in other words, making lots of bots offering prices lower than
all the other bots) would lead to taking most of the join volume.

At the time, this was true and false to some extent: it was true that the
default order choosing algorithm was exponentially weighted to lower fees.
But it was also true even then that Takers could simply manually choose any
counterparty bots they liked (-P).

Also at the time I complained that it was trivial to implement other order
choosing algorithms, in particular I advocated (for its simplicity) "choose
randomly under a user specified maximum fee", and indeed since the paper we
have implemented that algorithm and it's now the default.

Note that this algorithm is the crudest variant of what was loosely called
"quantization" in this discussion between belcher and gmaxwell on the topic
some years ago:

https://github.com/JoinMarket-Org/joinmarket/issues/14#issuecomment-143509788

To me the crucial point is that the Taker's price sensitivity should not be
too large, although of course it cannot be zero!

So independent of changes in the makeup of the users of Joinmarket, that
analysis from 2016 was in my opinion a bit skewed at the time, and
completely wrong today.

None of this is a critique of the fidelity bonds idea, since the Sybil
threat is real in any case (see issue 693 as mentioned), but price-based
Sybilling is less effective than it seems based on that.

I'll continue my thoughts on fidelity bonds, for what they're worth, in the
active thread:
https://github.com/JoinMarket-Org/joinmarket-clientserver/issues/371

(for those not in the know, Joinmarket-Org/joinmarket-clientserver is the
active repo, not Joinmarket-Org/joinmarket).

Adam Gibson / waxwing / AdamISZ

On Thu, Jul 25, 2019 at 3:18 PM Chris Belcher via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> JoinMarket[1] can be sybil attacked today at relatively low cost which
> can destroy its privacy. Bitcoins can be sacrificed with burner outputs
> and time-locked addresses (also called fidelity bonds), and this can be
> used to greatly improve JoinMarket's resistance to sybil attacks.
>
> With real-world data and realistic assumptions we calculate that under
> such a fidelity bond system an adversary would need to lock up
> 30,000-80,000 bitcoins for months, or send 45-120 bitcoins to burner
> addresses to have a good chance of sybil attacking the system if it were
> added to JoinMarket.
>
> This increased resistance to sybil attacks would most likely cause
> coinjoin fees to rise. I think the added cost is worth it for the
> greatly improved privacy, because today miner fees are the biggest cost
> to JoinMarket takers not coinjoin fees which are very low. Users should
> definitely share their opinion on fees after reading the document.
>
> ## Introduction
>
> JoinMarket creates a market for coinjoins, allowing anyone to create
> equal-amount coinjoins for any amount they want at any time they want.
> In return they pay a fee for the liquidity made available to them. The
> project has existed since 2015 and has probably created hundreds of
> thousands of coinjoins since then. Today there is available liquidity
> for creating coinjoins with amounts up to about 400 btc per coinjoin
> output.
>
> ### Sybil attacks
>
> JoinMarket, like many other schemes where participants are free to
> anonymously enter, can be targetted by sybil attacks. In JoinMarket this
> would work by an attacker running lots of maker bots which attempt to be
> all the makers in every coinjoin. If successful the attacker would have
> enough information unmix every coinjoin.
>
> One way to solve the problem of sybil attacks is centralization. For
> example coinjoins could be constructed on a centralized server. Then
> random anonymous participants cant sybil attack because they can't
> control the coinjoin construction, but this comes at the cost that the
> server can sybil attack very easily. So this solution is probably a bad
> tradeoff.
>
> In general, sybil attacks are solved by making them expensive. For
> example, bitcoin mining resists sybil attacks because it requires a
> provable sacrifice of electricity to mine. A bitcoin user can calculate
> the actual monetary value that an attacker must spend in order to
> reverse their transaction.
>
> Likewise in JoinMarket such a sybil attack is not free either as the
> attacker needs to own enough bitcoins to run enough maker bots for all
> the coinjoins.
>
> ### Today's low cost for sybil attacks
>
> A paper on JoinMarket [M?ser, Malte and Rainer B?hme. ?Join Me on a
> Market for Anonymity.? (2016).] calculates the requirement of such a
> sybil attack in 2016 to be just 32,000 USD. According to the paper such
> an attack would succeed 90% of the time and the investment is
> recoverable afterwards so that figure for the requirement isn't even a
> true cost.
>
> JoinMarket has been improved since 2016 and more makers have joined, so
> the true requirement is perhaps 2x or 3x higher today, but it is still
> relatively low.
>
> Even with future improvements like fixing issue #693 [2] the requirement
> of a sybil attack would probably only rise another 2x.
>
> Apart from the cost to sybil attack being low, there is also the odd
> situation that smaller coinjoin amounts receive less sybil protection
> than large ones. It costs 100x less to sybil attack a transaction of 0.1
> btc than one of 10 btc. Why should smaller amounts receive less
> sybil-resistance and therefore less privacy?
>
> ### Liquidity
>
> When creating this project, it was expected that many more people would
> enter the market as makers and so the cost of a sybil attack would be
> very high. That has not happened. One reason is that everyone who wants
> to create a coinjoin is able to even for large amounts. The fundamental
> problem is that takers are paying-for and getting liquidity, but not
> necessarily sybil-resistance.
>
> Another smaller reason for the low cost of sybil attacks is that many
> people don't want to store too many bitcoins on an computer connected to
> the internet.
>
> What is needed is a way to increase the cost of running in a maker in a
> way that retains the anonymity and is attractive to long-term holders of
> bitcoin. This can be done using time-locked addresses.
>
> ## Fidelity bonds
>
> In bitcoin, a fidelity bond [3] is a mechanism where bitcoin value is
> deliberately sacrificed to make a cryptographic identity expensive to
> obtain. The sacrifice is done in a way that can be proven to a third party.
>
> A way to create a fidelity bond is to burn an amount of bitcoins by
> sending to a OP_RETURN output. Another kind is time-locked addresses
> created using OP_CHECKLOCKTIMEVERIFY where the valuable thing being
> sacrificed is time rather than money, but the two are related because of
> the time-value-of-money.
>
> Under this system, makers would sacrifice an amount of bitcoins and
> publish a proof along with their coinjoin offers. Takers would choose
> maker offers based on the sacrificed amount (as well as other factors),
> knowing that a sybil attacker would also have to sacrifice a certain
> amount of coins in order to unmix the taker's coinjoins. The sacrifice
> would be an objective measurement that can't be faked and which can be
> verified by anybody (just like, for example PoW mining)
>
> Note that a long-term holder (or hodler) of bitcoins can buy time-locked
> fidelity bonds essentially for free, assuming they never intended to
> transact with their coins much anyway. A long-term holder probably won't
> want to attack a system like JoinMarket which makes his own investment
> coins more private and more fungible.
>
> ### Fidelity bonds in cold storage
>
> The private keys of fidelity bonds can be kept offline. Signatures
> potentially only need to be made when the timelock expires (every 6
> months for example), or only once in the case of OP_RETURN burned coins.
> This allows JoinMarket's sybil resistance to increase without the hot
> wallet risk.
>
> Burned coin signatures should still have a lifetime, in case the private
> key associated with the IRC nick (which is online) is stolen, so that
> the thief of that privkey can't impersonate the maker indefinitely. The
> signature linking the burned coins and IRC nick could expire after
> perhaps 6 months.
>
> ### Anonymity
>
> Under this scheme makers would need to publish the transactions of their
> fidelity bonds to the entire world. Those transactions could be subject
> to blockchain analysis. So before makers do this they should make sure
> their coins are anonymous (possibly by mixing with JoinMarket). Also if
> they ever want to use their coins for something else apart from fidelity
> bonds they should mix them.
>
> ### Value of a fidelity bond
>
> See the other document (Financial mathematics of joinmarket fidelity
> bonds)[4] for a formula expressing the value of a fidelity bond.
>
> The value of a fidelity bond made by sending V bitcoins to a burner
> address is:
>
>     V^2
>
> The amount of bitcoins is squared to get the fidelity bond value. This
> has the effect that economic-rational makers have a strong incentive to
> lump up all their coin sacrifices together into one maker bot, not to
> split it up over several bots.
>
> The value of a fidelity bond made by locking up V bitcoins in a
> time-locked address for time period T is:
>
>     V^2 (exp(rT) - 1)^2
>
> To get an idea of the numbers, if we burn 2 btc then the value of the
> fidelity bond is 4 BTC^2. If we lock up 100 BTC for one year, and have a
> bitcoin interest rate r = 0.001 (0.1%) per year, then the value of that
> fidelity bond is 0.01 BTC^2 which is the same as burning 0.1 BTC. That
> is a relatively small valued bond. It can be increased by locking up
> more bitcoins for longer (up to and including permanant locking via a
> burner transaction).
>
> ## Taker algorithm for choosing makers
>
> I suggest the following taker peer choosing algorithm: obtain the list
> of offers and discard offers which the taker's user deems are too
> expensive. One of the remaining offers is randomly chosen with weighting
> determined by the fidelity bond value. Once an offer is chosen it is
> removed from the list, and another offer is again randomly chosen, this
> is repeated until the taker has chosen the desired number of
> fidelity-bonded maker's offers.
>
> Some people run makers not for profit but for their own privacy.
> Therefore not all makers should be required to have bonds, because such
> privacy-makers are useful to include in coinjoins too. We could have
> taker allow say, an eighth (12.5%), of their coinjoin peers to be makers
> without bonds. They can be chosen randomly from the orderbook without
> any weighting based on fidelity bond values. Of course these are easy to
> fake by an adversary so they dont contribute much to sybil resistance.
>
> ### Cost of sybil attacks
>
> See the other document (Cost of sybil attacks) for discussion and
> calculations on the sybil resistance given by the above maker-choosing
> algorithm.
>
> It can be calculated that the fidelity bond system dramatically
> increases the cost of a sybil attack. With real-world data and realistic
> assumptions we can calculate that a sybil attacker would need to lock up
> 30,000-80,000 bitcoins for 6 months, or send 45-120 bitcoins to burner
> addresses to have a good chance of attacking the system by being all the
> counterparties in everyone's coinjoin.
>
> ## Effect of fidelity bonds on CoinJoin fees
>
> Someone might ask "why would anyone lock up coins for months or more,
> let alone burn coins forever, just to run a maker bot". The only way
> this would even happen is if makers can generate a higher income that
> justifies the fidelity bond sacrifice. That higher income can only come
> from taker's coinjoin fees (or possibly coinswap fees one day). We can
> expect that makers with higher valued fidelity bonds will demand higher
> coinjoin fees. So a big question is whether takers will accept paying
> higher coinjoin fees. I think they will, because right now coinjoin fees
> are only 10-1000 satoshi, and a far biggest cost of coinjoins is the
> miner fee not the coinjoin fee. I'm pretty sure takers will recognize
> that they get what they pay for, and that additional privacy is well
> worth the cost. Any other takers reading this should definitely let me
> know what they think.
>
> ## Technical ideas
>
> JoinMarket's wallet could also create time-locked addresses. Locktimes
> should be fixed to be midnight on the first day of each month, then each
> public key corresponds to 12 addresses per year (1200 addresses per
> century) which is very practical to all be monitored as watch-only
> addresses. These wallets can be created offline and could safely hold
> time-locked bitcoins.
>
> The timelocked addresses public key can be used to sign an IRC nickname
> proving that the nickname is the real owner of the TXO. OP_RETURN
> outputs used for burning coins can include a pubkey hash used for the
> same thing.
>
> We don't want the cold storage keypairs to be held online. We can design
> the system that the time-locked address keypair is held offline but it
> signs another key pair which is held online. Every time the IRC bot
> connects it can use this intermediate keypair to sign the IRC nickname
> proving ownership. The signature from the time-locked address to the
> intermediate keypair can be made to have an expiry date (for example 6
> months). This all means that the time-locked bitcoins can be held
> offline but still be used to prove ownership of an IRC nickname.
>
> The existance of the UTXO of a time-locked coin can be proved by
> revealing the TXID and vout, which full nodes can use to query the UTXO
> set to check that the coin exists. SPV clients would need a merkle proof
> as well. Burned coins and spent time-locked coins could have their
> existence proved by sharing the transaction which created them along
> with a block height and transaction position for an unpruned node, or a
> merkle proof for a pruned node or SPV client. Note that from the point
> of view of a pruned node, a merkle proof is a fully-verified proof of
> existance of a transaction. It is not a proof with just SPV-security.
>
> ## Links / References
> [1] https://github.com/JoinMarket-Org/joinmarket-clientserver
> [2] https://github.com/JoinMarket-Org/joinmarket/issues/693
> [3] https://en.bitcoin.it/wiki/Fidelity_bonds
> [4] https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b
> [5]
>
> https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b#cost-of-sybil-attacks
> [6] First ever mention of fidelity bonds I found. The idea is basically
> invented by Peter Todd: https://bitcointalk.org/index.php?topic=134827.0
> [7] Old idea for combining fidelity bonds with mixers:
> https://bitcointalk.org/index.php?topic=172047.0
> [8] Suggestion that is very close to the fidelity bonds idea. He talks
> about requiring a deposit from makers, but nobody is able to come up
> with a way to make such a deposit decentralized and trustless:
>
> https://www.reddit.com/r/Bitcoin/comments/2zc5tc/joinmarket_increase_the_privacy_of_bitcoin_and/ctk37hn/?context=1
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/ccfbca83/attachment-0001.html>

From tensiam at hotmail.com  Fri Aug  2 13:08:44 2019
From: tensiam at hotmail.com (Kenshiro [])
Date: Fri, 2 Aug 2019 13:08:44 +0000
Subject: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol
In-Reply-To: <CAEM=y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg@mail.gmail.com>
References: <DB6PR10MB1832329BC8D151DC18F1E6CEA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<28454621.Lge63Ifvux@dprfs-d5766>
	<DB6PR10MB1832F1E966CD83BC662985BDA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<DB6PR10MB183271245AAE84FB9AC96474A6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>,
	<CAEM=y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg@mail.gmail.com>
Message-ID: <DB6PR10MB1832110D67FB7FBD1AF5E3EDA6D90@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>

Hi all,

Very good points. I did some clarifications in a private conversation, the new rule is making the moving checkpoint valid only if the difference in blocks between the main chain and the new fork is smaller than X blocks, like for example 3 days of blocks, so after a long network split everyone can finally follow the longest chain:

With the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:

If a node sees a fork longer than his main chain, and the fork has at least X blocks more than the main chain, then the node ignore the moving checkpoint rule, and it follows the fork, the longest chain.

So as an example, the moving checkpoint could be 24 hours of blocks, and the limit of X blocks, the blocks of 3 days.

So we have 2 possible situations to consider:

- 51% attack:  the blocks older than 24 hours are protected against a history rewrite during at least 3 days, in that time developers could release an emergency release with another mining algorithm to stop the attack.

- Network split: if the network split is older than N blocks, we have 2 permanent forks (or chains), but in 3 days (or more) the blockchain heights will differ in more than X blocks (the blocks of 3 days) because there will be more miners in one chain than in the other so finally the loser chain will be abandoned and everyone will follow the longest chain.

It could be even more conservative, like 48 hours for the moving checkpoint and a block limit of 7 days of blocks.

Regards,



________________________________
From: Ethan Heilman <eth3rs at gmail.com>
Sent: Friday, August 2, 2019 14:19
To: Kenshiro [] <tensiam at hotmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
Cc: Alistair Mann <al at pectw.net>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

Attack 1:
I partition (i.e. eclipse) a bunch of nodes from the network this partition contains no mining power . I then mine 145 blocks for this partition. I don't even need 51% of the mining power because I'm not competing with any other miners. Under this rule this partition will hardfork from the network permanently. Under current rules this partition will be able to rejoin the network as the least weight chain will be orphaned.

Attack 2:
I pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I feed it 145 blocks which fork off from the consensus chain. I have 24+24 hours to mine these 145 blocks so I should be able to do this with 25% of the current hash rate at the time the node went offline. Under your rule each of these offline-->online nodes I attack this way will hardfork themselves from the rest of the network.

I believe a moving-checkpoint rule as describe above would make Bitcoin more vulnerable to 51% attacks.

A safer rule would be if a node detects a fork with both sides of the split having  length > 144 blocks, it halts and requests user intervention to determine which chain to follow.  I don't think 144 blocks is a great number to use here as 24 hours is very short. I suspect you could improve the security of the rule by making the number of blocks a fork most reach to halt the network proportional to the difference in time between the timestamp in the block prior to the fork and the current time. I am **NOT** proposing Bitcoin adopt such a rule.

NXT has a fundamentally different security model as it uses Proof-of-stake rather than Proof-of-Work.

On Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
P.S.: To be clearer, in this example I set an N value of 144 blocks, which is approximately 24 hours.

________________________________
From: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>
Sent: Wednesday, July 31, 2019 16:40
To: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

>>> How would a (potentially, state-sponsored) netsplit lasting longer than N be
handled?

It would be detected by the community much before reaching the reorg limit of N blocks (it's 24 hours) so nodes could stop until the netsplit is fixed.

In the extreme case no one notice the network split during more than N blocks (24 hours) and there are 2 permanent forks longer than N, nodes from one branch could delete their local history so they would join the other branch.

Regards,


________________________________
From: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>
Sent: Wednesday, July 31, 2019 15:59
To: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:

> I would like to propose that a "moving checkpoint" is added to the Bitcoin
> protocol. It's a very simple rule already implemented in NXT coin:
>
> - A node will ignore any new block under nodeBlockHeight - N, so the
> blockchain becomes truly immutable after N blocks, even during a 51% attack
> which thanks to the moving checkpoint can't rewrite history older than the
> last N blocks.

How would a (potentially, state-sponsored) netsplit lasting longer than N be
handled?
--
Alistair Mann

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/98a6f15e/attachment.html>

From blinnpr at gmail.com  Fri Aug  2 16:44:01 2019
From: blinnpr at gmail.com (Steven Blinn)
Date: Fri, 2 Aug 2019 12:44:01 -0400
Subject: [bitcoin-dev] bitcoin-dev Digest, Vol 51, Issue 3
In-Reply-To: <mailman.712.1564748374.27056.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.712.1564748374.27056.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CAEV=t-Bgyd2kdzfmspPb+Jn2M-FcBGcK1ppM7g0JPALx9m_uAw@mail.gmail.com>

Emil,

Re: [Meta] bitcoin-dev moderation (Emil Engler)

Since my coding skills are in the infancy stage and I can't contribute much
in that area, at least not yet, I'm looking for other ways to get involved
and moderating the mailing list sounds like an ideal situation.  If you
need help in this area I'm more than happy to volunteer and pick up the
slack.

Steven

On Fri, Aug 2, 2019 at 8:50 AM <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. [Meta] bitcoin-dev moderation (Emil Engler)
>    2. Re: Improving JoinMarket's resistance to sybil attacks using
>       fidelity bonds (Chris Belcher)
>    3. Re: Proposed Extensions to BIP 174 for Future Extensibility
>       (Dmitry Petukhov)
>    4. Re: [Meta] bitcoin-dev moderation (Bryan Bishop)
>    5. Re: Add a moving checkpoint to the Bitcoin protocol
>       (Ethan Heilman)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Thu, 1 Aug 2019 21:47:40 +0200
> From: Emil Engler <me at emilengler.com>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] [Meta] bitcoin-dev moderation
> Message-ID: <53b75074-59ff-9890-419d-d5e6fcb44a7c at emilengler.com>
> Content-Type: text/plain; charset="utf-8"
>
> In the last #bitcoin-core-dev IRC meeting, the mailing list moderation
> was slightly discussed. It was decided to do this discussion mainly on
> this mailing list (which makes sense).
>
> The current situation is that the moderation is slow and takes around
> >24h for a E-Mail to be on the mailing list.
>
> Jonas Schnelli proposed: "I propose that we add more moderators to
> shorten the moderation lag which has been between >24h, thus makes
> debates cumbersome"
>
> Beside this I had the idea of people who already contributed n e-mails
> to the mailing list don't need an approval for any e-mail anymore (Where
> n is the number of previous e-mails). Does this exists already?
>
> Greetings,
> Emil Engler
> -------------- next part --------------
> A non-text attachment was scrubbed...
> Name: pEpkey.asc
> Type: application/pgp-keys
> Size: 3147 bytes
> Desc: not available
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190801/a78795b7/attachment-0001.bin
> >
>
> ------------------------------
>
> Message: 2
> Date: Fri, 2 Aug 2019 10:21:57 +0100
> From: Chris Belcher <belcher at riseup.net>
> To: Dmitry Petukhov <dp at simplexum.com>,
>         bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] Improving JoinMarket's resistance to sybil
>         attacks using fidelity bonds
> Message-ID: <ae32dcbb-c950-3b3f-22b9-d152d6b221cb at riseup.net>
> Content-Type: text/plain; charset=utf-8
>
> On 31/07/2019 16:50, Dmitry Petukhov wrote:
> > ? Tue, 30 Jul 2019 22:39:14 +0100
> > Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> > wrote:
> >
> >> This is where a sacrifice of V bitcoins creates a
> >> bond of value V^2. The formula provides a strong incentive for
> >> profit-motivated makers to use all their fidelity bond coins with just
> >> one maker, not spread them out over many makers.
> >
> > The attacker derives additional value from the use of
> > locked utxo - the deanonimyzation capabilities.
> >
> > An entity M can use all of its locked coins to run a maker, and then
> > earn value X. It will also incur some operational expenses in the course
> > of running the maker, so the profit will be less than X.
> >
> > If these locked coins are given to the attacker A as a package, an
> > attacker can derive a value of X+D where D is a value of increased
> > deanonymization capabilities for an attacker. Operational expenses
> > for an attacker are the same as before (without timelocked bonds),
> > because they need to operate a lot of makers either way.
> >
> > If M is profit-driven and non-ideological, it can rent out all of its
> > coins to A as a package, for the price X, and get the same value without
> > running a maker and dedicating any resources and time to it, not
> > incurring any operatinal expenses (thus having a bigger profit in the
> > end).
> >
> > Attacker A will run a maker with M's coins, get profit X, pay X to M,
> > get increased deanonymization capabilities.
> >
> > If renting out of utxo is done in a way that the owner always gets X
> > after the lock expires, the operation will be riskless for the owner.
> > The attacker will need to lock amount X along with owner's coins, but
> > hopefully makes X back by running a maker operation.
> >
> > The price for renting out the coins will be determined on the size of
> > the 'coin package', so it will not be feasible for the owners of the
> > coins to rent them out separately.
> >
> > An attacker can even rent coins from several entities and combine them
> > to create a more 'powerful' maker. If I understand correctly, such
> > 'powerful' maker can have bigger profit than two less 'powerful'
> > makers. It seems like a centralization risk to me.
> >
>
> There's a few different issues here.
>
> Yes TXO fidelity bonds can be rented out, but that doesn't make a sybil
> attack cheaper. The aim of the fidelity bond scheme is to require makers
> to sacrifice value, renting out their fidelity bond coins doesn't avoid
> that sacrifice because the sacrifice is the paid rent. Because of the
> maths and market forces the rent paid by the attacker should be about
> the same as the cost of just buying the bitcoins and locking them.
>
> Centralization and decentralization are not ends in themselves, the main
> aim in JoinMarket is to improve privacy while keeping the other
> properties of bitcoin (e.g. censorship resistance). A single maker can
> never deanonoymize coinjoins no matter how valuable their bond is,
> because takers always choose multiple makers, and all of them need to be
> controlled by the sybil attacker for the attack to succeed. If a sybil
> attacker splits up their fidelity bonds (rented or not) amongst multiple
> maker bots then they reduce the value of their bonds because of the V^2
> term.
>
> Rented TXOs does destroy the effect of "A long-term holder probably
> won't want to attack a system like JoinMarket which makes his own
> investment coins more private and more fungible". However this is not
> the main effect which would protect JoinMarket's privacy. The main
> effect is the cost which for real-life numbers would be about 45-120
> bitcoin sent to burner outputs.
>
> Perhaps then rented TXOs is an argument against using coin age as a way
> to create fidelity bonds. Hodlers would be far less likely to rent out
> their coins if they have to specifically move them to a special
> time-locked address. Another point is that for privacy reasons creators
> of fidelity bonds should mix their coins before and after using them,
> because those TXOs are revealed to the world. So it's likely that
> fidelity bonds creators will need to install and run JoinMarket anyway.
>
>
>
> ------------------------------
>
> Message: 3
> Date: Fri, 2 Aug 2019 14:18:36 +0500
> From: Dmitry Petukhov <dp at simplexum.com>
> To: Andrew Chow <achow101-lists at achow101.com>
> Cc: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] Proposed Extensions to BIP 174 for Future
>         Extensibility
> Message-ID: <20190802141836.15771ad6 at simplexum.com>
> Content-Type: text/plain; charset=UTF-8
>
> ? Thu, 01 Aug 2019 19:01:06 +0000
> Andrew Chow <achow101-lists at achow101.com> wrote:
>
> > I spoke to some people OOB and they said that they didn't really like
> > the idea of having a prefix string (partially because they've already
> > implemented some proprietary types by simply squatting on unused
> > types). Matching the prefix string adds additional complexity to the
> > parser code.
>
> I do not oppose the idea of "{0xFC}|{private_type}" strongly, but I
> would like to note that for those who do not want to deal with
> additional complexity of handling a prefixed string, they can simply
> not use it at all. Since this is a private construction, and their
> private format specifies 'no prefix', they can just ignore everything
> that does not start with "{0xFC}|{0x00}", thus any further complexity
> regarding the prefix is also ignored. The only added complexity is one
> condition check: second_byte_of_the_key != 0
>
> My other argument for conflict-avoidance prefix as a first thing after
> 0xFC is that the set of future users of PSBT and private types is
> most likely much larger than the current set of those who already
> implemented proprietary types on their own, and thus the overall benefit
> for the whole industry will likely be bigger when 'i do not want
> conflict avoidance' decision have to be explicit, by setting the prefix
> to 0x00, and the set of possible conflicting types are limited only to
> those entities that made this explicit decision.
>
> Regarding the 'squatted' types, it seems to me that this only matters
> in the discussed context if they squatted on 0xFC type in particular.
> In other cases, they will need to implement changes anyway, to be
> compatible with the BIP. Maybe they could consider that one additional
> condition check is a small burden, and maybe they can tolerate that,
> for the benefit of reducing possibility of interoperability problems
> between other future PSBT/private types implementors.
>
>
>
> ------------------------------
>
> Message: 4
> Date: Fri, 2 Aug 2019 06:43:27 -0500
> From: Bryan Bishop <kanzure at gmail.com>
> To: Emil Engler <me at emilengler.com>,    Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>,        Bryan Bishop
>         <kanzure at gmail.com>
> Subject: Re: [bitcoin-dev] [Meta] bitcoin-dev moderation
> Message-ID:
>         <CABaSBay1w6ncJX2wVKWotp-FkzkDH4Nkve=
> QBz90S1G_-SzpZA at mail.gmail.com>
> Content-Type: text/plain; charset="UTF-8"
>
> On Thu, Aug 1, 2019 at 10:50 PM Emil Engler via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > The current situation is that the moderation is slow and takes around
> > >24h for a E-Mail to be on the mailing list
>
> It really shouldn't be 24 hours. Our strategy was to have a few
> moderators in different timezones to cover sleep shifts or other
> disruptions of service. Evidently this has not been adequate.
>
> > Jonas Schnelli proposed: "I propose that we add more moderators to
> > shorten the moderation lag which has been between >24h, thus makes
> > debates cumbersome"
>
> Makes sense. I'll go find a few people.
>
> > Beside this I had the idea of people who already contributed n e-mails
> > to the mailing list don't need an approval for any e-mail anymore (Where
> > n is the number of previous e-mails). Does this exists already?
>
> There is an active software vulnerability which requires moderation to
> be enabled. This version of mailman is unmaintained, and Linux
> Foundation is migrating away from or abandoning the email protocol so
> they are less willing to do backend infrastructure work. This
> manifests in other ways, like downtime, but also weird situations like
> missing emails that never hit the moderation queue. I get pings from
> different people about two times a year where they report an email
> that they think I missed, but in fact it never hit the moderation
> queue at all. Email clearly isn't the greatest protocol.
>
> - Bryan
> http://heybryan.org/
> 1 512 203 0507
>
>
> ------------------------------
>
> Message: 5
> Date: Fri, 2 Aug 2019 08:19:03 -0400
> From: Ethan Heilman <eth3rs at gmail.com>
> To: "Kenshiro []" <tensiam at hotmail.com>,        Bitcoin Dev
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin
>         protocol
> Message-ID:
>         <CAEM=
> y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Attack 1:
> I partition (i.e. eclipse) a bunch of nodes from the network this partition
> contains no mining power . I then mine 145 blocks for this partition. I
> don't even need 51% of the mining power because I'm not competing with any
> other miners. Under this rule this partition will hardfork from the network
> permanently. Under current rules this partition will be able to rejoin the
> network as the least weight chain will be orphaned.
>
> Attack 2:
> I pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I
> feed it 145 blocks which fork off from the consensus chain. I have 24+24
> hours to mine these 145 blocks so I should be able to do this with 25% of
> the current hash rate at the time the node went offline. Under your rule
> each of these offline-->online nodes I attack this way will hardfork
> themselves from the rest of the network.
>
> I believe a moving-checkpoint rule as describe above would make Bitcoin
> more vulnerable to 51% attacks.
>
> A safer rule would be if a node detects a fork with both sides of the split
> having  length > 144 blocks, it halts and requests user intervention to
> determine which chain to follow.  I don't think 144 blocks is a great
> number to use here as 24 hours is very short. I suspect you could improve
> the security of the rule by making the number of blocks a fork most reach
> to halt the network proportional to the difference in time between the
> timestamp in the block prior to the fork and the current time. I am **NOT**
> proposing Bitcoin adopt such a rule.
>
> NXT has a fundamentally different security model as it uses Proof-of-stake
> rather than Proof-of-Work.
>
> On Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > P.S.: To be clearer, in this example I set an N value of 144 blocks,
> which
> > is approximately 24 hours.
> >
> > ------------------------------
> > *From:* Kenshiro [] <tensiam at hotmail.com>
> > *Sent:* Wednesday, July 31, 2019 16:40
> > *To:* Alistair Mann <al at pectw.net>; Bitcoin Protocol Discussion <
> > bitcoin-dev at lists.linuxfoundation.org>
> > *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin
> > protocol
> >
> > >>> How would a (potentially, state-sponsored) netsplit lasting longer
> > than N be
> > handled?
> >
> > It would be detected by the community much before reaching the reorg
> limit
> > of N blocks (it's 24 hours) so nodes could stop until the netsplit is
> > fixed.
> >
> > In the extreme case no one notice the network split during more than N
> > blocks (24 hours) and there are 2 permanent forks longer than N, nodes
> > from one branch could delete their local history so they would join the
> > other branch.
> >
> > Regards,
> >
> >
> > ------------------------------
> > *From:* Alistair Mann <al at pectw.net>
> > *Sent:* Wednesday, July 31, 2019 15:59
> > *To:* Kenshiro [] <tensiam at hotmail.com>; Bitcoin Protocol Discussion <
> > bitcoin-dev at lists.linuxfoundation.org>
> > *Subject:* Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin
> > protocol
> >
> > On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:
> >
> > > I would like to propose that a "moving checkpoint" is added to the
> > Bitcoin
> > > protocol. It's a very simple rule already implemented in NXT coin:
> > >
> > > - A node will ignore any new block under nodeBlockHeight - N, so the
> > > blockchain becomes truly immutable after N blocks, even during a 51%
> > attack
> > > which thanks to the moving checkpoint can't rewrite history older than
> > the
> > > last N blocks.
> >
> > How would a (potentially, state-sponsored) netsplit lasting longer than N
> > be
> > handled?
> > --
> > Alistair Mann
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/9071fcc3/attachment.html
> >
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 51, Issue 3
> ******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190802/97a230b4/attachment-0001.html>

From willtech at live.com.au  Sat Aug  3 00:51:12 2019
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Sat, 3 Aug 2019 00:51:12 +0000
Subject: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol
In-Reply-To: <DB6PR10MB1832110D67FB7FBD1AF5E3EDA6D90@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
References: <DB6PR10MB1832329BC8D151DC18F1E6CEA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<28454621.Lge63Ifvux@dprfs-d5766>
	<DB6PR10MB1832F1E966CD83BC662985BDA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<DB6PR10MB183271245AAE84FB9AC96474A6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>,
	<CAEM=y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg@mail.gmail.com>,
	<DB6PR10MB1832110D67FB7FBD1AF5E3EDA6D90@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
Message-ID: <PS2P216MB0179F9419B116F333EBF10799DD80@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

I have but one point to make in a brief catch-up read over.

With the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:

It is not to be considered the longest chain, it is to be considered the longest chain with the most proof of work.

Regards,
LORD HIS EXCELLENCY JAMES HRMH
<https://earn.com/willtech>


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Friday, 2 August 2019 11:08 PM
To: Ethan Heilman <eth3rs at gmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

Hi all,

Very good points. I did some clarifications in a private conversation, the new rule is making the moving checkpoint valid only if the difference in blocks between the main chain and the new fork is smaller than X blocks, like for example 3 days of blocks, so after a long network split everyone can finally follow the longest chain:

With the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:

If a node sees a fork longer than his main chain, and the fork has at least X blocks more than the main chain, then the node ignore the moving checkpoint rule, and it follows the fork, the longest chain.

So as an example, the moving checkpoint could be 24 hours of blocks, and the limit of X blocks, the blocks of 3 days.

So we have 2 possible situations to consider:

- 51% attack:  the blocks older than 24 hours are protected against a history rewrite during at least 3 days, in that time developers could release an emergency release with another mining algorithm to stop the attack.

- Network split: if the network split is older than N blocks, we have 2 permanent forks (or chains), but in 3 days (or more) the blockchain heights will differ in more than X blocks (the blocks of 3 days) because there will be more miners in one chain than in the other so finally the loser chain will be abandoned and everyone will follow the longest chain.

It could be even more conservative, like 48 hours for the moving checkpoint and a block limit of 7 days of blocks.

Regards,



________________________________
From: Ethan Heilman <eth3rs at gmail.com>
Sent: Friday, August 2, 2019 14:19
To: Kenshiro [] <tensiam at hotmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
Cc: Alistair Mann <al at pectw.net>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

Attack 1:
I partition (i.e. eclipse) a bunch of nodes from the network this partition contains no mining power . I then mine 145 blocks for this partition. I don't even need 51% of the mining power because I'm not competing with any other miners. Under this rule this partition will hardfork from the network permanently. Under current rules this partition will be able to rejoin the network as the least weight chain will be orphaned.

Attack 2:
I pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I feed it 145 blocks which fork off from the consensus chain. I have 24+24 hours to mine these 145 blocks so I should be able to do this with 25% of the current hash rate at the time the node went offline. Under your rule each of these offline-->online nodes I attack this way will hardfork themselves from the rest of the network.

I believe a moving-checkpoint rule as describe above would make Bitcoin more vulnerable to 51% attacks.

A safer rule would be if a node detects a fork with both sides of the split having  length > 144 blocks, it halts and requests user intervention to determine which chain to follow.  I don't think 144 blocks is a great number to use here as 24 hours is very short. I suspect you could improve the security of the rule by making the number of blocks a fork most reach to halt the network proportional to the difference in time between the timestamp in the block prior to the fork and the current time. I am **NOT** proposing Bitcoin adopt such a rule.

NXT has a fundamentally different security model as it uses Proof-of-stake rather than Proof-of-Work.

On Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
P.S.: To be clearer, in this example I set an N value of 144 blocks, which is approximately 24 hours.

________________________________
From: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>
Sent: Wednesday, July 31, 2019 16:40
To: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

>>> How would a (potentially, state-sponsored) netsplit lasting longer than N be
handled?

It would be detected by the community much before reaching the reorg limit of N blocks (it's 24 hours) so nodes could stop until the netsplit is fixed.

In the extreme case no one notice the network split during more than N blocks (24 hours) and there are 2 permanent forks longer than N, nodes from one branch could delete their local history so they would join the other branch.

Regards,


________________________________
From: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>
Sent: Wednesday, July 31, 2019 15:59
To: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:

> I would like to propose that a "moving checkpoint" is added to the Bitcoin
> protocol. It's a very simple rule already implemented in NXT coin:
>
> - A node will ignore any new block under nodeBlockHeight - N, so the
> blockchain becomes truly immutable after N blocks, even during a 51% attack
> which thanks to the moving checkpoint can't rewrite history older than the
> last N blocks.

How would a (potentially, state-sponsored) netsplit lasting longer than N be
handled?
--
Alistair Mann

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190803/8720e865/attachment.html>

From tensiam at hotmail.com  Sat Aug  3 10:35:51 2019
From: tensiam at hotmail.com (Kenshiro [])
Date: Sat, 3 Aug 2019 10:35:51 +0000
Subject: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol
In-Reply-To: <PS2P216MB0179F9419B116F333EBF10799DD80@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <DB6PR10MB1832329BC8D151DC18F1E6CEA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<28454621.Lge63Ifvux@dprfs-d5766>
	<DB6PR10MB1832F1E966CD83BC662985BDA6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>
	<DB6PR10MB183271245AAE84FB9AC96474A6DF0@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>,
	<CAEM=y+UCdW2__nmQhWuL2FYvL6WKdBsF31WDFZUSdXPvgM2bvg@mail.gmail.com>,
	<DB6PR10MB1832110D67FB7FBD1AF5E3EDA6D90@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>,
	<PS2P216MB0179F9419B116F333EBF10799DD80@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <DB6PR10MB18326F80886EFE159176893DA6D80@DB6PR10MB1832.EURPRD10.PROD.OUTLOOK.COM>

Good point, for the moving checkpoint a number of blocks (or maybe a timestamp) could be enough, but for the block limit of X blocks to decide if the moving checkpoint is ignored or not, as we have to compare two chains (main chain and fork) maybe is much better to measure the blockchain lengths as numberOfBlocks * averageBlockDifficulty, so if a difficulty adjustment happens in that time interval, it's taken into account.

Regards

________________________________
From: LORD HIS EXCELLENCY JAMES HRMH <willtech at live.com.au>
Sent: Saturday, August 3, 2019 2:51
To: Ethan Heilman <eth3rs at gmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>; Kenshiro [] <tensiam at hotmail.com>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

I have but one point to make in a brief catch-up read over.

With the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:

It is not to be considered the longest chain, it is to be considered the longest chain with the most proof of work.

Regards,
LORD HIS EXCELLENCY JAMES HRMH
<https://earn.com/willtech>


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Friday, 2 August 2019 11:08 PM
To: Ethan Heilman <eth3rs at gmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

Hi all,

Very good points. I did some clarifications in a private conversation, the new rule is making the moving checkpoint valid only if the difference in blocks between the main chain and the new fork is smaller than X blocks, like for example 3 days of blocks, so after a long network split everyone can finally follow the longest chain:

With the current protocol the fix to a network split is simple, the longest chain win. But with the moving checkpoint I'm proposing we have a problem if both chains began to differ more than N blocks ago, the forks are permanent. So we need an additional rule to ignore the moving checkpoint, a limit of X blocks:

If a node sees a fork longer than his main chain, and the fork has at least X blocks more than the main chain, then the node ignore the moving checkpoint rule, and it follows the fork, the longest chain.

So as an example, the moving checkpoint could be 24 hours of blocks, and the limit of X blocks, the blocks of 3 days.

So we have 2 possible situations to consider:

- 51% attack:  the blocks older than 24 hours are protected against a history rewrite during at least 3 days, in that time developers could release an emergency release with another mining algorithm to stop the attack.

- Network split: if the network split is older than N blocks, we have 2 permanent forks (or chains), but in 3 days (or more) the blockchain heights will differ in more than X blocks (the blocks of 3 days) because there will be more miners in one chain than in the other so finally the loser chain will be abandoned and everyone will follow the longest chain.

It could be even more conservative, like 48 hours for the moving checkpoint and a block limit of 7 days of blocks.

Regards,



________________________________
From: Ethan Heilman <eth3rs at gmail.com>
Sent: Friday, August 2, 2019 14:19
To: Kenshiro [] <tensiam at hotmail.com>; Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>
Cc: Alistair Mann <al at pectw.net>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

Attack 1:
I partition (i.e. eclipse) a bunch of nodes from the network this partition contains no mining power . I then mine 145 blocks for this partition. I don't even need 51% of the mining power because I'm not competing with any other miners. Under this rule this partition will hardfork from the network permanently. Under current rules this partition will be able to rejoin the network as the least weight chain will be orphaned.

Attack 2:
I pre-mine 145 blocks. A node goes offline for 24 hours, when it rejoins I feed it 145 blocks which fork off from the consensus chain. I have 24+24 hours to mine these 145 blocks so I should be able to do this with 25% of the current hash rate at the time the node went offline. Under your rule each of these offline-->online nodes I attack this way will hardfork themselves from the rest of the network.

I believe a moving-checkpoint rule as describe above would make Bitcoin more vulnerable to 51% attacks.

A safer rule would be if a node detects a fork with both sides of the split having  length > 144 blocks, it halts and requests user intervention to determine which chain to follow.  I don't think 144 blocks is a great number to use here as 24 hours is very short. I suspect you could improve the security of the rule by making the number of blocks a fork most reach to halt the network proportional to the difference in time between the timestamp in the block prior to the fork and the current time. I am **NOT** proposing Bitcoin adopt such a rule.

NXT has a fundamentally different security model as it uses Proof-of-stake rather than Proof-of-Work.

On Wed, Jul 31, 2019 at 2:37 PM Kenshiro [] via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
P.S.: To be clearer, in this example I set an N value of 144 blocks, which is approximately 24 hours.

________________________________
From: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>
Sent: Wednesday, July 31, 2019 16:40
To: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

>>> How would a (potentially, state-sponsored) netsplit lasting longer than N be
handled?

It would be detected by the community much before reaching the reorg limit of N blocks (it's 24 hours) so nodes could stop until the netsplit is fixed.

In the extreme case no one notice the network split during more than N blocks (24 hours) and there are 2 permanent forks longer than N, nodes from one branch could delete their local history so they would join the other branch.

Regards,


________________________________
From: Alistair Mann <al at pectw.net<mailto:al at pectw.net>>
Sent: Wednesday, July 31, 2019 15:59
To: Kenshiro [] <tensiam at hotmail.com<mailto:tensiam at hotmail.com>>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Subject: Re: [bitcoin-dev] Add a moving checkpoint to the Bitcoin protocol

On Wednesday 31 Jul 2019 12:28:58 Kenshiro [] via bitcoin-dev wrote:

> I would like to propose that a "moving checkpoint" is added to the Bitcoin
> protocol. It's a very simple rule already implemented in NXT coin:
>
> - A node will ignore any new block under nodeBlockHeight - N, so the
> blockchain becomes truly immutable after N blocks, even during a 51% attack
> which thanks to the moving checkpoint can't rewrite history older than the
> last N blocks.

How would a (potentially, state-sponsored) netsplit lasting longer than N be
handled?
--
Alistair Mann

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190803/954f387d/attachment-0001.html>

From junderwood at bitcoinbank.co.jp  Sun Aug  4 00:15:17 2019
From: junderwood at bitcoinbank.co.jp (Jonathan Underwood)
Date: Sun, 4 Aug 2019 09:15:17 +0900
Subject: [bitcoin-dev] Proposed Extensions to BIP 174 for Future
	Extensibility
In-Reply-To: <20190802141836.15771ad6@simplexum.com>
References: <mailman.437.1564598007.27056.bitcoin-dev@lists.linuxfoundation.org>
	<CACL8y1tOn_U2YjpzGuRebv=2=tvaEYwR2yMCK_4girJ4WtZ1Ug@mail.gmail.com>
	<I3Yq3q73tNvEF-Ubis-0A_OPB84-NdRMLUMmMPnQMEazrWw3Q25yGNHVUt5nMOtdD3ISlJj3efNJaLwQjTsvQI1ToF7stRabWo1SYiZjg9U=@achow101.com>
	<YgIGlecoK1dbkfdP7mhW_qtJfGfamClPl_0ALhGovnXTPfcQlQDqAiMgeUvSIUVfzblz8oh4zix90pxIj0j3ppvQxDOpCJztJ62vvXn1yO4=@achow101.com>
	<20190802141836.15771ad6@simplexum.com>
Message-ID: <CAMpN3mJy4TF+ayWV7aXWFwzeQUdrvX5zKsYi4k+dCEp89ZPH0w@mail.gmail.com>

My two cents:

1. Reserved types are awesome.
2. Varint for type is awesome.
3. BIP174 should specify a specific type for all (global, input, and
output) which means "see the BIP numbered in the next byte" so we can have
some sort of BIP43-ish system for BIP174... POR COMMITMENT and my current
signature protocol proposal should go in there.

More like three cents, but you get the idea.

I'll keep an eye on the bips repo. If someone wants to ping me once things
settle down I'll implement it.

Thanks,
Jon

2019?8?2?(?) 20:34 Dmitry Petukhov via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> ? Thu, 01 Aug 2019 19:01:06 +0000
> Andrew Chow <achow101-lists at achow101.com> wrote:
>
> > I spoke to some people OOB and they said that they didn't really like
> > the idea of having a prefix string (partially because they've already
> > implemented some proprietary types by simply squatting on unused
> > types). Matching the prefix string adds additional complexity to the
> > parser code.
>
> I do not oppose the idea of "{0xFC}|{private_type}" strongly, but I
> would like to note that for those who do not want to deal with
> additional complexity of handling a prefixed string, they can simply
> not use it at all. Since this is a private construction, and their
> private format specifies 'no prefix', they can just ignore everything
> that does not start with "{0xFC}|{0x00}", thus any further complexity
> regarding the prefix is also ignored. The only added complexity is one
> condition check: second_byte_of_the_key != 0
>
> My other argument for conflict-avoidance prefix as a first thing after
> 0xFC is that the set of future users of PSBT and private types is
> most likely much larger than the current set of those who already
> implemented proprietary types on their own, and thus the overall benefit
> for the whole industry will likely be bigger when 'i do not want
> conflict avoidance' decision have to be explicit, by setting the prefix
> to 0x00, and the set of possible conflicting types are limited only to
> those entities that made this explicit decision.
>
> Regarding the 'squatted' types, it seems to me that this only matters
> in the discussed context if they squatted on 0xFC type in particular.
> In other cases, they will need to implement changes anyway, to be
> compatible with the BIP. Maybe they could consider that one additional
> condition check is a small burden, and maybe they can tolerate that,
> for the benefit of reducing possibility of interoperability problems
> between other future PSBT/private types implementors.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
-----------------
Jonathan Underwood
??????? ??????????????
-----------------

???????????????????????????????

??: 0xCE5EA9476DE7D3E45EBC3FDAD998682F3590FEA3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190804/52748714/attachment.html>

From belcher at riseup.net  Mon Aug  5 19:04:26 2019
From: belcher at riseup.net (Chris Belcher)
Date: Mon, 5 Aug 2019 20:04:26 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <20190802145057.7b81c597@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
Message-ID: <ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>

On 02/08/2019 10:50, Dmitry Petukhov wrote:
> ? Fri, 2 Aug 2019 10:21:57 +0100
> Chris Belcher <belcher at riseup.net> wrote:
> 
>> The aim of the fidelity bond scheme is to require makers
>> to sacrifice value, renting out their fidelity bond coins doesn't
>> avoid that sacrifice because the sacrifice is the paid rent
> 
> But if the entity that rented the coins, makes a profit using this coins
> from the maker opertion, and it makes the same or higher amount than
> it paid in rent, is it a sacrifice ? Given that the aim was to not make
> a profit in the first place, just increase deanonymization
> capabilities ?

Yes you're right. I should correct myself: Running a maker under the
proposal doesn't require a sacrifice of value, in fact you actually make
money doing it.

However, there _is_ a cost to being a sybil attacker. If we define
honest makers as entities who run just one maker bot, and dishonest
makers as entities who run multiple maker bots, then we can say that
running a dishonest maker operation requires a sacrifice of fee income,
because someone doing that would earn more money if they ran an honest
maker instead. This happens because of the quadratic V^2 term in the
formula calculating the fidelity bond value, which provides this
incentive for lumping together fidelity bonds. This V^2 is probably the
most important part for privacy.

The V^2 term also creates a bad incentive where multiple people might
choose to pool together their bitcoin hoard into one maker bot so that
each can earn a higher fee income. This can be done by renting out TXOs
signatures as you've said.

So what's needed is a way to make renting out TXOs impossible or very
difficult. We can note that fidelity bonds made of rented TXOs will be
made up of a large number of relatively small valued TXOs, so one
amelioration is to cap the number of TXOs that can be used in one
fidelity bond. This could be worked around by honest makers because they
can consolidate TXOs on the blockchain, which rented TXO owners can't do
because the TXOs are owned by different people.

Another way is to require the bond signature proofs to involve the
one-time taker identifier, and so be different every time. This
basically requires fidelity bond privkeys to be online in hot wallets,
and so should massively increase the difficulty of renting TXOs because
the maker and the TXO owner need to be in constant real-time communication.

Thoughts?

CB

From praveen.baratam at gmail.com  Mon Aug  5 15:36:49 2019
From: praveen.baratam at gmail.com (Praveen Baratam)
Date: Mon, 5 Aug 2019 21:06:49 +0530
Subject: [bitcoin-dev] CoinVault - Secure Cryptocurrency Exchange -
	Technology Overview
Message-ID: <CAAQs3wtbh5sVvTCa6qnLYs_ATT_oHS_JdOFkwnx7anhQ7czh-A@mail.gmail.com>

Hello Devs,

I am Praveen and I am the inventor of CoinVault, a new second layer
protocol and technology that makes Bitcoin and other similar altcoins
`Unstealable
and Unlosable` for all practical purposes. Tall claim, but I will get to
the details in a bit.

Before that, here is a little context to set the perspective?

I was introduced to Bitcoin by a friend in 2017 and realized how late I was
to the party.

Bitcoin Cash's block size debate was a hot topic then and so were many
hacks and heists affecting various cryptocurrency exchanges across the
world.

I personally did not like the idea of increasing block size to accommodate
more transactions and also thought that Cold Storage and Multi-Sig security
for Hot Wallets (BitGo) is just the beginning.

We thought micro and high frequency transactions should ideally be handled
by intermediaries who settle balances periodically, while larger
transactions and settlements happen directly on Blockchain. Even if
Lightning Network handles all micro-transactions, we cannot completely rule
out all intermediaries and we still need exchanges, etc. to interface with
the offline world. This felt like a healthy compromise while preserving the
spirit of Bitcoin.

But given the security requirements and concerns surrounding Bitcoin and
other cryptocurrencies, any kind of pooling in the hands of any
intermediary such as an exchange, wallet, escrow, etc., makes it a hot
target for hackers.

To mitigate this problem, me and my fellow compatriots set out to create a
safer way to store cryptocurrencies both for individuals and enterprises.

After nearly two years of brainstorming and toiling we have come up with
CoinVault, a second layer technology, that can ensure the safety and
security of Bitcoin and other cryptocurrencies for both large and small
entities.

Below is an overview of CoinVault technology specifically adopted to secure
Cryptocurrency Exchanges and Wallets. Please find the figures referred to
in the below text in the PDF attached. The complete draft is also attached
as a PDF if you prefer printing and reading it. A video overview
<https://www.youtube.com/watch?v=yDvLqTv1FDg> is also attached for those
who prefer a video over text.

Any and every feedback will help us iterate and serve the ecosystem better.
We are all ears for your comments and suggestions.



-----------------~~~~~~~~~~~~~~~-----------------


Secure Cryptocurrency Exchange & Wallet

Dr. Praveen Baratam

Background:

Cryptocurrencies in general are both acquired and traded on an electronic
exchange that lists different cryptocurrencies/crypto-assets often with
other assets such as fiat currencies issued by central banks of various
countries and enables trading between them. Most of these exchanges are
custodial in nature and act as trusted third parties where trading parties
transfer both cryptocurrencies and other assets in their control/possession
to the exchange controlled addresses/accounts and get notional limits on
the exchange to trade. All this works well as long as there is no security
breach on the exchange.

Since most cryptocurrencies are secured by public-key encryption which is
knowledge based, any security breach on the exchange?s systems can be
disastrous. And any adversary gaining access to exchange?s private-keys can
irreversibly steal the cryptocurrencies in its custody leading to huge loss
of wealth for trading parties and loss of trust within the ecosystem. We
have seen this scenario playout with many cryptocurrency exchanges all over
the world at some point or the other and approximately 15 Billion USD worth
cryptocurrencies were stolen from them as of Dec 2017. This has become the
Achilles heel of the cryptocurrency world off late.

Over time cryptocurrency exchanges have evolved several strategies such as
Hot-Wallets coupled with Cold/Offline Storage, Multi-Signature arrangements
with third-parties that serve as gatekeepers to enforce limits on
transactions, insurance for hot funds, etc. But most of these strategies
have proved inadequate and/or were circumvented over the past few years by
increasingly sophisticated attacks. eg: BitFinex lost $71 Million USD worth
of Bitcoin in spite of Multi-Signature arrangements with BitGo.

The same is true for Custodial Cryptocurrency Wallet Services, hereafter
referred to as Cryptocurrency Wallets, that store users? funds/tokens with
them and allow their users to make transactions like a bank. They then
settle these transactions on their users? behalf. Most Cryptocurrency
Exchanges also double up as Cryptocurrency Wallets for their users allowing
transacting parties to pay/accept in cryptocurrencies/assets of their
choice and managing the conversion for them when necessary.

There is an urgent need for securing cryptocurrency exchanges and wallets
to prevent further losses and bolster general faith in the cryptocurrency
ecosystem.

Solution:

The following describes an arrangement and method, in its simplest form,
between two parties (First Party and Second Party where the Second Party is
acting as Secure Cryptocurrency Exchange and/or Wallet for the First Party)
participating in a cryptocurrency network/system to effectively reduce the
probability of loss or theft of the First Party?s funds/tokens while
guaranteeing settlement between trading/transacting parties by the Second
Party. Hereafter, the term Cryptocurrency Exchange, shall also imply
Cryptocurrency Wallet wherever relevant.

The method presumes that unrecoverable hardware wallets (or rendered
unrecoverable by not-recording / discarding the backup/seed) without any
provision for recovery of the private-keys/secrets stored inside it in case
of loss or malfunction of the device, hereafter referred to as hardware
tokens, and time-locks for transaction outputs are available for the
crypto-currency system of interest. Relative time-locks
(CheckSequenceVerify) similar to the one described in Bitcoin Improvement
Proposal 112 are more desirable than absolute time-locks
(CheckLockTimeVerify) similar to the one described in Bitcoin Improvement
Proposal 65. The subsequent discussion assumes relative time-locks are
available for the cryptocurrency of interest even though similar
functionality can be devised using absolute time-locks too.

The method and arrangement proceeds as follows:


   1.

   At inception, the First Party creates a transaction similar to the one
   depicted in Figure 1, hereafter called the Deposit Transaction, in which
   the First Party transfers an arbitrary sum of funds/tokens in its control
   to a multi-signature address but does not yet sign or broadcast it. The
   multi-signature address in the Deposit Transaction requires the following
   signatures to authenticate and spend/transfer from it:

   1.

      First Party?s Private Key generated Signature
      2.

      First Party?s Hardware Token generated Signature
      3.

      Second Party?s Private Key generated Signature

      2.

   Then, the First Party creates a second transaction, hereafter referred
   to as Provisional Transaction, as depicted in Figure 2, spending all the
   funds/tokens sent to the multi-signature address in the Deposit
   Transaction, and sends a copy of the Provisional Transaction without any
   signed inputs or signatures, to the Second Party. Please note that the
   Provisional transaction is spending from an unconfirmed Deposit Transaction.

   3.

   Then, the Second Party adds its  Private Key generated signature to the
   unsigned Provisional Transaction received from the First Party and then
   sends the partially signed Provisional Transaction back to the First Party.

   4.

   In the meantime, the First Party also adds its Private Key generated
   signature and the signature generated by the hardware token in its
   possession to the unsigned copy of the Provisional Transaction it created
   and sends the partially signed Provisional Transaction to the Second Party.

   Note: The signatures used in this scheme sign the transaction similar to
   SIGHASH_ALL or SIGHASH_SINGLE in BitCoin protocol where the corresponding
   output of the transaction cannot be modified once signed.

   5.

   At this point in time, the First Party is in possession of the partially
   signed Provisional Transaction with Second Party?s Private Key generated
   signature added to it and the Second Party is in possession of the
   partially signed Provisional Transaction with First Party?s Private Key
   generated signature and the signature generated by the hardware token in
   First Party?s possession added to it.

   6.

   Then, the First Party signs and broadcasts the Deposit Transaction it
   created to the cryptocurrency network/system completing the setup process.
   The whole process in outlined in Figure 3.

   7.

   Once the Deposit Transaction is confirmed, both First Party and Second
   Party start monitoring the Cryptocurrency network directly and/or using
   third party services for transactions referencing the Multi-Signature
   output address described above from the Deposit Transaction to detect any
   breach of security or foul play.

   8.

   Subsequently, the First Party, at its discretion, can add its Private
   Key generated signature and the signature generated by the hardware token
   in its possession to the partially signed Provisional Transaction with the
   Second Party?s Private Key generated signature and broadcast the fully
   signed Provisional Transaction to the cryptocurrency network/system when
   necessary.

   9.

   Similarly, the Second Party can add its Private Key generated signature
   to the partially signed Provisional Transaction with the First Party?s
   Private Key generated signature and the signature generated by the hardware
   token in possession of the First Party and broadcast the fully signed
   Provisional Transaction to the cryptocurrency network/system when necessary.

   10.

   To sum it up, either parties can add missing signatures to the partially
   signed Provisional Transaction in their possession and broadcast them when
   necessary.

   11.

   As soon as the Provisional Transaction is broadcasted, the
   cryptocurrency monitoring systems prompt both parties to initiate recovery
   if it is not broadcasted by them to begin with. Either ways First Party or
   the Second Party in coordination with the other or optionally unilaterally
   create and broadcast a transaction using the respective options of the
   Provisional Transaction transferring the funds/tokens to a desired address
   terminating the arrangement.


Description

Cryptocurrency Exchanges act as custodial escrow agents for the trading
entities participating on their platforms to minimize counter party risk
and guarantee settlement. However, this escrow mechanism, with respect to
cryptocurrencies, creates a new problem of keeping third party funds/tokens
in their custody safe and secure. A security breach on the respective
Cryptocurrency Exchanges? systems can compromise the private-keys securing
the funds in its custody and lead to loss/theft of respective funds/tokens.

In the proposed scheme/arrangement a Cryptocurrency Exchange can enforce
settlement albeit with a predefined delay and does not need exclusive
custody of the said funds/tokens beforehand to guarantee settlement.
Moreover, in the event of a security breach on one or both sides, there are
remedial steps that the Cryptocurrency Exchange and/or First Party can take
to prevent loss or theft of respective funds/tokens.

Generally, First Party will cooperate with Second Party in the settlement
process and in situations where it disagrees or refuses to cooperate, the
Cryptocurrency Exchange (Second Party) can get exclusive custody of the
respective funds/tokens and enforce settlements as per the terms of the
contractual service agreement with the First Party.

For instance, when the First Party is in disagreement with a proposed
settlement for a trade, the Cryptocurrency Exchange (Second Party) can use
the Option 2 as depicted in Figure 2 and take exclusive custody of the
respective funds/tokens to enforce settlement. This option allows the
Cryptocurrency Exchange to function as a regular custodial escrow between
trading parties as is the case with most exchanges and in general.

In another instance, if a Cryptocurrency Exchange suffers a security breach
and its private-keys are compromised/stolen, it can use Option 1, 2, 3, 7
or 8 depicted in Figure 2 to transfer the funds/tokens to another secure
address or back to the First Party as may be desired. Cryptocurrency
Exchanges can even prevent loss/theft using Option 7 depicted in Figure 2
and transfer the respective funds/tokens away from the compromised address
even when its hardware tokens are lost/stolen in the above described
situation.

Also, the Cryptocurrency Exchange (Second Party) can use Option 2 depicted
in Figure 2 and transfer the respective funds/tokens to a secure address
when First Party?s private-key and/or hardware token are
compromised/lost/stolen.

The Confusion Matrix in Figure 4 enumerates the options available and
outcomes of situations where private-keys and/or hardware tokens of First
Party and/or Second Party are compromised or stolen. It also enumerates
situations where respective private-keys are lost by First Party but not
Second Party.

Since Second Party is an organized entity that can employ data-safety
measures such as multi-site replication, offline storage, etc. this method
does not explicitly specify the process and enumerate options available
when Second Party?s private-keys are lost for simplicity and brevity. This
method can be analogously extended to this scenario and more or simplified
if desired by reordering,adding or removing options in the Provisional
Transaction accordingly when planning and accounting for certain
contingencies are deemed necessary or unnecessary. Also the timelocks
mentioned in the Provisional Transaction are one of the many possible
values for them exemplifying a particular order and can be adjusted as
necessary to suit a particular arrangement.

It should be noted here that the Second Party always gets first claim on
the respective funds/tokens as it is accepting a liability on First Party?s
behalf and can steal First Party?s funds/tokens but will not do so because
such unilateral actions will result in loss of trust/business from other
parties as well as legal proceedings by the First Party. Hence, the
incentive and motive to cheat the First Party of its funds/tokens by Second
Party is non-existent. But if First Party and/or Second Party are
compromised either by an internal or external adversary, they still have
recourse and can reconcile the situation by taking remedial steps available.

Finally, even if Hardware Tokens are not available and we have to rely on
relative/absolute timelocks only, the method and scheme described above can
be scaled down as depicted in Figure 5 and still offer better protection
than currently practiced multi-signature arrangements.


https://www.youtube.com/watch?v=yDvLqTv1FDg


?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190805/9c44b218/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: Figures - CoinVault - Secure Cryptocurrency Exchange.pdf
Type: application/pdf
Size: 915042 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190805/9c44b218/attachment-0002.pdf>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: CoinVault - Secure Cryptocurrency Exchange.pdf
Type: application/pdf
Size: 985589 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190805/9c44b218/attachment-0003.pdf>

From leo at LeoWandersleb.de  Tue Aug  6 01:51:02 2019
From: leo at LeoWandersleb.de (Leo Wandersleb)
Date: Tue, 6 Aug 2019 13:51:02 +1200
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
Message-ID: <3a9a9277-130d-fbb2-fa51-6119a2242812@LeoWandersleb.de>

On 8/6/19 7:04 AM, Chris Belcher via bitcoin-dev wrote:
> However, there _is_ a cost to being a sybil attacker. If we define
> honest makers as entities who run just one maker bot, and dishonest
> makers as entities who run multiple maker bots, then we can say that
> running a dishonest maker operation requires a sacrifice of fee income,
> because someone doing that would earn more money if they ran an honest
> maker instead. This happens because of the quadratic V^2 term in the
> formula calculating the fidelity bond value, which provides this
> incentive for lumping together fidelity bonds. This V^2 is probably the
> most important part for privacy.

As established above, there will emerge a market to lock coins, so these locks
will be readily available without having to buy them. Even with V^2 there is no
reason to amass more coins beyond a certain point. Running the biggest 5 V^2
scores should be pretty solid to get in on many coin joins.

> Another way is to require the bond signature proofs to involve the
> one-time taker identifier, and so be different every time. This
> basically requires fidelity bond privkeys to be online in hot wallets,
> and so should massively increase the difficulty of renting TXOs because
> the maker and the TXO owner need to be in constant real-time communication.

Requiring the bond to reside on a hot wallet would be a massive disadvantage.

No matter how you look at the whole problem of sibyl attacks, the honest maker
will have operational costs and gain fees and the sibyl attacker will have the
same plus profit from the deanonymization. As long as makers hunt marginal
profits, the sibyl attacker having the higher margin from deanonymization will
always win. The fidelity bonds would make this even worse, as increased
complexity and entry cost would not favor more makers but less even before the
centralization incentive mentioned above (V^2). To say that old holders have
bitcoins laying around that they can use for such bonds is a fallacy as they
could just as well rent them out on a bonds market.

How about turning this upside down and shift the incentives from being taker to
being maker by introducing a mandatory fee? If each join costs 1% per maker,
people would initially gasp and reject to update to that version but those who
do, will do to become makers, increasing the maker count massively and
eventually most people in frequent need of joining will also become makers to
offset the costs of being takers.

With these changed rules again the sibyl attackers would still have their
competitive edge and would flood the market with even more cheap offers but now
everybody would have an incentive to do the same and as makers have to have the
UTXOs, it's not free to sibyl attack already.

LW

From ZmnSCPxj at protonmail.com  Tue Aug  6 02:54:14 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 06 Aug 2019 02:54:14 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
Message-ID: <vwdvU8vMocIk6rEm5jdlRa9G_0dsDyNjURYYxin6HcjDddDFv8IyOQcxNvnGn6ywFLVWkVb7VvP-qcboH1EX8f_t85sbyuCzT6DbXhj5if0=@protonmail.com>

Good morning Chris,


> This could be worked around by honest makers because they
> can consolidate TXOs on the blockchain, which rented TXO owners can't do
> because the TXOs are owned by different people.

Would it not be possible the below?

* I rent some funds from Dmitry.
  I agree to pay him 0.5 BTC for this service of putting up 50BTC from Dmitry UTXO.
* I also own 50BTC myself in a separate UTXO.
* We create a funding transaction paying out to a Schnorr MuSig output that is 2-of-2 between us.
  This spends Dmitry UTXO 50 BTC and my UTXO 50BTC.
  We only create this yet and do not sign.
* We create a backout transaction, probably with `nLockTime`, paying out 50.5BTC to Dmitry and 49.5BTC to me.
  This spends the funding transaction.
  We sign this using MuSig.
* After we exchange the signatures of the backout transaction, we exchange signatures for the funding transaction.
* Now we have a common 100BTC UTXO (indistinguishable from other Schnorr single-sig UTXOs) that can be used as fidelity bond for me.
  This is the output of the funding transaction.

The above can be scaled up so I can rent arbitrary amounts of coin from many different people, who are assured of getting their funds back, in exchange for a fidelity bond / advertisement, and thus greatly destroying the properties of the V^2 tweak.

(The ability to have shared ownership of UTXOs is a powerful feature of Bitcoin, and backs its ability to scale, as witnessed with Lightning Network and channel factories.)

Regards,
ZmnSCPxj

From belcher at riseup.net  Tue Aug  6 10:27:17 2019
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 6 Aug 2019 11:27:17 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <3a9a9277-130d-fbb2-fa51-6119a2242812@LeoWandersleb.de>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<3a9a9277-130d-fbb2-fa51-6119a2242812@LeoWandersleb.de>
Message-ID: <7a42fc7c-2e89-deae-12d6-8f7f5a46b915@riseup.net>

On 06/08/2019 02:51, Leo Wandersleb via bitcoin-dev wrote:
> On 8/6/19 7:04 AM, Chris Belcher via bitcoin-dev wrote:
>> However, there _is_ a cost to being a sybil attacker. If we define
>> honest makers as entities who run just one maker bot, and dishonest
>> makers as entities who run multiple maker bots, then we can say that
>> running a dishonest maker operation requires a sacrifice of fee income,
>> because someone doing that would earn more money if they ran an honest
>> maker instead. This happens because of the quadratic V^2 term in the
>> formula calculating the fidelity bond value, which provides this
>> incentive for lumping together fidelity bonds. This V^2 is probably the
>> most important part for privacy.
> 
> As established above, there will emerge a market to lock coins, so these locks
> will be readily available without having to buy them. Even with V^2 there is no
> reason to amass more coins beyond a certain point. Running the biggest 5 V^2
> scores should be pretty solid to get in on many coin joins.

We can be much more exact than saying makers get in on "many" coins. The
supporting document "Financial mathematics of JoinMarket fidelity bonds"
contains calculations for exactly this:
https://gist.github.com/chris-belcher/87ebbcbb639686057a389acb9ab3e25b#sybil-attacks-from-enemies-within

The document finds that with realistic real-world data, the makers with
the top 5 most valuable bonds will be chosen 48% of the time. So
approximately half:half success for one coinjoin. This isn't enough to
deanonymize every single coinjoin. For example, the tumbler script by
default makes around 16 transactions so the odds of a successful sybil
attack is (0.48)^16 = 8 parts per million, with the success probability
reducing exponentially after each additional coinjoin.

>> Another way is to require the bond signature proofs to involve the
>> one-time taker identifier, and so be different every time. This
>> basically requires fidelity bond privkeys to be online in hot wallets,
>> and so should massively increase the difficulty of renting TXOs because
>> the maker and the TXO owner need to be in constant real-time communication.
> 
> Requiring the bond to reside on a hot wallet would be a massive disadvantage.

Hopefully it won't come to that and we can invent some other way to stop
renting TXOs. But if that's the only way then we'd have to code it in
order to protect the interests of takers.

The most dangerous source of rented TXOs seems to be the coin age form
of fidelity bond. Hodlers could have coins already in a hardware wallet
or cold storage and just sign proofs renting their UTXOs to earn an
extra income without changing their setup at all. Bonds from OP_CLTV and
OP_RETURN burned coins seems to me a much less likely source of rented TXOs.

Because of that, it seems to me only coin age fidelity bonds would be
required to be on hot wallets.

Another option worth considering is the have a separate lower interest
rate for coin age bonds compared to OP_CLTV bonds, this would reflect
the lower sacrifice for coin age (past sacrifices must be worth less
than future sacrifices, because of risk and uncertainty of the unknown
future, as well as the risk of rented UTXOs)

> No matter how you look at the whole problem of sibyl attacks, the honest maker
> will have operational costs and gain fees and the sibyl attacker will have the
> same plus profit from the deanonymization. As long as makers hunt marginal
> profits, the sibyl attacker having the higher margin from deanonymization will
> always win. The fidelity bonds would make this even worse, as increased
> complexity and entry cost would not favor more makers but less even before the
> centralization incentive mentioned above (V^2). To say that old holders have
> bitcoins laying around that they can use for such bonds is a fallacy as they
> could just as well rent them out on a bonds market.

I think this is absolutely wrong, because sybil attackers give up some
fee income. Here is a worked example:

Let's say the sybil attacker is operating the top 5 most valuable maker
bots. If this attacker has X coins they would split them equally into 5,
so each maker has X/5 coins and their bond is worth (X^5)^2 = X^2/25,
with a total of 5 bots the fee income would be proportional to 5*X^2/25
= X^2/5. However if an honest maker had X coins they could create a
single bond which would be worth simply X^2 with a fee income
proportional to X^2. So the honest maker has a fee income higher by a
factor of 5 than the sybil attacker. The sybil attacker must take a 5x
hit to their fee income in order to sybil attack. This is the crucial
effect of the V^2 term.

The V^2 term is important, it just has the downside of incentivizing
renting of coins. If we can make that impossible then the problem would
go away.

> How about turning this upside down and shift the incentives from being taker to
> being maker by introducing a mandatory fee? If each join costs 1% per maker,
> people would initially gasp and reject to update to that version but those who
> do, will do to become makers, increasing the maker count massively and
> eventually most people in frequent need of joining will also become makers to
> offset the costs of being takers.
> 
> With these changed rules again the sibyl attackers would still have their
> competitive edge and would flood the market with even more cheap offers but now
> everybody would have an incentive to do the same and as makers have to have the
> UTXOs, it's not free to sibyl attack already.
> 

Apart from the inability of developers to enforce any kind of price, I
don't think this scheme would fix the sybil attack problem, because a
sybil attacker still gets a higher gain (deanonymization + fees)
compared to honest makers (who earn just fees)


From niels.thijssen at improveqs.nl  Tue Aug  6 10:36:18 2019
From: niels.thijssen at improveqs.nl (Niels Thijssen)
Date: Tue, 6 Aug 2019 10:36:18 +0000
Subject: [bitcoin-dev] testing bitcoin nodes
Message-ID: <AM0PR07MB54748379B8B41BA5023F46CAE9D50@AM0PR07MB5474.eurprd07.prod.outlook.com>

Hi,

I'm working as (software) test specialist and run private a full bitcoin node (based upon Raspberry Pi 4).
I've been trying to figure out the tests performed during installation/upgrade/compilation of the software for the node.
Is there any overview on what's the (common) test approach, or other stuff. Because the tests on GitHub don't help me that much.
I'd like to figure out what/how is tested, maybe refine test cases, and try some manual test also, as part of learning.

Who would be able to join me or share information that guides me.
Thanks in advance,

Niels.



-------- Disclaimer --------
This email and any files transmitted may contain proprietary and confidential information of Improve Quality Services B.V. (?Improve QS?) and is intended only for the (use of the) named recipient(s) above. If you have received this message in error or are not the intended or named recipient(s) of this message, please immediately notify the sender by return and delete this email message from your computer. Any views or opinions presented are solely those of its author and do not necessarily represent those of Improve QS. You are hereby notified that unauthorized disclosure, use, dissemination, forwarding, printing or copying of this e-mail and its attachments either whole or partial of its contents is strictly prohibited. Improve QS cannot guarantee that email communications are secured and error-free and does not accept any liability for damages resulting from the use of email. The general terms and conditions of purchase respectively sale and delivery of Improve QS are applicable to all transactions and undertakings resulting therefrom.


From leo at LeoWandersleb.de  Tue Aug  6 13:07:19 2019
From: leo at LeoWandersleb.de (Leo Wandersleb)
Date: Wed, 7 Aug 2019 01:07:19 +1200
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <7a42fc7c-2e89-deae-12d6-8f7f5a46b915@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<3a9a9277-130d-fbb2-fa51-6119a2242812@LeoWandersleb.de>
	<7a42fc7c-2e89-deae-12d6-8f7f5a46b915@riseup.net>
Message-ID: <a6a37f82-ad73-f5a1-9376-a3815d484e57@LeoWandersleb.de>

On 8/6/19 10:27 PM, Chris Belcher via bitcoin-dev wrote:
> I think this is absolutely wrong, because sybil attackers give up some
> fee income. Here is a worked example:
>
> Let's say the sybil attacker is operating the top 5 most valuable maker
> bots. If this attacker has X coins they would split them equally into 5,
> so each maker has X/5 coins and their bond is worth (X^5)^2 = X^2/25,
> with a total of 5 bots the fee income would be proportional to 5*X^2/25
> = X^2/5. However if an honest maker had X coins they could create a
> single bond which would be worth simply X^2 with a fee income
> proportional to X^2. So the honest maker has a fee income higher by a
> factor of 5 than the sybil attacker. The sybil attacker must take a 5x
> hit to their fee income in order to sybil attack. This is the crucial
> effect of the V^2 term.
>
> The V^2 term is important, it just has the downside of incentivizing
> renting of coins. If we can make that impossible then the problem would
> go away.

To show how this argument is wrong, think about the market being split between
100 makers, each making 1% of the fees. By your argument, by colluding, they
could make far more than 100% of the fees.

Every cartel of makers pooling their bonds beating the odds can't be the goal.

And again, bonds are just a cost of business. If a $10/month in bonds (paid to a
guy to sign with his UTXOs or interest for BTCs lent or ...) leaves me with zero
fees, a $100/month with $1k in fees and $10k/month with $40k in fees, then there
might be a $1000/month barrier to entry for this market but there are enough
people with $10k available to enter the market and drive the fees (earned per
maker) down such that the barrier to entry increases even further. In the end,
only the holders of the 20 biggest bonds will get meaningful business and the
rest will lose their investment or just not bother being makers. And the sibyl
attackers again are the ones that put up the necessary funds with most ease of
them all.

From dp at simplexum.com  Tue Aug  6 20:55:41 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Wed, 7 Aug 2019 01:55:41 +0500
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
Message-ID: <20190807015541.3d8aa849@simplexum.com>

? Mon, 5 Aug 2019 20:04:26 +0100
Chris Belcher <belcher at riseup.net> wrote:

> So what's needed is a way to make renting out TXOs impossible or very
> difficult.

You can make renting the TXOs risky for the attacker. Make it so that
the entity that rented out the TXO can revoke the participation of said
TXO in the market, by publishing some special signature. That act of
revocation can also mean revocation of all other TXOs that were used in
a bond alongside it. This way, any entity that wants to spoil an
attacker's consolidation via rent, can rent out its TXO to the
attacker, and then revoke it, spoiling the whole package the attacker
have consolidated.

There may be other way to impose penalties.

For example, all locked TXO may be required to be spendable by *any*
key that controls any TXO in the 'bond TXO package'. I think this
should be possible with taproot - you will have to publish a taproot
trees for your locked TXOs (say, N of them), and the tree for each TXO
will have N leaves, each leaf will specify a condition "spendable by
the key N". This way, if I give you my TXO to include it in a bond by
locking it, you also need to make your other TXOs in a bond spendable
by me.

For both scenarios to work for the attacker, there's need to be an
off-chain contractual relationship between the parties. Otherwise the
entity that rents out the TXOs can spoil or just confiscate the bond of
the entity that rented them, without reprecussions.

From dp at simplexum.com  Tue Aug  6 21:37:42 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Wed, 7 Aug 2019 02:37:42 +0500
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <20190807015541.3d8aa849@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
Message-ID: <20190807023742.73750ba3@simplexum.com>

Unfortunately, both described schemes fail the same way as
'require TXOs to be consolidated by the owner', by the fact that with
muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in
[1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban
musig for the bonds' is not the answer, I believe.

[1]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html

? Wed, 7 Aug 2019 01:55:41 +0500
Dmitry Petukhov <dp at simplexum.com> wrote:

> ? Mon, 5 Aug 2019 20:04:26 +0100
> Chris Belcher <belcher at riseup.net> wrote:
> 
> > So what's needed is a way to make renting out TXOs impossible or
> > very difficult.  
> 
> You can make renting the TXOs risky for the attacker. Make it so that
> the entity that rented out the TXO can revoke the participation of
> said TXO in the market, by publishing some special signature. That
> act of revocation can also mean revocation of all other TXOs that
> were used in a bond alongside it. This way, any entity that wants to
> spoil an attacker's consolidation via rent, can rent out its TXO to
> the attacker, and then revoke it, spoiling the whole package the
> attacker have consolidated.
> 
> There may be other way to impose penalties.
> 
> For example, all locked TXO may be required to be spendable by *any*
> key that controls any TXO in the 'bond TXO package'. I think this
> should be possible with taproot - you will have to publish a taproot
> trees for your locked TXOs (say, N of them), and the tree for each TXO
> will have N leaves, each leaf will specify a condition "spendable by
> the key N". This way, if I give you my TXO to include it in a bond by
> locking it, you also need to make your other TXOs in a bond spendable
> by me.
> 
> For both scenarios to work for the attacker, there's need to be an
> off-chain contractual relationship between the parties. Otherwise the
> entity that rents out the TXOs can spoil or just confiscate the bond
> of the entity that rented them, without reprecussions.


From belcher at riseup.net  Wed Aug  7 09:38:43 2019
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 7 Aug 2019 10:38:43 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <j-MXLs8fEpx57ttA_3TbcaWXT_eGjpcFkFE-Yzy3aPrUhSmnSSwHS1zIuez4aoBp8VrIsGHL8sAWYc_vR_T6QgQXM4xCDrVVlv0uW9MIs5s=@protonmail.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<j-MXLs8fEpx57ttA_3TbcaWXT_eGjpcFkFE-Yzy3aPrUhSmnSSwHS1zIuez4aoBp8VrIsGHL8sAWYc_vR_T6QgQXM4xCDrVVlv0uW9MIs5s=@protonmail.com>
Message-ID: <113a68d9-6c8c-3bf2-b337-9b87c5fd1db7@riseup.net>

On 07/08/2019 00:33, ZmnSCPxj wrote:
> Good morning all,
> 
> It might be useful to remember that there exists pressure to pool proof-of-work due to tiny non-linearities caused by Proximity Premium and Variance Discount flaws.
> Similarly, any non-linearity in any fidelity bond scheme exerts the same pooling pressure.
> Deliberately increasing the non-linearity to V^2 worsens the pooling pressure, not lessens it.
> 
> (I wonder if instead going the opposite way and doing V^0.999 might work better; I have not figured all the implications of such a scheme and leave it to the reader.)
> 
>> Unfortunately, both described schemes fail the same way as
>> 'require TXOs to be consolidated by the owner', by the fact that with
>> muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in
>> [1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban
>> musig for the bonds' is not the answer, I believe.
> 
> If my understanding is correct, efforts to expand ECDSA to more than two-party n-of-n "true" multisignatures already are ongoing.
> 
> One might attempt to use transaction malleability as a protection, and require that transactions that put up bond TXOs should spend from at least one ***non***-SegWit output, so that the scheme as described fails (as the funding txid is malleable after-the-fact).
> 
> But the scheme as described only considers ways to securely aggregate *within* the Bitcoin universe.
> 
> I have recently learned of a spacce called the "real world", wherein apparently there exist things as "contract law".
> It seems to me this "contract law" is a half-baked implementation of Bitcoin cryptographic smart contracts.
> By what little I understand of this "contract law", it would be possible for an aggregator to accept some amount of money, with a promise to return that money in the future with some additional funds.
> If the aggregator fails to uphold its promise, then some (admittedly centralized) authority entity within the "real world" then imposes punishments (apparently inspired by similar mechanisms in Lightning Network) on the aggregator.
> Such arrangements (accepting some money now with a promise to return the money, plus some interest earned, in the future) apparently already exist in this "real world", under the name of "time deposits".
> 
> 
> Regards,
> ZmnSCPxj
> 

Good morning all,

Custodial solutions are much less worrying because they introduce so
much counterparty risk.

It's more risky to give bitcoins in custody than for fiat money because
there's no lender of last resort. People using JoinMarket in a
non-custodial way will always have a larger risk-adjusted return; The
return for running a JoinMarket yield generator isn't that big anyway to
start with. The non-custodial renting of TXO signatures is far more
worrying.

Also, as described in my other email
(https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017218.html
starting "
Let's say the sybil attacker...") the superlinear V^2 term is essential
to the resistance of the fidelity bond system to sybil attacks. All
things considered the consolidation of makers due to renting TXOs is not
as bad as sybil attacks. Consolidation of makers means that the
privacy-relevant information is shared amongst fewer people than
otherwise, but at least those people are independent (otherwise they'd
merge together). In a sybil attack the privacy-relevant information is
not shared at all, but entirely known by just one person which is much
worse.

CB

From belcher at riseup.net  Wed Aug  7 10:05:41 2019
From: belcher at riseup.net (Chris Belcher)
Date: Wed, 7 Aug 2019 11:05:41 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <20190807023742.73750ba3@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
Message-ID: <483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>

These are very creative schemes. At the very least they would stop the
easy mindless renting TXO method, where someone with coins on a hardware
wallet simply creates a signature and copypastes it into a website to
get free money. The workaround scheme with shared ownership of TXOs
requires brand new wallets to be created and hodlers must trust the
wallets enough to move their coins and hold them there for a long time.

Requiring fidelity bond TXOs to be held in hot wallets can also be
beaten as a scheme for stopping renting, because the rentee can put
their coin private keys on an always-on raspberry pi which is connected
to the maker's computer and constantly ready to give out signatures. The
coins would be in hot wallets yet still be rented out. As above the
raspberry pi setup would be much more of a hassle than copypasting a
signature into a website, so it could still be worth doing.

I wonder if there's a cryptographic way to prove that muSig and 2P-ECDSA
have not been used to create a certain pubkey/signature.

On 06/08/2019 22:37, Dmitry Petukhov wrote:
> Unfortunately, both described schemes fail the same way as
> 'require TXOs to be consolidated by the owner', by the fact that with
> muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in
> [1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban
> musig for the bonds' is not the answer, I believe.
> 
> [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html
> 
> ? Wed, 7 Aug 2019 01:55:41 +0500
> Dmitry Petukhov <dp at simplexum.com> wrote:
> 
>> ? Mon, 5 Aug 2019 20:04:26 +0100
>> Chris Belcher <belcher at riseup.net> wrote:
>>
>>> So what's needed is a way to make renting out TXOs impossible or
>>> very difficult.  
>>
>> You can make renting the TXOs risky for the attacker. Make it so that
>> the entity that rented out the TXO can revoke the participation of
>> said TXO in the market, by publishing some special signature. That
>> act of revocation can also mean revocation of all other TXOs that
>> were used in a bond alongside it. This way, any entity that wants to
>> spoil an attacker's consolidation via rent, can rent out its TXO to
>> the attacker, and then revoke it, spoiling the whole package the
>> attacker have consolidated.
>>
>> There may be other way to impose penalties.
>>
>> For example, all locked TXO may be required to be spendable by *any*
>> key that controls any TXO in the 'bond TXO package'. I think this
>> should be possible with taproot - you will have to publish a taproot
>> trees for your locked TXOs (say, N of them), and the tree for each TXO
>> will have N leaves, each leaf will specify a condition "spendable by
>> the key N". This way, if I give you my TXO to include it in a bond by
>> locking it, you also need to make your other TXOs in a bond spendable
>> by me.
>>
>> For both scenarios to work for the attacker, there's need to be an
>> off-chain contractual relationship between the parties. Otherwise the
>> entity that rents out the TXOs can spoil or just confiscate the bond
>> of the entity that rented them, without reprecussions.
> 
> 

From vitteaymeric at gmail.com  Wed Aug  7 10:54:10 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Wed, 7 Aug 2019 12:54:10 +0200
Subject: [bitcoin-dev] Fwd: Discover and move your coins by yourself
In-Reply-To: <e9b5743b-15af-56e5-9caf-0900b47e62b1@gmail.com>
References: <e9b5743b-15af-56e5-9caf-0900b47e62b1@gmail.com>
Message-ID: <93bdd23a-9a41-e531-76ad-e92ed571d587@gmail.com>

FYI Phase 3 is released https://github.com/Ayms/bitcoin-transactions,
features:

- create transactions

- decode transactions

- verify transactions

- convert/map addresses (including bech32)

- create/map wallets (bip32,39,44, etc), wallets recovery (missing/wrong
words) and check

- decode/create multisig redeem scripts

- pubkey/privkey mapping , conversion and formats

- sign/verify messages

Browserifying everything now for the end of the month



-------- Message transf?r? --------
Sujet?: 	Discover and move your coins by yourself
Date?: 	Fri, 12 Jul 2019 20:35:00 +0200
De?: 	Aymeric Vitte <vitteaymeric at gmail.com>
Pour?: 	Bitcoin Dev <bitcoin-dev at lists.linuxfoundation.org>




Please see https://github.com/Ayms/bitcoin-transactions this is a merge
of former bitcoin-transactions and bitcoin-wallets nodejs modules with
additional features to be implemented as described in the README

It is financed by NLnet via EU Horizon 2020 Next Generation Internet
Search and Discovery call

So the initial dev fees have been removed and the code is now open
source and provided in clear under a MIT license

The intent is to provide all the necessary tools for anybody to discover
and manage their coins, as well as making transactions by themselves,
without having to sync a full node or as an alternative to wallets when
people don't understand where their coins are (we saw quite a lot of
confusion for people not understanding at all how to find their coins
and to what keys their addresses did relate in case of multisig, segwit
and now bech32)

It's somewhere bitcoin-cli outside of bitcoin core more easy to use and
not restricted to its own wallet, available for any bitcoin based coins

At the end it will be a secure standalone offline js webapp inside
browsers (like https://peersm.com/wallet but the app does not reflect
the current state of the nodejs repo)

It's not a remake of iancoleman's tool but of course some features
overlap, as well as for other existing tools, we will also extend all of
this inside one tool with no limitations (for example some tools do not
accept "invalid" bip39 seeds, or bip32 seeds, etc)

Comments/suggestions welcome

PS: initially sent to bitcoin-discuss but the list seems to be dead

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/57f7489c/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Aug  6 23:33:19 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 06 Aug 2019 23:33:19 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <20190807023742.73750ba3@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
Message-ID: <j-MXLs8fEpx57ttA_3TbcaWXT_eGjpcFkFE-Yzy3aPrUhSmnSSwHS1zIuez4aoBp8VrIsGHL8sAWYc_vR_T6QgQXM4xCDrVVlv0uW9MIs5s=@protonmail.com>

Good morning all,

It might be useful to remember that there exists pressure to pool proof-of-work due to tiny non-linearities caused by Proximity Premium and Variance Discount flaws.
Similarly, any non-linearity in any fidelity bond scheme exerts the same pooling pressure.
Deliberately increasing the non-linearity to V^2 worsens the pooling pressure, not lessens it.

(I wonder if instead going the opposite way and doing V^0.999 might work better; I have not figured all the implications of such a scheme and leave it to the reader.)

> Unfortunately, both described schemes fail the same way as
> 'require TXOs to be consolidated by the owner', by the fact that with
> muSig, shared ownership of TXO is possible, as explained by ZmnSCPxj in
> [1]. 2P-ECDSA is also possible, just more complex, so just saying 'ban
> musig for the bonds' is not the answer, I believe.

If my understanding is correct, efforts to expand ECDSA to more than two-party n-of-n "true" multisignatures already are ongoing.

One might attempt to use transaction malleability as a protection, and require that transactions that put up bond TXOs should spend from at least one ***non***-SegWit output, so that the scheme as described fails (as the funding txid is malleable after-the-fact).

But the scheme as described only considers ways to securely aggregate *within* the Bitcoin universe.

I have recently learned of a spacce called the "real world", wherein apparently there exist things as "contract law".
It seems to me this "contract law" is a half-baked implementation of Bitcoin cryptographic smart contracts.
By what little I understand of this "contract law", it would be possible for an aggregator to accept some amount of money, with a promise to return that money in the future with some additional funds.
If the aggregator fails to uphold its promise, then some (admittedly centralized) authority entity within the "real world" then imposes punishments (apparently inspired by similar mechanisms in Lightning Network) on the aggregator.
Such arrangements (accepting some money now with a promise to return the money, plus some interest earned, in the future) apparently already exist in this "real world", under the name of "time deposits".


Regards,
ZmnSCPxj

>
> [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html
>
> ? Wed, 7 Aug 2019 01:55:41 +0500
> Dmitry Petukhov dp at simplexum.com wrote:
>
> > ? Mon, 5 Aug 2019 20:04:26 +0100
> > Chris Belcher belcher at riseup.net wrote:
> >
> > > So what's needed is a way to make renting out TXOs impossible or
> > > very difficult.
> >
> > You can make renting the TXOs risky for the attacker. Make it so that
> > the entity that rented out the TXO can revoke the participation of
> > said TXO in the market, by publishing some special signature. That
> > act of revocation can also mean revocation of all other TXOs that
> > were used in a bond alongside it. This way, any entity that wants to
> > spoil an attacker's consolidation via rent, can rent out its TXO to
> > the attacker, and then revoke it, spoiling the whole package the
> > attacker have consolidated.
> > There may be other way to impose penalties.
> > For example, all locked TXO may be required to be spendable by any
> > key that controls any TXO in the 'bond TXO package'. I think this
> > should be possible with taproot - you will have to publish a taproot
> > trees for your locked TXOs (say, N of them), and the tree for each TXO
> > will have N leaves, each leaf will specify a condition "spendable by
> > the key N". This way, if I give you my TXO to include it in a bond by
> > locking it, you also need to make your other TXOs in a bond spendable
> > by me.
> > For both scenarios to work for the attacker, there's need to be an
> > off-chain contractual relationship between the parties. Otherwise the
> > entity that rents out the TXOs can spoil or just confiscate the bond
> > of the entity that rented them, without reprecussions.
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ZmnSCPxj at protonmail.com  Wed Aug  7 11:20:38 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 07 Aug 2019 11:20:38 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <113a68d9-6c8c-3bf2-b337-9b87c5fd1db7@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<j-MXLs8fEpx57ttA_3TbcaWXT_eGjpcFkFE-Yzy3aPrUhSmnSSwHS1zIuez4aoBp8VrIsGHL8sAWYc_vR_T6QgQXM4xCDrVVlv0uW9MIs5s=@protonmail.com>
	<113a68d9-6c8c-3bf2-b337-9b87c5fd1db7@riseup.net>
Message-ID: <6neYGtuk8rPzYt5-qWJDrGiWAfC9aRUzlmjb6bg9JV_D59UFPfuvU7w0cSIbJ4c_YzbPcwk7O7ZDnu7ML_CvkBcQNPigS6RVdzFDAuk7Eu8=@protonmail.com>

Good morning Chris,

> Also, as described in my other email
> (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017218.html
> starting "
> Let's say the sybil attacker...") the superlinear V^2 term is essential
> to the resistance of the fidelity bond system to sybil attacks.

At the cost of *greatly* strengthening aggregation.

Suppose there is currently many makers, all with roughly-equal bonds.
Suppose I were to approach two of these makers, and offer to aggregate their bonds.
The combined bond would, because of the V^2 term, have 4 times the weight of the other makers.
Thus, approximately I can earn a little below 4 times what one other maker does.
I offer 1.5x what one maker does to both of those makers and keep a little below 0.5x to myself.
So:

1.  I earn without putting any of my money into bonds.
    I just need starting capital to pre-pay for the rents.
2.  I get to learn a little below 4x more CoinJoins than other makers.
    This increases my earnings further since I can sell this privacy information, and I also get an advantage compared to other non-aggregating spies.

It seems to me not to fix the root issue, i.e. makers who make for the purpose of gathering privacy information, even if it might fix sybil attackers.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Aug  7 11:35:34 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 07 Aug 2019 11:35:34 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
Message-ID: <IQE7dkcU-WE3QslZJ4uFyFafmFL_qAWJ_Us0nvwAGlyT44RDy9qUT7UZ2xDHyriIUzyYy-_dgGdTdJNKhx7zXlZkcPMfs2tHO1njLzHa-JY=@protonmail.com>

Good morning Dmitry,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Wednesday, August 7, 2019 6:05 PM, Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> These are very creative schemes. At the very least they would stop the
> easy mindless renting TXO method, where someone with coins on a hardware
> wallet simply creates a signature and copypastes it into a website to
> get free money. The workaround scheme with shared ownership of TXOs
> requires brand new wallets to be created and hodlers must trust the
> wallets enough to move their coins and hold them there for a long time.

Possibly not so much?
The wallet need only sign two things:

1.  The fidelity bond itself.
2.  The backout transaction.

Both can be done in a single session, then the private key involved can be erased permanently from memory.
Only the signature for the backout needs to be stored, and this can be safely stored without encryption by publishing to any cloud service --- others getting a copy of the signature does not let them change the signature to authorize a different transaction.
It would be enough to write the signing code in C and use special OS calls (which most languages higher than C do not expose) to allocate memory that will never be put in swap.
Then generate the private key using that memory, then clear it after usage before deallocating to the OS.
I believe `libsecp256k1` makes this easy.

Unless part of the bond process requires that the taker do a challenge "sign this random nonce for me", but of note is that it would have to impose this on all makers.
But if so, consider again this:

1.  There exists two non-spying makers with nearly-equal bond values.
2.  These makers need to keep their bond private keys in hot storage.
3.  I approach both makers and offer to aggregate their bond values, forming a new bond with 4x the weight of their individual bonds, and split up the increased earnings between us.
    This can be made noncustodial by use of smart contracts on Bitcoin.
4.  It is no different from the point of view of both makers: they still need to keep their bond private keys in hot storage.
    But this way earns them more money than operating as non-spying makers.
5.  I earn not only the fees for JoinMarket, I also earn additional fees for spying on CoinJoins.

It still seems to me that adding the V^2 tweak weakens the bond system, not strengthens it.

Regards,
ZmnSCPxj

From kanzure at gmail.com  Wed Aug  7 13:48:06 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Wed, 7 Aug 2019 08:48:06 -0500
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
Message-ID: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>

Hi,

I have a proposal for implementing bitcoin vaults in a way that does not
require any soft-forks or other software upgrades, although it could benefit
from SIGHASH_NOINPUT which I'll describe later.

I call them pre-signed vaults.

Vault definition
================

Here, a vault is defined as a transaction setup scheme that binds both the user
and the attacker to always using a public observation and delay period before a
weakly-secured hot key is allowed to arbitrarily spend coins. This is the same
definition previously used[1]. During the delay period, there is an opportunity
to initiate recovery/clawback which can either trigger deeper cold storage
parameters or at least reset the delay period to start over again for the same
keys.

One of the important components of this is the delete-the-key pre-signed
transaction concept, where only a single transaction is (pre)signed before
deleting the key. This is basically an emulation of a covenant and enforces a
certain outcome.

Background and motivation
=========================

I was looking at Eyal and Sirer's 2016 vaults paper [1], and I saw this
headscratcher:

> Vault transactions use a delay mechanism. We note that vault transactions
> cannot be implemented with existing timing mechanisms such as
> CHECKLOCKTIMEVERIFY opcode or transaction locktime.

This was probably written before the introduction of OP_CHECKSEQUENCEVERIFY.
Still, a viable construction would have more steps than just using OP_CSV. They
were probably not thinking about what those steps might be, because in the
context of the paper they were proposing a bitcoin vault implemented using
recursive consensus-enforced covenants via a new opcode, which obviously cannot
be deployed without an upgrade fork. Covenants have been discussed for years,
but require new opcodes or other consensus-enforcement changes.

Relative locktimes are useful here because there is no knowledge as to when the
transactions might be broadcasted in the future. The delays need to be relative
to after the transaction is included in the blockchain, not to setup
initialization time.

Also, from [2]:

> We show that a [vault transaction] mechanism is currently not possible in all
> cryptocurrencies [...] Bitcoin's scripting language requires support for
> covenants.

I haven't seen any previous proposal for how to implement recursive bitcoin
vaults without a fork and without a covenant. After asking around, I am pretty
sure this is somewhat novel. The closest I guess is [3].

Vaults are particularly interesting as a bitcoin cold storage security
mechanism because they enable a publicly observable delay period during which
time a user could be alerted by a watchtower that a thief might be in the
process of stealing their coins, and then the user may take some actions to
place the coins back into the vault before the relative timelock expires. There
seems to be no way to get this notification or observation period without a
vault construction. It might have been assumed it required a covenant.

Having a vault construction might go a long way to discourage would-be
attackers, on principle that the attacker might be incapable of recovering
their cost-of-attack because the recovery mechanism can lock up the coins
indefinitely. Griefing or denial-of-service would still be possible, of course,
but with multisig there might be some ways to put a halt to that as well. I am
working under the assumption that the attacker knows that the user is a vault
user.

Vaults
======

The idea is to have a sequence of pre-generated pre-signed transactions that
are generated in a certain way. The basic components are a vaulting transaction
that locks coins into a vault, a delayed-spend transaction which is the only
way to spend from a vault, and a re-vaulting transaction which can
recover/clawback coins from the delayed-spend transaction. The security of this
scheme is enforced by pre-signing transactions and deleting private keys, or
with the help of SIGHASH_NOINPUT then there's another scheme where private keys
are provably never known. This enforces that there's only a specific set of
possible outcomes at every step of the vault.

Some examples of what the set of broadcasted transactions might look like in
regular usage:

    coins -> VT -> DST -> exit via hot wallet key
    coins -> VT -> DST -> RVT
    coins -> VT -> DST -> RVT -> DST -> ...
    coins -> VT -> ... -> RVT998 -> nuclear abort

where:
    VT = vault transaction
    DST = delayed-spend transaction
    RVT = re-vaulting transaction

The delayed-spending transaction would have a single output with a script like:
(
    30 days AND hot wallet key
 OR 10 days AND re-vaulting public key
 OR 1 day AND 4-of-7 multisig
 OR 0 days and super-secure nuclear abort ragequit key
)

Another diagram:

    VT_100 -> DST -> (optionally) RVT -> coins are now in VT_99
    VT_99 -> DST -> (optionally) RVT -> coins are now in VT_98
    ...
    VT_1 -> burn-all-coins nuclear abort ragequit (final)

Definitions
===========

Transactions and components:

* Commitment/funding vault setup transaction. Signed after setting up the
transaction tree, and it is broadcasted whenever funds are to be placed into
the vault.

* Delayed-spend transaction. Signed during the vault transaction tree setup,
and it is broadcasted when the user wants to withdraw coins from cold storage
or otherwise manipulate the coins. The output script template used by the
delayed-spend transaction was defined earlier.

* Hot wallet key: Somewhat insecure key. This can also be multisig using
multiple hot keys.

* Re-vaulting key: It is important to note that the private key either never
existed (SIGHASH_NOINPUT + P2WPK for the re-vaulting transaction) or the
private key was deleted after pre-signing the re-vaulting transaction.

* 4-of-7 multisig: This is a group of differently-motivated individuals who are
responsible for signing transactions. This multisig group is not necessry to
describe the technique, I just think it's a useful feature for a vault to
include.

* Nuclear abort key: Also unnecessary. This is a key for which only a single
signed transaction will ever exist, and that single transaction will spend to a
proof-of-burn key like 0x00. This key must be extremely secure, and if there
is any doubt about the ability to keep such a key secured, then it is better to
not include this in the protocol. Alternatively, maybe include it as an option
50 layers down in the revaulting sequence.

* Nuclear-abort pre-signed transaction. This is signed during transaction tree
setup, before constructing the delayed-spend transaction. It is broadcasted
only if the user wants to provably relinquish coins forever without giving the
attacker any coins.

* Re-vaulting transaction. This is where the magic happens. The re-vaulting
transaction is signed during transaction tree setup, before constructing the
delayed-spend transaction for the parent vault. The re-vaulting transaction is
broadcasted when someone wants to prevent a coin withdrawal during the public
observation delay period. The re-vaulting transaction spends the delayed-spend
transaction outputs. It has a single output with a script created by running
the entire vault setup function again. Hence, when the re-vaulting transaction
is confirmed, all of the coins go back into a new identically-configured vault
instead of being relinquished through the delayed-spend transaction timeout for
hot wallet key signing.

* Special case: final transaction. This is the very first pre-signed
transaction during setup, and the transaction spends the coins using any
provable burn technique. This is broadcasted only at the end of the game, as an
ultimate abort and forfeiture of coins without giving in to an adversary. It's
similar to the nuclear-abort ragequit transaction but it sits at the same place
that a delayed-spend transaction would, at the very end of the rainbow or
yellow brick road.

Example log during vault setup
==============================

When running the recursive vault setup function, the created artifacts (in
order) will look like:

1) choose one of:
   (first iteration) pre-signed burn-all-coins nuclear abort ragequit (final)
   (all others) a new vault setup transaction spendable only by its
                delayed-spend transaction

2) pre-signed re-vaulting transaction sending to vault setup or final
transaction, with a unique private key

3) pre-signed delayed-spend transaction, with a unique private key

4) vault transaction spendable only by the delayed-spend public key

Pseudocode
==========

In pseudocode (where PTX is a pre-signed transaction function with
private key deletion):

    VT(counter, *args, **kwargs) =
        if counter == 0:
            DST = PTX("burn-all-coins")
        else:
            next_vault = VT(counter-1, *args, **kwargs)
            revaulting = PTX("only spendable by next_vault public key")
            DST = PTX("DST policy including revaulting and other conditions")
        vault = PTX("spendable only by this DST")
        return vault

Pre-signed transactions
=======================

What has been known for a while is that a covenant can be somewhat emulated
using a pre-signed transaction where the user then deletes the private key,
enforcing that the user's chosen policy must be enforced since there is only
one existing option and there will only ever be one option.

Such a scheme has been previously described for simple one-time and chained
vaults [3]. I have learned that the author has an implementation that is in
preparation, for a non-recursive version.

Note that a series of pre-signed transactions can be considered to be an
emulation of a covenant. Imagine a linear chain of pre-signed transactions
where each hop has a relative locktime before being able to broadcast the next
transaction. To recover the coins at the end of the rainbow, one would need to
broadcast each sequential transaction in order and wait for the relative
timelocks to expire each time. Here, covenants provide something like an undo
for bitcoin, but only between pre-determined addresses and scripts.

Fees for pre-signed transactions
================================

There's a few different techniques to talk about:

1) SIGHASH_SINGLE|SIGHASH_ANYONECANPAY to let someone add inputs and outputs.
This can get pretty complex though.

2) Add a zero-value OP_TRUE output and let anyone spend the zero-value output
and attach a child-pays-for-parent (CPFP) transaction to pay for everything.

3) Pre-sign a variety of different possible fee rates. Unfortunately this
involves an explosive blow-up in the amount of transaction data to generate. It
might actually be a reasonable blow-up amount, only resulting in a few hundred
megabytes of additional data. But given the other options, this is unnecessary.

Delete the key (for pre-signed transactions)
============================================

The delete-the-key trick is simple. The idea is to pre-sign at least one
transaction and then delete the private key, thus locking in that course of
action.

Unfortunately, delete-the-key doesn't really work for multisig scenarios
because nobody would trust that anyone else in the scheme has actually deleted
the secret. If they haven't deleted the secret, then they have full unilateral
control to sign anything in that branch of the transaction tree. The only time
that delete-the-key might be appropriate would be where the user who deletes
the key and controls the key during the setup process is also the sole
beneficiary of the entire setup with the multisig participants.

Alternative fee rates are easier to deal with using delete-the-key, compared to
a technique where the private key never existed which can only be used to sign
one fee rate per public key, requiring an entirely new vault subtree for each
alternative fee rate. With delete-the-key, the alternative fee rates are signed
with the private key before the private key is deleted.

Multisig gated by ECDSA pubkey recovery for provably-unknown keys
=================================================================

A group can participate in a multisig scheme with provably-unknown ECDSA keys.
Instead of deleting the key, the idea is to agree on a blockheight and then
select the blockhash (or some function of the chosen blockhash like
H(H(H(blockhash)))) as the signature. Next, the group agrees on a transaction
and they recover the public key from the signature using ECDSA pubkey recovery.
A pre-signed transaction is created, which will trigger the start of the public
observation period described earlier and also start the clock for the bip112
relative timelock on its output. In the output script, an OR branch
is added that enables the use of a re-vaulting key which could also be its own
separate multisig construction.

This is incompatible with P2WPKH because the P2WPKH spending scriptSig needs to
have the pubkey (to check the hash of the pubkey against the pubkeyhash in the
scriptPubKey), which in turn makes it incompatible with ECDSA pubkey recovery
which requires a hash of the message. However, with P2WPK and SIGHASH_NOINPUT
instead of P2WPKH it could conceivably work. SIGHASH_NOINPUT is required because
otherwise the input includes a txid which references the public key. With P2WPK,
the scriptSig only needs a signature and not a public key. Note that what would
be required is a version of SIGHASH_NOINPUT that does not commit to the public
key, and I think a few of the NOINPUT proposals are committing to the public
key.

Alternatively, there may be some constructions using the 2-party ECDSA
techniques or m-n party ECDSA techniques.

Deploying exceedingly large scripts
===================================

A brief interlude to share a somewhat obvious construction. I haven't seen this
written down yet.

Suppose there is a bitcoin script that someone is interested in using, but it
far exceeds the size limits and sigop limits. To fix this, they would split up
the script into usable chunks, and then use the delete-the-key mechanism (or
the other one) to create an OR branch that is signable by a single key for
which only a single signature is known. That new pre-signed transaction would
spend to a script that has the output with the remainder of the script of
interest. Re-vaulting or clawback clauses can be added to that output as well,
but spending back to the original root script will only work by generating new
scripts and keys (since the final hash isn't known until the whole tree is
constructed, it's a dependency loop).

Recursively-enforced multi-party multisig bitcoin vaults
========================================================

Ideally, to enforce a covenant with impossible fairy dust magic, we would ask
for a bitcoin transaction that could be self-referential because the
only-one-signature-ever trick requires that the signed message be known before
producing the signature, and the signature has to be known before the public
key can be known, and the public key would have to be included in the
self-referential message/transaction hash value. So, that's a dependency loop
and it doesn't work. It would be interesting to explore a variation of this
idea with masking, such that a value X can be replaced by a hash over the whole
script with the X value, even though the real script will have the hash.
Someone else can figure that one out for me :-).

Instead of the self-referential values attempting to reference the same
script that is in the process of being constructed, an alternative is to use
the same script template but populate it with different parameters. The script
template gets reused over and over again, all the way down the tree, until the
final transaction which could be >100 years into the future once done adding up
all the relative locktimes. In fact, to create and populate this terrifying
recursive script tree, the final transaction needs to be created first, and
then it is given as input to the script template function and that output is
then given to the script template function itself-- and so on. At each stage,
there are additional pre-signed transactions and values to remember.

This can be written as:

    final_transaction = TX(spend to 0x0000 to burn the coins)
    initial_transaction = F(F(...F(final_transaction))

    (This is missing parameters to indicate to the function what the spending
    keys requirements are to be.)

See earlier explanation for more details.

Each call to the template populating function produces values that each must be
preserved for a very long time. It is less safe to store all of the pre-signed
transactions together at the same time, but more convenient. With less
redundancy, there is an increased chance of losing data over time, which could
render the coins completely frozen. This doesn't particularly worry me because
forgetting a key has that property already, and this could be likened to
hundreds of megabytes of extra key data or something. Unlike the much smaller
covenant-based (opcode-based covenant) vault construction, the multiple layers
here can be separately stored and protected, which might be able to protect
against an adversary that has stolen some of the re-vaulting keys but not all
of them.

Optimizations can be made to store parameters for generating the remainder of
the tree, such as using deterministic key derivation, such that megabytes of
data wouldn't need to be long-term stored. Only the initial parameters would
need to be stored.

Financial privacy for custody
=============================

One of the concerns raised in [2] is that if all coins at an exchange are
stored together in the same vault, then attackers would be able to learn about
access control policies by observing scripts and keys. Some privacy can be
recovered by using segregated vaults, at the cost of additional setup
complexity and keeping more data in long-term storage.

However, note that I think vaults are also useful for personal cold storage
solutions.

Fail-deadly mechanism
=====================

An early nuclear abort option can be added to these scripts. This idea was
explored in [2]. This would be a very cold very secret key that would abort the
re-vaulting procedure and send all coins to a (provably) nonsense key. This
allows a vault user to destroy the coins instead of continuously monitoring the
bitcoin blockchain for the rest of his life. The attacker can't recover their
cost of attack if they never get the coins, and this eliminates an entire class
of potential attackers who are directly interested only in financial gain. The
disadvantage is that if the attacker finds the secret key for the fail-deadly
mechanism and uses it, then all of the coins are gone forever.

Multisig variations
===================

The re-vaulting key could be the same key at each layer, or only sometimes the
same key, or always a unique key stored separately in another secure location.

Additionally, these re-vaulting keys could be subjected to multisig schemes, as
well as Shamir secret sharing schemes or other secret sharing schemes.

The idea of adding the 4-of-7 multisig component is to avoid griefing
situations, at the cost of the additional security requirements for the 4-of-7
multisig group.

Key rotation for vaults
=======================

Keeping the same hot wallet key for 100 years is not advisable. Rotate the keys
by setting up a new vault construction and initiating a withdrawal transaction
from the old vault to the new vault.

Single-use seals
================

This proposal may have inadvertedly demonstrated a practical way to implement
Peter Todd's single-use seals concept [4]. I am hesitant to say so, though,
because I think he would ask for a more sophisticated way to verify seal
closure.

Paid defection
==============

It might be advisable to add small rewards for evidence of defection amongst
multiparty multisig setups. Besides amounts spendable by individual keys from a
multisig setup, it may be possible to use a zero-knowledge contingent payment
for a zero-knowledge statement like: I have a signature s over some message m
which validates for pubkey pk where pk is a member of the multisig group. Then
the zkcp transaction would pay for knowledge of defectors. The zkcp procedure
would require interaction with the defector, while the direct pubkey method
would not. This is similar to companies paying employees to quit when they
value the payment over the value of continued employment.

Handling change
===============

It is important to note that this vault setup is one-time and once-only. There
must only ever be one deposit into one vault. Also, spending some coins would
require sending the change amount back into a new vault.  Alternatively,
upfront work can be done to set a regular withdrawal stipend or assumption
about how many coins are left, such that the transaction tree can be
pre-generated for those possibilities, hence cutting down on future vault
reinitializations. It would also be possible to commit upfront to only ever
working in some minimum increment number of bitcoin or something.

It is very important to only fund the vault once, and only with the amount that
was configured when setting up the vault.

References
==========

[1] https://fc16.ifca.ai/bitcoin/papers/MES16.pdf

[2] http://www0.cs.ucl.ac.uk/staff/P.McCorry/preventing-cryptocurrency-exchange.pdf

[3] http://web.archive.org/web/20180503151920/https://blog.sldx.com/re-imagining-cold-storage-with-timelocks-1f293bfe421f?gi=da99a4a00f67

[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015350.html
or https://diyhpl.us/wiki/transcripts/building-on-bitcoin/2018/single-use-seals/
or https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy

Acknowledgements
================

* Jeremy Rubin for pointing out something embarrassingly broken in an earlier
draft.

* Bob McElrath for telling me to use SIGHASH_NOINPUT which I proceeded to
promptly forget about.

* Andrew Poelstra for the OP_TRUE trick.

* Joe Rayhawk for paid defection.

* Tadge Dryja for pointing out a few differences between SIGHASH_NOINPUT
proposals.



Thank you,

- Bryan
http://heybryan.org/

From dp at simplexum.com  Wed Aug  7 15:10:17 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Wed, 7 Aug 2019 20:10:17 +0500
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
Message-ID: <20190807201017.2a03b971@simplexum.com>

? Wed, 7 Aug 2019 11:05:41 +0100
Chris Belcher <belcher at riseup.net> wrote:

> These are very creative schemes. At the very least they would stop the
> easy mindless renting TXO method, where someone with coins on a
> hardware wallet simply creates a signature and copypastes it into a
> website to get free money.

The second scheme ("all locked TXO may be required to be spendable
by *any* key that controls any TXO in the 'bond TXO package'") is in
almost all regards the same as simple "require TXO to be consolidated",
and looks like it is not in any way better than simple consolidation.

The first scheme - 'allow revocation of the whole bond by the key
controlling even a single TXO in a bond' - might be more promising.

> I wonder if there's a cryptographic way to prove that muSig and
> 2P-ECDSA have not been used to create a certain pubkey/signature.

In the second scheme, to revoke/spoil the bond, the entity that
controls one TXO participating in this bond needs to simply prove that
it somehow controls/have the ability to spend that TXO.

In shared ownership rent scheme that ZmnSCPxj described in [1],
the 'TXO rentier' has a signed timelocked 'backout' transaction that
spends the locked TXO, and assigns the reward to rentier.

If we say that any transaction that spends any TXO in the bond
(ignoring the timelock), invalidates the bond when presented to
takers, then TXO rentier can revoke the bond by simply
publishing this transaction (not to the blockchain, but by some other
means so that takers can receive it).

The transaction validity can be verified, with the relaxed rules that
ignores the timelock. After it is verified, takers mark the whole
bond as revoked and will not consider it when chosing makers.

One inconvenience here is that takers need to store the
data about revoked bonds. But it seems to me that there's no need
for that information to be synchronized between the participants
instantly. It is enougth for takers to get the revoked-set eventually.

The rentier are still incentivized to not spoil the bond, to receive
the profit. Their funds are locked anyway.

But if the goal of the 'rentier' is to attack the attacker, the
opportunity cost of these locked funds is the cost of the attack.

If the renter rents TXOs from several entities to include in one bond,
revocation by one rentier spoils whole bond, and the total loss for all
participants is bigger than the oportunity cost of locked funds of a
single rentier that made the revocation. 

The possibility of such revocation increases risk for the renter and
would-be co-rentiers, and is likely limit the possible scale of such
TXO-renting operation.
 
[1]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017217.html

From kanzure at gmail.com  Wed Aug  7 20:32:47 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Wed, 7 Aug 2019 15:32:47 -0500
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
Message-ID: <CABaSBawQhC5EDbyc8c0rk1JxjF2NJBn+mb6tPgvTwkNXOPcSGg@mail.gmail.com>

Hi,

One of the biggest problems with the vault scheme (besides all of the
setup data that has to be stored for a long time) is an attacker that
silently steals the hot wallet private key and waits for the vault's
owner to make a delayed-spend transaction to initiate a withdrawal
from the vault. If the user was unaware of the theft of the key, then
the attacker could steal the funds after the delay period.

To mitigate this, it is important to choose a stipend or withdrawal
amount per withdrawal period like x% of the funds. This limits the
total stolen funds to x% because once the funds are stolen the user
would know their hot key is compromised, and the user would know to
instead use one of the other clawback paths during all of the future
withdrawal delay periods instead of letting the delay timeout all the
way to the (stolen) default/hot key.

The reason why a loss limiter is the way to go is because there's
currently no way (that I am aware of, without an upgrade) to force an
attacker to reveal his key on the blockchain while also forcing the
attacker to use a timelock before the key can spend the coins. I am
curious about what the smallest least invasive soft-fork would be for
enabling this kind of timelock. There are so many covenant proposals
at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,
....). Or there's crazy things like a fork that enables a transaction
mode where the (timelock...) script of the first output is
automatically prefixed to any of the other scripts on any of the other
outputs when an input tries to spend in the future. A thief could add
his key to a new output on the transaction and try to spend (just like
a user would with a fresh/rotated key), but the OP_CSV would be
automatically added to his script to implement the public observation
delay window.

Also, there was other previous work that I was only informed about
today after posting my proposal, so I should mention these as related
work:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html
https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better
https://www.youtube.com/watch?v=diNxp3ZTquo
https://bitcointalk.org/index.php?topic=5111656

- Bryan
http://heybryan.org/

From dustinpaystaxes at gmail.com  Wed Aug  7 21:19:05 2019
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Wed, 7 Aug 2019 14:19:05 -0700
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <CABaSBawQhC5EDbyc8c0rk1JxjF2NJBn+mb6tPgvTwkNXOPcSGg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
	<CABaSBawQhC5EDbyc8c0rk1JxjF2NJBn+mb6tPgvTwkNXOPcSGg@mail.gmail.com>
Message-ID: <CABLeJxTE09d3ujndAhrxiVwBmXkdxyUM9QfKTE69QQcNDbr5Qg@mail.gmail.com>

Does revaulting vault up with the same keys, or new ones?

Are they new derivation paths on the same key?

Would love some expanded explanation on how you?re proposing this would
work.

Thanks,
Dustin

On Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> One of the biggest problems with the vault scheme (besides all of the
> setup data that has to be stored for a long time) is an attacker that
> silently steals the hot wallet private key and waits for the vault's
> owner to make a delayed-spend transaction to initiate a withdrawal
> from the vault. If the user was unaware of the theft of the key, then
> the attacker could steal the funds after the delay period.
>
> To mitigate this, it is important to choose a stipend or withdrawal
> amount per withdrawal period like x% of the funds. This limits the
> total stolen funds to x% because once the funds are stolen the user
> would know their hot key is compromised, and the user would know to
> instead use one of the other clawback paths during all of the future
> withdrawal delay periods instead of letting the delay timeout all the
> way to the (stolen) default/hot key.
>
> The reason why a loss limiter is the way to go is because there's
> currently no way (that I am aware of, without an upgrade) to force an
> attacker to reveal his key on the blockchain while also forcing the
> attacker to use a timelock before the key can spend the coins. I am
> curious about what the smallest least invasive soft-fork would be for
> enabling this kind of timelock. There are so many covenant proposals
> at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,
> ....). Or there's crazy things like a fork that enables a transaction
> mode where the (timelock...) script of the first output is
> automatically prefixed to any of the other scripts on any of the other
> outputs when an input tries to spend in the future. A thief could add
> his key to a new output on the transaction and try to spend (just like
> a user would with a fresh/rotated key), but the OP_CSV would be
> automatically added to his script to implement the public observation
> delay window.
>
> Also, there was other previous work that I was only informed about
> today after posting my proposal, so I should mention these as related
> work:
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html
>
> https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better
> https://www.youtube.com/watch?v=diNxp3ZTquo
> https://bitcointalk.org/index.php?topic=5111656
>
> - Bryan
> http://heybryan.org/
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/eb1c27d9/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Aug  8 00:09:11 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 08 Aug 2019 00:09:11 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <20190807201017.2a03b971@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
	<20190807201017.2a03b971@simplexum.com>
Message-ID: <jyEbDqD57bjrjd1QF72bLHmubrQxdc-WVqONP0gx-PjixLnQrLwWn9A2W_MkWwkTi_aJHSuUcLfxh2JnRp71110TtNNv8ZoDIhWAXFmuT5c=@protonmail.com>

Good morning Dmitry,

> The first scheme - 'allow revocation of the whole bond by the key
> controlling even a single TXO in a bond' - might be more promising.

Is it?
I imagine any key can secretly be a MuSig or aggregated ECDSA key, with the aggregator being a signatory.

>
> > I wonder if there's a cryptographic way to prove that muSig and
> > 2P-ECDSA have not been used to create a certain pubkey/signature.
>
> In the second scheme, to revoke/spoil the bond, the entity that
> controls one TXO participating in this bond needs to simply prove that
> it somehow controls/have the ability to spend that TXO.
>
> In shared ownership rent scheme that ZmnSCPxj described in [1],
> the 'TXO rentier' has a signed timelocked 'backout' transaction that
> spends the locked TXO, and assigns the reward to rentier.
>
> If we say that any transaction that spends any TXO in the bond
> (ignoring the timelock), invalidates the bond when presented to
> takers, then TXO rentier can revoke the bond by simply
> publishing this transaction (not to the blockchain, but by some other
> means so that takers can receive it).
>
> The transaction validity can be verified, with the relaxed rules that
> ignores the timelock. After it is verified, takers mark the whole
> bond as revoked and will not consider it when chosing makers.
>
> One inconvenience here is that takers need to store the
> data about revoked bonds. But it seems to me that there's no need
> for that information to be synchronized between the participants
> instantly. It is enougth for takers to get the revoked-set eventually.
>
> The rentier are still incentivized to not spoil the bond, to receive
> the profit. Their funds are locked anyway.
>
> But if the goal of the 'rentier' is to attack the attacker, the
> opportunity cost of these locked funds is the cost of the attack.
>
> If the renter rents TXOs from several entities to include in one bond,
> revocation by one rentier spoils whole bond, and the total loss for all
> participants is bigger than the oportunity cost of locked funds of a
> single rentier that made the revocation.
>
> The possibility of such revocation increases risk for the renter and
> would-be co-rentiers, and is likely limit the possible scale of such
> TXO-renting operation.

This is quite a clever solution.

Let me then attempt to break it.

It is possible to encrypt data in such a way that it requires sequential operations in order to decrypt.
https://www.gwern.net/Self-decrypting-files

This basically allows us to encrypt some data in such a way that its decryption is timelocked, by requiring a large number of sequential operations to decrypt.

It also seems to me (I am not a cryptographer) that it may be possible to present a ZKP that an encrypted text, encrypted using the above timelock decryption, is a signature of a particular message with a particular public key.

Thus, we can change the ritual to this:

1.  I contact two lessors to aggregate their coins into a larger UTXO and thus break V^2.
2.  We create a funding transaction that pays to a locked bond address, with a pubkey equal to a MuSig among us.
    This spends the TXOs they want to lease out, as well as some of my funds to be used for paying for rent.
    We do not sign this yet.
3.  We create a backout transaction that returns the bond to both lessors, plus their rent.
    We partly perform the MuSig ritual to sign this transaction, with me as the last step.
4.  Instead of providing the completed signature to the lessors, I encrypt it using the above timelocked encryption.
    I provide this encryption and a zero-knowledge proof that I have actually completed the signature ritual correctly and that the timelocked-encrypted text has the signature as plaintext.
5.  The lessors now know they can acquire the signature by simply grinding the timelocked encryption.
    This allows them to recover their money by the appointed time.
6.  We then exchange signatures for the funding transaction and broadcast and confirm it.

Now, the lessors cannot provide a valid timelocked transaction, as they do *not* yet have a complete signature; thus they cannot snitch about my aggregation of their funds.
At the same time, they know that the timelocked encryption allows them to eventually get a complete signature and recover their funds.
I can defray this cost of processing by increasing my rent slightly.

Now of course we can just go one step further and also allow bonds to be snitched by presenting the timelocked-encrypted text and the ZKP that it contains the signature for a timelocked transactions.
But it seems to me that there is more than one way to skin this particular cat, thus unless all ways to create provable timelocked encryptions are enumerable, it would be possible to get around.

(though of course it is dependent on a ZKP being possible for a timelocked encryption)

Finally, aggregation is still possible to insure by off-blockchain agreements, possibly with legal consequences, and thus entities like exchanges might still be able to aggregate funds and acquire an undeservedly large weight in the fidelity bond system.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Thu Aug  8 00:27:32 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 08 Aug 2019 00:27:32 +0000
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
Message-ID: <japBRkZAIadJ9g0xOFbixrzJv4hk67ONKrjO6QuWARaeMtdIhNb7rDT_8NroxDCIVKFTjcAqukSt4sApPsJ0U9ori3bkCKmEW_jJMcXWMqc=@protonmail.com>

Good morning Bryan,

> -   Re-vaulting transaction. This is where the magic happens. The re-vaulting
>     transaction is signed during transaction tree setup, before constructing the
>     delayed-spend transaction for the parent vault. The re-vaulting transaction is
>     broadcasted when someone wants to prevent a coin withdrawal during the public
>     observation delay period. The re-vaulting transaction spends the delayed-spend
>     transaction outputs. It has a single output with a script created by running
>     the entire vault setup function again. Hence, when the re-vaulting transaction
>     is confirmed, all of the coins go back into a new identically-configured vault
>     instead of being relinquished through the delayed-spend transaction timeout for
>     hot wallet key signing.

As transactions need to be signed in reverse order, it seems to me that there is a practical limit in the number of times a vault can be used.
Basically, the number of times we run the vault setup function is the limit on number of re-vaultings possible.

Is my understanding correct?

Regards,
ZmnSCPxj

From kanzure at gmail.com  Thu Aug  8 01:16:42 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Wed, 7 Aug 2019 20:16:42 -0500
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <japBRkZAIadJ9g0xOFbixrzJv4hk67ONKrjO6QuWARaeMtdIhNb7rDT_8NroxDCIVKFTjcAqukSt4sApPsJ0U9ori3bkCKmEW_jJMcXWMqc=@protonmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
	<japBRkZAIadJ9g0xOFbixrzJv4hk67ONKrjO6QuWARaeMtdIhNb7rDT_8NroxDCIVKFTjcAqukSt4sApPsJ0U9ori3bkCKmEW_jJMcXWMqc=@protonmail.com>
Message-ID: <CABaSBay8hBkStv5rLPhHMmwnGjMhEjwdR_LeovQ8GMqRg0vxMA@mail.gmail.com>

Replying to two emails below.

On Wed, Aug 7, 2019 at 7:27 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> > -   Re-vaulting transaction. This is where the magic happens. The
> re-vaulting
> >     transaction is signed during transaction tree setup, before
> constructing the
> >     delayed-spend transaction for the parent vault. The re-vaulting
> transaction is
> >     broadcasted when someone wants to prevent a coin withdrawal during
> the public
> >     observation delay period. The re-vaulting transaction spends the
> delayed-spend
> >     transaction outputs. It has a single output with a script created by
> running
> >     the entire vault setup function again. Hence, when the re-vaulting
> transaction
> >     is confirmed, all of the coins go back into a new
> identically-configured vault
> >     instead of being relinquished through the delayed-spend transaction
> timeout for
> >     hot wallet key signing.
>
> As transactions need to be signed in reverse order, it seems to me that
> there is a practical limit in the number of times a vault can be used.
> Basically, the number of times we run the vault setup function is the
> limit on number of re-vaultings possible.
>
> Is my understanding correct?
>

Yes, that is correct. When setting up the vault, plan it "all the way to
the end" like next 100+ years. With exponential backoff on the relative
timelock values, the total number of pre-signed transactions isn't really
that high. With a few thousand pre-signed transactions (more than enough),
you can have high resolution timelocks well into the future.

On Wed, Aug 7, 2019 at 4:19 PM Dustin Dettmer <dustinpaystaxes at gmail.com>
wrote:

> Does revaulting vault up with the same keys, or new ones?
> Are they new derivation paths on the same key?
>

Honestly, no idea. The answer to that might depend on each individual vault
user. If the user doesn't want to deal with the expense of managing a bunch
of unique keys and other data, then it might make more sense to use the
same values and have a small blob that has to be stored for a long time,
rather than many different blobs stored in different places to deal with.

- Bryan
http://heybryan.org/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/8b220b88/attachment.html>

From sergio.d.lerner at gmail.com  Thu Aug  8 02:09:20 2019
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Wed, 7 Aug 2019 23:09:20 -0300
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <CABLeJxTE09d3ujndAhrxiVwBmXkdxyUM9QfKTE69QQcNDbr5Qg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
	<CABaSBawQhC5EDbyc8c0rk1JxjF2NJBn+mb6tPgvTwkNXOPcSGg@mail.gmail.com>
	<CABLeJxTE09d3ujndAhrxiVwBmXkdxyUM9QfKTE69QQcNDbr5Qg@mail.gmail.com>
Message-ID: <CAKzdR-q3nnWggUz7aE0p1ts8KsWVigznjuJpR1SNzKNXs+GmiA@mail.gmail.com>

Seems to be comparable to the proposed "Tick Method" from 2013:
https://bitcointalk.org/index.php?topic=307211.msg3308565#msg3308565

However I remember that someone told me the tick method had a flaw..



On Wed, Aug 7, 2019 at 6:28 PM Dustin Dettmer via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Does revaulting vault up with the same keys, or new ones?
>
> Are they new derivation paths on the same key?
>
> Would love some expanded explanation on how you?re proposing this would
> work.
>
> Thanks,
> Dustin
>
> On Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi,
>>
>> One of the biggest problems with the vault scheme (besides all of the
>> setup data that has to be stored for a long time) is an attacker that
>> silently steals the hot wallet private key and waits for the vault's
>> owner to make a delayed-spend transaction to initiate a withdrawal
>> from the vault. If the user was unaware of the theft of the key, then
>> the attacker could steal the funds after the delay period.
>>
>> To mitigate this, it is important to choose a stipend or withdrawal
>> amount per withdrawal period like x% of the funds. This limits the
>> total stolen funds to x% because once the funds are stolen the user
>> would know their hot key is compromised, and the user would know to
>> instead use one of the other clawback paths during all of the future
>> withdrawal delay periods instead of letting the delay timeout all the
>> way to the (stolen) default/hot key.
>>
>> The reason why a loss limiter is the way to go is because there's
>> currently no way (that I am aware of, without an upgrade) to force an
>> attacker to reveal his key on the blockchain while also forcing the
>> attacker to use a timelock before the key can spend the coins. I am
>> curious about what the smallest least invasive soft-fork would be for
>> enabling this kind of timelock. There are so many covenant proposals
>> at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,
>> ....). Or there's crazy things like a fork that enables a transaction
>> mode where the (timelock...) script of the first output is
>> automatically prefixed to any of the other scripts on any of the other
>> outputs when an input tries to spend in the future. A thief could add
>> his key to a new output on the transaction and try to spend (just like
>> a user would with a fresh/rotated key), but the OP_CSV would be
>> automatically added to his script to implement the public observation
>> delay window.
>>
>> Also, there was other previous work that I was only informed about
>> today after posting my proposal, so I should mention these as related
>> work:
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html
>>
>> https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better
>> https://www.youtube.com/watch?v=diNxp3ZTquo
>> https://bitcointalk.org/index.php?topic=5111656
>>
>> - Bryan
>> http://heybryan.org/
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190807/881ebc3d/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Aug  8 03:03:04 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 08 Aug 2019 03:03:04 +0000
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <CAKzdR-q3nnWggUz7aE0p1ts8KsWVigznjuJpR1SNzKNXs+GmiA@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
	<CABaSBawQhC5EDbyc8c0rk1JxjF2NJBn+mb6tPgvTwkNXOPcSGg@mail.gmail.com>
	<CABLeJxTE09d3ujndAhrxiVwBmXkdxyUM9QfKTE69QQcNDbr5Qg@mail.gmail.com>
	<CAKzdR-q3nnWggUz7aE0p1ts8KsWVigznjuJpR1SNzKNXs+GmiA@mail.gmail.com>
Message-ID: <xAXfAdir4XrXKbi1j7Jnpmr70WJQQ_iuGUHRjHJZ3bXMETO7Sf1w40Zr6Rvy8BLmheoaQewjzyLMVZKpUU7h1sHtuHOOocBaw8fzHiapfd4=@protonmail.com>

Good morning Sergio,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, August 8, 2019 10:09 AM, Sergio Demian Lerner via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Seems to be comparable to the proposed "Tick Method" from 2013:
> https://bitcointalk.org/index.php?topic=307211.msg3308565#msg3308565?
>
> However I remember that someone told me the tick method had a flaw..


Maybe the use of `SIGHASH_NONE` for both inputs of the TxOut transactions?
Also txid malleability.

The first can be fixed by not using `SIGHASH_NONE` for one of the inputs and requiring a hot privkey to sign with that.
The second can be fixed by using SegWit outputs.

Regards,
ZmnSCPxj

> ?
>
> On Wed, Aug 7, 2019 at 6:28 PM Dustin Dettmer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Does revaulting vault up with the same keys, or new ones?
> >
> > Are they new derivation paths on the same key?
> >
> > Would love some expanded explanation on how you?re proposing this would work.
> >
> > Thanks,
> > Dustin
> >
> > On Wed, Aug 7, 2019 at 1:35 PM Bryan Bishop via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > Hi,
> > >
> > > One of the biggest problems with the vault scheme (besides all of the
> > > setup data that has to be stored for a long time) is an attacker that
> > > silently steals the hot wallet private key and waits for the vault's
> > > owner to make a delayed-spend transaction to initiate a withdrawal
> > > from the vault. If the user was unaware of the theft of the key, then
> > > the attacker could steal the funds after the delay period.
> > >
> > > To mitigate this, it is important to choose a stipend or withdrawal
> > > amount per withdrawal period like x% of the funds. This limits the
> > > total stolen funds to x% because once the funds are stolen the user
> > > would know their hot key is compromised, and the user would know to
> > > instead use one of the other clawback paths during all of the future
> > > withdrawal delay periods instead of letting the delay timeout all the
> > > way to the (stolen) default/hot key.
> > >
> > > The reason why a loss limiter is the way to go is because there's
> > > currently no way (that I am aware of, without an upgrade) to force an
> > > attacker to reveal his key on the blockchain while also forcing the
> > > attacker to use a timelock before the key can spend the coins. I am
> > > curious about what the smallest least invasive soft-fork would be for
> > > enabling this kind of timelock. There are so many covenant proposals
> > > at this point (CHECKSIGFROMSTACK, SECURETHEBAG, CHECKOUTPUTVERIFY,
> > > ....). Or there's crazy things like a fork that enables a transaction
> > > mode where the (timelock...) script of the first output is
> > > automatically prefixed to any of the other scripts on any of the other
> > > outputs when an input tries to spend in the future. A thief could add
> > > his key to a new output on the transaction and try to spend (just like
> > > a user would with a fresh/rotated key), but the OP_CSV would be
> > > automatically added to his script to implement the public observation
> > > delay window.
> > >
> > > Also, there was other previous work that I was only informed about
> > > today after posting my proposal, so I should mention these as related
> > > work:
> > > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html
> > > https://blog.oleganza.com/post/163955782228/how-segwit-makes-security-better
> > > https://www.youtube.com/watch?v=diNxp3ZTquo
> > > https://bitcointalk.org/index.php?topic=5111656
> > >
> > > - Bryan
> > > http://heybryan.org/
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ZmnSCPxj at protonmail.com  Thu Aug  8 09:35:24 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 08 Aug 2019 09:35:24 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <jyEbDqD57bjrjd1QF72bLHmubrQxdc-WVqONP0gx-PjixLnQrLwWn9A2W_MkWwkTi_aJHSuUcLfxh2JnRp71110TtNNv8ZoDIhWAXFmuT5c=@protonmail.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
	<20190807201017.2a03b971@simplexum.com>
	<jyEbDqD57bjrjd1QF72bLHmubrQxdc-WVqONP0gx-PjixLnQrLwWn9A2W_MkWwkTi_aJHSuUcLfxh2JnRp71110TtNNv8ZoDIhWAXFmuT5c=@protonmail.com>
Message-ID: <-6u9Ut_oYRThO21GIO1G8u4LpKavq2okw0Z7KoIM0tgwg4mAYXt2TP-SgiigMofdvLhvRuwX_q7Op6DUDM_eWUCjGmIEL_VTLpAeYDNOl5c=@protonmail.com>

Good morning Dmitry, and list,

> > > I wonder if there's a cryptographic way to prove that muSig and
> > > 2P-ECDSA have not been used to create a certain pubkey/signature.
> >
> > In the second scheme, to revoke/spoil the bond, the entity that
> > controls one TXO participating in this bond needs to simply prove that
> > it somehow controls/have the ability to spend that TXO.
> > In shared ownership rent scheme that ZmnSCPxj described in [1],
> > the 'TXO rentier' has a signed timelocked 'backout' transaction that
> > spends the locked TXO, and assigns the reward to rentier.
> > If we say that any transaction that spends any TXO in the bond
> > (ignoring the timelock), invalidates the bond when presented to
> > takers, then TXO rentier can revoke the bond by simply
> > publishing this transaction (not to the blockchain, but by some other
> > means so that takers can receive it).
> > The transaction validity can be verified, with the relaxed rules that
> > ignores the timelock. After it is verified, takers mark the whole
> > bond as revoked and will not consider it when chosing makers.
> > One inconvenience here is that takers need to store the
> > data about revoked bonds. But it seems to me that there's no need
> > for that information to be synchronized between the participants
> > instantly. It is enougth for takers to get the revoked-set eventually.
> > The rentier are still incentivized to not spoil the bond, to receive
> > the profit. Their funds are locked anyway.
> > But if the goal of the 'rentier' is to attack the attacker, the
> > opportunity cost of these locked funds is the cost of the attack.
> > If the renter rents TXOs from several entities to include in one bond,
> > revocation by one rentier spoils whole bond, and the total loss for all
> > participants is bigger than the oportunity cost of locked funds of a
> > single rentier that made the revocation.
> > The possibility of such revocation increases risk for the renter and
> > would-be co-rentiers, and is likely limit the possible scale of such
> > TXO-renting operation.
>
> This is quite a clever solution.
>
> Let me then attempt to break it.
>
> It is possible to encrypt data in such a way that it requires sequential operations in order to decrypt.
> https://www.gwern.net/Self-decrypting-files

I apologize, I was being daft.
There is a simpler way to break this, involving such Lightning Network tropes as revocation and punishment schemes.
Truly, Lightning Network is a great great thing.

First, we should always consider, that due to the V^2, consolidated bonds are always higher weight than unconsolidated bonds.
Thus, even without considering motives to spy on CoinJoins, the existence of the V^2 tweak implies that there will be fewer larger makers and thus easier to take over the JoinMarket system.

So, let us focus on the backout transaction.
Under a consolidated bond, this requires an n-of-n.

Now, suppose we want to identify the snitch who reports our consolidation scheme to the takers.
This can be done easily by performing n MuSig n-of-n rituals, with each ritual using different `r` nonces.
We arrange this by having each of the n consolidators be the last signers in the second round of the MuSig, and have each signer keep their own unique version of the signature for the backout, with their own unique `r` nonce.

Each participant will want to keep its own version of the signature private, because if it gives out this signature to another participant in the consolidated bond scheme, the other participant can frame them for snitching.

We can now identify the snitch, by recognizing which signature was used in the transaction that was reported to the takers.
But we have not yet identified how we can punish the snitch.

As it happens, MuSig allows Scriptless Script.
This means, it is possible for one participant in the MuSig to provide an adaptor signature.
This adaptor signature commits to a particular point.
When the MuSig is completed and the participant (who is the last signer in the second round of MuSig) reveals the completed signature, the scalar that generates the commited point can be computed by anyone who knows the adaptor signature.

This is our next step in our scheme to identify and punish snitches.
In addition to putting up their funds in a consolidated bond, each of the participants in the consolidation scheme put up a fraction of the value into revocable bonds.

This revocable bond is a Taproot with a known-NUMS point as internal Taproot key, and the script alternatives below:

    <bond_time - 1> OP_CHECKLOCKTIMEVERIFY OP_DROP <participant_key> OP_CHECKSIG

and

    <MuSig(all participants *except* this participant)> OP_CHECKSIGVERIFY <participant_snitch_key> OP_CHECKSIG

A punishment transaction spends from the revocable bond via the second alternative above, and divides it equally among the *other* participants.
THis is signed using the MuSig above (where all participants except the owner of this revocable bond are part of).

Then, before starting the n rituals to sign the backoff transaction, the participants provide adaptor signatures to their own `participant_snitch_key`, such that if they publish the backoff transaction to the takers, any of their co-participants that masquerades as a taker can find out about this and derive the private key to the `participant_snitch_key`.

So:

1.  In case all the participants cooperate with the other consolidators, then just before the bond expires, each participant can recover their revocable bond via the first alternative shown above.
    Once the revocable bond is spent back to an address they solely control, the `participant_snitch_key` is worthless.
    Then any participant can publish onchain the backoff transaction without repercussion.
2.  In case a participant snitches and reveals a pre-signed backoff to the takers before the end of the bond period, they can only reveal their own version of the signature of the backoff transaction.
    In that case, their previously-shown adaptor signature can be used to reveal the private key behind their `participant_snitch_key`.
    Then any one of the other participants in the consolidation scheme can complete the punishment transaction.

We can even ensure that setup of the whole system is atomic, by unironically CoinJoining the creation of the consolidated JoinMarket V^2 fidelity bond, in the same transaction that creates the revocable bonds that can be used to ensure that snitches are punishable.

Now you might say, "well now the bond they can put into the JoinMarket fidelity bond is smaller because of the need to put a revocable bond".
And that is right.
It also shows that the V^2 tweak is broken.

Suppose there are two makers with 1.0 BTC each.
They decide to consolidate their bond in order to increase their consolidated weight in the JoinMarket fidelity bond system.
They decide to put up 0.25BTC each for the revocable bonds, and 0.75BTC each into the consolidated JoinMarket V^2 fidelity bond.
The total consolidated bond is 1.5BTC, which has a weight 2.25x the weight of one 1.0BTC bond, or 1.125x the weight of 2x 1.0BTC bonds.
Thus consolidation pressure still exists strongly (and I would think that losing as little as 5% of your total bondable funds would be enough to discourage snitches: this example is 25%).

The scheme would not be broken if there was no V^2 tweak, and would have worked perfectly to disable consolidation, if not for the V^2 tweak.

Regards,
ZmnSCPxj

From dp at simplexum.com  Thu Aug  8 11:37:50 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Thu, 8 Aug 2019 16:37:50 +0500
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <-6u9Ut_oYRThO21GIO1G8u4LpKavq2okw0Z7KoIM0tgwg4mAYXt2TP-SgiigMofdvLhvRuwX_q7Op6DUDM_eWUCjGmIEL_VTLpAeYDNOl5c=@protonmail.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
	<20190807201017.2a03b971@simplexum.com>
	<jyEbDqD57bjrjd1QF72bLHmubrQxdc-WVqONP0gx-PjixLnQrLwWn9A2W_MkWwkTi_aJHSuUcLfxh2JnRp71110TtNNv8ZoDIhWAXFmuT5c=@protonmail.com>
	<-6u9Ut_oYRThO21GIO1G8u4LpKavq2okw0Z7KoIM0tgwg4mAYXt2TP-SgiigMofdvLhvRuwX_q7Op6DUDM_eWUCjGmIEL_VTLpAeYDNOl5c=@protonmail.com>
Message-ID: <20190808163750.57f4e620@simplexum.com>

? Thu, 08 Aug 2019 09:35:24 +0000
ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> <MuSig(all participants *except* this participant)> OP_CHECKSIGVERIFY
> <participant_snitch_key> OP_CHECKSIG

This anti-snitch protection won't work if there are two snitches, which
is concievable in the case of a large-scale consolidated bonds (one
entity can pretend to be two independent entities with two different
TXO). The snitch co-conspirator will refuse to sign the punishment
transaction.

If you change the MuSig(all_except_snitch) to 1-of-n multisig
construction so that anyone other than the actual 'snitch' can
confiscate the snitch-bond, then there's possibility that that a
co-conspirator can get that bond before others - even before
the sntich transaction is distributed to takers.

It seems that to reasonably protect from more than one snitch with this
punishment scheme, you want to make a multitude of taproot leaves where
each leaf can be spent by cooperation of N entities, where N is the
size of expected non-snitch participant set.

> Finally, aggregation is still possible to insure by off-blockchain
> agreements, possibly with legal consequences, and thus entities like
> exchanges might still be able to aggregate funds and acquire an
> undeservedly large weight in the fidelity bond system.

This seems to me like the most immediate problem for the discussed
system.

Since the centralized exchanges or other custodial services already
control TXOs of their customers who sent their funds there, they can
use them to make extra profit with joinmarket, and create fidelity
bonds out of these TXO with (or without) consent of the customers, and
pay them (or not) the amount according to their UTXO, while getting the
consolidation benefit of V^2 for themselves. It is also more probable
that such centralized custodial services would be willing to
participate in a deanonymization efforts, so that they can explain
their participation in coinjoins to regulators.

From dp at simplexum.com  Thu Aug  8 12:05:05 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Thu, 8 Aug 2019 17:05:05 +0500
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <20190807201017.2a03b971@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<94534006-D560-4C90-9D5D-A3A64B698518@gmail.com>
	<20190726143738.0be561da@simplexum.com>
	<3c328312-2bdd-60d9-7425-8db620d09abb@riseup.net>
	<20190731205018.10ed4302@simplexum.com>
	<ae32dcbb-c950-3b3f-22b9-d152d6b221cb@riseup.net>
	<20190802145057.7b81c597@simplexum.com>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
	<20190807201017.2a03b971@simplexum.com>
Message-ID: <20190808170505.4169585f@simplexum.com>

? Wed, 7 Aug 2019 20:10:17 +0500
Dmitry Petukhov via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
wrote:

> In shared ownership rent scheme that ZmnSCPxj described in [1],
> the 'TXO rentier' has a signed timelocked 'backout' transaction that
> spends the locked TXO, and assigns the reward to rentier.
> 
> If we say that any transaction that spends any TXO in the bond
> (ignoring the timelock), invalidates the bond when presented to
> takers, then TXO rentier can revoke the bond by simply
> publishing this transaction (not to the blockchain, but by some other
> means so that takers can receive it).
> 
> The transaction validity can be verified, with the relaxed rules that
> ignores the timelock. After it is verified, takers mark the whole
> bond as revoked and will not consider it when chosing makers.

The backout transaction might not be timelocked itself, but can depend
on another timelocked transaction (made specifically to avoid the
backout transaction be timelocked). That extra transaction will need to
be broadcast before the backout transaction.

To account for that possibility, takers would need to either use more
relaxed verification rules (do not check if the inputs of the 'snitch
transaction' exist), or would need to check the whole package of
dependent transactions in which the last one spends the bond. 

From ZmnSCPxj at protonmail.com  Thu Aug  8 13:59:13 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 08 Aug 2019 13:59:13 +0000
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
	attacks using fidelity bonds
In-Reply-To: <20190808163750.57f4e620@simplexum.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
	<20190807201017.2a03b971@simplexum.com>
	<jyEbDqD57bjrjd1QF72bLHmubrQxdc-WVqONP0gx-PjixLnQrLwWn9A2W_MkWwkTi_aJHSuUcLfxh2JnRp71110TtNNv8ZoDIhWAXFmuT5c=@protonmail.com>
	<-6u9Ut_oYRThO21GIO1G8u4LpKavq2okw0Z7KoIM0tgwg4mAYXt2TP-SgiigMofdvLhvRuwX_q7Op6DUDM_eWUCjGmIEL_VTLpAeYDNOl5c=@protonmail.com>
	<20190808163750.57f4e620@simplexum.com>
Message-ID: <ybzcv93zmtmV9rve96W4Sti2pip5WSqzMgDsCXUOB4nFSd3EIfZ7IEmVAQNeF7VTIEY9giHjX_Xisnw2h9lCp7ZzQ_jUT043pblf-jW_J3Q=@protonmail.com>

Good morning Dmitry,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, August 8, 2019 7:37 PM, Dmitry Petukhov <dp at simplexum.com> wrote:

> ? Thu, 08 Aug 2019 09:35:24 +0000
> ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
>
> > <MuSig(all participants except this participant)> OP_CHECKSIGVERIFY
> > <participant_snitch_key> OP_CHECKSIG
>
> This anti-snitch protection won't work if there are two snitches, which
> is concievable in the case of a large-scale consolidated bonds (one
> entity can pretend to be two independent entities with two different
> TXO). The snitch co-conspirator will refuse to sign the punishment
> transaction.
>
> If you change the MuSig(all_except_snitch) to 1-of-n multisig
> construction so that anyone other than the actual 'snitch' can
> confiscate the snitch-bond, then there's possibility that that a
> co-conspirator can get that bond before others - even before
> the sntich transaction is distributed to takers.

The correct way to do this, as with any offchain technique, is to have the punishment transactions signed by the MuSig-of-everyone-other-than-punishment-target before you even sign the funding transaction.
If consolidation is subsidized by paying rent out to the consolidators, then the lessee of the UTXOs adds its rent payment in the same transaction that atomically instantiates the fidelity bond and all revocable bonds as a single CoinJoined transaction.
If any participant refuses to sign the punishment transactions of their co-consolidators, then the lessee refuses to sign the funding transaction and nobody earns any rent and the lessee goes look for another set of UTXO owners (or just kicks out the participant who refuses to sign and lives with the smaller fidelity bond, no big deal).

Of course, anyone renting consolidated bonds can themselves be unironic victims of sybil attackers who split up their funds to smaller parts so that their liability when later snitching is reduced, possibly to a level that is comfortable to them.
The sybil attacker then pretends to be lessors of UTXOs.

>
> It seems that to reasonably protect from more than one snitch with this
> punishment scheme, you want to make a multitude of taproot leaves where
> each leaf can be spent by cooperation of N entities, where N is the
> size of expected non-snitch participant set.
>
> > Finally, aggregation is still possible to insure by off-blockchain
> > agreements, possibly with legal consequences, and thus entities like
> > exchanges might still be able to aggregate funds and acquire an
> > undeservedly large weight in the fidelity bond system.
>
> This seems to me like the most immediate problem for the discussed
> system.
>
> Since the centralized exchanges or other custodial services already
> control TXOs of their customers who sent their funds there, they can
> use them to make extra profit with joinmarket, and create fidelity
> bonds out of these TXO with (or without) consent of the customers, and
> pay them (or not) the amount according to their UTXO, while getting the
> consolidation benefit of V^2 for themselves. It is also more probable
> that such centralized custodial services would be willing to
> participate in a deanonymization efforts, so that they can explain
> their participation in coinjoins to regulators.

Yes, down with the V^2 superlinearity, it is too strongly centralizing.

Regards,
ZmnSCPxj

From belcher at riseup.net  Thu Aug  8 20:06:07 2019
From: belcher at riseup.net (Chris Belcher)
Date: Thu, 8 Aug 2019 21:06:07 +0100
Subject: [bitcoin-dev] Improving JoinMarket's resistance to sybil
 attacks using fidelity bonds
In-Reply-To: <ybzcv93zmtmV9rve96W4Sti2pip5WSqzMgDsCXUOB4nFSd3EIfZ7IEmVAQNeF7VTIEY9giHjX_Xisnw2h9lCp7ZzQ_jUT043pblf-jW_J3Q=@protonmail.com>
References: <985792b1-e7aa-677b-a7a1-6a5f672da884@riseup.net>
	<ad501873-8912-765e-8df5-c9b0451fcd0a@riseup.net>
	<20190807015541.3d8aa849@simplexum.com>
	<20190807023742.73750ba3@simplexum.com>
	<483af6d0-ac5a-0e22-da29-af0be5196c15@riseup.net>
	<20190807201017.2a03b971@simplexum.com>
	<jyEbDqD57bjrjd1QF72bLHmubrQxdc-WVqONP0gx-PjixLnQrLwWn9A2W_MkWwkTi_aJHSuUcLfxh2JnRp71110TtNNv8ZoDIhWAXFmuT5c=@protonmail.com>
	<-6u9Ut_oYRThO21GIO1G8u4LpKavq2okw0Z7KoIM0tgwg4mAYXt2TP-SgiigMofdvLhvRuwX_q7Op6DUDM_eWUCjGmIEL_VTLpAeYDNOl5c=@protonmail.com>
	<20190808163750.57f4e620@simplexum.com>
	<ybzcv93zmtmV9rve96W4Sti2pip5WSqzMgDsCXUOB4nFSd3EIfZ7IEmVAQNeF7VTIEY9giHjX_Xisnw2h9lCp7ZzQ_jUT043pblf-jW_J3Q=@protonmail.com>
Message-ID: <4026143f-0af1-ad06-22c6-a6928c7b342b@riseup.net>

Hello list,

Two points:

* The V^2 term is the only thing in the whole scheme that provides any
sybil protection. I've already gone through the reasoning in an earlier
email and the maths is clear; in a scheme with linear V honest makers
have no economic advantage over sybil attackers. This is because only a
sybil attacker needs to split up their money into multiple fidelity
bonds, and that comes with a penalty under the V^2 rule.

It's worth reiterating that including a single evil maker in a
JoinMarket coinjoin does not ruin it's privacy. Privacy is only ruined
if *all* makers in a coinjoin are controlled by the same entity. So if
takers use one maker who has rented TXOs, then its no big deal as long
as the other included makers are controlled by other people. Therefore
when balancing the harms, consolidation into fewer makers is not as bad
as having no sybil protection (which as a reminder means that *all*
makers are controlled by one entity), and so the V^2 term does more good
than harm.

We can't condemn the V^2 rule because of consolidation without
acknowledging the good it does in penalizing sybil attacks.

* Regarding entities like exchanges running makers. They can also do
this today with JoinMarket, the proposed fidelity bond scheme doesn't
make that worse. It's an underlying assumption of JoinMarket that
coinjoining power is proportional to bitcoin ownership (in a similar way
that an underlying assumption of bitcoin is that transaction
confirmation power is proportional to hashpower). If those big exchanges
find that coinjoins involving them included just one maker controlled by
someone else then their aim of deanonymization will have failed. And
then those exchanges have to explain to their regulators why they helped
hide the origin and destination of some black market money.

From laanwj at gmail.com  Fri Aug  9 10:30:43 2019
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Fri, 9 Aug 2019 12:30:43 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.18.1 released
Message-ID: <20190809103043.x3nyimcpub6armaq@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version 0.18.1 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.18.1/>

Or through BitTorrent:

    magnet:?xt=urn:btih:c3ba0cfee3ef8413098ac5e81db08a2670e9da8c&dn=bitcoin-core-0.18.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969
    
This is a new minor version release, including new features, various bug
fixes and performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has
completely shut down (which might take a few minutes for older
versions), then run the installer (on Windows) or just copy over
`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on
Linux).

The first time you run version 0.15.0 or newer, your chainstate database
will be converted to a new format, which will take anywhere from a few
minutes to half an hour, depending on the speed of your machine.

Note that the block database format also changed in version 0.8.0 and
there is no automatic upgrade code from before version 0.8 to version
0.15.0 or later. Upgrading directly from 0.7.x and earlier without
redownloading the blockchain is not supported.  However, as usual, old
wallet versions are still supported.

Compatibility
==============

Bitcoin Core is supported and extensively tested on operating systems
using the Linux kernel, macOS 10.10+, and Windows 7 and newer. It is not
recommended to use Bitcoin Core on unsupported systems.

Bitcoin Core should also work on most other Unix-like systems but is not
as frequently tested on them.

- From 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is
built using Qt 5.9.x, which doesn't support versions of macOS older than
10.10. Additionally, Bitcoin Core does not yet change appearance when
macOS "dark mode" is activated.

Known issues
============

Wallet GUI
- ----------

For advanced users who have both (1) enabled coin control features, and
(2) are using multiple wallets loaded at the same time: The coin control
input selection dialog can erroneously retain wrong-wallet state when
switching wallets using the dropdown menu. For now, it is recommended
not to use coin control features with multiple wallets loaded.

0.18.1 change log
=================

### P2P protocol and network code
- - #15990 Add tests and documentation for blocksonly (MarcoFalke)
- - #16021 Avoid logging transaction decode errors to stderr (MarcoFalke)
- - #16405 fix: tor: Call `event_base_loopbreak` from the event's callback (promag)
- - #16412 Make poll in InterruptibleRecv only filter for POLLIN events (tecnovert)

### Wallet
- - #15913 Add -ignorepartialspends to list of ignored wallet options (luke-jr)

### RPC and other APIs
- - #15991 Bugfix: fix pruneblockchain returned prune height (jonasschnelli)
- - #15899 Document iswitness flag and fix bug in converttopsbt (MarcoFalke)
- - #16026 Ensure that uncompressed public keys in a multisig always returns a legacy address (achow101)
- - #14039 Disallow extended encoding for non-witness transactions (sipa)
- - #16210 add 2nd arg to signrawtransactionwithkey examples (dooglus)
- - #16250 signrawtransactionwithkey: report error when missing redeemScript/witnessScript (ajtowns)

### GUI
- - #16044 fix the bug of OPEN CONFIGURATION FILE on Mac (shannon1916)
- - #15957 Show "No wallets available" in open menu instead of nothing (meshcollider)
- - #16118 Enable open wallet menu on setWalletController (promag)
- - #16135 Set progressDialog to nullptr (promag)
- - #16231 Fix open wallet menu initialization order (promag) 
- - #16254 Set `AA_EnableHighDpiScaling` attribute early (hebasto) 
- - #16122 Enable console line edit on setClientModel (promag) 
- - #16348 Assert QMetaObject::invokeMethod result (promag)

### Build system
- - #15985 Add test for GCC bug 90348 (sipa)
- - #15947 Install bitcoin-wallet manpage (domob1812)
- - #15983 build with -fstack-reuse=none (MarcoFalke)

### Tests and QA
- - #15826 Pure python EC (sipa)
- - #15893 Add test for superfluous witness record in deserialization (instagibbs)
- - #14818 Bugfix: test/functional/rpc_psbt: Remove check for specific error message that depends on uncertain assumptions (luke-jr)
- - #15831 Add test that addmultisigaddress fails for watchonly addresses (MarcoFalke)

### Documentation
- - #15890 Remove text about txes always relayed from -whitelist (harding)

### Miscellaneous
- - #16095 Catch by reference not value in wallettool (kristapsk)
- - #16205 Replace fprintf with tfm::format (MarcoFalke)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Andrew Chow
- - Anthony Towns
- - Chris Moore
- - Daniel Kraft
- - David A. Harding
- - fanquake
- - Gregory Sanders
- - Hennadii Stepanov
- - John Newbery
- - Jonas Schnelli
- - Jo?o Barbosa
- - Kristaps Kaupe
- - Luke Dashjr
- - MarcoFalke
- - MeshCollider
- - Pieter Wuille
- - shannon1916
- - tecnovert
- - Wladimir J. van der Laan

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl1NSt4ACgkQHkrtYphs
0l0IEQf+PwMCgx93D/O2E3mbEXA/+CoIkqLHWGSsEUv0imtu/cS4HOVtG21EpBUK
6cbjjfnCQ+Cof3qiSdavStbIsGkLoeErx2RgmJXTSjNB8SSQbKGEAlQClged5vyz
CwmmuK/ZoSe2pxLPvO7C08nVdvtW9zvICMmSQt6kwpzEM5IePHC0SJV1akGmupWh
/d1B9LaCjtJvNZC8R0PxXoIci2Yy6JiqBjDY0UE8oATOA226cwSX/0JVccJnhL/O
4UepBnAqWoeKDNsFecuiyW08aZZlKg7oUmkNV6iFawUKW/YsYSnJmoK6t87S//h3
Ny5gdddWLY7HSRS3YcKMlq1GYefV0A==
=Ue9Z
-----END PGP SIGNATURE-----

From chris.haoyul at gmail.com  Fri Aug  9 13:35:19 2019
From: chris.haoyul at gmail.com (Haoyu LIN)
Date: Fri, 9 Aug 2019 21:35:19 +0800
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
Message-ID: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>

Hi everybody!

Runchao, Jiangshan (both CC'ed) and I bring up a BIP draft that describes a
new opcode OP_LOOKUP_OUTPUT, which is used for mitigating the arbitrage
risk in a HTLC-based Atomic Swap.

The problem is called the "free premium problem", where the initiator can
abort the deal (i.e. have optionality) without any penalty. See
https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-May/001292.html
and
https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-December/001752.html
for detail.

We have investigated this problem in very detail. We analysed how
profitable the arbitrage can be given the default timelock setting (24/48
hrs). Our result shows that the profit can be approximately 1% ~ 2.3%,
which is non-negligible compared with 0.3% for stock market. This can be
attractive as it's totally risk-free. Please refer to our paper
https://eprint.iacr.org/2019/896, and the related code
https://github.com/HAOYUatHZ/fair-atomic-swap if interested.

Several studies have proposed for solving this problem e.g.,
http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/
and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is
that, the transaction for the premium needs to be locked with the same
secret hash but with a flipped payout, i.e. when redeemed with the secret,
the money goes back to Alice and after timelock, the premium goes to Bob as
a compensation for Alice not revealing the secret. However, this introduces
a new problem: Bob can get the premium without paying anything, by never
participating in.

To solve this, the transaction verifier needs to know the status of an
dependent transaction. Unfortunately, Bitcoin does not support the stateful
transaction functionalities. Therefore, we propose the new opcode:
OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of
the output?s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide
whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT
<pubkeyhash> OP_EQUALVERIFY`.

Assume that Alice and Bob exchange asset1 and asset2, and using premium
(same asset type as asset2) as the collateral.

A sample premium transaction implementation of Atmoic Swap for Spot based
on this opcode is:

```
ScriptSig:
    Redeem: <Bob_sig> <Bob_pubkey> 1
    Refund: <Alice_sig> <Alice_pubkey> 0
ScriptPubKey:
    OP_IF // Normal redeem path
        // the owner of <asset2_output> should be Alice
        // which means Alice has redeemed asset2
        <asset2_output> OP_LOOKUP_OUTPUT <Alice_pubkeyhash> OP_EQUALVERIFY
        OP_DUP OP_HASH160 <Bob_pubkeyhash>
    OP_ELSE // Refund path
        // the premium timelock should be expired
        <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_DUP OP_HASH160 <Alice pubkey hash>
    OP_ENDIF
    OP_EQUALVERIFY
    OP_CHECKSIG
```

We also explore the Atomic Swaps in American Call Options scenario, which
is different from the Spot scenario. Alice should pay for the premium
besides the underlying asset, regardless of whether the swap is successful
or not. In reality, the option sellers are trustworthy - the option sellers
never abort the contract. However, in Atomic Swaps, Bob can abort the
contracts like Alice. To keep the Atomic Swap consistent with the American
Call Options, the premium should follow that: Alice pays the premium to Bob
if 1) Alice redeems Bob?s asset before Bob?s timelock, or 2) Bob refunds
his asset after Bob?s timelock but before Alice?s timelock. If Alice?s
timelock expires, Alice can refund her premium back.

A sample premium transaction implementation of Atmoic Swap for Option based
on this opcode is:

```
ScriptSig:
    Redeem: <Bob_sig> <Bob_pubkey> 1
    Refund: <Alice_sig> <Alice_pubkey> 0
ScriptPubKey:
    OP_IF // Normal redeem path
        // the owner of the asset2 should not be the contract
        // it should be either (redeemde by) Alice or (refunded by) Bob
        // which means Alice has redeemed asset2
        <asset2_output> OP_LOOKUP_OUTPUT <Alice_pubkeyhash> OP_NUMEQUAL
        <asset2_output> OP_LOOKUP_OUTPUT <Bob_pubkeyhash> OP_NUMEQUAL
        OP_ADD 1 OP_NUMEQUALVERIFY
        OP_DUP OP_HASH160 <Bob_pubkeyhash>
    OP_ELSE // Refund path
        // the premium timelock should be expired
        <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP
        OP_DUP OP_HASH160 <Alice pubkey hash>
    OP_ENDIF
    OP_EQUALVERIFY
    OP_CHECKSIG
```

Again, please refer to https://eprint.iacr.org/2019/896 if you need more
detail. The BIP draft can be found at
https://github.com/HAOYUatHZ/bips/blob/bip-lookup_output/bip-lookup_output.mediawiki

To conclude, in order to avoid the risk-free optionality in Atomic Swap, we
propose a new opcode OP_LOOKUP_OUTPUT, using premium to mitigate the risk
of Atomic Swap both in Spot and in Option.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190809/ae4a89c7/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Aug  9 14:29:25 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 09 Aug 2019 14:29:25 +0000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
Message-ID: <qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>

Good morning Haoyu LIN et al.,


> We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap if interested.
>
> Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
>
> To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output?s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.

I believe an unsaid principle of SCRIPT opcode design is this:

* No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.

This issue underlies the previous `OP_PUBREF` proposal also.

The reason for this is:

* We support a pruning mode, where in only the UTXO set is retained.
  If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.
* The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.
  Thus it cannot get information about the block it is in.
  Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.

In any case:

> However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.

Premium payment can be made contingent on Bob participating.
Of course, it does mean the premium is paid using the destination coin.
It also requires the destination coin to support SegWit.

Let me explain by this:

1.  Alice and Bob agree on swap parameters:
    * Alice will exchange 1 BTC for 1,000,000 WJT from Bob.
    * Alice will pay 10,000 WJT as premium to Bob.
    * Alice will lock BTC for 48 hours.
    * Bob will lock WJT for 24 hours.
    * The protocol will start at particular time T.
2.  Alice generates a preimage+hash.
3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.
4.  Alice presents above UTXO to Bob.
5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.
6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.
    This pays out to 1,010,000 WJT (the value plus the premium) HTLC.
    The hashlock branch requires not just Alice, but also Bob.
    The timelock branch at T+24 just requires Bob.
7.  Alice and Bob generate the claim transaction.
    This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.
8.  Alice and Bob sign the claim transaction.
    This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.
9.  Alice and Bob sign the funding transaction and broadcast it.
10.  Alice completes the claim transaction by adding the preimage and broadcasts it.
11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.

If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.
After step 9, Bob has been forced to participate and cannot back out and claim the premium only.

This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html


In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html
The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.


Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.

Regards,
ZmnSCPxj

From elichai.turkel at gmail.com  Fri Aug  9 14:58:58 2019
From: elichai.turkel at gmail.com (Elichai Turkel)
Date: Fri, 9 Aug 2019 10:58:58 -0400
Subject: [bitcoin-dev] Taproot proposal
Message-ID: <CALN7hCJ7dCER9zaQbXvT4AVt95cZwBsQcTX8XvvZwF-1xa-V4w@mail.gmail.com>

Hi,
I want to add to John Newbery's suggestion of using implicit even/odd only
public keys and tweaked public keys in taproot and suggest the following:

If everything is implicit then the only reason for the first byte of the
control block(`c[0]`) is the tapscript leaf version.
I suggest that this is moved to be the first OP_CODE of the tapscript
itself (i.e. OP_0/OP_1 etc.)
That way having the script *tells* you what does it mean without needing to
check the control block.
That way there's a separation between the tapscript+leaf version and the
control block being the merkle path to the script.
-- 
PGP: 5607C93B5F86650C
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190809/8b965583/attachment.html>

From pieter.wuille at gmail.com  Fri Aug  9 18:16:29 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Fri, 9 Aug 2019 11:16:29 -0700
Subject: [bitcoin-dev] 32-byte public keys in Schnorr and Taproot
Message-ID: <CAPg+sBhDQ5yS-BemRWqSxV7TJaWNFs7d-zD6p5HtquFwUjDdsg@mail.gmail.com>

Hello all,

It has been suggested [1] to drop the Y oddness bit in the witness
program for Taproot outputs. This seems like a worthwhile change, as:
* The bit doesn't actually contribute to security.
* It avoids Taproot outputs from being more expensive to create than v0 P2WSH.
* It doesn't preclude future changes that would still need the
additional byte anyway.

In exploring that option, Jonas Nick found that it seems cleanest [2]
to actually introduce a type of 32-byte public keys (which implicitly
have an even Y coordinate) in bip-schnorr, with associated signing and
verification logic that are distinct from the 33-byte variant.

This makes me wonder if we need 33-byte public keys at all.

So I'd like to hear opinions about modifying bip-schnorr to only
define 32-byte public keys. The implications of that would be:
* bip-schnorr public keys wouldn't be exactly the same as ECDSA public
keys, however all derivation logic would still apply (BIP32,
mnemonics, xpubs, ... would still exist and be compatible - just the
first pubkey byte would be dropped at the end).
* The Q point in bip-taproot (the one going in the scriptPubKey) would
just follow the 32-byte pubkey encoding, rather than needing a 33rd
byte.
* The P point in bip-taproot (the internal key revealed during script
path) would become just a 32-byte public key (and we can drop the one
bit in the control block to transmit the oddness of the Y coordinate
of P).
* In order to permit batch verification of the P to Q tweaking for
script-path spending, another control block bit is now needed, namely
one that indicates whether a negation was needed to make P+H(P||m)*G's
Y coordinate even.
* All public keys inside bip-tapscript would also become 32-bytes. If
desired, the "upgradable public key" construction in bip-tapscript can
be kept, by triggering based on the length of public keys (rather than
based on their first byte).

One question is whether it's worth such a change to bip-schnorr at
this point. We've purposefully never progressed it past draft since
publishing [3], but it has been a while. If necessary, it's possible
to keep verification compatible by still hashing the implied "even"
byte inside the scheme (which commits to the pubkey), but if we're
going to change things, it's perhaps best to do it as cleanly as
possible and also drop that byte.

Opinions?

  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016943.html
  [2] https://github.com/sipa/bips/pull/52
  [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html

Cheers,

-- 
Pieter

From pieter.wuille at gmail.com  Fri Aug  9 18:29:55 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Fri, 9 Aug 2019 11:29:55 -0700
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CALN7hCJ7dCER9zaQbXvT4AVt95cZwBsQcTX8XvvZwF-1xa-V4w@mail.gmail.com>
References: <CALN7hCJ7dCER9zaQbXvT4AVt95cZwBsQcTX8XvvZwF-1xa-V4w@mail.gmail.com>
Message-ID: <CAPg+sBgyhjRmVdtC1bGWkpaTtMqQRsCqKjFB=LU_fcMYUJc6jA@mail.gmail.com>

On Fri, 9 Aug 2019 at 08:02, Elichai Turkel via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi,

Since the idea of implicitly even pubkeys has potentially more general
implications, I've started a separate thread [1] about that idea.

> I want to add to John Newbery's suggestion of using implicit even/odd only public keys and tweaked public keys in taproot and suggest the following:
> If everything is implicit then the only reason for the first byte of the control block(`c[0]`) is the tapscript leaf version.

That's unfortunately not correct. If we want to maintain
batch-verifiability of the taproot tweaking (the Q = P + H(P,m)G
relation), we still need a bit in the control block to convey whether
a negation was necessary to make P+H(P,m)G even, even if P and Q both
have implied-even Y coordinates. Not doing that would require
exploring 2^n combinations to batch verify n relations, obviously
destroying any performance savings the batch verification had in the
first place.

> I suggest that this is moved to be the first OP_CODE of the tapscript itself (i.e. OP_0/OP_1 etc.)
> That way having the script *tells* you what does it mean without needing to check the control block.
> That way there's a separation between the tapscript+leaf version and the control block being the merkle path to the script.

If we keep the leaf version idea (it's possible to instead just rely
entirely on OP_SUCCESSx, and drop leaf versions), my preference is to
still keep it separate from script, though just for a fairly banal
reason: that way the script consists entirely of opcodes and can be
treated uniformly by debug tools, rather than needing to treat the
first byte special. I do understand your preference too, but I don't
know how it weighs up.

  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017247.html

Cheers,

-- 
Pieter

From ChristopherA at lifewithalacrity.com  Fri Aug  9 18:37:13 2019
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Fri, 9 Aug 2019 11:37:13 -0700
Subject: [bitcoin-dev] 32-byte public keys in Schnorr and Taproot
In-Reply-To: <CAPg+sBhDQ5yS-BemRWqSxV7TJaWNFs7d-zD6p5HtquFwUjDdsg@mail.gmail.com>
References: <CAPg+sBhDQ5yS-BemRWqSxV7TJaWNFs7d-zD6p5HtquFwUjDdsg@mail.gmail.com>
Message-ID: <CACrqygAn0Zq5nseVRUojm0_OLdV=ioPX+1FmUmBvU2NeGzH27w@mail.gmail.com>

On Fri, Aug 9, 2019 at 11:17 AM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> if we're going to change things, it's perhaps best to do it as cleanly as
> possible and also drop that byte.
>

I personally lean toward just dropping the byte. I like the simplicity and
I really like 32 bytes. 33 seems so over the edge and so odd ;-)

Yes, there may be some prototype implementations out there that did some
extra work, and will need to be revised, but that is always the risk
developers take when writing code when the spec hasn't fully been
implemented yet.

If you do revise the spec, would you consider proposing a format for
sharing public keys in a non-binary form, maybe using bech32? Given some of
the protocols emerging that may use Schnorr public keys in novel ways,
having a single encoding format for them would be useful.

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190809/663436d5/attachment.html>

From runchao.han at monash.edu  Sat Aug 10 05:46:35 2019
From: runchao.han at monash.edu (Runchao Han)
Date: Sat, 10 Aug 2019 15:46:35 +1000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
Message-ID: <D380D3EA-981C-44B7-A744-7E482B2347BC@monash.edu>

Hi ZmnSCPxj,

Thanks for your reply.

I agree with your opinions about OP_LOOKUP_OUTPUT.
Indeed, the pruning mechanism renders this opcode unrealistic for some nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of verifying this tx. 

However, I?m concerning of some security issues of your mentioned protocol (Alice pays the premium contingently on Bob participating).
If I understand it right, Alice and Bob should create a payment channel, and mutually construct the funding transaction that ?Alice pays Bob 10,000 WJT; Bob hash-timelocked pays Alice 1,000,000WJT?, where the time lock is T+24.
Here, Bob is responsible for broadcasting this tx after confirming Alice?s funding transaction on BTC blockchain.
In this case, Bob can arbitrage by broadcasting this tx *after T+24*. In this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT anymore.
If the premium (10,000WJT) is also hash-timelocked, Alice can keep unraveling the preimage, which makes the atomic swap still premium-free.

In the original atomic swap, Bob is incentivised to broadcast his funding transaction, otherwise he may miss the opportunity to redeem Alice?s asset.
Also, Alice will lose nothing regardless of how Bob behaves, because Alice locks all her money by hashlock.
However, Alice cannot lock the premium using hashlock. This gives Bob opportunity to arbitrage Alice?s premium.

What is implied here is that, where the premium should go strictly depends on where Bob?s asset goes.
If the Bitcoin?s timelock can be ?relative? (e.g. the timestamp can be x+24 where x is the timestamp of the block with this transaction), I think this protocol works.
Unfortunately, the ?x? here is also an external state according to your definition.

In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable, but cannot make sure if the premium mechanism can be implemented by using HTLCs.

Thanks,
Runchao

> On 10 Aug 2019, at 12:29 am, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Haoyu LIN et al.,
> 
> 
>> We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap if interested.
>> 
>> Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
>> 
>> To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output?s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.
> 
> I believe an unsaid principle of SCRIPT opcode design is this:
> 
> * No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.
> 
> This issue underlies the previous `OP_PUBREF` proposal also.
> 
> The reason for this is:
> 
> * We support a pruning mode, where in only the UTXO set is retained.
>  If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.
> * The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.
>  Thus it cannot get information about the block it is in.
>  Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.
> 
> In any case:
> 
>> However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
> 
> Premium payment can be made contingent on Bob participating.
> Of course, it does mean the premium is paid using the destination coin.
> It also requires the destination coin to support SegWit.
> 
> Let me explain by this:
> 
> 1.  Alice and Bob agree on swap parameters:
>    * Alice will exchange 1 BTC for 1,000,000 WJT from Bob.
>    * Alice will pay 10,000 WJT as premium to Bob.
>    * Alice will lock BTC for 48 hours.
>    * Bob will lock WJT for 24 hours.
>    * The protocol will start at particular time T.
> 2.  Alice generates a preimage+hash.
> 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.
> 4.  Alice presents above UTXO to Bob.
> 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.
> 6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.
>    This pays out to 1,010,000 WJT (the value plus the premium) HTLC.
>    The hashlock branch requires not just Alice, but also Bob.
>    The timelock branch at T+24 just requires Bob.
> 7.  Alice and Bob generate the claim transaction.
>    This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.
> 8.  Alice and Bob sign the claim transaction.
>    This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.
> 9.  Alice and Bob sign the funding transaction and broadcast it.
> 10.  Alice completes the claim transaction by adding the preimage and broadcasts it.
> 11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.
> 
> If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.
> After step 9, Bob has been forced to participate and cannot back out and claim the premium only.
> 
> This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html
> 
> 
> In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html
> The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.
> 
> 
> Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.
> 
> Regards,
> ZmnSCPxj


From ZmnSCPxj at protonmail.com  Sat Aug 10 12:50:18 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 10 Aug 2019 12:50:18 +0000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
Message-ID: <aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>

Good morning Runchao,




Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, August 10, 2019 1:44 PM, Runchao Han <runchao.han at monash.edu> wrote:

> Hi ZmnSCPxj,
>
> Thanks for your reply.
>
> I agree with your opinions about OP_LOOKUP_OUTPUT.
> Indeed, the pruning mechanism renders this opcode unrealistic for some nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of verifying this tx.
>
> However, I?m concerning of some security issues of your mentioned protocol (Alice pays the premium contingently on Bob participating).
> If I understand it right, Alice and Bob should create a payment channel, and mutually construct the funding transaction that ?Alice pays Bob 10,000 WJT; Bob hash-timelocked pays Alice 1,000,000WJT?, where the time lock is T+24.
> Here, Bob is responsible for broadcasting this tx after confirming Alice?s funding transaction on BTC blockchain.

No, Bob is not.

The signature exchange for the WJT-side funding tx is done by:

1. Alice waits for Bob to provide all its signatures for inputs that will fund the 1,000,000 WJT payout.
2. Alice signs its inputs that will fund the 10,000 WJT premium.
3. Alice broadacasts the completely signed funding tx.

Alice is the one responsible for broadcasting the funding tx.

If Bob stalls, it is not a Bob side option (i.e. Bob cannot stall then continue the protocol when the exchange rate moves to its favor) as Alice can refuse to sign and broadcast the funding tx once it has decided Bob is trolling it, thus Bob cannot force Alice to perform.

If Alice stalls, Bob can double-spend one of its inputs at a low feerate.
This either aborts the protocol, or if Alice then broadcasts the funding tx at the pre-agreed feerate and it is confirmed, the premium is now already paid to Bob.

Regards,
ZmnSCPxj

> In this case, Bob can arbitrage by broadcasting this tx after T+24. In this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT anymore.
> If the premium (10,000WJT) is also hash-timelocked, Alice can keep unraveling the preimage, which makes the atomic swap still premium-free.
>
> In the original atomic swap, Bob is incentivised to broadcast his funding transaction, otherwise he may miss the opportunity to redeem Alice?s asset.
> Also, Alice will lose nothing regardless of how Bob behaves, because Alice locks all her money by hashlock.
> However, Alice cannot lock the premium using hashlock. This gives Bob opportunity to arbitrage Alice?s premium.
>
> What is implied here is that, where the premium should go strictly depends on where Bob?s asset goes.
> If the Bitcoin?s timelock can be ?relative? (e.g. the timestamp can be x+24 where x is the timestamp of the block with this transaction), I think this protocol works.
> Unfortunately, the ?x? here is also an external state according to your definition.
>
> In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable, but cannot make sure if the premium mechanism can be implemented by using HTLCs.
>
> Thanks,
> Runchao
>
> > On 10 Aug 2019, at 12:29 am, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
> > Good morning Haoyu LIN et al.,
> >
> > > We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap if interested.
> > > Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
> > > To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output?s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.
> >
> > I believe an unsaid principle of SCRIPT opcode design is this:
> >
> > -   No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.
> >
> > This issue underlies the previous `OP_PUBREF` proposal also.
> > The reason for this is:
> >
> > -   We support a pruning mode, where in only the UTXO set is retained.
> >     If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.
> >
> > -   The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.
> >     Thus it cannot get information about the block it is in.
> >     Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.
> >
> >
> > In any case:
> >
> > > However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
> >
> > Premium payment can be made contingent on Bob participating.
> > Of course, it does mean the premium is paid using the destination coin.
> > It also requires the destination coin to support SegWit.
> > Let me explain by this:
> >
> > 1.  Alice and Bob agree on swap parameters:
> >
> > -   Alice will exchange 1 BTC for 1,000,000 WJT from Bob.
> > -   Alice will pay 10,000 WJT as premium to Bob.
> > -   Alice will lock BTC for 48 hours.
> > -   Bob will lock WJT for 24 hours.
> > -   The protocol will start at particular time T.
> >
> > 2.  Alice generates a preimage+hash.
> > 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.
> > 4.  Alice presents above UTXO to Bob.
> > 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.
> > 6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.
> >     This pays out to 1,010,000 WJT (the value plus the premium) HTLC.
> >     The hashlock branch requires not just Alice, but also Bob.
> >     The timelock branch at T+24 just requires Bob.
> >
> > 7.  Alice and Bob generate the claim transaction.
> >     This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.
> >
> > 8.  Alice and Bob sign the claim transaction.
> >     This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.
> >
> > 9.  Alice and Bob sign the funding transaction and broadcast it.
> > 10.  Alice completes the claim transaction by adding the preimage and broadcasts it.
> > 11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.
> >
> > If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.
> > After step 9, Bob has been forced to participate and cannot back out and claim the premium only.
> > This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html
> > In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html
> > The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.
> > Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.
> > Regards,
> > ZmnSCPxj



From runchao.han at monash.edu  Sat Aug 10 13:01:41 2019
From: runchao.han at monash.edu (Runchao Han)
Date: Sat, 10 Aug 2019 23:01:41 +1000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
	<aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
Message-ID: <CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>

If I remember it right, Alice first signs the WJT transaction, sends it to
Bob, then Bob signs it and makes this transaction valid.

If so, there are two problems.
First, Bob gets the valid tx first, and he can choose not to send it to
Alice.
Second, even if Bob honestly sends Alice this tx, Alice cannot fully
control when to broadcast this to, as Bob also has this transaction.

If Bob first signs then Alice signs, Alice still has optionality, as she
can choose whether to publish this tx and preimage.

Runchao

On Sat, Aug 10, 2019 at 10:50 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Runchao,
>
>
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Saturday, August 10, 2019 1:44 PM, Runchao Han <runchao.han at monash.edu>
> wrote:
>
> > Hi ZmnSCPxj,
> >
> > Thanks for your reply.
> >
> > I agree with your opinions about OP_LOOKUP_OUTPUT.
> > Indeed, the pruning mechanism renders this opcode unrealistic for some
> nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of
> verifying this tx.
> >
> > However, I?m concerning of some security issues of your mentioned
> protocol (Alice pays the premium contingently on Bob participating).
> > If I understand it right, Alice and Bob should create a payment channel,
> and mutually construct the funding transaction that ?Alice pays Bob 10,000
> WJT; Bob hash-timelocked pays Alice 1,000,000WJT?, where the time lock is
> T+24.
> > Here, Bob is responsible for broadcasting this tx after confirming
> Alice?s funding transaction on BTC blockchain.
>
> No, Bob is not.
>
> The signature exchange for the WJT-side funding tx is done by:
>
> 1. Alice waits for Bob to provide all its signatures for inputs that will
> fund the 1,000,000 WJT payout.
> 2. Alice signs its inputs that will fund the 10,000 WJT premium.
> 3. Alice broadacasts the completely signed funding tx.
>
> Alice is the one responsible for broadcasting the funding tx.
>
> If Bob stalls, it is not a Bob side option (i.e. Bob cannot stall then
> continue the protocol when the exchange rate moves to its favor) as Alice
> can refuse to sign and broadcast the funding tx once it has decided Bob is
> trolling it, thus Bob cannot force Alice to perform.
>
> If Alice stalls, Bob can double-spend one of its inputs at a low feerate.
> This either aborts the protocol, or if Alice then broadcasts the funding
> tx at the pre-agreed feerate and it is confirmed, the premium is now
> already paid to Bob.
>
> Regards,
> ZmnSCPxj
>
> > In this case, Bob can arbitrage by broadcasting this tx after T+24. In
> this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT
> anymore.
> > If the premium (10,000WJT) is also hash-timelocked, Alice can keep
> unraveling the preimage, which makes the atomic swap still premium-free.
> >
> > In the original atomic swap, Bob is incentivised to broadcast his
> funding transaction, otherwise he may miss the opportunity to redeem
> Alice?s asset.
> > Also, Alice will lose nothing regardless of how Bob behaves, because
> Alice locks all her money by hashlock.
> > However, Alice cannot lock the premium using hashlock. This gives Bob
> opportunity to arbitrage Alice?s premium.
> >
> > What is implied here is that, where the premium should go strictly
> depends on where Bob?s asset goes.
> > If the Bitcoin?s timelock can be ?relative? (e.g. the timestamp can be
> x+24 where x is the timestamp of the block with this transaction), I think
> this protocol works.
> > Unfortunately, the ?x? here is also an external state according to your
> definition.
> >
> > In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable,
> but cannot make sure if the premium mechanism can be implemented by using
> HTLCs.
> >
> > Thanks,
> > Runchao
> >
> > > On 10 Aug 2019, at 12:29 am, ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
> > > Good morning Haoyu LIN et al.,
> > >
> > > > We have investigated this problem in very detail. We analysed how
> profitable the arbitrage can be given the default timelock setting (24/48
> hrs). Our result shows that the profit can be approximately 1% ~ 2.3%,
> which is non-negligible compared with 0.3% for stock market. This can be
> attractive as it's totally risk-free. Please refer to our paper
> https://eprint.iacr.org/2019/896, and the related code
> https://github.com/HAOYUatHZ/fair-atomic-swap if interested.
> > > > Several studies have proposed for solving this problem e.g.,
> http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/
> and https://coblox.tech/docs/financial_crypto19.pdf. Their basic idea is
> that, the transaction for the premium needs to be locked with the same
> secret hash but with a flipped payout, i.e. when redeemed with the secret,
> the money goes back to Alice and after timelock, the premium goes to Bob as
> a compensation for Alice not revealing the secret. However, this introduces
> a new problem: Bob can get the premium without paying anything, by never
> participating in.
> > > > To solve this, the transaction verifier needs to know the status of
> an dependent transaction. Unfortunately, Bitcoin does not support the
> stateful transaction functionalities. Therefore, we propose the new opcode:
> OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of
> the output?s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide
> whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT
> <pubkeyhash> OP_EQUALVERIFY`.
> > >
> > > I believe an unsaid principle of SCRIPT opcode design is this:
> > >
> > > -   No SCRIPT opcode can look at anything that is not in the
> transaction spending from the SCRIPT.
> > >
> > > This issue underlies the previous `OP_PUBREF` proposal also.
> > > The reason for this is:
> > >
> > > -   We support a pruning mode, where in only the UTXO set is retained.
> > >     If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as
> `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early
> historical blocks.
> > >
> > > -   The SCRIPT interpreter is run only once, at the time the
> transaction enters the mempool.
> > >     Thus it cannot get information about the block it is in.
> > >     Instead, the SCRIPT interpreter can have as input only the
> transaction that is attempting to spend the SCRIPT.
> > >
> > >
> > > In any case:
> > >
> > > > However, this introduces a new problem: Bob can get the premium
> without paying anything, by never participating in.
> > >
> > > Premium payment can be made contingent on Bob participating.
> > > Of course, it does mean the premium is paid using the destination coin.
> > > It also requires the destination coin to support SegWit.
> > > Let me explain by this:
> > >
> > > 1.  Alice and Bob agree on swap parameters:
> > >
> > > -   Alice will exchange 1 BTC for 1,000,000 WJT from Bob.
> > > -   Alice will pay 10,000 WJT as premium to Bob.
> > > -   Alice will lock BTC for 48 hours.
> > > -   Bob will lock WJT for 24 hours.
> > > -   The protocol will start at particular time T.
> > >
> > > 2.  Alice generates a preimage+hash.
> > > 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and
> timelocked at T+48 going to Alice.
> > > 4.  Alice presents above UTXO to Bob.
> > > 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT
> premium to Bob.
> > > 6.  Alice and Bob generate, but do not sign, a funding transaction
> spending some of Bob coin as well as the premium coin from Alice.
> > >     This pays out to 1,010,000 WJT (the value plus the premium) HTLC.
> > >     The hashlock branch requires not just Alice, but also Bob.
> > >     The timelock branch at T+24 just requires Bob.
> > >
> > > 7.  Alice and Bob generate the claim transaction.
> > >     This spends the funding transaction HTLC output and pays out
> 1,000,000 WJT to Alice and 10,000 WJT to Bob.
> > >
> > > 8.  Alice and Bob sign the claim transaction.
> > >     This does not allow Bob to make the claim transaction valid by
> itself as it still requires the preimage, and at this point, only Alice
> knows the preimage.
> > >
> > > 9.  Alice and Bob sign the funding transaction and broadcast it.
> > > 10.  Alice completes the claim transaction by adding the preimage and
> broadcasts it.
> > > 11.  Bob sees the preimage on the WJT blockchain and claims the BTC
> using the preimage.
> > >
> > > If Bob stalls at step 8, then there is no way to claim the premium, as
> the funding transaction (which is the source of the claim transaction that
> pays the premium) is not valid yet.
> > > After step 9, Bob has been forced to participate and cannot back out
> and claim the premium only.
> > > This is basically this proposal:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html
> > > In addition, if you really want the premium to be denominated in BTC,
> I have a more complicated ritual:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html
> > > The described ritual only sets up the American Call Option, but by the
> time it has been set up, the premium has been paid already and the rest of
> the execution is claiming the American Call Option.
> > > Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.
> > > Regards,
> > > ZmnSCPxj
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190810/7ea46c36/attachment-0001.html>

From karljohan-alm at garage.co.jp  Sun Aug 11 06:08:48 2019
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Sun, 11 Aug 2019 15:08:48 +0900
Subject: [bitcoin-dev] 32-byte public keys in Schnorr and Taproot
In-Reply-To: <CAPg+sBhDQ5yS-BemRWqSxV7TJaWNFs7d-zD6p5HtquFwUjDdsg@mail.gmail.com>
References: <CAPg+sBhDQ5yS-BemRWqSxV7TJaWNFs7d-zD6p5HtquFwUjDdsg@mail.gmail.com>
Message-ID: <CALJw2w5=5vmO1jGyWU5XGorKX_UvyD2G+94SuBha1ZrX_ByK1A@mail.gmail.com>

Hello,

It makes no sense to me to not switch to 32-byte keys. There are
literally no (or very mild) disadvantages to this, from what it
appears like. I don't think refraining from updating a proposal just
because it's been out there for awhile is a valid reason, personally.

On Sat, Aug 10, 2019 at 3:17 AM Pieter Wuille via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hello all,
>
> It has been suggested [1] to drop the Y oddness bit in the witness
> program for Taproot outputs. This seems like a worthwhile change, as:
> * The bit doesn't actually contribute to security.
> * It avoids Taproot outputs from being more expensive to create than v0 P2WSH.
> * It doesn't preclude future changes that would still need the
> additional byte anyway.
>
> In exploring that option, Jonas Nick found that it seems cleanest [2]
> to actually introduce a type of 32-byte public keys (which implicitly
> have an even Y coordinate) in bip-schnorr, with associated signing and
> verification logic that are distinct from the 33-byte variant.
>
> This makes me wonder if we need 33-byte public keys at all.
>
> So I'd like to hear opinions about modifying bip-schnorr to only
> define 32-byte public keys. The implications of that would be:
> * bip-schnorr public keys wouldn't be exactly the same as ECDSA public
> keys, however all derivation logic would still apply (BIP32,
> mnemonics, xpubs, ... would still exist and be compatible - just the
> first pubkey byte would be dropped at the end).
> * The Q point in bip-taproot (the one going in the scriptPubKey) would
> just follow the 32-byte pubkey encoding, rather than needing a 33rd
> byte.
> * The P point in bip-taproot (the internal key revealed during script
> path) would become just a 32-byte public key (and we can drop the one
> bit in the control block to transmit the oddness of the Y coordinate
> of P).
> * In order to permit batch verification of the P to Q tweaking for
> script-path spending, another control block bit is now needed, namely
> one that indicates whether a negation was needed to make P+H(P||m)*G's
> Y coordinate even.
> * All public keys inside bip-tapscript would also become 32-bytes. If
> desired, the "upgradable public key" construction in bip-tapscript can
> be kept, by triggering based on the length of public keys (rather than
> based on their first byte).
>
> One question is whether it's worth such a change to bip-schnorr at
> this point. We've purposefully never progressed it past draft since
> publishing [3], but it has been a while. If necessary, it's possible
> to keep verification compatible by still hashing the implied "even"
> byte inside the scheme (which commits to the pubkey), but if we're
> going to change things, it's perhaps best to do it as cleanly as
> possible and also drop that byte.
>
> Opinions?
>
>   [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016943.html
>   [2] https://github.com/sipa/bips/pull/52
>   [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From runchao.han at monash.edu  Mon Aug 12 03:19:53 2019
From: runchao.han at monash.edu (Runchao Han)
Date: Mon, 12 Aug 2019 13:19:53 +1000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
	<aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
	<CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>
Message-ID: <212E8AD5-0EED-468E-8AFC-134611514CBC@monash.edu>

Good morning ZmnSCPxj,

Sorry for the ambiguity of my last email. It was Sunday and I wrote it in 1 min on my bed. Let me elaborate what we are thinking of here.



## Analysis on the protocol from Fournier et al.

In this protocol, Bob participates in the swap following the steps below:

1. Alice and Bob creates a payment channel on WJT blockchain.
2. Bob creates the WJT transaction using the joint account of Alice and Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice?s input for the 10,000 WJT premium. This transaction should be signed by both Alice and Bob in order to be valid.
3. Bob signs the WJT transaction and sends the WJT transaction to Alice.
4. Alice signs this WJT transaction. At this stage, Alice has both the valid BTC transaction and the valid WJT transaction.
5. Alice broadcasts both the BTC transaction and the WJT transaction.

In a word, Bob is responsible for preparing the WJT transaction, while Alice is responsible for preparing the BTC transaction and broadcasting both transactions.

Here, if Bob stalls, nothing will happen, because Bob cannot spend the 10,000 WJT premium without Alice?s signature.
If Alice stalls, you are saying that Bob can spend the input of 1,000,000 WJT so he does not lose any money.

I have 3 questions on this scheme.

First, I?m not sure how do you define ?Alice stalls?. In this case, Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding txs but withhold the preimage.
If 2), this protocol is okay. But what about 1) i.e. Alice withholds the WJT tx? Here, Bob cannot do anything except for closing the payment channel and quit.

Second, I?m not sure whether Bob can spend his money in this payment channel while the payment channel is still valid.
In Bitcoin, Bob needs to close the payment channel and get back his money first, then he can spend the money.

Third, let?s optimistically assume Bob can close this payment channel without Alice?s consent.
Now he decides to close this channel if Alice does not broadcast the WJT tx all the time.
Alice does not need to pay for the premium if she withholds the WJT tx. If Alice decides not to proceed this swap, Bob should close this channel and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.

In conclusion, Alice?s optionality is not free when she exercises this option, but is free when she aborts this option.



## What will happen if Alice is responsible for broadcasting both funding txs

If Alice is responsible for broadcasting both txs, Alice can always abort the swap for free, regardless of how the protocol is designed.
Basically, Bob officially participates in the swap by signing the WJT tx.
After Bob participating, if Alice hopes to abort the swap, she can just withhold the WJT tx.

In the original Atomic Swap, Bob participates in the swap by signing and broadcasting the WJT tx, and Alice cannot withhold Bob?s participation.
However, if Alice is responsible for broadcasting Bob?s WJT tx, Alice can withhold Bob?s participation by withholding the WJT tx.

Therefore, I think for Atomic Swap protocol design, Bob should be responsible for broadcasting the WJT tx, otherwise the protocol is impossible to be fair to Bob.



Again, sorry for the ambiguity introduced in our last email, and we look forward to hearing from you.

Thanks,
Runchao


> On 10 Aug 2019, at 11:01 pm, Runchao Han <runchao.han at monash.edu> wrote:
> 
> If I remember it right, Alice first signs the WJT transaction, sends it to Bob, then Bob signs it and makes this transaction valid.
> 
> If so, there are two problems.
> First, Bob gets the valid tx first, and he can choose not to send it to Alice.
> Second, even if Bob honestly sends Alice this tx, Alice cannot fully control when to broadcast this to, as Bob also has this transaction.
> 
> If Bob first signs then Alice signs, Alice still has optionality, as she can choose whether to publish this tx and preimage.
> 
> Runchao
> 
> On Sat, Aug 10, 2019 at 10:50 PM ZmnSCPxj <ZmnSCPxj at protonmail.com <mailto:ZmnSCPxj at protonmail.com>> wrote:
> Good morning Runchao,
> 
> 
> 
> 
> Sent with ProtonMail Secure Email.
> 
> ??????? Original Message ???????
> On Saturday, August 10, 2019 1:44 PM, Runchao Han <runchao.han at monash.edu <mailto:runchao.han at monash.edu>> wrote:
> 
> > Hi ZmnSCPxj,
> >
> > Thanks for your reply.
> >
> > I agree with your opinions about OP_LOOKUP_OUTPUT.
> > Indeed, the pruning mechanism renders this opcode unrealistic for some nodes. Also, the execution of OP_LOOKUP_OUTPUT depends on the time of verifying this tx.
> >
> > However, I?m concerning of some security issues of your mentioned protocol (Alice pays the premium contingently on Bob participating).
> > If I understand it right, Alice and Bob should create a payment channel, and mutually construct the funding transaction that ?Alice pays Bob 10,000 WJT; Bob hash-timelocked pays Alice 1,000,000WJT?, where the time lock is T+24.
> > Here, Bob is responsible for broadcasting this tx after confirming Alice?s funding transaction on BTC blockchain.
> 
> No, Bob is not.
> 
> The signature exchange for the WJT-side funding tx is done by:
> 
> 1. Alice waits for Bob to provide all its signatures for inputs that will fund the 1,000,000 WJT payout.
> 2. Alice signs its inputs that will fund the 10,000 WJT premium.
> 3. Alice broadacasts the completely signed funding tx.
> 
> Alice is the one responsible for broadcasting the funding tx.
> 
> If Bob stalls, it is not a Bob side option (i.e. Bob cannot stall then continue the protocol when the exchange rate moves to its favor) as Alice can refuse to sign and broadcast the funding tx once it has decided Bob is trolling it, thus Bob cannot force Alice to perform.
> 
> If Alice stalls, Bob can double-spend one of its inputs at a low feerate.
> This either aborts the protocol, or if Alice then broadcasts the funding tx at the pre-agreed feerate and it is confirmed, the premium is now already paid to Bob.
> 
> Regards,
> ZmnSCPxj
> 
> > In this case, Bob can arbitrage by broadcasting this tx after T+24. In this way, Bob receives the 10,000WJT, but Alice cannot redeem 1,000,000WJT anymore.
> > If the premium (10,000WJT) is also hash-timelocked, Alice can keep unraveling the preimage, which makes the atomic swap still premium-free.
> >
> > In the original atomic swap, Bob is incentivised to broadcast his funding transaction, otherwise he may miss the opportunity to redeem Alice?s asset.
> > Also, Alice will lose nothing regardless of how Bob behaves, because Alice locks all her money by hashlock.
> > However, Alice cannot lock the premium using hashlock. This gives Bob opportunity to arbitrage Alice?s premium.
> >
> > What is implied here is that, where the premium should go strictly depends on where Bob?s asset goes.
> > If the Bitcoin?s timelock can be ?relative? (e.g. the timestamp can be x+24 where x is the timestamp of the block with this transaction), I think this protocol works.
> > Unfortunately, the ?x? here is also an external state according to your definition.
> >
> > In conclusion, I believe your comments on OP_LOOKUP_OUTPUT reasonable, but cannot make sure if the premium mechanism can be implemented by using HTLCs.
> >
> > Thanks,
> > Runchao
> >
> > > On 10 Aug 2019, at 12:29 am, ZmnSCPxj ZmnSCPxj at protonmail.com <mailto:ZmnSCPxj at protonmail.com> wrote:
> > > Good morning Haoyu LIN et al.,
> > >
> > > > We have investigated this problem in very detail. We analysed how profitable the arbitrage can be given the default timelock setting (24/48 hrs). Our result shows that the profit can be approximately 1% ~ 2.3%, which is non-negligible compared with 0.3% for stock market. This can be attractive as it's totally risk-free. Please refer to our paper https://eprint.iacr.org/2019/896 <https://eprint.iacr.org/2019/896>, and the related code https://github.com/HAOYUatHZ/fair-atomic-swap <https://github.com/HAOYUatHZ/fair-atomic-swap> if interested.
> > > > Several studies have proposed for solving this problem e.g., http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/ <http://diyhpl.us/wiki/transcripts/scalingbitcoin/tokyo-2018/atomic-swaps/> and https://coblox.tech/docs/financial_crypto19.pdf <https://coblox.tech/docs/financial_crypto19.pdf>. Their basic idea is that, the transaction for the premium needs to be locked with the same secret hash but with a flipped payout, i.e. when redeemed with the secret, the money goes back to Alice and after timelock, the premium goes to Bob as a compensation for Alice not revealing the secret. However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
> > > > To solve this, the transaction verifier needs to know the status of an dependent transaction. Unfortunately, Bitcoin does not support the stateful transaction functionalities. Therefore, we propose the new opcode: OP_LOOKUP_OUTPUT. It takes the id of an output, and produces the address of the output?s owner. With OP_LOOKUP_OUTPUT, the Bitcoin script can decide whether Alice or Bob should take the premium by `<output> OP_LOOKUP_OUTPUT <pubkeyhash> OP_EQUALVERIFY`.
> > >
> > > I believe an unsaid principle of SCRIPT opcode design is this:
> > >
> > > -   No SCRIPT opcode can look at anything that is not in the transaction spending from the SCRIPT.
> > >
> > > This issue underlies the previous `OP_PUBREF` proposal also.
> > > The reason for this is:
> > >
> > > -   We support a pruning mode, where in only the UTXO set is retained.
> > >     If `OP_LOOKUP_OUTPUT` exists, we cannot prune, as `OP_LOOKUP_OUTPUT` might refer to a TXO that has been spent in very early historical blocks.
> > >
> > > -   The SCRIPT interpreter is run only once, at the time the transaction enters the mempool.
> > >     Thus it cannot get information about the block it is in.
> > >     Instead, the SCRIPT interpreter can have as input only the transaction that is attempting to spend the SCRIPT.
> > >
> > >
> > > In any case:
> > >
> > > > However, this introduces a new problem: Bob can get the premium without paying anything, by never participating in.
> > >
> > > Premium payment can be made contingent on Bob participating.
> > > Of course, it does mean the premium is paid using the destination coin.
> > > It also requires the destination coin to support SegWit.
> > > Let me explain by this:
> > >
> > > 1.  Alice and Bob agree on swap parameters:
> > >
> > > -   Alice will exchange 1 BTC for 1,000,000 WJT from Bob.
> > > -   Alice will pay 10,000 WJT as premium to Bob.
> > > -   Alice will lock BTC for 48 hours.
> > > -   Bob will lock WJT for 24 hours.
> > > -   The protocol will start at particular time T.
> > >
> > > 2.  Alice generates a preimage+hash.
> > > 3.  Alice pays 1 BTC to a HTLC with hashlock going to Bob and timelocked at T+48 going to Alice.
> > > 4.  Alice presents above UTXO to Bob.
> > > 5.  Alice reveals the WJT UTXOs to be spent to pay for the 10,000 WJT premium to Bob.
> > > 6.  Alice and Bob generate, but do not sign, a funding transaction spending some of Bob coin as well as the premium coin from Alice.
> > >     This pays out to 1,010,000 WJT (the value plus the premium) HTLC.
> > >     The hashlock branch requires not just Alice, but also Bob.
> > >     The timelock branch at T+24 just requires Bob.
> > >
> > > 7.  Alice and Bob generate the claim transaction.
> > >     This spends the funding transaction HTLC output and pays out 1,000,000 WJT to Alice and 10,000 WJT to Bob.
> > >
> > > 8.  Alice and Bob sign the claim transaction.
> > >     This does not allow Bob to make the claim transaction valid by itself as it still requires the preimage, and at this point, only Alice knows the preimage.
> > >
> > > 9.  Alice and Bob sign the funding transaction and broadcast it.
> > > 10.  Alice completes the claim transaction by adding the preimage and broadcasts it.
> > > 11.  Bob sees the preimage on the WJT blockchain and claims the BTC using the preimage.
> > >
> > > If Bob stalls at step 8, then there is no way to claim the premium, as the funding transaction (which is the source of the claim transaction that pays the premium) is not valid yet.
> > > After step 9, Bob has been forced to participate and cannot back out and claim the premium only.
> > > This is basically this proposal: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html <https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001798.html>
> > > In addition, if you really want the premium to be denominated in BTC, I have a more complicated ritual: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html <https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-January/001795.html>
> > > The described ritual only sets up the American Call Option, but by the time it has been set up, the premium has been paid already and the rest of the execution is claiming the American Call Option.
> > > Thus, I believe there is no need to add `OP_LOOKUP_OUTPUT`.
> > > Regards,
> > > ZmnSCPxj
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/c4e1a6bd/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Mon Aug 12 08:05:53 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 12 Aug 2019 08:05:53 +0000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <212E8AD5-0EED-468E-8AFC-134611514CBC@monash.edu>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
	<aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
	<CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>
	<212E8AD5-0EED-468E-8AFC-134611514CBC@monash.edu>
Message-ID: <OLQmXBBI4kc9mkjbpr92bKp3UFhmg7ZtTn-m_VNinXNDT4CYz9Jf45gpSfxmkzXQLJfchMk7AaqEjbEor-ZJ02xrd_0yb2MOekXfRyovj6U=@protonmail.com>

Good morning Runchao,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Monday, August 12, 2019 11:19 AM, Runchao Han <runchao.han at monash.edu> wrote:

> Good morning ZmnSCPxj,
>
> Sorry for the ambiguity of my last email. It was Sunday and I wrote it in 1 min on my bed. Let me elaborate what we are thinking of here.
>
> ## Analysis on the protocol from Fournier et al.
>
> In this protocol, Bob participates in the swap following the steps below:
>
> 1. Alice and Bob creates a payment channel on WJT blockchain.
> 2. Bob creates the WJT transaction using the joint account of Alice and Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice?s input for the 10,000 WJT premium. This transaction should be signed by both Alice and Bob in order to be valid.
> 3. Bob signs the WJT transaction and sends the WJT transaction to Alice.
> 4. Alice signs this WJT transaction. At this stage, Alice has both the valid BTC transaction and the valid WJT transaction.
> 5. Alice broadcasts both the BTC transaction and the WJT transaction.

Incorrect.

The order is below.
I add also the behavior when the protocol is stalled such that a step is not completed.

1.  Alice broadcasts and confirms a BTC transaction paying an HTLC, hashlock Bob, Timelock Alice.
    * Alice is initiating the protocol via this step, thus non-completion of this step is simply not performing the protocol.
2.  Alice informs the BTC transaction to Bob.
    * If Alice does not perform this, Bob does not know it and Alice locked her own money for no reason.
3.  Alice and Bob indicate their inputs for the WJT-side funding transaction.
    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.
    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).
4.  Alice and Bob exchange signatures for the WJT-side claim transaction which spends the funding transaction via the hashlock side and gives 1,000,000 WJT to payout to Alice and 10,000 WJT premium to Bob.
    Order does not matter as funding  tx is still unsigned.
    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.
    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).
5.  Bob provides signatures for the WJT funding tx,
    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).
6.  Alice signs WJT funding tx and broacasts and confirms.
    * If Alice does not perform this, Bob invalidates the transaction by spending any of his inputs.
      * Alice has an option here, but a very short option: up until Bob grows tired of waiting.
        Bob can make this timeout arbitrarily small, without requiring input from Alice.
        What value would there be in a 1-second option, even gotten for free, when Alice has spent fees on the BTC-side transaction in the first place?
7.  Alice completes the claim transaction and broadcasts.
    * If Alice does not perform this, Bob simply waits out the timelock and recovers his funds plus premium.
8.  Bob spends the BTC HTLC via the hashlock path.
    * If Bob does not perform this, Bob has given money for free to Alice.

Thus I do not believe this is needed for blockchain-layer atomic swaps.

For Lightning-layer atomic swaps, the solution requires that two hashes be used on the WJT side, and is largely the above protocol in very broad strokes.
Unfortunately, using two hashes instead of one leaks to intermediate hops that the payment involved a cross-currency swap, thus undesirable.



>
> In a word, Bob is responsible for preparing the WJT transaction, while Alice is responsible for preparing the BTC transaction and broadcasting both transactions.
>
> Here, if Bob stalls, nothing will happen, because Bob cannot spend the 10,000 WJT premium without Alice?s signature.
> If Alice stalls, you are saying that Bob can spend the input of 1,000,000 WJT so he does not lose any money.
>
> I have 3 questions on this scheme.
>
> First, I?m not sure how do you define ?Alice stalls?. In this case, Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding txs but withhold the preimage.
> If 2), this protocol is okay. But what about 1) i.e. Alice withholds the WJT tx? Here, Bob cannot do anything except for closing the payment channel and quit.

Yes.

>
> Second, I?m not sure whether Bob can spend his money in this payment channel while the payment channel is still valid.
> In Bitcoin, Bob needs to close the payment channel and get back his money first, then he can spend the money.

Depends on how the payment channel is implemented.
If you do something like send transactions spending the internal state outputs, then ratifying this later by performing a transaction cut-through to derive the next state update, then it is no different from blockchain layer.
Of course, if you postulate the non-cooperation of Alice in this, there is indeed a need to close unilaterally.
But this is the same as any non-cooperation in any channel system: that is the entire point why you have unilateral closes.

>
> Third, let?s optimistically assume Bob can close this payment channel without Alice?s consent.

Every payment channel system worth consideration today has a unilateral close.
There is no need for optimism.

> Now he decides to close this channel if Alice does not broadcast the WJT tx all the time.
> Alice does not need to pay for the premium if she withholds the WJT tx. If Alice decides not to proceed this swap, Bob should close this channel and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.

And this time frame can be made arbitarily small by Bob by simple threat of unilateral close, thus not making it an option for Alice.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Mon Aug 12 13:15:04 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 12 Aug 2019 13:15:04 +0000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <419535C8-DE1D-425B-A38C-4196607E43D3@monash.edu>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
	<aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
	<CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>
	<212E8AD5-0EED-468E-8AFC-134611514CBC@monash.edu>
	<OLQmXBBI4kc9mkjbpr92bKp3UFhmg7ZtTn-m_VNinXNDT4CYz9Jf45gpSfxmkzXQLJfchMk7AaqEjbEor-ZJ02xrd_0yb2MOekXfRyovj6U=@protonmail.com>
	<419535C8-DE1D-425B-A38C-4196607E43D3@monash.edu>
Message-ID: <phmro7hOHAALKuYqkqe0bS6DAwkES_62RoExz6VQ-F8ap89igX6IOV1kT07LL57dBlv-y4ujIbTx35z2JXrhIP8xEslVTWlILSqCH0ioAqs=@protonmail.com>

Good morning Runchao,

> Thanks for your explanation. It?s comprehensive.
>
> I think our disagreement is on the step 6.
> In step 6,
>
> - Alice can publish or withhold the WJT tx
> - Bob can wait or unilaterally close the WJT payment channel
>
> I see the following things:
>
> First, both Alice and Bob can do something on the WJT blockchain at this stage. What will happen if they publish txs simultaneously?
> For example, Alice publishes WJT tx while Bob publishes the tx closing the channel.

I am uncertain what you refer to by the "WJT payment channel".
What I am proposing here is there is a single funding transaction that will output to a modified HTLC where hashlock is Alice+Bob while Timelock is Bob, spending inputs from both Alice (10,000 WJT) and Bob (1,000,000 WJT).

So let me rephrase the nearest question as I understand it:

* What happens when Alice broadcasts the funding tx at the same time as Bob double-spends his 1,000,000 WJT input?

As both transactions spend the same input (the 1,000,000 WJT from Bob) then what happens depends on the miners.
The miners decide which transaction is valid and gets confirmed onchain.

That is the reason why we need large timeouts in the HTLC constructions: we need to give enough time, not only to react to transactions being published, but also to have transactions become deeply confirmed.
Otherwise we could have made the timelocks so small as to be practically worthless as an option.

>
> Second, will the concurrent txs introduce some attacks? ?I guess concurrent-while-conflicting txs lead to highly unpredictable behaviours.
> For example, Alice or Bob uses high tx fee to bribe miners to accept her/his tx, in order to gain some advantage on the concurrent txs?
> Also, the ?whale transaction? works here. Will this introduce some double-spending variants?

Yes, that is why Alice and Bob need to wait for deep confirmations of the transactions involved.
Once deeply confirmed, they now know which way the protocol went and can safely perform the next step (or abort the protocol).

>
> Third, assume Bob doesn?t wait any more and closes the channel. In this case, Bob cannot get the premium.
> This is not consistent with the original American Call Option, in which Bob should still get the premium.

It does not matter, because Bob doing so *prevents* the option.

Think of it this way:

Suppose we were to meet face-to-face, in order for you to sell me an options contract.
Now, suppose I agree to buy the options contract.
But, while filling up the paperwork, you change your mind.

Until the paperwork is properly filled up, the option does not exist.
Thus, until the paperwork is properly filled,, the option is not exerciseable (and I should not pay anything to you since you did not push through with completing the option).

This is similar in effect.


>
> To conclude, I find this protocol highly depends on the implementation of the payment channel as well as the expertise of participants (Alice and Bob) c.f. relatively low usability.
> We may need a suitable payment channel implementation here. What?s your opinion on the payment channel suitable for this scenario?

Any payment channel has the problem of non-cooperation by the other side.
I already mentioned this before.
Again, this is always an issue regardless of the existence or non-existence of an `OP_LOOKUP_OUTPUT`: you have to execute onchain activity anyway in order to enforce anything offchain in case of non-cooperation, and adding in the possibility of various attacks makes it more likely that non-cooperation occurs.
It is the main reason why I think it is difficult to make Lightning support multiple currencies on the same network.

Usability can always be improved by proper software design; you do not worry about what voltage levels need to be transmitted over the wires in order to transmit your email to me, yet you probably consider your email client quite usable.

Regards,
ZmnSCPxj



From pete at petertodd.org  Mon Aug 12 14:40:23 2019
From: pete at petertodd.org (Peter Todd)
Date: Mon, 12 Aug 2019 10:40:23 -0400
Subject: [bitcoin-dev] Single-use-Seal Implementation
In-Reply-To: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
Message-ID: <20190812144023.4mixitkcsrvpb7i6@petertodd.org>

On Wed, Aug 07, 2019 at 08:48:06AM -0500, Bryan Bishop via bitcoin-dev wrote:
> Single-use seals
> ================
> 
> This proposal may have inadvertedly demonstrated a practical way to implement
> Peter Todd's single-use seals concept [4]. I am hesitant to say so, though,
> because I think he would ask for a more sophisticated way to verify seal
> closure.

I'm not sure what you're getting at here; single-use-seals are really boring
and simple. To recap, they're akin to a pubkey that has the "magical" property
that it can only be signed once. This of course is impossible with math alone,
but can be implemented with beyond-math mechanisms like trust or PoW (physics).

Thus you have a globally unique seal, which can be closed over a message,
producing a witness attesting to the fact that the seal was closed over that
message. A single-use-seal protocol is secure if it is impossible (in your
chosen security model) to trick the validation function into thinking a single
seal was closed over two different messages.

The obvious implementation with Bitcoin is to define the seal to be a specified
txout, and the witness to be a transaction (and lite client proof) that spends
that txout in a transation with an OP_RETURN output committing to the hash of
the message as the first output. A fancier implementation could use a
pay-to-pubkey-style commitment (RGB? uses something along these lines).


For applications requiring a chain of single-use-seals, you can easily keep two
txouts for seals in your wallet, and alternate them as the chain is extended.


Do you mean to say there didn't previously exist a practical way to implement
them? Or that you've found another way? I'm curious what you mean here.


1) https://github.com/rgb-org/spec

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/c7c319b2/attachment.sig>

From pete at petertodd.org  Mon Aug 12 15:01:10 2019
From: pete at petertodd.org (Peter Todd)
Date: Mon, 12 Aug 2019 11:01:10 -0400
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
 mechanisms
In-Reply-To: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
Message-ID: <20190812150110.yf76pq47e5oszx62@petertodd.org>

On Wed, Aug 07, 2019 at 08:48:06AM -0500, Bryan Bishop via bitcoin-dev wrote:
> Hi,
> 
> I have a proposal for implementing bitcoin vaults in a way that does not
> require any soft-forks or other software upgrades, although it could benefit
> from SIGHASH_NOINPUT which I'll describe later.
> 
> I call them pre-signed vaults.
> 
> Vault definition
> ================
> 
> Here, a vault is defined as a transaction setup scheme that binds both the user
> and the attacker to always using a public observation and delay period before a
> weakly-secured hot key is allowed to arbitrarily spend coins. This is the same
> definition previously used[1]. During the delay period, there is an opportunity
> to initiate recovery/clawback which can either trigger deeper cold storage
> parameters or at least reset the delay period to start over again for the same
> keys.

So, I'll point out that I'd describe this a little bit differently:

    The vault is a tx setup scheme that binds coins in such a way that they can
    only be spent via a proof-of-publication *notification*, followed by a delay
    period, during which coins can be recovered/clawed back.

The key difference being it's not important that this be a *public*
notification: that the public can see just happens to be an (unfortunate)
implementation detail. For example, you could imagine a system where the
"prepare to spend" tx is indistinguishable from any other transaction.

> One of the important components of this is the delete-the-key pre-signed
> transaction concept, where only a single transaction is (pre)signed before
> deleting the key. This is basically an emulation of a covenant and enforces a
> certain outcome.

It's important to note the reason this is possible is because any coin bound by
a convenant simply isn't a coin in the normal sense of the word, and is only
acceptable as payment directly if the receiver chooses to accept it.

To use an analogy many others have used, if you owe me $100, it's not
acceptable for you to pay me that $100 by dumping a time-locked safe on my
front lawn containing that $100 unless I've agreed to accept payment that way.

> * Nuclear abort key: Also unnecessary. This is a key for which only a single
> signed transaction will ever exist, and that single transaction will spend to a
> proof-of-burn key like 0x00. This key must be extremely secure, and if there

So to be clear, you're spending to a proof-of-burn _key_ because of the use of
adapter signatures for multisig? I'm not sure where the 0x00 is coming from
here.

Obviously normally to provably destroy coins you'd spend to an OP_RETURN
output, or if miner censorship was an issue, a pay-to-script-hash of an
OP_RETURN <nonce> script.

> Delete the key (for pre-signed transactions)
> ============================================
> 
> The delete-the-key trick is simple. The idea is to pre-sign at least one
> transaction and then delete the private key, thus locking in that course of
> action.
> 
> Unfortunately, delete-the-key doesn't really work for multisig scenarios
> because nobody would trust that anyone else in the scheme has actually deleted
> the secret. If they haven't deleted the secret, then they have full unilateral
> control to sign anything in that branch of the transaction tree. The only time
> that delete-the-key might be appropriate would be where the user who deletes
> the key and controls the key during the setup process is also the sole
> beneficiary of the entire setup with the multisig participants.
> 
> Alternative fee rates are easier to deal with using delete-the-key, compared to
> a technique where the private key never existed which can only be used to sign
> one fee rate per public key, requiring an entirely new vault subtree for each
> alternative fee rate. With delete-the-key, the alternative fee rates are signed
> with the private key before the private key is deleted.

I think this could use a bit more analysis here: why can't delete the *keys*
work, with each party deleting a separate private key that's used in an m-of-n
fashion? So long as at least n-m+1 parties actually deleted their keys IIUC it
should be secure.

> Multisig gated by ECDSA pubkey recovery for provably-unknown keys
> =================================================================
> 
> A group can participate in a multisig scheme with provably-unknown ECDSA keys.
> Instead of deleting the key, the idea is to agree on a blockheight and then
> select the blockhash (or some function of the chosen blockhash like
> H(H(H(blockhash)))) as the signature. Next, the group agrees on a transaction
> and they recover the public key from the signature using ECDSA pubkey recovery.

Could you explain in more detail why you're deriving this from a blockhash?

> Deploying exceedingly large scripts
> ===================================
> 
> A brief interlude to share a somewhat obvious construction. I haven't seen this
> written down yet.
> 
> Suppose there is a bitcoin script that someone is interested in using, but it
> far exceeds the size limits and sigop limits. To fix this, they would split up
> the script into usable chunks, and then use the delete-the-key mechanism (or
> the other one) to create an OR branch that is signable by a single key for
> which only a single signature is known. That new pre-signed transaction would
> spend to a script that has the output with the remainder of the script of
> interest. Re-vaulting or clawback clauses can be added to that output as well,
> but spending back to the original root script will only work by generating new
> scripts and keys (since the final hash isn't known until the whole tree is
> constructed, it's a dependency loop).

Clever!

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/804c7e86/attachment.sig>

From kanzure at gmail.com  Tue Aug 13 02:09:43 2019
From: kanzure at gmail.com (Bryan Bishop)
Date: Mon, 12 Aug 2019 21:09:43 -0500
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <20190812150110.yf76pq47e5oszx62@petertodd.org>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
	<20190812150110.yf76pq47e5oszx62@petertodd.org>
Message-ID: <CABaSBawwSEa_dDLEXhWncsqKmsM+rdT2Npo334LEZPvcMzrzFQ@mail.gmail.com>

On Mon, Aug 12, 2019 at 10:01 AM Peter Todd <pete at petertodd.org> wrote:

> The key difference being it's not important that this be a *public*
> notification: that the public can see just happens to be an (unfortunate)
> implementation detail. For example, you could imagine a system where the
> "prepare to spend" tx is indistinguishable from any other transaction.
>

True, I did not intend for everyone to know the meaning of the observed
transaction. It turns out to not be too useful to the scheme anyway, unless
you're interested in protecting against an adversary dumb enough to tell
you he has stolen your key before spending your coins. To reiterate my
other follow-up email, the best you can do (... or the best I can do right
now) is limit losses to k% where k is selected by the user, e.g. 1 input
100 outputs each with succesively increasing timeouts allowing the rotten
non-rotated(pre-inserted) key to spend, and instant spending by a recovery
flow. Once the attacker steals any one of the k% outputs, you know to not
let the outputs timeout to that key in the future. Unfortunately, without
an opcode-style covenant, the only way to know if a stale hot key is stolen
is to observe an unexpected spend or, if you're lucky, observe an
unexpected signature otherwise unassociated with a transaction.


> > * Nuclear abort key: Also unnecessary. This is a key for which only a
> single


>
Obviously normally to provably destroy coins you'd spend to an OP_RETURN
> output, or if miner censorship was an issue, a pay-to-script-hash of an
> OP_RETURN <nonce> script.
>

Oh, right. Well, that works.


> > Delete the key (for pre-signed transactions)
> > ============================================
> >
> > The delete-the-key trick is simple. The idea is to pre-sign at least one
> > transaction and then delete the private key, thus locking in that course
> of
> > action.
> >
> > Unfortunately, delete-the-key doesn't really work for multisig scenarios
> > because nobody would trust that anyone else in the scheme has actually
> deleted
> > the secret. If they haven't deleted the secret, then they have full
> unilateral
> > control to sign anything in that branch of the transaction tree. The
> only time
> > that delete-the-key might be appropriate would be where the user who
> deletes
> > the key and controls the key during the setup process is also the sole
> > beneficiary of the entire setup with the multisig participants.
> >
> > Alternative fee rates are easier to deal with using delete-the-key,
> compared to
> > a technique where the private key never existed which can only be used
> to sign
> > one fee rate per public key, requiring an entirely new vault subtree for
> each
> > alternative fee rate. With delete-the-key, the alternative fee rates are
> signed
> > with the private key before the private key is deleted.
>
> I think this could use a bit more analysis here: why can't delete the
> *keys*
> work, with each party deleting a separate private key that's used in an
> m-of-n
> fashion? So long as at least n-m+1 parties actually deleted their keys
> IIUC it
> should be secure.
>

I was thinking about another construction where you pick a key as a group
(separate from the multisig setup) and sign with that. But in practice, as
you have pointed out, you would do the delete-the-key trick on the multisig
construction itself with each party contributing their own pubkey,
requiring 1/n honest deletes.


> > Multisig gated by ECDSA pubkey recovery for provably-unknown keys
> > =================================================================
> >
> > A group can participate in a multisig scheme with provably-unknown ECDSA
> keys.
> > Instead of deleting the key, the idea is to agree on a blockheight and
> then
> > select the blockhash (or some function of the chosen blockhash like
> > H(H(H(blockhash)))) as the signature. Next, the group agrees on a
> transaction
> > and they recover the public key from the signature using ECDSA pubkey
> recovery.
>
> Could you explain in more detail why you're deriving this from a blockhash?
>

Well you need to pick an entropy source, and I wouldn't want to tell people
to just trust the first party to tell you a good sequence of bytes.

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/457a9f30/attachment-0001.html>

From runchao.han at monash.edu  Mon Aug 12 10:02:33 2019
From: runchao.han at monash.edu (Runchao Han)
Date: Mon, 12 Aug 2019 20:02:33 +1000
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <OLQmXBBI4kc9mkjbpr92bKp3UFhmg7ZtTn-m_VNinXNDT4CYz9Jf45gpSfxmkzXQLJfchMk7AaqEjbEor-ZJ02xrd_0yb2MOekXfRyovj6U=@protonmail.com>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
	<aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
	<CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>
	<212E8AD5-0EED-468E-8AFC-134611514CBC@monash.edu>
	<OLQmXBBI4kc9mkjbpr92bKp3UFhmg7ZtTn-m_VNinXNDT4CYz9Jf45gpSfxmkzXQLJfchMk7AaqEjbEor-ZJ02xrd_0yb2MOekXfRyovj6U=@protonmail.com>
Message-ID: <419535C8-DE1D-425B-A38C-4196607E43D3@monash.edu>

Hi ZmnSCPxj,

Thanks for your explanation. It?s comprehensive.

I think our disagreement is on the step 6.
In step 6,

- Alice can publish or withhold the WJT tx
- Bob can wait or unilaterally close the WJT payment channel

I see the following things:

First, both Alice and Bob can do something on the WJT blockchain at this stage. What will happen if they publish txs simultaneously?
For example, Alice publishes WJT tx while Bob publishes the tx closing the channel.

Second, will the concurrent txs introduce some attacks?  I guess concurrent-while-conflicting txs lead to highly unpredictable behaviours.
For example, Alice or Bob uses high tx fee to bribe miners to accept her/his tx, in order to gain some advantage on the concurrent txs?
Also, the ?whale transaction? works here. Will this introduce some double-spending variants?

Third, assume Bob doesn?t wait any more and closes the channel. In this case, Bob cannot get the premium.
This is not consistent with the original American Call Option, in which Bob should still get the premium.

To conclude, I find this protocol highly depends on the implementation of the payment channel as well as the expertise of participants (Alice and Bob) c.f. relatively low usability.
We may need a suitable payment channel implementation here. What?s your opinion on the payment channel suitable for this scenario?

Sincerely,
Runchao

> On 12 Aug 2019, at 6:05 pm, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Runchao,
> 
> 
> Sent with ProtonMail Secure Email.
> 
> ??????? Original Message ???????
> On Monday, August 12, 2019 11:19 AM, Runchao Han <runchao.han at monash.edu <mailto:runchao.han at monash.edu>> wrote:
> 
>> Good morning ZmnSCPxj,
>> 
>> Sorry for the ambiguity of my last email. It was Sunday and I wrote it in 1 min on my bed. Let me elaborate what we are thinking of here.
>> 
>> ## Analysis on the protocol from Fournier et al.
>> 
>> In this protocol, Bob participates in the swap following the steps below:
>> 
>> 1. Alice and Bob creates a payment channel on WJT blockchain.
>> 2. Bob creates the WJT transaction using the joint account of Alice and Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice?s input for the 10,000 WJT premium. This transaction should be signed by both Alice and Bob in order to be valid.
>> 3. Bob signs the WJT transaction and sends the WJT transaction to Alice.
>> 4. Alice signs this WJT transaction. At this stage, Alice has both the valid BTC transaction and the valid WJT transaction.
>> 5. Alice broadcasts both the BTC transaction and the WJT transaction.
> 
> Incorrect.
> 
> The order is below.
> I add also the behavior when the protocol is stalled such that a step is not completed.
> 
> 1.  Alice broadcasts and confirms a BTC transaction paying an HTLC, hashlock Bob, Timelock Alice.
>    * Alice is initiating the protocol via this step, thus non-completion of this step is simply not performing the protocol.
> 2.  Alice informs the BTC transaction to Bob.
>    * If Alice does not perform this, Bob does not know it and Alice locked her own money for no reason.
> 3.  Alice and Bob indicate their inputs for the WJT-side funding transaction.
>    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.
>    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).
> 4.  Alice and Bob exchange signatures for the WJT-side claim transaction which spends the funding transaction via the hashlock side and gives 1,000,000 WJT to payout to Alice and 10,000 WJT premium to Bob.
>    Order does not matter as funding  tx is still unsigned.
>    * If Alice does not perform this, it aborts the protocol and Alice locked her own money for no reason.
>    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).
> 5.  Bob provides signatures for the WJT funding tx,
>    * If Bob does not perform this, it aborts the protocol and Bob turns down the opportunity to earn 10,000 WJT (opportunity cost).
> 6.  Alice signs WJT funding tx and broacasts and confirms.
>    * If Alice does not perform this, Bob invalidates the transaction by spending any of his inputs.
>      * Alice has an option here, but a very short option: up until Bob grows tired of waiting.
>        Bob can make this timeout arbitrarily small, without requiring input from Alice.
>        What value would there be in a 1-second option, even gotten for free, when Alice has spent fees on the BTC-side transaction in the first place?
> 7.  Alice completes the claim transaction and broadcasts.
>    * If Alice does not perform this, Bob simply waits out the timelock and recovers his funds plus premium.
> 8.  Bob spends the BTC HTLC via the hashlock path.
>    * If Bob does not perform this, Bob has given money for free to Alice.
> 
> Thus I do not believe this is needed for blockchain-layer atomic swaps.
> 
> For Lightning-layer atomic swaps, the solution requires that two hashes be used on the WJT side, and is largely the above protocol in very broad strokes.
> Unfortunately, using two hashes instead of one leaks to intermediate hops that the payment involved a cross-currency swap, thus undesirable.
> 
> 
> 
>> 
>> In a word, Bob is responsible for preparing the WJT transaction, while Alice is responsible for preparing the BTC transaction and broadcasting both transactions.
>> 
>> Here, if Bob stalls, nothing will happen, because Bob cannot spend the 10,000 WJT premium without Alice?s signature.
>> If Alice stalls, you are saying that Bob can spend the input of 1,000,000 WJT so he does not lose any money.
>> 
>> I have 3 questions on this scheme.
>> 
>> First, I?m not sure how do you define ?Alice stalls?. In this case, Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding txs but withhold the preimage.
>> If 2), this protocol is okay. But what about 1) i.e. Alice withholds the WJT tx? Here, Bob cannot do anything except for closing the payment channel and quit.
> 
> Yes.
> 
>> 
>> Second, I?m not sure whether Bob can spend his money in this payment channel while the payment channel is still valid.
>> In Bitcoin, Bob needs to close the payment channel and get back his money first, then he can spend the money.
> 
> Depends on how the payment channel is implemented.
> If you do something like send transactions spending the internal state outputs, then ratifying this later by performing a transaction cut-through to derive the next state update, then it is no different from blockchain layer.
> Of course, if you postulate the non-cooperation of Alice in this, there is indeed a need to close unilaterally.
> But this is the same as any non-cooperation in any channel system: that is the entire point why you have unilateral closes.
> 
>> 
>> Third, let?s optimistically assume Bob can close this payment channel without Alice?s consent.
> 
> Every payment channel system worth consideration today has a unilateral close.
> There is no need for optimism.
> 
>> Now he decides to close this channel if Alice does not broadcast the WJT tx all the time.
>> Alice does not need to pay for the premium if she withholds the WJT tx. If Alice decides not to proceed this swap, Bob should close this channel and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.
> 
> And this time frame can be made arbitarily small by Bob by simple threat of unilateral close, thus not making it an option for Alice.
> 
> Regards,
> ZmnSCPxj

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/260ad41c/attachment-0001.html>

From lloyd.fourn at gmail.com  Mon Aug 12 09:22:29 2019
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Mon, 12 Aug 2019 17:22:29 +0800
Subject: [bitcoin-dev] OP_LOOKUP_OUTPUT proposal
In-Reply-To: <OLQmXBBI4kc9mkjbpr92bKp3UFhmg7ZtTn-m_VNinXNDT4CYz9Jf45gpSfxmkzXQLJfchMk7AaqEjbEor-ZJ02xrd_0yb2MOekXfRyovj6U=@protonmail.com>
References: <CAEtgg6GOdceubg+b=-MvH66CKGBy-67mbQR01JpG3L1YJ1jaVw@mail.gmail.com>
	<qBFyALsLsiKkSXsssc3T7dvwrXtzBXmAAmTFWAt04AkrFwbWnoCdGIjoyqMZGnJa5Y4CX5mi0-1uWtuzPT5Swr3txw6NthtkOUdzCOlyfXo=@protonmail.com>
	<ADA03200-1EED-4EAD-B320-3F2034F00954@monash.edu>
	<aJ7usJIj2_reg-36SKEUDRApK8AhsIm2esl-I1CJSxs8cZACAmuR0X1bBNDK_zlDOUlzUWD2n2pCnbYx20Jg8kvAyryKZ9mqe0OH2J0QivY=@protonmail.com>
	<CABnocSBSKsmWeRCOZE6DHwPXc2rucQGkHvjd+wJ+9JAJOT5=QQ@mail.gmail.com>
	<212E8AD5-0EED-468E-8AFC-134611514CBC@monash.edu>
	<OLQmXBBI4kc9mkjbpr92bKp3UFhmg7ZtTn-m_VNinXNDT4CYz9Jf45gpSfxmkzXQLJfchMk7AaqEjbEor-ZJ02xrd_0yb2MOekXfRyovj6U=@protonmail.com>
Message-ID: <CAH5Bsr0rfHVnwcaHq_hpU4Wiz6AZ12kwDstJ34s3K7w=o-4azQ@mail.gmail.com>

Hello Runchao and ZmnSCPxj,

I think we can simplify the explanation here by not using joint signatures
and payment channel like constructions. ZmnSCPxj's more complex
construction could be more dynamic and practical in some settings but at
least for me it gets in the way of capturing how this relatively simple
idea works.
Here's my attempt at distilling the idea:

Step 0: Alice and Bob negotiate the parameters (timeouts, refund/redeem
pubkeys, the collateral amounts and inputs/outputs for the WTJ-HTLC)

=== Step 1 ===
 Alice signs and broadcasts the BTC-HTLC and sends signature(s) on her
input(s) to the WJT-HLTC to Bob.
Note:
1. She does not need to wait for the BTC-HTLC to confirm before she sends
her signature(s).
2. There is no benefit to Alice in delaying at this point

=== Step 2 ===
Upon receiving Alice's input signature(s) and seeing the BTC-HTLC with
sufficient confirmations, Bob completes the transaction by supplying his
own signature(s) and broadcasts it.

Note:
1. Bob's ability to delay at this point shouldn't be considered an option.
Alice may withdraw her offer by double spending her one of her inputs to
the WTJ-HTLC. Alice's ability to cancel the offer and take back BTC after
the timeout proves there is no option (options cannot be cancelled)
2. In this plain construction Alice should cancel promptly (if she doesn't
see the WTJ-HTLC within the next 1 or 2 blocks for example)
3. You could even extend this protocol  to specify that Bob send signatures
on his inputs the WTJ-HTLC immediately to Alice. If he refuses Alice can
cancel within a second or two.

=== Step 3 ===
Upon seeing the WTJ-HTLC get sufficient confirmations, Alice takes the
funds (including her collateral back) by revealing the secret.

Note:
1. If she doesn't redeem the HTLC she loses her collateral. Assuming the
loss of the collateral overwhelms any gain she could experience from the
delaying her decision and she operates in her own financial interest she
redeems it immediately.

Step 4 is as usual.

At each step there is no unfair advantage to either party (at least if we
idealise the blockchains somewhat and assume that neither party can
influence which transactions get into which block etc etc).

ZmnSCPxj,

Thanks for continuing to spread this idea!
I'm still not sure about your "two hashes" approach to lightning but I hope
to get to the bottom of it soon by describing how I think it should work
more formally somewhere. Will post to lightning-dev when I do :)

LL

On Mon, Aug 12, 2019 at 4:06 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Runchao,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Monday, August 12, 2019 11:19 AM, Runchao Han <runchao.han at monash.edu>
> wrote:
>
> > Good morning ZmnSCPxj,
> >
> > Sorry for the ambiguity of my last email. It was Sunday and I wrote it
> in 1 min on my bed. Let me elaborate what we are thinking of here.
> >
> > ## Analysis on the protocol from Fournier et al.
> >
> > In this protocol, Bob participates in the swap following the steps below:
> >
> > 1. Alice and Bob creates a payment channel on WJT blockchain.
> > 2. Bob creates the WJT transaction using the joint account of Alice and
> Bob, including 1) Bob's input of 1,000,000 WJT, 2) Alice?s input for the
> 10,000 WJT premium. This transaction should be signed by both Alice and Bob
> in order to be valid.
> > 3. Bob signs the WJT transaction and sends the WJT transaction to Alice.
> > 4. Alice signs this WJT transaction. At this stage, Alice has both the
> valid BTC transaction and the valid WJT transaction.
> > 5. Alice broadcasts both the BTC transaction and the WJT transaction.
>
> Incorrect.
>
> The order is below.
> I add also the behavior when the protocol is stalled such that a step is
> not completed.
>
> 1.  Alice broadcasts and confirms a BTC transaction paying an HTLC,
> hashlock Bob, Timelock Alice.
>     * Alice is initiating the protocol via this step, thus non-completion
> of this step is simply not performing the protocol.
> 2.  Alice informs the BTC transaction to Bob.
>     * If Alice does not perform this, Bob does not know it and Alice
> locked her own money for no reason.
> 3.  Alice and Bob indicate their inputs for the WJT-side funding
> transaction.
>     * If Alice does not perform this, it aborts the protocol and Alice
> locked her own money for no reason.
>     * If Bob does not perform this, it aborts the protocol and Bob turns
> down the opportunity to earn 10,000 WJT (opportunity cost).
> 4.  Alice and Bob exchange signatures for the WJT-side claim transaction
> which spends the funding transaction via the hashlock side and gives
> 1,000,000 WJT to payout to Alice and 10,000 WJT premium to Bob.
>     Order does not matter as funding  tx is still unsigned.
>     * If Alice does not perform this, it aborts the protocol and Alice
> locked her own money for no reason.
>     * If Bob does not perform this, it aborts the protocol and Bob turns
> down the opportunity to earn 10,000 WJT (opportunity cost).
> 5.  Bob provides signatures for the WJT funding tx,
>     * If Bob does not perform this, it aborts the protocol and Bob turns
> down the opportunity to earn 10,000 WJT (opportunity cost).
> 6.  Alice signs WJT funding tx and broacasts and confirms.
>     * If Alice does not perform this, Bob invalidates the transaction by
> spending any of his inputs.
>       * Alice has an option here, but a very short option: up until Bob
> grows tired of waiting.
>         Bob can make this timeout arbitrarily small, without requiring
> input from Alice.
>         What value would there be in a 1-second option, even gotten for
> free, when Alice has spent fees on the BTC-side transaction in the first
> place?
> 7.  Alice completes the claim transaction and broadcasts.
>     * If Alice does not perform this, Bob simply waits out the timelock
> and recovers his funds plus premium.
> 8.  Bob spends the BTC HTLC via the hashlock path.
>     * If Bob does not perform this, Bob has given money for free to Alice.
>
> Thus I do not believe this is needed for blockchain-layer atomic swaps.
>
> For Lightning-layer atomic swaps, the solution requires that two hashes be
> used on the WJT side, and is largely the above protocol in very broad
> strokes.
> Unfortunately, using two hashes instead of one leaks to intermediate hops
> that the payment involved a cross-currency swap, thus undesirable.
>
>
>
> >
> > In a word, Bob is responsible for preparing the WJT transaction, while
> Alice is responsible for preparing the BTC transaction and broadcasting
> both transactions.
> >
> > Here, if Bob stalls, nothing will happen, because Bob cannot spend the
> 10,000 WJT premium without Alice?s signature.
> > If Alice stalls, you are saying that Bob can spend the input of
> 1,000,000 WJT so he does not lose any money.
> >
> > I have 3 questions on this scheme.
> >
> > First, I?m not sure how do you define ?Alice stalls?. In this case,
> Alice can stall by 1) withhold the WJT tx, or 2) broadcast BTC/WJT funding
> txs but withhold the preimage.
> > If 2), this protocol is okay. But what about 1) i.e. Alice withholds the
> WJT tx? Here, Bob cannot do anything except for closing the payment channel
> and quit.
>
> Yes.
>
> >
> > Second, I?m not sure whether Bob can spend his money in this payment
> channel while the payment channel is still valid.
> > In Bitcoin, Bob needs to close the payment channel and get back his
> money first, then he can spend the money.
>
> Depends on how the payment channel is implemented.
> If you do something like send transactions spending the internal state
> outputs, then ratifying this later by performing a transaction cut-through
> to derive the next state update, then it is no different from blockchain
> layer.
> Of course, if you postulate the non-cooperation of Alice in this, there is
> indeed a need to close unilaterally.
> But this is the same as any non-cooperation in any channel system: that is
> the entire point why you have unilateral closes.
>
> >
> > Third, let?s optimistically assume Bob can close this payment channel
> without Alice?s consent.
>
> Every payment channel system worth consideration today has a unilateral
> close.
> There is no need for optimism.
>
> > Now he decides to close this channel if Alice does not broadcast the WJT
> tx all the time.
> > Alice does not need to pay for the premium if she withholds the WJT tx.
> If Alice decides not to proceed this swap, Bob should close this channel
> and get back 1,000,000 WJT. However, Bob cannot get the 10,000 WJT premium.
>
> And this time frame can be made arbitarily small by Bob by simple threat
> of unilateral close, thus not making it an option for Alice.
>
> Regards,
> ZmnSCPxj
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190812/d3532b48/attachment.html>

From praveen.baratam at gmail.com  Tue Aug 13 02:44:03 2019
From: praveen.baratam at gmail.com (Praveen Baratam)
Date: Tue, 13 Aug 2019 08:14:03 +0530
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
	mechanisms
In-Reply-To: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
Message-ID: <CAAQs3wvL_iG28ZDB10Y1ENjeNWhUOnFZ5pSWHudzYLB7D2HW6g@mail.gmail.com>

Bryan,

This is very similar to *CoinVault - Secure Depository and Secure Exchange*
technologies that I have shared with you all.
?

On Wed, Aug 7, 2019 at 7:23 PM Bryan Bishop via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> I have a proposal for implementing bitcoin vaults in a way that does not
> require any soft-forks or other software upgrades, although it could
> benefit
> from SIGHASH_NOINPUT which I'll describe later.
>
> I call them pre-signed vaults.
>
> Vault definition
> ================
>
> Here, a vault is defined as a transaction setup scheme that binds both the
> user
> and the attacker to always using a public observation and delay period
> before a
> weakly-secured hot key is allowed to arbitrarily spend coins. This is the
> same
> definition previously used[1]. During the delay period, there is an
> opportunity
> to initiate recovery/clawback which can either trigger deeper cold storage
> parameters or at least reset the delay period to start over again for the
> same
> keys.
>
> One of the important components of this is the delete-the-key pre-signed
> transaction concept, where only a single transaction is (pre)signed before
> deleting the key. This is basically an emulation of a covenant and
> enforces a
> certain outcome.
>
> Background and motivation
> =========================
>
> I was looking at Eyal and Sirer's 2016 vaults paper [1], and I saw this
> headscratcher:
>
> > Vault transactions use a delay mechanism. We note that vault transactions
> > cannot be implemented with existing timing mechanisms such as
> > CHECKLOCKTIMEVERIFY opcode or transaction locktime.
>
> This was probably written before the introduction of
> OP_CHECKSEQUENCEVERIFY.
> Still, a viable construction would have more steps than just using OP_CSV.
> They
> were probably not thinking about what those steps might be, because in the
> context of the paper they were proposing a bitcoin vault implemented using
> recursive consensus-enforced covenants via a new opcode, which obviously
> cannot
> be deployed without an upgrade fork. Covenants have been discussed for
> years,
> but require new opcodes or other consensus-enforcement changes.
>
> Relative locktimes are useful here because there is no knowledge as to
> when the
> transactions might be broadcasted in the future. The delays need to be
> relative
> to after the transaction is included in the blockchain, not to setup
> initialization time.
>
> Also, from [2]:
>
> > We show that a [vault transaction] mechanism is currently not possible
> in all
> > cryptocurrencies [...] Bitcoin's scripting language requires support for
> > covenants.
>
> I haven't seen any previous proposal for how to implement recursive bitcoin
> vaults without a fork and without a covenant. After asking around, I am
> pretty
> sure this is somewhat novel. The closest I guess is [3].
>
> Vaults are particularly interesting as a bitcoin cold storage security
> mechanism because they enable a publicly observable delay period during
> which
> time a user could be alerted by a watchtower that a thief might be in the
> process of stealing their coins, and then the user may take some actions to
> place the coins back into the vault before the relative timelock expires.
> There
> seems to be no way to get this notification or observation period without a
> vault construction. It might have been assumed it required a covenant.
>
> Having a vault construction might go a long way to discourage would-be
> attackers, on principle that the attacker might be incapable of recovering
> their cost-of-attack because the recovery mechanism can lock up the coins
> indefinitely. Griefing or denial-of-service would still be possible, of
> course,
> but with multisig there might be some ways to put a halt to that as well.
> I am
> working under the assumption that the attacker knows that the user is a
> vault
> user.
>
> Vaults
> ======
>
> The idea is to have a sequence of pre-generated pre-signed transactions
> that
> are generated in a certain way. The basic components are a vaulting
> transaction
> that locks coins into a vault, a delayed-spend transaction which is the
> only
> way to spend from a vault, and a re-vaulting transaction which can
> recover/clawback coins from the delayed-spend transaction. The security of
> this
> scheme is enforced by pre-signing transactions and deleting private keys,
> or
> with the help of SIGHASH_NOINPUT then there's another scheme where private
> keys
> are provably never known. This enforces that there's only a specific set of
> possible outcomes at every step of the vault.
>
> Some examples of what the set of broadcasted transactions might look like
> in
> regular usage:
>
>     coins -> VT -> DST -> exit via hot wallet key
>     coins -> VT -> DST -> RVT
>     coins -> VT -> DST -> RVT -> DST -> ...
>     coins -> VT -> ... -> RVT998 -> nuclear abort
>
> where:
>     VT = vault transaction
>     DST = delayed-spend transaction
>     RVT = re-vaulting transaction
>
> The delayed-spending transaction would have a single output with a script
> like:
> (
>     30 days AND hot wallet key
>  OR 10 days AND re-vaulting public key
>  OR 1 day AND 4-of-7 multisig
>  OR 0 days and super-secure nuclear abort ragequit key
> )
>
> Another diagram:
>
>     VT_100 -> DST -> (optionally) RVT -> coins are now in VT_99
>     VT_99 -> DST -> (optionally) RVT -> coins are now in VT_98
>     ...
>     VT_1 -> burn-all-coins nuclear abort ragequit (final)
>
> Definitions
> ===========
>
> Transactions and components:
>
> * Commitment/funding vault setup transaction. Signed after setting up the
> transaction tree, and it is broadcasted whenever funds are to be placed
> into
> the vault.
>
> * Delayed-spend transaction. Signed during the vault transaction tree
> setup,
> and it is broadcasted when the user wants to withdraw coins from cold
> storage
> or otherwise manipulate the coins. The output script template used by the
> delayed-spend transaction was defined earlier.
>
> * Hot wallet key: Somewhat insecure key. This can also be multisig using
> multiple hot keys.
>
> * Re-vaulting key: It is important to note that the private key either
> never
> existed (SIGHASH_NOINPUT + P2WPK for the re-vaulting transaction) or the
> private key was deleted after pre-signing the re-vaulting transaction.
>
> * 4-of-7 multisig: This is a group of differently-motivated individuals
> who are
> responsible for signing transactions. This multisig group is not necessry
> to
> describe the technique, I just think it's a useful feature for a vault to
> include.
>
> * Nuclear abort key: Also unnecessary. This is a key for which only a
> single
> signed transaction will ever exist, and that single transaction will spend
> to a
> proof-of-burn key like 0x00. This key must be extremely secure, and if
> there
> is any doubt about the ability to keep such a key secured, then it is
> better to
> not include this in the protocol. Alternatively, maybe include it as an
> option
> 50 layers down in the revaulting sequence.
>
> * Nuclear-abort pre-signed transaction. This is signed during transaction
> tree
> setup, before constructing the delayed-spend transaction. It is broadcasted
> only if the user wants to provably relinquish coins forever without giving
> the
> attacker any coins.
>
> * Re-vaulting transaction. This is where the magic happens. The re-vaulting
> transaction is signed during transaction tree setup, before constructing
> the
> delayed-spend transaction for the parent vault. The re-vaulting
> transaction is
> broadcasted when someone wants to prevent a coin withdrawal during the
> public
> observation delay period. The re-vaulting transaction spends the
> delayed-spend
> transaction outputs. It has a single output with a script created by
> running
> the entire vault setup function again. Hence, when the re-vaulting
> transaction
> is confirmed, all of the coins go back into a new identically-configured
> vault
> instead of being relinquished through the delayed-spend transaction
> timeout for
> hot wallet key signing.
>
> * Special case: final transaction. This is the very first pre-signed
> transaction during setup, and the transaction spends the coins using any
> provable burn technique. This is broadcasted only at the end of the game,
> as an
> ultimate abort and forfeiture of coins without giving in to an adversary.
> It's
> similar to the nuclear-abort ragequit transaction but it sits at the same
> place
> that a delayed-spend transaction would, at the very end of the rainbow or
> yellow brick road.
>
> Example log during vault setup
> ==============================
>
> When running the recursive vault setup function, the created artifacts (in
> order) will look like:
>
> 1) choose one of:
>    (first iteration) pre-signed burn-all-coins nuclear abort ragequit
> (final)
>    (all others) a new vault setup transaction spendable only by its
>                 delayed-spend transaction
>
> 2) pre-signed re-vaulting transaction sending to vault setup or final
> transaction, with a unique private key
>
> 3) pre-signed delayed-spend transaction, with a unique private key
>
> 4) vault transaction spendable only by the delayed-spend public key
>
> Pseudocode
> ==========
>
> In pseudocode (where PTX is a pre-signed transaction function with
> private key deletion):
>
>     VT(counter, *args, **kwargs) =
>         if counter == 0:
>             DST = PTX("burn-all-coins")
>         else:
>             next_vault = VT(counter-1, *args, **kwargs)
>             revaulting = PTX("only spendable by next_vault public key")
>             DST = PTX("DST policy including revaulting and other
> conditions")
>         vault = PTX("spendable only by this DST")
>         return vault
>
> Pre-signed transactions
> =======================
>
> What has been known for a while is that a covenant can be somewhat emulated
> using a pre-signed transaction where the user then deletes the private key,
> enforcing that the user's chosen policy must be enforced since there is
> only
> one existing option and there will only ever be one option.
>
> Such a scheme has been previously described for simple one-time and chained
> vaults [3]. I have learned that the author has an implementation that is in
> preparation, for a non-recursive version.
>
> Note that a series of pre-signed transactions can be considered to be an
> emulation of a covenant. Imagine a linear chain of pre-signed transactions
> where each hop has a relative locktime before being able to broadcast the
> next
> transaction. To recover the coins at the end of the rainbow, one would
> need to
> broadcast each sequential transaction in order and wait for the relative
> timelocks to expire each time. Here, covenants provide something like an
> undo
> for bitcoin, but only between pre-determined addresses and scripts.
>
> Fees for pre-signed transactions
> ================================
>
> There's a few different techniques to talk about:
>
> 1) SIGHASH_SINGLE|SIGHASH_ANYONECANPAY to let someone add inputs and
> outputs.
> This can get pretty complex though.
>
> 2) Add a zero-value OP_TRUE output and let anyone spend the zero-value
> output
> and attach a child-pays-for-parent (CPFP) transaction to pay for
> everything.
>
> 3) Pre-sign a variety of different possible fee rates. Unfortunately this
> involves an explosive blow-up in the amount of transaction data to
> generate. It
> might actually be a reasonable blow-up amount, only resulting in a few
> hundred
> megabytes of additional data. But given the other options, this is
> unnecessary.
>
> Delete the key (for pre-signed transactions)
> ============================================
>
> The delete-the-key trick is simple. The idea is to pre-sign at least one
> transaction and then delete the private key, thus locking in that course of
> action.
>
> Unfortunately, delete-the-key doesn't really work for multisig scenarios
> because nobody would trust that anyone else in the scheme has actually
> deleted
> the secret. If they haven't deleted the secret, then they have full
> unilateral
> control to sign anything in that branch of the transaction tree. The only
> time
> that delete-the-key might be appropriate would be where the user who
> deletes
> the key and controls the key during the setup process is also the sole
> beneficiary of the entire setup with the multisig participants.
>
> Alternative fee rates are easier to deal with using delete-the-key,
> compared to
> a technique where the private key never existed which can only be used to
> sign
> one fee rate per public key, requiring an entirely new vault subtree for
> each
> alternative fee rate. With delete-the-key, the alternative fee rates are
> signed
> with the private key before the private key is deleted.
>
> Multisig gated by ECDSA pubkey recovery for provably-unknown keys
> =================================================================
>
> A group can participate in a multisig scheme with provably-unknown ECDSA
> keys.
> Instead of deleting the key, the idea is to agree on a blockheight and then
> select the blockhash (or some function of the chosen blockhash like
> H(H(H(blockhash)))) as the signature. Next, the group agrees on a
> transaction
> and they recover the public key from the signature using ECDSA pubkey
> recovery.
> A pre-signed transaction is created, which will trigger the start of the
> public
> observation period described earlier and also start the clock for the
> bip112
> relative timelock on its output. In the output script, an OR branch
> is added that enables the use of a re-vaulting key which could also be its
> own
> separate multisig construction.
>
> This is incompatible with P2WPKH because the P2WPKH spending scriptSig
> needs to
> have the pubkey (to check the hash of the pubkey against the pubkeyhash in
> the
> scriptPubKey), which in turn makes it incompatible with ECDSA pubkey
> recovery
> which requires a hash of the message. However, with P2WPK and
> SIGHASH_NOINPUT
> instead of P2WPKH it could conceivably work. SIGHASH_NOINPUT is required
> because
> otherwise the input includes a txid which references the public key. With
> P2WPK,
> the scriptSig only needs a signature and not a public key. Note that what
> would
> be required is a version of SIGHASH_NOINPUT that does not commit to the
> public
> key, and I think a few of the NOINPUT proposals are committing to the
> public
> key.
>
> Alternatively, there may be some constructions using the 2-party ECDSA
> techniques or m-n party ECDSA techniques.
>
> Deploying exceedingly large scripts
> ===================================
>
> A brief interlude to share a somewhat obvious construction. I haven't seen
> this
> written down yet.
>
> Suppose there is a bitcoin script that someone is interested in using, but
> it
> far exceeds the size limits and sigop limits. To fix this, they would
> split up
> the script into usable chunks, and then use the delete-the-key mechanism
> (or
> the other one) to create an OR branch that is signable by a single key for
> which only a single signature is known. That new pre-signed transaction
> would
> spend to a script that has the output with the remainder of the script of
> interest. Re-vaulting or clawback clauses can be added to that output as
> well,
> but spending back to the original root script will only work by generating
> new
> scripts and keys (since the final hash isn't known until the whole tree is
> constructed, it's a dependency loop).
>
> Recursively-enforced multi-party multisig bitcoin vaults
> ========================================================
>
> Ideally, to enforce a covenant with impossible fairy dust magic, we would
> ask
> for a bitcoin transaction that could be self-referential because the
> only-one-signature-ever trick requires that the signed message be known
> before
> producing the signature, and the signature has to be known before the
> public
> key can be known, and the public key would have to be included in the
> self-referential message/transaction hash value. So, that's a dependency
> loop
> and it doesn't work. It would be interesting to explore a variation of this
> idea with masking, such that a value X can be replaced by a hash over the
> whole
> script with the X value, even though the real script will have the hash.
> Someone else can figure that one out for me :-).
>
> Instead of the self-referential values attempting to reference the same
> script that is in the process of being constructed, an alternative is to
> use
> the same script template but populate it with different parameters. The
> script
> template gets reused over and over again, all the way down the tree, until
> the
> final transaction which could be >100 years into the future once done
> adding up
> all the relative locktimes. In fact, to create and populate this terrifying
> recursive script tree, the final transaction needs to be created first, and
> then it is given as input to the script template function and that output
> is
> then given to the script template function itself-- and so on. At each
> stage,
> there are additional pre-signed transactions and values to remember.
>
> This can be written as:
>
>     final_transaction = TX(spend to 0x0000 to burn the coins)
>     initial_transaction = F(F(...F(final_transaction))
>
>     (This is missing parameters to indicate to the function what the
> spending
>     keys requirements are to be.)
>
> See earlier explanation for more details.
>
> Each call to the template populating function produces values that each
> must be
> preserved for a very long time. It is less safe to store all of the
> pre-signed
> transactions together at the same time, but more convenient. With less
> redundancy, there is an increased chance of losing data over time, which
> could
> render the coins completely frozen. This doesn't particularly worry me
> because
> forgetting a key has that property already, and this could be likened to
> hundreds of megabytes of extra key data or something. Unlike the much
> smaller
> covenant-based (opcode-based covenant) vault construction, the multiple
> layers
> here can be separately stored and protected, which might be able to protect
> against an adversary that has stolen some of the re-vaulting keys but not
> all
> of them.
>
> Optimizations can be made to store parameters for generating the remainder
> of
> the tree, such as using deterministic key derivation, such that megabytes
> of
> data wouldn't need to be long-term stored. Only the initial parameters
> would
> need to be stored.
>
> Financial privacy for custody
> =============================
>
> One of the concerns raised in [2] is that if all coins at an exchange are
> stored together in the same vault, then attackers would be able to learn
> about
> access control policies by observing scripts and keys. Some privacy can be
> recovered by using segregated vaults, at the cost of additional setup
> complexity and keeping more data in long-term storage.
>
> However, note that I think vaults are also useful for personal cold storage
> solutions.
>
> Fail-deadly mechanism
> =====================
>
> An early nuclear abort option can be added to these scripts. This idea was
> explored in [2]. This would be a very cold very secret key that would
> abort the
> re-vaulting procedure and send all coins to a (provably) nonsense key. This
> allows a vault user to destroy the coins instead of continuously
> monitoring the
> bitcoin blockchain for the rest of his life. The attacker can't recover
> their
> cost of attack if they never get the coins, and this eliminates an entire
> class
> of potential attackers who are directly interested only in financial gain.
> The
> disadvantage is that if the attacker finds the secret key for the
> fail-deadly
> mechanism and uses it, then all of the coins are gone forever.
>
> Multisig variations
> ===================
>
> The re-vaulting key could be the same key at each layer, or only sometimes
> the
> same key, or always a unique key stored separately in another secure
> location.
>
> Additionally, these re-vaulting keys could be subjected to multisig
> schemes, as
> well as Shamir secret sharing schemes or other secret sharing schemes.
>
> The idea of adding the 4-of-7 multisig component is to avoid griefing
> situations, at the cost of the additional security requirements for the
> 4-of-7
> multisig group.
>
> Key rotation for vaults
> =======================
>
> Keeping the same hot wallet key for 100 years is not advisable. Rotate the
> keys
> by setting up a new vault construction and initiating a withdrawal
> transaction
> from the old vault to the new vault.
>
> Single-use seals
> ================
>
> This proposal may have inadvertedly demonstrated a practical way to
> implement
> Peter Todd's single-use seals concept [4]. I am hesitant to say so, though,
> because I think he would ask for a more sophisticated way to verify seal
> closure.
>
> Paid defection
> ==============
>
> It might be advisable to add small rewards for evidence of defection
> amongst
> multiparty multisig setups. Besides amounts spendable by individual keys
> from a
> multisig setup, it may be possible to use a zero-knowledge contingent
> payment
> for a zero-knowledge statement like: I have a signature s over some
> message m
> which validates for pubkey pk where pk is a member of the multisig group.
> Then
> the zkcp transaction would pay for knowledge of defectors. The zkcp
> procedure
> would require interaction with the defector, while the direct pubkey method
> would not. This is similar to companies paying employees to quit when they
> value the payment over the value of continued employment.
>
> Handling change
> ===============
>
> It is important to note that this vault setup is one-time and once-only.
> There
> must only ever be one deposit into one vault. Also, spending some coins
> would
> require sending the change amount back into a new vault.  Alternatively,
> upfront work can be done to set a regular withdrawal stipend or assumption
> about how many coins are left, such that the transaction tree can be
> pre-generated for those possibilities, hence cutting down on future vault
> reinitializations. It would also be possible to commit upfront to only ever
> working in some minimum increment number of bitcoin or something.
>
> It is very important to only fund the vault once, and only with the amount
> that
> was configured when setting up the vault.
>
> References
> ==========
>
> [1] https://fc16.ifca.ai/bitcoin/papers/MES16.pdf
>
> [2]
> http://www0.cs.ucl.ac.uk/staff/P.McCorry/preventing-cryptocurrency-exchange.pdf
>
> [3]
> http://web.archive.org/web/20180503151920/https://blog.sldx.com/re-imagining-cold-storage-with-timelocks-1f293bfe421f?gi=da99a4a00f67
>
> [4]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015350.html
> or
> https://diyhpl.us/wiki/transcripts/building-on-bitcoin/2018/single-use-seals/
> or https://petertodd.org/2016/closed-seal-sets-and-truth-lists-for-privacy
>
> Acknowledgements
> ================
>
> * Jeremy Rubin for pointing out something embarrassingly broken in an
> earlier
> draft.
>
> * Bob McElrath for telling me to use SIGHASH_NOINPUT which I proceeded to
> promptly forget about.
>
> * Andrew Poelstra for the OP_TRUE trick.
>
> * Joe Rayhawk for paid defection.
>
> * Tadge Dryja for pointing out a few differences between SIGHASH_NOINPUT
> proposals.
>
>
>
> Thank you,
>
> - Bryan
> http://heybryan.org/
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
Dr. Praveen Baratam

about.me <http://about.me/praveen.baratam>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190813/55b63aec/attachment-0001.html>

From pete at petertodd.org  Tue Aug 13 14:15:32 2019
From: pete at petertodd.org (Peter Todd)
Date: Tue, 13 Aug 2019 10:15:32 -0400
Subject: [bitcoin-dev] Bitcoin vaults with anti-theft recovery/clawback
 mechanisms
In-Reply-To: <CABaSBawwSEa_dDLEXhWncsqKmsM+rdT2Npo334LEZPvcMzrzFQ@mail.gmail.com>
References: <CABaSBawe_oF_zoso2RQBX+7OWDoCwC7T2MeKSX9fYRUQaY_xmg@mail.gmail.com>
	<20190812150110.yf76pq47e5oszx62@petertodd.org>
	<CABaSBawwSEa_dDLEXhWncsqKmsM+rdT2Npo334LEZPvcMzrzFQ@mail.gmail.com>
Message-ID: <20190813141532.zv5n5ghii5e44qsf@petertodd.org>

On Mon, Aug 12, 2019 at 09:09:43PM -0500, Bryan Bishop wrote:
> > > Multisig gated by ECDSA pubkey recovery for provably-unknown keys
> > > =================================================================
> > >
> > > A group can participate in a multisig scheme with provably-unknown ECDSA
> > keys.
> > > Instead of deleting the key, the idea is to agree on a blockheight and
> > then
> > > select the blockhash (or some function of the chosen blockhash like
> > > H(H(H(blockhash)))) as the signature. Next, the group agrees on a
> > transaction
> > > and they recover the public key from the signature using ECDSA pubkey
> > recovery.
> >
> > Could you explain in more detail why you're deriving this from a blockhash?
> >
> 
> Well you need to pick an entropy source, and I wouldn't want to tell people
> to just trust the first party to tell you a good sequence of bytes.

But why does this specifically need to be entropy?

If I understand the scheme correctly, the important thing is for the ECDSA
private key to be unknown. Under the standard assumption that hash functions
are random oracles, hashing anything should be sufficient to create a pubkey
whose private key is unknown.

Secondly, there's probably better slightly privacy if a random nonce is chosen
(perhaps by concatenating a nonce from each party) rather than picking pubkeys
unique to this use-case.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190813/686185e5/attachment.sig>

From tamas.blummer at gmail.com  Wed Aug 14 02:32:40 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Wed, 14 Aug 2019 04:32:40 +0200
Subject: [bitcoin-dev] side memory - Transient memory of an other peer to
 peer network controlled through the bitcoin utxo set
Message-ID: <56030D8B-0EF4-4BE1-9CA0-EEDC2CF1B235@gmail.com>

It appears to me that there is a generic design pattern for peer to peer networks,
that we might call side memory.

The name is justified with some similarity to side chains. Side memory is however
not about a persistent store, but some transient memory of an other peer to peer network.

The UTXO set is the shared transient memory of the bitcoin network.

Just like we can link the bitcoin block chain with a side chain, we can link
the transient memory of an other network with the UTXO set of bitcoin.

The other network?s transient memory would hold an item until a uniquelly associated
a coin in the UTXO set is unspent. There are many ways to associate data with
an UTXO. How this is done is not a concern here. The method must however allow
the coin to be spent again, so the UTXO set can also trigger eviction of the associated
data from the other network?s memory.

The utility of such association is to impose control and the scarcity of bitcoin to
some other network?s transient memory.

Since the number of possible UTXOs is huge (21 million * 100million) an
associated peer to peer network will want to raise the bar for UTXOs eligible
to enter its store.

An obvious choice for raising the bar is requiring more satoshis to be committed.
The other network may dynamically tailor this requirement or let users compete
for a fixed capacity by committing higher amounts.

Observing the UTXO set is however not a cheap operation. Nodes of the other
network would have to also run a bitcoin node to be sure they do not miss
changes of the UTXO.

There is however a way to significantly simplify this task by using time locks and
SPV validation as follows:

The UTXO committing to associated data would have a relative timelock, such that
it can not be spent within n blocks after it entered the UTXO set. (with OP_CSV)

A network node that originally publishes the data would also send an SPV proof
of the inclusion of associated commitment into the bitcoin blockchain to its peers.

Other network nodes would therefore only need to observe the progress of
bitcoin?s header chain to validate the proof, which is the commitment transaction
and the path to merkle root, before accepting data into their transient store.

The commitment transaction also tells them how long the output can not be spent,
therefore they are relived the burden of watching for UTXO spends. Instead they
can evict the associated data from their transient store as soon as the header
chain they oberve is progressed past the relative locktime.

Nodes that publish new data would have to listen to all blocks after they
broadcast the commitment, until they see it confirmed and can extract the proof.
This could be further optimized if BIP158 filters were available and committed.

The network nodes could use IBLTs (Invertible Bloom Lookup Tables) to distribute
associated data.

Such an associated network would be lightweight since only observing and
storing bitcoin?s header chain and its own peer to peer network.

I will soon release the code of a network that implements this design pattern,
with the SPV optimization and IBLTs, and am looking for help to test it in a
limited deployment, before letting it out into the wild.

Please drop me a mail if you?d like to help there.

Prior art that I summed up as side memory:

The idea of linking names with UTXO goes back to the first fork of Bitcoin and
was significantly upgraded in the numerifides proposal[1] of tyzbit

ZmnSCPxj proposed an advertizement network in which the network's content
is controlled by associated UTXOs in [2].

I observed that time locked commitments would uncover to bitcoin?s internal
riskless interest rate [3].

The pattern is useful as sybill attack protection of coinjoin networks as time locked
commitments can act as fidelity bonds [4]

Regards,

Tamas Blummer

[1] https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001207.html
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017083.html
[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017059.html
[4] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017169.html
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190814/fc771022/attachment.sig>

From lf-lists at mattcorallo.com  Wed Aug 14 15:07:19 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Wed, 14 Aug 2019 11:07:19 -0400
Subject: [bitcoin-dev] Bitcoin Core to disable Bloom-based Filtering by
	default
In-Reply-To: <FF0175BF-1D1F-4AD4-9B13-99D522DBCD83@bridge21.com>
References: <59fad2b6-9b15-ffec-116e-91d27ce29f80@mattcorallo.com>
	<FF0175BF-1D1F-4AD4-9B13-99D522DBCD83@bridge21.com>
Message-ID: <C345325B-D0DE-42FD-849E-5DEF4BBC3C59@mattcorallo.com>

You very clearly didn't bother to read other mails in this thread. To make it easy for you, here's a few links:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017147.html
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-July/017175.html

Matt

> On Aug 13, 2019, at 23:05, Will Madden <will.madden at bridge21.com> wrote:
> 
> For the record, strong NACK. My understanding is that this breaks several established SPV implementations (such as early breadwallet for sure and possibly current BRD wallets) and I have yet to see quantitative prioritization or even a rational justification for this change.
> 
> Requiring SPV wallets to communicate with trusted nodes is centralization, and breaking functionality and implementations that enable this without a thoroughly researched rationale is highly suspect.
> 
>> On Jul 20, 2019, at 1:46 PM, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Just a quick heads-up for those watching the list who may be using it -
>> in the next Bitcoin Core release bloom filter serving will be turned off
>> by default. This has been a long time coming, it's been an option for
>> many releases and has been a well-known DoS vector for some time.
>> As other DoS vectors have slowly been closed, this has become
>> increasingly an obvious low-hanging fruit. Those who are using it should
>> already have long been filtering for NODE_BLOOM-signaling nodes, and I
>> don't anticipate those being gone any time particularly soon.
>> 
>> See-also PR at https://github.com/bitcoin/bitcoin/pull/16152
>> 
>> The release notes will liekly read:
>> 
>> P2P Changes
>> -----------
>> - The default value for the -peerbloomfilters configuration option (and,
>> thus, NODE_BLOOM support) has been changed to false.
>> This resolves well-known DoS vectors in Bitcoin Core, especially for
>> nodes with spinning disks. It is not anticipated that
>> this will result in a significant lack of availability of
>> NODE_BLOOM-enabled nodes in the coming years, however, clients
>> which rely on the availability of NODE_BLOOM-supporting nodes on the
>> P2P network should consider the process of migrating
>> to a more modern (and less trustful and privacy-violating) alternative
>> over the coming years.
>> 
>> Matt
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190814/bfe67a7a/attachment.html>

From john at johnnewbery.com  Fri Aug 16 15:23:37 2019
From: john at johnnewbery.com (John Newbery)
Date: Fri, 16 Aug 2019 11:23:37 -0400
Subject: [bitcoin-dev] Burying CSV and segwit soft fork activations
Message-ID: <CAFmfg2tv4AP6GYSeHkgOYBKiWa3ia_KxWWBBjqY5u4-GkW6oLw@mail.gmail.com>

Once a consensus change has been activated and buried by sufficient work,
we consider the height of that change to be historic fact. The exact
activation method is no longer of practical interest. In some cases the
cause of activation is not even decidable. For example, we know that segwit
activated at height 481,824 but it's debatable whether that was due to BIP
9 version bits signaling, BIP 148 UASF, or a combination of the two.

In such cases, we can significantly simplify the implementation by
hard-coding the activation height. This was done for the 3 ISM soft forks
(BIPs 34, 66 and 65) in BIP 90 [1] [2]. P2SH and segwit script enforcement
were backdated to the genesis block (with the exception of for one block)
for similar code simplification reasons [3] [4].

'Burying' deployments in this way provides a number of benefits:

1. consensus code is simplified and implementers can avoid writing and
testing code paths that are no longer relevant.
2. a hard-coded activation height is far easier to review and re-implement
than complex deployment activation logic.
3. using a non-contextual check (in this case a hard-coded constant) can
provide performance and code structure benefits (eg reducing lock
contention on blockchain data).

Bitcoin Core PR 16060 [5] was recently merged, which buries the CSV and
segwit activation heights to 419328 and 481824 respectively.

It is technically possible for this to be a non-backwards compatible
change. In the event of a re-org below the BIP9 segwit LOCKED_IN height,
this change _could_ cause a chainsplit between pre-0.19 nodes and 0.19
nodes. Such a re-org would require re-doing over 93% of the total work ever
committed to Bitcoin mining (chainwork is 0x7eb6a652531c5ad6a4b8e9 at
height 481824 compared to 0x07d75b9d25fb6602be2b51c6 at height 590393). To
quote from BIP90:

> The occurrence of such a reorg that would cause the activating block to
be disconnected would raise fundamental concerns about the security
assumptions of Bitcoin, a far bigger issue than any non-backwards
compatible change.

> So while this proposal could theoretically result in a consensus split,
it is extremely unlikely, and in particular any such circumstances would be
sufficiently damaging to the Bitcoin network to dwarf any concerns about
the effects of this proposed change.

(See the 'Considerations' section of BIP 90 for more details).

Cheers,
John

[1] https://github.com/bitcoin/bips/blob/master/bip-0090.mediawiki
[2] https://github.com/bitcoin/bitcoin/pull/8391
[3]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015588.html
[4] https://github.com/bitcoin/bitcoin/pull/11739
[5] https://github.com/bitcoin/bitcoin/pull/16060
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190816/c439614c/attachment.html>

From pete at petertodd.org  Fri Aug 16 16:06:50 2019
From: pete at petertodd.org (Peter Todd)
Date: Fri, 16 Aug 2019 12:06:50 -0400
Subject: [bitcoin-dev] Burying CSV and segwit soft fork activations
In-Reply-To: <CAFmfg2tv4AP6GYSeHkgOYBKiWa3ia_KxWWBBjqY5u4-GkW6oLw@mail.gmail.com>
References: <CAFmfg2tv4AP6GYSeHkgOYBKiWa3ia_KxWWBBjqY5u4-GkW6oLw@mail.gmail.com>
Message-ID: <20190816160650.artngylrzy2id5tr@petertodd.org>

On Fri, Aug 16, 2019 at 11:23:37AM -0400, John Newbery via bitcoin-dev wrote:
> Once a consensus change has been activated and buried by sufficient work,
> we consider the height of that change to be historic fact. The exact
> activation method is no longer of practical interest. In some cases the
> cause of activation is not even decidable. For example, we know that segwit
> activated at height 481,824 but it's debatable whether that was due to BIP
> 9 version bits signaling, BIP 148 UASF, or a combination of the two.

I just wanted to elaborate on this excellent point:

This is debatable because Bitcoin is a decentralized, soft-forks are backwards
compatible, and it's very difficult if not impossible to measure the
preferences of economically significant nodes. Both the BIP9 version bits
signalling and the BIP 148 UASF had the same basic effect: enforce segwit.
Furthermore, the BIP 148 UASF rejected blocks that didn't signal via the BIP9
version bits.

We can observe the fact that 100% of known blocks produced after Aug 1st 2017
have complied with segwit rules, and the BIP9 signalling protocol for segwit.
But strictly speaking we don't really know why that happened. It's possible
that miners were running the BIP9 signalling Bitcoin Core release around that
time. It's also possible that miners were running UASF enforcing software.
It's possible there was a combination of both. Or even entirely different
software - remember that some miners produced segwit-valid blocks, but didn't
actually mine segwit transactions. Each scenario leads to the same externally
observable outcome.

Furthermore there's the question as to why miners were producing
segwit-compliant blocks: perhaps they thought the vast majority of economically
significant nodes would reject their blocks? Perhaps they just wanted to
enforce segwit?

These are all questions that have plausible answers, backed by evidence and
argument. But because Bitcoin is a decentralized network no authority can tell
you what the answers are.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190816/88afef25/attachment.sig>

From eric at voskuil.org  Fri Aug 16 17:44:47 2019
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 16 Aug 2019 13:44:47 -0400
Subject: [bitcoin-dev] Burying CSV and segwit soft fork activations
In-Reply-To: <20190816160650.artngylrzy2id5tr@petertodd.org>
References: <CAFmfg2tv4AP6GYSeHkgOYBKiWa3ia_KxWWBBjqY5u4-GkW6oLw@mail.gmail.com>
	<20190816160650.artngylrzy2id5tr@petertodd.org>
Message-ID: <2377A2C2-04E6-4128-A756-2909474C423C@voskuil.org>

Thanks for adding this to the record.

And for the record I?ll reiterate here, as I did with BIP90, that this is a hard fork.

e

> On Aug 16, 2019, at 12:06, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> On Fri, Aug 16, 2019 at 11:23:37AM -0400, John Newbery via bitcoin-dev wrote:
>> Once a consensus change has been activated and buried by sufficient work,
>> we consider the height of that change to be historic fact. The exact
>> activation method is no longer of practical interest. In some cases the
>> cause of activation is not even decidable. For example, we know that segwit
>> activated at height 481,824 but it's debatable whether that was due to BIP
>> 9 version bits signaling, BIP 148 UASF, or a combination of the two.
> 
> I just wanted to elaborate on this excellent point:
> 
> This is debatable because Bitcoin is a decentralized, soft-forks are backwards
> compatible, and it's very difficult if not impossible to measure the
> preferences of economically significant nodes. Both the BIP9 version bits
> signalling and the BIP 148 UASF had the same basic effect: enforce segwit.
> Furthermore, the BIP 148 UASF rejected blocks that didn't signal via the BIP9
> version bits.
> 
> We can observe the fact that 100% of known blocks produced after Aug 1st 2017
> have complied with segwit rules, and the BIP9 signalling protocol for segwit.
> But strictly speaking we don't really know why that happened. It's possible
> that miners were running the BIP9 signalling Bitcoin Core release around that
> time. It's also possible that miners were running UASF enforcing software.
> It's possible there was a combination of both. Or even entirely different
> software - remember that some miners produced segwit-valid blocks, but didn't
> actually mine segwit transactions. Each scenario leads to the same externally
> observable outcome.
> 
> Furthermore there's the question as to why miners were producing
> segwit-compliant blocks: perhaps they thought the vast majority of economically
> significant nodes would reject their blocks? Perhaps they just wanted to
> enforce segwit?
> 
> These are all questions that have plausible answers, backed by evidence and
> argument. But because Bitcoin is a decentralized network no authority can tell
> you what the answers are.
> 
> -- 
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From orlovsky at protonmail.com  Mon Aug 19 22:08:09 2019
From: orlovsky at protonmail.com (Dr Maxim Orlovsky)
Date: Mon, 19 Aug 2019 22:08:09 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
Message-ID: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>

Hi,

I'd like to propose a design for distributed storage and messaging with escrow/economic incentivization leveraging LNP/BP ecosystem and working at Layer 2 and 3. It is described in details here: https://github.com/storm-org/storm-spec [1]

Briefly, it allows to construct special type of payment channels guaranteeing remote data storage and retrieval with counterparty risks mitigated by economic stimulus (stakes etc). Next, it can be combined with Lightning Network, i.e. operate completely off-chain ("Storm with Lightning" :).

This proposal came as a side-effect of our joint work on RGB and single-use seals technologies (recently mentioned by Peter Todd here [2]). In the nearest future I will be busy with finalizing and implementing these protocols, but don't want this idea to be missed/forgotten, since it can be very useful for other L2/L3 technologies requiring client-stored data, like guaranteeing external storage of script data for Taproot, scriptless scripts or Prometheus (technology for scalable computing [3]). So I'd welcome any possible comments, critics, or interest in driving Storm development forward.

[1] https://github.com/storm-org/storm-spec
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-August/017257.html
[3] https://github.com/pandoracore/prometheus-spec/blob/master/prometheus.pdf

------

Dr Maxim Orlovsky
Pandora Core AG
https://twitter.com/dr_orlovsky
https://github.com/dr-orlovsky
xorlovsky[1..]@pandoracore.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190819/31c10a56/attachment.html>

From pieter.wuille at gmail.com  Mon Aug 19 23:17:21 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 19 Aug 2019 16:17:21 -0700
Subject: [bitcoin-dev] Miniscript
Message-ID: <CAPg+sBiknRwBc8RV62wtuRVYi6wE1HNw6_ePquYVMWvjwp46bg@mail.gmail.com>

Hi all,

Miniscript is a project we've been working on for the past year or so,
and is now at a stage where I'd like to get it some more attention. It is joint
work with Andrew Poelstra and Sanket Sanjalkar.

It's a language for writing (a subset of) Bitcoin Scripts in a structured way,
enabling analysis, composition, generic signing and more.

For example the script

  <A> OP_CHECKSIG OP_IFDUP OP_NOTIF OP_DUP OP_HASH160 <hash160(B)>
  OP_EQUALVERIFY OP_CHECKSIGVERIFY <144> OP_CSV OP_ENDIF

in Miniscript notation would be

  or_d(c:pk(A),and_v(vc:pk_h(B),older(144)))

making it human (engineer?) readable that this is a script that permits A to
take the coins at any time, and B after 1 day. A full description of the
language can be found on the project website http://bitcoin.sipa.be/miniscript

Using Miniscript it's possible to:
* Write descriptors for addresses for scripts that implement things more
  complicated than multisig.
* Make software that can deal with composition of policies (e.g. have funds
  in a 2-of-3 setup where one of the 3 "keys" is itself a policy that involves
  perhaps multiple devices and timeouts).
* Compile complex spending policies to efficient scripts.
* Figure out under what necessary and/or sufficient conditions a script can be
  satisfied.
* Given signatures for a sufficient set of keys (and hash preimages, if needed),
  generically construct a witness for arbitrary scripts, without metadata
  apart from the script itself and public keys appearing in it. This means
  generic PSBT signers are possible for this class of scripts.
* Compute the bounds on the size of a witness for arbitrary scripts.
* Perform static analysis to see if any of Script's resource limitations
  (ops limit, stack size, ...) might interfere with the ability to spend.
* Who knows what else...

We have two implementations:
* a C++ one (https://github.com/sipa/miniscript)
* a Rust library (https://github.com/apoelstra/rust-miniscript).

The implementations are a work in progress, but through large scale randomized
tests we have confidence that the language design and associated witnesses are
compatible with the existing consensus and standardness rules.

To be clear: Miniscript is designed for Bitcoin as it exists today (primarily
P2WSH), and does not need any consensus changes. That said, we plan to extend
the design to support future script changes Bitcoin may include.

Cheers,

-- 
Pieter

From david.vorick at gmail.com  Tue Aug 20 07:15:24 2019
From: david.vorick at gmail.com (David Vorick)
Date: Tue, 20 Aug 2019 03:15:24 -0400
Subject: [bitcoin-dev] Miniscript
In-Reply-To: <CAPg+sBiknRwBc8RV62wtuRVYi6wE1HNw6_ePquYVMWvjwp46bg@mail.gmail.com>
References: <CAPg+sBiknRwBc8RV62wtuRVYi6wE1HNw6_ePquYVMWvjwp46bg@mail.gmail.com>
Message-ID: <CAFVRnyp0Z997-UwJMFn3H7N0ogHTkxc+fDj-yROit3coUk1rxw@mail.gmail.com>

Glad to see this post. I have been following Miniscript for some time, and
the static
analysis that is possible with Miniscript is particularly interesting to me.

Today, new Bitcoin applications such as JoinMarket, Wasabi wallet, and
Arwen all
suffer from a problem of having novel bitcoin scripts. Bitcoin script is
not easy to
analyze, and historically it has been difficult for me to get comfortable
using these
applications because I have been unable to convince myself to have complete
confidence in the integrity of the transactions these applications want me
to sign.

Well established applications can eventually overcome this issue for users
by
getting sufficient expert review and commentary, however this proves as a
substantial barrier to entry in an ecosystem that is ideally as open as
possible.

Miniscript can make a huge difference here. With Miniscript, it possible to
create
hardware wallets that can perform static analysis on novel miniscripts and
provide
the user with assurances about the nature of the transactions. A hardware
wallet
with a Miniscript analyzer may not be able to tell you that a transaction
is a
CoinJoin transaction, but it will be able to tell you that under all
possible scenarios,
you end up with just as many coins in your addresses that you started with,
modulo
some transaction fee.

This is a big deal for novel application writers, as it significantly
reduces the barrier
for them to convince both themselves and others that the code they wrote
does not
risk user funds being lost, especially if all transactions are being
externally analyzed
and signed.

Miniscript is not of course a complete solution, for example it cannot
solve all of the
high-risk edge cases that are present in the lightning network, but it is a
big step
forward and I believe that widespread use of Miniscript would be a huge
boon to the
Bitcoin ecosystem.

On Mon, Aug 19, 2019 at 7:18 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> Miniscript is a project we've been working on for the past year or so,
> and is now at a stage where I'd like to get it some more attention. It is
> joint
> work with Andrew Poelstra and Sanket Sanjalkar.
>
> It's a language for writing (a subset of) Bitcoin Scripts in a structured
> way,
> enabling analysis, composition, generic signing and more.
>
> For example the script
>
>   <A> OP_CHECKSIG OP_IFDUP OP_NOTIF OP_DUP OP_HASH160 <hash160(B)>
>   OP_EQUALVERIFY OP_CHECKSIGVERIFY <144> OP_CSV OP_ENDIF
>
> in Miniscript notation would be
>
>   or_d(c:pk(A),and_v(vc:pk_h(B),older(144)))
>
> making it human (engineer?) readable that this is a script that permits A
> to
> take the coins at any time, and B after 1 day. A full description of the
> language can be found on the project website
> http://bitcoin.sipa.be/miniscript
>
> Using Miniscript it's possible to:
> * Write descriptors for addresses for scripts that implement things more
>   complicated than multisig.
> * Make software that can deal with composition of policies (e.g. have funds
>   in a 2-of-3 setup where one of the 3 "keys" is itself a policy that
> involves
>   perhaps multiple devices and timeouts).
> * Compile complex spending policies to efficient scripts.
> * Figure out under what necessary and/or sufficient conditions a script
> can be
>   satisfied.
> * Given signatures for a sufficient set of keys (and hash preimages, if
> needed),
>   generically construct a witness for arbitrary scripts, without metadata
>   apart from the script itself and public keys appearing in it. This means
>   generic PSBT signers are possible for this class of scripts.
> * Compute the bounds on the size of a witness for arbitrary scripts.
> * Perform static analysis to see if any of Script's resource limitations
>   (ops limit, stack size, ...) might interfere with the ability to spend.
> * Who knows what else...
>
> We have two implementations:
> * a C++ one (https://github.com/sipa/miniscript)
> * a Rust library (https://github.com/apoelstra/rust-miniscript).
>
> The implementations are a work in progress, but through large scale
> randomized
> tests we have confidence that the language design and associated witnesses
> are
> compatible with the existing consensus and standardness rules.
>
> To be clear: Miniscript is designed for Bitcoin as it exists today
> (primarily
> P2WSH), and does not need any consensus changes. That said, we plan to
> extend
> the design to support future script changes Bitcoin may include.
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190820/7f2e5916/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Aug 20 08:14:13 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 20 Aug 2019 08:14:13 +0000
Subject: [bitcoin-dev] Miniscript
In-Reply-To: <CAFVRnyp0Z997-UwJMFn3H7N0ogHTkxc+fDj-yROit3coUk1rxw@mail.gmail.com>
References: <CAPg+sBiknRwBc8RV62wtuRVYi6wE1HNw6_ePquYVMWvjwp46bg@mail.gmail.com>
	<CAFVRnyp0Z997-UwJMFn3H7N0ogHTkxc+fDj-yROit3coUk1rxw@mail.gmail.com>
Message-ID: <YFM_3Midr1wdjxhejsksW0i4gTER2cF9XsjETAbJvnO_I77zkwJTHXKdDMK0qKSebO0KVTJ3sH0moZ6_olKUGAec0u9sgprInc6M3ktQR7w=@protonmail.com>

Good morning David,

> Today, new Bitcoin applications such as JoinMarket, Wasabi wallet, and Arwen all
> suffer from a problem of having novel bitcoin scripts.

For CoinJoin (JoinMarket, Wasabi) at least, I believe there is no need of novel Bitcoin SCRIPTs.
Indeed, from what I can tell they use only P2WPKH `SIGHASH_ALL` signatures and P2WPKH outputs: there seems to be nothing to analyze there.

I do not believe Miniscript would benefit those in particular.
(though miniscript does have other benefits as well: in particular sufficiently-advanced miniscript compilers will be able to write shorter SCRIPTs than mere unaided humans can)

I have not investigated much of Arwen yet but it seems to me to be a sort of exchange-specific payment-channel implementation.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Aug 21 04:14:13 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 21 Aug 2019 04:14:13 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
Message-ID: <6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>

Good morning Maxim,

Insufficient/unclear Description of Probabilistic Proof
=======================================================

It seems to me that the probabilistic checkable proof, whose description I read naively, is not sufficient to prove the statement:

* The source data is the same as the source data originally stored by Alice.

When generating the proof, Bob can use the output of any PRNG as the "source data".
If Alice only checks validity of this proof, then it will accept the output of the PRNG as the actual stored data, which from what I understand is not your goal.

The probabilistic checkable proof by itself just proves the statement:

* The encrypted data corresponds to the given plaintext.

So, before Alice sends its local copy of the data to Bob for storage and deletes it, Alice must first compute a Merkle Tree of the data chunks and store the Merkle Tree root (a small 32-byte data).
And the probabilistic checkable proof has to include the Merkle Tree Path proofs of the selected *source* data chunks together with the source chunks.

Similar problems arise in the pay-for-data scheme proposed in Lightning:https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-June/002035.html
The data provider is trusted to give actual data instead of the output of a PRNG.

In the case of paid storage, Alice had access to the data originally stored (presumably) and can keep a short "checksum" of the original data.

It might be that you imply this in your step 1 for Alice validation of the probabilistic checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:

> With this data Alice will be able to check with this zero-knowledge argument by:
> 1. Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them

Will the Real Decryption Key Please Stand Up?
=============================================

Also, it seems to me that the encryption used must be an asymmetrical encryption.
That is, the encryption and decryption keys must be different, with the encryption key being a "public" key Bob can safely share with Alice and the decryption key being a "private" key that Bob can share only once it has acquired its funds.

An issue that arises is: while an HTLC is used to atomically transfer the decryption key in exchange for payment, what is the assurance given to Alice that the hash of the decryption key is indeed the hash of the decryption key and not, say, the output of a PRNG?

That is, Bob must prove:

* The given hash h is the hash of the secret decryption key d whose equivalent encryption key is e

...while revealing only h and e to Alice.

If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.
Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.

Transporting Storm Over Lightning
=================================

Of note is that any mechanism that requires multiple participants to put up money into a contract (as in the case of Storm, which requires both the stake from Bob and the reward from Alice to be put into a single timebound HTLC) can only live inside a single LN channel and is not transportable across intermediate nodes.
This is because intermediate nodes potentially become subject to attack in case of routing failure.
(Though it *may* be possible to reuse the sketch I give here for HTLC-enforced publication of combined HTLCs: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002055.html)

This is part of what makes LN difficult to work with multiple asset types due to HTLCs naturally forming premium-free American Call Options.
Avoiding premium-free American Call Options is possible by extracting the premium from the receiver and combining it with the money from the exchange, but this again is doable only onchain, or in a single LN channel (meaning receivers must centralize around exchanges).

It may be possible to get around this, once Lightning supports payment points + scalars, by use of EC magic homomorphisms, though I lack the energy right now to go dig up the resources on lightning-dev.
But the storage provider can route a payment to Alice to serve as stake, which can be claimed only if knowing some secret, then Alice routes the stake+reward to Bob, and use some of the EC magic homomorphism while keeping intermediate nodes unaware.

Regards,
ZmnSCPxj



From ZmnSCPxj at protonmail.com  Wed Aug 21 07:32:25 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 21 Aug 2019 07:32:25 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
	<6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
Message-ID: <x1b18QXzxALwxxp8ehwcB7XORizrw5vOJ9BNXWpXbd2SJgUra-AFIyTgnM_yxKEtCg_frZcz916NLmm-pTsCD4Z7aOFprdQ_W87mHnn8vYg=@protonmail.com>

Good morning Maxim,

The Deaf Bob Attack
===================

It seems to me that Bob can promote the N3 problem to the N2 problem.

Suppose Alice contacts Bob to get the data.
However, Bob happens to have lost the data in a tragic boating accident.

Now, supposedly what Alice does in this case would be to broadcast the HTLC settlement transaction, whose signature was provided by Bob during protocol setup.

But this seems unworkable.

* If Bob managed to sign the HTLC settlement transaction, what `SIGHASH` flags did Bob sign with?
  * If it was `SIGHASH_ALL` or `SIGHASH_SINGLE`, then Bob already selected the decryption key at setup time.
  * If it was `SIGHASH_NONE`, then Alice could put any SCRIPT, including `<Alice> OP_CHECKSIG`.

If Bob already selected the decryption key at setup time, then Bob can ignore Alice.

* If Alice does not publish the HTLC settlement transaction, then Bob will eventually enter the N2 state and get the stake+reward.
* If Alice *does* publish the HTLC settlement transaction, without Bob giving the encrypted data, then Bob can just use the hashlock and reveal the decryption key.
  * The decryption key is useless without the encrypted data!

It seems this part is not workable?
As the decryption key is embedded in the HTLC, Alice cannot get a signature from Bob without the decryption key already being selected by Bob (and thus already claimable even without any data being returned by Bob).


Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed Aug 21 12:12:30 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 21 Aug 2019 12:12:30 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <A733B8A1-2E88-47F4-A6CF-C56C84E8FF9A@pandoracore.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
	<6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
	<A733B8A1-2E88-47F4-A6CF-C56C84E8FF9A@pandoracore.com>
Message-ID: <ZUfNKbb6WUnXsNZX-WYwkIDby7UcTuagwHFoay99gD39SnWLr26J7N1CtwXmdlrrwuvjpaGAt5IMyr0-flhrpGYpV0ChXsXFn00Qf6cEzPM=@protonmail.com>

Good morning Maxim,

I also sent another email with the below text, it seems to have gotten missed somehow or not sent properly or some other problem.

The Deaf Bob Attack
===================

It seems to me that Bob can promote the N3 problem to the N2 problem.

Suppose Alice contacts Bob to get the data.
However, Bob happens to have lost the data in a tragic boating accident.

Now, supposedly what Alice does in this case would be to broadcast the HTLC settlement transaction, whose signature was provided by Bob during protocol setup.

But this seems unworkable.

* If Bob managed to sign the HTLC settlement transaction, what `SIGHASH` flags did Bob sign with?
  * If it was `SIGHASH_ALL` or `SIGHASH_SINGLE`, then Bob already selected the decryption key at setup time.
  * If it was `SIGHASH_NONE`, then Alice could put any SCRIPT, including `<Alice> OP_CHECKSIG`.

If Bob already selected the decryption key at setup time, then Bob can ignore Alice.

* If Alice does not publish the HTLC settlement transaction, then Bob will eventually enter the N2 state and get the stake+reward.
* If Alice *does* publish the HTLC settlement transaction, without Bob giving the encrypted data, then Bob can just use the hashlock and reveal the decryption key.
  * The decryption key is useless without the encrypted data!

It seems this part is not workable?
As the decryption key is embedded in the HTLC, Alice cannot get a signature from Bob without the decryption key already being selected by Bob (and thus already claimable even without any data being returned by Bob).

Regards,
ZmnSCPxj

> Hi ZmnSCPxj,
>
> Thank you very much for spending your time on analysing my idea at such deep level ? and writing the detailed review proposing possible solutions to the main found issues.
>
> > Insufficient/unclear Description of Probabilistic Proof
> >
> > ========================================================
> >
> > <...>
> > It might be that you imply this in your step 1 for Alice validation of the probabilistic checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:
> >
> > > With this data Alice will be able to check with this zero-knowledge argument by:
> > >
> > > 1.  Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them
>
> Correct, I forgot to put this step into the description, will fix, sorry for that. Indeed, Alice needs to take a "shot" from the data in a form of Merkle tree and keep its root for herself, and Bob has to provide her with
>
> -   "PCP-selected" blocks of source
> -   "PCP-selected" blocks of encrypted data
> -   siblings of the Merkle root "leafs" for the selected source data (required for Alice to check source data paths up to the Merkle root which she had kept for herself)
> -   Merkle paths for both of them
> -   public key used for the encryption, so Alice can re-encrypt received source data blocks and make sure they are equal to the provided encrypted blocks, so this public key is true
>
>
> > Will the Real Decryption Key Please Stand Up?
> >
> > ==============================================
> >
> > Also, it seems to me that the encryption used must be an asymmetrical encryption.
> > That is, the encryption and decryption keys must be different, with the encryption key being a "public" key Bob can safely share with Alice and the decryption key being a "private" key that Bob can share only once it has acquired its funds.
>
> Correct, it should be working like in PGP/GPG
>
> > That is, Bob must prove:
> >
> > -   The given hash h is the hash of the secret decryption key d whose equivalent encryption key is e
> >
> > ...while revealing only h and e to Alice.
>
> Yes, that is an important point, I've missed that out.
>
> > If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.
> > Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.
>
> Very elegant solution, thank you! Yes, seems one can encrypt/decrypt with EC:https://developer.ibm.com/swift/2019/03/04/blueecc-elliptic-curve-cryptography/ and this should work. I will include your solution into the proposal.
>
> It also might be possible to implement your solution with threshold ECDSA signatures, that will enable Storm before Schorr's will get to Bitcoin. I am not very good in understanding them yet, but it seems that multiparty ECDSA (or threshold ECDSA, t-ECDSA) unlock many of Schnorr?s signature features and benefits.
> One may check https://github.com/KZen-networks/multi-party-ecdsa and papers:
>
> -   https://eprint.iacr.org/2019/114.pdf
> -   https://link.springer.com/chapter/10.1007/978-3-319-39555-5_9 https://twitter.com/alexbosworth/status/1163116574238056448
>
>     I will investigate that in more details.
>
>
> > Transporting Storm Over Lightning
> >
> > ==================================
> >
> > Of note is that any mechanism that requires multiple participants to put up money into a contract (as in the case of Storm, which requires both the stake from Bob and the reward from Alice to be put into a single timebound HTLC) can only live inside a single LN channel and is not transportable across intermediate nodes.
> > This is because intermediate nodes potentially become subject to attack in case of routing failure.
> > (Though it may be possible to reuse the sketch I give here for HTLC-enforced publication of combined HTLCs: https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002055.html)
> > This is part of what makes LN difficult to work with multiple asset types due to HTLCs naturally forming premium-free American Call Options.
> > Avoiding premium-free American Call Options is possible by extracting the premium from the receiver and combining it with the money from the exchange, but this again is doable only onchain, or in a single LN channel (meaning receivers must centralize around exchanges).
> > It may be possible to get around this, once Lightning supports payment points + scalars, by use of EC magic homomorphisms, though I lack the energy right now to go dig up the resources on lightning-dev.
> > But the storage provider can route a payment to Alice to serve as stake, which can be claimed only if knowing some secret, then Alice routes the stake+reward to Bob, and use some of the EC magic homomorphism while keeping intermediate nodes unaware.
>
> You are right, my solution is limited to a single LN channels, i.e. there must be a direct dually-funded channel between Alice and Bob (and we don't have dually-funded channels as a part of current LN BOLT's). I will add this disclaimer to the spec.
>
> Your solution to the transporting problem is indeed very interesting, however I need some time to analyze it in more details. Meanwhile, if you don't mind, I will open an issue in GitHub and will be copying the discussion to there as well, so others from outside of this mail list can also join.
>
> Kind regards,
> Maxim Orlovsky
> https://github.com/dr-orlovsky



From ZmnSCPxj at protonmail.com  Wed Aug 21 12:48:16 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 21 Aug 2019 12:48:16 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <gzj3nFgqW8Tc2eV8WQRGrC6GYyAGEJiVLgG7KA5tmosZ5NJpz3k4cIgBH9KszySwe3pcQMtit_-hOb6JZzPjH5p4Mi9-xqyWCT6p8leSU8Q=@protonmail.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
	<6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
	<gzj3nFgqW8Tc2eV8WQRGrC6GYyAGEJiVLgG7KA5tmosZ5NJpz3k4cIgBH9KszySwe3pcQMtit_-hOb6JZzPjH5p4Mi9-xqyWCT6p8leSU8Q=@protonmail.com>
Message-ID: <-88WqEQyIbOd9y51ewaYLJwIbxCxCUQZKPD7zd3KhaCVw8Tknts8zKLmqGRZBJBQzGYbUVLgW4RZny6eQu-rGof5yImn7MLEKsNi5T0GOnI=@protonmail.com>

Good morning Maxim,

> > <...>
> > It might be that you imply this in your step 1 for Alice validation of the probabilistically checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:
> >
> > > With these data, Alice will be able to check with this zero-knowledge argument by:
> > >
> > > 1.  Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them
>
> Correct, I forgot to put this step into the description, will fix, sorry for that. Indeed, Alice needs to take a "shot" from the data in a form of Merkle tree and keep its root for herself

Thank you for the clarification, indeed it is better to explicit this step.

> > If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.
> > Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.
>
> A very elegant solution, thank you! Yes, seems one can encrypt/decrypt with EC:https://developer.ibm.com/swift/2019/03/04/blueecc-elliptic-curve-cryptography/ and this should work. I will include your solution to the proposal.
>
> It also might be possible to implement your solution with threshold ECDSA signatures, that will enable Storm before Schorr's will get to Bitcoin. I am not very good in understanding them yet, but it seems that multiparty ECDSA (or threshold ECDSA, t-ECDSA) unlock many of Schnorr?s signature features and benefits.
> One may check https://github.com/KZen-networks/multi-party-ecdsa and papers

I did mention 2p-ECDSA, which the last time I checked, was the "best" available multiparty ECDSA.
I have not checked in detail the relative security details of 2p-ECDSA compared to the various multiparty ECDSAs.

In this particular case this is only between two parties, thus 2p-ECDSA should be sufficient.

https://eprint.iacr.org/2011/494.pdf
https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-April/001221.html

I have not checked your links and it is possible we are referring to the exact same thing, or your t-ECDSA is a strict improvement over 2p-ECDSA.


> You are right, my solution is limited to a single LN channels, i.e. there must be a direct dually-funded channel between Alice and Bob (and we don't have dually-funded channels as a part of current LN BOLT's). I will add this disclaimer to the spec.

Strictly speaking, dual-funding is completely and totally unnecessary.
As submarine swaps / off-to-onchain swaps are already possible, a simple ritual like the below can emulate dual-funding (at the cost that one side must own the total they agree on onchain):

1.  Alice and Bob agree to each put 10mBTC each to form 20mBTC channel.
2.  Alice happens to have 20mBTC onchain in her pocket, while Bob has 10mBTC.
3.  Bob puts his 10mBTC into an onchain 10mBTC HTLC with locktime 2*L paying to Bob, hashlock paying to Alice (with a preimage known only by Bob).
4.  Alice sets up the 20mBTC channel using her 20mBTC onchain.
5.  After the channel funding tx is deeply confirmed, Alice forwards a 10mBTC HTLC over that channel with locktime L paying to Alice, hashlock paying to Bob (with the same hash as the above).
6.  Bob claims the payment offchain.
7.  Alice can now claim the onchain payment.
8.  Alice and Bob now have a perfectly balanced channel (as all channels should be), while Alice is now in possession of an extra 10mBTC onchain.
    So Alice has 10mBTC offchain, 10mBTC onchain, while Bob has 10mBTC offchain on the same channel.

Dual-funding simply makes the above *much* more efficient, but is not strictly necessary in a world where atomic cross-system swaps are already possible.
>From this point of view, every distinct channel is a unique cryptocurrency system, and if atomic cross-system swaps are possible at all, it is immaterial if one system is a blockchain and the other is a payment channel, etc.

You may also be interested in Fulgurite.
This is a project to "split" a channel into Lightning part and DLC (discreet log contract) part.
The reason for splitting is because LN is expected to have much more state updates than DLC (you forward payments all the time, but set up only a few DLCs with direct counterparties).
DLCs require a lot of signatures if they are reanchored to a new state update transaction, so splitting the channel into an LN part with many updates and a DLC part with few updates is sensible to reduce processing and bandwidth.
Similar reasoning may hold for Storm.

Regards,
ZmnSCPxj

From richter at cs.rwth-aachen.de  Wed Aug 21 09:33:24 2019
From: richter at cs.rwth-aachen.de (Stefan Richter)
Date: Wed, 21 Aug 2019 11:33:24 +0200
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <x1b18QXzxALwxxp8ehwcB7XORizrw5vOJ9BNXWpXbd2SJgUra-AFIyTgnM_yxKEtCg_frZcz916NLmm-pTsCD4Z7aOFprdQ_W87mHnn8vYg=@protonmail.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
	<6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
	<x1b18QXzxALwxxp8ehwcB7XORizrw5vOJ9BNXWpXbd2SJgUra-AFIyTgnM_yxKEtCg_frZcz916NLmm-pTsCD4Z7aOFprdQ_W87mHnn8vYg=@protonmail.com>
Message-ID: <CAH+=Z+U8sGRtK7TwkGjAQ3yL4WYYnJMJjz9pm+9SOSrHReoerg@mail.gmail.com>

Please see the github issues and the twitter discussion (e.g. here:
https://twitter.com/stefanwouldgo/status/1163801056423403520) for similar
points other people including me have made. At this point I feel there are
quite a few unclear points in the presentation and it is not clear to me if
they can be salvaged.

Am Mi., 21. Aug. 2019 um 09:32 Uhr schrieb ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> Good morning Maxim,
>
> The Deaf Bob Attack
> ===================
>
> It seems to me that Bob can promote the N3 problem to the N2 problem.
>
> Suppose Alice contacts Bob to get the data.
> However, Bob happens to have lost the data in a tragic boating accident.
>
> Now, supposedly what Alice does in this case would be to broadcast the
> HTLC settlement transaction, whose signature was provided by Bob during
> protocol setup.
>
> But this seems unworkable.
>
> * If Bob managed to sign the HTLC settlement transaction, what `SIGHASH`
> flags did Bob sign with?
>   * If it was `SIGHASH_ALL` or `SIGHASH_SINGLE`, then Bob already selected
> the decryption key at setup time.
>   * If it was `SIGHASH_NONE`, then Alice could put any SCRIPT, including
> `<Alice> OP_CHECKSIG`.
>
> If Bob already selected the decryption key at setup time, then Bob can
> ignore Alice.
>
> * If Alice does not publish the HTLC settlement transaction, then Bob will
> eventually enter the N2 state and get the stake+reward.
> * If Alice *does* publish the HTLC settlement transaction, without Bob
> giving the encrypted data, then Bob can just use the hashlock and reveal
> the decryption key.
>   * The decryption key is useless without the encrypted data!
>
> It seems this part is not workable?
> As the decryption key is embedded in the HTLC, Alice cannot get a
> signature from Bob without the decryption key already being selected by Bob
> (and thus already claimable even without any data being returned by Bob).
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190821/25a4c8a0/attachment-0001.html>

From orlovsky at protonmail.com  Wed Aug 21 10:51:58 2019
From: orlovsky at protonmail.com (Dr Maxim Orlovsky)
Date: Wed, 21 Aug 2019 10:51:58 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
	<6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
Message-ID: <gzj3nFgqW8Tc2eV8WQRGrC6GYyAGEJiVLgG7KA5tmosZ5NJpz3k4cIgBH9KszySwe3pcQMtit_-hOb6JZzPjH5p4Mi9-xqyWCT6p8leSU8Q=@protonmail.com>

Hi ZmnSCPxj,

Thank you very much for spending your time on analysing my idea at such a deep level ? and writing the detailed review proposing possible solutions to the main found issues.


> Insufficient/unclear Description of Probabilistic Proof
> =======================================================
>
> <...>
> It might be that you imply this in your step 1 for Alice validation of the probabilistically checkable proof though it may be better clarified that Alice has to keep the Merkle Tree root for the original data it originally requested:
>
>> With these data, Alice will be able to check with this zero-knowledge argument by:
>> 1. Checking Merkle tree paths leading to the chunks and resulting Merkle tree root hash to correspond to them

Correct, I forgot to put this step into the description, will fix, sorry for that. Indeed, Alice needs to take a "shot" from the data in a form of Merkle tree and keep its root for herself, and Bob has to provide her with
* "PCP-selected" blocks of source
* "PCP-selected" blocks of encrypted data
* siblings of the Merkle root "leafs" for the selected source data (required for Alice to check source data paths up to the Merkle root which she had kept for herself)
* Merkle paths for both of them
* public key used for the encryption, so Alice can re-encrypt received source data blocks and make sure they are equal to the provided encrypted blocks, so this public key is true


> Will the Real Decryption Key Please Stand Up?
> =============================================
>
> Also, it seems to me that the encryption used must be an asymmetrical encryption.
> That is, the encryption and decryption keys must be different, with the encryption key being a "public" key Bob can safely share with Alice and the decryption key being a "private" key that Bob can share only once it has acquired its funds.

Correct, it should be working like in PGP/GPG


> That is, Bob must prove:
>
> * The given hash h is the hash of the secret decryption key d whose equivalent encryption key is e
>
> ...while revealing only h and e to Alice.

Yes, that is an important point, I've missed that out.


> If there exists some asymmetric encryption using EC (I know of no such, but that is only due to my ignorance), where the decryption key is a scalar and the encryption key is the scalar times the generator then it would be possible to use 2p-ECDSA / Schnorr Scriptless Script to atomically pay for knowledge of the scalar / decryption key, while knowing the encryption key.
> Instead of a hash of the decryption key, Bob sends the encryption key during setup and Alice and Bob use that in the pointlocked timelocked contract under Scriptless Script.

A very elegant solution, thank you! Yes, seems one can encrypt/decrypt with EC: https://developer.ibm.com/swift/2019/03/04/blueecc-elliptic-curve-cryptography/ and this should work. I will include your solution to the proposal.

It also might be possible to implement your solution with threshold ECDSA signatures, that will enable Storm before Schorr's will get to Bitcoin. I am not very good in understanding them yet, but it seems that multiparty ECDSA (or threshold ECDSA, t-ECDSA) unlock many of Schnorr?s signature features and benefits.
One may check https://github.com/KZen-networks/multi-party-ecdsa and papers:
* https://eprint.iacr.org/2019/114.pdf
* https://link.springer.com/chapter/10.1007/978-3-319-39555-5_9 https://twitter.com/alexbosworth/status/1163116574238056448

I will investigate that in more details.


> Transporting Storm Over Lightning
> =================================
>
> Of note is that any mechanism that requires multiple participants to put up money into a contract (as in the case of Storm, which requires both the stake from Bob and the reward from Alice to be put into a single timebound HTLC) can only live inside a single LN channel and is not transportable across intermediate nodes.
> This is because intermediate nodes potentially become subject to attack in case of routing failure.
> (Though it *may* be possible to reuse the sketch I give here for HTLC-enforced publication of combined HTLCs:  https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-July/002055.html)
>
> This is part of what makes LN difficult to work with multiple asset types due to HTLCs naturally forming premium-free American Call Options.
> Avoiding premium-free American Call Options is possible by extracting the premium from the receiver and combining it with the money from the exchange, but this again is doable only onchain, or in a single LN channel (meaning receivers must centralize around exchanges).

> It may be possible to get around this, once Lightning supports payment points + scalars, by use of EC magic homomorphisms, though I lack the energy right now to go dig up the resources on lightning-dev.
> But the storage provider can route a payment to Alice to serve as stake, which can be claimed only if knowing some secret, then Alice routes the stake+reward to Bob, and use some of the EC magic homomorphism while keeping intermediate nodes unaware.

You are right, my solution is limited to a single LN channels, i.e. there must be a direct dually-funded channel between Alice and Bob (and we don't have dually-funded channels as a part of current LN BOLT's). I will add this disclaimer to the spec.

Your solution to the transporting problem is indeed very interesting, however, I need some time to analyze it in more details. Meanwhile, if you don't mind, I will open an issue on GitHub and will be copying the discussion to there as well, so others from outside of this mail list can also join.

Kind regards,
Maxim Orlovsky
https://github.com/dr-orlovsky

From niels.thijssen at improveqs.nl  Wed Aug 21 12:35:45 2019
From: niels.thijssen at improveqs.nl (Niels Thijssen)
Date: Wed, 21 Aug 2019 12:35:45 +0000
Subject: [bitcoin-dev] testing bitcoin nodes
In-Reply-To: <AM0PR07MB54748379B8B41BA5023F46CAE9D50@AM0PR07MB5474.eurprd07.prod.outlook.com>
References: <AM0PR07MB54748379B8B41BA5023F46CAE9D50@AM0PR07MB5474.eurprd07.prod.outlook.com>
Message-ID: <AM0PR07MB54744DA07A130BFB8B0C65DAE9AA0@AM0PR07MB5474.eurprd07.prod.outlook.com>


As no one was able to respond, a gentle reminder : ?

Hi,

I'm working as (software) test specialist and run private a full bitcoin node (based upon Raspberry Pi 4).
I've been trying to figure out the tests performed during installation/upgrade/compilation of the software for the node.
Is there any overview on what's the (common) test approach, or other stuff. Because the tests on GitHub don't help me that much.
I'd like to figure out what/how is tested, maybe refine test cases, and try some manual test also, as part of learning.

Who would be able to join me or share information that guides me.
Thanks in advance,

Niels.



-------- Disclaimer --------
This email and any files transmitted may contain proprietary and confidential information of Improve Quality Services B.V. (?Improve QS?) and is intended only for the (use of the) named recipient(s) above. If you have received this message in error or are not the intended or named recipient(s) of this message, please immediately notify the sender by return and delete this email message from your computer. Any views or opinions presented are solely those of its author and do not necessarily represent those of Improve QS. You are hereby notified that unauthorized disclosure, use, dissemination, forwarding, printing or copying of this e-mail and its attachments either whole or partial of its contents is strictly prohibited. Improve QS cannot guarantee that email communications are secured and error-free and does not accept any liability for damages resulting from the use of email. The general terms and conditions of purchase respectively sale and delivery of Improve QS are applicable to all transactions and undertakings resulting therefrom.


From orlovsky at protonmail.com  Wed Aug 21 17:04:35 2019
From: orlovsky at protonmail.com (Dr Maxim Orlovsky)
Date: Wed, 21 Aug 2019 17:04:35 +0000
Subject: [bitcoin-dev] Storm: escrowed storage and messaging at L2/L3
In-Reply-To: <x1b18QXzxALwxxp8ehwcB7XORizrw5vOJ9BNXWpXbd2SJgUra-AFIyTgnM_yxKEtCg_frZcz916NLmm-pTsCD4Z7aOFprdQ_W87mHnn8vYg=@protonmail.com>
References: <GJgJhEIXm9MyKb_3kGCd2RdvkVQGHjJIE_lCHtp5hQUt7lHvYl1lXTfgyGwwVC0w9LfeZBf86XEbU694V0EdDrB0HwXa7dMhxD7m5MSUI-g=@protonmail.com>
	<6o-9VFKLR0h4CUf_fUN1rAqwTTZMlxk2CwwHSbuuvesIapG8ySj4KyHyUmHRh8rf7Lc2urCX8vw7tmlkP60SfvS3VyWnauD25_E8psrcx7I=@protonmail.com>
	<x1b18QXzxALwxxp8ehwcB7XORizrw5vOJ9BNXWpXbd2SJgUra-AFIyTgnM_yxKEtCg_frZcz916NLmm-pTsCD4Z7aOFprdQ_W87mHnn8vYg=@protonmail.com>
Message-ID: <yBkmyGw473TegSTQPwap9mH7xT4yHWeFBAuq7Whztr56CPIMeN4Ld0edRg9uGnvTGhUy_GML8pM9XHnIHPxBc4Cv0MVejhlclbC_6eMFsKI=@protonmail.com>

Hi ZmnSCPxj,

> The Deaf Bob Attack
> =============================================

> -   If Alice does not publish the HTLC settlement transaction, then Bob will eventually enter the N2 state and get the stake+reward.
> -   If Alice does publish the HTLC settlement transaction, without Bob giving the encrypted data, then Bob can just use the hashlock and reveal the decryption key.
>     -   The decryption key is useless without the encrypted data!

That is the main attack already addressed by couple of other guys in different forms; and you have provided the most detailed explanation of it, thank you. I was working for its solution over the last day and I'd like to propose the following update: https://github.com/storm-org/storm-spec/issues/6#issuecomment-523497555

Briefly, I introduce two new intermediary HTLC transactions (called confirmation and fallbacks). Alice has now a choice to sign HTLC fallback tx if she didn't get the data, and in that case she will get her money (reward) back and Bob's stake as a compensation. Bob can "appeal" to this by confirming that he had hold the data for Alice. Bob does this by providing a "preimage" to the secret hashed by Alice.

This secret is composed at setup time by Alice, and she uses her newly-derived public key for both funding transaction output and deterministically definition of some small portion of the source data. This portion is double-hashed to 160-bit hash and included into HTLC fallback tx by Alice as a hash lock. Later, when Bob wants to prove that he still has the data available, he see the published HTLC transaction, extracts Alice public key and uses it to get the same deterministic piece of the source data as Alice. Bob computes a single hash on the date, which gives him a preimage to unlock the hash lock from HTLC transaction output before Alice will spend it (Alice's output is timelocked).

This solution requires Bob to select decription key at setup time, when he pre-signs the transaction, as you correctly have pointed out:
> If Bob already selected the decryption key at setup time, then Bob can ignore Alice.

Now, we need to aviod situation where by selecting the encryption/decryption pair Bob knows which part of the data he needs to provide Alice in PCP proof, and can discard the rest of the data. This can be mitigated by requiring that the data have to be encrypted using EC multiplication with some factor provided by Alice at the request time.

The only case for possible cheating now is Alice not needing data anymore and avoiding paying the full amount for the storage. However, this can be a part of the Bob business risk and may be covered by some insurance + Alice's reputation & taken into account by Bob at setup time.

Kind regards,
Maxim Orlovsky

From leishman3 at gmail.com  Wed Aug 21 17:33:28 2019
From: leishman3 at gmail.com (Alexander Leishman)
Date: Wed, 21 Aug 2019 10:33:28 -0700
Subject: [bitcoin-dev] testing bitcoin nodes
In-Reply-To: <AM0PR07MB54744DA07A130BFB8B0C65DAE9AA0@AM0PR07MB5474.eurprd07.prod.outlook.com>
References: <AM0PR07MB54748379B8B41BA5023F46CAE9D50@AM0PR07MB5474.eurprd07.prod.outlook.com>
	<AM0PR07MB54744DA07A130BFB8B0C65DAE9AA0@AM0PR07MB5474.eurprd07.prod.outlook.com>
Message-ID: <CABW94zRu+wo5KKczMiTwG6GXt+icThTVN4oh62BykVFk_hueQQ@mail.gmail.com>

Hey Niels,


I'm no expert on bitcoind tests, but maybe these bits of information can
help you get started:


The steps to build bitcoind typically involve running:


./autogen.sh

./configure

make

make install


When you run autogen, the autoreconf
<https://www.gnu.org/software/autoconf/manual/autoconf-2.68/html_node/autoreconf-Invocation.html>
tool
is invoked which creates the configure script that gets run next. The
configure script is generated based on the configure.ac
<https://github.com/bitcoin/bitcoin/blob/master/configure.ac> file, which
performs a number of compatibility checks for the compiler and other
tooling. You can see these checks being performed with
the AX_CHECK_COMPILE_FLAG calls.


My understanding is that running configure does a lot of system
compatibility checks. When you run "make", I do not think any tests get run
by default, but I could be wrong about this. If you want to run unit tests
you need to run "make check". You can read more about this here
<https://github.com/bitcoin/bitcoin/blob/master/src/test/README.md>


There are unit tests for bitcoind written in C++ and a lot of integration
and higher level tests written in python.


Hopefully this information was useful and accurate. Again, I could be wrong
about exactly how the build process works as it's not super obvious.
Hopefully someone else more knowledgeable than me can chime in here if I
got anything wrong.


Best,

Alex



On Wed, Aug 21, 2019 at 10:06 AM Niels Thijssen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> As no one was able to respond, a gentle reminder : ?
>
> Hi,
>
> I'm working as (software) test specialist and run private a full bitcoin
> node (based upon Raspberry Pi 4).
> I've been trying to figure out the tests performed during
> installation/upgrade/compilation of the software for the node.
> Is there any overview on what's the (common) test approach, or other
> stuff. Because the tests on GitHub don't help me that much.
> I'd like to figure out what/how is tested, maybe refine test cases, and
> try some manual test also, as part of learning.
>
> Who would be able to join me or share information that guides me.
> Thanks in advance,
>
> Niels.
>
>
>
> -------- Disclaimer --------
> This email and any files transmitted may contain proprietary and
> confidential information of Improve Quality Services B.V. (?Improve QS?)
> and is intended only for the (use of the) named recipient(s) above. If you
> have received this message in error or are not the intended or named
> recipient(s) of this message, please immediately notify the sender by
> return and delete this email message from your computer. Any views or
> opinions presented are solely those of its author and do not necessarily
> represent those of Improve QS. You are hereby notified that unauthorized
> disclosure, use, dissemination, forwarding, printing or copying of this
> e-mail and its attachments either whole or partial of its contents is
> strictly prohibited. Improve QS cannot guarantee that email communications
> are secured and error-free and does not accept any liability for damages
> resulting from the use of email. The general terms and conditions of
> purchase respectively sale and delivery of Improve QS are applicable to all
> transactions and undertakings resulting therefrom.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190821/2d435f7f/attachment-0001.html>

From pieter.wuille at gmail.com  Wed Aug 21 18:33:03 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 21 Aug 2019 11:33:03 -0700
Subject: [bitcoin-dev] testing bitcoin nodes
In-Reply-To: <AM0PR07MB54748379B8B41BA5023F46CAE9D50@AM0PR07MB5474.eurprd07.prod.outlook.com>
References: <AM0PR07MB54748379B8B41BA5023F46CAE9D50@AM0PR07MB5474.eurprd07.prod.outlook.com>
Message-ID: <CAPg+sBi2Wvh-x0fDVNvAR8ET4OGbbgoegEydaKOaeF4FOWffXQ@mail.gmail.com>

On Tue, 6 Aug 2019 at 09:57, Niels Thijssen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi,
>
> I'm working as (software) test specialist and run private a full bitcoin node (based upon Raspberry Pi 4).
> I've been trying to figure out the tests performed during installation/upgrade/compilation of the software for the node.
> Is there any overview on what's the (common) test approach, or other stuff. Because the tests on GitHub don't help me that much.
> I'd like to figure out what/how is tested, maybe refine test cases, and try some manual test also, as part of learning.

Hi Niels,

You're probably not getting many answers because this isn't the right
place to ask. The mailinglist is about development of the Bitcoin
protocol and conventions about its usage across multiple applications.
If you want to learn about the Bitcoin Core software and its testing
infrastructure, see https://bitcoincore.org/en/contribute/

Cheers,

-- 
Pieter

