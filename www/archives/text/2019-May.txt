From ZmnSCPxj at protonmail.com  Thu May  2 00:10:37 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 02 May 2019 00:10:37 +0000
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
	<aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
	<1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>
Message-ID: <UjO5iL0rbqOeo-nhFpOQSnVX7B4EHToLspAjUNFevNahTrU5O650U0shNQEOwSMCUxs90LZOtl5OuX9VawOXtGTTaW1Wl0gEQF0gv_jtb6w=@protonmail.com>

Good morning Aymeric,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:

> I must badly explain my point (or just wondering things that do not
> exist finally), the question is indeed whether nodes will relay non
> usual transactions or not and how to know what they will accept or not:
>
> -   my modified multisig 2 of 3: I did put OP_2 out of the usual redeem
>     script, the redeem script still matches scriptpubkey and scriptsig will
>     execute succesfully, that's a normal legacy P2SH or segwit P2WSH
>
> -   bch segwit recovery: it's a p2sh transaction without any signature
>     verification, as far as I remember there was a story that it could not
>     propagate in the network (even taking the risk to be stolen) and that
>     people had to contact a (honest) miner
>
> -   sha bounties: same as above, p2sh transactions without signatures
>
>     etc
>
>     Will all of those transactions propagate normally? And then the rule is
>     just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates
>     whatever scripts you put inside?

P2PKH and P2WPKH cannot have custom script.
However, yes, any custom script can be wrapped in P2SH and P2WSH and it will be propagated.
The P2SH/P2WSH hides the details of your custom script so cannot be filtered based on your custom script.
Do realize that once a claim on your modified x-of-3 is propagated your `redeemScript` is known and someone can attempt to RBF (or coordinate with a miner) with a modified `witness` stack or `scriptSig` to claim your UTXO.
(I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at least one of your signatories could make it a 1-of-3 and bribe a miner to get it claimed)

I cannot answer for BCH; arguably that is off-topic here.

The old SHA bounty transactions were propagated in the days before `isStandard` I think.
Either that or they were put in by miners.
An SHA bounty can still be propagated today if they are wrapped in a P2SH or P2WSH, but you have to publish the `redeemScript` yourself in some other method.
Or bribe a miner if the transaction is not time-sensitive (for an SHA bounty, unlikely to be time-sensitive).

Regards,
ZmnSCPxj

From vitteaymeric at gmail.com  Thu May  2 10:01:54 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 2 May 2019 12:01:54 +0200
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <UjO5iL0rbqOeo-nhFpOQSnVX7B4EHToLspAjUNFevNahTrU5O650U0shNQEOwSMCUxs90LZOtl5OuX9VawOXtGTTaW1Wl0gEQF0gv_jtb6w=@protonmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
	<aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
	<1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>
	<UjO5iL0rbqOeo-nhFpOQSnVX7B4EHToLspAjUNFevNahTrU5O650U0shNQEOwSMCUxs90LZOtl5OuX9VawOXtGTTaW1Wl0gEQF0gv_jtb6w=@protonmail.com>
Message-ID: <6b8f2a91-af73-4d66-1b90-51acd4ce217c@gmail.com>

Thanks for the answer, indeed for the redeem script and someone
attempting a 0/1 of 3, good example

So to summarize everything is standard as long as it matches P2PKH,
P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in
op_return

Still the case of bch is unclear (it's related since based on bitcoin
code unless they changed the policy), was the story that nodes would not
propagate the fix or that people did not want to take the risk to
propagate it? And why a non segwit old bitcoin node would not accept it
either?

Le 02/05/2019 ? 02:10, ZmnSCPxj a ?crit?:
> Good morning Aymeric,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>
>> I must badly explain my point (or just wondering things that do not
>> exist finally), the question is indeed whether nodes will relay non
>> usual transactions or not and how to know what they will accept or not:
>>
>> -   my modified multisig 2 of 3: I did put OP_2 out of the usual redeem
>>     script, the redeem script still matches scriptpubkey and scriptsig will
>>     execute succesfully, that's a normal legacy P2SH or segwit P2WSH
>>
>> -   bch segwit recovery: it's a p2sh transaction without any signature
>>     verification, as far as I remember there was a story that it could not
>>     propagate in the network (even taking the risk to be stolen) and that
>>     people had to contact a (honest) miner
>>
>> -   sha bounties: same as above, p2sh transactions without signatures
>>
>>     etc
>>
>>     Will all of those transactions propagate normally? And then the rule is
>>     just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates
>>     whatever scripts you put inside?
> P2PKH and P2WPKH cannot have custom script.
> However, yes, any custom script can be wrapped in P2SH and P2WSH and it will be propagated.
> The P2SH/P2WSH hides the details of your custom script so cannot be filtered based on your custom script.
> Do realize that once a claim on your modified x-of-3 is propagated your `redeemScript` is known and someone can attempt to RBF (or coordinate with a miner) with a modified `witness` stack or `scriptSig` to claim your UTXO.
> (I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at least one of your signatories could make it a 1-of-3 and bribe a miner to get it claimed)
>
> I cannot answer for BCH; arguably that is off-topic here.
>
> The old SHA bounty transactions were propagated in the days before `isStandard` I think.
> Either that or they were put in by miners.
> An SHA bounty can still be propagated today if they are wrapped in a P2SH or P2WSH, but you have to publish the `redeemScript` yourself in some other method.
> Or bribe a miner if the transaction is not time-sensitive (for an SHA bounty, unlikely to be time-sensitive).
>
> Regards,
> ZmnSCPxj

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From laanwj at gmail.com  Thu May  2 08:11:03 2019
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Thu, 2 May 2019 10:11:03 +0200
Subject: [bitcoin-dev] Bitcoin Core 0.18.0 released
Message-ID: <20190502081103.wfiglbuj7trtackz@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version 0.18.0 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.18.0/>

or through bittorrent:

    magnet:?xt=urn:btih:a25c86ffa7a512b6d074287f74762b77f91cef4c&dn=bitcoin-core-0.18.0&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969&tr=udp%3A%2F%2Fzer0day.ch%3A1337&tr=udp%3A%2F%2Fexplodie.org%3A6969

This is a new major version release, including new features, various bug
fixes and performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has
completely shut down (which might take a few minutes for older
versions), then run the installer (on Windows) or just copy over
`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on
Linux).

The first time you run version 0.15.0 or newer, your chainstate database
will be converted to a new format, which will take anywhere from a few
minutes to half an hour, depending on the speed of your machine.

Note that the block database format also changed in version 0.8.0 and
there is no automatic upgrade code from before version 0.8 to version
0.15.0 or later. Upgrading directly from 0.7.x and earlier without
redownloading the blockchain is not supported.  However, as usual, old
wallet versions are still supported.

Compatibility
==============

Bitcoin Core is supported and extensively tested on operating systems
using the Linux kernel, macOS 10.10+, and Windows 7 and newer. It is not
recommended to use Bitcoin Core on unsupported systems.

Bitcoin Core should also work on most other Unix-like systems but is not
as frequently tested on them.

- From 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is
built using Qt 5.9.x, which doesn't support versions of macOS older than
10.10. Additionally, Bitcoin Core does not yet change appearance when
macOS "dark mode" is activated.

In addition to previously-supported CPU platforms, this release's
pre-compiled distribution also provides binaries for the RISC-V
platform.

If you are using the `systemd` unit configuration file located at
`contrib/init/bitcoind.service`, it has been changed to use
`/var/lib/bitcoind` as the data directory instead of
`~bitcoin/.bitcoin`. When switching over to the new configuration file,
please make sure that the filesystem on which `/var/lib/bitcoind` will
exist has enough space (check using `df -h /var/lib/bitcoind`), and
optionally copy over your existing data directory. See the [systemd init
file section](#systemd-init-file) for more details.

Known issues
============

Wallet GUI
- ----------

For advanced users who have both (1) enabled coin control features, and
(2) are using multiple wallets loaded at the same time: The coin control
input selection dialog can erroneously retain wrong-wallet state when
switching wallets using the dropdown menu. For now, it is recommended
not to use coin control features with multiple wallets loaded.

Notable changes
===============

Mining
- ------

- - Calls to `getblocktemplate` will fail if the segwit rule is not
  specified.  Calling `getblocktemplate` without segwit specified is
  almost certainly a misconfiguration since doing so results in lower
  rewards for the miner.  Failed calls will produce an error message
  describing how to enable the segwit rule.

Configuration option changes
- ----------------------------

- - A warning is printed if an unrecognized section name is used in the
  configuration file.  Recognized sections are `[test]`, `[main]`, and
  `[regtest]`.

- - Four new options are available for configuring the maximum number of
  messages that ZMQ will queue in memory (the "high water mark") before
  dropping additional messages.  The default value is 1,000, the same as
  was used for previous releases.  See the [ZMQ
  documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/zmq.md#usage)
  for details.

- - The `rpcallowip` option can no longer be used to automatically listen
  on all network interfaces.  Instead, the `rpcbind` parameter must be
  used to specify the IP addresses to listen on.  Listening for RPC
  commands over a public network connection is insecure and should be
  disabled, so a warning is now printed if a user selects such a
  configuration.  If you need to expose RPC in order to use a tool like
  Docker, ensure you only bind RPC to your localhost, e.g. `docker run
  [...] -p 127.0.0.1:8332:8332` (this is an extra `:8332` over the
  normal Docker port specification).

- - The `rpcpassword` option now causes a startup error if the password
  set in the configuration file contains a hash character (#), as it's
  ambiguous whether the hash character is meant for the password or as a
  comment.

- - The `whitelistforcerelay` option is used to relay transactions from
  whitelisted peers even when not accepted to the mempool. This option
  now defaults to being off, so that changes in policy and
  disconnect/ban behavior will not cause a node that is whitelisting
  another to be dropped by peers.  Users can still explicitly enable
  this behavior with the command line option (and may want to consider
  [contacting](https://bitcoincore.org/en/contact/) the Bitcoin Core
  project to let us know about their use-case, as this feature could be
  deprecated in the future).

systemd init file
- -----------------

The systemd init file (`contrib/init/bitcoind.service`) has been changed
to use `/var/lib/bitcoind` as the data directory instead of
`~bitcoin/.bitcoin`. This change makes Bitcoin Core more consistent with
other services, and makes the systemd init config more consistent with
existing Upstart and OpenRC configs.

The configuration, PID, and data directories are now completely managed
by systemd, which will take care of their creation, permissions, etc.
See [`systemd.exec(5)`](https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RuntimeDirectory=)
for more details.

When using the provided init files under `contrib/init`, overriding the
`datadir` option in `/etc/bitcoin/bitcoin.conf` will have no effect.
This is because the command line arguments specified in the init files
take precedence over the options specified in
`/etc/bitcoin/bitcoin.conf`.


Documentation
- -------------

- - A new short [document](https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)
  about the JSON-RPC interface describes cases where the results of an
  RPC might contain inconsistencies between data sourced from different
  subsystems, such as wallet state and mempool state.  A note is added
  to the [REST interface documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md)
  indicating that the same rules apply.

- - Further information is added to the [JSON-RPC
  documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)
  about how to secure this interface.

- - A new [document](https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md)
  about the `bitcoin.conf` file describes how to use it to configure
  Bitcoin Core.

- - A new document introduces Bitcoin Core's BIP174 [Partially-Signed
  Bitcoin Transactions
  (PSBT)](https://github.com/bitcoin/bitcoin/blob/master/doc/psbt.md)
  interface, which is used to allow multiple programs to collaboratively
  work to create, sign, and broadcast new transactions.  This is useful
  for offline (cold storage) wallets, multisig wallets, coinjoin
  implementations, and many other cases where two or more programs need
  to interact to generate a complete transaction.

- - The [output script
  descriptor](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)
  documentation has been updated with information about new features in
  this still-developing language for describing the output scripts that
  a wallet or other program wants to receive notifications for, such as
  which addresses it wants to know received payments.  The language is
  currently used in multiple new and updated RPCs described in these
  release notes and is expected to be adapted to other RPCs and to the
  underlying wallet structure.

Build system changes
- --------------------

- - A new `--disable-bip70` option may be passed to `./configure` to
  prevent Bitcoin-Qt from being built with support for the BIP70 payment
  protocol or from linking libssl.  As the payment protocol has exposed
  Bitcoin Core to libssl vulnerabilities in the past, builders who don't
  need BIP70 support are encouraged to use this option to reduce their
  exposure to future vulnerabilities.

- - The minimum required version of Qt (when building the GUI) has been
  increased from 5.2 to 5.5.1 (the [depends
  system](https://github.com/bitcoin/bitcoin/blob/master/depends/README.md)
  provides 5.9.7)

New RPCs
- --------

- - `getnodeaddresses` returns peer addresses known to this node. It may
  be used to find nodes to connect to without using a DNS seeder.

- - `listwalletdir` returns a list of wallets in the wallet directory
  (either the default wallet directory or the directory configured by
  the `-walletdir` parameter).

- - `getrpcinfo` returns runtime details of the RPC server. At the moment,
  it returns an array of the currently active commands and how long
  they've been running.

- - `deriveaddresses` returns one or more addresses corresponding to an
  [output descriptor](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).

- - `getdescriptorinfo` accepts a descriptor and returns information about
  it, including its computed checksum.

- - `joinpsbts` merges multiple distinct PSBTs into a single PSBT. The
  multiple PSBTs must have different inputs. The resulting PSBT will
  contain every input and output from all of the PSBTs. Any signatures
  provided in any of the PSBTs will be dropped.

- - `analyzepsbt` examines a PSBT and provides information about what
  the PSBT contains and the next steps that need to be taken in order
  to complete the transaction. For each input of a PSBT, `analyzepsbt`
  provides information about what information is missing for that
  input, including whether a UTXO needs to be provided, what pubkeys
  still need to be provided, which scripts need to be provided, and
  what signatures are still needed. Every input will also list which
  role is needed to complete that input, and `analyzepsbt` will also
  list the next role in general needed to complete the PSBT.
  `analyzepsbt` will also provide the estimated fee rate and estimated
  virtual size of the completed transaction if it has enough
  information to do so.

- - `utxoupdatepsbt` searches the set of Unspent Transaction Outputs
  (UTXOs) to find the outputs being spent by the partial transaction.
  PSBTs need to have the UTXOs being spent to be provided because
  the signing algorithm requires information from the UTXO being spent.
  For segwit inputs, only the UTXO itself is necessary.  For
  non-segwit outputs, the entire previous transaction is needed so
  that signers can be sure that they are signing the correct thing.
  Unfortunately, because the UTXO set only contains UTXOs and not full
  transactions, `utxoupdatepsbt` will only add the UTXO for segwit
  inputs.

Updated RPCs
- ------------

Note: some low-level RPC changes mainly useful for testing are described
in the Low-level Changes section below.

- - `getpeerinfo` now returns an additional `minfeefilter` field set to
  the peer's BIP133 fee filter.  You can use this to detect that you
  have peers that are willing to accept transactions below the default
  minimum relay fee.

- - The mempool RPCs, such as `getrawmempool` with `verbose=true`, now
  return an additional "bip125-replaceable" value indicating whether the
  transaction (or its unconfirmed ancestors) opts-in to asking nodes and
  miners to replace it with a higher-feerate transaction spending any of
  the same inputs.

- - `settxfee` previously silently ignored attempts to set the fee below
  the allowed minimums.  It now prints a warning.  The special value of
  "0" may still be used to request the minimum value.

- - `getaddressinfo` now provides an `ischange` field indicating whether
  the wallet used the address in a change output.

- - `importmulti` has been updated to support P2WSH, P2WPKH, P2SH-P2WPKH,
  and P2SH-P2WSH. Requests for P2WSH and P2SH-P2WSH accept an additional
  `witnessscript` parameter.

- - `importmulti` now returns an additional `warnings` field for each
  request with an array of strings explaining when fields are being
  ignored or are inconsistent, if there are any.

- - `getaddressinfo` now returns an additional `solvable` boolean field
  when Bitcoin Core knows enough about the address's scriptPubKey,
  optional redeemScript, and optional witnessScript in order for the
  wallet to be able to generate an unsigned input spending funds sent to
  that address.

- - The `getaddressinfo`, `listunspent`, and `scantxoutset` RPCs now
  return an additional `desc` field that contains an output descriptor
  containing all key paths and signing information for the address
  (except for the private key).  The `desc` field is only returned for
  `getaddressinfo` and `listunspent` when the address is solvable.

- - `importprivkey` will preserve previously-set labels for addresses or
  public keys corresponding to the private key being imported.  For
  example, if you imported a watch-only address with the label "cold
  wallet" in earlier releases of Bitcoin Core, subsequently importing
  the private key would default to resetting the address's label to the
  default empty-string label ("").  In this release, the previous label
  of "cold wallet" will be retained.  If you optionally specify any
  label besides the default when calling `importprivkey`, the new label
  will be applied to the address.

- - See the [Mining](#mining) section for changes to `getblocktemplate`.

- - `getmininginfo` now omits `currentblockweight` and `currentblocktx`
  when a block was never assembled via RPC on this node.

- - The `getrawtransaction` RPC & REST endpoints no longer check the
  unspent UTXO set for a transaction. The remaining behaviors are as
  follows: 1. If a blockhash is provided, check the corresponding block.
  2. If no blockhash is provided, check the mempool. 3. If no blockhash
  is provided but txindex is enabled, also check txindex.

- - `unloadwallet` is now synchronous, meaning it will not return until
  the wallet is fully unloaded.

- - `importmulti` now supports importing of addresses from descriptors. A
  "desc" parameter can be provided instead of the "scriptPubKey" in a
  request, as well as an optional range for ranged descriptors to
  specify the start and end of the range to import. Descriptors with key
  origin information imported through `importmulti` will have their key
  origin information stored in the wallet for use with creating PSBTs.
  More information about descriptors can be found
  [here](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).

- - `listunspent` has been modified so that it also returns
  `witnessScript`, the witness script in the case of a P2WSH or
  P2SH-P2WSH output.

- - `createwallet` now has an optional `blank` argument that can be used
  to create a blank wallet. Blank wallets do not have any keys or HD
  seed.  They cannot be opened in software older than 0.18. Once a blank
  wallet has a HD seed set (by using `sethdseed`) or private keys,
  scripts, addresses, and other watch only things have been imported,
  the wallet is no longer blank and can be opened in 0.17.x. Encrypting
  a blank wallet will also set a HD seed for it.

Deprecated or removed RPCs
- --------------------------

- - `signrawtransaction` is removed after being deprecated and hidden
  behind a special configuration option in version 0.17.0.

- - The 'account' API is removed after being deprecated in v0.17.  The
  'label' API was introduced in v0.17 as a replacement for accounts.
  See the [release notes from
  v0.17](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.17.0.md#label-and-account-apis-for-wallet)
  for a full description of the changes from the 'account' API to the
  'label' API.

- - `addwitnessaddress` is removed after being deprecated in version
  0.16.0.

- - `generate` is deprecated and will be fully removed in a subsequent
  major version.  This RPC is only used for testing, but its
  implementation reached across multiple subsystems (wallet and mining),
  so it is being deprecated to simplify the wallet-node interface.
  Projects that are using `generate` for testing purposes should
  transition to using the `generatetoaddress` RPC, which does not
  require or use the wallet component. Calling `generatetoaddress` with
  an address returned by the `getnewaddress` RPC gives the same
  functionality as the old `generate` RPC.  To continue using `generate`
  in this version, restart bitcoind with the `-deprecatedrpc=generate`
  configuration option.

- - Be reminded that parts of the `validateaddress` command have been
  deprecated and moved to `getaddressinfo`. The following deprecated
  fields have moved to `getaddressinfo`: `ismine`, `iswatchonly`,
  `script`, `hex`, `pubkeys`, `sigsrequired`, `pubkey`, `embedded`,
  `iscompressed`, `label`, `timestamp`, `hdkeypath`, `hdmasterkeyid`.

- - The `addresses` field has been removed from the `validateaddress`
  and `getaddressinfo` RPC methods.  This field was confusing since
  it referred to public keys using their P2PKH address.  Clients
  should use the `embedded.address` field for P2SH or P2WSH wrapped
  addresses, and `pubkeys` for inspecting multisig participants.

REST changes
- ------------

- - A new `/rest/blockhashbyheight/` endpoint is added for fetching the
  hash of the block in the current best blockchain based on its height
  (how many blocks it is after the Genesis Block).

Graphical User Interface (GUI)
- ------------------------------

- - A new Window menu is added alongside the existing File, Settings, and
  Help menus.  Several items from the other menus that opened new
  windows have been moved to this new Window menu.

- - In the Send tab, the checkbox for "pay only the required fee" has been
  removed.  Instead, the user can simply decrease the value in the
  Custom Feerate field all the way down to the node's configured minimum
  relay fee.

- - In the Overview tab, the watch-only balance will be the only balance
  shown if the wallet was created using the `createwallet` RPC and the
  `disable_private_keys` parameter was set to true.

- - The launch-on-startup option is no longer available on macOS if
  compiled with macosx min version greater than 10.11 (use
  CXXFLAGS="-mmacosx-version-min=10.11"
  CFLAGS="-mmacosx-version-min=10.11" for setting the deployment sdk
  version)

Tools
- -----

- - A new `bitcoin-wallet` tool is now distributed alongside Bitcoin
  Core's other executables.  Without needing to use any RPCs, this tool
  can currently create a new wallet file or display some basic
  information about an existing wallet, such as whether the wallet is
  encrypted, whether it uses an HD seed, how many transactions it
  contains, and how many address book entries it has.

Planned changes
===============

This section describes planned changes to Bitcoin Core that may affect
other Bitcoin software and services.

- - Since version 0.16.0, Bitcoin Core?s built-in wallet has defaulted to
  generating P2SH-wrapped segwit addresses when users want to receive
  payments. These addresses are backwards compatible with all
  widely-used software.  Starting with Bitcoin Core 0.20 (expected about
  a year after 0.18), Bitcoin Core will default to native segwit
  addresses (bech32) that provide additional fee savings and other
  benefits. Currently, many wallets and services already support sending
  to bech32 addresses, and if the Bitcoin Core project sees enough
  additional adoption, it will instead default to bech32 receiving
  addresses in Bitcoin Core 0.19 (approximately November 2019).
  P2SH-wrapped segwit addresses will continue to be provided if the user
  requests them in the GUI or by RPC, and anyone who doesn?t want the
  update will be able to configure their default address type.
  (Similarly, pioneering users who want to change their default now may
  set the `addresstype=bech32` configuration option in any Bitcoin Core
  release from 0.16.0 up.)

Deprecated P2P messages
- -----------------------

- - BIP 61 reject messages are now deprecated. Reject messages have no use
  case on the P2P network and are only logged for debugging by most
  network nodes. Furthermore, they increase bandwidth and can be harmful
  for privacy and security. It has been possible to disable BIP 61
  messages since v0.17 with the `-enablebip61=0` option. BIP 61 messages
  will be disabled by default in a future version, before being removed
  entirely.

Low-level changes
=================

This section describes RPC changes mainly useful for testing, mostly not
relevant in production. The changes are mentioned for completeness.

RPC
- ---

- - The `submitblock` RPC previously returned the reason a rejected block
  was invalid the first time it processed that block, but returned a
  generic "duplicate" rejection message on subsequent occasions it
  processed the same block.  It now always returns the fundamental
  reason for rejecting an invalid block and only returns "duplicate" for
  valid blocks it has already accepted.

- - A new `submitheader` RPC allows submitting block headers independently
  from their block.  This is likely only useful for testing.

- - The `signrawtransactionwithkey` and `signrawtransactionwithwallet`
  RPCs have been modified so that they also optionally accept a
  `witnessScript`, the witness script in the case of a P2WSH or
  P2SH-P2WSH output. This is compatible with the change to
  `listunspent`.

- - For the `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs, if the
  `bip32derivs` parameter is set to true but the key metadata for a
  public key has not been updated yet, then that key will have a
  derivation path as if it were just an independent key (i.e. no
  derivation path and its master fingerprint is itself).

Configuration
- -------------

- - The `-usehd` configuration option was removed in version 0.16. From
  that version onwards, all new wallets created are hierarchical
  deterministic wallets. This release makes specifying `-usehd` an
  invalid configuration option.

Network
- -------

- - This release allows peers that your node automatically disconnected
  for misbehavior (e.g. sending invalid data) to reconnect to your node
  if you have unused incoming connection slots.  If your slots fill up,
  a misbehaving node will be disconnected to make room for nodes without
  a history of problems (unless the misbehaving node helps your node in
  some other way, such as by connecting to a part of the Internet from
  which you don't have many other peers).  Previously, Bitcoin Core
  banned the IP addresses of misbehaving peers for a period of time
  (default of 1 day); this was easily circumvented by attackers with
  multiple IP addresses. If you manually ban a peer, such as by using
  the `setban` RPC, all connections from that peer will still be
  rejected.

Wallet
- -------

- - The key metadata will need to be upgraded the first time that the HD
  seed is available.  For unencrypted wallets this will occur on wallet
  loading.  For encrypted wallets this will occur the first time the
  wallet is unlocked.

- - Newly encrypted wallets will no longer require restarting the
  software. Instead such wallets will be completely unloaded and
  reloaded to achieve the same effect.

- - A sub-project of Bitcoin Core now provides Hardware Wallet Interaction
  (HWI) scripts that allow command-line users to use several popular
  hardware key management devices with Bitcoin Core.  See their [project
  page](https://github.com/bitcoin-core/HWI#readme) for details.

Security
- --------

- - This release changes the Random Number Generator (RNG) used from
  OpenSSL to Bitcoin Core's own implementation, although entropy
  gathered by Bitcoin Core is fed out to OpenSSL and then read back in
  when the program needs strong randomness. This moves Bitcoin Core a
  little closer to no longer needing to depend on OpenSSL, a dependency
  that has caused security issues in the past.  The new implementation
  gathers entropy from multiple sources, including from hardware
  supporting the rdseed CPU instruction.

Changes for particular platforms
- --------------------------------

- - On macOS, Bitcoin Core now opts out of application CPU throttling
  ("app nap") during initial blockchain download, when catching up from
  over 100 blocks behind the current chain tip, or when reindexing chain
  data. This helps prevent these operations from taking an excessively
  long time because the operating system is attempting to conserve
  power.

0.18.0 change log
=================

### Consensus
- - #14247 Fix crash bug with duplicate inputs within a transaction (TheBlueMatt)

### Mining
- - #14811 Mining: Enforce that segwit option must be set in GBT (jnewbery)

### Block and transaction handling
- - #13310 Report progress in ReplayBlocks while rolling forward (promag)
- - #13783 validation: Pass tx pool reference into CheckSequenceLocks (MarcoFalke)
- - #14834 validation: Assert that pindexPrev is non-null when required (kallewoof)
- - #14085 index: Fix for indexers skipping genesis block (jimpo)
- - #14963 mempool, validation: Explain `cs_main` locking semantics (MarcoFalke)
- - #15193 Default `-whitelistforcerelay` to off (sdaftuar)
- - #15429 Update `assumevalid`, `minimumchainwork`, and `getchaintxstats` to height 563378 (gmaxwell)
- - #15552 Granular invalidateblock and RewindBlockIndex (MarcoFalke)
- - #14841 Move CheckBlock() call to critical section (hebasto)

### P2P protocol and network code
- - #14025 Remove dead code for nVersion=10300 (MarcoFalke)
- - #12254 BIP 158: Compact Block Filters for Light Clients (jimpo)
- - #14073 blockfilter: Avoid out-of-bounds script access (jimpo)
- - #14140 Switch nPrevNodeCount to vNodesSize (pstratem)
- - #14027 Skip stale tip checking if outbound connections are off or if reindexing (gmaxwell)
- - #14532 Never bind `INADDR_ANY` by default, and warn when doing so explicitly (luke-jr)
- - #14733 Make peer timeout configurable, speed up very slow test and ensure correct code path tested (zallarak)
- - #14336 Implement poll (pstratem)
- - #15051 IsReachable is the inverse of IsLimited (DRY). Includes unit tests (mmachicao)
- - #15138 Drop IsLimited in favor of IsReachable (Empact)
- - #14605 Return of the Banman (dongcarl)
- - #14970 Add dnsseed.emzy.de to DNS seeds (Emzy)
- - #14929 Allow connections from misbehavior banned peers (gmaxwell)
- - #15345 Correct comparison of addr count (dongcarl)
- - #15201 Add missing locking annotation for vNodes. vNodes is guarded by cs_vNodes (practicalswift)
- - #14626 Select orphan transaction uniformly for eviction (sipa)
- - #15486 Ensure tried collisions resolve, and allow feeler connections to existing outbound netgroups (sdaftuar)

### Wallet
- - #13962 Remove unused `dummy_tx` variable from FillPSBT (dongcarl)
- - #13967 Don't report `minversion` wallet entry as unknown (instagibbs)
- - #13988 Add checks for settxfee reasonableness (ajtowns)
- - #12559 Avoid locking `cs_main` in some wallet RPC (promag)
- - #13631 Add CMerkleTx::IsImmatureCoinBase method (Empact)
- - #14023 Remove accounts RPCs (jnewbery)
- - #13825 Kill accounts (jnewbery)
- - #10605 Add AssertLockHeld assertions in CWallet::ListCoins (ryanofsky)
- - #12490 Remove deprecated wallet rpc features from `bitcoin_server` (jnewbery)
- - #14138 Set `encrypted_batch` to nullptr after delete. Avoid double free in the case of NDEBUG (practicalswift)
- - #14168 Remove `ENABLE_WALLET` from `libbitcoin_server.a` (jnewbery)
- - #12493 Reopen CDBEnv after encryption instead of shutting down (achow101)
- - #14282 Remove `-usehd` option (jnewbery)
- - #14146 Remove trailing separators from `-walletdir` arg (PierreRochard)
- - #14291 Add ListWalletDir utility function (promag)
- - #14468 Deprecate `generate` RPC method (jnewbery)
- - #11634 Add missing `cs_wallet`/`cs_KeyStore` locks to wallet (practicalswift)
- - #14296 Remove `addwitnessaddress` (jnewbery)
- - #14451 Add BIP70 deprecation warning and allow building GUI without BIP70 support (jameshilliard)
- - #14320 Fix duplicate fileid detection (ken2812221)
- - #14561 Remove `fs::relative` call and fix listwalletdir tests (promag)
- - #14454 Add SegWit support to importmulti (MeshCollider)
- - #14410 rpcwallet: `ischange` field for `getaddressinfo` RPC (mrwhythat)
- - #14350 Add WalletLocation class (promag)
- - #14689 Require a public key to be retrieved when signing a P2PKH input (achow101)
- - #14478 Show error to user when corrupt wallet unlock fails (MeshCollider)
- - #14411 Restore ability to list incoming transactions by label (ryanofsky)
- - #14552 Detect duplicate wallet by comparing the db filename (ken2812221)
- - #14678 Remove redundant KeyOriginInfo access, already done in CreateSig (instagibbs)
- - #14477 Add ability to convert solvability info to descriptor (sipa)
- - #14380 Fix assert crash when specified change output spend size is unknown (instagibbs)
- - #14760 Log env path in `BerkeleyEnvironment::Flush` (promag)
- - #14646 Add expansion cache functions to descriptors (unused for now) (sipa)
- - #13076 Fix ScanForWalletTransactions to return an enum indicating scan result: `success` / `failure` / `user_abort` (Empact)
- - #14821 Replace CAffectedKeysVisitor with descriptor based logic (sipa)
- - #14957 Initialize `stop_block` in CWallet::ScanForWalletTransactions (Empact)
- - #14565 Overhaul `importmulti` logic (sipa)
- - #15039 Avoid leaking nLockTime fingerprint when anti-fee-sniping (MarcoFalke)
- - #14268 Introduce SafeDbt to handle Dbt with free or `memory_cleanse` raii-style (Empact)
- - #14711 Remove uses of chainActive and mapBlockIndex in wallet code (ryanofsky)
- - #15279 Clarify rescanblockchain doc (MarcoFalke)
- - #15292 Remove `boost::optional`-related false positive -Wmaybe-uninitialized warnings on GCC compiler (hebasto)
- - #13926 [Tools] bitcoin-wallet - a tool for creating and managing wallets offline (jnewbery)
- - #11911 Free BerkeleyEnvironment instances when not in use (ryanofsky)
- - #15235 Do not import private keys to wallets with private keys disabled (achow101)
- - #15263 Descriptor expansions only need pubkey entries for PKH/WPKH (sipa)
- - #15322 Add missing `cs_db` lock (promag)
- - #15297 Releases dangling files on `BerkeleyEnvironment::Close` (promag)
- - #14491 Allow descriptor imports with importmulti (MeshCollider)
- - #15365 Add lock annotation for mapAddressBook (MarcoFalke)
- - #15226 Allow creating blank (empty) wallets (alternative) (achow101)
- - #15390 [wallet-tool] Close bdb when flushing wallet (jnewbery)
- - #15334 Log absolute paths for the wallets (hebasto)
- - #14978 Factor out PSBT utilities from RPCs for use in GUI code; related refactoring (gwillen)
- - #14481 Add P2SH-P2WSH support to listunspent RPC (MeshCollider)
- - #14021 Import key origin data through descriptors in importmulti (achow101)
- - #14075 Import watch only pubkeys to the keypool if private keys are disabled (achow101)
- - #15368 Descriptor checksums (sipa)
- - #15433 Use a single wallet batch for `UpgradeKeyMetadata` (jonasschnelli)
- - #15408 Remove unused `TransactionError` constants (MarcoFalke)
- - #15583 Log and ignore errors in ListWalletDir and IsBerkeleyBtree (promag)
- - #14195 Pass privkey export DER compression flag correctly (fingera)
- - #15299 Fix assertion in `CKey::SignCompact` (promag)
- - #14437 Start to separate wallet from node (ryanofsky)
- - #15749 Fix: importmulti only imports origin info for PKH outputs (sipa)

### RPC and other APIs
- - #12842 Prevent concurrent `savemempool` (promag)
- - #13987 Report `minfeefilter` value in `getpeerinfo` RPC (ajtowns)
- - #13891 Remove getinfo deprecation warning (jnewbery)
- - #13399 Add `submitheader` (MarcoFalke)
- - #12676 Show `bip125-replaceable` flag, when retrieving mempool entries (dexX7)
- - #13723 PSBT key path cleanups (sipa)
- - #14008 Preserve a format of RPC command definitions (kostyantyn)
- - #9332 Let wallet `importmulti` RPC accept labels for standard scriptPubKeys (ryanofsky)
- - #13983 Return more specific reject reason for submitblock (MarcoFalke)
- - #13152 Add getnodeaddresses RPC command (chris-belcher)
- - #14298 rest: Improve performance for JSON calls (alecalve)
- - #14297 Remove warning for removed estimatefee RPC (jnewbery)
- - #14373 Consistency fixes for RPC descriptions (ch4ot1c)
- - #14150 Add key origin support to descriptors (sipa)
- - #14518 Always throw in getblockstats if `-txindex` is required (promag)
- - #14060 ZMQ: add options to configure outbound message high water mark, aka SNDHWM (mruddy)
- - #13381 Add possibility to preserve labels on importprivkey (marcoagner)
- - #14530 Use `RPCHelpMan` to generate RPC doc strings (MarcoFalke)
- - #14720 Correctly name RPC arguments (MarcoFalke)
- - #14726 Use `RPCHelpMan` for all RPCs (MarcoFalke)
- - #14796 Pass argument descriptions to `RPCHelpMan` (MarcoFalke)
- - #14670 http: Fix HTTP server shutdown (promag)
- - #14885 Assert that named arguments are unique in `RPCHelpMan` (promag)
- - #14877 Document default values for optional arguments (MarcoFalke)
- - #14875 RPCHelpMan: Support required arguments after optional ones (MarcoFalke)
- - #14993 Fix data race (UB) in InterruptRPC() (practicalswift)
- - #14653 rpcwallet: Add missing transaction categories to RPC helptexts (andrewtoth)
- - #14981 Clarify RPC `getrawtransaction`'s time help text (benthecarman)
- - #12151 Remove `cs_main` lock from blockToJSON and blockheaderToJSON (promag)
- - #15078 Document `bytessent_per_msg` and `bytesrecv_per_msg` (MarcoFalke)
- - #15057 Correct `reconsiderblock `help text, add test (MarcoFalke)
- - #12153 Avoid permanent `cs_main` lock in `getblockheader` (promag)
- - #14982 Add `getrpcinfo` command (promag)
- - #15122 Expand help text for `importmulti` changes (jnewbery)
- - #15186 remove duplicate solvable field from `getaddressinfo` (fanquake)
- - #15209 zmq: log outbound message high water mark when reusing socket (fanquake)
- - #15177 rest: Improve tests and documention of /headers and /block (promag)
- - #14353 rest: Add blockhash call, fetch blockhash by height (jonasschnelli)
- - #15248 Compile on GCC4.8 (MarcoFalke)
- - #14987 RPCHelpMan: Pass through Result and Examples (MarcoFalke)
- - #15159 Remove lookup to UTXO set from GetTransaction (amitiuttarwar)
- - #15245 remove deprecated mentions of signrawtransaction from fundraw help (instagibbs)
- - #14667 Add `deriveaddresses` RPC util method (Sjors)
- - #15357 Don't ignore `-maxtxfee` when wallet is disabled (JBaczuk)
- - #15337 Fix for segfault if combinepsbt called with empty inputs (benthecarman)
- - #14918 RPCHelpMan: Check default values are given at compile-time (MarcoFalke)
- - #15383 mining: Omit uninitialized currentblockweight, currentblocktx (MarcoFalke)
- - #13932 Additional utility RPCs for PSBT (achow101)
- - #15401 Actually throw help when passed invalid number of params (MarcoFalke)
- - #15471 rpc/gui: Remove 'Unknown block versions being mined' warning (laanwj)
- - #15497 Consistent range arguments in scantxoutset/importmulti/deriveaddresses (sipa)
- - #15510 deriveaddresses: add range to CRPCConvertParam (Sjors)
- - #15582 Fix overflow bug in analyzepsbt fee: CAmount instead of int (sipa)
- - #13424 Consistently validate txid / blockhash length and encoding in rpc calls (Empact)
- - #15750 Remove the addresses field from the getaddressinfo return object (jnewbery)

### GUI
- - #13634 Compile `boost::signals2` only once (MarcoFalke)
- - #13248 Make proxy icon from statusbar clickable (mess110)
- - #12818 TransactionView: highlight replacement tx after fee bump (Sjors)
- - #13529 Use new Qt5 connect syntax (promag)
- - #14162 Also log and print messages or questions like bitcoind (MarcoFalke)
- - #14385 Avoid system harfbuzz and bz2 (theuni)
- - #14450 Fix QCompleter popup regression (hebasto)
- - #14177 Set C locale for amountWidget (hebasto)
- - #14374 Add `Blocksdir` to Debug window (hebasto)
- - #14554 Remove unused `adjustedTime` parameter (hebasto)
- - #14228 Enable system tray icon by default if available (hebasto)
- - #14608 Remove the "Pay only required fee?" checkbox (hebasto)
- - #14521 qt, docs: Fix `bitcoin-qt -version` output formatting (hebasto)
- - #13966 When private key is disabled, only show watch-only balance (ken2812221)
- - #14828 Remove hidden columns in coin control dialog (promag)
- - #14783 Fix `boost::signals2::no_slots_error` in early calls to InitWarning (promag)
- - #14854 Cleanup SplashScreen class (hebasto)
- - #14801 Use window() instead of obsolete topLevelWidget() (hebasto)
- - #14573 Add Window menu (promag)
- - #14979 Restore < Qt5.6 compatibility for addAction (jonasschnelli)
- - #14975 Refactoring with QString::toNSString() (hebasto)
- - #15000 Fix broken notificator on GNOME (hebasto)
- - #14375 Correct misleading "overridden options" label (hebasto)
- - #15007 Notificator class refactoring (hebasto)
- - #14784 Use `WalletModel*` instead of the wallet name as map key (promag)
- - #11625 Add BitcoinApplication & RPCConsole tests (ryanofsky)
- - #14517 Fix start with the `-min` option (hebasto)
- - #13216 implements concept for different disk sizes on intro (marcoagner)
- - #15114 Replace remaining 0 with nullptr (Empact)
- - #14594 Fix minimized window bug on Linux (hebasto)
- - #14556 Fix confirmed transaction labeled "open" (#13299) (hebasto)
- - #15149 Show current wallet name in window title (promag)
- - #15136 "Peers" tab overhaul (hebasto)
- - #14250 Remove redundant stopThread() and stopExecutor() signals (hebasto)
- - #15040 Add workaround for QProgressDialog bug on macOS (hebasto)
- - #15101 Add WalletController (promag)
- - #15178 Improve "help-console" message (hebasto)
- - #15210 Fix window title update (promag)
- - #15167 Fix wallet selector size adjustment (hebasto)
- - #15208 Remove macOS launch-at-startup when compiled with > macOS 10.11, fix memory mismanagement (jonasschnelli)
- - #15163 Correct units for "-dbcache" and "-prune" (hebasto)
- - #15225 Change the receive button to respond to keypool state changing (achow101)
- - #15280 Fix shutdown order (promag)
- - #15203 Fix issue #9683 "gui, wallet: random abort (segmentation fault) (dooglus)
- - #15091 Fix model overlay header sync (jonasschnelli)
- - #15153 Add Open Wallet menu (promag)
- - #15183 Fix `m_assumed_blockchain_size` variable value (marcoagner)
- - #15063 If BIP70 is disabled, attempt to fall back to BIP21 parsing (luke-jr)
- - #15195 Add Close Wallet action (promag)
- - #15462 Fix async open wallet call order (promag)
- - #15801 Bugfix: GUI: Options: Initialise prune setting range before loading current value, and remove upper bound limit (luke-jr)

### Build system
- - #13955 gitian: Bump descriptors for (0.)18 (fanquake)
- - #13899 Enable -Wredundant-decls where available. Remove redundant redeclarations (practicalswift)
- - #13665 Add RISC-V support to gitian (ken2812221)
- - #14062 Generate MSVC project files via python script (ken2812221)
- - #14037 Add README.md to linux release tarballs (hebasto)
- - #14183 Remove unused Qt 4 dependencies (ken2812221)
- - #14127 Avoid getifaddrs when unavailable (greenaddress)
- - #14184 Scripts and tools: increased timeout downloading (cisba)
- - #14204 Move `interfaces/*` to `libbitcoin_server` (laanwj)
- - #14208 Actually remove `ENABLE_WALLET` (jnewbery)
- - #14212 Remove libssl from LDADD unless GUI (MarcoFalke)
- - #13578 Upgrade zeromq to 4.2.5 and avoid deprecated zeromq API functions (mruddy)
- - #14281 lcov: filter /usr/lib/ from coverage reports (MarcoFalke)
- - #14325 gitian: Use versioned unsigned tarballs instead of generically named ones (achow101)
- - #14253 During 'make clean', remove some files that are currently missed (murrayn)
- - #14455 Unbreak `make clean` (jamesob)
- - #14495 Warn (don't fail!) on spelling errors (practicalswift)
- - #14496 Pin to specific versions of Python packages we install from PyPI in Travis (practicalswift)
- - #14568 Fix Qt link order for Windows build (ken2812221)
- - #14252 Run functional tests and benchmarks under the undefined behaviour sanitizer (UBSan) (practicalswift)
- - #14612 Include full version number in released file names (achow101)
- - #14840 Remove duplicate libconsensus linking in test make (AmirAbrams)
- - #14564 Adjust configure so that only BIP70 is disabled when protobuf is missing instead of the GUI (jameshilliard)
- - #14883 Add `--retry 5` to curl opts in `install_db4.sh` (qubenix)
- - #14701 Add `CLIENT_VERSION_BUILD` to CFBundleGetInfoString (fanquake)
- - #14849 Qt 5.9.7 (fanquake)
- - #15020 Add names to Travis jobs (gkrizek)
- - #15047 Allow to configure --with-sanitizers=fuzzer (MarcoFalke)
- - #15154 Configure: bitcoin-tx doesn't need libevent, so don't pull it in (luke-jr)
- - #15175 Drop macports support (Empact)
- - #15308 Restore compatibility with older boost (Empact)
- - #15407 msvc: Fix silent merge conflict between #13926 and #14372 part II (ken2812221)
- - #15388 Makefile.am: add rule for src/bitcoin-wallet (Sjors)
- - #15393 Bump minimum Qt version to 5.5.1 (Sjors)
- - #15285 Prefer Python 3.4 even if newer versions are present on the system (Sjors)
- - #15398 msvc: Add rapidcheck property tests (ken2812221)
- - #15431 msvc: scripted-diff: Remove NDEBUG pre-define in project file (ken2812221)
- - #15549 gitian: Improve error handling (laanwj)
- - #15548 use full version string in setup.exe (MarcoFalke)
- - #11526 Visual Studio build configuration for Bitcoin Core (sipsorcery)
- - #15110 build\_msvc: Fix the build problem in `libbitcoin_server` (Mr-Leshiy)
- - #14372 msvc: build secp256k1 and leveldb locally (ken2812221)
- - #15325 msvc: Fix silent merge conflict between #13926 and #14372 (ken2812221)
- - #15391 Add compile time verification of assumptions we're currently making implicitly/tacitly (practicalswift)
- - #15503 msvc: Use a single file to specify the include path (ken2812221)
- - #13765 contrib: Add gitian build support for github pull request (ken2812221)
- - #15809 gitignore: plist and dat (jamesob)

### Tests and QA
- - #15405 appveyor: Clean cache when build configuration changes (Sjors)
- - #13953 Fix deprecation in bitcoin-util-test.py (isghe)
- - #13963 Replace usage of tostring() with tobytes() (dongcarl)
- - #13964 ci: Add appveyor ci (ken2812221)
- - #13997 appveyor: fetch the latest port data (ken2812221)
- - #13707 Add usage note to check-rpc-mappings.py (masonicboom)
- - #14036 travis: Run unit tests --with-sanitizers=undefined (MarcoFalke)
- - #13861 Add testing of `value_ret` for SelectCoinsBnB (Empact)
- - #13863 travis: Move script sections to files in `.travis/` subject to shellcheck (scravy)
- - #14081 travis: Fix missing differentiation between unit and functional tests (scravy)
- - #14042 travis: Add cxxflags=-wno-psabi at arm job (ken2812221)
- - #14051 Make `combine_logs.py` handle multi-line logs (jnewbery)
- - #14093 Fix accidental trunction from int to bool (practicalswift)
- - #14108 Add missing locking annotations and locks (`g_cs_orphans`) (practicalswift)
- - #14088 Don't assert(?) with side effects (practicalswift)
- - #14086 appveyor: Use clcache to speed up build (ken2812221)
- - #13954 Warn (don't fail!) on spelling errors. Fix typos reported by codespell (practicalswift)
- - #12775 Integration of property based testing into Bitcoin Core (Christewart)
- - #14119 Read reject reasons from debug log, not P2P messages (MarcoFalke)
- - #14189 Fix silent merge conflict in `wallet_importmulti` (MarcoFalke)
- - #13419 Speed up `knapsack_solver_test` by not recreating wallet 100 times (lucash-dev)
- - #14199 Remove redundant BIP174 test from `rpc_psbt.json` (araspitzu)
- - #14179 Fixups to "Run all tests even if wallet is not compiled" (MarcoFalke)
- - #14225 Reorder tests and move most of extended tests up to normal tests (ken2812221)
- - #14236 `generate` --> `generatetoaddress` change to allow tests run without wallet (sanket1729)
- - #14287 Use MakeUnique to construct objects owned by `unique_ptrs` (practicalswift)
- - #14007 Run functional test on Windows and enable it on Appveyor (ken2812221)
- - #14275 Write the notification message to different files to avoid race condition in `feature_notifications.py` (ken2812221)
- - #14306 appveyor: Move AppVeyor YAML to dot-file-style YAML (MitchellCash)
- - #14305 Enforce critical class instance attributes in functional tests, fix segwit test specificity (JustinTArthur)
- - #12246 Bugfix: Only run bitcoin-tx tests when bitcoin-tx is enabled (luke-jr)
- - #14316 Exclude all tests with difference parameters in `--exclude` list (ken2812221)
- - #14381 Add missing call to `skip_if_no_cli()` (practicalswift)
- - #14389 travis: Set codespell version to avoid breakage (MarcoFalke)
- - #14398 Don't access out of bounds array index: array[sizeof(array)] (Empact)
- - #14419 Remove `rpc_zmq.py` (jnewbery)
- - #14241 appveyor: Script improvement (ken2812221)
- - #14413 Allow closed RPC handler in `assert_start_raises_init_error` (ken2812221)
- - #14324 Run more tests with wallet disabled (MarcoFalke)
- - #13649 Allow arguments to be forwarded to flake8 in lint-python.sh (jamesob)
- - #14465 Stop node before removing the notification file (ken2812221)
- - #14460 Improve 'CAmount' tests (hebasto)
- - #14456 forward timeouts properly in `send_blocks_and_test` (jamesob)
- - #14527 Revert "Make qt wallet test compatible with qt4" (MarcoFalke)
- - #14504 Show the progress of functional tests (isghe)
- - #14559 appveyor: Enable multiwallet tests (ken2812221)
- - #13515 travis: Enable qt for all jobs (ken2812221)
- - #14571 Test that nodes respond to `getdata` with `notfound` (MarcoFalke)
- - #14569 Print dots by default in functional tests (ken2812221)
- - #14631 Move deterministic address import to `setup_nodes` (jnewbery)
- - #14630 test: Remove travis specific code (MarcoFalke)
- - #14528 travis: Compile once on xenial (MarcoFalke)
- - #14092 Dry run `bench_bitcoin` as part `make check` to allow for quick identification of assertion/sanitizer failures in benchmarking code (practicalswift)
- - #14664 `example_test.py`: fixup coinbase height argument, derive number clearly (instagibbs)
- - #14522 Add invalid P2P message tests (jamesob)
- - #14619 Fix value display name in `test_runner` help text (merland)
- - #14672 Send fewer spam messages in `p2p_invalid_messages` (jamesob)
- - #14673 travis: Fail the ubsan travis build in case of newly introduced ubsan errors (practicalswift)
- - #14665 appveyor: Script improvement part II (ken2812221)
- - #14365 Add Python dead code linter (vulture) to Travis (practicalswift)
- - #14693 `test_node`: `get_mem_rss` fixups (MarcoFalke)
- - #14714 util.h: explicitly include required QString header (1Il1)
- - #14705 travis: Avoid timeout on verify-commits check (MarcoFalke)
- - #14770 travis: Do not specify sudo in `.travis` (scravy)
- - #14719 Check specific reject reasons in `feature_block` (MarcoFalke)
- - #14771 Add `BOOST_REQUIRE` to getters returning optional (MarcoFalke)
- - #14777 Add regtest for JSON-RPC batch calls (domob1812)
- - #14764 travis: Run thread sanitizer on unit tests (MarcoFalke)
- - #14400 Add Benchmark to test input de-duplication worst case (JeremyRubin)
- - #14812 Fix `p2p_invalid_messages` on macOS (jamesob)
- - #14813 Add `wallet_encryption` error tests (MarcoFalke)
- - #14820 Fix `descriptor_tests` not checking ToString output of public descriptors (ryanofsky)
- - #14794 Add AddressSanitizer (ASan) Travis build (practicalswift)
- - #14819 Bugfix: `test/functional/mempool_accept`: Ensure oversize transaction is actually oversize (luke-jr)
- - #14822 bench: Destroy wallet txs instead of leaking their memory (MarcoFalke)
- - #14683 Better `combine_logs.py` behavior (jamesob)
- - #14231 travis: Save cache even when build or test fail (ken2812221)
- - #14816 Add CScriptNum decode python implementation in functional suite (instagibbs)
- - #14861 Modify `rpc_bind` to conform to #14532 behaviour (dongcarl)
- - #14864 Run scripted-diff in subshell (dongcarl)
- - #14795 Allow `test_runner` command line to receive parameters for each test (marcoagner)
- - #14788 Possible fix the permission error when the tests open the cookie file (ken2812221)
- - #14857 `wallet_keypool_topup.py`: Test for all keypool address types (instagibbs)
- - #14886 Refactor importmulti tests (jnewbery)
- - #14908 Removed implicit CTransaction constructor calls from tests and benchmarks (lucash-dev)
- - #14903 Handle ImportError explicitly, improve comparisons against None (daniel-s-ingram)
- - #14884 travis: Enforce python 3.4 support through linter (Sjors)
- - #14940 Add test for truncated pushdata script (MarcoFalke)
- - #14926 consensus: Check that final transactions are valid (MarcoFalke)
- - #14937 travis: Fix travis would always be green even if it fail (ken2812221)
- - #14953 Make `g_insecure_rand_ctx` `thread_local` (MarcoFalke)
- - #14931 mempool: Verify prioritization is dumped correctly (MarcoFalke)
- - #14935 Test for expected return values when calling functions returning a success code (practicalswift)
- - #14969 Fix `cuckoocache_tests` TSAN failure introduced in 14935 (practicalswift)
- - #14964 Fix race in `mempool_accept` (MarcoFalke)
- - #14829 travis: Enable functional tests in the threadsanitizer (tsan) build job (practicalswift)
- - #14985 Remove `thread_local` from `test_bitcoin` (MarcoFalke)
- - #15005 Bump timeout to run tests in travis thread sanitizer (MarcoFalke)
- - #15013 Avoid race in `p2p_timeouts` (MarcoFalke)
- - #14960 lint/format-strings: Correctly exclude escaped percent symbols (luke-jr)
- - #14930 pruning: Check that verifychain can be called when pruned (MarcoFalke)
- - #15022 Upgrade Travis OS to Xenial (gkrizek)
- - #14738 Fix running `wallet_listtransactions.py` individually through `test_runner.py` (kristapsk)
- - #15026 Rename `rpc_timewait` to `rpc_timeout` (MarcoFalke)
- - #15069 Fix `rpc_net.py` `pong` race condition (Empact)
- - #14790 Allow running `rpc_bind.py` --nonloopback test without IPv6 (kristapsk)
- - #14457 add invalid tx templates for use in functional tests (jamesob)
- - #14855 Correct ineffectual WithOrVersion from `transactions_tests` (Empact)
- - #15099 Use `std::vector` API for construction of test data (domob1812)
- - #15102 Run `invalid_txs.InputMissing` test in `feature_block` (MarcoFalke)
- - #15059 Add basic test for BIP34 (MarcoFalke)
- - #15108 Tidy up `wallet_importmulti.py` (amitiuttarwar)
- - #15164 Ignore shellcheck warning SC2236 (promag)
- - #15170 refactor/lint: Add ignored shellcheck suggestions to an array (koalaman)
- - #14958 Remove race between connecting and shutdown on separate connections (promag)
- - #15166 Pin shellcheck version (practicalswift)
- - #15196 Update all `subprocess.check_output` functions to be Python 3.4 compatible (gkrizek)
- - #15043 Build fuzz targets into seperate executables (MarcoFalke)
- - #15276 travis: Compile once on trusty (MarcoFalke)
- - #15246 Add tests for invalid message headers (MarcoFalke)
- - #15301 When testing with --usecli, unify RPC arg to cli arg conversion and handle dicts and lists (achow101)
- - #15247 Use wallet to retrieve raw transactions (MarcoFalke)
- - #15303 travis: Remove unused `functional_tests_config` (MarcoFalke)
- - #15330 Fix race in `p2p_invalid_messages` (MarcoFalke)
- - #15324 Make bloom tests deterministic (MarcoFalke)
- - #15328 travis: Revert "run extended tests once daily" (MarcoFalke)
- - #15327 Make test `updatecoins_simulation_test` deterministic (practicalswift)
- - #14519 add utility to easily profile node performance with perf (jamesob)
- - #15349 travis: Only exit early if compilation took longer than 30 min (MarcoFalke)
- - #15350 Drop RPC connection if --usecli (promag)
- - #15370 test: Remove unused --force option (MarcoFalke)
- - #14543 minor `p2p_sendheaders` fix of height in coinbase (instagibbs)
- - #13787 Test for Windows encoding issue (ken2812221)
- - #15378 Added missing tests for RPC wallet errors (benthecarman)
- - #15238 remove some magic mining constants in functional tests (instagibbs)
- - #15411 travis: Combine --disable-bip70 into existing job (MarcoFalke)
- - #15295 fuzz: Add `test/fuzz/test_runner.py` and run it in travis (MarcoFalke)
- - #15413 Add missing `cs_main` locks required when accessing pcoinsdbview, pcoinsTip or pblocktree (practicalswift)
- - #15399 fuzz: Script validation flags (MarcoFalke)
- - #15410 txindex: interrupt threadGroup before calling destructor (MarcoFalke)
- - #15397 Remove manual byte editing in `wallet_tx_clone` func test (instagibbs)
- - #15415 functional: allow custom cwd, use tmpdir as default (Sjors)
- - #15404 Remove `-txindex` to start nodes (amitiuttarwar)
- - #15439 remove `byte.hex()` to keep compatibility (AkioNak)
- - #15419 Always refresh cache to be out of ibd (MarcoFalke)
- - #15507 Bump timeout on tests that timeout on windows (MarcoFalke)
- - #15506 appveyor: fix cache issue and reduce dependencies build time (ken2812221)
- - #15485 add `rpc_misc.py`, mv test getmemoryinfo, add test mallocinfo (adamjonas)
- - #15321 Add `cs_main` lock annotations for mapBlockIndex (MarcoFalke)
- - #14128 lint: Make sure we read the command line inputs using UTF-8 decoding in python (ken2812221)
- - #14115 lint: Make all linters work under the default macos dev environment (build-osx.md) (practicalswift)
- - #15219 lint: Enable python linters via an array (Empact)

### Platform support
- - #13866 utils: Use `_wfopen` and `_wfreopen` on windows (ken2812221)
- - #13886 utils: Run commands using UTF-8 string on windows (ken2812221)
- - #14192 utils: Convert `fs::filesystem_error` messages from local multibyte to UTF-8 on windows (ken2812221)
- - #13877 utils: Make fs::path::string() always return UTF-8 string on windows (ken2812221)
- - #13883 utils: Convert windows args to UTF-8 string (ken2812221)
- - #13878 utils: Add fstream wrapper to allow to pass unicode filename on windows (ken2812221)
- - #14426 utils: Fix broken windows filelock (ken2812221)
- - #14686 Fix windows build error if `--disable-bip70` (ken2812221)
- - #14922 windows: Set `_WIN32_WINNT` to 0x0601 (Windows 7) (ken2812221)
- - #13888 Call unicode API on Windows (ken2812221)
- - #15468 Use `fsbridge::ifstream` to fix Windows path issue (ken2812221)
- - #13734 Drop `boost::scoped_array` and use `wchar_t` API explicitly on Windows (ken2812221)
- - #13884 Enable bdb unicode support for Windows (ken2812221)

### Miscellaneous
- - #13935 contrib: Adjust output to current test format (AkioNak)
- - #14097 validation: Log FormatStateMessage on ConnectBlock error in ConnectTip (MarcoFalke)
- - #13724 contrib: Support ARM and RISC-V symbol check (ken2812221)
- - #13159 Don't close old debug log file handle prematurely when trying to re-open (on SIGHUP) (practicalswift)
- - #14186 bitcoin-cli: don't translate command line options (HashUnlimited)
- - #14057 logging: Only log `using config file path_to_bitcoin.conf` message on startup if conf file exists (leishman)
- - #14164 Update univalue subtree (MarcoFalke)
- - #14272 init: Remove deprecated args from hidden args (MarcoFalke)
- - #14494 Error if # is used in rpcpassword in conf (MeshCollider)
- - #14742 Properly generate salt in rpcauth.py (dongcarl)
- - #14708 Warn unrecognised sections in the config file (AkioNak)
- - #14756 Improve rpcauth.py by using argparse and getpass modules (promag)
- - #14785 scripts: Fix detection of copyright holders (cornelius)
- - #14831 scripts: Use `#!/usr/bin/env bash` instead of `#!/bin/bash` (vim88)
- - #14869 Scripts: Add trusted key for samuel dobson (laanwj)
- - #14809 Tools: improve verify-commits.py script (jlopp)
- - #14624 Some simple improvements to the RNG code (sipa)
- - #14947 scripts: Remove python 2 import workarounds (practicalswift)
- - #15087 Error if rpcpassword contains hash in conf sections (MeshCollider)
- - #14433 Add checksum in gitian build scripts for ossl (TheCharlatan)
- - #15165 contrib: Allow use of github api authentication in github-merge (laanwj)
- - #14409 utils and libraries: Make 'blocksdir' always net specific (hebasto)
- - #14839 threads: Fix unitialized members in `sched_param` (fanquake)
- - #14955 Switch all RNG code to the built-in PRNG (sipa)
- - #15258 Scripts and tools: Fix `devtools/copyright_header.py` to always honor exclusions (Empact)
- - #12255 Update bitcoin.service to conform to init.md (dongcarl)
- - #15266 memory: Construct globals on first use (MarcoFalke)
- - #15347 Fix build after pr 15266 merged (hebasto)
- - #15351 Update linearize-hashes.py (OverlordQ)
- - #15358 util: Add setuphelpoptions() (MarcoFalke)
- - #15216 Scripts and tools: Replace script name with a special parameter (hebasto)
- - #15250 Use RdSeed when available, and reduce RdRand load (sipa)
- - #15278 Improve PID file error handling (hebasto)
- - #15270 Pull leveldb subtree (MarcoFalke)
- - #15456 Enable PID file creation on WIN (riordant)
- - #12783 macOS: disable AppNap during sync (krab)
- - #13910 Log progress while verifying blocks at level 4 (domob1812)
- - #15124 Fail AppInitMain if either disk space check fails (Empact)
- - #15117 Fix invalid memory write in case of failing mmap(?) in PosixLockedPageAllocator::AllocateLocked (practicalswift)
- - #14357 streams: Fix broken `streams_vector_reader` test. Remove unused `seek(size_t)`
- - #11640 Make `LOCK`, `LOCK2`, `TRY_LOCK` work with CWaitableCriticalSection (ryanofsky)
- - #14074 Use `std::unordered_set` instead of `set` in blockfilter interface (jimpo)
- - #15275 Add gitian PGP key for hebasto (hebasto)

### Documentation
- - #14120 Notes about control port and read access to cookie (JBaczuk)
- - #14135 correct GetDifficulty doc after #13288 (fanquake)
- - #14013 Add new regtest ports in man following #10825 ports reattributions (ariard)
- - #14149 Remove misleading checkpoints comment in CMainParams (MarcoFalke)
- - #14153 Add disable-wallet section to OSX build instructions, update line in Unix instructions (bitstein)
- - #13662 Explain when reindex-chainstate can be used instead of reindex (Sjors)
- - #14207 `-help-debug` implies `-help` (laanwj)
- - #14213 Fix reference to lint-locale-dependence.sh (hebasto)
- - #14206 Document `-checklevel` levels (laanwj)
- - #14217 Add GitHub PR template (MarcoFalke)
- - #14331 doxygen: Fix member comments (MarcoFalke)
- - #14264 Split depends installation instructions per arch (MarcoFalke)
- - #14393 Add missing apt-get install (poiuty)
- - #14428 Fix macOS files description in qt/README.md (hebasto)
- - #14390 release process: RPC documentation (karel-3d)
- - #14472 getblocktemplate: use SegWit in example (Sjors)
- - #14497 Add doc/bitcoin-conf.md (hebasto)
- - #14526 Document lint tests (fanquake)
- - #14511 Remove explicit storage requirement from README.md (merland)
- - #14600 Clarify commit message guidelines (merland)
- - #14617 FreeBSD: Document Python 3 requirement for 'gmake check' (murrayn)
- - #14592 Add external interface consistency guarantees (MarcoFalke)
- - #14625 Make clear function argument case in dev notes (dongcarl)
- - #14515 Update OpenBSD build guide for 6.4 (fanquake)
- - #14436 Add comment explaining recentRejects-DoS behavior (jamesob)
- - #14684 conf: Remove deprecated options from docs, Other cleanup (MarcoFalke)
- - #14731 Improve scripted-diff developer docs (dongcarl)
- - #14778 A few minor formatting fixes and clarifications to descriptors.md (jnewbery)
- - #14448 Clarify rpcwallet flag url change (JBaczuk)
- - #14808 Clarify RPC rawtransaction documentation (jlopp)
- - #14804 Less confusing documentation for `torpassword` (fanquake)
- - #14848 Fix broken Gmane URL in security-check.py (cyounkins-bot)
- - #14882 developer-notes.md: Point out that UniValue deviates from upstream (Sjors)
- - #14909 Update minimum required Qt (fanquake)
- - #14914 Add nice table to files.md (emilengler)
- - #14741 Indicate `-rpcauth` option password hashing alg (dongcarl)
- - #14950 Add NSIS setup/install steps to windows docs (fanquake)
- - #13930 Better explain GetAncestor check for `m_failed_blocks` in AcceptBlockHeader (Sjors)
- - #14973 Improve Windows native build instructions (murrayn)
- - #15073 Botbot.me (IRC logs) not available anymore (anduck)
- - #15038 Get more info about GUI-related issue on Linux (hebasto)
- - #14832 Add more Doxygen information to Developer Notes (ch4ot1c)
- - #15128 Fix download link in doc/README.md (merland)
- - #15127 Clarifying testing instructions (benthecarman)
- - #15132 Add FreeBSD build notes link to doc/README.md (fanquake)
- - #15173 Explain what .python-version does (Sjors)
- - #15223 Add information about security to the JSON-RPC doc (harding)
- - #15249 Update python docs to reflect that wildcard imports are disallowed (Empact)
- - #15176 Get rid of badly named `doc/README_osx.md` (merland)
- - #15272 Correct logging return type and RPC example (fanquake)
- - #15244 Gdb attaching to process during tests has non-sudo solution (instagibbs)
- - #15332 Small updates to `getrawtransaction` description (amitiuttarwar)
- - #15354 Add missing `bitcoin-wallet` tool manpages (MarcoFalke)
- - #15343 netaddress: Make IPv4 loopback comment more descriptive (dongcarl)
- - #15353 Minor textual improvements in `translation_strings_policy.md` (merland)
- - #15426 importmulti: add missing description of keypool option (harding)
- - #15425 Add missing newline to listunspent help for witnessScript (harding)
- - #15348 Add separate productivity notes document (dongcarl)
- - #15416 Update FreeBSD build guide for 12.0 (fanquake)
- - #15222 Add info about factors that affect dependency list (merland)
- - #13676 Explain that mempool memory is added to `-dbcache` (Sjors)
- - #15273 Slight tweak to the verify-commits script directions (droark)
- - #15477 Remove misleading hint in getrawtransaction (MarcoFalke)
- - #15489 Update release process for snap package (MarcoFalke)
- - #15524 doc: Remove berkeleydb PPA from linux build instructions (MarcoFalke)
- - #15559 Correct `analyzepsbt` rpc doc (fanquake)
- - #15194 Add comment describing `fDisconnect` behavior (dongcarl)
- - #15754 getrpcinfo docs (benthecarman)
- - #15763 Update bips.md for 0.18.0 (sipa)
- - #15757 List new RPCs in psbt.md and descriptors.md (sipa)
- - #15765 correct bitcoinconsensus_version in shared-libraries.md (fanquake)
- - #15792 describe onlynet option in doc/tor.md (jonatack)
- - #15802 mention creating application support bitcoin folder on OSX (JimmyMow)
- - #15799 Clarify RPC versioning (MarcoFalke)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - 1Il1
- - 251
- - Aaron Clauson
- - Adam Jonas
- - Akio Nakamura
- - Alexander Leishman
- - Alexey Ivanov
- - Alexey Poghilenkov
- - Amir Abrams
- - Amiti Uttarwar
- - Andrew Chow
- - andrewtoth
- - Anthony Towns
- - Antoine Le Calvez
- - Antoine Riard
- - Antti Majakivi
- - araspitzu
- - Arvid Norberg
- - Ben Carman
- - Ben Woosley
- - benthecarman
- - bitcoinhodler
- - Carl Dong
- - Chakib Benziane
- - Chris Moore
- - Chris Stewart
- - chris-belcher
- - Chun Kuan Lee
- - Cornelius Schumacher
- - Cory Fields
- - Craig Younkins
- - Cristian Mircea Messel
- - Damian Mee
- - Daniel Ingram
- - Daniel Kraft
- - David A. Harding
- - DesWurstes
- - dexX7
- - Dimitri Deijs
- - Dimitris Apostolou
- - Douglas Roark
- - DrahtBot
- - Emanuele Cisbani
- - Emil Engler
- - Eric Scrivner
- - fridokus
- - Gal Buki
- - Gleb Naumenko
- - Glenn Willen
- - Graham Krizek
- - Gregory Maxwell
- - Gregory Sanders
- - gustavonalle
- - Harry Moreno
- - Hennadii Stepanov
- - Isidoro Ghezzi
- - Jack Mallers
- - James Hilliard
- - James O'Beirne
- - Jameson Lopp
- - Jeremy Rubin
- - Jesse Cohen
- - Jim Posen
- - John Newbery
- - Jon Layton
- - Jonas Schnelli
- - Jo?o Barbosa
- - Jordan Baczuk
- - Jorge Tim?n
- - Julian Fleischer
- - Justin Turner Arthur
- - Karel B?lek
- - Karl-Johan Alm
- - Kaz Wesley
- - ken2812221
- - Kostiantyn Stepaniuk
- - Kristaps Kaupe
- - Lawrence Nahum
- - Lenny Maiorani
- - liuyujun
- - lucash-dev
- - luciana
- - Luke Dashjr
- - marcaiaf
- - marcoagner
- - MarcoFalke
- - Martin Erlandsson
- - Marty Jones
- - Mason Simon
- - Michael Ford
- - Michael Goldstein
- - Michael Polzer
- - Mitchell Cash
- - mruddy
- - Murray Nesbitt
- - OverlordQ
- - Patrick Strateman
- - Pierre Rochard
- - Pieter Wuille
- - poiuty
- - practicalswift
- - priscoan
- - qubenix
- - riordant
- - Russell Yanofsky
- - Samuel Dobson
- - sanket1729
- - Sjors Provoost
- - Stephan Oeste
- - Steven Roose
- - Suhas Daftuar
- - TheCharlatan
- - Tim Ruffing
- - Vidar Holen
- - vim88
- - Walter
- - whythat
- - Wladimir J. van der Laan
- - Zain Iqbal Allarakhia

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAlzKpd8ACgkQHkrtYphs
0l2kkQgAiQPVcgcckNxZt3fy4SriLnL2E2lR5CCUC3UA1Aeq1m22NoZOX2oOJXE2
YHqq94ufCOiAracJ/38OB60hbVZaWhsXMWgfuMIFtG1SMQMmOT4sEIG639kiFPoy
J+c045GI9Kasje3beJZCQUMleYroIb7n2H8yGZG5x1S+/H8htx2NPHp54MzQHBbj
SWclp1aLtff3qfgk8slWI1AC7eopw2nqeunNktwauc35CUZun9S4C+g+q0d3w3wH
9N4hK0BCEptA9jKiMLoPEKcihiyKod2RjSe3m5vZTGNOJ6fz4F7LhzkYBGe5Rt5d
g3n/Anm3fVRNU0HHPoJUZT21LHwjCg==
=l+2W
-----END PGP SIGNATURE-----

From achow101-lists at achow101.com  Wed May  1 16:57:38 2019
From: achow101-lists at achow101.com (Andrew Chow)
Date: Wed, 01 May 2019 16:57:38 +0000
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more
	secure
In-Reply-To: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
References: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
Message-ID: <-9vv_PTO55EHqObZe3e3wBo_sNF34p0IWbK-rkrcW4q31pQwahpqy4xJw9dq_CB2UCo1FvOz6I3EMcQM_9u5Ht3y9VFYAB2uJGkZjds84nI=@achow101.com>

Hi Stepan,

I think that this would be a good extension.

Just for clairty, by xpub, do you mean the extended serialization format 
defined in BIP 32 or the Base58 check encoded string of that serialization?

Andrew

On 4/26/19 11:21 AM, Stepan Snigirev via bitcoin-dev wrote:
> Hi list,
>
> I was looking at the bip174 PSBT specs, in particular for 
> multisignature setup, and I think with current spec there is a way to 
> steal user funds in M of N setup with M ? N/2.
>
> I made a small write-up on this: 
> https://github.com/stepansnigirev/random_notes/blob/master/psbt_multisig.md
>
> To compress:
>
> Currently in PSBT there is no way to reliably say if the output uses 
> the keys derived from the same root keys as the inputs aside from the 
> key owned by the signer => there is no way to verify that the output 
> is a change output in multisig setup.
>
> Therefore an attacker can replace half of the keys in the change 
> address by his own keys and still get the transaction signed.
>
> I suggest to add an xpub field to the inputs and outputs metadata, 
> then signers can verify that the same xpubs are used for public keys 
> in inputs and outputs => output is indeed a change.
>
> Normally change and receiving addresses are derived from the same xpub 
> with non-hardened derivation pathes, so providing xpub after the last 
> hardened index should be enough to see that public keys of inputs and 
> change output are derived from the same xpub.
>
> I suggest to add the following key-value pairs to PSBT:
>
> Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`
> - Key: derivation path for xpub
> ? `{0x10}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`
> - Value: 78-byte xpub value
> ? `{xpub}`
>
> Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`
> - Key: derivation path for xpub
> ? `{0x03}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`
> - Value: 78-byte xpub value
> ? `{xpub}`
>
> Derivation paths are in the key of the key-value pair as they are used 
> for lookup, and xpub itself is the actual value being looked up.
>
> I also want to mention that Trezor for example doesn't suffer from 
> this problem as they use xpubs to verify change outputs. So it may 
> make sense to go through the communication protocols of existing 
> hardware / multisignature wallets and see if there is something else 
> we are missing.
>
> If everyone is happy about the proposal I would prepare a pull request 
> to the bip.
>
> Best regards,
> Stepan Snigirev.
>


From falke.marco at gmail.com  Thu May  2 16:16:08 2019
From: falke.marco at gmail.com (Marco Falke)
Date: Thu, 2 May 2019 12:16:08 -0400
Subject: [bitcoin-dev] [bitcoin-core-dev] Bitcoin Core 0.18.0 released
In-Reply-To: <20190502081103.wfiglbuj7trtackz@aurora.visucore.com>
References: <20190502081103.wfiglbuj7trtackz@aurora.visucore.com>
Message-ID: <CAK51vgD+NOScgv9vRW6SnFGFxXLW0rxEqREBMqxWj+bBcVPzUA@mail.gmail.com>

Two addenda from me:

* Beginning with Bitcoin Core 0.18.0, Windows builds for 32-bit
Windows will no longer be provided. Please let us know if and why you
can not use the 64-bit build.
* There is an experimental Bitcoin Core snap package in the snap
store. There should be a "track" for the latest release and a track
for each major version branch that is not yet EOL. While the snap
package uses the signed release binaries, I am not aware of a way to
generate the hash of binaries in an installed snap that works on any
Linux distribution. (On some distributions, a call to `sha256sum
/var/lib/snapd/snap/bitcoin-core/current/{bin/*,snap/snapcraft.yaml}`
generates the hashes that you can then compare to the signed ones as
usual)

Marco

From peter at coinkite.com  Fri May  3 13:29:45 2019
From: peter at coinkite.com (Peter D. Gray)
Date: Fri, 3 May 2019 09:29:45 -0400
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more
 secure
In-Reply-To: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
References: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
Message-ID: <20190503132945.GR810@coinkite.com>

On Fri, Apr 26, 2019 at 05:21:06PM +0200, Stepan Snigirev wrote:
...
> Currently in PSBT there is no way to reliably say if the output uses the
> keys derived from the same root keys as the inputs aside from the key owned

Writing the multisig support for Coldcard, I've come to the same conclusion. I've
exchanged some helpful mail with Andrew Chow on this subject.

...
> I suggest to add the following key-value pairs to PSBT:
> Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`
...
> Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`

I'd rather see the xpubs shared in the global section of the file,
with the restriction that they must/should only include the hardened
prefix of the path. The existing bip32 derivation path included in
individual inputs and outputs be merged in as needed.

After all in a typical PSBT, we would expect the same master keys
to be used on all inputs, and at least one output, and there might
be as many as 20 co-signers. No need to repeat all that information.

Even with this additions to the PSBT format, I think PSBT-signing
devices still need to store the xpubs of their co-signers. It's not
possible to safely show an incoming address to the user without a
full understanding of the other keys in a "multisig wallet". Also,
it represents data that should not change between PSBT instances
(ie. tomorrow's co-signers should match today's).

Having said that, the xpubs in the PSBT would allow a "trust on first
use" which I think can be a good feature.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10


> Hi list,
> 
> I was looking at the bip174 PSBT specs, in particular for multisignature
> setup, and I think with current spec there is a way to steal user funds in
> M of N setup with M ? N/2.
> 
> I made a small write-up on this:
> https://github.com/stepansnigirev/random_notes/blob/master/psbt_multisig.md
> 
> To compress:
> 
> Currently in PSBT there is no way to reliably say if the output uses the
> keys derived from the same root keys as the inputs aside from the key owned
> by the signer => there is no way to verify that the output is a change
> output in multisig setup.
> 
> Therefore an attacker can replace half of the keys in the change address by
> his own keys and still get the transaction signed.
> 
> I suggest to add an xpub field to the inputs and outputs metadata, then
> signers can verify that the same xpubs are used for public keys in inputs
> and outputs => output is indeed a change.
> 
> Normally change and receiving addresses are derived from the same xpub with
> non-hardened derivation pathes, so providing xpub after the last hardened
> index should be enough to see that public keys of inputs and change output
> are derived from the same xpub.
> 
> I suggest to add the following key-value pairs to PSBT:
> 
> Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`
> - Key: derivation path for xpub
>   `{0x10}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`
> - Value: 78-byte xpub value
>   `{xpub}`
> 
> Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`
> - Key: derivation path for xpub
>   `{0x03}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`
> - Value: 78-byte xpub value
>   `{xpub}`
> 
> Derivation paths are in the key of the key-value pair as they are used for
> lookup, and xpub itself is the actual value being looked up.
> 
> I also want to mention that Trezor for example doesn't suffer from this
> problem as they use xpubs to verify change outputs. So it may make sense to
> go through the communication protocols of existing hardware /
> multisignature wallets and see if there is something else we are missing.
> 
> If everyone is happy about the proposal I would prepare a pull request to
> the bip.
> 
> Best regards,
> Stepan Snigirev.

From james at prestwi.ch  Thu May  2 23:33:09 2019
From: james at prestwi.ch (James Prestwich)
Date: Thu, 2 May 2019 16:33:09 -0700
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <6b8f2a91-af73-4d66-1b90-51acd4ce217c@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
	<aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
	<1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>
	<UjO5iL0rbqOeo-nhFpOQSnVX7B4EHToLspAjUNFevNahTrU5O650U0shNQEOwSMCUxs90LZOtl5OuX9VawOXtGTTaW1Wl0gEQF0gv_jtb6w=@protonmail.com>
	<6b8f2a91-af73-4d66-1b90-51acd4ce217c@gmail.com>
Message-ID: <CAOP2CbwfwnDCRTpsoDyAHemRYu617QeOWinwM8j95m5e7ceRKA@mail.gmail.com>

Hi Aymeric,

As Luke and ZmnSCPxj have pointed out, documenting standardness is
sisyphean, as it varies from version to version. I recently put together a
reference for default TX_NONSTANDARD policies in v0.18, which can be found
here: https://prestwi.ch/the-bitcoin-nonstandard/

It applies only to v0.18, and may already be outdated.

Best,
James

On Thu, May 2, 2019 at 4:29 PM Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks for the answer, indeed for the redeem script and someone
> attempting a 0/1 of 3, good example
>
> So to summarize everything is standard as long as it matches P2PKH,
> P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in
> op_return
>
> Still the case of bch is unclear (it's related since based on bitcoin
> code unless they changed the policy), was the story that nodes would not
> propagate the fix or that people did not want to take the risk to
> propagate it? And why a non segwit old bitcoin node would not accept it
> either?
>
> Le 02/05/2019 ? 02:10, ZmnSCPxj a ?crit :
> > Good morning Aymeric,
> >
> >
> > Sent with ProtonMail Secure Email.
> >
> > ??????? Original Message ???????
> > On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte <
> vitteaymeric at gmail.com> wrote:
> >
> >> I must badly explain my point (or just wondering things that do not
> >> exist finally), the question is indeed whether nodes will relay non
> >> usual transactions or not and how to know what they will accept or not:
> >>
> >> -   my modified multisig 2 of 3: I did put OP_2 out of the usual redeem
> >>     script, the redeem script still matches scriptpubkey and scriptsig
> will
> >>     execute succesfully, that's a normal legacy P2SH or segwit P2WSH
> >>
> >> -   bch segwit recovery: it's a p2sh transaction without any signature
> >>     verification, as far as I remember there was a story that it could
> not
> >>     propagate in the network (even taking the risk to be stolen) and
> that
> >>     people had to contact a (honest) miner
> >>
> >> -   sha bounties: same as above, p2sh transactions without signatures
> >>
> >>     etc
> >>
> >>     Will all of those transactions propagate normally? And then the
> rule is
> >>     just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates
> >>     whatever scripts you put inside?
> > P2PKH and P2WPKH cannot have custom script.
> > However, yes, any custom script can be wrapped in P2SH and P2WSH and it
> will be propagated.
> > The P2SH/P2WSH hides the details of your custom script so cannot be
> filtered based on your custom script.
> > Do realize that once a claim on your modified x-of-3 is propagated your
> `redeemScript` is known and someone can attempt to RBF (or coordinate with
> a miner) with a modified `witness` stack or `scriptSig` to claim your UTXO.
> > (I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at least one of
> your signatories could make it a 1-of-3 and bribe a miner to get it claimed)
> >
> > I cannot answer for BCH; arguably that is off-topic here.
> >
> > The old SHA bounty transactions were propagated in the days before
> `isStandard` I think.
> > Either that or they were put in by miners.
> > An SHA bounty can still be propagated today if they are wrapped in a
> P2SH or P2WSH, but you have to publish the `redeemScript` yourself in some
> other method.
> > Or bribe a miner if the transaction is not time-sensitive (for an SHA
> bounty, unlikely to be time-sensitive).
> >
> > Regards,
> > ZmnSCPxj
>
> --
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple:
> https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist:
> http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor <https://github.com/Ayms/torrent-livenode-Tor> :
> https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190502/4a39edaa/attachment-0001.html>

From pieter.wuille at gmail.com  Thu May  2 23:35:06 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 2 May 2019 16:35:06 -0700
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <6b8f2a91-af73-4d66-1b90-51acd4ce217c@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
	<aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
	<1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>
	<UjO5iL0rbqOeo-nhFpOQSnVX7B4EHToLspAjUNFevNahTrU5O650U0shNQEOwSMCUxs90LZOtl5OuX9VawOXtGTTaW1Wl0gEQF0gv_jtb6w=@protonmail.com>
	<6b8f2a91-af73-4d66-1b90-51acd4ce217c@gmail.com>
Message-ID: <CAPg+sBgDEMfeh_17q++EANOu9T4fcf49kJdi4rT8vRqQQkmdHA@mail.gmail.com>

On Thu, 2 May 2019 at 16:28, Aymeric Vitte via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Thanks for the answer, indeed for the redeem script and someone
> attempting a 0/1 of 3, good example
>
> So to summarize everything is standard as long as it matches P2PKH,
> P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in
> op_return

Generally, all spends of P2SH/P2WSH is standard, with the following exceptions:
* Non-push operations in the scriptSig
* Resource limitations (too large scripts or items on the stack)
* Protections against known attack vectors (low s rule, cleanstack
rule, minimally encoded numbers rule, codesep usage, ...)
* Usage of unconditionally spendable constructions intended for future
extensions, such as spending future segwit versions.

Cheers,

-- 
Pieter

From vitteaymeric at gmail.com  Fri May  3 09:51:25 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 3 May 2019 11:51:25 +0200
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <CAOP2CbwfwnDCRTpsoDyAHemRYu617QeOWinwM8j95m5e7ceRKA@mail.gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
	<aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
	<1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>
	<UjO5iL0rbqOeo-nhFpOQSnVX7B4EHToLspAjUNFevNahTrU5O650U0shNQEOwSMCUxs90LZOtl5OuX9VawOXtGTTaW1Wl0gEQF0gv_jtb6w=@protonmail.com>
	<6b8f2a91-af73-4d66-1b90-51acd4ce217c@gmail.com>
	<CAOP2CbwfwnDCRTpsoDyAHemRYu617QeOWinwM8j95m5e7ceRKA@mail.gmail.com>
Message-ID: <37e3f1ee-a3c6-2670-f0e0-4b939bf8e396@gmail.com>

Great doc, thanks, then my previous summarized conclusion was wrong,
trying on my side to write a "demistifying (simply) once for all bitcoin
scripting", not sure that "simply" can stay in the title at the end...

So my multisig modification is non standard, now I am still puzzled by
something, mainly the fact that we have op_pushdata inside op_pushdata,
maybe I am misreading the specs, but in case of p2sh only the last
op_pushdata (called {serialized script} (or redeem script) is executed,
then if succesfull it comes back onto the stack and scriptpubkey is executed

So, let's take again the BCH recovery example, scriptSig was OP_PUSHDATA
0014<hash160 of pubkey>, and scriptPubKey OP_HASH160 <hash160 of
0014<hash160 of pubkey> OP_EQUAL, then scriptSig executes pushing
nothing and <hash160 of pubkey> into the stack, then scriptSig is pushed
again and executed with scriptPubKey, at the end we get nothing +
<hash160 of pubkey> + 1 in the stack, then cleanstack (maybe among
others, I have to read in more details your doc) says it is a correct
transaction but non standard, is this correct?

Le 03/05/2019 ? 01:33, James Prestwich a ?crit?:
> Hi Aymeric,?
>
> As Luke and ZmnSCPxj have pointed out, documenting standardness is
> sisyphean, as it varies from version to version. I recently put
> together a reference for default TX_NONSTANDARD policies in v0.18,
> which can be found here:?https://prestwi.ch/the-bitcoin-nonstandard/?
>
> It applies only to v0.18, and may already be outdated.
>
> Best,
> James
>
> On Thu, May 2, 2019 at 4:29 PM Aymeric Vitte via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     Thanks for the answer, indeed for the redeem script and someone
>     attempting a 0/1 of 3, good example
>
>     So to summarize everything is standard as long as it matches P2PKH,
>     P2SH, P2WPKH or P2WSH , the redeem scripts for the sha bounties are in
>     op_return
>
>     Still the case of bch is unclear (it's related since based on bitcoin
>     code unless they changed the policy), was the story that nodes
>     would not
>     propagate the fix or that people did not want to take the risk to
>     propagate it? And why a non segwit old bitcoin node would not
>     accept it
>     either?
>
>     Le 02/05/2019 ? 02:10, ZmnSCPxj a ?crit?:
>     > Good morning Aymeric,
>     >
>     >
>     > Sent with ProtonMail Secure Email.
>     >
>     > ??????? Original Message ???????
>     > On Tuesday, April 30, 2019 5:43 PM, Aymeric Vitte
>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>     >
>     >> I must badly explain my point (or just wondering things that do not
>     >> exist finally), the question is indeed whether nodes will relay non
>     >> usual transactions or not and how to know what they will accept
>     or not:
>     >>
>     >> -? ?my modified multisig 2 of 3: I did put OP_2 out of the
>     usual redeem
>     >>? ? ?script, the redeem script still matches scriptpubkey and
>     scriptsig will
>     >>? ? ?execute succesfully, that's a normal legacy P2SH or segwit
>     P2WSH
>     >>
>     >> -? ?bch segwit recovery: it's a p2sh transaction without any
>     signature
>     >>? ? ?verification, as far as I remember there was a story that
>     it could not
>     >>? ? ?propagate in the network (even taking the risk to be
>     stolen) and that
>     >>? ? ?people had to contact a (honest) miner
>     >>
>     >> -? ?sha bounties: same as above, p2sh transactions without
>     signatures
>     >>
>     >>? ? ?etc
>     >>
>     >>? ? ?Will all of those transactions propagate normally? And then
>     the rule is
>     >>? ? ?just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH
>     templates
>     >>? ? ?whatever scripts you put inside?
>     > P2PKH and P2WPKH cannot have custom script.
>     > However, yes, any custom script can be wrapped in P2SH and P2WSH
>     and it will be propagated.
>     > The P2SH/P2WSH hides the details of your custom script so cannot
>     be filtered based on your custom script.
>     > Do realize that once a claim on your modified x-of-3 is
>     propagated your `redeemScript` is known and someone can attempt to
>     RBF (or coordinate with a miner) with a modified `witness` stack
>     or `scriptSig` to claim your UTXO.
>     > (I do not know if `OP_CHECKMULTISIG` supports 0-of-3 but at
>     least one of your signatories could make it a 1-of-3 and bribe a
>     miner to get it claimed)
>     >
>     > I cannot answer for BCH; arguably that is off-topic here.
>     >
>     > The old SHA bounty transactions were propagated in the days
>     before `isStandard` I think.
>     > Either that or they were put in by miners.
>     > An SHA bounty can still be propagated today if they are wrapped
>     in a P2SH or P2WSH, but you have to publish the `redeemScript`
>     yourself in some other method.
>     > Or bribe a miner if the transaction is not time-sensitive (for
>     an SHA bounty, unlikely to be time-sensitive).
>     >
>     > Regards,
>     > ZmnSCPxj
>
>     -- 
>     Move your coins by yourself (browser version):
>     https://peersm.com/wallet
>     Bitcoin transactions made simple:
>     https://github.com/Ayms/bitcoin-transactions
>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist
>     Check the 10 M passwords list: http://peersm.com/findmyass
>     Anti-spies and private torrents, dynamic blocklist:
>     http://torrent-live.org
>     Peersm : http://www.peersm.com
>     torrent-live: https://github.com/Ayms/torrent-live
>     node-Tor <https://github.com/Ayms/torrent-livenode-Tor> :
>     https://www.github.com/Ayms/node-Tor
>     GitHub : https://www.github.com/Ayms
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190503/fa40d55f/attachment-0001.html>

From luke at dashjr.org  Sat May  4 02:50:02 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 4 May 2019 02:50:02 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.18.0.knots20190502 released
Message-ID: <201905040250.10240.luke@dashjr.org>

Bitcoin Knots version *0.18.0.knots20190502* is now available from:

  <https://bitcoinknots.org/files/0.18.x/0.18.0.knots20190502/>

This is a new major version release, including new features, various bug
fixes and performance improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoinknots/bitcoin/issues>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has
completely shut down (which might take a few minutes for older
versions), then run the installer (on Windows) or just copy over
`/Applications/Bitcoin-Qt` (on Mac) or `bitcoind`/`bitcoin-qt` (on
Linux).

The first time you run version 0.15.0 or newer, your chainstate database
will be converted to a new format, which will take anywhere from a few
minutes to half an hour, depending on the speed of your machine.

Note that the block database format also changed in version 0.8.0 and
there is no automatic upgrade code from before version 0.8 to version
0.15.0 or later. Upgrading directly from 0.7.x and earlier without
redownloading the blockchain is not supported.  However, as usual, old
wallet versions are still supported.

Compatibility
==============

Bitcoin Knots is supported on operating systems using the Linux kernel,
macOS 10.10+, and Windows 7 and newer. It is not recommended to use
Bitcoin Knots on unsupported systems.

From 0.17.0 onwards, macOS <10.10 is no longer supported. 0.17.0 is
built using Qt 5.9.x, which doesn't support versions of macOS older than
10.10. Additionally, Bitcoin Knots does not yet change appearance when
macOS "dark mode" is activated.

In addition to previously-supported CPU platforms, this release's
pre-compiled distribution also provides binaries for the RISC-V
platform.

If you are using the `systemd` unit configuration file located at
`contrib/init/bitcoind.service`, it has been changed to use
`/var/lib/bitcoind` as the data directory instead of
`~bitcoin/.bitcoin`. When switching over to the new configuration file,
please make sure that the filesystem on which `/var/lib/bitcoind` will
exist has enough space (check using `df -h /var/lib/bitcoind`), and
optionally copy over your existing data directory. See the [systemd init
file section](#systemd-init-file) for more details.

Known issues
============

Wallet GUI
----------

For advanced users who have both (1) enabled coin control features, and
(2) are using multiple wallets loaded at the same time: The coin control
input selection dialog can erroneously retain wrong-wallet state when
switching wallets using the dropdown menu. For now, it is recommended
not to use coin control features with multiple wallets loaded.

Notable changes
===============

Policy
------

- Previously, transactions sending to future Bech32 address versions
  would be rejected, which could lead to stuck transactions, locking
  up change. This has been relaxed by default to mitigate the issue.
  For 0.18.0, the `-sendtofuture=0` option (also available in the
  GUI Mempool Settings tab) can restore the old policy, but this is
  discouraged, and will be removed in the future.

Mining
------

- Calls to `getblocktemplate` will fail if the segwit rule is not
  specified.  Calling `getblocktemplate` without segwit specified is
  almost certainly a misconfiguration since doing so results in lower
  rewards for the miner.  Failed calls will produce an error message
  describing how to enable the segwit rule.

- By default, blocks mined with Bitcoin Knots will be limited to 300k
  in size, or 1.5 MWU in weight. Note these defaults are just healthy
  recommendations, and can be overridden with the `-blockmaxsize` and
  `-blockmaxweight` options.

Configuration option changes
----------------------------

- A warning is printed if an unrecognized section name is used in the
  configuration file.  Recognized sections are `[test]`, `[main]`, and
  `[regtest]`.

- The `rpcallowip` option can no longer be used to automatically listen
  on all network interfaces.  Instead, the `rpcbind` parameter must be
  used to specify the IP addresses to listen on.  Listening for RPC
  commands over a public network connection is insecure and should be
  disabled, so a warning is now printed if a user selects such a
  configuration.  If you need to expose RPC in order to use a tool like
  Docker, ensure you only bind RPC to your localhost, e.g. `docker run
  [...] -p 127.0.0.1:8332:8332` (this is an extra `:8332` over the
  normal Docker port specification).

- The `rpcpassword` option now causes a startup error if the password
  set in the configuration file contains a hash character (#), as it's
  ambiguous whether the hash character is meant for the password or as a
  comment.

- The `whitelistforcerelay` option is used to relay transactions from
  whitelisted peers even when not accepted to the mempool. This option
  now defaults to being off, so that changes in policy and
  disconnect/ban behavior will not cause a node that is whitelisting
  another to be dropped by peers.  Users can still explicitly enable
  this behavior with the command line option (and may want to consider
  [contacting](https://bitcoincore.org/en/contact/) the Bitcoin Core
  project to let us know about their use-case, as this feature could be
  deprecated in the future).

- The `startupnotify` option is used to specify a command to execute when
  Bitcoin Knots has finished with its startup sequence.

systemd init file
-----------------

The systemd init file (`contrib/init/bitcoind.service`) has been changed
to use `/var/lib/bitcoind` as the data directory instead of
`~bitcoin/.bitcoin`. This change makes Bitcoin Knots more consistent with
other services, and makes the systemd init config more consistent with
existing Upstart and OpenRC configs.

The configuration, PID, and data directories are now completely managed
by systemd, which will take care of their creation, permissions, etc.
See [`systemd.exec(5)`]
(https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RuntimeDirectory=)
for more details.

When using the provided init files under `contrib/init`, overriding the
`datadir` option in `/etc/bitcoin/bitcoin.conf` will have no effect.
This is because the command line arguments specified in the init files
take precedence over the options specified in
`/etc/bitcoin/bitcoin.conf`.


Documentation
-------------

- A new short [document]
(https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)
  about the JSON-RPC interface describes cases where the results of an
  RPC might contain inconsistencies between data sourced from different
  subsystems, such as wallet state and mempool state.  A note is added
  to the [REST interface documentation]
(https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md)
  indicating that the same rules apply.

- Further information is added to the [JSON-RPC
  documentation]
(https://github.com/bitcoin/bitcoin/blob/master/doc/JSON-RPC-interface.md)
  about how to secure this interface.

- A new [document]
(https://github.com/bitcoin/bitcoin/blob/master/doc/bitcoin-conf.md)
  about the `bitcoin.conf` file describes how to use it to configure
  Bitcoin Knots.

- A new document introduces Bitcoin Knots's BIP174 [Partially-Signed
  Bitcoin Transactions
  (PSBT)](https://github.com/bitcoin/bitcoin/blob/master/doc/psbt.md)
  interface, which is used to allow multiple programs to collaboratively
  work to create, sign, and broadcast new transactions.  This is useful
  for offline (cold storage) wallets, multisig wallets, coinjoin
  implementations, and many other cases where two or more programs need
  to interact to generate a complete transaction.

- The [output script
  descriptor]
(https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md)
  documentation has been updated with information about new features in
  this still-developing language for describing the output scripts that
  a wallet or other program wants to receive notifications for, such as
  which addresses it wants to know received payments.  The language is
  currently used in multiple new and updated RPCs described in these
  release notes and is expected to be adapted to other RPCs and to the
  underlying wallet structure.

Build system changes
--------------------

- The minimum required version of Qt (when building the GUI) has been
  increased from 5.2 to 5.5.1 (the [depends
  system](https://github.com/bitcoin/bitcoin/blob/master/depends/README.md)
  provides 5.9.7)

New RPCs
--------

- `listwalletdir` returns a list of wallets in the wallet directory
  (either the default wallet directory or the directory configured by
  the `-walletdir` parameter).

- `getrpcinfo` returns runtime details of the RPC server. At the moment,
  it returns an array of the currently active commands and how long
  they've been running.

- `deriveaddresses` returns one or more addresses corresponding to an
  [output descriptor]
(https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).

- `getdescriptorinfo` accepts a descriptor and returns information about
  it, including its computed checksum.

- `joinpsbts` merges multiple distinct PSBTs into a single PSBT. The
  multiple PSBTs must have different inputs. The resulting PSBT will
  contain every input and output from all of the PSBTs. Any signatures
  provided in any of the PSBTs will be dropped.

- `analyzepsbt` examines a PSBT and provides information about what
  the PSBT contains and the next steps that need to be taken in order
  to complete the transaction. For each input of a PSBT, `analyzepsbt`
  provides information about what information is missing for that
  input, including whether a UTXO needs to be provided, what pubkeys
  still need to be provided, which scripts need to be provided, and
  what signatures are still needed. Every input will also list which
  role is needed to complete that input, and `analyzepsbt` will also
  list the next role in general needed to complete the PSBT.
  `analyzepsbt` will also provide the estimated fee rate and estimated
  virtual size of the completed transaction if it has enough
  information to do so.

- `utxoupdatepsbt` searches the set of Unspent Transaction Outputs
  (UTXOs) to find the outputs being spent by the partial transaction.
  PSBTs need to have the UTXOs being spent to be provided because
  the signing algorithm requires information from the UTXO being spent.
  For segwit inputs, only the UTXO itself is necessary.  For
  non-segwit outputs, the entire previous transaction is needed so
  that signers can be sure that they are signing the correct thing.
  Unfortunately, because the UTXO set only contains UTXOs and not full
  transactions, `utxoupdatepsbt` will only add the UTXO for segwit
  inputs.

Updated RPCs
------------

Note: some low-level RPC changes mainly useful for testing are described
in the Low-level Changes section below.

- The mempool RPCs, such as `getrawmempool` with `verbose=true`, now
  return an additional "bip125-replaceable" value indicating whether the
  transaction (or its unconfirmed ancestors) opts-in to asking nodes and
  miners to replace it with a higher-feerate transaction spending any of
  the same inputs.

- `settxfee` previously silently ignored attempts to set the fee below
  the allowed minimums.  It now prints a warning.  The special value of
  "0" may still be used to request the minimum value.

- `importmulti` has been updated to support P2WSH, P2WPKH, P2SH-P2WPKH,
  and P2SH-P2WSH. Requests for P2WSH and P2SH-P2WSH accept an additional
  `witnessscript` parameter.

- `importmulti` now returns an additional `warnings` field for each
  request with an array of strings explaining when fields are being
  ignored or are inconsistent, if there are any.

- `getaddressinfo` now returns an additional `solvable` boolean field
  when Bitcoin Knots knows enough about the address's scriptPubKey,
  optional redeemScript, and optional witnessScript in order for the
  wallet to be able to generate an unsigned input spending funds sent to
  that address.

- The `getaddressinfo`, `listunspent`, and `scantxoutset` RPCs now
  return an additional `desc` field that contains an output descriptor
  containing all key paths and signing information for the address
  (except for the private key).  The `desc` field is only returned for
  `getaddressinfo` and `listunspent` when the address is solvable.

- `importprivkey` will preserve previously-set labels for addresses or
  public keys corresponding to the private key being imported.  For
  example, if you imported a watch-only address with the label "cold
  wallet" in earlier releases of Bitcoin Knots, subsequently importing
  the private key would default to resetting the address's label to the
  default empty-string label ("").  In this release, the previous label
  of "cold wallet" will be retained.  If you optionally specify any
  label besides the default when calling `importprivkey`, the new label
  will be applied to the address.

- See the [Mining](#mining) section for changes to `getblocktemplate`.

- `getmininginfo` now omits `currentblocksize`, `currentblockweight` and
  `currentblocktx` when a block was never assembled via RPC on this node.
  `currentblocksize` is also omitted if the `-blockmaxsize` option is
  set to 4 MB or larger (and therefore ineffective).

- The `getrawtransaction` RPC & REST endpoints no longer check the
  unspent UTXO set for a transaction. The remaining behaviors are as
  follows: 1. If a blockhash is provided, check the corresponding block.
  2. If no blockhash is provided, check the mempool. 3. If no blockhash
  is provided but txindex is enabled, also check txindex.

- `unloadwallet` is now synchronous, meaning it will not return until
  the wallet is fully unloaded.

- `importmulti` now supports importing of addresses from descriptors. A
  "desc" parameter can be provided instead of the "scriptPubKey" in a
  request, as well as an optional range for ranged descriptors to
  specify the start and end of the range to import. Descriptors with key
  origin information imported through `importmulti` will have their key
  origin information stored in the wallet for use with creating PSBTs.
  More information about descriptors can be found
  [here](https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md).

- `listunspent` has been modified so that it also returns
  `witnessScript`, the witness script in the case of a P2WSH or
  P2SH-P2WSH output.

- `createwallet` now has an optional `blank` argument that can be used
  to create a blank wallet. Blank wallets do not have any keys or HD
  seed.  They cannot be opened in software older than 0.18. Once a blank
  wallet has a HD seed set (by using `sethdseed`) or private keys,
  scripts, addresses, and other watch only things have been imported,
  the wallet is no longer blank and can be opened in 0.17.x. Encrypting
  a blank wallet will also set a HD seed for it.

- `walletcreatefundedpsbt` now respects the `-walletrbf` option for its
  default BIP125 RBF parameter.

- `testmempoolaccept` and `sendrawtransaction` now accept a new `maxfeerate`
  parameter to help avoid accidentally exceeding a given fee rate.

- `getmempoolinfo` now has a `loaded` key in the result to indicate
  completed loading of the saved mempool cache (or that it was skipped or
  absent).

- `getmempoolinfo` now accepts an optional parameter to get a fee histogram
  in the result.

- `getwalletinfo` includes a `scanning` key in its result, which will be
  either `false` (to indicate no scanning in progress), or progress
  information.

Deprecated or removed RPCs
--------------------------

- `signrawtransaction` is removed after being deprecated and hidden
  behind a special configuration option in version 0.17.0.

- The 'account' API is removed after being deprecated in v0.17.  The
  'label' API was introduced in v0.17 as a replacement for accounts.
  See the [release notes from
  v0.17]
(https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.17.0.md#label-and-account-apis-for-wallet)
  for a full description of the changes from the 'account' API to the
  'label' API.

- `addwitnessaddress` is removed after being deprecated in version
  0.16.0.

- `generate` is deprecated and will be fully removed in a subsequent
  major version.  This RPC is only used for testing, but its
  implementation reached across multiple subsystems (wallet and mining),
  so it is being deprecated to simplify the wallet-node interface.
  Projects that are using `generate` for testing purposes should
  transition to using the `generatetoaddress` RPC, which does not
  require or use the wallet component. Calling `generatetoaddress` with
  an address returned by the `getnewaddress` RPC gives the same
  functionality as the old `generate` RPC.  To continue using `generate`
  in this version, restart bitcoind with the `-deprecatedrpc=generate`
  configuration option.

- Be reminded that parts of the `validateaddress` command have been
  deprecated and moved to `getaddressinfo`. The following deprecated
  fields have moved to `getaddressinfo`: `ismine`, `iswatchonly`,
  `script`, `hex`, `pubkeys`, `sigsrequired`, `pubkey`, `embedded`,
  `iscompressed`, `label`, `timestamp`, `hdkeypath`, `hdmasterkeyid`.

- The `addresses` field has been removed from the `validateaddress`
  and `getaddressinfo` RPC methods.  This field was confusing since
  it referred to public keys using their P2PKH address.  Clients
  should use the `embedded.address` field for P2SH or P2WSH wrapped
  addresses, and `pubkeys` for inspecting multisig participants.

- Due to apparent lack of interest, the `verifyscript` method has been
  removed.

REST changes
------------

- A new `/rest/blockhashbyheight/` endpoint is added for fetching the
  hash of the block in the current best blockchain based on its height
  (how many blocks it is after the Genesis Block). This replaces the
  older `/rest/blockhash/` endpoint which did the same thing, and is
  now deprecated. Note that the new API uses a HTTP 404 Not Found
  response for heights beyond the current chain length, has inverted
  the order of bytes for hex format, and uses a "blockhash" key for
  JSON format.

- The `/rest/mempool/info.json` endpoint now has a `loaded` key in the
  result to indicate completed loading of the saved mempool cache (or that
  it was skipped or absent).

- A new REST `/rest/mempool/info/with_fee_histogram` endpoint parallels
  `/rest/mempool/info`, but adds a fee histogram to the result.

Graphical User Interface (GUI)
------------------------------

- In the Send tab, the checkbox for "pay only the required fee" has been
  removed.  Instead, the user can simply decrease the value in the
  Custom Feerate field all the way down to the node's configured minimum
  relay fee.

- The special send-to-self transaction record type has been removed.
  Instead, all such transactions (including old transactions) will now
  be displayed as a pair of send and receive (or possibly multiple
  receives, in some circumstances).

- A new experimental Pairing tab has been added to assist in linking
  other wallet software (for example, such as you might have on your
  phone) with your node. Note that it is likely the pairing address
  displayed will change in future versions, possibly requiring
  re-pairing.

- In the Overview tab, the watch-only balance will be the only balance
  shown if the wallet was created using the `createwallet` RPC and the
  `disable_private_keys` parameter was set to true.

- The launch-on-startup option is no longer available on macOS if
  compiled with macosx min version greater than 10.11 (use
  CXXFLAGS="-mmacosx-version-min=10.11"
  CFLAGS="-mmacosx-version-min=10.11" for setting the deployment sdk
  version)

- Tonal Bitcoin support is now stricter with font detection. If you
  use Tonal Bitcoin and no longer have TBC unit options visible, try
  another font and/or open an issue on GitHub.

Tools
-----

- A new `bitcoin-wallet` tool is now distributed alongside Bitcoin
  Knots's other executables.  Without needing to use any RPCs, this tool
  can currently create a new wallet file or display some basic
  information about an existing wallet, such as whether the wallet is
  encrypted, whether it uses an HD seed, how many transactions it
  contains, and how many address book entries it has.

- Due to apparent lack of interest, support for Script debugging has been
  removed from libbitcoinconsensus.

Planned changes
===============

This section describes planned changes to Bitcoin Knots that may affect
other Bitcoin software and services.

Deprecated P2P messages
-----------------------

- BIP 61 reject messages are now deprecated. Reject messages have no use
  case on the P2P network and are only logged for debugging by most
  network nodes. Furthermore, they increase bandwidth and can be harmful
  for privacy and security. It has been possible to disable BIP 61
  messages since v0.17 with the `-enablebip61=0` option. BIP 61 messages
  will be disabled by default in a future version, before being removed
  entirely.

Low-level changes
=================

This section describes RPC changes mainly useful for testing, mostly not
relevant in production. The changes are mentioned for completeness.

RPC
---

- The `submitblock` RPC previously returned the reason a rejected block
  was invalid the first time it processed that block, but returned a
  generic "duplicate" rejection message on subsequent occasions it
  processed the same block.  It now always returns the fundamental
  reason for rejecting an invalid block and only returns "duplicate" for
  valid blocks it has already accepted.

- A new `submitheader` RPC allows submitting block headers independently
  from their block.  This is likely only useful for testing.

- The `signrawtransactionwithkey` and `signrawtransactionwithwallet`
  RPCs have been modified so that they also optionally accept a
  `witnessScript`, the witness script in the case of a P2WSH or
  P2SH-P2WSH output. This is compatible with the change to
  `listunspent`.

- For the `walletprocesspsbt` and `walletcreatefundedpsbt` RPCs, if the
  `bip32derivs` parameter is set to true but the key metadata for a
  public key has not been updated yet, then that key will have a
  derivation path as if it were just an independent key (i.e. no
  derivation path and its master fingerprint is itself).

Configuration
-------------

- The `-usehd` configuration option was removed in version 0.16. From
  that version onwards, all new wallets created are hierarchical
  deterministic wallets. This release makes specifying `-usehd` an
  invalid configuration option.

Network
-------

- This release allows peers that your node automatically disconnected
  for misbehavior (e.g. sending invalid data) to reconnect to your node
  if you have unused incoming connection slots.  If your slots fill up,
  a misbehaving node will be disconnected to make room for nodes without
  a history of problems (unless the misbehaving node helps your node in
  some other way, such as by connecting to a part of the Internet from
  which you don't have many other peers).  Previously, Bitcoin Knots
  banned the IP addresses of misbehaving peers for a period of time
  (default of 1 day); this was easily circumvented by attackers with
  multiple IP addresses. If you manually ban a peer, such as by using
  the `setban` RPC, all connections from that peer will still be
  rejected.

Wallet
-------

- The key metadata will need to be upgraded the first time that the HD
  seed is available.  For unencrypted wallets this will occur on wallet
  loading.  For encrypted wallets this will occur the first time the
  wallet is unlocked.

- Newly encrypted wallets will no longer require restarting the
  software. Instead such wallets will be completely unloaded and
  reloaded to achieve the same effect.

- A sub-project of Bitcoin Core now provides Hardware Wallet Interaction
  (HWI) scripts that allow command-line users to use several popular
  hardware key management devices with Bitcoin Knots.  See their [project
  page](https://github.com/bitcoin-core/HWI#readme) for details.

Security
--------

- This release changes the Random Number Generator (RNG) used from
  OpenSSL to Bitcoin Core's implementation, although entropy gathered
  by Bitcoin Knots is fed out to OpenSSL and then read back in when the
  program needs strong randomness. This moves Bitcoin Knots a little
  closer to no longer needing to depend on OpenSSL, a dependency that
  has caused security issues in the past.  The new implementation
  gathers entropy from multiple sources, including from hardware
  supporting the rdseed CPU instruction.

0.18.0 change log
=================

### Consensus
- n/a *Update checkpoints and chain params, adding a new checkpoint at block 
571,392 (luke-jr)

### Policy
- #15846 *Policy-accept sending to future native witness outputs 
with -sendtofuture=1 (luke-jr)
- #15846 *Policy: Enable -sendtofuture=1 by default (except with -corepolicy) 
(luke-jr)
- n/a *Reduce default block size/weight to a safer 300kB/1.5MWU (luke-jr)

### Mining
- #14811 Mining: Enforce that segwit option must be set in GBT (jnewbery)

### Block and transaction handling
- #13310 Report progress in ReplayBlocks while rolling forward (promag)
- #13783 validation: Pass tx pool reference into CheckSequenceLocks 
(MarcoFalke)
- #14834 validation: Assert that pindexPrev is non-null when required 
(kallewoof)
- #14085 index: Fix for indexers skipping genesis block (jimpo)
- #14963 mempool, validation: Explain `cs_main` locking semantics (MarcoFalke)
- #15193 Default `-whitelistforcerelay` to off (sdaftuar)
- #15552 Granular invalidateblock and RewindBlockIndex (MarcoFalke)
- #14841 Move CheckBlock() call to critical section (hebasto)
- #15218 *validation: flush state after initial sync (andrewtoth)

### P2P protocol and network code
- #14025 Remove dead code for nVersion=10300 (MarcoFalke)
- #12254 BIP 158: Compact Block Filters for Light Clients (jimpo)
- #14073 blockfilter: Avoid out-of-bounds script access (jimpo)
- #14140 Switch nPrevNodeCount to vNodesSize (pstratem)
- #14027 Skip stale tip checking if outbound connections are off or if 
reindexing (gmaxwell)
- #14532 Never bind `INADDR_ANY` by default, and warn when doing so explicitly 
(luke-jr)
- #14733 Make peer timeout configurable, speed up very slow test and ensure 
correct code path tested (zallarak)
- #14336 Implement poll (pstratem)
- #15051 IsReachable is the inverse of IsLimited (DRY). Includes unit tests 
(mmachicao)
- #15138 Drop IsLimited in favor of IsReachable (Empact)
- #14605 Return of the Banman (dongcarl)
- #14929 Allow connections from misbehavior banned peers (gmaxwell)
- #15345 Correct comparison of addr count (dongcarl)
- #15201 Add missing locking annotation for vNodes. vNodes is guarded by 
cs_vNodes (practicalswift)
- #14626 Select orphan transaction uniformly for eviction (sipa)
- #15486 Ensure tried collisions resolve, and allow feeler connections to 
existing outbound netgroups (sdaftuar)
- #15558 *Do not query all DNS seed at once (sipa)
- #15651 *torcontrol: Use the default/standard network port for Tor hidden 
services, even if the internal port is set differently (luke-jr)
- #15423 *torcontrol: Query Tor for correct -onion configuration (luke-jr)
- #15633 *Ignore BIP-152 HB requests from non-witness peers. (gmaxwell)

### Wallet
- #13962 Remove unused `dummy_tx` variable from FillPSBT (dongcarl)
- #13967 Don't report `minversion` wallet entry as unknown (instagibbs)
- #13988 Add checks for settxfee reasonableness (ajtowns)
- #12559 Avoid locking `cs_main` in some wallet RPC (promag)
- #13631 Add CMerkleTx::IsImmatureCoinBase method (Empact)
- #14023 Remove accounts RPCs (jnewbery)
- #13825 Kill accounts (jnewbery)
- #10605 Add AssertLockHeld assertions in CWallet::ListCoins (ryanofsky)
- #12490 Remove deprecated wallet rpc features from `bitcoin_server` 
(jnewbery)
- #14138 Set `encrypted_batch` to nullptr after delete. Avoid double free in 
the case of NDEBUG (practicalswift)
- #14168 Remove `ENABLE_WALLET` from `libbitcoin_server.a` (jnewbery)
- #12493 Reopen CDBEnv after encryption instead of shutting down (achow101)
- #14282 Remove `-usehd` option (jnewbery)
- #14146 Remove trailing separators from `-walletdir` arg (PierreRochard)
- #14291 Add ListWalletDir utility function (promag)
- #14468 Deprecate `generate` RPC method (jnewbery)
- #11634 Add missing `cs_wallet`/`cs_KeyStore` locks to wallet 
(practicalswift)
- #14296 Remove `addwitnessaddress` (jnewbery)
- #14451 Add BIP70 deprecation warning (jameshilliard)
- #14320 Fix duplicate fileid detection (ken2812221)
- #14561 Remove `fs::relative` call and fix listwalletdir tests (promag)
- #14454 Add SegWit support to importmulti (MeshCollider)
- #14350 Add WalletLocation class (promag)
- #14689 Require a public key to be retrieved when signing a P2PKH input 
(achow101)
- #14478 Show error to user when corrupt wallet unlock fails (MeshCollider)
- #14552 Detect duplicate wallet by comparing the db filename (ken2812221)
- #14678 Remove redundant KeyOriginInfo access, already done in CreateSig 
(instagibbs)
- #14477 Add ability to convert solvability info to descriptor (sipa)
- #14760 Log env path in `BerkeleyEnvironment::Flush` (promag)
- #14646 Add expansion cache functions to descriptors (unused for now) (sipa)
- #13076 Fix ScanForWalletTransactions to return an enum indicating scan 
result: `success` / `failure` / `user_abort` (Empact)
- #14821 Replace CAffectedKeysVisitor with descriptor based logic (sipa)
- #14957 Initialize `stop_block` in CWallet::ScanForWalletTransactions 
(Empact)
- #14565 Overhaul `importmulti` logic (sipa)
- #15039 Avoid leaking nLockTime fingerprint when anti-fee-sniping 
(MarcoFalke)
- #14268 Introduce SafeDbt to handle Dbt with free or `memory_cleanse` 
raii-style (Empact)
- #14711 Remove uses of chainActive and mapBlockIndex in wallet code 
(ryanofsky)
- #15279 Clarify rescanblockchain doc (MarcoFalke)
- #15292 Remove `boost::optional`-related false positive -Wmaybe-uninitialized 
warnings on GCC compiler (hebasto)
- #13926 [Tools] bitcoin-wallet - a tool for creating and managing wallets 
offline (jnewbery)
- #11911 Free BerkeleyEnvironment instances when not in use (ryanofsky)
- #15235 Do not import private keys to wallets with private keys disabled 
(achow101)
- #15263 Descriptor expansions only need pubkey entries for PKH/WPKH (sipa)
- #15322 Add missing `cs_db` lock (promag)
- #15297 Releases dangling files on `BerkeleyEnvironment::Close` (promag)
- #14491 Allow descriptor imports with importmulti (MeshCollider)
- #15365 Add lock annotation for mapAddressBook (MarcoFalke)
- #15226 Allow creating blank (empty) wallets (alternative) (achow101)
- #15390 [wallet-tool] Close bdb when flushing wallet (jnewbery)
- #15334 Log absolute paths for the wallets (hebasto)
- #14978 Factor out PSBT utilities from RPCs for use in GUI code; related 
refactoring (gwillen)
- #14481 Add P2SH-P2WSH support to listunspent RPC (MeshCollider)
- #14021 Import key origin data through descriptors in importmulti (achow101)
- #14075 Import watch only pubkeys to the keypool if private keys are disabled 
(achow101)
- #15368 Descriptor checksums (sipa)
- #15433 Use a single wallet batch for `UpgradeKeyMetadata` (jonasschnelli)
- #15408 Remove unused `TransactionError` constants (MarcoFalke)
- #15583 Log and ignore errors in ListWalletDir and IsBerkeleyBtree (promag)
- #14195 Pass privkey export DER compression flag correctly (fingera)
- #15299 Fix assertion in `CKey::SignCompact` (promag)
- #14437 Start to separate wallet from node (ryanofsky)
- #15749 Fix: importmulti only imports origin info for PKH outputs (sipa)
- #15913 *Bugfix: dummywallet: Add -ignorepartialspends to list of ignored 
wallet options (luke-jr)
- #15911 *[rpc] walletcreatefundedpsbt: use wallet default RBF (Sjors)
- #9152 *RPC/Wallet: Use BroadcastTransaction for sweepprivkeys to ensure 
wallet is synced before we return (luke-jr)
- #13541 *wallet/rpc: add maxfeerate parameter to testmempoolaccept and 
sendrawtransaction (kallewoof)

### RPC and other APIs
- #12842 Prevent concurrent `savemempool` (promag)
- #13891 Remove getinfo deprecation warning (jnewbery)
- #13399 Add `submitheader` (MarcoFalke)
- #13723 PSBT key path cleanups (sipa)
- #14008 Preserve a format of RPC command definitions (kostyantyn)
- #13983 Return more specific reject reason for submitblock (MarcoFalke)
- #14298 rest: Improve performance for JSON calls (alecalve)
- #14297 Remove warning for removed estimatefee RPC (jnewbery)
- #14373 Consistency fixes for RPC descriptions (ch4ot1c)
- #14150 Add key origin support to descriptors (sipa)
- #14518 Always throw in getblockstats if `-txindex` is required (promag)
- #13381 Add possibility to preserve labels on importprivkey (marcoagner)
- #14530 Use `RPCHelpMan` to generate RPC doc strings (MarcoFalke)
- #14720 Correctly name RPC arguments (MarcoFalke)
- #14726 Use `RPCHelpMan` for all RPCs (MarcoFalke)
- #14796 Pass argument descriptions to `RPCHelpMan` (MarcoFalke)
- #14670 http: Fix HTTP server shutdown (promag)
- #14885 Assert that named arguments are unique in `RPCHelpMan` (promag)
- #14877 Document default values for optional arguments (MarcoFalke)
- #14875 RPCHelpMan: Support required arguments after optional ones 
(MarcoFalke)
- #14993 Fix data race (UB) in InterruptRPC() (practicalswift)
- #14653 rpcwallet: Add missing transaction categories to RPC helptexts 
(andrewtoth)
- #14981 Clarify RPC `getrawtransaction`'s time help text (benthecarman)
- #12151 Remove `cs_main` lock from blockToJSON and blockheaderToJSON (promag)
- #15078 Document `bytessent_per_msg` and `bytesrecv_per_msg` (MarcoFalke)
- #15057 Correct `reconsiderblock `help text, add test (MarcoFalke)
- #12153 Avoid permanent `cs_main` lock in `getblockheader` (promag)
- #14982 Add `getrpcinfo` command (promag)
- #15122 Expand help text for `importmulti` changes (jnewbery)
- #15186 remove duplicate solvable field from `getaddressinfo` (fanquake)
- #15209 zmq: log outbound message high water mark when reusing socket 
(fanquake)
- #15177 rest: Improve tests and documention of /headers and /block (promag)
- #14353 rest: Add blockhash call, fetch blockhash by height (jonasschnelli)
- #15248 Compile on GCC4.8 (MarcoFalke)
- #14987 RPCHelpMan: Pass through Result and Examples (MarcoFalke)
- #15159 Remove lookup to UTXO set from GetTransaction (amitiuttarwar)
- #15245 remove deprecated mentions of signrawtransaction from fundraw help 
(instagibbs)
- #14667 Add `deriveaddresses` RPC util method (Sjors)
- #15357 Don't ignore `-maxtxfee` when wallet is disabled (JBaczuk)
- #15337 Fix for segfault if combinepsbt called with empty inputs 
(benthecarman)
- #14918 RPCHelpMan: Check default values are given at compile-time 
(MarcoFalke)
- #15383 mining: Omit uninitialized currentblockweight, currentblocktx 
(MarcoFalke)
- #13932 Additional utility RPCs for PSBT (achow101)
- #15401 Actually throw help when passed invalid number of params (MarcoFalke)
- #15497 Consistent range arguments in 
scantxoutset/importmulti/deriveaddresses (sipa)
- #15510 deriveaddresses: add range to CRPCConvertParam (Sjors)
- #15582 Fix overflow bug in analyzepsbt fee: CAmount instead of int (sipa)
- #13424 Consistently validate txid / blockhash length and encoding in rpc 
calls (Empact)
- #15750 Remove the addresses field from the getaddressinfo return object 
(jnewbery)
- n/a *Bugfix: httpserver: Close listen socket if we fail to make an evhttp 
handle (luke-jr)
- #15323 *rpc: Expose g_is_mempool_loaded via getmempoolinfo 
and /rest/mempool/info.json (Empact)
- #15730 *rpc: Show scanning details in getwalletinfo (promag)
- #15836 *Add feerate histogram to getmempoolinfo (jonasschnelli)
- #15861 *rpc/gui: Refactor 'Unknown block versions being mined' warning 
(luke-jr)
- n/a *Removed verifyscript method (luke-jr)
- n/a *Removed libbitcoinconsensus Script debugging support (luke-jr)
- #15932 *rpc: Serialize in getblock without cs_main (MarcoFalke)

### GUI
- #13634 Compile `boost::signals2` only once (MarcoFalke)
- #13248 Make proxy icon from statusbar clickable (mess110)
- #13529 Use new Qt5 connect syntax (promag)
- #14162 Also log and print messages or questions like bitcoind (MarcoFalke)
- #14385 Avoid system harfbuzz and bz2 (theuni)
- #14450 Fix QCompleter popup regression (hebasto)
- #14177 Set C locale for amountWidget (hebasto)
- #14374 Add `Blocksdir` to Debug window (hebasto)
- #14554 Remove unused `adjustedTime` parameter (hebasto)
- #14608 Remove the "Pay only required fee?" checkbox (hebasto)
- #14521 qt, docs: Fix `bitcoin-qt -version` output formatting (hebasto)
- #13966 When private key is disabled, only show watch-only balance 
(ken2812221)
- #14828 Remove hidden columns in coin control dialog (promag)
- #14783 Fix `boost::signals2::no_slots_error` in early calls to InitWarning 
(promag)
- #14854 Cleanup SplashScreen class (hebasto)
- #14801 Use window() instead of obsolete topLevelWidget() (hebasto)
- #14975 Refactoring with QString::toNSString() (hebasto)
- #15000 Fix broken notificator on GNOME (hebasto)
- #14375 Correct misleading "overridden options" label (hebasto)
- #15007 Notificator class refactoring (hebasto)
- #14784 Use `WalletModel*` instead of the wallet name as map key (promag)
- #11625 Add BitcoinApplication & RPCConsole tests (ryanofsky)
- #13216 implements concept for different disk sizes on intro (marcoagner)
- #15114 Replace remaining 0 with nullptr (Empact)
- #14594 Fix minimized window bug on Linux (hebasto)
- #14556 Fix confirmed transaction labeled "open" (#13299) (hebasto)
- #15149 Show current wallet name in window title (promag)
- #15136 "Peers" tab overhaul (hebasto)
- #14250 Remove redundant stopThread() and stopExecutor() signals (hebasto)
- #15040 Add workaround for QProgressDialog bug on macOS (hebasto)
- #15101 Add WalletController (promag)
- #15178 Improve "help-console" message (hebasto)
- #15210 Fix window title update (promag)
- #15167 Fix wallet selector size adjustment (hebasto)
- #15208 Remove macOS launch-at-startup when compiled with > macOS 10.11, fix 
memory mismanagement (jonasschnelli)
- #15163 Correct units for "-dbcache" and "-prune" (hebasto)
- #15225 Change the receive button to respond to keypool state changing 
(achow101)
- #15280 Fix shutdown order (promag)
- #15203 Fix issue #9683 "gui, wallet: random abort (segmentation fault) 
(dooglus)
- #15091 Fix model overlay header sync (jonasschnelli)
- #15153 Add Open Wallet menu (promag)
- #15183 Fix `m_assumed_blockchain_size` variable value (marcoagner)
- #15063 If BIP70 is disabled, attempt to fall back to BIP21 parsing (luke-jr)
- #15195 Add Close Wallet action (promag)
- #15462 Fix async open wallet call order (promag)
- #15801 Bugfix: GUI: Options: Initialise prune setting range before loading 
current value, and remove upper bound limit (luke-jr)
- #11750 *CoinControl: Remove selection-only counter (luke-jr)
- #15115 *Replace send-to-self with dual send+receive entries (luke-jr)
- #15371 *Uppercase bech32 addresses in qr codes (benthecarman)
- #15428 *Add Pairing tab with Tor onion address as copyable text and QR code 
(luke-jr)
- #7510 *Various improvements for pruning controls (luke-jr)
- #929 *Bugfix: GUI: bitcoinunits: Don't make unitlist static, since it gets 
rebuilt every call (luke-jr)
- #929 *tonalutils: For Tonal support detection, check that the font has all 
glyphs and they all have the same sizes (luke-jr)
- n/a *update receiving address book description to refer to receive tab for 
new addresses (HatboyWonder)
- n/a *Qt/Options: Configure sendtofuture using rwconf (luke-jr)

### Build system
- #13955 gitian: Bump descriptors for (0.)18 (fanquake)
- #13899 Enable -Wredundant-decls where available. Remove redundant 
redeclarations (practicalswift)
- #13665 Add RISC-V support to gitian (ken2812221)
- #14062 Generate MSVC project files via python script (ken2812221)
- #14037 Add README.md to linux release tarballs (hebasto)
- #14183 Remove unused Qt 4 dependencies (ken2812221)
- #14127 Avoid getifaddrs when unavailable (greenaddress)
- #14184 Scripts and tools: increased timeout downloading (cisba)
- #14204 Move `interfaces/*` to `libbitcoin_server` (laanwj)
- #14208 Actually remove `ENABLE_WALLET` (jnewbery)
- #14212 Remove libssl from LDADD unless GUI (MarcoFalke)
- #13578 Upgrade zeromq to 4.2.5 and avoid deprecated zeromq API functions 
(mruddy)
- #14281 lcov: filter /usr/lib/ from coverage reports (MarcoFalke)
- #14325 gitian: Use versioned unsigned tarballs instead of generically named 
ones (achow101)
- #14253 During 'make clean', remove some files that are currently missed 
(murrayn)
- #14455 Unbreak `make clean` (jamesob)
- #14495 Warn (don't fail!) on spelling errors (practicalswift)
- #14496 Pin to specific versions of Python packages we install from PyPI in 
Travis (practicalswift)
- #14568 Fix Qt link order for Windows build (ken2812221)
- #14252 Run functional tests and benchmarks under the undefined behaviour 
sanitizer (UBSan) (practicalswift)
- #14612 Include full version number in released file names (achow101)
- #14840 Remove duplicate libconsensus linking in test make (AmirAbrams)
- #14883 Add `--retry 5` to curl opts in `install_db4.sh` (qubenix)
- #14701 Add `CLIENT_VERSION_BUILD` to CFBundleGetInfoString (fanquake)
- #14849 Qt 5.9.7 (fanquake)
- #15020 Add names to Travis jobs (gkrizek)
- #15047 Allow to configure --with-sanitizers=fuzzer (MarcoFalke)
- #15154 Configure: bitcoin-tx doesn't need libevent, so don't pull it in 
(luke-jr)
- #15175 Drop macports support (Empact)
- #15308 Restore compatibility with older boost (Empact)
- #15407 msvc: Fix silent merge conflict between #13926 and #14372 part II 
(ken2812221)
- #15388 Makefile.am: add rule for src/bitcoin-wallet (Sjors)
- #15393 Bump minimum Qt version to 5.5.1 (Sjors)
- #15285 Prefer Python 3.4 even if newer versions are present on the system 
(Sjors)
- #15398 msvc: Add rapidcheck property tests (ken2812221)
- #15431 msvc: scripted-diff: Remove NDEBUG pre-define in project file 
(ken2812221)
- #15549 gitian: Improve error handling (laanwj)
- #15548 use full version string in setup.exe (MarcoFalke)
- #11526 Visual Studio build configuration for Bitcoin Core (sipsorcery)
- #15110 build\_msvc: Fix the build problem in `libbitcoin_server` (Mr-Leshiy)
- #14372 msvc: build secp256k1 and leveldb locally (ken2812221)
- #15325 msvc: Fix silent merge conflict between #13926 and #14372 
(ken2812221)
- #15391 Add compile time verification of assumptions we're currently making 
implicitly/tacitly (practicalswift)
- #15503 msvc: Use a single file to specify the include path (ken2812221)
- #13765 contrib: Add gitian build support for github pull request 
(ken2812221)
- #15809 gitignore: plist and dat (jamesob)

### Tests and QA
- #15405 appveyor: Clean cache when build configuration changes (Sjors)
- #13953 Fix deprecation in bitcoin-util-test.py (isghe)
- #13963 Replace usage of tostring() with tobytes() (dongcarl)
- #13964 ci: Add appveyor ci (ken2812221)
- #13997 appveyor: fetch the latest port data (ken2812221)
- #13707 Add usage note to check-rpc-mappings.py (masonicboom)
- #13861 Add testing of `value_ret` for SelectCoinsBnB (Empact)
- #13863 travis: Move script sections to files in `.travis/` subject to 
shellcheck (scravy)
- #14081 travis: Fix missing differentiation between unit and functional tests 
(scravy)
- #14042 travis: Add cxxflags=-wno-psabi at arm job (ken2812221)
- #14051 Make `combine_logs.py` handle multi-line logs (jnewbery)
- #14093 Fix accidental trunction from int to bool (practicalswift)
- #14108 Add missing locking annotations and locks (`g_cs_orphans`) 
(practicalswift)
- #14088 Don't assert(?) with side effects (practicalswift)
- #14086 appveyor: Use clcache to speed up build (ken2812221)
- #13954 Warn (don't fail!) on spelling errors. Fix typos reported by 
codespell (practicalswift)
- #12775 Integration of property based testing into Bitcoin Core (Christewart)
- #14119 Read reject reasons from debug log, not P2P messages (MarcoFalke)
- #14189 Fix silent merge conflict in `wallet_importmulti` (MarcoFalke)
- #13419 Speed up `knapsack_solver_test` by not recreating wallet 100 times 
(lucash-dev)
- #14199 Remove redundant BIP174 test from `rpc_psbt.json` (araspitzu)
- #14179 Fixups to "Run all tests even if wallet is not compiled" (MarcoFalke)
- #14225 Reorder tests and move most of extended tests up to normal tests 
(ken2812221)
- #14236 `generate` --> `generatetoaddress` change to allow tests run without 
wallet (sanket1729)
- #14287 Use MakeUnique to construct objects owned by `unique_ptrs` 
(practicalswift)
- #14007 Run functional test on Windows and enable it on Appveyor (ken2812221)
- #14275 Write the notification message to different files to avoid race 
condition in `feature_notifications.py` (ken2812221)
- #14306 appveyor: Move AppVeyor YAML to dot-file-style YAML (MitchellCash)
- #14305 Enforce critical class instance attributes in functional tests, fix 
segwit test specificity (JustinTArthur)
- #14316 Exclude all tests with difference parameters in `--exclude` list 
(ken2812221)
- #14381 Add missing call to `skip_if_no_cli()` (practicalswift)
- #14389 travis: Set codespell version to avoid breakage (MarcoFalke)
- #14398 Don't access out of bounds array index: array[sizeof(array)] (Empact)
- #14419 Remove `rpc_zmq.py` (jnewbery)
- #14241 appveyor: Script improvement (ken2812221)
- #14413 Allow closed RPC handler in `assert_start_raises_init_error` 
(ken2812221)
- #14324 Run more tests with wallet disabled (MarcoFalke)
- #13649 Allow arguments to be forwarded to flake8 in lint-python.sh (jamesob)
- #14465 Stop node before removing the notification file (ken2812221)
- #14460 Improve 'CAmount' tests (hebasto)
- #14456 forward timeouts properly in `send_blocks_and_test` (jamesob)
- #14527 Revert "Make qt wallet test compatible with qt4" (MarcoFalke)
- #14504 Show the progress of functional tests (isghe)
- #14559 appveyor: Enable multiwallet tests (ken2812221)
- #13515 travis: Enable qt for all jobs (ken2812221)
- #14571 Test that nodes respond to `getdata` with `notfound` (MarcoFalke)
- #14569 Print dots by default in functional tests (ken2812221)
- #14631 Move deterministic address import to `setup_nodes` (jnewbery)
- #14630 test: Remove travis specific code (MarcoFalke)
- #14528 travis: Compile once on xenial (MarcoFalke)
- #14092 Dry run `bench_bitcoin` as part `make check` to allow for quick 
identification of assertion/sanitizer failures in benchmarking code 
(practicalswift)
- #14664 `example_test.py`: fixup coinbase height argument, derive number 
clearly (instagibbs)
- #14522 Add invalid P2P message tests (jamesob)
- #14619 Fix value display name in `test_runner` help text (merland)
- #14672 Send fewer spam messages in `p2p_invalid_messages` (jamesob)
- #14673 travis: Fail the ubsan travis build in case of newly introduced ubsan 
errors (practicalswift)
- #14665 appveyor: Script improvement part II (ken2812221)
- #14365 Add Python dead code linter (vulture) to Travis (practicalswift)
- #14693 `test_node`: `get_mem_rss` fixups (MarcoFalke)
- #14714 util.h: explicitly include required QString header (1Il1)
- #14705 travis: Avoid timeout on verify-commits check (MarcoFalke)
- #14770 travis: Do not specify sudo in `.travis` (scravy)
- #14719 Check specific reject reasons in `feature_block` (MarcoFalke)
- #14771 Add `BOOST_REQUIRE` to getters returning optional (MarcoFalke)
- #14777 Add regtest for JSON-RPC batch calls (domob1812)
- #14764 travis: Run thread sanitizer on unit tests (MarcoFalke)
- #14400 Add Benchmark to test input de-duplication worst case (JeremyRubin)
- #14812 Fix `p2p_invalid_messages` on macOS (jamesob)
- #14813 Add `wallet_encryption` error tests (MarcoFalke)
- #14820 Fix `descriptor_tests` not checking ToString output of public 
descriptors (ryanofsky)
- #14794 Add AddressSanitizer (ASan) Travis build (practicalswift)
- #14822 bench: Destroy wallet txs instead of leaking their memory 
(MarcoFalke)
- #14683 Better `combine_logs.py` behavior (jamesob)
- #14231 travis: Save cache even when build or test fail (ken2812221)
- #14816 Add CScriptNum decode python implementation in functional suite 
(instagibbs)
- #14861 Modify `rpc_bind` to conform to #14532 behaviour (dongcarl)
- #14864 Run scripted-diff in subshell (dongcarl)
- #14795 Allow `test_runner` command line to receive parameters for each test 
(marcoagner)
- #14788 Possible fix the permission error when the tests open the cookie file 
(ken2812221)
- #14857 `wallet_keypool_topup.py`: Test for all keypool address types 
(instagibbs)
- #14886 Refactor importmulti tests (jnewbery)
- #14908 Removed implicit CTransaction constructor calls from tests and 
benchmarks (lucash-dev)
- #14903 Handle ImportError explicitly, improve comparisons against None 
(daniel-s-ingram)
- #14884 travis: Enforce python 3.4 support through linter (Sjors)
- #14940 Add test for truncated pushdata script (MarcoFalke)
- #14926 consensus: Check that final transactions are valid (MarcoFalke)
- #14937 travis: Fix travis would always be green even if it fail (ken2812221)
- #14953 Make `g_insecure_rand_ctx` `thread_local` (MarcoFalke)
- #14931 mempool: Verify prioritization is dumped correctly (MarcoFalke)
- #14935 Test for expected return values when calling functions returning a 
success code (practicalswift)
- #14969 Fix `cuckoocache_tests` TSAN failure introduced in 14935 
(practicalswift)
- #14964 Fix race in `mempool_accept` (MarcoFalke)
- #14829 travis: Enable functional tests in the threadsanitizer (tsan) build 
job (practicalswift)
- #14985 Remove `thread_local` from `test_bitcoin` (MarcoFalke)
- #15005 Bump timeout to run tests in travis thread sanitizer (MarcoFalke)
- #15013 Avoid race in `p2p_timeouts` (MarcoFalke)
- #14930 pruning: Check that verifychain can be called when pruned 
(MarcoFalke)
- #15022 Upgrade Travis OS to Xenial (gkrizek)
- #14738 Fix running `wallet_listtransactions.py` individually through 
`test_runner.py` (kristapsk)
- #15026 Rename `rpc_timewait` to `rpc_timeout` (MarcoFalke)
- #15069 Fix `rpc_net.py` `pong` race condition (Empact)
- #14790 Allow running `rpc_bind.py` --nonloopback test without IPv6 
(kristapsk)
- #14457 add invalid tx templates for use in functional tests (jamesob)
- #14855 Correct ineffectual WithOrVersion from `transactions_tests` (Empact)
- #15099 Use `std::vector` API for construction of test data (domob1812)
- #15102 Run `invalid_txs.InputMissing` test in `feature_block` (MarcoFalke)
- #15059 Add basic test for BIP34 (MarcoFalke)
- #15108 Tidy up `wallet_importmulti.py` (amitiuttarwar)
- #15164 Ignore shellcheck warning SC2236 (promag)
- #15170 refactor/lint: Add ignored shellcheck suggestions to an array 
(koalaman)
- #14958 Remove race between connecting and shutdown on separate connections 
(promag)
- #15166 Pin shellcheck version (practicalswift)
- #15196 Update all `subprocess.check_output` functions to be Python 3.4 
compatible (gkrizek)
- #15043 Build fuzz targets into seperate executables (MarcoFalke)
- #15276 travis: Compile once on trusty (MarcoFalke)
- #15246 Add tests for invalid message headers (MarcoFalke)
- #15301 When testing with --usecli, unify RPC arg to cli arg conversion and 
handle dicts and lists (achow101)
- #15247 Use wallet to retrieve raw transactions (MarcoFalke)
- #15303 travis: Remove unused `functional_tests_config` (MarcoFalke)
- #15330 Fix race in `p2p_invalid_messages` (MarcoFalke)
- #15324 Make bloom tests deterministic (MarcoFalke)
- #15328 travis: Revert "run extended tests once daily" (MarcoFalke)
- #15327 Make test `updatecoins_simulation_test` deterministic 
(practicalswift)
- #14519 add utility to easily profile node performance with perf (jamesob)
- #15349 travis: Only exit early if compilation took longer than 30 min 
(MarcoFalke)
- #15350 Drop RPC connection if --usecli (promag)
- #15370 test: Remove unused --force option (MarcoFalke)
- #14543 minor `p2p_sendheaders` fix of height in coinbase (instagibbs)
- #13787 Test for Windows encoding issue (ken2812221)
- #15378 Added missing tests for RPC wallet errors (benthecarman)
- #15238 remove some magic mining constants in functional tests (instagibbs)
- #15411 travis: Combine --disable-bip70 into existing job (MarcoFalke)
- #15295 fuzz: Add `test/fuzz/test_runner.py` and run it in travis 
(MarcoFalke)
- #15413 Add missing `cs_main` locks required when accessing pcoinsdbview, 
pcoinsTip or pblocktree (practicalswift)
- #15399 fuzz: Script validation flags (MarcoFalke)
- #15410 txindex: interrupt threadGroup before calling destructor (MarcoFalke)
- #15397 Remove manual byte editing in `wallet_tx_clone` func test 
(instagibbs)
- #15415 functional: allow custom cwd, use tmpdir as default (Sjors)
- #15404 Remove `-txindex` to start nodes (amitiuttarwar)
- #15439 remove `byte.hex()` to keep compatibility (AkioNak)
- #15419 Always refresh cache to be out of ibd (MarcoFalke)
- #15507 Bump timeout on tests that timeout on windows (MarcoFalke)
- #15506 appveyor: fix cache issue and reduce dependencies build time 
(ken2812221)
- #15485 add `rpc_misc.py`, mv test getmemoryinfo, add test mallocinfo 
(adamjonas)
- #15321 Add `cs_main` lock annotations for mapBlockIndex (MarcoFalke)
- #14128 lint: Make sure we read the command line inputs using UTF-8 decoding 
in python (ken2812221)
- #14115 lint: Make all linters work under the default macos dev environment 
(build-osx.md) (practicalswift)
- #15219 lint: Enable python linters via an array (Empact)
- #15155 *test: Support -cli tests using external bitcoin-cli (luke-jr)
- #15888 *QA: Add wallet_implicitsegwit to test the ability to transform keys 
between address types (luke-jr)
- #15896 *QA: feature_filelock, interface_bitcoin_cli: Use PACKAGE_NAME in 
messages rather than hardcoding Bitcoin Core (luke-jr)
- #15897 *QA/mininode: Send all headers upfront in send_blocks_and_test to 
avoid sending an unconnected one (luke-jr)
- #12911 *test: add test to segwit tests for fee rate when signing raw tx 
(kallewoof)
- #12146 *QA: wallet_implicitsegwit: Add tests for -walletimplicitsegwit=0 
(luke-jr)

### Platform support
- #13866 utils: Use `_wfopen` and `_wfreopen` on windows (ken2812221)
- #13886 utils: Run commands using UTF-8 string on windows (ken2812221)
- #14192 utils: Convert `fs::filesystem_error` messages from local multibyte 
to UTF-8 on windows (ken2812221)
- #13877 utils: Make fs::path::string() always return UTF-8 string on windows 
(ken2812221)
- #13883 utils: Convert windows args to UTF-8 string (ken2812221)
- #13878 utils: Add fstream wrapper to allow to pass unicode filename on 
windows (ken2812221)
- #14426 utils: Fix broken windows filelock (ken2812221)
- #14686 Fix windows build error if `--disable-bip70` (ken2812221)
- #14922 windows: Set `_WIN32_WINNT` to 0x0601 (Windows 7) (ken2812221)
- #13888 Call unicode API on Windows (ken2812221)
- #15468 Use `fsbridge::ifstream` to fix Windows path issue (ken2812221)
- #13734 Drop `boost::scoped_array` and use `wchar_t` API explicitly on 
Windows (ken2812221)
- #13884 Enable bdb unicode support for Windows (ken2812221)
- #15600 *lockedpool: When possible, use madvise to avoid including sensitive 
information in core dumps or forked process memory spaces (luke-jr)
- #15650 *Handle the result of posix_fallocate system call (lucayepa)

### Miscellaneous
- #13935 contrib: Adjust output to current test format (AkioNak)
- #14097 validation: Log FormatStateMessage on ConnectBlock error in 
ConnectTip (MarcoFalke)
- #14186 bitcoin-cli: don't translate command line options (HashUnlimited)
- #14057 logging: Only log `using config file path_to_bitcoin.conf` message on 
startup if conf file exists (leishman)
- #14164 Update univalue subtree (MarcoFalke)
- #14272 init: Remove deprecated args from hidden args (MarcoFalke)
- #14494 Error if # is used in rpcpassword in conf (MeshCollider)
- #14742 Properly generate salt in rpcauth.py (dongcarl)
- #14708 Warn unrecognised sections in the config file (AkioNak)
- #14756 Improve rpcauth.py by using argparse and getpass modules (promag)
- #14785 scripts: Fix detection of copyright holders (cornelius)
- #14831 scripts: Use `#!/usr/bin/env bash` instead of `#!/bin/bash` (vim88)
- #14869 Scripts: Add trusted key for samuel dobson (laanwj)
- #14809 Tools: improve verify-commits.py script (jlopp)
- #14624 Some simple improvements to the RNG code (sipa)
- #14947 scripts: Remove python 2 import workarounds (practicalswift)
- #15087 Error if rpcpassword contains hash in conf sections (MeshCollider)
- #14433 Add checksum in gitian build scripts for ossl (TheCharlatan)
- #15165 contrib: Allow use of github api authentication in github-merge 
(laanwj)
- #14409 utils and libraries: Make 'blocksdir' always net specific (hebasto)
- #14839 threads: Fix unitialized members in `sched_param` (fanquake)
- #14955 Switch all RNG code to the built-in PRNG (sipa)
- #15258 Scripts and tools: Fix `devtools/copyright_header.py` to always honor 
exclusions (Empact)
- #12255 Update bitcoin.service to conform to init.md (dongcarl)
- #15266 memory: Construct globals on first use (MarcoFalke)
- #15347 Fix build after pr 15266 merged (hebasto)
- #15351 Update linearize-hashes.py (OverlordQ)
- #15358 util: Add setuphelpoptions() (MarcoFalke)
- #15216 Scripts and tools: Replace script name with a special parameter 
(hebasto)
- #15250 Use RdSeed when available, and reduce RdRand load (sipa)
- #15278 Improve PID file error handling (hebasto)
- #15270 Pull leveldb subtree (MarcoFalke)
- #15456 Enable PID file creation on WIN (riordant)
- #15124 Fail AppInitMain if either disk space check fails (Empact)
- #15117 Fix invalid memory write in case of failing mmap(?) in 
PosixLockedPageAllocator::AllocateLocked (practicalswift)
- #14357 streams: Fix broken `streams_vector_reader` test. Remove unused 
`seek(size_t)`
- #11640 Make `LOCK`, `LOCK2`, `TRY_LOCK` work with CWaitableCriticalSection 
(ryanofsky)
- #14074 Use `std::unordered_set` instead of `set` in blockfilter interface 
(jimpo)
- #15275 Add gitian PGP key for hebasto (hebasto)
- #8501 *Stats: Fix typing issues in memory management logic (luke-jr)
- #8501 *Stats: In weird memory management cases, do the best that makes sense 
(luke-jr)
- #13339 *wallet: Escape wallet name in -walletnotify script (promag)
- #15367 *feature: Added ability for users to add a startup command 
(benthecarman)
- #15566 *cli: add chain and return network name as per BIP70. (fanquake)

### Documentation
- #14120 Notes about control port and read access to cookie (JBaczuk)
- #14135 correct GetDifficulty doc after #13288 (fanquake)
- #14013 Add new regtest ports in man following #10825 ports reattributions 
(ariard)
- #14149 Remove misleading checkpoints comment in CMainParams (MarcoFalke)
- #14153 Add disable-wallet section to OSX build instructions, update line in 
Unix instructions (bitstein)
- #13662 Explain when reindex-chainstate can be used instead of reindex 
(Sjors)
- #14207 `-help-debug` implies `-help` (laanwj)
- #14213 Fix reference to lint-locale-dependence.sh (hebasto)
- #14206 Document `-checklevel` levels (laanwj)
- #14217 Add GitHub PR template (MarcoFalke)
- #14331 doxygen: Fix member comments (MarcoFalke)
- #14264 Split depends installation instructions per arch (MarcoFalke)
- #14393 Add missing apt-get install (poiuty)
- #14428 Fix macOS files description in qt/README.md (hebasto)
- #14390 release process: RPC documentation (karel-3d)
- #14497 Add doc/bitcoin-conf.md (hebasto)
- #14526 Document lint tests (fanquake)
- #14511 Remove explicit storage requirement from README.md (merland)
- #14600 Clarify commit message guidelines (merland)
- #14617 FreeBSD: Document Python 3 requirement for 'gmake check' (murrayn)
- #14592 Add external interface consistency guarantees (MarcoFalke)
- #14625 Make clear function argument case in dev notes (dongcarl)
- #14515 Update OpenBSD build guide for 6.4 (fanquake)
- #14436 Add comment explaining recentRejects-DoS behavior (jamesob)
- #14684 conf: Remove deprecated options from docs, Other cleanup (MarcoFalke)
- #14731 Improve scripted-diff developer docs (dongcarl)
- #14778 A few minor formatting fixes and clarifications to descriptors.md 
(jnewbery)
- #14448 Clarify rpcwallet flag url change (JBaczuk)
- #14808 Clarify RPC rawtransaction documentation (jlopp)
- #14804 Less confusing documentation for `torpassword` (fanquake)
- #14848 Fix broken Gmane URL in security-check.py (cyounkins-bot)
- #14882 developer-notes.md: Point out that UniValue deviates from upstream 
(Sjors)
- #14909 Update minimum required Qt (fanquake)
- #14914 Add nice table to files.md (emilengler)
- #14741 Indicate `-rpcauth` option password hashing alg (dongcarl)
- #14950 Add NSIS setup/install steps to windows docs (fanquake)
- #13930 Better explain GetAncestor check for `m_failed_blocks` in 
AcceptBlockHeader (Sjors)
- #14973 Improve Windows native build instructions (murrayn)
- #15073 Botbot.me (IRC logs) not available anymore (anduck)
- #15038 Get more info about GUI-related issue on Linux (hebasto)
- #14832 Add more Doxygen information to Developer Notes (ch4ot1c)
- #15128 Fix download link in doc/README.md (merland)
- #15127 Clarifying testing instructions (benthecarman)
- #15132 Add FreeBSD build notes link to doc/README.md (fanquake)
- #15173 Explain what .python-version does (Sjors)
- #15223 Add information about security to the JSON-RPC doc (harding)
- #15249 Update python docs to reflect that wildcard imports are disallowed 
(Empact)
- #15176 Get rid of badly named `doc/README_osx.md` (merland)
- #15272 Correct logging return type and RPC example (fanquake)
- #15244 Gdb attaching to process during tests has non-sudo solution 
(instagibbs)
- #15332 Small updates to `getrawtransaction` description (amitiuttarwar)
- #15354 Add missing `bitcoin-wallet` tool manpages (MarcoFalke)
- #15343 netaddress: Make IPv4 loopback comment more descriptive (dongcarl)
- #15353 Minor textual improvements in `translation_strings_policy.md` 
(merland)
- #15426 importmulti: add missing description of keypool option (harding)
- #15425 Add missing newline to listunspent help for witnessScript (harding)
- #15348 Add separate productivity notes document (dongcarl)
- #15416 Update FreeBSD build guide for 12.0 (fanquake)
- #15222 Add info about factors that affect dependency list (merland)
- #13676 Explain that mempool memory is added to `-dbcache` (Sjors)
- #15273 Slight tweak to the verify-commits script directions (droark)
- #15477 Remove misleading hint in getrawtransaction (MarcoFalke)
- #15489 Update release process for snap package (MarcoFalke)
- #15524 doc: Remove berkeleydb PPA from linux build instructions (MarcoFalke)
- #15559 Correct `analyzepsbt` rpc doc (fanquake)
- #15194 Add comment describing `fDisconnect` behavior (dongcarl)
- #15754 getrpcinfo docs (benthecarman)
- #15763 Update bips.md for 0.18.0 (sipa)
- #15757 List new RPCs in psbt.md and descriptors.md (sipa)
- #15765 correct bitcoinconsensus_version in shared-libraries.md (fanquake)
- #15792 describe onlynet option in doc/tor.md (jonatack)
- #15802 mention creating application support bitcoin folder on OSX (JimmyMow)
- #15799 Clarify RPC versioning (MarcoFalke)

Credits
=======

Thanks to everyone who directly contributed to this release:

- 1Il1
- 251
- Aaron Clauson
- Adam Jonas
- Akio Nakamura
- Alexander Leishman
- Alexey Poghilenkov
- Amir Abrams
- Amiti Uttarwar
- Andrew Chow
- andrewtoth
- Anthony Towns
- Antoine Le Calvez
- Antoine Riard
- Antti Majakivi
- araspitzu
- Arvid Norberg
- Ben Carman
- Ben Woosley
- benthecarman
- bitcoinhodler
- Carl Dong
- Chakib Benziane
- Chris Moore
- Chris Stewart
- Chun Kuan Lee
- Cornelius Schumacher
- Cory Fields
- Craig Younkins
- Cristian Mircea Messel
- Damian Mee
- Daniel Ingram
- Daniel Kraft
- David A. Harding
- DesWurstes
- Dimitri Deijs
- Dimitris Apostolou
- Douglas Roark
- DrahtBot
- Emanuele Cisbani
- Emil Engler
- Eric Scrivner
- fridokus
- Gal Buki
- Gleb Naumenko
- Glenn Willen
- Graham Krizek
- Gregory Maxwell
- Gregory Sanders
- gustavonalle
- Harry Moreno
- Hennadii Stepanov
- Isidoro Ghezzi
- Jack Mallers
- James Hilliard
- James O'Beirne
- Jameson Lopp
- Jeremy Rubin
- Jesse Cohen
- Jim Posen
- John Newbery
- Jon Layton
- Jonas Schnelli
- Jo?o Barbosa
- Jordan Baczuk
- Jorge Tim?n
- Julian Fleischer
- Justin Turner Arthur
- Karel B?lek
- Karl-Johan Alm
- Kaz Wesley
- ken2812221
- Kostiantyn Stepaniuk
- Kristaps Kaupe
- Lawrence Nahum
- Lenny Maiorani
- liuyujun
- Luca Venturini
- lucash-dev
- luciana
- Luke Dashjr
- marcaiaf
- marcoagner
- MarcoFalke
- Martin Erlandsson
- Marty Jones
- Mason Simon
- Michael Ford
- Michael Goldstein
- Michael Polzer
- Mitchell Cash
- mruddy
- Murray Nesbitt
- OverlordQ
- Patrick Strateman
- Pierre Rochard
- Pieter Wuille
- poiuty
- practicalswift
- priscoan
- qubenix
- riordant
- Russell Yanofsky
- Samuel Dobson
- sanket1729
- Sjors Provoost
- Stephan Oeste
- Steven Roose
- Suhas Daftuar
- TheCharlatan
- Tim Ruffing
- Tobias Kaderle
- Vidar Holen
- vim88
- Walter
- Wladimir J. van der Laan
- Zain Iqbal Allarakhia

As well as everyone that helped translating on [Transifex]
(https://www.transifex.com/projects/p/bitcoin/).

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190504/f7bc70bc/attachment-0001.sig>

From pieter.wuille at gmail.com  Mon May  6 17:57:57 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 6 May 2019 10:57:57 -0700
Subject: [bitcoin-dev] Taproot proposal
Message-ID: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>

Hello everyone,

Here are two BIP drafts that specify a proposal for a Taproot
softfork. A number of ideas are included:

* Taproot to make all outputs and cooperative spends indistinguishable
from eachother.
* Merkle branches to hide the unexecuted branches in scripts.
* Schnorr signatures enable wallet software to use key
aggregation/thresholds within one input.
* Improvements to the signature hashing algorithm (including signing
all input amounts).
* Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support
batch validation.
* Tagged hashing for domain separation (avoiding issues like
CVE-2012-2459 in Merkle trees).
* Extensibility through leaf versions, OP_SUCCESS opcodes, and
upgradable pubkey types.

The BIP drafts can be found here:
* https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki
specifies the transaction input spending rules.
* https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki
specifies the changes to Script inside such spends.
* https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
is the Schnorr signature proposal that was discussed earlier on this
list (See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html)

An initial reference implementation of the consensus changes, plus
preliminary construction/signing tests in the Python framework can be
found on https://github.com/sipa/bitcoin/commits/taproot. All
together, excluding the Schnorr signature module in libsecp256k1, the
consensus changes are around 520 LoC.

While many other ideas exist, not everything is incorporated. This
includes several ideas that can be implemented separately without loss
of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,
which we're working on as an independent proposal.

The document explains basic wallet operations, such as constructing
outputs and signing. However, a wide variety of more complex
constructions exist. Standardizing these is useful, but out of scope
for now. It is likely also desirable to define extensions to PSBT
(BIP174) for interacting with Taproot. That too is not included here.

Cheers,

-- 
Pieter

From luke at dashjr.org  Mon May  6 20:17:09 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 6 May 2019 20:17:09 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
Message-ID: <201905062017.11396.luke@dashjr.org>

There are multiple references to "space savings", but no rationale for 
treating "space" as something to save or even define. The costs are in CPU 
time and I/O (which "space saving" doesn't necessarily reduce) and bandwidth 
(which can often be reduced without "space saving" in commitments). The 
proposal can apparently be made simpler by ignoring this irrelevant "space 
saving" goal.

Tagged hashes put the tagging at the start of the hash input. This means 
implementations can pre-cache SHA2 states, but it also means they can't reuse 
states to produce data for different contexts. (I'm not sure if there is a 
use for doing so... but maybe as part of further hiding MAST branches?)

Is there any way to use the Taproot construct here while retaining external 
script limitations that the involved party(ies) *cannot* agree to override? 
For example, it is conceivable that one might wish to have an unconditional 
CLTV enforced in all circumstances.

It may be useful to have a way to add a salt to tap branches.

Some way to sign an additional script (not committed to by the witness 
program) seems like it could be a trivial addition.


On Monday 06 May 2019 17:57:57 Pieter Wuille via bitcoin-dev wrote:
> Hello everyone,
>
> Here are two BIP drafts that specify a proposal for a Taproot
> softfork. A number of ideas are included:
>
> * Taproot to make all outputs and cooperative spends indistinguishable
> from eachother.
> * Merkle branches to hide the unexecuted branches in scripts.
> * Schnorr signatures enable wallet software to use key
> aggregation/thresholds within one input.
> * Improvements to the signature hashing algorithm (including signing
> all input amounts).
> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support
> batch validation.
> * Tagged hashing for domain separation (avoiding issues like
> CVE-2012-2459 in Merkle trees).
> * Extensibility through leaf versions, OP_SUCCESS opcodes, and
> upgradable pubkey types.
>
> The BIP drafts can be found here:
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki
> specifies the transaction input spending rules.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki
> specifies the changes to Script inside such spends.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> is the Schnorr signature proposal that was discussed earlier on this
> list (See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.ht
>ml)
>
> An initial reference implementation of the consensus changes, plus
> preliminary construction/signing tests in the Python framework can be
> found on https://github.com/sipa/bitcoin/commits/taproot. All
> together, excluding the Schnorr signature module in libsecp256k1, the
> consensus changes are around 520 LoC.
>
> While many other ideas exist, not everything is incorporated. This
> includes several ideas that can be implemented separately without loss
> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,
> which we're working on as an independent proposal.
>
> The document explains basic wallet operations, such as constructing
> outputs and signing. However, a wide variety of more complex
> constructions exist. Standardizing these is useful, but out of scope
> for now. It is likely also desirable to define extensions to PSBT
> (BIP174) for interacting with Taproot. That too is not included here.
>
> Cheers,


From snigirev.stepan at gmail.com  Tue May  7 09:23:44 2019
From: snigirev.stepan at gmail.com (Stepan Snigirev)
Date: Tue, 7 May 2019 11:23:44 +0200
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more
	secure
In-Reply-To: <20190503132945.GR810@coinkite.com>
References: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
	<20190503132945.GR810@coinkite.com>
Message-ID: <CACL8y1tesev2OLrkfYfvmkgbR2xuk-0JPqdmYGtrUcser9GPfg@mail.gmail.com>

> I'd rather see the xpubs shared in the global section of the file,
> with the restriction that they must/should only include the hardened
> prefix of the path. The existing bip32 derivation path included in
> individual inputs and outputs be merged in as needed.
> After all in a typical PSBT, we would expect the same master keys
> to be used on all inputs, and at least one output, and there might
> be as many as 20 co-signers. No need to repeat all that information.

I agree that it makes sense to put xpubs to the global scope.
But I am not sure that restricting xpubs to have only hardened derivation
is necessary.
People may want to share non-hardened xpubs with co-signers and keep parent
xpub on there watch-only wallet.
For example, in bip45 cosigner_index is not hardened, and sharing top level
xpub is not necessary.

> Even with this additions to the PSBT format, I think PSBT-signing
> devices still need to store the xpubs of their co-signers. It's not
> possible to safely show an incoming address to the user without a
> full understanding of the other keys in a "multisig wallet". Also,
> it represents data that should not change between PSBT instances
> (ie. tomorrow's co-signers should match today's).

I would like to keep hardware wallets state-less, otherwise wiping and
recovering them would be problematic.
At the setup phase the user can verify a multisignature address (or xpub)
on the screens of all devices,
after that we just need to verify that xpubs in the inputs and in the
change output are the same.

Andrew, regarding your question:
> Just for clairty, by xpub, do you mean the extended serialization format
> defined in BIP 32 or the Base58 check encoded string of that
serialization?

As PSBT is a binary format I think it makes sense to use extension
serialization format without any encodings.
I am not sure if we need the whole xpub or keeping chain_code and
public_key is enough, but I would suggest to keep other data
just in case. For example, keeping prefix that defines if the key is used
for testnet or mainnet may be useful.

Best regards,
Stepan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190507/8cc9e1f1/attachment.html>

From dp at simplexum.com  Tue May  7 13:40:34 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Tue, 7 May 2019 18:40:34 +0500
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more
 secure
In-Reply-To: <CACL8y1tesev2OLrkfYfvmkgbR2xuk-0JPqdmYGtrUcser9GPfg@mail.gmail.com>
References: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
	<20190503132945.GR810@coinkite.com>
	<CACL8y1tesev2OLrkfYfvmkgbR2xuk-0JPqdmYGtrUcser9GPfg@mail.gmail.com>
Message-ID: <20190507184034.0a72a9c7@simplexum.com>


> > Even with this additions to the PSBT format, I think PSBT-signing
> > devices still need to store the xpubs of their co-signers. It's not
> > possible to safely show an incoming address to the user without a
> > full understanding of the other keys in a "multisig wallet". Also,
> > it represents data that should not change between PSBT instances
> > (ie. tomorrow's co-signers should match today's).
> 
> I would like to keep hardware wallets state-less, otherwise wiping and
> recovering them would be problematic.
> At the setup phase the user can verify a multisignature address (or
> xpub) on the screens of all devices,
> after that we just need to verify that xpubs in the inputs and in the
> change output are the same.

At the setup phase, hardware wallet can sign a message that consists of
xpubs of participants, and some auxiliary text. It can use the key
derived from the master key, with path chosen specifically for this
purpose.

Hardware wallet then gives out this signature to the software.

The software will store the message and the signature (or maybe it can
take xpubs from PSBT), and will send this 'trusted-xpub-package' to
hardware wallet along with the transaction.

Hardware wallet can then verify that the message is indeed signed by
the key for that purpose, and then can mark the ouputs that use the
pubkeys derived from 'verified' xpubs as 'trusted' outputs. It can also
display the auxiliary text along with the information about the
'trusted' output.

This way, hardware wallet does not need to store anything extra besides
the master key.

This would allow to distinguish the trusted output even if the inputs
are not all derived from the same set of xpubs, that could happen in
more complex scenarios (batching, key rotation, etc.), and can possibly
be used to have several different types of 'trusted' outputs.

If the user loses the signature for trusted-xpub-package, the signature
can be re-created again - but maybe the procedure should be more
involved than ordinary signing, because creating creating such
'trusted-xpub-package' with malicious keys can enable attackers to
bypass these checks.

From sjors at sprovoost.nl  Tue May  7 20:42:58 2019
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Tue, 7 May 2019 22:42:58 +0200
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <201905062017.11396.luke@dashjr.org>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
Message-ID: <34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>

Hey Pieter,

I think this is a reasonable collection of changes that make sense in combination. Some initial feedback and questions.

From the BIP:
> If one or more of the spending conditions consist of just a single key (after aggregation),
> he most likely one should be made the internal key. If no such condition exists, it may
> be worthwhile adding one that consists of an aggregation of all keys participating in all
> scripts combined; effectively adding an "everyone agrees" branch. If that is inacceptable,
> pick as internal key a point with unknown discrete logarithm (TODO).

I assume Luke Dashjr referred to the above when saying:

> Is there any way to use the Taproot construct here while retaining external 
> script limitations that the involved party(ies) *cannot* agree to override? 
> For example, it is conceivable that one might wish to have an unconditional 
> CLTV enforced in all circumstances.


One reason why someone would want to avoid a "everone agrees" branch, is duress (or self-discipline, or limiting powers of a trustee). In particular with respect to time-locks.

Can this "unknown discrete logarithm" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.

Perhaps Lightning devs have an opinion on "everyone agrees" with respect to hash pre-images. I suspect there is no benefit in guaranteeing that a pre-image must be revealed or a timeout must be waited for and there's no way around that condition.


Regarding usage of Schnorr: do I understand correctly that the "everyone agrees" internal key MUST use Schnorr, and that individual branches MAY use Schnorr, but only if they're marked as tapscript spend?

Why is tapscript not mandatory?


Misc details:

In the Design section under "Merkle branches" I suggest adding bullet points with short descriptions of "various known mechanisms for implementing this". In addition to "space savings" maybe also briefly mention a few other pros and cons, like implementation complexity and privacy. And then point out which one you picked.

In the Design section, explicitly point out you're no longer using the hash of a public key (can move some explanation up from rationale section). This is a significant change, even if you have good reason to believe it's perfectly safe.

Regarding the 64 byte SHA256(tag) || SHA256(tag) 64-byte long context-specific constant: maybe add that sha-2 block size is 512 bits

"Conceptually every Taproot output corresponds to" -> some of this conceptual stuff belongs in or before the Specification section. Try briefly explaining how tagged hashes and script validation (stack) interact, before specifying them in detail. The figure (without the pseudo-code) can be helpful for that. 

In the figure with the merkle tree, the description says there's "3 script leaves.". So what's going on in leaf D? If it's a way to indicate an unused leaf, why is E different (or is also TapLeaf)? Maybe emphasize that "TapLeaf" tag is there so prove to all signers there's no secret conditions (the CVE-2012-2459 protection you refer to).

Sjors


> Op 6 mei 2019, om 22:17 heeft Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> There are multiple references to "space savings", but no rationale for 
> treating "space" as something to save or even define. The costs are in CPU 
> time and I/O (which "space saving" doesn't necessarily reduce) and bandwidth 
> (which can often be reduced without "space saving" in commitments). The 
> proposal can apparently be made simpler by ignoring this irrelevant "space 
> saving" goal.
> 
> Tagged hashes put the tagging at the start of the hash input. This means 
> implementations can pre-cache SHA2 states, but it also means they can't reuse 
> states to produce data for different contexts. (I'm not sure if there is a 
> use for doing so... but maybe as part of further hiding MAST branches?)
> 
> Is there any way to use the Taproot construct here while retaining external 
> script limitations that the involved party(ies) *cannot* agree to override? 
> For example, it is conceivable that one might wish to have an unconditional 
> CLTV enforced in all circumstances.
> 
> It may be useful to have a way to add a salt to tap branches.
> 
> Some way to sign an additional script (not committed to by the witness 
> program) seems like it could be a trivial addition.
> 
> 
> On Monday 06 May 2019 17:57:57 Pieter Wuille via bitcoin-dev wrote:
>> Hello everyone,
>> 
>> Here are two BIP drafts that specify a proposal for a Taproot
>> softfork. A number of ideas are included:
>> 
>> * Taproot to make all outputs and cooperative spends indistinguishable
>> from eachother.
>> * Merkle branches to hide the unexecuted branches in scripts.
>> * Schnorr signatures enable wallet software to use key
>> aggregation/thresholds within one input.
>> * Improvements to the signature hashing algorithm (including signing
>> all input amounts).
>> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support
>> batch validation.
>> * Tagged hashing for domain separation (avoiding issues like
>> CVE-2012-2459 in Merkle trees).
>> * Extensibility through leaf versions, OP_SUCCESS opcodes, and
>> upgradable pubkey types.
>> 
>> The BIP drafts can be found here:
>> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki
>> specifies the transaction input spending rules.
>> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki
>> specifies the changes to Script inside such spends.
>> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
>> is the Schnorr signature proposal that was discussed earlier on this
>> list (See
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.ht
>> ml)
>> 
>> An initial reference implementation of the consensus changes, plus
>> preliminary construction/signing tests in the Python framework can be
>> found on https://github.com/sipa/bitcoin/commits/taproot. All
>> together, excluding the Schnorr signature module in libsecp256k1, the
>> consensus changes are around 520 LoC.
>> 
>> While many other ideas exist, not everything is incorporated. This
>> includes several ideas that can be implemented separately without loss
>> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,
>> which we're working on as an independent proposal.
>> 
>> The document explains basic wallet operations, such as constructing
>> outputs and signing. However, a wide variety of more complex
>> constructions exist. Standardizing these is useful, but out of scope
>> for now. It is likely also desirable to define extensions to PSBT
>> (BIP174) for interacting with Taproot. That too is not included here.
>> 
>> Cheers,
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From aj at erisian.com.au  Wed May  8 04:49:28 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 8 May 2019 14:49:28 +1000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <201905062017.11396.luke@dashjr.org>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
Message-ID: <20190508044928.z52oaxevwcppkvna@erisian.com.au>

On Mon, May 06, 2019 at 08:17:09PM +0000, Luke Dashjr via bitcoin-dev wrote:
> Some way to sign an additional script (not committed to by the witness 
> program) seems like it could be a trivial addition.

Aside: if you want to commit to something extra *with* the witness
program, you could use either an unsolvable tapleaf branch (eg, one
that uses OP_RETURN and also pushes the data you want to commit to),
or a p2c construction like:

  Taproot: Q = P + H_TapTweak(P || S)*G

  P2C: P = R + H_"myp2c"(R || Contract)*G

If you don't have any scripts for S, you could set S=["OP_RETURN"]
to ensure there are no scripts. Having either the TapTweak formula or
the H_myp2c hash should be enough to ensure that your contract can't
get maliciously reinterpreted as a valid tapscript, having both is just
belts and suspenders.

But to address your question: if you want to commit to something extra
at spending/signing time rather than when creating the address, then
that's what the annex should be useful for. eg as a simple example,
your annex might be:

    0x50 [flag]
    0x25 [entry size]
      0x77 [annex entry id]
      0x0008c618 [block height == 575000]
      0x00000000000000000007df59824a0c86d1cc21b90eb25259dd2dba5170cea5f5
         [block hash for block at 575000]

which would allow you to commit to a particular block hash, and there
could be a soft fork that added the restriction that such a commitment
invalidates the transaction if the block at the given height doesn't
match the provided hash.

You still need to the soft-fork to do the enforcing, but once you have
that, *every* existing taproot address automatically gets "upgraded"
to allow you to make the commitment, including via key path spends,
which seems pretty nice.

(That construction (ie size,id,data) lets you have multiple entries in
the annex reasonably efficiently)

Cheers,
aj

From pieter.wuille at gmail.com  Wed May  8 23:06:51 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 8 May 2019 16:06:51 -0700
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
	<34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>
Message-ID: <CAPg+sBjqgyu=Do-8P=7Q1S3tehr30K58=o_SokAE7H_SP-pf8g@mail.gmail.com>

Thanks for the comments so far!

I'm going to respond to some of the comments here. Things which I plan
to address with changes in the BIP I'll leave for later.

On Mon, 6 May 2019 at 13:17, Luke Dashjr <luke at dashjr.org> wrote:
> Tagged hashes put the tagging at the start of the hash input. This means
> implementations can pre-cache SHA2 states, but it also means they can't reuse
> states to produce data for different contexts. (I'm not sure if there is a
> use for doing so... but maybe as part of further hiding MAST branches?)

It's true you can't cache/precompute things across tags, but I also
think there is no need. The type of data hashed in a sighash vs a
merkle branch/leaf vs a tweak is fundamentally different. I think this
is perhaps a good guidance to include about when separate tags are
warranted vs. simply making sure the input does not collide: there
shouldn't be much or any shared data with things that are expected to
be inputs under other tags.

> Is there any way to use the Taproot construct here while retaining external
> script limitations that the involved party(ies) *cannot* agree to override?
> For example, it is conceivable that one might wish to have an unconditional
> CLTV enforced in all circumstances.

Yes, absolutely - you can use a point with unknown discrete logarithm
as internal key. This will result in only script path spends being
available. For the specific goal you're stating an alternative may be
using a valid known private key, using it to pre-sign a timelocked
transaction, and destroying the key.

> It may be useful to have a way to add a salt to tap branches.

If you don't reuse public keys, effectively every branch is
automatically salted (and the position in the tree gets randomized
automatically when doing so, providing a small additional privacy
benefit).

>> Some way to sign an additional script (not committed to by the witness
>> program) seems like it could be a trivial addition.
> This would be especially useful for things like OP_CHECKBLOCKATHEIGHT:
> https://github.com/bitcoin/bips/blob/master/bip-0115.mediawiki

If you're talking about the ability to sign over the ability to spend
to another script ("delegation"), there are lots of interesting
applications and ways to implement it. But it overlaps with Graftroot,
and doing it efficiently in general has some interesting and
non-obvious engineering challenges (for example, signing over to a
script that enforces "f(tx)=y" for some f can be done by only storing
f and then including y in the sighash).

For the specific example of BIP115's functionality, that seems like a
reasonable thing that could be dealt with using the annex construction
in the proposed BIP. A consensus rule could define a region inside the
annex that functions as a height-blockhash assertion. The annex is
included in all sighashes, so it can't be removed from the input;
later opcodes could include the ability to inspect that assertion
even.

On Tue, 7 May 2019 at 13:43, Sjors Provoost <sjors at sprovoost.nl> wrote:
> One reason why someone would want to avoid a "everone agrees" branch, is duress (or self-discipline, or limiting powers of a trustee). In particular with respect to time-locks.>

Indeed, though as I suggested above, you can also use timelocked
transactions (but using only CLTV branches is more flexible
certainly).

> Can this "unknown discrete logarithm" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.

Yes, that's a TODO that's left in the draft, but this is absolutely
possible (using a hash-to-curve operation). As ZmnSCPxj already
suggested, there can even be a fixed known constant you can use for
this. However, you get better privacy by taking this fixed known
constant (call it C) and using as internal key a blinded version of it
(C+rG, for some random value r, and G the normal secp256k1 generator);
as long as the DL between G and C is unknown, this is safe (and does
not reveal to the world that in fact no key-path was permitted when
spending).

> Regarding usage of Schnorr: do I understand correctly that the "everyone agrees" internal key MUST use Schnorr, and that individual branches MAY use Schnorr, but only if they're marked as tapscript spend?
>
> Why is tapscript not mandatory?

Spending using the internal key always uses a single Schnorr signature
and nothing else. When you spend using a script path, you must reveal
both the script and its leaf version. If that leaf version is 0xc0,
the script is interpreted as a tapscript (in which only Schnorr
opcodes exist). If that leaf version is not 0xc0, the script is
undefined, and is unconditionally valid. This is one of the included
extension mechanisms, allowing replacing the whole script language
with something else, but without revealing it unless a branch using it
is actually used (different Merkle tree leaves can have a distinct
leaf versions).

So the reason that tapscript is not mandatory is because other leaf
versions are undefined, and left for future extensions (similar to how
future segwit versions at the output level are undefined).

Cheers,

-- 
Pieter

From ZmnSCPxj at protonmail.com  Wed May  8 03:44:29 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 08 May 2019 03:44:29 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <201905062017.11396.luke@dashjr.org>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
Message-ID: <sujR-1TPC3DI-bNyQD2U5c5E0qkkfi6WezKQOfB9YgP7UbLj3x-maV0ooIqvJ4C2V_yjkrq78F7QqIZ5LyoZuSKcpC08RFWapH2k-FF3_zc=@protonmail.com>

Good morning Luke,


> Is there any way to use the Taproot construct here while retaining external
> script limitations that the involved party(ies) cannot agree to override?
> For example, it is conceivable that one might wish to have an unconditional
> CLTV enforced in all circumstances.

Perhaps this can be enforced offchain, by participants refusing to sign a transaction unless it has an `nLockTime` of the agreed-upon "unconditional CLTV".
Then the CLTV need only be on branches which have a strict subset of the participants as signers.

>
> It may be useful to have a way to add a salt to tap branches.

Would not adding `OP_PUSH(<salt>) OP_DROP` to the leaves work?
If you enforce always salting with a 32-byte salt, that "only" saves 3 bytes of witness data (for the `OP_PUSHDATA1+size` and `OP_DROP` opcodes).
Or do you refer to always salting every node?
(I am uncertain, but would not adding a salt to every leaf be sufficient?)

(in any case, if you use different pubkeys for each contract, rather than reusing keys, is that not enough randomization to prevent creating rainbow tables of scripts?)

>
> Some way to sign an additional script (not committed to by the witness
> program) seems like it could be a trivial addition.

It seems to me the annex can be used for this, by having it contain both the script and the signature somehow concatenated.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed May  8 04:37:37 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 08 May 2019 04:37:37 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
	<34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>
Message-ID: <2OTGF_pw4RyRk4r84XkFrxdU-wz8m0iRr469ZvlBitshF7K8arSwXkaxdmL-GjTatYbU8DcgWO2zzM2u3EZ3hhjsCUeKHWu0prFoSUmeRUs=@protonmail.com>

Good morning Sjors,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Wednesday, May 8, 2019 4:42 AM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hey Pieter,
>
> I think this is a reasonable collection of changes that make sense in combination. Some initial feedback and questions.
>
> From the BIP:
>
> > If one or more of the spending conditions consist of just a single key (after aggregation),
> > he most likely one should be made the internal key. If no such condition exists, it may
> > be worthwhile adding one that consists of an aggregation of all keys participating in all
> > scripts combined; effectively adding an "everyone agrees" branch. If that is inacceptable,
> > pick as internal key a point with unknown discrete logarithm (TODO).
>
> I assume Luke Dashjr referred to the above when saying:
>
> > Is there any way to use the Taproot construct here while retaining external
> > script limitations that the involved party(ies) cannot agree to override?
> > For example, it is conceivable that one might wish to have an unconditional
> > CLTV enforced in all circumstances.
>
> One reason why someone would want to avoid a "everone agrees" branch, is duress (or self-discipline, or limiting powers of a trustee). In particular with respect to time-locks.
>
> Can this "unknown discrete logarithm" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.

As I understand it, it is possible to take some random data, hash it with SHA256 and acquire a 256-bit number.
Then treat that number as an X coordinate (or is it Y...), and see if there exists a point on the secp256k1 curve at that coordinate.
If not, try another random data, or just hash the same number again.
As I understand it, about half the possible X coordinates will have a point on the curve.

I believe this is the "hash to a point" technique.

The scalar behind the above point cannot be known, unless either the hash function is broken, or ECDLP is broken.
(perhaps a better cryptographer can give the proper qualifications, any corrections, and etc etc)

As the point is just an arbitrary point on the curve, it is unknown to the rest of the world whether somebody knows the scalar, or nobody knows.

>
> Perhaps Lightning devs have an opinion on "everyone agrees" with respect to hash pre-images. I suspect there is no benefit in guaranteeing that a pre-image must be revealed or a timeout must be waited for and there's no way around that condition.

The "everyone agrees" branch in Lightning is basically the "cooperative close" of the channel.
So it is not likely we will need an "everyone agrees" branch in the actual HTLCs we transfer *within* the channel.
So if we need to use hashes still, we will likely use the "hash to a point" technique above.

Or just use pubkeys given by both participants, that should be enough to ensure the "everyone agrees" branch is never taken if we write our software such that we never agree to sign with it (i.e. just get points from both sides and MuSig them; then each side can just erase the scalar generating it from memory and whatever caches exist on the system; a node might even just generate a single random point from a scalar it subsequently erases, and just use some non-hardened derivation path from that for every HTLC it has to make).
This technique is "sufficiently provably unknown" since each participant knows that it deliberately erased the only means of knowing the complete discrete log by erasing its share.
In short, "everyone agrees" is trivially easy to make "nobody can agree" by a single participant never agreeing to let itself be ripped off.

Do note that it is likely Lightning will eventually switch to using payment points/scalars instead of hashes/preimages.
This will allow us to have path decorrelation, both within a route, and in multiple routes of the same payment.
This is enabled by Schnorr, as this requires Scriptless Script.
(granted 2p-ECDSA also enables Scriptless Script, but we decided to wait for Schnorr to hit base layer instead)
This means we would be using the "everyone agrees" path only, with everyone agreeing to first create a `nLockTime` backout tx, then everyone agreeing to create a transaction where one side has knowledge of a secret scalar that is learned by the other side upon completion of the signature.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Wed May  8 05:16:03 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 08 May 2019 05:16:03 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <2OTGF_pw4RyRk4r84XkFrxdU-wz8m0iRr469ZvlBitshF7K8arSwXkaxdmL-GjTatYbU8DcgWO2zzM2u3EZ3hhjsCUeKHWu0prFoSUmeRUs=@protonmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
	<34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>
	<2OTGF_pw4RyRk4r84XkFrxdU-wz8m0iRr469ZvlBitshF7K8arSwXkaxdmL-GjTatYbU8DcgWO2zzM2u3EZ3hhjsCUeKHWu0prFoSUmeRUs=@protonmail.com>
Message-ID: <woFxDfVHc0Od_GjeuU7FXoYnIQLk-xBx3z68nryT6PQhBNKYRh3pdV3OEiw4vFKe2TGbbOmdDmxUAC4g80vfx3KRadk5_N0t3pSdS07cnPY=@protonmail.com>

Good morning Sjors, sorry everyone for the double-posting...

> I believe this is the "hash to a point" technique.
>
> The scalar behind the above point cannot be known, unless either the hash function is broken, or ECDLP is broken.
> (perhaps a better cryptographer can give the proper qualifications, any corrections, and etc etc)
>
> As the point is just an arbitrary point on the curve, it is unknown to the rest of the world whether somebody knows the scalar, or nobody knows.

Now that I think further, everyone can use *the same* point generated from an arbitrary "hash to a point".
For example, we can define the "script-only point" as the point whose X coordinate (or is it Y...) is equal to SHA256("Pieter Wuille is really great!").
Add more "really " until we get a point on the curve.

Provided everyone knows what the exact data to hash is, and the exact hash function, the above procedure is sufficient for everybody to verify that Pieter Wuille (and anyone else for that matter) cannot, in fact, spend the coin unilaterally, and that nobody can actually spend the coin, except via a script.

Since the point on the output is tweaked by the script merkle tree root, varying your pubkey for each use will be enough to blind the use of the "script-only point" until you have to reveal it during spending anyway.
If you *absolutely* insist on reusing your pubkeys, then adding a `OP_PUSH(<salt>) OP_DROP` to at least one script, with a random salt, should be enough to blind the use of the script-only point until you have to reveal the script you want to use.
Or even just further tweak the point before using it as the taproot internal pubkey, so that not even a coin spend reveals that the "everyone agrees" branch was never actually an option.

> Or just use pubkeys given by both participants, that should be enough to ensure the "everyone agrees" branch is never taken if we write our software such that we never agree to sign with it (i.e. just get points from both sides and MuSig them; then each side can just erase the scalar generating it from memory and whatever caches exist on the system; a node might even just generate a single random point from a scalar it subsequently erases, and just use some non-hardened derivation path from that for every HTLC it has to make).
> This technique is "sufficiently provably unknown" since each participant knows that it deliberately erased the only means of knowing the complete discrete log by erasing its share.
> In short, "everyone agrees" is trivially easy to make "nobody can agree" by a single participant never agreeing to let itself be ripped off.
>

The "taproot assumption" is that there exists some finite set of participants that is interested in how the coin will be spent.
Under the taproot assumption then, any "truster" that assigns time-limited control of a coin to a "trustee" is part of that finite set interested in the coin spend conditions.
So the truster should in fact be asked for a pubkey to be added in the taproot internal pubkey that enables the "everyone agrees" branch.
Then the truster can simply generate a point without knowing its private key, or by forgetting this private key.

If one is sufficiently schizophrenic, one can split oneself into a "truster" and "trustee" as above and deliberately forget the truster private key.
Then one is sufficiently unable to spend under duress by deleting the "truster" sub-agent and providing real-world access to the "trustee" sub-agent that can only spend under specific SCRIPT-defined conditions.

(the above paragraph should not be taken to mean that I am an agent-based AI)

That is, it should be enough for everyone to agree to lock the "everyone agrees" branch and throw away their own key, to keep that branch locked.

Regards,
ZmnSCPxj

From luke at dashjr.org  Wed May  8 13:10:17 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 8 May 2019 13:10:17 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <201905062017.11396.luke@dashjr.org>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
Message-ID: <201905081310.20205.luke@dashjr.org>

On Monday 06 May 2019 20:17:09 Luke Dashjr via bitcoin-dev wrote:
> Some way to sign an additional script (not committed to by the witness
> program) seems like it could be a trivial addition.

This would be especially useful for things like OP_CHECKBLOCKATHEIGHT:

https://github.com/bitcoin/bips/blob/master/bip-0115.mediawiki

From jan.matejek at satoshilabs.com  Wed May  8 07:54:53 2019
From: jan.matejek at satoshilabs.com (jan matejek)
Date: Wed, 8 May 2019 09:54:53 +0200
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more
 secure
In-Reply-To: <20190507184034.0a72a9c7@simplexum.com>
References: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
	<20190503132945.GR810@coinkite.com>
	<CACL8y1tesev2OLrkfYfvmkgbR2xuk-0JPqdmYGtrUcser9GPfg@mail.gmail.com>
	<20190507184034.0a72a9c7@simplexum.com>
Message-ID: <9e85b47c-6ba9-ab85-03f1-eb0ddf3022de@satoshilabs.com>

hello,

On 07. 05. 19 15:40, Dmitry Petukhov via bitcoin-dev wrote:
> At the setup phase, hardware wallet can sign a message that consists of
> xpubs of participants, and some auxiliary text. It can use the key
> derived from the master key, with path chosen specifically for this
> purpose.

This seems overly complicated.

What is your threat model?

IIUC, each individual multisig signature also signs the set of signers
(through signing redeem-script (or scriptPubKey in address-based multisig))
So if an attacker gives me bad xpubs, i will sign them, but the
signature won't be valid for the given multisig output - even if the
attacker manages to trick 2 of 3 signers and recombine their signatures.

Therefore, the input==output check is sufficient: if I use the same set
of signers for an input and an output, I can be sure that the change
goes to the same multisig wallet.

Or is there something I'm missing?

The weak spot is the part where you generate receiving address, because
that "creates" the particular multisig wallet. But that's nothing to do
with PSBT.

> This would allow to distinguish the trusted output even if the inputs
> are not all derived from the same set of xpubs, that could happen in
> more complex scenarios (batching, key rotation, etc.), and can possibly
> be used to have several different types of 'trusted' outputs.

This seems to be an attempt at a different, much broader problem. And it
won't help if the attacker can replay a different trusted-xpub package
(e.g., one that contains a revoked previously compromised key).

regards
m.

From dp at simplexum.com  Thu May  9 17:08:47 2019
From: dp at simplexum.com (Dmitry Petukhov)
Date: Thu, 9 May 2019 22:08:47 +0500
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more
 secure
In-Reply-To: <9e85b47c-6ba9-ab85-03f1-eb0ddf3022de@satoshilabs.com>
References: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>
	<20190503132945.GR810@coinkite.com>
	<CACL8y1tesev2OLrkfYfvmkgbR2xuk-0JPqdmYGtrUcser9GPfg@mail.gmail.com>
	<20190507184034.0a72a9c7@simplexum.com>
	<9e85b47c-6ba9-ab85-03f1-eb0ddf3022de@satoshilabs.com>
Message-ID: <20190509220847.11ff9c33@simplexum.com>


> Therefore, the input==output check is sufficient: if I use the same
> set of signers for an input and an output, I can be sure that the
> change goes to the same multisig wallet.

This is sufficient, in a simple case.

I consider cases where spending from different wallets ('wallet
compartments') can be aggregated into one transaction, for efficiency
and convenience in certain circumstances. (ex: legacy addresses that
cannot be abandoned due to users still sending to them, but managing
them separately is inconvenient; wallet 'compartments' that each have
different multisig policies and spending priorities, and change would
go to most secure compartment used, etc.)

This is most likely a 'borader problem', as you said, but this is just
what my code already does, although with stateful signers that
store trusted xpubs. I had an idea how to apply this to stateless hw
wallets, and shared it.

> > This would allow to distinguish the trusted output even if the
> > inputs are not all derived from the same set of xpubs, that could
> > happen in more complex scenarios (batching, key rotation, etc.),
> > and can possibly be used to have several different types of
> > 'trusted' outputs.
> 
> This seems to be an attempt at a different, much broader problem. And
> it won't help if the attacker can replay a different trusted-xpub
> package (e.g., one that contains a revoked previously compromised
> key).

The auxiliary text can be constructed to include some code word that
would mark 'epoch' of the package, and will be displayed prominently.
Upon compromise, new trusted-xpub packages would use different 'epoch'
code word. This is one method to make it stateless (stateful way would
be to just have a counter inside hw wallet and check package version
against it).

From jl2012 at xbt.hk  Thu May  9 16:56:57 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 10 May 2019 00:56:57 +0800
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <sujR-1TPC3DI-bNyQD2U5c5E0qkkfi6WezKQOfB9YgP7UbLj3x-maV0ooIqvJ4C2V_yjkrq78F7QqIZ5LyoZuSKcpC08RFWapH2k-FF3_zc=@protonmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
	<sujR-1TPC3DI-bNyQD2U5c5E0qkkfi6WezKQOfB9YgP7UbLj3x-maV0ooIqvJ4C2V_yjkrq78F7QqIZ5LyoZuSKcpC08RFWapH2k-FF3_zc=@protonmail.com>
Message-ID: <DBADD452-6DAE-46D4-9511-69F8EAA02FFB@xbt.hk>



> 
>> 
>> Some way to sign an additional script (not committed to by the witness
>> program) seems like it could be a trivial addition.
> 
> It seems to me the annex can be used for this, by having it contain both the script and the signature somehow concatenated.

This is not possible since the whole annex is signed. It is possible if the signed ?script? does not require further input, like per-input lock-time, relative lock-time, check block hash


> 
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ZmnSCPxj at protonmail.com  Fri May 10 05:38:52 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 10 May 2019 05:38:52 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <DBADD452-6DAE-46D4-9511-69F8EAA02FFB@xbt.hk>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
	<sujR-1TPC3DI-bNyQD2U5c5E0qkkfi6WezKQOfB9YgP7UbLj3x-maV0ooIqvJ4C2V_yjkrq78F7QqIZ5LyoZuSKcpC08RFWapH2k-FF3_zc=@protonmail.com>
	<DBADD452-6DAE-46D4-9511-69F8EAA02FFB@xbt.hk>
Message-ID: <-3ac1EW7T8KOkUw6DK2Ejq83DiawO15bwaZJ79kw1U81w6sPCCkS2pAcTXtmLr8eOkohU7T8JJbW0K8dj690UYC9ffIqAqzP8e7fjbOqG70=@protonmail.com>

Good morning Johnson,


> > > Some way to sign an additional script (not committed to by the witness
> > > program) seems like it could be a trivial addition.
> >
> > It seems to me the annex can be used for this, by having it contain both the script and the signature somehow concatenated.
>
> This is not possible since the whole annex is signed. It is possible if the signed ?script? does not require further input, like per-input lock-time, relative lock-time, check block hash

I understand, you are correct.

Possibly the correct way would be to use another leaf version.
The "script" of such a new leaf version would not actually be a script, but a delegation key.
Then for this leaf version the actual script and signature from the delegation key attesting that script would be on top of the witness stack that will be used by the actual script.
This has the nice property that the existence of a delegation key is hidden from the output, and that if an alternate script is in the MAST (as an alternative to the delegation), use of that alternate script does not reveal that delegation could have been possible.

Regards,
ZmnSCPxj



From aj at erisian.com.au  Fri May 10 20:38:04 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 11 May 2019 06:38:04 +1000
Subject: [bitcoin-dev] SIGHASH_ANYPREVOUT proposal
Message-ID: <20190510203804.554q333lw3l7qql4@erisian.com.au>

Hi everybody!

Here is a followup BIP draft that enables SIGHASH_ANYPREVOUT and
SIGHASH_ANYPREVOUTANYSCRIPT on top of taproot/tapscript. (This is NOINPUT,
despite the name change)

I don't think we are (or should be) as confident that ANYPREVOUT is
ready for implementation and deployment as we are that taproot is.
In particular, we were still coming up with surprising ways that these
style of signatures could maybe cause problems over the past few months,
despite "NOINPUT" having been around for years, and having been thinking
seriously about it for most of the last year. In comparison we've had
a roughed out security proof for taproot [0] for over a year now.

So far, the best approach (in my opinion) that we've come up with to
limit the possible negative impacts of these types of signatures is to
require an additional regular signature to accompany every ANYPREVOUT
signature. As such, it's included in the BIP draft.

In theory this ensures that no ANYPREVOUT tx can cause any more problems
than some existing tx could; but in practice this assumes that the private
key for that signature is maintained in a similar way to the private keys
currently securing transactions are. After passing this around privately,
I'm not convinced the theory will survive meeting adversarial reality,
in which case I don't think this draft will be suitable for adoption.

But maybe I'm too pessimistic, or maybe we can come up with either
a proof that ANYPREVOUT is already safe without any other measures,
or maybe we can come up with some better measures to ensure it's safe.
So in any case I'm still hopeful that publishing the best we've got is
helpful, even if that still isn't good enough.

The BIP draft can be found here:
 https://github.com/ajtowns/bips/blob/bip-anyprevout/bip-anyprevout.mediawiki

A sample implementation based on the taproot branch is here:
 https://github.com/ajtowns/bitcoin/commits/anyprevout

Some interesting features:

 * This demonstrates how to upgrade tapscript's existing CHECKSIG,
   CHECKSIGADD and CHECKSIGVERIFY opcodes for new SIGHASH methods or
   potentially a new signature scheme, a new elliptic curve or other
   public key scheme
 * This demonstrates a cheap way of using the taproot internal key
   as the public key for CHECKSIG operations in script
 * There are two variants, ANYPREVOUT and ANYPREVOUTANYSCRIPT, which
   seems helpful for eltoo
 * The BIP attempts to describe the security implications of ANYPREVOUT-style
   signatures

Cheers,
aj

[0] https://github.com/apoelstra/taproot/blob/master/main.tex


From deluciac at bu.edu  Sun May 12 01:35:38 2019
From: deluciac at bu.edu (Christopher DeLucia)
Date: Sat, 11 May 2019 21:35:38 -0400
Subject: [bitcoin-dev] IBLT & Bitcoin
Message-ID: <CAPwAn9RLT7_FpQ4PMrN9OpoPw2y0qZDiGzMYp_fMq+A8sO55GQ@mail.gmail.com>

Hi all,

While in college (2017), I produced this paper on IBLT applications and
Bitcoin that referenced some of the research done by folks like Gavin
Andresen and Rusty Russell.

This should come with a disclaimer: I have not really looked at this paper
nor Bitcoin since 2017.  Additionally, this paper was not peer reviewed; it
was just for class.

Regardless, I came across it when I was cleaning out some old docs on my
drive and figured I'd send it over to bitcoin-dev in the event it can
contribute to anything at all.

Thanks,
Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190511/44daa7ae/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: IBLT Memory Pool Paper.pdf
Type: application/pdf
Size: 522278 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190511/44daa7ae/attachment-0001.pdf>

From ZmnSCPxj at protonmail.com  Mon May 13 23:39:51 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 13 May 2019 23:39:51 +0000
Subject: [bitcoin-dev] IBLT & Bitcoin
In-Reply-To: <CAPwAn9RLT7_FpQ4PMrN9OpoPw2y0qZDiGzMYp_fMq+A8sO55GQ@mail.gmail.com>
References: <CAPwAn9RLT7_FpQ4PMrN9OpoPw2y0qZDiGzMYp_fMq+A8sO55GQ@mail.gmail.com>
Message-ID: <AuLZSDpWg-6A75Z1awd0jVhhlGyUvjARCUoXMYbL7Nlfy1E-aC7GD2RLrGcaXk33gd6mHA_tdEonPcQCdXxgHnPU7-J2SMp7OGGd_1eE8-M=@protonmail.com>

Good morning Chris,

As I understand it, the latest proposal for improved transaction relay is to use Bose-Chaudhuri-Hocquenghem codes for set reconciliation.
https://github.com/sipa/minisketch

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Sunday, May 12, 2019 9:35 AM, Christopher DeLucia via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> While in college (2017), I produced this paper on IBLT applications and Bitcoin that referenced some of the research done by folks like Gavin Andresen and Rusty Russell.?
>
> This should come with a disclaimer: I have not really looked at this paper nor Bitcoin since 2017.? Additionally, this paper was not peer reviewed; it was just for class.
>
> Regardless, I came across it when I was cleaning out some old docs on my drive and figured I'd send it over to bitcoin-dev in the event it can contribute to anything at all.
>
> Thanks,
> Chris



From wordsgalore at gmail.com  Sat May 18 17:40:16 2019
From: wordsgalore at gmail.com (Zawy)
Date: Sat, 18 May 2019 13:40:16 -0400
Subject: [bitcoin-dev] Code not following proof of security
Message-ID: <CADtTMv=H1rqfspx4=r+TDqxWVOXRO5yROzTuo0go6vtpevEJDQ@mail.gmail.com>

If MAX_FUTURE_BLOCK_TIME in chain.h is set smaller than
DEFAULT_MAX_TIME_ADJUSTMENT in timedata.h, the POW security can be
undermined by a 33% Sybil attack on the nodes. Blocks with accurate
timestamps would be rejected which allows various attacks. Code should
reflect a proof of security, so it should be coded as

DEFAULT_MAX_TIME_ADJUSTMENT = MAX_FUTURE_BLOCK_TIME / 2

(or sufficiently commented) otherwise future developers could make a
change that hurts security. "Unintended consequences due to how
disparate code interacts" is the result of code not following a proof
of security. I came across this while trying to "derive" POW security
from within Lamport's 1982 framework. The problem is that POW security
requires clock synchronization. But using median of network time for
it is a consensus mechanism that is subject to Byzantine attacks. So
POW requires an absolute bound on time (enforced by an oracle) that is
at least as stringent as  the allowed timestamp variation.  The rule
to revert to node time if network time is >70 minutes off is the real
bound that honest nodes can impose unilaterally, limiting the
potential damage of consensus (if MAX_FUTURE_BLOCK_TIME is not too
small). This fail-safe uses node operators as the oracle, who can all
approximately agree as to what time it is without asking each other. A
>50% Sybil attack on nodes fails because an honest new node joining
can unilaterally reject the chain if the current timestamp is not
realistic. Cryptonote appears to have done away with network time
without ill effect. The only other option to "the node operator is the
oracle" is to assume all internal clocks have a max drift, but this
would disconnect timestamps from real time to the extent of that drift
(if I'm reading Halpern, etc 1984 IBM correctly). I'm assuming Mike
Hearn was wrong in saying the centralization of NTP (or GPS) is
acceptable:

https://bitcointalk.org/index.php?topic=10241.msg148084#msg148084

This affects coins who reduced MAX_FUTURE_BLOCK_TIME without either
removing the time consensus mechanism or reducing the
DEFAULT_MAX_TIME_ADJUSTMENT. Many have done this in order to have
faster responding difficulty algorithms, otherwise a large
MAX_FUTURE_BLOCK_TIME allows a sizable manipulation of difficulty.
Therefore, MAX_FUTURE_BLOCK_TIME should itself should be a function of
the size of the difficulty window for proof of security (instead of a
constant). I suspect more constants = less proof of security. For
example
MFBT = WindowTimespan / 10 would limit timestamp manipulation to 10% per window.

From ZmnSCPxj at protonmail.com  Sat May 18 17:51:16 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 18 May 2019 17:51:16 +0000
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAPg+sBjqgyu=Do-8P=7Q1S3tehr30K58=o_SokAE7H_SP-pf8g@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<201905062017.11396.luke@dashjr.org>
	<34827F16-9061-4317-B91F-250734850EE6@sprovoost.nl>
	<CAPg+sBjqgyu=Do-8P=7Q1S3tehr30K58=o_SokAE7H_SP-pf8g@mail.gmail.com>
Message-ID: <wsHT3V-IhjJLoWYTdS1MHucmq64qr_uUnYruU-mANVEMackqpTdulxCRV_w92zaXlfRvBrL8Dll3wu4g4H-GDp3Rqjv9RhM3yaEk_xXFs4g=@protonmail.com>

Good morning list,


> > Can this "unknown discrete logarithm" be made provably unknown, so all signers are assured of this property? Bonus points if the outside world can't tell. The exact mechanism could be outside the scope of the BIP, but knowing that it's possible is useful.
>
> Yes, that's a TODO that's left in the draft, but this is absolutely
> possible (using a hash-to-curve operation). As ZmnSCPxj already
> suggested, there can even be a fixed known constant you can use for
> this. However, you get better privacy by taking this fixed known
> constant (call it C) and using as internal key a blinded version of it
> (C+rG, for some random value r, and G the normal secp256k1 generator);
> as long as the DL between G and C is unknown, this is safe (and does
> not reveal to the world that in fact no key-path was permitted when
> spending).

Gregory Maxwell commented some days ago:

> 2019-05-11T23:35:02  <gmaxwell> sipa: also someone might want to point out to ZmnSCPxj  that his scheme for getting a NUMS point is insecure (it must also commit to G because we don't know how G was generated)

I am assuming that gmax is referring to my description of the "hash-to-point" or "hash-to-curve" operation.

A little more research shows this: https://crypto.stackexchange.com/a/25603

>From the above, it seems the method that real cryptographers use is:

1.  Generate some random data d.
2.  Get x = h(G | d) where G is the existing generator for secp256k1.
3.  Find a point on secp256k1 with X coordinate x.
4.  If not found, go to 1.

In any case, I am almost sure that for every case where the "everyone agrees" path is unwanted in a taproot address, the simple "put your own pubkey lock on the door and throw away the privkey" technique would work without requiring a NUMS point: the same taproot assumption should also work here.
But generation of a NUMS point might be of independent interest in any case (e.g. setting up Pedersen commitments).

Regards,
ZmnSCPxj

From jlrubin at mit.edu  Mon May 20 20:58:03 2019
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 20 May 2019 13:58:03 -0700
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
Message-ID: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>

Hello bitcoin-devs,

Below is a link to a BIP Draft for a new opcode, OP_CHECKOUTPUTSHASHVERIFY.
This opcode enables an easy-to-use trustless congestion control techniques
via a rudimentary, limited form of covenant which does not bear the same
technical and social risks of prior covenant designs.

Congestion control allows Bitcoin users to confirm payments to many users
in a single transaction without creating the UTXO on-chain until a later
time. This therefore improves the throughput of confirmed payments, at the
expense of latency on spendability and increased average block space
utilization. The BIP covers this use case in detail, and a few other use
cases lightly.

The BIP draft is here:
https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki

The BIP proposes to deploy the change simultaneously with Taproot as an
OPSUCCESS, but it could be deployed separately if needed.

An initial reference implementation of the consensus changes and  tests
which demonstrate how to use it for basic congestion control is available
at https://github.com/JeremyRubin/bitcoin/tree/congestion-control.  The
changes are about 74 lines of code on top of sipa's Taproot reference
implementation.

Best regards,

Jeremy Rubin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190520/63c29c81/attachment.html>

From roconnor at blockstream.io  Tue May 21 17:20:32 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 21 May 2019 13:20:32 -0400
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
Message-ID: <CAMZUoKkm33U+Rb+x03qUsFDG5CeX2C=nW8vD_8zbiAdsWazofQ@mail.gmail.com>

Regarding Tapscript, the specification calls for the final value of the
stack being a single non-false value:

The tapscript is executed according to the rules in the following section,
> with the initial stack as input
>     II. If the execution results in anything but exactly one element on
> the stack which evaluates to true with CastToBool(), fail.
>

Perhaps it is worth taking this opportunity here to remove a minor wart of
the Script language and instead require the stack to be exactly empty upon
completion.

In addition to removing a potential malleability vector, I expect it would
simplify development of Bitcoin Script.  A rule requiring an empty stack
means that the conjunction (logical and) of two policies can be implemented
by the simple concatenation of Bitcoin Scripts.  This combined with the
taproot ability to form the disjunction (logical or) of policies by having
multiple Merkle branches, means that the translation of a policy written in
disjunctive normal form (the logical ors of logical ands of primitive
policies) can be straightforwardly translated to a taproot of tapscript.

That said, I think the developers of miniscript <
http://bitcoin.sipa.be/miniscript/miniscript.html> are in a much better
position to comment on whether my above intuition is correct given that
they've had to implement a host of various calling conventions.  I
understand that at least some of this complexity is due to Bitcoin Script's
one element stack rule.

Scripts under the old one element rule can be translated to the new rule by
adding an OP_VERIFY operation to the end of the script; however it is
likely that this OP_VERIFY can be folded into the previous operation
yielding an OP_EQUALVERIFY or OP_CHECKSIGVERIFY in many cases.

Even if we choose not to implement the empty stack rule, we should at least
require that the last element be 0x01 to remove a potential malleability
vector and bring it in line with MINIMAL_IF semantics.

Thanks.

On Mon, May 6, 2019 at 2:36 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> Here are two BIP drafts that specify a proposal for a Taproot
> softfork. A number of ideas are included:
>
> * Taproot to make all outputs and cooperative spends indistinguishable
> from eachother.
> * Merkle branches to hide the unexecuted branches in scripts.
> * Schnorr signatures enable wallet software to use key
> aggregation/thresholds within one input.
> * Improvements to the signature hashing algorithm (including signing
> all input amounts).
> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support
> batch validation.
> * Tagged hashing for domain separation (avoiding issues like
> CVE-2012-2459 in Merkle trees).
> * Extensibility through leaf versions, OP_SUCCESS opcodes, and
> upgradable pubkey types.
>
> The BIP drafts can be found here:
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki
> specifies the transaction input spending rules.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki
> specifies the changes to Script inside such spends.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> is the Schnorr signature proposal that was discussed earlier on this
> list (See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html
> )
>
> An initial reference implementation of the consensus changes, plus
> preliminary construction/signing tests in the Python framework can be
> found on https://github.com/sipa/bitcoin/commits/taproot. All
> together, excluding the Schnorr signature module in libsecp256k1, the
> consensus changes are around 520 LoC.
>
> While many other ideas exist, not everything is incorporated. This
> includes several ideas that can be implemented separately without loss
> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,
> which we're working on as an independent proposal.
>
> The document explains basic wallet operations, such as constructing
> outputs and signing. However, a wide variety of more complex
> constructions exist. Standardizing these is useful, but out of scope
> for now. It is likely also desirable to define extensions to PSBT
> (BIP174) for interacting with Taproot. That too is not included here.
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190521/d6d438b1/attachment.html>

From lf-lists at mattcorallo.com  Tue May 21 19:41:22 2019
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 21 May 2019 19:41:22 +0000
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
 proposal
In-Reply-To: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
Message-ID: <80353196-0f32-0e7b-d048-bd870e30029c@mattcorallo.com>

If we're going to do covenants (and I think we should), then I think we
need to have a flexible solution that provides more features than just
this, or we risk adding it only to go through all the effort again when
people ask for a better solution.

Matt

On 5/20/19 8:58 PM, Jeremy via bitcoin-dev wrote:
> Hello bitcoin-devs,
> 
> Below is a link to a BIP Draft for a new opcode,
> OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless
> congestion control techniques via a rudimentary, limited form of
> covenant which does not bear the same technical and social risks of
> prior covenant designs.
> 
> Congestion control allows Bitcoin users to confirm payments to many
> users in a single transaction without creating the UTXO on-chain until a
> later time. This therefore improves the throughput of confirmed
> payments, at the expense of latency on spendability and increased
> average block space utilization. The BIP covers this use case in detail,
> and a few other use cases lightly.
> 
> The BIP draft is here:
> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki
> 
> The BIP proposes to deploy the change simultaneously with Taproot as an
> OPSUCCESS, but it could be deployed separately if needed.
> 
> An initial reference implementation of the consensus changes and? tests
> which demonstrate how to use it for basic congestion control is
> available at
> https://github.com/JeremyRubin/bitcoin/tree/congestion-control.? The
> changes are about 74 lines of code on top of sipa's Taproot reference
> implementation.
> 
> Best regards,
> 
> Jeremy Rubin
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From jlrubin at mit.edu  Wed May 22 01:47:11 2019
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 21 May 2019 18:47:11 -0700
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <80353196-0f32-0e7b-d048-bd870e30029c@mattcorallo.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<80353196-0f32-0e7b-d048-bd870e30029c@mattcorallo.com>
Message-ID: <CAD5xwhh4McBah1yr0X5sDyto+0Q8XVOzg7Jq9Z=rXRyoS=n6gg@mail.gmail.com>

I agree a little bit, but I think that logic is somewhat infectious. If
we're going to do covenants, we should also do it as a part of a more
comprehensive new scripting system that gives us other strong benefits for
our ability to template scripts. And so on. I'm excited to see what's
possible!

Given that this is very simple to implement and has obvious deployable big
wins with few controversial drawbacks, it makes more sense to streamline
adoption of something like this for now and work on a more comprehensive
solution without urgency.

The design is also explicitly versioned so short of an eventual full
redesign it should be easy enough to add more flexible features piecemeal
as they come up and their use cases are strongly justified as I have shown
here for certified post dated utxo creation.

Lastly I think that while these are classifiable as covenants in
implementation, they are closer in use to multisig pre-signed scripts,
without the requirement of interactive setup. We should think of these as
'certified checks' instead, which can also describe a pre-signed design
satisfactorily. With true covenants we don't want require the satisfying
conditions to be 'computationally enumerable' (e.g. we can't in
computational limits enumerate all public keys if the covenant expresses a
spend must be to a public key). And if the covenant is computationally
enumerable, then we should use this construct and put the spending paths
into a Huffman encoded taproot tree.

On Tue, May 21, 2019, 12:41 PM Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> If we're going to do covenants (and I think we should), then I think we
> need to have a flexible solution that provides more features than just
> this, or we risk adding it only to go through all the effort again when
> people ask for a better solution.
>
> Matt
>
> On 5/20/19 8:58 PM, Jeremy via bitcoin-dev wrote:
> > Hello bitcoin-devs,
> >
> > Below is a link to a BIP Draft for a new opcode,
> > OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless
> > congestion control techniques via a rudimentary, limited form of
> > covenant which does not bear the same technical and social risks of
> > prior covenant designs.
> >
> > Congestion control allows Bitcoin users to confirm payments to many
> > users in a single transaction without creating the UTXO on-chain until a
> > later time. This therefore improves the throughput of confirmed
> > payments, at the expense of latency on spendability and increased
> > average block space utilization. The BIP covers this use case in detail,
> > and a few other use cases lightly.
> >
> > The BIP draft is here:
> >
> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki
> >
> > The BIP proposes to deploy the change simultaneously with Taproot as an
> > OPSUCCESS, but it could be deployed separately if needed.
> >
> > An initial reference implementation of the consensus changes and  tests
> > which demonstrate how to use it for basic congestion control is
> > available at
> > https://github.com/JeremyRubin/bitcoin/tree/congestion-control.  The
> > changes are about 74 lines of code on top of sipa's Taproot reference
> > implementation.
> >
> > Best regards,
> >
> > Jeremy Rubin
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190521/618bcea2/attachment-0001.html>

From rusty at rustcorp.com.au  Wed May 22 02:47:31 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Wed, 22 May 2019 12:17:31 +0930
Subject: [bitcoin-dev] SIGHASH_ANYPREVOUT proposal
In-Reply-To: <20190510203804.554q333lw3l7qql4@erisian.com.au>
References: <20190510203804.554q333lw3l7qql4@erisian.com.au>
Message-ID: <87d0kbkxx8.fsf@rustcorp.com.au>

Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:

> Hi everybody!
>
> Here is a followup BIP draft that enables SIGHASH_ANYPREVOUT and
> SIGHASH_ANYPREVOUTANYSCRIPT on top of taproot/tapscript. (This is NOINPUT,
> despite the name change)

I really like this proposal, and am impressed with how cleanly it
separated from taproot/tapscript.

I believe the chaparone signature requirement should be eliminated: I am
aware of four suggested benefits, which I don't believe are addressed
adaquately enough by chaparones to justify enshrining this complexity
into the protocol.

1. "These features could be used dangerously, and chaparone signatures make
   them harder to use, thus less likely to be adopted by random wallet
   authors."

   This change is already hard to implement, even once you're on v1
   segwit; you can't just use it with existing outputs.  I prefer to
   change the bip introduction to expliclty shout "THESE SIGNATURE
   HASHES ARE UNSAFE FOR NORMAL WALLET USAGE.", and maybe rename it
   SIGHASH_UNSAFE_ANYPREVOUT.

2. "Accidental key reuse can make this unsafe."

   This is true, but chaparones don't seem to help.  The main purpose of
   ANYPREV is where you can't re-sign; in particular, in lightning you
   are co-signing with an untrusted party up-front.  So you have to
   share the chaparone privkeys with one untrusted party.

   The BIP says "SHOULD limit the distribution of those private keys".
   That seems ridiculously optimistic: don't tell the secret to more
   than *one* untrusted party?

   In fact, lightning will also need to hand chaparone keys to
   watchtowers, so we'll probably end up using some fixed known secret.

3. "Miners can reorg and invalidate downstream txs".

   There's a principle (ISTR reading it years ago from Greg Maxwell?)
   that if no spender is malicious, a transaction should generally not
   become invalid.  With ANYPREV, a miner could reattach a transaction
   during a reorg, changing its txid and invalidating normal spends from
   it.

   In practice, I believe this principle will remain just as generally
   true with ANYPREV:

   1. For lightning the locktime will be fairly high before these txs are
      generally spendable.
   2. Doing this would require special software, since I don't see bitcoin
      core indexing outputs to enable this kind of rewriting.
   3. We already added such a common possibility with RBF, but before I
      brought it up I don't believe anyone realized.  We certainly
      haven't seen any problems in practice, for similar practical
      reasons.

4. "Rebinding is a new power in bitcoin, and it makes me uncomfortable".

   I have a degree of sympathy for this view, but objections must be
   backed in facts.  If we don't understand it well enough, we should
   not do it.  If we do understand it, we should be able to point out
   real problems.

Finally, it seems to me that chaparones can be opt-in, and don't need to
burden the protocol.

Cheers,
Rusty.

From ZmnSCPxj at protonmail.com  Wed May 22 02:51:52 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 22 May 2019 02:51:52 +0000
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
Message-ID: <VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>

Good morning Jeremy,

>If a sender needs to know the recipient can remove the covenant before spending, they may request a signature of an challenge string from the recipients

The recipients can always choose to destroy the privkey after providing the above signature.
Indeed, the recipients can always insist on not cooperating to sign using the taproot branch and thus force spending via the `OP_CHECKOUTPUTSHASHVERIFY`.

Regards,
ZmnSCPxj

From jlrubin at mit.edu  Wed May 22 05:11:55 2019
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 21 May 2019 22:11:55 -0700
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
Message-ID: <CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>

Morning,

Yes, in general, Bitcoin does not do anything to prevent users from
discarding their keys.

I don't think this will be fixed anytime soon.

There are some protocols where, though, knowing that a key was once known
to the recipients may make it legally valid to inflict a punitive measure
(e.g., via HTLC), whereas if the key was never known that might be a breach
of contract for the payment provider.

Best,

Jeremy

On Tue, May 21, 2019 at 7:52 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Jeremy,
>
> >If a sender needs to know the recipient can remove the covenant before
> spending, they may request a signature of an challenge string from the
> recipients
>
> The recipients can always choose to destroy the privkey after providing
> the above signature.
> Indeed, the recipients can always insist on not cooperating to sign using
> the taproot branch and thus force spending via the
> `OP_CHECKOUTPUTSHASHVERIFY`.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190521/90cc48e6/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Wed May 22 06:04:27 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 22 May 2019 06:04:27 +0000
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
	<CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
Message-ID: <CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>

Good morning,

Some more comments.

* I do not think CoinJoin is much improved by this opcode.
  Typically, you would sign off only if one of the outputs of the CoinJoin transaction is yours, and this does not really improve this situation.
* Using this for congestion control increases blockchain usage by one TXO and one input, ending up with *more* bytes onchain, and a UTXO that will be removed later in (we hope) short time.
  I do not know if this is a good idea, to increase congestion by making unnecessary intermediate transaction outputs, at times when congestion is a problem.
* I cannot find a way to implement Decker-Russell-Osuntokun (or any offchain update mechanism) on top of this opcode, so I cannot support replacing `SIGHASH_NOINPUT` with this opcode.
  In particular, while the finite loop support by this opcode appears (at first glance) to be useable as the "stepper" for an offchain update mechanism, I cannot find a good way to short-circuit the transaction chain without `SIGHASH_NOINPUT` anyway.
* Channel factories created by this opcode do not, by themselves, support updates to the channel structure.
  But such simple "close only" channel factories can be done using n-of-n and a pre-signed offchain transaction (especially since the entities interested in the factory are known and enumerable, and thus can be induced to sign in order to enter the factory).
  More complex channel factories that can update the division of the factory to channels cannot be done without a multiparty offchain update mechanism such as Decker-Wattenhofer or Decker-Russell-Osuntokun.
  So, similarly to CoinJoin, I do not think it is much improved by this opcode.

Regards,
ZmnSCPxj

Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Wednesday, May 22, 2019 1:11 PM, Jeremy <jlrubin at mit.edu> wrote:

> Morning,
>
> Yes, in general, Bitcoin does not do anything to prevent users from discarding their keys.
>
> I don't think this will be fixed anytime soon.
>
> There are some protocols where, though, knowing that a key was once known to the recipients may make it legally valid to inflict a punitive measure (e.g., via HTLC), whereas if the key was never known that might be a breach of contract for the payment provider.
>
> Best,
>
> Jeremy
>
> On Tue, May 21, 2019 at 7:52 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> > Good morning Jeremy,
> >
> > >If a sender needs to know the recipient can remove the covenant before spending, they may request a signature of an challenge string from the recipients
> >
> > The recipients can always choose to destroy the privkey after providing the above signature.
> > Indeed, the recipients can always insist on not cooperating to sign using the taproot branch and thus force spending via the `OP_CHECKOUTPUTSHASHVERIFY`.
> >
> > Regards,
> > ZmnSCPxj



From jlrubin at mit.edu  Wed May 22 08:10:23 2019
From: jlrubin at mit.edu (Jeremy)
Date: Wed, 22 May 2019 01:10:23 -0700
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
	<CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
	<CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
Message-ID: <CAD5xwhiHHemzaRLC7WMeXQ5hgu0rwMKMUym34xTxWO81qqf-oQ@mail.gmail.com>

> * I do not think CoinJoin is much improved by this opcode.
>   Typically, you would sign off only if one of the outputs of the
CoinJoin transaction is yours, and this does not really improve this
situation.

Coinjoin benefits a lot I think.


Coinjoin is improved because you can fit more users into the protocol and
create many more outputs at lower cost or include more participants.
Ideally a coinjoin creates a lot of outputs so that the ownership is
smeared more, but this has a cost at the time of the coinjoin.

Coinjoin is also improved because you don't reveal the outputs created by
the coinjoin until some time, perhaps very far in the future, when you need
the coin. In fact, you only need to reveal where you're moving the coins to
participants in your subtree because participants need only verify their
branch.

It also makes the protocol more stable with respect to input choice. This
is because, similar to how NOINPUT may work, OP_COSHV outputs are spendable
without knowing what the TXID will be. Therefore if someone changes their
input or non segwit spend script, it won't break the presigned txns. This
also means that all the inputs can be ANYONECANPAY, so there is no need to
reveal your inputs before anyone else.

This culminates in being able to open channels from a coinjoin safely, I
believe this is difficult/impossible to do currently.




> * Using this for congestion control increases blockchain usage by one TXO
and one input, ending up with *more* bytes onchain, and a UTXO that will be
removed later in (we hope) short time.
>   I do not know if this is a good idea, to increase congestion by making
unnecessary intermediate transaction outputs, at times when congestion is a
problem.

This is a good idea because it improves QoS for most users.

For receiving money pending spendable but confirmed payment (i.e. certified
checks) is superior to having unconfirmed funds.

For sending money, being able to clear all liabilities in a single txn
decreases business exposure to fee variance and confirmation time variance.
E.g., if I'm doing payroll in Bitcoin I will pay big fines if I am a day
late. If I have 10,000 employees this might be painful if fees are
currently up.

It also helps to have a backlog of low priority txns to support the fee
market.

Overall block bandwidth utilization is fairly spikey, so having long term
well known outputs that are not time sensitive can be used to better
utilize bandwidth.

The total extra bandwidth btw is really small given the expansion factor
optimizations available.


> * I cannot find a way to implement Decker-Russell-Osuntokun (or any
offchain update mechanism) on top of this opcode, so I cannot support
replacing `SIGHASH_NOINPUT` with this opcode.
>   In particular, while the finite loop support by this opcode appears (at
first glance) to be useable as the "stepper" for an offchain update
mechanism, I cannot find a good way to short-circuit the transaction chain
without `SIGHASH_NOINPUT` anyway.

I'm not deeply familiar with DRO channels. This opcode isn't a replacement
for SIGHASH_NOINPUT -- SIGHASH_NOINPUT is mentioned merely to contrast
using SIGHASH_NOINPUT for the uses presented in this BIP.

Lastly there's no 'replacing'. Neither NOINPUT nor COSHV are accepted by
the community at large yet, and they do different things.


> * Channel factories created by this opcode do not, by themselves, support
updates to the channel structure.
>   But such simple "close only" channel factories can be done using n-of-n
and a pre-signed offchain transaction (especially since the entities
interested in the factory are known and enumerable, and thus can be induced
to sign in order to enter the factory).

I'm not really an expert at Bitcoin Lightning, but this basic mechanism
should work.

Imagine the script at a leaf node:

Taproot([Alice, Bob], [OP_COSHV <H(H(2 coins to uncooperative script))>]
where uncooperative script is:

Taproot([Alice, Bob], ["1 week" CHECKSEQUENCEVERIFY DROP OP_COSHV <H(H(Pay
alice 2 coins))>)

Cooperative closing skips the extra transactions. Updates are signed
against the uncooperative script with repudation. E.g.:

    HASH160 <revokehash> EQUAL
    IF
        <Bob's pubkey>
    ELSE
        "1 week" CHECKSEQUENCEVERIFY DROP
        <Alice's pubkey>
    ENDIF
    CHECKSIG

It can even be optimized by letting the uncooperative script branches in
the leaf be blaming Alice or Bob.

Does that not work?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/671f372d/attachment.html>

From john at johnnewbery.com  Wed May 22 14:14:44 2019
From: john at johnnewbery.com (John Newbery)
Date: Wed, 22 May 2019 10:14:44 -0400
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
Message-ID: <CAFmfg2tV+_M2_HD-GO1jbnufSLAW+K36LCXRNL9R_-0FPpNQVA@mail.gmail.com>

Hi,

> A Taproot output is a SegWit output [...]  with
> version number 1, and a 33-byte witness program whose first byte is 0 or
1.

Given a secret key k and public key P=(x,y), a signer with the knowledge of
k
can sign for -P=(x,p-y) since -k is the secret key for that point. Encoding
the
y value of the public key therefore adds no security. As an alternative to
providing the y value of the taproot output key Q when constructing the
taproot
output, the signer can provide it when signing. We can also restrict the y
value
of the internal key P to be even (or high, or a quadratic residue). That
gives
us 4 options for how to set the y signs for P and Q.

1. Q sign is explictly set in the witness program, P sign is explicitly set
in the control block
    => witness program is 33 bytes, 32 possible leaf versions (one for each
pair of 0xc0..0xff)
2. Q sign is explictly set in the witness program, P sign is implicitly even
    => witness program is 33 bytes, 64 possible leaf versions (one for each
0xc0..0xff)
3. Q sign is explictly set in the control block, P sign is explicitly set
in the control block
    => witness program is 32 bytes, 16 possible leaf versions (one for each
4-tuple of 0xc0..0xff)
4. Q sign is explictly set in the control block, P sign is implicitly even
    => witness program is 32 bytes, 32 possible leaf versions (one for pair
of 0xc0..0xff)

The current proposal uses (1). Using (3) or (4) would reduce the size of a
taproot output by one byte to be the same size as a P2WSH output. That means
that it's not more expensive for senders compared to sending to P2WSH.

(Credit to James Chiang for suggesting omitting the y sign from the public
key and
to sipa for pointing out the 4 options above)

> (native or P2SH-nested, see BIP141)

I'd prefer to not support P2SH-nested TR. P2SH wrapping was useful for
segwit
v0 for compatibility reasons. Most wallets/exchanges/services now support
sending
to native segwit addresses (https://en.bitcoin.it/wiki/Bech32_adoption) and
that
will be even more true if Schnorr/Taproot activate in 12+ months time.

On Mon, May 6, 2019 at 2:36 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> Here are two BIP drafts that specify a proposal for a Taproot
> softfork. A number of ideas are included:
>
> * Taproot to make all outputs and cooperative spends indistinguishable
> from eachother.
> * Merkle branches to hide the unexecuted branches in scripts.
> * Schnorr signatures enable wallet software to use key
> aggregation/thresholds within one input.
> * Improvements to the signature hashing algorithm (including signing
> all input amounts).
> * Replacing OP_CHECKMULTISIG(VERIFY) with OP_CHECKSIGADD, to support
> batch validation.
> * Tagged hashing for domain separation (avoiding issues like
> CVE-2012-2459 in Merkle trees).
> * Extensibility through leaf versions, OP_SUCCESS opcodes, and
> upgradable pubkey types.
>
> The BIP drafts can be found here:
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-taproot.mediawiki
> specifies the transaction input spending rules.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki
> specifies the changes to Script inside such spends.
> * https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki
> is the Schnorr signature proposal that was discussed earlier on this
> list (See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html
> )
>
> An initial reference implementation of the consensus changes, plus
> preliminary construction/signing tests in the Python framework can be
> found on https://github.com/sipa/bitcoin/commits/taproot. All
> together, excluding the Schnorr signature module in libsecp256k1, the
> consensus changes are around 520 LoC.
>
> While many other ideas exist, not everything is incorporated. This
> includes several ideas that can be implemented separately without loss
> of effectiveness. One such idea is a way to integrate SIGHASH_NOINPUT,
> which we're working on as an independent proposal.
>
> The document explains basic wallet operations, such as constructing
> outputs and signing. However, a wide variety of more complex
> constructions exist. Standardizing these is useful, but out of scope
> for now. It is likely also desirable to define extensions to PSBT
> (BIP174) for interacting with Taproot. That too is not included here.
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/74fc5f35/attachment-0001.html>

From aj at erisian.com.au  Wed May 22 20:11:31 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 23 May 2019 06:11:31 +1000
Subject: [bitcoin-dev] SIGHASH_ANYPREVOUT proposal
In-Reply-To: <87d0kbkxx8.fsf@rustcorp.com.au>
References: <20190510203804.554q333lw3l7qql4@erisian.com.au>
	<87d0kbkxx8.fsf@rustcorp.com.au>
Message-ID: <20190522201131.tfbfldddvkkktcc6@erisian.com.au>

On Wed, May 22, 2019 at 12:17:31PM +0930, Rusty Russell wrote:
>    I prefer to
>    change the bip introduction to expliclty shout "THESE SIGNATURE
>    HASHES ARE UNSAFE FOR NORMAL WALLET USAGE.", and maybe rename it
>    SIGHASH_UNSAFE_ANYPREVOUT.

> 4. "Rebinding is a new power in bitcoin, and it makes me uncomfortable".
>    I have a degree of sympathy for this view, but objections must be
>    backed in facts.  If we don't understand it well enough, we should
>    not do it.

Yeah, that's where I'm at: if we think something is UNSAFE enough to
need a warning, then I think it's too unsafe to include in the consensus
layer. I would like to find a way of making ANYPREVOUT safe enough that
it doesn't need scary warnings; a week or two ago, chaperone sigs were
my best idea for that.

> Finally, it seems to me that chaparones can be opt-in, and don't need to
> burden the protocol.

Eltoo (and perhaps lightning more generally) seem like the most obvious
use case for ANYPREVOUT, so if it isn't going to opt-in (or is going
to opt-out in any way it can, as you suggest) then they're not a good
solution.

I'm not going to argue about any of that here, though I do reserve the
right to do so later. :)

So here's something I almost think is an argument that ANYPREVOUT is safe
(without chaperone sigs or output tagging, etc).

#1. I'm assuming funds are "safe" in Bitcoin if they're (a) held in
a cryptographically secured UTXO, (b) under "enough" proof of work
that a reorg is "sufficiently" unlikely. If you don't have both those
assumptions, your money is not safe in obvious ways; if you do have them
both, your money is safe.

#2. My theory is that as long as you, personally, only use ANYPREVOUT
to sign transactions that are paying the money back to yourself, your
funds will remain safe.

If you follow this rule, then other people replaying your signature is
not a problem -- the funds will just move from one of your addresses, to
a different address.

If other people *fail* to follow this rule, you might receive funds
directly authorised by an ANYPREVOUT signature. But those funds are only
secure if they're "sufficiently" buried in confirmations anyway, and
once they are, they won't disappear. You might be able to reuse that
signature against some different UTXO, but that's only to your benefit:
they lose funds after violating the rule, but you gain funds.

Eltoo naturally meets this requirement, as long as you consider "paying
to yourself" to cover both "paying to same multisig address" (for update
transactions) and "splitting funds between members of a group who owned
the funds". If you consider the "split" to be "you get 50% of our funds,
you get 20%, you get 30%", even if the signature gets replayed later
against a different utxo, the percentage split remains true it just
unexpectedly applies to more funds.

#3. Making ANYPREVOUT only available via script is aligned with this;
if you'repaying to yourself you probably want complicated rules that
you have to encode in script, and there's a mild economic incentive to
try to avoid that because the key path is cheaper.

#4. I think this covers the major security property for bitcoin (your
funds are yours to decide what to do with), but maybe there are other
ways in which ANYPREVOUT is scary that could be formalised and addressed?

#5. It's probably not compatible with luke's "malleability proof" wallet
idea [0]. Malleability is only a concern for funds that aren't already
"sufficiently" buried, and if you're only spending it to yourself that
doesn't help with burying, and if you're spending it to someone else
immediately after, doesn't help with making that transaction less
malleable. But if the line of argument above's correct, that just
recognises that a wallet like that risks losing funds if someone else
reuses its addresses; it doesn't add any systemic risk. And "wallet X
isn't safe" is a risk category we already deal with.

[0] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012463.html

Cheers,
aj


From aj at erisian.com.au  Wed May 22 20:49:11 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 23 May 2019 06:49:11 +1000
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
 proposal
In-Reply-To: <CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
	<CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
	<CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
Message-ID: <20190522204911.q4omleepjt5mpxeo@erisian.com.au>

On Wed, May 22, 2019 at 06:04:27AM +0000, ZmnSCPxj via bitcoin-dev wrote:
> * I do not think CoinJoin is much improved by this opcode.

I think (especially with cross-input sig aggregation) it makes it easier
to do a coinjoin during a high fee period -- if you're willing to wait
'til fees are lower to claim your funds you can still do that, despite
participating now.

Otherwise, I don't think it makes coordination that much easier. 

If the coinjoin groups stays around in a Layer 2-ish protocol, and
coordinates to cut-through transactions, that could be a scaling and
privacy benefit, but comes with much harder coordination problems. ie:

   A,B,C,D do a coinjoin with outputs of 1 BTC each
   tx on chain looks like:
     in: 1 A
         1 B
         1 C
         1 D
     out: 4 to muSig(A,B,C,D) or COHV(1 A, 1 B, 1 C, 1 D)

but then A wants to spend 0.2 BTC to E, and B wants to spend 0.1 BTC to
F, so they agree to update the state and publish:

     in: (above, signed by A+B+C+D)
     out: 
         0.1 F
	 0.2 E
	 3.7 to muSig(A,B,C,D) or COHV(0.8 A, 0.9 B, 1 C, 1 D)

and they continue the protocol.

> * I cannot support replacing `SIGHASH_NOINPUT` with this opcode.

(I don't think this in any way replaces ANYPREVOUT or similar)

I think lightning is improved by this in that it makes it cheaper to
create lightning channels during a high fee period. If you're creating
1000 channels you can do that via a single output with this opcode, and
then wait until either there's a low fee period to publish the funding
tx cheaply; or until the channel fails and you need to extract the funds
which always has the risk of happening during a high fee period.

You might be able to slightly simplify eltoo (or conceivably some parts of
current lightning); if your eltoo update tx has as it's output [musig(A,B)
or (n+1 cltv checksig) or (d CSV COHV(balances))] then your settlement
transaction only needs to reveal the 40B script, rather than needing a
65B ANYPREVOUT signature.

Cheers,
aj


From roconnor at blockstream.io  Wed May 22 21:01:21 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 22 May 2019 17:01:21 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
Message-ID: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>

Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and
OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for
Bitcoin via new Script operations.  However, I think that these proposals
miss the mark when it comes to how they approach Bitcoin Script and
language features.

Bitcoin Script appears designed to be a flexible programmable system that
provides generic features to be composed to achieve various purposes.
Thus, when we design new language features for Script, we should be
striving, as much as possible, to similarly build general purpose tools
which can in turn be used for a variety of purposes.

I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail
to achieve these design goals.  They are both are designed with very narrow
applications in mind, while also going out of their way to extend the
semantic domain of the interpretation of Bitcoin operations in new ways
that complicate their specification.  In the case of SIGHASH_ANYPREVOUT,
the semantic domain is extended by adding new counters to track the use of
various v0 and v2 signature types.  In the case of
OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that
peeks at the value of surrounding opcodes.

Instead, I propose that, for the time being, we simply implement OP_CAT and
OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack and
pushes their concatenation back onto the stack.  OP_CHECKSIGFROMSTACKVERIFY
pops a signature, message, and pubkey off the stack and performs a
bip-schnorr verification on the SHA256 hash of the message.

In concert, these two operations enable:

* Oracle signature verification, including discrete log contracts.
* Amortized secure multiparty computations (see "Amortizing Secure
Computation with Penalties" by Kumaresan and Bentov).
* Transaction introspection including:
+ Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by
the nature of the construction.
+ Decide if a transaction has exactly one input or not. (etc.)
+ Weak covenants, which can verify output scripts to see if they are among
a set of predefined values or verify the output hash.

and presumably more applications as well.

For better or for worse, without an OP_PUBKEYTWEEK operation available, the
more interesting recursive-covenants remain largely out of reach, with the
exception of a recursive covenant that is only able to send back to its own
address, possibly abusing its own TXO value as a state variable.

All this is accomplished by two straightforward opcodes whose semantics are
pure computational operations on stack values.  The only semantic
side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the
existing 'sigops_passed' count.  Moreover, I feel that adding these
operations does not preclude adding more specialized opcodes in the future
as an optimization for whatever popular constructions come up, once we know
what those are.

I feel that this style of generic building blocks truly embodies what is
meant by "programmable money".
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/4a09c076/attachment-0001.html>

From pieter.wuille at gmail.com  Thu May 23 02:06:42 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 22 May 2019 19:06:42 -0700
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAMZUoKkm33U+Rb+x03qUsFDG5CeX2C=nW8vD_8zbiAdsWazofQ@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<CAMZUoKkm33U+Rb+x03qUsFDG5CeX2C=nW8vD_8zbiAdsWazofQ@mail.gmail.com>
Message-ID: <CAPg+sBh=VGiBS6Cof_SBKo2aPGURicTRkuaXWwaW0_u8_nWZ1Q@mail.gmail.com>

On Tue, 21 May 2019 at 10:20, Russell O'Connor <roconnor at blockstream.io> wrote:
>
> Regarding Tapscript, the specification calls for the final value of the stack being a single non-false value:
>
>> The tapscript is executed according to the rules in the following section, with the initial stack as input
>>     II. If the execution results in anything but exactly one element on the stack which evaluates to true with CastToBool(), fail.
>
> Perhaps it is worth taking this opportunity here to remove a minor wart of the Script language and instead require the stack to be exactly empty upon completion.
>
> In addition to removing a potential malleability vector, I expect it would simplify development of Bitcoin Script.  A rule requiring an empty stack means that the conjunction (logical and) of two policies can be implemented by the simple concatenation of Bitcoin Scripts.  This combined with the taproot ability to form the disjunction (logical or) of policies by having multiple Merkle branches, means that the translation of a policy written in disjunctive normal form (the logical ors of logical ands of primitive policies) can be straightforwardly translated to a taproot of tapscript.
>
> That said, I think the developers of miniscript <http://bitcoin.sipa.be/miniscript/miniscript.html> are in a much better position to comment on whether my above intuition is correct given that they've had to implement a host of various calling conventions.  I understand that at least some of this complexity is due to Bitcoin Script's one element stack rule.

IIRC I looked into this a few months ago, and found that the spending
cost (script size + expected witness size) of the optimal script for
every Miniscript policy at most changes by 1 WU (in either direction)
by requiring an empty stack rather than a true value, though in a
(admittedly very arbitrarily biased) distribution, more policies were
improved by it than degraded. This is not taking Taproot into account
(as many of those policies in a Taproot-supporting world should
optimally make use of the internal key and Merkle tree, rather than
turning everything into a monolithic script). I expect that this may
make the impact somewhat larger, but still never more than a 1 WU
gain.

I don't think the spending cost changes justify this change, so the
remaining criteria are complexity ones. In my view, the main benefit
would be to authors of hand-written scripts where the consistency
benefits matter, but this needs to be weighed against the mental cost
of learning the new semantics. For Miniscript itself, this doesn't
make much difference - the top level calling convention would become
'V' instead of 'T', but 'T' would still exist as a calling convention
that may be used internally; it's a few lines change.

So overall this feels like something with marginal costs, but also at
most marginal benefits. Perhaps other people have stronger opinions.

> Even if we choose not to implement the empty stack rule, we should at least require that the last element be 0x01 to remove a potential malleability vector and bring it in line with MINIMAL_IF semantics.

This feels like the right thing to do; as we're making MINIMALIF part
of consensus for Tapscript it would make sense to apply the same rule
to the "return" value of the script. There is a downside though,
namely that in some places where you'd use "<n>
OP_CHECKSEQUENCEVERIFY" or "<n> OP_CHECKLOCKTIMEVERIFY" you now need
to add an additional OP_0NOTEQUAL to convert the left-over element n
into an exact 0x01. I also can't come up with any practical benefits
that this would have; if the top stack element in a particular code
path comes directly from the input, it's insecure regardless; if there
isn't, it'll generally be a a boolean (or an intentional non-boolean
true value) computed by the script.

On Tue, 21 May 2019 at 13:05, John Newbery <john at johnnewbery.com> wrote:
>
> Hi,
>
> > A Taproot output is a SegWit output [...]  with
> > version number 1, and a 33-byte witness program whose first byte is 0 or 1.
>
> Given a secret key k and public key P=(x,y), a signer with the knowledge of k
> can sign for -P=(x,p-y) since -k is the secret key for that point. Encoding the
> y value of the public key therefore adds no security.

That's a good point; without security benefit there's no reason to
make pay-to-taproots more expensive. Making them the same cost as
P2WSH is nice in any case.

> As an alternative to
> providing the y value of the taproot output key Q when constructing the taproot
> output, the signer can provide it when signing. We can also restrict the y value
> of the internal key P to be even (or high, or a quadratic residue). That gives
> us 4 options for how to set the y signs for P and Q.
>
> 1. Q sign is explictly set in the witness program, P sign is explicitly set in the control block
>     => witness program is 33 bytes, 32 possible leaf versions (one for each pair of 0xc0..0xff)
> 2. Q sign is explictly set in the witness program, P sign is implicitly even
>     => witness program is 33 bytes, 64 possible leaf versions (one for each 0xc0..0xff)
> 3. Q sign is explictly set in the control block, P sign is explicitly set in the control block
>     => witness program is 32 bytes, 16 possible leaf versions (one for each 4-tuple of 0xc0..0xff)
> 4. Q sign is explictly set in the control block, P sign is implicitly even
>     => witness program is 32 bytes, 32 possible leaf versions (one for pair of 0xc0..0xff)
>
> The current proposal uses (1). Using (3) or (4) would reduce the size of a
> taproot output by one byte to be the same size as a P2WSH output. That means
> that it's not more expensive for senders compared to sending to P2WSH.

I prefer (4). There is a slight complexity in needing a conditional
sign swap when signing (to make sure the corresponding key is even),
but I think it's minimal compared to the other changes needed here
already. I'll try to amend the reference code soon to see what impact
this idea has.

> > (native or P2SH-nested, see BIP141)
>
> I'd prefer to not support P2SH-nested TR. P2SH wrapping was useful for segwit
> v0 for compatibility reasons. Most wallets/exchanges/services now support sending
> to native segwit addresses (https://en.bitcoin.it/wiki/Bech32_adoption) and that
> will be even more true if Schnorr/Taproot activate in 12+ months time.

I'm not sure there is much to gain here. There is perhaps a minimal
fungibility improvement by not having another bit (P2SH or not) that
can leak some information about the software you're using. On the
other hand, until native taproot outputs are common, choosing P2SH
wrapped ones leak less information at output creation time. Apart from
that, I think it would only minimally impact implementation
complexity. Are there other advantages I'm missing?

Cheers,

-- 
Pieter

From roconnor at blockstream.io  Thu May 23 02:32:26 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 22 May 2019 22:32:26 -0400
Subject: [bitcoin-dev] Taproot proposal
In-Reply-To: <CAPg+sBh=VGiBS6Cof_SBKo2aPGURicTRkuaXWwaW0_u8_nWZ1Q@mail.gmail.com>
References: <CAPg+sBg6Gg8b7hPogC==fehY3ZTHHpQReqym2fb4XXWFpMM-pQ@mail.gmail.com>
	<CAMZUoKkm33U+Rb+x03qUsFDG5CeX2C=nW8vD_8zbiAdsWazofQ@mail.gmail.com>
	<CAPg+sBh=VGiBS6Cof_SBKo2aPGURicTRkuaXWwaW0_u8_nWZ1Q@mail.gmail.com>
Message-ID: <CAMZUoKmo8TZvr36Ybp_bXmLDnhDEeHQ9d8rS+ZhYeDeNPrjsdw@mail.gmail.com>

On Wed, May 22, 2019 at 10:06 PM Pieter Wuille <pieter.wuille at gmail.com>
wrote:

> On Tue, 21 May 2019 at 10:20, Russell O'Connor <roconnor at blockstream.io>
> wrote:
> >
> > Regarding Tapscript, the specification calls for the final value of the
> stack being a single non-false value:
> >
> >> The tapscript is executed according to the rules in the following
> section, with the initial stack as input
> >>     II. If the execution results in anything but exactly one element on
> the stack which evaluates to true with CastToBool(), fail.
> >
> > Perhaps it is worth taking this opportunity here to remove a minor wart
> of the Script language and instead require the stack to be exactly empty
> upon completion.
> >
> > In addition to removing a potential malleability vector, I expect it
> would simplify development of Bitcoin Script.  A rule requiring an empty
> stack means that the conjunction (logical and) of two policies can be
> implemented by the simple concatenation of Bitcoin Scripts.  This combined
> with the taproot ability to form the disjunction (logical or) of policies
> by having multiple Merkle branches, means that the translation of a policy
> written in disjunctive normal form (the logical ors of logical ands of
> primitive policies) can be straightforwardly translated to a taproot of
> tapscript.
> >
> > That said, I think the developers of miniscript <
> http://bitcoin.sipa.be/miniscript/miniscript.html> are in a much better
> position to comment on whether my above intuition is correct given that
> they've had to implement a host of various calling conventions.  I
> understand that at least some of this complexity is due to Bitcoin Script's
> one element stack rule.
>
> IIRC I looked into this a few months ago, and found that the spending
> cost (script size + expected witness size) of the optimal script for
> every Miniscript policy at most changes by 1 WU (in either direction)
> by requiring an empty stack rather than a true value, though in a
> (admittedly very arbitrarily biased) distribution, more policies were
> improved by it than degraded. This is not taking Taproot into account
> (as many of those policies in a Taproot-supporting world should
> optimally make use of the internal key and Merkle tree, rather than
> turning everything into a monolithic script). I expect that this may
> make the impact somewhat larger, but still never more than a 1 WU
> gain.
>
> I don't think the spending cost changes justify this change, so the
> remaining criteria are complexity ones. In my view, the main benefit
> would be to authors of hand-written scripts where the consistency
> benefits matter, but this needs to be weighed against the mental cost
> of learning the new semantics. For Miniscript itself, this doesn't
> make much difference - the top level calling convention would become
> 'V' instead of 'T', but 'T' would still exist as a calling convention
> that may be used internally; it's a few lines change.
>
> So overall this feels like something with marginal costs, but also at
> most marginal benefits. Perhaps other people have stronger opinions.
>

Thanks for the info.  I'm surprised to learn that 'T' would still exist
internally.  That does make my proposed ammendment a somewhat more marginal
than I expected.  I still think it would be an improvement, but I guess it
is acceptable the way it is if that is what other people prefer.


> > Even if we choose not to implement the empty stack rule, we should at
> least require that the last element be 0x01 to remove a potential
> malleability vector and bring it in line with MINIMAL_IF semantics.
>
> This feels like the right thing to do; as we're making MINIMALIF part
> of consensus for Tapscript it would make sense to apply the same rule
> to the "return" value of the script. There is a downside though,
> namely that in some places where you'd use "<n>
> OP_CHECKSEQUENCEVERIFY" or "<n> OP_CHECKLOCKTIMEVERIFY" you now need
> to add an additional OP_0NOTEQUAL to convert the left-over element n
> into an exact 0x01. I also can't come up with any practical benefits
> that this would have; if the top stack element in a particular code
> path comes directly from the input, it's insecure regardless; if there
> isn't, it'll generally be a a boolean (or an intentional non-boolean
> true value) computed by the script.
>

That is a very good argument.  If we were to go with an empty stack we'd
probably also want modify to have CSV and CLTV pop their inputs off the
stack.  But at that point perhaps we'd want to change their opcode values
to avoid confusion with old style script.  I guess I'm getting more
convinced to not touch this stuff just and just bear with the somewhat
unfortunate legacy behaviour.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190522/08c86fec/attachment.html>

From ZmnSCPxj at protonmail.com  Thu May 23 03:45:39 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 23 May 2019 03:45:39 +0000
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <CAD5xwhiHHemzaRLC7WMeXQ5hgu0rwMKMUym34xTxWO81qqf-oQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
	<CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
	<CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
	<CAD5xwhiHHemzaRLC7WMeXQ5hgu0rwMKMUym34xTxWO81qqf-oQ@mail.gmail.com>
Message-ID: <vbL4Nj9knpm6GMzS3wfTOcDPz9F6RoStna3mDwgJmmvYa1mPWa62x_atF3kBXjajlTDIxerTsYRr5pzI3xC3eSM_ssffsrXESqoNqMSg2h4=@protonmail.com>

Good morning Jeremy,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Wednesday, May 22, 2019 4:10 PM, Jeremy <jlrubin at mit.edu> wrote:

> > * I do not think CoinJoin is much improved by this opcode.
> > ? Typically, you would sign off only if one of the outputs of the CoinJoin transaction is yours, and this does not really improve this situation.
>
> Coinjoin benefits a lot I think.
>
> Coinjoin is improved because you can fit more users into the protocol and create many more outputs at lower cost or include more participants. Ideally a coinjoin creates a lot of outputs so that the ownership is smeared more, but this has a cost at the time of the coinjoin.

But the separate outputs still need to be published at some point in the future.
Further, ideally CoinJoin should be as indistinguishable from normal transactions as possible.
(admittedly, the equal-sized outputs often recommended for CoinJoin tend to blatantly signal "this is a CoinJoin!!", but in any case that "should" be fixed with some kind of future Confidential Transactions)

>
> Coinjoin is also improved because you don't reveal the outputs created by the coinjoin until some time, perhaps very far in the future, when you need the coin. In fact, you only need to reveal where you're moving the coins to participants in your subtree because participants need only verify their branch.

The same technique of congestion control can still be used with only an "ordinary" MuSig of all participant keys on the output of the "funding" transaction, forming a sort of very tiny CoinJoinXT.
This has the advantage that the MuSig is indistinguishable from 1-of-1 spends, which is important for a privacy technique like CoinJoin.
Even in the future and we have published the output-side transaction of the CoinJoin, the transaction chain *could* be interpreted as "one person consolidated all his coins in an ordinary 1-of-1 UTXO, then spent on several things at once" whereas use of the `OP_CHECKOUTPUTSHASHVERIFY` is a blatant "several people agreed to put in their coins provided these outputs were on the second transaction, i.e. some kind of attempt at hiding their coins".

>
> It also makes the protocol more stable with respect to input choice. This is because, similar to how NOINPUT may work, OP_COSHV outputs are spendable without knowing what the TXID will be. Therefore if someone changes their input or non segwit spend script, it won't break the presigned txns. This also means that all the inputs can be ANYONECANPAY, so there is no need to reveal your inputs before anyone else.
>
> This culminates in being able to open channels from a coinjoin safely, I believe this is difficult/impossible to do currently.

This is already *technically* possible, though no software exists to do so (sorry, we have bugs between interop of c-lightning and lnd that take up our debugging time already, we cannot spare it for this *yet*).

SegWit by itself already allows child transactions to be signed before parent transactions are signed.
This safety underlies *all* offchain protocols.
See: https://zmnscpxj.github.io/offchain/generalized.html
This is sufficient to ensure that channels can be opened from whatever transactions you want, though having to interop with other software that *also* has to coordinate with other participants in a different protocol is much more difficult than having to interop with other software using the same protocol.

Finally, `SIGHASH_ANYPREVOUT` can *also* do this, since the txid becomes mooted.
And `SIGHASH_ANYPREVOUT` *also* enables a better offchain update mechanism (Decker-Russell-Osuntokun, more commonly known as "eltoo") whereas I am unable to derive a similar offchain update mechanism using `OP_CHECKOUTPUTSHASHVERIFY` (though possibly for lack of trying).

>
> > * Using this for congestion control increases blockchain usage by one TXO and one input, ending up with *more* bytes onchain, and a UTXO that will be removed later in (we hope) short time.
> > ? I do not know if this is a good idea, to increase congestion by making unnecessary intermediate transaction outputs, at times when congestion is a problem.
>
> This is a good idea because it improves QoS for most users.
>
> For receiving money pending spendable but confirmed payment (i.e. certified checks) is superior to having unconfirmed funds.
>
> For sending money, being able to clear all liabilities in a single txn decreases business exposure to fee variance and confirmation time variance. E.g., if I'm doing payroll in Bitcoin I will pay big fines if I am a day late. If I have 10,000 employees this might be painful if fees are currently up.
>
> It also helps to have a backlog of low priority txns to support the fee market.
>
> Overall block bandwidth utilization is fairly spikey, so having long term well known outputs that are not time sensitive can be used to better utilize bandwidth.
>
> The total extra bandwidth btw is really small given the expansion factor optimizations available.

Okay, you have convinced me regarding this point, at least.

> > * Channel factories created by this opcode do not, by themselves, support updates to the channel structure.
> > ? But such simple "close only" channel factories can be done using n-of-n and a pre-signed offchain transaction (especially since the entities interested in the factory are known and enumerable, and thus can be induced to sign in order to enter the factory).
>
> I'm not really an expert at Bitcoin Lightning, but this basic mechanism should work.
> Imagine the script at a leaf node:
>
> Taproot([Alice, Bob], [OP_COSHV <H(H(2 coins to uncooperative script))>]
>
> where uncooperative script is:
>
> Taproot([Alice, Bob], ["1 week" CHECKSEQUENCEVERIFY DROP  OP_COSHV <H(H(Pay alice 2 coins))>)
>
> Cooperative closing skips the extra transactions. Updates are signed against the uncooperative script with repudation. E.g.:
>
> ? ? HASH160 <revokehash> EQUAL
> ? ? IF
> ? ? ? ? <Bob's pubkey>
> ? ? ELSE
> ? ? ? ? "1 week" CHECKSEQUENCEVERIFY DROP
> ? ? ? ? <Alice's pubkey>
> ? ? ENDIF
> ? ? CHECKSIG
>
> It can even be optimized by letting the uncooperative script branches in the leaf be blaming Alice or Bob.
>
> Does that not work?

Possibly, but the point is that an n-of-n MuSig will work just as well and we would not need to reveal the Taproot key (33 bytes) and the specific script containing the output hash (1+32 bytes) we want, we just have to reveal a single 64-byte signature.

My objection here is simply that n-of-n already exists, it will work already using that (and it is much more likely to be assured of getting into base layer).

Again, we only need to use SegWit and sign transactions in reverse order to ensure proper operation.
This is already what is done for normal channel opens (the initial commitment transactions are signed first, then the funding transaction is signed and confirmed onchain).

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Thu May 23 16:59:15 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 23 May 2019 16:59:15 +0000
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <-doGGpQeidaYIWCJLexeiJPyi1leWSjZ4nMdO6K2CmhnaTLLtJCz4kOTY5stLEuly0qe7TUSYjzqoksbiXPp7IrA-qk0c8Abr_2Nad7ZJks=@protonmail.com>

Good morning Russell,

While I am sympathetic to this argument from first principles, as I understand it, it requires that provided witness inputs will become larger, compared to "shortcuts" like `SIGHASH_ANYPREVOUT` and `OP_CHECKOUTPUTSHASHVERIFY`.

For instance, to simulate `SIGHASH_ANYPREVOUT` with `OP_CAT` and `OP_CHECKSIGFROMSTACK`, I would effectively split the unsigned transaction into its "inputs" and "outputs" part, concat them and use `OP_CHECKSIGFROMSTACK` on the chaperone signature, and also use a normal `OP_CHECKSIGVERIFY` on that same chaperone signature, then dup the "outputs" part and use `OP_CHECKSIGFROMSTACK` on the "any prevout"/"noinput" signature.
I would effectively give the transaction to itself as part of the witness, and further, I would also have to very carefully write the script (admittedly the writing of the template could be done once, but it would require far more review than simple usages of the "limited" operations like `SIGHASH_ANYPREVOUT`).
So my witness stack would contain two signatures, and a duplicate of the transaction itself, plus a very much complicated script, whereas use of `SIGHASH_ANYPREVOUT` just requires two signatures and a script not much longer than pre-Schnorr multisig scripts.


It seems to me desirable, to try to reduce bandwidth consumption on the Bitcoin blockchain, including witness data.
Indeed, I had thought the whole exercise of putting `OP_CHECKSIGFROMSTACK` in a federated sidechain (Elements/Liquid) was to try to identify common patterns of usage for that opcode, and *then* to propose those common patterns as specific "optimized" opcodes as a sort of "jet" for Bitcoin itself (but not `OP_CHECKSIGFROMSTACK` itself).

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, May 23, 2019 5:01 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for Bitcoin via new Script operations.? However, I think that these proposals miss the mark when it comes to how they approach Bitcoin Script and language features.
>
> Bitcoin Script appears designed to be a flexible programmable system that provides generic features to be composed to achieve various purposes.? Thus, when we design new language features for Script, we should be striving, as much as possible, to similarly build general purpose tools which can in turn be used for a variety of purposes.
>
> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail to achieve these design goals.? They are both are designed with very narrow applications in mind, while also going out of their way to extend the semantic domain of the interpretation of Bitcoin operations in new ways that complicate their specification.? In the case of SIGHASH_ANYPREVOUT, the semantic domain is extended by adding new counters to track the use of various v0 and v2 signature types.? In the case of OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that peeks at the value of surrounding opcodes.
>
> Instead, I propose that, for the time being, we simply implement OP_CAT and OP_CHECKSIGFROMSTACKVERIFY.? OP_CAT pops two byte arrays off the stack and pushes their concatenation back onto the stack.? OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the stack and performs a bip-schnorr verification on the SHA256 hash of the message.
>
> In concert, these two operations enable:
>
> * Oracle signature verification, including discrete log contracts.
> * Amortized secure multiparty computations (see "Amortizing Secure Computation with Penalties" by Kumaresan and Bentov).
> * Transaction introspection including:
> +?Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the nature of the construction.
> + Decide if a transaction has exactly one input or not. (etc.)
> + Weak covenants, which can verify output scripts to see if they are among a set of predefined values or verify the output hash.
>
> and presumably more applications as well.
>
> For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.
>
> All this is accomplished by two straightforward opcodes whose semantics are pure computational operations on stack values.? The only semantic side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the existing 'sigops_passed' count.? Moreover, I feel that adding these operations does not preclude adding more specialized opcodes in the future as an optimization for whatever popular constructions come up, once we know what those are.
>
> I feel that this style of generic building blocks truly embodies what is meant by "programmable money".



From jaejoon at gmail.com  Thu May 23 17:36:19 2019
From: jaejoon at gmail.com (Jimmy Song)
Date: Thu, 23 May 2019 12:36:19 -0500
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <CAJR7vkqogCzy8_SpCxcAhnEdkS6DRKaDtvJa8Wc-TNGsCcjM5g@mail.gmail.com>

Hi Russell,

This is probably a dumb question, but I'd like to get some clarity on your
proposal.

OP_CHECKSIGFROMSTACKVERIFY would pop off a signature, message and pubkey.
Presumably, the message would then have to get constructed as part of the
Script execution. What would such a message look like? What, in other
words, would you be signing and would that be similar to what signatures
sign now? Would it be a single blob that incorporates all the input/output
information in some hashed manner (like BIP143)? Or would you need separate
signatures for different parts of the transaction? Or is it something more
complicated like aggregating multiple signatures over different parts of
the transaction?

Best,

Jimmy

On Thu, May 23, 2019 at 8:35 AM Russell O'Connor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and
> OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for
> Bitcoin via new Script operations.  However, I think that these proposals
> miss the mark when it comes to how they approach Bitcoin Script and
> language features.
>
> Bitcoin Script appears designed to be a flexible programmable system that
> provides generic features to be composed to achieve various purposes.
> Thus, when we design new language features for Script, we should be
> striving, as much as possible, to similarly build general purpose tools
> which can in turn be used for a variety of purposes.
>
> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail
> to achieve these design goals.  They are both are designed with very narrow
> applications in mind, while also going out of their way to extend the
> semantic domain of the interpretation of Bitcoin operations in new ways
> that complicate their specification.  In the case of SIGHASH_ANYPREVOUT,
> the semantic domain is extended by adding new counters to track the use of
> various v0 and v2 signature types.  In the case of
> OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that
> peeks at the value of surrounding opcodes.
>
> Instead, I propose that, for the time being, we simply implement OP_CAT
> and OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack
> and pushes their concatenation back onto the stack.
> OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the
> stack and performs a bip-schnorr verification on the SHA256 hash of the
> message.
>
> In concert, these two operations enable:
>
> * Oracle signature verification, including discrete log contracts.
> * Amortized secure multiparty computations (see "Amortizing Secure
> Computation with Penalties" by Kumaresan and Bentov).
> * Transaction introspection including:
> + Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply
> by the nature of the construction.
> + Decide if a transaction has exactly one input or not. (etc.)
> + Weak covenants, which can verify output scripts to see if they are among
> a set of predefined values or verify the output hash.
>
> and presumably more applications as well.
>
> For better or for worse, without an OP_PUBKEYTWEEK operation available,
> the more interesting recursive-covenants remain largely out of reach, with
> the exception of a recursive covenant that is only able to send back to its
> own address, possibly abusing its own TXO value as a state variable.
>
> All this is accomplished by two straightforward opcodes whose semantics
> are pure computational operations on stack values.  The only semantic
> side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the
> existing 'sigops_passed' count.  Moreover, I feel that adding these
> operations does not preclude adding more specialized opcodes in the future
> as an optimization for whatever popular constructions come up, once we know
> what those are.
>
> I feel that this style of generic building blocks truly embodies what is
> meant by "programmable money".
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/28a9b6e8/attachment.html>

From tamas.blummer at gmail.com  Thu May 23 17:42:35 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 23 May 2019 19:42:35 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
Message-ID: <42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>

Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.

I think we could do much better than them natively within Bitcoin.

A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into. 
The output script may then decide comparing that value with a strike which key can spend it. 
The input of the transaction would be a multi-sig escrow of those who entered the bet. 
The winner would broadcast. 

Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.

I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.

Do you see a fault in this proposal or want to contribute?

Tamas Blummer 


From jtimon at jtimon.cc  Thu May 23 19:03:09 2019
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 23 May 2019 21:03:09 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
Message-ID: <CABm2gDoFS=dNbqzEo+RcWb32Kx4QM7YHLxYLOG54a=RGR8rQcw@mail.gmail.com>

The complains I could imagine about this, (apart from being a very
specific use case) are the same complains I heard about op_expiry.
Namely, that in a reorg, the same tx, having been valid in a given
block could potentially become invalid in some other block mining it.
I guess in this case the situation is less likely in this case than
with op_expiry, but it is still possible.
Another complain I could imagine is this kind of forces the
implementation to break some existing encapsulations, but I guess
those are just implementation details not that relevant here.
I personally don't have strong feelings towards this proposal one way
or the other, I'm just imagining what other people may complain about.

On Thu, May 23, 2019 at 8:33 PM Tamas Blummer via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
>
> I think we could do much better than them natively within Bitcoin.
>
> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
> The output script may then decide comparing that value with a strike which key can spend it.
> The input of the transaction would be a multi-sig escrow of those who entered the bet.
> The winner would broadcast.
>
> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
>
> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
>
> Do you see a fault in this proposal or want to contribute?
>
> Tamas Blummer
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From nathan.cook at gmail.com  Thu May 23 19:05:02 2019
From: nathan.cook at gmail.com (Nathan Cook)
Date: Thu, 23 May 2019 22:05:02 +0300
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
Message-ID: <CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>

You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke
Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki)
if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN.
See
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html
and
the ensuing thread.

Nathan Cook


On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Difficulty change has profound impact on miner?s production thereby
> introduce the biggest risk while considering an investment.
> Commodity markets offer futures and options to hedge risks on traditional
> trading venues. Some might soon list difficulty futures.
>
> I think we could do much better than them natively within Bitcoin.
>
> A better solution could be a transaction that uses nLocktime denominated
> in block height, such that it is valid after the difficulty adjusted block
> in the future.
> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty
> for the block the transaction is included into.
> The output script may then decide comparing that value with a strike which
> key can spend it.
> The input of the transaction would be a multi-sig escrow of those who
> entered the bet.
> The winner would broadcast.
>
> Once signed by both the transaction would not carry any counterparty risk
> and would not need an oracle to settle according to the bet.
>
> I plan to draft a BIP for this as I think this opcode would serve
> significant economic interest of Bitcoin economy, and is compatible with
> Bitcoin?s aim not to introduce 3rd party to do so.
>
> Do you see a fault in this proposal or want to contribute?
>
> Tamas Blummer
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/3cb49dd5/attachment-0001.html>

From tamas.blummer at gmail.com  Thu May 23 19:10:53 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 23 May 2019 21:10:53 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CABm2gDoFS=dNbqzEo+RcWb32Kx4QM7YHLxYLOG54a=RGR8rQcw@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CABm2gDoFS=dNbqzEo+RcWb32Kx4QM7YHLxYLOG54a=RGR8rQcw@mail.gmail.com>
Message-ID: <31A492B1-AFDD-4A4D-AC2C-2020F8EF2954@gmail.com>

The parameter used is property of the block just like the block height is a property and is already evaluated in scripts,
so no new kind of dependency or encapsulation break.

The transaction itself was not invalid in a re-org but evtl. others spending it if the difficulty on that fork is different,
this is however intended as then on that fork the other was the winner.

Tamas Blummer

> On May 23, 2019, at 21:03, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> 
> The complains I could imagine about this, (apart from being a very
> specific use case) are the same complains I heard about op_expiry.
> Namely, that in a reorg, the same tx, having been valid in a given
> block could potentially become invalid in some other block mining it.
> I guess in this case the situation is less likely in this case than
> with op_expiry, but it is still possible.
> Another complain I could imagine is this kind of forces the
> implementation to break some existing encapsulations, but I guess
> those are just implementation details not that relevant here.
> I personally don't have strong feelings towards this proposal one way
> or the other, I'm just imagining what other people may complain about.
> 
> On Thu, May 23, 2019 at 8:33 PM Tamas Blummer via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
>> 
>> I think we could do much better than them natively within Bitcoin.
>> 
>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
>> The output script may then decide comparing that value with a strike which key can spend it.
>> The input of the transaction would be a multi-sig escrow of those who entered the bet.
>> The winner would broadcast.
>> 
>> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
>> 
>> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
>> 
>> Do you see a fault in this proposal or want to contribute?
>> 
>> Tamas Blummer
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/c2fb6e5b/attachment.sig>

From tamas.blummer at gmail.com  Thu May 23 19:18:06 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 23 May 2019 21:18:06 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>
Message-ID: <C6788578-80D4-44E7-8CF7-82AD15E3F12C@gmail.com>

That opcode would not help as it fetches block hash and not the content of the header.

> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:
> 
> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki <https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki>) if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html> and the ensuing thread.
> 
> Nathan Cook
> 
> 
> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
> 
> I think we could do much better than them natively within Bitcoin.
> 
> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
> The output script may then decide comparing that value with a strike which key can spend it.
> The input of the transaction would be a multi-sig escrow of those who entered the bet.
> The winner would broadcast.
> 
> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
> 
> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
> 
> Do you see a fault in this proposal or want to contribute?
> 
> Tamas Blummer
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/e41fcfc1/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/e41fcfc1/attachment.sig>

From nathan.cook at gmail.com  Thu May 23 19:21:39 2019
From: nathan.cook at gmail.com (Nathan Cook)
Date: Thu, 23 May 2019 22:21:39 +0300
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <C6788578-80D4-44E7-8CF7-82AD15E3F12C@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>
	<C6788578-80D4-44E7-8CF7-82AD15E3F12C@gmail.com>
Message-ID: <CAGNXQMQG4KwAohfENYuUW=uABGshbJMYmdb_71ZtByCuj=14bQ@mail.gmail.com>

It's true that it fetches the block hash; the idea is to compare the block
hash's numeric value to the desired (uncompressed) difficulty directly,
using a 256-bit version of OP_LESSTHAN.

Nathan Cook


On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com> wrote:

> That opcode would not help as it fetches block hash and not the content of
> the header.
>
> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:
>
> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke
> Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki)
> if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN.
> See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html and
> the ensuing thread.
>
> Nathan Cook
>
>
> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Difficulty change has profound impact on miner?s production thereby
>> introduce the biggest risk while considering an investment.
>> Commodity markets offer futures and options to hedge risks on traditional
>> trading venues. Some might soon list difficulty futures.
>>
>> I think we could do much better than them natively within Bitcoin.
>>
>> A better solution could be a transaction that uses nLocktime denominated
>> in block height, such that it is valid after the difficulty adjusted block
>> in the future.
>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty
>> for the block the transaction is included into.
>> The output script may then decide comparing that value with a strike
>> which key can spend it.
>> The input of the transaction would be a multi-sig escrow of those who
>> entered the bet.
>> The winner would broadcast.
>>
>> Once signed by both the transaction would not carry any counterparty risk
>> and would not need an oracle to settle according to the bet.
>>
>> I plan to draft a BIP for this as I think this opcode would serve
>> significant economic interest of Bitcoin economy, and is compatible with
>> Bitcoin?s aim not to introduce 3rd party to do so.
>>
>> Do you see a fault in this proposal or want to contribute?
>>
>> Tamas Blummer
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/af280d71/attachment-0001.html>

From pieter.wuille at gmail.com  Thu May 23 19:45:37 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 23 May 2019 12:45:37 -0700
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
Message-ID: <CAPg+sBged=ivVLj9tAM6zZdvWdYnG5pj4gozac5EupFPLtwyfA@mail.gmail.com>

On Thu, 23 May 2019 at 11:33, Tamas Blummer via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
>
> I think we could do much better than them natively within Bitcoin.
>
> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
> The output script may then decide comparing that value with a strike which key can spend it.
> The input of the transaction would be a multi-sig escrow of those who entered the bet.
> The winner would broadcast.

If the difficulty can be directly observed by the script language, you
would need to re-evaluate all scripts in unconfirmed transactions
whenever the difficulty changes. This complicates implementation of
mempools, but it also makes reasoning about validity of (chains of)
unconfirmed transactions harder, as an unconfirmed predecessor may
have conditions that change over time.

For things like block time/height, this is solved by not having the
script itself observe the context state directly, but instead having
an assertion on the state outside of script (nLockTime for absolute
time/height and nSequence for relative), and then having opcodes
inside script that observe the assertion (OP_CLTV and OP_CSV). By
doing so, script validity is a single context-free yes or not that can
be evaluated once, and the variable part is just transaction-level
reasoning that doesn't involve a full script interpreter.
Additionally, the supported assertions are restricted in such a way
that if they are true within a particular block, they're also true in
any descendant, removing the complexity of reasoning about validity
(apart from the inevitable reasoning about possible double-spend
before confirmation).

I feel a similar construction is needed for observing block
difficulty. This can be done by either having an opcode that as a side
effect of execution "posts" an assertion (e.g. "difficulty at block
height X is at least Y"), instead of putting the difficulty on the
stack. An alternative is having the assertion be part of the
transaction structure (for example in the annex we propose in
bip-taproot), and having an opcode that observes the difficulty
assertion inside script.

I don't have a strong opinion either way on the usefulness of having
difficulty-dependent transaction/scripts.

Cheers,

-- 
Pieter

From tamas.blummer at gmail.com  Thu May 23 19:45:58 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 23 May 2019 21:45:58 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CAGNXQMQG4KwAohfENYuUW=uABGshbJMYmdb_71ZtByCuj=14bQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>
	<C6788578-80D4-44E7-8CF7-82AD15E3F12C@gmail.com>
	<CAGNXQMQG4KwAohfENYuUW=uABGshbJMYmdb_71ZtByCuj=14bQ@mail.gmail.com>
Message-ID: <09724852-6971-4E5A-AAB5-3FBAEEA1D995@gmail.com>

I see. The uncompressing needs to be done either to compare. How are chances for that BIP?

This BIP would be explicitly offering risk managment of miners biggest risk.
Doing so without relying on external markets or oracle, self cointained would be an impressive and adequate feature.

Tamas Blummer

> On May 23, 2019, at 21:21, Nathan Cook <nathan.cook at gmail.com> wrote:
> 
> It's true that it fetches the block hash; the idea is to compare the block hash's numeric value to the desired (uncompressed) difficulty directly, using a 256-bit version of OP_LESSTHAN.
> 
> Nathan Cook
> 
> 
> On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> That opcode would not help as it fetches block hash and not the content of the header.
> 
>> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:
>> 
>> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki) if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html and the ensuing thread.
>> 
>> Nathan Cook
>> 
>> 
>> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
>> 
>> I think we could do much better than them natively within Bitcoin.
>> 
>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
>> The output script may then decide comparing that value with a strike which key can spend it.
>> The input of the transaction would be a multi-sig escrow of those who entered the bet.
>> The winner would broadcast.
>> 
>> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
>> 
>> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
>> 
>> Do you see a fault in this proposal or want to contribute?
>> 
>> Tamas Blummer
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/ac6e377c/attachment.sig>

From tamas.blummer at gmail.com  Thu May 23 19:54:43 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 23 May 2019 21:54:43 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <09724852-6971-4E5A-AAB5-3FBAEEA1D995@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>
	<C6788578-80D4-44E7-8CF7-82AD15E3F12C@gmail.com>
	<CAGNXQMQG4KwAohfENYuUW=uABGshbJMYmdb_71ZtByCuj=14bQ@mail.gmail.com>
	<09724852-6971-4E5A-AAB5-3FBAEEA1D995@gmail.com>
Message-ID: <FC1E77CA-929C-40E1-A80E-ADC1CBD65A6E@gmail.com>

Block hash can suggest much higher difficulty than what is in effect, so OP_CHECKBLOCKATHEIGHT would not work to decide if difficulty is above the level of the bet.

> On May 23, 2019, at 21:45, Tamas Blummer <tamas.blummer at gmail.com> wrote:
> 
> I see. The uncompressing needs to be done either to compare. How are chances for that BIP?
> 
> This BIP would be explicitly offering risk managment of miners biggest risk.
> Doing so without relying on external markets or oracle, self cointained would be an impressive and adequate feature.
> 
> Tamas Blummer
> 
>> On May 23, 2019, at 21:21, Nathan Cook <nathan.cook at gmail.com> wrote:
>> 
>> It's true that it fetches the block hash; the idea is to compare the block hash's numeric value to the desired (uncompressed) difficulty directly, using a 256-bit version of OP_LESSTHAN.
>> 
>> Nathan Cook
>> 
>> 
>> On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com> wrote:
>> That opcode would not help as it fetches block hash and not the content of the header.
>> 
>>> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:
>>> 
>>> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by Luke Dashjr (https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki) if you also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html and the ensuing thread.
>>> 
>>> Nathan Cook
>>> 
>>> 
>>> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
>>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
>>> 
>>> I think we could do much better than them natively within Bitcoin.
>>> 
>>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
>>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
>>> The output script may then decide comparing that value with a strike which key can spend it.
>>> The input of the transaction would be a multi-sig escrow of those who entered the bet.
>>> The winner would broadcast.
>>> 
>>> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
>>> 
>>> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
>>> 
>>> Do you see a fault in this proposal or want to contribute?
>>> 
>>> Tamas Blummer
>>> 
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/7a642174/attachment.sig>

From nathan.cook at gmail.com  Thu May 23 20:07:30 2019
From: nathan.cook at gmail.com (Nathan Cook)
Date: Thu, 23 May 2019 23:07:30 +0300
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <FC1E77CA-929C-40E1-A80E-ADC1CBD65A6E@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAGNXQMTLjkC+i7YcVyWC0Z0ixTkwhYR2qF4R0qeMNTT4ntj9oQ@mail.gmail.com>
	<C6788578-80D4-44E7-8CF7-82AD15E3F12C@gmail.com>
	<CAGNXQMQG4KwAohfENYuUW=uABGshbJMYmdb_71ZtByCuj=14bQ@mail.gmail.com>
	<09724852-6971-4E5A-AAB5-3FBAEEA1D995@gmail.com>
	<FC1E77CA-929C-40E1-A80E-ADC1CBD65A6E@gmail.com>
Message-ID: <CAGNXQMQ9z4hOaZctVu6gR14yUd=JzxgyXcaxReYYRJdhauofOw@mail.gmail.com>

You're right, I didn't remember the whole procedure. You provide the
80-byte header in the spend script, duplicate it on the stack, hash it, and
compare to what OP_CHECKBLOCKATHEIGHT gives you. Then you do bit masking on
the header with OP_AND to extract the difficulty. You can compare two
compressed difficulties directly by using more bit masking to separate the
exponent and mantissa.

On Thu, 23 May 2019 at 22:54, Tamas Blummer <tamas.blummer at gmail.com> wrote:

> Block hash can suggest much higher difficulty than what is in effect, so
> OP_CHECKBLOCKATHEIGHT would not work to decide if difficulty is above the
> level of the bet.
>
> > On May 23, 2019, at 21:45, Tamas Blummer <tamas.blummer at gmail.com>
> wrote:
> >
> > I see. The uncompressing needs to be done either to compare. How are
> chances for that BIP?
> >
> > This BIP would be explicitly offering risk managment of miners biggest
> risk.
> > Doing so without relying on external markets or oracle, self cointained
> would be an impressive and adequate feature.
> >
> > Tamas Blummer
> >
> >> On May 23, 2019, at 21:21, Nathan Cook <nathan.cook at gmail.com> wrote:
> >>
> >> It's true that it fetches the block hash; the idea is to compare the
> block hash's numeric value to the desired (uncompressed) difficulty
> directly, using a 256-bit version of OP_LESSTHAN.
> >>
> >> Nathan Cook
> >>
> >>
> >> On Thu, 23 May 2019 at 22:18, Tamas Blummer <tamas.blummer at gmail.com>
> wrote:
> >> That opcode would not help as it fetches block hash and not the content
> of the header.
> >>
> >>> On May 23, 2019, at 21:05, Nathan Cook <nathan.cook at gmail.com> wrote:
> >>>
> >>> You can get the same effect with OP_CHECKBLOCKATHEIGHT as proposed by
> Luke Dashjr (
> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki) if you
> also re-enable/extend certain opcodes like OP_AND and OP_LESSTHAN. See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013149.html
> and the ensuing thread.
> >>>
> >>> Nathan Cook
> >>>
> >>>
> >>> On Thu, 23 May 2019 at 21:33, Tamas Blummer via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>> Difficulty change has profound impact on miner?s production thereby
> introduce the biggest risk while considering an investment.
> >>> Commodity markets offer futures and options to hedge risks on
> traditional trading venues. Some might soon list difficulty futures.
> >>>
> >>> I think we could do much better than them natively within Bitcoin.
> >>>
> >>> A better solution could be a transaction that uses nLocktime
> denominated in block height, such that it is valid after the difficulty
> adjusted block in the future.
> >>> A new OP_DIFFICULTY opcode would put onto stack the value of
> difficulty for the block the transaction is included into.
> >>> The output script may then decide comparing that value with a strike
> which key can spend it.
> >>> The input of the transaction would be a multi-sig escrow of those who
> entered the bet.
> >>> The winner would broadcast.
> >>>
> >>> Once signed by both the transaction would not carry any counterparty
> risk and would not need an oracle to settle according to the bet.
> >>>
> >>> I plan to draft a BIP for this as I think this opcode would serve
> significant economic interest of Bitcoin economy, and is compatible with
> Bitcoin?s aim not to introduce 3rd party to do so.
> >>>
> >>> Do you see a fault in this proposal or want to contribute?
> >>>
> >>> Tamas Blummer
> >>>
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>
> >
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/d5bd334b/attachment-0001.html>

From tamas.blummer at gmail.com  Thu May 23 20:26:49 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 23 May 2019 22:26:49 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CAPg+sBged=ivVLj9tAM6zZdvWdYnG5pj4gozac5EupFPLtwyfA@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAPg+sBged=ivVLj9tAM6zZdvWdYnG5pj4gozac5EupFPLtwyfA@mail.gmail.com>
Message-ID: <8870AC4C-B5E4-491C-8973-8962DEBD39CE@gmail.com>


> On May 23, 2019, at 21:45, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> 
> On Thu, 23 May 2019 at 11:33, Tamas Blummer via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
>> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
>> 
>> I think we could do much better than them natively within Bitcoin.
>> 
>> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
>> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into.
>> The output script may then decide comparing that value with a strike which key can spend it.
>> The input of the transaction would be a multi-sig escrow of those who entered the bet.
>> The winner would broadcast.
> 
> If the difficulty can be directly observed by the script language, you
> would need to re-evaluate all scripts in unconfirmed transactions
> whenever the difficulty changes. This complicates implementation of
> mempools, but it also makes reasoning about validity of (chains of)
> unconfirmed transactions harder, as an unconfirmed predecessor may
> have conditions that change over time.
> 
> For things like block time/height, this is solved by not having the
> script itself observe the context state directly, but instead having
> an assertion on the state outside of script (nLockTime for absolute
> time/height and nSequence for relative), and then having opcodes
> inside script that observe the assertion (OP_CLTV and OP_CSV). By
> doing so, script validity is a single context-free yes or not that can
> be evaluated once, and the variable part is just transaction-level
> reasoning that doesn't involve a full script interpreter.
> Additionally, the supported assertions are restricted in such a way
> that if they are true within a particular block, they're also true in
> any descendant, removing the complexity of reasoning about validity
> (apart from the inevitable reasoning about possible double-spend
> before confirmation).
> 
> I feel a similar construction is needed for observing block
> difficulty. This can be done by either having an opcode that as a side
> effect of execution "posts" an assertion (e.g. "difficulty at block
> height X is at least Y"), instead of putting the difficulty on the
> stack. An alternative is having the assertion be part of the
> transaction structure (for example in the annex we propose in
> bip-taproot), and having an opcode that observes the difficulty
> assertion inside script.

Thanks for these suggestions I will follow up while preparing the BIP.

> 
> I don't have a strong opinion either way on the usefulness of having
> difficulty-dependent transaction/scripts.
> 

This is the best reception I could have hoped for :)

> Cheers,
> 
> --
> Pieter

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/9b03f58a/attachment.sig>

From jl2012 at xbt.hk  Thu May 23 20:54:01 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 24 May 2019 04:54:01 +0800
Subject: [bitcoin-dev] Safety of committing only to transaction outputs
Message-ID: <77218514-9118-4FE2-8F7F-7BB215CF2BB6@xbt.hk>

This is a meta-discussion for any approach that allows the witness committing to only transaction outputs, but not inputs.

We can already do the following things with the existing bitcoin script system:
* commit to both inputs and outputs: SIGHASH_ALL or SIGHASH_SINGLE, with optional SIGHASH_ANYONECANPAY
* commit to only inputs but not outputs: SIGHASH_NONE with optional SIGHASH_ANYONECANPAY
* not commit to any input nor output: not using any sigop; using a trivial private key; using the SIGHASH_SINGLE bug in legacy script

The last one is clearly unsafe as any relay/mining node may redirect the payment to any output it chooses. The witness/scriptSig is also replayable, so any future payment to this script will likely be swept immediately

SIGHASH_NONE with ANYONECANPAY also allows redirection of payment, but the signature is not replayable

But it?s quite obvious that not committing to outputs are inherently insecure

The existing system doesn?t allow committing only to outputs, and we now have 3 active proposals for this function:

1. CAT and CHECKSIGFROMSTACK (CSFS): https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016946.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016946.html>
2. ANYPREVOUT (aka NOINPUT): https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016929.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016929.html>
3. CHECKOUTPUTSHASHVERIFY (COHV): https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html>

With outputs committed, redirecting payment is not possible. On the other hand, not committing to any input means the witness is replayable without the consent of address owner. Whether replayability is acceptable is subject to controversy, but the ANYPREVOUT proposal fixes this by requiring a chaperone signature that commits to input. However, if the rationale for chaperone signature stands, it should be applicable to all proposals listed above.

A more generic approach is to always require a ?safe" signature that commits to at least one input. However, this interacts poorly with the "unknown public key type? upgrade path described in bip-tapscript (https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki <https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki>), since it?d be a hardfork to turn an ?unknown type sig? into a ?safe sig?. But we could still use a new ?leaf version? every time we introduce new sighash types, so we could have a new definition for ?safe sig?. I expect this would be a rare event and it won?t consume more than a couple leaf versions. By the way, customised sighash policies could be done with CAT/CSFS.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/d832f52d/attachment-0001.html>

From roconnor at blockstream.io  Thu May 23 22:00:59 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 23 May 2019 18:00:59 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAJR7vkqogCzy8_SpCxcAhnEdkS6DRKaDtvJa8Wc-TNGsCcjM5g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<CAJR7vkqogCzy8_SpCxcAhnEdkS6DRKaDtvJa8Wc-TNGsCcjM5g@mail.gmail.com>
Message-ID: <CAMZUoKmMWXO72HWQab4kXPKnbQD49sZdryq-nGWum30h6oGMqA@mail.gmail.com>

Hi Jimmy,

The message could really be anything.  For example, in discreet log
contracts, AFAIU, you might have a specific public key from a trusted third
party (the Oracle) that is signs the closing price of corn in BTC on
2019-05-23 with a particular nonce dedicated to that product-date pair, in
which case the message would be the price expressed in binary.  In the case
of amortized secure multiparty computations, the message is protocol
specific binary data that consists of a counter (or counters), concatenated
with shares of secret data that is used to construct the result of the
multiparty computation.  In the case of transaction reflection, the message
would be a duplicate copy of the tapscript signed transaction data (about
244 bytes of data plus a 64 byte prefix).

As you note, the message is likely to constructed from a value computed
from a mix of witness and committed data, though the message might be pure
witness data, as in the discreet log contract example.  In that the
discreet log contract example, you'd probably duplicate the integer value
and do further processing (e.g. compare it to some other committed value).

On Thu, May 23, 2019 at 1:36 PM Jimmy Song <jaejoon at gmail.com> wrote:

> Hi Russell,
>
> This is probably a dumb question, but I'd like to get some clarity on your
> proposal.
>
> OP_CHECKSIGFROMSTACKVERIFY would pop off a signature, message and pubkey.
> Presumably, the message would then have to get constructed as part of the
> Script execution. What would such a message look like? What, in other
> words, would you be signing and would that be similar to what signatures
> sign now? Would it be a single blob that incorporates all the input/output
> information in some hashed manner (like BIP143)? Or would you need separate
> signatures for different parts of the transaction? Or is it something more
> complicated like aggregating multiple signatures over different parts of
> the transaction?
>
> Best,
>
> Jimmy
>
> On Thu, May 23, 2019 at 8:35 AM Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and
>> OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for
>> Bitcoin via new Script operations.  However, I think that these proposals
>> miss the mark when it comes to how they approach Bitcoin Script and
>> language features.
>>
>> Bitcoin Script appears designed to be a flexible programmable system that
>> provides generic features to be composed to achieve various purposes.
>> Thus, when we design new language features for Script, we should be
>> striving, as much as possible, to similarly build general purpose tools
>> which can in turn be used for a variety of purposes.
>>
>> I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail
>> to achieve these design goals.  They are both are designed with very narrow
>> applications in mind, while also going out of their way to extend the
>> semantic domain of the interpretation of Bitcoin operations in new ways
>> that complicate their specification.  In the case of SIGHASH_ANYPREVOUT,
>> the semantic domain is extended by adding new counters to track the use of
>> various v0 and v2 signature types.  In the case of
>> OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that
>> peeks at the value of surrounding opcodes.
>>
>> Instead, I propose that, for the time being, we simply implement OP_CAT
>> and OP_CHECKSIGFROMSTACKVERIFY.  OP_CAT pops two byte arrays off the stack
>> and pushes their concatenation back onto the stack.
>> OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the
>> stack and performs a bip-schnorr verification on the SHA256 hash of the
>> message.
>>
>> In concert, these two operations enable:
>>
>> * Oracle signature verification, including discrete log contracts.
>> * Amortized secure multiparty computations (see "Amortizing Secure
>> Computation with Penalties" by Kumaresan and Bentov).
>> * Transaction introspection including:
>> + Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply
>> by the nature of the construction.
>> + Decide if a transaction has exactly one input or not. (etc.)
>> + Weak covenants, which can verify output scripts to see if they are
>> among a set of predefined values or verify the output hash.
>>
>> and presumably more applications as well.
>>
>> For better or for worse, without an OP_PUBKEYTWEEK operation available,
>> the more interesting recursive-covenants remain largely out of reach, with
>> the exception of a recursive covenant that is only able to send back to its
>> own address, possibly abusing its own TXO value as a state variable.
>>
>> All this is accomplished by two straightforward opcodes whose semantics
>> are pure computational operations on stack values.  The only semantic
>> side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the
>> existing 'sigops_passed' count.  Moreover, I feel that adding these
>> operations does not preclude adding more specialized opcodes in the future
>> as an optimization for whatever popular constructions come up, once we know
>> what those are.
>>
>> I feel that this style of generic building blocks truly embodies what is
>> meant by "programmable money".
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/c505017a/attachment-0001.html>

From roconnor at blockstream.io  Thu May 23 22:06:45 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 23 May 2019 18:06:45 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <-doGGpQeidaYIWCJLexeiJPyi1leWSjZ4nMdO6K2CmhnaTLLtJCz4kOTY5stLEuly0qe7TUSYjzqoksbiXPp7IrA-qk0c8Abr_2Nad7ZJks=@protonmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<-doGGpQeidaYIWCJLexeiJPyi1leWSjZ4nMdO6K2CmhnaTLLtJCz4kOTY5stLEuly0qe7TUSYjzqoksbiXPp7IrA-qk0c8Abr_2Nad7ZJks=@protonmail.com>
Message-ID: <CAMZUoKnD5_L7H8tGp2nbEV8-RQ8kJPxvpMp2Hi2Hu1=-DWsPZA@mail.gmail.com>

Hello ZmnSCPxj,

I agree that adding OP_CHECKSIGFROMSTACK doesn't preclude adding shortcuts
such as `SIGHASH_ANYPREVOUT` and `OP_CHECKOUTPUTSHASHVERIFY`, and I agree
we ought to support such operations directly, especially if we see
widespread use of these constructions in practice.

I think it is desirable to add OP_CHECKSIGFROMSTACK for its direct purposes
of enabling oracle verification and discreet log contracts.  Moreover, it
would be better decide if we do or do not want to do this first, because
whether or not we chose to implement a general OP_CHECKSIGFROMSTACK will
influence the design of these other proposals.

For example, if we choose to deploy OP_CHECKSIGFROMSTACK, then the design
of OP_CHECKOUTPUTSHASHVERIFY ought to be simplified to OP_PUSHOUTPUTHASH
and OP_PUSHNUMINPUTS (etc.) because the proposal would no longer be
extending the expressiveness of Bitcoin Script.  And while
OP_CHECKSIGFROMSTACK doesn't directly address whether SIGHASH_ANYPREVOUT
should be with or without a chaperone (as the simulated version with
OP_CHECKSIGFROMSTACK is necessarily chaperoned), we might get an
opportunity to learn if users are willing to take advantage of the
chaperone, or whether they rather bypass it by using a short well-known
pubkey: (e.g.
0x0200000000000000000000003b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63)
and/or similar short signatures if we deploy OP_CHECKSIGFROMSTACK first.

Since most of the "scary" recursive convents are not available with
OP_CHECKSIGFROMSTACK within taproot (without further extensions), the
OP_CHECKSIGFROMSTACK proposal now has quite different consequences than
before.

On Thu, May 23, 2019 at 12:59 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Russell,
>
> While I am sympathetic to this argument from first principles, as I
> understand it, it requires that provided witness inputs will become larger,
> compared to "shortcuts" like `SIGHASH_ANYPREVOUT` and
> `OP_CHECKOUTPUTSHASHVERIFY`.
>
> For instance, to simulate `SIGHASH_ANYPREVOUT` with `OP_CAT` and
> `OP_CHECKSIGFROMSTACK`, I would effectively split the unsigned transaction
> into its "inputs" and "outputs" part, concat them and use
> `OP_CHECKSIGFROMSTACK` on the chaperone signature, and also use a normal
> `OP_CHECKSIGVERIFY` on that same chaperone signature, then dup the
> "outputs" part and use `OP_CHECKSIGFROMSTACK` on the "any
> prevout"/"noinput" signature.
> I would effectively give the transaction to itself as part of the witness,
> and further, I would also have to very carefully write the script
> (admittedly the writing of the template could be done once, but it would
> require far more review than simple usages of the "limited" operations like
> `SIGHASH_ANYPREVOUT`).
> So my witness stack would contain two signatures, and a duplicate of the
> transaction itself, plus a very much complicated script, whereas use of
> `SIGHASH_ANYPREVOUT` just requires two signatures and a script not much
> longer than pre-Schnorr multisig scripts.
>
>
> It seems to me desirable, to try to reduce bandwidth consumption on the
> Bitcoin blockchain, including witness data.
> Indeed, I had thought the whole exercise of putting `OP_CHECKSIGFROMSTACK`
> in a federated sidechain (Elements/Liquid) was to try to identify common
> patterns of usage for that opcode, and *then* to propose those common
> patterns as specific "optimized" opcodes as a sort of "jet" for Bitcoin
> itself (but not `OP_CHECKSIGFROMSTACK` itself).
>
> Regards,
> ZmnSCPxj
>
>
> Sent with ProtonMail Secure Email.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190523/1d4853e6/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Fri May 24 03:51:13 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 24 May 2019 03:51:13 +0000
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAJR7vkqogCzy8_SpCxcAhnEdkS6DRKaDtvJa8Wc-TNGsCcjM5g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<CAJR7vkqogCzy8_SpCxcAhnEdkS6DRKaDtvJa8Wc-TNGsCcjM5g@mail.gmail.com>
Message-ID: <t6W0uozSuBP3lw7_leWuRW28TY9d31o5G8GxHQc4VoDFG3xBX0AKvUvCJMZpfLtlt5S1UGJhJMN6_Nr5MZoWRbxvNRx_-DqBa51EffCjXjI=@protonmail.com>

Good morning Jimmy,

??????? Original Message ???????
On Friday, May 24, 2019 1:36 AM, Jimmy Song via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Russell,
>
> This is probably a dumb question, but I'd like to get some clarity on your proposal.
>
> OP_CHECKSIGFROMSTACKVERIFY would pop off a signature, message and pubkey. Presumably, the message would then have to get constructed as part of the Script execution. What would such a message look like? What, in other words, would you be signing and would that be similar to what signatures sign now? Would it be a single blob that incorporates all the input/output information in some hashed manner (like BIP143)? Or would you need separate signatures for different parts of the transaction? Or is it something more complicated like aggregating multiple signatures over different parts of the transaction?

In order to use `OP_CHECKSIGFROMSTACK` work to allow transaction introspection, the message to be signed would be the equivalent of the sighash digest using `SIGHASH_ALL`.

As a general pattern, if you want a SCRIPT that imposes some rule on some field in the sighash digest of the transaction:

1.  You would require that the transaction be split into three parts, with those parts provided in the witness stack.
    One would be "data before the field", then "the field", then "data after the field".
2.  In addition, you would require a signature for the transaction in addition to the transaction parts above.
3.  You would ensure that "data before the field" is the correct size, so that you know "the field" is at the correct location in the transaction.
    Alternately you might need to also introspect some other fields in order to ensure other details like number of inputs, number of outputs, value of inputs etc. etc. are what you expect.
4.  You would check that the given signature is `SIGHASH_ALL` (most easily by checking its size --- proposed Schnorr signatures have a fixed size, and the lack of an extra sighash flags byte means `SIGHASH_ALL` by default, so if the signature is exactly the fixed Schnorr signature size, it is `SIGHASH_ALL`).
5.  You would use normal `OP_CHECKSIGVERIFY` to ensure that the signature signs the actual transaction.
6.  You would concatenate the supposed parts of the transaction together and use `OP_CHECKSIGFROMSTACKVERIFY` to ensure that the signature *also* is valid for that.
    Since you know the signature is valid for the transaction itself, if it *also* is valid for this, then the concatenation of the input "data before the field", "the field", and "data after the field" is exactly the same sighash digest as the actual transaction, and thus is accurate to the transaction.
7.  Finally, you would actually validate the field you want to impose some rule on.

`SIGHASH_ALL` is suggested since it allows you to introspect all fields, but also because ensuring that the signature is indeed a `SIGHASH_ALL` signature is easier (just do the size check).
Alternately you can use some other flag, but you would require the signature on the stack to be flagless and concat the flag yourself before using `OP_CHECKSIGVERIFY`.

This mechanism is very general and allows SCRIPT to introspect *any* field of the transactions.
Indeed, one can argue that `OP_CHECKLOCKTIMEVERIFY` and `OP_CHECKSEQUENCEVERIFY` are both superfluous in a system with `OP_CAT` and `OP_CHECKSIGFROMSTACK`.
OF course, these operations are significantly more optimized since they do not require that you quine the transaction.

Regards,
ZmnSCPxj


>
> Best,
>
> Jimmy
>
> On Thu, May 23, 2019 at 8:35 AM Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Recently there have been some tapscript proposals, SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY, that aim to enable particular new features for Bitcoin via new Script operations.? However, I think that these proposals miss the mark when it comes to how they approach Bitcoin Script and language features.
> >
> > Bitcoin Script appears designed to be a flexible programmable system that provides generic features to be composed to achieve various purposes.? Thus, when we design new language features for Script, we should be striving, as much as possible, to similarly build general purpose tools which can in turn be used for a variety of purposes.
> >
> > I feel the SIGHASH_ANYPREVOUT and OP_CHECKOUTPUTHASHVERIFY proposals fail to achieve these design goals.? They are both are designed with very narrow applications in mind, while also going out of their way to extend the semantic domain of the interpretation of Bitcoin operations in new ways that complicate their specification.? In the case of SIGHASH_ANYPREVOUT, the semantic domain is extended by adding new counters to track the use of various v0 and v2 signature types.? In the case of OP_CHECKOUTPUTHASHVERIFY, it employs a new context-sensitive operation that peeks at the value of surrounding opcodes.
> >
> > Instead, I propose that, for the time being, we simply implement OP_CAT and OP_CHECKSIGFROMSTACKVERIFY.? OP_CAT pops two byte arrays off the stack and pushes their concatenation back onto the stack.? OP_CHECKSIGFROMSTACKVERIFY pops a signature, message, and pubkey off the stack and performs a bip-schnorr verification on the SHA256 hash of the message.
> >
> > In concert, these two operations enable:
> >
> > * Oracle signature verification, including discrete log contracts.
> > * Amortized secure multiparty computations (see "Amortizing Secure Computation with Penalties" by Kumaresan and Bentov).
> > * Transaction introspection including:
> > +?Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the nature of the construction.
> > + Decide if a transaction has exactly one input or not. (etc.)
> > + Weak covenants, which can verify output scripts to see if they are among a set of predefined values or verify the output hash.
> >
> > and presumably more applications as well.
> >
> > For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.
> >
> > All this is accomplished by two straightforward opcodes whose semantics are pure computational operations on stack values.? The only semantic side-effect is that OP_CHECKSIGFROMSTACKVERIFY would count towards the existing 'sigops_passed' count.? Moreover, I feel that adding these operations does not preclude adding more specialized opcodes in the future as an optimization for whatever popular constructions come up, once we know what those are.
> >
> > I feel that this style of generic building blocks truly embodies what is meant by "programmable money".
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ZmnSCPxj at protonmail.com  Fri May 24 04:15:45 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 24 May 2019 04:15:45 +0000
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <CCdF2y99R_xiyrtQ3F80GDSpQVWJztgS71HaHXEHq1cZmj0om0Ge7yMEtx_QY4MMOD6qHT1YE3cn-3o-wVWWS3KatMQE8W-GJnolna_prsI=@protonmail.com>

> For better or for worse, without an OP_PUBKEYTWEEK operation available, the more interesting recursive-covenants remain largely out of reach, with the exception of a recursive covenant that is only able to send back to its own address, possibly abusing its own TXO value as a state variable.

After some thinking, I may have devised a way to achieve the more interesting Turing-complete system (where each "loop through" requires paying a fee to miners, akin to Ethereum Gas, and thus a good way to build new footguns) even without `OP_PUBKEYTWEAK`.

I observe the following:

1.  `OP_CHECKSIGFROMSTACK` can introspect into the transaction *doing the spend* by giving the transaction (minus witness) as part of the witness (i.e. quining).
2.  The above can be leveraged to introspect into the transaction *being spent* by giving that transaction *being spent* (minus witness) as part of the witness stack.
    This is because the transaction *doing the spend* commits to the transaction *being spent* by referring to its txid.
    We can concatenate the bits of the previous transaction and confirm that it is indeed the transaction *being spent* by hashing and comparing that to the txid in the input of the transaction *doing the spend*.
3.  The transaction *being spent* can contain an `OP_RETURN` output that contains the previous state (or a commitment to the previous state if it is too large to fit in an `OP_RETURN`, again requiring that the previous state be given as part of the witness).
    Since it can be introspected, a script can acquire a "previous state" data.
4.  The transaction *doing the spend* can also contain an `OP_RETURN` with the next state (or commitment to next state).
5.  The rest of the script can then determine if the transition from "previous state" to "next state" is valid.
6.  The script can impose that the same script is paid to by introspecting the transaction *being spent* to get at a commitment to itself.

The above seems enough to create a potentially unbound loop, bound only by the amount of money you are willing to spend on fees operating that loop.
The "state" would be the memory of your virtual machine, and the SCRIPT validates the execution of one iteration of the interpreter loop, and that would be enough to create a Turing-complete system within Bitcoin.
With MAST, you can compress branches not taken, reducing the number of operations you have to expose at each iteration.

I admit *creating* this by hand will probably be very difficult, but that should be doable with an army of lower-level cognition agents.
(disclaimer: I am not an AI with an army of lower-level cognition agents and I can completely and totally pass the Turing test)


Regards,
ZmnSCPxj

From jl2012 at xbt.hk  Fri May 24 08:15:45 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 24 May 2019 16:15:45 +0800
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
Message-ID: <21B03A11-EED7-423B-B885-9A963E86A708@xbt.hk>

A gamble like this, decentralised or not, is easy to manipulate since difficulty is determined entirely by the last block in a cycle

> On 24 May 2019, at 1:42 AM, Tamas Blummer via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Difficulty change has profound impact on miner?s production thereby introduce the biggest risk while considering an investment.
> Commodity markets offer futures and options to hedge risks on traditional trading venues. Some might soon list difficulty futures.
> 
> I think we could do much better than them natively within Bitcoin.
> 
> A better solution could be a transaction that uses nLocktime denominated in block height, such that it is valid after the difficulty adjusted block in the future.
> A new OP_DIFFICULTY opcode would put onto stack the value of difficulty for the block the transaction is included into. 
> The output script may then decide comparing that value with a strike which key can spend it. 
> The input of the transaction would be a multi-sig escrow of those who entered the bet. 
> The winner would broadcast. 
> 
> Once signed by both the transaction would not carry any counterparty risk and would not need an oracle to settle according to the bet.
> 
> I plan to draft a BIP for this as I think this opcode would serve significant economic interest of Bitcoin economy, and is compatible with Bitcoin?s aim not to introduce 3rd party to do so.
> 
> Do you see a fault in this proposal or want to contribute?
> 
> Tamas Blummer 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From natanael.l at gmail.com  Fri May 24 08:36:14 2019
From: natanael.l at gmail.com (Natanael)
Date: Fri, 24 May 2019 10:36:14 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CAPg+sBged=ivVLj9tAM6zZdvWdYnG5pj4gozac5EupFPLtwyfA@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAPg+sBged=ivVLj9tAM6zZdvWdYnG5pj4gozac5EupFPLtwyfA@mail.gmail.com>
Message-ID: <CAAt2M1_PKnJ5tR3VHgUg-=ibNVVp-Yocqa9KeUQhVj0X2PstGA@mail.gmail.com>

On Thu, May 23, 2019 at 9:58 PM Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> If the difficulty can be directly observed by the script language, you
> would need to re-evaluate all scripts in unconfirmed transactions
> whenever the difficulty changes. This complicates implementation of
> mempools, but it also makes reasoning about validity of (chains of)
> unconfirmed transactions harder, as an unconfirmed predecessor may
> have conditions that change over time.


To deal with potentially wildly varying difficulty, could the value exposed
be the sum of accumulated PoW, or in other words the sum of each block's
difficulty value in the entire chain? This should be a value that will only
rise unless a reorg happens after a difficulty drop happens (only likely to
be the result of users manually blacklisting an otherwise valid block that
is several blocks back in the chain).

This mimics the effect of the block number which only grows. So if you're
starting at time A with difficulty X, then you'd estimate what you think
the accumulated PoW ought to be at time B with expected difficulty Y (as
compared to the current value at time A), and put that value into the
script.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/2cdfd6bc/attachment.html>

From roconnor at blockstream.io  Fri May 24 15:10:21 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Fri, 24 May 2019 11:10:21 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <CAMZUoK=Y_08XHfkj=8D4wGsXT-hnFgD=KCyN=G4gWmLr8i7_=Q@mail.gmail.com>

On Wed, May 22, 2019 at 5:01 PM Russell O'Connor <roconnor at blockstream.io>
wrote:

> In concert, these two operations enable:
>
> * Oracle signature verification, including discrete log contracts.
>

Jonas informs me that I've misunderstood how discreet log contracts work.
The DLC signatures are not directly checked by Script and do not rely on
CHECKSIGFROMSTACK.  I apologize for my hasty literature review.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/ced6f553/attachment-0001.html>

From tamas.blummer at gmail.com  Fri May 24 16:23:38 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Fri, 24 May 2019 18:23:38 +0200
Subject: [bitcoin-dev] OP_DIFFICULTY to enable difficulty hedges (bets)
 without an oracle and 3rd party.
In-Reply-To: <CAAt2M1_PKnJ5tR3VHgUg-=ibNVVp-Yocqa9KeUQhVj0X2PstGA@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<42F53D61-BAAE-464F-BB0D-4D0CDC554D9A@gmail.com>
	<CAPg+sBged=ivVLj9tAM6zZdvWdYnG5pj4gozac5EupFPLtwyfA@mail.gmail.com>
	<CAAt2M1_PKnJ5tR3VHgUg-=ibNVVp-Yocqa9KeUQhVj0X2PstGA@mail.gmail.com>
Message-ID: <2502B467-092D-45A6-8F7B-9E3D08D5BB15@gmail.com>

yes, log2work is already computed and would be a strictly increasing value, like time. Thank you for this suggestion. I think attempting an implementation will give further clues it this more suitable to express the same.

Tamas Blummer

> On May 24, 2019, at 10:36, Natanael <natanael.l at gmail.com> wrote:
> 
> On Thu, May 23, 2019 at 9:58 PM Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> If the difficulty can be directly observed by the script language, you
> would need to re-evaluate all scripts in unconfirmed transactions
> whenever the difficulty changes. This complicates implementation of
> mempools, but it also makes reasoning about validity of (chains of)
> unconfirmed transactions harder, as an unconfirmed predecessor may
> have conditions that change over time.
> 
> To deal with potentially wildly varying difficulty, could the value exposed be the sum of accumulated PoW, or in other words the sum of each block's difficulty value in the entire chain? This should be a value that will only rise unless a reorg happens after a difficulty drop happens (only likely to be the result of users manually blacklisting an otherwise valid block that is several blocks back in the chain).
> 
> This mimics the effect of the block number which only grows. So if you're starting at time A with difficulty X, then you'd estimate what you think the accumulated PoW ought to be at time B with expected difficulty Y (as compared to the current value at time A), and put that value into the script.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/5d92fa56/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/5d92fa56/attachment.sig>

From jl2012 at xbt.hk  Fri May 24 19:12:32 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 25 May 2019 03:12:32 +0800
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
 proposal
In-Reply-To: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
Message-ID: <52AFAB05-040B-4310-9328-96E14A779D60@xbt.hk>

Functionally, COHV is a proper subset of ANYPREVOUT (NOINPUT). The only justification to do both is better space efficiency when making covenant.

With eltoo as a clear usecase of ANYPREVOUT, I?m not sure if we really want a very restricted opcode like COHV. But these are my comments, anyway:

1. The ?one input? rule could be relaxed to ?first input? rule. This allows adding more inputs as fees, as an alternative to CPFP. In case the value is insufficient to pay the required outputs, it is also possible to rescue the UTXO by adding more inputs.

2. While there is no reason to use non-minimal push, there is neither a reason to require minimal push. Since minimal push is never a consensus rule, COHV shouldn?t be a special case.

3. As I suggested in a different post (https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016963.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016963.html>), the argument for requiring a prevout binding signature may also be applicable to COHV

> On 21 May 2019, at 4:58 AM, Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hello bitcoin-devs,
> 
> Below is a link to a BIP Draft for a new opcode, OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless congestion control techniques via a rudimentary, limited form of covenant which does not bear the same technical and social risks of prior covenant designs.
> 
> Congestion control allows Bitcoin users to confirm payments to many users in a single transaction without creating the UTXO on-chain until a later time. This therefore improves the throughput of confirmed payments, at the expense of latency on spendability and increased average block space utilization. The BIP covers this use case in detail, and a few other use cases lightly.
> 
> The BIP draft is here:
> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki <https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki>
> 
> The BIP proposes to deploy the change simultaneously with Taproot as an OPSUCCESS, but it could be deployed separately if needed.
> 
> An initial reference implementation of the consensus changes and  tests which demonstrate how to use it for basic congestion control is available at https://github.com/JeremyRubin/bitcoin/tree/congestion-control <https://github.com/JeremyRubin/bitcoin/tree/congestion-control>.  The changes are about 74 lines of code on top of sipa's Taproot reference implementation.
> 
> Best regards,
> 
> Jeremy Rubin
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190525/26541eac/attachment-0001.html>

From roconnor at blockstream.io  Fri May 24 23:07:28 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Fri, 24 May 2019 19:07:28 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAD5xwhgVeTPP23SLrMrvXe6ApZyuuQq4us5z7wrPeJkx1+FSYA@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<CAD5xwhgVeTPP23SLrMrvXe6ApZyuuQq4us5z7wrPeJkx1+FSYA@mail.gmail.com>
Message-ID: <CAMZUoKkA4UFivR4xpFcSRE6ThtYawXh9M8my1HnKv34i4o6FJw@mail.gmail.com>

In order of escalating scope of amendments to OP_COSHV, I suggest

1) Peeking at surrounding data surrounding data should definitely be
replaced by a pushdata-like op-code that uses the subsequent 32-bytes
directly.  The OP_SUCCESSx upgrade path specifically allows for this, and
avoids complicating the semantics Bitcoin Script.
2) Furthermore, the number-of-input-verification and the
outputhash-verification operations ought to be split into different opcodes
as they are logically unrelated.
3) Better still, we should instead implement the transaction reflection
operations of OP_PUSHOUTPUTHASH and OP_NUMINPUTS that puts the outputhash
and number of inputs respectively onto the stack.  Recursive covenants
appear to be effectively impossible without either an OP_TWEEKPUBKEY or an
OP_PUSHSCRIPTPUBKEY so the effort your proposal goes through to guard
against placing an arbitrary outputhash onto the stack appears to be wasted
effort to me.
4) If we anticipate adding OP_CHECKSIGFROMSTACKVERIFY, then we should most
definitely prefer (3) instead of OP_COSHV, if we still feel the need to do
anything at all.  It is probably best to have both
OP_CHECKSIGFROMSTACKVERIFY and transaction reflection operations of
OP_PUSHOUTPUTHASH and OP_NUMINPUTS but I think I would be fine with just
OP_CHECKSIGFROMSTACKVERIFY as well.

On the other hand, if we are serious about preferring less per-block
bandwidth over reusable primitive opcodes for programming, then we should
instead abandon the RISC-style Bitcoin Script and instead add an
alternative CISC-style taproot leaf type that directly provides (a
conjunction of) the various popular common policies: channel opening,
channel factories, coinjoins, hashlocks, timelocks, congestion control
etc.  Segwit v0 already implements this CISC-style for the single most
popular policy: single signature verification.

On Fri, May 24, 2019 at 4:51 PM Jeremy <jlrubin at mit.edu> wrote:

> Hi Russell,
>
> Thanks for this detailed comparison. The COSHV BIP does include a brief
> comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more
> detailed.
>
>
> I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's
> clearly one of the more flexible options available and would enable a
> multitude of new use cases.
>
> When I originally presented my work on congestion control at Jan 2017
> BPASE, I also discussed it as an option for covenants. Unfortunately I
> think it may be on the edge of too powerful -- there are a lot of use cases
> and implications from having a potentially recursive covenant. If you see
> my response to Matt in the OP_COSHV BIP thread I classify it as enabling a
> non-computationally enumerable set of restrictions.
>
> I think also from a developer point of view working with OP_COSHV is much
> much simpler (maybe this can be abstracted) which will lead to increased
> adoption. OP_COSHV also uses less per-block bandwidth which also makes it
> preferable for a measure intended to decongest blocks. Do you know the
> exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with templating
> changes to taproot, can be a single byte. OP_COSHV also has less potential
> to have a negative interaction with future opcodes we may want like
> OP_PUBKEYTWEAK. While we're getting to an exact spec for the features we
> want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK
> unless there's an exact specification which makes us confident we're
> hitting all the points.
>
> If the main complaint about OP_COSHV is that it peeks at surrounding data,
> it's also possible to implement it more closely to a multi-byte pushdata
> opcode or do the template optimization.
>
> Lastly, as I have previously noted, OP_LEFT is probably safer to implement
> than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK scripts.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/868860a9/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat May 25 03:56:22 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 25 May 2019 03:56:22 +0000
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <CAD5xwhgN23tXDHx6rB3vspswaq8-QyPjFkgmXcPY_R83gUe54Q@mail.gmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
	<CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
	<CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
	<CAD5xwhiHHemzaRLC7WMeXQ5hgu0rwMKMUym34xTxWO81qqf-oQ@mail.gmail.com>
	<vbL4Nj9knpm6GMzS3wfTOcDPz9F6RoStna3mDwgJmmvYa1mPWa62x_atF3kBXjajlTDIxerTsYRr5pzI3xC3eSM_ssffsrXESqoNqMSg2h4=@protonmail.com>
	<CAD5xwhgN23tXDHx6rB3vspswaq8-QyPjFkgmXcPY_R83gUe54Q@mail.gmail.com>
Message-ID: <NtcMB87WFBKpIzRKHh5bbEeBFGITr2k0qAgmrSE97X30gYJI2RRldrNdeL8X3e50N9N-m6cbuPistWniu3gadi3LuF7oYLltuINj2heepVw=@protonmail.com>

Good morning Jeremy,

I believe I have caught the general point.
Indeed, I agree that this is useful, but it is *not* useful for these cases:

1.  CoinJoin - the initial funding transaction must be signed by the participants anyway after checking that the output is correct.
    Further any spend that is not a signature spend is going to defeat the purpose of CoinJoin trying to be private by imitating "typical" spends: if `OP_CHECKOUTPUTSHASHVERIFY` path is used, you have just lost the CoinJoin privacy by reducing anonymity set.
2.  Channel Factories - the initial funding transaction must be signed by the participants anyway after each initial sub-channel initial commitment / initial update+state transaction is signed.

In both above cases, the issue of users dropping out during the step of signing the initial funding transaction is unavoidable even with `OP_CHECKOUTPUTSHASHVERIFY`.

For congestion control, and for general "I promise to set this up later" as in c*stodial-service-directly-to-channel etc., I already agree this is useful.

My objection lies *only* with the above two cases, wherein `OP_CHECKOUTPUTSHASHVERIFY` does not really improve things, as you *still* need to coordinate multiple signers anyway.

You have convinced me already that the other cases are good example usages of this opcode.

Regards,
ZmnSCPxj




Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, May 25, 2019 5:15 AM, Jeremy <jlrubin at mit.edu> wrote:

> ZmnSCIPxj,
>
> I think you're missing the general point, so I'm just going to respond to one point to see if that helps your understanding of why OP_COSHV is better than just pre-signed.
>
> The reason why MuSig and other distributed signing solutions are not acceptable for this case is they all require interaction for guarantee of payout.
>
> In contrast, I can use a OP_COSHV Taproot key to request a withdrawal from an exchange which some time later pays out to a lot of people, rather than having to withdraw multiple times and then pay. The exchange doesn't have to know this is what I did. They also don't have to tell me the exact inputs they'll spend to me or if I'm batched or not (batching largely incompatible with pre-signing unless anyprevout)
>
> The exchange can take my withdrawal request and aggregate it to other payees into a tree as well, without requiring permission from the recipients.
>
> They can also -- without my permission -- make the payment not directly into me, but into a payment channel between me and the exchange, allowing me to undo the withdrawal by routing money back to the exchange over lightning.
>
> The exchange can take some inbound payments to their hot wallet and move them into cold storage with pre-set spending paths. They don't need to use ephemeral keys (how was that entropy created?) nor do they need to bring on their cold storage keys to pre-sign the spending paths.
>
> None of this really works well with just pre-signing because you need to ask for permission first in order to do these operations, but with OP_COSHV you can, just as the payer without talking to anyone else, or just as the recipient commit your funds to a complex txn structure.
>
> Lastly, think about this in terms of DoS. You have a set of N users who request a payment. You build the tree, collect signatures, and then at the LAST step of building the tree, one user drops out. You restart, excluding that user. Then a different user drops. Meanwhile you've had to keep your funds locked up to guarantee those inputs for the txn when it finalizes.
>
> In contrast, once you receive the requests with OP_COSHV, there's nothing else to do. You just issue the transaction and move on.
>
> Does that make sense as to why a user would prefer this, even if there is an emulation with pre-signed txns?



From jl2012 at xbt.hk  Sat May 25 07:53:34 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 25 May 2019 15:53:34 +0800
Subject: [bitcoin-dev] Safety of committing only to transaction outputs
In-Reply-To: <CAD5xwhhsk_4+C3dROGhBZqjmiqmOO+hGYR9qawbJ9MDW0so4=Q@mail.gmail.com>
References: <77218514-9118-4FE2-8F7F-7BB215CF2BB6@xbt.hk>
	<CAD5xwhhsk_4+C3dROGhBZqjmiqmOO+hGYR9qawbJ9MDW0so4=Q@mail.gmail.com>
Message-ID: <EB79DBDB-9C29-4699-9A06-27D1A2896661@xbt.hk>



> On 25 May 2019, at 4:59 AM, Jeremy <jlrubin at mit.edu> wrote:
> 
> Hi Johnson,
> 
> As noted on the other thread, witness replay-ability can be helped by salting the taproot key or the taproot leaf script at the last stage of a congestion control tree.
> 

The salt will be published when it is first spent. Salting won?t help if the address is reused.

> I also think that chaperone signatures should be opt-in; there are cases where we may not want them. OP_COSHV is compatible with an additional checksig operation.
> 
> There are also other mechanisms that can improve the safety. Proposed below:
> 
> OP_CHECKINPUTSHASHVERIFY -- allow checking that the hash of the inputs is a particular value. The top-level of a congestion control tree can check that the inputs match the desired inputs for that spend, and default to requiring N of N otherwise. This is replay proof! This is useful for other applications too.

It is circular dependent: the script has to commit to the txid, and the txid is a function of script


> 
> OP_CHECKFEEVERIFY -- allowing an explicit commitment to the exact amount of fee limits replay to txns which were funded with the exact amount of the prior. If there's a mismatch, an alternative branch can be used. This is a generally useful mechanism, but means that transactions using it must have all inputs/outputs set.
> 

This restricts replayability to input with same value, but is still replay-able, just like ANYPREVOUT committing to the input value


> Best,
> 
> Jeremy
> --
> @JeremyRubin <https://twitter.com/JeremyRubin> <https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190525/cebe50ff/attachment.html>

From jlrubin at mit.edu  Fri May 24 20:36:03 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 24 May 2019 13:36:03 -0700
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <52AFAB05-040B-4310-9328-96E14A779D60@xbt.hk>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<52AFAB05-040B-4310-9328-96E14A779D60@xbt.hk>
Message-ID: <CAD5xwhj58kq-HJTKKpq8VaXoWcw-Oec=kRhbd9SdxpE83n6Mew@mail.gmail.com>

Hi Johnson,

Thanks for the review. I do agree that OP_COSHV (note the pluralization --
it would also be possible to do a OP_COHV <index> <hash> to do specific
outputs).

I think the point of OP_COSHV is that something like ANYPREVOUT is much
more controversial. OP_COSHV is a subset by design. The IF on ANYPREVOUT is
substantial, discussion I've seen shows that the safety of ANYPREVOUT is
far from fully agreed. (I'll respond to your other email on the subject
too). OP_COSHV is also proposed specifically as a congestion control
mechanism, and so keeping it very easy to verify and minimal data
(optimizations allow reducing it to just OP_COSHV with no 32 byte argument)
suggest this approach is preferable.

In an earlier version, rather than have it be the first input restriction,
I had implemented it an an only one input restriction. This makes it easier
to work with SIGHASH_SINGLE. This works by having the PrecomputedData have
a atomic test_flag. However I felt that the statefulness between
verifications was not great and so I simplified it.

There actually is a reason to require minimal push -- maybe we can change
the rule to be non-minimal pushes are ignored, because we can later extend
it with a different rule. This seems a little error prone. There's also no
reason to not just treat OP_COSHV as a pushdata 32 itself, and drop the
extra byte if we don't care about versioning later.

Requiring a signature actually makes COSHV less useful. So I'm against that
-- such a signature prevents using OP_COSHV for non-interactive
setups/uncoordinated setups where the txids are unstable. It also makes
building the trees more expensive. If you want this feature, a better thing
to do would be to always tweak leaf nodes of the tx tree entropy so that
it's unique per key and doesn't impose extra data at every node, only the
leafs of the expansion tree.


--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, May 24, 2019 at 12:13 PM Johnson Lau <jl2012 at xbt.hk> wrote:

> Functionally, COHV is a proper subset of ANYPREVOUT (NOINPUT). The only
> justification to do both is better space efficiency when making covenant.
>
> With eltoo as a clear usecase of ANYPREVOUT, I?m not sure if we really
> want a very restricted opcode like COHV. But these are my comments, anyway:
>
> 1. The ?one input? rule could be relaxed to ?first input? rule. This
> allows adding more inputs as fees, as an alternative to CPFP. In case the
> value is insufficient to pay the required outputs, it is also possible to
> rescue the UTXO by adding more inputs.
>
> 2. While there is no reason to use non-minimal push, there is neither a
> reason to require minimal push. Since minimal push is never a consensus
> rule, COHV shouldn?t be a special case.
>
> 3. As I suggested in a different post (
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016963.html),
> the argument for requiring a prevout binding signature may also be
> applicable to COHV
>
> On 21 May 2019, at 4:58 AM, Jeremy via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hello bitcoin-devs,
>
> Below is a link to a BIP Draft for a new opcode,
> OP_CHECKOUTPUTSHASHVERIFY. This opcode enables an easy-to-use trustless
> congestion control techniques via a rudimentary, limited form of covenant
> which does not bear the same technical and social risks of prior covenant
> designs.
>
> Congestion control allows Bitcoin users to confirm payments to many users
> in a single transaction without creating the UTXO on-chain until a later
> time. This therefore improves the throughput of confirmed payments, at the
> expense of latency on spendability and increased average block space
> utilization. The BIP covers this use case in detail, and a few other use
> cases lightly.
>
> The BIP draft is here:
>
> https://github.com/JeremyRubin/bips/blob/op-checkoutputshashverify/bip-coshv.mediawiki
>
> The BIP proposes to deploy the change simultaneously with Taproot as an
> OPSUCCESS, but it could be deployed separately if needed.
>
> An initial reference implementation of the consensus changes and  tests
> which demonstrate how to use it for basic congestion control is available
> at https://github.com/JeremyRubin/bitcoin/tree/congestion-control.  The
> changes are about 74 lines of code on top of sipa's Taproot reference
> implementation.
>
> Best regards,
>
> Jeremy Rubin
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/d3863a38/attachment.html>

From jlrubin at mit.edu  Fri May 24 20:51:21 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 24 May 2019 13:51:21 -0700
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <CAD5xwhgVeTPP23SLrMrvXe6ApZyuuQq4us5z7wrPeJkx1+FSYA@mail.gmail.com>

Hi Russell,

Thanks for this detailed comparison. The COSHV BIP does include a brief
comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more
detailed.


I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's
clearly one of the more flexible options available and would enable a
multitude of new use cases.

When I originally presented my work on congestion control at Jan 2017
BPASE, I also discussed it as an option for covenants. Unfortunately I
think it may be on the edge of too powerful -- there are a lot of use cases
and implications from having a potentially recursive covenant. If you see
my response to Matt in the OP_COSHV BIP thread I classify it as enabling a
non-computationally enumerable set of restrictions.

I think also from a developer point of view working with OP_COSHV is much
much simpler (maybe this can be abstracted) which will lead to increased
adoption. OP_COSHV also uses less per-block bandwidth which also makes it
preferable for a measure intended to decongest blocks. Do you know the
exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with templating
changes to taproot, can be a single byte. OP_COSHV also has less potential
to have a negative interaction with future opcodes we may want like
OP_PUBKEYTWEAK. While we're getting to an exact spec for the features we
want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK
unless there's an exact specification which makes us confident we're
hitting all the points.

If the main complaint about OP_COSHV is that it peeks at surrounding data,
it's also possible to implement it more closely to a multi-byte pushdata
opcode or do the template optimization.

Lastly, as I have previously noted, OP_LEFT is probably safer to implement
than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK scripts.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/77a5aad9/attachment-0001.html>

From jlrubin at mit.edu  Fri May 24 20:59:03 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 24 May 2019 13:59:03 -0700
Subject: [bitcoin-dev] Safety of committing only to transaction outputs
In-Reply-To: <77218514-9118-4FE2-8F7F-7BB215CF2BB6@xbt.hk>
References: <77218514-9118-4FE2-8F7F-7BB215CF2BB6@xbt.hk>
Message-ID: <CAD5xwhhsk_4+C3dROGhBZqjmiqmOO+hGYR9qawbJ9MDW0so4=Q@mail.gmail.com>

Hi Johnson,

As noted on the other thread, witness replay-ability can be helped by
salting the taproot key or the taproot leaf script at the last stage of a
congestion control tree.

I also think that chaperone signatures should be opt-in; there are cases
where we may not want them. OP_COSHV is compatible with an additional
checksig operation.

There are also other mechanisms that can improve the safety. Proposed below:

OP_CHECKINPUTSHASHVERIFY -- allow checking that the hash of the inputs is a
particular value. The top-level of a congestion control tree can check that
the inputs match the desired inputs for that spend, and default to
requiring N of N otherwise. This is replay proof! This is useful for other
applications too.

OP_CHECKFEEVERIFY -- allowing an explicit commitment to the exact amount of
fee limits replay to txns which were funded with the exact amount of the
prior. If there's a mismatch, an alternative branch can be used. This is a
generally useful mechanism, but means that transactions using it must have
all inputs/outputs set.

Best,

Jeremy
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, May 24, 2019 at 7:40 AM Johnson Lau via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This is a meta-discussion for any approach that allows the witness
> committing to only transaction outputs, but not inputs.
>
> We can already do the following things with the existing bitcoin script
> system:
> * commit to both inputs and outputs: SIGHASH_ALL or SIGHASH_SINGLE, with
> optional SIGHASH_ANYONECANPAY
> * commit to only inputs but not outputs: SIGHASH_NONE with optional
> SIGHASH_ANYONECANPAY
> * not commit to any input nor output: not using any sigop; using a trivial
> private key; using the SIGHASH_SINGLE bug in legacy script
>
> The last one is clearly unsafe as any relay/mining node may redirect the
> payment to any output it chooses. The witness/scriptSig is also replayable,
> so any future payment to this script will likely be swept immediately
>
> SIGHASH_NONE with ANYONECANPAY also allows redirection of payment, but the
> signature is not replayable
>
> But it?s quite obvious that not committing to outputs are inherently
> insecure
>
> The existing system doesn?t allow committing only to outputs, and we now
> have 3 active proposals for this function:
>
> 1. CAT and CHECKSIGFROMSTACK (CSFS):
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016946.html
> 2. ANYPREVOUT (aka NOINPUT):
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016929.html
> 3. CHECKOUTPUTSHASHVERIFY (COHV):
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
>
> With outputs committed, redirecting payment is not possible. On the other
> hand, not committing to any input means the witness is replayable without
> the consent of address owner. Whether replayability is acceptable is
> subject to controversy, but the ANYPREVOUT proposal fixes this by requiring
> a chaperone signature that commits to input. However, if the rationale for
> chaperone signature stands, it should be applicable to all proposals listed
> above.
>
> A more generic approach is to always require a ?safe" signature that
> commits to at least one input. However, this interacts poorly with the
> "unknown public key type? upgrade path described in bip-tapscript (
> https://github.com/sipa/bips/blob/bip-schnorr/bip-tapscript.mediawiki),
> since it?d be a hardfork to turn an ?unknown type sig? into a ?safe sig?.
> But we could still use a new ?leaf version? every time we introduce new
> sighash types, so we could have a new definition for ?safe sig?. I expect
> this would be a rare event and it won?t consume more than a couple leaf
> versions. By the way, customised sighash policies could be done with
> CAT/CSFS.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/9e31d870/attachment-0001.html>

From jlrubin at mit.edu  Fri May 24 21:15:07 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 24 May 2019 14:15:07 -0700
Subject: [bitcoin-dev] Congestion Control via OP_CHECKOUTPUTSHASHVERIFY
	proposal
In-Reply-To: <vbL4Nj9knpm6GMzS3wfTOcDPz9F6RoStna3mDwgJmmvYa1mPWa62x_atF3kBXjajlTDIxerTsYRr5pzI3xC3eSM_ssffsrXESqoNqMSg2h4=@protonmail.com>
References: <CAD5xwhgHyR5qdd09ikvA_vgepj4o+Aqb0JA_T6FuqX56ZNe1RQ@mail.gmail.com>
	<VU6YVz_dc9U4BhGd6WWNvYLS-DI1lBE14tpYdXEyIufTZ2OvqQfcWh6RVelCLWTQMWqiNsSf_AM3Pq2hzn3G62RIQwceLx54rRmD-zHCdNU=@protonmail.com>
	<CAD5xwhixyvAA0zak86BwG3ZjinUJ37266K_wn_NCa-ECrVmouw@mail.gmail.com>
	<CljXxJhTEILR7KZxgZ3o_yJm66XeySWzUY3abCm01blY9yX3AmMczvu41CAm9dr4ZQTDCTQqEM1D4MhEaGASuM54l51DaJmZSKv0eqtPjEo=@protonmail.com>
	<CAD5xwhiHHemzaRLC7WMeXQ5hgu0rwMKMUym34xTxWO81qqf-oQ@mail.gmail.com>
	<vbL4Nj9knpm6GMzS3wfTOcDPz9F6RoStna3mDwgJmmvYa1mPWa62x_atF3kBXjajlTDIxerTsYRr5pzI3xC3eSM_ssffsrXESqoNqMSg2h4=@protonmail.com>
Message-ID: <CAD5xwhgN23tXDHx6rB3vspswaq8-QyPjFkgmXcPY_R83gUe54Q@mail.gmail.com>

ZmnSCIPxj,

I think you're missing the general point, so I'm just going to respond to
one point to see if that helps your understanding of why OP_COSHV is better
than just pre-signed.

The reason why MuSig and other distributed signing solutions are not
acceptable for this case is they all require interaction for guarantee of
payout.

In contrast, I can use a OP_COSHV Taproot key to request a withdrawal from
an exchange which some time later pays out to a lot of people, rather than
having to withdraw multiple times and then pay. The exchange doesn't have
to know this is what I did. They also don't have to tell me the exact
inputs they'll spend to me or if I'm batched or not (batching largely
incompatible with pre-signing unless anyprevout)

The exchange can take my withdrawal request and aggregate it to other
payees into a tree as well, without requiring permission from the
recipients.

They can also -- without my permission -- make the payment not directly
into me, but into a payment channel between me and the exchange, allowing
me to undo the withdrawal by routing money back to the exchange over
lightning.

The exchange can take some inbound payments to their hot wallet and move
them into cold storage with pre-set spending paths. They don't need to use
ephemeral keys (how was that entropy created?) nor do they need to bring on
their cold storage keys to pre-sign the spending paths.

None of this really works well with just pre-signing because you need to
ask for permission first in order to do these operations, but with OP_COSHV
you can, just as the payer without talking to anyone else, or just as the
recipient commit your funds to a complex txn structure.

Lastly, think about this in terms of DoS. You have a set of N users who
request a payment. You build the tree, collect signatures, and then at the
LAST step of building the tree, one user drops out. You restart, excluding
that user. Then a different user drops. Meanwhile you've had to keep your
funds locked up to guarantee those inputs for the txn when it finalizes.

In contrast, once you receive the requests with OP_COSHV, there's nothing
else to do. You just issue the transaction and move on.


Does that make sense as to why a user would prefer this, even if there is
an emulation with pre-signed txns?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/082629f1/attachment-0001.html>

From jlrubin at mit.edu  Sat May 25 01:08:00 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 24 May 2019 18:08:00 -0700
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoKkA4UFivR4xpFcSRE6ThtYawXh9M8my1HnKv34i4o6FJw@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<CAD5xwhgVeTPP23SLrMrvXe6ApZyuuQq4us5z7wrPeJkx1+FSYA@mail.gmail.com>
	<CAMZUoKkA4UFivR4xpFcSRE6ThtYawXh9M8my1HnKv34i4o6FJw@mail.gmail.com>
Message-ID: <CAD5xwhi9YoJ30xOo++mxqLeeGV7gy5kkucUSGzPJ9BkVVKxbfg@mail.gmail.com>

What do you think about having it be OP_CHECK_TXID_TEMPLATE_DATA where the
hash checked is the TXID of the transaction with the inputs set to 0000...
(maybe appended to the fee paid)?

This allows for a variable number of inputs to be allowed (e.g., one, two,
etc). This also fixes potential bugs around TXID malleability for lightning
like setups (Greg and I discussed in wizards about version malleability).

Allowing multiple inputs is great for structuring more complex contracts
with multiple nodes paying into the same covenantted transaction.

Also I personally prefer a RISC+CISC approach -- we should enable the
common paths easily as they are known (didn't you come up with jets?) and
improve security for API users, but also piecemeal enable features in
script to allow for experimentation or custom contracts.
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, May 24, 2019 at 4:15 PM Russell O'Connor <roconnor at blockstream.io>
wrote:

> In order of escalating scope of amendments to OP_COSHV, I suggest
>
> 1) Peeking at surrounding data surrounding data should definitely be
> replaced by a pushdata-like op-code that uses the subsequent 32-bytes
> directly.  The OP_SUCCESSx upgrade path specifically allows for this, and
> avoids complicating the semantics Bitcoin Script.
> 2) Furthermore, the number-of-input-verification and the
> outputhash-verification operations ought to be split into different opcodes
> as they are logically unrelated.
> 3) Better still, we should instead implement the transaction reflection
> operations of OP_PUSHOUTPUTHASH and OP_NUMINPUTS that puts the outputhash
> and number of inputs respectively onto the stack.  Recursive covenants
> appear to be effectively impossible without either an OP_TWEEKPUBKEY or an
> OP_PUSHSCRIPTPUBKEY so the effort your proposal goes through to guard
> against placing an arbitrary outputhash onto the stack appears to be wasted
> effort to me.
> 4) If we anticipate adding OP_CHECKSIGFROMSTACKVERIFY, then we should most
> definitely prefer (3) instead of OP_COSHV, if we still feel the need to do
> anything at all.  It is probably best to have both
> OP_CHECKSIGFROMSTACKVERIFY and transaction reflection operations of
> OP_PUSHOUTPUTHASH and OP_NUMINPUTS but I think I would be fine with just
> OP_CHECKSIGFROMSTACKVERIFY as well.
>
> On the other hand, if we are serious about preferring less per-block
> bandwidth over reusable primitive opcodes for programming, then we should
> instead abandon the RISC-style Bitcoin Script and instead add an
> alternative CISC-style taproot leaf type that directly provides (a
> conjunction of) the various popular common policies: channel opening,
> channel factories, coinjoins, hashlocks, timelocks, congestion control
> etc.  Segwit v0 already implements this CISC-style for the single most
> popular policy: single signature verification.
>
> On Fri, May 24, 2019 at 4:51 PM Jeremy <jlrubin at mit.edu> wrote:
>
>> Hi Russell,
>>
>> Thanks for this detailed comparison. The COSHV BIP does include a brief
>> comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more
>> detailed.
>>
>>
>> I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's
>> clearly one of the more flexible options available and would enable a
>> multitude of new use cases.
>>
>> When I originally presented my work on congestion control at Jan 2017
>> BPASE, I also discussed it as an option for covenants. Unfortunately I
>> think it may be on the edge of too powerful -- there are a lot of use cases
>> and implications from having a potentially recursive covenant. If you see
>> my response to Matt in the OP_COSHV BIP thread I classify it as enabling a
>> non-computationally enumerable set of restrictions.
>>
>> I think also from a developer point of view working with OP_COSHV is much
>> much simpler (maybe this can be abstracted) which will lead to increased
>> adoption. OP_COSHV also uses less per-block bandwidth which also makes it
>> preferable for a measure intended to decongest blocks. Do you know the
>> exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with templating
>> changes to taproot, can be a single byte. OP_COSHV also has less potential
>> to have a negative interaction with future opcodes we may want like
>> OP_PUBKEYTWEAK. While we're getting to an exact spec for the features we
>> want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK
>> unless there's an exact specification which makes us confident we're
>> hitting all the points.
>>
>> If the main complaint about OP_COSHV is that it peeks at surrounding
>> data, it's also possible to implement it more closely to a multi-byte
>> pushdata opcode or do the template optimization.
>>
>> Lastly, as I have previously noted, OP_LEFT is probably safer to
>> implement than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK
>> scripts.
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190524/e41318e9/attachment-0001.html>

From roconnor at blockstream.io  Sat May 25 12:52:44 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 25 May 2019 08:52:44 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAD5xwhi9YoJ30xOo++mxqLeeGV7gy5kkucUSGzPJ9BkVVKxbfg@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<CAD5xwhgVeTPP23SLrMrvXe6ApZyuuQq4us5z7wrPeJkx1+FSYA@mail.gmail.com>
	<CAMZUoKkA4UFivR4xpFcSRE6ThtYawXh9M8my1HnKv34i4o6FJw@mail.gmail.com>
	<CAD5xwhi9YoJ30xOo++mxqLeeGV7gy5kkucUSGzPJ9BkVVKxbfg@mail.gmail.com>
Message-ID: <CAMZUoKmxxS9fDd8ZA0gvFe+q_W=Pwh+6LzZ1bZXxOh4iPmxD1Q@mail.gmail.com>

Allowing multiple inputs is certainly better than the 1 restriction COSHV.

However, I agree on your preference for a RISC+CISC approach.  Which is why
instead of COSHV or CHECK_TXID_TEMPLACE_DATA we should do the more RISC-y
thing and begin adding transaction reflection primitives, starting with
OP_NUMINPUTS and OP_PUSHOUTPUTSHASH.  Nothing bad will happen by pushing
the OUTPUTSHASH onto the stack, and we won't even get recursive covenants
with just these transaction reflection primitives in tapscript.

On Fri, May 24, 2019 at 9:08 PM Jeremy <jlrubin at mit.edu> wrote:

> What do you think about having it be OP_CHECK_TXID_TEMPLATE_DATA where the
> hash checked is the TXID of the transaction with the inputs set to 0000...
> (maybe appended to the fee paid)?
>
> This allows for a variable number of inputs to be allowed (e.g., one, two,
> etc). This also fixes potential bugs around TXID malleability for lightning
> like setups (Greg and I discussed in wizards about version malleability).
>
> Allowing multiple inputs is great for structuring more complex contracts
> with multiple nodes paying into the same covenantted transaction.
>
> Also I personally prefer a RISC+CISC approach -- we should enable the
> common paths easily as they are known (didn't you come up with jets?) and
> improve security for API users, but also piecemeal enable features in
> script to allow for experimentation or custom contracts.
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
>
> On Fri, May 24, 2019 at 4:15 PM Russell O'Connor <roconnor at blockstream.io>
> wrote:
>
>> In order of escalating scope of amendments to OP_COSHV, I suggest
>>
>> 1) Peeking at surrounding data surrounding data should definitely be
>> replaced by a pushdata-like op-code that uses the subsequent 32-bytes
>> directly.  The OP_SUCCESSx upgrade path specifically allows for this, and
>> avoids complicating the semantics Bitcoin Script.
>> 2) Furthermore, the number-of-input-verification and the
>> outputhash-verification operations ought to be split into different opcodes
>> as they are logically unrelated.
>> 3) Better still, we should instead implement the transaction reflection
>> operations of OP_PUSHOUTPUTHASH and OP_NUMINPUTS that puts the outputhash
>> and number of inputs respectively onto the stack.  Recursive covenants
>> appear to be effectively impossible without either an OP_TWEEKPUBKEY or an
>> OP_PUSHSCRIPTPUBKEY so the effort your proposal goes through to guard
>> against placing an arbitrary outputhash onto the stack appears to be wasted
>> effort to me.
>> 4) If we anticipate adding OP_CHECKSIGFROMSTACKVERIFY, then we should
>> most definitely prefer (3) instead of OP_COSHV, if we still feel the need
>> to do anything at all.  It is probably best to have both
>> OP_CHECKSIGFROMSTACKVERIFY and transaction reflection operations of
>> OP_PUSHOUTPUTHASH and OP_NUMINPUTS but I think I would be fine with just
>> OP_CHECKSIGFROMSTACKVERIFY as well.
>>
>> On the other hand, if we are serious about preferring less per-block
>> bandwidth over reusable primitive opcodes for programming, then we should
>> instead abandon the RISC-style Bitcoin Script and instead add an
>> alternative CISC-style taproot leaf type that directly provides (a
>> conjunction of) the various popular common policies: channel opening,
>> channel factories, coinjoins, hashlocks, timelocks, congestion control
>> etc.  Segwit v0 already implements this CISC-style for the single most
>> popular policy: single signature verification.
>>
>> On Fri, May 24, 2019 at 4:51 PM Jeremy <jlrubin at mit.edu> wrote:
>>
>>> Hi Russell,
>>>
>>> Thanks for this detailed comparison. The COSHV BIP does include a brief
>>> comparison to OP_CHECKSIGFROMSTACKVERIFY and ANYPREVOUT, but this is more
>>> detailed.
>>>
>>>
>>> I think that the power from CHECKSIGFROMSTACKVERIFY is awesome. It's
>>> clearly one of the more flexible options available and would enable a
>>> multitude of new use cases.
>>>
>>> When I originally presented my work on congestion control at Jan 2017
>>> BPASE, I also discussed it as an option for covenants. Unfortunately I
>>> think it may be on the edge of too powerful -- there are a lot of use cases
>>> and implications from having a potentially recursive covenant. If you see
>>> my response to Matt in the OP_COSHV BIP thread I classify it as enabling a
>>> non-computationally enumerable set of restrictions.
>>>
>>> I think also from a developer point of view working with OP_COSHV is
>>> much much simpler (maybe this can be abstracted) which will lead to
>>> increased adoption. OP_COSHV also uses less per-block bandwidth which also
>>> makes it preferable for a measure intended to decongest blocks. Do you know
>>> the exact byte cost for OP_CHECKSIGFROMSTACK? OP_COSHV scripts, with
>>> templating changes to taproot, can be a single byte. OP_COSHV also has less
>>> potential to have a negative interaction with future opcodes we may want
>>> like OP_PUBKEYTWEAK. While we're getting to an exact spec for the features
>>> we want in Bitcoin scripting, it's hard to sign on to OP_CHECKSIGFROMSTACK
>>> unless there's an exact specification which makes us confident we're
>>> hitting all the points.
>>>
>>> If the main complaint about OP_COSHV is that it peeks at surrounding
>>> data, it's also possible to implement it more closely to a multi-byte
>>> pushdata opcode or do the template optimization.
>>>
>>> Lastly, as I have previously noted, OP_LEFT is probably safer to
>>> implement than OP_CAT and should be more efficient for OP_CHECKSIGFROMSTACK
>>> scripts.
>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190525/5adfc65a/attachment.html>

From vitteaymeric at gmail.com  Sat May 25 23:56:48 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 26 May 2019 01:56:48 +0200
Subject: [bitcoin-dev] Two questions about segwit implementation
Message-ID: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>

I realized recently that my segwit implementation was not correct,
basically some time ago, wrongly reading the specs (and misleaded by
what follows), I thought that scriptsig would go into witness data as it
was, but that's not the case, op_pushdata is replaced by varlen

Now reading correctly the specs, they seem to be not totally correct,
then the first question is: why OP_0 is 00 in witness data and not 0100?
Does this apply to other op_codes? This does not look logical at all

The second question is: why for non segwit inputs there is a 00 length
in segwit data, what is the rational for that? It should just be nothing
since you don't need this to reconciliate things


From rusty at rustcorp.com.au  Mon May 27 01:26:01 2019
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 27 May 2019 10:56:01 +0930
Subject: [bitcoin-dev] SIGHASH_ANYPREVOUT proposal
In-Reply-To: <20190522201131.tfbfldddvkkktcc6@erisian.com.au>
References: <20190510203804.554q333lw3l7qql4@erisian.com.au>
	<87d0kbkxx8.fsf@rustcorp.com.au>
	<20190522201131.tfbfldddvkkktcc6@erisian.com.au>
Message-ID: <87ef4k3cye.fsf@rustcorp.com.au>

Anthony Towns <aj at erisian.com.au> writes:
> On Wed, May 22, 2019 at 12:17:31PM +0930, Rusty Russell wrote:
>>    I prefer to
>>    change the bip introduction to expliclty shout "THESE SIGNATURE
>>    HASHES ARE UNSAFE FOR NORMAL WALLET USAGE.", and maybe rename it
>>    SIGHASH_UNSAFE_ANYPREVOUT.
>
>> 4. "Rebinding is a new power in bitcoin, and it makes me uncomfortable".
>>    I have a degree of sympathy for this view, but objections must be
>>    backed in facts.  If we don't understand it well enough, we should
>>    not do it.
>
> Yeah, that's where I'm at: if we think something is UNSAFE enough to
> need a warning, then I think it's too unsafe to include in the consensus
> layer. I would like to find a way of making ANYPREVOUT safe enough that
> it doesn't need scary warnings; a week or two ago, chaperone sigs were
> my best idea for that.

The DO_NOT_WANT naming is to prevent people who *don't* want to use it
from using it because it's the "new hotness".

It cannot both be powerful enough to do what we need (rebinding) and
safe enough for general use (no rebinding).

> So here's something I almost think is an argument that ANYPREVOUT is safe
> (without chaperone sigs or output tagging, etc).
>
> #1. I'm assuming funds are "safe" in Bitcoin if they're (a) held in
> a cryptographically secured UTXO, (b) under "enough" proof of work
> that a reorg is "sufficiently" unlikely. If you don't have both those
> assumptions, your money is not safe in obvious ways; if you do have them
> both, your money is safe.
>
> #2. My theory is that as long as you, personally, only use ANYPREVOUT
> to sign transactions that are paying the money back to yourself, your
> funds will remain safe.
>
> If you follow this rule, then other people replaying your signature is
> not a problem -- the funds will just move from one of your addresses, to
> a different address.
...
> Eltoo naturally meets this requirement, as long as you consider "paying
> to yourself" to cover both "paying to same multisig address" (for update
> transactions)

I disagree?  Paying to share with an untrusted party is *insecure*
without further, complex arrangements.  Those arrangements (already a
requirement for lightning) worry me far more than the bitcoin-level
rebinding, TBH.

Lightning relies on #1, not #2.  I don't know of any use for #2 in fact;
in practice if you have control of keys you can generally sign a new tx,
not requiring ANYPREVOUT.  If you're trying to blindly spend a tx which
may be RBF'd, ANYPREVOUT won't generally help you (amount changes).

> #5. It's probably not compatible with luke's "malleability proof" wallet
> idea [0]. Malleability is only a concern for funds that aren't already
> "sufficiently" buried, and if you're only spending it to yourself that
> doesn't help with burying, and if you're spending it to someone else
> immediately after, doesn't help with making that transaction less
> malleable. But if the line of argument above's correct, that just
> recognises that a wallet like that risks losing funds if someone else
> reuses its addresses; it doesn't add any systemic risk. And "wallet X
> isn't safe" is a risk category we already deal with.

Yes, I think our primary concern is risk to non-ANYPREVOUT using txs.
That would make ANYPREVOUT a bad idea, but seems we're concluding that's
not the case.

Secondary, is the accidentally-using-ANYPREVOUT scenario, which I
consider unlikely (like accidentally-using-SIGHASHNONE), especially
since you need to actually mark your keys now, so you can't do it
post-hoc to existing outputs.

Final concern is the using-correctly-but-nasty-gotchas.  This seems to
be inherent in rebinding, and is fully addressed by Don't Reuse
Addresses.  That is already a requirement for lightning (reusing
revocation keys is fatal).  Others reusing your addresses is already a
thing we have to deal with in bitcoin (Enjoy/Sochi).

Cheers,
Rusty.

From aj at erisian.com.au  Mon May 27 07:21:28 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 27 May 2019 17:21:28 +1000
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
Message-ID: <20190527072128.lbzeo6h23qgxvhsy@erisian.com.au>

On Wed, May 22, 2019 at 05:01:21PM -0400, Russell O'Connor via bitcoin-dev wrote:
> Bitcoin Script appears designed to be a flexible programmable system that
> provides generic features to be composed to achieve various purposes.

Counterpoint: haven't the flexibly designed parts of script mostly been
a failure -- requiring opcodes to be disabled due to DoS vectors or
consensus bugs, and mostly not being useful in practice where they're
still enabled in BTC or on other chains where they have been re-enabled
(eg, Liquid and BCH)?

> Instead, I propose that, for the time being, we simply implement OP_CAT and
> OP_CHECKSIGFROMSTACKVERIFY.

FWIW, I'd like to see CAT enabled, though I'm less convinced about a
CHECKSIG that takes the message from the stack. I think CAT's plausibly
useful in practice, but a sig against data from the stack seems more
useful in theory than in practice. Has it actually seen use on BCH or
Liquid, eg?  (Also, I think BCH's name for that opcode makes more sense
than Elements' -- all the CHECKSIG opcodes pull a sig from the stack,
after all)

> * Transaction introspection including:
> +?Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply by the
> nature of the construction.

I think simulating an ANYPREVOUT sig with a data signature means checking:

    S1 P CHECKSIG -- to check S1 is a signature for the tx

    S1 H_TapSighash(XAB) P CHECKDATASIG
         -- to pull out the tx data "X", "A", "B")

    S2 H_TapSighash(XCB) Q CHECKDATASIG
         -- for the ANYPREVOUT sig, with A changed to C to
	    avoid committing to prevout info

    X SIZE 42 EQUALVERIFY
    B SIZE 47 EQUALVERIFY
         -- to make sure only C is replaced from "XCB"

So to get all those conditions checked, I think you could do:

   P 2DUP TOALT TOALT CHECKSIGVERIFY
   SIZE 42 EQUALVERIFY
   "TapSighash" SHA256 DUP CAT SWAP CAT TOALT
   SIZE 47 EQUALVERIFY TUCK
   CAT FROMALT TUCK SWAP CAT SHA256 FROMALT SWAP FROMALT
   CHECKDATASIGVERIFY
   SWAP TOALT SWAP CAT FROMALT CAT SHA256 Q CHECKDATASIG
   
Where the stack elements are, from top to bottom:

   S1: (65B) signature by P of tx
   X:  (42B) start of TapSighash spec
   B:  (47B) end of TapSighash spec (amount, nSequence, tapleaf_hash,
             key_version, codesep_pos)
   A:  (73B) middle of TapSighash spec dropped for ANYPREVOUT (spend_type,
             scriptPubKey and outpoint)
   C:   (1B) alternate middle (different spend_type)
   S2: (64B) signature of "XCB" by key Q

So 298B for the witness data, and 119B or so for the script (if I've not
made mistakes), versus "P CHECKSIGVERIFY Q CHECKSIG" and S2 and S1 on
the stack, for 132B of witness data and 70B of script, or half that if
the chaperone requirement is removed.

I think you'd need to complicate it a bit further to do the
ANYPREVOUTANYSCRIPT variant, where you retain the commitment to
amount/nseq but drop the commitment to tapleaf_hash.

> I feel that this style of generic building blocks truly embodies what is meant
> by "programmable money".

For practical purposes, this doesn't seem like a great level of
abstraction to me. It's certainly better at "permissionless innovation"
though.

You could make these constructions a little bit simpler by having a
"CHECK_SIG_MSG_VERIFY" opcode that accepts [sig msg key], and does "sig
key CHECKSIGVERIFY" but also checks the the provided msg was what was
passed into bip-schnorr.

Cheers,
aj


From jl2012 at xbt.hk  Sun May 26 14:33:06 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sun, 26 May 2019 22:33:06 +0800
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
Message-ID: <6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>


> On 26 May 2019, at 7:56 AM, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I realized recently that my segwit implementation was not correct,
> basically some time ago, wrongly reading the specs (and misleaded by
> what follows), I thought that scriptsig would go into witness data as it
> was, but that's not the case, op_pushdata is replaced by varlen
> 

Witness is not script. There is no op_pushdata or any other opcodes.

Witness is a stack. For each input, the witness starts with a CCompactSize for the number of stack elements for this input. Each stack element in turns starts with a CCompactSize for the size of this element, followed by the actual data


> Now reading correctly the specs, they seem to be not totally correct,
> then the first question is: why OP_0 is 00 in witness data and not 0100?
> Does this apply to other op_codes? This does not look logical at all
> 

A ?00? element means the size of this element is zero. Since it?s zero size, no data is followed. This will create an empty element on the stack. It?s effectively same as OP_0 (Again, witness is not script)

A ?0100? element means the element size is one, and the data for this element is ?00?. So it will leave an 1-byte element on the stack.


> The second question is: why for non segwit inputs there is a 00 length
> in segwit data, what is the rational for that? It should just be nothing
> since you don't need this to reconciliate things

The ?00? here means "this input has no witness stack element?. You need this even for non segwit inputs, because there is no way to tell whether an input is segwit-enabled or not, until you look up the UTXO, which might not be always available. Transaction serialization couldn?t rely on contextual information.

However, if all inputs have no stack element, the spec requires you to always use the non-segwit serialization.

> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jl2012 at xbt.hk  Sun May 26 16:28:57 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Mon, 27 May 2019 00:28:57 +0800
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <e342cb8f-a909-a806-bd76-91580234cd7f@gmail.com>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
	<6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>
	<e342cb8f-a909-a806-bd76-91580234cd7f@gmail.com>
Message-ID: <253DB697-BECF-4D68-8A1E-1549B52D5AFA@xbt.hk>

This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.

In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that ?the witness for this input is empty?, and it is the ?00?.

> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
> 
> ??. for the 00 number of witness
> data for non segwit inputs the one that is doing the transaction knows
> which inputs are segwit or not, then parsing the transaction you can
> associate the correct input to the correct witness data, without the
> need of 00, so I must be missing the use case



From jl2012 at xbt.hk  Sun May 26 17:24:13 2019
From: jl2012 at xbt.hk (Johnson Lau)
Date: Mon, 27 May 2019 01:24:13 +0800
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <a7742e04-22b1-2015-440a-ef81b5fbeed4@gmail.com>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
	<6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>
	<e342cb8f-a909-a806-bd76-91580234cd7f@gmail.com>
	<253DB697-BECF-4D68-8A1E-1549B52D5AFA@xbt.hk>
	<a7742e04-22b1-2015-440a-ef81b5fbeed4@gmail.com>
Message-ID: <DD2C67C8-0DF6-4140-8427-19B7F28FA22C@xbt.hk>

Empty scriptSig doesn?t imply segwit input: if the previous scriptPubKey is OP_1 (which does not allow witness), it could still be spent with an empty scriptSig

Similarly, a scriptSig looking like a spend of P2SH-segwit doesn?t imply segwit input: if the previous scriptPubKey is empty, it could be spent with a push of any non-zero value.

> On 27 May 2019, at 1:09 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
> 
> I did not phrase correctly in fact, what I meant is: if the validator
> sees empty or witness script in scriptSig, then this is a segwit input,
> and doing this one by one the validator can associate the correct segwit
> data to the correct segwit input, so 00 does not look to be needed
> 
> Le 26/05/2019 ? 18:28, Johnson Lau a ?crit :
>> This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.
>> 
>> In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that ?the witness for this input is empty?, and it is the ?00?.
>> 
>>> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>>> 
>>> ??. for the 00 number of witness
>>> data for non segwit inputs the one that is doing the transaction knows
>>> which inputs are segwit or not, then parsing the transaction you can
>>> associate the correct input to the correct witness data, without the
>>> need of 00, so I must be missing the use case
>> 



From vitteaymeric at gmail.com  Sun May 26 16:18:46 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 26 May 2019 18:18:46 +0200
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
	<6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>
Message-ID: <e342cb8f-a909-a806-bd76-91580234cd7f@gmail.com>

OK, thanks, understood for OP_0 but still for the 00 number of witness
data for non segwit inputs the one that is doing the transaction knows
which inputs are segwit or not, then parsing the transaction you can
associate the correct input to the correct witness data, without the
need of 00, so I must be missing the use case

Le 26/05/2019 ? 16:33, Johnson Lau a ?crit?:
>> On 26 May 2019, at 7:56 AM, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> I realized recently that my segwit implementation was not correct,
>> basically some time ago, wrongly reading the specs (and misleaded by
>> what follows), I thought that scriptsig would go into witness data as it
>> was, but that's not the case, op_pushdata is replaced by varlen
>>
> Witness is not script. There is no op_pushdata or any other opcodes.
>
> Witness is a stack. For each input, the witness starts with a CCompactSize for the number of stack elements for this input. Each stack element in turns starts with a CCompactSize for the size of this element, followed by the actual data
>
>
>> Now reading correctly the specs, they seem to be not totally correct,
>> then the first question is: why OP_0 is 00 in witness data and not 0100?
>> Does this apply to other op_codes? This does not look logical at all
>>
> A ?00? element means the size of this element is zero. Since it?s zero size, no data is followed. This will create an empty element on the stack. It?s effectively same as OP_0 (Again, witness is not script)
>
> A ?0100? element means the element size is one, and the data for this element is ?00?. So it will leave an 1-byte element on the stack.
>
>
>> The second question is: why for non segwit inputs there is a 00 length
>> in segwit data, what is the rational for that? It should just be nothing
>> since you don't need this to reconciliate things
> The ?00? here means "this input has no witness stack element?. You need this even for non segwit inputs, because there is no way to tell whether an input is segwit-enabled or not, until you look up the UTXO, which might not be always available. Transaction serialization couldn?t rely on contextual information.
>
> However, if all inputs have no stack element, the spec requires you to always use the non-segwit serialization.
>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From pieter.wuille at gmail.com  Sun May 26 17:54:08 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 26 May 2019 10:54:08 -0700
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
Message-ID: <CAPg+sBg6ws3LZXeppDfjznHbdBSoeQ4-5FHwDutQ1frRFZNc9w@mail.gmail.com>

On Sun, May 26, 2019, 07:07 Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I realized recently that my segwit implementation was not correct,
> basically some time ago, wrongly reading the specs (and misleaded by
> what follows), I thought that scriptsig would go into witness data as it
> was, but that's not the case, op_pushdata is replaced by varlen
>
> Now reading correctly the specs, they seem to be not totally correct,
> then the first question is: why OP_0 is 00 in witness data and not 0100?
> Does this apply to other op_codes? This does not look logical at all
>
> The second question is: why for non segwit inputs there is a 00 length
> in segwit data, what is the rational for that? It should just be nothing
> since you don't need this to reconciliate things
>

This is a question that belongs on https://bitcoin.stackexchange.com, not
this list.

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190526/7df58353/attachment.html>

From vitteaymeric at gmail.com  Sun May 26 17:09:31 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 26 May 2019 19:09:31 +0200
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <253DB697-BECF-4D68-8A1E-1549B52D5AFA@xbt.hk>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
	<6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>
	<e342cb8f-a909-a806-bd76-91580234cd7f@gmail.com>
	<253DB697-BECF-4D68-8A1E-1549B52D5AFA@xbt.hk>
Message-ID: <a7742e04-22b1-2015-440a-ef81b5fbeed4@gmail.com>

I did not phrase correctly in fact, what I meant is: if the validator
sees empty or witness script in scriptSig, then this is a segwit input,
and doing this one by one the validator can associate the correct segwit
data to the correct segwit input, so 00 does not look to be needed

Le 26/05/2019 ? 18:28, Johnson Lau a ?crit?:
> This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.
>
> In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that ?the witness for this input is empty?, and it is the ?00?.
>
>> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>>
>> ??. for the 00 number of witness
>> data for non segwit inputs the one that is doing the transaction knows
>> which inputs are segwit or not, then parsing the transaction you can
>> associate the correct input to the correct witness data, without the
>> need of 00, so I must be missing the use case
>

From me at thomaskerin.io  Sun May 26 19:34:55 2019
From: me at thomaskerin.io (Thomas Kerin)
Date: Sun, 26 May 2019 20:34:55 +0100
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
Message-ID: <cbd7d991-ad8d-e311-661f-e93f05171522@thomaskerin.io>

The scriptSig when evaluated populates the stack so opcodes can operate
on them. A witness is essentially a list of data elements, quite similar
to the script stack (the witness is passed in as the script stack in fact)

OP_0 when evaluated pushes a _zero length_ value onto the stack, hence
the 00 (the varlen) in the witness serialization. OP_1 (51 in decimal)
pushes 0x01 to the stack, so when serialized would be 0101.

It may help to consider the entire witness structure as
vector<vector<data element>> and it's length must equal the number of
inputs - so a non-segwit input must have a zero sized witness.

On 5/26/19 12:56 AM, Aymeric Vitte via bitcoin-dev wrote:
> I realized recently that my segwit implementation was not correct,
> basically some time ago, wrongly reading the specs (and misleaded by
> what follows), I thought that scriptsig would go into witness data as it
> was, but that's not the case, op_pushdata is replaced by varlen
>
> Now reading correctly the specs, they seem to be not totally correct,
> then the first question is: why OP_0 is 00 in witness data and not 0100?
> Does this apply to other op_codes? This does not look logical at all
>
> The second question is: why for non segwit inputs there is a 00 length
> in segwit data, what is the rational for that? It should just be nothing
> since you don't need this to reconciliate things
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From vitteaymeric at gmail.com  Sun May 26 21:17:30 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sun, 26 May 2019 23:17:30 +0200
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <DD2C67C8-0DF6-4140-8427-19B7F28FA22C@xbt.hk>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
	<6DFB6C65-D123-40FD-9CE3-49FFCA81EE46@xbt.hk>
	<e342cb8f-a909-a806-bd76-91580234cd7f@gmail.com>
	<253DB697-BECF-4D68-8A1E-1549B52D5AFA@xbt.hk>
	<a7742e04-22b1-2015-440a-ef81b5fbeed4@gmail.com>
	<DD2C67C8-0DF6-4140-8427-19B7F28FA22C@xbt.hk>
Message-ID: <6d6766da-67fb-31e1-eceb-663bffeef74a@gmail.com>

Well, OK, then back to non standard stuff and bitcoin considers that an
OP_1 or empty scriptpubkey is something that can exist, sipa does not
like my questions on this list but this is a bit frightening in fact to
see that after 10 years an OP_1 scriptpubkey or empty one can be a use
case, thanks Thomas also, where all of this is clearly documented so
people don't bother the list not to produce approximative stuff remains
mysterious

Le 26/05/2019 ? 19:24, Johnson Lau a ?crit?:
> Empty scriptSig doesn?t imply segwit input: if the previous scriptPubKey is OP_1 (which does not allow witness), it could still be spent with an empty scriptSig
>
> Similarly, a scriptSig looking like a spend of P2SH-segwit doesn?t imply segwit input: if the previous scriptPubKey is empty, it could be spent with a push of any non-zero value.
>
>> On 27 May 2019, at 1:09 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>>
>> I did not phrase correctly in fact, what I meant is: if the validator
>> sees empty or witness script in scriptSig, then this is a segwit input,
>> and doing this one by one the validator can associate the correct segwit
>> data to the correct segwit input, so 00 does not look to be needed
>>
>> Le 26/05/2019 ? 18:28, Johnson Lau a ?crit :
>>> This is not how it works. While the transaction creator may know which inputs are segwit, the validators have no way to tell until they look up the UTXO set.
>>>
>>> In a transaction, all information about an input the validators have is the 36-byte outpoint (txid + index). Just by looking at the outpoint, there is no way to tell whether it is segwit-enabled or not. So there needs to be a way to tell the validator that ?the witness for this input is empty?, and it is the ?00?.
>>>
>>>> On 27 May 2019, at 12:18 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>>>>
>>>> ??. for the 00 number of witness
>>>> data for non segwit inputs the one that is doing the transaction knows
>>>> which inputs are segwit or not, then parsing the transaction you can
>>>> associate the correct input to the correct witness data, without the
>>>> need of 00, so I must be missing the use case
>

From kkarasavvas at gmail.com  Mon May 27 07:26:21 2019
From: kkarasavvas at gmail.com (Kostas Karasavvas)
Date: Mon, 27 May 2019 10:26:21 +0300
Subject: [bitcoin-dev] Two questions about segwit implementation
In-Reply-To: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
References: <e537e781-e10f-7299-fddb-67fab74124c0@gmail.com>
Message-ID: <CABE6yHsCf7Mz+wDq7wPUR3YT0ua2i4O20XjF1-GZD_zJ8BXkVQ@mail.gmail.com>

On Sun, May 26, 2019 at 5:07 PM Aymeric Vitte via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I realized recently that my segwit implementation was not correct,
> basically some time ago, wrongly reading the specs (and misleaded by
> what follows), I thought that scriptsig would go into witness data as it
> was, but that's not the case, op_pushdata is replaced by varlen
>
> Now reading correctly the specs, they seem to be not totally correct,
> then the first question is: why OP_0 is 00 in witness data and not 0100?
> Does this apply to other op_codes? This does not look logical at all
>
>
op_pushdata allows for unsigned integers and thus it uses the extra byte to
specify that.

A varint (varlen) is unsigned.  0 and anything <= 252 is one byte length,
so 00.


> The second question is: why for non segwit inputs there is a 00 length
> in segwit data, what is the rational for that? It should just be nothing
> since you don't need this to reconciliate things
>
>
Because you don't have the number of witnesses as you have for
inputs/outputs. The witness data length is assumed to be the same as the
inputs length. And then for non-segwit inputs you need the 00 to specify
that it is empty.

Hope that helps.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190527/b1ee6569/attachment.html>

From naumenko.gs at gmail.com  Tue May 28 00:11:50 2019
From: naumenko.gs at gmail.com (Gleb Naumenko)
Date: Mon, 27 May 2019 17:11:50 -0700
Subject: [bitcoin-dev] Bandwidth-Efficient Transaction Relay for Bitcoin
In-Reply-To: <dc505296-d415-443b-be76-90b254853eea@Spark>
References: <dc505296-d415-443b-be76-90b254853eea@Spark>
Message-ID: <d9eda8a2-4c96-4dec-a34a-cd184eb8aeda@Spark>

Hi all,

We are making public our latest work on Erlay, an efficient transaction relay protocol for Bitcoin.
It is available here:?https://arxiv.org/abs/1905.10518

The main idea is that instead of announcing every transaction to every peer, announcements are only sent directly over a small number of connections (only 8 outgoing ones). Further relay is achieved by periodically running a set reconciliation protocol over every connection between the sets of withheld announcements in both directions.

The set reconciliation protocol uses error correcting codes to communicate a set of transactions to a peer with an unknown but similar set using bandwidth only equal to the size of the difference and not the size of the sets themselves.

Results: we save half of the bandwidth a node consumes, allow increasing connectivity almost for free, and, as a side effect, better withstand timing attacks.
If outbound peer count were increased to 32, Erlay saves around 75% overall bandwidth compared to the current protocol.

This work uses Minisketch, an efficient library for set reconciliation, which we made public before:?github.com/sipa/minisketch.

Some of you may already know about it from discussions with me, Scaling Bitcoin 18, or CoreDev in Tokyo. Our proposal has become more precise since then.

The next step here is to receive more feedback, have a broader discussion, and then write a BIP along with improving reference implementation. We are looking forward to hearing your suggestions or concerns regarding this work.

This protocol is a result of work by myself, Gregory Maxwell, Pieter Wuille, and my supervisors at UBC: Ivan Beschastnikh and Sasha Fedorova.
I would like to thank Tim Ruffing and Ben Woosley for contributions to the write-up, and Blockstream for supporting my work on this protocol.

? gleb
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190527/b84a5c9f/attachment.html>

From ZmnSCPxj at protonmail.com  Tue May 28 03:41:58 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 28 May 2019 03:41:58 +0000
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <20190527072128.lbzeo6h23qgxvhsy@erisian.com.au>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<20190527072128.lbzeo6h23qgxvhsy@erisian.com.au>
Message-ID: <oUAmCZn8d8qxim0QgUJDaseoYn_52GuYm-1G88WRHmCe60t_pcbx_NL_Opn6HbEKklGuteRLbtEPVRC_JaNm9qJ_Opbbw3DkC0mLzTbXmWs=@protonmail.com>




Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Monday, May 27, 2019 3:21 PM, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Wed, May 22, 2019 at 05:01:21PM -0400, Russell O'Connor via bitcoin-dev wrote:
>
> > Bitcoin Script appears designed to be a flexible programmable system that
> > provides generic features to be composed to achieve various purposes.
>
> Counterpoint: haven't the flexibly designed parts of script mostly been
> a failure -- requiring opcodes to be disabled due to DoS vectors or
> consensus bugs, and mostly not being useful in practice where they're
> still enabled in BTC or on other chains where they have been re-enabled
> (eg, Liquid and BCH)?

One could argue that manually programming directly with `OP_CHECKSIGFROMSTACK` is difficult enough that we should really be using some compiler that (say) translates Simplicity to SCRIPT that uses `OP_CHECKSIGFROMSTACK` to implement transaction introspection.
So the lack of such use may point more to a lack of tools than a lack of actual use.

This extends in particular to "lack of abstraction"; the abstraction might be better served by implementing a pure functional language that is compiled down to `OP_CHECKSIGFROMSTACK` somehow, with the pure functional language implementing loops using the technique I described (keep current state in a separate `OP_RETURN` output, reuse the same `scriptPubKey` but modify the `OP_RETURN` output (i.e. code is `const`, data is `mutable`)).

But that still requires that we have at least a proof-of-existence in the form of some compiler that targets (say) Liquid/Elements SCRIPT and leverages `OP_CHECKSIGFROMSTACK` appropriately.

I believe Russell has expressed some interest in my Smart Contracts Unchained technique to implement Simplicity on top of Bitcoin by using a semi-trusted user-selected federation to enforce Simplicity execution.
If implemented as such, it may be possible to then show that actual use would be enabled if it is possible to run this on Bitcoin.
(I respect that Blockstream employees have to eat and thus made Liquid, but for example I myself would not be interested in putting any coins in Liquid, as its federation is not selected by me; I would be more willing to use a Simplicity or `OP_CHECKSIGFROMSTACK` implementation on top of Smart Contracts Unchained as at least I can select the federation to include my own hardware, and allow anyone I might want to form such contracts with to also select federation members to include my own hardware.)
(Of course Liquid is built on Elements and Elements is open-source and in theory I could just replace its federation with my own, but having to start a new blockchain for every federation-set seems wasteful compared to Smart Contracts Unchained; Elements does have the advantage of already actually existing whereas no Smart Contracts Unchained exists at all.)

Regards,
ZmnSCPxj

From roconnor at blockstream.io  Wed May 29 06:49:29 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 29 May 2019 02:49:29 -0400
Subject: [bitcoin-dev] An alternative: OP_CAT & OP_CHECKSIGFROMSTACK
In-Reply-To: <20190527072128.lbzeo6h23qgxvhsy@erisian.com.au>
References: <CAMZUoK=0YhqxguphmaKsMGZCy_NYVE_i53qGBfPVES=GAYTy1g@mail.gmail.com>
	<20190527072128.lbzeo6h23qgxvhsy@erisian.com.au>
Message-ID: <CAMZUoKk3XFsFsQ_UybxQn1NiKWFak4cWLmk7WQyoncVK3Y7S6w@mail.gmail.com>

On Mon, May 27, 2019 at 3:21 AM Anthony Towns <aj at erisian.com.au> wrote:

> On Wed, May 22, 2019 at 05:01:21PM -0400, Russell O'Connor via bitcoin-dev
> wrote:
> > Bitcoin Script appears designed to be a flexible programmable system that
> > provides generic features to be composed to achieve various purposes.
>
> Counterpoint: haven't the flexibly designed parts of script mostly been
> a failure -- requiring opcodes to be disabled due to DoS vectors or
> consensus bugs, and mostly not being useful in practice where they're
> still enabled in BTC or on other chains where they have been re-enabled
> (eg, Liquid and BCH)?
>

You may have a point.  However, I'm still inclined to think that problem is
that you want some subset of concatenation, arithmetic, CHECKDATASIG,
transaction reflection and/or covenants in order to create particularly
useful programs.

A while ago, I was designing a moderately sophisticated Script for Elements
Alpha to see if I could implement a toy game, but ultimately I was thwarted
due to the fact that Elements Alpha didn't support multiplication.
I did briefly consider using repeated additions and nested if statements to
implement multiplication since I was expecting my numbers to be 11 or less,
but ultimately I decided to just continue my work on an alternative to
Script rather than trying to work around the missing multiplication.


> > Instead, I propose that, for the time being, we simply implement OP_CAT
> and
> > OP_CHECKSIGFROMSTACKVERIFY.
>
> FWIW, I'd like to see CAT enabled, though I'm less convinced about a
> CHECKSIG that takes the message from the stack. I think CAT's plausibly
> useful in practice, but a sig against data from the stack seems more
> useful in theory than in practice. Has it actually seen use on BCH or
> Liquid, eg?  (Also, I think BCH's name for that opcode makes more sense
> than Elements' -- all the CHECKSIG opcodes pull a sig from the stack,
> after all)
>
> > * Transaction introspection including:
> > + Simulated SIGHASH_ANYPREVOUT, which are necessarily chaperoned simply
> by the
> > nature of the construction.
>
> I think simulating an ANYPREVOUT sig with a data signature means checking:
>
>     S1 P CHECKSIG -- to check S1 is a signature for the tx
>
>     S1 H_TapSighash(XAB) P CHECKDATASIG
>          -- to pull out the tx data "X", "A", "B")
>
>     S2 H_TapSighash(XCB) Q CHECKDATASIG
>          -- for the ANYPREVOUT sig, with A changed to C to
>             avoid committing to prevout info
>
>     X SIZE 42 EQUALVERIFY
>     B SIZE 47 EQUALVERIFY
>          -- to make sure only C is replaced from "XCB"
>
> So to get all those conditions checked, I think you could do:
>
>    P 2DUP TOALT TOALT CHECKSIGVERIFY
>    SIZE 42 EQUALVERIFY
>    "TapSighash" SHA256 DUP CAT SWAP CAT TOALT
>    SIZE 47 EQUALVERIFY TUCK
>    CAT FROMALT TUCK SWAP CAT SHA256 FROMALT SWAP FROMALT
>    CHECKDATASIGVERIFY
>    SWAP TOALT SWAP CAT FROMALT CAT SHA256 Q CHECKDATASIG
>
> Where the stack elements are, from top to bottom:
>
>    S1: (65B) signature by P of tx
>    X:  (42B) start of TapSighash spec
>    B:  (47B) end of TapSighash spec (amount, nSequence, tapleaf_hash,
>              key_version, codesep_pos)
>    A:  (73B) middle of TapSighash spec dropped for ANYPREVOUT (spend_type,
>              scriptPubKey and outpoint)
>    C:   (1B) alternate middle (different spend_type)
>    S2: (64B) signature of "XCB" by key Q
>
> So 298B for the witness data, and 119B or so for the script (if I've not
> made mistakes), versus "P CHECKSIGVERIFY Q CHECKSIG" and S2 and S1 on
> the stack, for 132B of witness data and 70B of script, or half that if
> the chaperone requirement is removed.
>

I haven't checked your details but the above looks about correct to me.

So what I was thinking is that we could add CHECKDATASIG first, and then
people could get started on actually using ANYPREVOUT in practice and we
can take our time to debate the merits of the chaperone vs non-chaperone,
and possibly learn something about actual use before making a decision.
There is no doubt that using ANYPREVOUT directly uses less weight, but they
seem close enough to that it the simulation is usable, though perhaps far
enough apart that we would want to eventually add ANYPREVOUT.  However, do
keep in mind that our goal is not to minimize the weight of specific
redemption policies.  The weight of implementing any particular redemption
policy in Script is somewhat arbitrary to begin with anyways, being
dependent on the choices made for the Script language operations and its
encoding.  Again, if our goal were to minimize weight for specific
redemption policies we should abandon SCRIPT and directly use a language
similar to Miniscript, and/or just directly implement an enumeration of
policies.

However, my proposal CHECKSIGFROMSTACK (aka CHECKDATASIG) proposal was
based on my argument that CHECKDATASIG covenant abilities wouldn't be
controversial since it was limited to self-recursion and had less than
64-bits of state space.  But ZmnSCPxj has shown that my conclusions were
hasty and that self-recursion has access to arbitrarily large amounts of
state space.  In light of this, it would appear that self-recursive
covenants is nearly as powerful as arbitrary recursive covenants, and
therefore is nearly as controversial.

So, while I do think that we should add support for recursive covenants to
Bitcoin, we probably not ready to add it yet given the controversy around
the far more innocent ANYPREVOUT.  I do think it would be useful to add
support for CAT and CHECKDATASIG in order to implement MPC with penalties,
but perhaps we should support that via a HASH_tapdata digest function
rather than SHA256, in order to avoid any accidental covenants.  Of course
doing so would no longer count as "an alternative" proposal to ANYPREVOUT
or COSHV, and simply "an additional" proposal.


> I think you'd need to complicate it a bit further to do the
> ANYPREVOUTANYSCRIPT variant, where you retain the commitment to
> amount/nseq but drop the commitment to tapleaf_hash.
>
> > I feel that this style of generic building blocks truly embodies what is
> meant
> > by "programmable money".
>
> For practical purposes, this doesn't seem like a great level of
> abstraction to me. It's certainly better at "permissionless innovation"
> though.
>
> You could make these constructions a little bit simpler by having a
> "CHECK_SIG_MSG_VERIFY" opcode that accepts [sig msg key], and does "sig
> key CHECKSIGVERIFY" but also checks the the provided msg was what was
> passed into bip-schnorr.
>

The whole point is to keep the functionality simple and let users program
what they want.  What we don't want to do is tailor an opcode for the
specific use case we have in mind, because that just comes at the expense
of all the use cases we don't have in mind.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190529/ac866e25/attachment.html>

