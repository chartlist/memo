From luke at dashjr.org  Mon Apr  1 00:30:34 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 1 Apr 2019 00:30:34 +0000
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k USD/BTC
Message-ID: <201904010030.34825.luke@dashjr.org>

Certain parts of the community have been selling bitcoins for unreasonably
low prices. This has halted Bitcoin's valuation at $20k and even driven the
price down below $15k! However, clearly Bitcoin is worth much more than
that, and there is widespread support for higher prices.

In light of this, I have written and implemented two BIPs: one to add a
signed price field to Bitcoin transactions, and the other to softfork a
minimum price of $50k USD/BTC a year from today.

The BIPs are here, as well as included at the bottom of this email for 
convenience:
  https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki

A reference implementation is here:
  https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k

Please review ASAP so we can get these deployed in Bitcoin Core v0.18.

Luke


<pre>
  BIP: ?
  Layer: Applications
  Title: Signed USD Price Indicator
  Author: Luke Dashjr <luke+bip at dashjr.org>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
  Status: Draft
  Type: Standards Track
  Created: 2019-04-01
  License: BSD-2-Clause
</pre>

==Abstract==

This BIP proposes a method to explicitly specify and sign the USD/BTC price 
for transactions.

==Copyright==

This BIP is licensed under the BSD 2-clause license.

==Motivation==

Certain parts of the community have been selling bitcoins for unreasonably low 
prices. This has halted Bitcoin's valuation at $20k and even driven the price 
down below $15k! However, clearly Bitcoin is worth much more than that, and 
there is widespread support for higher prices.

This problem can be fixed by setting a global minimum price for bitcoins. 
Unfortunately, today, the consensus protocol is completely oblivious to the 
price bitcoins are traded at. Therefore, we must first add a field to Bitcoin 
transactions to indicate their price.

==Specification==

===New field and legal implication===

A new field is added to Bitcoin transactions. This field, if present, must 
represent the honest and true USD/BTC rate used for the transaction. By 
signing the transaction, the sender legally affirms this is the valuation of 
bitcoins used for the transaction.

For the avoidance of doubt: when the transaction is valued in a currency other 
than USD, any reasonable exchange rate may be used to come up with the USD 
valuation.

===Serialisation===

When serialising the transaction for any purpose, including signing, weight 
calculation, and so on, the output count must be incremented by one. Prior to 
the first real output, the following bytes must be inserted:

* Constant: 00 00 00 00 00 00 00 00
* A single byte, the size in bytes of the remainder of the inserted data
* Constant: 6a 04 55 53 44 24
* A single byte, the size in bytes of the remainder of the inserted data
* The USD/BTC rate used for the transaction, in standard signed integer 
serialisation, with all leading zeros removed (except as necessary to 
preserve the sign bit).

==Backwards compatibility==

===Consensus===

The new price field is serialised as a dummy output, with a value of zero, and 
a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore 
this dummy output, and the leading OP_RETURN in the scriptPubKey ensures it 
is never considered spendable.

Therefore, current nodes will ignore the new field entirely, and accept 
transactions using it.

===Wallets===

Existing wallets do not typically generate price indicators as specified. 
Under this BIP, this absence of the field is perfectly acceptable.

==Reference implementation==

https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field

<pre>
  BIP: ?
  Layer: Consensus (soft fork)
  Title: $50k USD/BTC Minimum Price
  Author: Luke Dashjr <luke+bip at dashjr.org>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
  Status: Draft
  Type: Standards Track
  Created: 2019-04-01
  License: BSD-2-Clause
  Requires: usdprice
</pre>

==Abstract==

This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.

==Copyright==

This BIP is licensed under the BSD 2-clause license.

==Motivation==

Certain parts of the community have been selling bitcoins for unreasonably low 
prices. This has halted Bitcoin's valuation at $20k and even driven the price 
down below $15k! However, clearly Bitcoin is worth much more than that, and 
there is widespread support for higher prices.

bip-usdprice defines a new field to indicate the price of transactions. Using 
this, we can softfork to require a minimum transaction price.

==Specification==

Beginning with block height 622370 (expected approximately 2020 April 1), a 
block is reject as invalid unless all transactions it contains both declare a 
USD/BTC price (as defined in bip-usdprice) and specify a price that is at a 
minimum $50k USD/BTC.

==Backwards compatibility==

As a soft fork, older nodes will continue to accept the blockchain without 
modification. Non-upgraded nodes, however, will not validate the minimum 
price requirement, and may accept invalid blocks if miners choose to make 
them. Since transactions not declaring a price are at this time still 
common-place, the softfork activation has been set a full year into the 
future to ensure time to upgrade both nodes and wallet software.

==Reference implementation==

https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k

From pete at petertodd.org  Mon Apr  1 01:11:12 2019
From: pete at petertodd.org (Peter Todd)
Date: Sun, 31 Mar 2019 21:11:12 -0400
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <201904010030.34825.luke@dashjr.org>
References: <201904010030.34825.luke@dashjr.org>
Message-ID: <20190401011112.6icdkyjocf4qh5oz@petertodd.org>

On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev wrote:
> Certain parts of the community have been selling bitcoins for unreasonably
> low prices. This has halted Bitcoin's valuation at $20k and even driven the
> price down below $15k! However, clearly Bitcoin is worth much more than
> that, and there is widespread support for higher prices.
> 
> In light of this, I have written and implemented two BIPs: one to add a
> signed price field to Bitcoin transactions, and the other to softfork a
> minimum price of $50k USD/BTC a year from today.

I believe I've found a serious vulnerability in your proposal: there's no limit
on the maximum supply of USD.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190331/22f5e18a/attachment.sig>

From ricardojdfilipe at gmail.com  Mon Apr  1 01:04:10 2019
From: ricardojdfilipe at gmail.com (Ricardo Filipe)
Date: Mon, 1 Apr 2019 02:04:10 +0100
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <201904010030.34825.luke@dashjr.org>
References: <201904010030.34825.luke@dashjr.org>
Message-ID: <CALC81CNdndTKxT10gLAEnxJ+-kybUFzTQQLBV8unVHkGv9TP6A@mail.gmail.com>

one year seems too long. i think with the BIP-148 experience you have
we could easily get there in 6 months at most.

Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
escreveu no dia segunda, 1/04/2019 ?(s) 01:33:
>
> Certain parts of the community have been selling bitcoins for unreasonably
> low prices. This has halted Bitcoin's valuation at $20k and even driven the
> price down below $15k! However, clearly Bitcoin is worth much more than
> that, and there is widespread support for higher prices.
>
> In light of this, I have written and implemented two BIPs: one to add a
> signed price field to Bitcoin transactions, and the other to softfork a
> minimum price of $50k USD/BTC a year from today.
>
> The BIPs are here, as well as included at the bottom of this email for
> convenience:
>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki
>
> A reference implementation is here:
>   https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k
>
> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
>
> Luke
>
>
> <pre>
>   BIP: ?
>   Layer: Applications
>   Title: Signed USD Price Indicator
>   Author: Luke Dashjr <luke+bip at dashjr.org>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This BIP proposes a method to explicitly specify and sign the USD/BTC price
> for transactions.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> Certain parts of the community have been selling bitcoins for unreasonably low
> prices. This has halted Bitcoin's valuation at $20k and even driven the price
> down below $15k! However, clearly Bitcoin is worth much more than that, and
> there is widespread support for higher prices.
>
> This problem can be fixed by setting a global minimum price for bitcoins.
> Unfortunately, today, the consensus protocol is completely oblivious to the
> price bitcoins are traded at. Therefore, we must first add a field to Bitcoin
> transactions to indicate their price.
>
> ==Specification==
>
> ===New field and legal implication===
>
> A new field is added to Bitcoin transactions. This field, if present, must
> represent the honest and true USD/BTC rate used for the transaction. By
> signing the transaction, the sender legally affirms this is the valuation of
> bitcoins used for the transaction.
>
> For the avoidance of doubt: when the transaction is valued in a currency other
> than USD, any reasonable exchange rate may be used to come up with the USD
> valuation.
>
> ===Serialisation===
>
> When serialising the transaction for any purpose, including signing, weight
> calculation, and so on, the output count must be incremented by one. Prior to
> the first real output, the following bytes must be inserted:
>
> * Constant: 00 00 00 00 00 00 00 00
> * A single byte, the size in bytes of the remainder of the inserted data
> * Constant: 6a 04 55 53 44 24
> * A single byte, the size in bytes of the remainder of the inserted data
> * The USD/BTC rate used for the transaction, in standard signed integer
> serialisation, with all leading zeros removed (except as necessary to
> preserve the sign bit).
>
> ==Backwards compatibility==
>
> ===Consensus===
>
> The new price field is serialised as a dummy output, with a value of zero, and
> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore
> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures it
> is never considered spendable.
>
> Therefore, current nodes will ignore the new field entirely, and accept
> transactions using it.
>
> ===Wallets===
>
> Existing wallets do not typically generate price indicators as specified.
> Under this BIP, this absence of the field is perfectly acceptable.
>
> ==Reference implementation==
>
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field
>
> <pre>
>   BIP: ?
>   Layer: Consensus (soft fork)
>   Title: $50k USD/BTC Minimum Price
>   Author: Luke Dashjr <luke+bip at dashjr.org>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
>   Requires: usdprice
> </pre>
>
> ==Abstract==
>
> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> Certain parts of the community have been selling bitcoins for unreasonably low
> prices. This has halted Bitcoin's valuation at $20k and even driven the price
> down below $15k! However, clearly Bitcoin is worth much more than that, and
> there is widespread support for higher prices.
>
> bip-usdprice defines a new field to indicate the price of transactions. Using
> this, we can softfork to require a minimum transaction price.
>
> ==Specification==
>
> Beginning with block height 622370 (expected approximately 2020 April 1), a
> block is reject as invalid unless all transactions it contains both declare a
> USD/BTC price (as defined in bip-usdprice) and specify a price that is at a
> minimum $50k USD/BTC.
>
> ==Backwards compatibility==
>
> As a soft fork, older nodes will continue to accept the blockchain without
> modification. Non-upgraded nodes, however, will not validate the minimum
> price requirement, and may accept invalid blocks if miners choose to make
> them. Since transactions not declaring a price are at this time still
> common-place, the softfork activation has been set a full year into the
> future to ensure time to upgrade both nodes and wallet software.
>
> ==Reference implementation==
>
> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From omarshib at gmail.com  Mon Apr  1 02:54:16 2019
From: omarshib at gmail.com (Omar Shibli)
Date: Mon, 1 Apr 2019 05:54:16 +0300
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <201904010030.34825.luke@dashjr.org>
References: <201904010030.34825.luke@dashjr.org>
Message-ID: <CAE3EOfgpP8_a4ersRoc2F=VpazdhRa_4WFrF6_FM1hJpER=dUQ@mail.gmail.com>

Reasonable, I think also first timer should be forbidden form transacting
for at least 3 years from the first purchase, after going in '3 years' into
the rabbit hole, you can consider selling bitcoins. that's fair for low
time hard money folks, imho.

On Mon, Apr 1, 2019 at 3:33 AM Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Certain parts of the community have been selling bitcoins for unreasonably
> low prices. This has halted Bitcoin's valuation at $20k and even driven the
> price down below $15k! However, clearly Bitcoin is worth much more than
> that, and there is widespread support for higher prices.
>
> In light of this, I have written and implemented two BIPs: one to add a
> signed price field to Bitcoin transactions, and the other to softfork a
> minimum price of $50k USD/BTC a year from today.
>
> The BIPs are here, as well as included at the bottom of this email for
> convenience:
>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
>
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki
>
> A reference implementation is here:
>
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k
>
> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
>
> Luke
>
>
> <pre>
>   BIP: ?
>   Layer: Applications
>   Title: Signed USD Price Indicator
>   Author: Luke Dashjr <luke+bip at dashjr.org>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This BIP proposes a method to explicitly specify and sign the USD/BTC
> price
> for transactions.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> Certain parts of the community have been selling bitcoins for unreasonably
> low
> prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> there is widespread support for higher prices.
>
> This problem can be fixed by setting a global minimum price for bitcoins.
> Unfortunately, today, the consensus protocol is completely oblivious to
> the
> price bitcoins are traded at. Therefore, we must first add a field to
> Bitcoin
> transactions to indicate their price.
>
> ==Specification==
>
> ===New field and legal implication===
>
> A new field is added to Bitcoin transactions. This field, if present, must
> represent the honest and true USD/BTC rate used for the transaction. By
> signing the transaction, the sender legally affirms this is the valuation
> of
> bitcoins used for the transaction.
>
> For the avoidance of doubt: when the transaction is valued in a currency
> other
> than USD, any reasonable exchange rate may be used to come up with the USD
> valuation.
>
> ===Serialisation===
>
> When serialising the transaction for any purpose, including signing,
> weight
> calculation, and so on, the output count must be incremented by one. Prior
> to
> the first real output, the following bytes must be inserted:
>
> * Constant: 00 00 00 00 00 00 00 00
> * A single byte, the size in bytes of the remainder of the inserted data
> * Constant: 6a 04 55 53 44 24
> * A single byte, the size in bytes of the remainder of the inserted data
> * The USD/BTC rate used for the transaction, in standard signed integer
> serialisation, with all leading zeros removed (except as necessary to
> preserve the sign bit).
>
> ==Backwards compatibility==
>
> ===Consensus===
>
> The new price field is serialised as a dummy output, with a value of zero,
> and
> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore
> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures
> it
> is never considered spendable.
>
> Therefore, current nodes will ignore the new field entirely, and accept
> transactions using it.
>
> ===Wallets===
>
> Existing wallets do not typically generate price indicators as specified.
> Under this BIP, this absence of the field is perfectly acceptable.
>
> ==Reference implementation==
>
>
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field
>
> <pre>
>   BIP: ?
>   Layer: Consensus (soft fork)
>   Title: $50k USD/BTC Minimum Price
>   Author: Luke Dashjr <luke+bip at dashjr.org>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
>   Requires: usdprice
> </pre>
>
> ==Abstract==
>
> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> Certain parts of the community have been selling bitcoins for unreasonably
> low
> prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> there is widespread support for higher prices.
>
> bip-usdprice defines a new field to indicate the price of transactions.
> Using
> this, we can softfork to require a minimum transaction price.
>
> ==Specification==
>
> Beginning with block height 622370 (expected approximately 2020 April 1),
> a
> block is reject as invalid unless all transactions it contains both
> declare a
> USD/BTC price (as defined in bip-usdprice) and specify a price that is at
> a
> minimum $50k USD/BTC.
>
> ==Backwards compatibility==
>
> As a soft fork, older nodes will continue to accept the blockchain without
> modification. Non-upgraded nodes, however, will not validate the minimum
> price requirement, and may accept invalid blocks if miners choose to make
> them. Since transactions not declaring a price are at this time still
> common-place, the softfork activation has been set a full year into the
> future to ensure time to upgrade both nodes and wallet software.
>
> ==Reference implementation==
>
>
> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/30e360be/attachment-0001.html>

From omarshib at gmail.com  Mon Apr  1 02:55:41 2019
From: omarshib at gmail.com (Omar Shibli)
Date: Mon, 1 Apr 2019 05:55:41 +0300
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <20190401011112.6icdkyjocf4qh5oz@petertodd.org>
References: <201904010030.34825.luke@dashjr.org>
	<20190401011112.6icdkyjocf4qh5oz@petertodd.org>
Message-ID: <CAE3EOfgFdZUTdVW-hcxR2m5nM+GaV3R48En3_RVpN1O+rrPO6w@mail.gmail.com>

Shit, so we are vulnerable today? is this zero day vulnerability? so we
could be f***** big?

On Mon, Apr 1, 2019 at 5:47 AM Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev
> wrote:
> > Certain parts of the community have been selling bitcoins for
> unreasonably
> > low prices. This has halted Bitcoin's valuation at $20k and even driven
> the
> > price down below $15k! However, clearly Bitcoin is worth much more than
> > that, and there is widespread support for higher prices.
> >
> > In light of this, I have written and implemented two BIPs: one to add a
> > signed price field to Bitcoin transactions, and the other to softfork a
> > minimum price of $50k USD/BTC a year from today.
>
> I believe I've found a serious vulnerability in your proposal: there's no
> limit
> on the maximum supply of USD.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/73e3c005/attachment.html>

From thfrance at gmail.com  Mon Apr  1 02:57:57 2019
From: thfrance at gmail.com (Thomas France)
Date: Sun, 31 Mar 2019 19:57:57 -0700
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <CALC81CNdndTKxT10gLAEnxJ+-kybUFzTQQLBV8unVHkGv9TP6A@mail.gmail.com>
References: <201904010030.34825.luke@dashjr.org>
	<CALC81CNdndTKxT10gLAEnxJ+-kybUFzTQQLBV8unVHkGv9TP6A@mail.gmail.com>
Message-ID: <CACAnPXdNUtoz8SUmFUSH02AjALD35OzHEJCcWvcoS5w3Mx2UDA@mail.gmail.com>

Once again, Core shows how conservative they are. I am in favor of 2X with
a 100kUSD minimum price, all Bitcoin businesses are with me !

On Sun, Mar 31, 2019 at 7:48 PM Ricardo Filipe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> one year seems too long. i think with the BIP-148 experience you have
> we could easily get there in 6 months at most.
>
> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> escreveu no dia segunda, 1/04/2019 ?(s) 01:33:
> >
> > Certain parts of the community have been selling bitcoins for
> unreasonably
> > low prices. This has halted Bitcoin's valuation at $20k and even driven
> the
> > price down below $15k! However, clearly Bitcoin is worth much more than
> > that, and there is widespread support for higher prices.
> >
> > In light of this, I have written and implemented two BIPs: one to add a
> > signed price field to Bitcoin transactions, and the other to softfork a
> > minimum price of $50k USD/BTC a year from today.
> >
> > The BIPs are here, as well as included at the bottom of this email for
> > convenience:
> >
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
> >
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki
> >
> > A reference implementation is here:
> >
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k
> >
> > Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
> >
> > Luke
> >
> >
> > <pre>
> >   BIP: ?
> >   Layer: Applications
> >   Title: Signed USD Price Indicator
> >   Author: Luke Dashjr <luke+bip at dashjr.org>
> >   Comments-Summary: No comments yet.
> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
> >   Status: Draft
> >   Type: Standards Track
> >   Created: 2019-04-01
> >   License: BSD-2-Clause
> > </pre>
> >
> > ==Abstract==
> >
> > This BIP proposes a method to explicitly specify and sign the USD/BTC
> price
> > for transactions.
> >
> > ==Copyright==
> >
> > This BIP is licensed under the BSD 2-clause license.
> >
> > ==Motivation==
> >
> > Certain parts of the community have been selling bitcoins for
> unreasonably low
> > prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> > down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> > there is widespread support for higher prices.
> >
> > This problem can be fixed by setting a global minimum price for bitcoins.
> > Unfortunately, today, the consensus protocol is completely oblivious to
> the
> > price bitcoins are traded at. Therefore, we must first add a field to
> Bitcoin
> > transactions to indicate their price.
> >
> > ==Specification==
> >
> > ===New field and legal implication===
> >
> > A new field is added to Bitcoin transactions. This field, if present,
> must
> > represent the honest and true USD/BTC rate used for the transaction. By
> > signing the transaction, the sender legally affirms this is the
> valuation of
> > bitcoins used for the transaction.
> >
> > For the avoidance of doubt: when the transaction is valued in a currency
> other
> > than USD, any reasonable exchange rate may be used to come up with the
> USD
> > valuation.
> >
> > ===Serialisation===
> >
> > When serialising the transaction for any purpose, including signing,
> weight
> > calculation, and so on, the output count must be incremented by one.
> Prior to
> > the first real output, the following bytes must be inserted:
> >
> > * Constant: 00 00 00 00 00 00 00 00
> > * A single byte, the size in bytes of the remainder of the inserted data
> > * Constant: 6a 04 55 53 44 24
> > * A single byte, the size in bytes of the remainder of the inserted data
> > * The USD/BTC rate used for the transaction, in standard signed integer
> > serialisation, with all leading zeros removed (except as necessary to
> > preserve the sign bit).
> >
> > ==Backwards compatibility==
> >
> > ===Consensus===
> >
> > The new price field is serialised as a dummy output, with a value of
> zero, and
> > a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will
> ignore
> > this dummy output, and the leading OP_RETURN in the scriptPubKey ensures
> it
> > is never considered spendable.
> >
> > Therefore, current nodes will ignore the new field entirely, and accept
> > transactions using it.
> >
> > ===Wallets===
> >
> > Existing wallets do not typically generate price indicators as specified.
> > Under this BIP, this absence of the field is perfectly acceptable.
> >
> > ==Reference implementation==
> >
> >
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field
> >
> > <pre>
> >   BIP: ?
> >   Layer: Consensus (soft fork)
> >   Title: $50k USD/BTC Minimum Price
> >   Author: Luke Dashjr <luke+bip at dashjr.org>
> >   Comments-Summary: No comments yet.
> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
> >   Status: Draft
> >   Type: Standards Track
> >   Created: 2019-04-01
> >   License: BSD-2-Clause
> >   Requires: usdprice
> > </pre>
> >
> > ==Abstract==
> >
> > This BIP defines a minimum price of $50k USD/BTC for Bitcoin
> transactions.
> >
> > ==Copyright==
> >
> > This BIP is licensed under the BSD 2-clause license.
> >
> > ==Motivation==
> >
> > Certain parts of the community have been selling bitcoins for
> unreasonably low
> > prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> > down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> > there is widespread support for higher prices.
> >
> > bip-usdprice defines a new field to indicate the price of transactions.
> Using
> > this, we can softfork to require a minimum transaction price.
> >
> > ==Specification==
> >
> > Beginning with block height 622370 (expected approximately 2020 April
> 1), a
> > block is reject as invalid unless all transactions it contains both
> declare a
> > USD/BTC price (as defined in bip-usdprice) and specify a price that is
> at a
> > minimum $50k USD/BTC.
> >
> > ==Backwards compatibility==
> >
> > As a soft fork, older nodes will continue to accept the blockchain
> without
> > modification. Non-upgraded nodes, however, will not validate the minimum
> > price requirement, and may accept invalid blocks if miners choose to make
> > them. Since transactions not declaring a price are at this time still
> > common-place, the softfork activation has been set a full year into the
> > future to ensure time to upgrade both nodes and wallet software.
> >
> > ==Reference implementation==
> >
> >
> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190331/7ee15f90/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Apr  1 03:02:28 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 01 Apr 2019 03:02:28 +0000
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <20190401011112.6icdkyjocf4qh5oz@petertodd.org>
References: <201904010030.34825.luke@dashjr.org>
	<20190401011112.6icdkyjocf4qh5oz@petertodd.org>
Message-ID: <w46b6dgqqyu8-vDImIzlztiQx-l22uzl8c9SLG-iIo7-_uZAfdjpV7a1b1FJqXeG09yuaeVOp5pe58HzDbtEBwZmW28hrG7TEiZDgJCUfaY=@protonmail.com>

Hard NAK.

A minimum 50000 USD : 1 BTC exchange rate implies that the value of 1 USD = 0.00002 BTC at maximum.

However, such a USD value in BTC value maximum makes no sense since the true value of 1 USD = 0.00000000 BTC.
(on Lightning, 1 USD = 0.00000000000 BTC)

In particular, the encoding proposed in the BIP does not support a representation of infinity USD per BTC, such that it is impossible to express the true value of USD under this BIP.

> * The USD/BTC rate used for the transaction, in standard signed integer serialisation, with all leading zeros removed (except as necessary to preserve the sign bit).

Regards,
ZmnSCPxj





From dscotese at litmocracy.com  Mon Apr  1 03:04:18 2019
From: dscotese at litmocracy.com (Dave Scotese)
Date: Sun, 31 Mar 2019 20:04:18 -0700
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <CALC81CNdndTKxT10gLAEnxJ+-kybUFzTQQLBV8unVHkGv9TP6A@mail.gmail.com>
References: <201904010030.34825.luke@dashjr.org>
	<CALC81CNdndTKxT10gLAEnxJ+-kybUFzTQQLBV8unVHkGv9TP6A@mail.gmail.com>
Message-ID: <CAGLBAhekS1XbXzUrq8Z9ZZfbXamAumbir6W97vXi75qS8-KNMQ@mail.gmail.com>

I think EXACTLY ONE YEAR is the perfect time.  Well, a year and a day for
me because I'm on the wrong side of the date line, apparently.

On Sun, Mar 31, 2019 at 6:04 PM Ricardo Filipe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> one year seems too long. i think with the BIP-148 experience you have
> we could easily get there in 6 months at most.
>
> Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> escreveu no dia segunda, 1/04/2019 ?(s) 01:33:
> >
> > Certain parts of the community have been selling bitcoins for
> unreasonably
> > low prices. This has halted Bitcoin's valuation at $20k and even driven
> the
> > price down below $15k! However, clearly Bitcoin is worth much more than
> > that, and there is widespread support for higher prices.
> >
> > In light of this, I have written and implemented two BIPs: one to add a
> > signed price field to Bitcoin transactions, and the other to softfork a
> > minimum price of $50k USD/BTC a year from today.
> >
> > The BIPs are here, as well as included at the bottom of this email for
> > convenience:
> >
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
> >
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki
> >
> > A reference implementation is here:
> >
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k
> >
> > Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
> >
> > Luke
> >
> >
> > <pre>
> >   BIP: ?
> >   Layer: Applications
> >   Title: Signed USD Price Indicator
> >   Author: Luke Dashjr <luke+bip at dashjr.org>
> >   Comments-Summary: No comments yet.
> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
> >   Status: Draft
> >   Type: Standards Track
> >   Created: 2019-04-01
> >   License: BSD-2-Clause
> > </pre>
> >
> > ==Abstract==
> >
> > This BIP proposes a method to explicitly specify and sign the USD/BTC
> price
> > for transactions.
> >
> > ==Copyright==
> >
> > This BIP is licensed under the BSD 2-clause license.
> >
> > ==Motivation==
> >
> > Certain parts of the community have been selling bitcoins for
> unreasonably low
> > prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> > down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> > there is widespread support for higher prices.
> >
> > This problem can be fixed by setting a global minimum price for bitcoins.
> > Unfortunately, today, the consensus protocol is completely oblivious to
> the
> > price bitcoins are traded at. Therefore, we must first add a field to
> Bitcoin
> > transactions to indicate their price.
> >
> > ==Specification==
> >
> > ===New field and legal implication===
> >
> > A new field is added to Bitcoin transactions. This field, if present,
> must
> > represent the honest and true USD/BTC rate used for the transaction. By
> > signing the transaction, the sender legally affirms this is the
> valuation of
> > bitcoins used for the transaction.
> >
> > For the avoidance of doubt: when the transaction is valued in a currency
> other
> > than USD, any reasonable exchange rate may be used to come up with the
> USD
> > valuation.
> >
> > ===Serialisation===
> >
> > When serialising the transaction for any purpose, including signing,
> weight
> > calculation, and so on, the output count must be incremented by one.
> Prior to
> > the first real output, the following bytes must be inserted:
> >
> > * Constant: 00 00 00 00 00 00 00 00
> > * A single byte, the size in bytes of the remainder of the inserted data
> > * Constant: 6a 04 55 53 44 24
> > * A single byte, the size in bytes of the remainder of the inserted data
> > * The USD/BTC rate used for the transaction, in standard signed integer
> > serialisation, with all leading zeros removed (except as necessary to
> > preserve the sign bit).
> >
> > ==Backwards compatibility==
> >
> > ===Consensus===
> >
> > The new price field is serialised as a dummy output, with a value of
> zero, and
> > a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will
> ignore
> > this dummy output, and the leading OP_RETURN in the scriptPubKey ensures
> it
> > is never considered spendable.
> >
> > Therefore, current nodes will ignore the new field entirely, and accept
> > transactions using it.
> >
> > ===Wallets===
> >
> > Existing wallets do not typically generate price indicators as specified.
> > Under this BIP, this absence of the field is perfectly acceptable.
> >
> > ==Reference implementation==
> >
> >
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field
> >
> > <pre>
> >   BIP: ?
> >   Layer: Consensus (soft fork)
> >   Title: $50k USD/BTC Minimum Price
> >   Author: Luke Dashjr <luke+bip at dashjr.org>
> >   Comments-Summary: No comments yet.
> >   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
> >   Status: Draft
> >   Type: Standards Track
> >   Created: 2019-04-01
> >   License: BSD-2-Clause
> >   Requires: usdprice
> > </pre>
> >
> > ==Abstract==
> >
> > This BIP defines a minimum price of $50k USD/BTC for Bitcoin
> transactions.
> >
> > ==Copyright==
> >
> > This BIP is licensed under the BSD 2-clause license.
> >
> > ==Motivation==
> >
> > Certain parts of the community have been selling bitcoins for
> unreasonably low
> > prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> > down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> > there is widespread support for higher prices.
> >
> > bip-usdprice defines a new field to indicate the price of transactions.
> Using
> > this, we can softfork to require a minimum transaction price.
> >
> > ==Specification==
> >
> > Beginning with block height 622370 (expected approximately 2020 April
> 1), a
> > block is reject as invalid unless all transactions it contains both
> declare a
> > USD/BTC price (as defined in bip-usdprice) and specify a price that is
> at a
> > minimum $50k USD/BTC.
> >
> > ==Backwards compatibility==
> >
> > As a soft fork, older nodes will continue to accept the blockchain
> without
> > modification. Non-upgraded nodes, however, will not validate the minimum
> > price requirement, and may accept invalid blocks if miners choose to make
> > them. Since transactions not declaring a price are at this time still
> > common-place, the softfork activation has been set a full year into the
> > future to ensure time to upgrade both nodes and wallet software.
> >
> > ==Reference implementation==
> >
> >
> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190331/6f6bb0ce/attachment.html>

From satoshin at mybitcoincenter.com  Mon Apr  1 03:07:41 2019
From: satoshin at mybitcoincenter.com (Satoshin)
Date: Sun, 31 Mar 2019 23:07:41 -0400
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <20190401011112.6icdkyjocf4qh5oz@petertodd.org>
References: <201904010030.34825.luke@dashjr.org>
	<20190401011112.6icdkyjocf4qh5oz@petertodd.org>
Message-ID: <5D9DDB14-9E0F-419B-A069-25448F1FA473@mybitcoincenter.com>

Hi Everyone,
     First portion of your First BIP is excellent- with this field the protocol can actually attain HFT- by  pinning of value at time of trade for later unblock scaling as a mark to market tool which is used in HFT.

The Second BIP of a minimum price would never allow Bitcoin to pass the SEC test of a viable asset. - I hope that portion was actually a Joke since it makes no sense economically. 
If one has ever seen a stock drop 90% in one day then you would understand the volatile nature of future valuation.

Prices have to be able to go higher and lower based on market demand and not tethering to perceived norms. If the US dollar was crashed and it went down to Venezuelan currency levels [hypothetically then where would your 50k limit lead the currency} Never say never- 

Best Regards
XX
 
> On Mar 31, 2019, at 9:11 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev wrote:
>> Certain parts of the community have been selling bitcoins for unreasonably
>> low prices. This has halted Bitcoin's valuation at $20k and even driven the
>> price down below $15k! However, clearly Bitcoin is worth much more than
>> that, and there is widespread support for higher prices.
>> 
>> In light of this, I have written and implemented two BIPs: one to add a
>> signed price field to Bitcoin transactions, and the other to softfork a
>> minimum price of $50k USD/BTC a year from today.
> 
> I believe I've found a serious vulnerability in your proposal: there's no limit
> on the maximum supply of USD.
> 
> -- 
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From willtech at live.com.au  Mon Apr  1 08:55:00 2019
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Mon, 1 Apr 2019 08:55:00 +0000
Subject: [bitcoin-dev] Softfork proposal for minimum price of
	$50k	USD/BTC
In-Reply-To: <5D9DDB14-9E0F-419B-A069-25448F1FA473@mybitcoincenter.com>
References: <201904010030.34825.luke@dashjr.org>
	<20190401011112.6icdkyjocf4qh5oz@petertodd.org>,
	<5D9DDB14-9E0F-419B-A069-25448F1FA473@mybitcoincenter.com>
Message-ID: <PS2P216MB01799D11B4BC9CDB376302959D550@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

It is April 1st. Nonetheless, I am agreed that the first part to track the exchange rate in USD (why not use Gold $/oz?) has merit if properly implemented. Voluntary data is notoriously difficult to enforce for accuracy.

Regards,
________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Satoshin via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, 1 April 2019 2:07 PM
To: Peter Todd; Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] Softfork proposal for minimum price of $50k USD/BTC

Hi Everyone,
     First portion of your First BIP is excellent- with this field the protocol can actually attain HFT- by  pinning of value at time of trade for later unblock scaling as a mark to market tool which is used in HFT.

The Second BIP of a minimum price would never allow Bitcoin to pass the SEC test of a viable asset. - I hope that portion was actually a Joke since it makes no sense economically.
If one has ever seen a stock drop 90% in one day then you would understand the volatile nature of future valuation.

Prices have to be able to go higher and lower based on market demand and not tethering to perceived norms. If the US dollar was crashed and it went down to Venezuelan currency levels [hypothetically then where would your 50k limit lead the currency} Never say never-

Best Regards
XX

> On Mar 31, 2019, at 9:11 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Mon, Apr 01, 2019 at 12:30:34AM +0000, Luke Dashjr via bitcoin-dev wrote:
>> Certain parts of the community have been selling bitcoins for unreasonably
>> low prices. This has halted Bitcoin's valuation at $20k and even driven the
>> price down below $15k! However, clearly Bitcoin is worth much more than
>> that, and there is widespread support for higher prices.
>>
>> In light of this, I have written and implemented two BIPs: one to add a
>> signed price field to Bitcoin transactions, and the other to softfork a
>> minimum price of $50k USD/BTC a year from today.
>
> I believe I've found a serious vulnerability in your proposal: there's no limit
> on the maximum supply of USD.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/82a31c09/attachment-0001.html>

From melvincarvalho at gmail.com  Mon Apr  1 11:22:28 2019
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Mon, 1 Apr 2019 13:22:28 +0200
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <201904010030.34825.luke@dashjr.org>
References: <201904010030.34825.luke@dashjr.org>
Message-ID: <CAKaEYhLfBVFQXST4DavZ=tK=ZGuPgOYa9CxpuPvEVL1CybVFjA@mail.gmail.com>

On Mon, 1 Apr 2019 at 02:32, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Certain parts of the community have been selling bitcoins for unreasonably
> low prices. This has halted Bitcoin's valuation at $20k and even driven the
> price down below $15k! However, clearly Bitcoin is worth much more than
> that, and there is widespread support for higher prices.
>
> In light of this, I have written and implemented two BIPs: one to add a
> signed price field to Bitcoin transactions, and the other to softfork a
> minimum price of $50k USD/BTC a year from today.
>
> The BIPs are here, as well as included at the bottom of this email for
> convenience:
>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
>
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki
>
> A reference implementation is here:
>
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k
>
> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
>

This seems a little arbitrary.  Ask yourself, "Why the USD?".  Yes, it is
the dominant currency now, but in 2, 6, 10, 14 years?  Who knows.

You could make equally an argument to denominate in euros.  Or a basket of
currencies, or even the Bancor.

However the wider question is why even denominate in fiat at all?

I suggest denominating the minimum value in satoshsis themselves, which
would be a negligable upgrade to the network.


>
> Luke
>
>
> <pre>
>   BIP: ?
>   Layer: Applications
>   Title: Signed USD Price Indicator
>   Author: Luke Dashjr <luke+bip at dashjr.org>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This BIP proposes a method to explicitly specify and sign the USD/BTC
> price
> for transactions.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> Certain parts of the community have been selling bitcoins for unreasonably
> low
> prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> there is widespread support for higher prices.
>
> This problem can be fixed by setting a global minimum price for bitcoins.
> Unfortunately, today, the consensus protocol is completely oblivious to
> the
> price bitcoins are traded at. Therefore, we must first add a field to
> Bitcoin
> transactions to indicate their price.
>
> ==Specification==
>
> ===New field and legal implication===
>
> A new field is added to Bitcoin transactions. This field, if present, must
> represent the honest and true USD/BTC rate used for the transaction. By
> signing the transaction, the sender legally affirms this is the valuation
> of
> bitcoins used for the transaction.
>
> For the avoidance of doubt: when the transaction is valued in a currency
> other
> than USD, any reasonable exchange rate may be used to come up with the USD
> valuation.
>
> ===Serialisation===
>
> When serialising the transaction for any purpose, including signing,
> weight
> calculation, and so on, the output count must be incremented by one. Prior
> to
> the first real output, the following bytes must be inserted:
>
> * Constant: 00 00 00 00 00 00 00 00
> * A single byte, the size in bytes of the remainder of the inserted data
> * Constant: 6a 04 55 53 44 24
> * A single byte, the size in bytes of the remainder of the inserted data
> * The USD/BTC rate used for the transaction, in standard signed integer
> serialisation, with all leading zeros removed (except as necessary to
> preserve the sign bit).
>
> ==Backwards compatibility==
>
> ===Consensus===
>
> The new price field is serialised as a dummy output, with a value of zero,
> and
> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore
> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures
> it
> is never considered spendable.
>
> Therefore, current nodes will ignore the new field entirely, and accept
> transactions using it.
>
> ===Wallets===
>
> Existing wallets do not typically generate price indicators as specified.
> Under this BIP, this absence of the field is perfectly acceptable.
>
> ==Reference implementation==
>
>
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field
>
> <pre>
>   BIP: ?
>   Layer: Consensus (soft fork)
>   Title: $50k USD/BTC Minimum Price
>   Author: Luke Dashjr <luke+bip at dashjr.org>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
>   Requires: usdprice
> </pre>
>
> ==Abstract==
>
> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.
>
> ==Copyright==
>
> This BIP is licensed under the BSD 2-clause license.
>
> ==Motivation==
>
> Certain parts of the community have been selling bitcoins for unreasonably
> low
> prices. This has halted Bitcoin's valuation at $20k and even driven the
> price
> down below $15k! However, clearly Bitcoin is worth much more than that,
> and
> there is widespread support for higher prices.
>
> bip-usdprice defines a new field to indicate the price of transactions.
> Using
> this, we can softfork to require a minimum transaction price.
>
> ==Specification==
>
> Beginning with block height 622370 (expected approximately 2020 April 1),
> a
> block is reject as invalid unless all transactions it contains both
> declare a
> USD/BTC price (as defined in bip-usdprice) and specify a price that is at
> a
> minimum $50k USD/BTC.
>
> ==Backwards compatibility==
>
> As a soft fork, older nodes will continue to accept the blockchain without
> modification. Non-upgraded nodes, however, will not validate the minimum
> price requirement, and may accept invalid blocks if miners choose to make
> them. Since transactions not declaring a price are at this time still
> common-place, the softfork activation has been set a full year into the
> future to ensure time to upgrade both nodes and wallet software.
>
> ==Reference implementation==
>
>
> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/a7d3675c/attachment.html>

From dana.coe at bitlox.com  Mon Apr  1 11:50:24 2019
From: dana.coe at bitlox.com (Dana L. Coe)
Date: Mon, 1 Apr 2019 19:50:24 +0800
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <CAKaEYhLfBVFQXST4DavZ=tK=ZGuPgOYa9CxpuPvEVL1CybVFjA@mail.gmail.com>
References: <201904010030.34825.luke@dashjr.org>
	<CAKaEYhLfBVFQXST4DavZ=tK=ZGuPgOYa9CxpuPvEVL1CybVFjA@mail.gmail.com>
Message-ID: <DFB57847-C402-4206-BA9E-E3DA2FB3077C@bitlox.com>

I suggest in the spirit of the times that we not use USD as the reference, but USDT.

Everyone knows Tethers are much more flexible in tracking the true value of the US dollar.

Dana

> On Apr 1, 2019, at 7:22 PM, Melvin Carvalho via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> 
> On Mon, 1 Apr 2019 at 02:32, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> Certain parts of the community have been selling bitcoins for unreasonably
> low prices. This has halted Bitcoin's valuation at $20k and even driven the
> price down below $15k! However, clearly Bitcoin is worth much more than
> that, and there is widespread support for higher prices.
> 
> In light of this, I have written and implemented two BIPs: one to add a
> signed price field to Bitcoin transactions, and the other to softfork a
> minimum price of $50k USD/BTC a year from today.
> 
> The BIPs are here, as well as included at the bottom of this email for 
> convenience:
>   https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki <https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki>
> https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki <https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki>
> 
> A reference implementation is here:
>   https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k <https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k>
> 
> Please review ASAP so we can get these deployed in Bitcoin Core v0.18.
> 
> This seems a little arbitrary.  Ask yourself, "Why the USD?".  Yes, it is the dominant currency now, but in 2, 6, 10, 14 years?  Who knows.
> 
> You could make equally an argument to denominate in euros.  Or a basket of currencies, or even the Bancor.
> 
> However the wider question is why even denominate in fiat at all?  
> 
> I suggest denominating the minimum value in satoshsis themselves, which would be a negligable upgrade to the network.
>  
> 
> Luke
> 
> 
> <pre>
>   BIP: ?
>   Layer: Applications
>   Title: Signed USD Price Indicator
>   Author: Luke Dashjr <luke+bip at dashjr.org <mailto:luke%2Bbip at dashjr.org>>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-?? <https://github.com/bitcoin/bips/wiki/Comments:BIP-??>??
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This BIP proposes a method to explicitly specify and sign the USD/BTC price 
> for transactions.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> Certain parts of the community have been selling bitcoins for unreasonably low 
> prices. This has halted Bitcoin's valuation at $20k and even driven the price 
> down below $15k! However, clearly Bitcoin is worth much more than that, and 
> there is widespread support for higher prices.
> 
> This problem can be fixed by setting a global minimum price for bitcoins. 
> Unfortunately, today, the consensus protocol is completely oblivious to the 
> price bitcoins are traded at. Therefore, we must first add a field to Bitcoin 
> transactions to indicate their price.
> 
> ==Specification==
> 
> ===New field and legal implication===
> 
> A new field is added to Bitcoin transactions. This field, if present, must 
> represent the honest and true USD/BTC rate used for the transaction. By 
> signing the transaction, the sender legally affirms this is the valuation of 
> bitcoins used for the transaction.
> 
> For the avoidance of doubt: when the transaction is valued in a currency other 
> than USD, any reasonable exchange rate may be used to come up with the USD 
> valuation.
> 
> ===Serialisation===
> 
> When serialising the transaction for any purpose, including signing, weight 
> calculation, and so on, the output count must be incremented by one. Prior to 
> the first real output, the following bytes must be inserted:
> 
> * Constant: 00 00 00 00 00 00 00 00
> * A single byte, the size in bytes of the remainder of the inserted data
> * Constant: 6a 04 55 53 44 24
> * A single byte, the size in bytes of the remainder of the inserted data
> * The USD/BTC rate used for the transaction, in standard signed integer 
> serialisation, with all leading zeros removed (except as necessary to 
> preserve the sign bit).
> 
> ==Backwards compatibility==
> 
> ===Consensus===
> 
> The new price field is serialised as a dummy output, with a value of zero, and 
> a scriptPubKey that begins with OP_RETURN (6a). Existing nodes will ignore 
> this dummy output, and the leading OP_RETURN in the scriptPubKey ensures it 
> is never considered spendable.
> 
> Therefore, current nodes will ignore the new field entirely, and accept 
> transactions using it.
> 
> ===Wallets===
> 
> Existing wallets do not typically generate price indicators as specified. 
> Under this BIP, this absence of the field is perfectly acceptable.
> 
> ==Reference implementation==
> 
> https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field <https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field>
> 
> <pre>
>   BIP: ?
>   Layer: Consensus (soft fork)
>   Title: $50k USD/BTC Minimum Price
>   Author: Luke Dashjr <luke+bip at dashjr.org <mailto:luke%2Bbip at dashjr.org>>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-?? <https://github.com/bitcoin/bips/wiki/Comments:BIP-??>??
>   Status: Draft
>   Type: Standards Track
>   Created: 2019-04-01
>   License: BSD-2-Clause
>   Requires: usdprice
> </pre>
> 
> ==Abstract==
> 
> This BIP defines a minimum price of $50k USD/BTC for Bitcoin transactions.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> Certain parts of the community have been selling bitcoins for unreasonably low 
> prices. This has halted Bitcoin's valuation at $20k and even driven the price 
> down below $15k! However, clearly Bitcoin is worth much more than that, and 
> there is widespread support for higher prices.
> 
> bip-usdprice defines a new field to indicate the price of transactions. Using 
> this, we can softfork to require a minimum transaction price.
> 
> ==Specification==
> 
> Beginning with block height 622370 (expected approximately 2020 April 1), a 
> block is reject as invalid unless all transactions it contains both declare a 
> USD/BTC price (as defined in bip-usdprice) and specify a price that is at a 
> minimum $50k USD/BTC.
> 
> ==Backwards compatibility==
> 
> As a soft fork, older nodes will continue to accept the blockchain without 
> modification. Non-upgraded nodes, however, will not validate the minimum 
> price requirement, and may accept invalid blocks if miners choose to make 
> them. Since transactions not declaring a price are at this time still 
> common-place, the softfork activation has been set a full year into the 
> future to ensure time to upgrade both nodes and wallet software.
> 
> ==Reference implementation==
> 
> https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k <https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190401/c9f2e2e4/attachment.html>

From nathanw at tutanota.com  Tue Apr  2 16:53:11 2019
From: nathanw at tutanota.com (nathanw at tutanota.com)
Date: Tue, 2 Apr 2019 18:53:11 +0200 (CEST)
Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
Message-ID: <LbTxyE4--3-1@tutanota.com>

To whom it may concern,

I believe a missing feature in Bitcoin is the ability to have an "integrated address", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.

By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the "sweeping" step required to move multiple customer deposits from a hot address into a single cold address.

Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.

Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being "swept" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.

There are several other more minor advantages such a feature would have, including:
- Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.
- Less need for large rescans after loading huge amounts of customer addresses into client software.
- Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.
- By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.
The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.

I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.

Thanks for your time.
Regards,

Nathan Worsley
CTO - LocalCoinSwap.Com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/400c1e1b/attachment.html>

From htimsxela at protonmail.com  Tue Apr  2 20:01:34 2019
From: htimsxela at protonmail.com (htimSxelA)
Date: Tue, 02 Apr 2019 20:01:34 +0000
Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
In-Reply-To: <LbTxyE4--3-1@tutanota.com>
References: <LbTxyE4--3-1@tutanota.com>
Message-ID: <wtbAF1FAGePDAkY3xkqANuFJtAhEXvz0JeGWnc_OZcGEyFQb-1B590I3IbwtW2FBivur0yONbSQtxaWqiQTJeoDdadivtbGkWwJnLnnzQQE=@protonmail.com>

Hello,

I see two immediate issues with this:
1. Increased resource requirements per transaction
2. Embedding identifying information into the blockchain is generally bad for privacy

It may help your case to provide some technical details of how you'd like to see this implemented, but without overcoming the issues mentioned above I think this proposal will be a very tough sell.

> ...this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.

I am not sure if I see how this issue is solved by your proposal. Assumedly, a human will still need to manually approve cold-wallet withdrawals in order to maintain security. So it seems to me that removing the 'hot-wallet' component of the backend would only amplify the need for human interaction.

I assume you are familiar with hierarchical deterministic wallets? They can allow an exchange to assign/identify user deposits based on address derivation path. Keys for deposit addresses can be kept offline if wanted, and a proper implementation of an HD wallet system should also remove the need for rescans of user deposit addresses.

There is also a functionality built into Bitcoin that allows a user to prove that they own the private keys to some address: signing an agreed upon message using the private key that controls that address. Unfortunately I don't think this is a workable solution for you, since the majority of modern wallet software does not include this feature-- but perhaps worth mentioning nonetheless.

Best,
Alex

??????? Original Message ???????
On Tuesday, April 2, 2019 9:53 AM, Nathan Worsley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> To whom it may concern,
>
> I believe a missing feature in Bitcoin is the ability to have an "integrated address", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.
>
> By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the "sweeping" step required to move multiple customer deposits from a hot address into a single cold address.
>
> Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.
>
> Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being "swept" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.
>
> There are several other more minor advantages such a feature would have, including:
> - Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.
> - Less need for large rescans after loading huge amounts of customer addresses into client software.
> - Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.
> - By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.
>
> The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.
>
> I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.
>
> Thanks for your time.
>
> Regards,
>
> Nathan Worsley
> CTO - LocalCoinSwap.Com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/ade34235/attachment.html>

From james.obeirne at gmail.com  Tue Apr  2 20:43:11 2019
From: james.obeirne at gmail.com (James O'Beirne)
Date: Tue, 2 Apr 2019 16:43:11 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
Message-ID: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>

Hi,

I'd like to discuss assumeutxo, which is an appealing and simple
optimization in the spirit of assumevalid[0].

# Motivation

To start a fully validating bitcoin client from scratch, that client
currently
needs to perform an initial block download. To the surprise of no one, IBD
takes a linear amount time based on the length of the chain's history. For
clients running on modest hardware under limited bandwidth constraints,
say a mobile device, completing IBD takes a considerable amount of time
and thus poses serious usability challenges.

As a result, having fully validating clients run on such hardware is rare
and
basically unrealistic. Clients with even moderate resource constraints
are encouraged to rely on the SPV trust model. Though we have promising
improvements to existing SPV modes pending deployment[1], it's worth
thinking about a mechanism that would allow such clients to use trust
models closer to full validation.

The subject of this mail is a proposal for a complementary alternative to
SPV
modes, and which is in the spirit of an existing default, `assumevalid`. It
may
help modest clients transact under a security model that closely resembles
full validation within minutes instead of hours or days.

# assumeutxo

The basic idea is to allow nodes to initialize using a serialized version
of the
UTXO set rendered by another node at some predetermined height. The
initializing node syncs the headers chain from the network, then obtains and
loads one of these UTXO snapshots (i.e. a serialized version of the UTXO set
bundled with the block header indicating its "base" and some other
metadata).

Based upon the snapshot, the node is able to quickly reconstruct its
chainstate,
and compares a hash of the resulting UTXO set to a preordained hash
hard-coded
in the software a la assumevalid. This all takes ~23 minutes, not
accounting for
download of the 3.2GB snapshot[2].

The node then syncs to the network tip and afterwards begins a simultaneous
background validation (i.e., a conventional IBD) up to the base height of
the
snapshot in order to achieve full validation. Crucially, even while the
background validation is happening the node can validate incoming blocks and
transact with the benefit of the full (assumed-valid) UTXO set.

Snapshots could be obtained from multiple separate peers in the same manner
as
block download, but I haven't put much thought into this. In concept it
doesn't
matter too much where the snapshots come from since their validity is
determined via content hash.

# Security

Obviously there are some security implications due consideration. While this
proposal is in the spirit of assumevalid, practical attacks may become
easier.
Under assumevalid, a user can be tricked into transacting under a false
history
if an attacker convinces them to start bitcoind with a malicious
`-assumevalid`
parameter, sybils their node, and then feeds them a bogus chain encompassing
all of the hard-coded checkpoints[3].

The same attack is made easier in assumeutxo because, unlike in assumevalid,
the attacker need not construct a valid PoW chain to get the victim's node
into
a false state; they simply need to get the user to accept a bad
`-assumeutxo`
parameter and then supply them an easily made UTXO snapshot containing,
say, a
false coin assignment.

For this reason, I recommend that if we were to implement assumeutxo, we not
allow its specification via commandline argument[4].

Beyond this risk, I can't think of material differences in security
relative to
assumevalid, though I appeal to the list for help with this.

# More fully validating clients

A particularly exciting use-case for assumeutxo is the possibility of mobile
devices functioning as fully validating nodes with access to the complete
UTXO
set (as an alternative to SPV models). The total resource burden needed to
start a node
from scratch based on a snapshot is, at time of writing, a ~(3.2GB
+ blocks_to_tip * 4MB) download and a few minutes of processing time, which
sounds
manageable for many mobile devices currently in use.

A mobile user could initialize an assumed-valid bitcoin node within an hour,
transact immediately, and complete a pruned full validation of their
assumed-valid chain over the next few days, perhaps only doing the
background
IBD when their device has access to suitable high-bandwidth connections.

If we end up implementing an accumulator-based UTXO scaling design[5][6]
down
the road, it's easy to imagine an analogous process that would allow very
fast
startup using an accumulator of a few kilobytes in lieu of a multi-GB
snapshot.

---

I've created a related issue at our Github repository here:
  https://github.com/bitcoin/bitcoin/issues/15605

and have submitted a draft implementation of snapshot usage via RPC here:
  https://github.com/bitcoin/bitcoin/pull/15606

I'd like to discuss here whether this is a good fit for Bitcoin
conceptually. Concrete
plans for deployment steps should be discussed in the Github issue, and
after all
that my implementation may be reviewed as a sketch of the specific software
changes necessary.

Regards,
James


[0]:
https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
[1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
[2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
2.10GHz
[3]:
https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
[4]: Marco Falke is due credit for this point
[5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
[6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/46b25dd8/attachment-0001.html>

From vitteaymeric at gmail.com  Tue Apr  2 16:48:55 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 2 Apr 2019 18:48:55 +0200
Subject: [bitcoin-dev] Softfork proposal for minimum price of $50k
	USD/BTC
In-Reply-To: <DFB57847-C402-4206-BA9E-E3DA2FB3077C@bitlox.com>
References: <201904010030.34825.luke@dashjr.org>
	<CAKaEYhLfBVFQXST4DavZ=tK=ZGuPgOYa9CxpuPvEVL1CybVFjA@mail.gmail.com>
	<DFB57847-C402-4206-BA9E-E3DA2FB3077C@bitlox.com>
Message-ID: <df67f6f3-ded7-6f71-98ee-6a868b802ada@gmail.com>

Right and everybody knows that Tether is the most clever sidechain ever 
invented far more sophisticated than lightning, which makes me think 
that a punishment should be added in the proposal for the cheater 
advertising a price < 50 k (or 100) and/or selling before 1-3 years 
(tbd) so all his coins go to the Bitcoin Mediator, a new notion here to 
sustain the community (I modestly apply for the position)


Le 01/04/2019 ? 13:50, Dana L. Coe via bitcoin-dev a ?crit :
> I suggest in the spirit of the times that we not use USD as the 
> reference, but USDT.
>
> Everyone knows Tethers are much more flexible in tracking the true 
> value of the US dollar.
>
> Dana
>
>> On Apr 1, 2019, at 7:22 PM, Melvin Carvalho via bitcoin-dev 
>> <bitcoin-dev at lists.linuxfoundation.org 
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>
>>
>> On Mon, 1 Apr 2019 at 02:32, Luke Dashjr via bitcoin-dev 
>> <bitcoin-dev at lists.linuxfoundation.org 
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>     Certain parts of the community have been selling bitcoins for
>>     unreasonably
>>     low prices. This has halted Bitcoin's valuation at $20k and even
>>     driven the
>>     price down below $15k! However, clearly Bitcoin is worth much
>>     more than
>>     that, and there is widespread support for higher prices.
>>
>>     In light of this, I have written and implemented two BIPs: one to
>>     add a
>>     signed price field to Bitcoin transactions, and the other to
>>     softfork a
>>     minimum price of $50k USD/BTC a year from today.
>>
>>     The BIPs are here, as well as included at the bottom of this
>>     email for
>>     convenience:
>>     https://github.com/luke-jr/bips/blob/softfork_50k/bip-usdprice.mediawiki
>>     https://github.com/luke-jr/bips/blob/softfork_50k/bip-softfork-50k-price.mediawiki
>>
>>     A reference implementation is here:
>>     https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:softfork_50k
>>
>>     Please review ASAP so we can get these deployed in Bitcoin Core
>>     v0.18.
>>
>>
>> This seems a little arbitrary.  Ask yourself, "Why the USD?".  Yes, 
>> it is the dominant currency now, but in 2, 6, 10, 14 years?  Who knows.
>>
>> You could make equally an argument to denominate in euros.  Or a 
>> basket of currencies, or even the Bancor.
>>
>> However the wider question is why even denominate in fiat at all?
>>
>> I suggest denominating the minimum value in satoshsis themselves, 
>> which would be a negligable upgrade to the network.
>>
>>
>>     Luke
>>
>>
>>     <pre>
>>       BIP: ?
>>       Layer: Applications
>>       Title: Signed USD Price Indicator
>>       Author: Luke Dashjr <luke+bip at dashjr.org
>>     <mailto:luke%2Bbip at dashjr.org>>
>>       Comments-Summary: No comments yet.
>>       Comments-URI:
>>     https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>>       Status: Draft
>>       Type: Standards Track
>>       Created: 2019-04-01
>>       License: BSD-2-Clause
>>     </pre>
>>
>>     ==Abstract==
>>
>>     This BIP proposes a method to explicitly specify and sign the
>>     USD/BTC price
>>     for transactions.
>>
>>     ==Copyright==
>>
>>     This BIP is licensed under the BSD 2-clause license.
>>
>>     ==Motivation==
>>
>>     Certain parts of the community have been selling bitcoins for
>>     unreasonably low
>>     prices. This has halted Bitcoin's valuation at $20k and even
>>     driven the price
>>     down below $15k! However, clearly Bitcoin is worth much more than
>>     that, and
>>     there is widespread support for higher prices.
>>
>>     This problem can be fixed by setting a global minimum price for
>>     bitcoins.
>>     Unfortunately, today, the consensus protocol is completely
>>     oblivious to the
>>     price bitcoins are traded at. Therefore, we must first add a
>>     field to Bitcoin
>>     transactions to indicate their price.
>>
>>     ==Specification==
>>
>>     ===New field and legal implication===
>>
>>     A new field is added to Bitcoin transactions. This field, if
>>     present, must
>>     represent the honest and true USD/BTC rate used for the
>>     transaction. By
>>     signing the transaction, the sender legally affirms this is the
>>     valuation of
>>     bitcoins used for the transaction.
>>
>>     For the avoidance of doubt: when the transaction is valued in a
>>     currency other
>>     than USD, any reasonable exchange rate may be used to come up
>>     with the USD
>>     valuation.
>>
>>     ===Serialisation===
>>
>>     When serialising the transaction for any purpose, including
>>     signing, weight
>>     calculation, and so on, the output count must be incremented by
>>     one. Prior to
>>     the first real output, the following bytes must be inserted:
>>
>>     * Constant: 00 00 00 00 00 00 00 00
>>     * A single byte, the size in bytes of the remainder of the
>>     inserted data
>>     * Constant: 6a 04 55 53 44 24
>>     * A single byte, the size in bytes of the remainder of the
>>     inserted data
>>     * The USD/BTC rate used for the transaction, in standard signed
>>     integer
>>     serialisation, with all leading zeros removed (except as
>>     necessary to
>>     preserve the sign bit).
>>
>>     ==Backwards compatibility==
>>
>>     ===Consensus===
>>
>>     The new price field is serialised as a dummy output, with a value
>>     of zero, and
>>     a scriptPubKey that begins with OP_RETURN (6a). Existing nodes
>>     will ignore
>>     this dummy output, and the leading OP_RETURN in the scriptPubKey
>>     ensures it
>>     is never considered spendable.
>>
>>     Therefore, current nodes will ignore the new field entirely, and
>>     accept
>>     transactions using it.
>>
>>     ===Wallets===
>>
>>     Existing wallets do not typically generate price indicators as
>>     specified.
>>     Under this BIP, this absence of the field is perfectly acceptable.
>>
>>     ==Reference implementation==
>>
>>     https://github.com/bitcoin/bitcoin/compare/v0.17.1...luke-jr:usd_price_tx_field
>>
>>     <pre>
>>       BIP: ?
>>       Layer: Consensus (soft fork)
>>       Title: $50k USD/BTC Minimum Price
>>       Author: Luke Dashjr <luke+bip at dashjr.org
>>     <mailto:luke%2Bbip at dashjr.org>>
>>       Comments-Summary: No comments yet.
>>       Comments-URI:
>>     https://github.com/bitcoin/bips/wiki/Comments:BIP-????
>>       Status: Draft
>>       Type: Standards Track
>>       Created: 2019-04-01
>>       License: BSD-2-Clause
>>       Requires: usdprice
>>     </pre>
>>
>>     ==Abstract==
>>
>>     This BIP defines a minimum price of $50k USD/BTC for Bitcoin
>>     transactions.
>>
>>     ==Copyright==
>>
>>     This BIP is licensed under the BSD 2-clause license.
>>
>>     ==Motivation==
>>
>>     Certain parts of the community have been selling bitcoins for
>>     unreasonably low
>>     prices. This has halted Bitcoin's valuation at $20k and even
>>     driven the price
>>     down below $15k! However, clearly Bitcoin is worth much more than
>>     that, and
>>     there is widespread support for higher prices.
>>
>>     bip-usdprice defines a new field to indicate the price of
>>     transactions. Using
>>     this, we can softfork to require a minimum transaction price.
>>
>>     ==Specification==
>>
>>     Beginning with block height 622370 (expected approximately 2020
>>     April 1), a
>>     block is reject as invalid unless all transactions it contains
>>     both declare a
>>     USD/BTC price (as defined in bip-usdprice) and specify a price
>>     that is at a
>>     minimum $50k USD/BTC.
>>
>>     ==Backwards compatibility==
>>
>>     As a soft fork, older nodes will continue to accept the
>>     blockchain without
>>     modification. Non-upgraded nodes, however, will not validate the
>>     minimum
>>     price requirement, and may accept invalid blocks if miners choose
>>     to make
>>     them. Since transactions not declaring a price are at this time
>>     still
>>     common-place, the softfork activation has been set a full year
>>     into the
>>     future to ensure time to upgrade both nodes and wallet software.
>>
>>     ==Reference implementation==
>>
>>     https://github.com/luke-jr/bitcoin/compare/usd_price_tx_field...softfork_50k
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org 
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Peersm : http://www.peersm.com
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/8ef5619c/attachment-0001.html>

From ricardojdfilipe at gmail.com  Tue Apr  2 23:52:16 2019
From: ricardojdfilipe at gmail.com (Ricardo Filipe)
Date: Wed, 3 Apr 2019 00:52:16 +0100
Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
In-Reply-To: <LbTxyE4--3-1@tutanota.com>
References: <LbTxyE4--3-1@tutanota.com>
Message-ID: <CALC81CPkveVjJVnDRG9qXrFmxz0qQMcOT=pMVyXXnpkO43pBnQ@mail.gmail.com>

I believe you are looking for HD wallets.

Nathan Worsley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
escreveu no dia ter?a, 2/04/2019 ?(s) 18:06:
>
> To whom it may concern,
>
> I believe a missing feature in Bitcoin is the ability to have an "integrated address", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.
>
> By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the "sweeping" step required to move multiple customer deposits from a hot address into a single cold address.
>

From forums at dl1ye.com  Wed Apr  3 05:53:25 2019
From: forums at dl1ye.com (Elia)
Date: Wed, 03 Apr 2019 05:53:25 +0000
Subject: [bitcoin-dev] License for BIP39 word lists
In-Reply-To: <pgnG4aynAMLF_fvTKASzXWqV9OMAQFghcNTGmwRA9Dvo6JKD6vN7kcfyMNyIgXz-ONUWYq5AjA8G1fUVqPrMbeWiXicnkczqDlerjSiDZB8=@dl1ye.com>
References: <iKDdEbi-0Ihe0gNPYsIN_nkg2X8t9FK7RRUoTb6fz9rF4mRReXjpKDjIOsZkpGYKG1UXtCHdMdKzXNgk2iihosaWg-8HqYIa9JDoGdJv9Kw=@dl1ye.com>
	<pgnG4aynAMLF_fvTKASzXWqV9OMAQFghcNTGmwRA9Dvo6JKD6vN7kcfyMNyIgXz-ONUWYq5AjA8G1fUVqPrMbeWiXicnkczqDlerjSiDZB8=@dl1ye.com>
Message-ID: <hiMtqbeiSVlUZNbhq34FyJT9uJ-LyDNBsdX1IjK94ZCeTl6mvQaeGYrr9Vu_f3-H0fFLoTsBiJRiG1aVoV1n__nSSWDjjN1ZpwjxbaoUTmc=@dl1ye.com>

I would like to use the BIP39 word lists posted in the Github BIP repo
for my own project.


Unfortunately there is no license associated with the lists provided on
Github so I am not sure whether usage for other projects is permitted. I
am not able to file issues on the repo either to suggest adding a license.

Does anybody know under which license these lists are published?


Best regards,

Elia






From dev at jonasschnelli.ch  Wed Apr  3 06:37:31 2019
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Wed, 3 Apr 2019 08:37:31 +0200
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
Message-ID: <816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>

Thanks James for the post.

I proposed a similar idea [1] back in 2016 with the difference of signing the UTXO-set hash in a gitian-ish way.

While the idea of UTXO-set-syncs are attractive, there are probably still significant downsides in usability (compared to models with less security), mainly:
* Assume the UTXO set is 6 weeks old (which seems a reasonable age for providing enough security) a peer using that snapshot would still require to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,? probably CPU-days on a phone)
* Do we semi-trust the peer that servers the UTXO set (compared to a block or tx which we can validate)? What channel to we use to serve the snapshot?

If the goal is to run a full node on a consumer device that is also been used for other CPU intense operations (like a phone, etc.), I?m not sure if this proposal will lead to a satisfactory user experience.

The longer I think around this problem, the more I lean towards accepting the fact that one need to use dedicated hardware in his own environment to perform a painless full validation.

/jonas

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html

> Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>:
> 
> Hi,
> 
> I'd like to discuss assumeutxo, which is an appealing and simple
> optimization in the spirit of assumevalid[0].
> 
> # Motivation
> 
> To start a fully validating bitcoin client from scratch, that client currently
> needs to perform an initial block download. To the surprise of no one, IBD
> takes a linear amount time based on the length of the chain's history. For
> clients running on modest hardware under limited bandwidth constraints,
> say a mobile device, completing IBD takes a considerable amount of time
> and thus poses serious usability challenges.
> 
> As a result, having fully validating clients run on such hardware is rare and
> basically unrealistic. Clients with even moderate resource constraints
> are encouraged to rely on the SPV trust model. Though we have promising
> improvements to existing SPV modes pending deployment[1], it's worth
> thinking about a mechanism that would allow such clients to use trust
> models closer to full validation.
> 
> The subject of this mail is a proposal for a complementary alternative to SPV
> modes, and which is in the spirit of an existing default, `assumevalid`. It may
> help modest clients transact under a security model that closely resembles
> full validation within minutes instead of hours or days.
> 
> # assumeutxo
> 
> The basic idea is to allow nodes to initialize using a serialized version of the
> UTXO set rendered by another node at some predetermined height. The
> initializing node syncs the headers chain from the network, then obtains and
> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO set
> bundled with the block header indicating its "base" and some other metadata).
> 
> Based upon the snapshot, the node is able to quickly reconstruct its chainstate,
> and compares a hash of the resulting UTXO set to a preordained hash hard-coded
> in the software a la assumevalid. This all takes ~23 minutes, not accounting for
> download of the 3.2GB snapshot[2].
> 
> The node then syncs to the network tip and afterwards begins a simultaneous
> background validation (i.e., a conventional IBD) up to the base height of the
> snapshot in order to achieve full validation. Crucially, even while the
> background validation is happening the node can validate incoming blocks and
> transact with the benefit of the full (assumed-valid) UTXO set.
> 
> Snapshots could be obtained from multiple separate peers in the same manner as
> block download, but I haven't put much thought into this. In concept it doesn't
> matter too much where the snapshots come from since their validity is
> determined via content hash.
> 
> # Security
> 
> Obviously there are some security implications due consideration. While this
> proposal is in the spirit of assumevalid, practical attacks may become easier.
> Under assumevalid, a user can be tricked into transacting under a false history
> if an attacker convinces them to start bitcoind with a malicious `-assumevalid`
> parameter, sybils their node, and then feeds them a bogus chain encompassing
> all of the hard-coded checkpoints[3].
> 
> The same attack is made easier in assumeutxo because, unlike in assumevalid,
> the attacker need not construct a valid PoW chain to get the victim's node into
> a false state; they simply need to get the user to accept a bad `-assumeutxo`
> parameter and then supply them an easily made UTXO snapshot containing, say, a
> false coin assignment.
> 
> For this reason, I recommend that if we were to implement assumeutxo, we not
> allow its specification via commandline argument[4].
> 
> Beyond this risk, I can't think of material differences in security relative to
> assumevalid, though I appeal to the list for help with this.
> 
> # More fully validating clients
> 
> A particularly exciting use-case for assumeutxo is the possibility of mobile
> devices functioning as fully validating nodes with access to the complete UTXO
> set (as an alternative to SPV models). The total resource burden needed to start a node
> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> + blocks_to_tip * 4MB) download and a few minutes of processing time, which sounds
> manageable for many mobile devices currently in use.
> 
> A mobile user could initialize an assumed-valid bitcoin node within an hour,
> transact immediately, and complete a pruned full validation of their
> assumed-valid chain over the next few days, perhaps only doing the background
> IBD when their device has access to suitable high-bandwidth connections.
> 
> If we end up implementing an accumulator-based UTXO scaling design[5][6] down
> the road, it's easy to imagine an analogous process that would allow very fast
> startup using an accumulator of a few kilobytes in lieu of a multi-GB snapshot.
> 
> ---
> 
> I've created a related issue at our Github repository here:
>   https://github.com/bitcoin/bitcoin/issues/15605
> 
> and have submitted a draft implementation of snapshot usage via RPC here:
>   https://github.com/bitcoin/bitcoin/pull/15606
> 
> I'd like to discuss here whether this is a good fit for Bitcoin conceptually. Concrete
> plans for deployment steps should be discussed in the Github issue, and after all
> that my implementation may be reviewed as a sketch of the specific software
> changes necessary.
> 
> Regards,
> James
> 
> 
> [0]: https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @ 2.10GHz
> [3]: https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> [4]: Marco Falke is due credit for this point
> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/0005961e/attachment.sig>

From nicolas.dorier at gmail.com  Wed Apr  3 07:51:04 2019
From: nicolas.dorier at gmail.com (Nicolas Dorier)
Date: Wed, 3 Apr 2019 16:51:04 +0900
Subject: [bitcoin-dev]  assumeutxo and UTXO snapshots
In-Reply-To: <mailman.2593.1554248572.29810.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.2593.1554248572.29810.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CA+1nnrkFWNugSm+o=BrQMLcsO0gNDDCcKRJfDi=5osMZV7o7CA@mail.gmail.com>

James,

You might be interested by my work which is currently used in production,
without any change to bitcoin core.

I properly explain how to verify the utxoset independently.

https://github.com/btcpayserver/btcpayserver-docker/blob/master/contrib/FastSync/README.md


People are using it, since I get around 10 download a day.
What can be done to help at Bitcoin Core level is actually very minimal.

First, instead of asking signers of by UTXOSet to sign the utxoset hash
from gettxoutsetinfo, I ask them to sign the hash of the tarball of my UTXO
Set.

The reason is that it is currently impossible to stop BitcoinD on a
specific block then asking the serialized hash of the UTXO Set.

So instead, a verifier download the tarball (300 blocks + utxoset at
specific height), sync to the latest block, then compare the
gettxoutsetinfo of the newly synched node with another trusted node. If it
match, the verifier sign the tarball.

I create a new utxoset snapshot every 6 months, so people have time to
verify it and add their signatures. (Approximately once every bitcoin core
release)

The easiest thing that could be done at Bitcoin Core level does not require
any code change, but a change in the release process.

The new process would be to ask to the gitian signers to not only build the
source themselves, but also verify a tarball following the procedure I
explain in the link above.

More complicated solution like signing the serialized utxoset itself, while
possible, would require bothersome code changes.

Nicolas,

On Wed, Apr 3, 2019 at 9:25 AM <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. BIP: Bitcoin Integrated Address Feature? (nathanw at tutanota.com)
>    2. Re: BIP: Bitcoin Integrated Address Feature? (htimSxelA)
>    3. assumeutxo and UTXO snapshots (James O'Beirne)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Tue, 2 Apr 2019 18:53:11 +0200 (CEST)
> From: <nathanw at tutanota.com>
> To: <bitcoin-dev at lists.linuxfoundation.org>
> Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
> Message-ID: <LbTxyE4--3-1 at tutanota.com>
> Content-Type: text/plain; charset="utf-8"
>
> To whom it may concern,
>
> I believe a missing feature in Bitcoin is the ability to have an
> "integrated address", where the address resolves into a Bitcoin address,
> and also a transaction message or some other kind of identifier.
>
> By having this feature we could enhance the security of exchange
> cold-wallet systems, by allowing them to easily receive all payments to a
> single address from an infinite number of customers. We would also greatly
> simplify the process of setting up and managing exchange cold-wallet
> systems, because we would eliminate the "sweeping" step required to move
> multiple customer deposits from a hot address into a single cold address.
>
> Although it would be nice to have all customers deposit directly into cold
> addresses, this quickly becomes impractical when large amounts of customers
> begin to use exchange wallets as their personal web-wallet, frequently
> depositing and withdrawing without trading action. You end up needing to
> have a staff member moving funds away from cold deposit addresses as a full
> time job - if you wish to handle customer funds in a completely secure
> manner.
>
> Thus we see that most exchanges now use the hot-deposit system, where
> customers deposit into a hot address that is then automatically swept into
> a singular cold address, by a service which holds customers private keys
> online. You can observe this service at work simply by making a deposit to
> most major exchanges (including the largest exchange Binance), as you will
> see the funds quickly being "swept" to their cold wallet address in a
> manner which heavily suggests automation by a program which possesses
> private keys to the address you are sending funds to. This means there is
> always the danger of a sophisticated hacker being able to capture private
> keys to customer deposit addresses (as they are clearly being held online).
> An integrated address would allow all exchanges using this automated
> hot-deposit service to easily switch to a far more secure alternative of
> having all customers depositing directly into their singular cold wallet
> address.
>
> There are several other more minor advantages such a feature would have,
> including:
> - Lower fees for exchanges (which could be passed onto customers), by
> reducing a transaction step out of the deposit-to-withdrawal flow.
> - Less need for large rescans after loading huge amounts of customer
> addresses into client software.
> - Exchanges can more easily provision deposit addresses to new customers
> in a secure manner, by simply generating a hex or other value, creating an
> integrated address from the cold wallet address, and then providing this to
> the customer.
> - By providing a singular cold address for exchanges publicly, customers
> can more easily verify that no man-in-the-middle has given them an
> incorrect address to deposit to.
> The integrated address could work by combining the Bitcoin address
> together with some kind of hex or other value, allowing users to choose the
> amount they wish to deposit themselves, but ensuring their deposits are
> uniquely trackable.
>
> I'm not sure if some kind of functionality already exists in BTC, as I
> haven't been able to find it. If not, can I submit a proposal to implement
> this? This feature would be a godsend to all exchange developers if it was
> widely accepted.
>
> Thanks for your time.
> Regards,
>
> Nathan Worsley
> CTO - LocalCoinSwap.Com
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/400c1e1b/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Tue, 02 Apr 2019 20:01:34 +0000
> From: htimSxelA <htimsxela at protonmail.com>
> To: "nathanw at tutanota.com" <nathanw at tutanota.com>,      Bitcoin Protocol
>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
> Message-ID:
>
> <wtbAF1FAGePDAkY3xkqANuFJtAhEXvz0JeGWnc_OZcGEyFQb-1B590I3IbwtW2FBivur0yONbSQtxaWqiQTJeoDdadivtbGkWwJnLnnzQQE=@
> protonmail.com>
>
> Content-Type: text/plain; charset="utf-8"
>
> Hello,
>
> I see two immediate issues with this:
> 1. Increased resource requirements per transaction
> 2. Embedding identifying information into the blockchain is generally bad
> for privacy
>
> It may help your case to provide some technical details of how you'd like
> to see this implemented, but without overcoming the issues mentioned above
> I think this proposal will be a very tough sell.
>
> > ...this quickly becomes impractical when large amounts of customers
> begin to use exchange wallets as their personal web-wallet, frequently
> depositing and withdrawing without trading action. You end up needing to
> have a staff member moving funds away from cold deposit addresses as a full
> time job - if you wish to handle customer funds in a completely secure
> manner.
>
> I am not sure if I see how this issue is solved by your proposal.
> Assumedly, a human will still need to manually approve cold-wallet
> withdrawals in order to maintain security. So it seems to me that removing
> the 'hot-wallet' component of the backend would only amplify the need for
> human interaction.
>
> I assume you are familiar with hierarchical deterministic wallets? They
> can allow an exchange to assign/identify user deposits based on address
> derivation path. Keys for deposit addresses can be kept offline if wanted,
> and a proper implementation of an HD wallet system should also remove the
> need for rescans of user deposit addresses.
>
> There is also a functionality built into Bitcoin that allows a user to
> prove that they own the private keys to some address: signing an agreed
> upon message using the private key that controls that address.
> Unfortunately I don't think this is a workable solution for you, since the
> majority of modern wallet software does not include this feature-- but
> perhaps worth mentioning nonetheless.
>
> Best,
> Alex
>
> ??????? Original Message ???????
> On Tuesday, April 2, 2019 9:53 AM, Nathan Worsley via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > To whom it may concern,
> >
> > I believe a missing feature in Bitcoin is the ability to have an
> "integrated address", where the address resolves into a Bitcoin address,
> and also a transaction message or some other kind of identifier.
> >
> > By having this feature we could enhance the security of exchange
> cold-wallet systems, by allowing them to easily receive all payments to a
> single address from an infinite number of customers. We would also greatly
> simplify the process of setting up and managing exchange cold-wallet
> systems, because we would eliminate the "sweeping" step required to move
> multiple customer deposits from a hot address into a single cold address.
> >
> > Although it would be nice to have all customers deposit directly into
> cold addresses, this quickly becomes impractical when large amounts of
> customers begin to use exchange wallets as their personal web-wallet,
> frequently depositing and withdrawing without trading action. You end up
> needing to have a staff member moving funds away from cold deposit
> addresses as a full time job - if you wish to handle customer funds in a
> completely secure manner.
> >
> > Thus we see that most exchanges now use the hot-deposit system, where
> customers deposit into a hot address that is then automatically swept into
> a singular cold address, by a service which holds customers private keys
> online. You can observe this service at work simply by making a deposit to
> most major exchanges (including the largest exchange Binance), as you will
> see the funds quickly being "swept" to their cold wallet address in a
> manner which heavily suggests automation by a program which possesses
> private keys to the address you are sending funds to. This means there is
> always the danger of a sophisticated hacker being able to capture private
> keys to customer deposit addresses (as they are clearly being held online).
> An integrated address would allow all exchanges using this automated
> hot-deposit service to easily switch to a far more secure alternative of
> having all customers depositing directly into their singular cold wallet
> address.
> >
> > There are several other more minor advantages such a feature would have,
> including:
> > - Lower fees for exchanges (which could be passed onto customers), by
> reducing a transaction step out of the deposit-to-withdrawal flow.
> > - Less need for large rescans after loading huge amounts of customer
> addresses into client software.
> > - Exchanges can more easily provision deposit addresses to new customers
> in a secure manner, by simply generating a hex or other value, creating an
> integrated address from the cold wallet address, and then providing this to
> the customer.
> > - By providing a singular cold address for exchanges publicly, customers
> can more easily verify that no man-in-the-middle has given them an
> incorrect address to deposit to.
> >
> > The integrated address could work by combining the Bitcoin address
> together with some kind of hex or other value, allowing users to choose the
> amount they wish to deposit themselves, but ensuring their deposits are
> uniquely trackable.
> >
> > I'm not sure if some kind of functionality already exists in BTC, as I
> haven't been able to find it. If not, can I submit a proposal to implement
> this? This feature would be a godsend to all exchange developers if it was
> widely accepted.
> >
> > Thanks for your time.
> >
> > Regards,
> >
> > Nathan Worsley
> > CTO - LocalCoinSwap.Com
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/ade34235/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 3
> Date: Tue, 2 Apr 2019 16:43:11 -0400
> From: "James O'Beirne" <james.obeirne at gmail.com>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
> Message-ID:
>         <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=
> XwngA at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi,
>
> I'd like to discuss assumeutxo, which is an appealing and simple
> optimization in the spirit of assumevalid[0].
>
> # Motivation
>
> To start a fully validating bitcoin client from scratch, that client
> currently
> needs to perform an initial block download. To the surprise of no one, IBD
> takes a linear amount time based on the length of the chain's history. For
> clients running on modest hardware under limited bandwidth constraints,
> say a mobile device, completing IBD takes a considerable amount of time
> and thus poses serious usability challenges.
>
> As a result, having fully validating clients run on such hardware is rare
> and
> basically unrealistic. Clients with even moderate resource constraints
> are encouraged to rely on the SPV trust model. Though we have promising
> improvements to existing SPV modes pending deployment[1], it's worth
> thinking about a mechanism that would allow such clients to use trust
> models closer to full validation.
>
> The subject of this mail is a proposal for a complementary alternative to
> SPV
> modes, and which is in the spirit of an existing default, `assumevalid`. It
> may
> help modest clients transact under a security model that closely resembles
> full validation within minutes instead of hours or days.
>
> # assumeutxo
>
> The basic idea is to allow nodes to initialize using a serialized version
> of the
> UTXO set rendered by another node at some predetermined height. The
> initializing node syncs the headers chain from the network, then obtains
> and
> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO
> set
> bundled with the block header indicating its "base" and some other
> metadata).
>
> Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> download of the 3.2GB snapshot[2].
>
> The node then syncs to the network tip and afterwards begins a simultaneous
> background validation (i.e., a conventional IBD) up to the base height of
> the
> snapshot in order to achieve full validation. Crucially, even while the
> background validation is happening the node can validate incoming blocks
> and
> transact with the benefit of the full (assumed-valid) UTXO set.
>
> Snapshots could be obtained from multiple separate peers in the same manner
> as
> block download, but I haven't put much thought into this. In concept it
> doesn't
> matter too much where the snapshots come from since their validity is
> determined via content hash.
>
> # Security
>
> Obviously there are some security implications due consideration. While
> this
> proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> Under assumevalid, a user can be tricked into transacting under a false
> history
> if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> parameter, sybils their node, and then feeds them a bogus chain
> encompassing
> all of the hard-coded checkpoints[3].
>
> The same attack is made easier in assumeutxo because, unlike in
> assumevalid,
> the attacker need not construct a valid PoW chain to get the victim's node
> into
> a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> false coin assignment.
>
> For this reason, I recommend that if we were to implement assumeutxo, we
> not
> allow its specification via commandline argument[4].
>
> Beyond this risk, I can't think of material differences in security
> relative to
> assumevalid, though I appeal to the list for help with this.
>
> # More fully validating clients
>
> A particularly exciting use-case for assumeutxo is the possibility of
> mobile
> devices functioning as fully validating nodes with access to the complete
> UTXO
> set (as an alternative to SPV models). The total resource burden needed to
> start a node
> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> + blocks_to_tip * 4MB) download and a few minutes of processing time, which
> sounds
> manageable for many mobile devices currently in use.
>
> A mobile user could initialize an assumed-valid bitcoin node within an
> hour,
> transact immediately, and complete a pruned full validation of their
> assumed-valid chain over the next few days, perhaps only doing the
> background
> IBD when their device has access to suitable high-bandwidth connections.
>
> If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> the road, it's easy to imagine an analogous process that would allow very
> fast
> startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
>
> ---
>
> I've created a related issue at our Github repository here:
>   https://github.com/bitcoin/bitcoin/issues/15605
>
> and have submitted a draft implementation of snapshot usage via RPC here:
>   https://github.com/bitcoin/bitcoin/pull/15606
>
> I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> plans for deployment steps should be discussed in the Github issue, and
> after all
> that my implementation may be reviewed as a sketch of the specific software
> changes necessary.
>
> Regards,
> James
>
>
> [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
> 2.10GHz
> [3]:
>
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> [4]: Marco Falke is due credit for this point
> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/46b25dd8/attachment.html
> >
>
> ------------------------------
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> End of bitcoin-dev Digest, Vol 47, Issue 6
> ******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/7a1cb47c/attachment-0001.html>

From stick at satoshilabs.com  Wed Apr  3 09:19:40 2019
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Wed, 3 Apr 2019 11:19:40 +0200
Subject: [bitcoin-dev] License for BIP39 word lists
In-Reply-To: <hiMtqbeiSVlUZNbhq34FyJT9uJ-LyDNBsdX1IjK94ZCeTl6mvQaeGYrr9Vu_f3-H0fFLoTsBiJRiG1aVoV1n__nSSWDjjN1ZpwjxbaoUTmc=@dl1ye.com>
References: <iKDdEbi-0Ihe0gNPYsIN_nkg2X8t9FK7RRUoTb6fz9rF4mRReXjpKDjIOsZkpGYKG1UXtCHdMdKzXNgk2iihosaWg-8HqYIa9JDoGdJv9Kw=@dl1ye.com>
	<pgnG4aynAMLF_fvTKASzXWqV9OMAQFghcNTGmwRA9Dvo6JKD6vN7kcfyMNyIgXz-ONUWYq5AjA8G1fUVqPrMbeWiXicnkczqDlerjSiDZB8=@dl1ye.com>
	<hiMtqbeiSVlUZNbhq34FyJT9uJ-LyDNBsdX1IjK94ZCeTl6mvQaeGYrr9Vu_f3-H0fFLoTsBiJRiG1aVoV1n__nSSWDjjN1ZpwjxbaoUTmc=@dl1ye.com>
Message-ID: <CAF90AvnKXZta0S+Pxe6t9mGmf9vsm_Y_ZjF1PaAygUaCk+fM0A@mail.gmail.com>

I am the author of the wordlist. Feel free to use it without any
restrictions.

However, we are finalizing SLIP39 standard for splitting shares which uses
a different wordlist with better properties. It might be more suitable for
your project.

See https://github.com/satoshilabs/slips/blob/master/slip-0039.md and
https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt



On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I would like to use the BIP39 word lists posted in the Github BIP repo
> for my own project.
>
>
> Unfortunately there is no license associated with the lists provided on
> Github so I am not sure whether usage for other projects is permitted. I
> am not able to file issues on the repo either to suggest adding a license.
>
> Does anybody know under which license these lists are published?
>
>
> Best regards,
>
> Elia
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/79fcf295/attachment-0001.html>

From luke at dashjr.org  Wed Apr  3 09:55:26 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 3 Apr 2019 09:55:26 +0000
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
Message-ID: <201904030955.26536.luke@dashjr.org>

This would lead to users trusting third parties (like developers) way too 
much.

Furthermore, removing the ability for users to easily set it removes the one 
reasonable use case: where the user has already verified the state at some 
point previously, and saved the hash (ie, as backup of the UTXO set).

Luke


On Tuesday 02 April 2019 20:43:11 James O'Beirne via bitcoin-dev wrote:
> Hi,
>
> I'd like to discuss assumeutxo, which is an appealing and simple
> optimization in the spirit of assumevalid[0].
>
> # Motivation
>
> To start a fully validating bitcoin client from scratch, that client
> currently
> needs to perform an initial block download. To the surprise of no one, IBD
> takes a linear amount time based on the length of the chain's history. For
> clients running on modest hardware under limited bandwidth constraints,
> say a mobile device, completing IBD takes a considerable amount of time
> and thus poses serious usability challenges.
>
> As a result, having fully validating clients run on such hardware is rare
> and
> basically unrealistic. Clients with even moderate resource constraints
> are encouraged to rely on the SPV trust model. Though we have promising
> improvements to existing SPV modes pending deployment[1], it's worth
> thinking about a mechanism that would allow such clients to use trust
> models closer to full validation.
>
> The subject of this mail is a proposal for a complementary alternative to
> SPV
> modes, and which is in the spirit of an existing default, `assumevalid`. It
> may
> help modest clients transact under a security model that closely resembles
> full validation within minutes instead of hours or days.
>
> # assumeutxo
>
> The basic idea is to allow nodes to initialize using a serialized version
> of the
> UTXO set rendered by another node at some predetermined height. The
> initializing node syncs the headers chain from the network, then obtains
> and loads one of these UTXO snapshots (i.e. a serialized version of the
> UTXO set bundled with the block header indicating its "base" and some other
> metadata).
>
> Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> download of the 3.2GB snapshot[2].
>
> The node then syncs to the network tip and afterwards begins a simultaneous
> background validation (i.e., a conventional IBD) up to the base height of
> the
> snapshot in order to achieve full validation. Crucially, even while the
> background validation is happening the node can validate incoming blocks
> and transact with the benefit of the full (assumed-valid) UTXO set.
>
> Snapshots could be obtained from multiple separate peers in the same manner
> as
> block download, but I haven't put much thought into this. In concept it
> doesn't
> matter too much where the snapshots come from since their validity is
> determined via content hash.
>
> # Security
>
> Obviously there are some security implications due consideration. While
> this proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> Under assumevalid, a user can be tricked into transacting under a false
> history
> if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> parameter, sybils their node, and then feeds them a bogus chain
> encompassing all of the hard-coded checkpoints[3].
>
> The same attack is made easier in assumeutxo because, unlike in
> assumevalid, the attacker need not construct a valid PoW chain to get the
> victim's node into
> a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> false coin assignment.
>
> For this reason, I recommend that if we were to implement assumeutxo, we
> not allow its specification via commandline argument[4].
>
> Beyond this risk, I can't think of material differences in security
> relative to
> assumevalid, though I appeal to the list for help with this.
>
> # More fully validating clients
>
> A particularly exciting use-case for assumeutxo is the possibility of
> mobile devices functioning as fully validating nodes with access to the
> complete UTXO
> set (as an alternative to SPV models). The total resource burden needed to
> start a node
> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> + blocks_to_tip * 4MB) download and a few minutes of processing time, which
> sounds
> manageable for many mobile devices currently in use.
>
> A mobile user could initialize an assumed-valid bitcoin node within an
> hour, transact immediately, and complete a pruned full validation of their
> assumed-valid chain over the next few days, perhaps only doing the
> background
> IBD when their device has access to suitable high-bandwidth connections.
>
> If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> the road, it's easy to imagine an analogous process that would allow very
> fast
> startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
>
> ---
>
> I've created a related issue at our Github repository here:
>   https://github.com/bitcoin/bitcoin/issues/15605
>
> and have submitted a draft implementation of snapshot usage via RPC here:
>   https://github.com/bitcoin/bitcoin/pull/15606
>
> I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> plans for deployment steps should be discussed in the Github issue, and
> after all
> that my implementation may be reviewed as a sketch of the specific software
> changes necessary.
>
> Regards,
> James
>
>
> [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
> 2.10GHz
> [3]:
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L1
>61 [4]: Marco Falke is due credit for this point
> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188


From ethan.scruples at gmail.com  Wed Apr  3 15:39:29 2019
From: ethan.scruples at gmail.com (Ethan Scruples)
Date: Wed, 3 Apr 2019 11:39:29 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
Message-ID: <CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>

Jonas,

If we can get mandatory UTXO commitments soft forked into Bitcoin, we get
the advantage of a non-growing IBD, which I think everyone would agree is a
benefit that, uh, grows over time. The thing I do not see people noticing
is that we actually pay little to no security price for this benefit.

To see this, consider Alice, who starts from a UTXO snapshot made at
current height - 50,000 and Bob who validates from genesis.

After her partial validation, Alice is satisfied that she is in possession
of the UTXO set-- she is in consensus with the rest of the network peers.

However, Bob realizes that there is actually an invalid block at current
height - 50,001.

Three things to notice:

1. This scenario essentially cannot happen. There is no way that the miners
are going to stack 50,000 blocks on top of an invalid block without the
economic majority abandoning the invalid chain.

2. If this scenario DOES happen, Bob has learned about it too late for it
to matter to Bob. The blockchain Bob wants to be on is the one that
everyone has been using for the last year, whether or not it is besmirched
by an invalid block.

3. If this scenario DOES happen, and Bob DOES want to reject the last
50,000 mined blocks as invalid, he may discover to his dismay that in the 1
year since the invalid block, mischievous entities have enough time to mine
equally weighted alternative histories from the Genesis block forward to
the invalid block, meaning that Bob has no way to use POW to come to
consensus with other Bobs out there.

On Wed, Apr 3, 2019 at 3:33 AM Jonas Schnelli via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks James for the post.
>
> I proposed a similar idea [1] back in 2016 with the difference of signing
> the UTXO-set hash in a gitian-ish way.
>
> While the idea of UTXO-set-syncs are attractive, there are probably still
> significant downsides in usability (compared to models with less security),
> mainly:
> * Assume the UTXO set is 6 weeks old (which seems a reasonable age for
> providing enough security) a peer using that snapshot would still require
> to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,? probably
> CPU-days on a phone)
> * Do we semi-trust the peer that servers the UTXO set (compared to a block
> or tx which we can validate)? What channel to we use to serve the snapshot?
>
> If the goal is to run a full node on a consumer device that is also been
> used for other CPU intense operations (like a phone, etc.), I?m not sure if
> this proposal will lead to a satisfactory user experience.
>
> The longer I think around this problem, the more I lean towards accepting
> the fact that one need to use dedicated hardware in his own environment to
> perform a painless full validation.
>
> /jonas
>
> [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html
>
> > Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>:
> >
> > Hi,
> >
> > I'd like to discuss assumeutxo, which is an appealing and simple
> > optimization in the spirit of assumevalid[0].
> >
> > # Motivation
> >
> > To start a fully validating bitcoin client from scratch, that client
> currently
> > needs to perform an initial block download. To the surprise of no one,
> IBD
> > takes a linear amount time based on the length of the chain's history.
> For
> > clients running on modest hardware under limited bandwidth constraints,
> > say a mobile device, completing IBD takes a considerable amount of time
> > and thus poses serious usability challenges.
> >
> > As a result, having fully validating clients run on such hardware is
> rare and
> > basically unrealistic. Clients with even moderate resource constraints
> > are encouraged to rely on the SPV trust model. Though we have promising
> > improvements to existing SPV modes pending deployment[1], it's worth
> > thinking about a mechanism that would allow such clients to use trust
> > models closer to full validation.
> >
> > The subject of this mail is a proposal for a complementary alternative
> to SPV
> > modes, and which is in the spirit of an existing default, `assumevalid`.
> It may
> > help modest clients transact under a security model that closely
> resembles
> > full validation within minutes instead of hours or days.
> >
> > # assumeutxo
> >
> > The basic idea is to allow nodes to initialize using a serialized
> version of the
> > UTXO set rendered by another node at some predetermined height. The
> > initializing node syncs the headers chain from the network, then obtains
> and
> > loads one of these UTXO snapshots (i.e. a serialized version of the UTXO
> set
> > bundled with the block header indicating its "base" and some other
> metadata).
> >
> > Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> > and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> > in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> > download of the 3.2GB snapshot[2].
> >
> > The node then syncs to the network tip and afterwards begins a
> simultaneous
> > background validation (i.e., a conventional IBD) up to the base height
> of the
> > snapshot in order to achieve full validation. Crucially, even while the
> > background validation is happening the node can validate incoming blocks
> and
> > transact with the benefit of the full (assumed-valid) UTXO set.
> >
> > Snapshots could be obtained from multiple separate peers in the same
> manner as
> > block download, but I haven't put much thought into this. In concept it
> doesn't
> > matter too much where the snapshots come from since their validity is
> > determined via content hash.
> >
> > # Security
> >
> > Obviously there are some security implications due consideration. While
> this
> > proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> > Under assumevalid, a user can be tricked into transacting under a false
> history
> > if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> > parameter, sybils their node, and then feeds them a bogus chain
> encompassing
> > all of the hard-coded checkpoints[3].
> >
> > The same attack is made easier in assumeutxo because, unlike in
> assumevalid,
> > the attacker need not construct a valid PoW chain to get the victim's
> node into
> > a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> > parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> > false coin assignment.
> >
> > For this reason, I recommend that if we were to implement assumeutxo, we
> not
> > allow its specification via commandline argument[4].
> >
> > Beyond this risk, I can't think of material differences in security
> relative to
> > assumevalid, though I appeal to the list for help with this.
> >
> > # More fully validating clients
> >
> > A particularly exciting use-case for assumeutxo is the possibility of
> mobile
> > devices functioning as fully validating nodes with access to the
> complete UTXO
> > set (as an alternative to SPV models). The total resource burden needed
> to start a node
> > from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> > + blocks_to_tip * 4MB) download and a few minutes of processing time,
> which sounds
> > manageable for many mobile devices currently in use.
> >
> > A mobile user could initialize an assumed-valid bitcoin node within an
> hour,
> > transact immediately, and complete a pruned full validation of their
> > assumed-valid chain over the next few days, perhaps only doing the
> background
> > IBD when their device has access to suitable high-bandwidth connections.
> >
> > If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> > the road, it's easy to imagine an analogous process that would allow
> very fast
> > startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
> >
> > ---
> >
> > I've created a related issue at our Github repository here:
> >   https://github.com/bitcoin/bitcoin/issues/15605
> >
> > and have submitted a draft implementation of snapshot usage via RPC here:
> >   https://github.com/bitcoin/bitcoin/pull/15606
> >
> > I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> > plans for deployment steps should be discussed in the Github issue, and
> after all
> > that my implementation may be reviewed as a sketch of the specific
> software
> > changes necessary.
> >
> > Regards,
> > James
> >
> >
> > [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> > [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> > [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU
> @ 2.10GHz
> > [3]:
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> > [4]: Marco Falke is due credit for this point
> > [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> > [6]: Boneh, Bunz, Fisch on accumulators:
> https://eprint.iacr.org/2018/1188
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/69a9a9bf/attachment-0001.html>

From james.obeirne at gmail.com  Wed Apr  3 19:51:32 2019
From: james.obeirne at gmail.com (James O'Beirne)
Date: Wed, 3 Apr 2019 15:51:32 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
Message-ID: <CAPfvXf+vLzAtQvF=jP0Ro6Nt195zzVOSOmQfegZvcc8S1Pfu9Q@mail.gmail.com>

Thanks for the reply, Jonas. I should've figured someone had hit the
mailing list with this one before!

In hindsight, I may have overemphasized the use of this for low-powered
mobile devices. Indeed I think this may also be a worthwhile optimization
for common hardware too.

On the margin, if a user wants to interact with Bitcoin they will download
software that allows them to do it immediately - this results in many
people defaulting to a light client. If Bitcoin were able to initialize
from scratch in a comparable amount of time and then populate the full
chain in the background, we may have many more people *incidentally*
running full nodes.

Regardless of whether or not we use UTXO snapshots per se, I'd argue that
the pattern of doing some kind of quick initialization (whether it's with
assumed-valid data, or headers-contingent data like BIP157) and then
performing full validation in the background is a good way to ensure that
we have a healthier population of full nodes than we would otherwise.

For this reason, and (as Ethan points out) because IBD's linear setup time
is infeasible in the long-term, I think this pattern is an obvious
direction for the bitcoin client to go.

> * Do we semi-trust the peer that servers the UTXO set (compared to a
block or tx which we can validate)? What channel to we use to serve the
snapshot?

As you note in your post from 2016, where and how we retrieve the snapshot
is more or less immaterial because we compare a hash of its contents to a
previously specified value that the code ships with (the `assumeutxo`
hash). We don't need to trust the source serving it to us, although
bandwidth DoS prevention via some kind chunked delivery from peers would be
worth thinking about.

Regards,
James

On Wed, Apr 3, 2019 at 2:37 AM Jonas Schnelli <dev at jonasschnelli.ch> wrote:

> Thanks James for the post.
>
> I proposed a similar idea [1] back in 2016 with the difference of signing
> the UTXO-set hash in a gitian-ish way.
>
> While the idea of UTXO-set-syncs are attractive, there are probably still
> significant downsides in usability (compared to models with less security),
> mainly:
> * Assume the UTXO set is 6 weeks old (which seems a reasonable age for
> providing enough security) a peer using that snapshot would still require
> to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,? probably
> CPU-days on a phone)
> * Do we semi-trust the peer that servers the UTXO set (compared to a block
> or tx which we can validate)? What channel to we use to serve the snapshot?
>
> If the goal is to run a full node on a consumer device that is also been
> used for other CPU intense operations (like a phone, etc.), I?m not sure if
> this proposal will lead to a satisfactory user experience.
>
> The longer I think around this problem, the more I lean towards accepting
> the fact that one need to use dedicated hardware in his own environment to
> perform a painless full validation.
>
> /jonas
>
> [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html
>
> > Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>:
> >
> > Hi,
> >
> > I'd like to discuss assumeutxo, which is an appealing and simple
> > optimization in the spirit of assumevalid[0].
> >
> > # Motivation
> >
> > To start a fully validating bitcoin client from scratch, that client
> currently
> > needs to perform an initial block download. To the surprise of no one,
> IBD
> > takes a linear amount time based on the length of the chain's history.
> For
> > clients running on modest hardware under limited bandwidth constraints,
> > say a mobile device, completing IBD takes a considerable amount of time
> > and thus poses serious usability challenges.
> >
> > As a result, having fully validating clients run on such hardware is
> rare and
> > basically unrealistic. Clients with even moderate resource constraints
> > are encouraged to rely on the SPV trust model. Though we have promising
> > improvements to existing SPV modes pending deployment[1], it's worth
> > thinking about a mechanism that would allow such clients to use trust
> > models closer to full validation.
> >
> > The subject of this mail is a proposal for a complementary alternative
> to SPV
> > modes, and which is in the spirit of an existing default, `assumevalid`.
> It may
> > help modest clients transact under a security model that closely
> resembles
> > full validation within minutes instead of hours or days.
> >
> > # assumeutxo
> >
> > The basic idea is to allow nodes to initialize using a serialized
> version of the
> > UTXO set rendered by another node at some predetermined height. The
> > initializing node syncs the headers chain from the network, then obtains
> and
> > loads one of these UTXO snapshots (i.e. a serialized version of the UTXO
> set
> > bundled with the block header indicating its "base" and some other
> metadata).
> >
> > Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> > and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> > in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> > download of the 3.2GB snapshot[2].
> >
> > The node then syncs to the network tip and afterwards begins a
> simultaneous
> > background validation (i.e., a conventional IBD) up to the base height
> of the
> > snapshot in order to achieve full validation. Crucially, even while the
> > background validation is happening the node can validate incoming blocks
> and
> > transact with the benefit of the full (assumed-valid) UTXO set.
> >
> > Snapshots could be obtained from multiple separate peers in the same
> manner as
> > block download, but I haven't put much thought into this. In concept it
> doesn't
> > matter too much where the snapshots come from since their validity is
> > determined via content hash.
> >
> > # Security
> >
> > Obviously there are some security implications due consideration. While
> this
> > proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> > Under assumevalid, a user can be tricked into transacting under a false
> history
> > if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> > parameter, sybils their node, and then feeds them a bogus chain
> encompassing
> > all of the hard-coded checkpoints[3].
> >
> > The same attack is made easier in assumeutxo because, unlike in
> assumevalid,
> > the attacker need not construct a valid PoW chain to get the victim's
> node into
> > a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> > parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> > false coin assignment.
> >
> > For this reason, I recommend that if we were to implement assumeutxo, we
> not
> > allow its specification via commandline argument[4].
> >
> > Beyond this risk, I can't think of material differences in security
> relative to
> > assumevalid, though I appeal to the list for help with this.
> >
> > # More fully validating clients
> >
> > A particularly exciting use-case for assumeutxo is the possibility of
> mobile
> > devices functioning as fully validating nodes with access to the
> complete UTXO
> > set (as an alternative to SPV models). The total resource burden needed
> to start a node
> > from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> > + blocks_to_tip * 4MB) download and a few minutes of processing time,
> which sounds
> > manageable for many mobile devices currently in use.
> >
> > A mobile user could initialize an assumed-valid bitcoin node within an
> hour,
> > transact immediately, and complete a pruned full validation of their
> > assumed-valid chain over the next few days, perhaps only doing the
> background
> > IBD when their device has access to suitable high-bandwidth connections.
> >
> > If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> > the road, it's easy to imagine an analogous process that would allow
> very fast
> > startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
> >
> > ---
> >
> > I've created a related issue at our Github repository here:
> >   https://github.com/bitcoin/bitcoin/issues/15605
> >
> > and have submitted a draft implementation of snapshot usage via RPC here:
> >   https://github.com/bitcoin/bitcoin/pull/15606
> >
> > I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> > plans for deployment steps should be discussed in the Github issue, and
> after all
> > that my implementation may be reviewed as a sketch of the specific
> software
> > changes necessary.
> >
> > Regards,
> > James
> >
> >
> > [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> > [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> > [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU
> @ 2.10GHz
> > [3]:
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> > [4]: Marco Falke is due credit for this point
> > [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> > [6]: Boneh, Bunz, Fisch on accumulators:
> https://eprint.iacr.org/2018/1188
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/e631ec0b/attachment.html>

From jonas.shane at gmail.com  Wed Apr  3 20:48:24 2019
From: jonas.shane at gmail.com (Shane Jonas)
Date: Wed, 3 Apr 2019 13:48:24 -0700
Subject: [bitcoin-dev] Add OpenRPC Service Discovery To JSON-RPC Services
Message-ID: <CA+1vstqKjj5yE=zRRe=ZX+1ynTH2ox8kfLGyBr5HyrzmfnW_mA@mail.gmail.com>

Similar to how Bitcion has BIPs to normalize bitcoin wallets, this is a
proposal to normalize the Bitcoin RPC Interface.

Just one example of the problems that arise: If a client doesn't provide
getblock or doesn't work in the same way it will have
unintended consequences .

Having a standard described interfaces lets you generate documentation,
generate RPC clients, test interfaces, across implementations.


Here is the proposal:

https://github.com/bitcoin/bips/pull/776

Here is just an example of what something like that would look like for
Bitcoin:
https://github.com/bitcoin/bips/pull/776#issuecomment-479649785
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/8d7a9bc2/attachment-0001.html>

From dscotese at litmocracy.com  Wed Apr  3 21:39:32 2019
From: dscotese at litmocracy.com (Dave Scotese)
Date: Wed, 3 Apr 2019 14:39:32 -0700
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
Message-ID: <CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>

Every block's hash is smaller than the difficulty at that time.  Block
569927's hash was VERY small (started with 21 zeros).  The ratio of block
hash to difficulty requirement (0xffffffff - difficulty, I think) could be
used to identify blocks as "special," thus providing the opportunity to
popularize unimportant but memorable-and-therefore-useful details.  How can
they be useful if they are unimportant?  They are useful for sanity
checking.  For example, if the drunken bishop walk (or some other popular
randomart) produced by block 569927's hash looked like a face, that would
be memorable: "The block with the smallest hash in 2019 (maybe ever?) looks
like a face after the drunken bishop walk."

If a few of these showed up each year, then Bob and/or Alice would have a
good chance of seeing that something was wrong if and when they checked.
It would not be surprising, given Ethan's assumption that the invalid block
Bob found contributed to Alice's UTXOs, that at some point, the history one
of them has would be missing the memorable things beginning at some block
height because, clearly, one of them has been forked.

Luke's comment that it could "lead to users trusting third parties (like
developers) way too much" is pertinent too, but I think an honest abatement
of that concern is impossible without teaching everyone C++.  "Developers"
as an open group (anyone can fork the github repo, find a problem, and make
an issue) deserve the trust we put in them, and that's because they're
accountable (any such error found in the repo will have been put there by
someone).  The same thing goes for making it possible to download (*not
just the compiled software*, but) the entire UTXO Set if a commitment of it
is hardcoded into the software, as James suggests.  We all trust
"developers" like that, and it's okay.  No one holds the "ring of power."

On Wed, Apr 3, 2019 at 8:39 AM Ethan Scruples via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Jonas,
>
> If we can get mandatory UTXO commitments soft forked into Bitcoin, we get
> the advantage of a non-growing IBD, which I think everyone would agree is a
> benefit that, uh, grows over time. The thing I do not see people noticing
> is that we actually pay little to no security price for this benefit.
>
> To see this, consider Alice, who starts from a UTXO snapshot made at
> current height - 50,000 and Bob who validates from genesis.
>
> After her partial validation, Alice is satisfied that she is in possession
> of the UTXO set-- she is in consensus with the rest of the network peers.
>
> However, Bob realizes that there is actually an invalid block at current
> height - 50,001.
>
> Three things to notice:
>
> 1. This scenario essentially cannot happen. There is no way that the
> miners are going to stack 50,000 blocks on top of an invalid block without
> the economic majority abandoning the invalid chain.
>
> 2. If this scenario DOES happen, Bob has learned about it too late for it
> to matter to Bob. The blockchain Bob wants to be on is the one that
> everyone has been using for the last year, whether or not it is besmirched
> by an invalid block.
>
> 3. If this scenario DOES happen, and Bob DOES want to reject the last
> 50,000 mined blocks as invalid, he may discover to his dismay that in the 1
> year since the invalid block, mischievous entities have enough time to mine
> equally weighted alternative histories from the Genesis block forward to
> the invalid block, meaning that Bob has no way to use POW to come to
> consensus with other Bobs out there.
>
> On Wed, Apr 3, 2019 at 3:33 AM Jonas Schnelli via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Thanks James for the post.
>>
>> I proposed a similar idea [1] back in 2016 with the difference of signing
>> the UTXO-set hash in a gitian-ish way.
>>
>> While the idea of UTXO-set-syncs are attractive, there are probably still
>> significant downsides in usability (compared to models with less security),
>> mainly:
>> * Assume the UTXO set is 6 weeks old (which seems a reasonable age for
>> providing enough security) a peer using that snapshot would still require
>> to download and verify ~6048 blocks (~7.9GB at 1.3MB blocks,? probably
>> CPU-days on a phone)
>> * Do we semi-trust the peer that servers the UTXO set (compared to a
>> block or tx which we can validate)? What channel to we use to serve the
>> snapshot?
>>
>> If the goal is to run a full node on a consumer device that is also been
>> used for other CPU intense operations (like a phone, etc.), I?m not sure if
>> this proposal will lead to a satisfactory user experience.
>>
>> The longer I think around this problem, the more I lean towards accepting
>> the fact that one need to use dedicated hardware in his own environment to
>> perform a painless full validation.
>>
>> /jonas
>>
>> [1]
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-February/012478.html
>>
>> > Am 02.04.2019 um 22:43 schrieb James O'Beirne via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org>:
>> >
>> > Hi,
>> >
>> > I'd like to discuss assumeutxo, which is an appealing and simple
>> > optimization in the spirit of assumevalid[0].
>> >
>> > # Motivation
>> >
>> > To start a fully validating bitcoin client from scratch, that client
>> currently
>> > needs to perform an initial block download. To the surprise of no one,
>> IBD
>> > takes a linear amount time based on the length of the chain's history.
>> For
>> > clients running on modest hardware under limited bandwidth constraints,
>> > say a mobile device, completing IBD takes a considerable amount of time
>> > and thus poses serious usability challenges.
>> >
>> > As a result, having fully validating clients run on such hardware is
>> rare and
>> > basically unrealistic. Clients with even moderate resource constraints
>> > are encouraged to rely on the SPV trust model. Though we have promising
>> > improvements to existing SPV modes pending deployment[1], it's worth
>> > thinking about a mechanism that would allow such clients to use trust
>> > models closer to full validation.
>> >
>> > The subject of this mail is a proposal for a complementary alternative
>> to SPV
>> > modes, and which is in the spirit of an existing default,
>> `assumevalid`. It may
>> > help modest clients transact under a security model that closely
>> resembles
>> > full validation within minutes instead of hours or days.
>> >
>> > # assumeutxo
>> >
>> > The basic idea is to allow nodes to initialize using a serialized
>> version of the
>> > UTXO set rendered by another node at some predetermined height. The
>> > initializing node syncs the headers chain from the network, then
>> obtains and
>> > loads one of these UTXO snapshots (i.e. a serialized version of the
>> UTXO set
>> > bundled with the block header indicating its "base" and some other
>> metadata).
>> >
>> > Based upon the snapshot, the node is able to quickly reconstruct its
>> chainstate,
>> > and compares a hash of the resulting UTXO set to a preordained hash
>> hard-coded
>> > in the software a la assumevalid. This all takes ~23 minutes, not
>> accounting for
>> > download of the 3.2GB snapshot[2].
>> >
>> > The node then syncs to the network tip and afterwards begins a
>> simultaneous
>> > background validation (i.e., a conventional IBD) up to the base height
>> of the
>> > snapshot in order to achieve full validation. Crucially, even while the
>> > background validation is happening the node can validate incoming
>> blocks and
>> > transact with the benefit of the full (assumed-valid) UTXO set.
>> >
>> > Snapshots could be obtained from multiple separate peers in the same
>> manner as
>> > block download, but I haven't put much thought into this. In concept it
>> doesn't
>> > matter too much where the snapshots come from since their validity is
>> > determined via content hash.
>> >
>> > # Security
>> >
>> > Obviously there are some security implications due consideration. While
>> this
>> > proposal is in the spirit of assumevalid, practical attacks may become
>> easier.
>> > Under assumevalid, a user can be tricked into transacting under a false
>> history
>> > if an attacker convinces them to start bitcoind with a malicious
>> `-assumevalid`
>> > parameter, sybils their node, and then feeds them a bogus chain
>> encompassing
>> > all of the hard-coded checkpoints[3].
>> >
>> > The same attack is made easier in assumeutxo because, unlike in
>> assumevalid,
>> > the attacker need not construct a valid PoW chain to get the victim's
>> node into
>> > a false state; they simply need to get the user to accept a bad
>> `-assumeutxo`
>> > parameter and then supply them an easily made UTXO snapshot containing,
>> say, a
>> > false coin assignment.
>> >
>> > For this reason, I recommend that if we were to implement assumeutxo,
>> we not
>> > allow its specification via commandline argument[4].
>> >
>> > Beyond this risk, I can't think of material differences in security
>> relative to
>> > assumevalid, though I appeal to the list for help with this.
>> >
>> > # More fully validating clients
>> >
>> > A particularly exciting use-case for assumeutxo is the possibility of
>> mobile
>> > devices functioning as fully validating nodes with access to the
>> complete UTXO
>> > set (as an alternative to SPV models). The total resource burden needed
>> to start a node
>> > from scratch based on a snapshot is, at time of writing, a ~(3.2GB
>> > + blocks_to_tip * 4MB) download and a few minutes of processing time,
>> which sounds
>> > manageable for many mobile devices currently in use.
>> >
>> > A mobile user could initialize an assumed-valid bitcoin node within an
>> hour,
>> > transact immediately, and complete a pruned full validation of their
>> > assumed-valid chain over the next few days, perhaps only doing the
>> background
>> > IBD when their device has access to suitable high-bandwidth connections.
>> >
>> > If we end up implementing an accumulator-based UTXO scaling
>> design[5][6] down
>> > the road, it's easy to imagine an analogous process that would allow
>> very fast
>> > startup using an accumulator of a few kilobytes in lieu of a multi-GB
>> snapshot.
>> >
>> > ---
>> >
>> > I've created a related issue at our Github repository here:
>> >   https://github.com/bitcoin/bitcoin/issues/15605
>> >
>> > and have submitted a draft implementation of snapshot usage via RPC
>> here:
>> >   https://github.com/bitcoin/bitcoin/pull/15606
>> >
>> > I'd like to discuss here whether this is a good fit for Bitcoin
>> conceptually. Concrete
>> > plans for deployment steps should be discussed in the Github issue, and
>> after all
>> > that my implementation may be reviewed as a sketch of the specific
>> software
>> > changes necessary.
>> >
>> > Regards,
>> > James
>> >
>> >
>> > [0]:
>> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
>> > [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
>> > [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116
>> CPU @ 2.10GHz
>> > [3]:
>> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
>> > [4]: Marco Falke is due credit for this point
>> > [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
>> > [6]: Boneh, Bunz, Fisch on accumulators:
>> https://eprint.iacr.org/2018/1188
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/d942b813/attachment-0001.html>

From jim.posen at gmail.com  Wed Apr  3 23:03:12 2019
From: jim.posen at gmail.com (Jim Posen)
Date: Wed, 3 Apr 2019 16:03:12 -0700
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
Message-ID: <CADZtCSjx-YeGzfs4DtuXZ-8y4tWiHB7Luh133S0ZPbQzWz-dbw@mail.gmail.com>

Big Concept ACK. I think this would be one of the biggest usability
improvements for Bitcoin and I see no security issues with the assumevalid
approach. I also agree that it's important to start work on this even
before the ultimate, perfect accumulator has been designed/tested and the
commitment scheme can always be upgraded later on. assumeutxo syncing
actually seems pretty orthogonal to the accumulator research.

I have a few questions

- So any nodes that do an initial sync will stop at the assumeutxo height,
serialize a snapshot of the chain state and store it? How many nodes are
expected to do this? Any idea how long this takes? Should it be enabled by
default?
- Would pruned nodes still download all historic blocks to double-check the
snapshot or only full nodes that intend to serve block data?
- How long are old snapshots retained? Presumably during a new release
nodes should keep at least a version back. Without P2P signalling of which
snapshots are available, they maybe have to keep all old snapshots or even
download old ones.

and comments

- The snapshot should probably be chunked up to minimize the amount of
bandwidth/IO/memory a malicious node could waste before you realize. Also,
it would make parallel downloading easier.

On Tue, Apr 2, 2019 at 4:43 PM James O'Beirne via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> I'd like to discuss assumeutxo, which is an appealing and simple
> optimization in the spirit of assumevalid[0].
>
> # Motivation
>
> To start a fully validating bitcoin client from scratch, that client
> currently
> needs to perform an initial block download. To the surprise of no one, IBD
> takes a linear amount time based on the length of the chain's history. For
> clients running on modest hardware under limited bandwidth constraints,
> say a mobile device, completing IBD takes a considerable amount of time
> and thus poses serious usability challenges.
>
> As a result, having fully validating clients run on such hardware is rare
> and
> basically unrealistic. Clients with even moderate resource constraints
> are encouraged to rely on the SPV trust model. Though we have promising
> improvements to existing SPV modes pending deployment[1], it's worth
> thinking about a mechanism that would allow such clients to use trust
> models closer to full validation.
>
> The subject of this mail is a proposal for a complementary alternative to
> SPV
> modes, and which is in the spirit of an existing default, `assumevalid`.
> It may
> help modest clients transact under a security model that closely resembles
> full validation within minutes instead of hours or days.
>
> # assumeutxo
>
> The basic idea is to allow nodes to initialize using a serialized version
> of the
> UTXO set rendered by another node at some predetermined height. The
> initializing node syncs the headers chain from the network, then obtains
> and
> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO
> set
> bundled with the block header indicating its "base" and some other
> metadata).
>
> Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> download of the 3.2GB snapshot[2].
>
> The node then syncs to the network tip and afterwards begins a simultaneous
> background validation (i.e., a conventional IBD) up to the base height of
> the
> snapshot in order to achieve full validation. Crucially, even while the
> background validation is happening the node can validate incoming blocks
> and
> transact with the benefit of the full (assumed-valid) UTXO set.
>
> Snapshots could be obtained from multiple separate peers in the same
> manner as
> block download, but I haven't put much thought into this. In concept it
> doesn't
> matter too much where the snapshots come from since their validity is
> determined via content hash.
>
> # Security
>
> Obviously there are some security implications due consideration. While
> this
> proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> Under assumevalid, a user can be tricked into transacting under a false
> history
> if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> parameter, sybils their node, and then feeds them a bogus chain
> encompassing
> all of the hard-coded checkpoints[3].
>
> The same attack is made easier in assumeutxo because, unlike in
> assumevalid,
> the attacker need not construct a valid PoW chain to get the victim's node
> into
> a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> false coin assignment.
>
> For this reason, I recommend that if we were to implement assumeutxo, we
> not
> allow its specification via commandline argument[4].
>
> Beyond this risk, I can't think of material differences in security
> relative to
> assumevalid, though I appeal to the list for help with this.
>
> # More fully validating clients
>
> A particularly exciting use-case for assumeutxo is the possibility of
> mobile
> devices functioning as fully validating nodes with access to the complete
> UTXO
> set (as an alternative to SPV models). The total resource burden needed to
> start a node
> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> + blocks_to_tip * 4MB) download and a few minutes of processing time,
> which sounds
> manageable for many mobile devices currently in use.
>
> A mobile user could initialize an assumed-valid bitcoin node within an
> hour,
> transact immediately, and complete a pruned full validation of their
> assumed-valid chain over the next few days, perhaps only doing the
> background
> IBD when their device has access to suitable high-bandwidth connections.
>
> If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> the road, it's easy to imagine an analogous process that would allow very
> fast
> startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
>
> ---
>
> I've created a related issue at our Github repository here:
>   https://github.com/bitcoin/bitcoin/issues/15605
>
> and have submitted a draft implementation of snapshot usage via RPC here:
>   https://github.com/bitcoin/bitcoin/pull/15606
>
> I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> plans for deployment steps should be discussed in the Github issue, and
> after all
> that my implementation may be reviewed as a sketch of the specific software
> changes necessary.
>
> Regards,
> James
>
>
> [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
> 2.10GHz
> [3]:
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> [4]: Marco Falke is due credit for this point
> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/49377fdf/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Apr  4 01:55:06 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 04 Apr 2019 01:55:06 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
Message-ID: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>

https://zmnscpxj.github.io/bitcoin/unchained.html

Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.  Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.  This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.

From tamas.blummer at gmail.com  Thu Apr  4 02:35:03 2019
From: tamas.blummer at gmail.com (Tamas Blummer)
Date: Thu, 4 Apr 2019 04:35:03 +0200
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
Message-ID: <4CF83957-A6FB-4DDF-A85C-F287BFB1644A@gmail.com>

Hi ZmnSCPxj,

Thought provoking, thank you!

Something I dislike in the scheme, that one could not tell which party colluded with the escrow agent.

Tamas Blummer

> On Apr 4, 2019, at 03:55, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> https://zmnscpxj.github.io/bitcoin/unchained.html
> 
> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.  Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.  This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From luke at dashjr.org  Thu Apr  4 02:48:33 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 4 Apr 2019 02:48:33 +0000
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
Message-ID: <201904040248.34162.luke@dashjr.org>

On Wednesday 03 April 2019 15:39:29 Ethan Scruples via bitcoin-dev wrote:
> If we can get mandatory UTXO commitments soft forked into Bitcoin, we get
> the advantage of a non-growing IBD,

No, we don't. This is exactly the danger. UTXO snapshots are NOT an 
alternative to a real IBD. There are HUGE security implications for this. 
Frankly, the danger that someone would do such a thing is itself a good 
reason not to ever add UTXO commitments.

Luke

From luke at dashjr.org  Thu Apr  4 03:01:00 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 4 Apr 2019 03:01:00 +0000
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
	<CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
Message-ID: <201904040301.01074.luke@dashjr.org>

On Wednesday 03 April 2019 21:39:32 Dave Scotese via bitcoin-dev wrote:
> Luke's comment that it could "lead to users trusting third parties (like
> developers) way too much" is pertinent too, but I think an honest abatement
> of that concern is impossible without teaching everyone C++.

Learning C++ is something within everyone's capability. Even people who do not 
wish to learn it can hire someone to perform review for them.

> "Developers" 
> as an open group (anyone can fork the github repo, find a problem, and make
> an issue) deserve the trust we put in them, and that's because they're
> accountable (any such error found in the repo will have been put there by
> someone). 

No, we are not. We explicitly disclaim any warranty, and do not want your 
trust.

> The same thing goes for making it possible to download (*not 
> just the compiled software*, but) the entire UTXO Set if a commitment of it
> is hardcoded into the software, as James suggests. 

Verifying a UTXO set commitment is impossible short of a real IBD. It's not 
even comparable.

> We all trust 
> "developers" like that, and it's okay.

No, it isn't okay. There are plenty of fiat options if you want a trust-based 
currency. Bitcoin is supposed to be something more than that.

Luke

From ethan.scruples at gmail.com  Thu Apr  4 03:04:58 2019
From: ethan.scruples at gmail.com (Ethan Scruples)
Date: Wed, 3 Apr 2019 23:04:58 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <201904040248.34162.luke@dashjr.org>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
	<201904040248.34162.luke@dashjr.org>
Message-ID: <CACiOHGy9q_W+w1n6q2hxvbrD_SfvbQ3AsNe+W+UBgEV8QF2C3Q@mail.gmail.com>

> This is exactly the danger. UTXO snapshots are NOT an alternative to a
real IBD. There are HUGE security implications for this.

This is a perfect example of what I am talking about when I say that people
do not appear to notice that there is no important security implication to
be found here.

If there are huge security implications for this, then I am keen to hear
them. In the scenario I have described, what advantage does Bob have over
Alice? What actionable information has Bob gained, and what is the action
he can take with it in hand? What value does Bob receive in return for the
electricity he has spent validating the previous blocks? I cannot find any,
but I am open to hearing the answer, and I think others would benefit from
knowing it as well.

On Wed, Apr 3, 2019 at 10:49 PM Luke Dashjr <luke at dashjr.org> wrote:

> On Wednesday 03 April 2019 15:39:29 Ethan Scruples via bitcoin-dev wrote:
> > If we can get mandatory UTXO commitments soft forked into Bitcoin, we get
> > the advantage of a non-growing IBD,
>
> No, we don't. This is exactly the danger. UTXO snapshots are NOT an
> alternative to a real IBD. There are HUGE security implications for this.
> Frankly, the danger that someone would do such a thing is itself a good
> reason not to ever add UTXO commitments.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/a03cbf04/attachment.html>

From arielluaces at gmail.com  Thu Apr  4 03:37:47 2019
From: arielluaces at gmail.com (Ariel Lorenzo-Luaces)
Date: Wed, 03 Apr 2019 20:37:47 -0700
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
Message-ID: <77b8f255-8f70-431e-839c-b99361d1dac7@gmail.com>

Hello ZmnSCPxj

I like the proposal because it generalizes escrow type mechanisms and I think it's a useful train of thought for distributed exchanges.

However, consider the situation where a group of participants are playing poker. One participant loses all their funds and decides to present to the escrow the contract+an old contract state+a signed message following the contract rules (eg. an independently signed cashing out message). How would the escrow know that the contract state is old and the operation is disallowed, without using a consensus mechanism like a blockchain?

Cheers
Ariel Lorenzo-Luaces

On Apr 3, 2019, 7:14 PM, at 7:14 PM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>https://zmnscpxj.github.io/bitcoin/unchained.html
>
>Smart contracts have traditionally been implemented as part of the
>consensus rules of some blokchain.  Often this means creating a new
>blockchain, or at least a sidechain to an existing blockchain.  This
>writeup proposes an alternative method without launching a separate
>blockchain or sidechain, while achieving security similar to federated
>sidechains and additional benefits to privacy and
>smart-contract-patching.
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/0125e3d2/attachment.html>

From jim.posen at gmail.com  Thu Apr  4 05:59:32 2019
From: jim.posen at gmail.com (Jim Posen)
Date: Wed, 3 Apr 2019 22:59:32 -0700
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <201904040301.01074.luke@dashjr.org>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
	<CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
	<201904040301.01074.luke@dashjr.org>
Message-ID: <CADZtCSi394PPwEJg3bcjLDE7jkuyFoEtcKPos4NQxBM+OJPv_Q@mail.gmail.com>

>
> Learning C++ is something within everyone's capability. Even people who do
> not
> wish to learn it can hire someone to perform review for them.
>

Anyone with enough knowledge of C++ to audit the entire the Bitcoin Core
codebase is more than capable of running it with assumeutxo disabled and
checking the hard-coded vale themself.

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190403/fa2a9a58/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Apr  4 07:07:10 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 04 Apr 2019 07:07:10 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <77b8f255-8f70-431e-839c-b99361d1dac7@gmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
	<77b8f255-8f70-431e-839c-b99361d1dac7@gmail.com>
Message-ID: <Yz-vUCuXGAD-evAyVSQDlL-8GzfDE-hDvGza7dgTY39gdklIZbFIv6XDfoBHSz96bwBNLCtAtCsXKvX7n-9oRqSgIVBD17y57Vvu8tzURXw=@protonmail.com>

Good morning Ariel,

> However, consider the situation where a group of participants are playing poker. One participant loses all their funds and decides to present to the escrow the contract+an old contract state+a signed message following the contract rules (eg. an independently signed cashing out message). How would the escrow know that the contract state is old and the operation is disallowed, without using a consensus mechanism like a blockchain?

One might point to the various channel mechanisms (Poon-Dryja, Decker-Wattenhofer, Decker-Russell-Osuntokun) as counterarguments.
Though they require a blockchain as backing, old states are invalidated (Poon-Dryja) or replaceable (Decker-*), without necessarily requiring a blockchain to keep track of all the states.

Suppose our purported smart contract platform supports some kind of covenant system.
This means, that it is possible to make a branch of the contract require that the fund go to a specific address template in the transaction that spends it.
Suppose we use this mechanism to require that the Bitcoin-level transaction pay again to a contract in the same contract platform.
It then becomes possible to make a covenant that requires spending the transaction to the same covenant.

This can allow us to enforce creating an offchain sequence of transactions T1...Tn, such that T2 spends T1, T3 spends T2, etc.
Then the final transaction Tn completes the sequence and pays out according to the rules of Poker, or whatever.
This sequence is anchored on an onchain transaction T0 which enters the funds into the smart contract.

The smart contract platform just signs "blindly" without particularly caring whether the signature went onchain, or even whether the UTXO being spent exists onchain --- all it cares, is that the smart contract can be given witnesses correctly.

Now upon reaching Tn, the winner(s) can just publish the sequence of transactions T1...Tn.
Alternately, they can present the sequence of transactions T1...Tn to all participants, and offer to give back part of the money allocated to fees for all the transactions T1...Tn in exchange for a single transaction that shortcuts all of that and spends to however Tn splits out.

Basically, consider that the Decker-Russell-Osuntokun mechanism starts with a mechanism very much like the above (a sequence of update transactions) and then does some optimizations to allow the final transaction Tn to spend any transaction Ti where i < n.
But the basic concept that the sequence is at all possible, and can be kept offchain, implies this state does not require to be stored onchain at all.




Regards,
ZmnSCPxj

From zapfmann at gmail.com  Thu Apr  4 10:27:02 2019
From: zapfmann at gmail.com (Kulpreet Singh)
Date: Thu, 4 Apr 2019 12:27:02 +0200
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CA+1nnrkFWNugSm+o=BrQMLcsO0gNDDCcKRJfDi=5osMZV7o7CA@mail.gmail.com>
References: <mailman.2593.1554248572.29810.bitcoin-dev@lists.linuxfoundation.org>
	<CA+1nnrkFWNugSm+o=BrQMLcsO0gNDDCcKRJfDi=5osMZV7o7CA@mail.gmail.com>
Message-ID: <CAN8S4uZz_WoAU-TiC4XHq81Vw4-Fzed9xsHzFdLO5m+AHX5JFA@mail.gmail.com>

Hi Nicolas,

I have a small question about FastSync.

Would it make sense to validate all blocks once FastSync is complete
and BTCPayServer has started accepting payments?

I am aware this will require changes to bitcoind. So this is just an
academic question to figure if there are problems with such an
approach, especially for merchants accepting payments who want to get
started immediately and still want to stay on a Raspberry PI.

Phase 1: FastSync from trusted UTXO set and start accepting payments.
Phase 2: Validate the entire blockchain - this will take X days on
Raspberry PI - but at least in in the end you can fully trust your own
node. In this phase, you'd do IBD, but instead of writing to db, just
verify that the validated block matches the on the the db and move on.

It is a pity leveldb doesn't allow multiple processes to open the db.
If so, phase 2 could have been a different process altogether as well.

Regards
Kulpreet



On Wed, 3 Apr 2019 at 21:23, Nicolas Dorier via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> James,
>
> You might be interested by my work which is currently used in production, without any change to bitcoin core.
>
> I properly explain how to verify the utxoset independently.
>
> https://github.com/btcpayserver/btcpayserver-docker/blob/master/contrib/FastSync/README.md
>
> People are using it, since I get around 10 download a day.
> What can be done to help at Bitcoin Core level is actually very minimal.
>
> First, instead of asking signers of by UTXOSet to sign the utxoset hash from gettxoutsetinfo, I ask them to sign the hash of the tarball of my UTXO Set.
>
> The reason is that it is currently impossible to stop BitcoinD on a specific block then asking the serialized hash of the UTXO Set.
>
> So instead, a verifier download the tarball (300 blocks + utxoset at specific height), sync to the latest block, then compare the gettxoutsetinfo of the newly synched node with another trusted node. If it match, the verifier sign the tarball.
>
> I create a new utxoset snapshot every 6 months, so people have time to verify it and add their signatures. (Approximately once every bitcoin core release)
>
> The easiest thing that could be done at Bitcoin Core level does not require any code change, but a change in the release process.
>
> The new process would be to ask to the gitian signers to not only build the source themselves, but also verify a tarball following the procedure I explain in the link above.
>
> More complicated solution like signing the serialized utxoset itself, while possible, would require bothersome code changes.
>
> Nicolas,
>
> On Wed, Apr 3, 2019 at 9:25 AM <bitcoin-dev-request at lists.linuxfoundation.org> wrote:
>>
>> Send bitcoin-dev mailing list submissions to
>>         bitcoin-dev at lists.linuxfoundation.org
>>
>> To subscribe or unsubscribe via the World Wide Web, visit
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> or, via email, send a message with subject or body 'help' to
>>         bitcoin-dev-request at lists.linuxfoundation.org
>>
>> You can reach the person managing the list at
>>         bitcoin-dev-owner at lists.linuxfoundation.org
>>
>> When replying, please edit your Subject line so it is more specific
>> than "Re: Contents of bitcoin-dev digest..."
>>
>>
>> Today's Topics:
>>
>>    1. BIP: Bitcoin Integrated Address Feature? (nathanw at tutanota.com)
>>    2. Re: BIP: Bitcoin Integrated Address Feature? (htimSxelA)
>>    3. assumeutxo and UTXO snapshots (James O'Beirne)
>>
>>
>> ----------------------------------------------------------------------
>>
>> Message: 1
>> Date: Tue, 2 Apr 2019 18:53:11 +0200 (CEST)
>> From: <nathanw at tutanota.com>
>> To: <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
>> Message-ID: <LbTxyE4--3-1 at tutanota.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> To whom it may concern,
>>
>> I believe a missing feature in Bitcoin is the ability to have an "integrated address", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.
>>
>> By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the "sweeping" step required to move multiple customer deposits from a hot address into a single cold address.
>>
>> Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.
>>
>> Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being "swept" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.
>>
>> There are several other more minor advantages such a feature would have, including:
>> - Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.
>> - Less need for large rescans after loading huge amounts of customer addresses into client software.
>> - Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.
>> - By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.
>> The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.
>>
>> I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.
>>
>> Thanks for your time.
>> Regards,
>>
>> Nathan Worsley
>> CTO - LocalCoinSwap.Com
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/400c1e1b/attachment-0001.html>
>>
>> ------------------------------
>>
>> Message: 2
>> Date: Tue, 02 Apr 2019 20:01:34 +0000
>> From: htimSxelA <htimsxela at protonmail.com>
>> To: "nathanw at tutanota.com" <nathanw at tutanota.com>,      Bitcoin Protocol
>>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] BIP: Bitcoin Integrated Address Feature?
>> Message-ID:
>>         <wtbAF1FAGePDAkY3xkqANuFJtAhEXvz0JeGWnc_OZcGEyFQb-1B590I3IbwtW2FBivur0yONbSQtxaWqiQTJeoDdadivtbGkWwJnLnnzQQE=@protonmail.com>
>>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Hello,
>>
>> I see two immediate issues with this:
>> 1. Increased resource requirements per transaction
>> 2. Embedding identifying information into the blockchain is generally bad for privacy
>>
>> It may help your case to provide some technical details of how you'd like to see this implemented, but without overcoming the issues mentioned above I think this proposal will be a very tough sell.
>>
>> > ...this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.
>>
>> I am not sure if I see how this issue is solved by your proposal. Assumedly, a human will still need to manually approve cold-wallet withdrawals in order to maintain security. So it seems to me that removing the 'hot-wallet' component of the backend would only amplify the need for human interaction.
>>
>> I assume you are familiar with hierarchical deterministic wallets? They can allow an exchange to assign/identify user deposits based on address derivation path. Keys for deposit addresses can be kept offline if wanted, and a proper implementation of an HD wallet system should also remove the need for rescans of user deposit addresses.
>>
>> There is also a functionality built into Bitcoin that allows a user to prove that they own the private keys to some address: signing an agreed upon message using the private key that controls that address. Unfortunately I don't think this is a workable solution for you, since the majority of modern wallet software does not include this feature-- but perhaps worth mentioning nonetheless.
>>
>> Best,
>> Alex
>>
>> ??????? Original Message ???????
>> On Tuesday, April 2, 2019 9:53 AM, Nathan Worsley via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> > To whom it may concern,
>> >
>> > I believe a missing feature in Bitcoin is the ability to have an "integrated address", where the address resolves into a Bitcoin address, and also a transaction message or some other kind of identifier.
>> >
>> > By having this feature we could enhance the security of exchange cold-wallet systems, by allowing them to easily receive all payments to a single address from an infinite number of customers. We would also greatly simplify the process of setting up and managing exchange cold-wallet systems, because we would eliminate the "sweeping" step required to move multiple customer deposits from a hot address into a single cold address.
>> >
>> > Although it would be nice to have all customers deposit directly into cold addresses, this quickly becomes impractical when large amounts of customers begin to use exchange wallets as their personal web-wallet, frequently depositing and withdrawing without trading action. You end up needing to have a staff member moving funds away from cold deposit addresses as a full time job - if you wish to handle customer funds in a completely secure manner.
>> >
>> > Thus we see that most exchanges now use the hot-deposit system, where customers deposit into a hot address that is then automatically swept into a singular cold address, by a service which holds customers private keys online. You can observe this service at work simply by making a deposit to most major exchanges (including the largest exchange Binance), as you will see the funds quickly being "swept" to their cold wallet address in a manner which heavily suggests automation by a program which possesses private keys to the address you are sending funds to. This means there is always the danger of a sophisticated hacker being able to capture private keys to customer deposit addresses (as they are clearly being held online). An integrated address would allow all exchanges using this automated hot-deposit service to easily switch to a far more secure alternative of having all customers depositing directly into their singular cold wallet address.
>> >
>> > There are several other more minor advantages such a feature would have, including:
>> > - Lower fees for exchanges (which could be passed onto customers), by reducing a transaction step out of the deposit-to-withdrawal flow.
>> > - Less need for large rescans after loading huge amounts of customer addresses into client software.
>> > - Exchanges can more easily provision deposit addresses to new customers in a secure manner, by simply generating a hex or other value, creating an integrated address from the cold wallet address, and then providing this to the customer.
>> > - By providing a singular cold address for exchanges publicly, customers can more easily verify that no man-in-the-middle has given them an incorrect address to deposit to.
>> >
>> > The integrated address could work by combining the Bitcoin address together with some kind of hex or other value, allowing users to choose the amount they wish to deposit themselves, but ensuring their deposits are uniquely trackable.
>> >
>> > I'm not sure if some kind of functionality already exists in BTC, as I haven't been able to find it. If not, can I submit a proposal to implement this? This feature would be a godsend to all exchange developers if it was widely accepted.
>> >
>> > Thanks for your time.
>> >
>> > Regards,
>> >
>> > Nathan Worsley
>> > CTO - LocalCoinSwap.Com
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/ade34235/attachment-0001.html>
>>
>> ------------------------------
>>
>> Message: 3
>> Date: Tue, 2 Apr 2019 16:43:11 -0400
>> From: "James O'Beirne" <james.obeirne at gmail.com>
>> To: bitcoin-dev at lists.linuxfoundation.org
>> Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
>> Message-ID:
>>         <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Hi,
>>
>> I'd like to discuss assumeutxo, which is an appealing and simple
>> optimization in the spirit of assumevalid[0].
>>
>> # Motivation
>>
>> To start a fully validating bitcoin client from scratch, that client
>> currently
>> needs to perform an initial block download. To the surprise of no one, IBD
>> takes a linear amount time based on the length of the chain's history. For
>> clients running on modest hardware under limited bandwidth constraints,
>> say a mobile device, completing IBD takes a considerable amount of time
>> and thus poses serious usability challenges.
>>
>> As a result, having fully validating clients run on such hardware is rare
>> and
>> basically unrealistic. Clients with even moderate resource constraints
>> are encouraged to rely on the SPV trust model. Though we have promising
>> improvements to existing SPV modes pending deployment[1], it's worth
>> thinking about a mechanism that would allow such clients to use trust
>> models closer to full validation.
>>
>> The subject of this mail is a proposal for a complementary alternative to
>> SPV
>> modes, and which is in the spirit of an existing default, `assumevalid`. It
>> may
>> help modest clients transact under a security model that closely resembles
>> full validation within minutes instead of hours or days.
>>
>> # assumeutxo
>>
>> The basic idea is to allow nodes to initialize using a serialized version
>> of the
>> UTXO set rendered by another node at some predetermined height. The
>> initializing node syncs the headers chain from the network, then obtains and
>> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO set
>> bundled with the block header indicating its "base" and some other
>> metadata).
>>
>> Based upon the snapshot, the node is able to quickly reconstruct its
>> chainstate,
>> and compares a hash of the resulting UTXO set to a preordained hash
>> hard-coded
>> in the software a la assumevalid. This all takes ~23 minutes, not
>> accounting for
>> download of the 3.2GB snapshot[2].
>>
>> The node then syncs to the network tip and afterwards begins a simultaneous
>> background validation (i.e., a conventional IBD) up to the base height of
>> the
>> snapshot in order to achieve full validation. Crucially, even while the
>> background validation is happening the node can validate incoming blocks and
>> transact with the benefit of the full (assumed-valid) UTXO set.
>>
>> Snapshots could be obtained from multiple separate peers in the same manner
>> as
>> block download, but I haven't put much thought into this. In concept it
>> doesn't
>> matter too much where the snapshots come from since their validity is
>> determined via content hash.
>>
>> # Security
>>
>> Obviously there are some security implications due consideration. While this
>> proposal is in the spirit of assumevalid, practical attacks may become
>> easier.
>> Under assumevalid, a user can be tricked into transacting under a false
>> history
>> if an attacker convinces them to start bitcoind with a malicious
>> `-assumevalid`
>> parameter, sybils their node, and then feeds them a bogus chain encompassing
>> all of the hard-coded checkpoints[3].
>>
>> The same attack is made easier in assumeutxo because, unlike in assumevalid,
>> the attacker need not construct a valid PoW chain to get the victim's node
>> into
>> a false state; they simply need to get the user to accept a bad
>> `-assumeutxo`
>> parameter and then supply them an easily made UTXO snapshot containing,
>> say, a
>> false coin assignment.
>>
>> For this reason, I recommend that if we were to implement assumeutxo, we not
>> allow its specification via commandline argument[4].
>>
>> Beyond this risk, I can't think of material differences in security
>> relative to
>> assumevalid, though I appeal to the list for help with this.
>>
>> # More fully validating clients
>>
>> A particularly exciting use-case for assumeutxo is the possibility of mobile
>> devices functioning as fully validating nodes with access to the complete
>> UTXO
>> set (as an alternative to SPV models). The total resource burden needed to
>> start a node
>> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
>> + blocks_to_tip * 4MB) download and a few minutes of processing time, which
>> sounds
>> manageable for many mobile devices currently in use.
>>
>> A mobile user could initialize an assumed-valid bitcoin node within an hour,
>> transact immediately, and complete a pruned full validation of their
>> assumed-valid chain over the next few days, perhaps only doing the
>> background
>> IBD when their device has access to suitable high-bandwidth connections.
>>
>> If we end up implementing an accumulator-based UTXO scaling design[5][6]
>> down
>> the road, it's easy to imagine an analogous process that would allow very
>> fast
>> startup using an accumulator of a few kilobytes in lieu of a multi-GB
>> snapshot.
>>
>> ---
>>
>> I've created a related issue at our Github repository here:
>>   https://github.com/bitcoin/bitcoin/issues/15605
>>
>> and have submitted a draft implementation of snapshot usage via RPC here:
>>   https://github.com/bitcoin/bitcoin/pull/15606
>>
>> I'd like to discuss here whether this is a good fit for Bitcoin
>> conceptually. Concrete
>> plans for deployment steps should be discussed in the Github issue, and
>> after all
>> that my implementation may be reviewed as a sketch of the specific software
>> changes necessary.
>>
>> Regards,
>> James
>>
>>
>> [0]:
>> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
>> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
>> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
>> 2.10GHz
>> [3]:
>> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
>> [4]: Marco Falke is due credit for this point
>> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
>> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190402/46b25dd8/attachment.html>
>>
>> ------------------------------
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>> End of bitcoin-dev Digest, Vol 47, Issue 6
>> ******************************************
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From james.obeirne at gmail.com  Thu Apr  4 14:36:53 2019
From: james.obeirne at gmail.com (James O'Beirne)
Date: Thu, 4 Apr 2019 10:36:53 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CADZtCSi394PPwEJg3bcjLDE7jkuyFoEtcKPos4NQxBM+OJPv_Q@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
	<CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
	<201904040301.01074.luke@dashjr.org>
	<CADZtCSi394PPwEJg3bcjLDE7jkuyFoEtcKPos4NQxBM+OJPv_Q@mail.gmail.com>
Message-ID: <CAPfvXfJz2_rpeN3mYAJg6XuYAPKJV_KM2R7pQm6zNzbX3qp+Kw@mail.gmail.com>

I recommend that anyone following this thread read through the recent IRC
exchange between Greg Maxwell and Luke Dashjr:
 http://www.erisian.com.au/bitcoin-core-dev/log-2019-04-04.html
<http://www.erisian.com.au/bitcoin-core-dev/log-2019-04-04.html>

The conversation starts on line 205 at 2019-04-04T02:54:50.

On Thu, Apr 4, 2019 at 2:38 AM Jim Posen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Learning C++ is something within everyone's capability. Even people who do
>> not
>> wish to learn it can hire someone to perform review for them.
>>
>
> Anyone with enough knowledge of C++ to audit the entire the Bitcoin Core
> codebase is more than capable of running it with assumeutxo disabled and
> checking the hard-coded vale themself.
>
>> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190404/91235d28/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Thu Apr  4 15:03:39 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 04 Apr 2019 15:03:39 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
Message-ID: <1ZxqlU561VPG4XszEcDYhWA28rvF5mjyAkLkG7qDxu-xIXXJ4iyCEl2jdikLHvgJcAOXwkUFNDLqom0zT25pICnuyzt235ODeazLVxuJTYA=@protonmail.com>

Somebody pointed out this to me:

https://gavintech.blogspot.com/2014/06/bit-thereum.html

I have updated the page accordingly.

One thing that seems not mentioned in bit-thereum is the "as long as everybody agrees" escape hatch, i.e. one branch which allows spending to anything (including a transaction that violates the letter of the contract) as long as all participants agree.
This is gives my newer mechanism the ability to "fix" buggy contracts if everybody involved can agree to the terms of a new contract, by simply abandoning the existing contract and spending to the new contract.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, April 4, 2019 9:55 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> https://zmnscpxj.github.io/bitcoin/unchained.html
>
> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain. Often this means creating a new blockchain, or at least a sidechain to an existing blockchain. This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From vitteaymeric at gmail.com  Thu Apr  4 17:18:30 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Thu, 4 Apr 2019 19:18:30 +0200
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
Message-ID: <d1cfa2e9-69e4-ee02-4c10-23b2b1a30e00@gmail.com>

What if the smart contract platform(s) disappear?

The proposal induces a very centralized system, to my knowledge all of 
existing sidechains whether on bitcoin or ethereum are centralized, 
except lightning (if we forget that someone must watch what others are 
doing when you are on a trek in Nepal)

Now I don't get why a sidechain should be a blockchain on top on another 
one (given also that we can't consider bitcoin or ethereum as 
decentralized today, so the path might be long for the sidechains...), 
the latest is used to store the final state, the former does not have to 
store forever the intermediate states, then it could just use a 
decentralized system (not necessarilly blockchain-like) to store the 
intermediate states and maybe be a distributed escrow

I know, easy to say, please do it (why not), now the fact that 
sidechains claim to be decentralized or that they will be is just 
misleading people (that's not the case of your proposal but it does not 
say what happens if the platforms go down)


Le 04/04/2019 ? 03:55, ZmnSCPxj via bitcoin-dev a ?crit :
> https://zmnscpxj.github.io/bitcoin/unchained.html
>
> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.  Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.  This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Peersm : http://www.peersm.com
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From ZmnSCPxj at protonmail.com  Thu Apr  4 23:52:20 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 04 Apr 2019 23:52:20 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <d1cfa2e9-69e4-ee02-4c10-23b2b1a30e00@gmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
	<d1cfa2e9-69e4-ee02-4c10-23b2b1a30e00@gmail.com>
Message-ID: <TF9WSGU6njZqgOyJF5-m1gYMwfgUCStjUV-IpRuX67w1Z6jL2Tdarr6PCOUO1vFb9hz_jWnbe_5Tg8E_a9iyPeXIY_iJUf9YN8u9xB4SC90=@protonmail.com>

Good morning Aymeric,


> What if the smart contract platform(s) disappear?
>

It is still possible to recover the funds, *if* you can convince all participants of some "fair" distribution of the funds.
You do this by all participants simply signing with their participant keys and taking the first branch of the script.
This branch does not require the participation of the smart contract platform, at all.
If all participants can agree to the result of the smart contract without dispute, then they can exit the platform even after the platform disappears.

Now of course there will be participants who will not cooperate in such a case, for example if they were doing some betting game and "lost".
But at least it gives the possibility of doing so, and it will not be as massive a loss.

Indeed, if the smart contract platform code is open source, it may be possible to set up another implementation of the smart contract platform.
And it would be possible to at least try to convince all participants to switch to that new platform (again, via the "as long as everybody agrees" escape hatch).
Again, this is not possible with current federated sidechains, or Ethereum (if Ethereum fails, all ETH becomes valueless).

> The proposal induces a very centralized system, to my knowledge all of
> existing sidechains whether on bitcoin or ethereum are centralized,
> except lightning (if we forget that someone must watch what others are
> doing when you are on a trek in Nepal)

I would not lump together Lightning with sidechains.
Indeed, this design moves things closer to true offchain techniques (as in Lightning) than to sidechain techniques.

So while centralized, it is less centralized than a federated sidechains.

> Now I don't get why a sidechain should be a blockchain on top on another
> one (given also that we can't consider bitcoin or ethereum as
> decentralized today, so the path might be long for the sidechains...),
> the latest is used to store the final state, the former does not have to
> store forever the intermediate states, then it could just use a
> decentralized system (not necessarilly blockchain-like) to store the
> intermediate states and maybe be a distributed escrow
>
> I know, easy to say, please do it (why not), now the fact that
> sidechains claim to be decentralized or that they will be is just
> misleading people (that's not the case of your proposal but it does not
> say what happens if the platforms go down)

Perhaps it can be a next step.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Fri Apr  5 06:00:20 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 05 Apr 2019 06:00:20 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
Message-ID: <c_M0c1ruLr2vU6M81IVT-Hv6P4s8tPWnShu4BIecDfIuQObXrLpN6hiPFaTdmX0fWCYLByF1SzYnaPiekHqkNOb8TVqGxIgMVPaZFqFAtro=@protonmail.com>

Building from this ---

It is possible via this mechanism for the federation to be selected by the participants, rather than the federation being defined as a fixed set by the smart contract platform.

Perhaps anyone can advertise themselves (by e.g. locking some bonded amount on the blockchain with a `OP_CHECKSEQUENCEVERIFY`) as being willing to act as trusted executors of smart contracts.

Participants then select such executors they believe to be trustworthy, and what voting quorum of the selected executors is sufficient to convince the participants of the correct execution of the smart contract.

Of course, more choices, more cognitive effort for you mere humans, so probably not a good idea in general.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, April 4, 2019 9:55 AM, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> https://zmnscpxj.github.io/bitcoin/unchained.html
>
> Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain. Often this means creating a new blockchain, or at least a sidechain to an existing blockchain. This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From vitteaymeric at gmail.com  Fri Apr  5 17:46:35 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 5 Apr 2019 19:46:35 +0200
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <TF9WSGU6njZqgOyJF5-m1gYMwfgUCStjUV-IpRuX67w1Z6jL2Tdarr6PCOUO1vFb9hz_jWnbe_5Tg8E_a9iyPeXIY_iJUf9YN8u9xB4SC90=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
	<d1cfa2e9-69e4-ee02-4c10-23b2b1a30e00@gmail.com>
	<TF9WSGU6njZqgOyJF5-m1gYMwfgUCStjUV-IpRuX67w1Z6jL2Tdarr6PCOUO1vFb9hz_jWnbe_5Tg8E_a9iyPeXIY_iJUf9YN8u9xB4SC90=@protonmail.com>
Message-ID: <392367fe-b1d7-7d47-01de-ebb4b7142ead@gmail.com>

Hi,

Apparently you are not a fan of ethereum, as far as I can tell ethereum 
sidechains look like a mess with stupid tokens/transactions flooding the 
network while they are completely centralized, but some bitcoin 
sidechains can easily compete with this too, like Tether, don't even 
understand how anyone can give some credit to that stuff the way it is 
implemented, and if bitcoin fails that would be the same as for ethereum

Most likely everyone would agree if the escrow disappears, but not sure 
at all, let's imagine 1 to N put 10K on the table for a game, they 
update the states and at the end N wins everything, N is rich and don't 
care finally if the others cheaters have their coins locked (and to lose 
10K), same with setting up a new escrow to resolve the conflict

I think that you should highlight this (and what private key corresponds 
to E + h(E | s) * G, not sure it's trivial for everybody), probably a 
way to get this more decentralized is to reward the escrows (what is the 
interest here for people to run a smart contract platform?)

For lightning, maybe it's a question of wording, I consider it as a 
sidechain AND methods that can be used by other sidechains, as well as 
the others you quoted, even if only two people in the world use 
lightning, it is still decentralized, because it sustains itself alone

Regards

Aymeric

Le 05/04/2019 ? 01:52, ZmnSCPxj a ?crit :
> Good morning Aymeric,
>
>
>> What if the smart contract platform(s) disappear?
>>
> It is still possible to recover the funds, *if* you can convince all participants of some "fair" distribution of the funds.
> You do this by all participants simply signing with their participant keys and taking the first branch of the script.
> This branch does not require the participation of the smart contract platform, at all.
> If all participants can agree to the result of the smart contract without dispute, then they can exit the platform even after the platform disappears.
>
> Now of course there will be participants who will not cooperate in such a case, for example if they were doing some betting game and "lost".
> But at least it gives the possibility of doing so, and it will not be as massive a loss.
>
> Indeed, if the smart contract platform code is open source, it may be possible to set up another implementation of the smart contract platform.
> And it would be possible to at least try to convince all participants to switch to that new platform (again, via the "as long as everybody agrees" escape hatch).
> Again, this is not possible with current federated sidechains, or Ethereum (if Ethereum fails, all ETH becomes valueless).
>
>> The proposal induces a very centralized system, to my knowledge all of
>> existing sidechains whether on bitcoin or ethereum are centralized,
>> except lightning (if we forget that someone must watch what others are
>> doing when you are on a trek in Nepal)
> I would not lump together Lightning with sidechains.
> Indeed, this design moves things closer to true offchain techniques (as in Lightning) than to sidechain techniques.
>
> So while centralized, it is less centralized than a federated sidechains.
>
>> Now I don't get why a sidechain should be a blockchain on top on another
>> one (given also that we can't consider bitcoin or ethereum as
>> decentralized today, so the path might be long for the sidechains...),
>> the latest is used to store the final state, the former does not have to
>> store forever the intermediate states, then it could just use a
>> decentralized system (not necessarilly blockchain-like) to store the
>> intermediate states and maybe be a distributed escrow
>>
>> I know, easy to say, please do it (why not), now the fact that
>> sidechains claim to be decentralized or that they will be is just
>> misleading people (that's not the case of your proposal but it does not
>> say what happens if the platforms go down)
> Perhaps it can be a next step.
>
> Regards,
> ZmnSCPxj


From random at gmx.ch  Sun Apr  7 08:50:46 2019
From: random at gmx.ch (simondev1)
Date: Sun, 7 Apr 2019 10:50:46 +0200
Subject: [bitcoin-dev] new BIP: Self balancing between excessively low/high
 fees and block size
Message-ID: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>

An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190407/67671d75/attachment.html>

From natanael.l at gmail.com  Sun Apr  7 18:52:30 2019
From: natanael.l at gmail.com (Natanael)
Date: Sun, 7 Apr 2019 20:52:30 +0200
Subject: [bitcoin-dev] new BIP: Self balancing between excessively
 low/high fees and block size
In-Reply-To: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
References: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
Message-ID: <CAAt2M1-0GD0hHVhZc+3bfefCMEOH-a2PoU-ULi8iWnLQUds6ng@mail.gmail.com>

Related ideas previously submitted by me;

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-March/013885.html

Title: Block size adjustment idea - expedience fees + difficulty scaling
proportional to block size (+ fee pool)

Den s?n 7 apr. 2019 17:45simondev1 via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> skrev:

> Dear bitcoin developers,
>
> New BIP: https://github.com/bitcoin/bips/pull/774
>
> ==Abstract==
> Logarithm of transaction fee limits block size.
>
> ==Motivation==
> Keep block space small.
> Waste less with spam transactions.
> Auto balance Fees: Increase very low fees, Descrease very high fees.
> Allow larger size when sender pays a lot.
> Allow wallets to calculate/display how much average free block space there
> is for each fee price.
> Allow senders to have more control about how the fee/priority of their
> transaction will behave, especially in the case of increased adoption in
> the future.
>
> ==Specification==
> Every transaction has to fit into the following block space:
> Input variable 'FeeInSatoshiPerByte': Must be positive or 0
> type: double
> unit: Satishi per byte
> Output:
> type: uint
> unit: bytes
> Formula:
> floor( log10( 1.1 + FeeInSatoshiPerByte ) * 1024 * 1024 )
>
> ==Implementation==
> Sort transactions by FeeInSatoshiPerByte (lowest first)
> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the
> bytes of space used so far. Check if summed up bytes of space used so far
> is smaller or equal than the formula result.
> If this is valid for each transaction then the blocksize is valid.
>
> ==Backward compatibility==
> Soft fork: If applied AND old hardcoded block size limit is kept.
> Hard fork: If applied AND old hardcoded block size limit is removed.
>
> Regards, simondev1
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190407/0f09ef59/attachment.html>

From bitcoin at bpj-code.co.za  Sun Apr  7 22:11:55 2019
From: bitcoin at bpj-code.co.za (Bernd Jendrissek)
Date: Mon, 8 Apr 2019 00:11:55 +0200
Subject: [bitcoin-dev] new BIP: Self balancing between excessively
 low/high fees and block size
In-Reply-To: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
References: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
Message-ID: <CAF7PVPrXg2nefBkPH6E1Qz8hvL8JVSn-mCRCK60TtY1NjA-z3w@mail.gmail.com>

On Sun, 7 Apr 2019 at 17:45, simondev1 via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> ==Implementation==
> Sort transactions by FeeInSatoshiPerByte (lowest first)
> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the bytes of space used so far. Check if summed up bytes of space used so far is smaller or equal than the formula result.
> If this is valid for each transaction then the blocksize is valid.

Doesn't this break CPFP? I think to avoid that you'll need to rework
your proposed algorithm to treat chains of transactions as a group.
(And note that you could have multiple transactions in one block that
depend on the same "parent" transaction, also in the same block.)

From ZmnSCPxj at protonmail.com  Mon Apr  8 00:55:18 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 08 Apr 2019 00:55:18 +0000
Subject: [bitcoin-dev] new BIP: Self balancing between excessively
	low/high fees and block size
In-Reply-To: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
References: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
Message-ID: <j9Yc7SPFXCH_C3wUJs5oZwwdEWQnnfcfJ_DW_DJCCH1QYCr4N9ABx3-IG9mMxKAFKHmaWE_K_XIT5hwK8aV8pGpuVYZr13sl5KQSO88vPgk=@protonmail.com>

Good morning simondev1,

It seems the algorithm would greatly increase validation time.
In particular, if the current limit is removed (as in hardforked proposal) then a 1Tb block can be used to attack the network, since sorting would require looking through the entire block.
Thus, validation time would still limit the practical block sizes that can be deployed with this.

Regards,
ZmnSCPxj

Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Sunday, April 7, 2019 4:50 PM, simondev1 via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Dear bitcoin developers,
> ?
> New BIP: https://github.com/bitcoin/bips/pull/774
> ?
> ==Abstract==
> Logarithm of transaction fee limits block size.
> ?
> ==Motivation==
> Keep block space small.
> Waste less with spam transactions.
> Auto balance Fees: Increase very low fees, Descrease very high fees.
> Allow larger size when sender pays a lot.
> Allow wallets to calculate/display how much average free block space there is for each fee price.
> Allow senders to have more control about how the fee/priority of their transaction will behave, especially in the case of increased adoption in the future.
> ?
> ==Specification==
> Every transaction has to fit into the following block space:
> Input variable 'FeeInSatoshiPerByte': Must be positive or 0
> type: double
> unit: Satishi per byte
> Output:
> type: uint
> unit: bytes
> Formula:
> floor( log10( 1.1 + FeeInSatoshiPerByte ) * 1024 * 1024 )
> ?
> ==Implementation==
> Sort transactions by FeeInSatoshiPerByte (lowest first)
> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the bytes of space used so far. Check if summed up bytes of space used so far is smaller or equal than the formula result.
> If this is valid for each transaction then the blocksize is valid.
> ?
> ==Backward compatibility==
> Soft fork: If applied AND old hardcoded block size limit is kept.
> Hard fork: If applied AND old hardcoded block size limit is removed.
>
> Regards, simondev1
>



From ZmnSCPxj at protonmail.com  Mon Apr  8 10:45:29 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 08 Apr 2019 10:45:29 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <392367fe-b1d7-7d47-01de-ebb4b7142ead@gmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
	<d1cfa2e9-69e4-ee02-4c10-23b2b1a30e00@gmail.com>
	<TF9WSGU6njZqgOyJF5-m1gYMwfgUCStjUV-IpRuX67w1Z6jL2Tdarr6PCOUO1vFb9hz_jWnbe_5Tg8E_a9iyPeXIY_iJUf9YN8u9xB4SC90=@protonmail.com>
	<392367fe-b1d7-7d47-01de-ebb4b7142ead@gmail.com>
Message-ID: <GkSgHQYXGen75-KP_N2VbK1EmY5DSDe0sncJBU77l6_2xdYhh9Yw5rQSgtPuwXJnMlnA0j195hkMfhnxhGkMERa3kXXW6KvR5qt88oSNGvY=@protonmail.com>

Good morning Aymeric,

> Hi,
>
> Apparently you are not a fan of ethereum, as far as I can tell ethereum
> sidechains look like a mess with stupid tokens/transactions flooding the
> network while they are completely centralized, but some bitcoin
> sidechains can easily compete with this too, like Tether, don't even
> understand how anyone can give some credit to that stuff the way it is
> implemented, and if bitcoin fails that would be the same as for ethereum

I prefer to be more precise in my terminology.
Colored coins are not the same as sidechains, and there are colored coins and then there are colored coins.
This mechanism does not propose some change in colored coins.
An important aspect of colored coins is that one can foist them on somebody else to extract things of real value from them, but this mechanism is more strongly for a fixed set of participants.

I strongly suspect that Bitcoin will outlast Ethereum, but that is rather not very related to this topic.

> Most likely everyone would agree if the escrow disappears, but not sure
> at all, let's imagine 1 to N put 10K on the table for a game, they
> update the states and at the end N wins everything, N is rich and don't
> care finally if the others cheaters have their coins locked (and to lose
> 10K), same with setting up a new escrow to resolve the conflict
>

Indeed.
Still, the option to do so exists, and sometimes all that is needed for humans to do the right thing, is to be given the option to do so.

> I think that you should highlight this (and what private key corresponds
> to E + h(E | s) * G, not sure it's trivial for everybody), probably a
> way to get this more decentralized is to reward the escrows (what is the
> interest here for people to run a smart contract platform?)

I assumed both were obvious, but I suppose a few more words about those would not be amiss.

>
> For lightning, maybe it's a question of wording, I consider it as a
> sidechain AND methods that can be used by other sidechains, as well as
> the others you quoted, even if only two people in the world use
> lightning, it is still decentralized, because it sustains itself alone

Again, I prefer precision in my terminology.
For me, a sidechain is a blockchain of some sort.
In particular, a kind of Merklized singly-linked list containing representations of transformations of state, is how I define blockchain to be.

No such Merklized singly-linked list exists in Lightning Network, thus I do not consider it, "blockchain".
And thus I do not consider it "sidechain", as a sidechain is a blockchain.
Current LN does use "shachains" by Rusty, but shachains are not Merklized singly-linked lists, but are instead a kind of inverse mountain range structure.

Still, one might consider both federated sidechains and Lightning Network to have a "federated" offchain structure.
This is because the coins on the Bitcoin blockchain are locked to a multisignature and activity is not recorded on the Bitcoin blockchain.
However, in LN, each channel is a 2-member federation (you and a counterparty) and the mechanism in LN requires consensus (2-of-2) rather than a quorum (m-of-n).
This greatly increases the security of LN: the owner of funding on an LN channel can always refuse to sign an update if the other member of the federation is taken over.
Compare this to the quorum that typical federations have, where takeover of a sufficient quorum is enough to steal funds from the remaining federation.
https://zmnscpxj.github.io/offchain/safety.html

Regards,
ZmnSCPxj

From vitteaymeric at gmail.com  Mon Apr  8 16:28:27 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Mon, 8 Apr 2019 18:28:27 +0200
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <GkSgHQYXGen75-KP_N2VbK1EmY5DSDe0sncJBU77l6_2xdYhh9Yw5rQSgtPuwXJnMlnA0j195hkMfhnxhGkMERa3kXXW6KvR5qt88oSNGvY=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
	<d1cfa2e9-69e4-ee02-4c10-23b2b1a30e00@gmail.com>
	<TF9WSGU6njZqgOyJF5-m1gYMwfgUCStjUV-IpRuX67w1Z6jL2Tdarr6PCOUO1vFb9hz_jWnbe_5Tg8E_a9iyPeXIY_iJUf9YN8u9xB4SC90=@protonmail.com>
	<392367fe-b1d7-7d47-01de-ebb4b7142ead@gmail.com>
	<GkSgHQYXGen75-KP_N2VbK1EmY5DSDe0sncJBU77l6_2xdYhh9Yw5rQSgtPuwXJnMlnA0j195hkMfhnxhGkMERa3kXXW6KvR5qt88oSNGvY=@protonmail.com>
Message-ID: <99bab1a0-ac84-7064-08fe-5836f5b2caab@gmail.com>

Hi,

I took the example of colored coins because you quoted ethereum and like
most of ethereum tokens most of them reflect something coming from
nowhere, worse I can send you 10K Tethers if you like that of course
will not be validated by the central system but will be recorded in
bitcoin blockchain

Bitcoin oulasting ethereum, maybe, but the bitcoin community must make
more efforts to explain things, like "both were obvious" below is not in
fact for an usual reader, so a few more words would be good indeed

For me a sidechain does not have to be a blockchain but a decentralized
system allowing to secure off chain transactions until the final state
is stored into the blockchain, I don't see the use of storing forever
the intermediate states neither why the sidechain should be a
blockchain, if not then the sidechain would just be another
bitcoin/ethereum, no? What would be the purpose of building a blockchain
on top of another one? Just do your own, and this would eliminate the
drawback of needing to have bitcoins or ethers to smart contract things
that have nothing to do with them, as well as mixing addresses between
the blockchain and the sidechains

Regards

Aymeric

Le 08/04/2019 ? 12:45, ZmnSCPxj a ?crit?:
> Good morning Aymeric,
>
>> Hi,
>>
>> Apparently you are not a fan of ethereum, as far as I can tell ethereum
>> sidechains look like a mess with stupid tokens/transactions flooding the
>> network while they are completely centralized, but some bitcoin
>> sidechains can easily compete with this too, like Tether, don't even
>> understand how anyone can give some credit to that stuff the way it is
>> implemented, and if bitcoin fails that would be the same as for ethereum
> I prefer to be more precise in my terminology.
> Colored coins are not the same as sidechains, and there are colored coins and then there are colored coins.
> This mechanism does not propose some change in colored coins.
> An important aspect of colored coins is that one can foist them on somebody else to extract things of real value from them, but this mechanism is more strongly for a fixed set of participants.
>
> I strongly suspect that Bitcoin will outlast Ethereum, but that is rather not very related to this topic.
>
>> Most likely everyone would agree if the escrow disappears, but not sure
>> at all, let's imagine 1 to N put 10K on the table for a game, they
>> update the states and at the end N wins everything, N is rich and don't
>> care finally if the others cheaters have their coins locked (and to lose
>> 10K), same with setting up a new escrow to resolve the conflict
>>
> Indeed.
> Still, the option to do so exists, and sometimes all that is needed for humans to do the right thing, is to be given the option to do so.
>
>> I think that you should highlight this (and what private key corresponds
>> to E + h(E | s) * G, not sure it's trivial for everybody), probably a
>> way to get this more decentralized is to reward the escrows (what is the
>> interest here for people to run a smart contract platform?)
> I assumed both were obvious, but I suppose a few more words about those would not be amiss.
>
>> For lightning, maybe it's a question of wording, I consider it as a
>> sidechain AND methods that can be used by other sidechains, as well as
>> the others you quoted, even if only two people in the world use
>> lightning, it is still decentralized, because it sustains itself alone
> Again, I prefer precision in my terminology.
> For me, a sidechain is a blockchain of some sort.
> In particular, a kind of Merklized singly-linked list containing representations of transformations of state, is how I define blockchain to be.
>
> No such Merklized singly-linked list exists in Lightning Network, thus I do not consider it, "blockchain".
> And thus I do not consider it "sidechain", as a sidechain is a blockchain.
> Current LN does use "shachains" by Rusty, but shachains are not Merklized singly-linked lists, but are instead a kind of inverse mountain range structure.
>
> Still, one might consider both federated sidechains and Lightning Network to have a "federated" offchain structure.
> This is because the coins on the Bitcoin blockchain are locked to a multisignature and activity is not recorded on the Bitcoin blockchain.
> However, in LN, each channel is a 2-member federation (you and a counterparty) and the mechanism in LN requires consensus (2-of-2) rather than a quorum (m-of-n).
> This greatly increases the security of LN: the owner of funding on an LN channel can always refuse to sign an update if the other member of the federation is taken over.
> Compare this to the quorum that typical federations have, where takeover of a sufficient quorum is enough to steal funds from the remaining federation.
> https://zmnscpxj.github.io/offchain/safety.html
>
> Regards,
> ZmnSCPxj


From omarshib at gmail.com  Tue Apr  9 00:13:21 2019
From: omarshib at gmail.com (Omar Shibli)
Date: Tue, 9 Apr 2019 03:13:21 +0300
Subject: [bitcoin-dev] new BIP: Self balancing between excessively
 low/high fees and block size
In-Reply-To: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
References: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
Message-ID: <CAE3EOfixRro2BpTLmjOd60e-wBA8ZkTUXYZgdjaYWmJ-cec7PQ@mail.gmail.com>

 Mining strategy is like HFT profitable strategy, you keep it close if it?s
interesting, and you talk about it with the whole world if it?s void. gl.

On Sun, Apr 7, 2019 at 6:45 PM simondev1 via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Dear bitcoin developers,
>
> New BIP: https://github.com/bitcoin/bips/pull/774
>
> ==Abstract==
> Logarithm of transaction fee limits block size.
>
> ==Motivation==
> Keep block space small.
> Waste less with spam transactions.
> Auto balance Fees: Increase very low fees, Descrease very high fees.
> Allow larger size when sender pays a lot.
> Allow wallets to calculate/display how much average free block space there
> is for each fee price.
> Allow senders to have more control about how the fee/priority of their
> transaction will behave, especially in the case of increased adoption in
> the future.
>
> ==Specification==
> Every transaction has to fit into the following block space:
> Input variable 'FeeInSatoshiPerByte': Must be positive or 0
> type: double
> unit: Satishi per byte
> Output:
> type: uint
> unit: bytes
> Formula:
> floor( log10( 1.1 + FeeInSatoshiPerByte ) * 1024 * 1024 )
>
> ==Implementation==
> Sort transactions by FeeInSatoshiPerByte (lowest first)
> For each transaction starting from lowest FeeInSatoshiPerByte: Sum up the
> bytes of space used so far. Check if summed up bytes of space used so far
> is smaller or equal than the formula result.
> If this is valid for each transaction then the blocksize is valid.
>
> ==Backward compatibility==
> Soft fork: If applied AND old hardcoded block size limit is kept.
> Hard fork: If applied AND old hardcoded block size limit is removed.
>
> Regards, simondev1
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/8753e479/attachment.html>

From vitteaymeric at gmail.com  Tue Apr  9 09:46:37 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 9 Apr 2019 11:46:37 +0200
Subject: [bitcoin-dev] License for BIP39 word lists
In-Reply-To: <CAF90AvnKXZta0S+Pxe6t9mGmf9vsm_Y_ZjF1PaAygUaCk+fM0A@mail.gmail.com>
References: <iKDdEbi-0Ihe0gNPYsIN_nkg2X8t9FK7RRUoTb6fz9rF4mRReXjpKDjIOsZkpGYKG1UXtCHdMdKzXNgk2iihosaWg-8HqYIa9JDoGdJv9Kw=@dl1ye.com>
	<pgnG4aynAMLF_fvTKASzXWqV9OMAQFghcNTGmwRA9Dvo6JKD6vN7kcfyMNyIgXz-ONUWYq5AjA8G1fUVqPrMbeWiXicnkczqDlerjSiDZB8=@dl1ye.com>
	<hiMtqbeiSVlUZNbhq34FyJT9uJ-LyDNBsdX1IjK94ZCeTl6mvQaeGYrr9Vu_f3-H0fFLoTsBiJRiG1aVoV1n__nSSWDjjN1ZpwjxbaoUTmc=@dl1ye.com>
	<CAF90AvnKXZta0S+Pxe6t9mGmf9vsm_Y_ZjF1PaAygUaCk+fM0A@mail.gmail.com>
Message-ID: <1a411898-75e6-89bb-96d0-f705690836f1@gmail.com>

Is it final now and live in Trezor? Do you know who else will adopt it?

Regards

Aymeric

Le 03/04/2019 ? 11:19, Pavol Rusnak via bitcoin-dev a ?crit?:
> I am the author of the wordlist. Feel free to use it without any
> restrictions.
>
> However, we are finalizing SLIP39 standard for splitting shares which
> uses a different wordlist with better properties. It might be more
> suitable for your project.
>
> See?https://github.com/satoshilabs/slips/blob/master/slip-0039.md
> and?https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt
>
>
>
> On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     I would like to use the BIP39 word lists posted in the Github BIP repo
>     for my own project.
>
>
>     Unfortunately there is no license associated with the lists
>     provided on
>     Github so I am not sure whether usage for other projects is
>     permitted. I
>     am not able to file issues on the repo either to suggest adding a
>     license.
>
>     Does anybody know under which license these lists are published?
>
>
>     Best regards,
>
>     Elia
>
>
>
>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/4236b446/attachment-0001.html>

From stick at satoshilabs.com  Tue Apr  9 09:49:53 2019
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Tue, 9 Apr 2019 11:49:53 +0200
Subject: [bitcoin-dev] License for BIP39 word lists
In-Reply-To: <1a411898-75e6-89bb-96d0-f705690836f1@gmail.com>
References: <iKDdEbi-0Ihe0gNPYsIN_nkg2X8t9FK7RRUoTb6fz9rF4mRReXjpKDjIOsZkpGYKG1UXtCHdMdKzXNgk2iihosaWg-8HqYIa9JDoGdJv9Kw=@dl1ye.com>
	<pgnG4aynAMLF_fvTKASzXWqV9OMAQFghcNTGmwRA9Dvo6JKD6vN7kcfyMNyIgXz-ONUWYq5AjA8G1fUVqPrMbeWiXicnkczqDlerjSiDZB8=@dl1ye.com>
	<hiMtqbeiSVlUZNbhq34FyJT9uJ-LyDNBsdX1IjK94ZCeTl6mvQaeGYrr9Vu_f3-H0fFLoTsBiJRiG1aVoV1n__nSSWDjjN1ZpwjxbaoUTmc=@dl1ye.com>
	<CAF90AvnKXZta0S+Pxe6t9mGmf9vsm_Y_ZjF1PaAygUaCk+fM0A@mail.gmail.com>
	<1a411898-75e6-89bb-96d0-f705690836f1@gmail.com>
Message-ID: <CAF90Avk1EdXTgCXx7xZHEekd8n=3EbR+L-bHsRRkj+-ZZbhODg@mail.gmail.com>

We are in process of finalizing it, so it is not live in Trezor yet. It
will be soon, though. I suppose every wallet that uses BIP39 will adopt
this one as well.

On Tue, Apr 9, 2019, 11:46 Aymeric Vitte <vitteaymeric at gmail.com> wrote:

> Is it final now and live in Trezor? Do you know who else will adopt it?
>
> Regards
>
> Aymeric
> Le 03/04/2019 ? 11:19, Pavol Rusnak via bitcoin-dev a ?crit :
>
> I am the author of the wordlist. Feel free to use it without any
> restrictions.
>
> However, we are finalizing SLIP39 standard for splitting shares which uses
> a different wordlist with better properties. It might be more suitable for
> your project.
>
> See https://github.com/satoshilabs/slips/blob/master/slip-0039.md and
> https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt
>
>
>
> On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I would like to use the BIP39 word lists posted in the Github BIP repo
>> for my own project.
>>
>>
>> Unfortunately there is no license associated with the lists provided on
>> Github so I am not sure whether usage for other projects is permitted. I
>> am not able to file issues on the repo either to suggest adding a license.
>>
>> Does anybody know under which license these lists are published?
>>
>>
>> Best regards,
>>
>> Elia
>>
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
> _______________________________________________
> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> --
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/45c69dcd/attachment-0001.html>

From vitteaymeric at gmail.com  Tue Apr  9 16:19:40 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 9 Apr 2019 18:19:40 +0200
Subject: [bitcoin-dev] License for BIP39 word lists
In-Reply-To: <CAF90Avk1EdXTgCXx7xZHEekd8n=3EbR+L-bHsRRkj+-ZZbhODg@mail.gmail.com>
References: <iKDdEbi-0Ihe0gNPYsIN_nkg2X8t9FK7RRUoTb6fz9rF4mRReXjpKDjIOsZkpGYKG1UXtCHdMdKzXNgk2iihosaWg-8HqYIa9JDoGdJv9Kw=@dl1ye.com>
	<pgnG4aynAMLF_fvTKASzXWqV9OMAQFghcNTGmwRA9Dvo6JKD6vN7kcfyMNyIgXz-ONUWYq5AjA8G1fUVqPrMbeWiXicnkczqDlerjSiDZB8=@dl1ye.com>
	<hiMtqbeiSVlUZNbhq34FyJT9uJ-LyDNBsdX1IjK94ZCeTl6mvQaeGYrr9Vu_f3-H0fFLoTsBiJRiG1aVoV1n__nSSWDjjN1ZpwjxbaoUTmc=@dl1ye.com>
	<CAF90AvnKXZta0S+Pxe6t9mGmf9vsm_Y_ZjF1PaAygUaCk+fM0A@mail.gmail.com>
	<1a411898-75e6-89bb-96d0-f705690836f1@gmail.com>
	<CAF90Avk1EdXTgCXx7xZHEekd8n=3EbR+L-bHsRRkj+-ZZbhODg@mail.gmail.com>
Message-ID: <788850e2-f361-4f06-43b4-0a21050de0d2@gmail.com>

What is not final finally and when do you expect it to be?

Le 09/04/2019 ? 11:49, Pavol Rusnak a ?crit?:
> We are in process of finalizing it, so it is not live in Trezor yet.
> It will be soon, though. I suppose every wallet that uses BIP39 will
> adopt this one as well.
>
> On Tue, Apr 9, 2019, 11:46 Aymeric Vitte <vitteaymeric at gmail.com
> <mailto:vitteaymeric at gmail.com>> wrote:
>
>     Is it final now and live in Trezor? Do you know who else will
>     adopt it?
>
>     Regards
>
>     Aymeric
>
>     Le 03/04/2019 ? 11:19, Pavol Rusnak via bitcoin-dev a ?crit?:
>>     I am the author of the wordlist. Feel free to use it without any
>>     restrictions.
>>
>>     However, we are finalizing SLIP39 standard for splitting shares
>>     which uses a different wordlist with better properties. It might
>>     be more suitable for your project.
>>
>>     See?https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>>     and?https://github.com/satoshilabs/slips/blob/master/slip-0039/wordlist.txt
>>
>>
>>
>>     On Wed, Apr 3, 2019, 09:32 Elia via bitcoin-dev
>>     <bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>         I would like to use the BIP39 word lists posted in the Github
>>         BIP repo
>>         for my own project.
>>
>>
>>         Unfortunately there is no license associated with the lists
>>         provided on
>>         Github so I am not sure whether usage for other projects is
>>         permitted. I
>>         am not able to file issues on the repo either to suggest
>>         adding a license.
>>
>>         Does anybody know under which license these lists are published?
>>
>>
>>         Best regards,
>>
>>         Elia
>>
>>
>>
>>
>>
>>         _______________________________________________
>>         bitcoin-dev mailing list
>>         bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190409/2089a69e/attachment-0001.html>

From pete at petertodd.org  Sat Apr 13 19:09:25 2019
From: pete at petertodd.org (Peter Todd)
Date: Sat, 13 Apr 2019 15:09:25 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
	<CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
Message-ID: <20190413190925.peux7djbopy5xu3t@petertodd.org>

On Wed, Apr 03, 2019 at 02:39:32PM -0700, Dave Scotese via bitcoin-dev wrote:
> Every block's hash is smaller than the difficulty at that time.  Block
> 569927's hash was VERY small (started with 21 zeros).  The ratio of block
> hash to difficulty requirement (0xffffffff - difficulty, I think) could be
> used to identify blocks as "special," thus providing the opportunity to
> popularize unimportant but memorable-and-therefore-useful details.  How can
> they be useful if they are unimportant?  They are useful for sanity
> checking.  For example, if the drunken bishop walk (or some other popular
> randomart) produced by block 569927's hash looked like a face, that would
> be memorable: "The block with the smallest hash in 2019 (maybe ever?) looks
> like a face after the drunken bishop walk."

As hashest smaller than the target have no significance to the Bitcoin
consensus I'd suggest not basing any features on that property. It's just as
arbitrary as picking whole decimal number block heights, yet has the additional
downsides of being harder to compute, and being likely to confuse people as to
how the Bitcoin consensus works.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190413/3b7d1bdd/attachment.sig>

From random at gmx.ch  Fri Apr 12 15:45:25 2019
From: random at gmx.ch (simondev1)
Date: Fri, 12 Apr 2019 17:45:25 +0200
Subject: [bitcoin-dev] new BIP: Self balancing between excessively
 low/high fees and block size
In-Reply-To: <CAF7PVPrXg2nefBkPH6E1Qz8hvL8JVSn-mCRCK60TtY1NjA-z3w@mail.gmail.com>
References: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
	<CAF7PVPrXg2nefBkPH6E1Qz8hvL8JVSn-mCRCK60TtY1NjA-z3w@mail.gmail.com>
Message-ID: <trinity-20a3d4d6-ff4a-488f-9288-d10c0388887a-1555083925577@3c-app-gmx-bs77>

An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190412/58213037/attachment.html>

From random at gmx.ch  Fri Apr 12 15:49:57 2019
From: random at gmx.ch (simondev1)
Date: Fri, 12 Apr 2019 17:49:57 +0200
Subject: [bitcoin-dev] new BIP: Self balancing between excessively
 low/high fees and block size
In-Reply-To: <j9Yc7SPFXCH_C3wUJs5oZwwdEWQnnfcfJ_DW_DJCCH1QYCr4N9ABx3-IG9mMxKAFKHmaWE_K_XIT5hwK8aV8pGpuVYZr13sl5KQSO88vPgk=@protonmail.com>
References: <trinity-9a1b0170-a250-4c06-a8e1-0f281499c4da-1554627046019@3c-app-gmx-bs53>
	<j9Yc7SPFXCH_C3wUJs5oZwwdEWQnnfcfJ_DW_DJCCH1QYCr4N9ABx3-IG9mMxKAFKHmaWE_K_XIT5hwK8aV8pGpuVYZr13sl5KQSO88vPgk=@protonmail.com>
Message-ID: <trinity-35c2289f-6ff5-43ee-ab71-3c0f1471284c-1555084197918@3c-app-gmx-bs77>

An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190412/1b9efcaf/attachment.html>

From willtech at live.com.au  Sun Apr 14 14:44:53 2019
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Sun, 14 Apr 2019 14:44:53 +0000
Subject: [bitcoin-dev] List of proposals for hard fork/soft fork
Message-ID: <PS2P216MB01792E6227170E85F95A2BB49D2A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

Is anybody keeping a list of the solid proposals > BIP's to be included in any actual future consensus-driven fork? Perhaps pre-consensus voting of what to include in the fork packages?

Surely not every or each proposal ever scouted is on for consideration.

This may actually help to build momentum for useful and valuable implementations that may otherwise languish.

Regards,
LORD HIS EXCELLENCY JAMES HRMH
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190414/ec57cd84/attachment.html>

From omarshib at gmail.com  Sun Apr 14 13:16:53 2019
From: omarshib at gmail.com (Omar Shibli)
Date: Sun, 14 Apr 2019 16:16:53 +0300
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
Message-ID: <CAE3EOfjhts_1m2ocrTvLJetcMUHvYgc9B8k5B4aEmgGUMDMW=w@mail.gmail.com>

This sounds really promising to me, I think it could seriously improve the
current SPV trust model.

In abstract these are the possible setups today:

Full node: All history, 100% monetary sovereignty.

SPV: fancy term to Electrum trust model, random selection of nodes, with
full delegation of monetary responsibility.

I think in that spirit a hybrid approach of full node + spv.

As follows:
Hardware spv with only genesis hash block seeded, as a safe bootstrap, from
there only headers is needed for validation, and ongoing new fresh blocks
and associated historic blocks for conducting transactions.

On Wed, Apr 3, 2019 at 2:43 AM James O'Beirne via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> I'd like to discuss assumeutxo, which is an appealing and simple
> optimization in the spirit of assumevalid[0].
>
> # Motivation
>
> To start a fully validating bitcoin client from scratch, that client
> currently
> needs to perform an initial block download. To the surprise of no one, IBD
> takes a linear amount time based on the length of the chain's history. For
> clients running on modest hardware under limited bandwidth constraints,
> say a mobile device, completing IBD takes a considerable amount of time
> and thus poses serious usability challenges.
>
> As a result, having fully validating clients run on such hardware is rare
> and
> basically unrealistic. Clients with even moderate resource constraints
> are encouraged to rely on the SPV trust model. Though we have promising
> improvements to existing SPV modes pending deployment[1], it's worth
> thinking about a mechanism that would allow such clients to use trust
> models closer to full validation.
>
> The subject of this mail is a proposal for a complementary alternative to
> SPV
> modes, and which is in the spirit of an existing default, `assumevalid`.
> It may
> help modest clients transact under a security model that closely resembles
> full validation within minutes instead of hours or days.
>
> # assumeutxo
>
> The basic idea is to allow nodes to initialize using a serialized version
> of the
> UTXO set rendered by another node at some predetermined height. The
> initializing node syncs the headers chain from the network, then obtains
> and
> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO
> set
> bundled with the block header indicating its "base" and some other
> metadata).
>
> Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> download of the 3.2GB snapshot[2].
>
> The node then syncs to the network tip and afterwards begins a simultaneous
> background validation (i.e., a conventional IBD) up to the base height of
> the
> snapshot in order to achieve full validation. Crucially, even while the
> background validation is happening the node can validate incoming blocks
> and
> transact with the benefit of the full (assumed-valid) UTXO set.
>
> Snapshots could be obtained from multiple separate peers in the same
> manner as
> block download, but I haven't put much thought into this. In concept it
> doesn't
> matter too much where the snapshots come from since their validity is
> determined via content hash.
>
> # Security
>
> Obviously there are some security implications due consideration. While
> this
> proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> Under assumevalid, a user can be tricked into transacting under a false
> history
> if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> parameter, sybils their node, and then feeds them a bogus chain
> encompassing
> all of the hard-coded checkpoints[3].
>
> The same attack is made easier in assumeutxo because, unlike in
> assumevalid,
> the attacker need not construct a valid PoW chain to get the victim's node
> into
> a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> false coin assignment.
>
> For this reason, I recommend that if we were to implement assumeutxo, we
> not
> allow its specification via commandline argument[4].
>
> Beyond this risk, I can't think of material differences in security
> relative to
> assumevalid, though I appeal to the list for help with this.
>
> # More fully validating clients
>
> A particularly exciting use-case for assumeutxo is the possibility of
> mobile
> devices functioning as fully validating nodes with access to the complete
> UTXO
> set (as an alternative to SPV models). The total resource burden needed to
> start a node
> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> + blocks_to_tip * 4MB) download and a few minutes of processing time,
> which sounds
> manageable for many mobile devices currently in use.
>
> A mobile user could initialize an assumed-valid bitcoin node within an
> hour,
> transact immediately, and complete a pruned full validation of their
> assumed-valid chain over the next few days, perhaps only doing the
> background
> IBD when their device has access to suitable high-bandwidth connections.
>
> If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> the road, it's easy to imagine an analogous process that would allow very
> fast
> startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
>
> ---
>
> I've created a related issue at our Github repository here:
>   https://github.com/bitcoin/bitcoin/issues/15605
>
> and have submitted a draft implementation of snapshot usage via RPC here:
>   https://github.com/bitcoin/bitcoin/pull/15606
>
> I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> plans for deployment steps should be discussed in the Github issue, and
> after all
> that my implementation may be reviewed as a sketch of the specific software
> changes necessary.
>
> Regards,
> James
>
>
> [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
> 2.10GHz
> [3]:
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> [4]: Marco Falke is due credit for this point
> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 
Sent from Gmail Mobile
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190414/49e2ee67/attachment-0001.html>

From dscotese at litmocracy.com  Mon Apr 15 00:44:51 2019
From: dscotese at litmocracy.com (Dave Scotese)
Date: Sun, 14 Apr 2019 17:44:51 -0700
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <20190413190925.peux7djbopy5xu3t@petertodd.org>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
	<816FFA03-B4D9-4ECE-AF15-85ACBFA4BA8F@jonasschnelli.ch>
	<CACiOHGxxqm5Qn8J9u5oDE5Ek5smqB4E4iz4PJOZHpJO5kwP=-A@mail.gmail.com>
	<CAGLBAhf1NZfT9TunhHAb==mFTfaAacjekQh6Pqn4yBS+90Zw6A@mail.gmail.com>
	<20190413190925.peux7djbopy5xu3t@petertodd.org>
Message-ID: <CAGLBAhcAxwWHZz-dLnsGNtu=-0QLv=RNM=V42cD9yRkwKzpj0w@mail.gmail.com>

No piece of data that does have significance to the Bitcoin consensus can
be memorable because it occurs (about) every ten minutes. In order to get
something memorable to provide sanity (let's say, anti-sybil-attack)
checking, it has to be rare, but recurrent.  The opportunity is actually
already there, but it usually goes by without providing the benefits.

For example, I found this blog post
<http://www.righto.com/2014/02/ascii-bernanke-wikileaks-photographs.html>
by Ken Shirriff who describes artifacts that can be found in the
blockchain. These artifacts are not intimately tied to their location in
the blockchain, so anyone building an alternative blockchain can relatively
easily add the artifacts with the same timestamp and at the same height,
masking the counterfeit.  In order to prevent that, the memorable thing has
to be intimately tied to work-intensive results, like the ratio of the hash
to the target.  Nelson Mandela's image appearing in the blockchain does NOT
prove to me it's the blockchain I can see at blockchain.com right now, but
if the smallest block hash in that blockchain, on 12/13/13, after all the
zeroes, starts with 3da1 (144 * 65536 times as much work) and is one of the
three block hashes from that day that have two occurrences of a double-e
(about 256 times more work), then it will.  The problem is that I'll
probably forget most of those details - but not that Mandela's image went
in the blockchain near the end of 2013.

On Sat, Apr 13, 2019 at 12:09 PM Peter Todd <pete at petertodd.org> wrote:

> On Wed, Apr 03, 2019 at 02:39:32PM -0700, Dave Scotese via bitcoin-dev
> wrote:
> > Every block's hash is smaller than the difficulty at that time.  Block
> > 569927's hash was VERY small (started with 21 zeros).  The ratio of block
> > hash to difficulty requirement (0xffffffff - difficulty, I think) could
> be
> > used to identify blocks as "special," thus providing the opportunity to
> > popularize unimportant but memorable-and-therefore-useful details.  How
> can
> > they be useful if they are unimportant?  They are useful for sanity
> > checking.  For example, if the drunken bishop walk (or some other popular
> > randomart) produced by block 569927's hash looked like a face, that would
> > be memorable: "The block with the smallest hash in 2019 (maybe ever?)
> looks
> > like a face after the drunken bishop walk."
>
> As hashest smaller than the target have no significance to the Bitcoin
> consensus I'd suggest not basing any features on that property. It's just
> as
> arbitrary as picking whole decimal number block heights, yet has the
> additional
> downsides of being harder to compute, and being likely to confuse people
> as to
> how the Bitcoin consensus works.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190414/36a84972/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Apr 15 02:59:44 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 15 Apr 2019 02:59:44 +0000
Subject: [bitcoin-dev] List of proposals for hard fork/soft fork
In-Reply-To: <PS2P216MB01792E6227170E85F95A2BB49D2A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <PS2P216MB01792E6227170E85F95A2BB49D2A0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <uwXr_PVDhAxPgfWwqANXIj4h0dyTW8ID4H9SMr1Aw6hYGfiB722bIcmhsZtyKMkdDUN9TzJUtcFxQ_mTvbjsqDKOIX4UtkBpl_4q_EpS1Cg=@protonmail.com>

Good morning LORD YOUR EXCELLENCY,

May it please you to be informed the below are likely to be included in some kind of upcoming softfork for SegWit v1:

1.  Schnorr signatures.
2.  MuSig.
3.  Taproot.
4.  `SIGHASH_NOINPUT`.
5.  Signature aggregation.  May it please you to be informed, that "Schnorr" enables signature aggregation, but is not signature aggregation itself.
6.  MAST.

The above may or may not be an exhaustive list, your excellency.

Of these, I believe only `SIGHASH_NOINPUT` has a BIP, may it please your excellency to learn that it is BIP 118.
However, I am sorry to inform your excellency, as I understand the `SIGHASH_NOINPUT` that will eventually reach Bitcoin Core will not match the current version of BIP118.
To improve on the possibility of incorrect use of `SIGHASH_NOINPUT`, it is proposed that every input that is signed with a `SIGHASH_NOINPUT` signature additionally require a signature without `SIGHASH_NOINPUT`.
For other details, I am sorry to inform your excellency, I have no reliable knowledge.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Sunday, April 14, 2019 10:44 PM, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Is anybody keeping a list of the solid proposals > BIP's to be included in any actual future consensus-driven fork? Perhaps pre-consensus voting of what to include in the fork packages?
>
> Surely not every or each proposal ever scouted is on for consideration.
>
> This may actually help to build momentum for useful and valuable implementations that may otherwise languish.
>
> Regards,
> LORD HIS EXCELLENCY JAMES HRMH



From ZmnSCPxj at protonmail.com  Thu Apr 18 05:33:42 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 18 Apr 2019 05:33:42 +0000
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <CALGTLwPjH8x_6gqRoXnkWKu8ZcJSgWBFV0vWss60MTi4E1MdHQ@mail.gmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
	<CALGTLwPjH8x_6gqRoXnkWKu8ZcJSgWBFV0vWss60MTi4E1MdHQ@mail.gmail.com>
Message-ID: <BuPb9X2Va172-mEpWEgdK8rcUEvLKJ4Y_804yfwJLULSa7tkTvpDyZ9GWJD0Q84AtdkzePOU-bTtRjdi5f-tbuJM4src6zaNIy9XM1tGeoQ=@protonmail.com>

Good morning Nadav,

Yes, transporting contracts over a single direct channel is always possible.

When Lightning switches to Decker-Russell-Osuntokun ("eltoo"), do note that contracts with an absolute timelock must be forced onchain earlier than the absolute timelock by the CSV requirement of the channel (unilateral close time).

With current Poon-Dryja channels, transported contracts must be augmented by a 2-of-2 on all branches, which can be done by adding a 2-of-2 multisig on the escrow branch, using temporary keys.
The purpose of the 2-of-2 is to enforce that the only valid claims to the contract have an `nSequence` representing the unilateral close time of the channel.
xref. HTLC-timeout and HTLC-success transactions in BOLT#3.

Transporting over multiple hops requires that compliance to a contract makes one side reveal information that the other side does not know, together with some kind of timeout/backoff.
Practically speaking, only HTLC-type contracts can be transported.
For example, DLCs will have many possible branches where the Oracle provides a signature for one branch, and this signature is what is learned by the other party in the contract.
In addition, DLCs for practical use require a timeout (in case the Oracle fails to reveal the signature on the appointed time).
Thus, far fewer contracts can be transported over the network.

(Of note is that a Lightning channel is itself a contract (that is transportable only within a direct channel); this is the basis of channel factories, where the factory level is effectively a "channel" with more than two participants, and transporting Lightning channels instead of HTLCs)
(You may be interested in looking at the "Fulgurite" effort)

OF note is that DLCs have an Oracle.
I observe that escrow services (which are specializations of the Smart Contracts Unchained technique) are basically oracles also.
If DLCs can transport their oracle signatures over multiple hops, then it should be possible for Smart Contracts Unchained to transport the federation/escrow signatures over multiple hops also.
I do not know the math behind DLCs enough to be certain, however, and leave it to better mathematicians than I.

Regards,
ZmnSCPxj

Regards,
ZmnSCPxj

??????? Original Message ???????
On Thursday, April 18, 2019 12:17 AM, Nadav Kohen <nadav at suredbits.com> wrote:

> Hi all!
>
> I've been thinking a lot about how to add the benefits that lightning provides in terms of privacy and speed to the smart contracts unchained setup. The high-level idea is to utilize the fact that a lightning channel already has on-chain funds locked up, and if parties cooperate, some of these funds can be moved into the 2/3 MultiSig output needed for the escrow scheme by cooperating off-chain (and then moved back to their channel balances off-chain as well). The following is an admittedly pretty rough outline of how this might be accomplished.
>
> A - B : Smart Contracts in a Lightning Channel
>
> 1) Parties both commit to a 2/3 MultiSig output on their next commitment transaction
> 2) Parties then both revoke_and_ack
> 3) When the contract yields a result, the to_local and to_remote balances can be updated and the 2/3 MultiSig output can be removed
> 4) If either party is uncooperative, their counter-party can force close the channel and funds can be resolved on-chain using the escrow
>
> If either party does not revoke_and_ack well before any potential for them to discover if they have an advantage in the contract (or after some small but reasonable time), their counter-party should go on chain with the commitment transaction containing the 2/3 MultiSig
>
> A - B - C : Single Hop Smart Contracts (Useful if someone, B in this case, wants to provide a hub that matches users wanting to enter smart contracts)
>
> 1) A irrevocably commits to a 2/3 MultiSig output on their commitment transaction with B (which B also commits to but does not yet revoke their old state)
> 2) C irrevocably commits to the same 2/3 MultiSig output on their commitment transaction with B (which B also commits to)
> 3) B irrevocably commits to both outputs
> 4) When the contract yields a result, say A should win some money from C, then A can ask B to remove that output (and update balances) by revealing to B how to claim funds from C
> 5) B can then ask C to remove the output and add to B's balance
>
> If B does not revoke_and_ack on either channel, then the affected counter-party should close the channel and go on chain with the 2/3 MultiSig transaction
> If B refuses to remove the output, A can claim their funds on-chain where B can learn how to claim funds from C
> If C refuses to remove the output, B can claim their funds on-chain using the information revealed by A
>
> Problems: How do we ensure that only B can claim the 2/3 MultiSig from C, and not anyone who sees A's on-chain spend of their 2/3 MultiSig? I'm pretty sure this is possible to do but I don't know Script well enough
>
> A - B - C - D : Fully Routed Smart Contracts
>
> 1) Given the n possible outcomes in which A gets money from the contract between A and D, a_1 < a_2 < ... < a_n, and the m possible outcomes in which D gets money, d_1 < d_2 < ... < d_m, D must send n HTLCs to A with the amounts a_1, a_2 - a_1, a_3 - a_2, ..., a_n - a_(n-1) and A must send m HTLCs to D with amounts d_1, d_2 - d_1, d_3 - d_2, ..., d_m - d_(m-1)
> 2) These HTLCs must be special and have two hashes, where either preimage unlocks the funds
> 3) In the payments from A to D, A knows one preimage and the smart contracting platform knows the other (and similarly for D to A)
> 4) Should a_i be the outcome of the contract, D should tell A what the preimages are to payments 1 through i
> 5) D should fail all m payments
> 6) A should fail all payments i+1 through n
> (It is possible and in fact likely that there can be ways to use fewer transactions and thus less collateral than this, perhaps by using subtraction and not just addition as in a_i - d_j, what I've presented is simply a lower bound that works in all cases)
>
> If D does not reveal their preimages, A can get the relevant preimages from the smart contracting platform
>
> Problems: The smart contracting platform is given more information about the contract in the happy path in this scheme. Also, all routers need to support special double-hash HTLCs
>
> An alternative way to possibly do multi-hop routing that would require less be told to the escrow service, is to have each routing node add an output on either side where it takes one position in one channel and the other position in the other channel (essentially allowing them to break event when the contract is completed). This has the same problems as the Single Hop case as well as the additional problem (that I couldn't imagine a solution for) of making the commitments to the 2/3 MultiSig output on commitment transactions atomic; in the single hop case incentives seem to work out but I don't know how "failed routing" would be detected or handled in the multi-hop case.
>
> Feedback welcome!
>
> Best,
> Nadav
>
> On Wed, Apr 3, 2019 at 9:14 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > https://zmnscpxj.github.io/bitcoin/unchained.html
> >
> > Smart contracts have traditionally been implemented as part of the consensus rules of some blokchain.? Often this means creating a new blockchain, or at least a sidechain to an existing blockchain.? This writeup proposes an alternative method without launching a separate blockchain or sidechain, while achieving security similar to federated sidechains and additional benefits to privacy and smart-contract-patching.
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From nadav at suredbits.com  Wed Apr 17 16:17:11 2019
From: nadav at suredbits.com (Nadav Kohen)
Date: Wed, 17 Apr 2019 11:17:11 -0500
Subject: [bitcoin-dev] Smart Contracts Unchained
In-Reply-To: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
References: <IAFPSZAn6TYt348fmmnPznQ_ApG7pa48eMjzTgrjuVAt6fS1tNieRxlcIXyTATy2vjZCUn4wVQcsyDlyb_3Ip46BstFRikB95-lKewAZBEE=@protonmail.com>
Message-ID: <CALGTLwPjH8x_6gqRoXnkWKu8ZcJSgWBFV0vWss60MTi4E1MdHQ@mail.gmail.com>

Hi all!

I've been thinking a lot about how to add the benefits that lightning
provides in terms of privacy and speed to the smart contracts unchained
setup. The high-level idea is to utilize the fact that a lightning channel
already has on-chain funds locked up, and if parties cooperate, some of
these funds can be moved into the 2/3 MultiSig output needed for the escrow
scheme by cooperating off-chain (and then moved back to their channel
balances off-chain as well). The following is an admittedly pretty rough
outline of how this might be accomplished.

A - B : Smart Contracts in a Lightning Channel

1) Parties both commit to a 2/3 MultiSig output on their next commitment
transaction
2) Parties then both revoke_and_ack
3) When the contract yields a result, the to_local and to_remote balances
can be updated and the 2/3 MultiSig output can be removed
4) If either party is uncooperative, their counter-party can force close
the channel and funds can be resolved on-chain using the escrow

If either party does not revoke_and_ack well before any potential for them
to discover if they have an advantage in the contract (or after some small
but reasonable time), their counter-party should go on chain with the
commitment transaction containing the 2/3 MultiSig

A - B - C : Single Hop Smart Contracts (Useful if someone, B in this case,
wants to provide a hub that matches users wanting to enter smart contracts)

1) A irrevocably commits to a 2/3 MultiSig output on their commitment
transaction with B (which B also commits to but does not yet revoke their
old state)
2) C irrevocably commits to the same 2/3 MultiSig output on their
commitment transaction with B (which B also commits to)
3) B irrevocably commits to both outputs
4) When the contract yields a result, say A should win some money from C,
then A can ask B to remove that output (and update balances) by revealing
to B how to claim funds from C
5) B can then ask C to remove the output and add to B's balance

If B does not revoke_and_ack on either channel, then the affected
counter-party should close the channel and go on chain with the 2/3
MultiSig transaction
If B refuses to remove the output, A can claim their funds on-chain where B
can learn how to claim funds from C
If C refuses to remove the output, B can claim their funds on-chain using
the information revealed by A

Problems: How do we ensure that only B can claim the 2/3 MultiSig from C,
and not anyone who sees A's on-chain spend of their 2/3 MultiSig? I'm
pretty sure this is possible to do but I don't know Script well enough

A - B - C - D : Fully Routed Smart Contracts

1) Given the n possible outcomes in which A gets money from the contract
between A and D, a_1 < a_2 < ... < a_n, and the m possible outcomes in
which D gets money, d_1 < d_2 < ... < d_m, D must send n HTLCs to A with
the amounts a_1, a_2 - a_1, a_3 - a_2, ..., a_n - a_(n-1) and A must send m
HTLCs to D with amounts d_1, d_2 - d_1, d_3 - d_2, ..., d_m - d_(m-1)
2) These HTLCs must be special and have two hashes, where either preimage
unlocks the funds
3) In the payments from A to D, A knows one preimage and the smart
contracting platform knows the other (and similarly for D to A)
4) Should a_i be the outcome of the contract, D should tell A what the
preimages are to payments 1 through i
5) D should fail all m payments
6) A should fail all payments i+1 through n
(It is possible and in fact likely that there can be ways to use fewer
transactions and thus less collateral than this, perhaps by using
subtraction and not just addition as in a_i - d_j, what I've presented is
simply a lower bound that works in all cases)

If D does not reveal their preimages, A can get the relevant preimages from
the smart contracting platform

Problems: The smart contracting platform is given more information about
the contract in the happy path in this scheme. Also, all routers need to
support special double-hash HTLCs

An alternative way to possibly do multi-hop routing that would require less
be told to the escrow service, is to have each routing node add an output
on either side where it takes one position in one channel and the other
position in the other channel (essentially allowing them to break event
when the contract is completed). This has the same problems as the Single
Hop case as well as the additional problem (that I couldn't imagine a
solution for) of making the commitments to the 2/3 MultiSig output on
commitment transactions atomic; in the single hop case incentives seem to
work out but I don't know how "failed routing" would be detected or handled
in the multi-hop case.

Feedback welcome!

Best,
Nadav

On Wed, Apr 3, 2019 at 9:14 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> https://zmnscpxj.github.io/bitcoin/unchained.html
>
> Smart contracts have traditionally been implemented as part of the
> consensus rules of some blokchain.  Often this means creating a new
> blockchain, or at least a sidechain to an existing blockchain.  This
> writeup proposes an alternative method without launching a separate
> blockchain or sidechain, while achieving security similar to federated
> sidechains and additional benefits to privacy and smart-contract-patching.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190417/e30ba24f/attachment.html>

From olinzodd at gmail.com  Wed Apr 17 13:57:25 2019
From: olinzodd at gmail.com (Bill Miller)
Date: Wed, 17 Apr 2019 09:57:25 -0400
Subject: [bitcoin-dev] BIPS (re:LORD HIS EXCELLENCY JAMES HRMH)
Message-ID: <CAA8OeootauhLfj3M3DPW0Nv-MppTOUgnTuKjiGoU_oekiDNvOw@mail.gmail.com>

Here is where I keep track, in general (don't know if that helps, but
thought I'd send it)

https://github.com/bitcoin/bips/blob/master/README.mediawiki
Regards,
Bill
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190417/87c126a9/attachment-0001.html>

From rsomsen at gmail.com  Mon Apr 15 06:37:43 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Mon, 15 Apr 2019 08:37:43 +0200
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
Message-ID: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>

Simplified-Payment-Verification (SPV) is secure under the assumption
that the chain with the most Proof-of-Work (PoW) is valid. As many
have pointed out before, and attacks like Segwit2x have shown, this is
not a safe assumption. What I propose below improves this assumption
-- invalid blocks will be rejected as long as there are enough honest
miners to create a block within a reasonable time frame. This still
doesn?t fully inoculate SPV clients against dishonest miners, but is a
clear improvement over regular SPV (and compatible with the privacy
improvements of BIP157[0]).

The idea is that a fork is an indication of potential misbehavior --
its block header can serve as a PoW fraud proof. Conversely, the lack
of a fork is an indication that a block is valid. If a fork is created
from a block at height N, this means a subset of miners may disagree
on the validity of block N+1. If SPV clients download and verify this
block, they can judge for themselves whether or not the chain should
be rejected. Of course it could simply be a natural fork, in which
case we continue following the chain with the most PoW.

The way Bitcoin currently works, it is impossible to verify the
validity of block N+1 without knowing the UTXO set at block N, even if
you are willing to assume that block N (and everything before it) is
valid. This would change with the introduction of UTXO set
commitments, allowing block N+1 to be validated by verifying whether
its inputs are present in the UTXO set that was committed to in block
N. An open question is whether a similar result can be achieved
without a soft fork that commits to the UTXO set[0][1].

If an invalid block is created and only 10% of the miners are honest,
on average it would take 100 minutes for a valid block to appear.
During this time, the SPV client will be following the invalid chain
and see roughly 9 confirmations before the chain gets rejected. It may
therefore be prudent to wait for a number of confirmations that
corresponds to the time it may take for the conservative percentage of
miners that you think may behave honestly to create a block (including
variance).

If users do not wait and happen to accept payments from an invalid
chain during this time, these payments could get reverted. This is a
weakness, but still seems preferably to continually following an
invalid chain. As long as a reasonable number of miners remains
honest, a dishonest majority can only temporarily control the network,
and their blocks (and all coins gained from it) will eventually be
rejected.

-- Ruben Somsen


[0] Olaoluwa Osuntokun, BIP 157: Client Side Block Filtering,
https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki

[1] Peter Todd, TXO commitments do not need a soft-fork to be useful,
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-February/013591.html

From ZmnSCPxj at protonmail.com  Thu Apr 18 16:55:10 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 18 Apr 2019 16:55:10 +0000
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
Message-ID: <-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>

Good morning Ruben,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Simplified-Payment-Verification (SPV) is secure under the assumption
> that the chain with the most Proof-of-Work (PoW) is valid. As many
> have pointed out before, and attacks like Segwit2x have shown, this is
> not a safe assumption. What I propose below improves this assumption
> -- invalid blocks will be rejected as long as there are enough honest
> miners to create a block within a reasonable time frame. This still
> doesn?t fully inoculate SPV clients against dishonest miners, but is a
> clear improvement over regular SPV (and compatible with the privacy
> improvements of BIP157[0]).
>
> The idea is that a fork is an indication of potential misbehavior --
> its block header can serve as a PoW fraud proof. Conversely, the lack
> of a fork is an indication that a block is valid. If a fork is created
> from a block at height N, this means a subset of miners may disagree
> on the validity of block N+1. If SPV clients download and verify this
> block, they can judge for themselves whether or not the chain should
> be rejected. Of course it could simply be a natural fork, in which
> case we continue following the chain with the most PoW.

I presume you mean a chain split?

>
> The way Bitcoin currently works, it is impossible to verify the
> validity of block N+1 without knowing the UTXO set at block N, even if
> you are willing to assume that block N (and everything before it) is
> valid. This would change with the introduction of UTXO set
> commitments, allowing block N+1 to be validated by verifying whether
> its inputs are present in the UTXO set that was committed to in block
> N. An open question is whether a similar result can be achieved
> without a soft fork that commits to the UTXO set[0][1].
>
> If an invalid block is created and only 10% of the miners are honest,
> on average it would take 100 minutes for a valid block to appear.
> During this time, the SPV client will be following the invalid chain
> and see roughly 9 confirmations before the chain gets rejected. It may
> therefore be prudent to wait for a number of confirmations that
> corresponds to the time it may take for the conservative percentage of
> miners that you think may behave honestly to create a block (including
> variance).

I suppose a minority miner that wants to disrupt the network could simply create a *valid* block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.

>10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.
Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.

It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.

Regards,
ZmnSCPxj

From eth3rs at gmail.com  Thu Apr 18 20:12:20 2019
From: eth3rs at gmail.com (Ethan Heilman)
Date: Thu, 18 Apr 2019 16:12:20 -0400
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
Message-ID: <CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>

I'm probably repeating a point which has been said before.

>I suppose a minority miner that wants to disrupt the network could simply create a *valid* block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
If this minority miner has > 10% of network hashrate, then the rule of
thumb above would, on average, give it the ability to disrupt the
SPV-using network.

Proposed rule:
Whenever a chainsplit occurs SPV clients should download and validate
the "longest chain" up to more than one block greater than the height
of the losing chain.

Lets say a block split causes chain A and chain B: Chain A is N blocks
long, chain B is M blocks long, and N < M. Then the SPV client should
download all the block data of N+1 blocks from Chain B to verify
availability of chain B. Once the SPV client has verified that chain B
is available they can use fraud proofs determine if chain B is valid.

An attacker could use this to force SPV clients to download 1 block
per block the attacker mines. This is strictly weaker security than
provided by a full-node because chain B will only be validated if the
client knows chain A exists. If the SPV client's view of the
blockchain is eclipsed then the client will never learn that chain A
exists and thus never validate chain B's availability nor will the
client be able to learn fraud proofs about chain B. A full node in
this circumstance would notice that the chain B is invalid and reject
it because a full node would not depend on fraud proofs. That being
said this rule would provide strictly more security than current SPV
clients.

On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Good morning Ruben,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Simplified-Payment-Verification (SPV) is secure under the assumption
> > that the chain with the most Proof-of-Work (PoW) is valid. As many
> > have pointed out before, and attacks like Segwit2x have shown, this is
> > not a safe assumption. What I propose below improves this assumption
> > -- invalid blocks will be rejected as long as there are enough honest
> > miners to create a block within a reasonable time frame. This still
> > doesn?t fully inoculate SPV clients against dishonest miners, but is a
> > clear improvement over regular SPV (and compatible with the privacy
> > improvements of BIP157[0]).
> >
> > The idea is that a fork is an indication of potential misbehavior --
> > its block header can serve as a PoW fraud proof. Conversely, the lack
> > of a fork is an indication that a block is valid. If a fork is created
> > from a block at height N, this means a subset of miners may disagree
> > on the validity of block N+1. If SPV clients download and verify this
> > block, they can judge for themselves whether or not the chain should
> > be rejected. Of course it could simply be a natural fork, in which
> > case we continue following the chain with the most PoW.
>
> I presume you mean a chain split?
>
> >
> > The way Bitcoin currently works, it is impossible to verify the
> > validity of block N+1 without knowing the UTXO set at block N, even if
> > you are willing to assume that block N (and everything before it) is
> > valid. This would change with the introduction of UTXO set
> > commitments, allowing block N+1 to be validated by verifying whether
> > its inputs are present in the UTXO set that was committed to in block
> > N. An open question is whether a similar result can be achieved
> > without a soft fork that commits to the UTXO set[0][1].
> >
> > If an invalid block is created and only 10% of the miners are honest,
> > on average it would take 100 minutes for a valid block to appear.
> > During this time, the SPV client will be following the invalid chain
> > and see roughly 9 confirmations before the chain gets rejected. It may
> > therefore be prudent to wait for a number of confirmations that
> > corresponds to the time it may take for the conservative percentage of
> > miners that you think may behave honestly to create a block (including
> > variance).
>
> I suppose a minority miner that wants to disrupt the network could simply create a *valid* block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.
>
> >10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.
> Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.
>
> It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Fri Apr 19 00:25:25 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 19 Apr 2019 00:25:25 +0000
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
Message-ID: <xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>

Good morning Ethan,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Friday, April 19, 2019 4:12 AM, Ethan Heilman <eth3rs at gmail.com> wrote:

> I'm probably repeating a point which has been said before.
>
> > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
>
> If this minority miner has > 10% of network hashrate, then the rule of
> thumb above would, on average, give it the ability to disrupt the
> SPV-using network.
>
> Proposed rule:
> Whenever a chainsplit occurs SPV clients should download and validate
> the "longest chain" up to more than one block greater than the height
> of the losing chain.
>
> Lets say a block split causes chain A and chain B: Chain A is N blocks
> long, chain B is M blocks long, and N < M. Then the SPV client should
> download all the block data of N+1 blocks from Chain B to verify
> availability of chain B. Once the SPV client has verified that chain B
> is available they can use fraud proofs determine if chain B is valid.

Let us then revert to the original scenario.
Suppose a supermajority (90%) of miners decide to increase inflation of the currency.

They do this by imposing the rule:

1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.
2.  For 9 blocks, the coinbase is the pre-fork value.
3.  Repeat this pattern every 10 blocks.

The above is a hardfork.
However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.

At height S+1, they begin the above rule.
This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.

At around height S+9, the minority miners generate an alternate block at height S+1.
So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.

At around height S+18, the minority miners generate an alternate block at height S+2.
So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.

This can go on for a good amount of time.
With a "rare enough" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.

Again: every rule is an opportunity to loophole.

Regards,
ZmnSCPxj

> An attacker could use this to force SPV clients to download 1 block
> per block the attacker mines. This is strictly weaker security than
> provided by a full-node because chain B will only be validated if the
> client knows chain A exists. If the SPV client's view of the
> blockchain is eclipsed then the client will never learn that chain A
> exists and thus never validate chain B's availability nor will the
> client be able to learn fraud proofs about chain B. A full node in
> this circumstance would notice that the chain B is invalid and reject
> it because a full node would not depend on fraud proofs. That being
> said this rule would provide strictly more security than current SPV
> clients.
>
> On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > Good morning Ruben,
> > Sent with ProtonMail Secure Email.
> > ??????? Original Message ???????
> > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> > > Simplified-Payment-Verification (SPV) is secure under the assumption
> > > that the chain with the most Proof-of-Work (PoW) is valid. As many
> > > have pointed out before, and attacks like Segwit2x have shown, this is
> > > not a safe assumption. What I propose below improves this assumption
> > > -- invalid blocks will be rejected as long as there are enough honest
> > > miners to create a block within a reasonable time frame. This still
> > > doesn?t fully inoculate SPV clients against dishonest miners, but is a
> > > clear improvement over regular SPV (and compatible with the privacy
> > > improvements of BIP157[0]).
> > > The idea is that a fork is an indication of potential misbehavior --
> > > its block header can serve as a PoW fraud proof. Conversely, the lack
> > > of a fork is an indication that a block is valid. If a fork is created
> > > from a block at height N, this means a subset of miners may disagree
> > > on the validity of block N+1. If SPV clients download and verify this
> > > block, they can judge for themselves whether or not the chain should
> > > be rejected. Of course it could simply be a natural fork, in which
> > > case we continue following the chain with the most PoW.
> >
> > I presume you mean a chain split?
> >
> > > The way Bitcoin currently works, it is impossible to verify the
> > > validity of block N+1 without knowing the UTXO set at block N, even if
> > > you are willing to assume that block N (and everything before it) is
> > > valid. This would change with the introduction of UTXO set
> > > commitments, allowing block N+1 to be validated by verifying whether
> > > its inputs are present in the UTXO set that was committed to in block
> > > N. An open question is whether a similar result can be achieved
> > > without a soft fork that commits to the UTXO set[0][1].
> > > If an invalid block is created and only 10% of the miners are honest,
> > > on average it would take 100 minutes for a valid block to appear.
> > > During this time, the SPV client will be following the invalid chain
> > > and see roughly 9 confirmations before the chain gets rejected. It may
> > > therefore be prudent to wait for a number of confirmations that
> > > corresponds to the time it may take for the conservative percentage of
> > > miners that you think may behave honestly to create a block (including
> > > variance).
> >
> > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.
> >
> > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.
> > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.
> >
> > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.
> > Regards,
> > ZmnSCPxj
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From eth3rs at gmail.com  Fri Apr 19 01:13:07 2019
From: eth3rs at gmail.com (Ethan Heilman)
Date: Thu, 18 Apr 2019 21:13:07 -0400
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
Message-ID: <CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>

Hi ZmnSCPxj,

Let's see if I understand what you are saying. In your scenario chain
A consists of honest miners (10% of the hash rate) and chain B  (90%
of the hash rate) consists of dishonest miners who are inflating the
coin supply.

Chain A: S, S+1
Chain B: S, S+1 (invalid), S+2, S+3, S+4, S+5, S+6, S+7, S+8, S+9

Chain B S+1 has a invalid coinbase

>At around height S+9, the minority miners generate an alternate block at height S+1. So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.

What I am suggesting is that when the minority miners generate an
alternate block at S+1 (chain A) the SPV node would download blocks
S+1 and S+2 from chain B (the dishonest chain). Since S+1 has the
invalid coinbase the SPV node would learn that chain B is invalid and
abandon it.

Bitcoin is in big trouble if a malicious party controls 90% of the
mining power. The malicious miners can spend +11% of their mining
power ensuring that the honest chain never reaches consensus by
continuously forking it. The malicious miners can then extend their
favored chain using the other 79% of the mining power. This would
produce a scenario in which users are forced to choose between a
stable chain that violates a consensus rule and an unstable honest
chain that is completely unusable and which never pays out mining
rewards. I agree that SPV nodes and many wallets would make this even
worse especially in their current condition where they just trust the
hash rate/wallet provider and there are no fraud proofs.

On Thu, Apr 18, 2019 at 8:25 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ethan,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Friday, April 19, 2019 4:12 AM, Ethan Heilman <eth3rs at gmail.com> wrote:
>
> > I'm probably repeating a point which has been said before.
> >
> > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> >
> > If this minority miner has > 10% of network hashrate, then the rule of
> > thumb above would, on average, give it the ability to disrupt the
> > SPV-using network.
> >
> > Proposed rule:
> > Whenever a chainsplit occurs SPV clients should download and validate
> > the "longest chain" up to more than one block greater than the height
> > of the losing chain.
> >
> > Lets say a block split causes chain A and chain B: Chain A is N blocks
> > long, chain B is M blocks long, and N < M. Then the SPV client should
> > download all the block data of N+1 blocks from Chain B to verify
> > availability of chain B. Once the SPV client has verified that chain B
> > is available they can use fraud proofs determine if chain B is valid.
>
> Let us then revert to the original scenario.
> Suppose a supermajority (90%) of miners decide to increase inflation of the currency.
>
> They do this by imposing the rule:
>
> 1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.
> 2.  For 9 blocks, the coinbase is the pre-fork value.
> 3.  Repeat this pattern every 10 blocks.
>
> The above is a hardfork.
> However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.
>
> At height S+1, they begin the above rule.
> This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.
>
> At around height S+9, the minority miners generate an alternate block at height S+1.
> So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.
>
> At around height S+18, the minority miners generate an alternate block at height S+2.
> So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.
>
> This can go on for a good amount of time.
> With a "rare enough" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.
>
> Again: every rule is an opportunity to loophole.
>
> Regards,
> ZmnSCPxj
>
> > An attacker could use this to force SPV clients to download 1 block
> > per block the attacker mines. This is strictly weaker security than
> > provided by a full-node because chain B will only be validated if the
> > client knows chain A exists. If the SPV client's view of the
> > blockchain is eclipsed then the client will never learn that chain A
> > exists and thus never validate chain B's availability nor will the
> > client be able to learn fraud proofs about chain B. A full node in
> > this circumstance would notice that the chain B is invalid and reject
> > it because a full node would not depend on fraud proofs. That being
> > said this rule would provide strictly more security than current SPV
> > clients.
> >
> > On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev
> > bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> > > Good morning Ruben,
> > > Sent with ProtonMail Secure Email.
> > > ??????? Original Message ???????
> > > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> > >
> > > > Simplified-Payment-Verification (SPV) is secure under the assumption
> > > > that the chain with the most Proof-of-Work (PoW) is valid. As many
> > > > have pointed out before, and attacks like Segwit2x have shown, this is
> > > > not a safe assumption. What I propose below improves this assumption
> > > > -- invalid blocks will be rejected as long as there are enough honest
> > > > miners to create a block within a reasonable time frame. This still
> > > > doesn?t fully inoculate SPV clients against dishonest miners, but is a
> > > > clear improvement over regular SPV (and compatible with the privacy
> > > > improvements of BIP157[0]).
> > > > The idea is that a fork is an indication of potential misbehavior --
> > > > its block header can serve as a PoW fraud proof. Conversely, the lack
> > > > of a fork is an indication that a block is valid. If a fork is created
> > > > from a block at height N, this means a subset of miners may disagree
> > > > on the validity of block N+1. If SPV clients download and verify this
> > > > block, they can judge for themselves whether or not the chain should
> > > > be rejected. Of course it could simply be a natural fork, in which
> > > > case we continue following the chain with the most PoW.
> > >
> > > I presume you mean a chain split?
> > >
> > > > The way Bitcoin currently works, it is impossible to verify the
> > > > validity of block N+1 without knowing the UTXO set at block N, even if
> > > > you are willing to assume that block N (and everything before it) is
> > > > valid. This would change with the introduction of UTXO set
> > > > commitments, allowing block N+1 to be validated by verifying whether
> > > > its inputs are present in the UTXO set that was committed to in block
> > > > N. An open question is whether a similar result can be achieved
> > > > without a soft fork that commits to the UTXO set[0][1].
> > > > If an invalid block is created and only 10% of the miners are honest,
> > > > on average it would take 100 minutes for a valid block to appear.
> > > > During this time, the SPV client will be following the invalid chain
> > > > and see roughly 9 confirmations before the chain gets rejected. It may
> > > > therefore be prudent to wait for a number of confirmations that
> > > > corresponds to the time it may take for the conservative percentage of
> > > > miners that you think may behave honestly to create a block (including
> > > > variance).
> > >
> > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> > > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.
> > >
> > > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.
> > > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.
> > >
> > > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.
> > > Regards,
> > > ZmnSCPxj
> > >
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>

From ZmnSCPxj at protonmail.com  Fri Apr 19 02:53:49 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 19 Apr 2019 02:53:49 +0000
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
Message-ID: <xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>

Good morning Ethan,

Thank you for clarifying, I understand better now.

It seems that minority miners can disrupt SPV clients such that SPV clients will download 2 blocks for every block the minority miner can find, not 1.

This can be done by simply making multiple 1-block chainsplits, rather than a single persistent chainsplit, and alternating split-off and non-split-off.

For instance, such a minority miner might split at S+1, forcing SPV clients to download S+1 and S+2.
Then the minority miner splits at S+3, forcing SPV clients to download S+3 and S+4.
With a mere 33% hashrate, this can force SPV clients to download every block, i.e. become a fullnode anyway.

Since there exist pools with >33% hashrate, the above attack is possible so the only solution is to become a fullnode anyway.

Regards,
ZmnSCPxj


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Friday, April 19, 2019 9:13 AM, Ethan Heilman <eth3rs at gmail.com> wrote:

> Hi ZmnSCPxj,
>
> Let's see if I understand what you are saying. In your scenario chain
> A consists of honest miners (10% of the hash rate) and chain B (90%
> of the hash rate) consists of dishonest miners who are inflating the
> coin supply.
>
> Chain A: S, S+1
> Chain B: S, S+1 (invalid), S+2, S+3, S+4, S+5, S+6, S+7, S+8, S+9
>
> Chain B S+1 has a invalid coinbase
>
> > At around height S+9, the minority miners generate an alternate block at height S+1. So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.
>
> What I am suggesting is that when the minority miners generate an
> alternate block at S+1 (chain A) the SPV node would download blocks
> S+1 and S+2 from chain B (the dishonest chain). Since S+1 has the
> invalid coinbase the SPV node would learn that chain B is invalid and
> abandon it.
>
> Bitcoin is in big trouble if a malicious party controls 90% of the
> mining power. The malicious miners can spend +11% of their mining
> power ensuring that the honest chain never reaches consensus by
> continuously forking it. The malicious miners can then extend their
> favored chain using the other 79% of the mining power. This would
> produce a scenario in which users are forced to choose between a
> stable chain that violates a consensus rule and an unstable honest
> chain that is completely unusable and which never pays out mining
> rewards. I agree that SPV nodes and many wallets would make this even
> worse especially in their current condition where they just trust the
> hash rate/wallet provider and there are no fraud proofs.
>
> On Thu, Apr 18, 2019 at 8:25 PM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
>
> > Good morning Ethan,
> > Sent with ProtonMail Secure Email.
> > ??????? Original Message ???????
> > On Friday, April 19, 2019 4:12 AM, Ethan Heilman eth3rs at gmail.com wrote:
> >
> > > I'm probably repeating a point which has been said before.
> > >
> > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> > >
> > > If this minority miner has > 10% of network hashrate, then the rule of
> > > thumb above would, on average, give it the ability to disrupt the
> > > SPV-using network.
> > > Proposed rule:
> > > Whenever a chainsplit occurs SPV clients should download and validate
> > > the "longest chain" up to more than one block greater than the height
> > > of the losing chain.
> > > Lets say a block split causes chain A and chain B: Chain A is N blocks
> > > long, chain B is M blocks long, and N < M. Then the SPV client should
> > > download all the block data of N+1 blocks from Chain B to verify
> > > availability of chain B. Once the SPV client has verified that chain B
> > > is available they can use fraud proofs determine if chain B is valid.
> >
> > Let us then revert to the original scenario.
> > Suppose a supermajority (90%) of miners decide to increase inflation of the currency.
> > They do this by imposing the rule:
> >
> > 1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.
> > 2.  For 9 blocks, the coinbase is the pre-fork value.
> > 3.  Repeat this pattern every 10 blocks.
> >
> > The above is a hardfork.
> > However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.
> > At height S+1, they begin the above rule.
> > This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.
> > At around height S+9, the minority miners generate an alternate block at height S+1.
> > So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.
> > At around height S+18, the minority miners generate an alternate block at height S+2.
> > So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.
> > This can go on for a good amount of time.
> > With a "rare enough" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.
> > Again: every rule is an opportunity to loophole.
> > Regards,
> > ZmnSCPxj
> >
> > > An attacker could use this to force SPV clients to download 1 block
> > > per block the attacker mines. This is strictly weaker security than
> > > provided by a full-node because chain B will only be validated if the
> > > client knows chain A exists. If the SPV client's view of the
> > > blockchain is eclipsed then the client will never learn that chain A
> > > exists and thus never validate chain B's availability nor will the
> > > client be able to learn fraud proofs about chain B. A full node in
> > > this circumstance would notice that the chain B is invalid and reject
> > > it because a full node would not depend on fraud proofs. That being
> > > said this rule would provide strictly more security than current SPV
> > > clients.
> > > On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev
> > > bitcoin-dev at lists.linuxfoundation.org wrote:
> > >
> > > > Good morning Ruben,
> > > > Sent with ProtonMail Secure Email.
> > > > ??????? Original Message ???????
> > > > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> > > >
> > > > > Simplified-Payment-Verification (SPV) is secure under the assumption
> > > > > that the chain with the most Proof-of-Work (PoW) is valid. As many
> > > > > have pointed out before, and attacks like Segwit2x have shown, this is
> > > > > not a safe assumption. What I propose below improves this assumption
> > > > > -- invalid blocks will be rejected as long as there are enough honest
> > > > > miners to create a block within a reasonable time frame. This still
> > > > > doesn?t fully inoculate SPV clients against dishonest miners, but is a
> > > > > clear improvement over regular SPV (and compatible with the privacy
> > > > > improvements of BIP157[0]).
> > > > > The idea is that a fork is an indication of potential misbehavior --
> > > > > its block header can serve as a PoW fraud proof. Conversely, the lack
> > > > > of a fork is an indication that a block is valid. If a fork is created
> > > > > from a block at height N, this means a subset of miners may disagree
> > > > > on the validity of block N+1. If SPV clients download and verify this
> > > > > block, they can judge for themselves whether or not the chain should
> > > > > be rejected. Of course it could simply be a natural fork, in which
> > > > > case we continue following the chain with the most PoW.
> > > >
> > > > I presume you mean a chain split?
> > > >
> > > > > The way Bitcoin currently works, it is impossible to verify the
> > > > > validity of block N+1 without knowing the UTXO set at block N, even if
> > > > > you are willing to assume that block N (and everything before it) is
> > > > > valid. This would change with the introduction of UTXO set
> > > > > commitments, allowing block N+1 to be validated by verifying whether
> > > > > its inputs are present in the UTXO set that was committed to in block
> > > > > N. An open question is whether a similar result can be achieved
> > > > > without a soft fork that commits to the UTXO set[0][1].
> > > > > If an invalid block is created and only 10% of the miners are honest,
> > > > > on average it would take 100 minutes for a valid block to appear.
> > > > > During this time, the SPV client will be following the invalid chain
> > > > > and see roughly 9 confirmations before the chain gets rejected. It may
> > > > > therefore be prudent to wait for a number of confirmations that
> > > > > corresponds to the time it may take for the conservative percentage of
> > > > > miners that you think may behave honestly to create a block (including
> > > > > variance).
> > > >
> > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> > > > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.
> > > >
> > > > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.
> > > > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.
> > > >
> > > > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.
> > > > Regards,
> > > > ZmnSCPxj
> > > > bitcoin-dev mailing list
> > > > bitcoin-dev at lists.linuxfoundation.org
> > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From eth3rs at gmail.com  Fri Apr 19 03:21:53 2019
From: eth3rs at gmail.com (Ethan Heilman)
Date: Thu, 18 Apr 2019 23:21:53 -0400
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
Message-ID: <CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>

Good morning to you as well ZmnSCPxj,

My above email contains an error. The SPV client needs to only
download S+1, not S+1 and S+2.

I agree with you that a weakness of this approach is a miner can make
SPV clients do substantially more work. However:

1. Mining a block which will never be accepted is an expensive way to
make SPV clients download, validate and discard ~2-4 megabytes of
data. There are far less expensive ways of wasting the resources of
SPV clients. Its unclear why someone would want to do this instead of
just packeting full nodes or SPV servers like we saw with the recent
DDoS attacks against electrum servers.

2. SPV clients may not even learn about these splits because it
requires that someone relay the split to them. Honest full nodes
should not relay such splits. To their bitcoin's worth the attacker
must also connect to lots of SPV clients.

3. Having SPV clients slow down or become full nodes when a malicious
miner with significant mining power is attempting to disrupt the
network is probably a best case outcome. I would prefer this failure
mode to the current SPV behavior which is to just go with the
"longest" chain.

Thanks,
Ethan

On Thu, Apr 18, 2019 at 10:53 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ethan,
>
> Thank you for clarifying, I understand better now.
>
> It seems that minority miners can disrupt SPV clients such that SPV clients will download 2 blocks for every block the minority miner can find, not 1.
>
> This can be done by simply making multiple 1-block chainsplits, rather than a single persistent chainsplit, and alternating split-off and non-split-off.
>
> For instance, such a minority miner might split at S+1, forcing SPV clients to download S+1 and S+2.
> Then the minority miner splits at S+3, forcing SPV clients to download S+3 and S+4.
> With a mere 33% hashrate, this can force SPV clients to download every block, i.e. become a fullnode anyway.
>
> Since there exist pools with >33% hashrate, the above attack is possible so the only solution is to become a fullnode anyway.
>
> Regards,
> ZmnSCPxj
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Friday, April 19, 2019 9:13 AM, Ethan Heilman <eth3rs at gmail.com> wrote:
>
> > Hi ZmnSCPxj,
> >
> > Let's see if I understand what you are saying. In your scenario chain
> > A consists of honest miners (10% of the hash rate) and chain B (90%
> > of the hash rate) consists of dishonest miners who are inflating the
> > coin supply.
> >
> > Chain A: S, S+1
> > Chain B: S, S+1 (invalid), S+2, S+3, S+4, S+5, S+6, S+7, S+8, S+9
> >
> > Chain B S+1 has a invalid coinbase
> >
> > > At around height S+9, the minority miners generate an alternate block at height S+1. So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.
> >
> > What I am suggesting is that when the minority miners generate an
> > alternate block at S+1 (chain A) the SPV node would download blocks
> > S+1 and S+2 from chain B (the dishonest chain). Since S+1 has the
> > invalid coinbase the SPV node would learn that chain B is invalid and
> > abandon it.
> >
> > Bitcoin is in big trouble if a malicious party controls 90% of the
> > mining power. The malicious miners can spend +11% of their mining
> > power ensuring that the honest chain never reaches consensus by
> > continuously forking it. The malicious miners can then extend their
> > favored chain using the other 79% of the mining power. This would
> > produce a scenario in which users are forced to choose between a
> > stable chain that violates a consensus rule and an unstable honest
> > chain that is completely unusable and which never pays out mining
> > rewards. I agree that SPV nodes and many wallets would make this even
> > worse especially in their current condition where they just trust the
> > hash rate/wallet provider and there are no fraud proofs.
> >
> > On Thu, Apr 18, 2019 at 8:25 PM ZmnSCPxj ZmnSCPxj at protonmail.com wrote:
> >
> > > Good morning Ethan,
> > > Sent with ProtonMail Secure Email.
> > > ??????? Original Message ???????
> > > On Friday, April 19, 2019 4:12 AM, Ethan Heilman eth3rs at gmail.com wrote:
> > >
> > > > I'm probably repeating a point which has been said before.
> > > >
> > > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> > > >
> > > > If this minority miner has > 10% of network hashrate, then the rule of
> > > > thumb above would, on average, give it the ability to disrupt the
> > > > SPV-using network.
> > > > Proposed rule:
> > > > Whenever a chainsplit occurs SPV clients should download and validate
> > > > the "longest chain" up to more than one block greater than the height
> > > > of the losing chain.
> > > > Lets say a block split causes chain A and chain B: Chain A is N blocks
> > > > long, chain B is M blocks long, and N < M. Then the SPV client should
> > > > download all the block data of N+1 blocks from Chain B to verify
> > > > availability of chain B. Once the SPV client has verified that chain B
> > > > is available they can use fraud proofs determine if chain B is valid.
> > >
> > > Let us then revert to the original scenario.
> > > Suppose a supermajority (90%) of miners decide to increase inflation of the currency.
> > > They do this by imposing the rule:
> > >
> > > 1.  For 1 block, the coinbase is 21,000,000 times the pre-fork coinbase value.
> > > 2.  For 9 blocks, the coinbase is the pre-fork value.
> > > 3.  Repeat this pattern every 10 blocks.
> > >
> > > The above is a hardfork.
> > > However, as they believe that SPV nodes dominate the economy, this mining supermajority believes it can take over the network hashpower and impose its will on the network.
> > > At height S+1, they begin the above rule.
> > > This implies that at heights S+1, S+11, S+21, s+31... the coinbase violates the pre-hardfork rules.
> > > At around height S+9, the minority miners generate an alternate block at height S+1.
> > > So SPV nodes download S+9 and S+8 on the longer chain, and see nothing wrong with those blocks.
> > > At around height S+18, the minority miners generate an alternate block at height S+2.
> > > So SPV nodes download S+18, S+17, S+16 and again see nothing wrong with those blocsk.
> > > This can go on for a good amount of time.
> > > With a "rare enough" inflation event, miners may even be able to spend some coinbases on SPV nodes that SPV nodes become unwilling to revert to the minority pre-hardfork chain, economically locking in the post-hardfork inflation.
> > > Again: every rule is an opportunity to loophole.
> > > Regards,
> > > ZmnSCPxj
> > >
> > > > An attacker could use this to force SPV clients to download 1 block
> > > > per block the attacker mines. This is strictly weaker security than
> > > > provided by a full-node because chain B will only be validated if the
> > > > client knows chain A exists. If the SPV client's view of the
> > > > blockchain is eclipsed then the client will never learn that chain A
> > > > exists and thus never validate chain B's availability nor will the
> > > > client be able to learn fraud proofs about chain B. A full node in
> > > > this circumstance would notice that the chain B is invalid and reject
> > > > it because a full node would not depend on fraud proofs. That being
> > > > said this rule would provide strictly more security than current SPV
> > > > clients.
> > > > On Thu, Apr 18, 2019 at 3:08 PM ZmnSCPxj via bitcoin-dev
> > > > bitcoin-dev at lists.linuxfoundation.org wrote:
> > > >
> > > > > Good morning Ruben,
> > > > > Sent with ProtonMail Secure Email.
> > > > > ??????? Original Message ???????
> > > > > On Thursday, April 18, 2019 9:44 PM, Ruben Somsen via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> > > > >
> > > > > > Simplified-Payment-Verification (SPV) is secure under the assumption
> > > > > > that the chain with the most Proof-of-Work (PoW) is valid. As many
> > > > > > have pointed out before, and attacks like Segwit2x have shown, this is
> > > > > > not a safe assumption. What I propose below improves this assumption
> > > > > > -- invalid blocks will be rejected as long as there are enough honest
> > > > > > miners to create a block within a reasonable time frame. This still
> > > > > > doesn?t fully inoculate SPV clients against dishonest miners, but is a
> > > > > > clear improvement over regular SPV (and compatible with the privacy
> > > > > > improvements of BIP157[0]).
> > > > > > The idea is that a fork is an indication of potential misbehavior --
> > > > > > its block header can serve as a PoW fraud proof. Conversely, the lack
> > > > > > of a fork is an indication that a block is valid. If a fork is created
> > > > > > from a block at height N, this means a subset of miners may disagree
> > > > > > on the validity of block N+1. If SPV clients download and verify this
> > > > > > block, they can judge for themselves whether or not the chain should
> > > > > > be rejected. Of course it could simply be a natural fork, in which
> > > > > > case we continue following the chain with the most PoW.
> > > > >
> > > > > I presume you mean a chain split?
> > > > >
> > > > > > The way Bitcoin currently works, it is impossible to verify the
> > > > > > validity of block N+1 without knowing the UTXO set at block N, even if
> > > > > > you are willing to assume that block N (and everything before it) is
> > > > > > valid. This would change with the introduction of UTXO set
> > > > > > commitments, allowing block N+1 to be validated by verifying whether
> > > > > > its inputs are present in the UTXO set that was committed to in block
> > > > > > N. An open question is whether a similar result can be achieved
> > > > > > without a soft fork that commits to the UTXO set[0][1].
> > > > > > If an invalid block is created and only 10% of the miners are honest,
> > > > > > on average it would take 100 minutes for a valid block to appear.
> > > > > > During this time, the SPV client will be following the invalid chain
> > > > > > and see roughly 9 confirmations before the chain gets rejected. It may
> > > > > > therefore be prudent to wait for a number of confirmations that
> > > > > > corresponds to the time it may take for the conservative percentage of
> > > > > > miners that you think may behave honestly to create a block (including
> > > > > > variance).
> > > > >
> > > > > I suppose a minority miner that wants to disrupt the network could simply create a valid block at block N+1 and deliberately ignore every other valid block at N+1, N+2, N+3 etc. that it did not create itself.
> > > > > If this minority miner has > 10% of network hashrate, then the rule of thumb above would, on average, give it the ability to disrupt the SPV-using network.
> > > > >
> > > > > > 10% of network hashrate to disrupt the SPV-using nodes would be a rather low bar to disruption.
> > > > > > Consider that SPV-using nodes would be disrupted, without this rule, only by >50% network hashrate.
> > > > >
> > > > > It is helpful to consider that every rule you impose is potentially a loophole by which a new attack is possible.
> > > > > Regards,
> > > > > ZmnSCPxj
> > > > > bitcoin-dev mailing list
> > > > > bitcoin-dev at lists.linuxfoundation.org
> > > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>

From ZmnSCPxj at protonmail.com  Fri Apr 19 04:48:23 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 19 Apr 2019 04:48:23 +0000
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
	<CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
Message-ID: <SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>

Good morning Ethan,

> My above email contains an error. The SPV client needs to only
> download S+1, not S+1 and S+2.
>
> I agree with you that a weakness of this approach is a miner can make
> SPV clients do substantially more work. However:
>
> 1.  Mining a block which will never be accepted is an expensive way to
>     make SPV clients download, validate and discard ~2-4 megabytes of
>     data. There are far less expensive ways of wasting the resources of
>     SPV clients. Its unclear why someone would want to do this instead of
>     just packeting full nodes or SPV servers like we saw with the recent
>     DDoS attacks against electrum servers.
>
> 2.  SPV clients may not even learn about these splits because it
>     requires that someone relay the split to them. Honest full nodes
>     should not relay such splits. To their bitcoin's worth the attacker
>     must also connect to lots of SPV clients.
>
> 3.  Having SPV clients slow down or become full nodes when a malicious
>     miner with significant mining power is attempting to disrupt the
>     network is probably a best case outcome. I would prefer this failure
>     mode to the current SPV behavior which is to just go with the
>     "longest" chain.


I understand.
It seems a reasonable point to do so.

As I understand it, this requires that UTXO commitments be mandatory.
In particular, if UTXO commitments were not mandatory, it would be trivial to force chainsplits at heights where a UTXO commitment was not made, and force an SPV node to download more blocks backwards until a block with a UTXO commitment is found.

More difficult is: how can an SPV node acquire the UTXO set at a particular block?
Fullnodes automatically update their UTXO set at each block they accept as tip.
Reversing the blocks to update the UTXO set at a particular past time would require a good amount of CPU and memory.
Thus any service that can provide the actual UTXO set at each block would potentially be attackable by simply requesting enough past blocks.


Regards,
ZmnSCPxj

From rsomsen at gmail.com  Fri Apr 19 13:23:50 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 19 Apr 2019 15:23:50 +0200
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
	<CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
	<SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>
Message-ID: <CAPv7TjYeuCA1WDHgEpkN1K8=NM88fw43HJeP5TeRE7q0Q+Chzg@mail.gmail.com>

Hi ZmnSCPxj and Ethan,

I apologize if my initial explanation was confusing, but it looks like
you figured it out. For every fork, SPV clients only have to download
one block. If there is a fork after block N, this means there are two
blocks at N+1. You only download and verify N+1 from the longer chain.

>Mining a block which will never be accepted is an expensive way to make SPV clients download validate and discard ~2-4 megabytes of data

Absolutely, hence the name "PoW fraud proof". It gets naturally
created by honest miners and is prohibitively expensive to forge.

>SPV clients may not even learn about these splits because it requires that someone relay the split to them. Honest full nodes should not relay such splits.

You could perform a fully valid repeated 1-block reorg from the top of
the chain. So at least theoretically you could get an honest network
to relay every split.

>Having SPV clients slow down or become full nodes when a malicious miner with significant mining power is attempting to disrupt the network is probably a best case outcome.

That is an excellent point.

>As I understand it, this requires that UTXO commitments be mandatory.

Perhaps UTXO sets can be made useful without committing them. I have
some very loose thoughts on the subject, I consider it an open
question.

> More difficult is: how can an SPV node acquire the UTXO set at a particular block?

I think you are asking fair questions about how the UTXO set
commitments would work in practice, and how viable that makes it. I'm
not sure. The most comprehensive work I have seen on this topic has
been the utreexo proposal by Tadge Dryja:
https://www.youtube.com/watch?v=edRun-6ubCc

Actually, now that I think about it... As an alternative to UTXO set
commitments, the old fraud proofs idea for segwit can be applied here.

We get miners to commit to the location of the UTXOs that are being
spent (e.g. transaction 5 in block 12). This allows full nodes to
succinctly prove invalidity to SPV clients in the following ways:

- a committed location does not contain the stated UTXO
- the UTXO has already been spent in a prior block

If no fraud proofs are given, then the inputs can be assumed to be valid.

As you may recall, these kinds of fraud proofs were abandoned mainly
because the data unavailability claim could only be verified by
downloading the data, resulting in a DoS vector where all blocks had
to be downloaded. This problem does not seem to apply here, because we
are only interested in blocks which have forks, so it's more doable to
download them.

-- Ruben Somsen

On Fri, Apr 19, 2019 at 6:48 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ethan,
>
> > My above email contains an error. The SPV client needs to only
> > download S+1, not S+1 and S+2.
> >
> > I agree with you that a weakness of this approach is a miner can make
> > SPV clients do substantially more work. However:
> >
> > 1.  Mining a block which will never be accepted is an expensive way to
> >     make SPV clients download, validate and discard ~2-4 megabytes of
> >     data. There are far less expensive ways of wasting the resources of
> >     SPV clients. Its unclear why someone would want to do this instead of
> >     just packeting full nodes or SPV servers like we saw with the recent
> >     DDoS attacks against electrum servers.
> >
> > 2.  SPV clients may not even learn about these splits because it
> >     requires that someone relay the split to them. Honest full nodes
> >     should not relay such splits. To their bitcoin's worth the attacker
> >     must also connect to lots of SPV clients.
> >
> > 3.  Having SPV clients slow down or become full nodes when a malicious
> >     miner with significant mining power is attempting to disrupt the
> >     network is probably a best case outcome. I would prefer this failure
> >     mode to the current SPV behavior which is to just go with the
> >     "longest" chain.
>
>
> I understand.
> It seems a reasonable point to do so.
>
> As I understand it, this requires that UTXO commitments be mandatory.
> In particular, if UTXO commitments were not mandatory, it would be trivial to force chainsplits at heights where a UTXO commitment was not made, and force an SPV node to download more blocks backwards until a block with a UTXO commitment is found.
>
> More difficult is: how can an SPV node acquire the UTXO set at a particular block?
> Fullnodes automatically update their UTXO set at each block they accept as tip.
> Reversing the blocks to update the UTXO set at a particular past time would require a good amount of CPU and memory.
> Thus any service that can provide the actual UTXO set at each block would potentially be attackable by simply requesting enough past blocks.
>
>
> Regards,
> ZmnSCPxj

From michele at federici.tech  Fri Apr 19 11:53:51 2019
From: michele at federici.tech (Michele Federici)
Date: Fri, 19 Apr 2019 13:53:51 +0200
Subject: [bitcoin-dev] Using the same public keys,
 the p2sh returned by `addmultisigaddress` differs from the one
 returned by `createmultisigaddress`
Message-ID: <298ab7b97f0f34b6ef0e4b8345a942b3d77296d5.camel@federici.tech>

Hi everyone,

I'm writing here because I didn't find any resources in the docs or
somewhere else online explaining this, I don't get if this is a bug or
I'm missing something.

I was working on a function to derive the pay-to-script-hash from a
multisig script and I was checking the results against the bitcoin
core's `addmultisigaddress` output, although I was quite sure that my
implementation was correct, my output address was different.
By chance, I then tried the `createmultisigaddress` method, using the
same public keys, and this time the output was matching with mine.

I thought the outputs of `addmultisigaddress` and
`createmultisigaddress` were supposed to be the same, but instead are
inconsistent from each other:

```
bitcoin-cli addmultisigaddress 1
'["045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c
e382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d","02ac46
c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831","0224a4dc
5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07"]'
{
"address": "36ULucjWUTrDvaJzCyhFoVbDoNS6Zum2Du",
"redeemScript":
"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c
0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4
6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc
5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae"
}
```

```
bitcoin-cli createmultisig 1
'["045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c
e382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d","02ac46
c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831","0224a4dc
5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07"]'
{
"address": "3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1",
"redeemScript":
"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c
0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4
6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc
5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae"
}
```

I was also pretty confused by the fact that the `redeemScript` is the
same, only the addresses are different, and calling `decodescript` with
it I get the same address as `createmultisig`:

```
bitcoin-cli decodescript
"5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c
0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4
6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc
5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae"
{
"asm": "1
045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0ce38
2458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d
02ac46c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831
0224a4dc5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07 3
OP_CHECKMULTISIG",
"reqSigs": 1,
"type": "multisig",
"addresses": [
"12PfkcWheYsfFddWfHhaXpFDVx78gnKQ9k",
"1AYLXzXd6N2avqW4j8Gyhb8jb2jXvNPyuV",
"1PWsxtcBMRHTSX2L7wrXgwnFigHD3KhbFT"
],
"p2sh": "3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1"
}
```

I don't understand, how can this be possible?

Thank you,
Michele
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: This is a digitally signed message part
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190419/58848b69/attachment.sig>

From achow101-lists at achow101.com  Fri Apr 19 14:30:03 2019
From: achow101-lists at achow101.com (Andrew Chow)
Date: Fri, 19 Apr 2019 14:30:03 +0000
Subject: [bitcoin-dev] Using the same public keys,
	the p2sh returned by `addmultisigaddress` differs from the one
	returned by `createmultisigaddress`
In-Reply-To: <298ab7b97f0f34b6ef0e4b8345a942b3d77296d5.camel@federici.tech>
References: <298ab7b97f0f34b6ef0e4b8345a942b3d77296d5.camel@federici.tech>
Message-ID: <MQxjTwjN3sOXFBr9KDzvHzYS3dSqHsG0M-h2UmAAF3nJRfb8UJxukDVMj9asr0nehKFz17kiMq6siGUgWLTSKVQ8OerdhISeu81NnfL_xa8=@achow101.com>

Hi Michele,

You are seeing this discrepancy due to the address types in use. addmultisigaddress uses the default address type of the wallet, which is p2sh-segwit. createmultisig uses a default address type of legacy. To have createmultisig get addmultisigaddress's result, you need to add the string "p2sh-segwit" to the end of your command. To have addmultisigaddress get createmultisig's result, you need to add the string "legacy" to the end of your command.

On 4/19/19 7:53 AM, Michele Federici via bitcoin-dev wrote:

> Hi everyone,
>
> I'm writing here because I didn't find any resources in the docs or
> somewhere else online explaining this, I don't get if this is a bug or
> I'm missing something.
>
> I was working on a function to derive the pay-to-script-hash from a
> multisig script and I was checking the results against the bitcoin
> core's `addmultisigaddress` output, although I was quite sure that my
> implementation was correct, my output address was different.
> By chance, I then tried the `createmultisigaddress` method, using the
> same public keys, and this time the output was matching with mine.
>
> I thought the outputs of `addmultisigaddress` and
> `createmultisigaddress` were supposed to be the same, but instead are
> inconsistent from each other:
>
> ```
> bitcoin-cli addmultisigaddress 1
> '["045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c
> e382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d","02ac46
> c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831","0224a4dc
> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07"]'
> {
> "address": "36ULucjWUTrDvaJzCyhFoVbDoNS6Zum2Du",
> "redeemScript":
> "5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c
> 0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4
> 6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc
> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae"
> }
> ```
>
> ```
> bitcoin-cli createmultisig 1
> '["045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0c
> e382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d","02ac46
> c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831","0224a4dc
> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07"]'
> {
> "address": "3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1",
> "redeemScript":
> "5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c
> 0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4
> 6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc
> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae"
> }
> ```
>
> I was also pretty confused by the fact that the `redeemScript` is the
> same, only the addresses are different, and calling `decodescript` with
> it I get the same address as `createmultisig`:
>
> ```
> bitcoin-cli decodescript
> "5141045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c
> 0ce382458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d2102ac4
> 6c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831210224a4dc
> 5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e0753ae"
> {
> "asm": "1
> 045897fee25bd7c5692510b2f50fcae9aa20fbc4d49d59814f4c7fdb5c4bc6eb1c0ce38
> 2458f9588e922e0d509ed8d34856787380075b00418b02e0bf7c652ef9d
> 02ac46c6d74d15e60f4f1035ff07ef740aca1d68d55ba0b8d336a73d7a35858831
> 0224a4dc5620714a9ecf67a09583d1e4c04f5bedb8ecea99028da05bb15a2a7e07 3
> OP_CHECKMULTISIG",
> "reqSigs": 1,
> "type": "multisig",
> "addresses": [
> "12PfkcWheYsfFddWfHhaXpFDVx78gnKQ9k",
> "1AYLXzXd6N2avqW4j8Gyhb8jb2jXvNPyuV",
> "1PWsxtcBMRHTSX2L7wrXgwnFigHD3KhbFT"
> ],
> "p2sh": "3GiimyxF1R5VixfBFAbQZbuy9EesD2r6n1"
> }
> ```
>
> I don't understand, how can this be possible?
>
> Thank you,
> Michele
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190419/e3db3ec9/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat Apr 20 01:59:25 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 20 Apr 2019 01:59:25 +0000
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <CAPv7TjYeuCA1WDHgEpkN1K8=NM88fw43HJeP5TeRE7q0Q+Chzg@mail.gmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
	<CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
	<SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>
	<CAPv7TjYeuCA1WDHgEpkN1K8=NM88fw43HJeP5TeRE7q0Q+Chzg@mail.gmail.com>
Message-ID: <EWP8Pzp8wS_Nh145H_g4w3yJaelXmm6UB12sa8MC2EsMbYFhm53C_kaOvjztksQpCNBBT0D0zuTbKHnEfEatlLKIa3whMlLZrihawZux1UY=@protonmail.com>

Good morning,


> > As I understand it, this requires that UTXO commitments be mandatory.
>
> Perhaps UTXO sets can be made useful without committing them. I have
> some very loose thoughts on the subject, I consider it an open
> question.

There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie.
The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work (and probably best to fold it into the Bitcoin blockchain if so).

You would get the UTXO commitment from the previous block (if the UTXO commitment is in the coinbase, then all you need is the Merkle proof of the coinbase).


>
> > More difficult is: how can an SPV node acquire the UTXO set at a particular block?
>
> I think you are asking fair questions about how the UTXO set
> commitments would work in practice, and how viable that makes it. I'm
> not sure. The most comprehensive work I have seen on this topic has
> been the utreexo proposal by Tadge Dryja:
> https://www.youtube.com/watch?v=edRun-6ubCc
>
> Actually, now that I think about it... As an alternative to UTXO set
> commitments, the old fraud proofs idea for segwit can be applied here.
>
> We get miners to commit to the location of the UTXOs that are being
> spent (e.g. transaction 5 in block 12). This allows full nodes to
> succinctly prove invalidity to SPV clients in the following ways:
>
> -   a committed location does not contain the stated UTXO
> -   the UTXO has already been spent in a prior block
>
>     If no fraud proofs are given, then the inputs can be assumed to be valid.
>
>     As you may recall, these kinds of fraud proofs were abandoned mainly
>     because the data unavailability claim could only be verified by
>     downloading the data, resulting in a DoS vector where all blocks had
>     to be downloaded. This problem does not seem to apply here, because we
>     are only interested in blocks which have forks, so it's more doable to
>     download them.

This makes no sense.
In order to validate block N, you need to know that every UTXO spent by a transaction in block N is valid.
The UTXO you want to validate is located in some other block, not on the single block you are verifying.

Thus the non-existent fraud proof can only be validated by loading the block of the UTXO purported to be spent, and every block between that and the current block you are verifying, i.e. fullnode.
Either that or you trust that every peer you have is not omitting the proof.

Regards,
ZmnSCPxj

From rsomsen at gmail.com  Sat Apr 20 03:26:03 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Sat, 20 Apr 2019 05:26:03 +0200
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <EWP8Pzp8wS_Nh145H_g4w3yJaelXmm6UB12sa8MC2EsMbYFhm53C_kaOvjztksQpCNBBT0D0zuTbKHnEfEatlLKIa3whMlLZrihawZux1UY=@protonmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<-tCD0qh97dAiz-VGkDQTwSbSQIm9cLF1kOzaWCnUDTI4dKdsmMgHJsGDntQhABZdE2_yBYpPAAdulm8EpdNxOB8o3lI6ZQJBJZWF1INzUrE=@protonmail.com>
	<CAEM=y+W==_+AW6ga9WMf=aAX-xPGUfhEJQFvUtdFodGGv-6eAg@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
	<CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
	<SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>
	<CAPv7TjYeuCA1WDHgEpkN1K8=NM88fw43HJeP5TeRE7q0Q+Chzg@mail.gmail.com>
	<EWP8Pzp8wS_Nh145H_g4w3yJaelXmm6UB12sa8MC2EsMbYFhm53C_kaOvjztksQpCNBBT0D0zuTbKHnEfEatlLKIa3whMlLZrihawZux1UY=@protonmail.com>
Message-ID: <CAPv7TjbbYkXf62ApadMgOLef-Z9xTU1HQy_f+L3vNVUfRhChrw@mail.gmail.com>

Hi ZmnSCPxj,

>There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie
>The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work

Olaoluwa Osuntokun's BIP157 manages to function without a commitment:
"If the client receives conflicting filter headers from different
peers for any block and filter type, it SHOULD interrogate them to
determine which is faulty."

I am wondering if the same logic can be applied to UTXO sets or the
fraud proofs I just described.

>This makes no sense
>or you trust that every peer you have is not omitting the proof.

It's the latter, you trust every peer you have is not omitting the
proof. It requires one honest peer. The reason this is acceptable is
because you're already making that assumption. If none of your peers
are honest, you have no guarantee of hearing about the chain with the
most PoW.

Again, this is not a new observation. I am just recalling the fraud
proof debate from when it was being considered for segwit (though of
course it's possible I got some details wrong).

-- Ruben Somsen

On Sat, Apr 20, 2019 at 3:59 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning,
>
>
> > > As I understand it, this requires that UTXO commitments be mandatory.
> >
> > Perhaps UTXO sets can be made useful without committing them. I have
> > some very loose thoughts on the subject, I consider it an open
> > question.
>
> There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie.
> The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work (and probably best to fold it into the Bitcoin blockchain if so).
>
> You would get the UTXO commitment from the previous block (if the UTXO commitment is in the coinbase, then all you need is the Merkle proof of the coinbase).
>
>
> >
> > > More difficult is: how can an SPV node acquire the UTXO set at a particular block?
> >
> > I think you are asking fair questions about how the UTXO set
> > commitments would work in practice, and how viable that makes it. I'm
> > not sure. The most comprehensive work I have seen on this topic has
> > been the utreexo proposal by Tadge Dryja:
> > https://www.youtube.com/watch?v=edRun-6ubCc
> >
> > Actually, now that I think about it... As an alternative to UTXO set
> > commitments, the old fraud proofs idea for segwit can be applied here.
> >
> > We get miners to commit to the location of the UTXOs that are being
> > spent (e.g. transaction 5 in block 12). This allows full nodes to
> > succinctly prove invalidity to SPV clients in the following ways:
> >
> > -   a committed location does not contain the stated UTXO
> > -   the UTXO has already been spent in a prior block
> >
> >     If no fraud proofs are given, then the inputs can be assumed to be valid.
> >
> >     As you may recall, these kinds of fraud proofs were abandoned mainly
> >     because the data unavailability claim could only be verified by
> >     downloading the data, resulting in a DoS vector where all blocks had
> >     to be downloaded. This problem does not seem to apply here, because we
> >     are only interested in blocks which have forks, so it's more doable to
> >     download them.
>
> This makes no sense.
> In order to validate block N, you need to know that every UTXO spent by a transaction in block N is valid.
> The UTXO you want to validate is located in some other block, not on the single block you are verifying.
>
> Thus the non-existent fraud proof can only be validated by loading the block of the UTXO purported to be spent, and every block between that and the current block you are verifying, i.e. fullnode.
> Either that or you trust that every peer you have is not omitting the proof.
>
> Regards,
> ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sat Apr 20 04:45:19 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 20 Apr 2019 04:45:19 +0000
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <CAPv7TjbbYkXf62ApadMgOLef-Z9xTU1HQy_f+L3vNVUfRhChrw@mail.gmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
	<CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
	<SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>
	<CAPv7TjYeuCA1WDHgEpkN1K8=NM88fw43HJeP5TeRE7q0Q+Chzg@mail.gmail.com>
	<EWP8Pzp8wS_Nh145H_g4w3yJaelXmm6UB12sa8MC2EsMbYFhm53C_kaOvjztksQpCNBBT0D0zuTbKHnEfEatlLKIa3whMlLZrihawZux1UY=@protonmail.com>
	<CAPv7TjbbYkXf62ApadMgOLef-Z9xTU1HQy_f+L3vNVUfRhChrw@mail.gmail.com>
Message-ID: <IbAS3IZpoD0wJKQvVekHDjHJL0R97CSGKwyy3ScU5yl2NIDSqBsmUJqvU_M7b0MRRu2u9aQXaof0zTs1OC562vkYu8LzV7vSDM6Pj5j55yI=@protonmail.com>

Good morning Ruben,

> Hi ZmnSCPxj,
>
> > There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie
> > The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work
>
> Olaoluwa Osuntokun's BIP157 manages to function without a commitment:
> "If the client receives conflicting filter headers from different
> peers for any block and filter type, it SHOULD interrogate them to
> determine which is faulty."
>
> I am wondering if the same logic can be applied to UTXO sets or the
> fraud proofs I just described.

UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.

What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.

UTXO sets summarize data in the entire blockchain, hence proper validation requires downloading the entire blockchain.
Thus it cannot be a comparison point.


> > This makes no sense
> > or you trust that every peer you have is not omitting the proof.
>
> It's the latter, you trust every peer you have is not omitting the
> proof. It requires one honest peer. The reason this is acceptable is
> because you're already making that assumption. If none of your peers
> are honest, you have no guarantee of hearing about the chain with the
> most PoW.

But peers can be set up to allow you to hear of all chains while denying you proof of the invalidity of some UTXO.
This is precisely the "data unavailability claim" that shot down the previous fraud proofs (i.e. absence of proof is not proof of absence, and proof of UTXO validity was defined by proof of absence of any intervening spend of the UTXO).

Perhaps in combination with BIP157/158 it may be possible, if the filters contain UTXO spends and a BIP158 filter was committed to on-chain.
Then a proof of absence could be done by revealing all the BIP158 filters from the UTXO creation to the block being validated, as well as the blocks whose BIP158 filters matched the UTXO and revealing that no, they actually do not spend the UTXO.

--

Tangentially, we cannot just magically commit to anything on the blockchain.
Header blocks commit to block data and commit to some other header block.
All those header blocks and the block data need to be stored and transmitted over the network somehow, even though they are "only" being committed to.
Thus, if you are adding new information to be committed, that may increase the resource usage of fullnodes.

So if UTXO set commitments, or utreexo commitments, or BIP158 filter digests, etc. are committed to in the coinbase, they have to be stored somehow in fullnodes the entire UUTXO set, or the actual utreexo structure, or the actual BIP158 filter, etc. at each block.
Otherwise it would be pointless to store those commitments since it would not be possible to somehow acquire the data being committed to after-the-fact.

This is probably still better than BIP37 but we should still be aware the additional load on fullnodes.

Regards,
ZmnSCPxj

From rsomsen at gmail.com  Sun Apr 21 09:13:00 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Sun, 21 Apr 2019 11:13:00 +0200
Subject: [bitcoin-dev] Improving SPV security with PoW fraud proofs
In-Reply-To: <IbAS3IZpoD0wJKQvVekHDjHJL0R97CSGKwyy3ScU5yl2NIDSqBsmUJqvU_M7b0MRRu2u9aQXaof0zTs1OC562vkYu8LzV7vSDM6Pj5j55yI=@protonmail.com>
References: <CAPv7TjYspkc1M=TKmBK8k0Zy857=bR7jSTarRDCr_5m2ktYHDQ@mail.gmail.com>
	<xqVUmHu0RXeogboFL8ivsZywPQKEqLCsUZTV1NbsxNB4CYqrNqS8TpYsP8PJSowIGUeq8Nu1XPVd9N9Exg5Is11767ytI0Sq4lVp9MGdII4=@protonmail.com>
	<CAEM=y+WVQz5x916sjCjWVmeEbRp4NoTyryxSH7uKNTHYz+Sdnw@mail.gmail.com>
	<xNr214GpQ7_9duD4RV0j2nufLLMff4ipqPcZEAsDIsjLwWDan9UijTADW0iJ76pUuaXgYth_BHla-p6G3SOksaySbDZXKhQPLvIfLqo0JeA=@protonmail.com>
	<CAEM=y+V0tMYBBLJhePfGUzyFNXVe9hr0F3QrX9JYFrDg5N1qXg@mail.gmail.com>
	<SHsLdVIPZcn9yyZN9Hx3moQmWXY-2yC99tEsFllksV-66ZrJNMQfDr0qHK_rCZuBcEa8gIcnThkvgRDkU6BYQ_mxX7JxfI_uM6ndOF26ofk=@protonmail.com>
	<CAPv7TjYeuCA1WDHgEpkN1K8=NM88fw43HJeP5TeRE7q0Q+Chzg@mail.gmail.com>
	<EWP8Pzp8wS_Nh145H_g4w3yJaelXmm6UB12sa8MC2EsMbYFhm53C_kaOvjztksQpCNBBT0D0zuTbKHnEfEatlLKIa3whMlLZrihawZux1UY=@protonmail.com>
	<CAPv7TjbbYkXf62ApadMgOLef-Z9xTU1HQy_f+L3vNVUfRhChrw@mail.gmail.com>
	<IbAS3IZpoD0wJKQvVekHDjHJL0R97CSGKwyy3ScU5yl2NIDSqBsmUJqvU_M7b0MRRu2u9aQXaof0zTs1OC562vkYu8LzV7vSDM6Pj5j55yI=@protonmail.com>
Message-ID: <CAPv7TjbFqJHL+OajCKMNkd=wYhO49g=s2qCjEOROygMTj7DLqQ@mail.gmail.com>

Hi ZmnSCPxj,


Allow me to reply to your post in mixed order (fraud proofs first):


>But peers can be set up to allow you to hear of all chains while denying you proof of the invalidity of some UTXO.

I don't believe this is fundamentally different. In either scenario
you end up on the wrong chain if all your peers are lying to you. One
happens by omission of a fraud proof, while the other happens by
omission of a valid longest chain.


>This is precisely the "data unavailability claim" that shot down the previous fraud proofs

The "data unavailability" issue I was referring to, and which I
believe is the reason why fraud proofs were abandoned, is the
following:

- Alice downloads a block with her full node, but the block is
incomplete (e.g. a transaction is missing).
- Alice reports this to Bob's SPV fraud proof client, who verifies
this by requesting the transaction from the network.
- If Bob can't download it, he rejects the block.
- If Bob can download it, either Alice was malicious, or a miner was
temporarily withholding the data.
- Since Bob can't be certain Alice was being malicious, Bob can't ban
her, which results in a DoS vector where SPV fraud proof clients can
be forced to download all blocks.

We circumvent the data unavailability problem here completely, since
we are only questioning the validity of blocks which are involved in a
fork (expensive and/or rare), and we are simply always downloading
them in full.

If my arguments above hold up, we can use fraud proof commitments as
described in segwit BIP141 [0] instead of UTXO set commitments, which
seems like the more elegant way to achieve the desired outcome.


>Perhaps in combination with BIP157/158 it may be possible, if the filters contain UTXO spends and a BIP158 filter was committed to on-chain. Then a proof of absence could be done by revealing all the BIP158 filters from the UTXO creation to the block being validated, as well as the blocks whose BIP158 filters matched the UTXO and revealing that no, they actually do not spend the UTXO.

Yes, I mentioned something similar to Laolu, but it does seem
computationally expensive to run every input in a block through the
filter of every past block. The fact that BIP157/158 can function
without commitments is also why I suspected we may not necessarily
need UTXO set commitments.


>UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.

It seems to me you can validate uncommitted UTXO sets by comparing
them. Download and compare UTXO set hashes from multiple peers. If
they disagree on a certain block, download that block and the relevant
merkle path(s) from the previous block's UTXO set, and then verify who
is right. Ban the peer who lied. Note that unlike fraud proofs, it is
not possible to lie by omission, but it does assume one of your peers
is honest. Of course this does nothing to dispute your earlier point
that this may not be all that efficient (e.g. full nodes keeping
merkle paths of all prior states).


>What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.
>UTXO sets summarize data in the entire blockchain, hence proper validation requires downloading the entire blockchain.
Thus it cannot be a comparison point.

It's still possible to lie by omission. Let's say a miner spends some
coins in block N, and spends the exact same coins again in block N+1,
making block N+1 invalid. If the filter for block N is maliciously
constructed, you won't notice the spend in block N, causing you to
think block N+1 is valid. In short, you're still relying on one of
your peers to give you a correct filter. If all your peers lie, you
can always be deceived.


>Tangentially, we cannot just magically commit to anything on the blockchain. [...] if you are adding new information to be committed, that may increase the resource usage of fullnodes. [...] This is probably still better than BIP37 but we should still be aware the additional load on fullnodes.

I agree with all this.


To summarize, this is my current understanding of our options for
enabling light clients to verify a single block in isolation:
1. UTXO set commitments (complex, more resource usage to full nodes)
2. BIP157/158 commitments (expensive for clients to check all filters
to get exclusion proofs)
3. BIP141 fraud proof commitments (assumes fraud proofs will be passed
on to the SPV client)

The debate is still open on whether the options above can be done
without actually committing them into blocks via a soft fork. My
current hunch is "yes" for 1 and 2, and "no" for 3, which would be
unfortunate, because 3 currently seems to me like the more elegant
solution.


-- Ruben Somsen


[0] https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#Compact_fraud_proof_for_SPV_nodes


>UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.
>What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.

UTXO sets summarize data in the entire blockchain, hence proper
validation requires downloading the entire blockchain.
Thus it cannot be a comparison point.


> > This makes no sense
> > or you trust that every peer you have is not omitting the proof.
>
> It's the latter, you trust every peer you have is not omitting the
> proof. It requires one honest peer. The reason this is acceptable is
> because you're already making that assumption. If none of your peers
> are honest, you have no guarantee of hearing about the chain with the
> most PoW.

But peers can be set up to allow you to hear of all chains while
denying you proof of the invalidity of some UTXO.
This is precisely the "data unavailability claim" that shot down the
previous fraud proofs (i.e. absence of proof is not proof of absence,
and proof of UTXO validity was defined by proof of absence of any
intervening spend of the UTXO).

Perhaps in combination with BIP157/158 it may be possible, if the
filters contain UTXO spends and a BIP158 filter was committed to
on-chain.
Then a proof of absence could be done by revealing all the BIP158
filters from the UTXO creation to the block being validated, as well
as the blocks whose BIP158 filters matched the UTXO and revealing that
no, they actually do not spend the UTXO.

--

Tangentially, we cannot just magically commit to anything on the blockchain.
Header blocks commit to block data and commit to some other header block.
All those header blocks and the block data need to be stored and
transmitted over the network somehow, even though they are "only"
being committed to.
Thus, if you are adding new information to be committed, that may
increase the resource usage of fullnodes.

So if UTXO set commitments, or utreexo commitments, or BIP158 filter
digests, etc. are committed to in the coinbase, they have to be stored
somehow in fullnodes the entire UUTXO set, or the actual utreexo
structure, or the actual BIP158 filter, etc. at each block.
Otherwise it would be pointless to store those commitments since it
would not be possible to somehow acquire the data being committed to
after-the-fact.

This is probably still better than BIP37 but we should still be aware
the additional load on fullnodes.

Regards,
ZmnSCPxj

On Sat, Apr 20, 2019 at 6:45 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ruben,
>
> > Hi ZmnSCPxj,
> >
> > > There is no safe way to use UTXO sets without identifying who is telling you those sets are valid, or making it expensive to lie
> > > The first option requires trust and is weaker than SPV, the second requires committing to a proof-of-work
> >
> > Olaoluwa Osuntokun's BIP157 manages to function without a commitment:
> > "If the client receives conflicting filter headers from different
> > peers for any block and filter type, it SHOULD interrogate them to
> > determine which is faulty."
> >
> > I am wondering if the same logic can be applied to UTXO sets or the
> > fraud proofs I just described.
>
> UTXO sets can only be validated by actually running the entire blockchain, i.e. fullnoding.
>
> What BIP157 does is summarize data that is within a block, thus validating them can be done simply by downloading the block in question.
>
> UTXO sets summarize data in the entire blockchain, hence proper validation requires downloading the entire blockchain.
> Thus it cannot be a comparison point.
>
>
> > > This makes no sense
> > > or you trust that every peer you have is not omitting the proof.
> >
> > It's the latter, you trust every peer you have is not omitting the
> > proof. It requires one honest peer. The reason this is acceptable is
> > because you're already making that assumption. If none of your peers
> > are honest, you have no guarantee of hearing about the chain with the
> > most PoW.
>
> But peers can be set up to allow you to hear of all chains while denying you proof of the invalidity of some UTXO.
> This is precisely the "data unavailability claim" that shot down the previous fraud proofs (i.e. absence of proof is not proof of absence, and proof of UTXO validity was defined by proof of absence of any intervening spend of the UTXO).
>
> Perhaps in combination with BIP157/158 it may be possible, if the filters contain UTXO spends and a BIP158 filter was committed to on-chain.
> Then a proof of absence could be done by revealing all the BIP158 filters from the UTXO creation to the block being validated, as well as the blocks whose BIP158 filters matched the UTXO and revealing that no, they actually do not spend the UTXO.
>
> --
>
> Tangentially, we cannot just magically commit to anything on the blockchain.
> Header blocks commit to block data and commit to some other header block.
> All those header blocks and the block data need to be stored and transmitted over the network somehow, even though they are "only" being committed to.
> Thus, if you are adding new information to be committed, that may increase the resource usage of fullnodes.
>
> So if UTXO set commitments, or utreexo commitments, or BIP158 filter digests, etc. are committed to in the coinbase, they have to be stored somehow in fullnodes the entire UUTXO set, or the actual utreexo structure, or the actual BIP158 filter, etc. at each block.
> Otherwise it would be pointless to store those commitments since it would not be possible to somehow acquire the data being committed to after-the-fact.
>
> This is probably still better than BIP37 but we should still be aware the additional load on fullnodes.
>
> Regards,
> ZmnSCPxj

From ZmnSCPxj at protonmail.com  Mon Apr 22 00:07:20 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 22 Apr 2019 00:07:20 +0000
Subject: [bitcoin-dev] Payjoin2swap: Enabling Payjoin Without Merchant
	Purchases
Message-ID: <pOqJuLTCi90Cz27QqCYHFBdkKBA0Hc0IY2zplQ0uFILWWqLULdspR6rA6Q_2oMC9yWKrB8p5VX7woQUYhNpV_cjDCcKCJajGsr3gNrcbYho=@protonmail.com>

Introduction
============

Payjoin vs. Existing Equal-Valued CoinJoins
-------------------------------------------

Any non-equal-value coinjoin is easily solvable via [value sudoku](https://www.coinjoinsudoku.com/advisory/).
Thus, common deployments of coinjoin use equal-value coinjoins.

Equal-valued coinjoins are very obvious onchain: it has many outputs that are of equal value, or have multiples of some base value.
Although it is in practice difficult to correlate the inputs to outputs, it is still an open indication to blockchain analysis that a break occurs in their analysis.
However, equal-valued coinjoins are needed to break value sudoku.

The exception to value sudoku for non-equal value coinjoins is if value is transferred between participants in the coinjoin, i.e. the Payjoin proposal.

Payjoin transactions are difficult to differentiate from non-payjoin transactions, which greatly increases the effort required for blockchain analysis.
In particular, it breaks the common-input heuristic (UTXOs that are spent together stay together).
They may cause blockchain analysis to go astray without blockchain analysis being able to pinpoint which transaction broke the analysis.

Payjoin For Hodlers?
--------------------

As payjoin transfers Bitcoin value, it is planned to be used for payments (i.e. spending) rather than hodling.
The issue is that it appears that payjoin cannot be used by hodlers, since hodlers are not interested in paying, but in saving.

Yet hodlers want to retain their privacy also.
They do not want their exchange snooping on them and finding out that they have not moved their coins from cold storage.
For long enough timeframes, a KYC-demanding exchange might eventually get hacked or hostilely taken over, with the identifying information of the hodler in the logs of the exchange.
The hodler would prefer to have those who have gotten this identifying information to believe that the value has been spent elsewhere, rather than in UTXOs that have not been moved.

At the same time, they are not interested in purchasing items and therefore cannot utilize payjoin as-is.
After all, payjoin requires a transfer of value from one participant to another.
(they can continue to utilize existing equal-value coinjoins, if those are acceptable to the hodler)

The key insight here is that hodlers "buy Bitcoin".
Thus there is still the possibility of hodlers using payjoin, by using bitcoins in a payjoin to buy bitcoins of similar value.

The same insight underlies the observation that, as long as LN-to-onchain swap services exist, it is possible to gain incoming capacity on Lightning channels immediately if one has bitcoins already.
One can observe that one gains capacity to receive on Lightning if one spends on Lightning: the technique, then, is to spend BTC on Lightning to buy BTC off Lightning (i.e. onchain).
We shall see later that Lightning has some parallels to payjoin2swap.

Using payjoin for purchases of bitcoins using bitcoins has the massive advantage that we can build software that interacts solely with the Bitcoin blockchain.
This simplifies the deployment of payjoin for bitcoin-to-bitcoin swaps, as payjoin for merchant deployment requires interaction of the Bitcoin blockchain, and the infrastructure of the merchant.
As most merchants are more interested in their product rather than in Bitcoin technology, we can expect that deployment of payjoin will be slower compared to a payjoin2swap deployment made by Bitcoin tech weenies.

References
----------

* This idea is not original to me: a [feature request on AdamISZ/CoinSwapCS](https://github.com/AdamISZ/CoinSwapCS/issues/52) by Chris Belcher proposes P2EP for CoinSwapCS.
  However, I have not found any follow up on this idea and the fleshed-out protocol and thoughts below are my own.

Payjoin2swap On the Blockchain
==============================

In a payjoin2swap, what is visible on the blockchain is two transactions that occur at about the same time.
They appear to pay two different addresses, and each has a change output.
The payment addresses are then spent almost immediately, as a self-to-self transfer (one input, one output), while the change output may or may not get spent any time soon.
If the wallet used follows [ZeroLink](https://github.com/nopara73/ZeroLink) strictly, then the four addresses (two payment addresses, two change addresses) do not seem to be related, and there would be no reason to think that the two transactions are related.

In reality, one payout and one change address each are actually owned by the two participants in a payjoin2swap.

These two transactions all pay out to P2WPKH addresses, and (if the payjoin2swap protocol is followed correctly) we do not see anything special: no 2-of-2, no HTLCs, nothing.
This is possible even without Schnorr-based signature schemes, by use of [2p-ECDSA](https://eprint.iacr.org/2017/552.pdf) to create a 2-of-2 multisig in ECDSA among the participants that operates the protocol.
Any special contracts are hosted inside a temporary offchain cryptocurrency system (slightly like a Lightning channel), and are not exposed if the protocol runs to completion.
The transactions have an `nLockTime` near the time they are confirmed onchain, looking like Bitcoin Core behavior.

Participants in a payjoin2swap need to own two UTXOs onchain; the values need not be equal.

Example 1
---------

Suppose Alice owns a 900 mBTC and a 10 mBTC UTXO.
And suppose Bob owns a 15 mBTC and 4 mBTC UTXO.
Both of the above users would have difficulty with current Wasabi coinjoins which use equal values of around 100mBTC: Alice would have to run several rounds, while Bob cannot participate at all.

What would be seen onchain would be:

1.  Alice 900mBTC, Bob 4mBTC -> Alice&Bob 903mBTC, Bob 1mBTC
2.  Alice 10mBTC, Bob 15mBTC -> Alice 7mBTC, Alice&Bob 18mBTC

Followed quickly by:

1.  Alice&Bob 903mBTC -> Alice 903mBTC
2.  Alice&Bob 10mBTC -> Bob 10mBTC

By use of 2p-ECDSA, the Alice&Bob addresses are P2WPKH addresses and do not reveal that they are actually 2-of-2 multisig.
Obviously, all the public keys would be different.

The above would lead blockchain analysts to believe that Alice is being paid 903mBTC from some confusing combination of Alice and Bob, and that Bob is being paid 10mBTC from some confusing combination of Alice and Bob.

Example 2
---------

Under ZeroLink, post-mix coins cannot be joined, even with other post-mix coins, except as part of a mix operation.

Suppose Alice has a 90mBTC UTXO and a 80mBTC UTXO that are both post-mix coins.
Now suppose Alice needs to pay Carol 120 mBTC.
Alice cannot simply join the post-mix coins and pay 120mBTC and get 50mBTC change, as it can reduce the privacy of the mix participants.
Under ZeroLink, Alice needs to re-mix the post-mix coins and get at least 120mBTC from the mix before paying.
This can be problematic if the only available mix is an equal-value coinjoin where the equal value is less than 120mBTC.

With payjoin2swap, Alice simply needs to find a Bob who has at two UTXOs that are at least 30mBTC each.

Suppose Alice finds a Bob with 37mBTC UTXO and 66mBTC UTXO.

They make:

1.  Alice 90mBTC, Bob 37mBTC -> Alice&Bob 120mBTC, Bob 7mBTC
2.  Alice 80mBTC, Bob 66mBTC -> Alice 50mBTC, Alice&Bob 96mBTC

Then:

1.  Alice&Bob 120mBTC -> Carol 120mBTC
2.  Alice&Bob 96mBTC -> Bob 96mBTC


There is no transaction directly tying the two post-mix UTXOs of Alice together, but we have effectively "consolidated" the inputs of Alice.

This is in fact quite similar to "rebalancing" channels on Lightning.
Post-mix UTXOs under ZeroLink and with payjoin2swap function similarly to channels on Lightning: you can transfer from one UTXO to another in order to make a large payment, just as you might transfer funds from one channel to another in order to make or forward a large payment on Lightning.

Payjoin2swap Swap Protocol
==========================

1.  Alice and Bob agree on various details.
    a.  Who Alice and Bob is.
        Alice is the one who knows the secret x and pays to an HTLC with higher time L1.
        Alice gives h(x) to Bob.
    b.  The start time (a blockheight) of the protocol, Ls.
    c.  An amount to swap.
        This should be smaller than the smallest UTXO that will be involved in the swap.
    d.  A "safe" confirmation depth for anchoring, D.
        This could be D = 6 as per the Bitcoin whitepaper.
    e.  Twp future blockheights, L0 and L1, such that Ls + D < L0 < L1.
    f.  Various public keys whose private keys are known by Alice, and various public keys whose private keys are known by Bob.
        This can be done by using a "base point" and deriving the keys from tweaking this base point.
        Let us call this the (Alice|Bob) "$name" basepoint-derived (public|private) key.
        Give a basepoint B (private key b such that B = bG), we can use something like B + h(B | "$name") as the basepoint-derived public key (private key is left as a trivial exercise to the reader).
    g.  A public key whose private key is known by Alice, and a public key whose private key is known by Bob.
        If we use the "base point" technique above, these keys cannot be derived from the same base point as other keys since the last step of this protocol involves sharing this private key to the other participant.
        Let us call this the (Alice|Bob) non-basepoint (public|private) key.
    h.  The feerate.

2.  Alice and Bob generate two 2p-ECDSA federation public keys.
    a.  The "Alice-to-Bob federation key" involves the Alice non-basepoint key, and the Bob "federation" basepoint-derived key.
        As per 2p-ECDSA, Alice can compute this public key by multiplying Alice non-basepoint private key with Bob "federation" basepoint-derived public key.
        Bob can compute this public key by multiplying his private key with the Alice public key.
    b.  The "Bob-to-Alice federation key" involves the Bob non-basepoint key, and the Alice "federation" basepoint-derived key.
        Similar to above as per 2p-ECDSA.

3.  Alice and Bob select from their UTXOs:
    a.  A set of UTXOs whose sum is greater than the swap value.
        Call these the "swap UTXOs", i.e. Alice swap UTXOs, Bob swap UTXOs.
    b.  A UTXO to use for a payjoin receive.
        Call this the "payjoin UTXO", i.e. Alice payjoin UTXO, Bob payjoin UTXO.

4.  Generate (but not sign) the "pre-swap transactions".
    Alice and Bob exchange the txids of these transactions and which output is the swap output.
    Their `nLockTime` is Ls.
    a.  The "Alice pre-swap transaction" spends the Alice swap UTXOs and pays to the "Alice-to-Bob federation public key" the agreed swap amount (the swap output).
        Any extra value is put into a change output that Alice controls.
    b.  The "Bob pre-swap transaction" spends the Bob swap UTXOs and pays to the "Bob-to-Alice federation public key" the agreed swap amount, and extra value into a Bob-only change output.

5.  Generate and sign the "pre-swap backout transactions", then exchange signatures.
    This spends the swap output of the "pre-swap transactions" and return it to the original payer.
    Both Alice and Bob can generate these themselves with information already exchanged before.
    a.  The "Alice pre-swap backout transaction" spends the "Alice pre-swap transaction" output and pays the entire value to the Alice "backout" basepoint-derived public key.
        Its `nLockTime` is L1.
    b.  The "Bob pre-swap backout transaction" spends the "Bob pre-swap transaction" output and pays the entire value to the Bob "backout" basepoint-derived public key.
        Its `nLockTime` is L0.

6.  Validate the signatures for "pre-swap backout transaction" of the counterparty.

7.  Sign the "pre-swap transactions" and exchange the actual transactions with witness.

8.  Validate the pre-swap transaction from the counterparty:
    a.  All inputs are signed correctly and are SegWit.
        All inputs are unspent.
    b.  The indicated "swap" output does pay the correct amount to the correct federation public key.
        e.g. Bob validates that the Alice pre-swap transaction pays the agreed swap amount to the Alice-to-Bob federation key.

9.  From this point onward, if either of the pre-swap transactions appears in the mempool or confirmed, abort.
    Attempt to spend all your own swap UTXOs, and if the pre-swap transaction is confirmed, wait for L2 and use the pre-swap backout transaction.

10.  Check if the pre-swap transaction from your counterparty spends a UTXOs in your blacklist.
     If there are, attempt to spend all your own swap UTXOs and abort.

11.  Add the UTXOs spent by the counterparty pre-swap transaction to your blacklist.

12.  Create the "payjoined swap transaction" for your counterparty and exchange their txids and the value of the swap outputs.
     i.e. Bob creates the Alice payjoined swap transaction and vice versa.
     Start with the counterparty pre-swap transaction.
     Insert your own payjoin UTXO at a random index of the inputs.
     Then increase the swap output according to the value of the payjoin UTXO, minus the feerate times the size of the additional input (including any witness needed).

13.  Generate and sign the "payjoined swap backout transactions" and exchange signatures, and whether the added output was before or after the existing output.
     Start with the counterparty pre-swap backout transaction.
     Change the input to spend the payjoined swap transaction swap output instead.
     Then add a new output that pays to the counterparty "payjoined backout" basepoint-derived public key, the difference of the input minus the other output, minus the feerate times the size of the additional output.

14.  Exchange the payjoined swap transactions and sign them completely.

15.  Validate that the payjoined swap transactions are signed correctly, and that the additional payjoin UTXO from the counterparty is an unspent SegWit output.

16.  Broadcast both payjoined swap transactions and wait for them to be confirmed to height D.
     If L0 is too near and both of the payjoined swap transactions are still unconfirmed, abort and attempt to respend all UTXOs you control that are involved.
     If L0 is too near and one of the payjoined swap transactions is still unconfirmed, abort, and if it is your payjoined swap transaction that is unconfirmed attempt to respend all UTXOs, or if not, just wait for L2 and broadcast the corresponding payjoined swap backout transaction.

17.  Generate the "HTLC offer transactions".
     Each can generate these transactions without communicating with the other.
     The `nLockTime` is the block height at which the payjoined swap transactions were confirmed at depth D.
     a.  The Alice HTLC offer:
         i. Spend the Alice payjoined swap transaction output.
         ii. Compute backout address N as the 2p-ECDSA of (1) Alice "alice-htlc-fail" basepoint-derived key (2) Bob "alice-htlc-fail" basepoint-derived key.
             Pay to `OP_IF OP_HASH160 <h(x)> OP_EQUALVERIFY <Bob "alice-htlc-claim" basepoint-derived key> OP_ELSE L1 OP_CHECKLOCKTIMEVERIFY OP_DROP <N> OP_ENDIF OP_CHECKSIG`
     b.  The Bob HTLC offer:
         i. Spend the Bob payjoined swap transaction output.
         ii. Compute backout address O as the 2p-ECDSA of (1) Alice "bob-htlc-fail" basepoint-derived key (2) Bob "bob-htlc-fail" basepoint-derived key.
             Pay to `OP_IF OP_HASH160 <h(x)> OP_EQUALVERIFY <Alice "bob-htlc-claim" basepoint-derived key> OP_ELSE L0 OP_CHECKLOCKTIMEVERIFY <N> OP_ENDIF OP_CHECKSIG`

18.  Alice generates the "Alice HTLC offer failure transaction".
     This spends the Alice HTLC offer via the timelock path.
     It thus has an `nLockTime` equal to L1.
     It gives the agreed swap value to Alice "backout" basepoint-derived public key, and the remaining value to Bob "payjoined backout" basepoint-derived public key.
     Alice and Bob generate a signature for this via 2p-ECDSA.
     Then they generate a signature for the Alice HTLC offer.

19.  From this point if the Alice HTLC offer appears on mempool or is confirmed, Alice must wait for L1 and broadcast the Alice HTLC offer failure transaction.

20.  Bob generates the "Bob HTLC offer failure transaction".
     This spends the Bob HTLC offer via the timelock path, with an `nLockTime` equal to L0.
     It gives the agreed swap value to Bob "backout" basepoint-derived public key, and the remaining value to Alice "payjoined backout" basepoint-derived public key.
     Alice and Bob generate a signature for this.
     Then they generate a signature for the Bob HTLC offer.

21.  From this point if the Bob HTLC offer appears on mempool or is confirmed, Bob must wait for L1 and broadcast the Bob HTLC offer failure tranasction, or for Alice to claim it by revealing x (and Bob must then broadcast and claim the Alice HTLC offer).

22.  Alice gives Bob x.

23.  Bob gives the Bob non-basepoint private key.

24.  Alice gives the Alice non-basepoint private key.

25.  Alice must now spend the Bob payjoined swap transaction swap output on or before L0.
     Bob must now spend the Alice payjoined swap transaction swap output on or before L1.
     They can send it to themselves, send it to any pending payments they might need to give, or find another partner to swap with and make sure to complete up to step 16 in the new cycle before their respective timeouts.
     a. Alice must spend from the Bob-to-Alice federation pubkey address.
        This is a combination of the Bob non-basepoint key and the Alice "federation" basepoint-derived key.
        Since Bob has given the Bob non-basepoint key and Alice knows the private keys in all the Alice basepoint-derived keys, Alice can now spend it without Bob authorization.
     b. Bob must spend from the Alice-to-Bob federation puobkey address.
        Again, Alice has given enough information to Bob for Bob to completely know the private key wihtout authorization from Alice.

Creating Plausible Transactions
===============================

For simplicity, let us consider the case where Alice and Bob each own two UTXOs each.
This means that the payjoined transactions have two inputs, and are likely to have two outputs.
Fortunately, a good number of transactions onchain are two-input two-output affairs.
However, we should attempt to build plausible transactions.

For example, suppose we have:

* Alice has 70mBTC and 800mBTC UTXOs.
* Bob has 100mBTC and 7 mBTC UTXOs.

They could propose to swap 85mBTC.
Then Alice would give the Alice pre-swap transaction as:

* Alice 800mBTC -> Alice 715mBTC, Alice&Bob 85mBTC

And Bob would make the Bob pre-swap transaction:

* Bob 100mBTC -> Alice&Bob 85mBTC, Bob 15mBTC

After payjoining:

* Alice 800mBTC, Bob 7mBTC -> Alice 715mBTC, Alice&Bob 92mBTC
* Alice 70mBTC, Bob 100mBTC -> Ailce&Bob 155mBTC, Bob 15mBTC

The first transaction above is implausible: if the payment amount were 715mBTC, then a fee-reducing coin selector would have just chosen the 800mBTC.
Thus, we should ensure that there exists one output which is larger than the sum of all inputs except the smallest input.
Otherwise, a fee-reducing coin selection algorithm would have eliminated the smaller coins from the transaction.

For the case where both Alice and Bob each have two inputs to mix, we could impose the below rules:

1.  Alice and Bob generate pre-swap transactions using the smaller UTXO they have.
    This implies that the swap amount must be less than or equal to the smallest UTXO.
2.  Alice and Bob check if their other coin (the one they will propose of payjoining) plus the swap amount is greater than the UTXO consumed in the pre-swap transaction from the other side.
    i.e. Alice checks the Bob pre-swap input is smaller than the Alice larger UTXO plus the swap amount.
    If thise fails, they may propose to the counterparty to split their smaller UTXO.

Thus, in the above, Alice and Bob should have started their pre-swap transactions as:

* Alice 70mBTC -> Alice 64mBTC, Alie&Bob 6mBTC
* Bob 7mBTC -> Alice&Bob 6mBTC, Bob 1mBTC

Then the payjoined versions would be:

* Alice 70mBTC, Bob 100mBTC -> Alice 64mBTC, Alice&Bob 106mBTC
* Alice 800mBTC, Bob 7mBTC -> Alice&Bob 806mBTC, Bob 1mBTC

Linking (and Overlinking) Payjoin2swap
--------------------------------------

Using the heuristic above leads to the strong tendency that the difference of an input to the smaller output will be the swap value.
(or if the transaction is 1 output, then one of the inputs will be exactly the swap value)
Also, the main transactions will usually be in the same block and will usually be 2-input transactions.
There are fewer possibilities, thus it is a possible avenue for blockchain analysis to attempt linking.

It is useful to remember that generating this transaction is two steps: first create the pre-swap transaction with the UTXO of one side, before adding a new UTXO for the other side.

Suppose our agreed swap value is S.
Then one side creates a pre-swap transaction from a UTXO V:

* V -> V - S, S

The other side can then monitor the mempool for two-input two-output/one-output transactions and compute an "apparent swap value" from the difference of an input and the lower input (or 0 if one-output).
Suppose it finds S'.
Then the other side can simply synthesize a UTXO of value V - S + S'.
The other side can do this by spending a larger UTXO and splitting out that value.
This leads to a swap transaction of:

* V, V - S + S' -> V - S, V + S'

The above still leads to plausible transaction as defined above; the V + S' output will always be larger than the inputs, thus having to combine both inputs is plausible.
In doing so, the existing mempool transaction with apparent swap value S' becomes potentially linked to this transaction, even though it is completely unrelated.

Further, while the swap output is identifiable as V + S', it is not possible to be sure whether S or S' is the swap value.
The difference between V + S' and V is S', while the difference between V + S' and V - S + S' is S, so either could be the swap value.

This operation to mislead blockchain analysis can be called "overlinking", as it can lead blockchain analysis to believe that an unrelated transaction is linked to one of the swap transactions.
Participants should refuse to swap unlesss they can overlink at least one (and preferably both) of the payjoined swap transactions.
If the swap is not possible, both sides can agree to lower the V value of one side (provided V >= S) until the V - S + S' is achievable by the other side.

From ZmnSCPxj at protonmail.com  Mon Apr 22 17:06:43 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 22 Apr 2019 17:06:43 +0000
Subject: [bitcoin-dev] Payjoin2swap: Enabling Payjoin Without Merchant
	Purchases
In-Reply-To: <pOqJuLTCi90Cz27QqCYHFBdkKBA0Hc0IY2zplQ0uFILWWqLULdspR6rA6Q_2oMC9yWKrB8p5VX7woQUYhNpV_cjDCcKCJajGsr3gNrcbYho=@protonmail.com>
References: <pOqJuLTCi90Cz27QqCYHFBdkKBA0Hc0IY2zplQ0uFILWWqLULdspR6rA6Q_2oMC9yWKrB8p5VX7woQUYhNpV_cjDCcKCJajGsr3gNrcbYho=@protonmail.com>
Message-ID: <kgldTB03owVUYGhhQln85x7tzZSqKD7VgfXwERpVpXP2IJ1dpBzahYZ7DkFhKqbdGWsS-2GO1ZiUnPBmjW6sfcm8I3hxAnOSyckrI4_HyTc=@protonmail.com>

Good morning list,

I observe that if the Lightning Network supports:

1.  Wumbo channels (>167.772215mBTC channels)
2.  Dual-funded channels

Then payjoin2swap is implementable using LN operations.
Given two UTXOs V and W you want to transfer some value S from V to W.

1.  Connect to an LN node on Tor and listen to gossip, then disconnect.
2.  Create two fake node addresses (A and B) and assign a unique Tor hidden service to each.
3.  Select two actual LN nodes with long uptime (use the lifetime of the channels they have as a rough estimate) and a short distance between them with good capacity and many alternate routes between them.
4.  Connect A to one node and create a channel using V.
    Indicate that the channel should be unpublished (the LN protocol has a flag existing for this already).
    Publishing channels is good for privacy if you intend to stay long on LN (it invites "normal" traffic to hide your own payments in), but we do not intend to stay long on LN here, so keep the channels unpublished.
5.  Connect B to the other node and create a channel with dual-funding, requesting at least S from the other node to put in the channel, using W as your own UTXO.
    Again indicate the channel should be unpublished.
6.  Transfer S satoshi over LN from the channel of A to the channel of B.
7.  Cooperatively close both channels.
    It is possible to time the closes to be some blocks apart to make them harder for blockchain analysis to link.

This rides payjoin2swap on top of existing infrastructure.
The drawback is that it is unlikely that existing LN implementations will apply ZeroLink for onchain funds, since much of the privacy on LN is with paying over the long-lived offchain channels.
This can erode privacy if either of the nodes you connect to uses the result of the cooperative closes to later fund a published channel, possibly mixing it with other coins of their own.

Regards,
ZmnSCPxj

From ahmerregos at gmail.com  Tue Apr 23 08:16:28 2019
From: ahmerregos at gmail.com (Ahmer Regos)
Date: Tue, 23 Apr 2019 11:16:28 +0300
Subject: [bitcoin-dev] Improving Pre and Post Merging Abilities With
	Rewriting Core In Python
Message-ID: <CA+PERc0+cUu-0-HsnTNEFY67v2T6BwtV-myjT=mh1i9z5vATYQ@mail.gmail.com>

I'm proposing re-writing bitcoin codebase in Python for improving pre and
post merging abilities, faster operations and better understandability.
Python is a fast language with C support, it is good with hashing things,
it has a good syntax and everyone can read /  understand it unlike C++.

I am willing the coordinate the transformation operation and i believe it
would be really good the get rid of C++.

- Ahmer Regos from Regain Beaches.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190423/8cbd825a/attachment.html>

From james.obeirne at gmail.com  Tue Apr 23 14:17:06 2019
From: james.obeirne at gmail.com (James O'Beirne)
Date: Tue, 23 Apr 2019 10:17:06 -0400
Subject: [bitcoin-dev] assumeutxo and UTXO snapshots
In-Reply-To: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
References: <CAPfvXf+JS6ZhXUieWVxiaNa4uhhWwafCk3odMKy5F_yi=XwngA@mail.gmail.com>
Message-ID: <CAPfvXfJkCqSpB9r-nF0vNh-GpP1RAhaEzxDJ0jit3JkUEeJtog@mail.gmail.com>

Good morning all,

Over the past weeks I've had a number of conversations with a few frequent
contributors about this idea. I've condensed these discussions into a
proposal document which you can view here:
https://github.com/jamesob/assumeutxo-docs/tree/2019-04-proposal/proposal

The document is structured as an FAQ, and so hopefully it addresses some of
the common questions that would come up in this thread. If you'd like to
comment, there's an associated pull request here:
https://github.com/jamesob/assumeutxo-docs/pull/1

Regards,
James


On Tue, Apr 2, 2019 at 4:43 PM James O'Beirne <james.obeirne at gmail.com>
wrote:

> Hi,
>
> I'd like to discuss assumeutxo, which is an appealing and simple
> optimization in the spirit of assumevalid[0].
>
> # Motivation
>
> To start a fully validating bitcoin client from scratch, that client
> currently
> needs to perform an initial block download. To the surprise of no one, IBD
> takes a linear amount time based on the length of the chain's history. For
> clients running on modest hardware under limited bandwidth constraints,
> say a mobile device, completing IBD takes a considerable amount of time
> and thus poses serious usability challenges.
>
> As a result, having fully validating clients run on such hardware is rare
> and
> basically unrealistic. Clients with even moderate resource constraints
> are encouraged to rely on the SPV trust model. Though we have promising
> improvements to existing SPV modes pending deployment[1], it's worth
> thinking about a mechanism that would allow such clients to use trust
> models closer to full validation.
>
> The subject of this mail is a proposal for a complementary alternative to
> SPV
> modes, and which is in the spirit of an existing default, `assumevalid`.
> It may
> help modest clients transact under a security model that closely resembles
> full validation within minutes instead of hours or days.
>
> # assumeutxo
>
> The basic idea is to allow nodes to initialize using a serialized version
> of the
> UTXO set rendered by another node at some predetermined height. The
> initializing node syncs the headers chain from the network, then obtains
> and
> loads one of these UTXO snapshots (i.e. a serialized version of the UTXO
> set
> bundled with the block header indicating its "base" and some other
> metadata).
>
> Based upon the snapshot, the node is able to quickly reconstruct its
> chainstate,
> and compares a hash of the resulting UTXO set to a preordained hash
> hard-coded
> in the software a la assumevalid. This all takes ~23 minutes, not
> accounting for
> download of the 3.2GB snapshot[2].
>
> The node then syncs to the network tip and afterwards begins a simultaneous
> background validation (i.e., a conventional IBD) up to the base height of
> the
> snapshot in order to achieve full validation. Crucially, even while the
> background validation is happening the node can validate incoming blocks
> and
> transact with the benefit of the full (assumed-valid) UTXO set.
>
> Snapshots could be obtained from multiple separate peers in the same
> manner as
> block download, but I haven't put much thought into this. In concept it
> doesn't
> matter too much where the snapshots come from since their validity is
> determined via content hash.
>
> # Security
>
> Obviously there are some security implications due consideration. While
> this
> proposal is in the spirit of assumevalid, practical attacks may become
> easier.
> Under assumevalid, a user can be tricked into transacting under a false
> history
> if an attacker convinces them to start bitcoind with a malicious
> `-assumevalid`
> parameter, sybils their node, and then feeds them a bogus chain
> encompassing
> all of the hard-coded checkpoints[3].
>
> The same attack is made easier in assumeutxo because, unlike in
> assumevalid,
> the attacker need not construct a valid PoW chain to get the victim's node
> into
> a false state; they simply need to get the user to accept a bad
> `-assumeutxo`
> parameter and then supply them an easily made UTXO snapshot containing,
> say, a
> false coin assignment.
>
> For this reason, I recommend that if we were to implement assumeutxo, we
> not
> allow its specification via commandline argument[4].
>
> Beyond this risk, I can't think of material differences in security
> relative to
> assumevalid, though I appeal to the list for help with this.
>
> # More fully validating clients
>
> A particularly exciting use-case for assumeutxo is the possibility of
> mobile
> devices functioning as fully validating nodes with access to the complete
> UTXO
> set (as an alternative to SPV models). The total resource burden needed to
> start a node
> from scratch based on a snapshot is, at time of writing, a ~(3.2GB
> + blocks_to_tip * 4MB) download and a few minutes of processing time,
> which sounds
> manageable for many mobile devices currently in use.
>
> A mobile user could initialize an assumed-valid bitcoin node within an
> hour,
> transact immediately, and complete a pruned full validation of their
> assumed-valid chain over the next few days, perhaps only doing the
> background
> IBD when their device has access to suitable high-bandwidth connections.
>
> If we end up implementing an accumulator-based UTXO scaling design[5][6]
> down
> the road, it's easy to imagine an analogous process that would allow very
> fast
> startup using an accumulator of a few kilobytes in lieu of a multi-GB
> snapshot.
>
> ---
>
> I've created a related issue at our Github repository here:
>   https://github.com/bitcoin/bitcoin/issues/15605
>
> and have submitted a draft implementation of snapshot usage via RPC here:
>   https://github.com/bitcoin/bitcoin/pull/15606
>
> I'd like to discuss here whether this is a good fit for Bitcoin
> conceptually. Concrete
> plans for deployment steps should be discussed in the Github issue, and
> after all
> that my implementation may be reviewed as a sketch of the specific software
> changes necessary.
>
> Regards,
> James
>
>
> [0]:
> https://bitcoincore.org/en/2017/03/08/release-0.14.0/#assumed-valid-blocks
> [1]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
> [2]: as tested at height 569895, on a 12 core Intel Xeon Silver 4116 CPU @
> 2.10GHz
> [3]:
> https://github.com/bitcoin/bitcoin/blob/84d0fdc/src/chainparams.cpp#L145-L161
> [4]: Marco Falke is due credit for this point
> [5]: utreexo: https://www.youtube.com/watch?v=edRun-6ubCc
> [6]: Boneh, Bunz, Fisch on accumulators: https://eprint.iacr.org/2018/1188
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190423/44dcd1c9/attachment.html>

From riperk at protonmail.com  Mon Apr 22 19:22:52 2019
From: riperk at protonmail.com (Ryan Perkins)
Date: Mon, 22 Apr 2019 19:22:52 +0000
Subject: [bitcoin-dev] CoinJoin Jigsaw
Message-ID: <kZwZOekiYq3oxv7wgNj57KJqpOP0a2lkwM-TXsROtIDW5M8VunVV7majgvia4uo_bF3LxJn-8IOYN3IHBy25gjEN-OmPt-T47068L6s5ycE=@protonmail.com>

Earlier today ZmnSCPxj posted to the mailing list with an interesting post about payjoin. In it he mentioned:

> Any non-equal-value coinjoin is easily solvable via [value sudoku](https://www.coinjoinsudoku.com/advisory/).

Which doesn't seem right to me.

I came up with something I call a "CoinJoin Jigsaw". A "CoinJoin Jigsaw" is send-to-self coinjoin transaction in which every input is ambiguously associated with an output (i.e. every transaction input must belong to at least one subset of every output amount).


For simplicity I've used minizinc to model this. To make it clean, I decided to model as two users (affectionately called 'A' and 'B') who trust a common party to orchestrate the CoinJoin Jigsaw for them. A and B don't trust each other, so they want to get all their money atomically in this one transaction. We also want the "CoinJoin Jigsaw" to have exactly 2 outputs. One for A, and one for B. That way at first approximation it looks like a pretty standard bitcoin payment. (Of course the problem is substantially easier to solve if we allow A and B to have N outputs, but that creates an ugly transaction).

We also need to make sure that both A and B are paying a fee proportional to the amount of inputs they added, and the total transaction fee is satisfactory.

So I've modelled it as A and B provide their utxo to the orchestrater. The orchestrater will pick the largest subset of A's and B's utxo and such that satisfies our CoinJoin Jigsaw properties. I ended up copy-and-pasting a lot more than I'd like:

https://gist.github.com/riperk/7be6698f291e865ad5c930d0edb0cd5a

I'm not sure it has much practical utility, but it's kind of cool. Maybe.

From achow101-lists at achow101.com  Tue Apr 23 15:23:27 2019
From: achow101-lists at achow101.com (Achow101)
Date: Tue, 23 Apr 2019 15:23:27 +0000
Subject: [bitcoin-dev] Improving Pre and Post Merging Abilities With
	Rewriting Core In Python
In-Reply-To: <CA+PERc0+cUu-0-HsnTNEFY67v2T6BwtV-myjT=mh1i9z5vATYQ@mail.gmail.com>
References: <CA+PERc0+cUu-0-HsnTNEFY67v2T6BwtV-myjT=mh1i9z5vATYQ@mail.gmail.com>
Message-ID: <V0VmX7UXCj3jIAzs4ChvyjabCLbjKvyOCURUOoR9q1y0xOcYO8Dl7aMYzIE0qoROqkVZQ4EpxCgD6UA2pBhWM_dfAwvYK7GVZcbs8EoSmW4=@achow101.com>

Feel free to re-implement Bitcoin Core in Python. It's open source software and you can do whatever you want.

However Bitcoin Core is not going move to Python and rewrite everything in Python. Besides the fact that Python is far less efficient than C/C++, rewriting Bitcoin Core in any other language would be a huge undertaking and introduce many bugs for almost no benefit whatsoever. Bitcoin Core won't be changing languages for the entire codebase, but you are welcome to port it to Python yourself.

??????? Original Message ???????
On Tuesday, April 23, 2019 4:16 AM, Ahmer Regos via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'm proposing re-writing bitcoin codebase in Python for improving pre and post merging abilities, faster operations and better understandability. Python is a fast language with C support, it is good with hashing things, it has a good syntax and everyone can read /  understand it unlike C++.
>
> I am willing the coordinate the transformation operation and i believe it would be really good the get rid of C++.
>
> - Ahmer Regos from Regain Beaches.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190423/961583db/attachment-0001.html>

From snigirev.stepan at gmail.com  Fri Apr 26 15:21:06 2019
From: snigirev.stepan at gmail.com (Stepan Snigirev)
Date: Fri, 26 Apr 2019 17:21:06 +0200
Subject: [bitcoin-dev] Adding xpub field to PSBT to make multisig more secure
Message-ID: <CACL8y1v9fpZ+gWLVHMx-bGUCaSd0=0ecHU-u4FF=LnhT7s1zTg@mail.gmail.com>

Hi list,

I was looking at the bip174 PSBT specs, in particular for multisignature
setup, and I think with current spec there is a way to steal user funds in
M of N setup with M ? N/2.

I made a small write-up on this:
https://github.com/stepansnigirev/random_notes/blob/master/psbt_multisig.md

To compress:

Currently in PSBT there is no way to reliably say if the output uses the
keys derived from the same root keys as the inputs aside from the key owned
by the signer => there is no way to verify that the output is a change
output in multisig setup.

Therefore an attacker can replace half of the keys in the change address by
his own keys and still get the transaction signed.

I suggest to add an xpub field to the inputs and outputs metadata, then
signers can verify that the same xpubs are used for public keys in inputs
and outputs => output is indeed a change.

Normally change and receiving addresses are derived from the same xpub with
non-hardened derivation pathes, so providing xpub after the last hardened
index should be enough to see that public keys of inputs and change output
are derived from the same xpub.

I suggest to add the following key-value pairs to PSBT:

Type: BIP 32 public key `PSBT_IN_BIP32_XPUB = 0x10`
- Key: derivation path for xpub
  `{0x10}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`
- Value: 78-byte xpub value
  `{xpub}`

Type: BIP 32 public key `PSBT_OUT_BIP32_XPUB = 0x03`
- Key: derivation path for xpub
  `{0x03}|{master key fingerprint}|{32-bit int}|...|{32-bit int}`
- Value: 78-byte xpub value
  `{xpub}`

Derivation paths are in the key of the key-value pair as they are used for
lookup, and xpub itself is the actual value being looked up.

I also want to mention that Trezor for example doesn't suffer from this
problem as they use xpubs to verify change outputs. So it may make sense to
go through the communication protocols of existing hardware /
multisignature wallets and see if there is something else we are missing.

If everyone is happy about the proposal I would prepare a pull request to
the bip.

Best regards,
Stepan Snigirev.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190426/5201b537/attachment.html>

From hampus.sjoberg at gmail.com  Fri Apr 26 09:38:03 2019
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Fri, 26 Apr 2019 11:38:03 +0200
Subject: [bitcoin-dev] Improving Pre and Post Merging Abilities With
 Rewriting Core In Python
In-Reply-To: <CA+PERc0+cUu-0-HsnTNEFY67v2T6BwtV-myjT=mh1i9z5vATYQ@mail.gmail.com>
References: <CA+PERc0+cUu-0-HsnTNEFY67v2T6BwtV-myjT=mh1i9z5vATYQ@mail.gmail.com>
Message-ID: <CAFMkqK94_EqXpdXX4swrWZy+Am-bjvWWR_JFG3JUJxOp1WBZJw@mail.gmail.com>

Bitcoin is a consensus critical system.
We have already had consensus problems between Bitcoin Core-versions,
rewriting everything in another language would expose us to even greater
risks, and moving to a language like Python I see no benefit whatsoever.

Best
Hampus

Den tis 23 apr. 2019 kl 16:47 skrev Ahmer Regos via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> I'm proposing re-writing bitcoin codebase in Python for improving pre and
> post merging abilities, faster operations and better understandability.
> Python is a fast language with C support, it is good with hashing things,
> it has a good syntax and everyone can read /  understand it unlike C++.
>
> I am willing the coordinate the transformation operation and i believe it
> would be really good the get rid of C++.
>
> - Ahmer Regos from Regain Beaches.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190426/e356187c/attachment.html>

From pete at petertodd.org  Sat Apr 27 03:32:27 2019
From: pete at petertodd.org (Peter Todd)
Date: Fri, 26 Apr 2019 23:32:27 -0400
Subject: [bitcoin-dev] Improving Pre and Post Merging Abilities With
 Rewriting Core In Python
In-Reply-To: <V0VmX7UXCj3jIAzs4ChvyjabCLbjKvyOCURUOoR9q1y0xOcYO8Dl7aMYzIE0qoROqkVZQ4EpxCgD6UA2pBhWM_dfAwvYK7GVZcbs8EoSmW4=@achow101.com>
References: <CA+PERc0+cUu-0-HsnTNEFY67v2T6BwtV-myjT=mh1i9z5vATYQ@mail.gmail.com>
	<V0VmX7UXCj3jIAzs4ChvyjabCLbjKvyOCURUOoR9q1y0xOcYO8Dl7aMYzIE0qoROqkVZQ4EpxCgD6UA2pBhWM_dfAwvYK7GVZcbs8EoSmW4=@achow101.com>
Message-ID: <20190427033227.g5t3p7meztdc6tr4@petertodd.org>

On Tue, Apr 23, 2019 at 03:23:27PM +0000, Achow101 via bitcoin-dev wrote:
> Feel free to re-implement Bitcoin Core in Python. It's open source software and you can do whatever you want.
> 
> However Bitcoin Core is not going move to Python and rewrite everything in Python. Besides the fact that Python is far less efficient than C/C++, rewriting Bitcoin Core in any other language would be a huge undertaking and introduce many bugs for almost no benefit whatsoever. Bitcoin Core won't be changing languages for the entire codebase, but you are welcome to port it to Python yourself.

Speaking as maintainer of the Python library python-bitcoinlib, I don't think
using Python for security critical codebases is a good idea. It's just too easy
to make mistakes; I wouldn't recommend new projects use python-bitcoinlib.

Currently I'm doing 100% of my new projects on Rust. That's not to say Rust is
the only language usable for this kind of work. But it fits my style of
programming well and the type system - esp good handling of immutability -
appears to offer significant benefits.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20190426/8c35d5c4/attachment.sig>

From vitteaymeric at gmail.com  Sat Apr 27 10:37:29 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sat, 27 Apr 2019 12:37:29 +0200
Subject: [bitcoin-dev] IsStandard
Message-ID: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>

Maybe trivial question but asking here because I can't find anything
clear (or updated) about it: is somewhere explained in details what txs
are considered standard and non standard today without having to read
the core code?

For example, modification of multisig 2 of 3:

scriptSig:
??? OP_0
??? OP_PUSHDATA sign1
??? OP_PUSHDATA sign2
??? OP_2
??? OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG
???
scriptPubKey:
??? OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3
OP_CHECKMULTISIG) OP_EQUAL

Is this standard? Are lightning txs standards ? etc



From ZmnSCPxj at protonmail.com  Mon Apr 29 01:46:35 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 29 Apr 2019 01:46:35 +0000
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
Message-ID: <NvaqlAYJTXaCBdFqlgaJdky81FfhEG5Q8r6gWnkoYGpp4_dWfYzU3OsZkAOWbFQ947n8ahnMQz_ZM1u7fL6j2GnuJmJ4i9alsJVjCzw7jqY=@protonmail.com>

Good morning Aymeric,

Different versions may consider different output scripts standard.

Your rule of thumb, post-SegWit, should be:

* If not P2PKH or P2WPKH, then wrap it in a P2SH or P2WSH.

There are more standard outputs accepted, but you can be reasonably sure that P2PKH, P2WPKH, P2SH, and P2WSH are the only standard output scripts that are likely to remain supported in the mid-future (5->10 years from 2019).

Lightning uses P2WSH for its scripts.

Any m-of-n signing scheme in Bitcoin is P2SH (usually) or P2WSH (if you are cool).


Regards,
ZmnSCPxj




Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Saturday, April 27, 2019 6:37 PM, Aymeric Vitte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Maybe trivial question but asking here because I can't find anything
> clear (or updated) about it: is somewhere explained in details what txs
> are considered standard and non standard today without having to read
> the core code?
>
> For example, modification of multisig 2 of 3:
>
> scriptSig:
> ??? OP_0
> ??? OP_PUSHDATA sign1
> ??? OP_PUSHDATA sign2
> ??? OP_2
> ??? OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG
> ???
> scriptPubKey:
> ??? OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3
> OP_CHECKMULTISIG) OP_EQUAL
>
> Is this standard? Are lightning txs standards ? etc
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From vitteaymeric at gmail.com  Mon Apr 29 09:30:39 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Mon, 29 Apr 2019 11:30:39 +0200
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <201904290301.43459.luke@dashjr.org>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
Message-ID: <56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>

ZmnSCPxj, OK, but you can put whatever you like in the different
standard output script you mention (my example below whether legacy or
segwit)

Luke, I am still confused or missing something, from your answer I
understand that everything is accepted, so if we take the past example
of bch coins wrongly sent to a segwit address, why was the recovery
solution where scriptsig included the matching segwit address/program
not a standard transaction?

Le 29/04/2019 ? 05:01, Luke Dashjr a ?crit?:
> On Saturday 27 April 2019 10:37:29 Aymeric Vitte via bitcoin-dev wrote:
>> Maybe trivial question but asking here because I can't find anything
>> clear (or updated) about it: is somewhere explained in details what txs
>> are considered standard and non standard today without having to read
>> the core code?
>>
>> For example, modification of multisig 2 of 3:
>>
>> scriptSig:
>> ??? OP_0
>> ??? OP_PUSHDATA sign1
>> ??? OP_PUSHDATA sign2
>> ??? OP_2
>> ??? OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG
>> ???
>> scriptPubKey:
>> ??? OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3
>> OP_CHECKMULTISIG) OP_EQUAL
>>
>> Is this standard? Are lightning txs standards ? etc
> The name is confusing. It has little to do with standards, really.
> IsStandard is just one of the functions which implement the node's policy.
> It allows many things for which there is no standard (eg, data carrier / 
> OP_RETURN outputs), and can vary freely from node to node (either by 
> configurable parameters, or by different/modified software) without breaking 
> consensus.
>
> As it is a node-specific criteria, it is not itself even a possible *subject* 
> for standards.
>
> Additionally, it should not be given much (if any) attention when defining new 
> standards. Just do what makes sense for the standard, and node policies can 
> be adapted around that.
>
> So, overall, there's limited use case for documenting this beyond the code.
> It makes far more sense to document actual standards instead.
>
> Luke

s


From ZmnSCPxj at protonmail.com  Tue Apr 30 04:29:18 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 30 Apr 2019 04:29:18 +0000
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
Message-ID: <aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>

Good morning Aymeric,


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Monday, April 29, 2019 5:30 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:

> ZmnSCPxj, OK, but you can put whatever you like in the different
> standard output script you mention (my example below whether legacy or
> segwit)
>

I am uncertain what you mean by this.

For P2PKH and P2WPKH, you must present a hash of a public key.
You cannot present a hash of anything else.

The P2PKH template can be interpreted as a script, but is actually recognized as a template by most current nodes (in a way that is consistent with interpreting it as a script).

For P2SH and P2WSH, you must present a hash of a script.

It is more helpful to consider that *today* nodes recognize particular patterns (P2PKH, P2WPKH, P2SH, P2WSH) as templates and not as scripts to be executed.

In any case, if you want to make anything more complicated than "single signer" you should use P2SH or P2WSH regardless, and give your script.
If you want to assure somebody that a particular P2SH or P2WSH commits to a particular policy, just expose the policy script to them and have them (i.e. their client software) verify that the policy is what the user wants and that when hashed it matches the P2SH/P2WSH.

As Luke said, nodes can have any policy for propagating transactions.
However it is generally expected that P2PKH, P2WPKH, P2SH, and P2WSH will be propagated by a majority of nodes, if only because those are reliably "passed" by `isStandard` in the default latest Bitcoin Core and most people will not modify the Core code.

Generally, anything that isn't P2PKH, P2WPKH, P2SH, or P2WSH will not likely be propagated by the network.
You *could* still coordinate with one or more miners to get it mined: you can put anything in the block, it is simply that most nodes will not inform miners about transactions that do not pay out to P2PKH, P2WPKH, P2SH, or P2WSH.

Regards,
ZmnSCPxj

From vitteaymeric at gmail.com  Tue Apr 30 09:43:27 2019
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 30 Apr 2019 11:43:27 +0200
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
	<201904290301.43459.luke@dashjr.org>
	<56b67b57-dc11-183a-1f4e-5a8c296b64cc@gmail.com>
	<aglJm4Zqda4W5Lrq33myL085DPnxjQTY1Eg6ANYFOe10nXeW8NvBOUUckAF4ASsZIO00xB8KoZ6wOQPPFB9g-uOl8A4gwZ10MYYZzZ2BjU0=@protonmail.com>
Message-ID: <1019ea57-7240-2dc7-8357-970223278e3d@gmail.com>

I must badly explain my point (or just wondering things that do not
exist finally), the question is indeed whether nodes will relay non
usual transactions or not and how to know what they will accept or not:

- my modified multisig 2 of 3: I did put OP_2 out of the usual redeem
script, the redeem script still matches scriptpubkey and scriptsig will
execute succesfully, that's a normal legacy P2SH or segwit P2WSH

- bch segwit recovery: it's a p2sh transaction without any signature
verification, as far as I remember there was a story that it could not
propagate in the network (even taking the risk to be stolen) and that
people had to contact a (honest) miner

- sha bounties: same as above, p2sh transactions without signatures

etc

Will all of those transactions propagate normally? And then the rule is
just that it matches the P2PKH, P2WPKH, P2SH, or P2WSH templates
whatever scripts you put inside?

Le 30/04/2019 ? 06:29, ZmnSCPxj a ?crit?:
> Good morning Aymeric,
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
> On Monday, April 29, 2019 5:30 PM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>
>> ZmnSCPxj, OK, but you can put whatever you like in the different
>> standard output script you mention (my example below whether legacy or
>> segwit)
>>
> I am uncertain what you mean by this.
>
> For P2PKH and P2WPKH, you must present a hash of a public key.
> You cannot present a hash of anything else.
>
> The P2PKH template can be interpreted as a script, but is actually recognized as a template by most current nodes (in a way that is consistent with interpreting it as a script).
>
> For P2SH and P2WSH, you must present a hash of a script.
>
> It is more helpful to consider that *today* nodes recognize particular patterns (P2PKH, P2WPKH, P2SH, P2WSH) as templates and not as scripts to be executed.
>
> In any case, if you want to make anything more complicated than "single signer" you should use P2SH or P2WSH regardless, and give your script.
> If you want to assure somebody that a particular P2SH or P2WSH commits to a particular policy, just expose the policy script to them and have them (i.e. their client software) verify that the policy is what the user wants and that when hashed it matches the P2SH/P2WSH.
>
> As Luke said, nodes can have any policy for propagating transactions.
> However it is generally expected that P2PKH, P2WPKH, P2SH, and P2WSH will be propagated by a majority of nodes, if only because those are reliably "passed" by `isStandard` in the default latest Bitcoin Core and most people will not modify the Core code.
>
> Generally, anything that isn't P2PKH, P2WPKH, P2SH, or P2WSH will not likely be propagated by the network.
> You *could* still coordinate with one or more miners to get it mined: you can put anything in the block, it is simply that most nodes will not inform miners about transactions that do not pay out to P2PKH, P2WPKH, P2SH, or P2WSH.
>
> Regards,
> ZmnSCPxj

-- 
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From luke at dashjr.org  Mon Apr 29 03:01:41 2019
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 29 Apr 2019 03:01:41 +0000
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
Message-ID: <201904290301.43459.luke@dashjr.org>

On Saturday 27 April 2019 10:37:29 Aymeric Vitte via bitcoin-dev wrote:
> Maybe trivial question but asking here because I can't find anything
> clear (or updated) about it: is somewhere explained in details what txs
> are considered standard and non standard today without having to read
> the core code?
>
> For example, modification of multisig 2 of 3:
>
> scriptSig:
> ??? OP_0
> ??? OP_PUSHDATA sign1
> ??? OP_PUSHDATA sign2
> ??? OP_2
> ??? OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG
> ???
> scriptPubKey:
> ??? OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3
> OP_CHECKMULTISIG) OP_EQUAL
>
> Is this standard? Are lightning txs standards ? etc

The name is confusing. It has little to do with standards, really.
IsStandard is just one of the functions which implement the node's policy.
It allows many things for which there is no standard (eg, data carrier / 
OP_RETURN outputs), and can vary freely from node to node (either by 
configurable parameters, or by different/modified software) without breaking 
consensus.

As it is a node-specific criteria, it is not itself even a possible *subject* 
for standards.

Additionally, it should not be given much (if any) attention when defining new 
standards. Just do what makes sense for the standard, and node policies can 
be adapted around that.

So, overall, there's limited use case for documenting this beyond the code.
It makes far more sense to document actual standards instead.

Luke

From falke.marco at gmail.com  Mon Apr 29 17:27:29 2019
From: falke.marco at gmail.com (Marco Falke)
Date: Mon, 29 Apr 2019 13:27:29 -0400
Subject: [bitcoin-dev] IsStandard
In-Reply-To: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
References: <21346b3c-dad5-c666-9234-8916aa5a56e4@gmail.com>
Message-ID: <CAK51vgCaGnS3Ha9OYF48BSVdzN8SBRjzjkhXBKGNeOUMukkg4g@mail.gmail.com>

There is not a single document that describes what is standard and
what is not. Transaction relay policy (including minimum relay fees)
may change over time, across different implementations or different
versions of the same implementation.

Generally you can assume that commonly used scripts that are standard
today remain standard. To test if a script is standard and accepted by
current relay policy of a Bitcoin Core node, you can create a tx that
spends from it on mainnet or on testnet and see if it is accepted to
the mempool of your local node. Make sure to disable
-acceptnonstdtxn=0 on testnet.

Should the standardness-rules of a script type ever change, it will be
announced and discussed on this mailing list.

And of course, lightning transactions are standard as they otherwise
wouldn't propagate.

Best,
Marco

On Sun, Apr 28, 2019 at 9:06 PM Aymeric Vitte via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Maybe trivial question but asking here because I can't find anything
> clear (or updated) about it: is somewhere explained in details what txs
> are considered standard and non standard today without having to read
> the core code?
>
> For example, modification of multisig 2 of 3:
>
> scriptSig:
>     OP_0
>     OP_PUSHDATA sign1
>     OP_PUSHDATA sign2
>     OP_2
>     OP_PUSHDATA <pubkey1><pubkey2><pubkey3> OP_3 OP_CHECKMULTISIG
>
> scriptPubKey:
>     OP_HASH160 hash160(<pubkey1><pubkey2><pubkey3> OP_3
> OP_CHECKMULTISIG) OP_EQUAL
>
> Is this standard? Are lightning txs standards ? etc
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

