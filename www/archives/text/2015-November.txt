From justus at openbitcoinprivacyproject.org  Sun Nov  1 14:36:35 2015
From: justus at openbitcoinprivacyproject.org (Justus Ranvier)
Date: Sun, 1 Nov 2015 08:36:35 -0600
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <8737wrwvn2.fsf@rustcorp.com.au>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<8737wrwvn2.fsf@rustcorp.com.au>
Message-ID: <56362373.9080105@openbitcoinprivacyproject.org>

On 10/30/2015 10:43 PM, Rusty Russell via bitcoin-dev wrote:
> By that benchmark, we should aim for "reasonable certainty".  A
> transaction which would never have been generated by any known software
> is the minimum bar.  Adding "...which would have to be deliberately
> stupid with many redundant OP_CHECKSIG etc" surpasses it.  The only extra
> safeguard I can think of is clear, widespread notification of the
> change.

If the policy of Bitcoin Core development includes a willingness to
makes the utxos created by software other than Bitcoin Core unspendable,
then it certainly merits clear, widespread notification.

Even if that is actually a good policy, the reasons why should be made
abundantly clear.


-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 23337 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/1034f016/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/1034f016/attachment.sig>

From jl2012 at xbt.hk  Sun Nov  1 17:28:39 2015
From: jl2012 at xbt.hk (jl2012 at xbt.hk)
Date: Sun, 01 Nov 2015 12:28:39 -0500
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
Message-ID: <df48a2c44441f39c71579aa5e474ec38@xbt.hk>

My answer is simply "No", you don't have to maintain backward 
compatibility for non-standard tx.

The same question applies to P2SH. Before the deployment of BIP16, one 
could have created a time-locked tx with one of the output was in the 
form of HASH160 <hash> EQUAL. The <hash>, however, is not a hash of a 
valid serialized script, so the output is now permanently frozen.

It also applies to all the OP codes disabled by Satoshi: one could have 
created a time-locked tx with those now disabled OP codes.

Same for BIP65 with the use of OP_NOP2. Following your logic, we can't 
make any softfork related to the script system.

I think it is very important to make it clear that non-standard txs and 
non-standard scripts may become invalid in the future

Gavin Andresen via bitcoin-dev ? 2015-10-28 10:06 ??:
> I'm hoping this fits under the moderation rule of "short-term changes
> to the Bitcoin protcol" (I'm not exactly clear on what is meant by
> "short-term"; it would be lovely if the moderators would start a
> thread on bitcoin-discuss to clarify that):
> 
> Should it be a requirement that ANY one-megabyte transaction that is
> valid
> under the existing rules also be valid under new rules?
> 
> Pro:  There could be expensive-to-validate transactions created and
> given a
> lockTime in the future stored somewhere safe. Their owners may have no
> other way of spending the funds (they might have thrown away the
> private
> keys), and changing validation rules to be more strict so that those
> transactions are invalid would be an unacceptable confiscation of
> funds.
> 
> Con: It is extremely unlikely there are any such large, timelocked
> transactions, because the Core code has had a clear policy for years
> that
> 100,000-byte transactions are &quot;standard&quot; and are relayed and
> mined, and
> larger transactions are not. The requirement should be relaxed so that
> only
> valid 100,000-byte transaction under old consensus rules must be valid
> under new consensus rules (larger transactions may or may not be
> valid).
> 
> I had to wrestle with that question when I implemented BIP101/Bitcoin
> XT
> when deciding on a limit for signature hashing (and decided the right
> answer was to support any "non-attack"1MB transaction; see
> https://bitcoincore.org/~gavin/ValidationSanity.pdf [1] for more
> details).
> 
> --
> 
> --
> Gavin Andresen
> 
> 
> Links:
> ------
> [1] https://bitcoincore.org/~gavin/ValidationSanity.pdf
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From luke at dashjr.org  Sun Nov  1 19:06:43 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 1 Nov 2015 19:06:43 +0000
Subject: [bitcoin-dev] BIP 113: Median time-past is a HARDfork,
	not a softfork!
Message-ID: <201511011906.44081.luke@dashjr.org>

BIP 113 makes things valid which currently are not (any transaction with a 
locktime between the median time past, and the block nTime). Therefore it is a 
hardfork. Yet the current BIP describes and deploys it as a softfork.

Furthermore, Bitcoin Core one week ago merged #6566 adding BIP 113 logic to 
the mempool and block creation. This will probably produce invalid blocks 
(which CNB's safety TestBlockValidity call should catch), and should be 
reverted until an appropriate solution is determined.

Rusty suggested something like adding N hours to the median time past for 
comparison, and to be a proper hardfork, this must be max()'d with the block 
nTime. On the other hand, if we will have a hardfork in the next year or so, 
it may be best to just hold off and deploy as part of that.

Further thoughts/input?

Luke

From tier.nolan at gmail.com  Sun Nov  1 23:46:39 2015
From: tier.nolan at gmail.com (Tier Nolan)
Date: Sun, 1 Nov 2015 23:46:39 +0000
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <df48a2c44441f39c71579aa5e474ec38@xbt.hk>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
Message-ID: <CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>

On Sun, Nov 1, 2015 at 5:28 PM, jl2012 via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I think it is very important to make it clear that non-standard txs and
> non-standard scripts may become invalid in the future
>

There can be unavoidable situations which cause locked coins become
unspendable.

In an ideal world, soft forks that make UTXOs unspendable should increase
the tx version number.  BIP-13 should have done that.  That would make the
change opt-in.

The disabled opcodes like OP_CAT were a DOS/network security change.

Invalidating locked coins is another reason that they shouldn't have been
disabled permanently.

It would have been better to disable them for six months, so at least
people can get their coins back after that.  Inherently, protecting the
network required some limitations being added so that nodes couldn't be
crashed.

For guidelines

* Transaction version numbers will be increased, if possible
* Transactions with unknown/large version numbers are unsafe to use with
locktime
* Reasonable notice is given that the change is being contemplated
* Non-opt-in changes will only be to protect the integrity of the network

Locked transaction that can be validated without excessive load on the
network should be safe to use, even if non-standard.

An OP_CAT script that requires TBs of RAM to validate crosses the threshold
of reasonableness.



>
> Gavin Andresen via bitcoin-dev ? 2015-10-28 10:06 ??:
>
>> I'm hoping this fits under the moderation rule of "short-term changes
>> to the Bitcoin protcol" (I'm not exactly clear on what is meant by
>> "short-term"; it would be lovely if the moderators would start a
>> thread on bitcoin-discuss to clarify that):
>>
>> Should it be a requirement that ANY one-megabyte transaction that is
>> valid
>> under the existing rules also be valid under new rules?
>>
>> Pro:  There could be expensive-to-validate transactions created and
>> given a
>> lockTime in the future stored somewhere safe. Their owners may have no
>> other way of spending the funds (they might have thrown away the
>> private
>> keys), and changing validation rules to be more strict so that those
>> transactions are invalid would be an unacceptable confiscation of
>> funds.
>>
>> Con: It is extremely unlikely there are any such large, timelocked
>> transactions, because the Core code has had a clear policy for years
>> that
>> 100,000-byte transactions are &quot;standard&quot; and are relayed and
>> mined, and
>> larger transactions are not. The requirement should be relaxed so that
>> only
>> valid 100,000-byte transaction under old consensus rules must be valid
>> under new consensus rules (larger transactions may or may not be
>> valid).
>>
>> I had to wrestle with that question when I implemented BIP101/Bitcoin
>> XT
>> when deciding on a limit for signature hashing (and decided the right
>> answer was to support any "non-attack"1MB transaction; see
>> https://bitcoincore.org/~gavin/ValidationSanity.pdf [1] for more
>> details).
>>
>> --
>>
>> --
>> Gavin Andresen
>>
>>
>> Links:
>> ------
>> [1] https://bitcoincore.org/~gavin/ValidationSanity.pdf
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/ba76df82/attachment.html>

From justus at openbitcoinprivacyproject.org  Mon Nov  2 00:23:27 2015
From: justus at openbitcoinprivacyproject.org (Justus Ranvier)
Date: Sun, 1 Nov 2015 18:23:27 -0600
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
Message-ID: <5636ACFF.5040908@openbitcoinprivacyproject.org>

On 11/01/2015 05:46 PM, Tier Nolan via bitcoin-dev wrote:
> An OP_CAT script that requires TBs of RAM to validate crosses the
> threshold of reasonableness. 

Are there actually any OP_CAT scripts currently in the utxo set?

It's one thing to have a theoretical scripting ability that gets removed
before anyone actually uses it - that doesn't put anyone in the position
of retroactively making decisions about the validity of someone else's
money.

Presently the utxo set is about $5 billion worth of other people's money.

It's a lot easier to justify the position: "nobody has the right to
change the meaning of someone else's outputs", than it is to justify,
"some small group of people gets to decide what's standard and what
isn't, and if you choose to use the network in a valid but nonstandard
way, that group of people might choose to deny you access to your money
in the future"

In other words, how close to the shores of "administrators of a virtual
currency" do Bitcoin developers want to sail?


-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 23337 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/173b3946/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/173b3946/attachment-0001.sig>

From luke at dashjr.org  Mon Nov  2 00:33:18 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 2 Nov 2015 00:33:18 +0000
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <5636ACFF.5040908@openbitcoinprivacyproject.org>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
	<5636ACFF.5040908@openbitcoinprivacyproject.org>
Message-ID: <201511020033.19291.luke@dashjr.org>

On Monday, November 02, 2015 12:23:27 AM Justus Ranvier via bitcoin-dev wrote:
> It's a lot easier to justify the position: "nobody has the right to
> change the meaning of someone else's outputs", than it is to justify,
> "some small group of people gets to decide what's standard and what
> isn't, and if you choose to use the network in a valid but nonstandard
> way, that group of people might choose to deny you access to your money
> in the future"

The reality is presently "some small group of people gets to decide how and if 
you can access your money"... and it's getting worse.

> In other words, how close to the shores of "administrators of a virtual
> currency" do Bitcoin developers want to sail?

Bitcoin developers don't make this decision, miners do.

Luke

From tier.nolan at gmail.com  Mon Nov  2 01:30:51 2015
From: tier.nolan at gmail.com (Tier Nolan)
Date: Mon, 2 Nov 2015 01:30:51 +0000
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <5636ACFF.5040908@openbitcoinprivacyproject.org>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
	<5636ACFF.5040908@openbitcoinprivacyproject.org>
Message-ID: <CAE-z3OVDT-0cYq4Hh_OozWEp-UEj6yxbyon6YhOretgKPRLfFg@mail.gmail.com>

On Mon, Nov 2, 2015 at 12:23 AM, Justus Ranvier via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Are there actually any OP_CAT scripts currently in the utxo set?
>

A locked transaction could pay to an OP_CAT script with the private key
being lost.

Even if it is only in theory, it is still worth trying to prevent rule
changes which permanently prevent outputs being spendable.


> It's a lot easier to justify the position: "nobody has the right to
> change the meaning of someone else's outputs", than it is to justify,
> "some small group of people gets to decide what's standard and what
> isn't, and if you choose to use the network in a valid but nonstandard
> way, that group of people might choose to deny you access to your money
> in the future"
>

If at least one year's notice was given, then people aren't going to lose
their money, since they have notice.

Locked transactions could have a difference expectation than non-locked
ones.


> In other words, how close to the shores of "administrators of a virtual
> currency" do Bitcoin developers want to sail?
>

Miners can collectively vote to disable specific UTXOs and change the
acceptance rules.


>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/5514cf3c/attachment.html>

From justus at openbitcoinprivacyproject.org  Mon Nov  2 04:15:36 2015
From: justus at openbitcoinprivacyproject.org (Justus Ranvier)
Date: Sun, 1 Nov 2015 22:15:36 -0600
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CAE-z3OVDT-0cYq4Hh_OozWEp-UEj6yxbyon6YhOretgKPRLfFg@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
	<5636ACFF.5040908@openbitcoinprivacyproject.org>
	<CAE-z3OVDT-0cYq4Hh_OozWEp-UEj6yxbyon6YhOretgKPRLfFg@mail.gmail.com>
Message-ID: <5636E368.3030808@openbitcoinprivacyproject.org>

I guess by "locked transaction" you must mean a P2SH output?

If so, that's a rather bizarre use of terms since outputs and
transactions are very different things.


-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 23337 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/f3ff4eea/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151101/f3ff4eea/attachment-0001.sig>

From jl2012 at xbt.hk  Mon Nov  2 04:27:50 2015
From: jl2012 at xbt.hk (jl2012 at xbt.hk)
Date: Sun, 01 Nov 2015 23:27:50 -0500
Subject: [bitcoin-dev] BIP 113: Median time-past is a HARDfork,
 not a softfork!
In-Reply-To: <201511011906.44081.luke@dashjr.org>
References: <201511011906.44081.luke@dashjr.org>
Message-ID: <67789addeb5a0e702998f26cc16a8dbd@xbt.hk>

Currently, a tx maybe included in a block only if its locktime (x) is 
smaller than the timestamp of a block (y)

BIP113 says that a tx maybe included in a block only if x is smaller 
than the median-time-past (z)

It is already a consensus rule that y > z. Therefore, if x < z, x < y

The new rule is absolutely stricter than the old rule, so it is a 
softfork. Anything wrong with my interpretation?

Luke Dashjr via bitcoin-dev ? 2015-11-01 14:06 ??:
> BIP 113 makes things valid which currently are not (any transaction 
> with a
> locktime between the median time past, and the block nTime). Therefore 
> it is a
> hardfork. Yet the current BIP describes and deploys it as a softfork.
> 
> Furthermore, Bitcoin Core one week ago merged #6566 adding BIP 113 
> logic to
> the mempool and block creation. This will probably produce invalid 
> blocks
> (which CNB's safety TestBlockValidity call should catch), and should be
> reverted until an appropriate solution is determined.
> 
> Rusty suggested something like adding N hours to the median time past 
> for
> comparison, and to be a proper hardfork, this must be max()'d with the 
> block
> nTime. On the other hand, if we will have a hardfork in the next year 
> or so,
> it may be best to just hold off and deploy as part of that.
> 
> Further thoughts/input?
> 
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From luke at dashjr.org  Mon Nov  2 05:06:36 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 2 Nov 2015 05:06:36 +0000
Subject: [bitcoin-dev] BIP 113: Median time-past is a HARDfork,
	not a softfork!
In-Reply-To: <67789addeb5a0e702998f26cc16a8dbd@xbt.hk>
References: <201511011906.44081.luke@dashjr.org>
	<67789addeb5a0e702998f26cc16a8dbd@xbt.hk>
Message-ID: <201511020506.37593.luke@dashjr.org>

On Monday, November 02, 2015 4:27:50 AM jl2012 at xbt.hk wrote:
> Currently, a tx maybe included in a block only if its locktime (x) is
> smaller than the timestamp of a block (y)
> 
> BIP113 says that a tx maybe included in a block only if x is smaller
> than the median-time-past (z)
> 
> It is already a consensus rule that y > z. Therefore, if x < z, x < y
> 
> The new rule is absolutely stricter than the old rule, so it is a
> softfork. Anything wrong with my interpretation?

I agree, false alarm. Somehow I had confused the comparison of locktimes this 
morning. :(

Sorry about that,

Luke

From justus at openbitcoinprivacyproject.org  Mon Nov  2 06:12:16 2015
From: justus at openbitcoinprivacyproject.org (Justus Ranvier)
Date: Mon, 2 Nov 2015 00:12:16 -0600
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CAE-z3OVDT-0cYq4Hh_OozWEp-UEj6yxbyon6YhOretgKPRLfFg@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
	<5636ACFF.5040908@openbitcoinprivacyproject.org>
	<CAE-z3OVDT-0cYq4Hh_OozWEp-UEj6yxbyon6YhOretgKPRLfFg@mail.gmail.com>
Message-ID: <5636FEC0.2010802@openbitcoinprivacyproject.org>

On 11/01/2015 07:30 PM, Tier Nolan via bitcoin-dev wrote:
> If at least one year's notice was given, then people aren't going to
> lose their money, since they have notice.

So after realizing that I misread substantial portions of this thread
due to a lack of attention to detail I'd like to point out this:

Bitcoin nodes have the capability to validate blocks going back to the
genesis block, including blocks which would not be valid if mined today
under current rules.

Therefore it must be the case that all the old consensus rules are
preserved somewhere in the current code bases of the various
implementations.

Given that, there shouldn't be any technical barrier to validating input
scripts according to the consensus rules that were in effect at the time
the input being spent was added to the blockchain.

Maybe dealing with output is more difficult.

Had every consensus rule change (deliberate and accidental) been
accompanied by a version number bump, it would have been possible to
phase out old versions without invaliding signed-but-unbroadcast
transactions by saying "as of block height x, transactions with version
y or lower are invalid unless their inputs are exclusively sourced from
blocks with heights < x"

If there already have been rule changes which have retroactively
invalided unbroadcast transactions which were valid at the time they
were signed, those rules could be relaxed to not apply to transactions
which exclusively spend inputs that existed before the rule change.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 23337 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/30e16f8d/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/30e16f8d/attachment-0001.sig>

From dstadulis at gmail.com  Mon Nov  2 10:55:38 2015
From: dstadulis at gmail.com (Daniel Stadulis)
Date: Mon, 2 Nov 2015 11:55:38 +0100
Subject: [bitcoin-dev] #bitcoin-dev Weekly Development Meeting Minutes
	2015-10-29
Message-ID: <CAHpxFbEO5eg3kyM-gh17BYib3cXhRNMz0wroLQx1Uwgk9vwz0Q@mail.gmail.com>

Google Docs formatted version:
https://docs.google.com/document/d/1t3kGkAUQ-Yui57P29YhDll5WyJuTiGrUhCW8so-E-iQ/edit?usp=sharing


Meeting Title:
#bitcoin-dev Weekly Development Meeting
Meeting Date:
2015-10-29
Meeting Time:
19:00-20:00 UTC

Participants in Attendance:
dstadulis
morcos
sipa
jgarzik
rusty
warren
jeremyrubin
evoskuil
Luke-Jr
dcousens
gmaxwell
jtimon
mcelrath
btcdrak

IRC Chat Logs:
http://bitcoinstats.com/irc/bitcoin-dev/logs/2015/10/29#l1446145135.0

--------------------------------------------------------------------------------

Topics discussed:

1. Upcoming softfork
1.1 Solely CLTV (morcos, petertodd, dcousens)
1.2 Softfork coordination with other clients
2. Chain Limits Agreement Status
2.1 What should be sufficient consensus for merges?
3. Backporting Policy
4. Leveldb Replacement
4.1 Can be considered when code is abstracted, allows for testing,
alternative implementations exist. Testing encouraged, no future moves
planned.
5. Clang format
5.1 History review:  Proposal a while ago was to clang-format file set <a b
c ...>   Once done, maintain those files' formatting with automation (git
hook checks or whatnot)
5.2 Clang format behavior changes "randomly" from version to version.
6. BIP-68: ?Mempool-only sequence number constraint verification?
Implementation PR #6312
6.1 Concern regarding skipping missing inputs
7. BIP-112: Mempool-only CHECKSEQUENCEVERIFY PR #6564


2015-10-29 Meeting Conclusions:

#
Action items
Responsible Parties
ETA/Due Date
1
Morcos to report chain stats


2
Review BIP68 implementation #6312
sipa, rusty

--------------------------------------------------------------------------------

Meetingbot Minutes
Minutes(HTML)
http://www.erisian.com.au/meetbot/bitcoin-dev/2015/bitcoin-dev.2015-10-29-19.02.html
Minutes(text)
http://www.erisian.com.au/meetbot/bitcoin-dev/2015/bitcoin-dev.2015-10-29-19.02.txt
IRC Log:
http://www.erisian.com.au/meetbot/bitcoin-dev/2015/bitcoin-dev.2015-10-29-19.02.log.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/c44e94e9/attachment.html>

From panos.sakkos at gmail.com  Mon Nov  2 13:30:48 2015
From: panos.sakkos at gmail.com (Panos Sakkos)
Date: Mon, 2 Nov 2015 14:30:48 +0100
Subject: [bitcoin-dev] Ramping up with bitcoin core engineering?
Message-ID: <CAERNvEQ6vGvf57N3LdiKZduSMWpyTMyptm-_pVE2y+gBeKtq0Q@mail.gmail.com>

Hey,

I'm interested in helping out with the development of Bitcoin Core.
I'm used to getting involved with huge projects by starting to write unit
tests (in order to get familiar with the project's tools, infrastructure
etc).

Is there any ramp up process (like for example any documentation) that I
can start with?

Also, if you are a leading a test effort and you need a hand, please 'r' me
:)

Thanks in advance!
:panos
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/ae151b8d/attachment.html>

From gavinandresen at gmail.com  Mon Nov  2 20:33:47 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Mon, 2 Nov 2015 15:33:47 -0500
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
Message-ID: <CABsx9T3w-=bqbfmG=gVxJ8SQZCoEXA7vQbFD+kC2CH36bd=xPw@mail.gmail.com>

On Sun, Nov 1, 2015 at 6:46 PM, Tier Nolan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> For guidelines
>
> * Transaction version numbers will be increased, if possible
> * Transactions with unknown/large version numbers are unsafe to use with
> locktime
> * Reasonable notice is given that the change is being contemplated
> * Non-opt-in changes will only be to protect the integrity of the network
>
> Locked transaction that can be validated without excessive load on the
> network should be safe to use, even if non-standard.
>
> An OP_CAT script that requires TBs of RAM to validate crosses the
> threshold of reasonableness.
>

I like those guidelines, although I'm sure there may be lots of arguing
over what fits under "protects the integrity of the network" or what
constitutes "reasonable notice" (publish a BIP at least 30 days before
rolling out a change? 60 days? a year?)

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/193dffef/attachment.html>

From eric at ericmartindale.com  Mon Nov  2 21:05:39 2015
From: eric at ericmartindale.com (Eric Martindale)
Date: Mon, 02 Nov 2015 21:05:39 +0000
Subject: [bitcoin-dev] Ramping up with bitcoin core engineering?
In-Reply-To: <CAERNvEQ6vGvf57N3LdiKZduSMWpyTMyptm-_pVE2y+gBeKtq0Q@mail.gmail.com>
References: <CAERNvEQ6vGvf57N3LdiKZduSMWpyTMyptm-_pVE2y+gBeKtq0Q@mail.gmail.com>
Message-ID: <CAAf19WoPd7oZG5MaDfu4Mi0mb=4uv6zGEd1XqLMY7D3sX2UR6A@mail.gmail.com>

The Bitcoin.org Development Guide has grown by leaps in bounds this year,
and has two great introductions:

1. https://bitcoin.org/en/development for an overview of how a developer
can contribute,
2. https://bitcoin.org/en/developer-reference for in-detail reference to
how the whole system works.

Other great places to get involved or find more detail include the Bitcoin
Wiki <https://en.bitcoin.it/wiki/Main_Page> and the #bitcoin-dev room on
Freenode <irc://irc.freenode.net/bitcoin-dev>.

Hope that helps!

On Mon, Nov 2, 2015 at 6:03 AM Panos Sakkos via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hey,
>
> I'm interested in helping out with the development of Bitcoin Core.
> I'm used to getting involved with huge projects by starting to write unit
> tests (in order to get familiar with the project's tools, infrastructure
> etc).
>
> Is there any ramp up process (like for example any documentation) that I
> can start with?
>
> Also, if you are a leading a test effort and you need a hand, please 'r'
> me :)
>
> Thanks in advance!
> :panos
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/b79cc42e/attachment.html>

From justus at openbitcoinprivacyproject.org  Mon Nov  2 22:12:29 2015
From: justus at openbitcoinprivacyproject.org (Justus Ranvier)
Date: Mon, 2 Nov 2015 16:12:29 -0600
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CABsx9T3w-=bqbfmG=gVxJ8SQZCoEXA7vQbFD+kC2CH36bd=xPw@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
	<CABsx9T3w-=bqbfmG=gVxJ8SQZCoEXA7vQbFD+kC2CH36bd=xPw@mail.gmail.com>
Message-ID: <5637DFCD.1010009@openbitcoinprivacyproject.org>

On 02/11/15 14:33, Gavin Andresen via bitcoin-dev wrote:
> I like those guidelines, although I'm sure there may be lots of arguing
> over what fits under "protects the integrity of the network" or what
> constitutes "reasonable notice" (publish a BIP at least 30 days before
> rolling out a change? 60 days? a year?)

If Bitcoin were perfect. then it would be the case that any transaction
that was valid at the time it was signed would always remain valid until
spent regardless of any protocol changes which occurred in the interim.

Certainly, that property, if it was possible to achieve, would give
Bitcoin maximum possible utility compared to alternative properties.

There are cases in which that guarantee can be met, and there are some
pathological cases where it can not be met.

It's not possible to know if the pathological cases are actually a real
problem in practice, because the possible existence of unbroadcast
transactions which would trigger them is unknowable.

A possible lazy/optimistic strategy is to implement as much
non-pathological backward compatibility as possible, and treat unhandled
cases as outstanding bugs whose resolution is deferred unless and until
they are actually triggered.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xEAD9E623.asc
Type: application/pgp-keys
Size: 18442 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/79c74617/attachment-0001.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151102/79c74617/attachment-0001.sig>

From jl2012 at xbt.hk  Tue Nov  3 05:32:18 2015
From: jl2012 at xbt.hk (jl2012 at xbt.hk)
Date: Tue, 03 Nov 2015 00:32:18 -0500
Subject: [bitcoin-dev] Compatibility requirements for hard or soft forks
In-Reply-To: <CABsx9T3w-=bqbfmG=gVxJ8SQZCoEXA7vQbFD+kC2CH36bd=xPw@mail.gmail.com>
References: <CABsx9T0Evf3B_NtmdKxc_M1xRQh-jSC4JzTHCx8Ez9RzCypvMg@mail.gmail.com>
	<df48a2c44441f39c71579aa5e474ec38@xbt.hk>
	<CAE-z3OWJ8YvXU5aGqgs9VJnW99va=0=FoObmpHS3irg4Kh6wrQ@mail.gmail.com>
	<CABsx9T3w-=bqbfmG=gVxJ8SQZCoEXA7vQbFD+kC2CH36bd=xPw@mail.gmail.com>
Message-ID: <ceb486d3be77383158b15be98bfdc11f@xbt.hk>

The other strategy is to have an informational BIP to define "safe" use 
of Bitcoin.

1. scriptPubKey must be one of the following types: P2PK, P2PKH, P2SH, 
n-of-m multisig with m < 4 (with or without CLTV or CSV, we should 
define standard use of CLTV and CSV)

2. For P2SH, the serialized script must be one of the standard type

3. No use of unknown transaction version

4. Tx size < 100k

5. If conditions 1-4 are all satisfied, the locktime must not be longer 
than 4 years from the creation of the tx

6. If at least one of the conditions 1-4 is not satisfied, the lock time 
must not be longer than 6 months from the creation of the tx

7. A chain of unconfirmed transactions is unsafe due the malleability

8. Tx created by wallet software last updated 1 year ago is unsafe

9. Permanently deleting a private key is unsafe (that might be safe if 
stricter practice is followed)

We must not introduce a new rule that may permanently invalidate a safe 
tx, unless in emergency. Even in emergency, we should try to preserve 
backward compatibility as much as possible (see the example at the end 
of my message)

Being unsafe means there is a chance that the tx may become 
unconfirmable, outputs become unspendable, or funds may be stolen 
without a private key.

A grace period of 5 years must be given for "soft-fork" type change of 
any of the rules. For example it is ok to introduce new standard script 
anytime but not to remove.

----------------------

Back to Gavin's original question. If you want to somehow keep backward 
compatibility for expensive-to-validate transactions in the future, you 
may have rules like there could only be at most one 
expensive-to-validate transaction in every 10 blocks, until year 2025. I 
know this is over-complicated but it's a possible way to address your 
concern.



Gavin Andresen via bitcoin-dev ? 2015-11-02 15:33 ??:
> On Sun, Nov 1, 2015 at 6:46 PM, Tier Nolan via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> For guidelines
>> 
>> * Transaction version numbers will be increased, if possible
>> 
>> * Transactions with unknown/large version numbers are unsafe to use
>> with locktime
>> 
>> * Reasonable notice is given that the change is being contemplated
>> 
>> * Non-opt-in changes will only be to protect the integrity of the
>> network
>> 
>> Locked transaction that can be validated without excessive load on
>> the network should be safe to use, even if non-standard.
>> 
>> An OP_CAT script that requires TBs of RAM to validate crosses the
>> threshold of reasonableness.
> 
> I like those guidelines, although I'm sure there may be lots of
> arguing over what fits under "protects the integrity of the network"
> or what constitutes "reasonable notice" (publish a BIP at least 30
> days before rolling out a change? 60 days? a year?)
> 
> --
> 
> --
> Gavin Andresen
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From decker.christian at gmail.com  Tue Nov  3 20:37:44 2015
From: decker.christian at gmail.com (Christian Decker)
Date: Tue, 03 Nov 2015 20:37:44 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <201510220905.27124.luke@dashjr.org>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201510212320.31052.luke@dashjr.org>
	<CALxbBHUK_na0qKEBrkCzV2oAUc90wpL4z=7h6Zuu4XzaKEazrA@mail.gmail.com>
	<201510220905.27124.luke@dashjr.org>
Message-ID: <CALxbBHV4JU7TG8QutkX7m9V4n_ANgKAgWO8ZA2KxQk8jP=kF0g@mail.gmail.com>

Ok, getting the ball rolling again after some downtime. I amended the
proposal to use a simple version number instead of the binary flags, added
the normalization of inputs before computing the signaturehash and added
Schnorr signatures as requested.

The BIP has also been assigned number 130 :-)

I am still very much intrigued by Luke's idea of having empty scriptsigs
and ship the signatures in external scripts, however the proposal uses the
on-the-fly normalization because we have no good way of relaying the
external scripts. Since we are still in the drafting phase I am open to
suggestions and if there is a good/working solution I can amend/withdraw
the proposal.

As for open venues for malleability, I'm not sure we can fix them at all,
after all the ability of a single signer to doublespend by
appending/replacing inputs/outputs in an arbitrary fashion is not fixable
IMHO and will cause any future transaction building on its outputs to be
orphaned. What would the perfect properties for such a fix be?

Regards,
Christian

On Thu, Oct 22, 2015 at 11:05 AM Luke Dashjr <luke at dashjr.org> wrote:

> On Thursday, October 22, 2015 8:26:58 AM Christian Decker wrote:
> > I think the scenario of the single signer re-ordering the outputs and
> > inputs and then re-signing the transaction is in the same category of
> > simple double-spends. The signer could just as well sign a completely
> > different transaction spending the same coins to somewhere else, so I
> don't
> > think there is a lot we can do about it even if we instate a canonical
> > ordering. Even if we order the inputs and outputs the signer can just
> add a
> > new input and output and we would have a different transaction.
> >
> > Normalized transaction IDs do help in the case that the single signer
> wants
> > to immediately follow up its transaction with another transaction
> spending
> > the first one's change output, and it prevents any modification in the
> > multi-signer scenario.
>
> Except that unlike malicious double spending, adding more outputs to
> unconfirmed transactions is what wallets *should ideally be doing every
> time
> they send another transaction*. Spending unconfirmed change is the wrong
> approach. So half-fixing malleability as this PR would, encourages
> inefficient behaviour in multiple ways (first, by not making it
> malleability-
> safe; second, by encouraging spending unconfirmed change).
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151103/be9e24b3/attachment.html>

From luke at dashjr.org  Tue Nov  3 20:48:17 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 3 Nov 2015 20:48:17 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <CALxbBHV4JU7TG8QutkX7m9V4n_ANgKAgWO8ZA2KxQk8jP=kF0g@mail.gmail.com>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201510220905.27124.luke@dashjr.org>
	<CALxbBHV4JU7TG8QutkX7m9V4n_ANgKAgWO8ZA2KxQk8jP=kF0g@mail.gmail.com>
Message-ID: <201511032048.18680.luke@dashjr.org>

On Tuesday, November 03, 2015 8:37:44 PM Christian Decker wrote:
> I am still very much intrigued by Luke's idea of having empty scriptsigs
> and ship the signatures in external scripts, however the proposal uses the
> on-the-fly normalization because we have no good way of relaying the
> external scripts. Since we are still in the drafting phase I am open to
> suggestions and if there is a good/working solution I can amend/withdraw
> the proposal.

Changing the network protocol is trivial in comparison to making a permanent 
increase in UTXO set costs.

> As for open venues for malleability, I'm not sure we can fix them at all,
> after all the ability of a single signer to doublespend by
> appending/replacing inputs/outputs in an arbitrary fashion is not fixable
> IMHO and will cause any future transaction building on its outputs to be
> orphaned. What would the perfect properties for such a fix be?

The problem isn't changing inputs/outputs, but that such changes invalidate 
later spends. In particular, note that wallets *should ideally* be actively 
trying to make transfers using multiple malleated versions of the same 
payment.

So the way to make an anti-malleable wallet, would be to strictly enforce the 
no-address-reuse rule on payments received (note this has no effect on 
other/current wallets) and rely only on the hash of that scriptPubKey+value 
for the input in subsequent transactions. This way, no matter what inputs or 
other outputs the transaction paying the address/invoice uses, the subsequent 
transaction ignores them and remains valid. (I am not suggesting this as a 
mandatory change that all wallets must adopt to receive the current semi-
malleability protection you propose - only that it be *possible* for wallets 
to upgrade to or offer in the future.)

Luke

From decker.christian at gmail.com  Tue Nov  3 21:44:02 2015
From: decker.christian at gmail.com (Christian Decker)
Date: Tue, 03 Nov 2015 21:44:02 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <201511032048.18680.luke@dashjr.org>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201510220905.27124.luke@dashjr.org>
	<CALxbBHV4JU7TG8QutkX7m9V4n_ANgKAgWO8ZA2KxQk8jP=kF0g@mail.gmail.com>
	<201511032048.18680.luke@dashjr.org>
Message-ID: <CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>

On Tue, Nov 3, 2015 at 9:49 PM Luke Dashjr <luke at dashjr.org> wrote:

> On Tuesday, November 03, 2015 8:37:44 PM Christian Decker wrote:
> > I am still very much intrigued by Luke's idea of having empty scriptsigs
> > and ship the signatures in external scripts, however the proposal uses
> the
> > on-the-fly normalization because we have no good way of relaying the
> > external scripts. Since we are still in the drafting phase I am open to
> > suggestions and if there is a good/working solution I can amend/withdraw
> > the proposal.
>
> Changing the network protocol is trivial in comparison to making a
> permanent
> increase in UTXO set costs.
>

Ok, so assuming we can get a connected component of upgraded nodes that
relay both the transaction and the associated external scripts then we
could just piggyback the external scripts on top of the normal messages.
Non-upgraded nodes will read the entire two-part message but only parse the
classical transaction, dropping the external script. Validation rules for
upgraded nodes are the same as before: if the attached signatures are
invalid the entire TX is dropped. We have to commit to the external scripts
used during the creation of a block. I think the easiest way to add this
commitment is the coinbase input I guess, and following the transaction
list a new list of signature lists is shipped with the rest of the block.
Non-upgraded will ignore it as before.

Would that work? It all hinges on having upgraded miners in a connected
component otherwise non-upgraded nodes will drop the external scripts on
the way (since they parse and then reconstruct the messages along the
path). But if it works this could be a much nicer solution.


>
> > As for open venues for malleability, I'm not sure we can fix them at all,
> > after all the ability of a single signer to doublespend by
> > appending/replacing inputs/outputs in an arbitrary fashion is not fixable
> > IMHO and will cause any future transaction building on its outputs to be
> > orphaned. What would the perfect properties for such a fix be?
>
> The problem isn't changing inputs/outputs, but that such changes invalidate
> later spends. In particular, note that wallets *should ideally* be actively
> trying to make transfers using multiple malleated versions of the same
> payment.
>

So this is indeed a form of desired malleability we will likely not be able
to fix. I'd argue that this goes more into the direction of double-spending
than a form of malleability, and is mostly out of scope for this BIP. As
the abstract mentions this BIP attempts to eliminate damage incurred by
malleability in the third party modification scenario and in the multisig
scenario, with the added benefit of enabling transaction templating. If we
can get the segregated witnesses approach working all the better, we don't
even have the penalty of increased UTXO size. The problem of singlesig
users doublespending their outputs to update transactions remains a problem
even then.


>
> So the way to make an anti-malleable wallet, would be to strictly enforce
> the
> no-address-reuse rule on payments received (note this has no effect on
> other/current wallets) and rely only on the hash of that scriptPubKey+value
> for the input in subsequent transactions. This way, no matter what inputs
> or
> other outputs the transaction paying the address/invoice uses, the
> subsequent
> transaction ignores them and remains valid. (I am not suggesting this as a
> mandatory change that all wallets must adopt to receive the current semi-
> malleability protection you propose - only that it be *possible* for
> wallets
> to upgrade to or offer in the future.)
>

Sounds very interesting. That would then be a new signature checking opcode
I guess that would allow the transaction hash in the input be replaced by
the hash of the serialized output it is spending? That way the transaction
would not be detached from the coins unless the amount or the scriptpubkey
(containing the address) is modified. So a user may add new outputs and
inputs to an existing transaction like you mentioned. This does not help
someone receiving funds from a sender to build new transactions on top
since the sender may simply doublespend its output before it is confirmed.
I think this is probably best addressed in a separate proposal.


>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151103/63439a8f/attachment.html>

From luke at dashjr.org  Tue Nov  3 22:01:20 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 3 Nov 2015 22:01:20 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032048.18680.luke@dashjr.org>
	<CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
Message-ID: <201511032201.21047.luke@dashjr.org>

On Tuesday, November 03, 2015 9:44:02 PM Christian Decker wrote:
> Ok, so assuming we can get a connected component of upgraded nodes that
> relay both the transaction and the associated external scripts then we
> could just piggyback the external scripts on top of the normal messages.
> Non-upgraded nodes will read the entire two-part message but only parse the
> classical transaction, dropping the external script. Validation rules for
> upgraded nodes are the same as before: if the attached signatures are
> invalid the entire TX is dropped. We have to commit to the external scripts
> used during the creation of a block. I think the easiest way to add this
> commitment is the coinbase input I guess, and following the transaction
> list a new list of signature lists is shipped with the rest of the block.
> Non-upgraded will ignore it as before.

I'd throw it in the merged-mining tree; it's not ideal, but it can be swapped 
out for something better when it's ready (I'm working on such a BIP - 
hopefully it can be before or at the same time as a SW deployment).

> Would that work? It all hinges on having upgraded miners in a connected
> component otherwise non-upgraded nodes will drop the external scripts on
> the way (since they parse and then reconstruct the messages along the
> path). But if it works this could be a much nicer solution.

It's actually better than that. If miners don't get the SW transactions, then 
they just won't mine them, and the wallets will continue to rebroadcast until 
they do. But realistically, the entire network will likely be running SW-
capable nodes long before any wallets have deployed SW transactions.

> > > As for open venues for malleability, I'm not sure we can fix them at
> > > all, after all the ability of a single signer to doublespend by
> > > appending/replacing inputs/outputs in an arbitrary fashion is not
> > > fixable IMHO and will cause any future transaction building on its
> > > outputs to be orphaned. What would the perfect properties for such a
> > > fix be?
> > 
> > The problem isn't changing inputs/outputs, but that such changes
> > invalidate later spends. In particular, note that wallets *should
> > ideally* be actively trying to make transfers using multiple malleated
> > versions of the same payment.
> 
> So this is indeed a form of desired malleability we will likely not be able
> to fix. I'd argue that this goes more into the direction of double-spending
> than a form of malleability, and is mostly out of scope for this BIP. As
> the abstract mentions this BIP attempts to eliminate damage incurred by
> malleability in the third party modification scenario and in the multisig
> scenario, with the added benefit of enabling transaction templating. If we
> can get the segregated witnesses approach working all the better, we don't
> even have the penalty of increased UTXO size. The problem of singlesig
> users doublespending their outputs to update transactions remains a problem
> even then.

I don't know what you're trying to say here. Double spending to the same 
destination(s) and malleability are literally the same thing. Things affected 
by malleability are still just as broken even with this BIP - whether it is 
triggered by a third-party or not is not very relevant.

> > So the way to make an anti-malleable wallet, would be to strictly enforce
> > the
> > no-address-reuse rule on payments received (note this has no effect on
> > other/current wallets) and rely only on the hash of that
> > scriptPubKey+value for the input in subsequent transactions. This way,
> > no matter what inputs or
> > other outputs the transaction paying the address/invoice uses, the
> > subsequent
> > transaction ignores them and remains valid. (I am not suggesting this as
> > a mandatory change that all wallets must adopt to receive the current
> > semi- malleability protection you propose - only that it be *possible*
> > for wallets
> > to upgrade to or offer in the future.)
> 
> Sounds very interesting. That would then be a new signature checking opcode
> I guess that would allow the transaction hash in the input be replaced by
> the hash of the serialized output it is spending? That way the transaction
> would not be detached from the coins unless the amount or the scriptpubkey
> (containing the address) is modified. So a user may add new outputs and
> inputs to an existing transaction like you mentioned. 

Correct...

> This does not help someone receiving funds from a sender to build new
> transactions on top since the sender may simply doublespend its output
> before it is confirmed. I think this is probably best addressed in a
> separate proposal.

Huh??

Luke

From pete at petertodd.org  Wed Nov  4 04:00:33 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 3 Nov 2015 23:00:33 -0500
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201510220905.27124.luke@dashjr.org>
	<CALxbBHV4JU7TG8QutkX7m9V4n_ANgKAgWO8ZA2KxQk8jP=kF0g@mail.gmail.com>
	<201511032048.18680.luke@dashjr.org>
	<CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
Message-ID: <20151104040033.GA26961@muck>

On Tue, Nov 03, 2015 at 09:44:02PM +0000, Christian Decker via bitcoin-dev wrote:
> Ok, so assuming we can get a connected component of upgraded nodes that
> relay both the transaction and the associated external scripts then we
> could just piggyback the external scripts on top of the normal messages.
> Non-upgraded nodes will read the entire two-part message but only parse the
> classical transaction, dropping the external script. Validation rules for
> upgraded nodes are the same as before: if the attached signatures are
> invalid the entire TX is dropped. We have to commit to the external scripts
> used during the creation of a block. I think the easiest way to add this
> commitment is the coinbase input I guess, and following the transaction
> list a new list of signature lists is shipped with the rest of the block.
> Non-upgraded will ignore it as before.
> 
> Would that work? It all hinges on having upgraded miners in a connected
> component otherwise non-upgraded nodes will drop the external scripts on
> the way (since they parse and then reconstruct the messages along the
> path). But if it works this could be a much nicer solution.

FWIW my replace-by-fee fork does preferential peering with other RBF
nodes to ensure that you'll always be connected to at least some
full-RBF peers. In practice this works very well, and I'm sure a similar
scheme could be used in this situation as well.

Basically, conceptually unless you're connected to peers that advertise
that they relay the new data, you treat the situation as though you're
not connected to any peers at all. No different than if for some reason
none of your peers were advertising NODE_NETWORK.

-- 
'peter'[:-1]@petertodd.org
00000000000000000247b0e7436a5169ac6f9087be0295d10b07bf0bcbd4c0cc
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151103/cea084c1/attachment.sig>

From mark at friedenbach.org  Wed Nov  4 22:47:35 2015
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 4 Nov 2015 14:47:35 -0800
Subject: [bitcoin-dev] A validation-cost metric for aggregate limits and fee
	determination
Message-ID: <CAOG=w-tR89zm_VDCR-MR_+F9bRNvm4TCZSQcTmYGKRW1JQhkUg@mail.gmail.com>

At the first Scaling Bitcoin workshop in Montreal I presented on the topic
of "bad blocks" that take an excessive amount of time to validate. You can
read a transcript of this talk here:

http://diyhpl.us/wiki/transcripts/scalingbitcoin/alternatives-to-block-size-as-aggregate-resource-limits/

The core message was that the assumption made by the design parameters of
the system, namely that validation costs scale linearly with transaction or
block size, is wrong. In particular, in certain kinds of transactions there
are validation costs which scale quadraticly with size. For example, the
construction of SIGHASH_ALL results in each input signing a different
message digest, meaning that the entire transaction (minus the scriptSigs)
is rehashed for each input. As another example, the number of signature
operation performed during block validation is unlimited if the validations
are contained within the scriptPubKey (this scales linearly but with a very
large constant factor). The severity of these issues increase as the
aggregate limits in place on maximum transaction and block size increase.

There have been various solutions suggested, and I would like to start a
public discussion to see if consensus can be reached over a viable approach.

Gavin, for example, has written code that tracks the number of bytes hashed
and enforces a separate limit for a block over this aggregate value. Other
costs could be constrained in a similar whack-a-mole way. I have two
concerns with this approach:

1. There would still exist a gap between the average-case validation cost
of a full block and the worst case validation cost of a block that was
specifically constructed to hit every limit.

2. Transaction selection and by extension fee determination would become
much more complicated multi-dimensional optimization problems. Since fee
management in particular is code replicated in a lot of infrastructure, I
would be very concerned over making optimal behavior greatly more difficult.

My own suggestion, which I submit for consideration, is to use a linear
function of the various costs involved (signatures verified, bytes hashed,
inputs consumed, script opcodes executed, etc.). The various algorithms
used for transaction selection and fee determination can then be reused,
using the output of this new linear function as the "size" of the
transaction.

Separately, many others including Greg Maxwell have advocated for a
"net-UTXO" metric instead of, or in combination with a validation-cost
metric. In the pure form the block size limit would be replaced with a
maximum UTXO set increase, thereby applying a cost in extra fee required to
create unspent outputs. This has the distinct advantage of making dust
outputs considerably more expensive than regular spend outputs.

For myself, I remain open to the possibility of adding a UTXO set size
corrective factor to a chiefly validation-cost metric. It would be nice to
reward users for cleaning up scattered small output, reward miners for
including dust-be-gone outputs, and make spam attacks more costly. But
doing so requires setting aside some unused validation resources in order
to reward miners who clean up the UTXO, which means it widens the gap
between average and worst case block validation times. Also, worry over the
size of the UTXO database is only a concern for how Bitcoin Core is
currently structured -- with e.g. UTXO or STXO commitments it could be the
case that in the future full nodes do not store the UTXO and instead carry
proofs of their inputs as prunable witness data. If we choose a net-UTXO
metric however, we will be stuck with it for some time.

I will be submitting a talk proposal for Scaling Bitcoin on this topic, but
I would like to get some feedback from the developer community first.
Anyone have any thoughts to add?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151104/036ee438/attachment.html>

From gavinandresen at gmail.com  Thu Nov  5 09:23:44 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 5 Nov 2015 09:23:44 +0000
Subject: [bitcoin-dev] A validation-cost metric for aggregate limits and
 fee determination
In-Reply-To: <CAOG=w-tR89zm_VDCR-MR_+F9bRNvm4TCZSQcTmYGKRW1JQhkUg@mail.gmail.com>
References: <CAOG=w-tR89zm_VDCR-MR_+F9bRNvm4TCZSQcTmYGKRW1JQhkUg@mail.gmail.com>
Message-ID: <CABsx9T3K+YfZpD4aiSxfZHpRMGfOjvdPm4fkgD067G6mRyYWbg@mail.gmail.com>

I have several thoughts:

Weighing CPU validation cost should be reasonably straightforward-- just
pick some arbitrary, commonly-available, recent hardware and then benchmark
the two things that take the bulk of validation time (hashing to create the
signature hash, then ECDSA validation), and weigh the terms in the
validation cost equation appropriately (e.g. hashing X GB of data takes the
same amount of CPU time as one libsecp256k1 validation, so count cpu cost
of an OP_CHECKSIG as 1 + X/actual_bytes_hashed).

But how should bandwidth cost be counted? There isn't an obvious "Y GB of
bandwidth-per-month equals 1 ECDSA validation. We need to find common units
for the terms in the validation cost equation for it to make sense,
otherwise we're adding apples and oranges.

I think the only units that will work is "percentage of maximum validation
ability for some reference hardware running with a network connection
capable of some reference bandwidth."

For example, imagine the reference was the typical home computer being sold
today running with some multiple or fraction of the average global
broadband connection speed of 5Mbps. CPU cost to validate a block can then
be expressed as a percentage of maximum capacity, as can bandwidth--
hooray, two metrics with the same units, so they can be added up.  If the
result is less than 100%, then the block is valid-- it can be received and
validated in a reasonable amount of time.


Rolling in UTXO growth is harder, for two reasons:
1) UTXO changes per block can be negative or positive, as opposed to
bandwidth/CPU costs.
2) It is not clear how to choose or benchmark "reference UTXO growth"

(1) could be finessed to just treat UTXO shrinkage as zero.
(2) could just be decided by picking a reasonable growth number. Since we
want the UTXO set to fit into main memory, something a bit below the
long-ish term price/performance trend of main memory would be a good target.

So, starting with that growth rate and an initial UTXO size in bytes,
divide by the number of blocks in a year to get a maximum UTXO growth in
bytes per block.

When validating a block, take the actual UTXO growth, express it as a
percentage of the maximum allowed (make it zero if it is negative), and
combine with the CPU and bandwidth percentages.

If the total is less than 100%, block is valid. Otherwise, invalid.

----------------

Now.... all of that worked through, I'm not 100% sure it solves the "do
miners or wallet have to solve a bin-packing problem to determine which
transactions to put into their blocks or what fees to attach."

I think it mostly works out-- instead of fee-per-kilobyte, it would be
fee-per-validation-cost (which is in the weird units "fraction of 100%
validation cost").

But the UTXO term might be a problem-- transactions that create more UTXOs
than they spend might end up being costly. I'm traveling right now, perhaps
somebody could pick some arbitrary reference points and try to get a rough
idea of what different transactions might pay in fees (e.g. if a
one-input-two-output had a cost of X, two-output-one-input would have a
cost of X/something).

I'm not convinced that a single validation cost metric is the best
approach-- it might be better to break the cost into three (UTXO growth,
CPU, and bandwidth) and just let miners set reasonable transaction
selection policies that keep each of the three under whatever caps are
imposed on each. If a miner comes up with a clever algorithm that lets them
pack in more transactions and get more fees, good for them!

But I do like the simplicity of a single validation cost metric.

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151105/541ff3fc/attachment.html>

From decker.christian at gmail.com  Thu Nov  5 09:38:03 2015
From: decker.christian at gmail.com (Christian Decker)
Date: Thu, 05 Nov 2015 09:38:03 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <20151104040033.GA26961@muck>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201510220905.27124.luke@dashjr.org>
	<CALxbBHV4JU7TG8QutkX7m9V4n_ANgKAgWO8ZA2KxQk8jP=kF0g@mail.gmail.com>
	<201511032048.18680.luke@dashjr.org>
	<CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
	<20151104040033.GA26961@muck>
Message-ID: <CALxbBHV=ge4fZ9Rma+UmOKs8amDc+yxzb+eUxcCEPmcOb4tsxQ@mail.gmail.com>

This does indeed sound reasonable. The chances of having a cut in the
network consisting of non-upgraded nodes partitioning the network and not
forwarding the segregated witnesses should be minimal, given a long rollout
phase before the activation.

If everybody agrees that this is a better way to approach the normalization
issue we should probably start writing it up and see if we can get critical
mass behind it :-)

On Wed, Nov 4, 2015 at 5:00 AM Peter Todd <pete at petertodd.org> wrote:

> On Tue, Nov 03, 2015 at 09:44:02PM +0000, Christian Decker via bitcoin-dev
> wrote:
> > Ok, so assuming we can get a connected component of upgraded nodes that
> > relay both the transaction and the associated external scripts then we
> > could just piggyback the external scripts on top of the normal messages.
> > Non-upgraded nodes will read the entire two-part message but only parse
> the
> > classical transaction, dropping the external script. Validation rules for
> > upgraded nodes are the same as before: if the attached signatures are
> > invalid the entire TX is dropped. We have to commit to the external
> scripts
> > used during the creation of a block. I think the easiest way to add this
> > commitment is the coinbase input I guess, and following the transaction
> > list a new list of signature lists is shipped with the rest of the block.
> > Non-upgraded will ignore it as before.
> >
> > Would that work? It all hinges on having upgraded miners in a connected
> > component otherwise non-upgraded nodes will drop the external scripts on
> > the way (since they parse and then reconstruct the messages along the
> > path). But if it works this could be a much nicer solution.
>
> FWIW my replace-by-fee fork does preferential peering with other RBF
> nodes to ensure that you'll always be connected to at least some
> full-RBF peers. In practice this works very well, and I'm sure a similar
> scheme could be used in this situation as well.
>
> Basically, conceptually unless you're connected to peers that advertise
> that they relay the new data, you treat the situation as though you're
> not connected to any peers at all. No different than if for some reason
> none of your peers were advertising NODE_NETWORK.
>
> --
> 'peter'[:-1]@petertodd.org
> 00000000000000000247b0e7436a5169ac6f9087be0295d10b07bf0bcbd4c0cc
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151105/5e7c974c/attachment-0001.html>

From jtimon at jtimon.cc  Thu Nov  5 15:27:37 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 5 Nov 2015 16:27:37 +0100
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <201511032201.21047.luke@dashjr.org>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032048.18680.luke@dashjr.org>
	<CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
	<201511032201.21047.luke@dashjr.org>
Message-ID: <CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>

On Tue, Nov 3, 2015 at 11:01 PM, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Tuesday, November 03, 2015 9:44:02 PM Christian Decker wrote:
>> So this is indeed a form of desired malleability we will likely not be able
>> to fix. I'd argue that this goes more into the direction of double-spending
>> than a form of malleability, and is mostly out of scope for this BIP. As
>> the abstract mentions this BIP attempts to eliminate damage incurred by
>> malleability in the third party modification scenario and in the multisig
>> scenario, with the added benefit of enabling transaction templating. If we
>> can get the segregated witnesses approach working all the better, we don't
>> even have the penalty of increased UTXO size. The problem of singlesig
>> users doublespending their outputs to update transactions remains a problem
>> even then.
>
> I don't know what you're trying to say here. Double spending to the same
> destination(s) and malleability are literally the same thing. Things affected
> by malleability are still just as broken even with this BIP - whether it is
> triggered by a third-party or not is not very relevant.

I think this is just a terminology confusion.
There's conflicting spends of the same outputs (aka unconfirmed
double-spends), and there's signature malleability which Segregated
Witnesses solves.
If we want to define malleability as signature malleability +
conflicting spends, then that's fine.
But it seems Christian is mostly interested in signature malleability,
which is what SW can solve.
In fact, creating conflicting spends is sometimes useful for some
contracts (ie to cancel the contract when that's supposed to be
allowed).
Maybe it is "incorrect" that people use "malleability" when they're
specifically talking about "signature malleability", but I think that
in this case it's clear that we're talking about transactions having
an id that cannot be changed just by signing with a different nonce
(what SW provides).

Please, Christian, correct me if you mean something else.

From jlrubin at mit.edu  Thu Nov  5 15:32:39 2015
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 5 Nov 2015 10:32:39 -0500
Subject: [bitcoin-dev] Call for Proposals for Scaling Bitcoin Hong Kong
Message-ID: <CAD5xwhhO8DBm4MayDWw_fO+4SYrhfFmAkjpeddOiTF=icdc3Bw@mail.gmail.com>

The second Scaling Bitcoin Workshop will take place December 6th-7th at the
Cyberport in Hong Kong. We are accepting technical proposals for improving
Bitcoin performance including designs, experimental results, and
comparisons against other proposals. The goals are twofold: 1) to present
potential solutions to scalability challenges while identifying key areas
for further research and 2) provide a venue where researchers, developers,
and miners can communicate about Bitcoin development.

We are accepting two types of proposals: one in which accepted authors will
have an opportunity to give a 20-30 minute presentation at the workshop,
and another where accepted authors can run an hour-long interactive
workshop.

Topics of interest include:

Improving Bitcoin throughput
Layer 2 ideas (i.e. payment channels, etc.)
Security and privacy
Incentives and fee structures
Testing, simulation, and modeling
Network resilience
Anti-spam measures
Block size proposals
Mining concerns
Community coordination


All as related to the scalability of Bitcoin.

Important Dates

November 9th - Last day for submission
November 16th - Last day for notification of acceptance and feedback

Formatting

We are doing rolling acceptance, so submit your proposal as soon as you
can. Proposals may be submitted as a BIP or as a 1-2 page extended abstract
describing ideas, designs, and expected experimental results. Indicate in
the proposal whether you are interested in speaking, running an interactive
workshop, or both. If you are interested in running an interactive
workshop, please include an agenda.

Proposals should be submitted to proposals at scalingbitcoin.org by November
9th.

All talks will be livestreamed and published online, including slide decks.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151105/c69c40bd/attachment.html>

From luke at dashjr.org  Thu Nov  5 19:36:08 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 5 Nov 2015 19:36:08 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032201.21047.luke@dashjr.org>
	<CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
Message-ID: <201511051936.09500.luke@dashjr.org>

On Thursday, November 05, 2015 3:27:37 PM Jorge Tim?n wrote:
> On Tue, Nov 3, 2015 at 11:01 PM, Luke Dashjr via bitcoin-dev
> 
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > On Tuesday, November 03, 2015 9:44:02 PM Christian Decker wrote:
> >> So this is indeed a form of desired malleability we will likely not be
> >> able to fix. I'd argue that this goes more into the direction of
> >> double-spending than a form of malleability, and is mostly out of scope
> >> for this BIP. As the abstract mentions this BIP attempts to eliminate
> >> damage incurred by malleability in the third party modification
> >> scenario and in the multisig scenario, with the added benefit of
> >> enabling transaction templating. If we can get the segregated witnesses
> >> approach working all the better, we don't even have the penalty of
> >> increased UTXO size. The problem of singlesig users doublespending
> >> their outputs to update transactions remains a problem even then.
> > 
> > I don't know what you're trying to say here. Double spending to the same
> > destination(s) and malleability are literally the same thing. Things
> > affected by malleability are still just as broken even with this BIP -
> > whether it is triggered by a third-party or not is not very relevant.
> 
> I think this is just a terminology confusion.
> There's conflicting spends of the same outputs (aka unconfirmed
> double-spends), and there's signature malleability which Segregated
> Witnesses solves.
> If we want to define malleability as signature malleability +
> conflicting spends, then that's fine.
> But it seems Christian is mostly interested in signature malleability,
> which is what SW can solve.
> In fact, creating conflicting spends is sometimes useful for some
> contracts (ie to cancel the contract when that's supposed to be
> allowed).
> Maybe it is "incorrect" that people use "malleability" when they're
> specifically talking about "signature malleability", but I think that
> in this case it's clear that we're talking about transactions having
> an id that cannot be changed just by signing with a different nonce
> (what SW provides).

Ok, then my point is that "signature malleability" is not particularly 
problematic or interesting alone, and the only way to get a practically-useful 
solution, is to address all kinds of malleability.

Luke

From jtimon at jtimon.cc  Thu Nov  5 20:25:33 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 5 Nov 2015 21:25:33 +0100
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <201511051936.09500.luke@dashjr.org>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032201.21047.luke@dashjr.org>
	<CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
	<201511051936.09500.luke@dashjr.org>
Message-ID: <CABm2gDpojFy_a9PRXgeJqH-8p-1KZ04Kc3N-QtwJZnzZCnbNEw@mail.gmail.com>

On Thu, Nov 5, 2015 at 8:36 PM, Luke Dashjr <luke at dashjr.org> wrote:
> Ok, then my point is that "signature malleability" is not particularly
> problematic or interesting alone, and the only way to get a practically-useful
> solution, is to address all kinds of malleability.

I disagree. Segregated witnesses, for example, doesn't solve all kinds
of malleability and is very useful in some practical cases by solving
all signature malleability.
As said, we don't want to eliminate all forms of malleability (for
example, replace by fee), although we may want to "address them" at
some level.
As you have said, wallets should be looking at scriptPubKeys, not
transaction ID, but that is orthogonal to SW, a normalized tx ID and
signature malleability.

From adam at cypherspace.org  Thu Nov  5 22:29:46 2015
From: adam at cypherspace.org (Adam Back)
Date: Thu, 5 Nov 2015 23:29:46 +0100
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <201511051936.09500.luke@dashjr.org>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032201.21047.luke@dashjr.org>
	<CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
	<201511051936.09500.luke@dashjr.org>
Message-ID: <CALqxMTGA-SHOgmNDfwTSFS5kwh8wCwJwmGKDNWg3F191SWBBTw@mail.gmail.com>

About the conflicting spends by the private key holder (self signature
malleability) that is in principle kind of fixable.

You make a new pub key type which is r,Q (where r is the DSA signature
component but chosen at key gen time, Q=xG is the pub key, r is point
compressed R = (r,f(r)) = kG ), r is the pre-computable part of an
ECDSA signature (unrelated to the message which can be decided later).

You make a new address type which is a = H(r,Q).

Then you make a new signature type which requires that the r from
sig=(r,s) matches the r committed to in the address.

As the ECDSA signature is s=(H(m)+r*x)/k mod n, if they sign two
different messages with the same r value they reveal the private key
via simultaneous equation, as s=(H(m)+r*x)/k and s'=(H(m')+r*x)/k and
solving k=(H(m)-H(m'))/(s-s') and x=(sk-H(m))/r allowing anyone who
sees both double spends to spend as they can replace the signature
with their own one.  That converts double signatures into miner can
spend.

It doesnt necessarily enforce no pubkey reuse (Q), as a=H(r,Q) and
a'=H(r',Q) are different addresses, though it does enforce no
extended-address reuse (H=(r,Q)).
Binary failure address reuse could be an issue.  Puts pressure on
transactional storage on wallets.

Adam

On 5 November 2015 at 20:36, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Thursday, November 05, 2015 3:27:37 PM Jorge Tim?n wrote:
>> On Tue, Nov 3, 2015 at 11:01 PM, Luke Dashjr via bitcoin-dev
>>
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > On Tuesday, November 03, 2015 9:44:02 PM Christian Decker wrote:
>> >> So this is indeed a form of desired malleability we will likely not be
>> >> able to fix. I'd argue that this goes more into the direction of
>> >> double-spending than a form of malleability, and is mostly out of scope
>> >> for this BIP. As the abstract mentions this BIP attempts to eliminate
>> >> damage incurred by malleability in the third party modification
>> >> scenario and in the multisig scenario, with the added benefit of
>> >> enabling transaction templating. If we can get the segregated witnesses
>> >> approach working all the better, we don't even have the penalty of
>> >> increased UTXO size. The problem of singlesig users doublespending
>> >> their outputs to update transactions remains a problem even then.
>> >
>> > I don't know what you're trying to say here. Double spending to the same
>> > destination(s) and malleability are literally the same thing. Things
>> > affected by malleability are still just as broken even with this BIP -
>> > whether it is triggered by a third-party or not is not very relevant.
>>
>> I think this is just a terminology confusion.
>> There's conflicting spends of the same outputs (aka unconfirmed
>> double-spends), and there's signature malleability which Segregated
>> Witnesses solves.
>> If we want to define malleability as signature malleability +
>> conflicting spends, then that's fine.
>> But it seems Christian is mostly interested in signature malleability,
>> which is what SW can solve.
>> In fact, creating conflicting spends is sometimes useful for some
>> contracts (ie to cancel the contract when that's supposed to be
>> allowed).
>> Maybe it is "incorrect" that people use "malleability" when they're
>> specifically talking about "signature malleability", but I think that
>> in this case it's clear that we're talking about transactions having
>> an id that cannot be changed just by signing with a different nonce
>> (what SW provides).
>
> Ok, then my point is that "signature malleability" is not particularly
> problematic or interesting alone, and the only way to get a practically-useful
> solution, is to address all kinds of malleability.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From s7r at sky-ip.org  Thu Nov  5 22:46:19 2015
From: s7r at sky-ip.org (s7r)
Date: Fri, 6 Nov 2015 00:46:19 +0200
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <CABm2gDpojFy_a9PRXgeJqH-8p-1KZ04Kc3N-QtwJZnzZCnbNEw@mail.gmail.com>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032201.21047.luke@dashjr.org>
	<CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
	<201511051936.09500.luke@dashjr.org>
	<CABm2gDpojFy_a9PRXgeJqH-8p-1KZ04Kc3N-QtwJZnzZCnbNEw@mail.gmail.com>
Message-ID: <563BDC3B.6020601@sky-ip.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Right. Wallets are covering malleability in acceptable ways. Normal
user to user payments aren't (or at least shouldn't be) affected by
malleability.

Problems appear in second level and third level malleability, when
Alice sends txB to Bob which spends from txA which is unconfirmed. If
txA changes txid, txB becomes useless and invalidates Alice's payment.
Looking at scriptPubKeys instead of transaction IDs doesn't help in
this context.

This is the reason why some type of contracts are not workable or not
100% safe. One can't pre-sign a refund transaction with an nLockTime
in the future: the payer will provide the funding transaction ID from
which the refund tx will spend, but if the transaction ID of the
funding transaction is affected by malleability (third party
malleability, since the signer doesn't have interest to do so) the
refund tx becomes useless.

On 11/5/2015 10:25 PM, Jorge Tim?n via bitcoin-dev wrote:
> On Thu, Nov 5, 2015 at 8:36 PM, Luke Dashjr <luke at dashjr.org>
> wrote:
>> Ok, then my point is that "signature malleability" is not
>> particularly problematic or interesting alone, and the only way
>> to get a practically-useful solution, is to address all kinds of
>> malleability.
> 
> I disagree. Segregated witnesses, for example, doesn't solve all
> kinds of malleability and is very useful in some practical cases by
> solving all signature malleability. As said, we don't want to
> eliminate all forms of malleability (for example, replace by fee),
> although we may want to "address them" at some level. As you have
> said, wallets should be looking at scriptPubKeys, not transaction
> ID, but that is orthogonal to SW, a normalized tx ID and signature
> malleability.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (MingW32)

iQEcBAEBCAAGBQJWO9w7AAoJEIN/pSyBJlsR2BsH+gMwxJ/isiWfJF12LJ9s4wat
Bd/K2Ld+Lyk5BRs+6rQzv5NeeYjYC3FtNFV+z1Z1dMDd752cUfEZqQA9dt9nl0E7
BEia3RSFii1k2L/4xwiIWKZM20qoiykou41J56GZrJa9SoP+9kg8iLq8CokahakP
PLjfBrTylJBsgq34foPPaOH9ckOa/RJpx3WHrRFTPhxbTCm1Ezv6jAZmYr9tTi1h
afzU0YayzLUIb9xH8vfODY2qMJ91uguTUZYCGuopDYhom5GMw8zss0kG5FdEZrEQ
Z7srQmKQ0SRMtiSlg6lg3d8TS5Mv1gIp1HcL+gtMFroi38pJS8dXT65nGjg0Epc=
=ZhVA
-----END PGP SIGNATURE-----

From adam at cypherspace.org  Thu Nov  5 23:03:32 2015
From: adam at cypherspace.org (Adam Back)
Date: Fri, 6 Nov 2015 00:03:32 +0100
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
Message-ID: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>

Some thoughts, hope this is not off-topic.

Maybe we should summarise the security assumptions and design
requirements.  It is often easier to have clear design discussions by
first articulating assumptions and requirements.

Validators: Economically dependent full nodes are an important part of
Bitcoin's security model because they assure Bitcoin security by
enforcing consensus rules.  While full nodes do not have orphan
risk, we also dont want maliciously crafted blocks with pathological
validation cost to erode security by knocking reasonable spec full
nodes off the network on CPU (or bandwidth grounds).

Miners: Miners are in a commodity economics competitive environment
where various types of attacks and collusion, even with small
advantage, may see actual use due to the advantage being significant
relative to the at times low profit margin

It is quite important for bitcoin decentralisation security that small
miners not be significantly disadvantaged vs large miners.  Similarly
it is important that there not be significant collusion advantages
that create policy centralisation as a side-effect (for example what
happened with "SPV mining" or validationless mining during BIP66
deployment).  Examples of attacks include selfish-mining and
amplifying that kind of attack via artificially large or
pathologically expensive to validate blocks.  Or elevating orphan risk
for others (a miner or collusion of miners is not at orphan risk for a
block they created).

Validators vs Miner decentralisation balance:

There is a tradeoff where we can tolerate weak miner decentralisation
if we can rely on good validator decentralisation or vice versa.  But
both being weak is risky.  Currently given mining centralisation
itself is weak, that makes validator decentralisation a critical
remaining defence - ie security depends more on validator
decentralisation than it would if mining decentralisation was in a
better shape.

Security:

We should consider the pathological case not average or default behaviour
because we can not assume people will follow the defaults, only the
consensus-enforced rules.

We should not discount attacks that have not seen exploitation to
date.  We have maybe benefitted from universal good-will (everybody
thinks Bitcoin is cool, particularly people with skills to find and
exploit attacks).

We can consider a hierarchy of defences most secure to least:

1. consensus rule enforced (attacker loses block reward)
2. economic alignment (attacker loses money)
3. overt (profitable, but overt attacks are less likely to be exploited)
4. meta-incentive (relying on meta-incentive to not damage the ecosystem only)

Best practices:

We might want to list some best practices that are important for the
health and security of the Bitcoin network.

Rule of thumb KISS stuff:

We should aim to keep things simple in general and to avoid creating
complex optimisation problems for transaction processors, wallets,
miners.

We may want to consider an incremental approach (shorter-time frame or
less technically ambitious) in the interests of simplifying and
getting something easier to arrive at consensus, and thus faster to
deploy.

We should not let the perfect be the enemy of the good.  But we should
not store new problems for the future, costs are stacked in favour of
getting it right vs A/B testing on the live network.

Not everything maybe fixable in one go for complexity reasons or for
the reason that there is no clear solution for some issues.  We should
work incrementally.

Adam

From eric at voskuil.org  Thu Nov  5 23:33:26 2015
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 05 Nov 2015 15:33:26 -0800
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
Message-ID: <563BE746.5030406@voskuil.org>

On 11/05/2015 03:03 PM, Adam Back via bitcoin-dev wrote:
> ...
> Validators: Economically dependent full nodes are an important part of
> Bitcoin's security model because they assure Bitcoin security by
> enforcing consensus rules.  While full nodes do not have orphan
> risk, we also dont want maliciously crafted blocks with pathological
> validation cost to erode security by knocking reasonable spec full
> nodes off the network on CPU (or bandwidth grounds).
> ...
> Validators vs Miner decentralisation balance:
> 
> There is a tradeoff where we can tolerate weak miner decentralisation
> if we can rely on good validator decentralisation or vice versa.  But
> both being weak is risky.  Currently given mining centralisation
> itself is weak, that makes validator decentralisation a critical
> remaining defence - ie security depends more on validator
> decentralisation than it would if mining decentralisation was in a
> better shape.

This side of the security model seems underappreciated, if not poorly
understood. Weakening is not just occurring because of the proliferation
of non-validating wallet software and centralized (web) wallets, but
also centralized Bitcoin APIs.

Over time developers tend to settle on a couple of API providers for a
given problem. Bing and Google for search and mapping, for example. All
applications and users of them, depending on an API service, reduce to a
single validator. Imagine most Bitcoin applications built on the
equivalent of Bing and Google.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151105/cabe5605/attachment.sig>

From jlrubin at mit.edu  Fri Nov  6 01:56:49 2015
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 5 Nov 2015 20:56:49 -0500
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <563BE746.5030406@voskuil.org>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
	<563BE746.5030406@voskuil.org>
Message-ID: <CAD5xwhj3Ys+kFaoFAqM4e_mec--02pij72ze6NoJ6+AaQdL0tA@mail.gmail.com>

I'd also like to see some more formal analysis of the notion that "$10 in
the hand of 10 people is more than $50 in the hand of two, or $100 in the
hand of one". I think this encapsulates the security assumption on why we
want decentralization at all.

This is a very critical property bitcoin exploits for being able to
transact large amounts, among other things. (Closely related is the notion
that defecting will destroy all the value...)




--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>

On Thu, Nov 5, 2015 at 6:33 PM, Eric Voskuil via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 11/05/2015 03:03 PM, Adam Back via bitcoin-dev wrote:
> > ...
> > Validators: Economically dependent full nodes are an important part of
> > Bitcoin's security model because they assure Bitcoin security by
> > enforcing consensus rules.  While full nodes do not have orphan
> > risk, we also dont want maliciously crafted blocks with pathological
> > validation cost to erode security by knocking reasonable spec full
> > nodes off the network on CPU (or bandwidth grounds).
> > ...
> > Validators vs Miner decentralisation balance:
> >
> > There is a tradeoff where we can tolerate weak miner decentralisation
> > if we can rely on good validator decentralisation or vice versa.  But
> > both being weak is risky.  Currently given mining centralisation
> > itself is weak, that makes validator decentralisation a critical
> > remaining defence - ie security depends more on validator
> > decentralisation than it would if mining decentralisation was in a
> > better shape.
>
> This side of the security model seems underappreciated, if not poorly
> understood. Weakening is not just occurring because of the proliferation
> of non-validating wallet software and centralized (web) wallets, but
> also centralized Bitcoin APIs.
>
> Over time developers tend to settle on a couple of API providers for a
> given problem. Bing and Google for search and mapping, for example. All
> applications and users of them, depending on an API service, reduce to a
> single validator. Imagine most Bitcoin applications built on the
> equivalent of Bing and Google.
>
> e
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151105/fcb5bbd4/attachment.html>

From jl2012 at xbt.hk  Fri Nov  6 08:13:10 2015
From: jl2012 at xbt.hk (jl2012 at xbt.hk)
Date: Fri, 06 Nov 2015 03:13:10 -0500
Subject: [bitcoin-dev] =?utf-8?q?Dealing_with_OP=5FIF_and_OP=5FNOTIF_malle?=
	=?utf-8?q?ability?=
Message-ID: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>

I have a new BIP draft for fixing OP_IF and OP_NOTIF malleability. 
Please comment: 
https://github.com/jl2012/bips/blob/master/opifmalleability.mediawiki

Copied below:

BIP: x
   Title: Dealing with OP_IF and OP_NOTIF malleability
   Author: jl2012 <jl2012 at xbt.hk>
   Status: Draft
   Type: Standards Track
   Created: 2015-11-06

Abstract

As an supplement to BIP62, this document specifies proposed changes to 
the Bitcoin transaction validity rules in order to make malleability of 
transactions with OP_IF and OP_NOTIF impossible.

Motivation

OP_IF and OP_NOTIF are flow control codes in the Bitcoin script system. 
The programme flow is decided by whether the top stake value is 0 or 
not. However, this behavior opens a source of malleability as a third 
party may alter a non-zero flow control value to any other non-zero 
value without invalidating the transaction.

As of November 2015, OP_IF and OP_NOTIF are not commonly used in the 
blockchain. However, as more sophisticated functions such as 
OP_CHECKLOCKTIMEVERITY are being introduced, OP_IF and OP_NOTIF will 
become more popular and the related malleability should be fixed. This 
proposal serves as a supplement to BIP62 and should be implemented with 
other malleability fixes together.

Specification

If the transaction version is 3 or above, the flow control value for 
OP_IF and OP_NOTIF must be either 0 or 1, or the transaction fails.

This is to be implemented with BIP62.

Compatibility

This is a softfork. To ensure OP_IF and OP_NOTIF transactions created 
before the introduction of this BIP will still be accpeted by the 
network, the new rules only apply to transactions of version 3 or above.

For people who want to preserve the original behaviour of OP_IF and 
OP_NOTIF, an OP_0NOTEQUAL could be  used before the flow control code to 
transform any non-zero value to 1.

Reference

BIP62: https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki


From tier.nolan at gmail.com  Fri Nov  6 09:27:24 2015
From: tier.nolan at gmail.com (Tier Nolan)
Date: Fri, 6 Nov 2015 09:27:24 +0000
Subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability
In-Reply-To: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
References: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
Message-ID: <CAE-z3OUQyW9Hss-jMDx_HjT9y55SctmUiXiGYhTZe6=2Mj2OaA@mail.gmail.com>

One and zero should be defined as arrays of length one.  Otherwise, it is
still possible to mutate the transaction by changing the length of the
array.

They should also be minimally encoded but that is covered by previous rules.

On Fri, Nov 6, 2015 at 8:13 AM, jl2012 via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I have a new BIP draft for fixing OP_IF and OP_NOTIF malleability. Please
> comment:
> https://github.com/jl2012/bips/blob/master/opifmalleability.mediawiki
>
> Copied below:
>
> BIP: x
>   Title: Dealing with OP_IF and OP_NOTIF malleability
>   Author: jl2012 <jl2012 at xbt.hk>
>   Status: Draft
>   Type: Standards Track
>   Created: 2015-11-06
>
> Abstract
>
> As an supplement to BIP62, this document specifies proposed changes to the
> Bitcoin transaction validity rules in order to make malleability of
> transactions with OP_IF and OP_NOTIF impossible.
>
> Motivation
>
> OP_IF and OP_NOTIF are flow control codes in the Bitcoin script system.
> The programme flow is decided by whether the top stake value is 0 or not.
> However, this behavior opens a source of malleability as a third party may
> alter a non-zero flow control value to any other non-zero value without
> invalidating the transaction.
>
> As of November 2015, OP_IF and OP_NOTIF are not commonly used in the
> blockchain. However, as more sophisticated functions such as
> OP_CHECKLOCKTIMEVERITY are being introduced, OP_IF and OP_NOTIF will become
> more popular and the related malleability should be fixed. This proposal
> serves as a supplement to BIP62 and should be implemented with other
> malleability fixes together.
>
> Specification
>
> If the transaction version is 3 or above, the flow control value for OP_IF
> and OP_NOTIF must be either 0 or 1, or the transaction fails.
>
> This is to be implemented with BIP62.
>
> Compatibility
>
> This is a softfork. To ensure OP_IF and OP_NOTIF transactions created
> before the introduction of this BIP will still be accpeted by the network,
> the new rules only apply to transactions of version 3 or above.
>
> For people who want to preserve the original behaviour of OP_IF and
> OP_NOTIF, an OP_0NOTEQUAL could be  used before the flow control code to
> transform any non-zero value to 1.
>
> Reference
>
> BIP62: https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151106/d815e1ae/attachment.html>

From tier.nolan at gmail.com  Fri Nov  6 09:37:58 2015
From: tier.nolan at gmail.com (Tier Nolan)
Date: Fri, 6 Nov 2015 09:37:58 +0000
Subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability
In-Reply-To: <8D9D1049-E502-4A37-ACE4-5A2B1369A90A@gmail.com>
References: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
	<CAE-z3OUQyW9Hss-jMDx_HjT9y55SctmUiXiGYhTZe6=2Mj2OaA@mail.gmail.com>
	<8D9D1049-E502-4A37-ACE4-5A2B1369A90A@gmail.com>
Message-ID: <CAE-z3OX6bMY+RjphyDS-zAO=aXLs-B41G4m6ssUjFC03ByQkWA@mail.gmail.com>

I meant not to use the OP_PUSH opcodes to do the push.

Does OP_0 give a zero length byte array?

Would this script return true?

OP_0
OP_PUSHDATA1 (length = 1, data = 0)
OP_EQUAL

The easiest definition is that OP_0 and OP_1 must be used to push the data
and not any other push opcodes.


On Fri, Nov 6, 2015 at 9:32 AM, Oleg Andreev <oleganza at gmail.com> wrote:

>
> > One and zero should be defined as arrays of length one. Otherwise, it is
> still possible to mutate the transaction by changing the length of the
> array.
> >
> > They should also be minimally encoded but that is covered by previous
> rules.
>
> These two lines contradict each other. Minimally-encoded "zero" is an
> array of length zero, not one. I'd suggest defining this explicitly here as
> "IF/NOTIF argument must be either zero-length array or a single byte 0x01".
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151106/435de781/attachment.html>

From jl2012 at xbt.hk  Fri Nov  6 10:16:46 2015
From: jl2012 at xbt.hk (jl2012 at xbt.hk)
Date: Fri, 06 Nov 2015 05:16:46 -0500
Subject: [bitcoin-dev]
 =?utf-8?q?Dealing_with_OP=5FIF_and_OP=5FNOTIF_malle?=
 =?utf-8?q?ability?=
In-Reply-To: <CAE-z3OX6bMY+RjphyDS-zAO=aXLs-B41G4m6ssUjFC03ByQkWA@mail.gmail.com>
References: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
	<CAE-z3OUQyW9Hss-jMDx_HjT9y55SctmUiXiGYhTZe6=2Mj2OaA@mail.gmail.com>
	<8D9D1049-E502-4A37-ACE4-5A2B1369A90A@gmail.com>
	<CAE-z3OX6bMY+RjphyDS-zAO=aXLs-B41G4m6ssUjFC03ByQkWA@mail.gmail.com>
Message-ID: <73251cb4c7585cf9acecb1708b25db8d@xbt.hk>

I assume this proposal is implemented at the same time as BIP62. As long 
as OP_IF/OP_NOTIF interprets the argument as a number, zero-padded 
number and negative zero are already prohibited in BIP62

Tier Nolan via bitcoin-dev ? 2015-11-06 04:37 ??:
> I meant not to use the OP_PUSH opcodes to do the push.
> 
> Does OP_0 give a zero length byte array?
> 
> Would this script return true?
> 
> OP_0
> 
> OP_PUSHDATA1 (length = 1, data = 0)
> 
> OP_EQUAL
> 
> The easiest definition is that OP_0 and OP_1 must be used to push the
> data and not any other push opcodes.
> 
> On Fri, Nov 6, 2015 at 9:32 AM, Oleg Andreev <oleganza at gmail.com>
> wrote:
> 
>>> One and zero should be defined as arrays of length one.
>> Otherwise, it is still possible to mutate the transaction by
>> changing the length of the array.
>>> 
>>> They should also be minimally encoded but that is covered by
>> previous rules.
>> 
>> These two lines contradict each other. Minimally-encoded "zero" is
>> an array of length zero, not one. I'd suggest defining this
>> explicitly here as "IF/NOTIF argument must be either zero-length
>> array or a single byte 0x01".
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From cp368202 at ohiou.edu  Fri Nov  6 08:05:23 2015
From: cp368202 at ohiou.edu (Chris Priest)
Date: Fri, 6 Nov 2015 00:05:23 -0800
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <563BE746.5030406@voskuil.org>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
	<563BE746.5030406@voskuil.org>
Message-ID: <CAAcC9yv6JwSY-LhWaFc5cF6CkTwTfLLtqFfemwjJ7hKnfzXuLQ@mail.gmail.com>

On 11/5/15, Eric Voskuil via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On 11/05/2015 03:03 PM, Adam Back via bitcoin-dev wrote:
>> ...
>> Validators: Economically dependent full nodes are an important part of
>> Bitcoin's security model because they assure Bitcoin security by
>> enforcing consensus rules.  While full nodes do not have orphan
>> risk, we also dont want maliciously crafted blocks with pathological
>> validation cost to erode security by knocking reasonable spec full
>> nodes off the network on CPU (or bandwidth grounds).
>> ...
>> Validators vs Miner decentralisation balance:
>>
>> There is a tradeoff where we can tolerate weak miner decentralisation
>> if we can rely on good validator decentralisation or vice versa.  But
>> both being weak is risky.  Currently given mining centralisation
>> itself is weak, that makes validator decentralisation a critical
>> remaining defence - ie security depends more on validator
>> decentralisation than it would if mining decentralisation was in a
>> better shape.
>
> This side of the security model seems underappreciated, if not poorly
> understood. Weakening is not just occurring because of the proliferation
> of non-validating wallet software and centralized (web) wallets, but
> also centralized Bitcoin APIs.
>
> Over time developers tend to settle on a couple of API providers for a
> given problem. Bing and Google for search and mapping, for example. All
> applications and users of them, depending on an API service, reduce to a
> single validator. Imagine most Bitcoin applications built on the
> equivalent of Bing and Google.
>
> e
>
>

I disagree. I think blockchain APIs are a good thing for
decentralization. There aren't just 3 or 4 blockexplorer APIs out
there, there are dozens. Each API returns essentially the same data,
so they are all interchangeable. Take a look at this python package:
https://github.com/priestc/moneywagon

From nickodell at gmail.com  Fri Nov  6 09:22:27 2015
From: nickodell at gmail.com (Nick ODell)
Date: Fri, 6 Nov 2015 02:22:27 -0700
Subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability
In-Reply-To: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
References: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
Message-ID: <CANN4kmdq5zWDtKMQK5ov5SyRYZL4vZ5htn_POTUeCJhmJaBbhw@mail.gmail.com>

Your suggested modification seems sound.

Though, a script author could do something similar right now by
prefacing his IF with this:

    OP_DUP OP_DUP OP_0 OP_EQUAL OP_SWAP OP_1 OP_EQUAL OP_BOOLOR
OP_NOTIF OP_RETURN OP_ENDIF [actual OP_IF goes here]

That checks whether the input is 0 or 1, and runs OP_RETURN if not.
Your way is cleaner, though.

On Fri, Nov 6, 2015 at 1:13 AM, jl2012 via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I have a new BIP draft for fixing OP_IF and OP_NOTIF malleability. Please
> comment:
> https://github.com/jl2012/bips/blob/master/opifmalleability.mediawiki
>
> Copied below:
>
> BIP: x
>   Title: Dealing with OP_IF and OP_NOTIF malleability
>   Author: jl2012 <jl2012 at xbt.hk>
>   Status: Draft
>   Type: Standards Track
>   Created: 2015-11-06
>
> Abstract
>
> As an supplement to BIP62, this document specifies proposed changes to the
> Bitcoin transaction validity rules in order to make malleability of
> transactions with OP_IF and OP_NOTIF impossible.
>
> Motivation
>
> OP_IF and OP_NOTIF are flow control codes in the Bitcoin script system. The
> programme flow is decided by whether the top stake value is 0 or not.
> However, this behavior opens a source of malleability as a third party may
> alter a non-zero flow control value to any other non-zero value without
> invalidating the transaction.
>
> As of November 2015, OP_IF and OP_NOTIF are not commonly used in the
> blockchain. However, as more sophisticated functions such as
> OP_CHECKLOCKTIMEVERITY are being introduced, OP_IF and OP_NOTIF will become
> more popular and the related malleability should be fixed. This proposal
> serves as a supplement to BIP62 and should be implemented with other
> malleability fixes together.
>
> Specification
>
> If the transaction version is 3 or above, the flow control value for OP_IF
> and OP_NOTIF must be either 0 or 1, or the transaction fails.
>
> This is to be implemented with BIP62.
>
> Compatibility
>
> This is a softfork. To ensure OP_IF and OP_NOTIF transactions created before
> the introduction of this BIP will still be accpeted by the network, the new
> rules only apply to transactions of version 3 or above.
>
> For people who want to preserve the original behaviour of OP_IF and
> OP_NOTIF, an OP_0NOTEQUAL could be  used before the flow control code to
> transform any non-zero value to 1.
>
> Reference
>
> BIP62: https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From oleganza at gmail.com  Fri Nov  6 09:32:02 2015
From: oleganza at gmail.com (Oleg Andreev)
Date: Fri, 6 Nov 2015 10:32:02 +0100
Subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability
In-Reply-To: <CAE-z3OUQyW9Hss-jMDx_HjT9y55SctmUiXiGYhTZe6=2Mj2OaA@mail.gmail.com>
References: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
	<CAE-z3OUQyW9Hss-jMDx_HjT9y55SctmUiXiGYhTZe6=2Mj2OaA@mail.gmail.com>
Message-ID: <8D9D1049-E502-4A37-ACE4-5A2B1369A90A@gmail.com>


> One and zero should be defined as arrays of length one. Otherwise, it is still possible to mutate the transaction by changing the length of the array. 
> 
> They should also be minimally encoded but that is covered by previous rules.

These two lines contradict each other. Minimally-encoded "zero" is an array of length zero, not one. I'd suggest defining this explicitly here as "IF/NOTIF argument must be either zero-length array or a single byte 0x01".



From adam at cypherspace.org  Fri Nov  6 14:08:10 2015
From: adam at cypherspace.org (Adam Back)
Date: Fri, 6 Nov 2015 15:08:10 +0100
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CAAcC9yv6JwSY-LhWaFc5cF6CkTwTfLLtqFfemwjJ7hKnfzXuLQ@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
	<563BE746.5030406@voskuil.org>
	<CAAcC9yv6JwSY-LhWaFc5cF6CkTwTfLLtqFfemwjJ7hKnfzXuLQ@mail.gmail.com>
Message-ID: <CALqxMTGnusroDgjt0a7HqfPpS=1n7WNu1uz6bOPG2vQAbCNQ1g@mail.gmail.com>

You're right that it is better that there be more APIs than fewer,
that is less of a single point of failure.  It also depends what you
mean by APIs: using an API to have a second cross-check of information
is quite different to building a wallet or business that only
interfaces with the blockchain via a 3rd party API.  There are
different APIs also: some are additive eg they add a second signature
via multisig, but even those models while better can still be a mixed
story for security, if the user is not also checking their own
full-node or checking SPV to make the first signature.

Power users and businesses using APIs instead of running a full-node,
or instead of doing SPV checks, should be clear about the API and what
security they are delegating to a third party, and whether they have a
reason to trust the governance and security competence of the third
party: in the simplest case it can reduce their and their users
security below SPV.

The bigger point however, which Erik explained, was: widespread use of
APIs as a sole means of interfacing with the blockchain also
contributes to reducing network security for everyone, because it
erodes the consensus rule validation security described under
"Validators" in the OP.

Adam


On 6 November 2015 at 09:05, Chris Priest <cp368202 at ohiou.edu> wrote:
> On 11/5/15, Eric Voskuil via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> On 11/05/2015 03:03 PM, Adam Back via bitcoin-dev wrote:
>>> ...
>>> Validators: Economically dependent full nodes are an important part of
>>> Bitcoin's security model because they assure Bitcoin security by
>>> enforcing consensus rules.  While full nodes do not have orphan
>>> risk, we also dont want maliciously crafted blocks with pathological
>>> validation cost to erode security by knocking reasonable spec full
>>> nodes off the network on CPU (or bandwidth grounds).
>>> ...
>>> Validators vs Miner decentralisation balance:
>>>
>>> There is a tradeoff where we can tolerate weak miner decentralisation
>>> if we can rely on good validator decentralisation or vice versa.  But
>>> both being weak is risky.  Currently given mining centralisation
>>> itself is weak, that makes validator decentralisation a critical
>>> remaining defence - ie security depends more on validator
>>> decentralisation than it would if mining decentralisation was in a
>>> better shape.
>>
>> This side of the security model seems underappreciated, if not poorly
>> understood. Weakening is not just occurring because of the proliferation
>> of non-validating wallet software and centralized (web) wallets, but
>> also centralized Bitcoin APIs.
>>
>> Over time developers tend to settle on a couple of API providers for a
>> given problem. Bing and Google for search and mapping, for example. All
>> applications and users of them, depending on an API service, reduce to a
>> single validator. Imagine most Bitcoin applications built on the
>> equivalent of Bing and Google.
>>
>> e
>>
>>
>
> I disagree. I think blockchain APIs are a good thing for
> decentralization. There aren't just 3 or 4 blockexplorer APIs out
> there, there are dozens. Each API returns essentially the same data,
> so they are all interchangeable. Take a look at this python package:
> https://github.com/priestc/moneywagon

From decker.christian at gmail.com  Fri Nov  6 14:52:49 2015
From: decker.christian at gmail.com (Christian Decker)
Date: Fri, 06 Nov 2015 14:52:49 +0000
Subject: [bitcoin-dev] [BIP] Normalized transaction IDs
In-Reply-To: <CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
References: <CALxbBHU+kdEAh_4+B663vknAAr8OKZpUzVTACORPZi47E=Ehkw@mail.gmail.com>
	<201511032048.18680.luke@dashjr.org>
	<CALxbBHVwv_T4=DTUdmbgG2y7QmjETCKbQ6_oKKNjsCS=HDrJ+A@mail.gmail.com>
	<201511032201.21047.luke@dashjr.org>
	<CABm2gDpNXGZ7yevFoN9k5nx7wBZX86cH0vJs38DyL+PtEPLHxw@mail.gmail.com>
Message-ID: <CALxbBHXESnrDhx13bUo56FS_zwUJto-FrdCien4TjMAR6esP_w@mail.gmail.com>

On Thu, Nov 5, 2015 at 4:27 PM Jorge Tim?n <jtimon at jtimon.cc> wrote:

> I think this is just a terminology confusion.
> There's conflicting spends of the same outputs (aka unconfirmed
> double-spends), and there's signature malleability which Segregated
> Witnesses solves.
> If we want to define malleability as signature malleability +
> conflicting spends, then that's fine.
> But it seems Christian is mostly interested in signature malleability,
> which is what SW can solve.
> In fact, creating conflicting spends is sometimes useful for some
> contracts (ie to cancel the contract when that's supposed to be
> allowed).
> Maybe it is "incorrect" that people use "malleability" when they're
> specifically talking about "signature malleability", but I think that
> in this case it's clear that we're talking about transactions having
> an id that cannot be changed just by signing with a different nonce
> (what SW provides).
>
> Please, Christian, correct me if you mean something else.
>

Yes, your differentiation is spot on. My main goal is to eliminate the risk
of detaching transactions in  off-blockchain protocols that rely on a
number of transactions being chained, hence solving signature malleability
might be the correct term. Canonical encodings do address part of the
problem, however they do nothing in the case of one of the signers
re-signing a transaction and detaching any followup transaction. Also
having transaction templates is a nice way to reduce the complexity of
protocols by eliminating some of the "who signs what when" gotchas.
Segregated witnesses would be a perfect solution, we just need to find a
good migration plan for Bitcoin :-)

Sorry for the confusion caused by me misusing the term malleability, I'll
use signature malleability in the future :-)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151106/1a49d31c/attachment.html>

From ittay.eyal at cornell.edu  Fri Nov  6 20:48:08 2015
From: ittay.eyal at cornell.edu (Ittay)
Date: Fri, 6 Nov 2015 15:48:08 -0500
Subject: [bitcoin-dev] Bitcoin-NG whitepaper.
In-Reply-To: <56302E34.7070906@mattcorallo.com>
References: <CAPkFh0viwmkUvjo4Qj50TNnkA5kG3z-3dLGExjkmDacE4E49Ow@mail.gmail.com>
	<CABaSBaxWAsEG71FTy4SrVu94BXokeozmJ80tjsNU8ERpTfFaFA@mail.gmail.com>
	<CABT1wW=xqShMGU0+eDiNyNkr-77fQ_HnyKL87C6iGL-xq8BYVw@mail.gmail.com>
	<28CC699B-4DA8-4472-A795-9505418C688A@mattcorallo.com>
	<CABT1wWm0QXjGAXgrBMT7w+25kcsEJnP8JZ5RSpuk3aefX45+wQ@mail.gmail.com>
	<56302E34.7070906@mattcorallo.com>
Message-ID: <CABT1wWndkSNK5FDbaiYoFZhhBu9FxXhy9qkb_pA7KW6Xqq1nfg@mail.gmail.com>

On Tue, Oct 27, 2015 at 10:08 PM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> Oops, just realized I never responded to this...
>
> On 10/15/15 15:09, Ittay wrote:
> > Thanks, Matt. Response inline.
> >
> > On Wed, Oct 14, 2015 at 2:57 PM, Matt Corallo <lf-lists at mattcorallo.com
> > <mailto:lf-lists at mattcorallo.com>> wrote:
> >
> >     That conversation missed a second issue. Namely that there is no way
> >     to punish people if there is a double spend in a micro block that
> >     happens in key block which reorg'd away the first transaction. eg
> >     one miner mines a transaction in a micro block, another miner
> >     (either by not having seen the first yet, or being malicious -
> >     potentially the same miner) mines a key block which reorgs away the
> >     first micro block and then, in their first micro block, mines a
> >     double spend. This can happen at any time, so you end up having to
> >     fall back to regular full blocks for confirmation times :(.
> >
> >
> > If NG is to be used efficiently, microblocks are going to be very
> > frequent, and so such forks should occur at almost every key-block
> > publication. Short reorgs as you described are the norm. A user should
> > wait before accepting a transaction to make sure there was no key-block
> > she missed. The wait time is chosen according to the network propagation
> > delay (+as much slack as the user feels necessary). This is similar to
> > the situation in Bitcoin when you receive a block. To be confident that
> > you have one confirmation you should wait for the propagation time of
> > the network to make sure there is no branch you missed.
>
> I think you're overstating how short the wait times can be. They need to
> be much longer than the network propagation delay.
>
> > As for the malicious case: the attacker has to win the key-block, have
> > the to-be-inverted transaction in the previous epoch, and withhold his
> > key-block for a while. That being said, indeed our fraud proof scheme
> > doesn't catch such an event, as it is indistinguishable from benign
> > behavior.
>
> The attacker does not need to withold their keyblock at all. All the
> attacker does is, for every transaction they ever send, after it is
> included in a microblock, set their hashpower to start mining a keyblock
> immediately prior to this microblock. When they find a keyblock, they
> immediately announce it and start creating microblocks, the first of
> which double-spends the previous transaction. If they dont win the key
> block, oh well, their payment went through normally and they couldn't
> double-spend.
>
> In chatting with Glenn about this, we roughly agreed that the
> confirmation time for microblocks possibly doesn't need to be a full
> key-block, but it needs to be a reasonable period after which such an
> attacker would lose more in fees than the value of their double-spend
> (ie because the key-block afterwards gets 20% more in fees than the
> key-block before hand). In any case, the game theory here starts to get
> rather complicated and it doesn't make me want to suggest accepting
> microblocks as confirmations is safe.
>

Yes, an attacker can continuously try to do this, losing all (and only)
fees.
They will succeed every time they mine a block after the to-be-double-spent
transaction is placed by the current leader. So a microblock + delay is
stronger
than a zero-confirmation transaction, but not as strong as a first-block
confirmation.

A game theory analysis is indeed difficult here, mainly since the
assumptions
are not entirely clear. We are working towards this, starting with
formalizing
the attacker's incentive structure.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151106/c5d8d279/attachment.html>

From cp368202 at ohiou.edu  Fri Nov  6 23:41:36 2015
From: cp368202 at ohiou.edu (Chris Priest)
Date: Fri, 6 Nov 2015 15:41:36 -0800
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CALqxMTGnusroDgjt0a7HqfPpS=1n7WNu1uz6bOPG2vQAbCNQ1g@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
	<563BE746.5030406@voskuil.org>
	<CAAcC9yv6JwSY-LhWaFc5cF6CkTwTfLLtqFfemwjJ7hKnfzXuLQ@mail.gmail.com>
	<CALqxMTGnusroDgjt0a7HqfPpS=1n7WNu1uz6bOPG2vQAbCNQ1g@mail.gmail.com>
Message-ID: <CAAcC9yvq51pj_yH_SsbqGg08sgwNZJ-h+YnY4ekgDUNYLBSRxQ@mail.gmail.com>

> The bigger point however, which Erik explained, was: widespread use of
> APIs as a sole means of interfacing with the blockchain also
> contributes to reducing network security for everyone, because it
> erodes the consensus rule validation security described under
> "Validators" in the OP.

I completely disagree with this. You are implying that there is some
sort of ideal ratio of full nodes to 'client only' nodes that the
network must maintain. You seem to be implying that if that ideal
ratio is to somehow be disrupted, then security suffers. My question
to you is what is that ideal ratio and what methodology did you use to
come up with it?

The way I see it, the security of the system is independent on ratio
between full nodes and lightweight nodes.

In other words, if there are 100,000 lightweight wallets to 100 full
nodes, then you have the same security profile as one with 100,000
full nodes to 100 lightweight wallets.

I think most 'big blockers' think the same way I do, hence the rub
between the two camps.

Small block people need to make a better case as to how exactly full
node ratio relates to network security (especially the 'for everyone'
part), because the link is not clear to me at all. Small block people
seem to take this simple fact as self evident, but I just don't see
it.

On 11/6/15, Adam Back <adam at cypherspace.org> wrote:
> You're right that it is better that there be more APIs than fewer,
> that is less of a single point of failure.  It also depends what you
> mean by APIs: using an API to have a second cross-check of information
> is quite different to building a wallet or business that only
> interfaces with the blockchain via a 3rd party API.  There are
> different APIs also: some are additive eg they add a second signature
> via multisig, but even those models while better can still be a mixed
> story for security, if the user is not also checking their own
> full-node or checking SPV to make the first signature.
>
> Power users and businesses using APIs instead of running a full-node,
> or instead of doing SPV checks, should be clear about the API and what
> security they are delegating to a third party, and whether they have a
> reason to trust the governance and security competence of the third
> party: in the simplest case it can reduce their and their users
> security below SPV.
>
> The bigger point however, which Erik explained, was: widespread use of
> APIs as a sole means of interfacing with the blockchain also
> contributes to reducing network security for everyone, because it
> erodes the consensus rule validation security described under
> "Validators" in the OP.
>
> Adam
>
>
> On 6 November 2015 at 09:05, Chris Priest <cp368202 at ohiou.edu> wrote:
>> On 11/5/15, Eric Voskuil via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> On 11/05/2015 03:03 PM, Adam Back via bitcoin-dev wrote:
>>>> ...
>>>> Validators: Economically dependent full nodes are an important part of
>>>> Bitcoin's security model because they assure Bitcoin security by
>>>> enforcing consensus rules.  While full nodes do not have orphan
>>>> risk, we also dont want maliciously crafted blocks with pathological
>>>> validation cost to erode security by knocking reasonable spec full
>>>> nodes off the network on CPU (or bandwidth grounds).
>>>> ...
>>>> Validators vs Miner decentralisation balance:
>>>>
>>>> There is a tradeoff where we can tolerate weak miner decentralisation
>>>> if we can rely on good validator decentralisation or vice versa.  But
>>>> both being weak is risky.  Currently given mining centralisation
>>>> itself is weak, that makes validator decentralisation a critical
>>>> remaining defence - ie security depends more on validator
>>>> decentralisation than it would if mining decentralisation was in a
>>>> better shape.
>>>
>>> This side of the security model seems underappreciated, if not poorly
>>> understood. Weakening is not just occurring because of the proliferation
>>> of non-validating wallet software and centralized (web) wallets, but
>>> also centralized Bitcoin APIs.
>>>
>>> Over time developers tend to settle on a couple of API providers for a
>>> given problem. Bing and Google for search and mapping, for example. All
>>> applications and users of them, depending on an API service, reduce to a
>>> single validator. Imagine most Bitcoin applications built on the
>>> equivalent of Bing and Google.
>>>
>>> e
>>>
>>>
>>
>> I disagree. I think blockchain APIs are a good thing for
>> decentralization. There aren't just 3 or 4 blockexplorer APIs out
>> there, there are dozens. Each API returns essentially the same data,
>> so they are all interchangeable. Take a look at this python package:
>> https://github.com/priestc/moneywagon
>

From bram at bittorrent.com  Sat Nov  7 01:25:53 2015
From: bram at bittorrent.com (Bram Cohen)
Date: Fri, 6 Nov 2015 17:25:53 -0800
Subject: [bitcoin-dev] How wallets can handle real transaction fees
Message-ID: <CA+KqGkq7L_gfaCRobSdaL4paEbhYcGO-j_Gmh_q_=P7CKPVPwQ@mail.gmail.com>

(My apologies for a 'drive-by' posting. I'm not subscribed to this mailing
list but this post may be of interest here. If you'd like to make sure I
see a response send it to me directly. This post was originally posted to
the web at
https://medium.com/@bramcohen/how-wallets-can-handle-transaction-fees-ff5d020d14fb
 )

Since transaction fees are a good thing (see
https://medium.com/@bramcohen/bitcoin-s-ironic-crisis-32226a85e39f ), that
brings up the question: How should wallets handle them? This essay is an
expansion of my talk at the bitcoin scaling conference (see
https://www.youtube.com/watch?v=iKDC2DpzNbw&t=13m17s and
https://scalingbitcoin.org/montreal2015/presentations/Day1/11-bram_wallet_fees.pdf
 ).

Ground Rules

To answer this question we first need to lay down some ground rules of what
we?re trying to solve. We?ll focus on trying to solve the problem for
consumer wallets only. We?ll be ignoring microchannels, which dramatically
reduce the number of transactions used but still have to put some on the
blockchain. We?ll also be assuming that full replace by fee is in effect
(see
https://medium.com/@bramcohen/the-inevitable-demise-of-unconfirmed-bitcoin-transactions-8b5f66a44a35
)
because the best solution uses that fairly aggressively.

What should transaction fees be?

Before figuring out how wallets should calculate transaction fees, we first
need to know what transaction fees should be. The obvious solution to that
question is straightforward: It should be determined by supply and demand.
The price is set at the point where the supply and demand curves meet. But
supply and demand curves, while mostly accurate, are a little too simple of
a model to use, because they don?t take into account time. In the real
world, the supply of space for transactions is extremely noisy, because
more becomes available (and has to be immediately consumed or it?s lost
forever) every time a block is minted, and block minting is an
intentionally random process, that randomness being essential for
consensus. Demand is random and cyclical. Random because each transaction
is generated individually so the total amount is noisy (although that
averages out to be somewhat smooth at scale) and has both daily and weekly
cycles, with more transactions done during the day than at night.

What all these result in is that there should be a reward for patience. If
you want or need to get your transaction in quicker you should have to pay
on average a higher fee, and if you?re willing to wait longer it should on
average cost less. Inevitably this will result in transactions taking on
average longer than one block to go through, but it doesn?t require it of
everyone. Those who wish to offer high fees to be sure of getting into the
very next block are free to do so, but if everyone were to do that the
system would fall apart.

What should the wallet user interface be?

Ideally transaction fees would be handled in a way which didn?t require
changes to a wallet?s user interface at all. Unfortunately that isn?t
possible. At a minimum it?s necessary to have a maximum fee which the user
is willing to spend in order to make a transaction go through, which of
course means that some transactions will fail because they aren?t willing
to pay enough, which is the whole point of having transaction fees in the
first place.

Because transaction fees should be lower for people willing to wait longer,
there should be some kind of patience parameter as well. The simplest form
of this is an amount of time which the wallet will spend trying to make the
transaction go through before giving up (Technically it may make sense to
specify block height instead of wall clock time, but that?s close enough to
not change anything meaningful). This results in fairly understandable
concepts of a transaction being ?pending? and ?failed? which happen at
predictable times.

Transactions eventually getting into a ?failed? state instead of going into
permanent limbo is an important part of the wallet fee user experience.
Unfortunately right now the only way to make sure that a transaction is
permanently failed is to spend its input on something else, but that
requires spending a transaction fee on the canceling transaction, which of
course would be just as big as the fee you weren?t willing to spend to make
the real transaction go through in the first place.

What?s needed is a protocol extension so a transaction can make it
impossible for it to be committed once a certain block height has been
reached. The current lack of such an extension is somewhat intentional
because there are significant potential problems with transactions going
bad because a block reorganization happened and some previously accepted
transactions can?t ever be recommitted because their max block height got
surpassed. To combat this, when a transaction with a max block height gets
committed near its cutoff it?s necessary to wait a longer than usual number
of blocks to be sure that it?s safe (I?m intentionally not giving specific
numbers here, some developers have suggested extremely conservative
values). This waiting is annoying but should only apply in the edge case of
failed transactions and is straightforward to implement. The really big
problem is that given the way Bitcoin works today it?s very hard to add
this sort of extension. If any backwards-incompatible change to Bitcoin is
done, it would be a very good idea to use that opportunity to improve
Bitcoin?s extension mechanisms in general and this one in particular.

What information to use

The most obvious piece of information to use for setting transaction fees
is past transaction fees from the last few blocks. This has a number of
problems. If the fee rate goes high, it can get stuck there and take a
while to come down, if ever, even though the equilibrium price should be
lower. A telltale sign of this is high fee blocks which aren?t full, but
it?s trivial for miners to get around that by padding their blocks with
self-paying transactions. To some extent this sort of monopoly pricing is
inherent, but normally it would require a cabal of most miners to pull it
off, because any one miner can make more money in the short term by
accepting every transaction they can instead of restricting the supply of
available transaction space. If transaction fees are sticky, a large but
still minority miner can make money for themselves even in the short term
by artificially pumping fees in one of their blocks because fees will
probably still be high by the time of their next block.

Past fees also create problems for SPV clients, who have to trust the full
nodes they connect to to report past fees accurately. That could be
mitigated by making an extension to the block format to, for example,
report what the minimum fee per bytes paid in this block is in the headers.
It isn?t clear exactly what that extension should do though. Maybe you want
to know the minimum, or the median, or the 25th percentile, or all of the
above. It?s also possible for miners to game the system by making a bunch
of full nodes which only report blocks which are a few back when fees have
recently dropped. There are already some incentives to do that sort of bad
behavior, and it can be mitigated by having SPV clients connect to more
full nodes than they currently do and always go with the max work, but SPV
clients don?t currently do that properly, and it?s unfortunate to create
more incentives for bad behavior.

Another potential source of information for transaction fees is currently
pending transactions in the network. This has a whole lot of problems. It?s
extremely noisy, much more so than regular transaction fees, because (a)
sometimes a backlog of transactions builds up if no blocks happen to have
happened in a while (b) sometimes there aren?t many transactions if a bunch
of blocks went through quickly, and (c) in the future full nodes can and
should have a policy of only forwarding transactions which are likely to
get accepted sometime soon given the other transactions in their pools.
Mempool is also trivially gameable, in exactly the same way as the last few
blocks are gameable, but worse: A miner who wishes to increase fees can run
a whole lot of full nodes and report much higher fees than are really
happening. Unlike with fee reporting in blocks, there?s no way for SPV
clients to audit this properly, even with a protocol extension, and it?s
possible for full nodes to lie in a much more precise and targetted manner.
Creating such a strong incentive for such a trivial and potentially
lucrative attack seems like a very bad idea.

A wallet?s best information to use when setting price are the things which
can be absolutely verified locally: The amount it?s hand to pay in the
past, the current time, how much it?s willing to pay by when. All of these
have unambiguous meanings, precise mathematical values, and no way for
anybody else to game them. A wallet can start at a minimum value, and every
time a new block is minted which doesn?t accept its transaction increase
its fee a little, until finally reaching its maximum value at the very end.
Full nodes can then follow the behavior of storing and forwarding along
several blocks?s worth of transactions, ten times sounds reasonable,
ignoring transactions which pay less per byte than the ones they have
stored, and further requiring that a new block be minted between times when
a single transaction gets replaced by fee. That policy both has the
property of being extremely denial-of-service resistant and minimizing the
damage to zeroconf. (Zeroconf is a bad idea, but if something is a good
idea to do for other reasons reducing the pain to those stuck with zeroconf
is a nice bonus.)

An actual formula

At long last, here is the formula I advocate using:

Pick a starting point which is de minimis for your first transaction or 1/2
(or less, configurable) your last fee paid if you?ve sent coin before

Let B = max number of blocks from start before giving up, S = starting fee,
M = max fee

For each new block at height H from the start, post a new transaction with
fee e^(lg(S) + (lg(M) ? lg(S)) * H/B)

To avoid artifacts when multiple wallets use the same magic numbers, do
this before the first block: pick V uniformly in [0, 1], let S = e^(lg(S) +
(lg(M) ? lg(S)) * (V/(V+B)))

The very first time you send coin it makes sense to give it a longer time
to do the transaction because it?s starting from a very low value and you
don?t want to way overshoot the amount necessary. But if you start from the
standard absolute minimum fee in Bitcoin and put the maximum time at
several hours it will increase by less than 10% per block, so exponential
growth is on your side.

It might be reasonable to, for example, start at a value which is a
discount to the minimum paid in the last block if that value is less than
what you would start with otherwise and if there?s a protocol extension to
put that information in the block headers. Such possibilities should be
studied and discussed more, but the formula I gave above should be the
default starting point if you simply want something which works and is
conservative and reliable.

Sidebar: Handling utxo combining

Whenever a wallet makes a payment, it needs to decide how to structure the
inputs and outputs of the new transaction. Generally the output consists of
two utxos, one of them going to the recipient and one of them going back
into the original wallet. Which input or inputs to use is less clear.
Usually an attempt is made to optimize for anonymity, or at least leaking
as little information as possible, and there?s usually a comment in the
code saying what amounts to ?I can?t clearly justify any particular
strategy here but this is what I?m doing?.

When there are real transaction fees, one might consider trying to optimize
utxo combining for fees. The strategy used turns out to matter surprisingly
little for fees in the long run. For every separate utxo in your wallet,
you?ll eventually have to pay the fee to combine it with something else,
and the amount of increase in fee will be the same regardless of whether
you do it in the current transaction or a later transaction. It does make
sense to include more inputs in earlier versions of a payment though,
because the fees at that time are lower, and drop them in later versions
once the fees have gone up, in the hopes that the utxo consolidation can be
done for cheaper in some later transaction. It may also make sense to do
completely separate purely consolidation transactions with no external
output during off-peak times. That puts more bytes on the blockchain
because of the unnecessary intermediary value it generates though, so there
needs to be a significant difference in fees between peak and off-peak
times for it to make sense. Both of those techniques have significant and
unclear privacy implications and should be studied more.

There are also signing tricks which could potentially save significant
amounts of bytes on the blockchain, thus lowering fees. The most elegant
would be to create a new extension so that when there are multiple inputs
to a transaction which all use Schnorr the signature can be a single
combination signature instead of separate signatures for each of them. This
has very little downside and I?m strongly in favor of it being done.

A simpler, less elegant trick which saves more bytes would be to allow
multiple inputs to the same transaction which use the same key to only
result in a single signature. This lowers privacy, because it gives away
the association between utxos before they?re consolidated, but if used
properly would only push back that reveal a little bit. The danger is that
wallets would instead use it improperly and use the same key all the time,
which would always save as many bytes as possible but be a privacy disaster.

A trick which is a just plain bad idea, although it would save even more
bytes, would be not count the bytes of the reveal of a p2sh script to count
if that exact same script has ever been used before. This is clearly a bad
idea, because it directly encourages extremely privacy-averse behavior, and
because it necessitates a data structure of all p2sh scripts which have
ever been done before for validation, which is quite large and costly to
maintain.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151106/f9ea4b51/attachment-0001.html>

From eric at voskuil.org  Sat Nov  7 00:44:48 2015
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 06 Nov 2015 16:44:48 -0800
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CAAcC9yvq51pj_yH_SsbqGg08sgwNZJ-h+YnY4ekgDUNYLBSRxQ@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>	<563BE746.5030406@voskuil.org>	<CAAcC9yv6JwSY-LhWaFc5cF6CkTwTfLLtqFfemwjJ7hKnfzXuLQ@mail.gmail.com>	<CALqxMTGnusroDgjt0a7HqfPpS=1n7WNu1uz6bOPG2vQAbCNQ1g@mail.gmail.com>
	<CAAcC9yvq51pj_yH_SsbqGg08sgwNZJ-h+YnY4ekgDUNYLBSRxQ@mail.gmail.com>
Message-ID: <563D4980.9080604@voskuil.org>

On 11/06/2015 03:41 PM, Chris Priest wrote:
>> The bigger point however, which Erik explained, was: widespread use of
>> APIs as a sole means of interfacing with the blockchain also
>> contributes to reducing network security for everyone, because it
>> erodes the consensus rule validation security described under
>> "Validators" in the OP.
> 
> I completely disagree with this. You are implying that there is some
> sort of ideal ratio of full nodes to 'client only' nodes that the
> network must maintain. You seem to be implying that if that ideal
> ratio is to somehow be disrupted, then security suffers. My question
> to you is what is that ideal ratio and what methodology did you use to
> come up with it?

Nobody has advocated a golden ratio.

> The way I see it, the security of the system is independent on ratio
> between full nodes and lightweight nodes.
> 
> In other words, if there are 100,000 lightweight wallets to 100 full
> nodes, then you have the same security profile as one with 100,000
> full nodes to 100 lightweight wallets.

This is a false dichotomy. Both scenarios are poor for security, as
nobody with a wallet is validating. It's entirely possible, even
probable, that one person controls all of the nodes.

> I think most 'big blockers' think the same way I do, hence the rub
> between the two camps.
> 
> Small block people need to make a better case as to how exactly full
> node ratio relates to network security (especially the 'for everyone'
> part), because the link is not clear to me at all. Small block people
> seem to take this simple fact as self evident, but I just don't see
> it.

Fewer people independently validating their own transactions means trust
is placed in fewer people. The degenerate case of one validator and
everyone trusting it is dispositive, and equates roughly to the Federal
Reserve.

> On 11/6/15, Adam Back <adam at cypherspace.org> wrote:
>> You're right that it is better that there be more APIs than fewer,
>> that is less of a single point of failure.  It also depends what you
>> mean by APIs: using an API to have a second cross-check of information
>> is quite different to building a wallet or business that only
>> interfaces with the blockchain via a 3rd party API.  There are
>> different APIs also: some are additive eg they add a second signature
>> via multisig, but even those models while better can still be a mixed
>> story for security, if the user is not also checking their own
>> full-node or checking SPV to make the first signature.
>>
>> Power users and businesses using APIs instead of running a full-node,
>> or instead of doing SPV checks, should be clear about the API and what
>> security they are delegating to a third party, and whether they have a
>> reason to trust the governance and security competence of the third
>> party: in the simplest case it can reduce their and their users
>> security below SPV.
>>
>> The bigger point however, which Erik explained, was: widespread use of
>> APIs as a sole means of interfacing with the blockchain also
>> contributes to reducing network security for everyone, because it
>> erodes the consensus rule validation security described under
>> "Validators" in the OP.
>>
>> Adam
>>
>>
>> On 6 November 2015 at 09:05, Chris Priest <cp368202 at ohiou.edu> wrote:
>>> On 11/5/15, Eric Voskuil via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> On 11/05/2015 03:03 PM, Adam Back via bitcoin-dev wrote:
>>>>> ...
>>>>> Validators: Economically dependent full nodes are an important part of
>>>>> Bitcoin's security model because they assure Bitcoin security by
>>>>> enforcing consensus rules.  While full nodes do not have orphan
>>>>> risk, we also dont want maliciously crafted blocks with pathological
>>>>> validation cost to erode security by knocking reasonable spec full
>>>>> nodes off the network on CPU (or bandwidth grounds).
>>>>> ...
>>>>> Validators vs Miner decentralisation balance:
>>>>>
>>>>> There is a tradeoff where we can tolerate weak miner decentralisation
>>>>> if we can rely on good validator decentralisation or vice versa.  But
>>>>> both being weak is risky.  Currently given mining centralisation
>>>>> itself is weak, that makes validator decentralisation a critical
>>>>> remaining defence - ie security depends more on validator
>>>>> decentralisation than it would if mining decentralisation was in a
>>>>> better shape.
>>>>
>>>> This side of the security model seems underappreciated, if not poorly
>>>> understood. Weakening is not just occurring because of the proliferation
>>>> of non-validating wallet software and centralized (web) wallets, but
>>>> also centralized Bitcoin APIs.
>>>>
>>>> Over time developers tend to settle on a couple of API providers for a
>>>> given problem. Bing and Google for search and mapping, for example. All
>>>> applications and users of them, depending on an API service, reduce to a
>>>> single validator. Imagine most Bitcoin applications built on the
>>>> equivalent of Bing and Google.
>>>>
>>>> e
>>>>
>>>>
>>>
>>> I disagree. I think blockchain APIs are a good thing for
>>> decentralization. There aren't just 3 or 4 blockexplorer APIs out
>>> there, there are dozens. Each API returns essentially the same data,
>>> so they are all interchangeable. Take a look at this python package:
>>> https://github.com/priestc/moneywagon
>>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151106/1cfc4dae/attachment.sig>

From gavinandresen at gmail.com  Sun Nov  8 14:54:04 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Sun, 8 Nov 2015 14:54:04 +0000
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
Message-ID: <CABsx9T0T6QuYRmNyF_F124GyQ2EX5w93HCPLvrd4L5P6=xj_Xw@mail.gmail.com>

On Thu, Nov 5, 2015 at 11:03 PM, Adam Back via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Some thoughts, hope this is not off-topic.
>
> Maybe we should summarise the security assumptions and design
> requirements.  It is often easier to have clear design discussions by
> first articulating assumptions and requirements.
>
> Validators: Economically dependent full nodes are an important part of
> Bitcoin's security model because they assure Bitcoin security by
> enforcing consensus rules.  While full nodes do not have orphan
> risk, we also dont want maliciously crafted blocks with pathological
> validation cost to erode security by knocking reasonable spec full
> nodes off the network on CPU (or bandwidth grounds).
>

Agreed. That is why BIP101 / BitcoinXT includes code to limit the relay and
validation cost of blocks.


>
> Miners: Miners are in a commodity economics competitive environment
> where various types of attacks and collusion, even with small
> advantage, may see actual use due to the advantage being significant
> relative to the at times low profit margin
>

Agreed, with a quibble: mining economics means they will ALWAYS have a low
profit margin.


>
> It is quite important for bitcoin decentralisation security that small
> miners not be significantly disadvantaged vs large miners.  Similarly
> it is important that there not be significant collusion advantages
> that create policy centralisation as a side-effect (for example what
> happened with "SPV mining" or validationless mining during BIP66
> deployment).  Examples of attacks include selfish-mining and
> amplifying that kind of attack via artificially large or
> pathologically expensive to validate blocks.  Or elevating orphan risk
> for others (a miner or collusion of miners is not at orphan risk for a
> block they created).
>

Okey dokey-- perhaps we should have another discussion about SPV mining, as
far as I know it harmed nobody besides the miners who mindlessly created
invalid, empty blocks (well, and besides being very annoying for developers
who had to figure out what was happening and get the offending miners to do
the right thing).

In any case, it seems to me all of this (except perhaps selfish mining) is
independent of the maximum block size, and solutions for all of the above
(including selfish mining) should be pursued regardless of what is done
with the max block size (e.g. I sent Ittay and Gun email a few minutes ago
with some might-be-wong-ideas for how weak block announcements might be
used to detect selfish mining).


>
> Validators vs Miner decentralisation balance:
>
> There is a tradeoff where we can tolerate weak miner decentralisation
> if we can rely on good validator decentralisation or vice versa.  But
> both being weak is risky.  Currently given mining centralisation
> itself is weak, that makes validator decentralisation a critical
> remaining defence - ie security depends more on validator
> decentralisation than it would if mining decentralisation was in a
> better shape.
>

I'm very disappointed you don't mention the tradeoff at "the other end of
the bathtub" -- Key-holder versus Validator decentralization balance. Did
you see the excellent Poon/Dryja "bathtub" presentation at Montreal?

https://scalingbitcoin.org/montreal2015/presentations/Day2/3-JosephPoonAndThaddeusDryja.pdf

Security:
>
> We should consider the pathological case not average or default behaviour
> because we can not assume people will follow the defaults, only the
> consensus-enforced rules.
>

Agreed, which is why BIP101/XT consider pathological behavior.


>
> We should not discount attacks that have not seen exploitation to
> date.  We have maybe benefitted from universal good-will (everybody
> thinks Bitcoin is cool, particularly people with skills to find and
> exploit attacks).
>

Disagree on wording: we should not ignore attacks that have not seen
exploitation. But in the never-ending-list of things to be worried about
and to write code for, attacks that have not been seen should be lower
priority than attacks that have been seen, either in Bitcoin or elsewhere.

E.g. Bitcoin has never seen a buffer-overflow attack, but we absolutely
positively need to put a very high priority on the network attack surface
-- we know buffer-overflow attacks are commonly exploited.

On the other hand, Bitcoin has never seen a "Goldfinger attack" (take a big
short position on Bitcoin, then find a way to destroy confidence so the
price drops and you can profit), and "Goldfinger attacks" don't seem to be
common anywhere (you don't see people taking huge short positions in
companies and then bombing their factories). There might be a reason
Bitcoin is more vulnerable, or the same checks-and-balances (e.g. whoever
took the other side of the large short has a strong incentive to report
you, and assuming you got paid in something other than Bitcoin that is
probably possible).
  (Aside: anybody who wants to talk about the likelihood of "Goldfinger
attacks" please start a thread somewhere else, I don't think that's
appropriate for bitcoin-dev).


>
> We can consider a hierarchy of defences most secure to least:
>
> 1. consensus rule enforced (attacker loses block reward)
> 2. economic alignment (attacker loses money)
> 3. overt (profitable, but overt attacks are less likely to be exploited)
> 4. meta-incentive (relying on meta-incentive to not damage the ecosystem
> only)
>

Agreed.


> Best practices:
>
> We might want to list some best practices that are important for the
> health and security of the Bitcoin network.
>
> Rule of thumb KISS stuff:
>
> We should aim to keep things simple in general and to avoid creating
> complex optimisation problems for transaction processors, wallets,
> miners.
>

I agree with KISS.

I think we can't avoid creating complex optimization problems sometimes--
see, for example, the difficulty of a wallet predicting what transaction
fee is needed for a transaction to get confirmed in X blocks (lots of
factors involved-- max block size, time since last block, miner policy as
expressed in previous blocks, transactions currently waiting in
mempool....).  I do agree we should prefer simple optimization problems
over complex wherever we can.



> We may want to consider an incremental approach (shorter-time frame or
> less technically ambitious) in the interests of simplifying and
> getting something easier to arrive at consensus, and thus faster to
> deploy.
>

Or we may want to go with something that is already tested and deployed...


>
> We should not let the perfect be the enemy of the good.  But we should
> not store new problems for the future, costs are stacked in favour of
> getting it right vs A/B testing on the live network.
>

I disagree about "storing new problems for the future."  We don't know what
the problems will be in the future, so there is alway a leap of faith that
future engineers will be smart enough to fix the engineering problems that
arise (see the worries over quantum computing advances making ECDSA
obsolete) -- ESPECIALLY if we have thumbnail sketches of solutions that
we're reasonably certain will work (e.g. switching to a quantum-resistant
signature algorithm via soft-fork).


>
> Not everything maybe fixable in one go for complexity reasons or for
> the reason that there is no clear solution for some issues.  We should
> work incrementally.
> <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>


I think the disagreement is how big a change fits into the definition of
"incrementally."

As Jeff Garzik has pointed out, the recent change from "we never hit the
maximum block size limit" to "we regularly run into the maximum block size
limit" was a large, NON-incremental change...

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151108/25830bce/attachment.html>

From kanzure at gmail.com  Sun Nov  8 17:19:15 2015
From: kanzure at gmail.com (Bryan Bishop)
Date: Sun, 8 Nov 2015 11:19:15 -0600
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CABsx9T0T6QuYRmNyF_F124GyQ2EX5w93HCPLvrd4L5P6=xj_Xw@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
	<CABsx9T0T6QuYRmNyF_F124GyQ2EX5w93HCPLvrd4L5P6=xj_Xw@mail.gmail.com>
Message-ID: <CABaSBaxKQe2SnMuwHq-7482BmY+vvD4SefKjXxEPhxZTOoyHrA@mail.gmail.com>

On Sun, Nov 8, 2015 at 8:54 AM, Gavin Andresen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'm very disappointed you don't mention the tradeoff at "the other end of
> the bathtub" -- Key-holder versus Validator decentralization balance


Gavin, could you please provide some clarity around the definition and
meaning of "key-holder [decentralization]"? Is this about the absolute
number of key-holders? or rather about the number of transactions (per unit
time?) that key-holders make? Both/other?

Anyone can generate a private key, and anyone can sign a transaction
spending to a new commitment. Child-pays-for-parent could be used when
transaction fees are too high. Perhaps more interesting would be something
like lightning network payment channels, where only the commitment
transaction needs to be in the blockchain history; does that count as
key-holder decentralization at all?

Also, consider the following scenario. Suppose there's a bunch of
merge-mined sidechains that are mainnet BTC-pegged, and these sidechains
are accessible by the lightning network protocol (multi-chain payments).
Suppose also that on the different sidechains there are different
transaction fee trends because of various technical differences underlying
consensus or a different blockchain implementation (who knows). When
someone routes payments to one of those different sidechains, because UTXOs
could be cheaper over there due to different fee pressures, ... would that
count as key-holder decentralization? Some of this scenario is described
here, although not in more detail:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-September/010909.html

Previously there has been the suggestion to use BTC-pegged merge-mined
chains to handle excess transaction demand:
http://diyhpl.us/wiki/transcripts/scalingbitcoin/sharding-the-blockchain/
https://github.com/vbuterin/scalability_paper/blob/master/scalability.pdf
http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-March/004797.html

I notice that in the Poon file there is a concern regarding "only 10 key
holders", but how does that scenario really work? I think the actual
scenario they mean to describe is "there's always a transaction backlog
where the fees are so high that lower fee transactions can never get
confirmations". So, more specifically, the scenario would have to be
"lightning network exists and is working, and no lightning node can ever
route enough different payments to commit to the blockchain under any
circumstance". How would that be possible? Wouldn't most participants
prefer the relatively instantaneous transactions of lightning, even if they
can afford extremely high fees? Seems like the settlements have all
necessary reason to actually happen, don't know what your concern is,
please send help.

I don't mean to put words in anyone's mouth, everything above is mostly
asking for clarification around definitions. Some of these questions are
repeats from:
http://gnusha.org/bitcoin-wizards/2015-11-08.log

Thank you.

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151108/e90b51a1/attachment-0001.html>

From laanwj at gmail.com  Mon Nov  9 10:41:17 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 9 Nov 2015 11:41:17 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.11.2 release candidate 1 available
Message-ID: <20151109104115.GA21603@amethyst.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Binaries for bitcoin Core version 0.11.2rc1 are now available from:

    https://bitcoin.org/bin/bitcoin-core-0.11.2/test/

Source code can be found on github under the signed tag

    https://github.com/bitcoin/bitcoin/tree/v0.11.2rc1

This is a new minor version release, bringing bug fixes, the BIP65 (CLTV)
consensus change, and relay policy preparation for BIP113.

Preliminary release notes for the 0.11.2 release can be found here:

    https://github.com/bitcoin/bitcoin/blob/0.11/doc/release-notes.md

Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.11.2.

Please report bugs using the issue tracker at github:

    https://github.com/bitcoin/bitcoin/issues

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBCgAGBQJWQHgdAAoJEHSBCwEjRsmmkZkH/joklzUWXNCS/CKjfhnDaSAL
kTuGpcBPcmGyLZ+n7YHIwXKi5Jjuy91ADbYKUQHtOI5oDK+5XY0SD5YDfQv+jx8a
m3J5rxePV6VXcXKtNURXRmmk71zGhIZvZ0ynUlgLqvP7WFM+FcH5BJF2sk2amFlK
2WIzJapJMXzOyYehb9ISb2qXtuSGDyevpfeDJVMNIqoQekS1r8jOPXJiT66G4HZZ
SvUMPZAjgOtjKUQK98nF1xzRggkWiP1rjeBVdvlYiTmCopYrNiB5scPmSf2guCrx
7IH5fLbQ7JDow49dcd2ILTYFgMF03HvPvtlwz9dvOx5JYOaCw0He5CnXzZgFmV0=
=uO43
-----END PGP SIGNATURE-----

From gavinandresen at gmail.com  Mon Nov  9 16:27:22 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Mon, 9 Nov 2015 11:27:22 -0500
Subject: [bitcoin-dev] summarising security assumptions (re cost metrics)
In-Reply-To: <CABaSBaxKQe2SnMuwHq-7482BmY+vvD4SefKjXxEPhxZTOoyHrA@mail.gmail.com>
References: <CALqxMTE1JDsT8fSoDZVTUWfnw4Cmb9LkDa+B-XUyXGPxAYernA@mail.gmail.com>
	<CABsx9T0T6QuYRmNyF_F124GyQ2EX5w93HCPLvrd4L5P6=xj_Xw@mail.gmail.com>
	<CABaSBaxKQe2SnMuwHq-7482BmY+vvD4SefKjXxEPhxZTOoyHrA@mail.gmail.com>
Message-ID: <CABsx9T081xkFgwGQ-vrnm_yDAVpZunQFxAEbBBJXXaSxOOoXcA@mail.gmail.com>

On Sun, Nov 8, 2015 at 12:19 PM, Bryan Bishop <kanzure at gmail.com> wrote:

> Gavin, could you please provide some clarity around the definition and
> meaning of "key-holder [decentralization]"? Is this about the absolute
> number of key-holders? or rather about the number of transactions (per unit
> time?) that key-holders make? Both/other?
>

Both.  If few transactions are possible, then that limits the number of
key-holders who can participate in the system.

Imagine the max block size was really small, and stretch your imagination
and just assume there would be enough demand that those small number of
transactions pay enough transaction fees to secure the network. Each
transaction must, therefore, pay a high fee. That limits the number of
keyholders to institutions with very-large-value transactions-- it is the
"Bitcoin as a clearing network for big financial players" model.

Using the Lightning Network doesn't help, since every Lightning Network
transaction IS a set of Bitcoin transactions, ready to be dropped onto the
main chain. If those Lightning Network transactions don't have enough fees,
then the whole security of the Lightning Protocol falls apart (since it
relies on being able to get timelocked transactions confirmed on the main
chain in case your trading partner cheats).

There is video of the Poon/Dryja talk:
https://youtu.be/TgjrS-BPWDQ?t=41m58s

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151109/4b351799/attachment.html>

From el33th4x0r at gmail.com  Mon Nov  9 18:33:27 2015
From: el33th4x0r at gmail.com (=?UTF-8?Q?Emin_G=C3=BCn_Sirer?=)
Date: Mon, 9 Nov 2015 13:33:27 -0500
Subject: [bitcoin-dev] Bitcoin-NG whitepaper.
In-Reply-To: <CAPkFh0viwmkUvjo4Qj50TNnkA5kG3z-3dLGExjkmDacE4E49Ow@mail.gmail.com>
References: <CAPkFh0viwmkUvjo4Qj50TNnkA5kG3z-3dLGExjkmDacE4E49Ow@mail.gmail.com>
Message-ID: <CAPkFh0vQ=c+r1e+UBpCL0B-nbytzvUW3x=5Chuo=8-Ywdfcr_A@mail.gmail.com>

Hi everyone,

Thanks to everyone for a very friendly and scientifically-oriented
discussion. We have collated all the issues that have been raised related
to NG, and placed them in context, here:
    http://hackingdistributed.com/2015/11/09/bitcoin-ng-followup/

Overall, NG has a unique insight: turning the block creation process upside
down can provide many benefits. Most notably, throughput can go as high as
the network will allow, providing scalability benefits that increase as the
network improves. There are many other side benefits, including fast
confirmations that are stronger than 0-conf in Core, and come much more
quickly than Core's 1-confirmations. And there are ancillary benefits as
well, such as resilience to fluctuations in mining power, and healthier
incentives for participants to ferry transactions. We believe that a fresh
new permission-less blockchain protocol, designed today, would end up
looking more like NG than Core. Of course, if NG could possibly be layered
on top of Bitcoin, that would be the ultimate combination.

Many thanks for an interesting discussion, and as always, we're happy to
hear constructive suggestions and feedback,
- egs


On Wed, Oct 14, 2015 at 2:02 PM, Emin G?n Sirer <el33th4x0r at gmail.com>
wrote:

> Hi everyone,
>
> We just released the whitepaper describing Bitcoin-NG, a new technique for
> addressing some of the scalability challenges faced by Bitcoin.
> Surprisingly, Bitcoin-NG can simultaneously increase throughput while
> reducing latency, and do so without impacting Bitcoin's open architecture
> or changing its trust model. This post illustrates the core technique:
>      http://hackingdistributed.com/2015/10/14/bitcoin-ng/
> while the whitepaper has all the nitty gritty details:
>      http://arxiv.org/abs/1510.02037
>
> Fitting NG on top of the current Bitcoin blockchain is future work that we
> think is quite possible. NG is compatible with both Bitcoin as is, as well
> as Blockstream-like sidechains, and we currently are not planning to
> compete commercially with either technology -- we see NG as being
> complementary to both efforts. This is pure science, published and shared
> with the community to advance the state of blockchains and to help them
> reach throughputs and latencies required of cutting edge fintech
> applications. Perhaps it can be adopted, or perhaps it can provide the
> spark of inspiration for someone else to come up with even better solutions.
>
> We would be delighted to hear your feedback.
> - Ittay Eyal and E. G?n Sirer.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151109/df19652c/attachment.html>

From peter.tschipper at gmail.com  Mon Nov  9 19:18:10 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Mon, 9 Nov 2015 11:18:10 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
Message-ID: <5640F172.3010004@gmail.com>

This is my first time through this process so please bear with me. 

I opened a PR #6973 this morning for Zlib Block Compression for block
relay and at the request of @sipa  this should have a BIP associated
with it.   The idea is simple, to compress the datastream before
sending, initially for blocks only but it could theoretically be done
for transactions as well.  Initial results show an average of 20% block
compression and taking 90 milliseconds for a full block (on a very slow
laptop) to compress.  The savings will be mostly in terms of less
bandwidth used, but I would expect there to be a small performance gain
during the transmission of the blocks particularly where network latency
is higher. 

I think the BIP title, if accepted should be the more generic, "Support
for Datastream Compression"  rather than the PR title of "Zlib
Compression for block relay" since it could also be used for
transactions as well at a later time.

Thanks for your time...

From johnathan at corganlabs.com  Mon Nov  9 20:41:17 2015
From: johnathan at corganlabs.com (Johnathan Corgan)
Date: Mon, 9 Nov 2015 12:41:17 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <5640F172.3010004@gmail.com>
References: <5640F172.3010004@gmail.com>
Message-ID: <CALOxbZubcT63VHFowdJBBTziHfVV1qnBEREMa+3ctnRRBzf-cg@mail.gmail.com>

On Mon, Nov 9, 2015 at 11:18 AM, Peter Tschipper via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:


> I opened a PR #6973 this morning for Zlib Block Compression for block
> relay and at the request of @sipa  this should have a BIP associated
> with it.   The idea is simple, to compress the datastream before
> sending, initially for blocks only but it could theoretically be done
> for transactions as well.  Initial results show an average of 20% block
> compression and taking 90 milliseconds for a full block (on a very slow
> laptop) to compress.  The savings will be mostly in terms of less
> bandwidth used, but I would expect there to be a small performance gain
> during the transmission of the blocks particularly where network latency
> is higher.
>

?The trade-off decisions among bandwidth savings, CPU performance, and
latency are local, and I think it shouldn't be assumed that any particular
node will want to support it.  I recommend that if P2P message compression
is implemented, it should be negotiated via the services field at
connection time.

-- 
Johnathan Corgan
Corgan Labs - SDR Training and Development Services
http://corganlabs.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151109/ba80d6bb/attachment.html>

From bob_bitcoin at mcelrath.org  Mon Nov  9 21:04:49 2015
From: bob_bitcoin at mcelrath.org (Bob McElrath)
Date: Mon, 9 Nov 2015 21:04:49 +0000
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
 Compression"
In-Reply-To: <5640F172.3010004@gmail.com>
References: <5640F172.3010004@gmail.com>
Message-ID: <20151109210449.GE5886@mcelrath.org>

I would expect that since a block contains mostly hashes and crypto signatures,
it would be almost totally incompressible.  I just calculated compression ratios:

zlib    -15%    (file is LARGER)
gzip     28%
bzip2    25%

So zlib compression is right out.  How much is ~25% bandwidth savings worth to
people?  This seems not worth it to me.  :-/

Peter Tschipper via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:
> This is my first time through this process so please bear with me. 
> 
> I opened a PR #6973 this morning for Zlib Block Compression for block
> relay and at the request of @sipa  this should have a BIP associated
> with it.   The idea is simple, to compress the datastream before
> sending, initially for blocks only but it could theoretically be done
> for transactions as well.  Initial results show an average of 20% block
> compression and taking 90 milliseconds for a full block (on a very slow
> laptop) to compress.  The savings will be mostly in terms of less
> bandwidth used, but I would expect there to be a small performance gain
> during the transmission of the blocks particularly where network latency
> is higher. 
> 
> I think the BIP title, if accepted should be the more generic, "Support
> for Datastream Compression"  rather than the PR title of "Zlib
> Compression for block relay" since it could also be used for
> transactions as well at a later time.
> 
> Thanks for your time...
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> !DSPAM:5640ff47206804314022622!
--
Cheers, Bob McElrath

"For every complex problem, there is a solution that is simple, neat, and wrong."
    -- H. L. Mencken 


From pindar.wong at gmail.com  Tue Nov 10 00:52:44 2015
From: pindar.wong at gmail.com (Pindar Wong)
Date: Tue, 10 Nov 2015 08:52:44 +0800
Subject: [bitcoin-dev] Call for Proposals for Scaling Bitcoin Hong Kong
In-Reply-To: <CAD5xwhhO8DBm4MayDWw_fO+4SYrhfFmAkjpeddOiTF=icdc3Bw@mail.gmail.com>
References: <CAD5xwhhO8DBm4MayDWw_fO+4SYrhfFmAkjpeddOiTF=icdc3Bw@mail.gmail.com>
Message-ID: <CAM7BtUrNc-CQ+TpKC+PHNv6qr2tEXWXUM_cKQb9tjKE0oTSbdA@mail.gmail.com>

Dear All,

Just a note that we've extended the last day for submissions by two days.

i.e. Proposals should be submitted to proposals at scalingbitcoin.org by November
11th 23:59 UTC

Cheers,

p.


On Thu, Nov 5, 2015 at 11:32 PM, Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The second Scaling Bitcoin Workshop will take place December 6th-7th at
> the Cyberport in Hong Kong. We are accepting technical proposals for
> improving Bitcoin performance including designs, experimental results, and
> comparisons against other proposals. The goals are twofold: 1) to present
> potential solutions to scalability challenges while identifying key areas
> for further research and 2) provide a venue where researchers, developers,
> and miners can communicate about Bitcoin development.
>
> We are accepting two types of proposals: one in which accepted authors
> will have an opportunity to give a 20-30 minute presentation at the
> workshop, and another where accepted authors can run an hour-long
> interactive workshop.
>
> Topics of interest include:
>
> Improving Bitcoin throughput
> Layer 2 ideas (i.e. payment channels, etc.)
> Security and privacy
> Incentives and fee structures
> Testing, simulation, and modeling
> Network resilience
> Anti-spam measures
> Block size proposals
> Mining concerns
> Community coordination
>
>
> All as related to the scalability of Bitcoin.
>
> Important Dates
>
> November 9th - Last day for submission
> November 16th - Last day for notification of acceptance and feedback
>
> Formatting
>
> We are doing rolling acceptance, so submit your proposal as soon as you
> can. Proposals may be submitted as a BIP or as a 1-2 page extended abstract
> describing ideas, designs, and expected experimental results. Indicate in
> the proposal whether you are interested in speaking, running an interactive
> workshop, or both. If you are interested in running an interactive
> workshop, please include an agenda.
>
> Proposals should be submitted to proposals at scalingbitcoin.org by November
> 9th.
>
> All talks will be livestreamed and published online, including slide decks.
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/cc258a3d/attachment.html>

From admin at glados.cc  Tue Nov 10 01:58:41 2015
From: admin at glados.cc (gladoscc)
Date: Tue, 10 Nov 2015 12:58:41 +1100
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <20151109210449.GE5886@mcelrath.org>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
Message-ID: <CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>

I think 25% bandwidth savings is certainly considerable, especially for
people running full nodes in countries like Australia where internet
bandwidth is lower and there are data caps.

I absolutely would not dismiss 25% compression. gzip and bzip2 compression
is relatively standard, and I'd consider the point of implementation
complexity tradeoff to be somewhere along 5-10%.

On Tue, Nov 10, 2015 at 8:04 AM, Bob McElrath via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I would expect that since a block contains mostly hashes and crypto
> signatures,
> it would be almost totally incompressible.  I just calculated compression
> ratios:
>
> zlib    -15%    (file is LARGER)
> gzip     28%
> bzip2    25%
>
> So zlib compression is right out.  How much is ~25% bandwidth savings
> worth to
> people?  This seems not worth it to me.  :-/
>
> Peter Tschipper via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org]
> wrote:
> > This is my first time through this process so please bear with me.
> >
> > I opened a PR #6973 this morning for Zlib Block Compression for block
> > relay and at the request of @sipa  this should have a BIP associated
> > with it.   The idea is simple, to compress the datastream before
> > sending, initially for blocks only but it could theoretically be done
> > for transactions as well.  Initial results show an average of 20% block
> > compression and taking 90 milliseconds for a full block (on a very slow
> > laptop) to compress.  The savings will be mostly in terms of less
> > bandwidth used, but I would expect there to be a small performance gain
> > during the transmission of the blocks particularly where network latency
> > is higher.
> >
> > I think the BIP title, if accepted should be the more generic, "Support
> > for Datastream Compression"  rather than the PR title of "Zlib
> > Compression for block relay" since it could also be used for
> > transactions as well at a later time.
> >
> > Thanks for your time...
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> >
> > !DSPAM:5640ff47206804314022622!
> --
> Cheers, Bob McElrath
>
> "For every complex problem, there is a solution that is simple, neat, and
> wrong."
>     -- H. L. Mencken
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/0d844af0/attachment.html>

From johnathan at corganlabs.com  Tue Nov 10 05:40:13 2015
From: johnathan at corganlabs.com (Johnathan Corgan)
Date: Mon, 9 Nov 2015 21:40:13 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
Message-ID: <CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>

On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:


> I think 25% bandwidth savings is certainly considerable, especially for
> people running full nodes in countries like Australia where internet
> bandwidth is lower and there are data caps.
>

?This reinforces the idea that such trade-off decisions should be be local
and negotiated between peers, not a required feature of the network P2P.?


-- 
Johnathan Corgan
Corgan Labs - SDR Training and Development Services
http://corganlabs.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151109/17db381d/attachment.html>

From tier.nolan at gmail.com  Tue Nov 10 09:44:11 2015
From: tier.nolan at gmail.com (Tier Nolan)
Date: Tue, 10 Nov 2015 09:44:11 +0000
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
Message-ID: <CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>

The network protocol is not quite consensus critical, but it is important.

Two implementations of the decompressor might not be bug for bug
compatible.  This (potentially) means that a block could be designed that
won't decode properly for some version of the client but would work for
another.  This would fork the network.

A "raw" network library is unlikely to have the same problem.

Rather than just compress the stream, you could compress only block
messages only.  A new "cblock" message could be created that is a
compressed block.  This shouldn't reduce efficiency by much.

If a client fails to decode a cblock, then it can ask for the block to be
re-sent as a standard "block" message.

This means that it is a pure performance improvement.  If problems occur,
then the client can just switch back to uncompressed mode for that block.

You should look into the block relay system.  This gives a larger
improvement than simply compressing the stream.  The main benefit is
latency but it means that actual blocks don't have to be sent, so gives a
potential 50% compression ratio.  Normally, a node receives all the
transactions and then those transactions are included later in the block.



On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
>> I think 25% bandwidth savings is certainly considerable, especially for
>> people running full nodes in countries like Australia where internet
>> bandwidth is lower and there are data caps.
>>
>
> ?This reinforces the idea that such trade-off decisions should be be local
> and negotiated between peers, not a required feature of the network P2P.?
>
>
> --
> Johnathan Corgan
> Corgan Labs - SDR Training and Development Services
> http://corganlabs.com
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/81ba0c7c/attachment-0001.html>

From oleganza at gmail.com  Tue Nov 10 10:52:46 2015
From: oleganza at gmail.com (Oleg Andreev)
Date: Tue, 10 Nov 2015 11:52:46 +0100
Subject: [bitcoin-dev] Dealing with OP_IF and OP_NOTIF malleability
In-Reply-To: <CAE-z3OX6bMY+RjphyDS-zAO=aXLs-B41G4m6ssUjFC03ByQkWA@mail.gmail.com>
References: <0e72b173ea8e8aaf6b1b678182fa1ea7@xbt.hk>
	<CAE-z3OUQyW9Hss-jMDx_HjT9y55SctmUiXiGYhTZe6=2Mj2OaA@mail.gmail.com>
	<8D9D1049-E502-4A37-ACE4-5A2B1369A90A@gmail.com>
	<CAE-z3OX6bMY+RjphyDS-zAO=aXLs-B41G4m6ssUjFC03ByQkWA@mail.gmail.com>
Message-ID: <B3EDCC26-F2CF-44AD-B373-0FD60DA3E30B@gmail.com>

OP_0 gives a zero length byte array because OP_0 == 0x00 which is equivalent to pushdata with zero length.

OP_EQUAL compares byte strings as-is. So it will push "false" because empty string is not the same as a single-byte string with 0x00 byte in it. Value "false" in turn is encoded as empty string, just like result of OP_0.

> On 06 Nov 2015, at 10:37, Tier Nolan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I meant not to use the OP_PUSH opcodes to do the push.
> 
> Does OP_0 give a zero length byte array?
> 
> Would this script return true?
> 
> OP_0
> OP_PUSHDATA1 (length = 1, data = 0)
> OP_EQUAL
> 
> The easiest definition is that OP_0 and OP_1 must be used to push the data and not any other push opcodes.
> 
> 
> On Fri, Nov 6, 2015 at 9:32 AM, Oleg Andreev <oleganza at gmail.com <mailto:oleganza at gmail.com>> wrote:
> 
> > One and zero should be defined as arrays of length one. Otherwise, it is still possible to mutate the transaction by changing the length of the array.
> >
> > They should also be minimally encoded but that is covered by previous rules.
> 
> These two lines contradict each other. Minimally-encoded "zero" is an array of length zero, not one. I'd suggest defining this explicitly here as "IF/NOTIF argument must be either zero-length array or a single byte 0x01".
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/8c16a920/attachment.html>

From laanwj at gmail.com  Tue Nov 10 14:02:22 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Tue, 10 Nov 2015 15:02:22 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.10.4 release candidate 1 available
Message-ID: <20151110140221.GA10280@amethyst.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Binaries for bitcoin Core version 0.10.4rc1 are now available from:

    https://bitcoin.org/bin/bitcoin-core-0.10.4/test/

Source code can be found on github under the signed tag

    https://github.com/bitcoin/bitcoin/tree/v0.10.4rc1

This is a new minor version release, bringing bug fixes, the BIP65 (CLTV)
consensus change, and relay policy preparation for BIP113.

Preliminary release notes for the 0.10.4 release can be found here:

    https://github.com/bitcoin/bitcoin/blob/0.10/doc/release-notes.md

Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.10.4.

Please report bugs using the issue tracker at github:

    https://github.com/bitcoin/bitcoin/issues

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBCgAGBQJWQfjkAAoJEHSBCwEjRsmmEPIIAJPrtqsFZ8h9yZ9z4zKyarT7
1TLdr5Pvd0j5JRtqE6ZlKrHNTNu5QON4vM7Nk/JXIb0kZGSjjMYevBzlWJxkqn7G
EM9EwmDwInRFgTnYiPG5/L/i0PZkeZn/8GIHZUHeRQ1MPhuy1t7fUmJ3ZXgQmrQp
imwg5ZKqF6HwHEb89nvxKCsqHEntUxP4uZaWcapWL7nKyDRtXjBuyWwNzceixlpo
c8cy944V2aXjjFQh4NStfEoxYHMgkcxyRAm9RWOt2v6PfV0l6SuYSaNsSgLWVhuv
GTsO6CX1gdqNpctEl8g3fkfihhN+eY7A+WBbyj+i//6kQb03xMZiy+CRmUfA31g=
=xKpy
-----END PGP SIGNATURE-----

From peter.tschipper at gmail.com  Tue Nov 10 16:17:40 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Tue, 10 Nov 2015 08:17:40 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
 Compression"
In-Reply-To: <5642172C.701@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
Message-ID: <564218A4.8070102@gmail.com>

On 10/11/2015 8:11 AM, Peter Tschipper wrote:
> On 10/11/2015 1:44 AM, Tier Nolan via bitcoin-dev wrote:
>> The network protocol is not quite consensus critical, but it is
>> important.
>>
>> Two implementations of the decompressor might not be bug for bug
>> compatible.  This (potentially) means that a block could be designed
>> that won't decode properly for some version of the client but would
>> work for another.  This would fork the network.
>>
>> A "raw" network library is unlikely to have the same problem.
>>
>> Rather than just compress the stream, you could compress only block
>> messages only.  A new "cblock" message could be created that is a
>> compressed block.  This shouldn't reduce efficiency by much.
>>
> I chose the more generic datastream compression so we could in the
> future apply to possibly to transactions but currently all that is
> planned, is to compress blocks, and that was really my only original
> intent until I saw that there might be some bandwidth savings for
> transactions as well. 
>
> The compression  however could be applied to any datastream but is not
> *forced* .  Basically it would just be a method call in CDatastream so
> we could do ss.compress and ss.decompress and apply that to blocks and
> possibly transactions if worthwhile and only IF compression is turned
> on.  But there is no intend to apply this to every type of message
> since most would be too small to benefit from compression.
>
> Here are some results of using the code in the PR to
> compress/decompress blocks using zlib compression level = 6.  This
> data was taken from the first 275K blocks in the mainnet blockchain. 
> Clearly once we get past 10KB we get pretty decent compression but
> even below that there is some benefit.  I'm still collecting data and
> will get the same for the whole blockchain.
>
> range = block size range
> ubytes = average size of uncompressed blocks
> cbytes = average size of compressed blocks
> ctime = average time to compress
> dtime = average time to decompress
> cmp_ratio% = compression ratio
> datapoints = number of datapoints taken
>
> range       ubytes    cbytes    ctime    dtime    cmp_ratio%    datapoints
> 0-250b      215         189    0.001    0.000    12.41            79498
> 250-500b    440         405    0.001    0.000    7.82            11903
> 500-1KB     762         702    0.001    0.000    7.83            10448
> 1KB-10KB    4166    3561    0.001    0.000    14.51            50572
> 10KB-100KB  40820    31597    0.005    0.001    22.59            75555
> 100KB-200KB 146238    106320    0.015    0.001    27.30            25024
> 200KB-300KB 242913    175482    0.025    0.002    27.76            20450
> 300KB-400KB 343430    251760    0.034    0.003    26.69            2069
> 400KB-500KB 457448    343495    0.045    0.004    24.91            1889
> 500KB-600KB 540736    424255    0.056    0.007    21.54            90
> 600KB-700KB 647851    506888    0.063    0.007    21.76            59
> 700KB-800KB 749513    586551    0.073    0.007    21.74            48
> 800KB-900KB 859439    652166    0.086    0.008    24.12            39
> 900KB-1MB   952333    725191    0.089    0.009    23.85            78
>
>> If a client fails to decode a cblock, then it can ask for the block
>> to be re-sent as a standard "block" message. 
> interesting idea.
>>
>> This means that it is a pure performance improvement.  If problems
>> occur, then the client can just switch back to uncompressed mode for
>> that block.
>>
>> You should look into the block relay system.  This gives a larger
>> improvement than simply compressing the stream.  The main benefit is
>> latency but it means that actual blocks don't have to be sent, so
>> gives a potential 50% compression ratio.  Normally, a node receives
>> all the transactions and then those transactions are included later
>> in the block.
>>
> There are better ways of sending new blocks, that's certainly true but
> for sending historical blocks and seding transactions I don't think
> so.  This PR is really designed to save bandwidth and not intended to
> be a huge performance improvement in terms of time spent sending.
>>
>> On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>     On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev
>>     <bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>      
>>
>>         I think 25% bandwidth savings is certainly considerable,
>>         especially for people running full nodes in countries like
>>         Australia where internet bandwidth is lower and there are
>>         data caps.
>>
>>
>>     ?This reinforces the idea that such trade-off decisions should be
>>     be local and negotiated between peers, not a required feature of
>>     the network P2P.?
>>      
>>
>>     -- 
>>     Johnathan Corgan
>>     Corgan Labs - SDR Training and Development Services
>>     http://corganlabs.com
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/a9fefde7/attachment.html>

From j at toom.im  Tue Nov 10 16:21:56 2015
From: j at toom.im (Jonathan Toomim)
Date: Tue, 10 Nov 2015 08:21:56 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <564218A4.8070102@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com> <564218A4.8070102@gmail.com>
Message-ID: <15009400-968C-47B4-98E8-53EA26B5B43C@toom.im>

Quick observation: block transmission would be compress-once, send-multiple-times, which makes the tradeoff a little better.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/2af4a58c/attachment.sig>

From tier.nolan at gmail.com  Tue Nov 10 16:30:57 2015
From: tier.nolan at gmail.com (Tier Nolan)
Date: Tue, 10 Nov 2015 16:30:57 +0000
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <5642172C.701@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
Message-ID: <CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>

On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper <peter.tschipper at gmail.com>
wrote:

> There are better ways of sending new blocks, that's certainly true but for
> sending historical blocks and seding transactions I don't think so.  This
> PR is really designed to save bandwidth and not intended to be a huge
> performance improvement in terms of time spent sending.
>

If the main point is for historical data, then sticking to just blocks is
the best plan.

Since small blocks don't compress well, you could define a "cblocks"
message that handles multiple blocks (just concatenate the block messages
as payload before compression).

The sending peer could combine blocks so that each cblock is compressing at
least 10kB of block data (or whatever is optimal).  It is probably worth
specifying a maximum size for network buffer reasons (either 1MB or 1 block
maximum).

Similarly, transactions could be combined together and compressed "ctxs".
The inv messages could be modified so that you can request groups of 10-20
transactions.  That would depend on how much of an improvement compressed
transactions would represent.

More generally, you could define a message which is a compressed message
holder.  That is probably to complex to be worth the effort though.



>
> On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via bitcoin-dev <
> <bitcoin-dev at lists.linuxfoundation.org>
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>
>>> I think 25% bandwidth savings is certainly considerable, especially for
>>> people running full nodes in countries like Australia where internet
>>> bandwidth is lower and there are data caps.
>>>
>>
>> ?This reinforces the idea that such trade-off decisions should be be
>> local and negotiated between peers, not a required feature of the network
>> P2P.?
>>
>>
>> --
>> Johnathan Corgan
>> Corgan Labs - SDR Training and Development Services
>> http://corganlabs.com
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> _______________________________________________
> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/77204283/attachment-0001.html>

From jgarzik at gmail.com  Tue Nov 10 16:46:15 2015
From: jgarzik at gmail.com (Jeff Garzik)
Date: Tue, 10 Nov 2015 11:46:15 -0500
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
Message-ID: <CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>

Comments:

1) cblock seems a reasonable way to extend the protocol.  Further wrapping
should probably be done at the stream level.

2) zlib has crappy security track record.

3) A fallback path to non-compressed is required, should compression fail
or crash.

4) Most blocks and transactions have runs of zeroes and/or highly common
bit-patterns, which contributes to useful compression even at smaller
sizes.  Peter Ts's most recent numbers bear this out.  zlib has a
dictionary (32K?) which works well with repeated patterns such as those you
see with concatenated runs of transactions.

5) LZO should provide much better compression, at a cost of CPU performance
and using a less-reviewed, less-field-tested library.





On Tue, Nov 10, 2015 at 11:30 AM, Tier Nolan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
>
> On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper <
> peter.tschipper at gmail.com> wrote:
>
>> There are better ways of sending new blocks, that's certainly true but
>> for sending historical blocks and seding transactions I don't think so.
>> This PR is really designed to save bandwidth and not intended to be a huge
>> performance improvement in terms of time spent sending.
>>
>
> If the main point is for historical data, then sticking to just blocks is
> the best plan.
>
> Since small blocks don't compress well, you could define a "cblocks"
> message that handles multiple blocks (just concatenate the block messages
> as payload before compression).
>
> The sending peer could combine blocks so that each cblock is compressing
> at least 10kB of block data (or whatever is optimal).  It is probably worth
> specifying a maximum size for network buffer reasons (either 1MB or 1 block
> maximum).
>
> Similarly, transactions could be combined together and compressed "ctxs".
> The inv messages could be modified so that you can request groups of 10-20
> transactions.  That would depend on how much of an improvement compressed
> transactions would represent.
>
> More generally, you could define a message which is a compressed message
> holder.  That is probably to complex to be worth the effort though.
>
>
>
>>
>> On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via bitcoin-dev <
>> <bitcoin-dev at lists.linuxfoundation.org>
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>
>>>> I think 25% bandwidth savings is certainly considerable, especially for
>>>> people running full nodes in countries like Australia where internet
>>>> bandwidth is lower and there are data caps.
>>>>
>>>
>>> ?This reinforces the idea that such trade-off decisions should be be
>>> local and negotiated between peers, not a required feature of the network
>>> P2P.?
>>>
>>>
>>> --
>>> Johnathan Corgan
>>> Corgan Labs - SDR Training and Development Services
>>> http://corganlabs.com
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/d0474410/attachment.html>

From peter.tschipper at gmail.com  Tue Nov 10 16:46:54 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Tue, 10 Nov 2015 08:46:54 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
 Compression"
In-Reply-To: <56421F1E.4050302@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<56421F1E.4050302@gmail.com>
Message-ID: <56421F7E.8070305@gmail.com>

On 10/11/2015 8:45 AM, Peter Tschipper wrote:
> On 10/11/2015 8:30 AM, Tier Nolan via bitcoin-dev wrote:
>>
>>
>> On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper
>> <peter.tschipper at gmail.com> wrote:
>>
>>     There are better ways of sending new blocks, that's certainly
>>     true but for sending historical blocks and seding transactions I
>>     don't think so.  This PR is really designed to save bandwidth and
>>     not intended to be a huge performance improvement in terms of
>>     time spent sending.
>>
>>
>> If the main point is for historical data, then sticking to just
>> blocks is the best plan.
>>
> at the beginning yes.
>> Since small blocks don't compress well, you could define a "cblocks"
>> message that handles multiple blocks (just concatenate the block
>> messages as payload before compression). 
>>
> Small block are rare these days (but plenty of historical block), but
> still they get a 10% compression, not bad and I think worthwhile and
> the time it takes to compress small blocks is less that a millisecond
> so no loss there in time.   But still you have a good point and
> something worthy of doing after getting compression to work.  I think
> it's wise to keep it simple at first and build on the success later.
>> The sending peer could combine blocks so that each cblock is
>> compressing at least 10kB of block data (or whatever is optimal).  It
>> is probably worth specifying a maximum size for network buffer
>> reasons (either 1MB or 1 block maximum).
> Good idea. Same answer as above.
>> Similarly, transactions could be combined together and compressed
>> "ctxs".  The inv messages could be modified so that you can request
>> groups of 10-20 transactions.  That would depend on how much of an
>> improvement compressed transactions would represent.
>>
> Good idea. Same answer as above.
>> More generally, you could define a message which is a compressed
>> message holder.  That is probably to complex to be worth the effort
>> though.
> That's actually pretty easy to do and part of the plan.  Sending a
> cmp_block rather than a block makes it all easier to implement.  It's
> just a matter of doing pnode->pushmessage("cmp_block",
> compressed_block); and handling the "cmp_block" command string at the
> other end.
>>
>>  
>>
>>>
>>>     On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via
>>>     bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>
>>>         On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev
>>>         <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>          
>>>
>>>             I think 25% bandwidth savings is certainly considerable,
>>>             especially for people running full nodes in countries
>>>             like Australia where internet bandwidth is lower and
>>>             there are data caps.
>>>
>>>
>>>         ? This reinforces the idea that such trade-off decisions
>>>         should be be local and negotiated between peers, not a
>>>         required feature of the network P2P.?
>>>          
>>>
>>>         -- 
>>>         Johnathan Corgan
>>>         Corgan Labs - SDR Training and Development Services
>>>         http://corganlabs.com
>>>
>>>         _______________________________________________
>>>         bitcoin-dev mailing list
>>>         bitcoin-dev at lists.linuxfoundation.org
>>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>>
>>>
>>>     _______________________________________________
>>>     bitcoin-dev mailing list
>>>     bitcoin-dev at lists.linuxfoundation.org
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/1aebeb1f/attachment-0001.html>

From peter.tschipper at gmail.com  Tue Nov 10 17:09:06 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Tue, 10 Nov 2015 09:09:06 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
 Compression"
In-Reply-To: <CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
Message-ID: <564224B2.9090903@gmail.com>

On 10/11/2015 8:46 AM, Jeff Garzik via bitcoin-dev wrote:
> Comments:
>
> 1) cblock seems a reasonable way to extend the protocol.  Further
> wrapping should probably be done at the stream level.
agreed.
>
> 2) zlib has crappy security track record.
>
Zlib had a bad buffer overflow bug but that was in 2005 and it got a lot
of press at the time.  It's was fixed in version 1.2.3...we're on 1.2.8
now.  I'm not aware of any other current issues with zlib. Do you have a
citation?

> 3) A fallback path to non-compressed is required, should compression
> fail or crash.
agreed.
>
> 4) Most blocks and transactions have runs of zeroes and/or highly
> common bit-patterns, which contributes to useful compression even at
> smaller sizes.  Peter Ts's most recent numbers bear this out.  zlib
> has a dictionary (32K?) which works well with repeated patterns such
> as those you see with concatenated runs of transactions.
>
> 5) LZO should provide much better compression, at a cost of CPU
> performance and using a less-reviewed, less-field-tested library.
I don't think LZO will give as good compression here but I will do some
benchmarking when I can.

>
>
>
>
>
> On Tue, Nov 10, 2015 at 11:30 AM, Tier Nolan via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>
>
>     On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper
>     <peter.tschipper at gmail.com <mailto:peter.tschipper at gmail.com>> wrote:
>
>         There are better ways of sending new blocks, that's certainly
>         true but for sending historical blocks and seding transactions
>         I don't think so.  This PR is really designed to save
>         bandwidth and not intended to be a huge performance
>         improvement in terms of time spent sending.
>
>
>     If the main point is for historical data, then sticking to just
>     blocks is the best plan.
>
>     Since small blocks don't compress well, you could define a
>     "cblocks" message that handles multiple blocks (just concatenate
>     the block messages as payload before compression). 
>
>     The sending peer could combine blocks so that each cblock is
>     compressing at least 10kB of block data (or whatever is optimal). 
>     It is probably worth specifying a maximum size for network buffer
>     reasons (either 1MB or 1 block maximum).
>
>     Similarly, transactions could be combined together and compressed
>     "ctxs".  The inv messages could be modified so that you can
>     request groups of 10-20 transactions.  That would depend on how
>     much of an improvement compressed transactions would represent.
>
>     More generally, you could define a message which is a compressed
>     message holder.  That is probably to complex to be worth the
>     effort though.
>
>      
>
>>
>>         On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via
>>         bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>             On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev
>>             <bitcoin-dev at lists.linuxfoundation.org
>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>              
>>
>>                 I think 25% bandwidth savings is certainly
>>                 considerable, especially for people running full
>>                 nodes in countries like Australia where internet
>>                 bandwidth is lower and there are data caps.
>>
>>
>>             ? This reinforces the idea that such trade-off decisions
>>             should be be local and negotiated between peers, not a
>>             required feature of the network P2P.?
>>              
>>
>>             -- 
>>             Johnathan Corgan
>>             Corgan Labs - SDR Training and Development Services
>>             http://corganlabs.com
>>
>>             _______________________________________________
>>             bitcoin-dev mailing list
>>             bitcoin-dev at lists.linuxfoundation.org
>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>>         _______________________________________________
>>         bitcoin-dev mailing list
>>         bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/1688b581/attachment.html>

From david.vorick at gmail.com  Tue Nov 10 20:37:21 2015
From: david.vorick at gmail.com (David Vorick)
Date: Tue, 10 Nov 2015 15:37:21 -0500
Subject: [bitcoin-dev] Proposal - Mandatory Weak Blocks
Message-ID: <CAFVRnyoFgZmwU9DRkaStcAo=K3Txv4PbG=jM5EK5_vUT7YrGCg@mail.gmail.com>

Prior discussion: http://gnusha.org/bitcoin-wizards/2015-11-09.log

Goal: Increase transaction throughput without increasing miner
centralization pressure, and without putting undue burden on full
validating nodes.

'Weak Block': a block which meets a target with a lower difficulty,
typically some fraction such as 5%.

'Strong Block': a block that meets the full target. Also called a block.

---

Introduction:

One of the key sources of miner centralization is the orphan rate. Miners
with 33% hash power are guaranteed to instantly validate 33% of the blocks,
while miners with only 1% hashrate only get this advantage for 1% of the
blocks. If the average orphan rate on the network is high, miners with
significantly more hashpower will have a substantial advantage over smaller
miners.

One of the strongest reasons to keep the block size small is to keep the
orphan rate low. This is to protect smaller miners. Numerous pre-consensus
schemes have been discussed which attempt to drive the orphan rate down.
When considering these schemes, the adversarial case must be considered as
well as the average case.

The circulation of weak blocks has been discussed as a form of
preconsensus. Upon finding a weak block, miners circulate the block to the
other miners, and then when a full block is found, a diff between the weak
block and full block can be circulated instead of just the full block. This
diff is both quicker to validate and quicker to circulate, resulting in
substantially improved block propagation times and a reduced orphan rate,
thus reduced miner centralization pressure.

The adversarial case is not addressed by this scheme. It is still possible
to find and circulate a large, difficult-to-verify block that slowly
propagates through the network and drives up the orphan rate for smaller
miners. A new construction (below) introduces a set of new consensus rules
which protect small miners even from the adversarial case.

---

Construction:

After a block is found, pre-consensus for the next block begins.
Pre-consensus consists of building a chain of weak blocks which meet a
target that has 5% the difficulty of a full block. Each weak block can
introduce at most 200kb of new transactions to the weak-block chain. On
average, a new weak block will appear every 30 seconds. When the next
strong block is found, it must be at the head of a weak block chain and it
must itself introduce a maximum of 200kb in transactions new to the
weak-block chain. The maximum size of a strong block is 16mb, but can be
composed of any number of weak blocks.

Example:

[strong block] -> [weak block - 200kb] -> [weak block - 400kb] -> [strong
block - 600kb] -> [weak block - 200kb]...

---

Analysis:

On average, weak blocks will be found every 30 seconds and each block will
build on top of 20 weak blocks. The average block size will be 4mb. 80 weak
blocks are required to construct a block of the maximum size of 16mb, which
will probably happen 3 out of every 1000 blocks. The race-size for blocks
is kept low, and as explained later, adversarial mining is inherently
decentivized.

This construction establishes a 'pre-consensus' that allows miners to do
faster validation when a new block is found. Assuming that the miner has
seen most of the precursor weak blocks, only a few hundred kilobytes of
validation must be performed even when the blocks are multiple megabytes in
size. In the usual case, only 100kb of validation needs to be performed.

More consistent transaction throughput is achieved. Strong blocks that are
found in rapid succession are likely to each be small, due to having a
small number of weak blocks that they build on top of. Strong blocks that
are found a long time after the previous strong block are likely to have
many weak blocks that they build on top of.

Better censorship resistance is achieved. Creating large blocks requires
building on top of weak blocks. A miner actively trying to censor certain
transactions will have to ignore all weak-block chains that contain the
offensive transaction, and thus will be at a disadvantage due to
consistently producing smaller (and less fee-rich) blocks.

An attacker that is trying to flood the network with intentionally
slow-validating blocks can no longer easily construct blocks at the maximum
size, and instead must create and hide weak blocks which build up to a
strong block that has many unseen transactions. Hiding weak blocks has an
opportunity cost, because in building a chain of weak block is exclusive to
the attacker, the attacker is missing out on the opportunity of building on
top of the other weak blocks being produced.

Compared to Bitcoin-NG, this construction lacks the vulnerability where a
single, more easily-targeted leader is elected and placed in charge of the
next round of consensus.

Everyone has incentive to build on top of the most recent weak block. In
the event that the next weak block discovered is also a strong block, the
fees reaped by the miner will be maximized.

Larger miners appear to have an incentive to withhold weak blocks in an
attempt to drive smaller miners off of the network. Large miners
withholding weak blocks will gain an advantage that amounts to (% chance of
finding a weak block) * (% chance of finding the full block) * (average fee
addition of a weak block) / (average total block reward). Assuming that
fees make up entire block reward, the advantage for a miner performing a
withholding attack is (hashrate^2 * weak block difficulty). For a 50%
miner, that advantage comes to 1.25%. For a 20% miner, this advantage is
just 0.2%. There are probably multiple ways to decentivize this behavior,
the simplest of which involves directly rewarding miners for announcing
weak blocks.

The orphan rate for weak blocks is going to be substantially higher for
smaller miner, due to the increased rate of appearance. I do not think that
this is going to create any issues, because small miners are still going to
have high visibility of the longest weak-block chain, and are still going
to be able to create blocks that are nearly as full as the blocks created
by larger miners.

The more time that passes between mining blocks, the more a block is worth
(because it will have more weak-blocks, and therefore more transactions).
Hashrate is therefore more valuable when a block has not been found for a
while, and may result in hashrate hopping, where hashrate is disabled or
clocked-down immediately after a block is found and then clocked-up if a
block is not found for a while. This is only a problem while fees from new
transactions make up a significant portion of the block reward.

---

Conclusion:

A forced-weak-blocks scheme potentially provides a powerful way to reduce
the orphan rate, increasing the safety margins on miner centralization
pressure and allowing the overall transaction throughput to be increased as
a result.

Additional analysis is needed to be certain that there are not new attack
vectors or mal-aligned incentives that have been introduced.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151110/cb13678f/attachment-0001.html>

From peter.tschipper at gmail.com  Wed Nov 11 18:35:01 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Wed, 11 Nov 2015 10:35:01 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
 Compression"
In-Reply-To: <CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
Message-ID: <56438A55.2010604@gmail.com>

Here are the latest results on compression ratios for the first 295,000
blocks, compressionlevel=6.  I think there are more than enough
datapoints for statistical significance. 

Results are very much similar to the previous test.   I'll work on
getting a comparison between how much time savings/loss in time there is
when syncing the blockchains: compressed vs uncompressed.  Still, I
think it's clear that serving up compressed blocks, at least historical
blocks, will be of benefit for those that have bandwidth caps on their
internet connections.

The proposal, so far is fairly simple:
1) compress blocks with some compression library: currently zlib but I
can investigate other possiblities
2) As a fall back we need to advertise compression as a service.  That
way we can turn off compression AND decompression completely if needed.
3) Do the compression at the datastream level in the code.  CDataStream
is the obvious place.


Test Results:

range = block size range
ubytes = average size of uncompressed blocks
cbytes = average size of compressed blocks
ctime = average time to compress
dtime = average time to decompress
cmp_ratio% = compression ratio
datapoints = number of datapoints taken

range       ubytes    cbytes    ctime    dtime    cmp_ratio%    datapoints
0-250b      215            189    0.001    0.000    12.40             91280
250-500b    438            404    0.001    0.000    7.85             13217
500-1KB     761            701    0.001    0.000    7.86               11434
1KB-10KB    4149    3547    0.001    0.000      14.51             52180
10KB-100KB  41934    32604    0.005    0.001    22.25         82890
100KB-200KB 146303    108080    0.016    0.001    26.13    29886
200KB-300KB 243299    179281    0.025    0.002    26.31    25066
300KB-400KB 344636    266177    0.036    0.003    22.77    4956
400KB-500KB 463201    356862    0.046    0.004    22.96    3167
500KB-600KB 545123    429854    0.056    0.005    21.15    366
600KB-700KB 647736    510931    0.065    0.006    21.12    254
700KB-800KB 746540    587287    0.073    0.008    21.33    294
800KB-900KB 868121    682650    0.087    0.008    21.36    199
900KB-1MB   945747    726307    0.091    0.010    23.20    304

On 10/11/2015 8:46 AM, Jeff Garzik via bitcoin-dev wrote:
> Comments:
>
> 1) cblock seems a reasonable way to extend the protocol.  Further
> wrapping should probably be done at the stream level.
>
> 2) zlib has crappy security track record.
>
> 3) A fallback path to non-compressed is required, should compression
> fail or crash.
>
> 4) Most blocks and transactions have runs of zeroes and/or highly
> common bit-patterns, which contributes to useful compression even at
> smaller sizes.  Peter Ts's most recent numbers bear this out.  zlib
> has a dictionary (32K?) which works well with repeated patterns such
> as those you see with concatenated runs of transactions.
>
> 5) LZO should provide much better compression, at a cost of CPU
> performance and using a less-reviewed, less-field-tested library.
>
>
>
>
>
> On Tue, Nov 10, 2015 at 11:30 AM, Tier Nolan via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>
>
>     On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper
>     <peter.tschipper at gmail.com <mailto:peter.tschipper at gmail.com>> wrote:
>
>         There are better ways of sending new blocks, that's certainly
>         true but for sending historical blocks and seding transactions
>         I don't think so.  This PR is really designed to save
>         bandwidth and not intended to be a huge performance
>         improvement in terms of time spent sending.
>
>
>     If the main point is for historical data, then sticking to just
>     blocks is the best plan.
>
>     Since small blocks don't compress well, you could define a
>     "cblocks" message that handles multiple blocks (just concatenate
>     the block messages as payload before compression). 
>
>     The sending peer could combine blocks so that each cblock is
>     compressing at least 10kB of block data (or whatever is optimal). 
>     It is probably worth specifying a maximum size for network buffer
>     reasons (either 1MB or 1 block maximum).
>
>     Similarly, transactions could be combined together and compressed
>     "ctxs".  The inv messages could be modified so that you can
>     request groups of 10-20 transactions.  That would depend on how
>     much of an improvement compressed transactions would represent.
>
>     More generally, you could define a message which is a compressed
>     message holder.  That is probably to complex to be worth the
>     effort though.
>
>      
>
>>
>>         On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via
>>         bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>             On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev
>>             <bitcoin-dev at lists.linuxfoundation.org
>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>              
>>
>>                 I think 25% bandwidth savings is certainly
>>                 considerable, especially for people running full
>>                 nodes in countries like Australia where internet
>>                 bandwidth is lower and there are data caps.
>>
>>
>>             ? This reinforces the idea that such trade-off decisions
>>             should be be local and negotiated between peers, not a
>>             required feature of the network P2P.?
>>              
>>
>>             -- 
>>             Johnathan Corgan
>>             Corgan Labs - SDR Training and Development Services
>>             http://corganlabs.com
>>
>>             _______________________________________________
>>             bitcoin-dev mailing list
>>             bitcoin-dev at lists.linuxfoundation.org
>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>>         _______________________________________________
>>         bitcoin-dev mailing list
>>         bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151111/b008e0c1/attachment.html>

From marcopon at gmail.com  Wed Nov 11 18:49:49 2015
From: marcopon at gmail.com (Marco Pontello)
Date: Wed, 11 Nov 2015 19:49:49 +0100
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <56438A55.2010604@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<56438A55.2010604@gmail.com>
Message-ID: <CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>

A random thought: aren't most communication over a data link already
compressed, at some point?
When I used a modem, we had the V.42bis protocol. Now, nearly all ADSL
connections using PPPoE, surely are. And so on.
I'm not sure another level of generic, data agnostic kind of compression
will really give us some real-life practical advantage over that.

Something that could take advantage of of special knowledge of the specific
data, instead, would be an entirely different matter.

Just my 2c.

On Wed, Nov 11, 2015 at 7:35 PM, Peter Tschipper via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Here are the latest results on compression ratios for the first 295,000
> blocks, compressionlevel=6.  I think there are more than enough datapoints
> for statistical significance.
>
> Results are very much similar to the previous test.   I'll work on getting
> a comparison between how much time savings/loss in time there is when
> syncing the blockchains: compressed vs uncompressed.  Still, I think it's
> clear that serving up compressed blocks, at least historical blocks, will
> be of benefit for those that have bandwidth caps on their internet
> connections.
>
> The proposal, so far is fairly simple:
> 1) compress blocks with some compression library: currently zlib but I can
> investigate other possiblities
> 2) As a fall back we need to advertise compression as a service.  That way
> we can turn off compression AND decompression completely if needed.
> 3) Do the compression at the datastream level in the code.  CDataStream is
> the obvious place.
>
>
> Test Results:
>
> range = block size range
> ubytes = average size of uncompressed blocks
> cbytes = average size of compressed blocks
> ctime = average time to compress
> dtime = average time to decompress
> cmp_ratio% = compression ratio
> datapoints = number of datapoints taken
>
> range       ubytes    cbytes    ctime    dtime    cmp_ratio%    datapoints
> 0-250b      215            189    0.001    0.000    12.40             91280
> 250-500b    438            404    0.001    0.000    7.85             13217
> 500-1KB     761            701    0.001    0.000    7.86
> 11434
> 1KB-10KB    4149    3547    0.001    0.000      14.51             52180
> 10KB-100KB  41934    32604    0.005    0.001    22.25         82890
> 100KB-200KB 146303    108080    0.016    0.001    26.13    29886
> 200KB-300KB 243299    179281    0.025    0.002    26.31    25066
> 300KB-400KB 344636    266177    0.036    0.003    22.77    4956
> 400KB-500KB 463201    356862    0.046    0.004    22.96    3167
> 500KB-600KB 545123    429854    0.056    0.005    21.15    366
> 600KB-700KB 647736    510931    0.065    0.006    21.12    254
> 700KB-800KB 746540    587287    0.073    0.008    21.33    294
> 800KB-900KB 868121    682650    0.087    0.008    21.36    199
> 900KB-1MB   945747    726307    0.091    0.010    23.20    304
>
> On 10/11/2015 8:46 AM, Jeff Garzik via bitcoin-dev wrote:
>
> Comments:
>
> 1) cblock seems a reasonable way to extend the protocol.  Further wrapping
> should probably be done at the stream level.
>
> 2) zlib has crappy security track record.
>
> 3) A fallback path to non-compressed is required, should compression fail
> or crash.
>
> 4) Most blocks and transactions have runs of zeroes and/or highly common
> bit-patterns, which contributes to useful compression even at smaller
> sizes.  Peter Ts's most recent numbers bear this out.  zlib has a
> dictionary (32K?) which works well with repeated patterns such as those you
> see with concatenated runs of transactions.
>
> 5) LZO should provide much better compression, at a cost of CPU
> performance and using a less-reviewed, less-field-tested library.
>
>
>
>
>
> On Tue, Nov 10, 2015 at 11:30 AM, Tier Nolan via bitcoin-dev <
> <bitcoin-dev at lists.linuxfoundation.org>
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>>
>>
>> On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper <
>> <peter.tschipper at gmail.com>peter.tschipper at gmail.com> wrote:
>>
>>> There are better ways of sending new blocks, that's certainly true but
>>> for sending historical blocks and seding transactions I don't think so.
>>> This PR is really designed to save bandwidth and not intended to be a huge
>>> performance improvement in terms of time spent sending.
>>>
>>
>> If the main point is for historical data, then sticking to just blocks is
>> the best plan.
>>
>> Since small blocks don't compress well, you could define a "cblocks"
>> message that handles multiple blocks (just concatenate the block messages
>> as payload before compression).
>>
>> The sending peer could combine blocks so that each cblock is compressing
>> at least 10kB of block data (or whatever is optimal).  It is probably worth
>> specifying a maximum size for network buffer reasons (either 1MB or 1 block
>> maximum).
>>
>> Similarly, transactions could be combined together and compressed
>> "ctxs".  The inv messages could be modified so that you can request groups
>> of 10-20 transactions.  That would depend on how much of an improvement
>> compressed transactions would represent.
>>
>> More generally, you could define a message which is a compressed message
>> holder.  That is probably to complex to be worth the effort though.
>>
>>
>>
>>>
>>> On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via bitcoin-dev <
>>> <bitcoin-dev at lists.linuxfoundation.org>
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev <
>>>> <bitcoin-dev at lists.linuxfoundation.org>
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>
>>>>> I think 25% bandwidth savings is certainly considerable, especially
>>>>> for people running full nodes in countries like Australia where internet
>>>>> bandwidth is lower and there are data caps.
>>>>>
>>>>
>>>> ? This reinforces the idea that such trade-off decisions should be be
>>>> local and negotiated between peers, not a required feature of the network
>>>> P2P.?
>>>>
>>>>
>>>> --
>>>> Johnathan Corgan
>>>> Corgan Labs - SDR Training and Development Services
>>>> <http://corganlabs.com>http://corganlabs.com
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>>
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> _______________________________________________
> bitcoin-dev mailing listbitcoin-dev at lists.linuxfoundation.orghttps://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Try the Online TrID File Identifier
http://mark0.net/onlinetrid.aspx
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151111/0430cab2/attachment-0001.html>

From j at toom.im  Wed Nov 11 19:05:29 2015
From: j at toom.im (Jonathan Toomim)
Date: Wed, 11 Nov 2015 11:05:29 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
	Compression"
In-Reply-To: <CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<56438A55.2010604@gmail.com>
	<CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>
Message-ID: <27BB52F9-3E3F-443D-93BC-B6843EB992F5@toom.im>

Data compression adds latency and reduces predictability, so engineers have decided to leave compression to application layers instead of transport layer or lower in order to let the application designer decide what tradeoffs to make.

On Nov 11, 2015, at 10:49 AM, Marco Pontello via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> A random thought: aren't most communication over a data link already compressed, at some point?
> When I used a modem, we had the V.42bis protocol. Now, nearly all ADSL connections using PPPoE, surely are. And so on.
> I'm not sure another level of generic, data agnostic kind of compression will really give us some real-life practical advantage over that.
> 
> Something that could take advantage of of special knowledge of the specific data, instead, would be an entirely different matter.
> 
> Just my 2c.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151111/a0171c49/attachment.sig>

From peter.tschipper at gmail.com  Wed Nov 11 19:11:13 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Wed, 11 Nov 2015 11:11:13 -0800
Subject: [bitcoin-dev] request BIP number for: "Support for Datastream
 Compression"
In-Reply-To: <CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<56438A55.2010604@gmail.com>
	<CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>
Message-ID: <564392D1.5060100@gmail.com>

If that were true then we wouldn't need to gzip large files before
sending them over the internet.  Data compression generally helps
transmission speed as long as the amount of compression is high enough
and the time it takes is low enough to make it worthwhile.  On a
corporate LAN it's generally not worthwhile unless you're dealing with
very large files, but over a corporate WAN or the internet where network
latency can be high it is IMO a worthwhile endevor.



On 11/11/2015 10:49 AM, Marco Pontello wrote:
> A random thought: aren't most communication over a data link already
> compressed, at some point?
> When I used a modem, we had the V.42bis protocol. Now, nearly all ADSL
> connections using PPPoE, surely are. And so on.
> I'm not sure another level of generic, data agnostic kind of
> compression will really give us some real-life practical advantage
> over that.
>
> Something that could take advantage of of special knowledge of the
> specific data, instead, would be an entirely different matter.
>
> Just my 2c.
>
> On Wed, Nov 11, 2015 at 7:35 PM, Peter Tschipper via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>     Here are the latest results on compression ratios for the first
>     295,000 blocks, compressionlevel=6.  I think there are more than
>     enough datapoints for statistical significance. 
>
>     Results are very much similar to the previous test.   I'll work on
>     getting a comparison between how much time savings/loss in time
>     there is when syncing the blockchains: compressed vs
>     uncompressed.  Still, I think it's clear that serving up
>     compressed blocks, at least historical blocks, will be of benefit
>     for those that have bandwidth caps on their internet connections.
>
>     The proposal, so far is fairly simple:
>     1) compress blocks with some compression library: currently zlib
>     but I can investigate other possiblities
>     2) As a fall back we need to advertise compression as a service. 
>     That way we can turn off compression AND decompression completely
>     if needed.
>     3) Do the compression at the datastream level in the code. 
>     CDataStream is the obvious place.
>
>
>     Test Results:
>
>     range = block size range
>     ubytes = average size of uncompressed blocks
>     cbytes = average size of compressed blocks
>     ctime = average time to compress
>     dtime = average time to decompress
>     cmp_ratio% = compression ratio
>     datapoints = number of datapoints taken
>
>     range       ubytes    cbytes    ctime    dtime    cmp_ratio%   
>     datapoints
>     0-250b      215            189    0.001    0.000    12.40        
>         91280
>     250-500b    438            404    0.001    0.000    7.85          
>       13217
>     500-1KB     761            701    0.001    0.000   
>     7.86               11434
>     1KB-10KB    4149    3547    0.001    0.000      14.51            
>     52180
>     10KB-100KB  41934    32604    0.005    0.001    22.25         82890
>     100KB-200KB 146303    108080    0.016    0.001    26.13    29886
>     200KB-300KB 243299    179281    0.025    0.002    26.31    25066
>     300KB-400KB 344636    266177    0.036    0.003    22.77    4956
>     400KB-500KB 463201    356862    0.046    0.004    22.96    3167
>     500KB-600KB 545123    429854    0.056    0.005    21.15    366
>     600KB-700KB 647736    510931    0.065    0.006    21.12    254
>     700KB-800KB 746540    587287    0.073    0.008    21.33    294
>     800KB-900KB 868121    682650    0.087    0.008    21.36    199
>     900KB-1MB   945747    726307    0.091    0.010    23.20    304
>
>     On 10/11/2015 8:46 AM, Jeff Garzik via bitcoin-dev wrote:
>>     Comments:
>>
>>     1) cblock seems a reasonable way to extend the protocol.  Further
>>     wrapping should probably be done at the stream level.
>>
>>     2) zlib has crappy security track record.
>>
>>     3) A fallback path to non-compressed is required, should
>>     compression fail or crash.
>>
>>     4) Most blocks and transactions have runs of zeroes and/or highly
>>     common bit-patterns, which contributes to useful compression even
>>     at smaller sizes.  Peter Ts's most recent numbers bear this out.
>>      zlib has a dictionary (32K?) which works well with repeated
>>     patterns such as those you see with concatenated runs of
>>     transactions.
>>
>>     5) LZO should provide much better compression, at a cost of CPU
>>     performance and using a less-reviewed, less-field-tested library.
>>
>>
>>
>>
>>
>>     On Tue, Nov 10, 2015 at 11:30 AM, Tier Nolan via bitcoin-dev
>>     <bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>
>>
>>         On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper
>>         <peter.tschipper at gmail.com
>>         <mailto:peter.tschipper at gmail.com>> wrote:
>>
>>             There are better ways of sending new blocks, that's
>>             certainly true but for sending historical blocks and
>>             seding transactions I don't think so.  This PR is really
>>             designed to save bandwidth and not intended to be a huge
>>             performance improvement in terms of time spent sending.
>>
>>
>>         If the main point is for historical data, then sticking to
>>         just blocks is the best plan.
>>
>>         Since small blocks don't compress well, you could define a
>>         "cblocks" message that handles multiple blocks (just
>>         concatenate the block messages as payload before compression). 
>>
>>         The sending peer could combine blocks so that each cblock is
>>         compressing at least 10kB of block data (or whatever is
>>         optimal).  It is probably worth specifying a maximum size for
>>         network buffer reasons (either 1MB or 1 block maximum).
>>
>>         Similarly, transactions could be combined together and
>>         compressed "ctxs".  The inv messages could be modified so
>>         that you can request groups of 10-20 transactions.  That
>>         would depend on how much of an improvement compressed
>>         transactions would represent.
>>
>>         More generally, you could define a message which is a
>>         compressed message holder.  That is probably to complex to be
>>         worth the effort though.
>>
>>          
>>
>>>
>>>             On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via
>>>             bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>
>>>                 On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via
>>>                 bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>>                 <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>>                  
>>>
>>>                     I think 25% bandwidth savings is certainly
>>>                     considerable, especially for people running full
>>>                     nodes in countries like Australia where internet
>>>                     bandwidth is lower and there are data caps.
>>>
>>>
>>>                 ? This reinforces the idea that such trade-off
>>>                 decisions should be be local and negotiated between
>>>                 peers, not a required feature of the network P2P.?
>>>                  
>>>
>>>                 -- 
>>>                 Johnathan Corgan
>>>                 Corgan Labs - SDR Training and Development Services
>>>                 http://corganlabs.com
>>>
>>>                 _______________________________________________
>>>                 bitcoin-dev mailing list
>>>                 bitcoin-dev at lists.linuxfoundation.org
>>>                 <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>                 https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>>
>>>
>>>             _______________________________________________
>>>             bitcoin-dev mailing list
>>>             bitcoin-dev at lists.linuxfoundation.org
>>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>         _______________________________________________
>>         bitcoin-dev mailing list
>>         bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
> -- 
> Try the Online TrID File Identifier
> http://mark0.net/onlinetrid.aspx

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151111/89fce255/attachment-0001.html>

From lists at coryfields.com  Thu Nov 12 18:16:03 2015
From: lists at coryfields.com (Cory Fields)
Date: Thu, 12 Nov 2015 13:16:03 -0500
Subject: [bitcoin-dev] Post-conference hacking in Hong Kong
Message-ID: <CAApLimhe=fhioZ9nQ2EcTrr3+gx-JsMo++1zupGvvxUcmXAQ9Q@mail.gmail.com>

Hi all

As some of you may recall, I tried to throw together a small
code-sprint after the Scaling Bitcoin event in Montreal. There were
several problems stemming from the last-minute-ness and some confusion
about the scope and goals, but I think it was a good thing overall.
Most importantly, it pointed out that many devs are interested in
face-time for technical/code discussions.

For those of you attending the Hong Kong conference next month, I'd
like to invite you to stay an extra day or two and join in on some
in-person hacking, code-review, and technical discussion.

If there was one take-away from the Montreal sprint, it was this:
trying to stick to a pre-defined set of goals with so many people is
counter-productive. The plan was to review a few long-standing Bitcoin
Core pull-requests in-person in order to knock them out quickly, but I
think it was the organic tangents and ad-hoc discussions that proved
to be more interesting. So let's encourage that!

The plan:

Thanks to Pindar and Cyberport, we have two rooms available the two
days after the conference. These will be treated as general meeting
rooms for technical discussion; anything goes as long as it's
technical and Bitcoin-related. Personally, I'll be bringing my laptop
and demoing some recent code to others who might be interested (or
anyone who will listen!). It's also a great opportunity for nascent
devs to ask veterans questions questions about development processes,
hard-to-understand code, etc. Miners are encouraged to come as well,
for discussing any technical hurdles or questions that may benefit
from some real-time technical discussion or debugging.

Attendees are encouraged to self-organize and huddle up as necessary.
Topics are by no means limited to Bitcoin Core, so feel free to
discuss/learn about projects outside of your usual bubble. If you find
yourself saying "I'd like to look at that code with you later" at the
conference, plan a time to meet and do it! While this isn't associated
with Scaling Bitcoin or its organizers, it's obviously meant to
piggy-back off of the event. If it becomes too chaotic, we may throw
together a sign-up sheet, but the intent is to let things happen
organically.

What it's not:

This is a venue for technical discussion. It should not be treated as
a place for discussing politics, agendas, plans for world domination,
etc. Let your code speak for you!


The location:
Video Conferencing Rooms 2 and 3, Level 3, Core C
Cyberport 3
100 Cyberport Rd,
Telegraph Bay,
Hong Kong

Room 2 seats 20 people around a conference table, room 3 seats 12.

The time:
Tuesday December 8 at 8:00am - Wednesday December 9 at midnight.

Extras:
Coffee/tea/water will be provided, but food is not arranged. Likely
some herds will form and venture out for food, but we can also order
in. Wifi/whiteboards provided as well.

See you all in Hong Kong!

Cory

From lf-lists at mattcorallo.com  Thu Nov 12 19:47:50 2015
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 12 Nov 2015 19:47:50 +0000
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
Message-ID: <5644ECE6.9090304@mattcorallo.com>

On the IRC meeting today there was a long discussion on how to handle
the old "transaction priority" stuff in 0.12. Over time the "transaction
priority" stuff has added a huge amount of code and taken a bunch of
otherwise-useful developer effort. There is still some debate about its
usefulness going forward, but there was general agreement that it will
either be removed entirely or replaced with something a bit less costly
to maintain some time around 0.13.

With the mempool limiting stuff already in git master, high-priority
relay is disabled when mempools are full. In addition, there was
agreement to take the following steps for 0.12:

 * Mining code will use starting priority for ease of implementation
 * Default block priority size will be 0
 * Wallet will no longer create 0-fee transactions when mempool limiting
is in effect.

What this means for you is, essentially, be more careful when relying on
priority to mine your transactions. If mempools are full, your
transactions will be increasingly less likely to be relayed and more
miners may start disabling high-priority block space. Make sure you
analyze previous blocks to determine if high-priority mining is still
enabled and ensure your transactions will be relayed.

Matt

From luke at dashjr.org  Thu Nov 12 20:12:28 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 12 Nov 2015 20:12:28 +0000
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <5644ECE6.9090304@mattcorallo.com>
References: <5644ECE6.9090304@mattcorallo.com>
Message-ID: <201511122012.29966.luke@dashjr.org>

On Thursday, November 12, 2015 7:47:50 PM Matt Corallo via bitcoin-dev wrote:
> With the mempool limiting stuff already in git master, high-priority
> relay is disabled when mempools are full. In addition, there was
> agreement to take the following steps for 0.12:
> 
>  * Mining code will use starting priority for ease of implementation

This should be optional, at least for 0.12.

>  * Default block priority size will be 0

We should not be influencing miner policy by changing defaults.

Luke

From 1240902 at gmail.com  Thu Nov 12 20:20:45 2015
From: 1240902 at gmail.com (Chun Wang)
Date: Fri, 13 Nov 2015 04:20:45 +0800
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <201511122012.29966.luke@dashjr.org>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122012.29966.luke@dashjr.org>
Message-ID: <CAFzgq-xZA7VApQJv-b9n12H+GmL7u4Qv_481UsHWNqXGn6NubA@mail.gmail.com>

I doubt changing the default value is useful as casual mining had long
dead, and pools all have their own customized policies. But I think
change the priority size to 0 is the right way to do. The sort by
priority part in the block is always the best place for spam nowadays.
I would think about to merge the priority, feerate, and probably
sigoprate into one number, probably 576 priorities trade for 1 satoshi
per kb?

On Fri, Nov 13, 2015 at 4:12 AM, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Thursday, November 12, 2015 7:47:50 PM Matt Corallo via bitcoin-dev wrote:
>> With the mempool limiting stuff already in git master, high-priority
>> relay is disabled when mempools are full. In addition, there was
>> agreement to take the following steps for 0.12:
>>
>>  * Mining code will use starting priority for ease of implementation
>
> This should be optional, at least for 0.12.
>
>>  * Default block priority size will be 0
>
> We should not be influencing miner policy by changing defaults.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From luke at dashjr.org  Thu Nov 12 20:25:23 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 12 Nov 2015 20:25:23 +0000
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <CAFzgq-xZA7VApQJv-b9n12H+GmL7u4Qv_481UsHWNqXGn6NubA@mail.gmail.com>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122012.29966.luke@dashjr.org>
	<CAFzgq-xZA7VApQJv-b9n12H+GmL7u4Qv_481UsHWNqXGn6NubA@mail.gmail.com>
Message-ID: <201511122025.24518.luke@dashjr.org>

On Thursday, November 12, 2015 8:20:45 PM Chun Wang wrote:
> The sort by priority part in the block is always the best place for spam
> nowadays.

What are you saying here? Spammers generally can't use the priority space at 
all, and it is a major way for legitimate users to get their transactions 
mined cheaply despite ongoing spam attempts. You're suggesting the exact 
opposite is true?? Please explain.

Luke

From james.hilliard1 at gmail.com  Thu Nov 12 20:35:05 2015
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Thu, 12 Nov 2015 14:35:05 -0600
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <201511122025.24518.luke@dashjr.org>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122012.29966.luke@dashjr.org>
	<CAFzgq-xZA7VApQJv-b9n12H+GmL7u4Qv_481UsHWNqXGn6NubA@mail.gmail.com>
	<201511122025.24518.luke@dashjr.org>
Message-ID: <CADvTj4r6JD=_0KHNcDPzEeDpUtdyCX2kHq2CnzbEqo8DBfwZjA@mail.gmail.com>

The priority space is causing major mempool bloating and GBT latency right
now since many of the free transactions aren't getting mined and cleared
out of the mempool anymore. From my testing setting minrelaytxfee=0.0001 is
not enough to prevent the mempool from getting large during a spam attack,
it is also necessary to set limitfreerelay=0 in order to prevent GBT
latency degradation. Without setting limitfreerelay=0 GBT degrades
significantly for every hour bitcoind is running.

On Thu, Nov 12, 2015 at 2:25 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thursday, November 12, 2015 8:20:45 PM Chun Wang wrote:
> > The sort by priority part in the block is always the best place for spam
> > nowadays.
>
> What are you saying here? Spammers generally can't use the priority space
> at
> all, and it is a major way for legitimate users to get their transactions
> mined cheaply despite ongoing spam attempts. You're suggesting the exact
> opposite is true?? Please explain.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151112/fa4cfe8d/attachment.html>

From jtimon at jtimon.cc  Thu Nov 12 20:43:17 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 12 Nov 2015 21:43:17 +0100
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <201511122012.29966.luke@dashjr.org>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122012.29966.luke@dashjr.org>
Message-ID: <CABm2gDqnmR5eAEZj_CRJ6Q5gi8LM_chb3tBCt2=L9ojr+Ziadw@mail.gmail.com>

On Thu, Nov 12, 2015 at 9:12 PM, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Thursday, November 12, 2015 7:47:50 PM Matt Corallo via bitcoin-dev wrote:
>>  * Mining code will use starting priority for ease of implementation
>
> This should be optional, at least for 0.12.

The ease of implementation is not gained if it's maintained optionally.

>>  * Default block priority size will be 0
>
> We should not be influencing miner policy by changing defaults.

I agree changing policy defaults is meaningless, but in this case it
is supposed to signal deprecation of the policy option.

On Thu, Nov 12, 2015 at 9:20 PM, Chun Wang via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I would think about to merge the priority, feerate, and probably
> sigoprate into one number, probably 576 priorities trade for 1 satoshi
> per kb?

I am in favor of having customizable cost (currently tx size but it
has been proposed to also include sigoprate) and reward (currently
feerate). The main problem I see for keep maintaining the code is that
priority is not integrated in the reward function and cannot easily be
with its current functionality unchanged (which slows down other very
necessary improvements in the mempool limits).

From luke at dashjr.org  Thu Nov 12 21:10:45 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 12 Nov 2015 21:10:45 +0000
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <CABm2gDqnmR5eAEZj_CRJ6Q5gi8LM_chb3tBCt2=L9ojr+Ziadw@mail.gmail.com>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122012.29966.luke@dashjr.org>
	<CABm2gDqnmR5eAEZj_CRJ6Q5gi8LM_chb3tBCt2=L9ojr+Ziadw@mail.gmail.com>
Message-ID: <201511122110.47665.luke@dashjr.org>

On Thursday, November 12, 2015 8:43:17 PM Jorge Tim?n wrote:
> On Thu, Nov 12, 2015 at 9:12 PM, Luke Dashjr via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > On Thursday, November 12, 2015 7:47:50 PM Matt Corallo via bitcoin-dev
> > wrote:
> >>  * Mining code will use starting priority for ease of implementation
> > 
> > This should be optional, at least for 0.12.
> 
> The ease of implementation is not gained if it's maintained optionally.

It has come to my attention maintaining the current priority algorithm is not 
even expensive, so I think I'm inclined to NACK using starting priority 
altogether. Since I am the mining maintainer for Core, I believe it's 
reasonable for me to decide on maintenance tradeoffs...

Therefore, my goal in this matter will be to review #6357 in depth to be 
merged, and follow up with #6898 based on the current default policies.

> >>  * Default block priority size will be 0
> > 
> > We should not be influencing miner policy by changing defaults.
> 
> I agree changing policy defaults is meaningless, but in this case it
> is supposed to signal deprecation of the policy option.

This is a bad idea anyway, since priority is the best metric we have right now 
for ensuring legitimate transactions get mined despite spam attacks.

Luke

From morcos at gmail.com  Thu Nov 12 21:21:57 2015
From: morcos at gmail.com (Alex Morcos)
Date: Thu, 12 Nov 2015 16:21:57 -0500
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <201511122110.47665.luke@dashjr.org>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122012.29966.luke@dashjr.org>
	<CABm2gDqnmR5eAEZj_CRJ6Q5gi8LM_chb3tBCt2=L9ojr+Ziadw@mail.gmail.com>
	<201511122110.47665.luke@dashjr.org>
Message-ID: <CAPWm=eXNFimrG1A7bxJ3i=w_iWm57r93bjfiGZwq9y8KbZ8+Qg@mail.gmail.com>

To be clear Luke, its not THAT complicated to maintain the mining policy,
but preserving the ability of people to place priority based transactions
in a limited mempool world is quite complicated.  See recently closed
#6992.
I think the biggest issue with #6357 is being sure the logic doesn't break
in future changes.  There are a lot of things that need to be updated in
the right order when blocks are connected or disconnected.
And whats the point of having even that added extra complication if its not
easy to place free transactions and starting priority is a decent
approximation for mining anyway (txs can just be rebroadcast in the worst
case).


On Thu, Nov 12, 2015 at 4:10 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thursday, November 12, 2015 8:43:17 PM Jorge Tim?n wrote:
> > On Thu, Nov 12, 2015 at 9:12 PM, Luke Dashjr via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > On Thursday, November 12, 2015 7:47:50 PM Matt Corallo via bitcoin-dev
> > > wrote:
> > >>  * Mining code will use starting priority for ease of implementation
> > >
> > > This should be optional, at least for 0.12.
> >
> > The ease of implementation is not gained if it's maintained optionally.
>
> It has come to my attention maintaining the current priority algorithm is
> not
> even expensive, so I think I'm inclined to NACK using starting priority
> altogether. Since I am the mining maintainer for Core, I believe it's
> reasonable for me to decide on maintenance tradeoffs...
>
> Therefore, my goal in this matter will be to review #6357 in depth to be
> merged, and follow up with #6898 based on the current default policies.
>
> > >>  * Default block priority size will be 0
> > >
> > > We should not be influencing miner policy by changing defaults.
> >
> > I agree changing policy defaults is meaningless, but in this case it
> > is supposed to signal deprecation of the policy option.
>
> This is a bad idea anyway, since priority is the best metric we have right
> now
> for ensuring legitimate transactions get mined despite spam attacks.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151112/e994acb0/attachment.html>

From luke at dashjr.org  Thu Nov 12 21:26:38 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 12 Nov 2015 21:26:38 +0000
Subject: [bitcoin-dev] Upcoming Transaction Priority Changes
In-Reply-To: <CAPWm=eXNFimrG1A7bxJ3i=w_iWm57r93bjfiGZwq9y8KbZ8+Qg@mail.gmail.com>
References: <5644ECE6.9090304@mattcorallo.com>
	<201511122110.47665.luke@dashjr.org>
	<CAPWm=eXNFimrG1A7bxJ3i=w_iWm57r93bjfiGZwq9y8KbZ8+Qg@mail.gmail.com>
Message-ID: <201511122126.39532.luke@dashjr.org>

On Thursday, November 12, 2015 9:21:57 PM Alex Morcos wrote:
> To be clear Luke, its not THAT complicated to maintain the mining policy,
> but preserving the ability of people to place priority based transactions
> in a limited mempool world is quite complicated.  See recently closed
> #6992.
> I think the biggest issue with #6357 is being sure the logic doesn't break
> in future changes.  There are a lot of things that need to be updated in
> the right order when blocks are connected or disconnected.

That's what unit tests are for. :)

> And whats the point of having even that added extra complication if its not
> easy to place free transactions and starting priority is a decent
> approximation for mining anyway (txs can just be rebroadcast in the worst
> case).

I'm not sure what you're getting at here, but rebroadcasting won't work if 
they're still in the memory pools (unless we open the door to DoS from 
reprocessing the same tx over and over).

Luke

From morcos at gmail.com  Thu Nov 12 21:44:57 2015
From: morcos at gmail.com (Alex Morcos)
Date: Thu, 12 Nov 2015 16:44:57 -0500
Subject: [bitcoin-dev] New lower policy limits for unconfirmed transaction
	chains or packages
Message-ID: <CAPWm=eXjDDYcOLgZREn6b6rnfWcYGfv5pG--VyRmCMDaL_ge-g@mail.gmail.com>

I just wanted to let everyone know that after much considered review, new
lower policy limits on the number and size of related unconfirmed
transactions that will be accepted in to the mempool and relayed have been
merged into the master branch of Bitcoin Core for 0.12 release.

The actual limits were merged in PR 6771
<https://github.com/bitcoin/bitcoin/pull/6771> and discussion of these
limits can be found in this previous email
<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-August/010221.html>
to the dev list and discussion of the new lower limits here
<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-October/011401.html>
.

The new limits are:
25 unconfirmed ancestors
25 unconfirmed descendants
101kb total size with unconfirmed ancestors
101kb total size with unconfirmed descendants.

These limits are just policy and do not affect consensus.
They can be modified by command line arguments.


Thanks,
Alex
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151112/90b6a2ad/attachment.html>

From johnsock at gmail.com  Thu Nov 12 23:47:31 2015
From: johnsock at gmail.com (John Sacco)
Date: Thu, 12 Nov 2015 18:47:31 -0500
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving with
 max block size of 32M
Message-ID: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>

Hi Devs,


Please consider the draft proposal below for peer review.


Thanks,


John


BIP

  BIP: ?

  Title: Block size doubles at each reward halving with max block size of
32M

  Author: John Sacco <johnsock at gmail.com>

  Status: Draft

  Type: Standards Track

  Created: 2015-11-11

Abstract

Change max block size to 2MB at next block subsidy halving, and double the
block size at each subsidy halving until reaching 32MB.

Copyright

This proposal belongs in the public domain. Anyone can use this text for
any purpose with proper attribution to the author.

Motivation

1.    Gradually restores block size to the default 32 MB setting originally
implemented by Satoshi.

2.    Initial increase to 2MB at block halving in July 2016 would have
minimal impact to existing nodes running on most hardware and networks.

3.    Long term solution that does not make enthusiastic assumptions
regarding future bandwidth and storage availability estimates.

4.    Maximum block size of 32MB allows peak usage of ~100 tx/sec by year
2031.

5.    Exercise network upgrade procedure during subsidy reward halving, a
milestone event with the goal of increasing awareness among miners and node
operators.

Specification

1.    Increase the maximum block size to 2MB when block 630,000 is reached
and 75% of the last 1,000 blocks have signaled support.

2.    Increase maximum block size to 4MB at block 840,000.

3.    Increase maximum block size to 8MB at block 1,050,000.

4.    Increase maximum block size to 16MB at block 1,260,000.

5.    Increase maximum block size to 32MB at block 1,470,000.

Backward compatibility

All older clients are not compatible with this change. The first block
larger than 1M will create a network partition excluding not-upgraded
network nodes and miners.

Rationale

While more comprehensive solutions are developed, an increase to the block
size is needed to continue network growth. A longer term solution is needed
to prevent complications associated with additional hard forks. It should
also increase at a gradual rate that retains and allows a large
distribution of full nodes.  Scheduling this hard fork to occur no earlier
than the subsidy halving in 2016 has the goal of simplifying the
communication outreach needed to achieve consensus, while also providing a
buffer of time to make necessary preparations.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151112/c00ed906/attachment-0001.html>

From 1240902 at gmail.com  Fri Nov 13 02:56:55 2015
From: 1240902 at gmail.com (Chun Wang)
Date: Fri, 13 Nov 2015 10:56:55 +0800
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
References: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
Message-ID: <CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>

How about these specs:
* 1 MB, height < 210000;
* 2 MB, 210000 <= height < 420000;
* 4 MB, 420000 <= height < 630000;
* 8 MB, 630000 <= height < 840000;
* 16 MB, 840000 <= height < 1050000;
* 32 MB, height >= 1050000.


On Fri, Nov 13, 2015 at 7:47 AM, John Sacco via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi Devs,
>
>
> Please consider the draft proposal below for peer review.
>
>
> Thanks,
>
>
> John
>
>
> BIP
>
>   BIP: ?
>
>   Title: Block size doubles at each reward halving with max block size of
> 32M
>
>   Author: John Sacco <johnsock at gmail.com>
>
>   Status: Draft
>
>   Type: Standards Track
>
>   Created: 2015-11-11
>
> Abstract
>
> Change max block size to 2MB at next block subsidy halving, and double the
> block size at each subsidy halving until reaching 32MB.
>
> Copyright
>
> This proposal belongs in the public domain. Anyone can use this text for any
> purpose with proper attribution to the author.
>
> Motivation
>
> 1.    Gradually restores block size to the default 32 MB setting originally
> implemented by Satoshi.
>
> 2.    Initial increase to 2MB at block halving in July 2016 would have
> minimal impact to existing nodes running on most hardware and networks.
>
> 3.    Long term solution that does not make enthusiastic assumptions
> regarding future bandwidth and storage availability estimates.
>
> 4.    Maximum block size of 32MB allows peak usage of ~100 tx/sec by year
> 2031.
>
> 5.    Exercise network upgrade procedure during subsidy reward halving, a
> milestone event with the goal of increasing awareness among miners and node
> operators.
>
> Specification
>
> 1.    Increase the maximum block size to 2MB when block 630,000 is reached
> and 75% of the last 1,000 blocks have signaled support.
>
> 2.    Increase maximum block size to 4MB at block 840,000.
>
> 3.    Increase maximum block size to 8MB at block 1,050,000.
>
> 4.    Increase maximum block size to 16MB at block 1,260,000.
>
> 5.    Increase maximum block size to 32MB at block 1,470,000.
>
> Backward compatibility
>
> All older clients are not compatible with this change. The first block
> larger than 1M will create a network partition excluding not-upgraded
> network nodes and miners.
>
> Rationale
>
> While more comprehensive solutions are developed, an increase to the block
> size is needed to continue network growth. A longer term solution is needed
> to prevent complications associated with additional hard forks. It should
> also increase at a gradual rate that retains and allows a large distribution
> of full nodes.  Scheduling this hard fork to occur no earlier than the
> subsidy halving in 2016 has the goal of simplifying the communication
> outreach needed to achieve consensus, while also providing a buffer of time
> to make necessary preparations.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From luke at dashjr.org  Fri Nov 13 06:39:51 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 13 Nov 2015 06:39:51 +0000
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
	with max block size of 32M
In-Reply-To: <CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>
References: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
	<CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>
Message-ID: <201511130639.53410.luke@dashjr.org>

On Friday, November 13, 2015 2:56:55 AM Chun Wang via bitcoin-dev wrote:
> * 2 MB, 210000 <= height < 420000;

It's impossible to have the entire network upgraded in the past.

Furthermore, 1 MB is already too large a block size today. While blocks don't 
need to be as big as the limit, it's better to have the limit approximate what 
is reasonably possible without straining the network. So while your proposed 
schedule change might be workable (if miners can be trusted to keep actual 
block size under 50% pending future improvements), I prefer the proposal 
beginning at the next subsidy halving (which we're well on the way to).

Luke

From johnsock at gmail.com  Fri Nov 13 03:37:34 2015
From: johnsock at gmail.com (John Sacco)
Date: Thu, 12 Nov 2015 22:37:34 -0500
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>
References: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
	<CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>
Message-ID: <CAEkt4Xsav9i2x26YhAPqr_b0on2SCkBCNwYv=Ym4v5HBLQzySA@mail.gmail.com>

I like your suggestion for the continuity and it gets us up to 2 MB in the
shorter term. Also I just noticed the math error.

Here is a revised spec (incorporating suggestions from Chun Wang):

Specification

* 1 MB, height < 210,000;
* 2 MB, height 210,000 < 420,000; (when 75% of last 1,000 blocks signal
support)
* 4 MB, height 420,000 < 630,000; (year 2016)
* 8 MB, height 630,000 < 840,000; (year ~2020)
* 16 MB, height 840,000 < 1,050,000; (year ~2024)
* 32 MB, height >= 1,050,000. (year ~2028)


On Thu, Nov 12, 2015 at 9:56 PM, Chun Wang <1240902 at gmail.com> wrote:

> How about these specs:
> * 1 MB, height < 210000;
> * 2 MB, 210000 <= height < 420000;
> * 4 MB, 420000 <= height < 630000;
> * 8 MB, 630000 <= height < 840000;
> * 16 MB, 840000 <= height < 1050000;
> * 32 MB, height >= 1050000.
>
>
> On Fri, Nov 13, 2015 at 7:47 AM, John Sacco via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Hi Devs,
> >
> >
> > Please consider the draft proposal below for peer review.
> >
> >
> > Thanks,
> >
> >
> > John
> >
> >
> > BIP
> >
> >   BIP: ?
> >
> >   Title: Block size doubles at each reward halving with max block size of
> > 32M
> >
> >   Author: John Sacco <johnsock at gmail.com>
> >
> >   Status: Draft
> >
> >   Type: Standards Track
> >
> >   Created: 2015-11-11
> >
> > Abstract
> >
> > Change max block size to 2MB at next block subsidy halving, and double
> the
> > block size at each subsidy halving until reaching 32MB.
> >
> > Copyright
> >
> > This proposal belongs in the public domain. Anyone can use this text for
> any
> > purpose with proper attribution to the author.
> >
> > Motivation
> >
> > 1.    Gradually restores block size to the default 32 MB setting
> originally
> > implemented by Satoshi.
> >
> > 2.    Initial increase to 2MB at block halving in July 2016 would have
> > minimal impact to existing nodes running on most hardware and networks.
> >
> > 3.    Long term solution that does not make enthusiastic assumptions
> > regarding future bandwidth and storage availability estimates.
> >
> > 4.    Maximum block size of 32MB allows peak usage of ~100 tx/sec by year
> > 2031.
> >
> > 5.    Exercise network upgrade procedure during subsidy reward halving, a
> > milestone event with the goal of increasing awareness among miners and
> node
> > operators.
> >
> > Specification
> >
> > 1.    Increase the maximum block size to 2MB when block 630,000 is
> reached
> > and 75% of the last 1,000 blocks have signaled support.
> >
> > 2.    Increase maximum block size to 4MB at block 840,000.
> >
> > 3.    Increase maximum block size to 8MB at block 1,050,000.
> >
> > 4.    Increase maximum block size to 16MB at block 1,260,000.
> >
> > 5.    Increase maximum block size to 32MB at block 1,470,000.
> >
> > Backward compatibility
> >
> > All older clients are not compatible with this change. The first block
> > larger than 1M will create a network partition excluding not-upgraded
> > network nodes and miners.
> >
> > Rationale
> >
> > While more comprehensive solutions are developed, an increase to the
> block
> > size is needed to continue network growth. A longer term solution is
> needed
> > to prevent complications associated with additional hard forks. It should
> > also increase at a gradual rate that retains and allows a large
> distribution
> > of full nodes.  Scheduling this hard fork to occur no earlier than the
> > subsidy halving in 2016 has the goal of simplifying the communication
> > outreach needed to achieve consensus, while also providing a buffer of
> time
> > to make necessary preparations.
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151112/4aa7457b/attachment.html>

From dev at jonasschnelli.ch  Fri Nov 13 07:27:48 2015
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Fri, 13 Nov 2015 08:27:48 +0100
Subject: [bitcoin-dev] Ads on bitcoin.org website
Message-ID: <564590F4.8040605@jonasschnelli.ch>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Hi all

I'm a little bit concerned about the future of bitcoin.org.
A neutral website that informs about bitcoin, bitcoin-applications and
bitcoin-exchanges is important at this "early stage".

You might have seen that bitcoin.com does not claim to be neutral and
informative. As counterweight, a neutral and ad-free bitcoin.org site
is even more important.

Recently, bitcoin.org did merge a PR [1] that enables Google analytics
for bitcoin.org. The PR comments did show disagreement for this step.
For me, this seems to be against the about-us rules [2] in about "who
is in charge of bitcoin".
Personally I think allowing Google to collect data of bitcoin.org
visitors is against the bitcoin "philosophy".

Another PR [3] (not merged yet) would enable the technical base to
display ads on the site.

What ads would be displayed there?
If an ad provider would be implemented (like Google Ads), very likely
bitcoin related things like bitcoin application vendors or bitcoin
exchanges would be shown there.
Wouldn't this attack the neutrality model of bitcoin.org?

I think, it would move bitcoin.org in the wrong direction, towards
sites like bitcoin.com and it would loose the neutral "feeling" and
users and press very likely will see this as a "greedy" step.

I'd like to know, how changes on bitcoin.org happen? Do they follow
consensus-agreement among bitcoin-space contributors or does a group
of people decide what to merge and what not?

If site operators or contributers need to get payed for their (highly
appreciated) work or need to pay for infrastructure, we should address
this root problem.
I'm pretty sure we can raise funds for a such purpose and I'm offering
my help to speak to bitcoin businesses and individuals.


[1] https://github.com/bitcoin-dot-org/bitcoin.org/pull/1087
[2] https://bitcoin.org/en/about-us
[3] https://github.com/bitcoin-dot-org/bitcoin.org/pull/1136
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBCAAGBQJWRZD0AAoJECnUvLZBb1PsrBoQALebNL8OUIucB/MqtI8JK9Fa
RctlDuJlPeLCOC0oXjM4WKu/mzYATSuc/2y1xxWQLgRgteKRMd1+4ZcCIz0fqbIk
M4RsEr24klybRl7A4+vMmuL0OsXd3vXjU52AUDrSokdaCEITxeSpsRROX+t+tKz4
It5CXRdZS9gyaDswCiWsnDTDbSSbpOiz7DzaBQTMziOQYr+VKQg5G0FSsVGrGNso
N2LpKtADBwpPbVP57S6NwAkOERcVQnIdJ2Ag6NgLLkdIA8z3lSgd+Yvn1rdbdKQh
NkPWy1e0QHUPS6gCunKguJA46UdO0vuIY+ZLNIaOtnnEQFKtSn3VYERghWPY9WQ2
PhBZXGuSsLyQg9/3qKeae9e11S+bz7xJpNOwJC8FnOOOS4h6W74O5UG4B7QXd3Ap
0eQZd2+iRlp59RNaKMbiXIHodmbB/nbefbH7HK+qNvKvL4i01Ar8FBPjXPXf3tOA
U5WHb6h7ClmOJ+tWsgB4RdhUISE/ryzyA4s59troQlIWRm7aWF9cjq1JWRqKWhfy
CfjVsRje9QBYnX3aS5Y9Vh8lGuArr8ZxiBbXgA7bL951GgWge747vxadvESeimCv
W2qf7oFzQ1QKAm8NbTzLHJEjq0HVop1KBjGS0rjyf0upA0Xtdu4u1cfTvhK0ULAe
ZCkR3m2qdxJ/JqtUbioq
=ZXsV
-----END PGP SIGNATURE-----

From laanwj at gmail.com  Fri Nov 13 07:30:53 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Fri, 13 Nov 2015 08:30:53 +0100
Subject: [bitcoin-dev] Announcing Jonas Schnelli as GUI maintainer
Message-ID: <20151113073052.GB19878@amethyst.visucore.com>

Hello,

I'd like to announce Jonas Schnelli as the new GUI maintainer of Bitcoin Core.

He's been very active in this area for the last year, as one example he
redesigned all the icons for 0.11.0, has visualized various network statistics,
and has been continuously improving the user experience. Something Bitcoin Core
very much needs, in my opinion.

Unofficially he has been giving direction in GUI matters for quite a while
already, so this only makes it 'official'.

He will be handling GUI related issues on the github tracker, and assisting on and
merging GUI-related pull requests.

Welcome Jonas to the team!

Wladimir


From btcdrak at gmail.com  Fri Nov 13 07:49:02 2015
From: btcdrak at gmail.com (Btc Drak)
Date: Fri, 13 Nov 2015 07:49:02 +0000
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <CAEkt4Xsav9i2x26YhAPqr_b0on2SCkBCNwYv=Ym4v5HBLQzySA@mail.gmail.com>
References: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
	<CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>
	<CAEkt4Xsav9i2x26YhAPqr_b0on2SCkBCNwYv=Ym4v5HBLQzySA@mail.gmail.com>
Message-ID: <CADJgMzu+69bMP4mJZ4pUA1JLc8GXaUQfORGzTDivnLwQ8Zw9+A@mail.gmail.com>

> * 2 MB, height 210,000 < 420,000; (when 75% of last 1,000 blocks signal
support)

This doesnt give anyone a chance to upgrade and would cause a hard fork the
moment a miner created a >1MB block. Flag day (hard fork) upgrades must
start the change at a sufficient time in the future (greater than the
current block height) to give all nodes the chance to upgrade.

On Fri, Nov 13, 2015 at 3:37 AM, John Sacco via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I like your suggestion for the continuity and it gets us up to 2 MB in the
> shorter term. Also I just noticed the math error.
>
> Here is a revised spec (incorporating suggestions from Chun Wang):
>
> Specification
>
> * 1 MB, height < 210,000;
> * 2 MB, height 210,000 < 420,000; (when 75% of last 1,000 blocks signal
> support)
> * 4 MB, height 420,000 < 630,000; (year 2016)
> * 8 MB, height 630,000 < 840,000; (year ~2020)
> * 16 MB, height 840,000 < 1,050,000; (year ~2024)
> * 32 MB, height >= 1,050,000. (year ~2028)
>
>
> On Thu, Nov 12, 2015 at 9:56 PM, Chun Wang <1240902 at gmail.com> wrote:
>
>> How about these specs:
>> * 1 MB, height < 210000;
>> * 2 MB, 210000 <= height < 420000;
>> * 4 MB, 420000 <= height < 630000;
>> * 8 MB, 630000 <= height < 840000;
>> * 16 MB, 840000 <= height < 1050000;
>> * 32 MB, height >= 1050000.
>>
>>
>> On Fri, Nov 13, 2015 at 7:47 AM, John Sacco via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > Hi Devs,
>> >
>> >
>> > Please consider the draft proposal below for peer review.
>> >
>> >
>> > Thanks,
>> >
>> >
>> > John
>> >
>> >
>> > BIP
>> >
>> >   BIP: ?
>> >
>> >   Title: Block size doubles at each reward halving with max block size
>> of
>> > 32M
>> >
>> >   Author: John Sacco <johnsock at gmail.com>
>> >
>> >   Status: Draft
>> >
>> >   Type: Standards Track
>> >
>> >   Created: 2015-11-11
>> >
>> > Abstract
>> >
>> > Change max block size to 2MB at next block subsidy halving, and double
>> the
>> > block size at each subsidy halving until reaching 32MB.
>> >
>> > Copyright
>> >
>> > This proposal belongs in the public domain. Anyone can use this text
>> for any
>> > purpose with proper attribution to the author.
>> >
>> > Motivation
>> >
>> > 1.    Gradually restores block size to the default 32 MB setting
>> originally
>> > implemented by Satoshi.
>> >
>> > 2.    Initial increase to 2MB at block halving in July 2016 would have
>> > minimal impact to existing nodes running on most hardware and networks.
>> >
>> > 3.    Long term solution that does not make enthusiastic assumptions
>> > regarding future bandwidth and storage availability estimates.
>> >
>> > 4.    Maximum block size of 32MB allows peak usage of ~100 tx/sec by
>> year
>> > 2031.
>> >
>> > 5.    Exercise network upgrade procedure during subsidy reward halving,
>> a
>> > milestone event with the goal of increasing awareness among miners and
>> node
>> > operators.
>> >
>> > Specification
>> >
>> > 1.    Increase the maximum block size to 2MB when block 630,000 is
>> reached
>> > and 75% of the last 1,000 blocks have signaled support.
>> >
>> > 2.    Increase maximum block size to 4MB at block 840,000.
>> >
>> > 3.    Increase maximum block size to 8MB at block 1,050,000.
>> >
>> > 4.    Increase maximum block size to 16MB at block 1,260,000.
>> >
>> > 5.    Increase maximum block size to 32MB at block 1,470,000.
>> >
>> > Backward compatibility
>> >
>> > All older clients are not compatible with this change. The first block
>> > larger than 1M will create a network partition excluding not-upgraded
>> > network nodes and miners.
>> >
>> > Rationale
>> >
>> > While more comprehensive solutions are developed, an increase to the
>> block
>> > size is needed to continue network growth. A longer term solution is
>> needed
>> > to prevent complications associated with additional hard forks. It
>> should
>> > also increase at a gradual rate that retains and allows a large
>> distribution
>> > of full nodes.  Scheduling this hard fork to occur no earlier than the
>> > subsidy halving in 2016 has the goal of simplifying the communication
>> > outreach needed to achieve consensus, while also providing a buffer of
>> time
>> > to make necessary preparations.
>> >
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >
>>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/f716f43a/attachment.html>

From dev at jonasschnelli.ch  Fri Nov 13 08:13:24 2015
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Fri, 13 Nov 2015 09:13:24 +0100
Subject: [bitcoin-dev] Announcing Jonas Schnelli as GUI maintainer
In-Reply-To: <20151113073052.GB19878@amethyst.visucore.com>
References: <20151113073052.GB19878@amethyst.visucore.com>
Message-ID: <56459BA4.8020301@jonasschnelli.ch>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> I'd like to announce Jonas Schnelli as the new GUI maintainer of
> Bitcoin Core.
> 
> He's been very active in this area for the last year, as one
> example he redesigned all the icons for 0.11.0, has visualized
> various network statistics, and has been continuously improving the
> user experience. Something Bitcoin Core very much needs, in my
> opinion.
> 
> Unofficially he has been giving direction in GUI matters for quite
> a while already, so this only makes it 'official'.
> 
> He will be handling GUI related issues on the github tracker, and
> assisting on and merging GUI-related pull requests.
> 
> Welcome Jonas to the team!
> 

Thanks Wladimir!

My long term vision for bitcoin-core was always a more user friendly
UI without loosing the security and privacy features bitcoin-core offers
.
However, it has shown that this is relatively hard to achieve. Its
unclear to me, what role wallets (and related UIs) will play in the
future of bitcoin. I think it needs several years until something like
bitcoin can be used to "pay for every coffee in the world" [1].
But I'm happy to explore this path!

That was and is also the reason why I'm often focus on non-UI-related
changes that keep bitcoin healthy and form a more defined role for the U
I.

Short words to myself:
I'm a senior software developer, 35 years old, living in Switzerland
(UTC+1).

Thanks for the trust and I try to give my best to maintain and improve
the GUI.

[1] https://twitter.com/ronmckown/status/643101952763658240
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBCAAGBQJWRZukAAoJECnUvLZBb1PsbEAP/jERgMowXP7rSV8FXwQ6mR+r
CdO4xs3OHKuRyZJKLhXq/aC48ThshzDynRcKAJifcxhoIN0Msnt2oz/kwyfJSssT
FHB2dZVmuSXSNdOKVjwemiIQJ1xVENrfBNEINNVkix3LNgbi/3vwPuNj/ImHjWOc
mTAcD+JkzZSdkWL53TWPY5noizl3hd/LJD0lJ357FZlzmnpt9UiiZw6+X3+n5aJI
7J5avpeEa36hppdej5Jh9V0Kq8JMkXgip/jSq9uP009Nki9RNywFQL+Pa26AgJvu
VxAyJRjq6Dcb8D6dux8QcC8K114tAWncR6Lh2Z9DepNHhytk/TYBSi9+MWbnuWci
JiN6fRCeBTt2A/m7IsUbVegfrmPgBiHAS5Mx+Q9vjTBzOOmpBbL2ZXOXR9wE3t3d
9hBodZxnK37gU8UwKsoOiWuB4+rTp4rlt5iz32jd+/r6zUXv3whOy11HuICzVR0c
ll2aHfvr8TkqTRds0cvrb5ZroT63mmGFaqJIrskVruVoMxVWjdqnOIiNxtXWSnCd
T9jmxdojqrSwtM+3A60UmrSNVwyhZudZFmyJsjHZGAK6aV/eGYb595vXUDvx8mtH
fzeqmpivONDrNhqFrbLPR1V8kBx0UCN5FreMjdXtmU81UTqLd4o5lCh0AFZ7upCq
2DiMpEgittqOtxDwb8YY
=Q5KE
-----END PGP SIGNATURE-----

From johnsock at gmail.com  Fri Nov 13 09:50:47 2015
From: johnsock at gmail.com (John Sacco)
Date: Fri, 13 Nov 2015 04:50:47 -0500
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <CADJgMzu+69bMP4mJZ4pUA1JLc8GXaUQfORGzTDivnLwQ8Zw9+A@mail.gmail.com>
References: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
	<CAFzgq-xmXcEKN0_0e8de0UDOJEXuivbz986-dsSC5BCYLA2t1A@mail.gmail.com>
	<CAEkt4Xsav9i2x26YhAPqr_b0on2SCkBCNwYv=Ym4v5HBLQzySA@mail.gmail.com>
	<CADJgMzu+69bMP4mJZ4pUA1JLc8GXaUQfORGzTDivnLwQ8Zw9+A@mail.gmail.com>
Message-ID: <CAEkt4XvGzkFipDwqD_m+56+vWxRaF+rRy8ydJJ7tqibcyjWJ0g@mail.gmail.com>

Revised spec below to put us back at 2 MB at next halving in 2016
(addressing Luke & Drak's points). This is more in line with intent of the
original proposal and provides sufficient time to gain consensus.

Specification
>
>
> * 2 MB, height 420,000 < 630,000; (fork active when 75% of last 1,000
blocks signal support and block 420,000 reached, ~July 2016)


* 4 MB, height 630,000 < 840,000; (year ~2020)


* 8 MB, height 840,000 < 1,050,000; (year ~2024)


* 16 MB, height 1,050,000 < 1,260,000; (year ~2028)


* 32 MB, height >= 1,260,000. (year ~2032)




On Fri, Nov 13, 2015 at 2:49 AM, Btc Drak <btcdrak at gmail.com> wrote:

> > * 2 MB, height 210,000 < 420,000; (when 75% of last 1,000 blocks signal
> support)
>
> This doesnt give anyone a chance to upgrade and would cause a hard fork
> the moment a miner created a >1MB block. Flag day (hard fork) upgrades must
> start the change at a sufficient time in the future (greater than the
> current block height) to give all nodes the chance to upgrade.
>
> On Fri, Nov 13, 2015 at 3:37 AM, John Sacco via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I like your suggestion for the continuity and it gets us up to 2 MB in
>> the shorter term. Also I just noticed the math error.
>>
>> Here is a revised spec (incorporating suggestions from Chun Wang):
>>
>> Specification
>>
>> * 1 MB, height < 210,000;
>> * 2 MB, height 210,000 < 420,000; (when 75% of last 1,000 blocks signal
>> support)
>> * 4 MB, height 420,000 < 630,000; (year 2016)
>> * 8 MB, height 630,000 < 840,000; (year ~2020)
>> * 16 MB, height 840,000 < 1,050,000; (year ~2024)
>> * 32 MB, height >= 1,050,000. (year ~2028)
>>
>>
>> On Thu, Nov 12, 2015 at 9:56 PM, Chun Wang <1240902 at gmail.com> wrote:
>>
>>> How about these specs:
>>> * 1 MB, height < 210000;
>>> * 2 MB, 210000 <= height < 420000;
>>> * 4 MB, 420000 <= height < 630000;
>>> * 8 MB, 630000 <= height < 840000;
>>> * 16 MB, 840000 <= height < 1050000;
>>> * 32 MB, height >= 1050000.
>>>
>>>
>>> On Fri, Nov 13, 2015 at 7:47 AM, John Sacco via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> > Hi Devs,
>>> >
>>> >
>>> > Please consider the draft proposal below for peer review.
>>> >
>>> >
>>> > Thanks,
>>> >
>>> >
>>> > John
>>> >
>>> >
>>> > BIP
>>> >
>>> >   BIP: ?
>>> >
>>> >   Title: Block size doubles at each reward halving with max block size
>>> of
>>> > 32M
>>> >
>>> >   Author: John Sacco <johnsock at gmail.com>
>>> >
>>> >   Status: Draft
>>> >
>>> >   Type: Standards Track
>>> >
>>> >   Created: 2015-11-11
>>> >
>>> > Abstract
>>> >
>>> > Change max block size to 2MB at next block subsidy halving, and double
>>> the
>>> > block size at each subsidy halving until reaching 32MB.
>>> >
>>> > Copyright
>>> >
>>> > This proposal belongs in the public domain. Anyone can use this text
>>> for any
>>> > purpose with proper attribution to the author.
>>> >
>>> > Motivation
>>> >
>>> > 1.    Gradually restores block size to the default 32 MB setting
>>> originally
>>> > implemented by Satoshi.
>>> >
>>> > 2.    Initial increase to 2MB at block halving in July 2016 would have
>>> > minimal impact to existing nodes running on most hardware and networks.
>>> >
>>> > 3.    Long term solution that does not make enthusiastic assumptions
>>> > regarding future bandwidth and storage availability estimates.
>>> >
>>> > 4.    Maximum block size of 32MB allows peak usage of ~100 tx/sec by
>>> year
>>> > 2031.
>>> >
>>> > 5.    Exercise network upgrade procedure during subsidy reward
>>> halving, a
>>> > milestone event with the goal of increasing awareness among miners and
>>> node
>>> > operators.
>>> >
>>> > Specification
>>> >
>>> > 1.    Increase the maximum block size to 2MB when block 630,000 is
>>> reached
>>> > and 75% of the last 1,000 blocks have signaled support.
>>> >
>>> > 2.    Increase maximum block size to 4MB at block 840,000.
>>> >
>>> > 3.    Increase maximum block size to 8MB at block 1,050,000.
>>> >
>>> > 4.    Increase maximum block size to 16MB at block 1,260,000.
>>> >
>>> > 5.    Increase maximum block size to 32MB at block 1,470,000.
>>> >
>>> > Backward compatibility
>>> >
>>> > All older clients are not compatible with this change. The first block
>>> > larger than 1M will create a network partition excluding not-upgraded
>>> > network nodes and miners.
>>> >
>>> > Rationale
>>> >
>>> > While more comprehensive solutions are developed, an increase to the
>>> block
>>> > size is needed to continue network growth. A longer term solution is
>>> needed
>>> > to prevent complications associated with additional hard forks. It
>>> should
>>> > also increase at a gradual rate that retains and allows a large
>>> distribution
>>> > of full nodes.  Scheduling this hard fork to occur no earlier than the
>>> > subsidy halving in 2016 has the goal of simplifying the communication
>>> > outreach needed to achieve consensus, while also providing a buffer of
>>> time
>>> > to make necessary preparations.
>>> >
>>> >
>>> > _______________________________________________
>>> > bitcoin-dev mailing list
>>> > bitcoin-dev at lists.linuxfoundation.org
>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> >
>>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/f0652a2e/attachment-0001.html>

From luke at dashjr.org  Fri Nov 13 10:52:57 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 13 Nov 2015 10:52:57 +0000
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
	with max block size of 32M
In-Reply-To: <CAEkt4XvGzkFipDwqD_m+56+vWxRaF+rRy8ydJJ7tqibcyjWJ0g@mail.gmail.com>
References: <CAEkt4Xu6vBFtRVEnXCWJa0f9OYi9wLKwToxc3p+KPfMuV5y0GA@mail.gmail.com>
	<CADJgMzu+69bMP4mJZ4pUA1JLc8GXaUQfORGzTDivnLwQ8Zw9+A@mail.gmail.com>
	<CAEkt4XvGzkFipDwqD_m+56+vWxRaF+rRy8ydJJ7tqibcyjWJ0g@mail.gmail.com>
Message-ID: <201511131052.58623.luke@dashjr.org>

On Friday, November 13, 2015 9:50:47 AM John Sacco wrote:
> * 2 MB, height 420,000 < 630,000; (fork active when 75% of last 1,000 blocks
> signal support and block 420,000 reached, ~July 2016)

I'd leave out the block signalling. It isn't really useful, complicates the 
whole BIP, and mistakenly gives people the idea that miners have a choice in 
hardforks.

Luke

From laanwj at gmail.com  Fri Nov 13 13:13:54 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Fri, 13 Nov 2015 14:13:54 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.11.2 released
Message-ID: <20151113131353.GA26622@amethyst.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Bitcoin Core version 0.11.2 is now available from:

  <https://bitcoin.org/bin/bitcoin-core-0.11.2/>

Alternatively, through bittorrent:

    magnet:?xt=urn:btih:d6d3387160f7e14f6f27dc40ae84cf566ebf631b&dn=bitcoin-core-0.11.2&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969&tr=udp%3A%2F%2Fopen.demonii.com%3A1337&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F 

This is a new minor version release, bringing bug fixes, the BIP65
(CLTV) consensus change, and relay policy preparation for BIP113. It is
recommended to upgrade to this version as soon as possible.

Please report bugs using the issue tracker at github:

  <https://github.com/bitcoin/bitcoin/issues>

Upgrading and downgrading
=========================

How to Upgrade
- --------------

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or
bitcoind/bitcoin-qt (on Linux).

Downgrade warning
- ------------------

Because release 0.10.0 and later makes use of headers-first synchronization and
parallel block download (see further), the block files and databases are not
backwards-compatible with pre-0.10 versions of Bitcoin Core or other software:

* Blocks will be stored on disk out of order (in the order they are
received, really), which makes it incompatible with some tools or
other programs. Reindexing using earlier versions will also not work
anymore as a result of this.

* The block index database will now hold headers for which no block is
stored on disk, which earlier versions won't support.

If you want to be able to downgrade smoothly, make a backup of your entire data
directory. Without this your node will need start syncing (or importing from
bootstrap.dat) anew afterwards. It is possible that the data from a completely
synchronised 0.10 node may be usable in older versions as-is, but this is not
supported and may break as soon as the older version attempts to reindex.

This does not affect wallet forward or backward compatibility. There are no
known problems when downgrading from 0.11.x to 0.10.x.

Notable changes since 0.11.1
============================

BIP65 soft fork to enforce OP_CHECKLOCKTIMEVERIFY opcode
- --------------------------------------------------------

This release includes several changes related to the [BIP65][] soft fork
which redefines the existing OP_NOP2 opcode as OP_CHECKLOCKTIMEVERIFY
(CLTV) so that a transaction output can be made unspendable until a
specified point in the future.

1. This release will only relay and mine transactions spending a CLTV
   output if they comply with the BIP65 rules as provided in code.

2. This release will produce version 4 blocks by default. Please see the
   *notice to miners* below.

3. Once 951 out of a sequence of 1,001 blocks on the local node's best block
   chain contain version 4 (or higher) blocks, this release will no
   longer accept new version 3 blocks and it will only accept version 4
   blocks if they comply with the BIP65 rules for CLTV.

For more information about the soft-forking change, please see
<https://github.com/bitcoin/bitcoin/pull/6351>

Graphs showing the progress towards block version 4 adoption may be
found at the URLs below:

- - Block versions over the last 50,000 blocks as progress towards BIP65
  consensus enforcement: <http://bitcoin.sipa.be/ver-50k.png>

- - Block versions over the last 2,000 blocks showing the days to the
  earliest possible BIP65 consensus-enforced block: <http://bitcoin.sipa.be/ver-2k.png>

**Notice to miners:** Bitcoin Core?s block templates are now for
version 4 blocks only, and any mining software relying on its
getblocktemplate must be updated in parallel to use libblkmaker either
version 0.4.3 or any version from 0.5.2 onward.

- - If you are solo mining, this will affect you the moment you upgrade
  Bitcoin Core, which must be done prior to BIP65 achieving its 951/1001
  status.

- - If you are mining with the stratum mining protocol: this does not
  affect you.

- - If you are mining with the getblocktemplate protocol to a pool: this
  will affect you at the pool operator?s discretion, which must be no
  later than BIP65 achieving its 951/1001 status.

[BIP65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki

BIP113 mempool-only locktime enforcement using GetMedianTimePast()
- ----------------------------------------------------------------

Bitcoin transactions currently may specify a locktime indicating when
they may be added to a valid block.  Current consensus rules require
that blocks have a block header time greater than the locktime specified
in any transaction in that block.

Miners get to choose what time they use for their header time, with the
consensus rule being that no node will accept a block whose time is more
than two hours in the future.  This creates a incentive for miners to
set their header times to future values in order to include locktimed
transactions which weren't supposed to be included for up to two more
hours.

The consensus rules also specify that valid blocks may have a header
time greater than that of the median of the 11 previous blocks.  This
GetMedianTimePast() time has a key feature we generally associate with
time: it can't go backwards.

[BIP113][] specifies a soft fork (**not enforced in this release**) that
weakens this perverse incentive for individual miners to use a future
time by requiring that valid blocks have a computed GetMedianTimePast()
greater than the locktime specified in any transaction in that block.

Mempool inclusion rules currently require transactions to be valid for
immediate inclusion in a block in order to be accepted into the mempool.
This release begins applying the BIP113 rule to received transactions,
so transaction whose time is greater than the GetMedianTimePast() will
no longer be accepted into the mempool.

**Implication for miners:** you will begin rejecting transactions that
would not be valid under BIP113, which will prevent you from producing
invalid blocks if/when BIP113 is enforced on the network. Any
transactions which are valid under the current rules but not yet valid
under the BIP113 rules will either be mined by other miners or delayed
until they are valid under BIP113. Note, however, that time-based
locktime transactions are more or less unseen on the network currently.

**Implication for users:** GetMedianTimePast() always trails behind the
current time, so a transaction locktime set to the present time will be
rejected by nodes running this release until the median time moves
forward. To compensate, subtract one hour (3,600 seconds) from your
locktimes to allow those transactions to be included in mempools at
approximately the expected time.

[BIP113]: https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki

Windows bug fix for corrupted UTXO database on unclean shutdowns
- ----------------------------------------------------------------

Several Windows users reported that they often need to reindex the
entire blockchain after an unclean shutdown of Bitcoin Core on Windows
(or an unclean shutdown of Windows itself). Although unclean shutdowns
remain unsafe, this release no longer relies on memory-mapped files for
the UTXO database, which significantly reduced the frequency of unclean
shutdowns leading to required reindexes during testing.

For more information, see: <https://github.com/bitcoin/bitcoin/pull/6917>

Other fixes for database corruption on Windows are expected in the
next major release.

0.11.2 Change log
=================

Detailed release notes follow. This overview includes changes that affect
behavior, not code moves, refactors and string updates. For convenience in locating
the code changes and accompanying discussion, both the pull request and
git merge commit are mentioned.

- - #6124 `684636b` Make CScriptNum() take nMaxNumSize as an argument
- - #6124 `4fa7a04` Replace NOP2 with CHECKLOCKTIMEVERIFY (BIP65)
- - #6124 `6ea5ca4` Enable CHECKLOCKTIMEVERIFY as a standard script verify flag
- - #6351 `5e82e1c` Add CHECKLOCKTIMEVERIFY (BIP65) soft-fork logic
- - #6353 `ba1da90` Show softfork status in getblockchaininfo
- - #6351 `6af25b0` Add BIP65 to getblockchaininfo softforks list
- - #6688 `01878c9` Fix locking in GetTransaction
- - #6653 `b3eaa30` [Qt] Raise debug window when requested
- - #6600 `1e672ae` Debian/Ubuntu: Include bitcoin-tx binary
- - #6600 `2394f4d` Debian/Ubuntu: Split bitcoin-tx into its own package
- - #5987 `33d6825` Bugfix: Allow mining on top of old tip blocks for testnet
- - #6852 `21e58b8` build: make sure OpenSSL heeds noexecstack
- - #6846 `af6edac` alias `-h` for `--help`
- - #6867 `95a5039` Set TCP_NODELAY on P2P sockets.
- - #6856 `dfe55bd` Do not allow blockfile pruning during reindex.
- - #6566 `a1d3c6f` Add rules--presently disabled--for using GetMedianTimePast as end point for lock-time calculations
- - #6566 `f720c5f` Enable policy enforcing GetMedianTimePast as the end point of lock-time constraints
- - #6917 `0af5b8e` leveldb: Win32WritableFile without memory mapping
- - #6948 `4e895b0` Always flush block and undo when switching to new file

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Alex Morcos
- - ?tcDrak
- - Chris Kleeschulte
- - Daniel Cousens
- - Diego Viola
- - Eric Lombrozo
- - Esteban Ordano
- - Gregory Maxwell
- - Luke Dashjr
- - Marco Falke
- - Mark Friedenbach
- - Matt Corallo
- - Micha
- - Mitchell Cash
- - Peter Todd
- - Pieter Wuille
- - Wladimir J. van der Laan
- - Zak Wilcox

And those who contributed additional code review and/or security research.

As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBCgAGBQJWReHOAAoJEHSBCwEjRsmmTAAH/iZQGklLHLIM6a2tTOj4d/O6
xHg5bJhXGjtzO284Uy3phTzvk+e4mqBTjI8BrSr4D+Vw7mJrfWihdTLlgZYCwso3
AyAk8ud1H42QanAfUvciY5uXd7cyzr8tCnCIBkvwJT5O8tI3FFhSMM5Fs86WnsP1
Y10+93sxaVJUave2xm1bmgiwApFZKQ2MNU1IVgFaW8agB59fuqtPRnBdKiK/j+AO
Jn1LKsObsINYhjtkAFiC66mUOBZ2N3rdhbN3LFl+u7EriTLoYk1OtZZhlC+rOueo
nxl1H5SHStjrD27vE9Hv2qD5Ckrwo3zib8hZNIVs6MJjFnWUCwNtNg0nqDEvpn4=
=xXdY
-----END PGP SIGNATURE-----

From erik.fors at startmail.com  Fri Nov 13 13:07:33 2015
From: erik.fors at startmail.com (Erik)
Date: Fri, 13 Nov 2015 14:07:33 +0100
Subject: [bitcoin-dev] BIP proposal - Max block size
Message-ID: <5645E095.4050704@startmail.com>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Hi devs. I was discussing the BIP proposals concerning max block size
yesterday in the #bitcoin channel. I believe that BIP101 fully utilized
will outperform consumer hardware soon or later and thereby centralize
Bitcoin. I would therefore like to do a different proposal:

Motivations:
* BIP101 propose a doubling of the block max size every second year.
This is very fast and may make the blockchain to grow faster than
consumer hardware can cope with.
* BIP102 is only a one-time solution, thus a new discussion of the next
block max size will need to arise soon after it has been implemented.
* BIP100 is an interesting solution in that the miners vote on the block
max size. Althoigh it has several cons: 1) The block max size can never
extend 32 MiB, even if we are so far in the future that it is need for
larger blocks. 2) The block max size could reach a size of 32 MiB in a
rather fast manner if pools vote for it, even though consumer hardware
today isn't really ready for the growth it implicates. 3) Block max size
can be pushed backwards, which will make TX fees higher, cause a lot of
orphaned low-fee TXes. It could make some smaller mining pools dependant
on lots of TXes with fees unprofitable. It is a serious flaw which could
damage the trust of the network.
* We does not for sure know how the evolution will proceed and if there
will be storage for the larger block chain in the future.
* There is a benefit of having a limit on the amount of transactions
that will be processed in that the fees will rise.
* Also there is a large problem if the fees rise too high because it
will prevent mainstream users from using the network. There will also be
a lot of orphan TXes which will cause uncertainity and fear of losses
among users that don't know how bitcoin works.
* Pruning is a problem if the blockchain grows too fast because some,
although a few, nodes still must store the complete data -> centralization.

Concepts:
There is always a growth in the block max size. Never a decrease.
The growth rate desicion should be in the hands of the miners.
It's good to have limits on the block max size to keep back spam TXes.
Use rules that makes a more smooth and predictable growth.

Rules:
1) Main target growth is 2^(1/2) every second year, or a doubling of the
block max size every four years.
2) The growth rate every second year will strictly be limited by the
formula 2^2 > growth > linear growth.
3) The target growth could be modified with positive or negative votes,
but it will not exceed the limits of 2) in any direction. Miners could
also choose to not vote.
4) The linear y=kx+m will be formed from the genesis block date with
size 1 MiB (m) through the last retarget block date with current size.
5) Target growth is based on votes from the last 26280 blocks (half a year).
6) Block max size grows at the same time as block difficulty retarget
(2016 blocks) with the formula 2^(((1/2)+(1/2*amount positive
votes)-(1/2*amount negative votes))/52). If the votes propose a lower
growth than the linear, use the linear growth instead. Block size is
floored to byte precision.
7) Amount positive/negative votes are calculated as following: number of
votes, positive or negative / 26280.
8) When this rule are put in force, the block max size will immidiately
be set to 4 MiB.

Notes:
* The number 52 came from 52 weeks/year * 2 years / 2 weeks. It measures
number of week pairs or difficulty retargets per two years.
* When there are no votes, the growth speed is set as main target as in
1). Also blocks mined before the implementation counts as blocks with no
votes.

Examples:
* After implementation, the block max size will be 4 MiB.
* At the first retarget, if no miner has left a vote, or equal number of
votes exists for positive and negative side. Then the next block max
size is 4096 KiB*2^((1/2)/52)=4123.3905 KiB (or exactly 4 222 351 bytes)
* If the block max size is exactly 11 MiB, it has been exactly 10 years
and 2 weeks since the genesis block, the next block is a retarget and
every vote is negative. Then 2^(((1/2)-(1/2))/52) = 1. It is lower than
the linear, then the next block max size will follow the linear derived
from: (11 MiB - 1 MiB) / (10.00 years) = 1 = k. Formula for a linear is
y=kx+m. m is the genesis block max size in MiB. Then y = 1 * (10+1/52) +
1 = 11.019 [MiB] (or exactly 11 554 500 bytes)
* If everyone in the past example continue voting negative for the next
four years, then the block max size will then be y = 1*14 + 1 = 15 [MiB].
* If the block max size was 10 MiB four years ago and every miner
instead has put positive votes into the block chain since 4.5 years,
then the block max size now is 10 MiB * 2^( ((1/2+1/2)/(52)) * 2) = 10
MiB * 4 = 40 MiB
* If there was 2628 negative votes and 5256 positive votes in the last
26280 blocks, then the formula will look like:
size*2^(((1/2)+(1/2*0.2)-(1/2*0.1))/52)

Pros:
Provides a long term solution that give opportunities to the network to
itself cope with the actual state and hardware limits of the future
network. No need to make a hard fork to adapt to other growth rates
within this proposal's limits.
Provides a smooth growth rate based on a large consensus, thus making
the growth for the near future almost predictable. No big jumps in block
max size provides stability to the network.
Miners can choose pools that votes in a way that conforms to the miners
interest.
Eliminates fluctuating block size as could happen with BIP100 proposal.

Cons:
A few single, large entities could either vote for smaller growth of
blocks for a long time, causing TX congestion and mistrust in the
bitcoin network. On the contrary they could vote for a larger growth of
blocks, causing the blockchain to be too large for consumer hardware. It
will then result in fewer nodes and in worst cases closing of small
pools. These cases seems to be extremely unlikely partly because of the
time and mining power that will be needed, partly also because of limits
in how much the votes can adjust the growth rate. It would therefore not
pose a large risk.

Sincerely,
Erik Fors
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQIcBAEBAgAGBQJWReCVAAoJEJ51csApon2oLBgP/jn7mL5AzvU7/PCeAD39Kmc3
IsgFwh9LrHin/SaerPebusRGbjKXezP86kbiQVGEsSu3K3BxUAf9O09UoQiWECoc
g2EOw5E1XrtzBopxYTO06daM/2CqDydpLVIVv6NwwLMpXKvmbixdqaD6vOKfzhNF
1B5tmg9Vh1zqEkBj7exnuypagG/3llkCt3DRb0+siVzkIM/O9GzgHbGtt8rtDEnH
XHIhwLw+ySGuHg6hRhLo3uHs3gCUQmarxx1AoqR6AyvzgR6TGhJcy22vXct7QK5G
B2K4+JseyVD0bvkBeIpjuqJpGoCq4lmNu/AmI/nQ82TmqqzvOBi/ljFF/Q+HArjZ
UQO6p28lE7rmXf80GB6L117QLHktA5CdY++vW4Gwz3KDYEafs6H3CptvSmj9JbQz
SVAt/eVvvdnVkRcYw++b0WrRuOS3Z+105QIX4yqt0Kyghr87LQ76LXnZHPMKZeHt
IRX3wv7ZFqrJEpmGrTK4ZMZUAPVpkGe0kPms5kLHjEtjU92rvZJA726JJFoaAv5S
rFDiGUupLvHttZLTYfTdyFhCo6ZStOI095qDZ69awVCLMmYpC9aR/tjQ5zMu5eNS
y4hQdrX0Z4sdrJ2mTB+OXO7broLDn2G9dIqfpZwcIU493ljcXk/Uma4lj3oDrGTA
oc5Q5ie/OVUclWB6GIho
=cocM
-----END PGP SIGNATURE-----

-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0x29A27DA8.asc
Type: application/pgp-keys
Size: 3117 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/2b1ae0ad/attachment.bin>

From dave at dtrt.org  Fri Nov 13 15:59:16 2015
From: dave at dtrt.org (David A. Harding)
Date: Fri, 13 Nov 2015 10:59:16 -0500
Subject: [bitcoin-dev] Ads on bitcoin.org website
In-Reply-To: <564590F4.8040605@jonasschnelli.ch>
References: <564590F4.8040605@jonasschnelli.ch>
Message-ID: <20151113155915.GA3822@localhost.localdomain>

On Fri, Nov 13, 2015 at 08:27:48AM +0100, Jonas Schnelli via bitcoin-dev wrote:
> I'm a little bit concerned about the future of bitcoin.org.

Bitcoin.org hosts the Bitcoin Core binaries refered to in release
announcements, so this subject is conceivably on-topic for bitcoin-dev.
However, I think questions about how Bitcoin.org operates are best asked
on bitcoin-discuss[1] (or somewhere else) and issues about the
advertising are best addressed in the PRs you referenced.

So, as one of the Bitcoin.org maintainers, here are my suggestions:

1. I'm on bitcoin-discuss.  Please feel free to ask any questions there.

2. I just opened a GitHub issue for discussing advertising on Bitcoin.org[2]

    - I will reply to your specific questions there after I've sent this
      mail.

3. If advertisements are added to Bitcoin.org and there is general
   dissatisfaction about that, maybe then we can come back to
   bitcoin-dev to discuss moving the Bitcoin Core binaries
   somewhere else.

Thanks,

-Dave

[1] https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-discuss

[2] https://github.com/bitcoin-dot-org/bitcoin.org/issues/1139
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/2c4e0c39/attachment-0001.sig>

From el33th4x0r at gmail.com  Fri Nov 13 16:37:51 2015
From: el33th4x0r at gmail.com (=?UTF-8?Q?Emin_G=C3=BCn_Sirer?=)
Date: Fri, 13 Nov 2015 11:37:51 -0500
Subject: [bitcoin-dev] How to evaluate block size increase suggestions.
Message-ID: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>

By now, we have seen quite a few proposals for the block size increase.
It's hard not to notice that there are potentially infinitely many
functions for future block size increases. One could, for instance, double
every N years for any rational number N, one could increase linearly, one
could double initially then increase linearly, one could ask the miners to
vote on the size, one could couple the block size increase to halvings,
etc. Without judging any of these proposals on the table, one can see that
there are countless alternative functions one could imagine creating.

I'd like to ask a question that is one notch higher: Can we enunciate what
grand goals a truly perfect function would achieve? That is, if we could
look into the future and know all the improvements to come in network
access technologies, see the expansion of the Bitcoin network across the
globe, and precisely know the placement and provisioning of all future
nodes, what metrics would we care about as we craft a function to fit what
is to come?

To be clear, I'd like to avoid discussing any specific block size increase
function. That's very much the tangible (non-meta) block size debate, and
everyone has their opinion and best good-faith attempt at what that
function should look like. I've purposefully stayed out of that issue,
because there are too many options and no metrics for evaluating proposals.

Instead, I'm asking to see if there is some agreement on how to evaluate a
good proposal. So, the meta-question: if we were looking at the best
possible function, how would we know? If we have N BIPs to choose from,
what criteria do we look for?

To illustrate, a possible meta goal might be: "increase the block size,
while ensuring that large miners never have an advantage over small miners
that [they did not have in the preceding 6 months, in 2012, pick your time
frame, or else specify the advantage in an absolute fashion]." Or "increase
block size as much as possible, subject to the constraint that 90% of the
nodes on the network are no more than 1 minute behind one of the tails of
the blockchain 99% of the time." Or "do not increase the blocksize until at
least date X." Or "the increase function should be monotonic." And it's
quite OK (and probably likely) to have a combination of these kinds of
metrics and constraints.

For disclosure, I personally do not have a horse in the block size debate,
besides wanting to see Bitcoin evolve and get more widely adopted. I ask
because as an academic, I'd like to understand if we can use various
simulation and analytic techniques to examine the proposals.  A second
reason is that it is very easy to have a proliferation of block size
increase proposals, and good engineering would ask that we define the
meta-criteria first and then pick. To do that, we need some criteria for
judging proposals other than gut feeling.

Of course, even with meta-criteria in hand, there will be room for lots of
disagreement because we do not actually know the future and reasonable
people can disagree on how things will evolve. I think this is good because
it makes it easier to agree on meta-criteria than on an actual, specific
function for increasing the block size.

It looks like some specific meta-level criteria would help more at this
point than new proposals all exploring a different variants of block size
increase schedules.

Best,

- egs


P.S. This message is an off-shoot of this blog post:

http://hackingdistributed.com/2015/11/13/suggestion-for-the-blocksize-debate/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/7a88aa6c/attachment.html>

From luke at dashjr.org  Fri Nov 13 19:37:02 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 13 Nov 2015 19:37:02 +0000
Subject: [bitcoin-dev] BIP proposal - Max block size
In-Reply-To: <5645E095.4050704@startmail.com>
References: <5645E095.4050704@startmail.com>
Message-ID: <201511131937.03430.luke@dashjr.org>

On Friday, November 13, 2015 1:07:33 PM Erik via bitcoin-dev wrote:
> Hi devs. I was discussing the BIP proposals concerning max block size
> yesterday in the #bitcoin channel. I believe that BIP101 fully utilized
> will outperform consumer hardware soon or later and thereby centralize
> Bitcoin. I would therefore like to do a different proposal:

It doesn't look like you've considered BIP103 or newer BIPs? Especially, I'd 
suggest you look at and work with John Sacco who just the other day posted a 
BIP draft very similar-looking to yours. My overall impression of your summary 
is that it is unnecessarily over-complicated and underspecified. How does the 
2^(1/2) block size limit actually work? This is not a very precise number, so 
it seems liable to produce rounding errors in different implementations. 
Additionally, the miner voting thing seems pointless since miners can already 
softfork lower limits. It would be beneficial to express the current 
possibility so full nodes can enforce it, but this would be expressed as an 
unlimited simple-majority vote to reduce the limit. Probably it would be ideal 
to separate this off from the hardfork BIP, since it's fairly tangent to it.

Luke

From xor at freenetproject.org  Fri Nov 13 21:48:34 2015
From: xor at freenetproject.org (xor)
Date: Fri, 13 Nov 2015 22:48:34 +0100
Subject: [bitcoin-dev] Contradiction in BIP65 text?
Message-ID: <1581446.3ZPnhFUSFq@1337h4x0r>

BIP65 [1] says this:
> Motivation
> [...]
> However, the nLockTime field can't prove that it is impossible to spend a
> transaction output until some time in the future, as there is no way to
> know if a valid signature for a different transaction spending that output
> has been created.

I'd interpret "can't prove that it is impossible to spend" = cannot be used 
for freezing funds.

Then later, at "Motivation", it says:
> Freezing Funds
> 
> In addition to using cold storage, hardware wallets, and P2SH multisig
> outputs to control funds, now funds can be frozen in UTXOs directly on the
> blockchain.

This clearly says that funds can be frozen.
Can the BIP65-thing be used to freeze funds or can it not be?

Notice: I am by no means someone who is able to read Bitcoin script. I'm 
rather an end user. So maybe I'm misinterpreting the document?
I'm nevertheless trying to provide a "neutral" review from an outsider who's 
trying to understand whats new in 0.11.2.
You may want to discard my opinion if you think that BIP65 is aimed at an 
audience with more experience.

Greetings and thanks for your work!

[1] 
https://github.com/bitcoin/bips/blob/d0cab0379aa50cdf4a9d1ab9e29c3366034ad77f/bip-0065.mediawiki
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/81565bca/attachment.sig>

From gmaxwell at gmail.com  Fri Nov 13 21:53:57 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Fri, 13 Nov 2015 21:53:57 +0000
Subject: [bitcoin-dev] Contradiction in BIP65 text?
In-Reply-To: <1581446.3ZPnhFUSFq@1337h4x0r>
References: <1581446.3ZPnhFUSFq@1337h4x0r>
Message-ID: <CAAS2fgQaUX92YUcO=WsC4rhkV3OsCXsSk6aJJ9m3V0vKMuC2FA@mail.gmail.com>

On Fri, Nov 13, 2015 at 9:48 PM, xor via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> BIP65 [1] says this:
>> Motivation
>> [...]
>> However, the nLockTime field can't prove that it is impossible to spend a
>> transaction output until some time in the future, as there is no way to
>> know if a valid signature for a different transaction spending that output
>> has been created.
>
> I'd interpret "can't prove that it is impossible to spend" = cannot be used
> for freezing funds.
>
> Then later, at "Motivation", it says:
>> Freezing Funds
>>
>> In addition to using cold storage, hardware wallets, and P2SH multisig
>> outputs to control funds, now funds can be frozen in UTXOs directly on the
>> blockchain.
>
> This clearly says that funds can be frozen.
> Can the BIP65-thing be used to freeze funds or can it not be?
>
> Notice: I am by no means someone who is able to read Bitcoin script. I'm
> rather an end user. So maybe I'm misinterpreting the document?
> I'm nevertheless trying to provide a "neutral" review from an outsider who's
> trying to understand whats new in 0.11.2.
> You may want to discard my opinion if you think that BIP65 is aimed at an
> audience with more experience.


The first text is explaining nlocktime without BIP65 in order to
explain the reason for having BIP65.

From peter.tschipper at gmail.com  Fri Nov 13 21:58:06 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Fri, 13 Nov 2015 13:58:06 -0800
Subject: [bitcoin-dev] Block Compression (Datastream Compression) test
 results using the PR#6973 compression prototype
In-Reply-To: <27BB52F9-3E3F-443D-93BC-B6843EB992F5@toom.im>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<56438A55.2010604@gmail.com>
	<CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>
	<27BB52F9-3E3F-443D-93BC-B6843EB992F5@toom.im>
Message-ID: <56465CEE.6010109@gmail.com>

Some further Block Compression tests results that compare performance
when network latency is added to the mix.

Running two nodes, windows 7, compressionlevel=6, syncing the first
200000 blocks from one node to another.  Running on a highspeed wireless
LAN with no connections to the outside world.
Network latency was added by using Netbalancer to induce the 30ms and
60ms latencies.

>From the data not only are bandwidth savings seen but also a small
performance savings as well.  However, the overall the value in
compressing blocks appears to be in terms of saving bandwidth.  

I was also surprised to see that there was no real difference in
performance when no latency was present; apparently the time it takes to
compress is about equal to the performance savings in such a situation.


The following results compare the tests in terms of how long it takes to
sync the blockchain, compressed vs uncompressed and with varying latencies.
uncmp = uncompressed
cmp = compressed

num blocks sync'd 	uncmp (secs) 	cmp (secs) 	uncmp 30ms (secs) 	cmp 30ms
(secs) 	uncmp 60ms (secs) 	cmp 60ms (secs)
10000 	264 	269 	265 	257 	274 	275
20000 	482 	492 	479 	467 	499 	497
30000 	703 	717 	693 	676 	724 	724
40000 	918 	939 	902 	886 	947 	944
50000 	1140 	1157 	1114 	1094 	1171 	1167
60000 	1362 	1380 	1329 	1310 	1400 	1395
70000 	1583 	1597 	1547 	1526 	1637 	1627
80000 	1810 	1817 	1767 	1745 	1872 	1862
90000 	2031 	2036 	1985 	1958 	2109 	2098
100000 	2257 	2260 	2223 	2184 	2385 	2355
110000 	2553 	2486 	2478 	2422 	2755 	2696
120000 	2800 	2724 	2849 	2771 	3345 	3254
130000 	3078 	2994 	3356 	3257 	4125 	4006
140000 	3442 	3365 	3979 	3870 	5032 	4904
150000 	3803 	3729 	4586 	4464 	5928 	5797
160000 	4148 	4075 	5168 	5034 	6801 	6661
170000 	4509 	4479 	5768 	5619 	7711 	7557
180000 	4947 	4924 	6389 	6227 	8653 	8479
190000 	5858 	5855 	7302 	7107 	9768 	9566
200000 	6980 	6969 	8469 	8220 	10944 	10724


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/885c94a1/attachment-0001.html>

From luke at dashjr.org  Fri Nov 13 22:28:46 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 13 Nov 2015 22:28:46 +0000
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
	with max block size of 32M
In-Reply-To: <1447430469019.e0ee1956@Nodemailer>
References: <201511131052.58623.luke@dashjr.org>
	<1447430469019.e0ee1956@Nodemailer>
Message-ID: <201511132228.47815.luke@dashjr.org>

On Friday, November 13, 2015 4:01:09 PM digitsu at gmail.com wrote:
> Forgive the frankness but I don't see why signaling your intent to support
> an upgrade to one side of a hard fork can be seen as a bad thing.  If for
> nothing else doesn't this make for a smoother flag day? (Because once you
> signal your intention, it makes it hard to back out on the commitment.)

It isn't a commitment in any sense, nor does it make it smoother, because for 
a hardfork to be successful, it is the *economy* that must switch entirely. 
The miners are unimportant.

> If miners don't have any choice in hard forks, who does? Just the core
> devs? 

Devs have even less of a choice in the matter. What is relevant is the 
economy: who do people want to spend their bitcoins with? There is no 
programmatic way to determine this, especially not in advance, so the best we 
can do is a flag day that gets called off if there isn't clear consensus.

Luke

From jgarzik at gmail.com  Fri Nov 13 23:58:07 2015
From: jgarzik at gmail.com (Jeff Garzik)
Date: Fri, 13 Nov 2015 18:58:07 -0500
Subject: [bitcoin-dev] Contradiction in BIP65 text?
In-Reply-To: <1581446.3ZPnhFUSFq@1337h4x0r>
References: <1581446.3ZPnhFUSFq@1337h4x0r>
Message-ID: <CADm_WcZnOXqcse1LC28ptLyxXJTtbv+RPMfrMamR4xZK3xcK8Q@mail.gmail.com>

On Fri, Nov 13, 2015 at 4:48 PM, xor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This clearly says that funds can be frozen.
> Can the BIP65-thing be used to freeze funds or can it not be?
>


This language definitely trips up or worries several folks - it's been
mentioned a few times before.

The user _chooses_ to freeze _their own_ funds.  It is not an unwilling act
of force, which many assume when they see the phrase "freeze funds."
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/2a23202a/attachment.html>

From gmaxwell at gmail.com  Sat Nov 14 00:29:51 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sat, 14 Nov 2015 00:29:51 +0000
Subject: [bitcoin-dev] Contradiction in BIP65 text?
In-Reply-To: <CADm_WcZnOXqcse1LC28ptLyxXJTtbv+RPMfrMamR4xZK3xcK8Q@mail.gmail.com>
References: <1581446.3ZPnhFUSFq@1337h4x0r>
	<CADm_WcZnOXqcse1LC28ptLyxXJTtbv+RPMfrMamR4xZK3xcK8Q@mail.gmail.com>
Message-ID: <CAAS2fgR1RcteCd-RZzi1bUjEsFRVi7DduDBiUkg6+RgHzuL+-Q@mail.gmail.com>

On Fri, Nov 13, 2015 at 11:58 PM, Jeff Garzik via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Fri, Nov 13, 2015 at 4:48 PM, xor via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> This clearly says that funds can be frozen.
>> Can the BIP65-thing be used to freeze funds or can it not be?
> This language definitely trips up or worries several folks - it's been
> mentioned a few times before.
>
> The user _chooses_ to freeze _their own_ funds.  It is not an unwilling act
> of force, which many assume when they see the phrase "freeze funds."


The most frequent related point of confusion I see is that people have
a dangerously wrong mental model of how scrpitpubkeys work.

It seems people think that wallets will infer whatever they can
possibly spend and display that.  This is not how wallets work, and if
any wallet were ever created like that its users would immediately go
broke (and it's author should be taken out and shot. :) ).

Rather, wallets must only display funds paid to scriptpubkeys (also
addresses) they actually generated or, at least, would have generated.

Otherwise someone can just create a 1 of 2 {them, you}  multisig and
then claw back the coins after you think you've been paid.

As such there is no risk of anyone sneaking in CLTV locked funds for
on you except by virtue of spectacular software bugs that would likely
cause you to destroy funds in a zillion other ways first.

From dscotese at litmocracy.com  Sat Nov 14 02:10:29 2015
From: dscotese at litmocracy.com (Dave Scotese)
Date: Fri, 13 Nov 2015 18:10:29 -0800
Subject: [bitcoin-dev] Bitcoin Core 0.11.2 released
In-Reply-To: <20151113131353.GA26622@amethyst.visucore.com>
References: <20151113131353.GA26622@amethyst.visucore.com>
Message-ID: <CAGLBAhcMMLnze8N=OLK0EypatRKEhFkHTJDo_KJyc_A1h1d-uA@mail.gmail.com>

I decided to try to certify Wladimir's PGP keys (the old one (2346C9A6)
first, and then the new one (36C2E964), since it was signed with the old
one).

I visited
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/009045.html
to see that the new key was referenced in a message signed by the old one.
I figure it's safe to assume that if the old key actually signed that
message, then the core dev using <laanwj at gmail.com
<https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>> is an
actual core dev (that's all I'd be worried about).  So I copied the text
from ------BEGIN PGP SIGNED MESSAGE----- to -----END PGP SIGNATURE----- to
my clipboard and asked Kleopatra (on Windows) to verify it.  It says the
signature is bad.  If I alter the text of the email (so the signature would
be have to be different to be valid), it says exactly the same thing.  So
maybe something is wrong with Kleopatra on Windows.

However, the SHA256SUMS.asc file I got from the magnet link posted in the
email (below)  verifies just fine using the new key (36C2E964).  So I
figure Kleopatra is not broken.  It recognizes that the old key was used to
create the signature in that old email, but it says it's invalid.  Has
Wladimir been secretly replaced by someone who doesn't have access to the
private key for 2346C9A6?  Can you make a (bad) signature look like it was
made using a key you don't have? The whole reason for signing is so that we
will know if something like that happened.  So did I do something wrong?
(I mean, besides using Windows).

I believe this is the expected result if someone took something Wladimir
signed and ripped off the signature and pasted it below this new message to
make everyone think the new message was genuine.  Maybe Wladimir made an
edit after the signature was attached.  Or maybe it got changed when it
went through the email system.  It would be nice to know.  Anyway, I fell
back on Windows security and ran the install because it said it verified
that the publisher was "The Bitcoin Foundation".


On Fri, Nov 13, 2015 at 5:13 AM, Wladimir J. van der Laan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA512
>
> Bitcoin Core version 0.11.2 is now available from:
>
>   <https://bitcoin.org/bin/bitcoin-core-0.11.2/>
>
> Alternatively, through bittorrent:
>
>
> magnet:?xt=urn:btih:d6d3387160f7e14f6f27dc40ae84cf566ebf631b&dn=bitcoin-core-0.11.2&tr=udp%3A%2F%
> 2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%
> 2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de
> %3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk
> %3A6969&tr=udp%3A%2F%2Fopen.demonii.com
> %3A1337&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F
>
> This is a new minor version release, bringing bug fixes, the BIP65
> (CLTV) consensus change, and relay policy preparation for BIP113. It is
> recommended to upgrade to this version as soon as possible.
>
> Please report bugs using the issue tracker at github:
>
>   <https://github.com/bitcoin/bitcoin/issues>
>
> Upgrading and downgrading
> =========================
>
> How to Upgrade
> - --------------
>
> If you are running an older version, shut it down. Wait until it has
> completely
> shut down (which might take a few minutes for older versions), then run the
> installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac)
> or
> bitcoind/bitcoin-qt (on Linux).
>
> Downgrade warning
> - ------------------
>
> Because release 0.10.0 and later makes use of headers-first
> synchronization and
> parallel block download (see further), the block files and databases are
> not
> backwards-compatible with pre-0.10 versions of Bitcoin Core or other
> software:
>
> * Blocks will be stored on disk out of order (in the order they are
> received, really), which makes it incompatible with some tools or
> other programs. Reindexing using earlier versions will also not work
> anymore as a result of this.
>
> * The block index database will now hold headers for which no block is
> stored on disk, which earlier versions won't support.
>
> If you want to be able to downgrade smoothly, make a backup of your entire
> data
> directory. Without this your node will need start syncing (or importing
> from
> bootstrap.dat) anew afterwards. It is possible that the data from a
> completely
> synchronised 0.10 node may be usable in older versions as-is, but this is
> not
> supported and may break as soon as the older version attempts to reindex.
>
> This does not affect wallet forward or backward compatibility. There are no
> known problems when downgrading from 0.11.x to 0.10.x.
>
> Notable changes since 0.11.1
> ============================
>
> BIP65 soft fork to enforce OP_CHECKLOCKTIMEVERIFY opcode
> - --------------------------------------------------------
>
> This release includes several changes related to the [BIP65][] soft fork
> which redefines the existing OP_NOP2 opcode as OP_CHECKLOCKTIMEVERIFY
> (CLTV) so that a transaction output can be made unspendable until a
> specified point in the future.
>
> 1. This release will only relay and mine transactions spending a CLTV
>    output if they comply with the BIP65 rules as provided in code.
>
> 2. This release will produce version 4 blocks by default. Please see the
>    *notice to miners* below.
>
> 3. Once 951 out of a sequence of 1,001 blocks on the local node's best
> block
>    chain contain version 4 (or higher) blocks, this release will no
>    longer accept new version 3 blocks and it will only accept version 4
>    blocks if they comply with the BIP65 rules for CLTV.
>
> For more information about the soft-forking change, please see
> <https://github.com/bitcoin/bitcoin/pull/6351>
>
> Graphs showing the progress towards block version 4 adoption may be
> found at the URLs below:
>
> - - Block versions over the last 50,000 blocks as progress towards BIP65
>   consensus enforcement: <http://bitcoin.sipa.be/ver-50k.png>
>
> - - Block versions over the last 2,000 blocks showing the days to the
>   earliest possible BIP65 consensus-enforced block: <
> http://bitcoin.sipa.be/ver-2k.png>
>
> **Notice to miners:** Bitcoin Core?s block templates are now for
> version 4 blocks only, and any mining software relying on its
> getblocktemplate must be updated in parallel to use libblkmaker either
> version 0.4.3 or any version from 0.5.2 onward.
>
> - - If you are solo mining, this will affect you the moment you upgrade
>   Bitcoin Core, which must be done prior to BIP65 achieving its 951/1001
>   status.
>
> - - If you are mining with the stratum mining protocol: this does not
>   affect you.
>
> - - If you are mining with the getblocktemplate protocol to a pool: this
>   will affect you at the pool operator?s discretion, which must be no
>   later than BIP65 achieving its 951/1001 status.
>
> [BIP65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
>
> BIP113 mempool-only locktime enforcement using GetMedianTimePast()
> - ----------------------------------------------------------------
>
> Bitcoin transactions currently may specify a locktime indicating when
> they may be added to a valid block.  Current consensus rules require
> that blocks have a block header time greater than the locktime specified
> in any transaction in that block.
>
> Miners get to choose what time they use for their header time, with the
> consensus rule being that no node will accept a block whose time is more
> than two hours in the future.  This creates a incentive for miners to
> set their header times to future values in order to include locktimed
> transactions which weren't supposed to be included for up to two more
> hours.
>
> The consensus rules also specify that valid blocks may have a header
> time greater than that of the median of the 11 previous blocks.  This
> GetMedianTimePast() time has a key feature we generally associate with
> time: it can't go backwards.
>
> [BIP113][] specifies a soft fork (**not enforced in this release**) that
> weakens this perverse incentive for individual miners to use a future
> time by requiring that valid blocks have a computed GetMedianTimePast()
> greater than the locktime specified in any transaction in that block.
>
> Mempool inclusion rules currently require transactions to be valid for
> immediate inclusion in a block in order to be accepted into the mempool.
> This release begins applying the BIP113 rule to received transactions,
> so transaction whose time is greater than the GetMedianTimePast() will
> no longer be accepted into the mempool.
>
> **Implication for miners:** you will begin rejecting transactions that
> would not be valid under BIP113, which will prevent you from producing
> invalid blocks if/when BIP113 is enforced on the network. Any
> transactions which are valid under the current rules but not yet valid
> under the BIP113 rules will either be mined by other miners or delayed
> until they are valid under BIP113. Note, however, that time-based
> locktime transactions are more or less unseen on the network currently.
>
> **Implication for users:** GetMedianTimePast() always trails behind the
> current time, so a transaction locktime set to the present time will be
> rejected by nodes running this release until the median time moves
> forward. To compensate, subtract one hour (3,600 seconds) from your
> locktimes to allow those transactions to be included in mempools at
> approximately the expected time.
>
> [BIP113]: https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki
>
> Windows bug fix for corrupted UTXO database on unclean shutdowns
> - ----------------------------------------------------------------
>
> Several Windows users reported that they often need to reindex the
> entire blockchain after an unclean shutdown of Bitcoin Core on Windows
> (or an unclean shutdown of Windows itself). Although unclean shutdowns
> remain unsafe, this release no longer relies on memory-mapped files for
> the UTXO database, which significantly reduced the frequency of unclean
> shutdowns leading to required reindexes during testing.
>
> For more information, see: <https://github.com/bitcoin/bitcoin/pull/6917>
>
> Other fixes for database corruption on Windows are expected in the
> next major release.
>
> 0.11.2 Change log
> =================
>
> Detailed release notes follow. This overview includes changes that affect
> behavior, not code moves, refactors and string updates. For convenience in
> locating
> the code changes and accompanying discussion, both the pull request and
> git merge commit are mentioned.
>
> - - #6124 `684636b` Make CScriptNum() take nMaxNumSize as an argument
> - - #6124 `4fa7a04` Replace NOP2 with CHECKLOCKTIMEVERIFY (BIP65)
> - - #6124 `6ea5ca4` Enable CHECKLOCKTIMEVERIFY as a standard script verify
> flag
> - - #6351 `5e82e1c` Add CHECKLOCKTIMEVERIFY (BIP65) soft-fork logic
> - - #6353 `ba1da90` Show softfork status in getblockchaininfo
> - - #6351 `6af25b0` Add BIP65 to getblockchaininfo softforks list
> - - #6688 `01878c9` Fix locking in GetTransaction
> - - #6653 `b3eaa30` [Qt] Raise debug window when requested
> - - #6600 `1e672ae` Debian/Ubuntu: Include bitcoin-tx binary
> - - #6600 `2394f4d` Debian/Ubuntu: Split bitcoin-tx into its own package
> - - #5987 `33d6825` Bugfix: Allow mining on top of old tip blocks for
> testnet
> - - #6852 `21e58b8` build: make sure OpenSSL heeds noexecstack
> - - #6846 `af6edac` alias `-h` for `--help`
> - - #6867 `95a5039` Set TCP_NODELAY on P2P sockets.
> - - #6856 `dfe55bd` Do not allow blockfile pruning during reindex.
> - - #6566 `a1d3c6f` Add rules--presently disabled--for using
> GetMedianTimePast as end point for lock-time calculations
> - - #6566 `f720c5f` Enable policy enforcing GetMedianTimePast as the end
> point of lock-time constraints
> - - #6917 `0af5b8e` leveldb: Win32WritableFile without memory mapping
> - - #6948 `4e895b0` Always flush block and undo when switching to new file
>
> Credits
> =======
>
> Thanks to everyone who directly contributed to this release:
>
> - - Alex Morcos
> - - ?tcDrak
> - - Chris Kleeschulte
> - - Daniel Cousens
> - - Diego Viola
> - - Eric Lombrozo
> - - Esteban Ordano
> - - Gregory Maxwell
> - - Luke Dashjr
> - - Marco Falke
> - - Mark Friedenbach
> - - Matt Corallo
> - - Micha
> - - Mitchell Cash
> - - Peter Todd
> - - Pieter Wuille
> - - Wladimir J. van der Laan
> - - Zak Wilcox
>
> And those who contributed additional code review and/or security research.
>
> As well as everyone that helped translating on [Transifex](
> https://www.transifex.com/projects/p/bitcoin/).
>
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v1
>
> iQEcBAEBCgAGBQJWReHOAAoJEHSBCwEjRsmmTAAH/iZQGklLHLIM6a2tTOj4d/O6
> xHg5bJhXGjtzO284Uy3phTzvk+e4mqBTjI8BrSr4D+Vw7mJrfWihdTLlgZYCwso3
> AyAk8ud1H42QanAfUvciY5uXd7cyzr8tCnCIBkvwJT5O8tI3FFhSMM5Fs86WnsP1
> Y10+93sxaVJUave2xm1bmgiwApFZKQ2MNU1IVgFaW8agB59fuqtPRnBdKiK/j+AO
> Jn1LKsObsINYhjtkAFiC66mUOBZ2N3rdhbN3LFl+u7EriTLoYk1OtZZhlC+rOueo
> nxl1H5SHStjrD27vE9Hv2qD5Ckrwo3zib8hZNIVs6MJjFnWUCwNtNg0nqDEvpn4=
> =xXdY
> -----END PGP SIGNATURE-----
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/debf1563/attachment-0001.html>

From lf-lists at mattcorallo.com  Sat Nov 14 04:11:01 2015
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Sat, 14 Nov 2015 04:11:01 +0000
Subject: [bitcoin-dev] Bitcoin Core 0.11.2 released
In-Reply-To: <5646B367.2090305@mattcorallo.com>
References: <20151113131353.GA26622@amethyst.visucore.com>
	<CAGLBAhcMMLnze8N=OLK0EypatRKEhFkHTJDo_KJyc_A1h1d-uA@mail.gmail.com>
	<5646B367.2090305@mattcorallo.com>
Message-ID: <5646B455.1090900@mattcorallo.com>

Heh, though mine doesnt since I mangled the line breaks...that should
have been...

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Strange, the signature validates for me. If I copy the entire mail
(including the signature and PGP armor, but not the ads) I see the hash
of the mail as
b3bbd0fcfcea5f4eb5b49e9c2d7ed7514259f004fbdb5930c92084d6de561238.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBCAAGBQJWRrNYAAoJEGOJ097IOJ+hTg0P/2H5DRaG1Gd8k72VPT/DiNHP
e8Al19f3FXIaGSiiJ2CC6Tx3d/13U8SOnbqC28vWDpCn6TR+aw7QMoLy2huyivSp
kTuboqtTVgyt2JbwmXQHrxHIHiW70Xa/dP0sfZlQKjI47RO/gBG8ccRuIyEPgVAi
ag7bT74hL7/C1BuEB+wA9E+b8lnCjr/rFjVKp0mSzp1/5qOCnoddUatQU4zNnE6E
WNKj+qGekqDLPzzfMH/VrE9XX0GVaQcFG2cSBSqVOL6WQHj6cqh2z7MXl1aWMkEt
X+GYVIYJw3UUikKKsHPdNqoVRHYAmrg7OVmrYXuL4JDOneJYnihTKj7O2bFy8tBz
eDIBuqjyG8RTvNvouKCYMN89ePt1P53B0zDK9o6aQDUIkT/2a6RAdUUUencrN812
Bc5E2EEbfdEn4wFeAgLAXLZ5KFFGMlEXC8ceswQHzONnXzy6UkK0D9MexvxEZnMm
6s3N1XBbB2Xqw04JfQ6k5r0ywV3yu1JmG0AoPuluA3xZkID2izMuSGQU2Vji/xdH
ByeeRBYMFLeTbVIIi8I5v19ThQ+j7MR7VK8A8tt3GIjNSL3grNABOlRPb7mDDIyB
oMnc48XBaRn3Rsdn3wwbmhvRGF2A5fDZ+APldVy89TNgtUXPMTlholCzY9ekiniA
lVAHrXea2CpzbH6In7GK
=dQCp
-----END PGP SIGNATURE-----



On 11/14/15 04:07, Matt Corallo wrote:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA256
>
> Strange, the signature validates for me. If I copy the entire mail
> (including the signature and PGP armor, but not the ads) I see the hash
> of the mail as
> b3bbd0fcfcea5f4eb5b49e9c2d7ed7514259f004fbdb5930c92084d6de561238.
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v2
> 
> iQIcBAEBCAAGBQJWRrNYAAoJEGOJ097IOJ+hTg0P/2H5DRaG1Gd8k72VPT/DiNHP
> e8Al19f3FXIaGSiiJ2CC6Tx3d/13U8SOnbqC28vWDpCn6TR+aw7QMoLy2huyivSp
> kTuboqtTVgyt2JbwmXQHrxHIHiW70Xa/dP0sfZlQKjI47RO/gBG8ccRuIyEPgVAi
> ag7bT74hL7/C1BuEB+wA9E+b8lnCjr/rFjVKp0mSzp1/5qOCnoddUatQU4zNnE6E
> WNKj+qGekqDLPzzfMH/VrE9XX0GVaQcFG2cSBSqVOL6WQHj6cqh2z7MXl1aWMkEt
> X+GYVIYJw3UUikKKsHPdNqoVRHYAmrg7OVmrYXuL4JDOneJYnihTKj7O2bFy8tBz
> eDIBuqjyG8RTvNvouKCYMN89ePt1P53B0zDK9o6aQDUIkT/2a6RAdUUUencrN812
> Bc5E2EEbfdEn4wFeAgLAXLZ5KFFGMlEXC8ceswQHzONnXzy6UkK0D9MexvxEZnMm
> 6s3N1XBbB2Xqw04JfQ6k5r0ywV3yu1JmG0AoPuluA3xZkID2izMuSGQU2Vji/xdH
> ByeeRBYMFLeTbVIIi8I5v19ThQ+j7MR7VK8A8tt3GIjNSL3grNABOlRPb7mDDIyB
> oMnc48XBaRn3Rsdn3wwbmhvRGF2A5fDZ+APldVy89TNgtUXPMTlholCzY9ekiniA
> lVAHrXea2CpzbH6In7GK
> =dQCp
> -----END PGP SIGNATURE-----
> 
> 
> On 11/14/15 02:10, Dave Scotese via bitcoin-dev wrote:
>> I decided to try to certify Wladimir's PGP keys (the old one (2346C9A6)
>> first, and then the new one (36C2E964), since it was signed with the old
>> one).
>>
>> I visited
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/009045.html
>> to see that the new key was referenced in a message signed by the old
>> one.  I figure it's safe to assume that if the old key actually signed
>> that message, then the core dev using <laanwj at gmail.com
>> <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>> is an
>> actual core dev (that's all I'd be worried about).  So I copied the text
>> from ------BEGIN PGP SIGNED MESSAGE----- to -----END PGP SIGNATURE-----
>> to my clipboard and asked Kleopatra (on Windows) to verify it.  It says
>> the signature is bad.  If I alter the text of the email (so the
>> signature would be have to be different to be valid), it says exactly
>> the same thing.  So maybe something is wrong with Kleopatra on Windows.
>>
>> However, the SHA256SUMS.asc file I got from the magnet link posted in
>> the email (below)  verifies just fine using the new key (36C2E964).  So
>> I figure Kleopatra is not broken.  It recognizes that the old key was
>> used to create the signature in that old email, but it says it's
>> invalid.  Has Wladimir been secretly replaced by someone who doesn't
>> have access to the private key for 2346C9A6?  Can you make a (bad)
>> signature look like it was made using a key you don't have? The whole
>> reason for signing is so that we will know if something like that
>> happened.  So did I do something wrong?  (I mean, besides using Windows).
>>
>> I believe this is the expected result if someone took something Wladimir
>> signed and ripped off the signature and pasted it below this new message
>> to make everyone think the new message was genuine.  Maybe Wladimir made
>> an edit after the signature was attached.  Or maybe it got changed when
>> it went through the email system.  It would be nice to know.  Anyway, I
>> fell back on Windows security and ran the install because it said it
>> verified that the publisher was "The Bitcoin Foundation".
>>
>>
>> On Fri, Nov 13, 2015 at 5:13 AM, Wladimir J. van der Laan via
>> bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>     -----BEGIN PGP SIGNED MESSAGE-----
>>     Hash: SHA512
>>
>>     Bitcoin Core version 0.11.2 is now available from:
>>
>>       <https://bitcoin.org/bin/bitcoin-core-0.11.2/>
>>
>>     Alternatively, through bittorrent:
>>
>>        
>>     magnet:?xt=urn:btih:d6d3387160f7e14f6f27dc40ae84cf566ebf631b&dn=bitcoin-core-0.11.2&tr=udp%3A%2F%2Ftracker.openbittorrent.com
>>     <http://2Ftracker.openbittorrent.com>%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.publicbt.com
>>     <http://2Ftracker.publicbt.com>%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de
>>     <http://2Ftracker.ccc.de>%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk
>>     <http://2Ftracker.coppersurfer.tk>%3A6969&tr=udp%3A%2F%2Fopen.demonii.com
>>     <http://2Fopen.demonii.com>%3A1337&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F
>>
>>     This is a new minor version release, bringing bug fixes, the BIP65
>>     (CLTV) consensus change, and relay policy preparation for BIP113. It is
>>     recommended to upgrade to this version as soon as possible.
>>
>>     Please report bugs using the issue tracker at github:
>>
>>       <https://github.com/bitcoin/bitcoin/issues>
>>
>>     Upgrading and downgrading
>>     =========================
>>
>>     How to Upgrade
>>     - --------------
>>
>>     If you are running an older version, shut it down. Wait until it has
>>     completely
>>     shut down (which might take a few minutes for older versions), then
>>     run the
>>     installer (on Windows) or just copy over /Applications/Bitcoin-Qt
>>     (on Mac) or
>>     bitcoind/bitcoin-qt (on Linux).
>>
>>     Downgrade warning
>>     - ------------------
>>
>>     Because release 0.10.0 and later makes use of headers-first
>>     synchronization and
>>     parallel block download (see further), the block files and databases
>>     are not
>>     backwards-compatible with pre-0.10 versions of Bitcoin Core or other
>>     software:
>>
>>     * Blocks will be stored on disk out of order (in the order they are
>>     received, really), which makes it incompatible with some tools or
>>     other programs. Reindexing using earlier versions will also not work
>>     anymore as a result of this.
>>
>>     * The block index database will now hold headers for which no block is
>>     stored on disk, which earlier versions won't support.
>>
>>     If you want to be able to downgrade smoothly, make a backup of your
>>     entire data
>>     directory. Without this your node will need start syncing (or
>>     importing from
>>     bootstrap.dat) anew afterwards. It is possible that the data from a
>>     completely
>>     synchronised 0.10 node may be usable in older versions as-is, but
>>     this is not
>>     supported and may break as soon as the older version attempts to
>>     reindex.
>>
>>     This does not affect wallet forward or backward compatibility. There
>>     are no
>>     known problems when downgrading from 0.11.x to 0.10.x.
>>
>>     Notable changes since 0.11.1
>>     ============================
>>
>>     BIP65 soft fork to enforce OP_CHECKLOCKTIMEVERIFY opcode
>>     - --------------------------------------------------------
>>
>>     This release includes several changes related to the [BIP65][] soft fork
>>     which redefines the existing OP_NOP2 opcode as OP_CHECKLOCKTIMEVERIFY
>>     (CLTV) so that a transaction output can be made unspendable until a
>>     specified point in the future.
>>
>>     1. This release will only relay and mine transactions spending a CLTV
>>        output if they comply with the BIP65 rules as provided in code.
>>
>>     2. This release will produce version 4 blocks by default. Please see the
>>        *notice to miners* below.
>>
>>     3. Once 951 out of a sequence of 1,001 blocks on the local node's
>>     best block
>>        chain contain version 4 (or higher) blocks, this release will no
>>        longer accept new version 3 blocks and it will only accept version 4
>>        blocks if they comply with the BIP65 rules for CLTV.
>>
>>     For more information about the soft-forking change, please see
>>     <https://github.com/bitcoin/bitcoin/pull/6351>
>>
>>     Graphs showing the progress towards block version 4 adoption may be
>>     found at the URLs below:
>>
>>     - - Block versions over the last 50,000 blocks as progress towards BIP65
>>       consensus enforcement: <http://bitcoin.sipa.be/ver-50k.png>
>>
>>     - - Block versions over the last 2,000 blocks showing the days to the
>>       earliest possible BIP65 consensus-enforced block:
>>     <http://bitcoin.sipa.be/ver-2k.png>
>>
>>     **Notice to miners:** Bitcoin Core?s block templates are now for
>>     version 4 blocks only, and any mining software relying on its
>>     getblocktemplate must be updated in parallel to use libblkmaker either
>>     version 0.4.3 or any version from 0.5.2 onward.
>>
>>     - - If you are solo mining, this will affect you the moment you upgrade
>>       Bitcoin Core, which must be done prior to BIP65 achieving its 951/1001
>>       status.
>>
>>     - - If you are mining with the stratum mining protocol: this does not
>>       affect you.
>>
>>     - - If you are mining with the getblocktemplate protocol to a pool: this
>>       will affect you at the pool operator?s discretion, which must be no
>>       later than BIP65 achieving its 951/1001 status.
>>
>>     [BIP65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
>>
>>     BIP113 mempool-only locktime enforcement using GetMedianTimePast()
>>     - ----------------------------------------------------------------
>>
>>     Bitcoin transactions currently may specify a locktime indicating when
>>     they may be added to a valid block.  Current consensus rules require
>>     that blocks have a block header time greater than the locktime specified
>>     in any transaction in that block.
>>
>>     Miners get to choose what time they use for their header time, with the
>>     consensus rule being that no node will accept a block whose time is more
>>     than two hours in the future.  This creates a incentive for miners to
>>     set their header times to future values in order to include locktimed
>>     transactions which weren't supposed to be included for up to two more
>>     hours.
>>
>>     The consensus rules also specify that valid blocks may have a header
>>     time greater than that of the median of the 11 previous blocks.  This
>>     GetMedianTimePast() time has a key feature we generally associate with
>>     time: it can't go backwards.
>>
>>     [BIP113][] specifies a soft fork (**not enforced in this release**) that
>>     weakens this perverse incentive for individual miners to use a future
>>     time by requiring that valid blocks have a computed GetMedianTimePast()
>>     greater than the locktime specified in any transaction in that block.
>>
>>     Mempool inclusion rules currently require transactions to be valid for
>>     immediate inclusion in a block in order to be accepted into the mempool.
>>     This release begins applying the BIP113 rule to received transactions,
>>     so transaction whose time is greater than the GetMedianTimePast() will
>>     no longer be accepted into the mempool.
>>
>>     **Implication for miners:** you will begin rejecting transactions that
>>     would not be valid under BIP113, which will prevent you from producing
>>     invalid blocks if/when BIP113 is enforced on the network. Any
>>     transactions which are valid under the current rules but not yet valid
>>     under the BIP113 rules will either be mined by other miners or delayed
>>     until they are valid under BIP113. Note, however, that time-based
>>     locktime transactions are more or less unseen on the network currently.
>>
>>     **Implication for users:** GetMedianTimePast() always trails behind the
>>     current time, so a transaction locktime set to the present time will be
>>     rejected by nodes running this release until the median time moves
>>     forward. To compensate, subtract one hour (3,600 seconds) from your
>>     locktimes to allow those transactions to be included in mempools at
>>     approximately the expected time.
>>
>>     [BIP113]: https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki
>>
>>     Windows bug fix for corrupted UTXO database on unclean shutdowns
>>     - ----------------------------------------------------------------
>>
>>     Several Windows users reported that they often need to reindex the
>>     entire blockchain after an unclean shutdown of Bitcoin Core on Windows
>>     (or an unclean shutdown of Windows itself). Although unclean shutdowns
>>     remain unsafe, this release no longer relies on memory-mapped files for
>>     the UTXO database, which significantly reduced the frequency of unclean
>>     shutdowns leading to required reindexes during testing.
>>
>>     For more information, see:
>>     <https://github.com/bitcoin/bitcoin/pull/6917>
>>
>>     Other fixes for database corruption on Windows are expected in the
>>     next major release.
>>
>>     0.11.2 Change log
>>     =================
>>
>>     Detailed release notes follow. This overview includes changes that
>>     affect
>>     behavior, not code moves, refactors and string updates. For
>>     convenience in locating
>>     the code changes and accompanying discussion, both the pull request and
>>     git merge commit are mentioned.
>>
>>     - - #6124 `684636b` Make CScriptNum() take nMaxNumSize as an argument
>>     - - #6124 `4fa7a04` Replace NOP2 with CHECKLOCKTIMEVERIFY (BIP65)
>>     - - #6124 `6ea5ca4` Enable CHECKLOCKTIMEVERIFY as a standard script
>>     verify flag
>>     - - #6351 `5e82e1c` Add CHECKLOCKTIMEVERIFY (BIP65) soft-fork logic
>>     - - #6353 `ba1da90` Show softfork status in getblockchaininfo
>>     - - #6351 `6af25b0` Add BIP65 to getblockchaininfo softforks list
>>     - - #6688 `01878c9` Fix locking in GetTransaction
>>     - - #6653 `b3eaa30` [Qt] Raise debug window when requested
>>     - - #6600 `1e672ae` Debian/Ubuntu: Include bitcoin-tx binary
>>     - - #6600 `2394f4d` Debian/Ubuntu: Split bitcoin-tx into its own package
>>     - - #5987 `33d6825` Bugfix: Allow mining on top of old tip blocks
>>     for testnet
>>     - - #6852 `21e58b8` build: make sure OpenSSL heeds noexecstack
>>     - - #6846 `af6edac` alias `-h` for `--help`
>>     - - #6867 `95a5039` Set TCP_NODELAY on P2P sockets.
>>     - - #6856 `dfe55bd` Do not allow blockfile pruning during reindex.
>>     - - #6566 `a1d3c6f` Add rules--presently disabled--for using
>>     GetMedianTimePast as end point for lock-time calculations
>>     - - #6566 `f720c5f` Enable policy enforcing GetMedianTimePast as the
>>     end point of lock-time constraints
>>     - - #6917 `0af5b8e` leveldb: Win32WritableFile without memory mapping
>>     - - #6948 `4e895b0` Always flush block and undo when switching to
>>     new file
>>
>>     Credits
>>     =======
>>
>>     Thanks to everyone who directly contributed to this release:
>>
>>     - - Alex Morcos
>>     - - ?tcDrak
>>     - - Chris Kleeschulte
>>     - - Daniel Cousens
>>     - - Diego Viola
>>     - - Eric Lombrozo
>>     - - Esteban Ordano
>>     - - Gregory Maxwell
>>     - - Luke Dashjr
>>     - - Marco Falke
>>     - - Mark Friedenbach
>>     - - Matt Corallo
>>     - - Micha
>>     - - Mitchell Cash
>>     - - Peter Todd
>>     - - Pieter Wuille
>>     - - Wladimir J. van der Laan
>>     - - Zak Wilcox
>>
>>     And those who contributed additional code review and/or security
>>     research.
>>
>>     As well as everyone that helped translating on
>>     [Transifex](https://www.transifex.com/projects/p/bitcoin/).
>>
>>     -----BEGIN PGP SIGNATURE-----
>>     Version: GnuPG v1
>>
>>     iQEcBAEBCgAGBQJWReHOAAoJEHSBCwEjRsmmTAAH/iZQGklLHLIM6a2tTOj4d/O6
>>     xHg5bJhXGjtzO284Uy3phTzvk+e4mqBTjI8BrSr4D+Vw7mJrfWihdTLlgZYCwso3
>>     AyAk8ud1H42QanAfUvciY5uXd7cyzr8tCnCIBkvwJT5O8tI3FFhSMM5Fs86WnsP1
>>     Y10+93sxaVJUave2xm1bmgiwApFZKQ2MNU1IVgFaW8agB59fuqtPRnBdKiK/j+AO
>>     Jn1LKsObsINYhjtkAFiC66mUOBZ2N3rdhbN3LFl+u7EriTLoYk1OtZZhlC+rOueo
>>     nxl1H5SHStjrD27vE9Hv2qD5Ckrwo3zib8hZNIVs6MJjFnWUCwNtNg0nqDEvpn4=
>>     =xXdY
>>     -----END PGP SIGNATURE-----
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>> -- 
>> I like to provide some work at no charge to prove my value. Do you need
>> a techie? 
>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
>> <http://www.memeracing.net> (in alpha).
>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
>> which now accepts Bitcoin.
>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
>> "He ought to find it more profitable to play by the rules" - Satoshi
>> Nakamoto
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>

From xor at freenetproject.org  Fri Nov 13 22:08:55 2015
From: xor at freenetproject.org (xor)
Date: Fri, 13 Nov 2015 23:08:55 +0100
Subject: [bitcoin-dev] Contradiction in BIP65 text?
In-Reply-To: <CAAS2fgQaUX92YUcO=WsC4rhkV3OsCXsSk6aJJ9m3V0vKMuC2FA@mail.gmail.com>
References: <1581446.3ZPnhFUSFq@1337h4x0r>
	<CAAS2fgQaUX92YUcO=WsC4rhkV3OsCXsSk6aJJ9m3V0vKMuC2FA@mail.gmail.com>
Message-ID: <11064196.Mmtap3aOyl@1337h4x0r>

On Friday, November 13, 2015 09:53:57 PM Gregory Maxwell wrote:
> The first text is explaining nlocktime without BIP65 in order to
> explain the reason for having BIP65.

Thanks. I would recommend changing the BIP65 to clarify what you just said, 
this clearly is the missing piece of information there.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/7a585341/attachment.sig>

From gubatron at gmail.com  Fri Nov 13 16:52:08 2015
From: gubatron at gmail.com (Angel Leon)
Date: Fri, 13 Nov 2015 11:52:08 -0500
Subject: [bitcoin-dev] How to evaluate block size increase suggestions.
In-Reply-To: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>
References: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>
Message-ID: <CADZB0_anho4c_qBq0yWoNHkMkkPgFEvQvWn8pCPkU+qS5ecS7A@mail.gmail.com>

I believe in the end it's the usability of bitcoin that matters.

For instance, a goal could be that no user on the network should wait more
than an hour to get 3 confirmations on the blockchain so that they can
actually have useful Bitcoins.

We can debate all we want about lots of technical aspects, but if you can't
send money what's the point?

My humble proposal tried to take that into consideration, but I like way
way more what you propose with NG.

http://twitter.com/gubatron

On Fri, Nov 13, 2015 at 11:37 AM, Emin G?n Sirer <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> By now, we have seen quite a few proposals for the block size increase.
> It's hard not to notice that there are potentially infinitely many
> functions for future block size increases. One could, for instance, double
> every N years for any rational number N, one could increase linearly, one
> could double initially then increase linearly, one could ask the miners to
> vote on the size, one could couple the block size increase to halvings,
> etc. Without judging any of these proposals on the table, one can see that
> there are countless alternative functions one could imagine creating.
>
> I'd like to ask a question that is one notch higher: Can we enunciate what
> grand goals a truly perfect function would achieve? That is, if we could
> look into the future and know all the improvements to come in network
> access technologies, see the expansion of the Bitcoin network across the
> globe, and precisely know the placement and provisioning of all future
> nodes, what metrics would we care about as we craft a function to fit what
> is to come?
>
> To be clear, I'd like to avoid discussing any specific block size increase
> function. That's very much the tangible (non-meta) block size debate, and
> everyone has their opinion and best good-faith attempt at what that
> function should look like. I've purposefully stayed out of that issue,
> because there are too many options and no metrics for evaluating proposals.
>
> Instead, I'm asking to see if there is some agreement on how to evaluate a
> good proposal. So, the meta-question: if we were looking at the best
> possible function, how would we know? If we have N BIPs to choose from,
> what criteria do we look for?
>
> To illustrate, a possible meta goal might be: "increase the block size,
> while ensuring that large miners never have an advantage over small miners
> that [they did not have in the preceding 6 months, in 2012, pick your time
> frame, or else specify the advantage in an absolute fashion]." Or "increase
> block size as much as possible, subject to the constraint that 90% of the
> nodes on the network are no more than 1 minute behind one of the tails of
> the blockchain 99% of the time." Or "do not increase the blocksize until at
> least date X." Or "the increase function should be monotonic." And it's
> quite OK (and probably likely) to have a combination of these kinds of
> metrics and constraints.
>
> For disclosure, I personally do not have a horse in the block size debate,
> besides wanting to see Bitcoin evolve and get more widely adopted. I ask
> because as an academic, I'd like to understand if we can use various
> simulation and analytic techniques to examine the proposals.  A second
> reason is that it is very easy to have a proliferation of block size
> increase proposals, and good engineering would ask that we define the
> meta-criteria first and then pick. To do that, we need some criteria for
> judging proposals other than gut feeling.
>
> Of course, even with meta-criteria in hand, there will be room for lots of
> disagreement because we do not actually know the future and reasonable
> people can disagree on how things will evolve. I think this is good because
> it makes it easier to agree on meta-criteria than on an actual, specific
> function for increasing the block size.
>
> It looks like some specific meta-level criteria would help more at this
> point than new proposals all exploring a different variants of block size
> increase schedules.
>
> Best,
>
> - egs
>
>
> P.S. This message is an off-shoot of this blog post:
>
>
> http://hackingdistributed.com/2015/11/13/suggestion-for-the-blocksize-debate/
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/4b303813/attachment-0001.html>

From digitsu at gmail.com  Sat Nov 14 00:02:01 2015
From: digitsu at gmail.com (digitsu at gmail.com)
Date: Fri, 13 Nov 2015 16:02:01 -0800 (PST)
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <201511132228.47815.luke@dashjr.org>
References: <201511132228.47815.luke@dashjr.org>
Message-ID: <1447459320911.325f57c8@Nodemailer>

Well I'd like to think that with an economy all parts of it interact with each other in ways more complex than simplistic imperative logic.?




I agree that the economic majority is essentially what matters in a hard fork but everyone (miners,devs,public thought leaders,businesses) is part of that economy. Additionally what miners signal as their intention affects the decision of that economic majority (and vice versa). ?You can see the effects of this in traditional political processes in how preliminary vote polling results affect (reinforce) the final vote.?

We also can see the results of this in (dare I mention) the whole XT affair which had the signed intent of many of the economy (payment processors and wallets and one miner pool) and the rest of the miners did not go along with it. This experiment either means that the rest of the miners couldn't be bothered to signal at all (because they didn't know how) or they were affected by the influence of core devs or the opinions of others on the matter and rejected the economic majority. ?(Which would imply core devs have some power by way of indirect influence) I would be inclined to believe the latter was more likely.?




The conclusion which this would seem to imply is that at the very least, miners matter (to what exact extent is debatable). ?And although there is no direct control of any party over the other in the strict sense, the public vocal opinions of any part of the Bitcoin economy does have an effect in its ability to sway the opinions of the other parts.?




Digitsu



?
Regards,

On Sat, Nov 14, 2015 at 7:29 AM, Luke Dashjr <luke at dashjr.org> wrote:

> On Friday, November 13, 2015 4:01:09 PM digitsu at gmail.com wrote:
>> Forgive the frankness but I don't see why signaling your intent to support
>> an upgrade to one side of a hard fork can be seen as a bad thing.  If for
>> nothing else doesn't this make for a smoother flag day? (Because once you
>> signal your intention, it makes it hard to back out on the commitment.)
> It isn't a commitment in any sense, nor does it make it smoother, because for 
> a hardfork to be successful, it is the *economy* that must switch entirely. 
> The miners are unimportant.
>> If miners don't have any choice in hard forks, who does? Just the core
>> devs? 
> Devs have even less of a choice in the matter. What is relevant is the 
> economy: who do people want to spend their bitcoins with? There is no 
> programmatic way to determine this, especially not in advance, so the best we 
> can do is a flag day that gets called off if there isn't clear consensus.
> Luke
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151113/5cadc0d6/attachment.html>

From adam at cypherspace.org  Sat Nov 14 09:31:18 2015
From: adam at cypherspace.org (Adam Back)
Date: Sat, 14 Nov 2015 10:31:18 +0100
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <1447459320911.325f57c8@Nodemailer>
References: <201511132228.47815.luke@dashjr.org>
	<1447459320911.325f57c8@Nodemailer>
Message-ID: <CALqxMTFE9W0nxGHvcJN_Wz88b00o-K29GRTbHJv+VSpYAJKUNQ@mail.gmail.com>

There is a difference between miners signalling intent (as they have
been for various BIPs, which is mostly informational only - they are
mostly not running the code, and in some cases it is not implemented,
so they cant be) there is a difference between that and a 95% miner
majority consensus rule.  Former can be useful information as you
said, latter implies as Luke described something that is not really
accurate, it is not strictly only a miner upgrade needed for basic
safety as with soft-forks.  If you look at BIP 103 for example it is
flag day based, and I think this is a more accurate approach.  Also
with miner votes they can be misleading - vote for one thing, but run
something else; what they are running is not generally
detectable/enforceable - see for example what happened with the BIP66
accidental fork due to "SPV mining" (ie validationless mining).

A hard-fork is for everyone to upgrade and talk with each other to see
that the vast majority is on the same plan which includes users,
ecosystem companies & miners.

Adam

On 14 November 2015 at 01:02, digitsu412 via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Well I'd like to think that with an economy all parts of it interact with
> each other in ways more complex than simplistic imperative logic.
>
> I agree that the economic majority is essentially what matters in a hard
> fork but everyone (miners,devs,public thought leaders,businesses) is part of
> that economy. Additionally what miners signal as their intention affects the
> decision of that economic majority (and vice versa).  You can see the
> effects of this in traditional political processes in how preliminary vote
> polling results affect (reinforce) the final vote.
> We also can see the results of this in (dare I mention) the whole XT affair
> which had the signed intent of many of the economy (payment processors and
> wallets and one miner pool) and the rest of the miners did not go along with
> it. This experiment either means that the rest of the miners couldn't be
> bothered to signal at all (because they didn't know how) or they were
> affected by the influence of core devs or the opinions of others on the
> matter and rejected the economic majority.  (Which would imply core devs
> have some power by way of indirect influence) I would be inclined to believe
> the latter was more likely.
>
> The conclusion which this would seem to imply is that at the very least,
> miners matter (to what exact extent is debatable).  And although there is no
> direct control of any party over the other in the strict sense, the public
> vocal opinions of any part of the Bitcoin economy does have an effect in its
> ability to sway the opinions of the other parts.
>
> Digitsu
>
> ? Regards,
>
>
> On Sat, Nov 14, 2015 at 7:29 AM, Luke Dashjr <luke at dashjr.org> wrote:
>>
>> On Friday, November 13, 2015 4:01:09 PM digitsu at gmail.com wrote:
>> > Forgive the frankness but I don't see why signaling your intent to
>> > support
>> > an upgrade to one side of a hard fork can be seen as a bad thing. If for
>> > nothing else doesn't this make for a smoother flag day? (Because once
>> > you
>> > signal your intention, it makes it hard to back out on the commitment.)
>>
>> It isn't a commitment in any sense, nor does it make it smoother, because
>> for
>> a hardfork to be successful, it is the *economy* that must switch
>> entirely.
>> The miners are unimportant.
>>
>> > If miners don't have any choice in hard forks, who does? Just the core
>> > devs?
>>
>> Devs have even less of a choice in the matter. What is relevant is the
>> economy: who do people want to spend their bitcoins with? There is no
>> programmatic way to determine this, especially not in advance, so the best
>> we
>> can do is a flag day that gets called off if there isn't clear consensus.
>>
>> Luke
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From jtimon at jtimon.cc  Sat Nov 14 10:52:12 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 14 Nov 2015 11:52:12 +0100
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <CALqxMTFE9W0nxGHvcJN_Wz88b00o-K29GRTbHJv+VSpYAJKUNQ@mail.gmail.com>
References: <201511132228.47815.luke@dashjr.org>
	<1447459320911.325f57c8@Nodemailer>
	<CALqxMTFE9W0nxGHvcJN_Wz88b00o-K29GRTbHJv+VSpYAJKUNQ@mail.gmail.com>
Message-ID: <CABm2gDo7D1rrsjRef173HVkwBrDQ0uJAhtWKk0SmRFaqzX5VTw@mail.gmail.com>

Currently bip99 recommends 95% miner upgrade confirmation with version bits
(bip9) for uncontroversial hardforks just like it does for uncontroversial
softforks. It is true that in the case of hardforks miners don't decide and
it's the whole economy who has to upgrade before activation, but "the whole
economy" and "all users" includes miners, so why not use the only upgrade
confirmation mechanism that we have available?

The way I see it, uncontroversial softforks are also expected to be
upgraded to by everyone eventually. The advantage of softforks is that
non-miners don't need to do it before activation like with hardforks.
That's the only important difference I see between uncontroversial
softforks and hardforks (unilateral softforks and schism hardforks are
another thing though).

Please let's discuss this generally within the context of bip99 instead of
discussing different deployment details with every proposal. There's a
couple of threads in the ml, a couple of now merged bip99 prs in
bitcoin/bips...
On Nov 14, 2015 10:31 AM, "Adam Back via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> There is a difference between miners signalling intent (as they have
> been for various BIPs, which is mostly informational only - they are
> mostly not running the code, and in some cases it is not implemented,
> so they cant be) there is a difference between that and a 95% miner
> majority consensus rule.  Former can be useful information as you
> said, latter implies as Luke described something that is not really
> accurate, it is not strictly only a miner upgrade needed for basic
> safety as with soft-forks.  If you look at BIP 103 for example it is
> flag day based, and I think this is a more accurate approach.  Also
> with miner votes they can be misleading - vote for one thing, but run
> something else; what they are running is not generally
> detectable/enforceable - see for example what happened with the BIP66
> accidental fork due to "SPV mining" (ie validationless mining).
>
> A hard-fork is for everyone to upgrade and talk with each other to see
> that the vast majority is on the same plan which includes users,
> ecosystem companies & miners.
>
> Adam
>
> On 14 November 2015 at 01:02, digitsu412 via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Well I'd like to think that with an economy all parts of it interact with
> > each other in ways more complex than simplistic imperative logic.
> >
> > I agree that the economic majority is essentially what matters in a hard
> > fork but everyone (miners,devs,public thought leaders,businesses) is
> part of
> > that economy. Additionally what miners signal as their intention affects
> the
> > decision of that economic majority (and vice versa).  You can see the
> > effects of this in traditional political processes in how preliminary
> vote
> > polling results affect (reinforce) the final vote.
> > We also can see the results of this in (dare I mention) the whole XT
> affair
> > which had the signed intent of many of the economy (payment processors
> and
> > wallets and one miner pool) and the rest of the miners did not go along
> with
> > it. This experiment either means that the rest of the miners couldn't be
> > bothered to signal at all (because they didn't know how) or they were
> > affected by the influence of core devs or the opinions of others on the
> > matter and rejected the economic majority.  (Which would imply core devs
> > have some power by way of indirect influence) I would be inclined to
> believe
> > the latter was more likely.
> >
> > The conclusion which this would seem to imply is that at the very least,
> > miners matter (to what exact extent is debatable).  And although there
> is no
> > direct control of any party over the other in the strict sense, the
> public
> > vocal opinions of any part of the Bitcoin economy does have an effect in
> its
> > ability to sway the opinions of the other parts.
> >
> > Digitsu
> >
> > ? Regards,
> >
> >
> > On Sat, Nov 14, 2015 at 7:29 AM, Luke Dashjr <luke at dashjr.org> wrote:
> >>
> >> On Friday, November 13, 2015 4:01:09 PM digitsu at gmail.com wrote:
> >> > Forgive the frankness but I don't see why signaling your intent to
> >> > support
> >> > an upgrade to one side of a hard fork can be seen as a bad thing. If
> for
> >> > nothing else doesn't this make for a smoother flag day? (Because once
> >> > you
> >> > signal your intention, it makes it hard to back out on the
> commitment.)
> >>
> >> It isn't a commitment in any sense, nor does it make it smoother,
> because
> >> for
> >> a hardfork to be successful, it is the *economy* that must switch
> >> entirely.
> >> The miners are unimportant.
> >>
> >> > If miners don't have any choice in hard forks, who does? Just the core
> >> > devs?
> >>
> >> Devs have even less of a choice in the matter. What is relevant is the
> >> economy: who do people want to spend their bitcoins with? There is no
> >> programmatic way to determine this, especially not in advance, so the
> best
> >> we
> >> can do is a flag day that gets called off if there isn't clear
> consensus.
> >>
> >> Luke
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151114/9ef5c0fd/attachment-0001.html>

From jtimon at jtimon.cc  Sat Nov 14 13:48:04 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 14 Nov 2015 14:48:04 +0100
Subject: [bitcoin-dev] How to evaluate block size increase suggestions.
In-Reply-To: <CADZB0_anho4c_qBq0yWoNHkMkkPgFEvQvWn8pCPkU+qS5ecS7A@mail.gmail.com>
References: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>
	<CADZB0_anho4c_qBq0yWoNHkMkkPgFEvQvWn8pCPkU+qS5ecS7A@mail.gmail.com>
Message-ID: <CABm2gDqcGD0AfRhsC70NSgZFJ4-o+xXFPGxPhVoG00OzUKYofg@mail.gmail.com>

I agree with the usefulness of at least trying to define a formal set
of criteria.
I'm afraid that with proposals that schedule future increases to the
blocksize consensus maximum or leave it for miners to decide (like
BIP100, BIP101 and BIP103) cannot be evaluated without making
assumptions about the future (or what miners will decide in the
future).
Since limiting resource consumption and mining centralization dynamics
are the reasons to have blocksize consensus maximum in the first
place, I think it would be ideal to have some simulation +
benchmarking software that is able to analyze a given proposal, give
resource consumption benchmark data about average and worst cases, and
also give some kind of metric from "mining centralization dynamics
simulations".
We could start with just a metric for concrete block sizes (for
arbitrary maximum blocksizes testchains see #6382).
Note that this is unrelated to the deployment mechanism, proposed
activation date and other details.

On Fri, Nov 13, 2015 at 5:52 PM, Angel Leon via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> For instance, a goal could be that no user on the network should wait more
> than an hour to get 3 confirmations on the blockchain so that they can
> actually have useful Bitcoins.

That depends on block space demand on a particular moment in time, the
fee paid by the example user and local relay and mining policies in
the network (and how they treat transactions with the specific form of
the transaction example) and even the network topology.
There's no consensus rule that can guarantee that all transaction from
all users will be included at most 3 blocks after they are relayed.
For starters, any user can create infinite transactions (without fee)
for free while the network will never have infinite computing
resources.
What we have is a fee estimator that observes the chain and can
estimate the market situation to tell you the average number of blocks
for a given transaction with a given feerate. I know that number was
only 14 blocks or so for free (not a single satoshi in fees)
transactions, but that has probably changed with the recent attacks...

From erik.fors at startmail.com  Sat Nov 14 15:25:19 2015
From: erik.fors at startmail.com (Erik)
Date: Sat, 14 Nov 2015 16:25:19 +0100
Subject: [bitcoin-dev] BIP proposal - Max block size
In-Reply-To: <201511131937.03430.luke@dashjr.org>
References: <5645E095.4050704@startmail.com>
	<201511131937.03430.luke@dashjr.org>
Message-ID: <5647525F.40801@startmail.com>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


I've seen two different BIP103's and choose to not write about it
because risk of ambiguity. One of them are proposing a linear growth and
the other one is proposing an exponential growth. The all-linear growth
is an option that will not work well in the future because the growth
will be too slow soon or later. The exponential growth assumes that the
technology will rise in a certain growth, which may be too slow or too
fast in accordance to the technical evolution. None of the BIP103
proposals will actually handle an unexpected future case.

BIP105 has another feature not mentioned in my proposal that is to place
a vote requires a cost as a difficulty increase. I do not think it's a
good option since it will make users refrain from voting to "earn" a
difficulty lowering. The votes are the (yet) only soft way I see to let
the blockchain know if it should allow growing faster or slower. I also
don't see a benefit of having the opportunity to lower the block max
size in comparison to the risks involved with that. Then it proposes a
limit to how much it can increase at all which will need a new hard fork
when we need to increase the limits of the proposal.

I don't see how John Sacco's BIP proposal is similar to this one since
there is no voting mechanism to make the increase dynamic. Also John
proposes that the size will double at each halving instead of each
difficulty retarget. This could, in contrary to increase the fees by
making larger spaces in the blocks, decrease the fees because of that
the fee required to enter the next block will be lowered. Also it
proposes a hard limit at 32 MB which, again, need a new hard fork later.

The formula I've provided isn't actually complicated. The 2^(1/2...)
formula creates a number in the interval 1 to 2. The formula can tell if
the block max size every second year shall double or be the same based
on the last 6 month of votes. Because i believe there should always be
an increase to secure a stable growth of the network, there is also a
linear formula that the growth cannot be lower than. If the 2^(1/2...)
formula gives a lower increase than the linear value for the next
retarget, then the linear value should be used instead.

There will not be a rounding error since the implementation shall floor
the value to a whole byte. The next size should be calculated on that
value. Also, if the block max size is included in the retarget block,
there would be an extra correcting method to uncertain clients. The
formula isn't very different in complexity from the difficulty retarget
formula and will still need the last recalculated value to be computed.

One of the benefits of using an exponential formula is that it could
easily be fit for any arbitrary block period by changing the divisor. I
personally think the two week interval will be smooth enough.

Erik

Den 2015-11-13 kl. 20:37, skrev Luke Dashjr:
> On Friday, November 13, 2015 1:07:33 PM Erik via bitcoin-dev wrote:
>> Hi devs. I was discussing the BIP proposals concerning max block size
>> yesterday in the #bitcoin channel. I believe that BIP101 fully utilized
>> will outperform consumer hardware soon or later and thereby centralize
>> Bitcoin. I would therefore like to do a different proposal:
>
> It doesn't look like you've considered BIP103 or newer BIPs?
Especially, I'd
> suggest you look at and work with John Sacco who just the other day
posted a
> BIP draft very similar-looking to yours. My overall impression of your
summary
> is that it is unnecessarily over-complicated and underspecified. How
does the
> 2^(1/2) block size limit actually work? This is not a very precise
number, so
> it seems liable to produce rounding errors in different implementations.
> Additionally, the miner voting thing seems pointless since miners can
already
> softfork lower limits. It would be beneficial to express the current
> possibility so full nodes can enforce it, but this would be expressed
as an
> unlimited simple-majority vote to reduce the limit. Probably it would
be ideal
> to separate this off from the hardfork BIP, since it's fairly tangent
to it.
>
> Luke

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQIcBAEBAgAGBQJWR1JfAAoJEJ51csApon2o1zkP/1Ik/VjakUII+2iXvPB+DSJ6
cekIC4A8zlgltSmFyE74IuQBlV/5LumNMCzXoKUaDRuKSedlyh1mUrt8hPFfISfr
yvIeWmXUQhd7s34mTTc9mBvz/TDuxuNYAFe1FYQhNzuV3GaLTysBAXScY5rGIkHf
hdgxG3mPtzaqse1I5e+3jpwlPUYpLn/0A2nmF0iXCoOv1LnTvrlV3thP8Fp/YMt3
iLsiWFQFf1jpA4mDoCC/G5bfYiqvFbtXdOKKZC12Dp3hTZZCzJ21FQ6+o/v4BT7y
MfW9kl3aWf3VSxbkvHppIrX1+HqDwTsn5u9kNcbYn8xBMRpFXFddFnsg/v6ai++L
mev+kIUrXvvDqvRSfQYmHIUKCwo+tzXbHcumydxBp412TOKW5bT1CmCRYMOvY/+C
45VWBj6foUYG/kq3QISm+lptVDQlESlAizHdWNkc9HJpKZG3VkNmmxEEXm3o7J07
LbBQ7bR2MELE6lP2Z3ImTXxZe0ZBdjyjDDV3qsIGK9D7LCK31KE70ZIueE3bePmR
9xWBfzKbm6Y3cQ6+4E8p8US7woVs9LGWXzLdKQyKEoiDx16bF7SOGvSyYcnOPsNu
O7lVpGh8Pezb0ZLEx5UnM5ONm35PzmzAT9Ng2iMEhche3AQS4s/b+wVWpyclQ62e
X4UVSr2O1mbfI9CmCPfI
=qcA8
-----END PGP SIGNATURE-----

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151114/ece596e0/attachment.html>

From nowostawski at gmail.com  Sat Nov 14 16:08:18 2015
From: nowostawski at gmail.com (Mariusz Nowostawski)
Date: Sat, 14 Nov 2015 17:08:18 +0100
Subject: [bitcoin-dev] How to evaluate block size increase suggestions.
In-Reply-To: <mailman.1887.1447451888.1619.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.1887.1447451888.1619.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <56475C72.10803@gmail.com>

> Date: Fri, 13 Nov 2015 11:37:51 -0500
> From: Emin G?n Sirer <el33th4x0r at gmail.com>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] How to evaluate block size increase
> 	suggestions.
> Message-ID:
> 	<CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
> 
> By now, we have seen quite a few proposals for the block size increase.
> It's hard not to notice that there are potentially infinitely many
> functions for future block size increases. One could, for instance, double
> every N years for any rational number N, one could increase linearly, one
> could double initially then increase linearly, one could ask the miners to
> vote on the size, one could couple the block size increase to halvings,
> etc. Without judging any of these proposals on the table, one can see that
> there are countless alternative functions one could imagine creating.
> 
> I'd like to ask a question that is one notch higher: Can we enunciate what
> grand goals a truly perfect function would achieve? That is, if we could
> look into the future and know all the improvements to come in network
> access technologies, see the expansion of the Bitcoin network across the
> globe, and precisely know the placement and provisioning of all future
> nodes, what metrics would we care about as we craft a function to fit what
> is to come?
> 
> To be clear, I'd like to avoid discussing any specific block size increase
> function. That's very much the tangible (non-meta) block size debate, and
> everyone has their opinion and best good-faith attempt at what that
> function should look like. I've purposefully stayed out of that issue,
> because there are too many options and no metrics for evaluating proposals.
> 
> Instead, I'm asking to see if there is some agreement on how to evaluate a
> good proposal. So, the meta-question: if we were looking at the best
> possible function, how would we know? If we have N BIPs to choose from,
> what criteria do we look for?
> 
> To illustrate, a possible meta goal might be: "increase the block size,
> while ensuring that large miners never have an advantage over small miners
> that [they did not have in the preceding 6 months, in 2012, pick your time
> frame, or else specify the advantage in an absolute fashion]." Or "increase
> block size as much as possible, subject to the constraint that 90% of the
> nodes on the network are no more than 1 minute behind one of the tails of
> the blockchain 99% of the time." Or "do not increase the blocksize until at
> least date X." Or "the increase function should be monotonic." And it's
> quite OK (and probably likely) to have a combination of these kinds of
> metrics and constraints.
> 
> For disclosure, I personally do not have a horse in the block size debate,
> besides wanting to see Bitcoin evolve and get more widely adopted. I ask
> because as an academic, I'd like to understand if we can use various
> simulation and analytic techniques to examine the proposals.  A second
> reason is that it is very easy to have a proliferation of block size
> increase proposals, and good engineering would ask that we define the
> meta-criteria first and then pick. To do that, we need some criteria for
> judging proposals other than gut feeling.
> 
> Of course, even with meta-criteria in hand, there will be room for lots of
> disagreement because we do not actually know the future and reasonable
> people can disagree on how things will evolve. I think this is good because
> it makes it easier to agree on meta-criteria than on an actual, specific
> function for increasing the block size.
> 
> It looks like some specific meta-level criteria would help more at this
> point than new proposals all exploring a different variants of block size
> increase schedules.
> 
> Best,
> 
> - egs



Hi,

Good point. I found it also to be important. Enumerating first exactly
WHAT and WHY is being solved and then formulating HOW the proposed
solutions can be evaluated, resonates with me, probably because I'm an
academic. We need to be able to predict if a given proposal addresses
the actual problem at hand and we need to know how to evaluate the
proposals.

But first, we need to re-evaluate the problem.  I think the original
problem of the increasing demands on the transaction throughput of the
bitcoin blockchain have been derailed into a rather constrained
discussion on the block size increase. This is fundamentally broken. The
debate should be reverted back to the actual problem: how to deal with
the increasing demands of the transaction throughput on the bitcoin
blockchain, what exactly is the problem, and what possible ways exist in
dealing with those problems? In other words, how to deal with the
scalability of the bitcoin blockchain.


Somewhat surprisingly, all the solutions proposals so far focused on a
"centralized" model in which Bitcoin blockchain plays the central role
in any future economy. Bitcoin has been compared to VISA and questions
have been asked how to handle 1000s of transactions per second - via the
Bitcoin blockchain. Should any form of electronic value transfer such as
assets, currencies, etc be handled by THE SINGLE CHAIN? A single chain
that does it ALL? Is that the objective for the Bitcoin blockchain?
There are some contradictions: from one hand the Bitcoin blockchain
offers transparent, distributed ledger that can be used for verification
of transactions, which is a good thing. At the same time, it uses p2p
technology, consensus, and limited transaction throughput (regardless of
where the actual block size limit sits), which are bad when considering
processing and validating large volumes of financial transactions such
as currently processed by VISA.

Planning the Bitcoin blockchain to handle everything will simply never
scale, it might turn out impossible, and also it will hinder innovation,
and can ultimately work against the Bitcoin blockchain (e.g. by
inadvertent and irreversible centralization of verification nodes, or
simply reducing the full verification nodes count).


(Devil's advocate): limit stays on 1MB and there are more transactions
generated every 10min that can potentially fit into the block. Then,
this follows:

1. There will be a strong incentive for fees to grow.
Is it a bad thing? Are growing fees unavoidable anyway? Miners need to
recover the costs of mining when the crossing-point of rewards/fees
happens, and that means growing fees, right?  Can this be modeled? Can
we predict how much the fees will actually grow to weed out all the
"noise" transactions that currently get through because it is cheap to
do so?

2. Some transactions will simply never made it to the chain.
Is it a bad thing? Perhaps it is just a self-adaptation to weed out
"invaluable" transactions from the system? Do we need to process and
cater for ALL the transactions? Including all the NOISE that doesn't
really contribute to anything? Can we model this?

Personally, I think transaction fees for electronic transfers should be
close to ZERO, but, at the same time, I think transaction costs of
Bitcoin blockchain should be high enough to keep this chain special,
noise free, and compact, with large number of validating nodes working
in p2p fashion.

So are points 1 and 2 really fundamentally BAD, or are they just a
self-regulating anti-noise mechanism? I can pack-up thousands of
transactions in auxiliary systems, and validate them via a SINGLE
bitcoin blockchain transaction, and this would scale.


3. Companies generating large number of transactions will have to look
into ways of saving costs and combining multiple individual transactions
into larger ones to save on FEE costs.
Is it a bad thing? No - it is a very good thing, and the sooner it
happens the better ;)


4. Companies, governments and institutions would have to look into ways
of improving their own performance and scalability OUTSIDE of the
Bitcoin blockchain. For example through client-server, extremely
efficient centralised blockchains, Open Chain-like models, and only
using Bitcoin blockchain for validation/verification in a transparent
and verifiable manner. How about running thousands of financial
transactions per second on open chain and only recording merkel root
hashes for batches of transactions every 10min in a Bitcoin blockchain
for transparency and verification?




So, coming back to the original question about CRITERIA:

*1* The ability to setup and run low-cost fully validating node should
remain the same or should improve; upon deployment of a given proposal
there should be an increase in a number of fully validating nodes, or at
worst, there should be no decrease.

*2* The ability to include additional data into Bitcoin blockchain (e.g.
via OP_RETURN) should improve or, at worst, remain the same as it is now.

*3* Upon deployment of a given proposal, the noise in the ledger should
be reduced, or at worst, remain the same.

*4* A proposal should address long-term scalability, and offer the
possibility of combining Bitcoin blockchain with well-defined auxiliary
protocols to offer high-transaction throughputs.



cheers
Mariusz


From luke at dashjr.org  Sat Nov 14 21:11:22 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 14 Nov 2015 21:11:22 +0000
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
	with max block size of 32M
In-Reply-To: <CABm2gDo7D1rrsjRef173HVkwBrDQ0uJAhtWKk0SmRFaqzX5VTw@mail.gmail.com>
References: <201511132228.47815.luke@dashjr.org>
	<CALqxMTFE9W0nxGHvcJN_Wz88b00o-K29GRTbHJv+VSpYAJKUNQ@mail.gmail.com>
	<CABm2gDo7D1rrsjRef173HVkwBrDQ0uJAhtWKk0SmRFaqzX5VTw@mail.gmail.com>
Message-ID: <201511142111.24046.luke@dashjr.org>

On Saturday, November 14, 2015 10:52:12 AM Jorge Tim?n via bitcoin-dev wrote:
> Currently bip99 recommends 95% miner upgrade confirmation with version bits
> (bip9) for uncontroversial hardforks just like it does for uncontroversial
> softforks. It is true that in the case of hardforks miners don't decide and
> it's the whole economy who has to upgrade before activation, but "the whole
> economy" and "all users" includes miners, so why not use the only upgrade
> confirmation mechanism that we have available?

Actually, the economy does not necessarily include miners, and in fact the 
present miner community for the most part does not overlap significantly with 
economic activity. And at the same time, miners also have a tendency to 
upgrade at a different rate than the economy. It might make sense to 
incorporate a miner-trigger, but *only if* the flag is enabled in nodes by an 
option disabled by default, and the BIP clearly specifies that miners must not 
enable it until they perceive complete economic adoption of the change.

Luke

From luke at dashjr.org  Sat Nov 14 21:27:51 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 14 Nov 2015 21:27:51 +0000
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
	with max block size of 32M
In-Reply-To: <CADZB0_Z3Kf4GW0VATjb10kJF0aFgyFOcqX_=y+LFoUpsi+TRUA@mail.gmail.com>
References: <201511132228.47815.luke@dashjr.org>
	<201511142111.24046.luke@dashjr.org>
	<CADZB0_Z3Kf4GW0VATjb10kJF0aFgyFOcqX_=y+LFoUpsi+TRUA@mail.gmail.com>
Message-ID: <201511142127.53255.luke@dashjr.org>

On Saturday, November 14, 2015 9:15:07 PM Angel Leon wrote:
> "the economy does not necessarily include miners"
> so the money supply isn't part of the economy?

Not in the context of economic majority deciding hardforks. After all, the 
outcome of the hardfork *determines* the money supply. So the former money 
supply not supporting the change would just mean they cease to be involved in 
that capacity. But even aside from that, the more relevant factor in terms of 
economic involvement is /acceptance/ of bitcoins as payment for real goods.

Luke

From peter_r at gmx.com  Sat Nov 14 21:45:25 2015
From: peter_r at gmx.com (Peter R)
Date: Sat, 14 Nov 2015 13:45:25 -0800
Subject: [bitcoin-dev] How to evaluate block size increase suggestions.
In-Reply-To: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>
References: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>
Message-ID: <B2C858C1-B15F-49F1-BF7E-02EA7C3FE474@gmx.com>

> It looks like some specific meta-level criteria would help more at this point than new proposals all exploring a different variants of block size increase schedules.

I agree.  In fact, I?ll go meta on your meta and suggest that we should first discuss how Bitcoin should be governed in the first place.  Should Bitcoin evolve from the ?bottom up,? or from the ?top down??

If one?s answer is from the ?top-down,? then the meta-level criteria can be endlessly debated, for they all involve some sort of tradeoff, they all require some sort of compromise.  The ?top down? perspective holds that people might make poor choices if given the freedom to easily do so--it holds that the trade-offs must be balanced instead by experts.  

However, if one's answer is from the ?bottom up,? then the meta-level criteria is very easy: we do what the people wants. We allow the people to weigh the tradeoffs and then we watch as consensus emerges through a decentralized process, objectively represented by the longest proof-of-work chain.  

Regarding the block size limit debate, at the end of the day it comes down to two things:

1.  How big of a block will my node accept today?

2.  What do I want my node to do if the longest chain includes a block larger than the limit I set?

If one concedes that Bitcoin should be governed from the ?bottom up,? then it is already possible to empower each node operator to more easily express his free choice regarding the size of blocks he is willing to accept, while simultaneously ensuring that his node tracks consensus.

Best regards,
Peter


From xor at freenetproject.org  Sat Nov 14 22:47:23 2015
From: xor at freenetproject.org (xor)
Date: Sat, 14 Nov 2015 23:47:23 +0100
Subject: [bitcoin-dev] Contradiction in BIP65 text?
In-Reply-To: <CADm_WcZnOXqcse1LC28ptLyxXJTtbv+RPMfrMamR4xZK3xcK8Q@mail.gmail.com>
References: <1581446.3ZPnhFUSFq@1337h4x0r>
	<CADm_WcZnOXqcse1LC28ptLyxXJTtbv+RPMfrMamR4xZK3xcK8Q@mail.gmail.com>
Message-ID: <1910992.nPu4WaYHE8@1337h4x0r>

On Friday, November 13, 2015 06:58:07 PM Jeff Garzik wrote:
> On Fri, Nov 13, 2015 at 4:48 PM, xor via bitcoin-dev <
> 
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> > This clearly says that funds can be frozen.
> > Can the BIP65-thing be used to freeze funds or can it not be?
> 
> This language definitely trips up or worries several folks - it's been
> mentioned a few times before.
> 
> The user _chooses_ to freeze _their own_ funds.  It is not an unwilling act
> of force, which many assume when they see the phrase "freeze funds."

Oh, interesting, albeit that was not subject of my question.

My question in fact was whether *I* can use it to freeze *my* funds; because I 
think that would be an interesting feature for various purposes.
From the state of BIP65 I talked about, it is not even clear whether that is 
possible.

Your observation beyond that is a valid concern though.
So both should be addressed.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151114/d16fea08/attachment.sig>

From peter.tschipper at gmail.com  Sat Nov 14 23:27:49 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Sat, 14 Nov 2015 15:27:49 -0800
Subject: [bitcoin-dev] request to use service bit 28 for testing
Message-ID: <5647C375.9050809@gmail.com>

I'd like to use service bit 28 for testing the block compression
prototype unless anyone has any objections or is using it already.

Thanks.

From peter_r at gmx.com  Sun Nov 15 01:02:33 2015
From: peter_r at gmx.com (Peter R)
Date: Sat, 14 Nov 2015 17:02:33 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
Message-ID: <571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>

Hi Greg,

Like you said, the issue with using more than one database technology is not that one node would prove that Block X is valid while the another node proves that Block X is NOT valid.  Instead, the problem is that one node might say ?valid? while the other node says ?I don?t know.?

It is often said that what caused the Level DB fork was that the old version determined that the triggering block was invalid while the new version determined the opposite.  This interpretation of the fork event has lead to the ?bug-for-bug?-compatibility fear regarding multiple implementations of the protocol (or multiple database technologies).  In reality, this fear is largely unfounded.  

The old version ran out of LDB locks and couldn?t execute properly.  If the software was written with the philosophy that tracking consensus was more important than bug-for-bug compatibility, it would have returned an exception rather than ?invalid.?  At that point, the software would have checked what decision the rest of the network came to about the block in question.   My node would have forked to the longest chain, automatically assuming that the questionable block was valid; your node may have made a different decision (it?s a question of ideology at that point).      

A group of us have been exploring this ?meta-cognition? idea with Bitcoin Unlimited.  For example, Bitcoin Unlimited can be (optionally) made to automatically fork to the longest chain if it ?gets stuck? and can neither prove that a block is valid nor that the block is invalid.  Similarly, Bitcoin Unlimited can be (optionally) made to automatically fork to a chain that contains a block marginally bigger than its block size limit?once that block is buried sufficiently in what has emerged as the longest persistent chain. 

Thinking from this perspective might go along way towards decentralizing development, the emergence of multiple competing implementations of the protocol, and true ?bottom up? governance.  

Best regards,
Peter



> On Oct 29, 2015, at 9:28 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> 
> On Fri, Oct 30, 2015 at 4:04 AM, Peter R <peter_r at gmx.com> wrote:
>> Can you give a specific example of how nodes that used different database technologies might determine different answers to whether a given transaction is valid or invalid?  I?m not a database expert, but to me it would seem that if all the unspent outputs can be found in the database, and if the relevant information about each output can be retrieved without corruption, then that?s all that really matters as far as the database is concerned.
> 
> If you add to those set of assumptions the handling of write ordering
> is the same (e.g. multiple updates in an change end up with the same
> entry surviving) and read/write interleave returning the same results
> then it wouldn't.
> 
> But databases sometimes have errors which cause them to fail to return
> records, or to return stale data. And if those exist consistency must
> be maintained; and "fixing" the bug can cause a divergence in
> consensus state that could open users up to theft.
> 
> Case in point, prior to leveldb's use in Bitcoin Core it had a bug
> that, under rare conditions, could cause it to consistently return not
> found on records that were really there (I'm running from memory so I
> don't recall the specific cause).  Leveldb fixed this serious bug in a
> minor update.  But deploying a fix like this in an uncontrolled manner
> in the bitcoin network would potentially cause a fork in the consensus
> state; so any such fix would need to be rolled out in an orderly
> manner.
> 
>> I?d like a concrete example to help me understand why more than one implementation of something like the UTXO database would be unreasonable.
> 
> It's not unreasonable, but great care is required around the specifics.
> 
> Bitcoin consensus implements a mathematical function that defines the
> operation of the system and above all else all systems must agree (or
> else the state can diverge and permit double-spends);  if you could
> prove that a component behaves identically under all inputs to another
> function then it can be replaced without concern but this is something
> that cannot be done generally for all software, and proving
> equivalence even in special cases it is an open area of research.  The
> case where the software itself is identical or nearly so is much
> easier to gain confidence in the equivalence of a change through
> testing and review.
> 
> With that cost in mind one must then consider the other side of the
> equation-- utxo database is an opaque compressed representation,
> several of the posts here have been about desirability of blockchain
> analysis interfaces, and I agree they're sometimes desirable but
> access to the consensus utxo database is not helpful for that.
> Similarly, other things suggested are so phenomenally slow that it's
> unlikely that a node would catch up and stay synced even on powerful
> hardware.  Regardless, in Bitcoin core the storage engine for this is
> fully internally abstracted and so it is relatively straight forward
> for someone to drop something else in to experiment with; whatever the
> motivation.
> 
> I think people are falling into a trap of thinking "It's a <database>,
> I know a <black box> for that!"; but the application and needs are
> very specialized here; no less than, say-- the table of pre-computed
> EC points used for signing in the ECDSA application. It just so
> happens that on the back of the very bitcoin specific cryptographic
> consensus algorithim there was a slot where a pre-existing high
> performance key-value store fit; and so we're using one and saving
> ourselves some effort.  If, in the future, Bitcoin Core adopts a
> merkelized commitment for the UTXO it would probably need to stop
> using any off-the-shelf key value store entirely, in order to avoid a
> 20+ fold write inflation from updating hash tree paths (And Bram Cohen
> has been working on just such a thing, in fact).


From gmaxwell at gmail.com  Sun Nov 15 01:08:16 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 15 Nov 2015 01:08:16 +0000
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
Message-ID: <CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>

On Sun, Nov 15, 2015 at 1:02 AM, Peter R <peter_r at gmx.com> wrote:
> Hi Greg,
>
> Like you said, the issue with using more than one database technology is not that one node would prove that Block X is valid while the another node proves that Block X is NOT valid.  Instead, the problem is that one node might say ?valid? while the other node says ?I don?t know.?

Sometimes errors are such that you can catch them (if you're super
vigilant and know an error is even possible in that case)-- and
indeed, in that case you can get a "I don't know, something is
wrong.", other times errors are undetectable.

> In reality, this fear is largely unfounded.

I cited an issue in leveldb (before we used it) where it would
silently fail to return records.

> If the software was written with the philosophy that tracking consensus was more important than bug-for-bug compatibility, it would have returned an exception rather than ?invalid.?

That invariant requires the software to be completely free of errors
that would violate it.

From peter_r at gmx.com  Sun Nov 15 01:45:03 2015
From: peter_r at gmx.com (Peter R)
Date: Sat, 14 Nov 2015 17:45:03 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
Message-ID: <6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>


> On Nov 14, 2015, at 5:08 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> 
> On Sun, Nov 15, 2015 at 1:02 AM, Peter R <peter_r at gmx.com> wrote:
>> Hi Greg,
>> 
>> Like you said, the issue with using more than one database technology is not that one node would prove that Block X is valid while the another node proves that Block X is NOT valid.  Instead, the problem is that one node might say ?valid? while the other node says ?I don?t know.?
> 
> Sometimes errors are such that you can catch them (if you're super
> vigilant and know an error is even possible in that case)-- and
> indeed, in that case you can get a "I don't know, something is
> wrong.", other times errors are undetectable.

Agreed.  There are two cases to consider:

Type 1.  One implementation says ?yes? or ?no,? while the other says ?I don?t know?, and

Type 2.  One implementation says ?yes? and the other says ?no,? because of a bug.  

My previous email described how Type 1 consensus failures can be safely dealt with.  These include many kinds of database exceptions (e.g., the LevelDB fork at block #225,430), or consensus mismatches regarding the max size of a block.  

Type 2 consensus failures are more severe but also less likely (I?m not aware of a Type 2 consensus failure besides the 92 million bitcoin bug from August 2010).  If Core was to accept a rogue TX that created another 92 million bitcoins, I think it would be a good thing if the other implementations forked away from it (we don?t want bug-for-bug compatibility here).   

This once again reveals the benefits of multiple competing implementations.  

Sincerely,
Peter 





From gmaxwell at gmail.com  Sun Nov 15 02:10:43 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 15 Nov 2015 02:10:43 +0000
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
Message-ID: <CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>

On Sun, Nov 15, 2015 at 1:45 AM, Peter R <peter_r at gmx.com> wrote:
> My previous email described how Type 1 consensus failures can be safely dealt with.  These include many kinds of database exceptions (e.g., the LevelDB fork at block #225,430), or consensus mismatches regarding the max size of a block.

The size of a block is not a type 1 failure. There is a clear, known,
unambiguous, and easily measured rule in the system that a block is
not permitted to have a size over a threshold. A block that violates
this threshold is invalid.   The only way I can see to classify that
as a type 1 failure is to call the violation of any known system rule
a type 1 failure.  "Spends a coin that was already spent" "provides a
signature that doesn't verify with the pubkey" "creates bitcoins out
of thin air" -- these are not logically different than "if size>x
return false".

> Type 2 consensus failures are more severe but also less likely (I?m not aware of a Type 2 consensus failure besides the 92 million bitcoin bug from August 2010).  If Core was to accept a rogue TX that created another 92 million bitcoins, I think it would be a good thing if the other implementations forked away from it (we don?t want bug-for-bug compatibility here).

The only consensus consistency error we've ever that I would have
classified as potentially type 1 had has been the BDB locks issue.
Every other one, including the most recently fixed one (eliminated by
BIP66) was a type 2, by your description. They are _much_ more common;
because if the author understood the possible cases well enough to
create an "I don't know" case, they could have gone one step further
and fully defined it in a consistent way. The fact that an
inconsistency was possible was due to a lack of complete knowledge.

Even in the BDB locks case, I don't know that the type 1 distinction
completely applies, a lower layer piece of software threw an error
that higher layer software didn't know was possible, and so it
interpreted "I don't know" as "no"-- it's not that it chose to treat I
don't know as no, its that it wasn't authored with the possibility of
I don't know in mind, and that exceptions were used to handle general
failures (which should have been treated as no). Once you step back to
the boundary of the calling code (much less the whole application) the
"I don't know" doesn't exist anymore; there.

From marcopon at gmail.com  Sun Nov 15 02:14:44 2015
From: marcopon at gmail.com (Marco Pontello)
Date: Sun, 15 Nov 2015 03:14:44 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
Message-ID: <CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>

Hi!

To anyone that followed the discussion (from some time ago) about the
proposed new URI for Blockchain references / exploration, I just wanted to
point out that I have collected the feedback provided, reworked the text,
put the BIP on GitHub and created a pull request:

https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
https://github.com/bitcoin/bips/pull/202

The need for an URI for this come to mind again in the last days looking at
Eternity Wall, which IMHO provide a use case that we will see more and more
in the (near) future: http://eternitywall.it/
Using that service, when you want to check for the proof that a specific
message was written in the Blockchain, it let you choose from 5 different
explorer.
Mycelium wallet recently added the option to select one of 15 block
explorers.
And there's the crypto_bot on reddit/r/bitcoin that detect reference to
transaction an add a message with links to 7 different explorers.

I think that's clearly something that's needed.

Bye!


On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <marcopon at gmail.com> wrote:

> Hi!
> My first post here, hope I'm following the right conventions.
> I had this humble idea for a while, so I thought to go ahead and propose
> it.
>
> BIP: XX
> Title: URI scheme for Blockchain exploration
> Author: Marco Pontello
> Status: Draft
> Type: Standards Track
> Created: 29 August 2015
>
> Abstract
> ========
> This BIP propose a simple URI scheme for looking up blocks, transactions,
> addresses on a Blockchain explorer.
>
> Motivation
> ==========
> The purpose of this URI scheme is to enable users to handle all the
> requests for details about blocks, transactions, etc. with their preferred
> tool (being that a web service or a local application).
>
> Currently a Bitcoin client usually point to an arbitrary blockchain
> explorer when the user look for the details of a transaction (es. Bitcoin
> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info, etc.).
> Other times resorting to cut&paste is needed.
> The same happens with posts and messages that reference some particular
> txs or blocks, if they provide links at all.
>
> Specification
> =============
> The URI follow this simple form:
>
> blockchain: <hash/string>
>
> Examples:
>
> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
> blockchain:001949
> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
>
> Rationale
> =========
> I thought about using some more complex scheme, or adding qualifiers to
> distinguish blocks from txs, but in the end I think that keeping it simple
> should be practical enough. Blockchain explorers can apply the same
> disambiguation rules they are already using to process the usual search
> box.
>
> From the point of view of a wallet developer (or other tool that need to
> show any kind of Blockchain references), using this scheme mean that he
> can simply make it a blockchain: link and be done with it, without having
> to worry about any specific Blockchain explorer or provide a means for the
> user to select one.
>
> Blockchain explorers in turn will simply offer to handle the blockchain:
> URI, the first time the user visit their website, or launch/install the
> application, or even set themselves if there isn't already one.
>
> Users get the convenience of using always their preferred explorer, which
> can be especially handy on mobile devices, where juggling with cut&paste
> is far from ideal.
>
>
>


-- 
Try the Online TrID File Identifier
http://mark0.net/onlinetrid.aspx
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151115/0a084af7/attachment.html>

From peter_r at gmx.com  Sun Nov 15 02:58:50 2015
From: peter_r at gmx.com (Peter R)
Date: Sat, 14 Nov 2015 18:58:50 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
Message-ID: <13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>


> On Nov 14, 2015, at 6:10 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> 
> On Sun, Nov 15, 2015 at 1:45 AM, Peter R <peter_r at gmx.com> wrote:
>> My previous email described how Type 1 consensus failures can be safely dealt with.  These include many kinds of database exceptions (e.g., the LevelDB fork at block #225,430), or consensus mismatches regarding the max size of a block.
> 
> The size of a block is not a type 1 failure. There is a clear, known,
> unambiguous, and easily measured rule in the system that a block is
> not permitted to have a size over a threshold. A block that violates
> this threshold is invalid.  

You are looking at the problem from a ?top down? governance perspective assuming you know what code is actually being run and what rules the market wants.  The reality is that you can only make estimates about these two things.  As Bitcoin evolves away from the current development monoculture, rules such as the max block size may no longer be perfectly clear.  However, we can prove that the following results will continue to hold:

1. A node with a block size limit greater than the hash-power weighted median will always follow the longest chain.

2. An excessive (e.g., greater than 1 MB) block will be accepted into the longest chain if it is smaller than the hash-power weighted median block size limit.

Already today, different nodes have different block size limits.  There are even some miners today that will attempt to build upon blocks larger than 1 MB if anyone dares to create one.  At some point, the majority of the hash power will support something larger than 1 MB.  When that first bigger block comes and gets buried in the longest chain, hold-out nodes (e.g., MP says he will never increase his limit) will have to make a choice: fight consensus or track consensus!  I know that I would want my node to give up on its block size limit and track consensus.  You may decide to make a different choice.  

You said that "a block that violates this [block size limit] threshold is invalid.?  I agree.  If the nodes and miners rejected the block as invalid then it would not persist as the longest chain. If the nodes and miners accepted the block and continued to build on top of it, then that chain would be Bitcoin (whether you personally agree of not).  

Bitcoin is ultimately a creature of the market, governed by the code people freely choose to run. Consensus is then an emergent property, objectively represented by the longest persistent chain.  Proof-of-work both enforces and defines the rules of the network.  


>  The only way I can see to classify that
> as a type 1 failure is to call the violation of any known system rule
> a type 1 failure.  "Spends a coin that was already spent" "provides a
> signature that doesn't verify with the pubkey" "creates bitcoins out
> of thin air" -- these are not logically different than "if size>x
> return false?.

I think you?re being intentionally obtuse here: accepting a block composed entirely of valid transactions that is 1.1 MB is entirely different than accepting a TX that creates a ten thousand bitcoins out of thin air.  The market would love the former but abhor the later.  I believe you can recognize the difference.  


>> Type 2 consensus failures are more severe but also less likely (I?m not aware of a Type 2 consensus failure besides the 92 million bitcoin bug from August 2010).  If Core was to accept a rogue TX that created another 92 million bitcoins, I think it would be a good thing if the other implementations forked away from it (we don?t want bug-for-bug compatibility here).
> 
> The only consensus consistency error we've ever that I would have
> classified as potentially type 1 had has been the BDB locks issue.

Thank you for conceding on that point. 

> Every other one, including the most recently fixed one (eliminated by
> BIP66) was a type 2, by your description. They are _much_ more common;
> because if the author understood the possible cases well enough to
> create an "I don't know" case, they could have gone one step further
> and fully defined it in a consistent way. The fact that an
> inconsistency was possible was due to a lack of complete knowledge.
> 
> Even in the BDB locks case, I don't know that the type 1 distinction
> completely applies, a lower layer piece of software threw an error
> that higher layer software didn't know was possible, and so it
> interpreted "I don't know" as "no"-- it's not that it chose to treat I
> don't know as no, its that it wasn't authored with the possibility of
> I don't know in mind, and that exceptions were used to handle general
> failures (which should have been treated as no). Once you step back to
> the boundary of the calling code (much less the whole application) the
> "I don't know" doesn't exist anymore; there.

Please don?t take my comments and observations as criticisms.  I think the Core Dev team has done excellent work!  What I am saying instead is that as we move forward?as development becomes decentralized and multiple protocol implementations emerge?development philosophies will change. Tracking consensus and the will of the market will be most important.  Personally, I hope to see design philosophies that support ?bottom up? governance instead of the current ?top down? model.  

Best regards,
Peter




From luke at dashjr.org  Sun Nov 15 03:04:33 2015
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 15 Nov 2015 03:04:33 +0000
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
Message-ID: <201511150304.41003.luke@dashjr.org>

On Sunday, November 15, 2015 1:02:33 AM Peter R via bitcoin-dev wrote:
> A group of us have been exploring this ?meta-cognition? idea with Bitcoin
> Unlimited.  For example, Bitcoin Unlimited can be (optionally) made to
> automatically fork to the longest chain if it ?gets stuck? and can neither
> prove that a block is valid nor that the block is invalid.

This situation isn't something that can be ignored and simply moved past. If 
you can't determine the validity of a block, you also cannot process its 
results correctly. Taking for example the BDB/LevelDB issue, the result was 
that BDB failed to accept further changes to the UTXO set. Unless the UTXO set 
could be updated correctly, there is no way to even attempt to validate the 
next block or any new transactions.

Luke

From peter_r at gmx.com  Sun Nov 15 03:17:08 2015
From: peter_r at gmx.com (Peter R)
Date: Sat, 14 Nov 2015 19:17:08 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <201511150304.41003.luke@dashjr.org>
References: <5631C363.5060705@neomailbox.net>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<201511150304.41003.luke@dashjr.org>
Message-ID: <F2D5CE08-FEF1-4E56-8B76-3E7964FC1C7B@gmx.com>


> On Sunday, November 15, 2015 1:02:33 AM Peter R via bitcoin-dev wrote:
>> A group of us have been exploring this ?meta-cognition? idea with Bitcoin
>> Unlimited.  For example, Bitcoin Unlimited can be (optionally) made to
>> automatically fork to the longest chain if it ?gets stuck? and can neither
>> prove that a block is valid nor that the block is invalid.
> 
> This situation isn't something that can be ignored and simply moved past. If 
> you can't determine the validity of a block, you also cannot process its 
> results correctly. Taking for example the BDB/LevelDB issue, the result was 
> that BDB failed to accept further changes to the UTXO set. Unless the UTXO set 
> could be updated correctly, there is no way to even attempt to validate the 
> next block or any new transactions.

Great point, Luke! 

Indeed, whether the program can or cannot continue after a Type 1 consensus mismatch depends on the specifics of the situation and exactly how the code was written.  But I agree: there are cases where the program *can?t* continue.  In those cases it would halt.  This would require manual intervention to fix but avoids the problem of potential double-spends during the fork event.  This would be preferable to knowingly causing a fork.  

Peter

From gmaxwell at gmail.com  Sun Nov 15 03:30:45 2015
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Sun, 15 Nov 2015 03:30:45 +0000
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
Message-ID: <CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>

On Sun, Nov 15, 2015 at 2:58 AM, Peter R <peter_r at gmx.com> wrote:
> I think you?re being intentionally obtuse here: accepting a block composed entirely of valid transactions that is 1.1 MB is entirely different than accepting a TX that creates a ten thousand bitcoins out of thin air.  The market would love the former but abhor the later.  I believe you can recognize the difference.

It is not technically distinct--today; politically-- perhaps, but--
sorry, no element of your prior message indicated that you were
interested in discussing politics rather than technology; on a mailing
list much more strongly scoped for the latter; I hope you can excuse
me for missing your intention prior to your most recent post.

That said, I believe you are privileging your own political
preferences in seeing the one rule of the bitcoin system as
categorically distinct even politically. No law of nature leaves the
other criteria I specified less politically negotiable, and we can see
concrete examples all around us -- the notion that funds can be
confiscated via external authority (spending without the owners
signature) is a more or less universal property of other modern
systems of money, that economic controls out to exist to regulate the
supply of money for the good of an economy is another widely deployed
political perspective. You, yourself, recently published a work on the
stable self regulation of block sizes based on mining incentives that
took as its starting premise a bitcoin that was forever inflationary.
Certainly things differ in degrees, but this is not the mailing list
to debate the details of political inertia.

> Thank you for conceding on that point.

You're welcome, but I would have preferred that you instead of your
thanks you would have responded in kind and acknowledged my correction
that other consensus inconsistencies discovered in implementations
thus far (none, that I'm aware of) could be classified as "maybe"; and
in doing so retained a semblance of a connection to a the technical
purposes of this mailing list.

From peter_r at gmx.com  Sun Nov 15 04:10:30 2015
From: peter_r at gmx.com (Peter R)
Date: Sat, 14 Nov 2015 20:10:30 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
Message-ID: <2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>

Hi Greg,

>> Thank you for conceding on that point.
> 
> You're welcome, but I would have preferred that you instead of your
> thanks you would have responded in kind and acknowledged my correction
> that other consensus inconsistencies discovered in implementations
> thus far (none, that I'm aware of) could be classified as "maybe"; and
> in doing so retained a semblance of a connection to a the technical
> purposes of this mailing list.

I apologize for that, Greg.  I have not read enough on the issues you brought up to comment intelligibly.  I should have conceded that you could very well be correct that those were Type 2 consensus failures.  

>> I think you?re being intentionally obtuse here: accepting a block composed entirely of valid transactions that is 1.1 MB is entirely different than accepting a TX that creates a ten thousand bitcoins out of thin air.  The market would love the former but abhor the later.  I believe you can recognize the difference.
> 
> It is not technically distinct--today; politically-- perhaps, but--
> sorry, no element of your prior message indicated that you were
> interested in discussing politics rather than technology; on a mailing
> list much more strongly scoped for the latter; I hope you can excuse
> me for missing your intention prior to your most recent post.

The difference between a 1.1 MB block full of valid transactions and an invalid TX that creates 10,000 BTC out of thin air is *not* a matter of ?politics.?  If people could freely award themselves coins, then Bitcoin would not be money.  It?s like saying that ?technically? there?s no difference between picking up a penny from the sidewalk and holding up a bank teller at gunpoint.  Ask the average person: there is more than a ?political? difference between creating coins out of thin air and increasing the block size limit. 
 
> That said, I believe you are privileging your own political
> preferences in seeing the one rule of the bitcoin system as
> categorically distinct even politically.

What rules does Bitcoin obey?  What is Bitcoin?s nature?  This brings us to the age-old debate between Rationalism versus Empiricism.

Rationalism holds that some propositions are known to be true by intuition alone and that others are knowable by being deduced from intuited propositions. The Rationalist may hold the view that Bitcoin has a 21-million coin limit or a 1 MB block size limit, based on deductive reasoning from the rules enforced by the Bitcoin Core source code. Such a Rationalists might believe that the code represents some immutable truth and then his understanding of Bitcoin follows from axiomatic deductions from that premise.

The Empiricist rejects the Rationalist?s intuition and deduction, believing instead that knowledge is necessarily a posteriori, dependent upon observation and sense experience. The Empiricist questions the notion that Bitcoin has a 21-million coin limit, instead observing that its money supply grew by 50 BTC per block for the first 210,000 and then 25 BTC per block ever since. The Empiricist rejects the idea that Bitcoin has any sort of block size limit, having observed previous empirical limits collapse in the face of increased demand.

I am not convinced that Bitcoin even *has* a block size limit, let alone that it can enforce one against the invisible hand of the market.  

> No law of nature leaves the
> other criteria I specified less politically negotiable, and we can see
> concrete examples all around us -- the notion that funds can be
> confiscated via external authority (spending without the owners
> signature) is a more or less universal property of other modern
> systems of money, that economic controls out to exist to regulate the
> supply of money for the good of an economy is another widely deployed
> political perspective. You, yourself, recently published a work on the
> stable self regulation of block sizes based on mining incentives that
> took as its starting premise a bitcoin that was forever inflationary.
> Certainly things differ in degrees, but this is not the mailing list
> to debate the details of political inertia.

You were the one who just brought up politics, Greg.  Not I. 

Best regards,
Peter


From johnathan at corganlabs.com  Sun Nov 15 06:04:10 2015
From: johnathan at corganlabs.com (Johnathan Corgan)
Date: Sat, 14 Nov 2015 22:04:10 -0800
Subject: [bitcoin-dev] How to evaluate block size increase suggestions.
In-Reply-To: <B2C858C1-B15F-49F1-BF7E-02EA7C3FE474@gmx.com>
References: <CAPkFh0s-o6BXAEC-s9s1UmFwVfMFQKStoJaM0u2Lct9yiP5QBQ@mail.gmail.com>
	<B2C858C1-B15F-49F1-BF7E-02EA7C3FE474@gmx.com>
Message-ID: <CALOxbZtt8k4Q+h0ZwKDQS7-UUpYKoM0dNd8vXUg5Z9i1MCf_iw@mail.gmail.com>

This topic is straying from Bitcoin development into general Bitcoin
governance, policy, or other meta-issues.

We have now the new bitcoin-discuss mailing list now, specifically for
these more free-flowing topics:

https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-discuss

Please take further discussion of this thread to that forum.

Thank you,

The bitcoin-dev moderation team


On Sat, Nov 14, 2015 at 1:45 PM, Peter R via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> > It looks like some specific meta-level criteria would help more at this
> point than new proposals all exploring a different variants of block size
> increase schedules.
>
> I agree.  In fact, I?ll go meta on your meta and suggest that we should
> first discuss how Bitcoin should be governed in the first place.  Should
> Bitcoin evolve from the ?bottom up,? or from the ?top down??
>
> If one?s answer is from the ?top-down,? then the meta-level criteria can
> be endlessly debated, for they all involve some sort of tradeoff, they all
> require some sort of compromise.  The ?top down? perspective holds that
> people might make poor choices if given the freedom to easily do so--it
> holds that the trade-offs must be balanced instead by experts.
>
> However, if one's answer is from the ?bottom up,? then the meta-level
> criteria is very easy: we do what the people wants. We allow the people to
> weigh the tradeoffs and then we watch as consensus emerges through a
> decentralized process, objectively represented by the longest proof-of-work
> chain.
>
> Regarding the block size limit debate, at the end of the day it comes down
> to two things:
>
> 1.  How big of a block will my node accept today?
>
> 2.  What do I want my node to do if the longest chain includes a block
> larger than the limit I set?
>
> If one concedes that Bitcoin should be governed from the ?bottom up,? then
> it is already possible to empower each node operator to more easily express
> his free choice regarding the size of blocks he is willing to accept, while
> simultaneously ensuring that his node tracks consensus.
>
> Best regards,
> Peter
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151114/ee289deb/attachment-0001.html>

From jtimon at jtimon.cc  Sun Nov 15 10:12:22 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 15 Nov 2015 11:12:22 +0100
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
Message-ID: <CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>

On Nov 15, 2015 5:10 AM, "Peter R via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> What rules does Bitcoin obey?

Thanks to the worl of many people, part of the consensus rules are finally
encapsulated in the libbitcoinconsensus library. I'm currently writing a
document to complete the encapsulation of the specification of the
consensus rules.

> I am not convinced that Bitcoin even *has* a block size limit, let alone
that it can enforce one against the invisible hand of the market.

You keep insisting that some consensus rules are not consensus rules while
others "are clearly a very different thing". What technical difference is
there between the rule that impedes me from creating transactions bigger
than X and the rules that prevent me frm creatin new coins (not as a miner,
as a regular user in a transaction with more coins in the outputs than in
the inputs)? What about property enforcement? If the invisible hand of the
market is what decides consensus rules instead of their (still incomple)
specification (aka libconsensus), then the market could decide to stop
enforcing ownership.
Will you still think that Bitcoin is a useful system when/if you
empirically observe the invisible hand of the market taking coins out of
your pocket?

You also keep assuming that somehow it is a universal law that users must
eventually converge under the most-work chain. People follow the most-work
VALID chain, but if they consciously decide to implement different rules
(different definitions of "valid block") then their chains can diverge, and
once they do they won't converge again (unless/until one group decides to
implement the rules of the other exactly again), just like when the
implementation of the rules diverge in a unintentional consensus fork. But
in this case they could decide to never implement the same rules.
See bip99 and specially the "schism hardforks" section for more details.

> You were the one who just brought up politics, Greg.  Not I.

Please, read the thread again. I think it is pretty clear that you did.
Nothing wrong with that, just move it to the discussion ml.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151115/15c036c5/attachment.html>

From jtimon at jtimon.cc  Sun Nov 15 11:28:44 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 15 Nov 2015 12:28:44 +0100
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
Message-ID: <CABm2gDrUavAxgXcq8R4J99ZbVoWmOnoAWAnjQJDZo5HagNtN5w@mail.gmail.com>

Going back on topic, I believe libconsensus shouldn't depend on any
particular database because assuming it will continue to be stateless
(the current libbitcoinconsensus is stateless) end therefore has no
storage. I know some people disagree in various degrees.
At the same time, the parts of the consensus rules verification that
depends on storage has not been encapsulated out to
libbitcoinconsensus yet, and I agree that changing the database is
unnecessarily risky at this point.
Even when the consensus rules are encapsulated, that doesn't mean that
Bitcoin Core should be DB agnostic or that we can guarantee that it
will follow the longest valid chain with databases that have not been
tested.

From jtimon at jtimon.cc  Sun Nov 15 11:42:33 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 15 Nov 2015 12:42:33 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
	<CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
Message-ID: <CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>

Thank you for incorporating the feedback, specifically thank you for
using the genesis block hash as the unique chain ID.

I wen't through the BIP draft and left a few of comments, but I really
like its simplicity and focus. Good work!

On Sun, Nov 15, 2015 at 3:14 AM, Marco Pontello via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi!
>
> To anyone that followed the discussion (from some time ago) about the
> proposed new URI for Blockchain references / exploration, I just wanted to
> point out that I have collected the feedback provided, reworked the text,
> put the BIP on GitHub and created a pull request:
>
> https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
> https://github.com/bitcoin/bips/pull/202
>
> The need for an URI for this come to mind again in the last days looking at
> Eternity Wall, which IMHO provide a use case that we will see more and more
> in the (near) future: http://eternitywall.it/
> Using that service, when you want to check for the proof that a specific
> message was written in the Blockchain, it let you choose from 5 different
> explorer.
> Mycelium wallet recently added the option to select one of 15 block
> explorers.
> And there's the crypto_bot on reddit/r/bitcoin that detect reference to
> transaction an add a message with links to 7 different explorers.
>
> I think that's clearly something that's needed.
>
> Bye!
>
>
> On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <marcopon at gmail.com> wrote:
>>
>> Hi!
>> My first post here, hope I'm following the right conventions.
>> I had this humble idea for a while, so I thought to go ahead and propose
>> it.
>>
>> BIP: XX
>> Title: URI scheme for Blockchain exploration
>> Author: Marco Pontello
>> Status: Draft
>> Type: Standards Track
>> Created: 29 August 2015
>>
>> Abstract
>> ========
>> This BIP propose a simple URI scheme for looking up blocks, transactions,
>> addresses on a Blockchain explorer.
>>
>> Motivation
>> ==========
>> The purpose of this URI scheme is to enable users to handle all the
>> requests for details about blocks, transactions, etc. with their preferred
>> tool (being that a web service or a local application).
>>
>> Currently a Bitcoin client usually point to an arbitrary blockchain
>> explorer when the user look for the details of a transaction (es. Bitcoin
>> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info, etc.).
>> Other times resorting to cut&paste is needed.
>> The same happens with posts and messages that reference some particular
>> txs or blocks, if they provide links at all.
>>
>> Specification
>> =============
>> The URI follow this simple form:
>>
>> blockchain: <hash/string>
>>
>> Examples:
>>
>>
>> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
>> blockchain:001949
>>
>> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
>>
>> Rationale
>> =========
>> I thought about using some more complex scheme, or adding qualifiers to
>> distinguish blocks from txs, but in the end I think that keeping it simple
>> should be practical enough. Blockchain explorers can apply the same
>> disambiguation rules they are already using to process the usual search
>> box.
>>
>> From the point of view of a wallet developer (or other tool that need to
>> show any kind of Blockchain references), using this scheme mean that he
>> can simply make it a blockchain: link and be done with it, without having
>> to worry about any specific Blockchain explorer or provide a means for the
>> user to select one.
>>
>> Blockchain explorers in turn will simply offer to handle the blockchain:
>> URI, the first time the user visit their website, or launch/install the
>> application, or even set themselves if there isn't already one.
>>
>> Users get the convenience of using always their preferred explorer, which
>> can be especially handy on mobile devices, where juggling with cut&paste
>> is far from ideal.
>>
>>
>
>
>
> --
> Try the Online TrID File Identifier
> http://mark0.net/onlinetrid.aspx
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From jtimon at jtimon.cc  Sun Nov 15 12:16:56 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 15 Nov 2015 13:16:56 +0100
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <201511142127.53255.luke@dashjr.org>
References: <201511132228.47815.luke@dashjr.org>
	<201511142111.24046.luke@dashjr.org>
	<CADZB0_Z3Kf4GW0VATjb10kJF0aFgyFOcqX_=y+LFoUpsi+TRUA@mail.gmail.com>
	<201511142127.53255.luke@dashjr.org>
Message-ID: <CABm2gDryvFsnnV=8Bwc8mQX4JtU9_PgJ0EBhcYjpcSdXjV2_WA@mail.gmail.com>

On Sat, Nov 14, 2015 at 10:11 PM, Luke Dashjr <luke at dashjr.org> wrote:
> On Saturday, November 14, 2015 10:52:12 AM Jorge Tim?n via bitcoin-dev wrote:
>> Currently bip99 recommends 95% miner upgrade confirmation with version bits
>> (bip9) for uncontroversial hardforks just like it does for uncontroversial
>> softforks. It is true that in the case of hardforks miners don't decide and
>> it's the whole economy who has to upgrade before activation, but "the whole
>> economy" and "all users" includes miners, so why not use the only upgrade
>> confirmation mechanism that we have available?
>
> Actually, the economy does not necessarily include miners, and in fact the
> present miner community for the most part does not overlap significantly with
> economic activity.

Maybe we should define "the bitcoin economy" is first. In my
definition, miners are definitely part of the economy (and also users
of the system).

On Sat, Nov 14, 2015 at 10:27 PM, Luke Dashjr <luke at dashjr.org> wrote:
> On Saturday, November 14, 2015 9:15:07 PM Angel Leon wrote:
>> "the economy does not necessarily include miners"
>> so the money supply isn't part of the economy?
>
> Not in the context of economic majority deciding hardforks. After all, the
> outcome of the hardfork *determines* the money supply. So the former money
> supply not supporting the change would just mean they cease to be involved in
> that capacity. But even aside from that, the more relevant factor in terms of
> economic involvement is /acceptance/ of bitcoins as payment for real goods.

Miners accept bitcoins as payment for a real service (with real costs
like electricity) to the network: extending the longest valid chain
with their proof of work.
In the context of BIP99, there's no concept of "an economic majority"
deciding hardforks. Hardforks are either uncontroversial, in which
case BIP99 recommends 95% miner upgrade confirmation in addition to a
time threshold, or are schism hardforks (for example, an anti-miner
hardfork), in which case BIP99 recommends using a time threshold
alone. But no majority can force the dissenting users to use one
validation rule set or the other: users will always be free to run
whatever free software they like.

> And at the same time, miners also have a tendency to
> upgrade at a different rate than the economy.

That alone seems like a very good reason in favor to confirm that
miners have upgraded in addition to a minimal activation block median
time, not a reason against it

> It might make sense to
> incorporate a miner-trigger, but *only if* the flag is enabled in nodes by an
> option disabled by default, and the BIP clearly specifies that miners must not
> enable it until they perceive complete economic adoption of the change.

I'm not sure I understand this. The trigger mechanism must be uniform
for each rule change, it cannot be optionally different or consensus
can fail.
How are miners supposed to "perceive" adoption?
The time threshold must be set enough in the future to give users time
to upgrade. But we can perceive miners' adoption, so if the system
knows they haven't upgraded, it should wait for them to upgrade (it
would be nice to have an equivalent mechanism to wait for the rest of
the users, but unfortunately there's none).
Please, remember that this is in the context of uncontroversial
hardforks for which all users (including all miners) are expected to
upgrade to.
To reiterate, schism hardforks are treated differently and the miner
upgrade confirmation becomes completely irrelevant.

From peter_r at gmx.com  Sun Nov 15 15:48:35 2015
From: peter_r at gmx.com (Peter R)
Date: Sun, 15 Nov 2015 07:48:35 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CABm2gDrUavAxgXcq8R4J99ZbVoWmOnoAWAnjQJDZo5HagNtN5w@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
	<CABm2gDrUavAxgXcq8R4J99ZbVoWmOnoAWAnjQJDZo5HagNtN5w@mail.gmail.com>
Message-ID: <5423F50E-A55B-4A18-9C88-84DDE405D619@gmx.com>


> On Nov 15, 2015, at 3:28 AM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> 
> Going back on topic, I believe libconsensus shouldn't depend on any
> particular database because assuming it will continue to be stateless
> (the current libbitcoinconsensus is stateless) end therefore has no
> storage.

Agreed.  


From peter_r at gmx.com  Sun Nov 15 17:06:58 2015
From: peter_r at gmx.com (Peter R)
Date: Sun, 15 Nov 2015 09:06:58 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
Message-ID: <D64AA4C7-BB66-41B2-A001-107985071DA1@gmx.com>

Hello Jorge:
> > What rules does Bitcoin obey? 
> 
> Thanks to the worl of many people, part of the consensus rules are finally encapsulated in the libbitcoinconsensus library. I'm currently writing a document to complete the encapsulation of the specification of the consensus rules.
> 
I applaud your work on the consensus library.  I think it an important step to encouraging multiple competing implementations of the protocol.
> > I am not convinced that Bitcoin even *has* a block size limit, let alone that it can enforce one against the invisible hand of the market.
> 
> You keep insisting that some consensus rules are not consensus rules while others "are clearly a very different thing". What technical difference is there between the rule that impedes me from creating transactions bigger than X and the rules that prevent me frm creatin new coins (not as a miner, as a regular user in a transaction with more coins in the outputs than in the inputs)?
> 
What technical difference is there between a cat and a dog? They both have four legs and a furry coat. 

I think you?re using the term ?technical difference? to mean something very specific.  Perhaps you could clarify exactly how you are defining that term because to me it is crystal clear that creating coins out of thin air is very different than accepting a block 1.1 MB in size and full of valid TXs.  There are many technical differences between the two. For example, technically the first allows coins to be created randomly while the second doesn?t.  
> What about property enforcement? If the invisible hand of the market is what decides consensus rules instead of their (still incomple) specification (aka libconsensus), then the market could decide to stop enforcing ownership.
> 
Correct.  Bitcoin is an experiment and could still fail (e.g., the network could allow people to move coins without valid signatures).  For Bitcoin to be viable, the network of miners and node operators being net-econo-rational actually is probably a core axiom that must be accepted.  
> You also keep assuming that somehow it is a universal law that users must eventually converge under the most-work chain. People follow the most-work VALID chain, but if they consciously decide to implement different rules (different definitions of "valid block") then their chains can diverge, and once they do they won't converge again (unless/until one group decides to implement the rules of the other exactly again)
> 
It is fact that two competing forks can persist for at least a short amount of time?we saw this a few years ago with the LevelDB bug and again this summer with the SPV mining incident.  In both cases, there was tremendous pressure to converge back to a single chain.

Could two chains persist indefinitely?  I don?t know.  No one knows.  My gut feeling is that since users would have coins on both sides of the fork, there would be a fork arbitrage event (a ?forkbitrage?) where speculators would sell the coins on the side they predict to lose in exchange for additional coins on the side they expect to win.  This could actually be facilitated by exchanges once the fork event is credible and before the fork actually occurs, or even in a futures market somehow.  I suspect that the forkbitrage would create an unstable equilibrium where coins on one side quickly devalue.  Miners would then abandon that side in favour of the other, killing the fork because difficulty would be too high to find new blocks.  Anyways, I think even *this* would be highly unlikely.  I suspect nodes and miners would get inline with consensus as soon as the fork event was credible.  

Cryptocurrency is a new area of interdisciplinary research.  We are all learning together and no one knows how things will unfold.  

Best regards,
Peter

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151115/864944e1/attachment.html>

From marcopon at gmail.com  Mon Nov 16 00:59:46 2015
From: marcopon at gmail.com (Marco Pontello)
Date: Mon, 16 Nov 2015 01:59:46 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
	<CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
	<CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>
Message-ID: <CAE0pACLyuaU=gJji1DkC1xkpmRjCFdRReLHa8zsD04+aDDQLeA@mail.gmail.com>

Thanks for the comments! Now I fixed the typos (hope to have got them all,
English isn't my first language), clarified the chain part a bit, and fixed
the link. There probably is a better way to reference that source code part
with the genesis blocks hashs, in a way that doesn't need to be changed,
maybe...

Now the main change would be to put in a proper BIP number! :)

On Sun, Nov 15, 2015 at 12:42 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:

> Thank you for incorporating the feedback, specifically thank you for
> using the genesis block hash as the unique chain ID.
>
> I wen't through the BIP draft and left a few of comments, but I really
> like its simplicity and focus. Good work!
>
> On Sun, Nov 15, 2015 at 3:14 AM, Marco Pontello via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Hi!
> >
> > To anyone that followed the discussion (from some time ago) about the
> > proposed new URI for Blockchain references / exploration, I just wanted
> to
> > point out that I have collected the feedback provided, reworked the text,
> > put the BIP on GitHub and created a pull request:
> >
> > https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
> > https://github.com/bitcoin/bips/pull/202
> >
> > The need for an URI for this come to mind again in the last days looking
> at
> > Eternity Wall, which IMHO provide a use case that we will see more and
> more
> > in the (near) future: http://eternitywall.it/
> > Using that service, when you want to check for the proof that a specific
> > message was written in the Blockchain, it let you choose from 5 different
> > explorer.
> > Mycelium wallet recently added the option to select one of 15 block
> > explorers.
> > And there's the crypto_bot on reddit/r/bitcoin that detect reference to
> > transaction an add a message with links to 7 different explorers.
> >
> > I think that's clearly something that's needed.
> >
> > Bye!
> >
> >
> > On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <marcopon at gmail.com>
> wrote:
> >>
> >> Hi!
> >> My first post here, hope I'm following the right conventions.
> >> I had this humble idea for a while, so I thought to go ahead and propose
> >> it.
> >>
> >> BIP: XX
> >> Title: URI scheme for Blockchain exploration
> >> Author: Marco Pontello
> >> Status: Draft
> >> Type: Standards Track
> >> Created: 29 August 2015
> >>
> >> Abstract
> >> ========
> >> This BIP propose a simple URI scheme for looking up blocks,
> transactions,
> >> addresses on a Blockchain explorer.
> >>
> >> Motivation
> >> ==========
> >> The purpose of this URI scheme is to enable users to handle all the
> >> requests for details about blocks, transactions, etc. with their
> preferred
> >> tool (being that a web service or a local application).
> >>
> >> Currently a Bitcoin client usually point to an arbitrary blockchain
> >> explorer when the user look for the details of a transaction (es.
> Bitcoin
> >> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info, etc.).
> >> Other times resorting to cut&paste is needed.
> >> The same happens with posts and messages that reference some particular
> >> txs or blocks, if they provide links at all.
> >>
> >> Specification
> >> =============
> >> The URI follow this simple form:
> >>
> >> blockchain: <hash/string>
> >>
> >> Examples:
> >>
> >>
> >>
> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
> >> blockchain:001949
> >>
> >>
> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
> >>
> >> Rationale
> >> =========
> >> I thought about using some more complex scheme, or adding qualifiers to
> >> distinguish blocks from txs, but in the end I think that keeping it
> simple
> >> should be practical enough. Blockchain explorers can apply the same
> >> disambiguation rules they are already using to process the usual search
> >> box.
> >>
> >> From the point of view of a wallet developer (or other tool that need to
> >> show any kind of Blockchain references), using this scheme mean that he
> >> can simply make it a blockchain: link and be done with it, without
> having
> >> to worry about any specific Blockchain explorer or provide a means for
> the
> >> user to select one.
> >>
> >> Blockchain explorers in turn will simply offer to handle the blockchain:
> >> URI, the first time the user visit their website, or launch/install the
> >> application, or even set themselves if there isn't already one.
> >>
> >> Users get the convenience of using always their preferred explorer,
> which
> >> can be especially handy on mobile devices, where juggling with cut&paste
> >> is far from ideal.
> >>
> >>
> >
> >
> >
> > --
> > Try the Online TrID File Identifier
> > http://mark0.net/onlinetrid.aspx
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>



-- 
Try the Online TrID File Identifier
http://mark0.net/onlinetrid.aspx
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151116/978ce25b/attachment-0001.html>

From rusty at rustcorp.com.au  Mon Nov 16 01:52:28 2015
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 16 Nov 2015 12:22:28 +1030
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
Message-ID: <87fv06pv6r.fsf@rustcorp.com.au>

Peter R via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> You are looking at the problem from a ?top down? governance
> perspective assuming you know what code is actually being run and what
> rules the market wants.

We have strayed far from both the Subject line and from making progress
on bitcoin development.  Please redirect to bitcoin-discuss.

I have set the moderation bits on the three contributors from here down
(CC'd): your next post will go to moderation.

Thanks,
Rusty.

From laanwj at gmail.com  Mon Nov 16 07:49:15 2015
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 16 Nov 2015 08:49:15 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.11.2 released
In-Reply-To: <CAGLBAhcMMLnze8N=OLK0EypatRKEhFkHTJDo_KJyc_A1h1d-uA@mail.gmail.com>
References: <20151113131353.GA26622@amethyst.visucore.com>
	<CAGLBAhcMMLnze8N=OLK0EypatRKEhFkHTJDo_KJyc_A1h1d-uA@mail.gmail.com>
Message-ID: <20151116074914.GA10127@amethyst.visucore.com>


I'm not sure that's the right way to go about verifing gpg keys.
Copy/pasting from webpages is going to run into padding/character set conversion issues, resulting in potential false negatives. If you want to verify mails, you have to verify the original mail, which archives don't make easy (or even possible).

So I'd do this:

The binary release signing key is signed by my normal key:

$ gpg --list-sigs 36C2E964

    pub   4096R/36C2E964 2015-06-24 [expires: 2017-02-13]
    uid                  Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj at gmail.com>
    sig 3        36C2E964 2015-06-24  Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj at gmail.com>
    sig          2346C9A6 2015-06-24  Wladimir J. van der Laan <laanwj at visucore.com>

My normal key in turn is signed by a lot of different people.

$ gpg --list-sigs 2346C9A6

...

Also, both keys can be found on bitcoin.org in the list of developers, as well
as linked on the download page:

https://bitcoin.org/en/download

Wladimir

On Fri, Nov 13, 2015 at 06:10:29PM -0800, Dave Scotese via bitcoin-dev wrote:
> I decided to try to certify Wladimir's PGP keys (the old one (2346C9A6)
> first, and then the new one (36C2E964), since it was signed with the old
> one).
> 
> I visited
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-June/009045.html
> to see that the new key was referenced in a message signed by the old one.
> I figure it's safe to assume that if the old key actually signed that
> message, then the core dev using <laanwj at gmail.com
> <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>> is an
> actual core dev (that's all I'd be worried about).  So I copied the text
> from ------BEGIN PGP SIGNED MESSAGE----- to -----END PGP SIGNATURE----- to
> my clipboard and asked Kleopatra (on Windows) to verify it.  It says the
> signature is bad.  If I alter the text of the email (so the signature would
> be have to be different to be valid), it says exactly the same thing.  So
> maybe something is wrong with Kleopatra on Windows.
> 
> However, the SHA256SUMS.asc file I got from the magnet link posted in the
> email (below)  verifies just fine using the new key (36C2E964).  So I
> figure Kleopatra is not broken.  It recognizes that the old key was used to
> create the signature in that old email, but it says it's invalid.  Has
> Wladimir been secretly replaced by someone who doesn't have access to the
> private key for 2346C9A6?  Can you make a (bad) signature look like it was
> made using a key you don't have? The whole reason for signing is so that we
> will know if something like that happened.  So did I do something wrong?
> (I mean, besides using Windows).
> 
> I believe this is the expected result if someone took something Wladimir
> signed and ripped off the signature and pasted it below this new message to
> make everyone think the new message was genuine.  Maybe Wladimir made an
> edit after the signature was attached.  Or maybe it got changed when it
> went through the email system.  It would be nice to know.  Anyway, I fell
> back on Windows security and ran the install because it said it verified
> that the publisher was "The Bitcoin Foundation".
> 
> 
> On Fri, Nov 13, 2015 at 5:13 AM, Wladimir J. van der Laan via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > -----BEGIN PGP SIGNED MESSAGE-----
> > Hash: SHA512
> >
> > Bitcoin Core version 0.11.2 is now available from:
> >
> >   <https://bitcoin.org/bin/bitcoin-core-0.11.2/>
> >
> > Alternatively, through bittorrent:
> >
> >
> > magnet:?xt=urn:btih:d6d3387160f7e14f6f27dc40ae84cf566ebf631b&dn=bitcoin-core-0.11.2&tr=udp%3A%2F%
> > 2Ftracker.openbittorrent.com%3A80%2Fannounce&tr=udp%3A%2F%
> > 2Ftracker.publicbt.com%3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.ccc.de
> > %3A80%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk
> > %3A6969&tr=udp%3A%2F%2Fopen.demonii.com
> > %3A1337&ws=https%3A%2F%2Fbitcoin.org%2Fbin%2F
> >
> > This is a new minor version release, bringing bug fixes, the BIP65
> > (CLTV) consensus change, and relay policy preparation for BIP113. It is
> > recommended to upgrade to this version as soon as possible.
> >
> > Please report bugs using the issue tracker at github:
> >
> >   <https://github.com/bitcoin/bitcoin/issues>
> >
> > Upgrading and downgrading
> > =========================
> >
> > How to Upgrade
> > - --------------
> >
> > If you are running an older version, shut it down. Wait until it has
> > completely
> > shut down (which might take a few minutes for older versions), then run the
> > installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac)
> > or
> > bitcoind/bitcoin-qt (on Linux).
> >
> > Downgrade warning
> > - ------------------
> >
> > Because release 0.10.0 and later makes use of headers-first
> > synchronization and
> > parallel block download (see further), the block files and databases are
> > not
> > backwards-compatible with pre-0.10 versions of Bitcoin Core or other
> > software:
> >
> > * Blocks will be stored on disk out of order (in the order they are
> > received, really), which makes it incompatible with some tools or
> > other programs. Reindexing using earlier versions will also not work
> > anymore as a result of this.
> >
> > * The block index database will now hold headers for which no block is
> > stored on disk, which earlier versions won't support.
> >
> > If you want to be able to downgrade smoothly, make a backup of your entire
> > data
> > directory. Without this your node will need start syncing (or importing
> > from
> > bootstrap.dat) anew afterwards. It is possible that the data from a
> > completely
> > synchronised 0.10 node may be usable in older versions as-is, but this is
> > not
> > supported and may break as soon as the older version attempts to reindex.
> >
> > This does not affect wallet forward or backward compatibility. There are no
> > known problems when downgrading from 0.11.x to 0.10.x.
> >
> > Notable changes since 0.11.1
> > ============================
> >
> > BIP65 soft fork to enforce OP_CHECKLOCKTIMEVERIFY opcode
> > - --------------------------------------------------------
> >
> > This release includes several changes related to the [BIP65][] soft fork
> > which redefines the existing OP_NOP2 opcode as OP_CHECKLOCKTIMEVERIFY
> > (CLTV) so that a transaction output can be made unspendable until a
> > specified point in the future.
> >
> > 1. This release will only relay and mine transactions spending a CLTV
> >    output if they comply with the BIP65 rules as provided in code.
> >
> > 2. This release will produce version 4 blocks by default. Please see the
> >    *notice to miners* below.
> >
> > 3. Once 951 out of a sequence of 1,001 blocks on the local node's best
> > block
> >    chain contain version 4 (or higher) blocks, this release will no
> >    longer accept new version 3 blocks and it will only accept version 4
> >    blocks if they comply with the BIP65 rules for CLTV.
> >
> > For more information about the soft-forking change, please see
> > <https://github.com/bitcoin/bitcoin/pull/6351>
> >
> > Graphs showing the progress towards block version 4 adoption may be
> > found at the URLs below:
> >
> > - - Block versions over the last 50,000 blocks as progress towards BIP65
> >   consensus enforcement: <http://bitcoin.sipa.be/ver-50k.png>
> >
> > - - Block versions over the last 2,000 blocks showing the days to the
> >   earliest possible BIP65 consensus-enforced block: <
> > http://bitcoin.sipa.be/ver-2k.png>
> >
> > **Notice to miners:** Bitcoin Core?s block templates are now for
> > version 4 blocks only, and any mining software relying on its
> > getblocktemplate must be updated in parallel to use libblkmaker either
> > version 0.4.3 or any version from 0.5.2 onward.
> >
> > - - If you are solo mining, this will affect you the moment you upgrade
> >   Bitcoin Core, which must be done prior to BIP65 achieving its 951/1001
> >   status.
> >
> > - - If you are mining with the stratum mining protocol: this does not
> >   affect you.
> >
> > - - If you are mining with the getblocktemplate protocol to a pool: this
> >   will affect you at the pool operator?s discretion, which must be no
> >   later than BIP65 achieving its 951/1001 status.
> >
> > [BIP65]: https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
> >
> > BIP113 mempool-only locktime enforcement using GetMedianTimePast()
> > - ----------------------------------------------------------------
> >
> > Bitcoin transactions currently may specify a locktime indicating when
> > they may be added to a valid block.  Current consensus rules require
> > that blocks have a block header time greater than the locktime specified
> > in any transaction in that block.
> >
> > Miners get to choose what time they use for their header time, with the
> > consensus rule being that no node will accept a block whose time is more
> > than two hours in the future.  This creates a incentive for miners to
> > set their header times to future values in order to include locktimed
> > transactions which weren't supposed to be included for up to two more
> > hours.
> >
> > The consensus rules also specify that valid blocks may have a header
> > time greater than that of the median of the 11 previous blocks.  This
> > GetMedianTimePast() time has a key feature we generally associate with
> > time: it can't go backwards.
> >
> > [BIP113][] specifies a soft fork (**not enforced in this release**) that
> > weakens this perverse incentive for individual miners to use a future
> > time by requiring that valid blocks have a computed GetMedianTimePast()
> > greater than the locktime specified in any transaction in that block.
> >
> > Mempool inclusion rules currently require transactions to be valid for
> > immediate inclusion in a block in order to be accepted into the mempool.
> > This release begins applying the BIP113 rule to received transactions,
> > so transaction whose time is greater than the GetMedianTimePast() will
> > no longer be accepted into the mempool.
> >
> > **Implication for miners:** you will begin rejecting transactions that
> > would not be valid under BIP113, which will prevent you from producing
> > invalid blocks if/when BIP113 is enforced on the network. Any
> > transactions which are valid under the current rules but not yet valid
> > under the BIP113 rules will either be mined by other miners or delayed
> > until they are valid under BIP113. Note, however, that time-based
> > locktime transactions are more or less unseen on the network currently.
> >
> > **Implication for users:** GetMedianTimePast() always trails behind the
> > current time, so a transaction locktime set to the present time will be
> > rejected by nodes running this release until the median time moves
> > forward. To compensate, subtract one hour (3,600 seconds) from your
> > locktimes to allow those transactions to be included in mempools at
> > approximately the expected time.
> >
> > [BIP113]: https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki
> >
> > Windows bug fix for corrupted UTXO database on unclean shutdowns
> > - ----------------------------------------------------------------
> >
> > Several Windows users reported that they often need to reindex the
> > entire blockchain after an unclean shutdown of Bitcoin Core on Windows
> > (or an unclean shutdown of Windows itself). Although unclean shutdowns
> > remain unsafe, this release no longer relies on memory-mapped files for
> > the UTXO database, which significantly reduced the frequency of unclean
> > shutdowns leading to required reindexes during testing.
> >
> > For more information, see: <https://github.com/bitcoin/bitcoin/pull/6917>
> >
> > Other fixes for database corruption on Windows are expected in the
> > next major release.
> >
> > 0.11.2 Change log
> > =================
> >
> > Detailed release notes follow. This overview includes changes that affect
> > behavior, not code moves, refactors and string updates. For convenience in
> > locating
> > the code changes and accompanying discussion, both the pull request and
> > git merge commit are mentioned.
> >
> > - - #6124 `684636b` Make CScriptNum() take nMaxNumSize as an argument
> > - - #6124 `4fa7a04` Replace NOP2 with CHECKLOCKTIMEVERIFY (BIP65)
> > - - #6124 `6ea5ca4` Enable CHECKLOCKTIMEVERIFY as a standard script verify
> > flag
> > - - #6351 `5e82e1c` Add CHECKLOCKTIMEVERIFY (BIP65) soft-fork logic
> > - - #6353 `ba1da90` Show softfork status in getblockchaininfo
> > - - #6351 `6af25b0` Add BIP65 to getblockchaininfo softforks list
> > - - #6688 `01878c9` Fix locking in GetTransaction
> > - - #6653 `b3eaa30` [Qt] Raise debug window when requested
> > - - #6600 `1e672ae` Debian/Ubuntu: Include bitcoin-tx binary
> > - - #6600 `2394f4d` Debian/Ubuntu: Split bitcoin-tx into its own package
> > - - #5987 `33d6825` Bugfix: Allow mining on top of old tip blocks for
> > testnet
> > - - #6852 `21e58b8` build: make sure OpenSSL heeds noexecstack
> > - - #6846 `af6edac` alias `-h` for `--help`
> > - - #6867 `95a5039` Set TCP_NODELAY on P2P sockets.
> > - - #6856 `dfe55bd` Do not allow blockfile pruning during reindex.
> > - - #6566 `a1d3c6f` Add rules--presently disabled--for using
> > GetMedianTimePast as end point for lock-time calculations
> > - - #6566 `f720c5f` Enable policy enforcing GetMedianTimePast as the end
> > point of lock-time constraints
> > - - #6917 `0af5b8e` leveldb: Win32WritableFile without memory mapping
> > - - #6948 `4e895b0` Always flush block and undo when switching to new file
> >
> > Credits
> > =======
> >
> > Thanks to everyone who directly contributed to this release:
> >
> > - - Alex Morcos
> > - - ?tcDrak
> > - - Chris Kleeschulte
> > - - Daniel Cousens
> > - - Diego Viola
> > - - Eric Lombrozo
> > - - Esteban Ordano
> > - - Gregory Maxwell
> > - - Luke Dashjr
> > - - Marco Falke
> > - - Mark Friedenbach
> > - - Matt Corallo
> > - - Micha
> > - - Mitchell Cash
> > - - Peter Todd
> > - - Pieter Wuille
> > - - Wladimir J. van der Laan
> > - - Zak Wilcox
> >
> > And those who contributed additional code review and/or security research.
> >
> > As well as everyone that helped translating on [Transifex](
> > https://www.transifex.com/projects/p/bitcoin/).
> >
> > -----BEGIN PGP SIGNATURE-----
> > Version: GnuPG v1
> >
> > iQEcBAEBCgAGBQJWReHOAAoJEHSBCwEjRsmmTAAH/iZQGklLHLIM6a2tTOj4d/O6
> > xHg5bJhXGjtzO284Uy3phTzvk+e4mqBTjI8BrSr4D+Vw7mJrfWihdTLlgZYCwso3
> > AyAk8ud1H42QanAfUvciY5uXd7cyzr8tCnCIBkvwJT5O8tI3FFhSMM5Fs86WnsP1
> > Y10+93sxaVJUave2xm1bmgiwApFZKQ2MNU1IVgFaW8agB59fuqtPRnBdKiK/j+AO
> > Jn1LKsObsINYhjtkAFiC66mUOBZ2N3rdhbN3LFl+u7EriTLoYk1OtZZhlC+rOueo
> > nxl1H5SHStjrD27vE9Hv2qD5Ckrwo3zib8hZNIVs6MJjFnWUCwNtNg0nqDEvpn4=
> > =xXdY
> > -----END PGP SIGNATURE-----
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> 
> 
> 
> -- 
> I like to provide some work at no charge to prove my value. Do you need a
> techie?
> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> <http://www.memeracing.net> (in alpha).
> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
> now accepts Bitcoin.
> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> "He ought to find it more profitable to play by the rules" - Satoshi
> Nakamoto

> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From jtimon at jtimon.cc  Mon Nov 16 12:06:49 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Mon, 16 Nov 2015 13:06:49 +0100
Subject: [bitcoin-dev] BIP99 and Schism hardforks lifecycle (was Switching
 Bitcoin Core to sqlite db)
Message-ID: <CABm2gDocOYndT7y44LwrN7PFXMcz4ABRLAEpdYPqqF_+1A368w@mail.gmail.com>

On Mon, Nov 16, 2015 at 2:52 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> We have strayed far from both the Subject line and from making progress
> on bitcoin development.  Please redirect to bitcoin-discuss.
>
> I have set the moderation bits on the three contributors from here down
> (CC'd): your next post will go to moderation.

Sorry for going out of topic on that thread, I have just created
another thread to discuss this particular point (whether schism
hardforks can be universally predicted to collapse into a single chain
or not), which is a fundamental part of BIP99 discussion and I believe
technical enough for this list (assuming that we stay on topic). But
the moderation thinks it's not relevant enough for this list, we can
move it to the discussion mailing list or private emails.

On Sun, Nov 15, 2015 at 6:06 PM, Peter R <peter_r at gmx.com> wrote:
>> I am not convinced that Bitcoin even *has* a block size limit, let alone
>> that it can enforce one against the invisible hand of the market.
>
Jorge Tim?n said:
> You keep insisting that some consensus rules are not consensus rules while
> others "are clearly a very different thing". What technical difference is
> there between the rule that impedes me from creating transactions bigger
> than X and the rules that prevent me frm creatin new coins (not as a miner,
> as a regular user in a transaction with more coins in the outputs than in
> the inputs)?
>

On Sun, Nov 15, 2015 at 6:06 PM, Peter R <peter_r at gmx.com> wrote:
> I think you?re using the term ?technical difference? to mean something very
> specific.  Perhaps you could clarify exactly how you are defining that term
> because to me it is crystal clear that creating coins out of thin air is
> very different than accepting a block 1.1 MB in size and full of valid TXs.
> There are many technical differences between the two. For example,
> technically the first allows coins to be created randomly while the second
> doesn?t.

Of course, their technical difference come from the fact they are
technically different. That's not what I meant.
There's no technical argument that lets you predict whether
eliminating one rule or the other will be more or less acceptable to
users.
There's no technical difference that I can see in that reward.
I think these two examples strike people as "obviously different" just
because they are morally different, but I want to avoid moral
judgments in BIP99.

> It is fact that two competing forks can persist for at least a short amount
> of time?we saw this a few years ago with the LevelDB bug and again this
> summer with the SPV mining incident.  In both cases, there was tremendous
> pressure to converge back to a single chain.

Those were unintentional hardforks. There's an example of a failed
schism hardfork: when some people changed the subsidy/issuance rules
to maintain the 50 btc block subsidy constant.
It didn't failed because of "tremendous pressure": it failed because
the users and miners of the alternative ruleset abandoned it. If they
hadn't, the two incompatible chains would still grow in parallel.

> Could two chains persist indefinitely?  I don?t know.  No one knows.  My gut
> feeling is that since users would have coins on both sides of the fork,
> there would be a fork arbitrage event (a ?forkbitrage?) where speculators
> would sell the coins on the side they predict to lose in exchange for
> additional coins on the side they expect to win.  This could actually be
> facilitated by exchanges once the fork event is credible and before the fork
> actually occurs, or even in a futures market somehow.  I suspect that the
> forkbitrage would create an unstable equilibrium where coins on one side
> quickly devalue.  Miners would then abandon that side in favour of the
> other, killing the fork because difficulty would be too high to find new
> blocks.  Anyways, I think even *this* would be highly unlikely.  I suspect
> nodes and miners would get inline with consensus as soon as the fork event
> was credible.

Yes, there could be arbitrage and speculators selling "on both sides"
is also a possibility.
At some point we would arrive to some kind of price equilibrium,
different for each of the coins. BIP99 states that those prices are
unpredictable (or at least there's no general method to predict the
result without knowing the concrete case, the market, etc) and in fact
states that the resulting price for both sides could be going to close
to zero market capitalization.
That still doesn't say anything about one side having to "surrender".
The coin that ends up with the lowest price (and consequently, the
lowest block reward and hashrate) can still continue, maybe even for
longer than the side that appeared to be "victorious" after the
initial arbitrage.
I haven't heard any convincing arguments about schism hardforks having
to necessarily collapse into a single chain and until I do I'm not
going to adapt BIP99 to reflect that.

On Sun, Nov 15, 2015 at 11:22 PM, Corey Haddad <corey3 at gmail.com> wrote:
> On Sun, Nov 15, 2015 at 2:12 AM, Jorge Tim?n
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
>>If the invisible hand of the market is what decides consensus rules instead
>> of their (still incomple) specification (aka libconsensus), then the market
>> could decide to stop enforcing ownership. Will you still think that Bitcoin
>> is a useful system when/if you empirically observe the invisible hand of the
>> market taking coins out of your pocket?
>
> The market, which in this instance I take to mean the economic majority,
> could absolutely decide to stop enforcing ownership of certain coins, even
> arbitrarily ascribing them to a different address.  That's not something any
> of us have any control over, and that reality must be acknowledged.
> Bitcoins have value is due to collective behavior.  We can provide tools to
> help people reach a common understanding, but the tools cannot force people
> to reach a certain conclusion.

Yes, I have control: all users (including miners) have direct control
over the rules that software they run validates.
You cannot ever have your coins stolen in the longest valid chain you
follow if the validity rules you use enforce property ownership.
No majority can force you to move to the new non-ownership rules, just
like no majority can force you to move to any different set of rules.
If we accept the notion that a groups of users could resist to
deploying this particular rule changes and keep operating under the
old rules, we have to accept that this can happen for any
controversial hardfork, and that we cannot predict a common lifecycle
for all schism hardforks.

From jtimon at jtimon.cc  Mon Nov 16 14:43:44 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Mon, 16 Nov 2015 15:43:44 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CAE0pACLyuaU=gJji1DkC1xkpmRjCFdRReLHa8zsD04+aDDQLeA@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
	<CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
	<CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>
	<CAE0pACLyuaU=gJji1DkC1xkpmRjCFdRReLHa8zsD04+aDDQLeA@mail.gmail.com>
Message-ID: <CABm2gDrz7iEoA6bMsFc-U4VNCKepSZ44tiT3_WfUPS=MR2eOmw@mail.gmail.com>

Not a native english speaker myself, so I may have missed some things...

Yes, sorry about the link. I guess you can point to #6230 . I can
rebase it if needed but I would close it again because I don't want to
have too many things from #6382 opened at the same time (is noisy and
worse for review). My plan was to not open it independently at least
until after #6907 (and actually after 0.12 assuming #6907 gets in by
0.12). But then I would maybe open a new one and reference the old one
rather than reopening #6230 (which tends to be confusing).
I'm not really sure what's the best answer here...but #6382 is
certainly going to need rebase and the link will be broken again.
Maybe one answer is to copy some text from #6230 or the commit and add
it directly to the BIP instead of referencing to that commit (which
will be, at least until #6907 is merged, a moving target).

On Mon, Nov 16, 2015 at 1:59 AM, Marco Pontello <marcopon at gmail.com> wrote:
> Thanks for the comments! Now I fixed the typos (hope to have got them all,
> English isn't my first language), clarified the chain part a bit, and fixed
> the link. There probably is a better way to reference that source code part
> with the genesis blocks hashs, in a way that doesn't need to be changed,
> maybe...
>
> Now the main change would be to put in a proper BIP number! :)
>
> On Sun, Nov 15, 2015 at 12:42 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
>>
>> Thank you for incorporating the feedback, specifically thank you for
>> using the genesis block hash as the unique chain ID.
>>
>> I wen't through the BIP draft and left a few of comments, but I really
>> like its simplicity and focus. Good work!
>>
>> On Sun, Nov 15, 2015 at 3:14 AM, Marco Pontello via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > Hi!
>> >
>> > To anyone that followed the discussion (from some time ago) about the
>> > proposed new URI for Blockchain references / exploration, I just wanted
>> > to
>> > point out that I have collected the feedback provided, reworked the
>> > text,
>> > put the BIP on GitHub and created a pull request:
>> >
>> > https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
>> > https://github.com/bitcoin/bips/pull/202
>> >
>> > The need for an URI for this come to mind again in the last days looking
>> > at
>> > Eternity Wall, which IMHO provide a use case that we will see more and
>> > more
>> > in the (near) future: http://eternitywall.it/
>> > Using that service, when you want to check for the proof that a specific
>> > message was written in the Blockchain, it let you choose from 5
>> > different
>> > explorer.
>> > Mycelium wallet recently added the option to select one of 15 block
>> > explorers.
>> > And there's the crypto_bot on reddit/r/bitcoin that detect reference to
>> > transaction an add a message with links to 7 different explorers.
>> >
>> > I think that's clearly something that's needed.
>> >
>> > Bye!
>> >
>> >
>> > On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <marcopon at gmail.com>
>> > wrote:
>> >>
>> >> Hi!
>> >> My first post here, hope I'm following the right conventions.
>> >> I had this humble idea for a while, so I thought to go ahead and
>> >> propose
>> >> it.
>> >>
>> >> BIP: XX
>> >> Title: URI scheme for Blockchain exploration
>> >> Author: Marco Pontello
>> >> Status: Draft
>> >> Type: Standards Track
>> >> Created: 29 August 2015
>> >>
>> >> Abstract
>> >> ========
>> >> This BIP propose a simple URI scheme for looking up blocks,
>> >> transactions,
>> >> addresses on a Blockchain explorer.
>> >>
>> >> Motivation
>> >> ==========
>> >> The purpose of this URI scheme is to enable users to handle all the
>> >> requests for details about blocks, transactions, etc. with their
>> >> preferred
>> >> tool (being that a web service or a local application).
>> >>
>> >> Currently a Bitcoin client usually point to an arbitrary blockchain
>> >> explorer when the user look for the details of a transaction (es.
>> >> Bitcoin
>> >> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info, etc.).
>> >> Other times resorting to cut&paste is needed.
>> >> The same happens with posts and messages that reference some particular
>> >> txs or blocks, if they provide links at all.
>> >>
>> >> Specification
>> >> =============
>> >> The URI follow this simple form:
>> >>
>> >> blockchain: <hash/string>
>> >>
>> >> Examples:
>> >>
>> >>
>> >>
>> >> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
>> >> blockchain:001949
>> >>
>> >>
>> >> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
>> >>
>> >> Rationale
>> >> =========
>> >> I thought about using some more complex scheme, or adding qualifiers to
>> >> distinguish blocks from txs, but in the end I think that keeping it
>> >> simple
>> >> should be practical enough. Blockchain explorers can apply the same
>> >> disambiguation rules they are already using to process the usual search
>> >> box.
>> >>
>> >> From the point of view of a wallet developer (or other tool that need
>> >> to
>> >> show any kind of Blockchain references), using this scheme mean that he
>> >> can simply make it a blockchain: link and be done with it, without
>> >> having
>> >> to worry about any specific Blockchain explorer or provide a means for
>> >> the
>> >> user to select one.
>> >>
>> >> Blockchain explorers in turn will simply offer to handle the
>> >> blockchain:
>> >> URI, the first time the user visit their website, or launch/install the
>> >> application, or even set themselves if there isn't already one.
>> >>
>> >> Users get the convenience of using always their preferred explorer,
>> >> which
>> >> can be especially handy on mobile devices, where juggling with
>> >> cut&paste
>> >> is far from ideal.
>> >>
>> >>
>> >
>> >
>> >
>> > --
>> > Try the Online TrID File Identifier
>> > http://mark0.net/onlinetrid.aspx
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >
>
>
>
>
> --
> Try the Online TrID File Identifier
> http://mark0.net/onlinetrid.aspx

From marcopon at gmail.com  Mon Nov 16 22:10:49 2015
From: marcopon at gmail.com (Marco Pontello)
Date: Mon, 16 Nov 2015 23:10:49 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CABm2gDrz7iEoA6bMsFc-U4VNCKepSZ44tiT3_WfUPS=MR2eOmw@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
	<CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
	<CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>
	<CAE0pACLyuaU=gJji1DkC1xkpmRjCFdRReLHa8zsD04+aDDQLeA@mail.gmail.com>
	<CABm2gDrz7iEoA6bMsFc-U4VNCKepSZ44tiT3_WfUPS=MR2eOmw@mail.gmail.com>
Message-ID: <CAE0pACK1Jp-GGZ84m-m8qNZXnOXvJfRXd+1SJk48wFYp02RX_Q@mail.gmail.com>

OK, adding the relevant code fragment is probably the simplest and direct
option. Done.

On Mon, Nov 16, 2015 at 3:43 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:

> Not a native english speaker myself, so I may have missed some things...
>
> Yes, sorry about the link. I guess you can point to #6230 . I can
> rebase it if needed but I would close it again because I don't want to
> have too many things from #6382 opened at the same time (is noisy and
> worse for review). My plan was to not open it independently at least
> until after #6907 (and actually after 0.12 assuming #6907 gets in by
> 0.12). But then I would maybe open a new one and reference the old one
> rather than reopening #6230 (which tends to be confusing).
> I'm not really sure what's the best answer here...but #6382 is
> certainly going to need rebase and the link will be broken again.
> Maybe one answer is to copy some text from #6230 or the commit and add
> it directly to the BIP instead of referencing to that commit (which
> will be, at least until #6907 is merged, a moving target).
>
> On Mon, Nov 16, 2015 at 1:59 AM, Marco Pontello <marcopon at gmail.com>
> wrote:
> > Thanks for the comments! Now I fixed the typos (hope to have got them
> all,
> > English isn't my first language), clarified the chain part a bit, and
> fixed
> > the link. There probably is a better way to reference that source code
> part
> > with the genesis blocks hashs, in a way that doesn't need to be changed,
> > maybe...
> >
> > Now the main change would be to put in a proper BIP number! :)
> >
> > On Sun, Nov 15, 2015 at 12:42 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> >>
> >> Thank you for incorporating the feedback, specifically thank you for
> >> using the genesis block hash as the unique chain ID.
> >>
> >> I wen't through the BIP draft and left a few of comments, but I really
> >> like its simplicity and focus. Good work!
> >>
> >> On Sun, Nov 15, 2015 at 3:14 AM, Marco Pontello via bitcoin-dev
> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> > Hi!
> >> >
> >> > To anyone that followed the discussion (from some time ago) about the
> >> > proposed new URI for Blockchain references / exploration, I just
> wanted
> >> > to
> >> > point out that I have collected the feedback provided, reworked the
> >> > text,
> >> > put the BIP on GitHub and created a pull request:
> >> >
> >> >
> https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
> >> > https://github.com/bitcoin/bips/pull/202
> >> >
> >> > The need for an URI for this come to mind again in the last days
> looking
> >> > at
> >> > Eternity Wall, which IMHO provide a use case that we will see more and
> >> > more
> >> > in the (near) future: http://eternitywall.it/
> >> > Using that service, when you want to check for the proof that a
> specific
> >> > message was written in the Blockchain, it let you choose from 5
> >> > different
> >> > explorer.
> >> > Mycelium wallet recently added the option to select one of 15 block
> >> > explorers.
> >> > And there's the crypto_bot on reddit/r/bitcoin that detect reference
> to
> >> > transaction an add a message with links to 7 different explorers.
> >> >
> >> > I think that's clearly something that's needed.
> >> >
> >> > Bye!
> >> >
> >> >
> >> > On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <marcopon at gmail.com>
> >> > wrote:
> >> >>
> >> >> Hi!
> >> >> My first post here, hope I'm following the right conventions.
> >> >> I had this humble idea for a while, so I thought to go ahead and
> >> >> propose
> >> >> it.
> >> >>
> >> >> BIP: XX
> >> >> Title: URI scheme for Blockchain exploration
> >> >> Author: Marco Pontello
> >> >> Status: Draft
> >> >> Type: Standards Track
> >> >> Created: 29 August 2015
> >> >>
> >> >> Abstract
> >> >> ========
> >> >> This BIP propose a simple URI scheme for looking up blocks,
> >> >> transactions,
> >> >> addresses on a Blockchain explorer.
> >> >>
> >> >> Motivation
> >> >> ==========
> >> >> The purpose of this URI scheme is to enable users to handle all the
> >> >> requests for details about blocks, transactions, etc. with their
> >> >> preferred
> >> >> tool (being that a web service or a local application).
> >> >>
> >> >> Currently a Bitcoin client usually point to an arbitrary blockchain
> >> >> explorer when the user look for the details of a transaction (es.
> >> >> Bitcoin
> >> >> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info, etc.).
> >> >> Other times resorting to cut&paste is needed.
> >> >> The same happens with posts and messages that reference some
> particular
> >> >> txs or blocks, if they provide links at all.
> >> >>
> >> >> Specification
> >> >> =============
> >> >> The URI follow this simple form:
> >> >>
> >> >> blockchain: <hash/string>
> >> >>
> >> >> Examples:
> >> >>
> >> >>
> >> >>
> >> >>
> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
> >> >> blockchain:001949
> >> >>
> >> >>
> >> >>
> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
> >> >>
> >> >> Rationale
> >> >> =========
> >> >> I thought about using some more complex scheme, or adding qualifiers
> to
> >> >> distinguish blocks from txs, but in the end I think that keeping it
> >> >> simple
> >> >> should be practical enough. Blockchain explorers can apply the same
> >> >> disambiguation rules they are already using to process the usual
> search
> >> >> box.
> >> >>
> >> >> From the point of view of a wallet developer (or other tool that need
> >> >> to
> >> >> show any kind of Blockchain references), using this scheme mean that
> he
> >> >> can simply make it a blockchain: link and be done with it, without
> >> >> having
> >> >> to worry about any specific Blockchain explorer or provide a means
> for
> >> >> the
> >> >> user to select one.
> >> >>
> >> >> Blockchain explorers in turn will simply offer to handle the
> >> >> blockchain:
> >> >> URI, the first time the user visit their website, or launch/install
> the
> >> >> application, or even set themselves if there isn't already one.
> >> >>
> >> >> Users get the convenience of using always their preferred explorer,
> >> >> which
> >> >> can be especially handy on mobile devices, where juggling with
> >> >> cut&paste
> >> >> is far from ideal.
> >> >>
> >> >>
> >> >
> >> >
> >> >
> >> > --
> >> > Try the Online TrID File Identifier
> >> > http://mark0.net/onlinetrid.aspx
> >> >
> >> > _______________________________________________
> >> > bitcoin-dev mailing list
> >> > bitcoin-dev at lists.linuxfoundation.org
> >> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >> >
> >
> >
> >
> >
> > --
> > Try the Online TrID File Identifier
> > http://mark0.net/onlinetrid.aspx
>



-- 
Try the Online TrID File Identifier
http://mark0.net/onlinetrid.aspx
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151116/88c6c760/attachment-0001.html>

From pete at petertodd.org  Mon Nov 16 23:24:05 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 16 Nov 2015 18:24:05 -0500
Subject: [bitcoin-dev] request to use service bit 28 for testing
In-Reply-To: <5647C375.9050809@gmail.com>
References: <5647C375.9050809@gmail.com>
Message-ID: <20151116232405.GA6302@savin.petertodd.org>

On Sat, Nov 14, 2015 at 03:27:49PM -0800, Peter Tschipper via bitcoin-dev wrote:
> I'd like to use service bit 28 for testing the block compression
> prototype unless anyone has any objections or is using it already.

Go for it!

AFAIK the only testing service bit in use right now is bit 26, used to
indicate full-RBF support by my replace-by-fee branch:

https://github.com/petertodd/bitcoin/tree/replace-by-fee-v0.11.2

Speaking of, you may find the preferential peering code in the above to
be useful. It's a bit of a hack, but it does work.

-- 
'peter'[:-1]@petertodd.org
000000000000000009c6356b4a0f309636e2b87e263063bee18ac22e91a57deb
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151116/bba4de27/attachment.sig>

From pete at petertodd.org  Tue Nov 17 00:42:18 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 16 Nov 2015 19:42:18 -0500
Subject: [bitcoin-dev] Opt-in Full Replace-By-Fee (Full-RBF)
Message-ID: <20151117004218.GB6302@savin.petertodd.org>

Summary
-------

Opt-In Full-RBF allows senders to opt-into full-RBF semantics for their
transactions in a way that allows receivers to detect if the sender has
done so. Existing "first-seen" mempool semantics are left unchanged for
transactions that do not opt-in.

At last week's IRC meeting(1) we decided to merge the opt-in Full-RBF
pull-req(2), pending code review and this post, so this feature will
likely make it into Bitcoin Core v0.12.0


Specification
-------------

A transaction is considered to have opted into full-RBF semantics if
nSequence < 0xFFFFFFFF-1 on at least one input. Nodes that respect the
opt-in will allow such opt-in transactions (and their descendents) to be
replaced in the mempool if they meet the economic replacement criteria.
Transactions in blocks are of course unaffected.

To detect if a transaction may be replaced check if it or any
unconfirmed ancestors have set nSequence < 0xFFFFFFFF-1 on any inputs.


Rational
--------

nSequence is used for opting in as it is the only "free-form" field
available for that purpose. Opt-in per output was proposed as well by
Luke-Jr, however the CTxOut data structure simply doesn't contain any
extra fields to use for that purpose. nSequence-based opt-in is also
compatible with the consensus-enforced transaction replacement semantics
in BIP68.

Allowing replacement if any input opts in vs. all inputs opting in is
chosen to ensure that transactions authored by multiple parties aren't
held up by the actions of a single party. Additionally, in the
multi-party scenario the value of any zeroconf guarantees are especially
dubious.

Replacement is allowed even if unconfirmed children did not opt-in to
ensure receivers can't maliciously prevent a replacement by spending the
funds. Additionally, any reasonable attempt at determining if a
transaction can be double-spent has to look at all unconfirmed parents
anyway.

Feedback from wallet authors indicates that first-seen-safe RBF isn't
very useful in practice due to the limitations inherent in FSS rules;
opt-in full-RBF doesn't preclude FSS-RBF from also being implemented.


Compatibility
-------------

Opt-in RBF transactions are currently mined by 100% of the hashing
power. Bitcoin Core has been producing transactions with non-maxint
nSequence since v0.11.0 to discourage fee sniping(3), and currently no
wallets are known that display such transactions yet do not display
opt-in RBF transactions.


Demonstrations
--------------

https://github.com/petertodd/replace-by-fee-tools#incremental-send-many


1) http://lists.linuxfoundation.org/pipermail/bitcoin-discuss/2015-November/000010.html

2) https://github.com/bitcoin/bitcoin/pull/6871

3) https://github.com/bitcoin/bitcoin/pull/2340

-- 
'peter'[:-1]@petertodd.org
00000000000000000f30567c63f8f4f079a8ecc2ab3d380bc7dc370e792b0a3a
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151116/d33dde25/attachment.sig>

From elombrozo at gmail.com  Tue Nov 17 11:40:43 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Tue, 17 Nov 2015 11:40:43 +0000
Subject: [bitcoin-dev] Dynamic Hierarchical Deterministic Key Trees
Message-ID: <em58ec03b8-7af4-4643-9414-679acc07fcba@platinum>

I've submitted a BIP proposal that solves the issue of needing to 
predefine HD wallet structures and not being able to arbitrarily nest 
deeper levels. Comments appreciated.

https://github.com/bitcoin/bips/pull/242


- Eric
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151117/2db0574f/attachment.html>

From tamas at bitsofproof.com  Tue Nov 17 13:10:17 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Tue, 17 Nov 2015 14:10:17 +0100
Subject: [bitcoin-dev] Dynamic Hierarchical Deterministic Key Trees
In-Reply-To: <em58ec03b8-7af4-4643-9414-679acc07fcba@platinum>
References: <em58ec03b8-7af4-4643-9414-679acc07fcba@platinum>
Message-ID: <9F747105-0BE5-48B0-9032-A0B4CBFC8A66@bitsofproof.com>

Hi Eric,

Would you please enumerate, or point to, arguments that discourage the use of a key both for signing and for derivation of a deeper level of the hierarchy ?

Tamas Blummer

> On Nov 17, 2015, at 12:40, Eric Lombrozo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I've submitted a BIP proposal that solves the issue of needing to predefine HD wallet structures and not being able to arbitrarily nest deeper levels. Comments appreciated.
>  
> https://github.com/bitcoin/bips/pull/242
>  
>  
> - Eric
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From tamas at bitsofproof.com  Tue Nov 17 13:54:19 2015
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Tue, 17 Nov 2015 14:54:19 +0100
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <D64AA4C7-BB66-41B2-A001-107985071DA1@gmx.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
	<D64AA4C7-BB66-41B2-A001-107985071DA1@gmx.com>
Message-ID: <0BABD098-33AB-4638-928B-F2D189FA2F8A@bitsofproof.com>

Isolating storage from the rest of consensus code is technically desirable, but implementations using different storage will be unlikely bug-for-bug compatible,
hence able to split the network.

Such split was disastrous on the network level if partitions were of comparable magnitude - as was the case in the March 2013 fork between versions of Bitcoin Core.

This means high level implementation diversity was great, provided we would get there without blowing up the network on the way from monoculture to true decentralization of code.

Libconsensus is immensely valuable to get diversity, as it makes alternate implementations bug-for-bug compatible for a big part of the consensus code.

Tamas Blummer
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151117/fc390dd3/attachment.sig>

From tomh at thinlink.com  Tue Nov 17 15:24:42 2015
From: tomh at thinlink.com (Tom Harding)
Date: Tue, 17 Nov 2015 07:24:42 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <0BABD098-33AB-4638-928B-F2D189FA2F8A@bitsofproof.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
	<D64AA4C7-BB66-41B2-A001-107985071DA1@gmx.com>
	<0BABD098-33AB-4638-928B-F2D189FA2F8A@bitsofproof.com>
Message-ID: <CALJP9GCia3fedPi4B56G1+07OvwytEAOMNczYrJ4iMwUA3F3rQ@mail.gmail.com>

On Nov 17, 2015 5:54 AM, "Tamas Blummer via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Isolating storage from the rest of consensus code is technically
desirable, but implementations using different storage will be unlikely
bug-for-bug compatible,
> hence able to split the network.

The problem with unknown bugs is you don't know how serious they are.  A
serious bug could itself be devastating.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151117/39c94d1d/attachment.html>

From telemaco at neomailbox.net  Tue Nov 17 22:17:33 2015
From: telemaco at neomailbox.net (telemaco)
Date: Tue, 17 Nov 2015 23:17:33 +0100
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <CALJP9GCia3fedPi4B56G1+07OvwytEAOMNczYrJ4iMwUA3F3rQ@mail.gmail.com>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
	<D64AA4C7-BB66-41B2-A001-107985071DA1@gmx.com>
	<0BABD098-33AB-4638-928B-F2D189FA2F8A@bitsofproof.com>
	<CALJP9GCia3fedPi4B56G1+07OvwytEAOMNczYrJ4iMwUA3F3rQ@mail.gmail.com>
Message-ID: <49CD7E61-C49B-472B-BB3C-1EFAD630104A@neomailbox.net>

Shouldn't a odbc jdbc jconnect or equivalent be totally transparent for the consensus code? I mean, the client would write or store the data communicating to the driver provided by the vendor. Using the schema bitcoin suggests adapted to many different vendors (one table schema for Oracle, other for mysql, etc with their slight syntax particularities), installed in the machine with the node and from that communication to the driver  the storage would be totally controlled by the third party rdbms. 
Regarding bugs or risk of fork, does not have actual client any defense against someone forking core and slightly changing the actual database used maybe wrongly and creating a fork by themselves? 
Does the client have any way to verify that what is stored is correct? Maybe inserting a column with a hash of what is stored in each row and another column with a incremental row by row hash composed by the hash of each row and the previous column one., so any tampering in a previous row can be verified up to where is not consistent.
I just imagine what would be for people to be able to access easily (with the thousands of software packages already bought and licensed by ALL companies in the world that already use open standard connectivity or equivalents)., the bitcoin blockchain. 
SUBSCRIPTION: for a couple decades replication servers have allowed a publish/subscription model using replication agents. If I am a guy working on a lever in the warehouse with my pda I do not need on my pda all the company info or maybe all the blockchain. If a company., that has already licensed a rdbms package with dozens of related software packages needs one guy to suscribe to something on the bitcoin blockchain, he can either use one of the purchased methods in their company and access the company database that holds blockchain data or hire a rare bitcoin developer that will create a interfaz bitcoin for a specific need up to the millions of needs out there. 
PUBLISHING Maybe even to have a publishing daemon that would allow those companies and their software packages to write things in the bitcoin blockchain provided of couse that they fund the agent with a small bitcoin amount to send transactions and they comply with the database constraint of being the owners of the private key. The publishing agent would check for changes every X minutes on that specific address  in the db and if funded it would publish "send" the transaction through the bitcoin client. People would be able to publish info on the decentralized ledger from 90% of enterprise software packages.,paying ofc  and with the small delay of the publishing agent checking for changes. In fact the db would allow publishing info while the publishing agent could just take its time publishing at its own rate like a slow write cache.
In any case shouldn't even actual consensus be shielded from a malfunctioning or Ill forked database from core client

El 17 de noviembre de 2015 16:24:42 CET, Tom Harding <tomh at thinlink.com> escribi?:
>On Nov 17, 2015 5:54 AM, "Tamas Blummer via bitcoin-dev" <
>bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Isolating storage from the rest of consensus code is technically
>desirable, but implementations using different storage will be unlikely
>bug-for-bug compatible,
>> hence able to split the network.
>
>The problem with unknown bugs is you don't know how serious they are. 
>A
>serious bug could itself be devastating.

-- 
Sent from my Android device with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151117/cf843748/attachment.html>

From j at blockstream.com  Wed Nov 18 00:06:44 2015
From: j at blockstream.com (Jonathan Wilkins)
Date: Tue, 17 Nov 2015 16:06:44 -0800
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <562E6BC0.7010002@vt.edu>
References: <CADm_WcaLQzigsdmFR43JqiCYJVpmqkhVDc8GiVG=UN+Z1zg7+w@mail.gmail.com>
	<3162730.lzR74nC3xW@garp> <562E6BC0.7010002@vt.edu>
Message-ID: <CAL0tybca59rZ6KiyqY8iUFpH94Zw0T1o16OZ-uO0YYjRCo7vFw@mail.gmail.com>

Benchmarks for various DBs under discussion:
http://symas.com/mdb/microbench/


On Mon, Oct 26, 2015 at 11:06 AM, Douglas Roark via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 2015/10/23 03:30, Tom Zander via bitcoin-dev wrote:
> > On Thursday 22 Oct 2015 17:26:42 Jeff Garzik via bitcoin-dev wrote:
> >> It was noted that leveldb is unmaintained, and this is part of
> researching
> >> alternatives that are maintained and reliable.
> >
> > Apart from it being unmaintained, any links to what are problems with
> levelDB?
>
> While not exactly the most rigorous link,
> https://en.wikipedia.org/wiki/LevelDB#Bugs_and_Reliability seems like an
> okay place to start. One thing I can attest to is that, when Armory used
> LevelDB (0.8 - 0.92, IIRC), quite a few users had DB corruption issues,
> particularly on Windows. Even when a switch to LMDB occurred for 0.93,
> loads of complaints would come in from users whose LevelDB-based Core
> DBs would fail. I know that the guy who moved Armory over to LMDB would
> love to have more time in the day so that he could write a Core patch
> that does the same. It's a very sore spot for him.
>
> (FWIW, LMDB seems to work quite nicely, at least once you patch up the
> source a little bit. The latest version is also compatible with Core's
> cross-compiling scheme. I'd love to see it added to Core one day.)
>
> Doug
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151117/394c3283/attachment-0001.html>

From jtimon at jtimon.cc  Wed Nov 18 11:29:13 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 18 Nov 2015 12:29:13 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CAE0pACK1Jp-GGZ84m-m8qNZXnOXvJfRXd+1SJk48wFYp02RX_Q@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
	<CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
	<CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>
	<CAE0pACLyuaU=gJji1DkC1xkpmRjCFdRReLHa8zsD04+aDDQLeA@mail.gmail.com>
	<CABm2gDrz7iEoA6bMsFc-U4VNCKepSZ44tiT3_WfUPS=MR2eOmw@mail.gmail.com>
	<CAE0pACK1Jp-GGZ84m-m8qNZXnOXvJfRXd+1SJk48wFYp02RX_Q@mail.gmail.com>
Message-ID: <CABm2gDoOMD0zujY+GGRrQ7HcZ9uBpk_diW+rB0wLzj61=qmt7w@mail.gmail.com>

I can always link to the BIP when I reopen that commit as independent
instead of the other way around.
Btw, the PR needs rebase (probably the conflict is in the README).

On Mon, Nov 16, 2015 at 11:10 PM, Marco Pontello <marcopon at gmail.com> wrote:
> OK, adding the relevant code fragment is probably the simplest and direct
> option. Done.
>
> On Mon, Nov 16, 2015 at 3:43 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
>>
>> Not a native english speaker myself, so I may have missed some things...
>>
>> Yes, sorry about the link. I guess you can point to #6230 . I can
>> rebase it if needed but I would close it again because I don't want to
>> have too many things from #6382 opened at the same time (is noisy and
>> worse for review). My plan was to not open it independently at least
>> until after #6907 (and actually after 0.12 assuming #6907 gets in by
>> 0.12). But then I would maybe open a new one and reference the old one
>> rather than reopening #6230 (which tends to be confusing).
>> I'm not really sure what's the best answer here...but #6382 is
>> certainly going to need rebase and the link will be broken again.
>> Maybe one answer is to copy some text from #6230 or the commit and add
>> it directly to the BIP instead of referencing to that commit (which
>> will be, at least until #6907 is merged, a moving target).
>>
>> On Mon, Nov 16, 2015 at 1:59 AM, Marco Pontello <marcopon at gmail.com>
>> wrote:
>> > Thanks for the comments! Now I fixed the typos (hope to have got them
>> > all,
>> > English isn't my first language), clarified the chain part a bit, and
>> > fixed
>> > the link. There probably is a better way to reference that source code
>> > part
>> > with the genesis blocks hashs, in a way that doesn't need to be changed,
>> > maybe...
>> >
>> > Now the main change would be to put in a proper BIP number! :)
>> >
>> > On Sun, Nov 15, 2015 at 12:42 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
>> >>
>> >> Thank you for incorporating the feedback, specifically thank you for
>> >> using the genesis block hash as the unique chain ID.
>> >>
>> >> I wen't through the BIP draft and left a few of comments, but I really
>> >> like its simplicity and focus. Good work!
>> >>
>> >> On Sun, Nov 15, 2015 at 3:14 AM, Marco Pontello via bitcoin-dev
>> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >> > Hi!
>> >> >
>> >> > To anyone that followed the discussion (from some time ago) about the
>> >> > proposed new URI for Blockchain references / exploration, I just
>> >> > wanted
>> >> > to
>> >> > point out that I have collected the feedback provided, reworked the
>> >> > text,
>> >> > put the BIP on GitHub and created a pull request:
>> >> >
>> >> >
>> >> > https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
>> >> > https://github.com/bitcoin/bips/pull/202
>> >> >
>> >> > The need for an URI for this come to mind again in the last days
>> >> > looking
>> >> > at
>> >> > Eternity Wall, which IMHO provide a use case that we will see more
>> >> > and
>> >> > more
>> >> > in the (near) future: http://eternitywall.it/
>> >> > Using that service, when you want to check for the proof that a
>> >> > specific
>> >> > message was written in the Blockchain, it let you choose from 5
>> >> > different
>> >> > explorer.
>> >> > Mycelium wallet recently added the option to select one of 15 block
>> >> > explorers.
>> >> > And there's the crypto_bot on reddit/r/bitcoin that detect reference
>> >> > to
>> >> > transaction an add a message with links to 7 different explorers.
>> >> >
>> >> > I think that's clearly something that's needed.
>> >> >
>> >> > Bye!
>> >> >
>> >> >
>> >> > On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <marcopon at gmail.com>
>> >> > wrote:
>> >> >>
>> >> >> Hi!
>> >> >> My first post here, hope I'm following the right conventions.
>> >> >> I had this humble idea for a while, so I thought to go ahead and
>> >> >> propose
>> >> >> it.
>> >> >>
>> >> >> BIP: XX
>> >> >> Title: URI scheme for Blockchain exploration
>> >> >> Author: Marco Pontello
>> >> >> Status: Draft
>> >> >> Type: Standards Track
>> >> >> Created: 29 August 2015
>> >> >>
>> >> >> Abstract
>> >> >> ========
>> >> >> This BIP propose a simple URI scheme for looking up blocks,
>> >> >> transactions,
>> >> >> addresses on a Blockchain explorer.
>> >> >>
>> >> >> Motivation
>> >> >> ==========
>> >> >> The purpose of this URI scheme is to enable users to handle all the
>> >> >> requests for details about blocks, transactions, etc. with their
>> >> >> preferred
>> >> >> tool (being that a web service or a local application).
>> >> >>
>> >> >> Currently a Bitcoin client usually point to an arbitrary blockchain
>> >> >> explorer when the user look for the details of a transaction (es.
>> >> >> Bitcoin
>> >> >> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info, etc.).
>> >> >> Other times resorting to cut&paste is needed.
>> >> >> The same happens with posts and messages that reference some
>> >> >> particular
>> >> >> txs or blocks, if they provide links at all.
>> >> >>
>> >> >> Specification
>> >> >> =============
>> >> >> The URI follow this simple form:
>> >> >>
>> >> >> blockchain: <hash/string>
>> >> >>
>> >> >> Examples:
>> >> >>
>> >> >>
>> >> >>
>> >> >>
>> >> >> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
>> >> >> blockchain:001949
>> >> >>
>> >> >>
>> >> >>
>> >> >> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
>> >> >>
>> >> >> Rationale
>> >> >> =========
>> >> >> I thought about using some more complex scheme, or adding qualifiers
>> >> >> to
>> >> >> distinguish blocks from txs, but in the end I think that keeping it
>> >> >> simple
>> >> >> should be practical enough. Blockchain explorers can apply the same
>> >> >> disambiguation rules they are already using to process the usual
>> >> >> search
>> >> >> box.
>> >> >>
>> >> >> From the point of view of a wallet developer (or other tool that
>> >> >> need
>> >> >> to
>> >> >> show any kind of Blockchain references), using this scheme mean that
>> >> >> he
>> >> >> can simply make it a blockchain: link and be done with it, without
>> >> >> having
>> >> >> to worry about any specific Blockchain explorer or provide a means
>> >> >> for
>> >> >> the
>> >> >> user to select one.
>> >> >>
>> >> >> Blockchain explorers in turn will simply offer to handle the
>> >> >> blockchain:
>> >> >> URI, the first time the user visit their website, or launch/install
>> >> >> the
>> >> >> application, or even set themselves if there isn't already one.
>> >> >>
>> >> >> Users get the convenience of using always their preferred explorer,
>> >> >> which
>> >> >> can be especially handy on mobile devices, where juggling with
>> >> >> cut&paste
>> >> >> is far from ideal.
>> >> >>
>> >> >>
>> >> >
>> >> >
>> >> >
>> >> > --
>> >> > Try the Online TrID File Identifier
>> >> > http://mark0.net/onlinetrid.aspx
>> >> >
>> >> > _______________________________________________
>> >> > bitcoin-dev mailing list
>> >> > bitcoin-dev at lists.linuxfoundation.org
>> >> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >> >
>> >
>> >
>> >
>> >
>> > --
>> > Try the Online TrID File Identifier
>> > http://mark0.net/onlinetrid.aspx
>
>
>
>
> --
> Try the Online TrID File Identifier
> http://mark0.net/onlinetrid.aspx

From jtimon at jtimon.cc  Wed Nov 18 10:15:54 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 18 Nov 2015 11:15:54 +0100
Subject: [bitcoin-dev] BIP - Block size doubles at each reward halving
 with max block size of 32M
In-Reply-To: <CABEog-XUNt9kDS7Mc0XYFjm5ePUT0m1YaAoG9VypTCiGLBongQ@mail.gmail.com>
References: <201511132228.47815.luke@dashjr.org>
	<201511142111.24046.luke@dashjr.org>
	<CADZB0_Z3Kf4GW0VATjb10kJF0aFgyFOcqX_=y+LFoUpsi+TRUA@mail.gmail.com>
	<201511142127.53255.luke@dashjr.org>
	<CABm2gDryvFsnnV=8Bwc8mQX4JtU9_PgJ0EBhcYjpcSdXjV2_WA@mail.gmail.com>
	<CABEog-XUNt9kDS7Mc0XYFjm5ePUT0m1YaAoG9VypTCiGLBongQ@mail.gmail.com>
Message-ID: <CABm2gDo30EhWmreaFBB81H6mvUwO=KpWz_c+uavsG1KBYGLgaw@mail.gmail.com>

On Wed, Nov 18, 2015 at 10:13 AM, Shuning Hong <hongshuning at gmail.com> wrote:
> 2015-11-15 20:16 GMT+08:00 Jorge Tim?n <bitcoin-dev at lists.linuxfoundation.org>:
>> The time threshold must be set enough in the future to give users time to upgrade. But we can perceive miners' adoption, so if the system knows they haven't upgraded, it should wait for them to upgrade (it would be nice to have an equivalent mechanism to wait for the rest of the users, but unfortunately there's none).
>
> If the majority of the miners never upgrade, how could we treat that
> BIP? Wait forever?

Assuming it was deployed as an uncontroversial hardfork as recommended
in BIP99, the deployment would use versionbits (BIP9) and the hardfork
would timeout.
But this timeout would clearly signal that either the minimum
activation threshold wasn't giving enough time for all users to
upgrade (apparently miners didn't had time) or the hardfork is not
really an uncontroversial hardfork but rather a schism one. Then,
assuming some people still want to deploy it as a schism hardfork,
bip99 recommends using only a mediantime threshold without versionbits
nor miner upgrade confirmation.

From marcopon at gmail.com  Wed Nov 18 12:31:46 2015
From: marcopon at gmail.com (Marco Pontello)
Date: Wed, 18 Nov 2015 13:31:46 +0100
Subject: [bitcoin-dev] RFC - BIP: URI scheme for Blockchain exploration
In-Reply-To: <CABm2gDoOMD0zujY+GGRrQ7HcZ9uBpk_diW+rB0wLzj61=qmt7w@mail.gmail.com>
References: <CAE0pACLMcMzHkA=vEx+fiEmq7FA1bXDc4t_hQ+955=r=62V5=g@mail.gmail.com>
	<CAE0pACLzGPHs7-KG+fzbYJzbDZ+qxkoko_uPz4Kc-1ov8jdMsA@mail.gmail.com>
	<CABm2gDrutCDFAVbXAFUaAZfoHK_sKzX6ZsMpD0j=f7HJj99Zpg@mail.gmail.com>
	<CAE0pACLyuaU=gJji1DkC1xkpmRjCFdRReLHa8zsD04+aDDQLeA@mail.gmail.com>
	<CABm2gDrz7iEoA6bMsFc-U4VNCKepSZ44tiT3_WfUPS=MR2eOmw@mail.gmail.com>
	<CAE0pACK1Jp-GGZ84m-m8qNZXnOXvJfRXd+1SJk48wFYp02RX_Q@mail.gmail.com>
	<CABm2gDoOMD0zujY+GGRrQ7HcZ9uBpk_diW+rB0wLzj61=qmt7w@mail.gmail.com>
Message-ID: <CAE0pACKqrO0X+XBjkEASz+T8YK_VdRdxhWYo0mUkOkJjjuzctA@mail.gmail.com>

Right, now it should be ok. Thanks.

On Wed, Nov 18, 2015 at 12:29 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:

> I can always link to the BIP when I reopen that commit as independent
> instead of the other way around.
> Btw, the PR needs rebase (probably the conflict is in the README).
>
> On Mon, Nov 16, 2015 at 11:10 PM, Marco Pontello <marcopon at gmail.com>
> wrote:
> > OK, adding the relevant code fragment is probably the simplest and direct
> > option. Done.
> >
> > On Mon, Nov 16, 2015 at 3:43 PM, Jorge Tim?n <jtimon at jtimon.cc> wrote:
> >>
> >> Not a native english speaker myself, so I may have missed some things...
> >>
> >> Yes, sorry about the link. I guess you can point to #6230 . I can
> >> rebase it if needed but I would close it again because I don't want to
> >> have too many things from #6382 opened at the same time (is noisy and
> >> worse for review). My plan was to not open it independently at least
> >> until after #6907 (and actually after 0.12 assuming #6907 gets in by
> >> 0.12). But then I would maybe open a new one and reference the old one
> >> rather than reopening #6230 (which tends to be confusing).
> >> I'm not really sure what's the best answer here...but #6382 is
> >> certainly going to need rebase and the link will be broken again.
> >> Maybe one answer is to copy some text from #6230 or the commit and add
> >> it directly to the BIP instead of referencing to that commit (which
> >> will be, at least until #6907 is merged, a moving target).
> >>
> >> On Mon, Nov 16, 2015 at 1:59 AM, Marco Pontello <marcopon at gmail.com>
> >> wrote:
> >> > Thanks for the comments! Now I fixed the typos (hope to have got them
> >> > all,
> >> > English isn't my first language), clarified the chain part a bit, and
> >> > fixed
> >> > the link. There probably is a better way to reference that source code
> >> > part
> >> > with the genesis blocks hashs, in a way that doesn't need to be
> changed,
> >> > maybe...
> >> >
> >> > Now the main change would be to put in a proper BIP number! :)
> >> >
> >> > On Sun, Nov 15, 2015 at 12:42 PM, Jorge Tim?n <jtimon at jtimon.cc>
> wrote:
> >> >>
> >> >> Thank you for incorporating the feedback, specifically thank you for
> >> >> using the genesis block hash as the unique chain ID.
> >> >>
> >> >> I wen't through the BIP draft and left a few of comments, but I
> really
> >> >> like its simplicity and focus. Good work!
> >> >>
> >> >> On Sun, Nov 15, 2015 at 3:14 AM, Marco Pontello via bitcoin-dev
> >> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> >> > Hi!
> >> >> >
> >> >> > To anyone that followed the discussion (from some time ago) about
> the
> >> >> > proposed new URI for Blockchain references / exploration, I just
> >> >> > wanted
> >> >> > to
> >> >> > point out that I have collected the feedback provided, reworked the
> >> >> > text,
> >> >> > put the BIP on GitHub and created a pull request:
> >> >> >
> >> >> >
> >> >> >
> https://github.com/MarcoPon/bips/blob/master/bip-MarcoPon-01.mediawiki
> >> >> > https://github.com/bitcoin/bips/pull/202
> >> >> >
> >> >> > The need for an URI for this come to mind again in the last days
> >> >> > looking
> >> >> > at
> >> >> > Eternity Wall, which IMHO provide a use case that we will see more
> >> >> > and
> >> >> > more
> >> >> > in the (near) future: http://eternitywall.it/
> >> >> > Using that service, when you want to check for the proof that a
> >> >> > specific
> >> >> > message was written in the Blockchain, it let you choose from 5
> >> >> > different
> >> >> > explorer.
> >> >> > Mycelium wallet recently added the option to select one of 15 block
> >> >> > explorers.
> >> >> > And there's the crypto_bot on reddit/r/bitcoin that detect
> reference
> >> >> > to
> >> >> > transaction an add a message with links to 7 different explorers.
> >> >> >
> >> >> > I think that's clearly something that's needed.
> >> >> >
> >> >> > Bye!
> >> >> >
> >> >> >
> >> >> > On Sat, Aug 29, 2015 at 1:48 PM, Marco Pontello <
> marcopon at gmail.com>
> >> >> > wrote:
> >> >> >>
> >> >> >> Hi!
> >> >> >> My first post here, hope I'm following the right conventions.
> >> >> >> I had this humble idea for a while, so I thought to go ahead and
> >> >> >> propose
> >> >> >> it.
> >> >> >>
> >> >> >> BIP: XX
> >> >> >> Title: URI scheme for Blockchain exploration
> >> >> >> Author: Marco Pontello
> >> >> >> Status: Draft
> >> >> >> Type: Standards Track
> >> >> >> Created: 29 August 2015
> >> >> >>
> >> >> >> Abstract
> >> >> >> ========
> >> >> >> This BIP propose a simple URI scheme for looking up blocks,
> >> >> >> transactions,
> >> >> >> addresses on a Blockchain explorer.
> >> >> >>
> >> >> >> Motivation
> >> >> >> ==========
> >> >> >> The purpose of this URI scheme is to enable users to handle all
> the
> >> >> >> requests for details about blocks, transactions, etc. with their
> >> >> >> preferred
> >> >> >> tool (being that a web service or a local application).
> >> >> >>
> >> >> >> Currently a Bitcoin client usually point to an arbitrary
> blockchain
> >> >> >> explorer when the user look for the details of a transaction (es.
> >> >> >> Bitcoin
> >> >> >> Wallet use BitEasy, Mycelium or Electrum use Blockchain.info,
> etc.).
> >> >> >> Other times resorting to cut&paste is needed.
> >> >> >> The same happens with posts and messages that reference some
> >> >> >> particular
> >> >> >> txs or blocks, if they provide links at all.
> >> >> >>
> >> >> >> Specification
> >> >> >> =============
> >> >> >> The URI follow this simple form:
> >> >> >>
> >> >> >> blockchain: <hash/string>
> >> >> >>
> >> >> >> Examples:
> >> >> >>
> >> >> >>
> >> >> >>
> >> >> >>
> >> >> >>
> blockchain:00000000000000001003e880d500968d51157f210c632e08a652af3576600198
> >> >> >> blockchain:001949
> >> >> >>
> >> >> >>
> >> >> >>
> >> >> >>
> blockchain:3b95a766d7a99b87188d6875c8484cb2b310b78459b7816d4dfc3f0f7e04281a
> >> >> >>
> >> >> >> Rationale
> >> >> >> =========
> >> >> >> I thought about using some more complex scheme, or adding
> qualifiers
> >> >> >> to
> >> >> >> distinguish blocks from txs, but in the end I think that keeping
> it
> >> >> >> simple
> >> >> >> should be practical enough. Blockchain explorers can apply the
> same
> >> >> >> disambiguation rules they are already using to process the usual
> >> >> >> search
> >> >> >> box.
> >> >> >>
> >> >> >> From the point of view of a wallet developer (or other tool that
> >> >> >> need
> >> >> >> to
> >> >> >> show any kind of Blockchain references), using this scheme mean
> that
> >> >> >> he
> >> >> >> can simply make it a blockchain: link and be done with it, without
> >> >> >> having
> >> >> >> to worry about any specific Blockchain explorer or provide a means
> >> >> >> for
> >> >> >> the
> >> >> >> user to select one.
> >> >> >>
> >> >> >> Blockchain explorers in turn will simply offer to handle the
> >> >> >> blockchain:
> >> >> >> URI, the first time the user visit their website, or
> launch/install
> >> >> >> the
> >> >> >> application, or even set themselves if there isn't already one.
> >> >> >>
> >> >> >> Users get the convenience of using always their preferred
> explorer,
> >> >> >> which
> >> >> >> can be especially handy on mobile devices, where juggling with
> >> >> >> cut&paste
> >> >> >> is far from ideal.
> >> >> >>
> >> >> >>
> >> >> >
> >> >> >
> >> >> >
> >> >> > --
> >> >> > Try the Online TrID File Identifier
> >> >> > http://mark0.net/onlinetrid.aspx
> >> >> >
> >> >> > _______________________________________________
> >> >> > bitcoin-dev mailing list
> >> >> > bitcoin-dev at lists.linuxfoundation.org
> >> >> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >> >> >
> >> >
> >> >
> >> >
> >> >
> >> > --
> >> > Try the Online TrID File Identifier
> >> > http://mark0.net/onlinetrid.aspx
> >
> >
> >
> >
> > --
> > Try the Online TrID File Identifier
> > http://mark0.net/onlinetrid.aspx
>



-- 
Try the Online TrID File Identifier
http://mark0.net/onlinetrid.aspx
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151118/95640aa5/attachment-0001.html>

From peter.tschipper at gmail.com  Wed Nov 18 14:00:35 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Wed, 18 Nov 2015 06:00:35 -0800
Subject: [bitcoin-dev] More findings: Block Compression (Datastream
 Compression) test results using the PR#6973 compression prototype
In-Reply-To: <56465CEE.6010109@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<56438A55.2010604@gmail.com>
	<CAE0pACK1-xQC4MsdbM46_Z0TQvZTrZKw4e8xFt3X=PmW7pmGJQ@mail.gmail.com>
	<27BB52F9-3E3F-443D-93BC-B6843EB992F5@toom.im>
	<56465CEE.6010109@gmail.com>
Message-ID: <564C8483.1000901@gmail.com>

Hi all,

I'm still doing a little more investigation before opening up a formal
bip PR, but getting close.  Here are some more findings.

After moving the compression from main.cpp to streams.h (CDataStream) it
was a simple matter to add compression to transactions as well. Results
as follows:

range = block size range
ubytes = average size of uncompressed transactions
cbytes = average size of compressed transactions
cmp_ratio% = compression ratio
datapoints = number of datapoints taken

range 	ubytes 	cbytes 	cmp_ratio% 	datapoints
0-250b 	220 	227 	-3.16 	23780
250-500b 	356 	354 	0.68 	20882
500-600 	534 	505 	5.29 	2772
600-700 	653 	608 	6.95 	1853
700-800 	757 	649 	14.22 	578
800-900  	822 	758 	7.77 	661
900-1KB 	954 	862 	9.69 	906
1KB-10KB  	2698 	2222 	17.64 	3370
10KB-100KB 	15463 	12092 	21.8 	15429


A couple of obvious observations.  Transactions don't compress well
below 500 bytes but do very well beyond 1KB where there are a great deal
of those large spam type transactions.   However, most transactions
happen to be in the < 500 byte range.  So the next step was to appy
bundling, or the creating of a "blob" for those smaller transactions, if
and only if there are multiple tx's in the getdata receive queue for a
peer.  Doing that yields some very good compression ratios.  Some
examples as follows:

The best one I've seen so far was the following where 175 transactions
were bundled into one blob before being compressed.  That yielded a 20%
compression ratio, but that doesn't take into account the savings from
the unneeded 174 message headers (24 bytes each) as well as 174 TCP
ACK's of 52 bytes each which yields and additional 76*174=13224 bytes,
making the overall bandwidth savings 32%, in this particular case.

*2015-11-18 01:09:09.002061 compressed blob from 79890 to 67426 txcount:175*

To be sure, this was an extreme example.  Most transaction blobs were in
the 2 to 10 transaction range.  Such as the following:

*2015-11-17 21:08:28.469313 compressed blob from 3199 to 2876 txcount:10*

But even here the savings are 10%, far better than the "nothing" we
would get without bundling, but add to that the 76 byte * 9 transaction
savings and we have a total 20% savings in bandwidth for transactions
that otherwise would not be compressible.

The same bundling was applied to blocks and very good compression ratios
are seen when sync'ing the blockchain.

Overall the bundling or blobbing of tx's and blocks seems to be a good
idea for improving bandwith use but also there is a scalability factor
here, when the system is busy, transactions are bundled more often,
compressed, sent faster, keeping message queue and network chatter to a
minimum.

I think I have enough information to put together a formal BIP with the
exception of which compression library to implement.  These tests were
done using ZLib but I'll also be running tests in the coming days with
LZO (Jeff Garzik's suggestion) and perhaps Snappy.  If there are any
other libraries that people would like me to get results for please let
me know and I'll pick maybe the top 2 or 3 and get results back to the
group.



On 13/11/2015 1:58 PM, Peter Tschipper wrote:
> Some further Block Compression tests results that compare performance
> when network latency is added to the mix.
>
> Running two nodes, windows 7, compressionlevel=6, syncing the first
> 200000 blocks from one node to another.  Running on a highspeed
> wireless LAN with no connections to the outside world.
> Network latency was added by using Netbalancer to induce the 30ms and
> 60ms latencies.
>
> From the data not only are bandwidth savings seen but also a small
> performance savings as well.  However, the overall the value in
> compressing blocks appears to be in terms of saving bandwidth.  
>
> I was also surprised to see that there was no real difference in
> performance when no latency was present; apparently the time it takes
> to compress is about equal to the performance savings in such a situation.
>
>
> The following results compare the tests in terms of how long it takes
> to sync the blockchain, compressed vs uncompressed and with varying
> latencies.
> uncmp = uncompressed
> cmp = compressed
>
> num blocks sync'd 	uncmp (secs) 	cmp (secs) 	uncmp 30ms (secs) 	cmp
> 30ms (secs) 	uncmp 60ms (secs) 	cmp 60ms (secs)
> 10000 	264 	269 	265 	257 	274 	275
> 20000 	482 	492 	479 	467 	499 	497
> 30000 	703 	717 	693 	676 	724 	724
> 40000 	918 	939 	902 	886 	947 	944
> 50000 	1140 	1157 	1114 	1094 	1171 	1167
> 60000 	1362 	1380 	1329 	1310 	1400 	1395
> 70000 	1583 	1597 	1547 	1526 	1637 	1627
> 80000 	1810 	1817 	1767 	1745 	1872 	1862
> 90000 	2031 	2036 	1985 	1958 	2109 	2098
> 100000 	2257 	2260 	2223 	2184 	2385 	2355
> 110000 	2553 	2486 	2478 	2422 	2755 	2696
> 120000 	2800 	2724 	2849 	2771 	3345 	3254
> 130000 	3078 	2994 	3356 	3257 	4125 	4006
> 140000 	3442 	3365 	3979 	3870 	5032 	4904
> 150000 	3803 	3729 	4586 	4464 	5928 	5797
> 160000 	4148 	4075 	5168 	5034 	6801 	6661
> 170000 	4509 	4479 	5768 	5619 	7711 	7557
> 180000 	4947 	4924 	6389 	6227 	8653 	8479
> 190000 	5858 	5855 	7302 	7107 	9768 	9566
> 200000 	6980 	6969 	8469 	8220 	10944 	10724
>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151118/7d8123e1/attachment.html>

From jtimon at jtimon.cc  Fri Nov 20 14:15:20 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 20 Nov 2015 15:15:20 +0100
Subject: [bitcoin-dev] [patch] Switching Bitcoin Core to sqlite db
In-Reply-To: <49CD7E61-C49B-472B-BB3C-1EFAD630104A@neomailbox.net>
References: <5631C363.5060705@neomailbox.net>
	<201510290803.52734.luke@dashjr.org>
	<5632DE33.7030600@bitcartel.com>
	<CAAS2fgTga_vTfOKrFu_hEzXSfTfg9FRfJ6aL6ginuGFqnbm7=w@mail.gmail.com>
	<3CB90C47-293E-4C18-A381-E5203483D68F@gmx.com>
	<CAAS2fgRdK4bDr3x_y9UpdH234PQSfD7U539HBLA==+hLQJ_7Fw@mail.gmail.com>
	<571D9B7F-077D-4B80-B577-1C18FF2ECF31@gmx.com>
	<CAAS2fgTLE1cpDqKTiy0r1VMex7zTAB8tgUC=Y0WXmbNBJL42xQ@mail.gmail.com>
	<6DAD1D38-A156-4507-B506-BF66F26E6594@gmx.com>
	<CAAS2fgT+r4aRPe7Qjww6wgbAzkwafN+340pUaVO9F7MZEVY-zA@mail.gmail.com>
	<13D7C936-4D2E-4BAC-AC61-3DA80581C946@gmx.com>
	<CAAS2fgTuty0OCxJvZwU+BCPXG-VuJxtwCPVMvL7Xbze=OjSSdA@mail.gmail.com>
	<2C8EBBD8-51B7-4F47-AFFA-3870DBD6C4EA@gmx.com>
	<CABm2gDrEymffZXRqkYij0eCR3Rg6x1w_=AUJpb3NxHwQ-q48aQ@mail.gmail.com>
	<D64AA4C7-BB66-41B2-A001-107985071DA1@gmx.com>
	<0BABD098-33AB-4638-928B-F2D189FA2F8A@bitsofproof.com>
	<CALJP9GCia3fedPi4B56G1+07OvwytEAOMNczYrJ4iMwUA3F3rQ@mail.gmail.com>
	<49CD7E61-C49B-472B-BB3C-1EFAD630104A@neomailbox.net>
Message-ID: <CABm2gDqOtdLo4aw0+O4UiZpei5v6FGdDCPkrV7_iza+XOouZxg@mail.gmail.com>

On Tue, Nov 17, 2015 at 11:17 PM, telemaco via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Shouldn't a odbc jdbc jconnect or equivalent be totally transparent for the
> consensus code?

Yes, but we're only testing levelDB and we couldn't assure that it
won't produce unintentional consensus forks with other databases
behind the whatever db-agnostic interface.
I believe Bitcoin Core should officially support only one database at
a time. And if that is to change in the future, I don't think it
should be before a storage-agnostic libconsensus is encapsulated (and
after that there will still be risks and costs in officially
supporting several several databases simultaneously).
As has been said, these kind of experiments are welcomed outside of
bitcoin/master though.

From elombrozo at gmail.com  Sat Nov 21 03:29:46 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Sat, 21 Nov 2015 03:29:46 +0000
Subject: [bitcoin-dev] Hierarchical Deterministic Script Templates
Message-ID: <em27bdafa1-7188-4c5b-bfbd-2154fc3c7e54@platinum>

A while back, I started working with William Swanson on a script 
template format to allow for interoperability in accounts between 
different wallets. We made some progress, but both of us got pretty busy 
with other projects and general interest was still quite low.

It seems interest has picked up again, especially in light of recent 
developments (i.e. CLTV, relative CLTV, bidirectional payment channels, 
lightning), where nongeneralized script formats will not readily support 
the rapidly advancing state-of-the-art in script design.

I have started working on a draft for such a standard: 
https://github.com/bitcoin/bips/pull/246

Comments, suggestions, and collaboration are welcome.

- Eric
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151121/9de14fb7/attachment.html>

From elombrozo at gmail.com  Sat Nov 21 08:45:10 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Sat, 21 Nov 2015 08:45:10 +0000
Subject: [bitcoin-dev] Dynamic Hierarchical Deterministic Key Trees
In-Reply-To: <9F747105-0BE5-48B0-9032-A0B4CBFC8A66@bitsofproof.com>
Message-ID: <em5e7d40c8-cabe-487e-a6ad-dfa73bbb4867@platinum>

Tamas,

You could use a key for both signing and for derivation of a deeper 
level (and perhaps there are some applications for this, if you think of 
any please let me know), but the use cases being considered involve 
generation of signing key sequences from seeds that are easy to backup 
and easy to share with others to simplify multidevice synchronization, 
key management, account structures, etc... while also allowing for 
privacy by making it nontrivial to associate transactions for an account 
without knowing the seed/chain code.

As such, we generally refer to such sequences by a path to the immediate 
parent node in the tree and reserve the children themselves for the 
signing keys.


- Eric



------ Original Message ------
From: "Tamas Blummer" <tamas at bitsofproof.com>
To: "Eric Lombrozo" <elombrozo at gmail.com>; "Eric Lombrozo via 
bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org>
Sent: 11/17/2015 5:10:17 AM
Subject: Re: [bitcoin-dev] Dynamic Hierarchical Deterministic Key Trees

>Hi Eric,
>
>Would you please enumerate, or point to, arguments that discourage the 
>use of a key both for signing and for derivation of a deeper level of 
>the hierarchy ?
>
>Tamas Blummer
>
>>  On Nov 17, 2015, at 12:40, Eric Lombrozo via bitcoin-dev 
>><bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>  I've submitted a BIP proposal that solves the issue of needing to 
>>predefine HD wallet structures and not being able to arbitrarily nest 
>>deeper levels. Comments appreciated.
>>
>>  https://github.com/bitcoin/bips/pull/242
>>
>>
>>  - Eric
>>  _______________________________________________
>>  bitcoin-dev mailing list
>>  bitcoin-dev at lists.linuxfoundation.org
>>  https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


From btcdrak at gmail.com  Sat Nov 21 14:13:05 2015
From: btcdrak at gmail.com (Btc Drak)
Date: Sat, 21 Nov 2015 14:13:05 +0000
Subject: [bitcoin-dev] BIP68: Relative lock-time through consensus-enforced
	sequence numbers (update)
Message-ID: <CADJgMzvzfLky3QOGiuUCyjpvQXom3WXUfxuA5_r7jE2itJwGCw@mail.gmail.com>

As I am sure you are aware, for the last 5 months work has been on-going to
create a relative lock-time proposal using sequence numbers. The
implementation can be found at https://github.com/bitcoin/bitcoin/pull/6312.
The current implementation is "mempool-only" and the soft-fork would be
deployed at a later stage.

Over these months there has been various discussion back and forth to
refine the details.

I have updated the BIP text now according to the details that were
discussed in mid-October[1][2] and have extensively clarified the text.

To recap, the overall picture for relative lock-time is that BIP68
introduces consensus rules using some of the nSequence field, while BIP112
creates a new opcode OP_CHECKSEQUENCEVERIFY (PR #6564) so relative
lock-time can be verified from the Bitcoin scripting language. Ideally we
would soft-fork BIP68, BIP112 (CSV) and 113 (MTP) together. BIP113 has been
deployed in 0.11.2 as mempool policy so miners should be applying this
policy as they deploy version 4 blocks for the ongoing CLTV soft-fork
(currently at 42% at the time of writing).

I am writing this mail to draw your attention to the BIP68 pull-requests
and to request final review at:

BIP68 text - https://github.com/bitcoin/bips/pull/245
BIP68 implementation - https://github.com/bitcoin/bitcoin/pull/6312

Discussion references:
[1]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-October/011357.html
[2] http://bitcoinstats.com/irc/bitcoin-dev/logs/2015/10/15#l1444928045.0
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151121/af05804b/attachment.html>

From pete at petertodd.org  Tue Nov 24 04:36:18 2015
From: pete at petertodd.org (Peter Todd)
Date: Mon, 23 Nov 2015 23:36:18 -0500
Subject: [bitcoin-dev] BIP68: Second-level granularity doesn't make sense
Message-ID: <20151124043618.GA7999@muck>

BIP68 currently represents by-height locks as a simple 16-bit integer of
the number of blocks - effectively giving a granularity of 600 seconds
on average - but for for by-time locks the representation is a 25-bit
integer with granularity of 1 second. However this granularity doesn't
make sense with BIP113, median time-past as endpoint for lock-time
calcualtions, and poses potential problems for future upgrades.


There's two cases to consider here:

1) No competing transactions

By this we mean that the nSequence field is being used simply to delay
when an output can be spent; there aren't competing transactions trying
to spend that output and thus we're not concerned about one transaction
getting mined before another "out of order". For instance, an 2-factor
escrow service like GreenAddress could use nSequence with
CHECKSEQUENCEVERIFY (CSV) to guarantee that users will eventually get
their funds back after some timeout.

In this use-case exact miner behavior is irrelevant. Equally given the
large tolerances allowed on block times, as well as the poisson
distribution of blocks generated, granularity below an hour or two
doesn't have much practical significance.


2) Competing transactions

Here we are relying on miners prefering lower sequence numbers. For
instance a bidirectional payment channel can decrement nSequence for
each change of direction; BIP68 suggests such a decrement might happen
in increments of one day.

BIP113 makes lock-time calculations use the median time-past as the
threshold for by-time locks. The median time past is calculated by
taking median time of the 11 previous blocks, which means when a miner
creates a block they have absolutely no control over what the median
time-past is; it's purely a function of the block tip they're building
upon.

This means that granularity below a block interval will, on average,
have absolutely no effect at all on what transaction the miner includes
even in the hypothetical case. In practice of course, users will want to
use significantly larger than 1 block interval granularity in protocols.


The downside of BIP68 as written is users of by-height locktimes have 14
bits unused in nSequence, but by-time locktimes have just 5 bits unused.
This presents an awkward situation if we add new meanings to nSequence
if we ever need more than 5 bits. Yet as shown above, the extra
granularity doesn't have a practical benefit.


Recommendation: Change BIP68 to make by-time locks have the same number
of bits as by-height locks, and multiply the by-time lock field by the
block interval.

-- 
'peter'[:-1]@petertodd.org
000000000000000001a06d85a46abce495fd793f89fe342e6da18b235ade373f
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151123/4e2a25bf/attachment.sig>

From btcdrak at gmail.com  Tue Nov 24 05:05:32 2015
From: btcdrak at gmail.com (Btc Drak)
Date: Tue, 24 Nov 2015 05:05:32 +0000
Subject: [bitcoin-dev] BIP68: Second-level granularity doesn't make sense
In-Reply-To: <20151124043618.GA7999@muck>
References: <20151124043618.GA7999@muck>
Message-ID: <CADJgMzscFPjY5tSPkZgp-Vkd7GraaeQ85qrYU2OHXEfKUSCYkg@mail.gmail.com>

On Tue, Nov 24, 2015 at 4:36 AM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The downside of BIP68 as written is users of by-height locktimes have 14
> bits unused in nSequence, but by-time locktimes have just 5 bits unused.
> This presents an awkward situation if we add new meanings to nSequence
> if we ever need more than 5 bits. Yet as shown above, the extra
> granularity doesn't have a practical benefit.
>
>
> Recommendation: Change BIP68 to make by-time locks have the same number
> of bits as by-height locks, and multiply the by-time lock field by the
> block interval.
>

I think you might be referring to the old specification. I believe this was
brought up before and the specification was changed so the same number of
bits were used for by-time and by-height. Please see
https://github.com/bitcoin/bips/pull/245

However, I am glad you came to the came conclusions independently because
"re-invention" often confirms good ideas :)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/284a4d36/attachment.html>

From pete at petertodd.org  Tue Nov 24 05:58:40 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 24 Nov 2015 00:58:40 -0500
Subject: [bitcoin-dev] BIP68: Second-level granularity doesn't make sense
In-Reply-To: <CADJgMzscFPjY5tSPkZgp-Vkd7GraaeQ85qrYU2OHXEfKUSCYkg@mail.gmail.com>
References: <20151124043618.GA7999@muck>
	<CADJgMzscFPjY5tSPkZgp-Vkd7GraaeQ85qrYU2OHXEfKUSCYkg@mail.gmail.com>
Message-ID: <20151124055840.GA5942@savin.petertodd.org>

On Tue, Nov 24, 2015 at 05:05:32AM +0000, Btc Drak wrote:
> On Tue, Nov 24, 2015 at 4:36 AM, Peter Todd via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > The downside of BIP68 as written is users of by-height locktimes have 14
> > bits unused in nSequence, but by-time locktimes have just 5 bits unused.
> > This presents an awkward situation if we add new meanings to nSequence
> > if we ever need more than 5 bits. Yet as shown above, the extra
> > granularity doesn't have a practical benefit.
> >
> >
> > Recommendation: Change BIP68 to make by-time locks have the same number
> > of bits as by-height locks, and multiply the by-time lock field by the
> > block interval.
> >
> 
> I think you might be referring to the old specification. I believe this was
> brought up before and the specification was changed so the same number of
> bits were used for by-time and by-height. Please see
> https://github.com/bitcoin/bips/pull/245
> 
> However, I am glad you came to the came conclusions independently because
> "re-invention" often confirms good ideas :)

Ha, that's awesome! Looks like we're pretty much on the same page re:
granularity.

-- 
'peter'[:-1]@petertodd.org
000000000000000003c0cf6b89d2a9b68a8cedbd3935962203c21663925c714b
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/4f0ba27e/attachment.sig>

From btcdrak at gmail.com  Tue Nov 24 10:30:52 2015
From: btcdrak at gmail.com (Btc Drak)
Date: Tue, 24 Nov 2015 10:30:52 +0000
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
Message-ID: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>

BIP68 introduces relative lock-time semantics to part of the nSequence
field leaving the majority of bits undefined for other future applications.

BIP112 introduces opcode CHECKSEQUENCEVERIFY (OP_CSV) that is specifically
limited to verifying transaction inputs according to BIP68's relative
lock-time[1], yet the _name_ OP_CSV is much boarder than that. We spent
months limiting the number of bits used in BIP68 so they would be available
for future use cases, thus we have acknowledged there will be completely
different usecases that take advantage of unused nSequence bits.

For this reason I believe the BIP112 should be renamed specifically for
it's usecase, which is verifying the time/maturity of transaction inputs
relative to their inclusion in a block.

Suggestions:-

CHECKMATURITYVERIFY
RELATIVELOCKTIMEVERIFY
RCHECKLOCKTIMEVERIFY
RCLTV

We could of course softfork additional meaning into OP_CSV each time we add
new sequence number usecases, but that would become obscure and confusing.
We have already shown there is no shortage of opcodes so it makes no sense
to cram everything into one generic opcode.

TL;DR: let's give BIP112 opcode a name that reflects it's actual usecase
rather than focusing on the bitcoin internals.

[1]
https://github.com/bitcoin/bitcoin/pull/6564/files#diff-be2905e2f5218ecdbe4e55637dac75f3R1223
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/a775f63a/attachment.html>

From pete at petertodd.org  Tue Nov 24 12:20:40 2015
From: pete at petertodd.org (Peter Todd)
Date: Tue, 24 Nov 2015 07:20:40 -0500
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
References: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
Message-ID: <20151124122040.GA16003@savin.petertodd.org>

On Tue, Nov 24, 2015 at 10:30:52AM +0000, Btc Drak via bitcoin-dev wrote:
> BIP68 introduces relative lock-time semantics to part of the nSequence
> field leaving the majority of bits undefined for other future applications.
> 
> BIP112 introduces opcode CHECKSEQUENCEVERIFY (OP_CSV) that is specifically
> limited to verifying transaction inputs according to BIP68's relative
> lock-time[1], yet the _name_ OP_CSV is much boarder than that. We spent
> months limiting the number of bits used in BIP68 so they would be available
> for future use cases, thus we have acknowledged there will be completely
> different usecases that take advantage of unused nSequence bits.
> 
> For this reason I believe the BIP112 should be renamed specifically for
> it's usecase, which is verifying the time/maturity of transaction inputs
> relative to their inclusion in a block.
> 
> Suggestions:-
> 
> CHECKMATURITYVERIFY

Definitely this one.

Although I wouldn't rush to make the change just yet - I for one am busy
writing some test programs to actually use BIP112, and in theory they
might say the more general CSV concept is better.

Whatever we call it, deciding on that is a simple s/FOO/BAR/ prior to
release.

-- 
'peter'[:-1]@petertodd.org
000000000000000008cd594ba6601fcc5e9e919b30630076c64657209b13c7b4
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/4d685b3f/attachment.sig>

From jtimon at jtimon.cc  Tue Nov 24 12:31:55 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 24 Nov 2015 13:31:55 +0100
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
References: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
Message-ID: <CABm2gDqoq4pkXLS=4rKGOLGU0_0mq1_yMOHmLw73m=apiMRMpg@mail.gmail.com>

I agree, I believe the first name that an op with equivalent functionality
had was simply op_maturity.
At least I remember we discussed such an opcode when discussing pegged
sidechains' design.

I kind of dislike the check_x_verify naming pattern. We want all new
operands to return if whatever they're checking/verifying fails, fine. Do
we have to repeat this redundant naming pattern forever due to that
discovery?
I hope not, but if that's the case my vote is for CMV.
As said before, I believe the documentation and code comments can become
much more clear with this change.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/5b9476f9/attachment.html>

From jtimon at jtimon.cc  Tue Nov 24 12:35:58 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 24 Nov 2015 13:35:58 +0100
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <20151124122040.GA16003@savin.petertodd.org>
References: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
	<20151124122040.GA16003@savin.petertodd.org>
Message-ID: <CABm2gDrG_5DN6HM6XxuZOQj_aZd0vCTs+mEHX+69Exnz5JCq2A@mail.gmail.com>

On Nov 24, 2015 1:21 PM, "Peter Todd via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Whatever we call it, deciding on that is a simple s/FOO/BAR/ prior to
> release.

While I agree we're not in a hurry, the more we wait, the longer docs (to
be modified later) will accumulate making the assumption that the name is
csv rather than op_maturity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/0212d72f/attachment.html>

From cp368202 at ohiou.edu  Tue Nov 24 17:34:35 2015
From: cp368202 at ohiou.edu (Chris Priest)
Date: Tue, 24 Nov 2015 09:34:35 -0800
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
	"Coalescing Transactions"
Message-ID: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>

Here is the problem I'm trying to solve with this idea:

Lets say you create an address, publish the address on your blog, and
tell all your readers to donate $0.05 to that address if they like
your blog. Lets assume you receive 10,000 donations this way. This all
adds up to $500. The problem is that because of the way the bitcoin
payment protocol works, a large chunk of that money will go to fees.
If one person sent you a single donation of $500, you would be able to
spend most of the $500, but since you got this coin by many smaller
UTXO's, your wallet has to use a higher tx fee when spending this
coin.

The technical reason for this is that you have to explicitly list each
UTXO individually when making bitcoin transactions. There is no way to
say "all the utxos". This post describes a way to achieve this. I'm
not yet a bitcoin master, so there are parts of this proposal that I
have not yet figured out entirely, but I'm sure other people who know
more could help out.

**OP_CHECKWILDCARDSIGVERIFY**

First, I propose a new opcode. This opcode works exactly the same as
OP_CHECKSIGVERIFY, except it only evaluates true if the signature is a
"wildcard signature". What is a wildcard signature you ask? This is
the part that I have not yet 100% figured out yet. It is basically a
signature that was created in such a way that expresses the private
key owners intent to make this input a *wildcard input*

** wildcard inputs **

A wildcard input is defined as a input to a transaction that has been
signed with OP_CHECKWILDCARDSIGVERIFY. The difference between a
wildcard input and a regular input is that the regular input respects
the "value" or "amount" field, while the wildcard input ignores that
value, and instead uses the value of *all inputs* with a matching
locking script.

** coalescing transaction"

A bitcoin transaction that

From gavinandresen at gmail.com  Tue Nov 24 20:32:37 2015
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Tue, 24 Nov 2015 15:32:37 -0500
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
Message-ID: <CABsx9T0A8EczcsE8f3D4WGk-0xsPadupBVgH5_kTs=GEhOq_9g@mail.gmail.com>

On Tue, Nov 24, 2015 at 12:34 PM, Chris Priest via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The technical reason for this is that you have to explicitly list each
> UTXO individually when making bitcoin transactions. There is no way to
> say "all the utxos". This post describes a way to achieve this. I'm
> not yet a bitcoin master, so there are parts of this proposal that I
> have not yet figured out entirely, but I'm sure other people who know
> more could help out.
>

So every input has:
 32-byte hash (transaction being spent)
 4-byte output (output being spent)
 4-byte sequence number
... plus the scriptSig. Which is as small as about 73 bytes if you're
spending a raw OP_CHECKSIG (which you can't do as a bitcoin address, but
could via the BIP70 payment protocol), and which is at least two serialized
bytes.

Best case for any scheme to coalesce scriptSigs would to somehow make
all-but-the-first scriptSig zero-length, so the inputs would be 42 bytes
instead of 40+73 bytes -- the coalesce transaction would be about one-third
the size, so instead of paying (say) $1 in transaction fees you'd pay 37
cents.

That's in the gray are of the "worth doing" threshold-- if it was a 10x
improvement (pay 10 cents instead of $1) it'd be in my personal "definitely
worth the trouble of doing" category.

RE: the scheme:  an OP_RINGSIGVERIFY is probably the right way to do this:
  https://en.wikipedia.org/wiki/Ring_signature

The funding transactions would be:  <public key> OP_RINGSIGVERIFY
... which might could be redeemed with <ring signature> for one input and
then... uhh... maybe just <index_to_input_with_signature> for the other
inputs that are part of the same ring signature group (OP_0 if the first
input has the signature that is good for all the other public keys, which
would be the common case).

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/ea951f71/attachment.html>

From cp368202 at ohiou.edu  Tue Nov 24 21:01:26 2015
From: cp368202 at ohiou.edu (Chris Priest)
Date: Tue, 24 Nov 2015 13:01:26 -0800
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CABsx9T0A8EczcsE8f3D4WGk-0xsPadupBVgH5_kTs=GEhOq_9g@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABsx9T0A8EczcsE8f3D4WGk-0xsPadupBVgH5_kTs=GEhOq_9g@mail.gmail.com>
Message-ID: <CAAcC9yvX2QRQvjtnO_Uiv5i=PUfAcNVJAazr_qR0Uz+uThxL6Q@mail.gmail.com>

A coalescing transaction in my scheme is the same size as a normal
transaction. You only include one UTXO, the rest are implied based on
the presence of the OP_CHECKWILDCARDSIGVERIFY opcode.

The code that determines if a UTXO is spent or not will need to be
modified to include a check to see if any matching coalescing
transactions exist in any later block. Maybe there should be a
"coalescing pool" containing all coalescing transactions that make
such a check faster.

The part I'm not too sure about is the "wildcard signature". I'm not
too versed in cryptography to know how exactly to pull this off, but I
think it should be simple.
You'd just have to some way inject a flag into the signing process
that can be verified later.

I originally wanted the "wildcardness" of the transaction expressed by
the transaction version number.
Basically any input that exists within a "version 2 transaction" is
viewed as a wildcard input. Then I realized whats to stop someone from
modifying the transaction from version 1 to version 2 and stealing
someones funds. The "wildcardness" must be expressed in the signature
so you know that the private key holder intended all inputs to be
included. Hence the need for a new opcode.

btw, this scheme is definitely in the 10x or higher gain. You could
potentially spend an unlimited number of UTXOs this way.

On 11/24/15, Gavin Andresen <gavinandresen at gmail.com> wrote:
> On Tue, Nov 24, 2015 at 12:34 PM, Chris Priest via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> The technical reason for this is that you have to explicitly list each
>> UTXO individually when making bitcoin transactions. There is no way to
>> say "all the utxos". This post describes a way to achieve this. I'm
>> not yet a bitcoin master, so there are parts of this proposal that I
>> have not yet figured out entirely, but I'm sure other people who know
>> more could help out.
>>
>
> So every input has:
>  32-byte hash (transaction being spent)
>  4-byte output (output being spent)
>  4-byte sequence number
> ... plus the scriptSig. Which is as small as about 73 bytes if you're
> spending a raw OP_CHECKSIG (which you can't do as a bitcoin address, but
> could via the BIP70 payment protocol), and which is at least two serialized
> bytes.
>
> Best case for any scheme to coalesce scriptSigs would to somehow make
> all-but-the-first scriptSig zero-length, so the inputs would be 42 bytes
> instead of 40+73 bytes -- the coalesce transaction would be about one-third
> the size, so instead of paying (say) $1 in transaction fees you'd pay 37
> cents.
>
> That's in the gray are of the "worth doing" threshold-- if it was a 10x
> improvement (pay 10 cents instead of $1) it'd be in my personal "definitely
> worth the trouble of doing" category.
>
> RE: the scheme:  an OP_RINGSIGVERIFY is probably the right way to do this:
>   https://en.wikipedia.org/wiki/Ring_signature
>
> The funding transactions would be:  <public key> OP_RINGSIGVERIFY
> ... which might could be redeemed with <ring signature> for one input and
> then... uhh... maybe just <index_to_input_with_signature> for the other
> inputs that are part of the same ring signature group (OP_0 if the first
> input has the signature that is good for all the other public keys, which
> would be the common case).
>
> --
> --
> Gavin Andresen
>

From kanzure at gmail.com  Tue Nov 24 21:51:12 2015
From: kanzure at gmail.com (Bryan Bishop)
Date: Tue, 24 Nov 2015 15:51:12 -0600
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
Message-ID: <CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>

On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> **OP_CHECKWILDCARDSIGVERIFY**


Some (minor) discussion of this idea in -wizards earlier today starting
near near "09:50" (apologies for having no anchor links):
http://gnusha.org/bitcoin-wizards/2015-11-24.log

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/1cabe010/attachment.html>

From dscotese at litmocracy.com  Tue Nov 24 23:28:33 2015
From: dscotese at litmocracy.com (Dave Scotese)
Date: Tue, 24 Nov 2015 15:28:33 -0800
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
Message-ID: <CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>

What is required to spend bitcoin is that input be provided to the UTXO
script that causes it to return true.  What Chris is proposing breaks the
programmatic nature of the requirement, replacing it with a requirement
that the secret be known.  Granted, the secret is the only requirement in
most cases, but there is no built-in assumption that the script always
requires only that secret.

This idea could be applied by having the wildcard signature apply to all
UTXOs that are of a standard form and paid to a particular address, and be
a signature of some kind of message to that effect.  I imagine the cost of
re-scanning the UTXO set to find them all would justify a special extra
mining fee for any transaction that used this opcode.

Please be blunt about any of my own misunderstandings that this email makes
clear.

On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> **OP_CHECKWILDCARDSIGVERIFY**
>
>
> Some (minor) discussion of this idea in -wizards earlier today starting
> near near "09:50" (apologies for having no anchor links):
> http://gnusha.org/bitcoin-wizards/2015-11-24.log
>
> - Bryan
> http://heybryan.org/
> 1 512 203 0507
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151124/0b0a26f2/attachment.html>

From cp368202 at ohiou.edu  Tue Nov 24 23:48:16 2015
From: cp368202 at ohiou.edu (Chris Priest)
Date: Tue, 24 Nov 2015 15:48:16 -0800
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
	<CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
Message-ID: <CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>

> This idea could be applied by having the wildcard signature apply to all
> UTXOs that are of a standard form and paid to a particular address, and be
> a signature of some kind of message to that effect.

I think this is true. Not *all* transactions will be able to match the
wildcard. For instance if someone sent some crazy smart contract tx to
your address, the script associated with that tx will be such that it
will not apply to the wildcard. Most "vanilla" utxos that I've seen
have the formula: OP_DUP OP_HASH160 [a hash corresponding to your
address] OP_EQUALVERIFY OP_CHECKSIG". Just UTXOs in that form could
apply to the wildcard.

On 11/24/15, Dave Scotese via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> What is required to spend bitcoin is that input be provided to the UTXO
> script that causes it to return true.  What Chris is proposing breaks the
> programmatic nature of the requirement, replacing it with a requirement
> that the secret be known.  Granted, the secret is the only requirement in
> most cases, but there is no built-in assumption that the script always
> requires only that secret.
>
> This idea could be applied by having the wildcard signature apply to all
> UTXOs that are of a standard form and paid to a particular address, and be
> a signature of some kind of message to that effect.  I imagine the cost of
> re-scanning the UTXO set to find them all would justify a special extra
> mining fee for any transaction that used this opcode.
>
> Please be blunt about any of my own misunderstandings that this email makes
> clear.
>
> On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> **OP_CHECKWILDCARDSIGVERIFY**
>>
>>
>> Some (minor) discussion of this idea in -wizards earlier today starting
>> near near "09:50" (apologies for having no anchor links):
>> http://gnusha.org/bitcoin-wizards/2015-11-24.log
>>
>> - Bryan
>> http://heybryan.org/
>> 1 512 203 0507
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> --
> I like to provide some work at no charge to prove my value. Do you need a
> techie?
> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> <http://www.memeracing.net> (in alpha).
> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
> now accepts Bitcoin.
> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> "He ought to find it more profitable to play by the rules" - Satoshi
> Nakamoto
>

From jannes.faber at gmail.com  Wed Nov 25 00:38:02 2015
From: jannes.faber at gmail.com (Jannes Faber)
Date: Wed, 25 Nov 2015 01:38:02 +0100
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
	<CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
	<CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>
Message-ID: <CABeL=0hm=6S6YRQP45pNVv42b1kHZrH1TFuz3xguN+YNW5o=ww@mail.gmail.com>

Few issues I can think of:

1. In its basic form this encourages address reuse. Unless the wildcard can
be constructed such that it can match a whole branch of an HD  wallet.
Although I guess that would tie all those addresses together making HD moot
to begin with.

2. Sounds pretty dangerous during reorgs. Maybe such a transaction should
include a block height which indicates the maximum block that any utxo can
match. With the requirement that the specified block height is at least 100
blocks in the past. Maybe add a minimum block height as well to prevent
unnecessary scanning (with the requirement that at least one utxo must be
in that minimum block).

3. Seems like a nice way to the reduce utxo set. But hard to say how
effective it would really be.
On 25 Nov 2015 12:48 a.m., "Chris Priest via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> > This idea could be applied by having the wildcard signature apply to all
> > UTXOs that are of a standard form and paid to a particular address, and
> be
> > a signature of some kind of message to that effect.
>
> I think this is true. Not *all* transactions will be able to match the
> wildcard. For instance if someone sent some crazy smart contract tx to
> your address, the script associated with that tx will be such that it
> will not apply to the wildcard. Most "vanilla" utxos that I've seen
> have the formula: OP_DUP OP_HASH160 [a hash corresponding to your
> address] OP_EQUALVERIFY OP_CHECKSIG". Just UTXOs in that form could
> apply to the wildcard.
>
> On 11/24/15, Dave Scotese via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > What is required to spend bitcoin is that input be provided to the UTXO
> > script that causes it to return true.  What Chris is proposing breaks the
> > programmatic nature of the requirement, replacing it with a requirement
> > that the secret be known.  Granted, the secret is the only requirement in
> > most cases, but there is no built-in assumption that the script always
> > requires only that secret.
> >
> > This idea could be applied by having the wildcard signature apply to all
> > UTXOs that are of a standard form and paid to a particular address, and
> be
> > a signature of some kind of message to that effect.  I imagine the cost
> of
> > re-scanning the UTXO set to find them all would justify a special extra
> > mining fee for any transaction that used this opcode.
> >
> > Please be blunt about any of my own misunderstandings that this email
> makes
> > clear.
> >
> > On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
> >> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >>> **OP_CHECKWILDCARDSIGVERIFY**
> >>
> >>
> >> Some (minor) discussion of this idea in -wizards earlier today starting
> >> near near "09:50" (apologies for having no anchor links):
> >> http://gnusha.org/bitcoin-wizards/2015-11-24.log
> >>
> >> - Bryan
> >> http://heybryan.org/
> >> 1 512 203 0507
> >>
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>
> >>
> >
> >
> > --
> > I like to provide some work at no charge to prove my value. Do you need a
> > techie?
> > I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> > <http://www.memeracing.net> (in alpha).
> > I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
> which
> > now accepts Bitcoin.
> > I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> > "He ought to find it more profitable to play by the rules" - Satoshi
> > Nakamoto
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/0140731a/attachment-0001.html>

From elombrozo at gmail.com  Wed Nov 25 01:14:55 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Wed, 25 Nov 2015 01:14:55 +0000
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CABm2gDqoq4pkXLS=4rKGOLGU0_0mq1_yMOHmLw73m=apiMRMpg@mail.gmail.com>
Message-ID: <em80f319b9-ff7c-4a88-85c7-efdb0333ada1@platinum>

>From a system developer standpoint, CHECKMATURITYVERIFY ties together 
the semantics of this opcode with another existing feature in the system 
(coinbase maturity).

HOWEVER...

from an application developer standpoint, I think the concept of a 
timelock is more relevant. Maturity is a concept that was introduced for 
the sake of reducing the disruptive impact of reorgs. Miners would 
prefer to be able to spend the coins immediately, but instead they are 
forced to wait due to inherent limitations of the system. Timelocks, on 
the other hand, are typically used to control when funds can be moved. 
In these use cases, one or more of the parties involved explicitly want 
there to be a delay even if there were an idealized situation in which 
consensus is always reached instantaneously and there were never any 
reorgs.

Moreover, since we already have CLTV, adding RCLTV or some variant 
thereof makes the relationship between the two more explicit.

So my vote goes to RCLTV or RCHECKLOCKTIMEVERIFY.

As for whether to explicitly use CHECK_..._VERIFY, consider that with 
segregated witness it will be possible to add opcodes that can push 
values onto the stack (rather than just hard failing or NOP), so there's 
something to be said for naming consistency.

- Eric



------ Original Message ------
From: "Jorge Tim?n" <bitcoin-dev at lists.linuxfoundation.org>
To: "Btc Drak" <btcdrak at gmail.com>
Cc: "Bitcoin Dev" <bitcoin-dev at lists.linuxfoundation.org>
Sent: 11/24/2015 4:31:55 AM
Subject: Re: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY 
(BIP112)

>I agree, I believe the first name that an op with equivalent 
>functionality had was simply op_maturity.
>At least I remember we discussed such an opcode when discussing pegged 
>sidechains' design.
>
>I kind of dislike the check_x_verify naming pattern. We want all new 
>operands to return if whatever they're checking/verifying fails, fine. 
>Do we have to repeat this redundant naming pattern forever due to that 
>discovery?
>I hope not, but if that's the case my vote is for CMV.
>As said before, I believe the documentation and code comments can 
>become much more clear with this change.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/f2bded13/attachment.html>

From cp368202 at ohiou.edu  Wed Nov 25 01:26:51 2015
From: cp368202 at ohiou.edu (Chris Priest)
Date: Tue, 24 Nov 2015 17:26:51 -0800
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CABeL=0hm=6S6YRQP45pNVv42b1kHZrH1TFuz3xguN+YNW5o=ww@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
	<CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
	<CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>
	<CABeL=0hm=6S6YRQP45pNVv42b1kHZrH1TFuz3xguN+YNW5o=ww@mail.gmail.com>
Message-ID: <CAAcC9yuUYx5o50ocTiFp2keYUuew8aT5fuCnx-huHUgeGK5r1g@mail.gmail.com>

1. Technically is it promoting address reuse, but in this case, I
think it's OK. The primary purpose of a coalescing transaction is to
clear out *all* funds associated with one address and send them to
another address (belonging to the same owner). If you coalesce the
inputs to the same address over and over again, you an do that, but
you'll run the risk of leaking your private key.

2. I see these transactions being broadcast in the background when the
user is not planning on sending or receiving any payments. By the time
the wallet user wants to spend funds from the address, the coalescing
transaction should be sufficiently deep enough in the blockchain to
avoid re-org tomfoolery. Exchanges and payment processors who take in
payments around the clock will probably never use these transactions,
at least not on "live" addresses.

3. I never thought of that, but thats a benefit too!

On 11/24/15, Jannes Faber via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Few issues I can think of:
>
> 1. In its basic form this encourages address reuse. Unless the wildcard can
> be constructed such that it can match a whole branch of an HD  wallet.
> Although I guess that would tie all those addresses together making HD moot
> to begin with.
>
> 2. Sounds pretty dangerous during reorgs. Maybe such a transaction should
> include a block height which indicates the maximum block that any utxo can
> match. With the requirement that the specified block height is at least 100
> blocks in the past. Maybe add a minimum block height as well to prevent
> unnecessary scanning (with the requirement that at least one utxo must be
> in that minimum block).
>
> 3. Seems like a nice way to the reduce utxo set. But hard to say how
> effective it would really be.
> On 25 Nov 2015 12:48 a.m., "Chris Priest via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> > This idea could be applied by having the wildcard signature apply to
>> > all
>> > UTXOs that are of a standard form and paid to a particular address, and
>> be
>> > a signature of some kind of message to that effect.
>>
>> I think this is true. Not *all* transactions will be able to match the
>> wildcard. For instance if someone sent some crazy smart contract tx to
>> your address, the script associated with that tx will be such that it
>> will not apply to the wildcard. Most "vanilla" utxos that I've seen
>> have the formula: OP_DUP OP_HASH160 [a hash corresponding to your
>> address] OP_EQUALVERIFY OP_CHECKSIG". Just UTXOs in that form could
>> apply to the wildcard.
>>
>> On 11/24/15, Dave Scotese via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > What is required to spend bitcoin is that input be provided to the UTXO
>> > script that causes it to return true.  What Chris is proposing breaks
>> > the
>> > programmatic nature of the requirement, replacing it with a requirement
>> > that the secret be known.  Granted, the secret is the only requirement
>> > in
>> > most cases, but there is no built-in assumption that the script always
>> > requires only that secret.
>> >
>> > This idea could be applied by having the wildcard signature apply to
>> > all
>> > UTXOs that are of a standard form and paid to a particular address, and
>> be
>> > a signature of some kind of message to that effect.  I imagine the cost
>> of
>> > re-scanning the UTXO set to find them all would justify a special extra
>> > mining fee for any transaction that used this opcode.
>> >
>> > Please be blunt about any of my own misunderstandings that this email
>> makes
>> > clear.
>> >
>> > On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
>> > bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >
>> >> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
>> >> bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >>
>> >>> **OP_CHECKWILDCARDSIGVERIFY**
>> >>
>> >>
>> >> Some (minor) discussion of this idea in -wizards earlier today
>> >> starting
>> >> near near "09:50" (apologies for having no anchor links):
>> >> http://gnusha.org/bitcoin-wizards/2015-11-24.log
>> >>
>> >> - Bryan
>> >> http://heybryan.org/
>> >> 1 512 203 0507
>> >>
>> >> _______________________________________________
>> >> bitcoin-dev mailing list
>> >> bitcoin-dev at lists.linuxfoundation.org
>> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >>
>> >>
>> >
>> >
>> > --
>> > I like to provide some work at no charge to prove my value. Do you need
>> > a
>> > techie?
>> > I own Litmocracy <http://www.litmocracy.com> and Meme Racing
>> > <http://www.memeracing.net> (in alpha).
>> > I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
>> which
>> > now accepts Bitcoin.
>> > I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
>> > "He ought to find it more profitable to play by the rules" - Satoshi
>> > Nakamoto
>> >
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>

From erik.fors at startmail.com  Wed Nov 25 14:16:14 2015
From: erik.fors at startmail.com (Erik)
Date: Wed, 25 Nov 2015 15:16:14 +0100
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <CAAcC9yuUYx5o50ocTiFp2keYUuew8aT5fuCnx-huHUgeGK5r1g@mail.gmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
	<CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
	<CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>
	<CABeL=0hm=6S6YRQP45pNVv42b1kHZrH1TFuz3xguN+YNW5o=ww@mail.gmail.com>
	<CAAcC9yuUYx5o50ocTiFp2keYUuew8aT5fuCnx-huHUgeGK5r1g@mail.gmail.com>
Message-ID: <5655C2AE.6040404@startmail.com>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1


Nice idea. I see it as an important feature because of several reasons:

Considering the website example, where most websites uses static
content, a bitcoin address could accumulate a dozen of transactions
before the webmaster changes the address to a new one.

Also consider a QR-code address printed on paper. That address is also
prone to multiple payments, which could be several small ones.

You ask someone to pay an amount of BTC. That person would be someone
that want you to actually don't get any money at all, so instead of
sending one payment, the person sends a lot of small TXes. It costs a
lot more to achieve this, but that doesn't bother the person sending the
transactions. What you see is the transactions to the address you've
agreed sum up to the amount you asked for. When you later try to spend
it, you can't because of that the size of all UXTOs is too high to even
overcome the tx fee.

If you use a wildcard transaction to bake them together into one UXTO,
you will not need to pay more than just one tx fee to solve the problem
you've got. Also the network will benefit from this because the
alternative is to not spend those UXTOs at all because it costs more
than it earns, leaving lots of UXTOs in the databases.

Some problems to consider is:
* Which addresses should be involved in a wildcard TX.
* How to not make it repeatable or delayed so that UXTOs not intended to
be in that TX wouldn't be included.
* How to make it impossible to sign an wildcard TX with a future date.
* How to limit outputs so they not are in risk being double-spent.
* How to guarantee that the output is actually calculated from all the
inputs involved and not less, making insane TX fees available.

I could see possible solutions to this problems:
* Using the highest block height number of transactions to include or
maybe better, the UXTO of one transaction destined to that address
involved in that block - that implies collecting all UXTOs in that block.
* Using a signature that includes the date. To let it be present more
times in the blockchain requires another timestamp that is newer than a
wildcard TX already existing in the blockchain. Also make the
transaction invalid to put in a block if the timestamp is behind a
certain time or in the future.
* Using the coinbase UXTO or the block hash from the latest block as
proof that the transaction isn't created earlier than that. Also makes
the wildcard TX invalid if that block isn't part of the blockchain
anymore. This also have a secondary effect of certifying the blockchain
itself making it more difficult to fork it from far behind because it
will effectively remove all transactions depending on a UXTO including
this type of certification.
* Either using a priority like way to determine what are being left to
wildcard in a block - all transactions spending UXTOs of that address is
removed before the wildcard TX if they occurs in the same block. Either
it is possible to set a rule that if a wildcard TX exists in one block,
it is invalid to include other UXTOs that is to be be included in the
wildcard from the same address in the same block. (Classic
double-spending rule)
* Using a special form of output specifying only one destination
address/script and the amount of fees to pay. If the amount of fees
could be payed, then the rest will be sent to the destination address.
This covers intentional delaying and also discourage forking the
blockchain by miners to making the signature UXTO appear later than more
recent transaction in a new fork to collect the later txes as fee.

This transaction type would in fact look like a time-limited offer to
the network to reduce the UXTO set of an address. I guess some miners
will then use a logic that prefers this types of TXes even if they are
low-fee because, if they removes lots of UXTOs, they benefits the network.

Sincerely,
Erik.

Den 2015-11-25 kl. 02:26, skrev Chris Priest via bitcoin-dev:
> 1. Technically is it promoting address reuse, but in this case, I
> think it's OK. The primary purpose of a coalescing transaction is to
> clear out *all* funds associated with one address and send them to
> another address (belonging to the same owner). If you coalesce the
> inputs to the same address over and over again, you an do that, but
> you'll run the risk of leaking your private key.
>
> 2. I see these transactions being broadcast in the background when the
> user is not planning on sending or receiving any payments. By the time
> the wallet user wants to spend funds from the address, the coalescing
> transaction should be sufficiently deep enough in the blockchain to
> avoid re-org tomfoolery. Exchanges and payment processors who take in
> payments around the clock will probably never use these transactions,
> at least not on "live" addresses.
>
> 3. I never thought of that, but thats a benefit too!
>
> On 11/24/15, Jannes Faber via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Few issues I can think of:
>>
>> 1. In its basic form this encourages address reuse. Unless the
wildcard can
>> be constructed such that it can match a whole branch of an HD  wallet.
>> Although I guess that would tie all those addresses together making
HD moot
>> to begin with.
>>
>> 2. Sounds pretty dangerous during reorgs. Maybe such a transaction should
>> include a block height which indicates the maximum block that any
utxo can
>> match. With the requirement that the specified block height is at
least 100
>> blocks in the past. Maybe add a minimum block height as well to prevent
>> unnecessary scanning (with the requirement that at least one utxo must be
>> in that minimum block).
>>
>> 3. Seems like a nice way to the reduce utxo set. But hard to say how
>> effective it would really be.
>> On 25 Nov 2015 12:48 a.m., "Chris Priest via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>>> This idea could be applied by having the wildcard signature apply to
>>>> all
>>>> UTXOs that are of a standard form and paid to a particular address, and
>>> be
>>>> a signature of some kind of message to that effect.
>>>
>>> I think this is true. Not *all* transactions will be able to match the
>>> wildcard. For instance if someone sent some crazy smart contract tx to
>>> your address, the script associated with that tx will be such that it
>>> will not apply to the wildcard. Most "vanilla" utxos that I've seen
>>> have the formula: OP_DUP OP_HASH160 [a hash corresponding to your
>>> address] OP_EQUALVERIFY OP_CHECKSIG". Just UTXOs in that form could
>>> apply to the wildcard.
>>>
>>> On 11/24/15, Dave Scotese via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> What is required to spend bitcoin is that input be provided to the UTXO
>>>> script that causes it to return true.  What Chris is proposing breaks
>>>> the
>>>> programmatic nature of the requirement, replacing it with a requirement
>>>> that the secret be known.  Granted, the secret is the only requirement
>>>> in
>>>> most cases, but there is no built-in assumption that the script always
>>>> requires only that secret.
>>>>
>>>> This idea could be applied by having the wildcard signature apply to
>>>> all
>>>> UTXOs that are of a standard form and paid to a particular address, and
>>> be
>>>> a signature of some kind of message to that effect.  I imagine the cost
>>> of
>>>> re-scanning the UTXO set to find them all would justify a special extra
>>>> mining fee for any transaction that used this opcode.
>>>>
>>>> Please be blunt about any of my own misunderstandings that this email
>>> makes
>>>> clear.
>>>>
>>>> On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>
>>>>>> **OP_CHECKWILDCARDSIGVERIFY**
>>>>>
>>>>>
>>>>> Some (minor) discussion of this idea in -wizards earlier today
>>>>> starting
>>>>> near near "09:50" (apologies for having no anchor links):
>>>>> http://gnusha.org/bitcoin-wizards/2015-11-24.log
>>>>>
>>>>> - Bryan
>>>>> http://heybryan.org/
>>>>> 1 512 203 0507
>>>>>
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>>>>
>>>>
>>>>
>>>> --
>>>> I like to provide some work at no charge to prove my value. Do you need
>>>> a
>>>> techie?
>>>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
>>>> <http://www.memeracing.net> (in alpha).
>>>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
>>> which
>>>> now accepts Bitcoin.
>>>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
>>>> "He ought to find it more profitable to play by the rules" - Satoshi
>>>> Nakamoto
>>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2.0.22 (GNU/Linux)

iQIcBAEBAgAGBQJWVcKuAAoJEJ51csApon2ofiYP/15DXthFvNg9pBPOaaboGOh1
DhN7R3SXnt4PTLygQGO3AkTRcDinQrZ0Q4GDLIgrOkaKJ4yr6FtnoEYGORQSfFkx
946eWtqkR4+IJi7gYIIn1yOfFjWKUp9l4OOWBA8Rxsn0tZUAQPXzf2f+dxAaj0Gd
fLrftYvK1XJ8BolhwNfonJ193RJGFynQfWqZ+XeQQMS5LW23RpQLyI26f495MPHG
Wug7M/Aq50JrJDe1OyhjnnjYxNV6Gdbg9o3YIdj2gaOsBKHzsPK+LjcLCdRqD/OI
TBwmwiI4vrOl3HzvtucHxQqnaP43wubydVhPfmjG97tDaj2cVLjadc17e77PzCVI
8N21oVIWDzyW6y14REoo1Zs4A9ALpHjXAGWdls71eP1NIFcfdFAJWhk2/giisw8o
ZsQTgq2mUHS+n4q3NjFEwGxS011yADE3Uf3ryjuTjp3HVQf3lZxn4E4Z7z/4gkXm
/h/3Ln7PkjEmOqp9htgHcYW7q5goeJzV0xNDBoY9wvOlJQcAh6nTiS4SJEiFJvXU
xVZIGZsisrdW/1CfcszOi7KFGaaV1VlAXQnuJHj1I3dJ2r68yi5TQk6voMNFprEz
2R4zuZKjIoH79rOjDV8l6XBIU1Kh92GEzCFlTicfvnAoa853fGZt+V/77ralftJW
E6sERK8uG8S3KdBSVQ7K
=1xdi
-----END PGP SIGNATURE-----



From trevinhofmann at gmail.com  Wed Nov 25 15:41:01 2015
From: trevinhofmann at gmail.com (Trevin Hofmann)
Date: Wed, 25 Nov 2015 09:41:01 -0600
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <5655C2AE.6040404@startmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
	<CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
	<CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>
	<CABeL=0hm=6S6YRQP45pNVv42b1kHZrH1TFuz3xguN+YNW5o=ww@mail.gmail.com>
	<CAAcC9yuUYx5o50ocTiFp2keYUuew8aT5fuCnx-huHUgeGK5r1g@mail.gmail.com>
	<5655C2AE.6040404@startmail.com>
Message-ID: <CALd2G5dYpf1pAM=8e+gnyT9j82qrKk-nhswGyk9HyysKtWkCmA@mail.gmail.com>

> Considering the website example, where most websites uses static
content, a bitcoin address could accumulate a dozen of transactions
before the webmaster changes the address to a new one.

Would this use case be a better match for something such as stealth
addresses or hierarchical deterministic addresses?

Trevin Hofmann
On Nov 25, 2015 8:16 AM, "Erik via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
>
>
> Nice idea. I see it as an important feature because of several reasons:
>
> Considering the website example, where most websites uses static
> content, a bitcoin address could accumulate a dozen of transactions
> before the webmaster changes the address to a new one.
>
> Also consider a QR-code address printed on paper. That address is also
> prone to multiple payments, which could be several small ones.
>
> You ask someone to pay an amount of BTC. That person would be someone
> that want you to actually don't get any money at all, so instead of
> sending one payment, the person sends a lot of small TXes. It costs a
> lot more to achieve this, but that doesn't bother the person sending the
> transactions. What you see is the transactions to the address you've
> agreed sum up to the amount you asked for. When you later try to spend
> it, you can't because of that the size of all UXTOs is too high to even
> overcome the tx fee.
>
> If you use a wildcard transaction to bake them together into one UXTO,
> you will not need to pay more than just one tx fee to solve the problem
> you've got. Also the network will benefit from this because the
> alternative is to not spend those UXTOs at all because it costs more
> than it earns, leaving lots of UXTOs in the databases.
>
> Some problems to consider is:
> * Which addresses should be involved in a wildcard TX.
> * How to not make it repeatable or delayed so that UXTOs not intended to
> be in that TX wouldn't be included.
> * How to make it impossible to sign an wildcard TX with a future date.
> * How to limit outputs so they not are in risk being double-spent.
> * How to guarantee that the output is actually calculated from all the
> inputs involved and not less, making insane TX fees available.
>
> I could see possible solutions to this problems:
> * Using the highest block height number of transactions to include or
> maybe better, the UXTO of one transaction destined to that address
> involved in that block - that implies collecting all UXTOs in that block.
> * Using a signature that includes the date. To let it be present more
> times in the blockchain requires another timestamp that is newer than a
> wildcard TX already existing in the blockchain. Also make the
> transaction invalid to put in a block if the timestamp is behind a
> certain time or in the future.
> * Using the coinbase UXTO or the block hash from the latest block as
> proof that the transaction isn't created earlier than that. Also makes
> the wildcard TX invalid if that block isn't part of the blockchain
> anymore. This also have a secondary effect of certifying the blockchain
> itself making it more difficult to fork it from far behind because it
> will effectively remove all transactions depending on a UXTO including
> this type of certification.
> * Either using a priority like way to determine what are being left to
> wildcard in a block - all transactions spending UXTOs of that address is
> removed before the wildcard TX if they occurs in the same block. Either
> it is possible to set a rule that if a wildcard TX exists in one block,
> it is invalid to include other UXTOs that is to be be included in the
> wildcard from the same address in the same block. (Classic
> double-spending rule)
> * Using a special form of output specifying only one destination
> address/script and the amount of fees to pay. If the amount of fees
> could be payed, then the rest will be sent to the destination address.
> This covers intentional delaying and also discourage forking the
> blockchain by miners to making the signature UXTO appear later than more
> recent transaction in a new fork to collect the later txes as fee.
>
> This transaction type would in fact look like a time-limited offer to
> the network to reduce the UXTO set of an address. I guess some miners
> will then use a logic that prefers this types of TXes even if they are
> low-fee because, if they removes lots of UXTOs, they benefits the network.
>
> Sincerely,
> Erik.
>
> Den 2015-11-25 kl. 02:26, skrev Chris Priest via bitcoin-dev:
> > 1. Technically is it promoting address reuse, but in this case, I
> > think it's OK. The primary purpose of a coalescing transaction is to
> > clear out *all* funds associated with one address and send them to
> > another address (belonging to the same owner). If you coalesce the
> > inputs to the same address over and over again, you an do that, but
> > you'll run the risk of leaking your private key.
> >
> > 2. I see these transactions being broadcast in the background when the
> > user is not planning on sending or receiving any payments. By the time
> > the wallet user wants to spend funds from the address, the coalescing
> > transaction should be sufficiently deep enough in the blockchain to
> > avoid re-org tomfoolery. Exchanges and payment processors who take in
> > payments around the clock will probably never use these transactions,
> > at least not on "live" addresses.
> >
> > 3. I never thought of that, but thats a benefit too!
> >
> > On 11/24/15, Jannes Faber via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> Few issues I can think of:
> >>
> >> 1. In its basic form this encourages address reuse. Unless the
> wildcard can
> >> be constructed such that it can match a whole branch of an HD  wallet.
> >> Although I guess that would tie all those addresses together making
> HD moot
> >> to begin with.
> >>
> >> 2. Sounds pretty dangerous during reorgs. Maybe such a transaction
> should
> >> include a block height which indicates the maximum block that any
> utxo can
> >> match. With the requirement that the specified block height is at
> least 100
> >> blocks in the past. Maybe add a minimum block height as well to prevent
> >> unnecessary scanning (with the requirement that at least one utxo must
> be
> >> in that minimum block).
> >>
> >> 3. Seems like a nice way to the reduce utxo set. But hard to say how
> >> effective it would really be.
> >> On 25 Nov 2015 12:48 a.m., "Chris Priest via bitcoin-dev" <
> >> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >>>> This idea could be applied by having the wildcard signature apply to
> >>>> all
> >>>> UTXOs that are of a standard form and paid to a particular address,
> and
> >>> be
> >>>> a signature of some kind of message to that effect.
> >>>
> >>> I think this is true. Not *all* transactions will be able to match the
> >>> wildcard. For instance if someone sent some crazy smart contract tx to
> >>> your address, the script associated with that tx will be such that it
> >>> will not apply to the wildcard. Most "vanilla" utxos that I've seen
> >>> have the formula: OP_DUP OP_HASH160 [a hash corresponding to your
> >>> address] OP_EQUALVERIFY OP_CHECKSIG". Just UTXOs in that form could
> >>> apply to the wildcard.
> >>>
> >>> On 11/24/15, Dave Scotese via bitcoin-dev
> >>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>> What is required to spend bitcoin is that input be provided to the
> UTXO
> >>>> script that causes it to return true.  What Chris is proposing breaks
> >>>> the
> >>>> programmatic nature of the requirement, replacing it with a
> requirement
> >>>> that the secret be known.  Granted, the secret is the only requirement
> >>>> in
> >>>> most cases, but there is no built-in assumption that the script always
> >>>> requires only that secret.
> >>>>
> >>>> This idea could be applied by having the wildcard signature apply to
> >>>> all
> >>>> UTXOs that are of a standard form and paid to a particular address,
> and
> >>> be
> >>>> a signature of some kind of message to that effect.  I imagine the
> cost
> >>> of
> >>>> re-scanning the UTXO set to find them all would justify a special
> extra
> >>>> mining fee for any transaction that used this opcode.
> >>>>
> >>>> Please be blunt about any of my own misunderstandings that this email
> >>> makes
> >>>> clear.
> >>>>
> >>>> On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
> >>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>
> >>>>> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
> >>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>>
> >>>>>> **OP_CHECKWILDCARDSIGVERIFY**
> >>>>>
> >>>>>
> >>>>> Some (minor) discussion of this idea in -wizards earlier today
> >>>>> starting
> >>>>> near near "09:50" (apologies for having no anchor links):
> >>>>> http://gnusha.org/bitcoin-wizards/2015-11-24.log
> >>>>>
> >>>>> - Bryan
> >>>>> http://heybryan.org/
> >>>>> 1 512 203 0507
> >>>>>
> >>>>> _______________________________________________
> >>>>> bitcoin-dev mailing list
> >>>>> bitcoin-dev at lists.linuxfoundation.org
> >>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>>>
> >>>>>
> >>>>
> >>>>
> >>>> --
> >>>> I like to provide some work at no charge to prove my value. Do you
> need
> >>>> a
> >>>> techie?
> >>>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> >>>> <http://www.memeracing.net> (in alpha).
> >>>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
> >>> which
> >>>> now accepts Bitcoin.
> >>>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> >>>> "He ought to find it more profitable to play by the rules" - Satoshi
> >>>> Nakamoto
> >>>>
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >>
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v2.0.22 (GNU/Linux)
>
> iQIcBAEBAgAGBQJWVcKuAAoJEJ51csApon2ofiYP/15DXthFvNg9pBPOaaboGOh1
> DhN7R3SXnt4PTLygQGO3AkTRcDinQrZ0Q4GDLIgrOkaKJ4yr6FtnoEYGORQSfFkx
> 946eWtqkR4+IJi7gYIIn1yOfFjWKUp9l4OOWBA8Rxsn0tZUAQPXzf2f+dxAaj0Gd
> fLrftYvK1XJ8BolhwNfonJ193RJGFynQfWqZ+XeQQMS5LW23RpQLyI26f495MPHG
> Wug7M/Aq50JrJDe1OyhjnnjYxNV6Gdbg9o3YIdj2gaOsBKHzsPK+LjcLCdRqD/OI
> TBwmwiI4vrOl3HzvtucHxQqnaP43wubydVhPfmjG97tDaj2cVLjadc17e77PzCVI
> 8N21oVIWDzyW6y14REoo1Zs4A9ALpHjXAGWdls71eP1NIFcfdFAJWhk2/giisw8o
> ZsQTgq2mUHS+n4q3NjFEwGxS011yADE3Uf3ryjuTjp3HVQf3lZxn4E4Z7z/4gkXm
> /h/3Ln7PkjEmOqp9htgHcYW7q5goeJzV0xNDBoY9wvOlJQcAh6nTiS4SJEiFJvXU
> xVZIGZsisrdW/1CfcszOi7KFGaaV1VlAXQnuJHj1I3dJ2r68yi5TQk6voMNFprEz
> 2R4zuZKjIoH79rOjDV8l6XBIU1Kh92GEzCFlTicfvnAoa853fGZt+V/77ralftJW
> E6sERK8uG8S3KdBSVQ7K
> =1xdi
> -----END PGP SIGNATURE-----
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/5e131aec/attachment-0001.html>

From dscotese at litmocracy.com  Wed Nov 25 17:03:32 2015
From: dscotese at litmocracy.com (Dave Scotese)
Date: Wed, 25 Nov 2015 09:03:32 -0800
Subject: [bitcoin-dev] OP_CHECKWILDCARDSIGVERIFY or "Wildcard Inputs" or
 "Coalescing Transactions"
In-Reply-To: <5655C2AE.6040404@startmail.com>
References: <CAAcC9yuM+dG+mJn_0vPqZuig5cHqeF-xgszw-zzD3D9UKRsyrQ@mail.gmail.com>
	<CABaSBaxKJjEd2e9hrnzyS57-YHspqCv9PiSH4XccqSZJMQG6qg@mail.gmail.com>
	<CAGLBAhd-6NbxppFdqNVSQ5ot_GX12eL8P2-qVe7_dZcUfHYv6w@mail.gmail.com>
	<CAAcC9yubb-Ajig+ZLrGVe3a7ON5MTzuLARP1_HCj2ngStJAGGg@mail.gmail.com>
	<CABeL=0hm=6S6YRQP45pNVv42b1kHZrH1TFuz3xguN+YNW5o=ww@mail.gmail.com>
	<CAAcC9yuUYx5o50ocTiFp2keYUuew8aT5fuCnx-huHUgeGK5r1g@mail.gmail.com>
	<5655C2AE.6040404@startmail.com>
Message-ID: <CAGLBAhdeejxXJqTFo5-Sch0dFbX8DNfsZ3eg7i80pDyH6juuHg@mail.gmail.com>

The message could specify:
{ stib: 0x01,
  TxnCount: (# of entries in the Indexes array)
  Indexes: [{BLK: Block#,Txns:[TxIndex,TxIndex,...]},{BLK:
Block#,Txns:[...]}],
  NewUTXO: (The script that will spend these coins)
}
*stib *is a Script Template Index Bitfield: Must (currently) be the byte
0x01, to indicate the "vanilla" script Chris identified.  If other scripts
appear to fit the bill in the future, they can be assigned to other bits.
*Indexes *is a list of pairs that identify a block by its height and a list
of indexes into the block.  This puts the onus on the transactor to
identify all the inputs instead of requiring the miner to scan for them.

If block heights and transaction indexes are 32-bit integers, this reduces
the per-input size cost by at least 100 bytes, if I did my math right.


On Wed, Nov 25, 2015 at 6:16 AM, Erik via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
>
>
> Nice idea. I see it as an important feature because of several reasons:
>
> Considering the website example, where most websites uses static
> content, a bitcoin address could accumulate a dozen of transactions
> before the webmaster changes the address to a new one.
>
> Also consider a QR-code address printed on paper. That address is also
> prone to multiple payments, which could be several small ones.
>
> You ask someone to pay an amount of BTC. That person would be someone
> that want you to actually don't get any money at all, so instead of
> sending one payment, the person sends a lot of small TXes. It costs a
> lot more to achieve this, but that doesn't bother the person sending the
> transactions. What you see is the transactions to the address you've
> agreed sum up to the amount you asked for. When you later try to spend
> it, you can't because of that the size of all UXTOs is too high to even
> overcome the tx fee.
>
> If you use a wildcard transaction to bake them together into one UXTO,
> you will not need to pay more than just one tx fee to solve the problem
> you've got. Also the network will benefit from this because the
> alternative is to not spend those UXTOs at all because it costs more
> than it earns, leaving lots of UXTOs in the databases.
>
> Some problems to consider is:
> * Which addresses should be involved in a wildcard TX.
> * How to not make it repeatable or delayed so that UXTOs not intended to
> be in that TX wouldn't be included.
> * How to make it impossible to sign an wildcard TX with a future date.
> * How to limit outputs so they not are in risk being double-spent.
> * How to guarantee that the output is actually calculated from all the
> inputs involved and not less, making insane TX fees available.
>
> I could see possible solutions to this problems:
> * Using the highest block height number of transactions to include or
> maybe better, the UXTO of one transaction destined to that address
> involved in that block - that implies collecting all UXTOs in that block.
> * Using a signature that includes the date. To let it be present more
> times in the blockchain requires another timestamp that is newer than a
> wildcard TX already existing in the blockchain. Also make the
> transaction invalid to put in a block if the timestamp is behind a
> certain time or in the future.
> * Using the coinbase UXTO or the block hash from the latest block as
> proof that the transaction isn't created earlier than that. Also makes
> the wildcard TX invalid if that block isn't part of the blockchain
> anymore. This also have a secondary effect of certifying the blockchain
> itself making it more difficult to fork it from far behind because it
> will effectively remove all transactions depending on a UXTO including
> this type of certification.
> * Either using a priority like way to determine what are being left to
> wildcard in a block - all transactions spending UXTOs of that address is
> removed before the wildcard TX if they occurs in the same block. Either
> it is possible to set a rule that if a wildcard TX exists in one block,
> it is invalid to include other UXTOs that is to be be included in the
> wildcard from the same address in the same block. (Classic
> double-spending rule)
> * Using a special form of output specifying only one destination
> address/script and the amount of fees to pay. If the amount of fees
> could be payed, then the rest will be sent to the destination address.
> This covers intentional delaying and also discourage forking the
> blockchain by miners to making the signature UXTO appear later than more
> recent transaction in a new fork to collect the later txes as fee.
>
> This transaction type would in fact look like a time-limited offer to
> the network to reduce the UXTO set of an address. I guess some miners
> will then use a logic that prefers this types of TXes even if they are
> low-fee because, if they removes lots of UXTOs, they benefits the network.
>
> Sincerely,
> Erik.
>
> Den 2015-11-25 kl. 02:26, skrev Chris Priest via bitcoin-dev:
> > 1. Technically is it promoting address reuse, but in this case, I
> > think it's OK. The primary purpose of a coalescing transaction is to
> > clear out *all* funds associated with one address and send them to
> > another address (belonging to the same owner). If you coalesce the
> > inputs to the same address over and over again, you an do that, but
> > you'll run the risk of leaking your private key.
> >
> > 2. I see these transactions being broadcast in the background when the
> > user is not planning on sending or receiving any payments. By the time
> > the wallet user wants to spend funds from the address, the coalescing
> > transaction should be sufficiently deep enough in the blockchain to
> > avoid re-org tomfoolery. Exchanges and payment processors who take in
> > payments around the clock will probably never use these transactions,
> > at least not on "live" addresses.
> >
> > 3. I never thought of that, but thats a benefit too!
> >
> > On 11/24/15, Jannes Faber via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> Few issues I can think of:
> >>
> >> 1. In its basic form this encourages address reuse. Unless the
> wildcard can
> >> be constructed such that it can match a whole branch of an HD  wallet.
> >> Although I guess that would tie all those addresses together making
> HD moot
> >> to begin with.
> >>
> >> 2. Sounds pretty dangerous during reorgs. Maybe such a transaction
> should
> >> include a block height which indicates the maximum block that any
> utxo can
> >> match. With the requirement that the specified block height is at
> least 100
> >> blocks in the past. Maybe add a minimum block height as well to prevent
> >> unnecessary scanning (with the requirement that at least one utxo must
> be
> >> in that minimum block).
> >>
> >> 3. Seems like a nice way to the reduce utxo set. But hard to say how
> >> effective it would really be.
> >> On 25 Nov 2015 12:48 a.m., "Chris Priest via bitcoin-dev" <
> >> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >>>> This idea could be applied by having the wildcard signature apply to
> >>>> all
> >>>> UTXOs that are of a standard form and paid to a particular address,
> and
> >>> be
> >>>> a signature of some kind of message to that effect.
> >>>
> >>> I think this is true. Not *all* transactions will be able to match the
> >>> wildcard. For instance if someone sent some crazy smart contract tx to
> >>> your address, the script associated with that tx will be such that it
> >>> will not apply to the wildcard. Most "vanilla" utxos that I've seen
> >>> have the formula: OP_DUP OP_HASH160 [a hash corresponding to your
> >>> address] OP_EQUALVERIFY OP_CHECKSIG". Just UTXOs in that form could
> >>> apply to the wildcard.
> >>>
> >>> On 11/24/15, Dave Scotese via bitcoin-dev
> >>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>> What is required to spend bitcoin is that input be provided to the
> UTXO
> >>>> script that causes it to return true.  What Chris is proposing breaks
> >>>> the
> >>>> programmatic nature of the requirement, replacing it with a
> requirement
> >>>> that the secret be known.  Granted, the secret is the only requirement
> >>>> in
> >>>> most cases, but there is no built-in assumption that the script always
> >>>> requires only that secret.
> >>>>
> >>>> This idea could be applied by having the wildcard signature apply to
> >>>> all
> >>>> UTXOs that are of a standard form and paid to a particular address,
> and
> >>> be
> >>>> a signature of some kind of message to that effect.  I imagine the
> cost
> >>> of
> >>>> re-scanning the UTXO set to find them all would justify a special
> extra
> >>>> mining fee for any transaction that used this opcode.
> >>>>
> >>>> Please be blunt about any of my own misunderstandings that this email
> >>> makes
> >>>> clear.
> >>>>
> >>>> On Tue, Nov 24, 2015 at 1:51 PM, Bryan Bishop via bitcoin-dev <
> >>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>
> >>>>> On Tue, Nov 24, 2015 at 11:34 AM, Chris Priest via bitcoin-dev <
> >>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>>
> >>>>>> **OP_CHECKWILDCARDSIGVERIFY**
> >>>>>
> >>>>>
> >>>>> Some (minor) discussion of this idea in -wizards earlier today
> >>>>> starting
> >>>>> near near "09:50" (apologies for having no anchor links):
> >>>>> http://gnusha.org/bitcoin-wizards/2015-11-24.log
> >>>>>
> >>>>> - Bryan
> >>>>> http://heybryan.org/
> >>>>> 1 512 203 0507
> >>>>>
> >>>>> _______________________________________________
> >>>>> bitcoin-dev mailing list
> >>>>> bitcoin-dev at lists.linuxfoundation.org
> >>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>>>
> >>>>>
> >>>>
> >>>>
> >>>> --
> >>>> I like to provide some work at no charge to prove my value. Do you
> need
> >>>> a
> >>>> techie?
> >>>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> >>>> <http://www.memeracing.net> (in alpha).
> >>>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
> >>> which
> >>>> now accepts Bitcoin.
> >>>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> >>>> "He ought to find it more profitable to play by the rules" - Satoshi
> >>>> Nakamoto
> >>>>
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>
> >>
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v2.0.22 (GNU/Linux)
>
> iQIcBAEBAgAGBQJWVcKuAAoJEJ51csApon2ofiYP/15DXthFvNg9pBPOaaboGOh1
> DhN7R3SXnt4PTLygQGO3AkTRcDinQrZ0Q4GDLIgrOkaKJ4yr6FtnoEYGORQSfFkx
> 946eWtqkR4+IJi7gYIIn1yOfFjWKUp9l4OOWBA8Rxsn0tZUAQPXzf2f+dxAaj0Gd
> fLrftYvK1XJ8BolhwNfonJ193RJGFynQfWqZ+XeQQMS5LW23RpQLyI26f495MPHG
> Wug7M/Aq50JrJDe1OyhjnnjYxNV6Gdbg9o3YIdj2gaOsBKHzsPK+LjcLCdRqD/OI
> TBwmwiI4vrOl3HzvtucHxQqnaP43wubydVhPfmjG97tDaj2cVLjadc17e77PzCVI
> 8N21oVIWDzyW6y14REoo1Zs4A9ALpHjXAGWdls71eP1NIFcfdFAJWhk2/giisw8o
> ZsQTgq2mUHS+n4q3NjFEwGxS011yADE3Uf3ryjuTjp3HVQf3lZxn4E4Z7z/4gkXm
> /h/3Ln7PkjEmOqp9htgHcYW7q5goeJzV0xNDBoY9wvOlJQcAh6nTiS4SJEiFJvXU
> xVZIGZsisrdW/1CfcszOi7KFGaaV1VlAXQnuJHj1I3dJ2r68yi5TQk6voMNFprEz
> 2R4zuZKjIoH79rOjDV8l6XBIU1Kh92GEzCFlTicfvnAoa853fGZt+V/77ralftJW
> E6sERK8uG8S3KdBSVQ7K
> =1xdi
> -----END PGP SIGNATURE-----
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/b0a18f46/attachment-0001.html>

From pete at petertodd.org  Wed Nov 25 21:37:47 2015
From: pete at petertodd.org (Peter Todd)
Date: Wed, 25 Nov 2015 16:37:47 -0500
Subject: [bitcoin-dev] Why sharding the blockchain is difficult
Message-ID: <20151125213746.GD20655@savin.petertodd.org>

https://www.reddit.com/r/Bitcoin/comments/3u1m36/why_arent_we_as_a_community_talking_about/cxbamhn?context=3

The following was originally posted to reddit; I was asked to repost it here:

In a system where everyone mostly trusts each other, sharding works great! You
just split up the blockchain the same way you'd shard a database, assigning
miners/validators a subset of the txid space. Transaction validation would
assume that if you don't have the history for an input yourself, you assume
that history is valid. In a banking-like environment where there's a way to
conduct audits and punish those who lie, this could certainly be made to work.
(I myself have worked on and off on a scheme to do exactly that for a few
different clients: [Proofchains](https://github.com/proofchains))

But in a decentralized environment sharding is far, far, harder to
accomplish... There's an old idea we've been calling "fraud proofs", where you
design a system where for every way validation can fail, you can create a short
proof that part of the blockchain was invalid. Upon receiving that proof your
node would reject the invalid part of the chain and roll back the chain. In
fact, the original Satoshi whitepaper refers to fraud proofs, using the term
"alerts", and assumed SPV nodes would use them to get better guarantees they're
using a valid chain. (SPV as implemented by bitcoinj is sometimes referred to
as "non-validating SPV") The problem is, how do you guarantee that the fraud
will get detected? And How do you guarantee that fraud that is detected
actually gets propagated around the network? And if all that fails... then
what?

The nightmare scenario in that kind of system is some miner successfully gets
away with fraud for awhile, possibly creating hundreds of millions of dollars
worth of bitcoins out of thin air. Those fake coins could easily "taint" a
significant fraction of the economy, making rollback impossible and shaking
faith in the value of the currency. Right now in Bitcoin this is pretty much
impossible because everyone can run a full node to validate the chain for
themselves, but in a sharded system that's far harder to guarantee.

Now, suppose we *can* guarantee validity. zk-SNARKS are basically a way of
mathematically proving that you ran a certain computer program on some data,
and that program returned true. *Recursive* zk-SNARKS are simply zk-SNARKS
where the program can also recursively evaluate that another zk-SNARK is true.
With this technology a miner could *prove* that the shard they're working on is
valid, solving the problem of fake coins. Unfortunately, zk-SNARKS are bleeding
edge crypto, (if zerocoin had been deployed a the entire system would have been
destroyed by a recently found bug that allowed fake proofs to be created) and
recursive zk-SNARKS don't exist yet.

The closest thing I know of to recrusive zk-SNARKS that actually does work
without "moon-math" is an idea I came up with for treechains called coin
history linearization. Basically, if you allow transactions to have multiple
inputs and outputs, proving that a given coin is valid requires the entire coin
history, which has quasi-exponential scaling - in the Bitcoin economy coins are
very quickly mixed such that all coins have pretty much all other coins in
their history.

Now suppose that rather than proving that all inputs are valid for a
transaction, what if you only had to prove that *one* was valid? This would
linearize the coin history as you only have to prove a single branch of the
transaction DAG, resulting in O(n) scaling. (with n <= total length of the
blockchain chain)

Let's assume Alice is trying to pay Bob with a transaction with two inputs each
of equal value. For each input she irrevocable records it as spent, permanently
committing that input's funds to Bob. (e.g. in an irrevocable ledger!) Next she
makes use of a random beacon - a source of publicly known random numbers that
no-one can influence - to chose which of the two inputs' coin history's she'll
give to Bob as proof that the transaction is real. (both the irrevocable ledger
and random beacon can be implemented with treechains, for example)

If Alice is being honest and both inputs are real, there's a 100% chance that
she'll be able to successfully convince Bob that the funds are real. Similarly,
if Alice is dishonest and neither input is real, it'll be impossible for her
convince prove to Bob that the funds are real.

But what if one of the two inputs is real and the other is actually fake? Half
the time the transaction will succeed - the random beacon will select the real
input and Bob won't know that the other input is fake. However, half the time
the *fake* input will be selected, and Alice won't be able to prove anything.
Yet, the real input has irrevocably been spent anyway, destroying the funds! If
the process by which funds are spent really is irrevocable, and Alice has
absolutely no way to influence the random beacon, the two cases cancel out.
While she can get away with fraud, there's no economic benefit for her to do
so. On a macro level, this means that fraud won't result in inflation of the
currency. (in fact, we want a system that institutionalizes this so-called
"fraud" - creating false proofs is a great way to make your coins more private)
(FWIW the way zk-SNARKS actually work is similar to this simple linearization
scheme, but with a lot of very clever error correction math, and the hash of
the data itself as the random beacon)

An actual implementation would be extended to handle multiple transaction
inputs of different sizes by weighing the probability that an input will be
selected by it's value - merkle-sum-trees work well for this. We still have the
problem that O(n) scaling kinda sucks; can we do better?

Yes! Remember that a genesis transaction output has no history - the coins are
created out of thin air and its validity is proven by the proof of work itself.
So every time you make a transaction that spends a genesis output you have a
chance of reducing the length of the coin validity proof back to zero. Better
yet, we can design a system where every transaction is associated with a bit of
proof-of-work, and thus every transaction has a chance of resetting the length
of the validity proof back to zero. In such a system you might do the PoW on a
per-transaction basis; you could outsource the task to miners with a special
output that only the miner can spend. Now we have O(1) scaling, with a k that
depends on the inflation rate. I'd have to dig up the calculations again, but
IIRC I sketched out a design for the above that resulted in something like 10MB
or 100MB coin validity proofs, assuming 1% inflation a year. (equally you can
describe that 1% inflation as a coin security tax) Certainly not small, but
compared to running a full node right now that's still a *huge* reduction in
storage space. (recursive zk-SNARKS might reduce that proof to something like
1kB of data)

Regardless of whether you have lightweight zk-SNARKS, heavyweight linearized
coin history proofs, or something else entirely, the key advantage is that
validation can become entirely client side. Miners don't even need to care
whether or not their *own* blocks are "valid", let alone other miners' blocks.
Invalid transactions in the chain are just garbage data, which gets rejected by
wallet software as invalid. So long as the protocol itself  works and is
implemented correctly it's impossible for fraud to go undetected and destroy
the economy the way it can in a sharded system.

However we still have a problem: censorship. This one is pretty subtle, and
gets to the heart of how these systems actually work. How do you prove that a
coin has validly been spent? First, prove that it hasn't already been spent!
How do you do that if you don't have the blockchain data? You can't, and no
amount of fancy math can change that.

In Bitcoin if everyone runs full nodes censorship can't happen: you either have
the full blockchain and thus can spend your money and help mine new blocks, or
that alternate fork might as well not exist. SPV breaks this as it allows funds
to be spent without also having the ability to mine - with SPV a cartel of
miners can prevent anyone else from getting access to the blockchain data
required to mine, while still allowing commerce to happen. In reality, this
type of cartel would be more subtle, and can even happen by accident; just
delaying other miners getting blockchain data by a few seconds harms those
non-cartel miners' profitability, without being obvious censorship. Equally, so
long as the cartel has [>30% of hashing power it's profitable in the long run
for the cartel if this
happens](http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03200.html).

In sharded systems the "full node defense" doesn't work, at least directly. The
whole point is that not everyone has all the data, so you have to decide what
happens when it's not available.

Altcoins provide one model, albeit a pretty terrible one: taken as a whole you
can imagine the entire space of altcoins as a series of cryptocurrency shards
for moving funds around. The problem is each individual shard - each altcoin -
is weak and can be 51% attacked. Since they can be attacked so easily, if you
designed a system where funds could be moved from one shard to another through
coin history proofs every time a chain was 51% attacked and reorged you'd be
creating coins out of thin air, destroying digital scarcity and risking the
whole economy with uncontrolled inflation. You can instead design a system
where coins can't move between shards - basically what the altcoin space looks
like now - but that means actually paying someone on another "shard" requires
you to sell your coins and buy their coins - a inefficient and expensive
logistical headache. (there's a reason the Eurozone was created!)

If you want to transfer value between shards with coin history proofs, without
risking inflation, you need all the shards to share some type of global
consensus. This is the idea behind treechains: every part of the tree is linked
to a top-level timestamp chain, which means we have global consensus on the
contents of all chains, and thus spending a coin really is an immutable
one-time act.

Let's go into a bit more detail. So what is a coin in a treechains system?
First and foremost it's a *starting point* in some part of the tree, a specific
subchain. When Alice wants to prove to Bob that she spent a coin, giving it to
Bob, she inserts into that subchain the data that proves that someone *could
have* spent that coin - a valid signature and the hash of the transaction
output it was spending. But the actual proof that she gives to Bob isn't just
that spend data, but rather proof that all the blocks in that chain between the
starting point and the spend did *not* have a valid spend in them. (easiest way
to do that? give Bob those blocks) That proof must link back to the top-level
chain; if it doesn't the proof is simply not valid.

Now suppose Alice can't get that part of the subchain, perhaps because a cartel
of miners is mining it and won't give anyone else the data, or perhaps because
everyone with the data suffered a simultaneous harddrive crash. We'll also say
that higher up in the tree the data is available, at minimum the top-level
chain. As with Bitcoin, as long as that cartel has 51% of the hashing power,
Alice is screwed and can't spend her money.

What's interesting is what happens after that cartel disbands: how does mining
restart? It's easy to design a system where the creation of a block doesn't
require the knowledge of previous blocks, so new blocks can be added to extend
the subchain. But Alice is still screwed: she can't prove to Bob that the
missing blocks in the subchain didn't contain a valid spend of her coin. This
is pretty bad, on the other hand the damage is limited to just that one
subchain, and the system as a whole is unaffected.

There's a tricky incentives problem here though: if a miner can extend a
subchain without actually having previous blocks in that chain, where's the
incentive for that miner to give anyone else the blocks they create? Remember
that exclusive knowledge of a block is potentially valuable if you can extort
coin owners for it. (Bitcoin suffers from this problem right now with
validationless "SPV" mining, though the fact that a block can be invalid in
Bitcoin helps limit its effects)

Part of the solution could be mining reward; in Bitcoin, coinbase outputs can't
be spent for 100 blocks. A similar scheme could require that a spend of a
coinbase output in a subchain include proof that the next X blocks in that
subchain were in fact linked together. Secondly make block creation dependent
on actually having that data to ensure the linkage actually means something,
e.g. by introducing some validity rules so blocks can be invalid, and/or using
a PoW function that requires hashers to have a copy of that data.

Ultimately though this isn't magic: like it or not lower subchains in such a
system are inherently weaker and more dangerous than higher ones, and this is
equally true of any sharded system. However a hierarchically sharded system
like treechains can give users options: higher subchains are safer, but
transactions will expensive. The hierarchy does combine the PoW security of all
subchains together for the thing you can easily combine: timestamping security.

There's a big problem though: holy !@#$ is the above complex compared to
Bitcoin! Even the "kiddy" version of sharding - my linearization scheme rather
than zk-SNARKS - is probably one or two orders of magnitude more complex than
using the Bitcoin protocol is right now, yet right now a huge % of the
companies in this space seem to have thrown their hands up and used centralized
API providers instead. Actually implementing the above and getting it into the
hands of end-users won't be easy.

On the other hand, decentralization isn't cheap: using PayPal is one or two
orders of magnitude simpler than the Bitcoin protocol.

-- 
'peter'[:-1]@petertodd.org
0000000000000000061df93abb76cdc4b1617bb097b4cab90f3f1ca5ae0a0df5
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/7a241e01/attachment.sig>

From mark at friedenbach.org  Wed Nov 25 23:05:50 2015
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 25 Nov 2015 15:05:50 -0800
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
References: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
Message-ID: <CAOG=w-v0_dfZS2=XfKQzRZ9Vq2Z2YqUO2_cuvOheuUrD4dbYtw@mail.gmail.com>

Looks like I'm the long dissenting voice here? As the originator of the
name CHECKSEQUENCEVERIFY, perhaps I can explain why the name was
appropriately chosen and why the proposed alternatives don't stand up.

First, the names are purposefully chosen to illustrate what they do:

What does CHECKLOCKTIMEVERIFY do? It verifies the range of tx.nLockTime.
What does CHECKSEQUENCEVERIFY do? It verifies the range of txin.nSequence.

Second, the semantics are not limited to relative lock-time / maturity
only. They both leave open ranges with possible, but currently undefined
future consensus-enforced behavior. We don't know what sort of future
behavior these values might trigger, but the associated opcodes are generic
enough to handle them:

CHECKLOCKTIMEVERIFY will pass an nSequence between 1985 and 2009, even
though such constraints have no meaning in Bitcoin.
CHECKSEQUENCEVERIFY is explicitly written to permit a 5-byte push operand,
while checking only 17 of the available 39 bits of both the operand and the
nSequence. Indeed the most recent semantic change of CSV was justified in
part because it relaxes all constraints over the values of these bits
freeing them for other purposes in transaction validation and/or future
extensions of the opcode semantics.

Third, single-byte opcode space is limited. There are less than 10 such
opcodes left. Maybe space won't be so precious in a post-segwitness world,
but I don't want to presume that just yet.


As for the alternatives, they capture only the initial use case of
nSequence. My objection would relax if nSequence were renamed, but I think
that would be too disruptive and unnecessary. In any case, the imagined use
cases for CHECKSEQUENCEVERIFY has to do with sequencing execution pathways
of script, so it's not a stretch in meaning. Previously CHECKMATURITYVERIFY
was a hypothicated opcode that directly checked the minimum age of inputs
of a transaction. The indirect naming of CHECKSEQUENCEVERIFY on the other
hand is due to its indirect behavior. RELATIVELOCKTIMEVERIFY was also a
hypothicated opcode that would check a ficticious nRelativeLockTime field,
which does not exist. Again my objection would go away if we renamed
nSequence, but I actually think the nSequence name is better...

On Tue, Nov 24, 2015 at 2:30 AM, Btc Drak via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> BIP68 introduces relative lock-time semantics to part of the nSequence
> field leaving the majority of bits undefined for other future applications.
>
> BIP112 introduces opcode CHECKSEQUENCEVERIFY (OP_CSV) that is specifically
> limited to verifying transaction inputs according to BIP68's relative
> lock-time[1], yet the _name_ OP_CSV is much boarder than that. We spent
> months limiting the number of bits used in BIP68 so they would be available
> for future use cases, thus we have acknowledged there will be completely
> different usecases that take advantage of unused nSequence bits.
>
> For this reason I believe the BIP112 should be renamed specifically for
> it's usecase, which is verifying the time/maturity of transaction inputs
> relative to their inclusion in a block.
>
> Suggestions:-
>
> CHECKMATURITYVERIFY
> RELATIVELOCKTIMEVERIFY
> RCHECKLOCKTIMEVERIFY
> RCLTV
>
> We could of course softfork additional meaning into OP_CSV each time we
> add new sequence number usecases, but that would become obscure and
> confusing. We have already shown there is no shortage of opcodes so it
> makes no sense to cram everything into one generic opcode.
>
> TL;DR: let's give BIP112 opcode a name that reflects it's actual usecase
> rather than focusing on the bitcoin internals.
>
> [1]
> https://github.com/bitcoin/bitcoin/pull/6564/files#diff-be2905e2f5218ecdbe4e55637dac75f3R1223
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/25ab2f56/attachment-0001.html>

From elombrozo at gmail.com  Wed Nov 25 23:41:03 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Wed, 25 Nov 2015 23:41:03 +0000
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CAOG=w-v0_dfZS2=XfKQzRZ9Vq2Z2YqUO2_cuvOheuUrD4dbYtw@mail.gmail.com>
Message-ID: <eme59eddfb-c410-4af4-b496-e3301ac9db85@platinum>

As I said in an earlier post, a systems developer and an application 
developer have very different perspectives on this. From the former's 
perspective, it is entirely sensible to name things based on basic 
features of the system's design (i.e. a field in the txin or tx that 
gets checked) - but from an app developer's perspective, what matters is 
how they will use a particular feature in an actual app.

I think that part of what systems developers should strive to do is to 
abstract out the inner minutiae of the system's guts and expose to app 
developers the clearest interface with which to develop apps. This is 
even more the case when the details of the inner workings are completely 
irrelevant to the application logic and there's no real gains to be had 
from attempting to optimize for the inner workings when designing an 
application.

>From an app developer's perspective, I think it is pretty blatantly 
clear that relative timelock is *the* critical exposed functionality 
intended here. Now, one could argue that the satoshi script is still a 
systems level component of the system...but with the advent of overlay 
protocols such as payment channels and the Lightning Network, it is 
clear that we now require a new abstraction layer for reasoning about 
the higher level logic of the system that doesn't burden the protocol 
designer with having to know the intimate and esoteric details of the 
lower system levels. Of course, many of those who work on these higher 
level protocols will also be experts in the underlying system design. 
However, it greatly increases the learning curve and can easily 
frustrate people looking to work on these ideas...and ultimately, 
knowing the inner details of how the nSequence field is structured and 
what the bits actually mean is irrelevant to someone trying to design 
scripts for such applications.

We've already deployed another opcode, CHECKLOCKTIMEVERIFY, which does 
refer to the field name. However, in this particular situation, the 
field name reflects *far* more closely what the app developer actually 
cares about than nSequence, which to the app developer might as well be 
called foo. As such, I stick with my original vote - we should call the 
opcode RCHECKLOCKTIMEVERIFY, which has the advantage of communicating 
fairly directly to developers and protocol designers the semantics they 
actually care about and also makes clear the relationship between 
absolute and relative timelock...that's to say, the ability for the 
script designer to lock specific coins until either a specific moment in 
time or until a certain delay has passed since the coin output was 
created (added to blockchain).

Let's face it - the entire motivation behind BIP68/BIP112 is relative 
timelock. Explicitly calling the opcode RCHECKLOCKTIMEVERIFY will make 
life easier for everyone and will help sell the idea and help it gain 
greater acceptance more quickly; while stubbornly adhering to an 
esoteric detail that is only there for historical reasons will only 
continue to delay the idea's acceptance and adoptance.

- Eric

------ Original Message ------
From: "Mark Friedenbach via bitcoin-dev" 
<bitcoin-dev at lists.linuxfoundation.org>
To: "Btc Drak" <btcdrak at gmail.com>
Cc: "Bitcoin Dev" <bitcoin-dev at lists.linuxfoundation.org>
Sent: 11/25/2015 3:05:50 PM
Subject: Re: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY 
(BIP112)

>Looks like I'm the long dissenting voice here? As the originator of the 
>name CHECKSEQUENCEVERIFY, perhaps I can explain why the name was 
>appropriately chosen and why the proposed alternatives don't stand up.
>
>First, the names are purposefully chosen to illustrate what they do:
>
>What does CHECKLOCKTIMEVERIFY do? It verifies the range of 
>tx.nLockTime.
>What does CHECKSEQUENCEVERIFY do? It verifies the range of 
>txin.nSequence.
>
>Second, the semantics are not limited to relative lock-time / maturity 
>only. They both leave open ranges with possible, but currently 
>undefined future consensus-enforced behavior. We don't know what sort 
>of future behavior these values might trigger, but the associated 
>opcodes are generic enough to handle them:
>
>CHECKLOCKTIMEVERIFY will pass an nSequence between 1985 and 2009, even 
>though such constraints have no meaning in Bitcoin.
>CHECKSEQUENCEVERIFY is explicitly written to permit a 5-byte push 
>operand, while checking only 17 of the available 39 bits of both the 
>operand and the nSequence. Indeed the most recent semantic change of 
>CSV was justified in part because it relaxes all constraints over the 
>values of these bits freeing them for other purposes in transaction 
>validation and/or future extensions of the opcode semantics.
>
>Third, single-byte opcode space is limited. There are less than 10 such 
>opcodes left. Maybe space won't be so precious in a post-segwitness 
>world, but I don't want to presume that just yet.
>
>
>As for the alternatives, they capture only the initial use case of 
>nSequence. My objection would relax if nSequence were renamed, but I 
>think that would be too disruptive and unnecessary. In any case, the 
>imagined use cases for CHECKSEQUENCEVERIFY has to do with sequencing 
>execution pathways of script, so it's not a stretch in meaning. 
>Previously CHECKMATURITYVERIFY was a hypothicated opcode that directly 
>checked the minimum age of inputs of a transaction. The indirect naming 
>of CHECKSEQUENCEVERIFY on the other hand is due to its indirect 
>behavior. RELATIVELOCKTIMEVERIFY was also a hypothicated opcode that 
>would check a ficticious nRelativeLockTime field, which does not exist. 
>Again my objection would go away if we renamed nSequence, but I 
>actually think the nSequence name is better...
>
>On Tue, Nov 24, 2015 at 2:30 AM, Btc Drak via bitcoin-dev 
><bitcoin-dev at lists.linuxfoundation.org> wrote:
>>BIP68 introduces relative lock-time semantics to part of the nSequence 
>>field leaving the majority of bits undefined for other future 
>>applications.
>>
>>BIP112 introduces opcode CHECKSEQUENCEVERIFY (OP_CSV) that is 
>>specifically limited to verifying transaction inputs according to 
>>BIP68's relative lock-time[1], yet the _name_ OP_CSV is much boarder 
>>than that. We spent months limiting the number of bits used in BIP68 
>>so they would be available for future use cases, thus we have 
>>acknowledged there will be completely different usecases that take 
>>advantage of unused nSequence bits.
>>
>>For this reason I believe the BIP112 should be renamed specifically 
>>for it's usecase, which is verifying the time/maturity of transaction 
>>inputs relative to their inclusion in a block.
>>
>>Suggestions:-
>>
>>CHECKMATURITYVERIFY
>>RELATIVELOCKTIMEVERIFY
>>RCHECKLOCKTIMEVERIFY
>>RCLTV
>>
>>We could of course softfork additional meaning into OP_CSV each time 
>>we add new sequence number usecases, but that would become obscure and 
>>confusing. We have already shown there is no shortage of opcodes so it 
>>makes no sense to cram everything into one generic opcode.
>>
>>TL;DR: let's give BIP112 opcode a name that reflects it's actual 
>>usecase rather than focusing on the bitcoin internals.
>>
>>[1] 
>>https://github.com/bitcoin/bitcoin/pull/6564/files#diff-be2905e2f5218ecdbe4e55637dac75f3R1223
>>
>>_______________________________________________
>>bitcoin-dev mailing list
>>bitcoin-dev at lists.linuxfoundation.org
>>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151125/180fa442/attachment.html>

From elombrozo at gmail.com  Thu Nov 26 21:32:58 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Thu, 26 Nov 2015 13:32:58 -0800
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <em80f319b9-ff7c-4a88-85c7-efdb0333ada1@platinum>
References: <em80f319b9-ff7c-4a88-85c7-efdb0333ada1@platinum>
Message-ID: <523E7E80-A958-4333-96FB-1E0D36BB128F@gmail.com>

After a little more though (and some comments from aj), I realize that the opcode naming convention is actually CHECK <condition > VERIFY.

Therefore, the full opcode name should be CHECKRELATIVELOCKTIMEVERIFY.

However, this name is ridiculously long, so at least some part will require abbreviation.

In typical script example usage, most sensible seems to be to abbreviate both CLTV and CRLTV.

- Eric

On November 24, 2015 5:14:55 PM PST, Eric Lombrozo <elombrozo at gmail.com> wrote:
>From a system developer standpoint, CHECKMATURITYVERIFY ties together 
>the semantics of this opcode with another existing feature in the
>system 
>(coinbase maturity).
>
>HOWEVER...
>
>from an application developer standpoint, I think the concept of a 
>timelock is more relevant. Maturity is a concept that was introduced
>for 
>the sake of reducing the disruptive impact of reorgs. Miners would 
>prefer to be able to spend the coins immediately, but instead they are 
>forced to wait due to inherent limitations of the system. Timelocks, on
>
>the other hand, are typically used to control when funds can be moved. 
>In these use cases, one or more of the parties involved explicitly want
>
>there to be a delay even if there were an idealized situation in which 
>consensus is always reached instantaneously and there were never any 
>reorgs.
>
>Moreover, since we already have CLTV, adding RCLTV or some variant 
>thereof makes the relationship between the two more explicit.
>
>So my vote goes to RCLTV or RCHECKLOCKTIMEVERIFY.
>
>As for whether to explicitly use CHECK_..._VERIFY, consider that with 
>segregated witness it will be possible to add opcodes that can push 
>values onto the stack (rather than just hard failing or NOP), so
>there's 
>something to be said for naming consistency.
>
>- Eric
>
>
>
>------ Original Message ------
>From: "Jorge Tim?n" <bitcoin-dev at lists.linuxfoundation.org>
>To: "Btc Drak" <btcdrak at gmail.com>
>Cc: "Bitcoin Dev" <bitcoin-dev at lists.linuxfoundation.org>
>Sent: 11/24/2015 4:31:55 AM
>Subject: Re: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY 
>(BIP112)
>
>>I agree, I believe the first name that an op with equivalent 
>>functionality had was simply op_maturity.
>>At least I remember we discussed such an opcode when discussing pegged
>
>>sidechains' design.
>>
>>I kind of dislike the check_x_verify naming pattern. We want all new 
>>operands to return if whatever they're checking/verifying fails, fine.
>
>>Do we have to repeat this redundant naming pattern forever due to that
>
>>discovery?
>>I hope not, but if that's the case my vote is for CMV.
>>As said before, I believe the documentation and code comments can 
>>become much more clear with this change.
>>

-- 
Sent from my Android device with K-9 Mail. Please excuse my brevity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151126/6326f2b7/attachment.html>

From lf-lists at mattcorallo.com  Thu Nov 26 22:23:38 2015
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 26 Nov 2015 22:23:38 +0000
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <eme59eddfb-c410-4af4-b496-e3301ac9db85@platinum>
References: <eme59eddfb-c410-4af4-b496-e3301ac9db85@platinum>
Message-ID: <507FBD75-6A20-4057-A280-FA0E0A6C5689@mattcorallo.com>

Actually, with this argument I think CHECKSEQUENCEVERIFY is more appropriate. To an app developer, you're enforcing maturity by enforcing sequence. I think it's much more clear to app devs to say sequence here since it makes explicit how to create the transaction which passes the check, whereas saying maturity night be confusing.

On November 25, 2015 6:41:03 PM EST, Eric Lombrozo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>As I said in an earlier post, a systems developer and an application 
>developer have very different perspectives on this. From the former's 
>perspective, it is entirely sensible to name things based on basic 
>features of the system's design (i.e. a field in the txin or tx that 
>gets checked) - but from an app developer's perspective, what matters
>is 
>how they will use a particular feature in an actual app.
>
>I think that part of what systems developers should strive to do is to 
>abstract out the inner minutiae of the system's guts and expose to app 
>developers the clearest interface with which to develop apps. This is 
>even more the case when the details of the inner workings are
>completely 
>irrelevant to the application logic and there's no real gains to be had
>
>from attempting to optimize for the inner workings when designing an 
>application.
>
>From an app developer's perspective, I think it is pretty blatantly 
>clear that relative timelock is *the* critical exposed functionality 
>intended here. Now, one could argue that the satoshi script is still a 
>systems level component of the system...but with the advent of overlay 
>protocols such as payment channels and the Lightning Network, it is 
>clear that we now require a new abstraction layer for reasoning about 
>the higher level logic of the system that doesn't burden the protocol 
>designer with having to know the intimate and esoteric details of the 
>lower system levels. Of course, many of those who work on these higher 
>level protocols will also be experts in the underlying system design. 
>However, it greatly increases the learning curve and can easily 
>frustrate people looking to work on these ideas...and ultimately, 
>knowing the inner details of how the nSequence field is structured and 
>what the bits actually mean is irrelevant to someone trying to design 
>scripts for such applications.
>
>We've already deployed another opcode, CHECKLOCKTIMEVERIFY, which does 
>refer to the field name. However, in this particular situation, the 
>field name reflects *far* more closely what the app developer actually 
>cares about than nSequence, which to the app developer might as well be
>
>called foo. As such, I stick with my original vote - we should call the
>
>opcode RCHECKLOCKTIMEVERIFY, which has the advantage of communicating 
>fairly directly to developers and protocol designers the semantics they
>
>actually care about and also makes clear the relationship between 
>absolute and relative timelock...that's to say, the ability for the 
>script designer to lock specific coins until either a specific moment
>in 
>time or until a certain delay has passed since the coin output was 
>created (added to blockchain).
>
>Let's face it - the entire motivation behind BIP68/BIP112 is relative 
>timelock. Explicitly calling the opcode RCHECKLOCKTIMEVERIFY will make 
>life easier for everyone and will help sell the idea and help it gain 
>greater acceptance more quickly; while stubbornly adhering to an 
>esoteric detail that is only there for historical reasons will only 
>continue to delay the idea's acceptance and adoptance.
>
>- Eric
>
>------ Original Message ------
>From: "Mark Friedenbach via bitcoin-dev" 
><bitcoin-dev at lists.linuxfoundation.org>
>To: "Btc Drak" <btcdrak at gmail.com>
>Cc: "Bitcoin Dev" <bitcoin-dev at lists.linuxfoundation.org>
>Sent: 11/25/2015 3:05:50 PM
>Subject: Re: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY 
>(BIP112)
>
>>Looks like I'm the long dissenting voice here? As the originator of
>the 
>>name CHECKSEQUENCEVERIFY, perhaps I can explain why the name was 
>>appropriately chosen and why the proposed alternatives don't stand up.
>>
>>First, the names are purposefully chosen to illustrate what they do:
>>
>>What does CHECKLOCKTIMEVERIFY do? It verifies the range of 
>>tx.nLockTime.
>>What does CHECKSEQUENCEVERIFY do? It verifies the range of 
>>txin.nSequence.
>>
>>Second, the semantics are not limited to relative lock-time / maturity
>
>>only. They both leave open ranges with possible, but currently 
>>undefined future consensus-enforced behavior. We don't know what sort 
>>of future behavior these values might trigger, but the associated 
>>opcodes are generic enough to handle them:
>>
>>CHECKLOCKTIMEVERIFY will pass an nSequence between 1985 and 2009, even
>
>>though such constraints have no meaning in Bitcoin.
>>CHECKSEQUENCEVERIFY is explicitly written to permit a 5-byte push 
>>operand, while checking only 17 of the available 39 bits of both the 
>>operand and the nSequence. Indeed the most recent semantic change of 
>>CSV was justified in part because it relaxes all constraints over the 
>>values of these bits freeing them for other purposes in transaction 
>>validation and/or future extensions of the opcode semantics.
>>
>>Third, single-byte opcode space is limited. There are less than 10
>such 
>>opcodes left. Maybe space won't be so precious in a post-segwitness 
>>world, but I don't want to presume that just yet.
>>
>>
>>As for the alternatives, they capture only the initial use case of 
>>nSequence. My objection would relax if nSequence were renamed, but I 
>>think that would be too disruptive and unnecessary. In any case, the 
>>imagined use cases for CHECKSEQUENCEVERIFY has to do with sequencing 
>>execution pathways of script, so it's not a stretch in meaning. 
>>Previously CHECKMATURITYVERIFY was a hypothicated opcode that directly
>
>>checked the minimum age of inputs of a transaction. The indirect
>naming 
>>of CHECKSEQUENCEVERIFY on the other hand is due to its indirect 
>>behavior. RELATIVELOCKTIMEVERIFY was also a hypothicated opcode that 
>>would check a ficticious nRelativeLockTime field, which does not
>exist. 
>>Again my objection would go away if we renamed nSequence, but I 
>>actually think the nSequence name is better...
>>
>>On Tue, Nov 24, 2015 at 2:30 AM, Btc Drak via bitcoin-dev 
>><bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>BIP68 introduces relative lock-time semantics to part of the
>nSequence 
>>>field leaving the majority of bits undefined for other future 
>>>applications.
>>>
>>>BIP112 introduces opcode CHECKSEQUENCEVERIFY (OP_CSV) that is 
>>>specifically limited to verifying transaction inputs according to 
>>>BIP68's relative lock-time[1], yet the _name_ OP_CSV is much boarder 
>>>than that. We spent months limiting the number of bits used in BIP68 
>>>so they would be available for future use cases, thus we have 
>>>acknowledged there will be completely different usecases that take 
>>>advantage of unused nSequence bits.
>>>
>>>For this reason I believe the BIP112 should be renamed specifically 
>>>for it's usecase, which is verifying the time/maturity of transaction
>
>>>inputs relative to their inclusion in a block.
>>>
>>>Suggestions:-
>>>
>>>CHECKMATURITYVERIFY
>>>RELATIVELOCKTIMEVERIFY
>>>RCHECKLOCKTIMEVERIFY
>>>RCLTV
>>>
>>>We could of course softfork additional meaning into OP_CSV each time 
>>>we add new sequence number usecases, but that would become obscure
>and 
>>>confusing. We have already shown there is no shortage of opcodes so
>it 
>>>makes no sense to cram everything into one generic opcode.
>>>
>>>TL;DR: let's give BIP112 opcode a name that reflects it's actual 
>>>usecase rather than focusing on the bitcoin internals.
>>>
>>>[1] 
>>>https://github.com/bitcoin/bitcoin/pull/6564/files#diff-be2905e2f5218ecdbe4e55637dac75f3R1223
>>>
>>>_______________________________________________
>>>bitcoin-dev mailing list
>>>bitcoin-dev at lists.linuxfoundation.org
>>>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>
>------------------------------------------------------------------------
>
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151126/9a401bd9/attachment-0001.html>

From pete at petertodd.org  Thu Nov 26 22:25:56 2015
From: pete at petertodd.org (Peter Todd)
Date: Thu, 26 Nov 2015 17:25:56 -0500
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <523E7E80-A958-4333-96FB-1E0D36BB128F@gmail.com>
References: <em80f319b9-ff7c-4a88-85c7-efdb0333ada1@platinum>
	<523E7E80-A958-4333-96FB-1E0D36BB128F@gmail.com>
Message-ID: <20151126222556.GC6550@savin.petertodd.org>

On Thu, Nov 26, 2015 at 01:32:58PM -0800, Eric Lombrozo via bitcoin-dev wrote:
> After a little more though (and some comments from aj), I realize that the opcode naming convention is actually CHECK <condition > VERIFY.
> 
> Therefore, the full opcode name should be CHECKRELATIVELOCKTIMEVERIFY.
> 
> However, this name is ridiculously long, so at least some part will require abbreviation.
> 
> In typical script example usage, most sensible seems to be to abbreviate both CLTV and CRLTV.

...and CRLTV is hard to visually distinguish from CLTV. :(

You know, calling it AGEVERIFY is short and sweet.

-- 
'peter'[:-1]@petertodd.org
00000000000000000ef246c814f8cb8c1a26bc3c6cb1286bdbc5f4140ed3fc79
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151126/47f980c2/attachment.sig>

From rusty at rustcorp.com.au  Fri Nov 27 04:02:45 2015
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Fri, 27 Nov 2015 14:32:45 +1030
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <eme59eddfb-c410-4af4-b496-e3301ac9db85@platinum>
References: <eme59eddfb-c410-4af4-b496-e3301ac9db85@platinum>
Message-ID: <87ziy0qeca.fsf@rustcorp.com.au>

Eric Lombrozo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
>>From an app developer's perspective, I think it is pretty blatantly 
> clear that relative timelock is *the* critical exposed functionality 
> intended here.

As someone who actually developed scripts using CSV, I agree with Mark
(and Matt).  The relative locktime stuff isn't in this opcode, it's in
the nSequence calculation.

So, I vote to keep CSV called as it is.

Thanks,
Rusty.

From dscotese at litmocracy.com  Fri Nov 27 04:08:35 2015
From: dscotese at litmocracy.com (Dave Scotese)
Date: Thu, 26 Nov 2015 20:08:35 -0800
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CAOG=w-v0_dfZS2=XfKQzRZ9Vq2Z2YqUO2_cuvOheuUrD4dbYtw@mail.gmail.com>
References: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
	<CAOG=w-v0_dfZS2=XfKQzRZ9Vq2Z2YqUO2_cuvOheuUrD4dbYtw@mail.gmail.com>
Message-ID: <CAGLBAhev1jZ6i0aW3B_bnLfrjJanHr_Qu6rtkEQL8fDfyF4yYQ@mail.gmail.com>

I was curious about there being only 10 single-byte opcodes left.  There
are ten single-byte OP_NOPx opcodes defined, but there are 15 opcodes that
"simply *do not exist anymore* in the protocol" because they are scary (had
bugs that "could crash any Bitcoin node if exploited" or "allowed anyone to
spend anyone's bitcoins").  There are also 66 single-byte values that are
currently reserved, 186 - 252 (0xba - 0xfc).

If the name OP_CHECKSEQUENCEVERIFY should not be changed, each of us has a
single best reason not to change it.  Finding other reasons suggests that
one's top reason isn't good enough.  See Nassim Taleb's book, Antifragile,
if that claim makes you curious.  The same goes for changing it.  In any
case, it is 178 (0xb2) and app developers can call it whatever they want.

It seems trivial to me since the following, in script.h, would neither slow
compilation nor confuse anyone, but could lead the curious to explore the
history and expand their knowledge:
OP_NOP3 = 0xb2,
OP_CHECKSEQUENCEVERIFY = OP_NOP3,
OP_CHECKMATURITYVERIFY = OP_NOP3, // A comment defending the alternative
name

I don't know the consensus here on leaving breadcrumbs in code comments
(and enum/variable names) for curious coders to use as inspiration for
studying the history, but I advocate it, since modern IDEs are fairly
well-equipped to make skipping or hiding comments easy.


On Wed, Nov 25, 2015 at 3:05 PM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Looks like I'm the long dissenting voice here? As the originator of the
> name CHECKSEQUENCEVERIFY, perhaps I can explain why the name was
> appropriately chosen and why the proposed alternatives don't stand up.
>
> First, the names are purposefully chosen to illustrate what they do:
>
> What does CHECKLOCKTIMEVERIFY do? It verifies the range of tx.nLockTime.
> What does CHECKSEQUENCEVERIFY do? It verifies the range of txin.nSequence.
>
> Second, the semantics are not limited to relative lock-time / maturity
> only. They both leave open ranges with possible, but currently undefined
> future consensus-enforced behavior. We don't know what sort of future
> behavior these values might trigger, but the associated opcodes are generic
> enough to handle them:
>
> CHECKLOCKTIMEVERIFY will pass an nSequence between 1985 and 2009, even
> though such constraints have no meaning in Bitcoin.
> CHECKSEQUENCEVERIFY is explicitly written to permit a 5-byte push operand,
> while checking only 17 of the available 39 bits of both the operand and the
> nSequence. Indeed the most recent semantic change of CSV was justified in
> part because it relaxes all constraints over the values of these bits
> freeing them for other purposes in transaction validation and/or future
> extensions of the opcode semantics.
>
> Third, single-byte opcode space is limited. There are less than 10 such
> opcodes left. Maybe space won't be so precious in a post-segwitness world,
> but I don't want to presume that just yet.
>
>
> As for the alternatives, they capture only the initial use case of
> nSequence. My objection would relax if nSequence were renamed, but I think
> that would be too disruptive and unnecessary. In any case, the imagined use
> cases for CHECKSEQUENCEVERIFY has to do with sequencing execution pathways
> of script, so it's not a stretch in meaning. Previously CHECKMATURITYVERIFY
> was a hypothicated opcode that directly checked the minimum age of inputs
> of a transaction. The indirect naming of CHECKSEQUENCEVERIFY on the other
> hand is due to its indirect behavior. RELATIVELOCKTIMEVERIFY was also a
> hypothicated opcode that would check a ficticious nRelativeLockTime field,
> which does not exist. Again my objection would go away if we renamed
> nSequence, but I actually think the nSequence name is better...
>
> On Tue, Nov 24, 2015 at 2:30 AM, Btc Drak via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> BIP68 introduces relative lock-time semantics to part of the nSequence
>> field leaving the majority of bits undefined for other future applications.
>>
>> BIP112 introduces opcode CHECKSEQUENCEVERIFY (OP_CSV) that is
>> specifically limited to verifying transaction inputs according to BIP68's
>> relative lock-time[1], yet the _name_ OP_CSV is much boarder than that. We
>> spent months limiting the number of bits used in BIP68 so they would be
>> available for future use cases, thus we have acknowledged there will be
>> completely different usecases that take advantage of unused nSequence bits.
>>
>> For this reason I believe the BIP112 should be renamed specifically for
>> it's usecase, which is verifying the time/maturity of transaction inputs
>> relative to their inclusion in a block.
>>
>> Suggestions:-
>>
>> CHECKMATURITYVERIFY
>> RELATIVELOCKTIMEVERIFY
>> RCHECKLOCKTIMEVERIFY
>> RCLTV
>>
>> We could of course softfork additional meaning into OP_CSV each time we
>> add new sequence number usecases, but that would become obscure and
>> confusing. We have already shown there is no shortage of opcodes so it
>> makes no sense to cram everything into one generic opcode.
>>
>> TL;DR: let's give BIP112 opcode a name that reflects it's actual usecase
>> rather than focusing on the bitcoin internals.
>>
>> [1]
>> https://github.com/bitcoin/bitcoin/pull/6564/files#diff-be2905e2f5218ecdbe4e55637dac75f3R1223
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151126/53c45125/attachment.html>

From elombrozo at gmail.com  Fri Nov 27 08:10:49 2015
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Fri, 27 Nov 2015 00:10:49 -0800
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <87ziy0qeca.fsf@rustcorp.com.au>
References: <eme59eddfb-c410-4af4-b496-e3301ac9db85@platinum>
	<87ziy0qeca.fsf@rustcorp.com.au>
Message-ID: <B412CC14-0FD7-47E3-8A34-EB73198ED041@gmail.com>

After reading Rusty's post, I admit there's something to be said for the fact that both the script and the nSequence field play a combined role, and thus, making the interaction between the two more clear in the naming make sense.

It is somewhat unfortunate that currently, we can't just have a dedicated field for the purpose of relative locktime (or minimum age) without having to repurpose the only unused 32 bits in the txin.

HOWEVER...there might be ways around this issue using segwit.

I've been pondering the possibility of adding an extra input vector to the prunable extra data that  comprises the witness. Witness structures can provide additional data that is used in transaction validation but does not contribute to the tx hash.

Currently, the signature checking opcodes in the script already do this implicitly for computing the hash that is signed (but not the tx hash used in block merkletrees)...and this is the principal cause of undesirable malleability issues. Clearly the signatures themselves cannot contribute to the hash they are signing. So segwit makes this separation explicit by moving the signatures to a structure external to the script. Pieter Wuille's implementation (https://github.com/sipa/bitcoin/tree/segwit) generalizes this idea using a script witness structure that is a vector of arbitrary inputs. Clearly moving the signatures into such structure is an important feature...but other types of input to the script could be placed here as well.

I had considered the possibility of placing a minimum age (relative locktime) field in the input vector that could be checked for mempool acceptance without having to evaluate the script. Of course, the location of such a field would have to be known by the mempool and cannot be an arbitrary element of a generic input vector, which adds some minor but surmountable complications.

Greg Maxwell pointed out, however, that signing opcodes that sign hashes discarding this data would make it trivial for anyone to change this field without signing anything. The nSequence fields of txins, being part of the tx serialization that gets hashed, is therefore always signed.

This led me to consider the possibility of adding extra opcodes to the script that can incorporate additional data in the hash that gets signed. This data would go in another structure that does not contribute to the tx hash but is outside the witness. Then we could add extra prunable data fields that the signer can commit to.

If I've missed something critical in the above analysis, someone please correct me...but it seems that such a mechanism would allow adding extra prunable signed data fields to transactions, which might ultimately remove scarcity of tx data that we can repurpose via soft forks. If this is the case, I would suggest turning the nSequence field into a dedicated min age/rlt field to simplify the semantics and avoid ugliness in trying to reclaim unused bits.

I may be overlooking something important here, but unless there's a reason such data cannot be made prunable, I haven't been able to poke a hole yet.

- Eric



On November 26, 2015 8:02:45 PM PST, Rusty Russell <rusty at rustcorp.com.au> wrote:
>Eric Lombrozo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>writes:
>>>From an app developer's perspective, I think it is pretty blatantly 
>> clear that relative timelock is *the* critical exposed functionality 
>> intended here.
>
>As someone who actually developed scripts using CSV, I agree with Mark
>(and Matt).  The relative locktime stuff isn't in this opcode, it's in
>the nSequence calculation.
>
>So, I vote to keep CSV called as it is.
>
>Thanks,
>Rusty.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151127/73b49c65/attachment-0001.html>

From jtimon at jtimon.cc  Fri Nov 27 10:14:10 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 27 Nov 2015 11:14:10 +0100
Subject: [bitcoin-dev] Alternative name for CHECKSEQUENCEVERIFY (BIP112)
In-Reply-To: <CAOG=w-v0_dfZS2=XfKQzRZ9Vq2Z2YqUO2_cuvOheuUrD4dbYtw@mail.gmail.com>
References: <CADJgMzs0w4L7ma42RCzT5dYDcG2aY1_04G1khcFPFPE6mmB=-A@mail.gmail.com>
	<CAOG=w-v0_dfZS2=XfKQzRZ9Vq2Z2YqUO2_cuvOheuUrD4dbYtw@mail.gmail.com>
Message-ID: <CABm2gDrjiNTNo3FZ82D3131g5gBEwfHCofdK9BeEPPZ6k-TzbQ@mail.gmail.com>

On Nov 26, 2015 12:06 AM, "Mark Friedenbach via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
> Again my objection would go away if we renamed nSequence, but I actually
think the nSequence name is better...

I suggested to rename nSequence to nMaturity on this list even before the
bips and implementations were started, probably too late now.
Before the implementation "let's think about those naming details later".
After the implementation "now it's too late, now we would need to change
the implementation, this renaming is now unnecessarily disruptive".

Reminds me of refactors and major releases:
At the beginning of the release "not now, this will disrupt development of
feature X"
After feature X is merged or replaced by feature Y: "too late in the
release cycle, refactors should be done only at the beginning, at the end
is 'too risky' ".
Sigh, I hope I find the "right time" (not both too soon and too late like
this time), next time...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151127/aae8691b/attachment.html>

From matsjj at gmail.com  Fri Nov 27 08:02:37 2015
From: matsjj at gmail.com (Mats Jerratsch)
Date: Fri, 27 Nov 2015 09:02:37 +0100
Subject: [bitcoin-dev] [BIP] OP_CHECKPRIVPUBPAIR
Message-ID: <CAE8CtVmqT0L74+xyEh-fn9vDcudBuMvgSr39DBVFopXbKyvNcA@mail.gmail.com>

Prior discussion:
http://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000309.html

Goal:
Greatly improve security for payment networks like the 'Lightning
Network' (LN) [1]

---

Introduction:
To improve privacy while using a payment network, it is possible to
use onion-routing to make a payment to someone. In this context,
onion-routing means encrypting the data about subsequent hops in a way
that each node only knows where it received a payment from and the
direct next node it should send the payment to. This way we can route
a payment over N nodes, and none of these will know

(1) at which position it is within the route (first, middle, last?)

(2) which node initially issued the payment (payer)

(3) which node consumes the payment (payee).

However, given the way payments in LN work, each payment is uniquely
identifiable by a preimage-hash pair R-H. H is included in the output
script of the commit transaction, such that the payment is enforceable
if you ever get to know the preimage R.

In a payment network each node makes a promise to pay the next node,
if they can produce R. They can pass on the payment, as they know that
they can enforce the payment from a previous node using the same
preimage R. This severely damages privacy, as it lowers the amount of
nodes an attacker has to control to gain information about payer and
payee.

---

Problem:
The problem was inherited by using RIPEMD-160 for preimage-hash
construction. For any cryptographic hash-function it is fundamentally
unfeasible to correlate preimage and hash in such a way, that

F1(R1) = R2 and
F2(H1) = H2, while
SHA(R1) = H1 and SHA(R2) = H2.

In other words, I cannot give a node H1 and H2 and ask it to receive
my payment using H1, but pass it on using H2, as the node has no way
of verifying it can produce R1 out of the R2 it will receive. If it
cannot produce R1, it is unable to enforce my part of the contract.

---

Solution:
While above functions are merely impossible to construct for a
cryptographic hash functions, they are trivial when R and H is a EC
private/public key pair. The original sender can make a payment using
H1 and pass on a random number M1, such that the node can calculate a
new public key

H2 = H1 + M1.

When he later receives the private key R2, he can construct

R1 = R2 - M1

to be able to enforce the other payment. M1 can be passed on in the
onion object, such that each node can only see M for that hop.
Furthermore, it is unfeasible to brute-force, given a sufficiently
large number M.

---

Example:

Given that E wants to receive a payment from A, payable to H. (if A
can produce R, it can be used as a prove he made the payment and E
received it)

A decides to route the payment over the nodes B, C and D. A uses four
numbers M1...M4 to calculate H1...H4. The following payments then take
place

A->B using H4
B->C using H3
C->D using H2
D->E using H1.

When E receives H1, he can use attached M1 to calculate R1 from it.
The chain will resolve itself, and A is able to calculate R using
M1...M4. It also means that all privacy is at the sole discretion of
the sender, and that not even the original pair R/H is known to any of
the nodes.

To improve privacy, E could also be a rendezvous point chosen by the
real receiver of the payment, similar constructions are similar in
that direction as well.

---

Caveats:

Currently it is difficult to enforce a payment to a private-public key
pair on the blockchain. While there exists OP_HASH160 OP_EQUAL to
enforce a payment to a hash, the same does not hold true for EC keys.
To make above possible we would therefore need some easy way to force
a private key, given a public key. This could be done by using one of
the unused OP_NOP codes, which will verify

<private key> <public key> OP_CHECKPRIVPUBPAIR

and fails if these are not correlated or NOP otherwise. Would need
OP_2DROP afterwards. This would allow deployment using a softfork.

As there are requests for all sort of general crypto operations in
script, we can also introduce a new general OP_CRYPTO and prepend one
byte for the operation, so

0x01 OP_CRYPTO = OP_CHECKPRIVPUBPAIR
0x02-0xff OP_CRYPTO = OP_NOP

to allow for extension at some later point.

---

Alternatives:

In the attached discussion there are some constructions that would
allow breaking the signature scheme, but they are either very large in
script language or expensive to calculate. Given that the blocksize is
a difficult topic already, it would not be beneficial to have a 400B+
for each open payment in case one party breaches the contract. (or
just disappears for a couple of days)

It is also possible to use a NIZKP - more specifically SNARK - to
prove to one node that it is able to recover a preimage R1 = R2 XOR
M1, given only H1, H2 and M1. However, these are expensive to
calculate and experimental in it's current state.

---

Acknowledgements:
Gregory Maxwell for pointing out addition of M1 for EC points is much
less expensive
Pieter Wuille for helping with general understanding of EC math.
Anthony Towns for bringing up the issue and explaining SNARKs

[1]
http://lightning.network/

From peter.tschipper at gmail.com  Sat Nov 28 14:48:41 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Sat, 28 Nov 2015 06:48:41 -0800
Subject: [bitcoin-dev] further test results for : "Datastream
 Compression of Blocks and Tx's"
In-Reply-To: <CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
Message-ID: <5659BEC9.50307@gmail.com>

Hi All,

Here are some final results of testing with the reference implementation
for compressing blocks and transactions. This implementation also
concatenates blocks and transactions when possible so you'll see data
sizes in the 1-2MB ranges.

Results below show the time it takes to sync the first part of the
blockchain, comparing Zlib to the LZOx library.  (LZOf was also tried
but wasn't found to be as good as LZOx).  The following shows tests run
with and without latency.  With latency on the network, all compression
libraries performed much better than without compression.

I don't think it's entirely obvious which is better, Zlib or LZO. 
Although I prefer the higher compression of Zlib, overall I would have
to give the edge to LZO.  With LZO we have the fastest most scalable
option when at the lowest compression setting which will be a boost in
performance for users that want peformance over compression, and then at
the high end LZO provides decent compression which approaches Zlib,
(although at a higher cost) but good for those that want to save more
bandwidth.

Uncompressed 60ms 	Zlib-1 (60ms) 	Zlib-6 (60ms) 	LZOx-1 (60ms) 	LZOx-999
(60ms)
219 	299 	296 	294 	291
432 	568 	565 	558 	548
652 	835 	836 	819 	811
866 	1106 	1107 	1081 	1071
1082 	1372 	1381 	1341 	1333
1309 	1644 	1654 	1605 	1600
1535 	1917 	1936 	1873 	1875
1762 	2191 	2210 	2141 	2141
1992 	2463 	2486 	2411 	2411
2257 	2748 	2780 	2694 	2697
2627 	3034 	3076 	2970 	2983
3226 	3416 	3397 	3266 	3302
4010 	3983 	3773 	3625 	3703
4914 	4503 	4292 	4127 	4287
5806 	4928 	4719 	4529 	4821
6674 	5249 	5164 	4840 	5314
7563 	5603 	5669 	5289 	6002
8477 	6054 	6268 	5858 	6638
9843 	7085 	7278 	6868 	7679
11338 	8215 	8433 	8044 	8795



These results from testing on a highspeed wireless LAN (very small latency)

Results in seconds 	
	
	
	
	
Num blocks sync'd 	Uncompressed 	Zlib-1 	Zlib-6 	LZOx-1 	LZOx-999
10000 	255 	232 	233 	231 	257
20000 	464 	414 	420 	407 	453
30000 	677 	594 	611 	585 	650
40000 	887 	782 	795 	760 	849
50000 	1099 	961 	977 	933 	1048
60000 	1310 	1145 	1167 	1110 	1259
70000 	1512 	1330 	1362 	1291 	1470
80000 	1714 	1519 	1552 	1469 	1679
90000 	1917 	1707 	1747 	1650 	1882
100000 	2122 	1905 	1950 	1843 	2111
110000 	2333 	2107 	2151 	2038 	2329
120000 	2560 	2333 	2376 	2256 	2580
130000 	2835 	2656 	2679 	2558 	2921
140000 	3274 	3259 	3161 	3051 	3466
150000 	3662 	3793 	3547 	3440 	3919
160000 	4040 	4172 	3937 	3767 	4416
170000 	4425 	4625 	4379 	4215 	4958
180000 	4860 	5149 	4895 	4781 	5560
190000 	5855 	6160 	5898 	5805 	6557
200000 	7004 	7234 	7051 	6983 	7770



The following show the compression ratio acheived for various sizes of
data.  Zlib is the clear
winner for compressibility, with LZOx-999 coming close but at a cost.

range 	Zlib-1 cmp%
	Zlib-6 cmp% 	LZOx-1 cmp% 	LZOx-999 cmp%
0-250b 	12.44 	12.86 	10.79 	14.34
250-500b  	19.33 	12.97 	10.34 	11.11
600-700 	16.72 	n/a 	12.91 	17.25
700-800 	6.37 	7.65 	4.83 	8.07
900-1KB 	6.54 	6.95 	5.64 	7.9
1KB-10KB 	25.08 	25.65 	21.21 	22.65
10KB-100KB 	19.77 	21.57 	14.37 	19.02
100KB-200KB 	21.49 	23.56 	15.37 	21.55
200KB-300KB 	23.66 	24.18 	16.91 	22.76
300KB-400KB 	23.4 	23.7 	16.5 	21.38
400KB-500KB 	24.6 	24.85 	17.56 	22.43
500KB-600KB 	25.51 	26.55 	18.51 	23.4
600KB-700KB 	27.25 	28.41 	19.91 	25.46
700KB-800KB 	27.58 	29.18 	20.26 	27.17
800KB-900KB 	27 	29.11 	20 	27.4
900KB-1MB 	28.19 	29.38 	21.15 	26.43
1MB -2MB 	27.41 	29.46 	21.33 	27.73


The following shows the time in seconds to compress data of various
sizes.  LZO1x is the
fastest and as file sizes increase, LZO1x time hardly increases at all. 
It's interesing
to note as compression ratios increase LZOx-999 performs much worse than
Zlib.  So LZO is faster
on the low end and slower (5 to 6 times slower) on the high end.

range 	Zlib-1 	Zlib-6 	LZOx-1 	LZOx-999 cmp%
0-250b    	0.001 	0 	0 	0
250-500b   	0 	0 	0 	0.001
500-1KB     	0 	0 	0 	0.001
1KB-10KB    	0.001 	0.001 	0 	0.002
10KB-100KB   	0.004 	0.006 	0.001 	0.017
100KB-200KB  	0.012 	0.017 	0.002 	0.054
200KB-300KB  	0.018 	0.024 	0.003 	0.087
300KB-400KB  	0.022 	0.03 	0.003 	0.121
400KB-500KB  	0.027 	0.037 	0.004 	0.151
500KB-600KB  	0.031 	0.044 	0.004 	0.184
600KB-700KB  	0.035 	0.051 	0.006 	0.211
700KB-800KB  	0.039 	0.057 	0.006 	0.243
800KB-900KB  	0.045 	0.064 	0.006 	0.27
900KB-1MB   	0.049 	0.072 	0.006 	0.307


On 10/11/2015 8:46 AM, Jeff Garzik via bitcoin-dev wrote:
> Comments:
>
> 1) cblock seems a reasonable way to extend the protocol.  Further
> wrapping should probably be done at the stream level.
>
> 2) zlib has crappy security track record.
>
> 3) A fallback path to non-compressed is required, should compression
> fail or crash.
>
> 4) Most blocks and transactions have runs of zeroes and/or highly
> common bit-patterns, which contributes to useful compression even at
> smaller sizes.  Peter Ts's most recent numbers bear this out.  zlib
> has a dictionary (32K?) which works well with repeated patterns such
> as those you see with concatenated runs of transactions.
>
> 5) LZO should provide much better compression, at a cost of CPU
> performance and using a less-reviewed, less-field-tested library.
>
>
>
>
>
> On Tue, Nov 10, 2015 at 11:30 AM, Tier Nolan via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>
>
>     On Tue, Nov 10, 2015 at 4:11 PM, Peter Tschipper
>     <peter.tschipper at gmail.com <mailto:peter.tschipper at gmail.com>> wrote:
>
>         There are better ways of sending new blocks, that's certainly
>         true but for sending historical blocks and seding transactions
>         I don't think so.  This PR is really designed to save
>         bandwidth and not intended to be a huge performance
>         improvement in terms of time spent sending.
>
>
>     If the main point is for historical data, then sticking to just
>     blocks is the best plan.
>
>     Since small blocks don't compress well, you could define a
>     "cblocks" message that handles multiple blocks (just concatenate
>     the block messages as payload before compression). 
>
>     The sending peer could combine blocks so that each cblock is
>     compressing at least 10kB of block data (or whatever is optimal). 
>     It is probably worth specifying a maximum size for network buffer
>     reasons (either 1MB or 1 block maximum).
>
>     Similarly, transactions could be combined together and compressed
>     "ctxs".  The inv messages could be modified so that you can
>     request groups of 10-20 transactions.  That would depend on how
>     much of an improvement compressed transactions would represent.
>
>     More generally, you could define a message which is a compressed
>     message holder.  That is probably to complex to be worth the
>     effort though.
>
>      
>
>>
>>         On Tue, Nov 10, 2015 at 5:40 AM, Johnathan Corgan via
>>         bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>
>>             On Mon, Nov 9, 2015 at 5:58 PM, gladoscc via bitcoin-dev
>>             <bitcoin-dev at lists.linuxfoundation.org
>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>>              
>>
>>                 I think 25% bandwidth savings is certainly
>>                 considerable, especially for people running full
>>                 nodes in countries like Australia where internet
>>                 bandwidth is lower and there are data caps.
>>
>>
>>             ? This reinforces the idea that such trade-off decisions
>>             should be be local and negotiated between peers, not a
>>             required feature of the network P2P.?
>>              
>>
>>             -- 
>>             Johnathan Corgan
>>             Corgan Labs - SDR Training and Development Services
>>             http://corganlabs.com
>>
>>             _______________________________________________
>>             bitcoin-dev mailing list
>>             bitcoin-dev at lists.linuxfoundation.org
>>             <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
>>
>>         _______________________________________________
>>         bitcoin-dev mailing list
>>         bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151128/66db15c2/attachment-0001.html>

From peter.tschipper at gmail.com  Sat Nov 28 21:41:51 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Sat, 28 Nov 2015 13:41:51 -0800
Subject: [bitcoin-dev] Test Results for : Datasstream Compression of Blocks
	and Tx's
Message-ID: <565A1F9F.1090005@gmail.com>

Hi All,

Here are some final results of testing with the reference implementation
for compressing blocks and transactions. This implementation also
concatenates blocks and transactions when possible so you'll see data
sizes in the 1-2MB ranges.

Results below show the time it takes to sync the first part of the
blockchain, comparing Zlib to the LZOx library.  (LZOf was also tried
but wasn't found to be as good as LZOx).  The following shows tests run
with and without latency.  With latency on the network, all compression
libraries performed much better than without compression.

I don't think it's entirely obvious which is better, Zlib or LZO. 
Although I prefer the higher compression of Zlib, overall I would have
to give the edge to LZO.  With LZO we have the fastest most scalable
option when at the lowest compression setting which will be a boost in
performance for users that want peformance over compression, and then at
the high end LZO provides decent compression which approaches Zlib,
(although at a higher cost) but good for those that want to save more
bandwidth.

Uncompressed 60ms 	Zlib-1 (60ms) 	Zlib-6 (60ms) 	LZOx-1 (60ms) 	LZOx-999
(60ms)
219 	299 	296 	294 	291
432 	568 	565 	558 	548
652 	835 	836 	819 	811
866 	1106 	1107 	1081 	1071
1082 	1372 	1381 	1341 	1333
1309 	1644 	1654 	1605 	1600
1535 	1917 	1936 	1873 	1875
1762 	2191 	2210 	2141 	2141
1992 	2463 	2486 	2411 	2411
2257 	2748 	2780 	2694 	2697
2627 	3034 	3076 	2970 	2983
3226 	3416 	3397 	3266 	3302
4010 	3983 	3773 	3625 	3703
4914 	4503 	4292 	4127 	4287
5806 	4928 	4719 	4529 	4821
6674 	5249 	5164 	4840 	5314
7563 	5603 	5669 	5289 	6002
8477 	6054 	6268 	5858 	6638
9843 	7085 	7278 	6868 	7679
11338 	8215 	8433 	8044 	8795



These results from testing on a highspeed wireless LAN (very small latency)

Results in seconds 	
	
	
	
	
Num blocks sync'd 	Uncompressed 	Zlib-1 	Zlib-6 	LZOx-1 	LZOx-999
10000 	255 	232 	233 	231 	257
20000 	464 	414 	420 	407 	453
30000 	677 	594 	611 	585 	650
40000 	887 	782 	795 	760 	849
50000 	1099 	961 	977 	933 	1048
60000 	1310 	1145 	1167 	1110 	1259
70000 	1512 	1330 	1362 	1291 	1470
80000 	1714 	1519 	1552 	1469 	1679
90000 	1917 	1707 	1747 	1650 	1882
100000 	2122 	1905 	1950 	1843 	2111
110000 	2333 	2107 	2151 	2038 	2329
120000 	2560 	2333 	2376 	2256 	2580
130000 	2835 	2656 	2679 	2558 	2921
140000 	3274 	3259 	3161 	3051 	3466
150000 	3662 	3793 	3547 	3440 	3919
160000 	4040 	4172 	3937 	3767 	4416
170000 	4425 	4625 	4379 	4215 	4958
180000 	4860 	5149 	4895 	4781 	5560
190000 	5855 	6160 	5898 	5805 	6557
200000 	7004 	7234 	7051 	6983 	7770



The following show the compression ratio acheived for various sizes of
data.  Zlib is the clear
winner for compressibility, with LZOx-999 coming close but at a cost.

range 	Zlib-1 cmp%
	Zlib-6 cmp% 	LZOx-1 cmp% 	LZOx-999 cmp%
0-250b 	12.44 	12.86 	10.79 	14.34
250-500b  	19.33 	12.97 	10.34 	11.11
600-700 	16.72 	n/a 	12.91 	17.25
700-800 	6.37 	7.65 	4.83 	8.07
900-1KB 	6.54 	6.95 	5.64 	7.9
1KB-10KB 	25.08 	25.65 	21.21 	22.65
10KB-100KB 	19.77 	21.57 	14.37 	19.02
100KB-200KB 	21.49 	23.56 	15.37 	21.55
200KB-300KB 	23.66 	24.18 	16.91 	22.76
300KB-400KB 	23.4 	23.7 	16.5 	21.38
400KB-500KB 	24.6 	24.85 	17.56 	22.43
500KB-600KB 	25.51 	26.55 	18.51 	23.4
600KB-700KB 	27.25 	28.41 	19.91 	25.46
700KB-800KB 	27.58 	29.18 	20.26 	27.17
800KB-900KB 	27 	29.11 	20 	27.4
900KB-1MB 	28.19 	29.38 	21.15 	26.43
1MB -2MB 	27.41 	29.46 	21.33 	27.73


The following shows the time in seconds to compress data of various
sizes.  LZO1x is the
fastest and as file sizes increase, LZO1x time hardly increases at all. 
It's interesing
to note as compression ratios increase LZOx-999 performs much worse than
Zlib.  So LZO is faster
on the low end and slower (5 to 6 times slower) on the high end.

range 	Zlib-1 	Zlib-6 	LZOx-1 	LZOx-999 cmp%
0-250b    	0.001 	0 	0 	0
250-500b   	0 	0 	0 	0.001
500-1KB     	0 	0 	0 	0.001
1KB-10KB    	0.001 	0.001 	0 	0.002
10KB-100KB   	0.004 	0.006 	0.001 	0.017
100KB-200KB  	0.012 	0.017 	0.002 	0.054
200KB-300KB  	0.018 	0.024 	0.003 	0.087
300KB-400KB  	0.022 	0.03 	0.003 	0.121
400KB-500KB  	0.027 	0.037 	0.004 	0.151
500KB-600KB  	0.031 	0.044 	0.004 	0.184
600KB-700KB  	0.035 	0.051 	0.006 	0.211
700KB-800KB  	0.039 	0.057 	0.006 	0.243
800KB-900KB  	0.045 	0.064 	0.006 	0.27
900KB-1MB   	0.049 	0.072 	0.006 	0.307


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151128/33ab8097/attachment-0001.html>

From j at toom.im  Sun Nov 29 00:30:20 2015
From: j at toom.im (Jonathan Toomim)
Date: Sat, 28 Nov 2015 16:30:20 -0800
Subject: [bitcoin-dev] further test results for : "Datastream
	Compression of Blocks and Tx's"
In-Reply-To: <5659BEC9.50307@gmail.com>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<5659BEC9.50307@gmail.com>
Message-ID: <725E6BCC-E839-4F91-9BCA-95D0549DC3C7@toom.im>

It appears you're using the term "compression ratio" to mean "size reduction". A compression ratio is the ratio (compressed / uncompressed). A 1 kB file compressed with a 10% compression ratio would be 0.1 kB. It seems you're using (1 - compressed/uncompressed), meaning that the compressed file would be 0.9 kB.

On Nov 28, 2015, at 6:48 AM, Peter Tschipper via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> The following show the compression ratio acheived for various sizes of data.  Zlib is the clear
> winner for compressibility, with LZOx-999 coming close but at a cost.
> 
> range	Zlib-1 cmp%
> Zlib-6 cmp%	LZOx-1 cmp%	LZOx-999 cmp%
> 0-250b	12.44	12.86	10.79	14.34
> 250-500b 	19.33	12.97	10.34	11.11
> 
> 
> 
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151128/7d5fb307/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151128/7d5fb307/attachment.sig>

From vincent.truong at procabiak.com  Sun Nov 29 03:50:14 2015
From: vincent.truong at procabiak.com (Vincent Truong)
Date: Sun, 29 Nov 2015 14:50:14 +1100
Subject: [bitcoin-dev] Use CPFP as consensus critical for Full-RBF
Message-ID: <CACrzPe=LMGW6HGoUii4pog0Ezn3kEv9_US==0XPUXHp1ivzuuw@mail.gmail.com>

(I haven't been following this development recently so apologies in advance
if I've made assumptions about RBF)

If you made CPFP consensus critical for all Full-RBF transactions, RBF
should be safer to use. I see RBF as a necessity for users to fix mistakes
(and not for transaction prioritisation), but we can't know for sure if
miners are playing with this policy fairly or not. It is hard to spot a
legitimate RBF and a malicious one, but if the recipient signs off on the
one they know about using CPFP, there should be no problems. This might
depend on the CPFP implementation, because you'll need a way for the
transaction to mark which output is a change address and which is a payment
to prevent the sender from signing off his own txns. (This might be bad for
privacy, but IMO a lot safer than allowing RBF double spending sprees... If
you value privacy then don't use RBF?) Or maybe let them sign it off but
make all outputs sign off somehow.

Copy/Paste from my reddit post:

https://www.reddit.com/r/Bitcoin/comments/3ul1kb/slug/cxgegkj

Going to chime in my opinion: opt-in RBF eliminates the trust required with
miners. You don't know if they're secretly running RBF right now anyway.
Whether Peter Todd invented this is irrelevant, it was going to happen
either way either with good intentions or with malice, so better to develop
this with good intentions.

Perhaps the solution to this problem is simple. Allow Full-RBF up to the
point where a recipient creates a CPFP transaction. Any transaction with
full RBF that hasn't been signed off with a CPFP cannot go into a block,
and this can become a consensus rule rather than local policy thanks to the
opt-in flags that's inside transactions.

> P.S. (When I wrote this, I'm actually not sure how the flag looks like
and am just guessing it can be used this way. I'm not familiar with the
implementation.)

CPFP is needed so that merchants can bear the burden of fees (double
bandwidth costs aside, and frankly if RBF is allowed bandwidth is going to
increase regardless anyway). That's always the way I've being seeing its
purpose. And this makes RBF much safer to use by combining the two.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151129/36a93a2d/attachment.html>

From peter.tschipper at gmail.com  Sun Nov 29 05:15:32 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Sat, 28 Nov 2015 21:15:32 -0800
Subject: [bitcoin-dev] further test results for : "Datastream
 Compression of Blocks and Tx's"
In-Reply-To: <725E6BCC-E839-4F91-9BCA-95D0549DC3C7@toom.im>
References: <5640F172.3010004@gmail.com> <20151109210449.GE5886@mcelrath.org>
	<CAL7-sS0Apm4O_Qi0FmY7=H580rEVD6DYjk2y+ACpZmKqUJTQwA@mail.gmail.com>
	<CALOxbZtTUrZwDfy_jTbs60n=K8RKDGg5X0gkLsh-OX3ikLf1FQ@mail.gmail.com>
	<CAE-z3OUB-se_HUvW2NLjWt=0d5sgMiPEciu0hLzr_HQN0m9fqQ@mail.gmail.com>
	<5642172C.701@gmail.com>
	<CAE-z3OXgWCHL_3CDR-ACc7ojbLi7EavyObNa3s7hPUMGj_V2+A@mail.gmail.com>
	<CADm_WcYAj9_r6tu8Be-U81LDwWvnv04PZJMmc-S4cY7+jxfzGw@mail.gmail.com>
	<5659BEC9.50307@gmail.com>
	<725E6BCC-E839-4F91-9BCA-95D0549DC3C7@toom.im>
Message-ID: <565A89F4.6070706@gmail.com>

yes, you're right, it's just the percentage compressed (size reduction)

On 28/11/2015 4:30 PM, Jonathan Toomim wrote:
> It appears you're using the term "compression ratio" to mean "size
> reduction". A compression ratio is the ratio (compressed /
> uncompressed). A 1 kB file compressed with a 10% compression ratio
> would be 0.1 kB. It seems you're using (1 - compressed/uncompressed),
> meaning that the compressed file would be 0.9 kB.
>
> On Nov 28, 2015, at 6:48 AM, Peter Tschipper via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>> The following show the compression ratio acheived for various sizes
>> of data.  Zlib is the clear
>> winner for compressibility, with LZOx-999 coming close but at a cost.
>>
>> range 	Zlib-1 cmp%
>> 	Zlib-6 cmp% 	LZOx-1 cmp% 	LZOx-999 cmp%
>> 0-250b 	12.44 	12.86 	10.79 	14.34
>> 250-500b  	19.33 	12.97 	10.34 	11.11
>>
>> 	
>> 	
>> 	
>> 	
>>
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151128/38398a67/attachment.html>

From jtimon at jtimon.cc  Sun Nov 29 11:55:08 2015
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 29 Nov 2015 12:55:08 +0100
Subject: [bitcoin-dev] Use CPFP as consensus critical for Full-RBF
In-Reply-To: <CACrzPe=LMGW6HGoUii4pog0Ezn3kEv9_US==0XPUXHp1ivzuuw@mail.gmail.com>
References: <CACrzPe=LMGW6HGoUii4pog0Ezn3kEv9_US==0XPUXHp1ivzuuw@mail.gmail.com>
Message-ID: <CABm2gDq_KKhtvgvT6G=rpsv28acV7pDX1cR6Gd5gpNNofm3wKQ@mail.gmail.com>

Both CPFP and RBF are relay/mining policy and cannot be made consensus
rules because you cannot know which transactions have been received by a
givrn peer and which have not (or at what time). Consensus rules can only
validate information that's in the blockchain.
On Nov 29, 2015 5:33 AM, "Vincent Truong via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> (I haven't been following this development recently so apologies in
> advance if I've made assumptions about RBF)
>
> If you made CPFP consensus critical for all Full-RBF transactions, RBF
> should be safer to use. I see RBF as a necessity for users to fix mistakes
> (and not for transaction prioritisation), but we can't know for sure if
> miners are playing with this policy fairly or not. It is hard to spot a
> legitimate RBF and a malicious one, but if the recipient signs off on the
> one they know about using CPFP, there should be no problems. This might
> depend on the CPFP implementation, because you'll need a way for the
> transaction to mark which output is a change address and which is a payment
> to prevent the sender from signing off his own txns. (This might be bad for
> privacy, but IMO a lot safer than allowing RBF double spending sprees... If
> you value privacy then don't use RBF?) Or maybe let them sign it off but
> make all outputs sign off somehow.
>
> Copy/Paste from my reddit post:
>
> https://www.reddit.com/r/Bitcoin/comments/3ul1kb/slug/cxgegkj
>
> Going to chime in my opinion: opt-in RBF eliminates the trust required
> with miners. You don't know if they're secretly running RBF right now
> anyway. Whether Peter Todd invented this is irrelevant, it was going to
> happen either way either with good intentions or with malice, so better to
> develop this with good intentions.
>
> Perhaps the solution to this problem is simple. Allow Full-RBF up to the
> point where a recipient creates a CPFP transaction. Any transaction with
> full RBF that hasn't been signed off with a CPFP cannot go into a block,
> and this can become a consensus rule rather than local policy thanks to the
> opt-in flags that's inside transactions.
>
> > P.S. (When I wrote this, I'm actually not sure how the flag looks like
> and am just guessing it can be used this way. I'm not familiar with the
> implementation.)
>
> CPFP is needed so that merchants can bear the burden of fees (double
> bandwidth costs aside, and frankly if RBF is allowed bandwidth is going to
> increase regardless anyway). That's always the way I've being seeing its
> purpose. And this makes RBF much safer to use by combining the two.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151129/2b2e39b7/attachment.html>

From aj at erisian.com.au  Sun Nov 29 23:41:43 2015
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 30 Nov 2015 09:41:43 +1000
Subject: [bitcoin-dev] [BIP] OP_CHECKPRIVPUBPAIR
In-Reply-To: <CAE8CtVmqT0L74+xyEh-fn9vDcudBuMvgSr39DBVFopXbKyvNcA@mail.gmail.com>
References: <CAE8CtVmqT0L74+xyEh-fn9vDcudBuMvgSr39DBVFopXbKyvNcA@mail.gmail.com>
Message-ID: <20151129234143.GA21152@sapphire.erisian.com.au>

On Fri, Nov 27, 2015 at 09:02:37AM +0100, Mats Jerratsch via bitcoin-dev wrote:
> <private key> <public key> OP_CHECKPRIVPUBPAIR
> As there are requests for all sort of general crypto operations in
> script, we can also introduce a new general OP_CRYPTO and prepend one
> byte for the operation, so
> 0x01 OP_CRYPTO = OP_CHECKPRIVPUBPAIR
> 0x02-0xff OP_CRYPTO = OP_NOP
> to allow for extension at some later point.

This wouldn't be a softfork -- a single prefixed 0x01 byte would just
push "OP_CRYPTO" onto the stack... If you had OP_CRYPTO look at the top
item on the stack to determine what to do, you could have:

  OP_[0-16] OP_CRYPTO
  OP_PUSHDATA1 [0x11-0xFF] OP_CRYPTO
  OP_PUSHDATA2 [0x00-0xFF] [0x01-0xFF] OP_CRYPTO
  ...

to get 17 different crypto ops in two bytes, and the next 238 in three,
and be arbitrarily expandable from there with multibyte pushes.

> Alternatives:
> In the attached discussion there are some constructions that would
> allow breaking the signature scheme, but they are either very large in
> script language or expensive to calculate.

I think that's good enough to try them out in prototypes though -- and
presumably if they're demonstrably useful in prototypes that's a good
argument for adding a dedicated op code to script?

Are there any other crypto ops that might be worth adding into a BIP for
a check-verify crypto toolkit op like this? The only ones that come to mind
as having practical uses in the near term are:

 Base-point multiply on secp256k1 (ie, CHECKPUBPRIVPAIR)
 Schnorr-signature of transaction with secp256k1 curve (smaller,
   faster, more-anonymous N-of-N multisig)

But perhaps there's also uses for some of:

 General point addition on secp256k1
 General point multiply on secp256k1
 SHA3-256 / SHA2-512 / SHA3-512
 ECDSA/Schnorr signature of value from stack
 ...?

Then again, I gather that if the segregated witness soft-fork turns out
to be plausible, re-enabling/changing/adding *any* sort of opcode could
be done as a soft-fork, not just turning a NOP into CHECK_foo_VERIFY...
So it might be better to wait and see how that goes before putting too
much time into drafting a BIP or similar?

Cheers,
aj


From ctpacia at gmail.com  Mon Nov 30 03:32:34 2015
From: ctpacia at gmail.com (Chris)
Date: Sun, 29 Nov 2015 22:32:34 -0500
Subject: [bitcoin-dev] Opt-in Full Replace-By-Fee (Full-RBF)
In-Reply-To: <20151117004218.GB6302@savin.petertodd.org>
References: <20151117004218.GB6302@savin.petertodd.org>
Message-ID: <565BC352.4080001@gmail.com>

On 11/16/2015 07:42 PM, Peter Todd via bitcoin-dev wrote:
> Sequence is used for opting in as it is the only "free-form" field
> available for that purpose. Opt-in per output was proposed as well by
> Luke-Jr, however the CTxOut data structure simply doesn't contain any
> extra fields to use for that purpose.
What is wrong with using they same scheme as sighash_single?

If input 0 has nSequence < maxint-1 then output 0 is replaceable.

For fee bumps you would just stick the change in position zero and
reduce the value.

You get FFS functionality without the hassle of addition other inputs.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151129/dc16d383/attachment.html>

From jgarzik at gmail.com  Mon Nov 30 16:53:39 2015
From: jgarzik at gmail.com (Jeff Garzik)
Date: Mon, 30 Nov 2015 11:53:39 -0500
Subject: [bitcoin-dev] Test Results for : Datasstream Compression of
 Blocks and Tx's
In-Reply-To: <565A1F9F.1090005@gmail.com>
References: <565A1F9F.1090005@gmail.com>
Message-ID: <CADm_WcZMvRa6XF7-8Gmz5KONtex9Jpono=PmKzRxxX_dKB_jEA@mail.gmail.com>

Thanks for providing an in-depth, data driven analysis.

It is surprising that zlib provides better compression at the high end.  I
wonder if that is due to our specific data patterns - many zeroes - which
probably puts us into the zlib dictionary fast path.



On Sat, Nov 28, 2015 at 4:41 PM, Peter Tschipper via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi All,
>
> Here are some final results of testing with the reference implementation
> for compressing blocks and transactions. This implementation also
> concatenates blocks and transactions when possible so you'll see data sizes
> in the 1-2MB ranges.
>
> Results below show the time it takes to sync the first part of the
> blockchain, comparing Zlib to the LZOx library.  (LZOf was also tried but
> wasn't found to be as good as LZOx).  The following shows tests run with
> and without latency.  With latency on the network, all compression
> libraries performed much better than without compression.
>
> I don't think it's entirely obvious which is better, Zlib or LZO.
> Although I prefer the higher compression of Zlib, overall I would have to
> give the edge to LZO.  With LZO we have the fastest most scalable option
> when at the lowest compression setting which will be a boost in performance
> for users that want peformance over compression, and then at the high end
> LZO provides decent compression which approaches Zlib, (although at a
> higher cost) but good for those that want to save more bandwidth.
>
> Uncompressed 60ms Zlib-1 (60ms) Zlib-6 (60ms) LZOx-1 (60ms) LZOx-999
> (60ms) 219 299 296 294 291 432 568 565 558 548 652 835 836 819 811 866
> 1106 1107 1081 1071 1082 1372 1381 1341 1333 1309 1644 1654 1605 1600 1535
> 1917 1936 1873 1875 1762 2191 2210 2141 2141 1992 2463 2486 2411 2411 2257
> 2748 2780 2694 2697 2627 3034 3076 2970 2983 3226 3416 3397 3266 3302 4010
> 3983 3773 3625 3703 4914 4503 4292 4127 4287 5806 4928 4719 4529 4821 6674
> 5249 5164 4840 5314 7563 5603 5669 5289 6002 8477 6054 6268 5858 6638 9843
> 7085 7278 6868 7679 11338 8215 8433 8044 8795
>
> These results from testing on a highspeed wireless LAN (very small latency)
>
> Results in seconds
>
>
>
>
> Num blocks sync'd Uncompressed Zlib-1 Zlib-6 LZOx-1 LZOx-999 10000 255 232
> 233 231 257 20000 464 414 420 407 453 30000 677 594 611 585 650 40000 887
> 782 795 760 849 50000 1099 961 977 933 1048 60000 1310 1145 1167 1110 1259
> 70000 1512 1330 1362 1291 1470 80000 1714 1519 1552 1469 1679 90000 1917
> 1707 1747 1650 1882 100000 2122 1905 1950 1843 2111 110000 2333 2107 2151
> 2038 2329 120000 2560 2333 2376 2256 2580 130000 2835 2656 2679 2558 2921
> 140000 3274 3259 3161 3051 3466 150000 3662 3793 3547 3440 3919 160000
> 4040 4172 3937 3767 4416 170000 4425 4625 4379 4215 4958 180000 4860 5149
> 4895 4781 5560 190000 5855 6160 5898 5805 6557 200000 7004 7234 7051 6983
> 7770
>
> The following show the compression ratio acheived for various sizes of
> data.  Zlib is the clear
> winner for compressibility, with LZOx-999 coming close but at a cost.
>
> range Zlib-1 cmp%
> Zlib-6 cmp% LZOx-1 cmp% LZOx-999 cmp% 0-250b 12.44 12.86 10.79 14.34
> 250-500b  19.33 12.97 10.34 11.11 600-700 16.72 n/a 12.91 17.25 700-800
> 6.37 7.65 4.83 8.07 900-1KB 6.54 6.95 5.64 7.9 1KB-10KB 25.08 25.65 21.21
> 22.65 10KB-100KB 19.77 21.57 14.37 19.02 100KB-200KB 21.49 23.56 15.37
> 21.55 200KB-300KB 23.66 24.18 16.91 22.76 300KB-400KB 23.4 23.7 16.5 21.38
> 400KB-500KB 24.6 24.85 17.56 22.43 500KB-600KB 25.51 26.55 18.51 23.4
> 600KB-700KB 27.25 28.41 19.91 25.46 700KB-800KB 27.58 29.18 20.26 27.17
> 800KB-900KB 27 29.11 20 27.4 900KB-1MB 28.19 29.38 21.15 26.43 1MB -2MB
> 27.41 29.46 21.33 27.73
> The following shows the time in seconds to compress data of various
> sizes.  LZO1x is the
> fastest and as file sizes increase, LZO1x time hardly increases at all.
> It's interesing
> to note as compression ratios increase LZOx-999 performs much worse than
> Zlib.  So LZO is faster
> on the low end and slower (5 to 6 times slower) on the high end.
>
> range Zlib-1 Zlib-6 LZOx-1 LZOx-999 cmp% 0-250b    0.001 0 0 0 250-500b
> 0 0 0 0.001 500-1KB     0 0 0 0.001 1KB-10KB    0.001 0.001 0 0.002
> 10KB-100KB   0.004 0.006 0.001 0.017 100KB-200KB  0.012 0.017 0.002 0.054
> 200KB-300KB  0.018 0.024 0.003 0.087 300KB-400KB  0.022 0.03 0.003 0.121
> 400KB-500KB  0.027 0.037 0.004 0.151 500KB-600KB  0.031 0.044 0.004 0.184
> 600KB-700KB  0.035 0.051 0.006 0.211 700KB-800KB  0.039 0.057 0.006 0.243
> 800KB-900KB  0.045 0.064 0.006 0.27 900KB-1MB   0.049 0.072 0.006 0.307
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20151130/2bc11689/attachment-0001.html>

From peter.tschipper at gmail.com  Mon Nov 30 23:12:24 2015
From: peter.tschipper at gmail.com (Peter Tschipper)
Date: Mon, 30 Nov 2015 15:12:24 -0800
Subject: [bitcoin-dev] [BIP Draft] Datastream compression of Blocks and
	Transactions
Message-ID: <565CD7D8.3070102@gmail.com>


@gmaxwell Bip Editor, and the Bitcoin Dev Community,

After several weeks of experimenting and testing with various
compression libraries I think there is enough evidence to show that
compressing blocks and transactions is not only beneficial in reducing
network bandwidth but is also provides a small performance boost when
there is latency on the network.

The following is a BIP Draft document for your review. 
(The alignment of the columns in the tables doesn't come out looking
right in this email but if you cut and paste into a text document they
are just fine)


<pre>
  BIP: ?
  Title: Datastream compression of Blocks and Tx's
  Author: Peter Tschipper <peter.tschipper at gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2015-11-30
</pre>

==Abstract==

To compress blocks and transactions, and to concatenate them together
when possible, before sending.

==Motivation==

Bandwidth is an issue for users that run nodes in regions where
bandwidth is expensive and subject to caps, in addition network latency
in some regions can also be quite high. By compressing data we can
reduce daily bandwidth used in a significant way while at the same time
speed up the transmission of data throughout the network. This should
encourage users to keep their nodes running longer and allow for more
peer connections with less need for bandwidth throttling and in
addition, may also encourage users in areas of marginal internet
connectivity to run nodes where in the past they would not have been
able to.

==Specification==

Advertise compression using a service bit.  Both peers must have
compression turned on in order for data to be compressed, sent, and
decompressed.

Blocks will be sent compressed.

Transactions will be sent compressed with the exception of those less
than 500 bytes.

Blocks will be concatenated when possible.

Transactions will be concatenated when possible or when a
MSG_FILTERED_BLOCK is requested.

Compression levels to be specified in "bitcoin.conf".

Compression and decompression can be completely turned off.

Although unlikely, if compression should fail then data will be sent
uncompressed.

The code for compressing and decompressing will be located in class
CDataStream.

Compression library LZO1x will be used.

==Rationale==

By using a service bit, compression and decompression can be turned
on/off completely at both ends with a simple configuration setting. It
is important to be able to easily turn off compression/decompression as
a fall back mechanism.  Using a service bit also makes the code fully
compatible with any node that does not currently support compression. A
node that do not present the correct service bit will simply receive
data in standard uncompressed format.

All blocks will be compressed. Even small blocks have been found to
benefit from compression.
 
Multiple block requests that are in queue will be concatenated together
when possible to increase compressibility of smaller blocks.
Concatenation will happen only if there are multiple block requests from
the same remote peer.  For example, if peer1 is requesting two blocks
and they are both in queue then those two blocks will be concatenated.
However, if peer1 is requesting 1 block and peer2 also one block, and
they are both in queue, then each peer is sent only its block and no
concatenation will occur. Up to 16 blocks (the max blocks in flight) can
be concatenated but not exceeding the MAX_PROTOCOL_MESSAGE_LENGTH.
Concatenated blocks compress better and further reduce bandwidth.

Transactions below 500 bytes do not compress well and will be sent
uncompressed unless they can be concatenated (see Table 3).

Multiple transaction requests that are in queue will be concatenated
when possible.  This further reduces bandwidth needs and speeds the
transfer of large requests for many transactions, such as with
MSG_FILTERED_BLOCK requests, or when the system gets busy and is flooded
with transactions.  Concatenation happens in the same way as for blocks,
described above.

By allowing for differing compression levels which can be specified in
the bitcoin.conf file, a node operator can tailor their compression to a
level suitable for their system.

Although unlikely, if compression fails for any reason then blocks and
transactions will be sent uncompressed.  Therefore, even with
compression turned on, a node will be able to handle both compressed and
uncompressed data from another peer.

By Abstracting the compression/decompression code into class
"CDataStream", compression can be easily applied to any datastream.

The compression library LZO1x-1 does not compress to the extent that
Zlib does but it is clearly the better performer (particularly as file
sizes get larger), while at the same time providing very good
compression (see Tables 1 and 2).  Furthermore, LZO1x-999 can provide
and almost Zlib like compression for those who wish to have more
compression, although at a cost.

==Test Results==

With the LZO library, current test results show up to a 20% compression
using LZO1x-1 and up to 27% when using LZO1x-999.  In addition there is
a marked performance improvement when there is latency on the network.
>From the test results, with a latency of 60ms there is an almost 30%
improvement in performance when comparing LZO1x-1 compressed blocks with
uncompressed blocks (see Table 5).

The following table shows the percentage that blocks were compressed,
using two different Zlib and LZO1x compression level settings.

TABLE 1:
range = data size range
range           Zlib-1  Zlib-6  LZO1x-1 LZO1x-999
-----------     ------  ------  ------- --------
0-250           12.44   12.86   10.79   14.34
250-500         19.33   12.97   10.34   11.11   
600-700         16.72   n/a     12.91   17.25
700-800         6.37    7.65    4.83    8.07
900-1KB         6.54    6.95    5.64    7.9
1KB-10KB        25.08   25.65   21.21   22.65
10KB-100KB      19.77   21.57   4.37    19.02
100KB-200KB     21.49   23.56   15.37   21.55
200KB-300KB     23.66   24.18   16.91   22.76
300KB-400KB     23.4    23.7    16.5    21.38
400KB-500KB     24.6    24.85   17.56   22.43
500KB-600KB     25.51   26.55   18.51   23.4
600KB-700KB     27.25   28.41   19.91   25.46
700KB-800KB     27.58   29.18   20.26   27.17
800KB-900KB     27      29.11   20      27.4
900KB-1MB       28.19   29.38   21.15   26.43
1MB -2MB        27.41   29.46   21.33   27.73

The following table shows the time in seconds that a block of data takes
to compress using different compression levels.  One can clearly see
that LZO1x-1 is the fastest and is not as affected when data sizes get
larger.

TABLE 2:
range = data size range
range           Zlib-1  Zlib-6  LZO1x-1 LZO1x-999
-----------     ------  ------  ------- ---------
0-250           0.001   0       0       0
250-500         0       0       0       0.001
500-1KB         0       0       0       0.001
1KB-10KB        0.001   0.001   0       0.002
10KB-100KB      0.004   0.006   0.001   0.017
100KB-200KB     0.012   0.017   0.002   0.054
200KB-300KB     0.018   0.024   0.003   0.087
300KB-400KB     0.022   0.03    0.003   0.121
400KB-500KB     0.027   0.037   0.004   0.151
500KB-600KB     0.031   0.044   0.004   0.184
600KB-700KB     0.035   0.051   0.006   0.211
700KB-800KB     0.039   0.057   0.006   0.243
800KB-900KB     0.045   0.064   0.006   0.27
900KB-1MB       0.049   0.072   0.006   0.307

TABLE 3:
Compression of Transactions (without concatenation)
range = block size range
ubytes = average size of uncompressed transactions
cbytes = average size of compressed transactions
cmp% = the percentage amount that the transaction was compressed
datapoints = number of datapoints taken

range       ubytes    cbytes    cmp%    datapoints
----------  ------    ------    ------  ----------    
0-250       220       227       -3.16   23780
250-500     356       354       0.68    20882
500-600     534       505       5.29    2772
600-700     653       608       6.95    1853
700-800     757       649       14.22   578
800-900     822       758       7.77    661
900-1KB     954       862       9.69    906
1KB-10KB    2698      2222      17.64   3370
10KB-100KB  15463     12092     21.80   15429

The above table shows that transactions don't compress well below 500
bytes but do very well beyond 1KB where there are a great deal of those
large spam type transactions.   However, most transactions happen to be
in the < 500 byte range.  So the next step was to appy concatenation for
those smaller transactions.  Doing that yielded some very good
compression results.  Some examples as follows:

The best one that was seen was when 175 transactions were concatenated
before being compressed.  That yielded a 20% compression ratio, but that
doesn't take into account the savings from the unneeded 174 message
headers (24 bytes each) as well as 174 TCP ACKs of 52 bytes each which
yields and additional 76*174 = 13224 byte savings, making for an overall
bandwidth savings of 32%:

     2015-11-18 01:09:09.002061 compressed data from 79890 to 67426
txcount:175

However, that was an extreme example.  Most transaction aggregates were
in the 2 to 10 transaction range.  Such as the following:

     2015-11-17 21:08:28.469313 compressed data from 3199 to 2876 txcount:10

But even here the savings of 10% was far better than the "nothing" we
would get without concatenation, but add to that the 76 byte * 9
transaction savings and we have a total 20% savings in bandwidth for
transactions that otherwise would not be compressible.  Therefore the
concatenation of small transactions can also save bandwidth and speed up
the transmission of those transactions through the network while keeping
network and message queue chatter to a minimum.

==Choice of Compression library==

LZO was chosen over Zlib.  LZO is the fastest most scalable option when
used at the lowest compression setting which will be a performance boost
for users that prefer performance over bandwidth savings. And at the
higher end, LZO provides good compression (although at a higher cost)
which approaches that of Zlib.

Other compression libraries investigated were Snappy, LZOf, fastZlib and
LZ4 however none of these were found to be suitable, either because they
were not portable, lacked the flexibility to set compression levels or
did not provide a useful compression ratio.

The following two tables show results in seconds for syncing the first
200,000 blocks. Tests were run on a high-speed wireless LAN with very
little latency, and also run with a 60ms latency which was induced with
"Netbalancer".
               
TABLE 4:
Results shown in seconds on highspeed wireless LAN (no induced latency)
Num blks sync'd  Uncmp  Zlib-1  Zlib-6  LZO1x-1  LZO1x-999
---------------  -----  ------  ------  -------  ---------
10000            255    232     233     231      257      
20000            464    414     420     407      453      
30000            677    594     611     585      650      
40000            887    787     795     760      849     
50000            1099   961     977     933      1048   
60000            1310   1145    1167    1110     1259  
70000            1512   1330    1362    1291     1470  
80000            1714   1519    1552    1469     1679   
90000            1917   1707    1747    1650     1882  
100000           2122   1905    1950    1843     2111    
110000           2333   2107    2151    2038     2329  
120000           2560   2333    2376    2256     2580   
130000           2835   2656    2679    2558     2921 
140000           3274   3259    3161    3051     3466   
150000           3662   3793    3547    3440     3919   
160000           4040   4172    3937    3767     4416   
170000           4425   4625    4379    4215     4958   
180000           4860   5149    4895    4781     5560    
190000           5855   6160    5898    5805     6557    
200000           7004   7234    7051    6983     7770   

TABLE 5:
Results shown in seconds with 60ms of induced latency
Num blks sync'd  Uncmp  Zlib-1  Zlib-6  LZO1x-1  LZO1x-999
---------------  -----  ------  ------  -------  ---------
10000            219    299     296     294      291
20000            432    568     565     558      548
30000            652    835     836     819      811
40000            866    1106    1107    1081     1071
50000            1082   1372    1381    1341     1333
60000            1309   1644    1654    1605     1600
70000            1535   1917    1936    1873     1875
80000            1762   2191    2210    2141     2141
90000            1992   2463    2486    2411     2411
100000           2257   2748    2780    2694     2697
110000           2627   3034    3076    2970     2983
120000           3226   3416    3397    3266     3302
130000           4010   3983    3773    3625     3703
140000           4914   4503    4292    4127     4287
150000           5806   4928    4719    4529     4821
160000           6674   5249    5164    4840     5314
170000           7563   5603    5669    5289     6002
180000           8477   6054    6268    5858     6638
190000           9843   7085    7278    6868     7679
200000           11338  8215    8433    8044     8795

==Backward compatibility==

Being unable to present the correct service bit, older clients will
continue to receive standard uncompressed data and will be fully
compatible with this change.

==Fallback==

It is important to be able to entirely and easily turn off compression
and decompression as a fall back mechanism. This can be done with a
simple bitcoin.conf setting of "compressionlevel=0". Only one of the two
connected peers need to set compressionlevel=0 in order to turn off
compression and decompression completely.

==Deployment==

This enhancement does not require a hard or soft fork.

==Service Bit==

During the testing of this implementation, service bit 28 was used,
however this enhancement will require a permanently assigned service bit.

==Implementation==

This implementation depends on the LZO compression library: lzo-2.09

     https://github.com/ptschip/bitcoin/tree/compress

==Copyright==

This document is placed in the public domain.



