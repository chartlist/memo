From pete at petertodd.org  Sun Feb  2 02:36:51 2014
From: pete at petertodd.org (Peter Todd)
Date: Sat, 1 Feb 2014 21:36:51 -0500
Subject: [Bitcoin-development] (space) efficient reusable addr via weil
 pairing IBE (Re: Bait for reusable addresses)
In-Reply-To: <20140125161901.GA17457@netbook.cypherspace.org>
References: <CAAS2fgQmsxjkQFSiCdeMoVMaqq5720KpUpdkKZOE+XytHsWw0w@mail.gmail.com>
	<20140124090218.GA15398@savin>
	<CANEZrP0MnXr4xjaMPg7v7vTiDQr-y7esvEBE=xk=Y0BUGXak9A@mail.gmail.com>
	<20140124154235.GA3741@netbook.cypherspace.org>
	<20140124161330.GA31233@petertodd.org>
	<20140125161901.GA17457@netbook.cypherspace.org>
Message-ID: <20140202023651.GA18666@savin>

On Sat, Jan 25, 2014 at 05:19:01PM +0100, Adam Back wrote:
> I think I figured out a proof of existance for a space efficient way to do
> better than bloom filters/prefix/bloom-bait.  (Must have been dreaming on it
> as I woke up with the idea following Peter's suggestion to try prove instead
> if its possible or not:).
> 
> I wrote up the details here:
> 
> https://bitcointalk.org/index.php?topic=431756.new

One of the main reasons I post to the bitcoin-development mailing list
rather than the forum is because the mailing list is archived by many
different, independent, parties. The forum is not - as an example
archive.org didn't have that URL until I manually told it to archive it.

So I'm taking the liberty of reposting your two posts there below:

[quote author=adam3us link=topic=431756.msg4729682#msg4729682
date=1390660452]
So have been talking with Greg Maxwell, Peter Todd, Jeremy Spillman,
Mike Hearn, Bytecoin and others about reusable addresses.

There is a summary of the situation here
http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03792.html
and I had posed th question of whether it was possible to do better at
all with Peter Todd:

[quote author=adam3us on bitcoin-dev]
Now while it would be clearly a very nice win if reusable addresses
could be  made SPV-like in network characteristics and privacy, but we
dont have a plausible mechanism yet IMO.  Close as we got was Greg's
enhancement of my/your "bloom bait"/"prefix" concept to make multiple
candidate baits to provide some ambiguity (still allows elimination,
just slightly less of it).

If we can find some efficient crypto to solve that last one, we could
even adopt them generally if it was efficient enough without needing
interactive one-use address release
[/quote]

and Peter proposed also the related problem of proving something about
that existence or not of a solution to that problem.

I think I have a proof-of-concept solution that proves by example we can
do better in space efficiency, linkability defense and non-interactivity
than my bloom bait, Peter Todds related prefix; and Greg Maxwell's
extended bloom bait described
http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03705.html.

So the idea is to use an IBE scheme as a building block in analogous way
to my 1996 problem statement for NIFS and 1998 observation that a novel
use for an IBE scheme can provide a generic solution to NIFS, and the
arrival in 2001 of the first efficient / sensible trapdoor steepness (*)
IBE with the introduction of the Weil Pairing problem by Dan Boneh and
Matt Franklin described here
http://en.wikipedia.org/wiki/Boneh%E2%80%93Franklin_scheme.

Greg summarized IBE as follows on IRC:

[quote]
(for those who may) not be familar with IBE stuff: The idea is that the
user has a master private key, which results in a master public key.
Anyone can take a prior block hash and combine it with the master public
key to get a session pubkey which could be used to encrypt a chaincode
included in an OP_RETURN.   Using the master private key the user can
derrive the session private key, which can then be used to recognize
transactions using the same session key.

In IBE (identity based encryption) this is all used a bit differently:
the master keys are held by a CA, and the session ID is your email
address, and now anyone can make a public key for you? but you need the
CA's help to get your private key)
[/quote]

Basically as Greg said your public key is your address (an email
address, a block hash, whatever is convenient and unique) and from that
and the master public key of the IBE server, the server can compute a
private key corresponding to that.  The master public is usually
considered to be a system-wide domain parameter.   Naturally enough
because a side effect of this is that the IBE server can decrypt
everyones email people were never too excited about the prospect.

However my 1998 NIFS observation is by acting as your own IBE server
(each user creates their own master public server key) they can create a
sequence (NIFS) or set (bitcoin reusable address) of public keys with
interesting and publicly derivable properties!

It is my conclusion from 1996 that to solve this with DL directly at
least in the NIFS case appears to be not possible.


So basically the reusable address becomes an IBE public key, the
existing public derivation via DH or EC Elgamal/ECIES or whatever
variant (bytecoins, mine, Peter Todd/Amir Taaki's) arrives at a factor
that can be recovered.  So with my variant (random sender generated
multiplication factor encrypted with ECIES) you could encrypt the factor
with a pub=IBE-extract(master pub, id=previous block hash) using the
previous block hash as the "identity" and the users own self-owned IBE
"server".

For Bytecoin & Peter Todd/Amir Taaki EC DH version using input or
auxilliary addresses to save space its not even necessary to send the
factor, its already sent.  So then you send a separate message to do
with secure delegatable filtering, a more secure/more space efficient
bloom filter/prefix replacement, and this is a more flexible structure.

So the secure delegatable filter is you separately add an encrypted
bloom bait Greg suggested (eg 1byte prefix communicated with public
address.)  And you can even combine that with Greg's extended bloom bait
above to add anonymity set within the block.

Consequently you can now securely and very network/space efficiently
securely delegate searching a block by computing the private key for the
IBE pub key that any sender would use for that block, and sending it as
a query to a random (or node-capture defended random selected node).
The node can decrypt the encrypted bloom baits with it, but remains
powerless to correlate with bloom baits to other payments received by
the same user in bother blocks.

(In practice you might need an epoch not block or overlapping test
because the user does not have full assurance of their tx ending up in
the pending block).

About weil pairing, and new hardness crypto risk, this is also the
hardness assumption under some ZK-SNARKs as I think used in zerocash,
and while ZK-SNARK introduces its own complexity/crypto system risk on
top; in my view weil pairing is slightly lower assurance/review not so
widely used relative to EC DL problem.  Anyway the interesting thing to
say about that is in the event this scheme got broken in the future it
falls back to the scheme that is being proposed using prefix.  Ie its no
worse than that from linkability and likely would retain some cost even
if broken-- asymmetric crypto breaks are usually somewhat gradual.

This looks more expensive and non-indexable though I didnt look to see
if there is any ciphertext only or batch precomputation that could be
squeezed out of it.

Obviously its more CPU intensive and some eg fee mechanism to prevent
node DoS could be nice, but it seems to demonstrate a proof by existence
that it is possible to do better.


Finally I think it maybe within possibility to do further than this
because it is not technically necessary to delegate decryption, only to
delegate filtering, which can be a simpler requirement.

Adam

(*) There was an earlier scheme by Maurer et al if I recall, but to get
a 1024-bit security margin you had to perform a discrete log attack on a
512-bit prime, so the key generation cost was immense, hence "sensible
trapdoor steepness" thats very shallow in tems of work difference
between setup cost and crypto system strength.
[/quote]

------

[quote author=adam3us link=topic=431756.msg4732503#msg4732503
date=1390669542]
[quote author=Mike Hearn link=topic=431756.msg4730986#msg4730986
date=1390664867]
You would need epochs for another reason. Recall that with Bloom
filtering the remote node is asked for blocks in batches of 500 at a
time and the remote end handles updating the filter as transactions are
matched. This is to avoid the performance hit of a network round-trip
for every block.
[/quote]

I see I dont think I realized that aspect of how bloom query works.  So
you then with IBE-based filtering could send multiple keys, one for each
block; but you are implicitly linked by being in one query, so you'd
just as well mark your key with your preferred epoch size and sender
uses epoch number in the query.

I think Greg is pointing out on IRC that by having a fairly small epoch
you can choose later to go down to that epoch size or scale up by
sending multiple epoch keys in a batch, a privacy/network round-trip
trade off.

Re my other problem with epochs ("In practice you might need an epoch
not block or overlapping test because the user does not have full
assurance of their tx ending up in the pending block") I think that
maybe fixable, if the blocknumber is chosen by the sender, and
communicated in enough bits to be mostly unambiguous in the message.
Then the node can index them by sen block num and no ambiguity.

It could be that another way to partly obscure ownership of queries
would be to relay queries and responses and mix other peoples queries
with your own in a batch, however as we are considering the SPV client
case relaying other peoples queries seems hard to gather query traffic
on demand and to use more bandwidth than it saves relative just issuing
smaller batches.

You could have relaying in the network eg using the embedded Tor but
waiting for queries to mix with adds latency, and suffers flood attacks
on mix-nets (send fake encrypted query traffic to flush out a tx, that
has no-anon set vs the person doing the flooding who can distinguish
their own queries).

Adam

[/quote]

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140201/b8c8c0cb/attachment.sig>

From jeremy at taplink.co  Sun Feb  2 09:16:20 2014
From: jeremy at taplink.co (Jeremy Spilman)
Date: Sun, 02 Feb 2014 01:16:20 -0800
Subject: [Bitcoin-development] (space) efficient reusable addr via weil
 pairing IBE (Re: Bait for reusable addresses)
In-Reply-To: <20140202023651.GA18666@savin>
References: <CAAS2fgQmsxjkQFSiCdeMoVMaqq5720KpUpdkKZOE+XytHsWw0w@mail.gmail.com>
	<20140124090218.GA15398@savin>
	<CANEZrP0MnXr4xjaMPg7v7vTiDQr-y7esvEBE=xk=Y0BUGXak9A@mail.gmail.com>
	<20140124154235.GA3741@netbook.cypherspace.org>
	<20140124161330.GA31233@petertodd.org>
	<20140125161901.GA17457@netbook.cypherspace.org>
	<20140202023651.GA18666@savin>
Message-ID: <op.xanddiq6yldrnw@laptop-air>

>
> Consequently you can now securely and very network/space efficiently
> securely delegate searching a block by computing the private key for the
> IBE pub key that any sender would use for that block, and sending it as
> a query to a random (or node-capture defended random selected node).
> The node can decrypt the encrypted bloom baits with it, but remains
> powerless to correlate with bloom baits to other payments received by
> the same user in bother blocks.
>

I'm not sure I've fully wrapped my head around it.

   d/Q        - Identity key
   E          - Generate an epoch-pubkey: E = Q * H1(epoch)
   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs
   S = r * K  - Shared secret (ECDE)

Payer derives an encryption key H(S), and encrypts M, which is a 1 byte  
bloom bait.

For each epoch, payee generates e = d * H1(epoch) and provides the key to  
a full node for monitoring. So you are providing a per-block or per-epoch  
private key, along with the block ID or epoch ID that the key corresponds  
to.

The full node then uses this privkey to decrypt the same byte in all the  
transactions in that epoch/block which match the expected layout/template,  
e.g. given a certain length OP_RETURN, pull the specific byte and decrypt.

This decrypted byte is then in turn used as bloom bait which may or may  
not cause the transaction to be sent back to the SPV client.

Am I right in saying the full node has no idea if decryption is  
'succeeding' it just feeds the resultant bait into the bloom filter and  
the transaction may match or not? So we do get some level of repudiation  
by the SPV client -- the server doesn't know exactly which transactions  
belong to the SPV client.

The bloom bait specified in the reusable address is still making the  
bandwidth/privacy trade-off, it just doesn't become public information,  
because it's protected by another factor?

What encryption scheme is being used here?

-=-=-=-==

Another approach (inspired by IBE) which narrows the discoverability of  
transactions to the nodes that your SPV client is actually communicating  
with, for the specific blocks/epochs that you specify, would be to use  
PEKS.

PEKS(Q, W) for a public key Q and a keyword W produces a searchable  
encryption of the word W.

The payee holding 'd' (privkey for Q) can create a trapdoor which allows a  
server to search for transactions with W, where the searching party only  
knows if a match is found or not.

Payer:

   d/Q   - Longstanding / identity privkey/pubkey
   r/P   - Ephemeral privkey/pubkey, or discoverable from inputs
   W     - Searchable Keyword
   H1    - Hash function, {0, 1} ? ? G1
   H2    - Hash function, G2 ? {0, 1}p

Secret, as usual per ECDH:

   S = r * Q

For payer to create the searchable encryption of W for Q, called 'Sw':

   Sw = H2(e(H1(W), S))
   OP_RETURN P, Sw

For payee to search for a given 'W', payee calculates a trapdoor 'Tw':

   Tw = d * H1(W)

For a searcher, given a Trapdoor (Tw), check each Transaction (P, Sw):

   H2(e(Tw, P)) ==? Sw
   If the values match, the keyword matches

Without getting into the concepts of e(g,g) and binomial pairing, I think  
of it this way:

   Sw = H2(r * Q * H1(W)), but recall: rQ == dP, so...
      = H2(d * P * H1(W)), which can be written
      = H2(d * H1(W) * P)

Severs finds all transactions with 'P' on relevant parts of the  
blockchain, multiplies by the provided trapdoor 'Tw', applies 'H2', and  
checks for a matching 'Sw' in the transaction;

   Tw = d * H1(W)
   Sw = H2(Tw * P)
        H2(d * H1(W) * P)

PEKS is vulnerable to an offline keyword guessing attack, where you can  
discover the value of the keyword being searched, if the keyword is low  
entropy. The server/attacker can figure out the value of W, but they can't  
generate their own trapdoors to search for other keywords.

But in this case, the 'keyword' can simply be the block ID / epoch ID  
itself, not a secret value at all. In other words, the server can only  
search for your transactions within the blocks/epochs that you specify.

Using blockID/epochID as W, this would allow a server to find all  
transactions belonging to the payer for that blockID / epochID. The SPV  
client would simply provide the trapdoor for each block/epoch to be  
searched.

There are extensions to PEKS which provide for 'fuzzy' matching but they  
are 'fuzzy' within the scope of Q, not across different Q, so that doesn't  
help provide any repudiation. So I see this as only slightly improving  
Peter's original proposal of providing 'Q' to the searcher, but if you  
want repudiation, not as good as Adam's solution.

Perfunctory disclaimer... Hopefully this is close to correct, but please  
don't anyone actually try to implement this!

Thanks,
Jeremy




From pete at petertodd.org  Sun Feb  2 11:55:31 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 2 Feb 2014 06:55:31 -0500
Subject: [Bitcoin-development] (space) efficient reusable addr via weil
 pairing IBE (Re: Bait for reusable addresses)
In-Reply-To: <20140202023651.GA18666@savin>
References: <CAAS2fgQmsxjkQFSiCdeMoVMaqq5720KpUpdkKZOE+XytHsWw0w@mail.gmail.com>
	<20140124090218.GA15398@savin>
	<CANEZrP0MnXr4xjaMPg7v7vTiDQr-y7esvEBE=xk=Y0BUGXak9A@mail.gmail.com>
	<20140124154235.GA3741@netbook.cypherspace.org>
	<20140124161330.GA31233@petertodd.org>
	<20140125161901.GA17457@netbook.cypherspace.org>
	<20140202023651.GA18666@savin>
Message-ID: <20140202115531.GA22375@savin>

> On Sat, Jan 25, 2014 at 05:19:01PM +0100, Adam Back wrote:
> [quote author=adam3us link=topic=431756.msg4729682#msg4729682
> date=1390660452]
> So have been talking with Greg Maxwell, Peter Todd, Jeremy Spillman,
> Mike Hearn, Bytecoin and others about reusable addresses.
> 
> There is a summary of the situation here
> http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03792.html
> and I had posed th question of whether it was possible to do better at
> all with Peter Todd:

You're explanation is a bit long-winded, so I'll start with a simplified
ECC-based version first and later explain how identity-based encryption
applies to the problem; I have a feeling not many non-crypt-experts
spent the time to figure out what you're talking about; do check if what
I've written below is correct:

So Alice wants to pay Bob, who is bandwidth constrained and frequently
offline. Meanwhile Ivan has a full node, but can't really be trusted.
Meanwhile Eve is busy trying to piece together everyones' financial
details.

Bob publicly publishes three pubkeys, Filter, Recover, and Spend, along
with a short n-bit prefix p. When Alice needs to pay Bob she creates a
ephemeral keypair and uses ECDH *two* shared secrets, n_f and n_r, from
Bob's Filter and Recover pubkeys respectively. She makes a transaction
that pays Bob by deriving pubkey Spend_{n_f} from the Spend and n_r
nonce.  She also uses the Filter nonce and the prefix to derive a
encrypted prefix p'=n_f^p and puts that prefix and the cleartext
ephemeral pubkey in the transaction as data.

When Bob wants to find that transaction he gives the prefix and Filter
secret key to Ivan, who then scans the blockchain. For every transaction
he computes n_f=ECDH(Filter_sec, Ephm_pub), extracts the encrypted
prefix p' from the transaction, and checks if p'=n_f^p If so he gives
that transaction to Bob who can then use his Recover secret key to check
if the transaction was in fact for him. (note how the prefix can
actually always be simply a given length of zeros)

Because Bob's prefix is short Ivan only learns probabalistic information
about what transactions might be Bob's. Eve doesn't know the Filter
secret key, and thus learns nothing at all from the blockchain data. On
the other hand after getting the key once Ivan can forever after get
that probability information about what transactions might be Bob's.

What we'd really like is for there to be some way for Alice to derive a
time-limited Filter pubkey from some public random beacon with value
R_i, such as the Bitcoin blockchain, such that each defined time
interval uses a different key. Bob would then only give Ivan the secret
key(s) for the time interval(s) in question.

Unfortunately ECDSA doesn't have a way to do this. The closest thing
available is BIP32-style key derivation, however it has the property
that given a derived secret key and known master pubkey the master
secret key can be derived. Thus Ivan can simply try every public Filter
key/epoch tweak he knows about until he finds Q,d' st. (d+d')G=Q+d'G
From that he can recover d, reducing the security to where we started.
(or put another way, Ivan can store every (d+d') secret key he is asked
to search with, and test it against every public key he learns about
later)

Identity-based cryptograhy however can do that. Bob publishes a (single)
master public key, and anyone can derive public keys based on that
master key and the random beacon value R_i. Bob can then derive the
corresponding secret key, but unlike with ECDSA, that secret key *can't*
be used to derive the master private key. Having said that, it can of
course be linked to that key, so every query that Bob makes gives Ivan
some knowledge about what transactions might be in Bob's wallet.

Problem is, who the hell has a production-ready Weil pairing library
kicking around? (is this read? http://crypto.stanford.edu/pbc/) Also,
Weil pairing is not yet trustworthy:

    < gmaxwell> (IMO thats how we should be using pairing in
    cryptosystems: for lower value applications, and solving things that
    can't be solved any other way)

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140202/ce7414ce/attachment.sig>

From pete at petertodd.org  Sun Feb  2 12:26:10 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 2 Feb 2014 07:26:10 -0500
Subject: [Bitcoin-development] (space) efficient reusable addr via weil
 pairing IBE (Re: Bait for reusable addresses)
In-Reply-To: <op.xanddiq6yldrnw@laptop-air>
References: <CAAS2fgQmsxjkQFSiCdeMoVMaqq5720KpUpdkKZOE+XytHsWw0w@mail.gmail.com>
	<20140124090218.GA15398@savin>
	<CANEZrP0MnXr4xjaMPg7v7vTiDQr-y7esvEBE=xk=Y0BUGXak9A@mail.gmail.com>
	<20140124154235.GA3741@netbook.cypherspace.org>
	<20140124161330.GA31233@petertodd.org>
	<20140125161901.GA17457@netbook.cypherspace.org>
	<20140202023651.GA18666@savin> <op.xanddiq6yldrnw@laptop-air>
Message-ID: <20140202122610.GA22329@savin>

On Sun, Feb 02, 2014 at 01:16:20AM -0800, Jeremy Spilman wrote:
> >
> >Consequently you can now securely and very network/space efficiently
> >securely delegate searching a block by computing the private key for the
> >IBE pub key that any sender would use for that block, and sending it as
> >a query to a random (or node-capture defended random selected node).
> >The node can decrypt the encrypted bloom baits with it, but remains
> >powerless to correlate with bloom baits to other payments received by
> >the same user in bother blocks.
> >
> 
> I'm not sure I've fully wrapped my head around it.
> 
>   d/Q        - Identity key
>   E          - Generate an epoch-pubkey: E = Q * H1(epoch)
>   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs
>   S = r * K  - Shared secret (ECDE)

There needs to be two separate payor pubkeys, which I called elsewhere
the "Filter" and "Recover" pubkeys - the latter I think corresponds to
what you meant by identity key. From those two pubkeys two separate
shared secrets are derived.

The key idea is that you can encrypt a short string of zeros with the
"Filter" pubkey using ECDH and place the resulting "filter bait" in the
transaction. This lets the payor give the secret key corresponding to
that pubkey to a semi-trusted third party. That third party can then
trial decrypt all filter bait seen in transactions in the blockchain,
and every time the decrypted string has a sufficient number of zeros
it's considered a filter pass and the transaction is given to the payor.
For n zero bits one in 2^n transactions will match at random, which sets
your false positive rate.

Basically think of it as a way to outsource the work required for
zero-prefix stealth addresses, but with (less) of a sacrifice of
anonymity compared to just giving the third-party your recovery pubkey.
Identity-based encryption only comes into it because it's nice to be
able to further limit what transactions the server knows about to
specific time intervals rather than forver into the future.

Interestingly both schemes can be used at once - a short public prefix
combined with a second private filter. What's interesting there is that
the public prefix can do a first-pass filtering, with the second private
filter relatively long but still providing plausible deniability - you
can always claim 100% of the matching transactions were false positives
because you didn't receive any funds!

> The full node then uses this privkey to decrypt the same byte in all
> the transactions in that epoch/block which match the expected
> layout/template, e.g. given a certain length OP_RETURN, pull the
> specific byte and decrypt.
> 
> This decrypted byte is then in turn used as bloom bait which may or
> may not cause the transaction to be sent back to the SPV client.

There's no bloom filters involved; as I said before "bloom bait" is a
misleading name. "Filter bait" is a better term given it's a generic
concept.

> What encryption scheme is being used here?

XOR with the ECDH-calculated nonce is fine. (run the nonce though a hash
function first)

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140202/873aaab8/attachment.sig>

From adam at cypherspace.org  Sun Feb  2 15:26:24 2014
From: adam at cypherspace.org (Adam Back)
Date: Sun, 2 Feb 2014 16:26:24 +0100
Subject: [Bitcoin-development] (space) efficient reusable addr via weil
 pairing IBE (Re: Bait for reusable addresses)
In-Reply-To: <20140202122610.GA22329@savin>
References: <CAAS2fgQmsxjkQFSiCdeMoVMaqq5720KpUpdkKZOE+XytHsWw0w@mail.gmail.com>
	<20140124090218.GA15398@savin>
	<CANEZrP0MnXr4xjaMPg7v7vTiDQr-y7esvEBE=xk=Y0BUGXak9A@mail.gmail.com>
	<20140124154235.GA3741@netbook.cypherspace.org>
	<20140124161330.GA31233@petertodd.org>
	<20140125161901.GA17457@netbook.cypherspace.org>
	<20140202023651.GA18666@savin> <op.xanddiq6yldrnw@laptop-air>
	<20140202122610.GA22329@savin>
Message-ID: <20140202152624.GA22093@netbook.cypherspace.org>

I think you Peter & Jeremy figured it out - dont disagree with the
explanation details.

And it seems better explained between the two posts than I did.  I think
Peter is right that you do not need an explicit prefix, the prefix after
decryption can be a chosen number of leading 0s and this gives a tunable
amount of false positives.  You already have privacy becaue the query is
only revealed to the semi-trusted full node, and its query scope is limited
to one or a chosen batch of blocks.  But you can if desired add additional
ambiguity as Peter described by reducing the number of bits of 0 in the
decrypted block.  There is no need for matching a specific prefix as its
already a recipient specific calculation.  (It means the actual encrypted
value where it is chosen would have to mimic false positives: random with
n-bits of trailing 0s and expected probability distribution).

It should be compatible for combining with sharding or public prefixes, as
Peter mentioned but for short public prefixes those still has some (reduced)
blockchain ledger logged possibility to reduce anonymity set when combined
with flow analysis.

Maybe you could vary a public prefix per block.  Eg the public prefix for a
given user is the LSBits of the per block IBE derived pubic key for a given
user.  I am not sure if that helps or hinders.  Maybe it hurts anonymity set
because the analyst (Eve) is given multiple chances over time to exclude an
analysed flow candidate.

It would desirable to find a non-IBE way to do this.  (And more
computationally efficient / precomputable / indexable)

Or you could use different address types depending on the circumstance:
one-use, stealth, or IBE.  Kind of difficult to automate that (to know what
the user is planning to do with it) and avoid user confusion.  Clearly users
are quite confused and the convenient and understandable thing is to have a
(safely) reusable address.

Adam

On Sun, Feb 02, 2014 at 07:26:10AM -0500, Peter Todd wrote:
>On Sun, Feb 02, 2014 at 01:16:20AM -0800, Jeremy Spilman wrote:
>> >
>> >Consequently you can now securely and very network/space efficiently
>> >securely delegate searching a block by computing the private key for the
>> >IBE pub key that any sender would use for that block, and sending it as
>> >a query to a random (or node-capture defended random selected node).
>> >The node can decrypt the encrypted bloom baits with it, but remains
>> >powerless to correlate with bloom baits to other payments received by
>> >the same user in bother blocks.
>> >
>>
>> I'm not sure I've fully wrapped my head around it.
>>
>>   d/Q        - Identity key
>>   E          - Generate an epoch-pubkey: E = Q * H1(epoch)
>>   r/P        - Ephemeral privkey/pubkey, or discoverable from inputs
>>   S = r * K  - Shared secret (ECDE)
>
>There needs to be two separate payor pubkeys, which I called elsewhere
>the "Filter" and "Recover" pubkeys - the latter I think corresponds to
>what you meant by identity key. From those two pubkeys two separate
>shared secrets are derived.
>
>The key idea is that you can encrypt a short string of zeros with the
>"Filter" pubkey using ECDH and place the resulting "filter bait" in the
>transaction. This lets the payor give the secret key corresponding to
>that pubkey to a semi-trusted third party. That third party can then
>trial decrypt all filter bait seen in transactions in the blockchain,
>and every time the decrypted string has a sufficient number of zeros
>it's considered a filter pass and the transaction is given to the payor.
>For n zero bits one in 2^n transactions will match at random, which sets
>your false positive rate.
>
>Basically think of it as a way to outsource the work required for
>zero-prefix stealth addresses, but with (less) of a sacrifice of
>anonymity compared to just giving the third-party your recovery pubkey.
>Identity-based encryption only comes into it because it's nice to be
>able to further limit what transactions the server knows about to
>specific time intervals rather than forver into the future.
>
>Interestingly both schemes can be used at once - a short public prefix
>combined with a second private filter. What's interesting there is that
>the public prefix can do a first-pass filtering, with the second private
>filter relatively long but still providing plausible deniability - you
>can always claim 100% of the matching transactions were false positives
>because you didn't receive any funds!
>
>> The full node then uses this privkey to decrypt the same byte in all
>> the transactions in that epoch/block which match the expected
>> layout/template, e.g. given a certain length OP_RETURN, pull the
>> specific byte and decrypt.
>>
>> This decrypted byte is then in turn used as bloom bait which may or
>> may not cause the transaction to be sent back to the SPV client.
>
>There's no bloom filters involved; as I said before "bloom bait" is a
>misleading name. "Filter bait" is a better term given it's a generic
>concept.
>
>> What encryption scheme is being used here?
>
>XOR with the ECDH-calculated nonce is fine. (run the nonce though a hash
>function first)
>
>-- 
>'peter'[:-1]@petertodd.org
>000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0





From tim at go-taxi.biz  Mon Feb  3 18:08:47 2014
From: tim at go-taxi.biz (Tim Tuxworth)
Date: Mon, 03 Feb 2014 11:08:47 -0700
Subject: [Bitcoin-development] BIP70: Canceling Payments
Message-ID: <52EFDB2F.3040604@go-taxi.biz>

The process described in BIP70 might be ok for a simple "happy path" 
scenario, but what if things don't work so smoothly. I'm not talking 
here about technical issues, but _very common_ business scenarios such as:

e.g. Merchant cancels request before payment is sent, such as when:-
- the merchant realizes that they charged the wrong amount
- the merchant realizes that they send the payment request to the wrong 
customer
...

e.g. the Merchant or Customer decides to cancel the transaction after 
the payment request is sent because:-
- the customer decides to pay by some other mechanism like cash or 
credit/debit
- the customer doesn't have sufficient funds and decides not to purchase
- the customer changes their mind and decides not to purchase
...

It strikes me that a "Cancel Payment Request" message is required
and a "Reject Payment Request" may also be required (or maybe use the 
same message for both).

Tim Tuxworth



From christophe.biocca at gmail.com  Mon Feb  3 18:49:07 2014
From: christophe.biocca at gmail.com (Christophe Biocca)
Date: Mon, 3 Feb 2014 13:49:07 -0500
Subject: [Bitcoin-development] BIP70: Canceling Payments
In-Reply-To: <52EFDB2F.3040604@go-taxi.biz>
References: <52EFDB2F.3040604@go-taxi.biz>
Message-ID: <CANOOu=8oCKVXLHMVAgZyhE1DZ4i==o0dYom9Fe3day6oSQBhRA@mail.gmail.com>

Over http, the merchant doesn't have the ability to reach out to the
consumer's bitcoin wallet on their own. So sending "Cancel Payment
Request" to the user is impossible.

If the customer doesn't want to send, nothing ever needs to happen. So
sending a "Reject Payment Request" to the merchant is useless.

The unhappy path scenario with Payment Requests (customer paid, but
for whatever reason that payment is no longer valid) can be simply
solved in 1 of 2 ways:

If the merchant realizes the mistake, they can refund the money.
If the customer realizes the problem, they can contact the merchant,
provide the signed request, and ask the merchant to return the funds.

What isn't covered?

On Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:
> The process described in BIP70 might be ok for a simple "happy path"
> scenario, but what if things don't work so smoothly. I'm not talking
> here about technical issues, but _very common_ business scenarios such as:
>
> e.g. Merchant cancels request before payment is sent, such as when:-
> - the merchant realizes that they charged the wrong amount
> - the merchant realizes that they send the payment request to the wrong
> customer
> ...
>
> e.g. the Merchant or Customer decides to cancel the transaction after
> the payment request is sent because:-
> - the customer decides to pay by some other mechanism like cash or
> credit/debit
> - the customer doesn't have sufficient funds and decides not to purchase
> - the customer changes their mind and decides not to purchase
> ...
>
> It strikes me that a "Cancel Payment Request" message is required
> and a "Reject Payment Request" may also be required (or maybe use the
> same message for both).
>
> Tim Tuxworth
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From christophe.biocca at gmail.com  Mon Feb  3 20:37:55 2014
From: christophe.biocca at gmail.com (Christophe Biocca)
Date: Mon, 3 Feb 2014 15:37:55 -0500
Subject: [Bitcoin-development] BIP70: Canceling Payments
In-Reply-To: <5kemthp1y7py3inyyquy78cf.1391459458968@email.android.com>
References: <5kemthp1y7py3inyyquy78cf.1391459458968@email.android.com>
Message-ID: <CANOOu=_3hrWGgx7+nkXOOJmU72_CL4f3OC+xkGwNxnd+jFNU=Q@mail.gmail.com>

It's not limited to HTTP. I was pointing out that unsolicited
merchant-to-consumer messages don't work on HTTP (and a lot of other
situations), and so you can't add a need for it to the payment
protocol (since it wouldn't be usable in the majority of cases).

On Mon, Feb 3, 2014 at 3:30 PM, Tim Tuxworth Founder Go-taxi.biz
<tim at go-taxi.biz> wrote:
> Is BIP70 limited to http only?
>
> What about face to face scenarios, or realtime like ticket sales or
> gambling, and socket and/or bluetooth type connections?
>
> Tim Tuxworth
> Founder Go-Taxi.biz
>
>
> -------- Original message --------
> From: Christophe Biocca
> Date:2014/02/03 10:49 AM (GMT-08:00)
> To: Tim Tuxworth
> Cc: bitcoin-development at lists.sourceforge.net
> Subject: Re: [Bitcoin-development] BIP70: Canceling Payments
>
> Over http, the merchant doesn't have the ability to reach out to the
> consumer's bitcoin wallet on their own. So sending "Cancel Payment
> Request" to the user is impossible.
>
> If the customer doesn't want to send, nothing ever needs to happen. So
> sending a "Reject Payment Request" to the merchant is useless.
>
> The unhappy path scenario with Payment Requests (customer paid, but
> for whatever reason that payment is no longer valid) can be simply
> solved in 1 of 2 ways:
>
> If the merchant realizes the mistake, they can refund the money.
> If the customer realizes the problem, they can contact the merchant,
> provide the signed request, and ask the merchant to return the funds.
>
> What isn't covered?
>
> On Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:
>> The process described in BIP70 might be ok for a simple "happy path"
>> scenario, but what if things don't work so smoothly. I'm not talking
>> here about technical issues, but _very common_ business scenarios such as:
>>
>> e.g. Merchant cancels request before payment is sent, such as when:-
>> - the merchant realizes that they charged the wrong amount
>> - the merchant realizes that they send the payment request to the wrong
>> customer
>> ...
>>
>> e.g. the Merchant or Customer decides to cancel the transaction after
>> the payment request is sent because:-
>> - the customer decides to pay by some other mechanism like cash or
>> credit/debit
>> - the customer doesn't have sufficient funds and decides not to purchase
>> - the customer changes their mind and decides not to purchase
>> ...
>>
>> It strikes me that a "Cancel Payment Request" message is required
>> and a "Reject Payment Request" may also be required (or maybe use the
>> same message for both).
>>
>> Tim Tuxworth
>>
>>
>> ------------------------------------------------------------------------------
>> Managing the Performance of Cloud-Based Applications
>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>> Read the Whitepaper.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From tim at go-taxi.biz  Mon Feb  3 20:30:58 2014
From: tim at go-taxi.biz (Tim Tuxworth Founder Go-taxi.biz)
Date: Mon, 03 Feb 2014 12:30:58 -0800
Subject: [Bitcoin-development] BIP70: Canceling Payments
Message-ID: <5kemthp1y7py3inyyquy78cf.1391459458968@email.android.com>

Is BIP70 limited to http only?

What about face to face scenarios, or realtime like ticket sales or gambling, and socket and/or bluetooth type connections?

Tim Tuxworth
Founder Go-Taxi.biz

<div>-------- Original message --------</div><div>From: Christophe Biocca <christophe.biocca at gmail.com> </div><div>Date:2014/02/03  10:49 AM  (GMT-08:00) </div><div>To: Tim Tuxworth <tim at go-taxi.biz> </div><div>Cc: bitcoin-development at lists.sourceforge.net </div><div>Subject: Re: [Bitcoin-development] BIP70: Canceling Payments </div><div>
</div>Over http, the merchant doesn't have the ability to reach out to the
consumer's bitcoin wallet on their own. So sending "Cancel Payment
Request" to the user is impossible.

If the customer doesn't want to send, nothing ever needs to happen. So
sending a "Reject Payment Request" to the merchant is useless.

The unhappy path scenario with Payment Requests (customer paid, but
for whatever reason that payment is no longer valid) can be simply
solved in 1 of 2 ways:

If the merchant realizes the mistake, they can refund the money.
If the customer realizes the problem, they can contact the merchant,
provide the signed request, and ask the merchant to return the funds.

What isn't covered?

On Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:
> The process described in BIP70 might be ok for a simple "happy path"
> scenario, but what if things don't work so smoothly. I'm not talking
> here about technical issues, but _very common_ business scenarios such as:
>
> e.g. Merchant cancels request before payment is sent, such as when:-
> - the merchant realizes that they charged the wrong amount
> - the merchant realizes that they send the payment request to the wrong
> customer
> ...
>
> e.g. the Merchant or Customer decides to cancel the transaction after
> the payment request is sent because:-
> - the customer decides to pay by some other mechanism like cash or
> credit/debit
> - the customer doesn't have sufficient funds and decides not to purchase
> - the customer changes their mind and decides not to purchase
> ...
>
> It strikes me that a "Cancel Payment Request" message is required
> and a "Reject Payment Request" may also be required (or maybe use the
> same message for both).
>
> Tim Tuxworth
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140203/278866eb/attachment.html>

From andreas at schildbach.de  Mon Feb  3 21:25:53 2014
From: andreas at schildbach.de (Andreas Schildbach)
Date: Mon, 03 Feb 2014 22:25:53 +0100
Subject: [Bitcoin-development] BIP70: Canceling Payments
In-Reply-To: <5kemthp1y7py3inyyquy78cf.1391459458968@email.android.com>
References: <5kemthp1y7py3inyyquy78cf.1391459458968@email.android.com>
Message-ID: <lcp1gk$1d6$1@ger.gmane.org>

Have a look at my post "Payment Protocol for Face-to-face payments". In
short: I implemented BIP70 using combinations of either QR-code or NFC
plus Bluetooth. You can download a working preview app from:

https://github.com/schildbach/bitcoin-wallet/releases/tag/v3.30-bitcoinj0.11


On 02/03/2014 09:30 PM, Tim Tuxworth Founder Go-taxi.biz wrote:
> Is BIP70 limited to http only?
> 
> What about face to face scenarios, or realtime like ticket sales or
> gambling, and socket and/or bluetooth type connections?
> 
> Tim Tuxworth
> Founder Go-Taxi.biz
> 
> 
> -------- Original message --------
> From: Christophe Biocca
> Date:2014/02/03 10:49 AM (GMT-08:00)
> To: Tim Tuxworth
> Cc: bitcoin-development at lists.sourceforge.net
> Subject: Re: [Bitcoin-development] BIP70: Canceling Payments
> 
> Over http, the merchant doesn't have the ability to reach out to the
> consumer's bitcoin wallet on their own. So sending "Cancel Payment
> Request" to the user is impossible.
> 
> If the customer doesn't want to send, nothing ever needs to happen. So
> sending a "Reject Payment Request" to the merchant is useless.
> 
> The unhappy path scenario with Payment Requests (customer paid, but
> for whatever reason that payment is no longer valid) can be simply
> solved in 1 of 2 ways:
> 
> If the merchant realizes the mistake, they can refund the money.
> If the customer realizes the problem, they can contact the merchant,
> provide the signed request, and ask the merchant to return the funds.
> 
> What isn't covered?
> 
> On Mon, Feb 3, 2014 at 1:08 PM, Tim Tuxworth <tim at go-taxi.biz> wrote:
>> The process described in BIP70 might be ok for a simple "happy path"
>> scenario, but what if things don't work so smoothly. I'm not talking
>> here about technical issues, but _very common_ business scenarios such as:
>>
>> e.g. Merchant cancels request before payment is sent, such as when:-
>> - the merchant realizes that they charged the wrong amount
>> - the merchant realizes that they send the payment request to the wrong
>> customer
>> ...
>>
>> e.g. the Merchant or Customer decides to cancel the transaction after
>> the payment request is sent because:-
>> - the customer decides to pay by some other mechanism like cash or
>> credit/debit
>> - the customer doesn't have sufficient funds and decides not to purchase
>> - the customer changes their mind and decides not to purchase
>> ...
>>
>> It strikes me that a "Cancel Payment Request" message is required
>> and a "Reject Payment Request" may also be required (or maybe use the
>> same message for both).
>>
>> Tim Tuxworth
>>
>>
> ------------------------------------------------------------------------------
>> Managing the Performance of Cloud-Based Applications
>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>> Read the Whitepaper.
>>
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> 
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> 
> 
> 
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 





From mike at plan99.net  Tue Feb  4 12:01:12 2014
From: mike at plan99.net (Mike Hearn)
Date: Tue, 4 Feb 2014 13:01:12 +0100
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
	bip39 and payment protocol support
Message-ID: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>

Hello,

I'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.

The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.

Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
Signature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=

Notable changes and new features

Thanks to Ken Sedgwick, an implementation of BIP39 ("Mnemonic code for generating deterministic keys") has been added. This is compatible with the latest Trezor implementation.
Thanks to Mike Belshe, the wallet can now send to P2SH addresses.
Thanks to Matt Corallo, the network layer was rewritten from scratch. It no longer depends on Netty, and it now supports both blocking and non-blocking sockets. In practice that means Java's built in support for transparent SSL and SOCKS becomes available again, which in turn means connecting via Tor is now possible. The new framework is lightweight, easy to understand and has been running a DNS seed crawler for some months now.
Thanks to Kevin Greene, we've added some support for the BIP70 payment protocol. Wallet authors can now consume payment requests, check their signatures and submit payments with the new easy to use PaymentSession class. The wallet-tool command line UI has support and an article explains how to use it.
Thanks to Miron Cuperman, the wallet can now watch arbitrary addresses and scripts. The wallet could previously watch an address as long as the public key was known. Now it's possible to watch for addresses even when the public key is not known.
Also thanks to Miron, Bloom filtering was also improved. The system now tracks false positive rates and cleans the filter when FP rates get too high. Unfortunately, some privacy bugs in Bloom filtering remain, which could (amongst other things) allow a malicious remote peer to test whether you own a particular key.
Thanks to Alex Taylor (bitpos.me), a new PostgreSQL based pruning block store was added. This block store is fast, and indexes the UTXO set, allowing for fast lookup of the balance of any given address.
A Java 8 based wallet template app is now included. The template is designed for people writing contract based applications. It provides a simple app that can be copy/pasted, which connects to the P2P network, manages a wallet, and provides a GUI that shows progress, balance, address+qrcode for receiving money and has a button that is used to empty the wallet out. It's designed to have an attractive and modern look, with tasteful animations and artwork.
Micropayment channels got many big improvements to the API and implementation. The release in 0.10 can be seen as a beta, in this release the micropayments code has been taken for a test drive for a couple of real apps and many rough edges polished as a result.
The default USER_THREAD executor can now be replaced, allowing a 1-line switch of all callbacks onto a thread of your choice instead of needing to override each callback, each time. This should simplify and clean up the GUI code of wallet apps significantly.
The WalletTool command line app has a more convenient user interface now.
A new DNS seed has been added. The seed is run by Christian Decker, from ETH Zurich.
bitcoinj 0.11 will shortly be available via Maven Central. Please use the dependency verifier plugin and/or check the PGP signatures on the uploads, if you use this!
Smaller improvements

We finished adding nullity annotations to the API. You should now be able to assume that any method not annotated with @Nullable won't ever return null values.
The WalletAppKit got a bunch of new features and convenience APIs.
The wallet will now create inputs with dummy signatures if the private key for an output is missing, rather than throwing an exception. You can then edit the input later to substitute in a real signature. This is useful when the signing is being done elsewhere, outside of the library.
In full verification mode, execution of scripts (i.e. checking signatures) can now be switched off. This is useful if you trust the source of the chain and just want to calculate the UTXO set.
The wallet risk analysis code is now pluggable, better documented and checks for finality in a more sensible way.
Various memory usage and flow control optimisations were made to allow much larger wallets to sync on Android.
The transaction broadcast algorithm was changed to be more robust.
Double spend handling in the wallet was improved.
Generated signatures now use canonical S values. This will aid a future hard-forking rule change which bans malleable signatures.
Some fixes were made for enable usage with the Orchid Tor library. Further support for Tor is planned for future releases.
Notable bug fixes

Some hard-forking full verification bugs were fixed.
Thanks to Miron, PeerGroup now performs exponential backoff for peer connections, for instance if we cannot connect to them or if they disconnect us. This resolves an annoying bug in which if the library was configured with a single peer that was down, it would spin in a tight loop consuming battery.
API changes

Some functionality of the Wallet class was moved into separate classes under the wallet package.
The micropayments API and protocol changed. New clients/servers are not compatible with apps running against previous releases.
The Wallet sendCoins/completeTx methods no longer return booleans or null to indicate failure, they now throw InsufficientMoneyException or a subclass if the transaction cannot be completed. The exception object typically contains information on how much money is missing.
Some mis-named methods in the HD key derivation API were renamed.
The WalletEventListener interface has an extra method for watching scripts now.
Peer discovery classes moved under the net.discovery package
Any APIs that relied on Netty are now different.
New documentation

An article on the networking API
Info on testing your apps, and how to use regtest mode to make a private Bitcoin network that allows you to mine blocks instantly.
A reference table showing which API's implement which Bitcoin Improvement Proposals (BIPs).
Please note that as I am no longer employed by Google, after 0.11 signing the Google contributor license agreement will no longer be necessary. I look forward to welcoming contributions from Andreas Schildbach now this requirement has gone away. Also, in future I plan to re-namespace the library from com.google.bitcoin to org.bitcoinj - auto-migration scripts will be provided when this is done.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/fe4e53f6/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 7453 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/fe4e53f6/attachment.p7s>

From pete at petertodd.org  Tue Feb  4 13:03:13 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 4 Feb 2014 08:03:13 -0500
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
Message-ID: <20140204130312.GA23538@savin>

On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:
> Hello,
> 
> I'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.
> 
> The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.
> 
> Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
> Signature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=

The above makes for a great homework problem for budding cryptographers:
Why did the three forms of signature, DKIM, long-lived bitcoin address,
and Official Swiss Government Identity fail to let you actually verify
you have the right code? (but make for great security theater)

Bonus question: Who has the smallest work-factor for such an attack?

Two rewards of 25mBTC for correct responses to each question from a
crypto newbie.

> Thanks to Mike Belshe, the wallet can now send to P2SH addresses.

Thanks

> Generated signatures now use canonical S values. This will aid a future hard-forking rule change which bans malleable signatures.

Soft-forking rule change.

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/dea3f133/attachment.sig>

From mike at plan99.net  Tue Feb  4 13:13:12 2014
From: mike at plan99.net (Mike Hearn)
Date: Tue, 4 Feb 2014 14:13:12 +0100
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <20140204130312.GA23538@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
Message-ID: <CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>

Hah, good point. If nobody completes the homework, I'll post a fixed
version tomorrow :)


On Tue, Feb 4, 2014 at 2:03 PM, Peter Todd <pete at petertodd.org> wrote:

> On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:
> > Hello,
> >
> > I'm pleased to announce the release of bitcoinj 0.11, a library for
> writing Bitcoin applications that run on the JVM. BitcoinJ is widely used
> across the Bitcoin community; some users include Bitcoin Wallet for
> Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer
> (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me,
> Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced
> contracts research and more.
> >
> > The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The
> commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin
> key as with previous releases (check their release announcements to
> establish continuity). Additionally, this email is signed using DKIM and
> for the first time, a key that was ID verified by the Swiss government.
> >
> > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
> > Signature for last paragraph:
> H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=
>
> The above makes for a great homework problem for budding cryptographers:
> Why did the three forms of signature, DKIM, long-lived bitcoin address,
> and Official Swiss Government Identity fail to let you actually verify
> you have the right code? (but make for great security theater)
>
> Bonus question: Who has the smallest work-factor for such an attack?
>
> Two rewards of 25mBTC for correct responses to each question from a
> crypto newbie.
>
> > Thanks to Mike Belshe, the wallet can now send to P2SH addresses.
>
> Thanks
>
> > Generated signatures now use canonical S values. This will aid a future
> hard-forking rule change which bans malleable signatures.
>
> Soft-forking rule change.
>
> --
> 'peter'[:-1]@petertodd.org
> 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/22905784/attachment.html>

From pete at petertodd.org  Tue Feb  4 13:17:23 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 4 Feb 2014 08:17:23 -0500
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
Message-ID: <20140204131723.GA10309@savin>

On Tue, Feb 04, 2014 at 02:13:12PM +0100, Mike Hearn wrote:
> Hah, good point. If nobody completes the homework, I'll post a fixed
> version tomorrow :)

Heh, here's another 25mBTC while we're at it:

https://github.com/opentimestamps/opentimestamps-client/commit/288f3c17626974de7eaef4f1c9b5cd93eecf40f6

Why is that a bad idea?

Bonus question: What was I smoking? (hint: where do I live?)

> On Tue, Feb 4, 2014 at 2:03 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:
> > > Hello,
> > >
> > > I'm pleased to announce the release of bitcoinj 0.11, a library for
> > writing Bitcoin applications that run on the JVM. BitcoinJ is widely used
> > across the Bitcoin community; some users include Bitcoin Wallet for
> > Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer
> > (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me,
> > Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced
> > contracts research and more.
> > >
> > > The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The
> > commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin
> > key as with previous releases (check their release announcements to
> > establish continuity). Additionally, this email is signed using DKIM and
> > for the first time, a key that was ID verified by the Swiss government.
> > >
> > > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
> > > Signature for last paragraph:
> > H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=
> >
> > The above makes for a great homework problem for budding cryptographers:
> > Why did the three forms of signature, DKIM, long-lived bitcoin address,
> > and Official Swiss Government Identity fail to let you actually verify
> > you have the right code? (but make for great security theater)
> >
> > Bonus question: Who has the smallest work-factor for such an attack?
> >
> > Two rewards of 25mBTC for correct responses to each question from a
> > crypto newbie.
> >
> > > Thanks to Mike Belshe, the wallet can now send to P2SH addresses.
> >
> > Thanks
> >
> > > Generated signatures now use canonical S values. This will aid a future
> > hard-forking rule change which bans malleable signatures.
> >
> > Soft-forking rule change.
> >
> > --
> > 'peter'[:-1]@petertodd.org
> > 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
> >

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/32b91c27/attachment.sig>

From jgarzik at bitpay.com  Tue Feb  4 14:43:31 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Tue, 4 Feb 2014 09:43:31 -0500
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <20140204131723.GA10309@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
	<20140204131723.GA10309@savin>
Message-ID: <CAJHLa0NL4ji27w+1cgpRTDzx9QXv-kWSM1GSr_A76AitsJL75Q@mail.gmail.com>

On Tue, Feb 4, 2014 at 8:17 AM, Peter Todd <pete at petertodd.org> wrote:
> Bonus question: What was I smoking? (hint: where do I live?)

Cryptographers smoke... hash, right?

(couldn't resist)

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From pete at petertodd.org  Tue Feb  4 14:46:40 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 4 Feb 2014 09:46:40 -0500
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <CAJHLa0NL4ji27w+1cgpRTDzx9QXv-kWSM1GSr_A76AitsJL75Q@mail.gmail.com>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
	<20140204131723.GA10309@savin>
	<CAJHLa0NL4ji27w+1cgpRTDzx9QXv-kWSM1GSr_A76AitsJL75Q@mail.gmail.com>
Message-ID: <20140204144640.GC26174@savin>

On Tue, Feb 04, 2014 at 09:43:31AM -0500, Jeff Garzik wrote:
> On Tue, Feb 4, 2014 at 8:17 AM, Peter Todd <pete at petertodd.org> wrote:
> > Bonus question: What was I smoking? (hint: where do I live?)
> 
> Cryptographers smoke... hash, right?
> 
> (couldn't resist)

<groan>

I think we have a winner; as you can see Jeff must be a great father.

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/df60701e/attachment.sig>

From natanael.l at gmail.com  Tue Feb  4 15:17:47 2014
From: natanael.l at gmail.com (Natanael)
Date: Tue, 4 Feb 2014 16:17:47 +0100
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <20140204131723.GA10309@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
	<20140204131723.GA10309@savin>
Message-ID: <CAAt2M1-LZ1APX9F93WE7Z877-WxqvJFbGaUmu5eriRGwvAOESw@mail.gmail.com>

Because it's trivial to create collisions! You can choose exactly what
output you want. That's why XOR is a very bad digest scheme.

- Sent from my phone
Den 4 feb 2014 14:20 skrev "Peter Todd" <pete at petertodd.org>:

> On Tue, Feb 04, 2014 at 02:13:12PM +0100, Mike Hearn wrote:
> > Hah, good point. If nobody completes the homework, I'll post a fixed
> > version tomorrow :)
>
> Heh, here's another 25mBTC while we're at it:
>
>
> https://github.com/opentimestamps/opentimestamps-client/commit/288f3c17626974de7eaef4f1c9b5cd93eecf40f6
>
> Why is that a bad idea?
>
> Bonus question: What was I smoking? (hint: where do I live?)
>
> > On Tue, Feb 4, 2014 at 2:03 PM, Peter Todd <pete at petertodd.org> wrote:
> >
> > > On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:
> > > > Hello,
> > > >
> > > > I'm pleased to announce the release of bitcoinj 0.11, a library for
> > > writing Bitcoin applications that run on the JVM. BitcoinJ is widely
> used
> > > across the Bitcoin community; some users include Bitcoin Wallet for
> > > Android, MultiBit, Hive, blockchain.info, the biteasy.com block
> explorer
> > > (written in Lisp!), Circle, Neo/Bee (Cypriot payment network),
> bitpos.me,
> > > Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic
> advanced
> > > contracts research and more.
> > > >
> > > > The release-0.11 git tag is signed by Andreas Schildbach's GPG key.
> The
> > > commit hash is 410d4547a7dd. This paragraph is signed by the same
> Bitcoin
> > > key as with previous releases (check their release announcements to
> > > establish continuity). Additionally, this email is signed using DKIM
> and
> > > for the first time, a key that was ID verified by the Swiss government.
> > > >
> > > > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
> > > > Signature for last paragraph:
> > >
> H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=
> > >
> > > The above makes for a great homework problem for budding
> cryptographers:
> > > Why did the three forms of signature, DKIM, long-lived bitcoin address,
> > > and Official Swiss Government Identity fail to let you actually verify
> > > you have the right code? (but make for great security theater)
> > >
> > > Bonus question: Who has the smallest work-factor for such an attack?
> > >
> > > Two rewards of 25mBTC for correct responses to each question from a
> > > crypto newbie.
> > >
> > > > Thanks to Mike Belshe, the wallet can now send to P2SH addresses.
> > >
> > > Thanks
> > >
> > > > Generated signatures now use canonical S values. This will aid a
> future
> > > hard-forking rule change which bans malleable signatures.
> > >
> > > Soft-forking rule change.
> > >
> > > --
> > > 'peter'[:-1]@petertodd.org
> > > 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
> > >
>
> --
> 'peter'[:-1]@petertodd.org
> 000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/a609d169/attachment.html>

From pete at petertodd.org  Tue Feb  4 16:04:14 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 4 Feb 2014 11:04:14 -0500
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <CAAt2M1-LZ1APX9F93WE7Z877-WxqvJFbGaUmu5eriRGwvAOESw@mail.gmail.com>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
	<20140204131723.GA10309@savin>
	<CAAt2M1-LZ1APX9F93WE7Z877-WxqvJFbGaUmu5eriRGwvAOESw@mail.gmail.com>
Message-ID: <20140204160414.GA23803@savin>

On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:
> Because it's trivial to create collisions! You can choose exactly what
> output you want. That's why XOR is a very bad digest scheme.

You're close, but not quite.

So, imagine you have a merkle tree, and you're trying to timestamp some
data at the bottom of the tree. Now you can successfully timestamp the
top digest in the Bitcoin blockchain right, and be sure that digest
existed before some time. But what about the digests at the bottom of
the tree? What can an attacker do exactly to make a fake timestamp if
the tree is using XOR rather than a proper hash function?

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140204/9a607aa4/attachment.sig>

From jeremy at taplink.co  Wed Feb  5 07:57:36 2014
From: jeremy at taplink.co (Jeremy Spilman)
Date: Tue, 04 Feb 2014 23:57:36 -0800
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <20140204160414.GA23803@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
	<20140204131723.GA10309@savin>
	<CAAt2M1-LZ1APX9F93WE7Z877-WxqvJFbGaUmu5eriRGwvAOESw@mail.gmail.com>
	<20140204160414.GA23803@savin>
Message-ID: <op.xastqaf9yldrnw@laptop-air>

Well the point of the Merkle tree is that if I all you have is the top,  
and all I give you is a leaf node and the siblings of all parents of that  
leaf, then by simply hashing you can check if the node was actually  
present in the tree.

The only reason this works is because it's hard for an attacker to come up  
with the list of values which would ultimately hash together to produce  
the expected top value. But if the hash function is actually just XOR, it  
becomes completely trivial for me to claim any value I want was in the  
tree.

1) Pick the fake value you want to claim was in the tree (leaf node)
2) Choose some random values to fake the depth in the tree
3) Calculate the last value as 'Prev (x) Top'
4) When your victim goes to verify set membership, they will get the top  
value they expected



On Tue, 04 Feb 2014 08:04:14 -0800, Peter Todd <pete at petertodd.org> wrote:

> On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:
>> Because it's trivial to create collisions! You can choose exactly what
>> output you want. That's why XOR is a very bad digest scheme.
>
> You're close, but not quite.
>
> So, imagine you have a merkle tree, and you're trying to timestamp some
> data at the bottom of the tree. Now you can successfully timestamp the
> top digest in the Bitcoin blockchain right, and be sure that digest
> existed before some time. But what about the digests at the bottom of
> the tree? What can an attacker do exactly to make a fake timestamp if
> the tree is using XOR rather than a proper hash function?




From boydb at midnightdesign.ws  Wed Feb  5 15:09:31 2014
From: boydb at midnightdesign.ws (Brooks Boyd)
Date: Wed, 5 Feb 2014 09:09:31 -0600
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <20140204160414.GA23803@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
	<CANEZrP2NyvRKwSEZORjAOq6G7UqLv=F3FjxmGNTPMT10yWGxzw@mail.gmail.com>
	<20140204131723.GA10309@savin>
	<CAAt2M1-LZ1APX9F93WE7Z877-WxqvJFbGaUmu5eriRGwvAOESw@mail.gmail.com>
	<20140204160414.GA23803@savin>
Message-ID: <CANg-TZBvZGwXaNoz5h7FD7Rh072+qc6T3FrUV-J81o4xZEuZ9A@mail.gmail.com>

On Tue, Feb 4, 2014 at 10:04 AM, Peter Todd <pete at petertodd.org> wrote:
>
> On Tue, Feb 04, 2014 at 04:17:47PM +0100, Natanael wrote:
> > Because it's trivial to create collisions! You can choose exactly what
> > output you want. That's why XOR is a very bad digest scheme.
>
> You're close, but not quite.
>
> So, imagine you have a merkle tree, and you're trying to timestamp some
> data at the bottom of the tree. Now you can successfully timestamp the
> top digest in the Bitcoin blockchain right, and be sure that digest
> existed before some time. But what about the digests at the bottom of
> the tree? What can an attacker do exactly to make a fake timestamp if
> the tree is using XOR rather than a proper hash function?
>

Given a tree like:

      G
     / \
    E   F
   / \
  C   D
 / \
A   B

Where G is the root hash and A is the legitimate data that was included in
the tree, the legitimate user provides B, D and F along with A to prove A
is part of the tree G.

Now an attacker could just make up an arbitrary set of values that XOR
together into G, like:

  G
 / \
Z   Y

And could therefore claim Z is part of tree G by providing Y. But if A is
also trying to prove its a part of G, we know the first level of the tree
must be E and F. It cannot also be Z and Y, so one of the two users is
lying and the deceit is obvious, though not obvious which user is lying.

An attacker could look more convincing by using the data passed with A as a
starting point:

        G
       / \
      E   F
     / \
    /   \
   /     \
  C       D
 / \     / \
A   B   Z   Y

Instead of working off of G, work of the lowest branch provided by A in its
verification (D, in this case), and create the fake data Z, and calculate Y
such that Z XOR Y == D (which is just Z XOR D). Now the attacker can claim
Z is part of G by supplying Y, C, and F. The tree looks valid (it can
coexist with the proof provided by A, at least until someone else claims to
be a descendant of the D node as well), and since G was verified by
timestamp, looks like Z existed before that timestamp, when really it could
be added at any time by calculating Z XOR D.

Brooks
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140205/25eaf6b2/attachment.html>

From mail at jeremyhahn.com  Wed Feb  5 21:25:48 2014
From: mail at jeremyhahn.com (Jeremy Hahn)
Date: Wed, 05 Feb 2014 16:25:48 -0500
Subject: [Bitcoin-development] Modular PoW
Message-ID: <52F2AC5C.1030702@jeremyhahn.com>

Relocating this conversation to the dev list. Feedback / continued 
discussion welcome.

https://github.com/bitcoin/bitcoin/issues/3624



From pete at petertodd.org  Fri Feb  7 09:21:41 2014
From: pete at petertodd.org (Peter Todd)
Date: Fri, 7 Feb 2014 04:21:41 -0500
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
 bip39 and payment protocol support
In-Reply-To: <20140204130312.GA23538@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin>
Message-ID: <20140207092141.GA3532@savin>

Thanks for the great response! I had about a dozen or so people contact
me with solutions for one or more questions, and even a anonymous
donation of 75mBTC to cover the rewards.

I'll start with my summaries of those solutions:

On Tue, Feb 04, 2014 at 08:03:13AM -0500, Peter Todd wrote:
> On Tue, Feb 04, 2014 at 01:01:12PM +0100, Mike Hearn wrote:
> > Hello,
> > 
> > I'm pleased to announce the release of bitcoinj 0.11, a library for writing Bitcoin applications that run on the JVM. BitcoinJ is widely used across the Bitcoin community; some users include Bitcoin Wallet for Android, MultiBit, Hive, blockchain.info, the biteasy.com block explorer (written in Lisp!), Circle, Neo/Bee (Cypriot payment network), bitpos.me, Bitcoin Touch, BlueMatt's relay network and DNS crawler, academic advanced contracts research and more.
> > 
> > The release-0.11 git tag is signed by Andreas Schildbach's GPG key. The commit hash is 410d4547a7dd. This paragraph is signed by the same Bitcoin key as with previous releases (check their release announcements to establish continuity). Additionally, this email is signed using DKIM and for the first time, a key that was ID verified by the Swiss government.
> > 
> > Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
> > Signature for last paragraph: H3DvWBqFHPxKW/cdYUdZ6OHjbq6ZtC5PHK4ebpeiE+FqTHyRLJ58BItbC0R2vo77h+DthpQigdEZ0V8ivSM7VIg=
> 
> The above makes for a great homework problem for budding cryptographers:
> Why did the three forms of signature, DKIM, long-lived bitcoin address,
> and Official Swiss Government Identity fail to let you actually verify
> you have the right code? (but make for great security theater)

So as most people correctly guessed, the problem here is that Mike
truncated the git commit hash; normally it's 160 bits long, but he only
gave 48 of those bits. To understand why this is a problem, recall that
what a cryptographic hash does is it takes a arbitrary block of data,
the message, and returns a fixed length bit string, the message digest
or simply digest. With git the message essentially your source code and
commit history, and the digest is the git commit hash. Critically for a
cryptographic hash to be secure the mapping between messages and digests
must be random - it must not be infeasible to find two messages with the
same digest. (this is called a preimage attack)

The problem is that 48 bits just isn't that many bits. An attacker can
take the bitcoinj sourcecode and modify it to do something malicious
like generate private keys insecurely. Then they can keep modifying it
until the last 48-bits of the commit hash match Mike's message. (this
called a partial preimage attack) Each modification has a 1 in 2^48
chance of succeeding. You can calculate the attackers chances exactly
with the Binominal distribution, but a good enough approximation is
they'd have to make about 2^48 attempts.

That's not a very big number! Here's a nice visual comparison of how
long 48 bits is, compared to the partial preimage the Bitcoin network
cracks every 10 minutes:

0000000000000001512b077de3cc7ec88d1d65dc474a52a9ac9ac14ac34d7ac8
410d4547a7dd

Literally tens of thousands of times harder. This problem is similar to
password cracking, and they're getting speeds like ten million attempts
per second per CPU core. Just do the math: 2^48/10million/second/core =
46 Core Weeks. Now I can rent 32-core servers at Amazon EC2 for as
little as $0.27 per hour (spot requests) which gives me a cost for the
attack of about $100; my time to actually do it will cost more than
that.


But that calculation is missing the point; the extra bytes are really
cheap, so you can just use a simple rule of thumb: If a partial-preimage
attack is what you are trying to prevent, then in cryptography an
accepted number of bits to use is 128. Maybe just 80 bits would be
enough, or even just 64 bits, but pretty much everyone agrees 128 is
safe and conservative. But read on, because even 128 bits isn't safe
enough against another type of attack...


A second issue that a few people noticed was that Mike just said
"Andreas Schildbach's GPG key", rather than specifying the fingerprint
of the key. By now I'd expect Mike to be confident as to what PGP key
is actually the correct one for the human Andreas Schildbach, so there's
absolutely no reason not state what that key is, either in the release
notes, or by signing the key with Mike's (non-existant?) PGP key.
Preferably both.

> Bonus question: Who has the smallest work-factor for such an attack?

No-one got this one correct or even tried!

What if Mike Hearn himself were the attacker? For instance, US officials
wanted to shutdown the gambling site SatoshiDice, which reportedly uses
the bitcoinj library. One way to do this would be to seize the funds
held by SatoshiDice, putting them out of business. If they could trick
SatoshiDice into using a version of bitcoinj with a broken PRNG, they
could simply wait until funds had moved into addresses generated by that
PRNG, and/or ECC signatures were created with a known k value. (leaking
the private key)

But how to pull that off? The bitcoinj sourcecode is public, so they
can't just backdoor bitcoinj directly - everyone would find out. What
they need is a way to trick SatoshiDice into installing a bugged
version, without leaving any evidence.

With Mike Hearn's help they can calculate a pair of hashes, each with a
n-bit prefix, but with only sqrt(2^n) work. This is called a
second-preimage attack, and takes advantage of the birthday paradox,
which as you may recall, is that in a room of just 23 people, there is a
50% chance that two them share the same birthday.

Now the US government continually generates pairs of slightly different
git commits, one being the honest code, the other with the backdoor.
Generating these pairs is simple enough, just change something
insignificant like the exact timestamp of last few commits. Every hash
generated is saved in a big hashtable, as well as compared with all
pre-existing hashes. In this case they'll just need to do about 2^24
tries to succeed, only 24 million attempts, which is frankly pretty
trivial.

Now that they have two collissions they have Mike release bitcoinj as
before to the public, and at the same time they intercept the internet
connections of the people suspected to be the SatoshiDice developers.
For the latter a MITM attack is performed, secretly replacing the good
copy of bitcoinj they download with the backdoored copy. The developers
don't notice anything unusual, because both copies appear to have the
same commit hash!

The beauty of this technique is provided the disclosed hash isn't too
long, it's still plausible that a powerful government agency brute
forced the thing even if the backdoored code is leaked. With 48 bits
that's obviously trivial, but even a 64-bit collision could be made at
the cost of only a few million dollars. Thus, Mike Hearn has plausible
deniability and can claim innocence.

Moral of the story is if a second-pre-image attack is a threat, you need
to use a lot of bits. Even a full SHA-1 commit hash is only 160 bits,
which gives sqrt(2^160) or 2^80 security, so anything less than the full
git commit hash is risky. Industry standard is to use at least 160 bits,
and preferably you should always just use the full 256 bits that SHA-256
or similar provides unless you have a really good reason not too.


On Tue, Feb 04, 2014 at 08:17:23AM -0500, Peter Todd wrote:
> On Tue, Feb 04, 2014 at 02:13:12PM +0100, Mike Hearn wrote:
> > Hah, good point. If nobody completes the homework, I'll post a fixed
> > version tomorrow :)
> 
> Heh, here's another 25mBTC while we're at it:
> 
> https://github.com/opentimestamps/opentimestamps-client/commit/288f3c17626974de7eaef4f1c9b5cd93eecf40f6
> 
> Why is that a bad idea?

Brooks Boyd already posted a great writeup, so I'm going to reference
his instead:
http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03882.html


In closing I think it's important that we all remember we're writing
software that handles money and the incentives to sneak backdoors into
said software are enormous, and every worse, universal. Everyone can
profit pretty directly from stealing cash, so the "Bad guys" we're up
against range from your "Russian hackers" to the US government and
everyone in between.

Fortunately the nature of attacks is that for an attack to succeed,
everything has to go right, but for it to fail, you only need a single
person to notice something is wrong. This is why the Bitcoin Core
development effort consists of multiple people, mutually verifying each
other's work, and signing code with OpenPGP keys that in turn are
verifiable via numerous different paths. Of course, many users will
naturally not bother with that effort and outsoruce their trust to a
single person or certificate authority, but the more advanced users with
more stringent security needs, such as developers at exchanges and big
merchants, can validate the code through the indepdent multiple
independent paths OpenPGP signatures provide. Bitcoinj would do well to
give their users that kind of security.

So in the spirit of community auditing, I'll give one last 25mBTC reward
out; I'll sneak in another obvious security flaw into something I write
in the future, and I want to see if you guys catch it.


As for the winners, I went by timestamp on the first email or other
contact I got, and rewarded better descriptions where it wasn't clear.
First of all I'm awarding the first bonus question to Vitalik, who in
person at the Toronto Bitcoin Meetup noticed the issue immediately. He's
no crypto-newbie, but at that point I had to give it to someone! Jeff
Garzik will receive nothing for his answer, as it would be morally wrong
to encourage further dad jokes.

Brooks Boyd wins for #3, and thanks for the solid write up! Finally, #1
had a lot of submissions, but the earliest really clear answere was
privately emailed to me. Dunno if they want to be named publicly, but
here's the SHA256 hash of their email address for bragging rights:

49bf07a9ce1421effe887509a361b62283ed269d328bd3be12334f8cce7a0acd


Finally, it'd be really awesome to have some concrete examples of git
commits with these preimage and second-preimage attacks applied. So, I'm
pledging 250mBTC to anyone who creates a tool that can run on Ubuntu
Linux that takes two git commits, and brute-forces some not trivially
noticed nonce within those commits - I suggest the timestamp - to make
some subset of their hash collide.

A fast C or C++ inner loop would be ideal - being able to create
reasonably long collisions, best yet against arbitrary bit masks, would
be an excellent way to show people why they need to be careful. Contact
me if you want to take this on.

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/bcdc7570/attachment.sig>

From mike at plan99.net  Fri Feb  7 10:48:17 2014
From: mike at plan99.net (Mike Hearn)
Date: Fri, 7 Feb 2014 11:48:17 +0100
Subject: [Bitcoin-development] bitcoinj 0.11 released, with p2sh,
	bip39 and payment protocol support
In-Reply-To: <20140207092141.GA3532@savin>
References: <1D8E0828-D07F-46EF-9F9F-5CA83AA9DB59@plan99.net>
	<20140204130312.GA23538@savin> <20140207092141.GA3532@savin>
Message-ID: <B652BED9-6DAB-40D2-9164-206787F5DDEF@plan99.net>

Here?s a new release announcement with full ID?s this time:

The v0.11 tag is signed by Andreas Schildbach?s GPG key (fingerprint E944 AE66 7CF9 60B1 004B C32F CA66 2BE1 8B87 7A60). The commit hash is 410d4547a7dd20745f637313ed54d04d08d28687.

Key: 16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m
Signature: IFXzt4ZdWFEpLrAXRDnQS6ZKJYGmyHDHtyAgeg/2/EaTvg41jSsUQW8rq19evT2UNp+eP0+OWgWM7iDKrTv11DY=

It?s worth noting that this problem crops up in other contexts too. For instance, it?s very common for people to identify PGP keys by a short identifier.

As it happens I do have a PGP key, fingerprint C85A AB0F 7A1C CCA3 2BFC EECC F2E4 861C 9988 816F, and I just signed Andreas? key with it. However, as I?m not myself well connected in the web of trust, that doesn?t add a whole lot. But now that my key is effectively signed out of band by SwissSign so if people wanted to manually trace a trust path across systems, they could. I am skeptical anyone will :-)

Note that thanks to Gary Rowe, there is a Maven dependency checker plugin that verifies the (full) hashes of library dependencies. It could be better integrated but it provides another backstop.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smime.p7s
Type: application/pkcs7-signature
Size: 7453 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/927761b1/attachment.p7s>

From cryptofish82 at gmail.com  Fri Feb  7 17:33:12 2014
From: cryptofish82 at gmail.com (Crypto Fish)
Date: Fri, 7 Feb 2014 10:33:12 -0700
Subject: [Bitcoin-development] Multi Input/Output Transaction Problems
Message-ID: <CALDrD5O0bn1xchKH=vs0FNDcdL24uUm3qs+1ERj24zw_VtVsHQ@mail.gmail.com>

So, I'm having some problems getting a multi input/multi output transaction
working. My code below works with 1 input and 2 output, but when adding
more inputs/outputs the transaction gets rejected. I'm sure whatever I'm
doing wrong in pretty simple, any ideas?

Code works for this (1 input, 2 outputs):

CTransaction(hash=01a3204517476812df2c2f77735a72a6d3e7eb8b9a5d5330ca433dd875fc4c3c,
ver=1, vin.size=2, vout.size=4, nLockTime=0)

CTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,
0), scriptSig=304502204cdfd276ff9c53bb)
    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 b07e181ce438)
    CTxOut(nValue=1.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)

Code doesn't work for this (2 input, 4 outputs):

CTransaction(hash=01a3204517476812df2c2f77735a72a6d3e7eb8b9a5d5330ca433dd875fc4c3c,
ver=1, vin.size=2, vout.size=4, nLockTime=0)

CTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,
1), scriptSig=304502204aef3f393c273835)

CTxIn(COutPoint(6ee4049d6c75d6450e961446d28760207bd7036e2aa692afb80bb34245d3df84,
0), scriptSig=304502204cdfd276ff9c53bb)
    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)
    CTxOut(nValue=491.00000000, scriptPubKey=OP_DUP OP_HASH160 0796b7f3430f)
    CTxOut(nValue=4.00000000, scriptPubKey=OP_DUP OP_HASH160 b07e181ce438)
    CTxOut(nValue=1.00000000, scriptPubKey=OP_DUP OP_HASH160 bf7484e469c8)

Pseudo code showing working transaction:

    // These are how the vout's are made
    CScript scriptPubKey;
    scriptPubKey.SetDestination(address);
    CScript s;
    s << OP_DUP << OP_HASH160 << scriptPubKey.GetID() << OP_EQUALVERIFY <<
OP_CHECKSIG;

    CTxOut out(nValue, s);

    ---------------


    CTransaction txNew;
    txNew.vin.clear();
    txNew.vout.clear();

    // vin and vout are already populated
    for(unsigned int i = 0; i < vout.size(); i++){
        txNew.vout.push_back(vout[i]);
    }

    //add all vins
    for(unsigned int i = 0; i < vin.size(); i++){
        txNew.vin.push_back(vin[i]);
    }

    //add all vins
    for(unsigned int i = 0; i < vin.size(); i++){
        // this is signed with 2 separate keys for each vin
        if(!SignSignature(*keystore, prevPubKey, txNew, i,
int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)))
            printf('signing failed!\n');

        // I was told I might need to serialize the inputs? Not sure how
that would work
    }

    RelayTransaction(txNew, txNew.Hash());


---

CryptoFish
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/99d7ccc3/attachment.html>

From andreas at schildbach.de  Fri Feb  7 23:15:43 2014
From: andreas at schildbach.de (Andreas Schildbach)
Date: Sat, 08 Feb 2014 00:15:43 +0100
Subject: [Bitcoin-development] Payment Protocol for Face-to-face Payments
In-Reply-To: <lcdaid$rd4$1@ger.gmane.org>
References: <lc5hmg$1jh$1@ger.gmane.org> <lcdaid$rd4$1@ger.gmane.org>
Message-ID: <ld3pei$7fk$1@ger.gmane.org>

I have refreshed the Bitcoin Wallet preview version with beta version
3.32. It now implements BIP72 aka "URI extension for payment protocol".

There is one important deviation from the standard though: Bitcoin URI
address and amount fields need to correspond to the data from the
payment request. The makes sure the signature really signs the URI
(which you've gotten directly from the payee) and not a malicious
payment request introduced by a MITM. Note the memo isn't protected like
that, so it can still be MITM'ed.

I know this means that for the time being Bitcoin URIs must be
"backwards compatible". That should not be an issue since we will be in
transition phase for many months anyway. Until then, I hope we will have
agreed on a more sophisticated approach, e.g. a separate hash in the URI.

Source:
https://github.com/schildbach/bitcoin-wallet/commits/v3.32

Binaries:
https://github.com/schildbach/bitcoin-wallet/releases/tag/v3.32
(also published to the corresponding channels on Google Play)


On 01/30/2014 11:46 AM, Andreas Schildbach wrote:
> Just a small update. I merged the code to my bitcoinj-0.11 branch and
> put up binary .apk files for experimentation. Just make sure to tick
> "BIP70 for tap-to-pay/scan-to-pay" in the labs settings.
> 
> Source:
> https://github.com/schildbach/bitcoin-wallet/commits/bitcoinj-0.11
> 
> Binaries:
> https://github.com/schildbach/bitcoin-wallet/releases/tag/v3.30-bitcoinj0.11
> 
> 
> On 01/27/2014 12:59 PM, Andreas Schildbach wrote:
>> As promised I'd like to present my work done on leveraging the payment
>> protocol for face-to-face payments. The general assumption is that
>> individuals don't own X.509 certificates. Their devices may be only
>> badly connected to the internet or in some cases not at all. I've
>> implemented a prototype on a branch of Bitcoin Wallet. It is using
>> bitcoinj 0.11 (not released).
>>
>> https://github.com/schildbach/bitcoin-wallet/commits/payment-protocol
> 
> 
> 
> ------------------------------------------------------------------------------
> WatchGuard Dimension instantly turns raw network data into actionable 
> security intelligence. It gives you real-time visual feedback on key
> security issues and trends.  Skip the complicated setup - simply import
> a virtual appliance and go from zero to informed in seconds.
> http://pubads.g.doubleclick.net/gampad/clk?id=123612991&iu=/4140/ostg.clktrk
> 





From stephane at kill-bill.org  Sat Feb  8 02:57:40 2014
From: stephane at kill-bill.org (Stephane Brossier)
Date: Fri, 7 Feb 2014 18:57:40 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
Message-ID: <0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>

Mike and all,

Pierre and I just committed a prototype implementation of the recurring payment protocol using bitcoinj. You can find the diff on our fork: 
https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7

We did not write the server (merchant side), but wanted to have some feedback before going deeper (merchant implementation and tests). We did our best to build it on top of the existing BIP-0070 protocol-- only a few additions in the messages, but no new calls and no new uri scheme. We created a new package 'recurring' where most of the new code lives.

At a high level:

1. Creation of the subscription:

The initial handshake for creating the subscription is exactly similar to the one for the payment protocol (PaymentRequest is used to provide the contract)

2. Wallet can decide to poll the merchants for its active subscriptions.

Here the flow is exactly similar to the payment protocol but the wallet receives a callback to verify the payment matches the contract and should go through.

Please give us some feedback whenever you have the chance. In the meantime we will start implementing the merchant side and test the code.

Cheers!



On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:

> That looks OK at a very high level. Things you probably want to think about:
> How to trigger it off the existing payment protocol (no new top level messages or mime types or uri extensions please)
> Data structures to define the payment schedule
> Do you allow pre-submission of time locked transactions or not?
> I think as you prototype these things will become clearer.  You could try prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the PaymentSession class).
> 
> 
> 
> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org> wrote:
> From what I have seen so far, there seems to be an agreement that this is a nice feature to add.  We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.
> 
> 
> We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:
> * some feedbacks on the high level proposal
> * additional requirements we might have missed
> 
> So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.
> 
> 
>  
> I. Abstract
> ---------------
> 
> This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.
> 
> An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, ?). For the sake of discussion, we?ll focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.
> 
> 
> II. Motivation
> ------------------
> 
> Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. 
> 
> Bitcoin?s push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.
> 
> 
> III. Flow of Operations
> ----------------------------------------
> 
> 
> Creation of the subscription:
> - - - - - - - - - - - - - - - - - - - - - - 
> 
> 1. The customer clicks 'subscribe' -> A message is sent to the merchant.
> 2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.
> 3. The wallet prompts the customer for authorization.
> 4. The customer authorizes (or denies) it.
> 5. The wallet sends the confirmation to the merchant.
> 6. The merchant confirms the subscription was created.
> 
> Ongoing payments:
> - - - - - - - - - - - - - - - -
> 
> From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.
> 
> Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.
> 
> 
> Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.
> 
> 
> In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments, ? match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.
> 
> Subscription change (optional):
> - - - - - - - - - - - - - - - - - - - - - - - - 
> 
> Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.
> 
> 1. The customer clicks 'upgrade', 'downgrade', ? -> A msg is sent to the merchant.
> 2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. 
> 3. The wallet prompts the customer for authorization.
> 4. The customer authorizes (or denies) it.
> 5. The wallet sends the confirmation to the merchant.
> 6. The merchant confirms the change in the subscription.
> 
> Cancellation of the subscription:
> - - - - - - - - - - - - - - - - - - - - - - - - - 
> 
> The cancellation is initiated from the customer:
> 
> 1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.
> 2. The wallet sends a message to the merchant to inform about the cancellation.
> 3. The merchant confirms the subscription was cancelled.
> 
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140207/6ca3ee7f/attachment.html>

From stephane at kill-bill.org  Sun Feb  9 02:48:06 2014
From: stephane at kill-bill.org (Stephane Brossier)
Date: Sat, 8 Feb 2014 18:48:06 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
Message-ID: <DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>

Mike, Gavin,


We started to work on the merchant side to test the integration of our prototype for the recurring payments. We modified the 'Payment Request Generator' from Gavin to include a new check box 'set recurring'. We forked the code and checked in our modification here: https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3

We also found a few issues with the code diff that we sent yesterday for bitcoinj and checked in the bug fixes  in our fork-- so the diff sent yesterday is slightly outdated.

So at this point we have a working prototype for bitcoinj and we are waiting for your feedbacks. We also started to look at integrating the protocol in Kill Bill to check that what is proposed supports indeed the business cases of a full recurring billing platform.

Hope to hear from you guys soon!


On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org> wrote:

> Mike and all,
> 
> Pierre and I just committed a prototype implementation of the recurring payment protocol using bitcoinj. You can find the diff on our fork: 
> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7
> 
> We did not write the server (merchant side), but wanted to have some feedback before going deeper (merchant implementation and tests). We did our best to build it on top of the existing BIP-0070 protocol-- only a few additions in the messages, but no new calls and no new uri scheme. We created a new package 'recurring' where most of the new code lives.
> 
> At a high level:
> 
> 1. Creation of the subscription:
> 
> The initial handshake for creating the subscription is exactly similar to the one for the payment protocol (PaymentRequest is used to provide the contract)
> 
> 2. Wallet can decide to poll the merchants for its active subscriptions.
> 
> Here the flow is exactly similar to the payment protocol but the wallet receives a callback to verify the payment matches the contract and should go through.
> 
> Please give us some feedback whenever you have the chance. In the meantime we will start implementing the merchant side and test the code.
> 
> Cheers!
> 
> 
> 
> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:
> 
>> That looks OK at a very high level. Things you probably want to think about:
>> How to trigger it off the existing payment protocol (no new top level messages or mime types or uri extensions please)
>> Data structures to define the payment schedule
>> Do you allow pre-submission of time locked transactions or not?
>> I think as you prototype these things will become clearer.  You could try prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the PaymentSession class).
>> 
>> 
>> 
>> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org> wrote:
>> From what I have seen so far, there seems to be an agreement that this is a nice feature to add.  We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.
>> 
>> 
>> We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:
>> * some feedbacks on the high level proposal
>> * additional requirements we might have missed
>> 
>> So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.
>> 
>> 
>>  
>> I. Abstract
>> ---------------
>> 
>> This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.
>> 
>> An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, ?). For the sake of discussion, we?ll focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.
>> 
>> 
>> II. Motivation
>> ------------------
>> 
>> Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. 
>> 
>> Bitcoin?s push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.
>> 
>> 
>> III. Flow of Operations
>> ----------------------------------------
>> 
>> 
>> Creation of the subscription:
>> - - - - - - - - - - - - - - - - - - - - - - 
>> 
>> 1. The customer clicks 'subscribe' -> A message is sent to the merchant.
>> 2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.
>> 3. The wallet prompts the customer for authorization.
>> 4. The customer authorizes (or denies) it.
>> 5. The wallet sends the confirmation to the merchant.
>> 6. The merchant confirms the subscription was created.
>> 
>> Ongoing payments:
>> - - - - - - - - - - - - - - - -
>> 
>> From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.
>> 
>> Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.
>> 
>> 
>> Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.
>> 
>> 
>> In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments, ? match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.
>> 
>> Subscription change (optional):
>> - - - - - - - - - - - - - - - - - - - - - - - - 
>> 
>> Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.
>> 
>> 1. The customer clicks 'upgrade', 'downgrade', ? -> A msg is sent to the merchant.
>> 2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. 
>> 3. The wallet prompts the customer for authorization.
>> 4. The customer authorizes (or denies) it.
>> 5. The wallet sends the confirmation to the merchant.
>> 6. The merchant confirms the change in the subscription.
>> 
>> Cancellation of the subscription:
>> - - - - - - - - - - - - - - - - - - - - - - - - - 
>> 
>> The cancellation is initiated from the customer:
>> 
>> 1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.
>> 2. The wallet sends a message to the merchant to inform about the cancellation.
>> 3. The merchant confirms the subscription was cancelled.
>> 
>> 
>> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140208/c439679a/attachment.html>

From pete at petertodd.org  Sun Feb  9 17:12:14 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 9 Feb 2014 12:12:14 -0500
Subject: [Bitcoin-development] Embedded consensus system upgrade procedures
Message-ID: <20140209171214.GA20126@savin>

The Problem
===========

We have an embedded consensus system and we want to be able to upgrade
it with new rules. There inevitably will be a transition period where
some users use clients that interpret the new rules, while others only
interpret the old rules. Since we only rely on the host consensus system
for timestamped proof-of-publication the the miner-vote soft-fork
upgrade mechanism;(1) there are no validating miners in the system to
whome trust can be outsourced.

We have a problem: messages encoding actions, such as moving as asset
from one owner to another, can be published on the the blockchain
according to new and old rules simultaneously, double-spending the
asset. Potentially a user with the old v1 software may be tricked into
accepting an asset when the consensus of the v2 software is that the
asset has already been spent, and the v1-visible transaction is invalid.


Solution
========

Split actions into a separate "decrement" and "increment" operations,
and ensure that v1 software can see the "decrement" of a balance, spend
of a transaction output etc. even if it does not see the corresponding
increment operation. This solves the double-spend problem and ensures v1
users can't be ripped off. With obvious analogy to the PoW case, we will
refer to this general principle as a embedded consensus system
soft-fork.

Note how with the Colored Coins technology this principle happens
implicitly and with miner validation: colored coins are valid
transaction outputs known to the host consensus system and moving them
from one owner to another is guaranteed to result in the desctruction of
the colored coin from the point of view of any older software version.
Older software that does not support the newer colored coin kernel
specified by the new asset definition will simply see the respective
coins be destroyed in invalid transactions. Note how this implies that
asset definitions created by issuers should be careful to ensure that
kernels chosen should be designed such that the actioned specified by
one kernel can-not be interpreted differently by another; kernels should
be clearly incompatible with each other.


Balance-based systems
=====================

Mastercoin is a balance-based system where transactions increment and
decrement balances. Being balance-based, and lacking pruning, an even
simplier "scorched earth" approach will be used where each address is
associated with a maximum version number seen by transactions signed by
the address. Addresses with a max version number higher than what the
software understands are considered to be null and have no value of any
kind. (counterparty would be wise to do the same)


Upgrading implementation
========================

Implementations should record in their databases the blockhash
associated with transactions that were not recognized yet affected the
state of the consensus. For instance a colored coin implementation
should record the blockhash and transaction ID where a given coin was
destroyed in an invalid transaction; after upgrading these "last
transaction understood" markers can be used to replay blockchain data to
arrive at the new consensus.

Similarly in the case of the Mastercoin system balances associated with
addresses that have been frozen should be still allowed to increment so
that replaying blockchain data from the last recognized transaction
arrives at a upgraded consensus.

As an aside, any embedded consensus system would be wise to have a way
of generating a master digest representing the state of the consensus in
the database. The Bitcoin Core gettxoutsetinfo command is a good model,
which provides hash_serialized, a digest representing the entire UTXO
set. In all systems this is useful for ensuring that different
implementations and instances have in fact arrived at a consensus.


1) BIP-16, Pay to Script Hash,
   https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/af0f5c1e/attachment.sig>

From luke at dashjr.org  Sun Feb  9 17:25:41 2014
From: luke at dashjr.org (Luke-Jr)
Date: Sun, 9 Feb 2014 17:25:41 +0000
Subject: [Bitcoin-development] Embedded consensus system upgrade
	procedures
In-Reply-To: <20140209171214.GA20126@savin>
References: <20140209171214.GA20126@savin>
Message-ID: <201402091725.42306.luke@dashjr.org>

On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:
> We have an embedded consensus system and we want to be able to upgrade
> it with new rules.

This asserts a central authority and gives developers too much power.



From pete at petertodd.org  Sun Feb  9 18:04:58 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 9 Feb 2014 13:04:58 -0500
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
Message-ID: <20140209180458.GB20126@savin>

Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE
that allows colored coins and similar embedded consensus system assets
to be securely transferred to another party in exchange for Bitcoins
atomically. In summary his p2p 2-step-trade mechanism operates as
follows:

Alice controls a colored txout and wishes to sell it for 1BTC. Bob
wishes to buy that txout.

Alice signs a scriptSig using SIGHASH_SINGLE|ANYONECANPAY for a
transaction with a that time. (albeit a offer floor) single input, the
colored txout, and a single output with a scriptPubKey she controls and
nValue=1 This transaction is not valid as the value out is greater than
the value in.

She gives this partial transaction to Bob. He can now complete the
transaction by providing one or more inputs with a sum value >=1BTC, one
output for the colored coins to be directed to, and optionally any other
outputs required. (for instance for change)

Bob signs his inputs with SIGHASH_ALL and broadcasts the transaction,
completing the trade.

What Alice has signed, the first txin scriptSig, guarantees that if the
colored txout is spent she will receive 1BTC. Meanwhile what Bob has
signed, all other txin scriptSigs, sign the colored input and output,
guaranteeing that he will receive his coin in exchange for his money.
Thus the trade is trust free and atomic.


Decentralized markets and honest pricing
========================================

We can extend Mizrahi's 2-step-trade mechanism to create a decentralized
marketplace. First of all, remember that traders wishing to sell their
assets want to be sure that their assets offers reach the 100% of the
audience who may wish to buy said assets; an attacker may try to
manipulate the market to depress the price of an asset by hiding offers
from potential buyers. Similarly buyers want assurance that the offers
they are responding to represent all offers available.

Proof-of-publication(2) offers a solution. Alice can embed her
incomplete transaction as data in a second, valid, transaction. She
broadcasts this secondary transaction to some agreed upon blockchain,
either the one the colored coin is in, or potentially a secondary system
with suitable proof-of-publication security. Bidders such as Bob can now
scan the blockchain for offers with an acceptable price. (the offers can
make use of techniques like prefix filters to allow Bob to only scan
part of the blockchain, although Bob needs to know the status of all
assets of the type he is interested in anyway)

There is still some potential for manipulation with very recent offers,
particularly those embedded in unconfirmed transactions. However
typically markets have a large number of long-standing offers, which in
this case would be committed to the blockchain with one or more
confirmations.

Interestingly such a system can also provide honest historical pricing
information: any offer that goes unfilled for one or more blocks has (in
theory) been honestly published to 100% of those watching the blockchain
at that time. Thus we can assume the unfufilled offers at any
given block height are honest information about the market at that time
historically.

The overhead involved involved in Alice publishing the offer is roughly
a doubling of the overall transaction fees consumed. (remember that the
offer transaction is incomplete, and about half the size of the
acceptance transaction)


Application to other embedded consensus systems
===============================================

Any embedded consensus system can make use of the 2-step-trade mechanism
so long as it is possible to create transactions where spending a single
transaction output moves an asset appropriately.

Unfortunately extending this to circumstances where more than one input
needs to be spent, or more than out output needs to be created, is
difficult. SIGHASH_SINGLE by itself results in a signature where the
index of the output is signed, but the contents - scriptPubKey and
nValue - of all other outputs is not signed. Meanwhile all transaction
inputs are signed and changes to that set, other than modifying the
nSequence value in each CTxIn, is not possible.

If there was a SIGHASH mode that merely truncated vin and vout based on
the index of the scriptSig we could commit to data in either, but
unfortunately we can't do that.

An alternative could be to create a mechanism where some embedded data
signified the creation of a temporary transfer txout, where spending
that txout made the underlying change desired in the consensus state
atomically.


1) Alex Mizrahi, color kernel design considerations, Jan 7th 2014,
   Colored coins (BitcoinX) mailing list,
   https://groups.google.com/d/msg/bitcoinx/pON4XCIBeV4/IvzwkU8Vch0J

2) Peter Todd, [Bitcoin-development] Disentangling Crypto-Coin Mining:
   Timestamping, Proof-of-Publication, and Validation, Nov 19 2013,
   https://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03307.html

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/8c5bec2d/attachment.sig>

From pete at petertodd.org  Sun Feb  9 18:09:38 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 9 Feb 2014 13:09:38 -0500
Subject: [Bitcoin-development] Embedded consensus system upgrade
 procedures
In-Reply-To: <201402091725.42306.luke@dashjr.org>
References: <20140209171214.GA20126@savin> <201402091725.42306.luke@dashjr.org>
Message-ID: <20140209180938.GC20126@savin>

On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:
> On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:
> > We have an embedded consensus system and we want to be able to upgrade
> > it with new rules.
> 
> This asserts a central authority and gives developers too much power.

Please, the rule change only can happen if users accept it.

If anything my proposed mechanism makes it even harder for developers to
impose anything by fiat: the spending your digital asset under new rules
decreases the amount available of it to trade with users who chose to
accept only the old rules. Since there is no safety concern involved,
the process is safe for both groups, developers can't plea to the
community that "OMG the sky will fall and you'll be all defrauded if you
don't upgrade right now!!!" Instead they'll be forced to make it clear
that if the community doesn't accept the new rules, whatever assets
you've moved to the new system may become forever worthless.

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/ac8bba1c/attachment.sig>

From hozer at hozed.org  Sun Feb  9 18:11:32 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Sun, 9 Feb 2014 12:11:32 -0600
Subject: [Bitcoin-development] Embedded consensus system upgrade
 procedures
In-Reply-To: <201402091725.42306.luke@dashjr.org>
References: <20140209171214.GA20126@savin> <201402091725.42306.luke@dashjr.org>
Message-ID: <20140209181132.GF3180@nl.grid.coop>

On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:
> On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:
> > We have an embedded consensus system and we want to be able to upgrade
> > it with new rules.
> 
> This asserts a central authority and gives developers too much power.

I don't quite see how, There is nothing that 'forces' me to upgrade,
unless I have chosen to run an operating system (MacOS, Windows, Android)
that have automatic don't-ask-the-user update mechanisms.

The bigger problem with 'asset transfer' of assets which do not exist 
soley in the blockchain is including the consensus of relevant local and
distributed legal jurisdictions.

For example, just because the 'colored coin' and blockchain consensus is
that I 'electronically' signed a mortgage document giving some random 
internet company the rights to foreclose on my home does not mean that 
my local county Judge or Sheriff are going to do anything if the internet
company cannot produce the original paper document with ink signature.

The only 'assertion' of central authority here is people who download and
run the code and submit to whatever the code asserts they are supposed to do.

At least with the 'central authority' of the big-business bitcoin developer
cabal I can read the code before I submit to it's central authority, and
this is a significant improvement over amgibuous legislation or proprietary
high-frequency trading algorithms.



From pete at petertodd.org  Sun Feb  9 18:38:31 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 9 Feb 2014 13:38:31 -0500
Subject: [Bitcoin-development] Embedded consensus system upgrade
 procedures
In-Reply-To: <20140209181132.GF3180@nl.grid.coop>
References: <20140209171214.GA20126@savin> <201402091725.42306.luke@dashjr.org>
	<20140209181132.GF3180@nl.grid.coop>
Message-ID: <20140209183831.GA8878@savin>

On Sun, Feb 09, 2014 at 12:11:32PM -0600, Troy Benjegerdes wrote:
> On Sun, Feb 09, 2014 at 05:25:41PM +0000, Luke-Jr wrote:
> > On Sunday, February 09, 2014 5:12:14 PM Peter Todd wrote:
> > > We have an embedded consensus system and we want to be able to upgrade
> > > it with new rules.
> > 
> > This asserts a central authority and gives developers too much power.
> 
> I don't quite see how, There is nothing that 'forces' me to upgrade,
> unless I have chosen to run an operating system (MacOS, Windows, Android)
> that have automatic don't-ask-the-user update mechanisms.
> 
> The bigger problem with 'asset transfer' of assets which do not exist 
> soley in the blockchain is including the consensus of relevant local and
> distributed legal jurisdictions.
> 
> For example, just because the 'colored coin' and blockchain consensus is
> that I 'electronically' signed a mortgage document giving some random 
> internet company the rights to foreclose on my home does not mean that 
> my local county Judge or Sheriff are going to do anything if the internet
> company cannot produce the original paper document with ink signature.
> 
> The only 'assertion' of central authority here is people who download and
> run the code and submit to whatever the code asserts they are supposed to do.
> 
> At least with the 'central authority' of the big-business bitcoin developer
> cabal I can read the code before I submit to it's central authority, and
> this is a significant improvement over amgibuous legislation or proprietary
> high-frequency trading algorithms.

Standard Disclaimer: Digital asset transfer systems are fundementally
fancy accounting systems; no amount of code can, by itself, make data
represent a physical or legal entity. Only consensus and/or authorities
in the "real world" can do that. Crypto-currencies are only a partial
exception to that rule, and only because a scarce asset that can be
transferred digitally appears to have potential to be broadly useful.

Those considering investing in or otherwise devoting resources to the
creation of digital asset transfer systems should be warned that their
value in general remains unproven and losing some or all of your
investment is very possible, even probable. I myself have doubts that
these systems serve real-world business needs, but the only way to find
out is to build them and see.

Peter Todd
Chief Scientist
Mastercoin


Anyway, the best we can do is build good tools. Dwelling on the
underlying metaphysical nature of what those tools may or may not do
from a social perspective is frankly off-topic on this email list.

-- 
'peter'[:-1]@petertodd.org
000000000000000075829f6169c79d7d5aaa20bfa8da6e9edb2393c4f8662ba0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/c3d887d7/attachment.sig>

From hozer at hozed.org  Sun Feb  9 19:02:49 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Sun, 9 Feb 2014 13:02:49 -0600
Subject: [Bitcoin-development] Embedded consensus system upgrade
 procedures
In-Reply-To: <20140209183831.GA8878@savin>
References: <20140209171214.GA20126@savin> <201402091725.42306.luke@dashjr.org>
	<20140209181132.GF3180@nl.grid.coop> <20140209183831.GA8878@savin>
Message-ID: <20140209190249.GG3180@nl.grid.coop>

> > The only 'assertion' of central authority here is people who download and
> > run the code and submit to whatever the code asserts they are supposed to do.
> > 
> > At least with the 'central authority' of the big-business bitcoin developer
> > cabal I can read the code before I submit to it's central authority, and
> > this is a significant improvement over amgibuous legislation or proprietary
> > high-frequency trading algorithms.
> 
> Standard Disclaimer: Digital asset transfer systems are fundementally
> fancy accounting systems; no amount of code can, by itself, make data
> represent a physical or legal entity. Only consensus and/or authorities
> in the "real world" can do that. Crypto-currencies are only a partial
> exception to that rule, and only because a scarce asset that can be
> transferred digitally appears to have potential to be broadly useful.

How do I document in the embedded consensus system what the ruling in
a small-claims court about the ownership of a contested asset was?

Good accounting systems (such as mercurial, and proper double-entry 
financial accounting tools) allow reverting a bad commit, or bad data
entry, while maintaining records of the history. Not as good accounting
systems (like git) allow you to re-write history. What's the equivalent
user interface, process, and wire protocol for reversing a fraudulent
transaction while maintaining a full audit trail?

Courts can't legislate our code, and we can't expect them to download
and trust our 'distributed de-centralized' digital asset tracking system
that will be downloaded from a single centralized developer website
unless we meet them at least halfway, and probably need to propose model
municipal and county ordinances that go along with our code releases.

> Those considering investing in or otherwise devoting resources to the
> creation of digital asset transfer systems should be warned that their
> value in general remains unproven and losing some or all of your
> investment is very possible, even probable. I myself have doubts that
> these systems serve real-world business needs, but the only way to find
> out is to build them and see.

I would agree 100% that we need to build them, test the code, use them,
and then *try them in court*, and make sure we can explain in very simple
plain language what an 'embedded consensus system' is to the distributed 
de-centralized local court systems.



From pete at petertodd.org  Sun Feb  9 20:44:34 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 9 Feb 2014 15:44:34 -0500
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140209180458.GB20126@savin>
References: <20140209180458.GB20126@savin>
Message-ID: <20140209204434.GA11488@savin>

On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:
> Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE
> that allows colored coins and similar embedded consensus system assets
> to be securely transferred to another party in exchange for Bitcoins
> atomically. In summary his p2p 2-step-trade mechanism operates as
> follows:

I'm told there's probably at least one if not more earlier
attributions/reinventions for the 2-step-trade protocol using
SIGHASH_SINGLE. Please reply with them if you have them so we can give
credit where credit is due.

-- 
'peter'[:-1]@petertodd.org
0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/ce15a7d6/attachment.sig>

From pieter.wuille at gmail.com  Sun Feb  9 23:33:02 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 10 Feb 2014 00:33:02 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with malleability
Message-ID: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>

Hello all,

it was something I planned to do since a long time, but with the
recent related issues popping up, I finally got around to writing a
BIP about how we can get rid of transaction malleability over time.

The proposed document is here: https://gist.github.com/sipa/8907691

I expect most rules to not be controversial. Maybe rules 1 and 3, as
they require modifications to wallet software (Bitcoin Core 0.9 and
BitcoinJ already implement it, though) and potentially invalidate some
script functionality. However, these new rules remain optional and
controlled by an nVersion increase.

Comments please!

-- 
Pieter



From odinn.cyberguerrilla at riseup.net  Mon Feb 10 00:31:51 2014
From: odinn.cyberguerrilla at riseup.net (Odinn Cyberguerrilla)
Date: Sun, 9 Feb 2014 16:31:51 -0800
Subject: [Bitcoin-development] Malware authors and best practices for
 addressing the issue from development / licensing perspective or other
Message-ID: <e7fa1100d6d6077002a3c04f4fbf0f49.squirrel@fulvetta.riseup.net>

Hello,

I have a request, which is how do developers address the circumstance in
which someone utilizes your code as part of some effort to deprive (or
steal as the case may be) someone of their bitcoin?

This hasn't happened to me, but I have posed a question about it at
bitcointalk:

https://bitcointalk.org/index.php?topic=454903.msg5045596#msg5045596

It was prompted by the apparent use of sx by a malware author who then
generated something called Stealthbit (which is malware, and which no-one
should touch).  [fortunately I have not tried to access or use
Stealthbit.)  However, this is a question that also touches on bitcoin
development generally, due to that (it's happened before, it will happen
again, etc.) people may end up using bitcoin code (if they haven't
already) to develop something else that would then be used expressly to
deprive someone of their bitcoins (such as steal them, but I am not
thinking only of theft here).  My question for developers is:  Given that
code is open source and anything can be done with it, good or bad, what
are common development approaches to mitigate or potentially prevent
malware authors from being able to easily appropriate the code you
develop?

I realize this question may sound dumb and out of place being that it is
pretty obvious that code which is developed in a free, open source context
can technically be used for anything.  However, beyond suggesting that
people just go to bitcoin.org for wallet technology, what can be done in
the development community that would lessen the likelihood that the code
you develop might be "misappropriated?"  Please note: I am not sure how
this issue might be approached from a development perspective, or license
(MIT, Affero GPL, etc.) perspective, or any other perspective.. I'm just
asking the question.  I support bitcoin and other decentralized currency
efforts including walled development such as darkwallet, and I appreciate
what you all are doing.  Maybe I'm asking the wrong question and it should
be put another way, but I hope you will rephrase my question(s) in a way
that makes more sense in the context of the list discussion here.

Thanks for your work.




From pete at petertodd.org  Mon Feb 10 03:00:48 2014
From: pete at petertodd.org (Peter Todd)
Date: Sun, 9 Feb 2014 22:00:48 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
 malleability
In-Reply-To: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
Message-ID: <20140210030048.GB31925@savin>

On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:
> Hello all,
> 
> it was something I planned to do since a long time, but with the
> recent related issues popping up, I finally got around to writing a
> BIP about how we can get rid of transaction malleability over time.
> 
> The proposed document is here: https://gist.github.com/sipa/8907691
> 
> I expect most rules to not be controversial. Maybe rules 1 and 3, as
> they require modifications to wallet software (Bitcoin Core 0.9 and
> BitcoinJ already implement it, though) and potentially invalidate some
> script functionality. However, these new rules remain optional and
> controlled by an nVersion increase.
> 
> Comments please!

You should probably add making CHECKMULTISIG require the dummy value to
be exactly equal to OP_FALSE; verifying that in the transaction itself is
laborious. A more subtle example is we may want both CHECKSIG and
CHECKMULTISIG to fail the transaction if the signature is invalid but
not exactly equal to OP_FALSE; some transaction forms are significantly
more compact if you can have failed signatures, but that's a source of
malleability. (are there counter examples people can think of?)


But as I said on IRC, I'm a bit hesitant to bake in assumptions about
malleability when we have no solid idea if ECC signatures are or are not
malleable on a fundemental level; if "whack-a-mole" anti-malleability is
all we've got it could be ugly if a break is found. Similarly, we may
find we missed something, or some needed change makes the malleability
rules difficult to work with for some new script type that is required.

I'd rather see a new CHECKSIG mode for the case where malleability
absolutely must be eliminated - certain multi-party protocols - and fix
wallet software instead. (the malleability problems people see are
closely related to inability to handle double-spends and reorgs) But I
can easily see that being an impossible goal engineering wise...

-- 
'peter'[:-1]@petertodd.org
0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140209/a2c80f9b/attachment.sig>

From luke at dashjr.org  Mon Feb 10 04:39:28 2014
From: luke at dashjr.org (Luke-Jr)
Date: Mon, 10 Feb 2014 04:39:28 +0000
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
Message-ID: <201402100439.29419.luke@dashjr.org>

On Sunday, February 09, 2014 11:33:02 PM Pieter Wuille wrote:
> The proposed document is here: https://gist.github.com/sipa/8907691

Rule 3 & 4 are already enforced.

AFAIK nVersion==3 transactions are not currently considered non-standard?

Luke



From drak at zikula.org  Mon Feb 10 11:28:28 2014
From: drak at zikula.org (Drak)
Date: Mon, 10 Feb 2014 11:28:28 +0000
Subject: [Bitcoin-development] MtGox blames bitcoin
Message-ID: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>

What is the official response from the Bitcoin Core developers about
MtGox's assertion that their problems are due to a fault of bitcoin, as
opposed to a fault of their own?

The technical analysis preluding this mess, was that MtGox was at fault for
their faulty wallet implementation.

Drak
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/dd667928/attachment.html>

From sickpig at gmail.com  Mon Feb 10 11:54:36 2014
From: sickpig at gmail.com (sickpig at gmail.com)
Date: Mon, 10 Feb 2014 12:54:36 +0100
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
Message-ID: <CA+c4Zowae-YHE6yqfM_z1MUzTANBgOv=jH3ZR+EtT5Q+TWDz6Q@mail.gmail.com>

Hi,

On Mon, Feb 10, 2014 at 12:28 PM, Drak <drak at zikula.org> wrote:
> What is the official response from the Bitcoin Core developers about MtGox's
> assertion that their problems are due to a fault of bitcoin, as opposed to a
> fault of their own?
>
> The technical analysis preluding this mess, was that MtGox was at fault for
> their faulty wallet implementation.

this seems a fair explanation of what happened:

http://www.reddit.com/r/Bitcoin/comments/1x93tf/some_irc_chatter_about_what_is_going_on_at_mtgox/cf99yac



From gmaxwell at gmail.com  Mon Feb 10 12:25:34 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 10 Feb 2014 04:25:34 -0800
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
Message-ID: <CAAS2fgTx8UzQiocyNMfMNkt2uUZRTmhagb2BY9TPuAupVjVa2g@mail.gmail.com>

On Mon, Feb 10, 2014 at 3:28 AM, Drak <drak at zikula.org> wrote:
> What is the official response from the Bitcoin Core developers about MtGox's
> assertion that their problems are due to a fault of bitcoin, as opposed to a
> fault of their own?
>
> The technical analysis preluding this mess, was that MtGox was at fault for
> their faulty wallet implementation.

In the real world fault seldom falls in a single place. Bitcoin is at
fault? in many places? for making it harder for implementers to get
things right.   MtGox is at fault for not implementing in a way that
copes with behaviors in the Bitcoin protocol which have been known
since at least 2011.
(https://en.bitcoin.it/wiki/Transaction_Malleability).

Not that Bitcoin-QT handles Malleability fantastically? but because it
tracks inputs it will still detect the mutant transactions.

An interesting point which I haven't pointed out elsewhere is that for
the question of basic funds safety in re-issuing a transaction
mallablity is basically irrelevant.

Say you pay someone and it doesn't go through (or it does and you
don't see it because its been mutated and your software can't detect
that), and they ask you to reissue.... if you reissue without
double-spending any of the original inputs you are at risk of getting
robbed. This is true with or without malleability.  Without the
double-spend of at least one input the original transaction could just
go through in addition to your reissue.

Say that you do make sure to double spend at least one input?  then
the result is funds safe safe, regardless of if a mutation happened.

Say you want to support _canceling_ a payment (send me the goat
instead!) rather than reissue you still must double-spend the
attempted payment to cancel it, since it still might go through if you
don't.  And the double spend works to protect this case regardless of
if the transaction was mutated.

For support and accounting purposes you absolutely do need tools to
identify mutated transactions, so long as mutation exists... so we
ought to provide some better tools there.  But I can't think a case
where mutation handling is necessary or sufficient for cancellation
security, but? rather? input tracking appears to be both necessary and
sufficient in all cancellation cases.

This helps explain why Bitcoin-QT? whos mutation handling kinda
stinks? doesn't ever end up in a really bad situation with mutants: it
tracks inputs pretty well.

In any case, I've always been happy to help out Mtgox with technical
issues. Having some specs for a stable transaction ID would probably
be helpful to many applications, even if it isn't the critical key you
need for cancellation security.  Removing mallability entirely has
been a soft long term goal, and there were recently (as in today) some
posts about it? look at the list archives... though it won't happen
fast since all signers/wallets will need to be updated.



From pieter.wuille at gmail.com  Mon Feb 10 12:28:42 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 10 Feb 2014 13:28:42 +0100
Subject: [Bitcoin-development] Malleability and MtGox's announcement
Message-ID: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>

Hi all,

I was a bit surprised to see MtGox's announcement. The malleability of
transactions was known for years already (see for example the wiki
article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,
or mails on this list from 2012 and 2013). I don't consider it a very
big problem, but it does make it harder for infrastructure to interact
with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
avoid it altogether to make life easier for everyone.

But we can't just change all infrastructure that exists today. We're
slowly working towards making malleability harder (and hopefully
impossible someday), but this will take a long time. For example, 0.8
not supporting non-DER encoded signatures was a step in that direction
(and ironically, the trigger that caused MtGox's initial problems
here). In any case, this will take years, and nobody should wait for
this.

There seem to be two more direct problems here.
* Wallets which deal badly with modified txids.
* Services that use the transaction id to detect unconfirming transactions.

The first is something that needs to be done correctly in software -
it just needs to be aware of malleability.

The second is something I was unaware of and would have advised
against. If you plan on reissuing a transaction because on old version
doesn't confirm, make sure to make it a double spend of the first one
- so that not both can confirm.

I certainly don't like press making this sound like a problem in the
Bitcoin protocol or clients. I think this is an issue that needs to be
solved at the layer above - the infrastructure building on the Bitcoin
system. Despite that, I do think that we (as a community, not just
developers) can benefit from defining a standard way to identify
transactions unambiguously. This is something Mark Karpeles suggested
a few days ago, and my proposal is this:

We define the normalized transaction id as SHA256^2(normalized_tx +
0x01000000), where normalized_tx is the transaction with all input
scripts replaced by empty scripts. This is exactly what would be
signed inside transaction signatures using SIGHASH_ALL (except not
substituting the previous scriptPubKey to be signed, and not dealing
with the input being signed specially). An implementation is here:
https://github.com/sipa/bitcoin/commits/normtxid.

Note that this is not a solution for all problems related to
malleability, but maybe it can make people more aware of it, in
tangible way.

-- 
Pieter



From bitcoin-development at lists.sourceforge.net  Mon Feb 10 14:40:03 2014
From: bitcoin-development at lists.sourceforge.net (Isidor Zeuner)
Date: Mon, 10 Feb 2014 15:40:03 +0100 (CET)
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
Message-ID: <20140210144003.2BDCCDDAEFC@quidecco.de>

>
> What is the official response from the Bitcoin Core developers about
> MtGox's assertion that their problems are due to a fault of bitcoin, as
> opposed to a fault of their own?
>
> The technical analysis preluding this mess, was that MtGox was at fault for
> their faulty wallet implementation.
>

I'm not a core developer, but I would certainly hope that those
who have commit access to the Bitcoin repository don't let
themselves be pressured by a company holding back user funds in order
to get a patch included into the Bitcoin source code.

I think this is less a matter of whose fault it is if a company
running a custom wallet implementation has problems peering with a
network mostly running another, community-based wallet
implementation. It is a matter of common sense that it's just not
practical to try to quickly apply an update to a distributed network,
which may possibly cause problems with peering and consensus
finding. When working with a protocol based on mutual agreement of a
large user base, a single entity like MtGox would be better off trying
to have their preferred changes implemented slowly if at all, while
solving their immediate issues on their side. Problems with
transactions being accepted can often be solved by changing the wallet
client's way of peering with other nodes, without changing the
protocol at all.

Thinking this further, I am kind of surprised that something like this
can even become an issue worth discussing. I never heard of a bank
which would try to create pressure by suspending money withdrawals
until the TCP/IP protocol is changed to match their preferences.

Best regards,

Isidor Zeuner



From hozer at hozed.org  Mon Feb 10 16:14:02 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Mon, 10 Feb 2014 10:14:02 -0600
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
Message-ID: <20140210161402.GI3180@nl.grid.coop>

Okay, why the everloving FUCK is there not someone on this list with a
@mtgox.com address talking about this?

I started using bitcoin because I could audit the code, and when the
developer cabal does stuff 'off-list' what you do is hand over market 
manipulation power to the selected cabal of company insiders who are
discussing things 'off-list'. 

The people having a 'private' discussion about how to solve this are
TAKING MONEY from everyone else, by having access to insider information.

I don't think any of the developers actually have a clue this is the 
result, because a good chunk of them are employed by for-profit companies
funded by venture capital, and VC lawyers are very good at writing 
employment contracts that provide plausible deniability of insider 
trading.

The press MAKES MONEY (okay, takes money) by manipulating markets,
and venture capitalists pay lots of money to ensure the market is
manipulated in ways they can profit from.

Private market manipulation is one of the costs of anonymity and privacy,
and I don't really like paying for some off-list discussion of what appears
to be a serious scalability and usability problem.

Bitcoin is such a powerful tool because it broadcasts transactions to
the network for everyone to see. 

Can we please broadcast some more technical details to this mailing list,
including exactly what MtGox is doing, and how they wish to resolve it?

If you gave me the entire code stack that MtGox runs on under an AGPLv3
license, I'm pretty sure I, along with everyone else here could come up
with a workable solution. I think a code release would be a huge win 
for MtGox as well, and would cement their position as market leader in
transparent cryptocurrency trading.

Otherwise we are just a bunch of dinghys getting capsized one by one
in a sea of market-manipulating white whales. Isn't the closed door
market manipulation of the big banks one of the reasons we all started
using Bitcoin in the first place?

Why do revolutions always put the same old bullshit back in power?

What we need is some transparent code evolution.

On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:
> Hi all,
> 
> I was a bit surprised to see MtGox's announcement. The malleability of
> transactions was known for years already (see for example the wiki
> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,
> or mails on this list from 2012 and 2013). I don't consider it a very
> big problem, but it does make it harder for infrastructure to interact
> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
> avoid it altogether to make life easier for everyone.
> 
> But we can't just change all infrastructure that exists today. We're
> slowly working towards making malleability harder (and hopefully
> impossible someday), but this will take a long time. For example, 0.8
> not supporting non-DER encoded signatures was a step in that direction
> (and ironically, the trigger that caused MtGox's initial problems
> here). In any case, this will take years, and nobody should wait for
> this.
> 
> There seem to be two more direct problems here.
> * Wallets which deal badly with modified txids.
> * Services that use the transaction id to detect unconfirming transactions.
> 
> The first is something that needs to be done correctly in software -
> it just needs to be aware of malleability.
> 
> The second is something I was unaware of and would have advised
> against. If you plan on reissuing a transaction because on old version
> doesn't confirm, make sure to make it a double spend of the first one
> - so that not both can confirm.
> 
> I certainly don't like press making this sound like a problem in the
> Bitcoin protocol or clients. I think this is an issue that needs to be
> solved at the layer above - the infrastructure building on the Bitcoin
> system. Despite that, I do think that we (as a community, not just
> developers) can benefit from defining a standard way to identify
> transactions unambiguously. This is something Mark Karpeles suggested
> a few days ago, and my proposal is this:
> 
> We define the normalized transaction id as SHA256^2(normalized_tx +
> 0x01000000), where normalized_tx is the transaction with all input
> scripts replaced by empty scripts. This is exactly what would be
> signed inside transaction signatures using SIGHASH_ALL (except not
> substituting the previous scriptPubKey to be signed, and not dealing
> with the input being signed specially). An implementation is here:
> https://github.com/sipa/bitcoin/commits/normtxid.
> 
> Note that this is not a solution for all problems related to
> malleability, but maybe it can make people more aware of it, in
> tangible way.
> 
> -- 
> Pieter
> 
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From hozer at hozed.org  Mon Feb 10 16:30:55 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Mon, 10 Feb 2014 10:30:55 -0600
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <20140210144003.2BDCCDDAEFC@quidecco.de>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
Message-ID: <20140210163055.GJ3180@nl.grid.coop>

On Mon, Feb 10, 2014 at 03:40:03PM +0100, Isidor Zeuner wrote:
> >
> > What is the official response from the Bitcoin Core developers about
> > MtGox's assertion that their problems are due to a fault of bitcoin, as
> > opposed to a fault of their own?
> >
> > The technical analysis preluding this mess, was that MtGox was at fault for
> > their faulty wallet implementation.
> >
> 
> I'm not a core developer, but I would certainly hope that those
> who have commit access to the Bitcoin repository don't let
> themselves be pressured by a company holding back user funds in order
> to get a patch included into the Bitcoin source code.

This isn't about developers.

This is about venture capitalists taking lots of money from unsuspecting
investors, and MtGox is in a psy-ops PR-war with multiple other exchanges
and lots of places that would like to take their market share and money.

Why do you want the 'official' PR-spin-war response approved by the official
bitcoin developer PR-firm, who's probably being paid by competitors to MtGox?

Name me one single person with commit access to the bitcoin github repository
who is *independent* of any venture capital or other 'investment' connections.

Fortunately for the rest of us, any dumb farmer can create a copycatcoin

Hell, if MtGox hosted their *own* fork of bitcoin I'd run that in a heartbeat.


And for full disclosure, I am available for consulting if anyone would like 
assistance setting up and hosting an independent source code repository that
includes good automated regression tests.


-- Troy



From gmaxwell at gmail.com  Mon Feb 10 16:45:03 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 10 Feb 2014 08:45:03 -0800
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <20140210163055.GJ3180@nl.grid.coop>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
Message-ID: <CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>

On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:
> Name me one single person with commit access to the bitcoin github repository
> who is *independent* of any venture capital or other 'investment' connections.

I am, unless you count the fact that I own some Bitcoin and some
mining hardware as "'investment' connections" (and that case your
comments are worthless).

(By not naming anyone else I don't mean to imply there are no others,
but I don't want to speak for anyone else. Nor would I necessarily
expect the other part(ies|y) to step forward, since this mostly
appears to be an invitation to step up and be attacked.)



From drak at zikula.org  Mon Feb 10 16:49:21 2014
From: drak at zikula.org (Drak)
Date: Mon, 10 Feb 2014 16:49:21 +0000
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <20140210144003.2BDCCDDAEFC@quidecco.de>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
Message-ID: <CANAnSg0OUuETUhbQYoXHf12yxBHsZ_czBwxbtD8Btg9E+cJTOg@mail.gmail.com>

Well done Gavin for quickly setting the record straight[1] officially as
project lead. MtGox tried to blame their issues by throwing Bitcoin under a
bus and I am glad there has been a public rebuttal showing up their
incompetence which is doing harm to the bitcoin eco system. Basically, yes
there are issues, but MtGox should have worked around it.

Also thanks to Gregory for also writing[2] about the matter.

Drak

[1] https://bitcoinfoundation.org/blog/?p=418
[2]
http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/f7a24071/attachment.html>

From nick at mynicknet.com  Mon Feb 10 16:57:03 2014
From: nick at mynicknet.com (Nick Simpson)
Date: Mon, 10 Feb 2014 10:57:03 -0600
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <20140210161402.GI3180@nl.grid.coop>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
	<20140210161402.GI3180@nl.grid.coop>
Message-ID: <2d588a9e-9a85-41c1-82ce-e26c791a1022@email.android.com>

You must be new here. MtGox very rarely comments on things like this publicly, outside of irc or their website. 

Second, MtGox problem is a MtGox problem. You have no right to demand access to their private code. If you feel wronged as a customer, sue them. Otherwise, they have no obligation to you.

I believe you are "barking up the wrong tree".

Respectfully,

Nick

On February 10, 2014 10:14:02 AM CST, Troy Benjegerdes <hozer at hozed.org> wrote:
>Okay, why the everloving FUCK is there not someone on this list with a
>@mtgox.com address talking about this?
>
>I started using bitcoin because I could audit the code, and when the
>developer cabal does stuff 'off-list' what you do is hand over market 
>manipulation power to the selected cabal of company insiders who are
>discussing things 'off-list'. 
>
>The people having a 'private' discussion about how to solve this are
>TAKING MONEY from everyone else, by having access to insider
>information.
>
>I don't think any of the developers actually have a clue this is the 
>result, because a good chunk of them are employed by for-profit
>companies
>funded by venture capital, and VC lawyers are very good at writing 
>employment contracts that provide plausible deniability of insider 
>trading.
>
>The press MAKES MONEY (okay, takes money) by manipulating markets,
>and venture capitalists pay lots of money to ensure the market is
>manipulated in ways they can profit from.
>
>Private market manipulation is one of the costs of anonymity and
>privacy,
>and I don't really like paying for some off-list discussion of what
>appears
>to be a serious scalability and usability problem.
>
>Bitcoin is such a powerful tool because it broadcasts transactions to
>the network for everyone to see. 
>
>Can we please broadcast some more technical details to this mailing
>list,
>including exactly what MtGox is doing, and how they wish to resolve it?
>
>If you gave me the entire code stack that MtGox runs on under an AGPLv3
>license, I'm pretty sure I, along with everyone else here could come up
>with a workable solution. I think a code release would be a huge win 
>for MtGox as well, and would cement their position as market leader in
>transparent cryptocurrency trading.
>
>Otherwise we are just a bunch of dinghys getting capsized one by one
>in a sea of market-manipulating white whales. Isn't the closed door
>market manipulation of the big banks one of the reasons we all started
>using Bitcoin in the first place?
>
>Why do revolutions always put the same old bullshit back in power?
>
>What we need is some transparent code evolution.
>
>On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:
>> Hi all,
>> 
>> I was a bit surprised to see MtGox's announcement. The malleability
>of
>> transactions was known for years already (see for example the wiki
>> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability
>it,
>> or mails on this list from 2012 and 2013). I don't consider it a very
>> big problem, but it does make it harder for infrastructure to
>interact
>> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
>> avoid it altogether to make life easier for everyone.
>> 
>> But we can't just change all infrastructure that exists today. We're
>> slowly working towards making malleability harder (and hopefully
>> impossible someday), but this will take a long time. For example, 0.8
>> not supporting non-DER encoded signatures was a step in that
>direction
>> (and ironically, the trigger that caused MtGox's initial problems
>> here). In any case, this will take years, and nobody should wait for
>> this.
>> 
>> There seem to be two more direct problems here.
>> * Wallets which deal badly with modified txids.
>> * Services that use the transaction id to detect unconfirming
>transactions.
>> 
>> The first is something that needs to be done correctly in software -
>> it just needs to be aware of malleability.
>> 
>> The second is something I was unaware of and would have advised
>> against. If you plan on reissuing a transaction because on old
>version
>> doesn't confirm, make sure to make it a double spend of the first one
>> - so that not both can confirm.
>> 
>> I certainly don't like press making this sound like a problem in the
>> Bitcoin protocol or clients. I think this is an issue that needs to
>be
>> solved at the layer above - the infrastructure building on the
>Bitcoin
>> system. Despite that, I do think that we (as a community, not just
>> developers) can benefit from defining a standard way to identify
>> transactions unambiguously. This is something Mark Karpeles suggested
>> a few days ago, and my proposal is this:
>> 
>> We define the normalized transaction id as SHA256^2(normalized_tx +
>> 0x01000000), where normalized_tx is the transaction with all input
>> scripts replaced by empty scripts. This is exactly what would be
>> signed inside transaction signatures using SIGHASH_ALL (except not
>> substituting the previous scriptPubKey to be signed, and not dealing
>> with the input being signed specially). An implementation is here:
>> https://github.com/sipa/bitcoin/commits/normtxid.
>> 
>> Note that this is not a solution for all problems related to
>> malleability, but maybe it can make people more aware of it, in
>> tangible way.
>> 
>> -- 
>> Pieter
>> 
>>
>------------------------------------------------------------------------------
>> Managing the Performance of Cloud-Based Applications
>> Take advantage of what the Cloud has to offer - Avoid Common
>Pitfalls.
>> Read the Whitepaper.
>>
>http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>------------------------------------------------------------------------------
>Managing the Performance of Cloud-Based Applications
>Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>Read the Whitepaper.
>http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/7dc4dfba/attachment.html>

From hozer at hozed.org  Mon Feb 10 17:54:17 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Mon, 10 Feb 2014 11:54:17 -0600
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <CANOOu=_rQfRORmbEWz=1MVk9dK26ddiCeyeHMaua6iyioBUr4g@mail.gmail.com>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
	<20140210161402.GI3180@nl.grid.coop>
	<CANOOu=_rQfRORmbEWz=1MVk9dK26ddiCeyeHMaua6iyioBUr4g@mail.gmail.com>
Message-ID: <20140210175417.GK3180@nl.grid.coop>

I cannot judge the competence of code I've never seen, so I have no
position on that.

What I HAVE seen quite clearly is both overt and covert market 
manipulation under cover of blame for 'the developers', or 'the exchange'

You're doing it yourself with the phrase 'incompetence'. When you run an
exchange of that volume, then maybe you might be in a position to say so,
but if you were *invested* in a competitor to MtGox you'd make a lot of
money calling them incompetent, wouldn't you?

I'm looking to drum up some consulting business by making my observations
about market manipulation public, and if I can't drum up any business, at
least I can speak my mind free of any non-disclsosure agreements.

What do you stand to gain from your statements on this list?


On another note, is there any third-party archive of bitcointalk.org?
I much prefer mailing lists because *I* have an archive.

On Mon, Feb 10, 2014 at 11:39:19AM -0500, Christophe Biocca wrote:
> The bug MtGox is blaming has been documented on the wiki for years.
> Mark Karpeles was on IRC publicly discussing the topic
> https://bitcointalk.org/index.php?topic=458076.msg5052255#msg5052255
> MtGox's incompetence has been on public display since day 1.
> 
> I'm not sure what critical information you think secret cabals are
> keeping from you.
> 
> On Mon, Feb 10, 2014 at 11:14 AM, Troy Benjegerdes <hozer at hozed.org> wrote:
> > Okay, why the everloving FUCK is there not someone on this list with a
> > @mtgox.com address talking about this?
> >
> > I started using bitcoin because I could audit the code, and when the
> > developer cabal does stuff 'off-list' what you do is hand over market
> > manipulation power to the selected cabal of company insiders who are
> > discussing things 'off-list'.
> >
> > The people having a 'private' discussion about how to solve this are
> > TAKING MONEY from everyone else, by having access to insider information.
> >
> > I don't think any of the developers actually have a clue this is the
> > result, because a good chunk of them are employed by for-profit companies
> > funded by venture capital, and VC lawyers are very good at writing
> > employment contracts that provide plausible deniability of insider
> > trading.
> >
> > The press MAKES MONEY (okay, takes money) by manipulating markets,
> > and venture capitalists pay lots of money to ensure the market is
> > manipulated in ways they can profit from.
> >
> > Private market manipulation is one of the costs of anonymity and privacy,
> > and I don't really like paying for some off-list discussion of what appears
> > to be a serious scalability and usability problem.
> >
> > Bitcoin is such a powerful tool because it broadcasts transactions to
> > the network for everyone to see.
> >
> > Can we please broadcast some more technical details to this mailing list,
> > including exactly what MtGox is doing, and how they wish to resolve it?
> >
> > If you gave me the entire code stack that MtGox runs on under an AGPLv3
> > license, I'm pretty sure I, along with everyone else here could come up
> > with a workable solution. I think a code release would be a huge win
> > for MtGox as well, and would cement their position as market leader in
> > transparent cryptocurrency trading.
> >
> > Otherwise we are just a bunch of dinghys getting capsized one by one
> > in a sea of market-manipulating white whales. Isn't the closed door
> > market manipulation of the big banks one of the reasons we all started
> > using Bitcoin in the first place?
> >
> > Why do revolutions always put the same old bullshit back in power?
> >
> > What we need is some transparent code evolution.
> >
> > On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:
> >> Hi all,
> >>
> >> I was a bit surprised to see MtGox's announcement. The malleability of
> >> transactions was known for years already (see for example the wiki
> >> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,
> >> or mails on this list from 2012 and 2013). I don't consider it a very
> >> big problem, but it does make it harder for infrastructure to interact
> >> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
> >> avoid it altogether to make life easier for everyone.
> >>
> >> But we can't just change all infrastructure that exists today. We're
> >> slowly working towards making malleability harder (and hopefully
> >> impossible someday), but this will take a long time. For example, 0.8
> >> not supporting non-DER encoded signatures was a step in that direction
> >> (and ironically, the trigger that caused MtGox's initial problems
> >> here). In any case, this will take years, and nobody should wait for
> >> this.
> >>
> >> There seem to be two more direct problems here.
> >> * Wallets which deal badly with modified txids.
> >> * Services that use the transaction id to detect unconfirming transactions.
> >>
> >> The first is something that needs to be done correctly in software -
> >> it just needs to be aware of malleability.
> >>
> >> The second is something I was unaware of and would have advised
> >> against. If you plan on reissuing a transaction because on old version
> >> doesn't confirm, make sure to make it a double spend of the first one
> >> - so that not both can confirm.
> >>
> >> I certainly don't like press making this sound like a problem in the
> >> Bitcoin protocol or clients. I think this is an issue that needs to be
> >> solved at the layer above - the infrastructure building on the Bitcoin
> >> system. Despite that, I do think that we (as a community, not just
> >> developers) can benefit from defining a standard way to identify
> >> transactions unambiguously. This is something Mark Karpeles suggested
> >> a few days ago, and my proposal is this:
> >>
> >> We define the normalized transaction id as SHA256^2(normalized_tx +
> >> 0x01000000), where normalized_tx is the transaction with all input
> >> scripts replaced by empty scripts. This is exactly what would be
> >> signed inside transaction signatures using SIGHASH_ALL (except not
> >> substituting the previous scriptPubKey to be signed, and not dealing
> >> with the input being signed specially). An implementation is here:
> >> https://github.com/sipa/bitcoin/commits/normtxid.
> >>
> >> Note that this is not a solution for all problems related to
> >> malleability, but maybe it can make people more aware of it, in
> >> tangible way.
> >>
> >> --
> >> Pieter
> >>
> >> ------------------------------------------------------------------------------
> >> Managing the Performance of Cloud-Based Applications
> >> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> >> Read the Whitepaper.
> >> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> >> _______________________________________________
> >> Bitcoin-development mailing list
> >> Bitcoin-development at lists.sourceforge.net
> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
> > ------------------------------------------------------------------------------
> > Managing the Performance of Cloud-Based Applications
> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> > Read the Whitepaper.
> > http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From hozer at hozed.org  Mon Feb 10 18:02:58 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Mon, 10 Feb 2014 12:02:58 -0600
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <2d588a9e-9a85-41c1-82ce-e26c791a1022@email.android.com>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
	<20140210161402.GI3180@nl.grid.coop>
	<2d588a9e-9a85-41c1-82ce-e26c791a1022@email.android.com>
Message-ID: <20140210180258.GL3180@nl.grid.coop>

A bitcoin problem is not really my problem, and if MtGox's investors 
can't seem to understand the value of publishing their code, I'll 
be happy to take their money as it leaves bitcoin for more distributed
and transparent cryptocurrency ecosystems.

I feel some sort of moral obligation to point out to this community 
when something stupid is going on, and if you think a MtGox problem 
is not a Bitcoin problem then I can't really help you, all I can do
is point out my observations and facts as I see them, and then execute
trades to relieve those who choose to ignore these facts of their money.

Happy trading


On Mon, Feb 10, 2014 at 10:57:03AM -0600, Nick Simpson wrote:
> You must be new here. MtGox very rarely comments on things like this publicly, outside of irc or their website. 
> 
> Second, MtGox problem is a MtGox problem. You have no right to demand access to their private code. If you feel wronged as a customer, sue them. Otherwise, they have no obligation to you.
> 
> I believe you are "barking up the wrong tree".
> 
> Respectfully,
> 
> Nick
> 
> On February 10, 2014 10:14:02 AM CST, Troy Benjegerdes <hozer at hozed.org> wrote:
> >Okay, why the everloving FUCK is there not someone on this list with a
> >@mtgox.com address talking about this?
> >
> >I started using bitcoin because I could audit the code, and when the
> >developer cabal does stuff 'off-list' what you do is hand over market 
> >manipulation power to the selected cabal of company insiders who are
> >discussing things 'off-list'. 
> >
> >The people having a 'private' discussion about how to solve this are
> >TAKING MONEY from everyone else, by having access to insider
> >information.
> >
> >I don't think any of the developers actually have a clue this is the 
> >result, because a good chunk of them are employed by for-profit
> >companies
> >funded by venture capital, and VC lawyers are very good at writing 
> >employment contracts that provide plausible deniability of insider 
> >trading.
> >
> >The press MAKES MONEY (okay, takes money) by manipulating markets,
> >and venture capitalists pay lots of money to ensure the market is
> >manipulated in ways they can profit from.
> >
> >Private market manipulation is one of the costs of anonymity and
> >privacy,
> >and I don't really like paying for some off-list discussion of what
> >appears
> >to be a serious scalability and usability problem.
> >
> >Bitcoin is such a powerful tool because it broadcasts transactions to
> >the network for everyone to see. 
> >
> >Can we please broadcast some more technical details to this mailing
> >list,
> >including exactly what MtGox is doing, and how they wish to resolve it?
> >
> >If you gave me the entire code stack that MtGox runs on under an AGPLv3
> >license, I'm pretty sure I, along with everyone else here could come up
> >with a workable solution. I think a code release would be a huge win 
> >for MtGox as well, and would cement their position as market leader in
> >transparent cryptocurrency trading.
> >
> >Otherwise we are just a bunch of dinghys getting capsized one by one
> >in a sea of market-manipulating white whales. Isn't the closed door
> >market manipulation of the big banks one of the reasons we all started
> >using Bitcoin in the first place?
> >
> >Why do revolutions always put the same old bullshit back in power?
> >
> >What we need is some transparent code evolution.
> >
> >On Mon, Feb 10, 2014 at 01:28:42PM +0100, Pieter Wuille wrote:
> >> Hi all,
> >> 
> >> I was a bit surprised to see MtGox's announcement. The malleability
> >of
> >> transactions was known for years already (see for example the wiki
> >> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability
> >it,
> >> or mails on this list from 2012 and 2013). I don't consider it a very
> >> big problem, but it does make it harder for infrastructure to
> >interact
> >> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
> >> avoid it altogether to make life easier for everyone.
> >> 
> >> But we can't just change all infrastructure that exists today. We're
> >> slowly working towards making malleability harder (and hopefully
> >> impossible someday), but this will take a long time. For example, 0.8
> >> not supporting non-DER encoded signatures was a step in that
> >direction
> >> (and ironically, the trigger that caused MtGox's initial problems
> >> here). In any case, this will take years, and nobody should wait for
> >> this.
> >> 
> >> There seem to be two more direct problems here.
> >> * Wallets which deal badly with modified txids.
> >> * Services that use the transaction id to detect unconfirming
> >transactions.
> >> 
> >> The first is something that needs to be done correctly in software -
> >> it just needs to be aware of malleability.
> >> 
> >> The second is something I was unaware of and would have advised
> >> against. If you plan on reissuing a transaction because on old
> >version
> >> doesn't confirm, make sure to make it a double spend of the first one
> >> - so that not both can confirm.
> >> 
> >> I certainly don't like press making this sound like a problem in the
> >> Bitcoin protocol or clients. I think this is an issue that needs to
> >be
> >> solved at the layer above - the infrastructure building on the
> >Bitcoin
> >> system. Despite that, I do think that we (as a community, not just
> >> developers) can benefit from defining a standard way to identify
> >> transactions unambiguously. This is something Mark Karpeles suggested
> >> a few days ago, and my proposal is this:
> >> 
> >> We define the normalized transaction id as SHA256^2(normalized_tx +
> >> 0x01000000), where normalized_tx is the transaction with all input
> >> scripts replaced by empty scripts. This is exactly what would be
> >> signed inside transaction signatures using SIGHASH_ALL (except not
> >> substituting the previous scriptPubKey to be signed, and not dealing
> >> with the input being signed specially). An implementation is here:
> >> https://github.com/sipa/bitcoin/commits/normtxid.
> >> 
> >> Note that this is not a solution for all problems related to
> >> malleability, but maybe it can make people more aware of it, in
> >> tangible way.
> >> 
> >> -- 
> >> Pieter
> >> 
> >>
> >------------------------------------------------------------------------------
> >> Managing the Performance of Cloud-Based Applications
> >> Take advantage of what the Cloud has to offer - Avoid Common
> >Pitfalls.
> >> Read the Whitepaper.
> >>
> >http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> >> _______________________________________________
> >> Bitcoin-development mailing list
> >> Bitcoin-development at lists.sourceforge.net
> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
> >------------------------------------------------------------------------------
> >Managing the Performance of Cloud-Based Applications
> >Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> >Read the Whitepaper.
> >http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> >_______________________________________________
> >Bitcoin-development mailing list
> >Bitcoin-development at lists.sourceforge.net
> >https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From hozer at hozed.org  Mon Feb 10 18:25:06 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Mon, 10 Feb 2014 12:25:06 -0600
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
Message-ID: <20140210182506.GM3180@nl.grid.coop>

On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:
> On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:
> > Name me one single person with commit access to the bitcoin github repository
> > who is *independent* of any venture capital or other 'investment' connections.
> 
> I am, unless you count the fact that I own some Bitcoin and some
> mining hardware as "'investment' connections" (and that case your
> comments are worthless).
> 
> (By not naming anyone else I don't mean to imply there are no others,
> but I don't want to speak for anyone else. Nor would I necessarily
> expect the other part(ies|y) to step forward, since this mostly
> appears to be an invitation to step up and be attacked.)

Thank you.

I also appreciate your commentary[1], and willingness to list your investment
position. What I'm concerned about are people who have signed non-disclosure 
agreements or who's salary/equity/whatever depend on people who are experts
at manipulating markets to take naive investors money.

Independent is also a state of mind as much as it is about financial connections.

What pisses me off here is that a huge amount of wealth just changed hands based
on MtGox's press release, and it stinks of insider trading. I still maintain the
best outcome would be for MtGox to AGPLv3 release their code, and then those of 
us that understand it would be able to have a public technical discussion about
how to fix it, and MtGox would still maintain their intellectual property
ownership position.

This, however, cuts off a significant revenue stream for people who take money
making market bets 5 minutes before the information goes public, so I expect
the likelyhood of such an outbreak of sanity is quite low.

[1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/


DISCLAIMER: I have a significant emotional investment in copyleft/viral copyright
development models, and I expect to take a lot of money charging people to write
code I give away for free. I also occasionally make money from cryptocurrency
mining, but only when I can sell it in functional and transparent markets.



From jameson.lopp at gmail.com  Mon Feb 10 18:45:58 2014
From: jameson.lopp at gmail.com (Jameson Lopp)
Date: Mon, 10 Feb 2014 13:45:58 -0500
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <20140210182506.GM3180@nl.grid.coop>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>	<20140210144003.2BDCCDDAEFC@quidecco.de>	<20140210163055.GJ3180@nl.grid.coop>	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop>
Message-ID: <52F91E66.6060305@gmail.com>

You have plenty of good points, but they are not relevant to this mailing list. I suggest you take them elsewhere.
--
Jameson Lopp
Software Engineer
Bronto Software, Inc

On 02/10/2014 01:25 PM, Troy Benjegerdes wrote:
> On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:
>> On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:
>>> Name me one single person with commit access to the bitcoin github repository
>>> who is *independent* of any venture capital or other 'investment' connections.
>>
>> I am, unless you count the fact that I own some Bitcoin and some
>> mining hardware as "'investment' connections" (and that case your
>> comments are worthless).
>>
>> (By not naming anyone else I don't mean to imply there are no others,
>> but I don't want to speak for anyone else. Nor would I necessarily
>> expect the other part(ies|y) to step forward, since this mostly
>> appears to be an invitation to step up and be attacked.)
> 
> Thank you.
> 
> I also appreciate your commentary[1], and willingness to list your investment
> position. What I'm concerned about are people who have signed non-disclosure 
> agreements or who's salary/equity/whatever depend on people who are experts
> at manipulating markets to take naive investors money.
> 
> Independent is also a state of mind as much as it is about financial connections.
> 
> What pisses me off here is that a huge amount of wealth just changed hands based
> on MtGox's press release, and it stinks of insider trading. I still maintain the
> best outcome would be for MtGox to AGPLv3 release their code, and then those of 
> us that understand it would be able to have a public technical discussion about
> how to fix it, and MtGox would still maintain their intellectual property
> ownership position.
> 
> This, however, cuts off a significant revenue stream for people who take money
> making market bets 5 minutes before the information goes public, so I expect
> the likelyhood of such an outbreak of sanity is quite low.
> 
> [1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/
> 
> 
> DISCLAIMER: I have a significant emotional investment in copyleft/viral copyright
> development models, and I expect to take a lot of money charging people to write
> code I give away for free. I also occasionally make money from cryptocurrency
> mining, but only when I can sell it in functional and transparent markets.
> 
> ------------------------------------------------------------------------------
> Android&trade; apps run on BlackBerry&reg;10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 



From gavinandresen at gmail.com  Mon Feb 10 18:53:16 2014
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Mon, 10 Feb 2014 13:53:16 -0500
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <52F91E66.6060305@gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
Message-ID: <CABsx9T1nOZN1E8=zQfFct-gy+e7YOic49Kfcpz4T7Mg-UQo4Qg@mail.gmail.com>

RE: taking discussion elsewhere:

Yes, please, the purpose of this mailing list is technical discussions to
encourage interoperability of Bitcoin implementations, improve ease-of-use
and security, etc.

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/165de986/attachment.html>

From hozer at hozed.org  Mon Feb 10 19:07:03 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Mon, 10 Feb 2014 13:07:03 -0600
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <52F91E66.6060305@gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
Message-ID: <20140210190703.GO3180@nl.grid.coop>

If you've got any ideas for a better forum, let me know.

MtGox is one of the largest public faces of the code being developed here. If
the public perception is that this is a bitcoin protocol flaw, then we need
some damned strong and compelling public arguments about why it ain't so. But
after some thought, that's not the critical issue I want to raise on this list.

If something about the implementation, the protocol, of bitcoin-qt or bitcoind
makes it easy for an attacker to mutate transactions and hard for an 'end-user'
such as MtGox to confirm payments, then we've got a fundamental user-interface
flaw.

We can get all indignant about RTFM or telling the users they are idiots, but
that's not really going to be good for long-term adoption and use.

My opinion is part of the development process should be to react to public
perceptions of how the code is being used (and mis-used), and how the market is
being manipulated, and try to improve it so the whole system is stable,
predictable, and friendly to users.


On Mon, Feb 10, 2014 at 01:45:58PM -0500, Jameson Lopp wrote:
> You have plenty of good points, but they are not relevant to this mailing list. I suggest you take them elsewhere.
> --
> Jameson Lopp
> Software Engineer
> Bronto Software, Inc
> 
> On 02/10/2014 01:25 PM, Troy Benjegerdes wrote:
> > On Mon, Feb 10, 2014 at 08:45:03AM -0800, Gregory Maxwell wrote:
> >> On Mon, Feb 10, 2014 at 8:30 AM, Troy Benjegerdes <hozer at hozed.org> wrote:
> >>> Name me one single person with commit access to the bitcoin github repository
> >>> who is *independent* of any venture capital or other 'investment' connections.
> >>
> >> I am, unless you count the fact that I own some Bitcoin and some
> >> mining hardware as "'investment' connections" (and that case your
> >> comments are worthless).
> >>
> >> (By not naming anyone else I don't mean to imply there are no others,
> >> but I don't want to speak for anyone else. Nor would I necessarily
> >> expect the other part(ies|y) to step forward, since this mostly
> >> appears to be an invitation to step up and be attacked.)
> > 
> > Thank you.
> > 
> > I also appreciate your commentary[1], and willingness to list your investment
> > position. What I'm concerned about are people who have signed non-disclosure 
> > agreements or who's salary/equity/whatever depend on people who are experts
> > at manipulating markets to take naive investors money.
> > 
> > Independent is also a state of mind as much as it is about financial connections.
> > 
> > What pisses me off here is that a huge amount of wealth just changed hands based
> > on MtGox's press release, and it stinks of insider trading. I still maintain the
> > best outcome would be for MtGox to AGPLv3 release their code, and then those of 
> > us that understand it would be able to have a public technical discussion about
> > how to fix it, and MtGox would still maintain their intellectual property
> > ownership position.
> > 
> > This, however, cuts off a significant revenue stream for people who take money
> > making market bets 5 minutes before the information goes public, so I expect
> > the likelyhood of such an outbreak of sanity is quite low.
> > 
> > [1] http://www.cryptocoinsnews.com/2014/02/10/mt-gox-blames-bitcoin-core-developer-greg-maxwell-responds/
> > 
> > 
> > DISCLAIMER: I have a significant emotional investment in copyleft/viral copyright
> > development models, and I expect to take a lot of money charging people to write
> > code I give away for free. I also occasionally make money from cryptocurrency
> > mining, but only when I can sell it in functional and transparent markets.
> > 
> > ------------------------------------------------------------------------------
> > Android&trade; apps run on BlackBerry&reg;10
> > Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> > Now with support for Jelly Bean, Bluetooth, Mapview and more.
> > Get your Android app in front of a whole new audience.  Start now.
> > http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> > 
> 
> ------------------------------------------------------------------------------
> Androi apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From pete at petertodd.org  Mon Feb 10 19:23:08 2014
From: pete at petertodd.org (Peter Todd)
Date: Mon, 10 Feb 2014 14:23:08 -0500
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <20140210190703.GO3180@nl.grid.coop>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop>
Message-ID: <20140210192308.GA17359@savin>

On Mon, Feb 10, 2014 at 01:07:03PM -0600, Troy Benjegerdes wrote:
> If you've got any ideas for a better forum, let me know.

Your political conversations would be welcome at unsystem at lists.dyne.org

See you there.

-- 
'peter'[:-1]@petertodd.org
0000000077ddbd0b6faa6d6fe50cdc7808dea5db5b538f85b736ede8515c54c7
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/eb5d602f/attachment.sig>

From namanhd at gmail.com  Mon Feb 10 19:30:21 2014
From: namanhd at gmail.com (naman naman)
Date: Tue, 11 Feb 2014 01:00:21 +0530
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <20140210192308.GA17359@savin>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop> <20140210192308.GA17359@savin>
Message-ID: <CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>

Hi guys,

Please check this thread
https://bitcointalk.org/index.php?topic=458608.0for a possible attack
scenario.

Already mailed Gavin, Mike Hearn and Adam about this :

See if it makes sense.


On Tue, Feb 11, 2014 at 12:53 AM, Peter Todd <pete at petertodd.org> wrote:

> On Mon, Feb 10, 2014 at 01:07:03PM -0600, Troy Benjegerdes wrote:
> > If you've got any ideas for a better forum, let me know.
>
> Your political conversations would be welcome at unsystem at lists.dyne.org
>
> See you there.
>
> --
> 'peter'[:-1]@petertodd.org
> 0000000077ddbd0b6faa6d6fe50cdc7808dea5db5b538f85b736ede8515c54c7
>
>
> ------------------------------------------------------------------------------
> Androi apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/304f18df/attachment.html>

From pete at petertodd.org  Mon Feb 10 19:32:47 2014
From: pete at petertodd.org (Peter Todd)
Date: Mon, 10 Feb 2014 14:32:47 -0500
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140209204434.GA11488@savin>
References: <20140209180458.GB20126@savin>
 <20140209204434.GA11488@savin>
Message-ID: <20140210193247.GC17359@savin>

On Sun, Feb 09, 2014 at 03:44:34PM -0500, Peter Todd wrote:
> On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:
> > Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE
> > that allows colored coins and similar embedded consensus system assets
> > to be securely transferred to another party in exchange for Bitcoins
> > atomically. In summary his p2p 2-step-trade mechanism operates as
> > follows:
> 
> I'm told there's probably at least one if not more earlier
> attributions/reinventions for the 2-step-trade protocol using
> SIGHASH_SINGLE. Please reply with them if you have them so we can give
> credit where credit is due.

Got this:

Message-ID: <52418EBA.3080602 at monetize.io>
Date: Tue, 24 Sep 2013 06:08:10 -0700
From: Mark Friedenbach <mark at monetize.io>
Organization: Monetize.io Inc.
To: Meni Rosenfeld <meni at bitcoil.co.il>
Subject: Re: Freimarkets and investment

If assets were tagged you could do a very limited form of pre-signed offers:

in: 10 btc SINGLE|ANYONECANPAY
out: 1 AAA

These are composable, in that you can append the inputs and outputs of
multiple offers together and result in a valid transaction. However this
is pretty much the limit of what is possible without adding new SIGHASH
modes, and if you're going to hard-fork to add tagging, then you might
as well go the whole distance with explicit hierarchical
sub-transactions as we did with Freimarkets.

Cheers,
Mark

On 9/24/13 5:44 AM, Meni Rosenfeld wrote:
> Hi Jorge,
> 
> The video was sent to me by Amos Meiri, I think eToro funded its production.
> 
> Maybe I don't understand SIGHASH_ANYONECANPAY very well. In the
> transaction, there will be an output of 1 "my stock" to an initially
> unknown address. Can I provide a signature for my input of 1 "my stock"
> that will be valid even with the output details provided later?
> 
> In any case, I think that's out of scope for the presentation.
> 
> Meni
> 
> On 24/09/2013 13:10, Jorge Tim?n wrote:
>> Yes, it's a nice presentation.
>> I love the video with the chameleons that you link at the end !!
>>
>> As a little sugestion, I think the biggest advantage of tagging is not
>> inflatable assets, it's open binding orders. Even without granular
>> subtransactions as freimarket has, you could sign your input (say,
>> representing 1 "My stock") and only the output you're interested in
>> (say 100 bitstampUSD to myAddress) with SIGHASH_SINGLE |
>> SIGHASH_ANYONECANPAY.
>>
>> Without tagging, you need to know where the inputs come from to check
>> they're really bitstampUSD, because the network won't enforce the "100
>> bistampUSD" in your output, any uncolored coins filling the btc
>> quantity you wanted to represent those 100 usd will be ok, for miners.
>>
>> Goog luck with the talk, I'm eager to hear it.
>>
>> By the way, Mark, the explanation of the blockchain image sounds a
>> little bit like hashcasttle, no? well, just merged mining every new
>> asset, sounds like jaromil's freecoin too.
>>
>>
>> On 9/24/13, Meni Rosenfeld <meni at bitcoil.co.il> wrote:
>>> Hi Mark,
>>>
>>> We currently have a more general mathematical framework for the concept of
>>> colored coins - a color is a combination of initial state and a kernel
>>> function that maps input colors to output colors. Order-based coloring is
>>> one such kernel function, tagging is another. As long as you can point at an
>>> output and say what its color is, we call it a colored coin system.
>>>
>>> The blockchain image is a stand-in for "using a new block chain for each
>>> asset".
>>>
>>> Meni
>>>
>>> On 24/09/2013 00:42, Mark Friedenbach wrote:
> Hi Meni,
> 
> I did call Freimarkets "colored coins" in the early days, but the term
> colored coin itself within the community seems to have become
> identified with the specific proposal of assigning value to specific
> satoshis, and running an order based coloring algorithm to determine
> asset flow, e.g. Bitcoin-X. Freimarkets allows issuance of entirely
> new assets and has explicit tagging of outputs, so we decided to avoid
> the phrase "colored coin" so as to keep from confusing people. But as
> an academic, yes you are correct.
> 
> You presentation looks great. BTW, what's the first logo for the
> "Alternative token systems" slide? Or is that just a stand-in for the
> block chain?
> 
> Mark
> 
> On 9/23/13 12:24 PM, Meni Rosenfeld wrote:
>>>>>> Hi,
>>>>>>
>>>>>> As you might know I'm giving a talk about Colored Coins in
>>>>>> Amsterdam.
>>>>>>
>>>>>> My presentation is available at
>>>>>> https://bitcoil.co.il/files/Colored Coins.pptx (I'm not posting
>>>>>> this link publicly until after the talk).
>>>>>>
>>>>>> I'll be happy for any feedback.
>>>>>>
>>>>>> I'm listing Freimarkets as an implementation of Colored Coins. It
>>>>>> doesn't look like you're identifying with the term, but it does fit
>>>>>> the definition (and though it does obviously do much more than
>>>>>> just implement colored coins.)
>>>>>>
>>>>>> Thanks, Meni
>>>>
>>>
>>
> 

-- 
'peter'[:-1]@petertodd.org
0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/a482ab35/attachment.sig>

From pete at petertodd.org  Mon Feb 10 19:40:32 2014
From: pete at petertodd.org (Peter Todd)
Date: Mon, 10 Feb 2014 14:40:32 -0500
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop> <20140210192308.GA17359@savin>
	<CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>
Message-ID: <20140210194032.GD17359@savin>

On Tue, Feb 11, 2014 at 01:00:21AM +0530, naman naman wrote:
> Hi guys,
> 
> Please check this thread
> https://bitcointalk.org/index.php?topic=458608.0for a possible attack
> scenario.
> 
> Already mailed Gavin, Mike Hearn and Adam about this :
> 
> See if it makes sense.

That's basically what appears to have happened with Mt. Gox.

Preventing the attack is as simple as training your customer service
people to ask the customer if their wallet software shows a payment to a
specific address of a specific amount at some approximate time. Making
exact payment amounts unique - add a few satoshis - is a trivial if
slightly ugly way of making sure payments can be identified uniquely
over the phone. That the procedure at Mt. Gox let front-line customer
service reps manually send funds to customers without a proper
investigation of why the funds didn't arrive was a serious mistake on
their part.

Ultimately this is more of a social engineering attack than a technical
one, and a good example of why well-thought-out payment protocols are
helpful. Though the BIP70 payment protocol doesn't yet handle busines to
individual, or individual to indivudal, payments a future iteration can
and this kind of problem will be less of an issue.

Similarly stealth addresses have an inherent per-tx unique identifier,
the derived pubkey, which a UI might be able to take advantage of.

-- 
'peter'[:-1]@petertodd.org
0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/eff54755/attachment.sig>

From bitcoin at olivere.de  Mon Feb 10 19:47:47 2014
From: bitcoin at olivere.de (Oliver Egginger)
Date: Mon, 10 Feb 2014 20:47:47 +0100
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
Message-ID: <52F92CE3.7080105@olivere.de>

Am 10.02.2014 13:28, schrieb Pieter Wuille:
> Hi all,
> 
> I was a bit surprised to see MtGox's announcement. The malleability of
> transactions was known for years already (see for example the wiki
> article on it, https://en.bitcoin.it/wiki/Transaction_Malleability it,
> or mails on this list from 2012 and 2013). I don't consider it a very
> big problem, but it does make it harder for infrastructure to interact
> with Bitcoin. If we'd design Bitcoin today, I'm sure we would try to
> avoid it altogether to make life easier for everyone.

Sorry, I'm not a developer, but I have got a question. It's a little bit
off-topic and can't maybe answered easy.

As I understand this attack someone renames the transaction ID before
being confirmed in the blockchain. Not easy but if he is fast enough it
should be possible. With a bit of luck for the attacker the new
transaction is added to the block chain and the original transaction is
discarded as double-spend. Right?

Up to this point the attacker has nothing gained. But next the attacker
stressed the Gox support and refers to the original transaction ID. Gox
was then probably fooled in such cases and has refunded already paid
Bitcoins to the attackers (virtual) Gox-wallet.

So far everything is clear. But what I do not understand: Why apparently
had so many customers of Gox payment defaults or severely delayed
payments? I would imagine that the attacker may have doubled not only
his own transaction (maybe for obfuscating the fraud). But then all
transfers would still have go through anyway. And a normal customers
would have been satisfied. Most people observe only their wallets, I
think. What am I missing here?

Sorry, is perhaps a silly question. But maybe you can put me on the
right track.

regards
Oliver







From gmaxwell at gmail.com  Mon Feb 10 20:40:03 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 10 Feb 2014 12:40:03 -0800
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <52F92CE3.7080105@olivere.de>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
	<52F92CE3.7080105@olivere.de>
Message-ID: <CAAS2fgRksY-KeD27unAWrNkt3BPjGHMFRis_kyrAfZN-zpyoag@mail.gmail.com>

On Mon, Feb 10, 2014 at 11:47 AM, Oliver Egginger <bitcoin at olivere.de> wrote:
> As I understand this attack someone renames the transaction ID before
> being confirmed in the blockchain. Not easy but if he is fast enough it
> should be possible. With a bit of luck for the attacker the new
> transaction is added to the block chain and the original transaction is
> discarded as double-spend. Right?
>
> Up to this point the attacker has nothing gained. But next the attacker
> stressed the Gox support and refers to the original transaction ID. Gox
> was then probably fooled in such cases and has refunded already paid
> Bitcoins to the attackers (virtual) Gox-wallet.

At this point the attack should fail. Before crediting the funds back Gox
should form a new transaction moving at least one of the coins the prior
transaction was spending and wait for that transaction to confirm.

Without performing this step? even if there were no malleability at all
you'd have the risk that someone would go resurrect the old transaction
and get a miner to mine it. Then it goes through.

With performing it, even if they missed the mutated transaction in the chain
their cancellation transaction could not confirm (because its a double spend).

> So far everything is clear. But what I do not understand: Why apparently
> had so many customers of Gox payment defaults or severely delayed
> payments?

Back in September a lot of people were having stuck transactions and
when I looked it was because Mtgox was spending immature coins: newly
generated coins which cannot be spent for 100 blocks since their creation.
(A rule since Bitcoin's started)

Then later it was noticed that they were producing transactions with invalid
DER encodings (excessively padded signatures). The Bitcoin network used
to accept these transactions, but in order to more towards eliminating
malleability
Bitcoin 0.8 and later will not relay and mine them.

Then after people started using mutation to fix those excessively padded
transactions and/or someone was exploiting Gox's behavior? it seems that
Gox's wallet may have been in a state where it thought a lot of coins weren't
spent that were and was reusing them in new transansactions... this one
is harder to tell externally? I saw it appeared to be producing a LOT of
double spends with different destinations, but I'm guessing as to the exact
cause.



From tier.nolan at gmail.com  Mon Feb 10 20:47:46 2014
From: tier.nolan at gmail.com (Tier Nolan)
Date: Mon, 10 Feb 2014 20:47:46 +0000
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <52F92CE3.7080105@olivere.de>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
	<52F92CE3.7080105@olivere.de>
Message-ID: <CAE-z3OUK0_8an3xAt3T1Sb_iFLNy=AWwiKZYnrURg_o=w0dmPg@mail.gmail.com>

On Mon, Feb 10, 2014 at 7:47 PM, Oliver Egginger <bitcoin at olivere.de> wrote:

> As I understand this attack someone renames the transaction ID before
> being confirmed in the blockchain. Not easy but if he is fast enough it
> should be possible. With a bit of luck for the attacker the new
> transaction is added to the block chain and the original transaction is
> discarded as double-spend. Right?
>

No, the problem was that the transaction MtGox produced was poorly
formatted.

It wouldn't cause a block containing the transaction to be rejected, but
the default client wouldn't relay the transaction or add it into a block.

This means that transaction stalls.

If the attacker has a direct connection to MtGox, they can receive the
transaction directly.

The attacker would fix the formatting (which changes the transaction id,
but doesn't change the signature) and then forward it to the network, as
normal.

The old transaction never propagates correctly.

Up to this point the attacker has nothing gained. But next the attacker
> stressed the Gox support and refers to the original transaction ID. Gox
> was then probably fooled in such cases and has refunded already paid
> Bitcoins to the attackers (virtual) Gox-wallet.
>

They sent out the transaction a second time.

The right solution is that the new transaction should re-spend at least one
of the coins that the first transaction spent.  That way only one can
possibly be accepted.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140210/a1da9e05/attachment.html>

From gmaxwell at gmail.com  Mon Feb 10 20:55:21 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 10 Feb 2014 12:55:21 -0800
Subject: [Bitcoin-development] Malleability and MtGox's announcement
In-Reply-To: <CAE-z3OUK0_8an3xAt3T1Sb_iFLNy=AWwiKZYnrURg_o=w0dmPg@mail.gmail.com>
References: <CAPg+sBi-phaw3hDgguk-LYrPsKX4M5snTJBv_NsQML1M=XgZEw@mail.gmail.com>
	<52F92CE3.7080105@olivere.de>
	<CAE-z3OUK0_8an3xAt3T1Sb_iFLNy=AWwiKZYnrURg_o=w0dmPg@mail.gmail.com>
Message-ID: <CAAS2fgR9D0Vzp+Yx+azLhrPgZmynOy9-g0Kx94of4rPPYnER0A@mail.gmail.com>

On Mon, Feb 10, 2014 at 12:47 PM, Tier Nolan <tier.nolan at gmail.com> wrote:
> If the attacker has a direct connection to MtGox, they can receive the
> transaction directly.
MtGox had a php script that returned base64 data for all their stalled
transactions.

Not just attackers used that, some people trying to unstick their
transactions tried manually fixing them with honest intent and no idea
it would potentially confuse mtgox's software.



From justusranvier at gmail.com  Tue Feb 11 06:05:25 2014
From: justusranvier at gmail.com (Justus Ranvier)
Date: Tue, 11 Feb 2014 00:05:25 -0600
Subject: [Bitcoin-development] Framework for modular input selection policy
	for Bitcoin wallets
In-Reply-To: <52F94B89.8020603@silicon>
References: <52F94B89.8020603@silicon>
Message-ID: <52F9BDA5.8040601@gmail.com>

One of the areas that isn't as well developed as it could be in terms of
wallet design is fine-grained control over input selection policy.

Coin control is great when a human is manually crafting transactions,
but that's not really a very scalable solution.

The attached image is a possible way to stack different independent
selection algorithms. If wallets implemented something like this, it
would be easy for other programs to implement new application-specific
algorithms that would not need to completely reinvent the wheel.

As an example, voting pools in Open-Transactions will implement cold
storage in a FIFO manner, meaning that UTXOs will be clustered into
groups which should be consumed in a specific sequence. Within that
constraint, however, they still want to minimize transaction size.

If wallets were designed to make selection policy modular, they'd only
need to implement their FIFO algorithm and stack it in before the
default algorithm. Surely this capability would be useful to other
projects as well.

It would also allow people who want to prioritize privacy over
transaction cost to easily modify the behavior of their clients and
would make it easier to incorporate new tx construction algorithms like
CoinJoin.

Link to the image in case attachment is stripped:
http://i.imgur.com/Fkkq7pI.png
-- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k

-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0x1B438BF4.asc
Type: application/pgp-keys
Size: 21174 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/c6ac92c8/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 538 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/c6ac92c8/attachment.sig>

From kgreenek at gmail.com  Tue Feb 11 10:00:53 2014
From: kgreenek at gmail.com (Kevin Greene)
Date: Tue, 11 Feb 2014 02:00:53 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
Message-ID: <CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>

Figured I would have a crack at reviewing this since Mike is out for a bit.
It was great running into you guys at the bitcoin fair in SF! Small world :)

I like how simple this is. You just give it an url to fetch the next
payment request and a date to fetch it.

What should happen if the client tries to fetch the PaymentRequest early or
late? Does it become valid after some date and stay valid for some length
of time? Also, what should happen if the client tries to consume the same
PaymentRequest twice (or multiple times) during the same period?

I do not think daily/weekly/monthly is flexible enough. What do you think
about having a concrete start time and end time when the next
PaymentRequest will be valid? This also prevents the wallet from having to
remember when it last sent a payment and getting skewed over time.

When a wallet hits the polling_url to download the next PaymentRequest, it
seems we need a way to communicate an error code to the wallet, for example
if the server canceled the contract without the wallet knowing. Perhaps a
separate polling_status_url, with a corresponding ACK message to indicate
if the PaymentRequest is available. What do you think of that idea?

One high-level comment -- the wallet in this design doesn't have any way of
knowing when the payments are supposed to end. I feel this is important to
show to the user before they start their wallet polling infinitely.




On Sat, Feb 8, 2014 at 6:48 PM, Stephane Brossier <stephane at kill-bill.org>wrote:

> Mike, Gavin,
>
>
> We started to work on the merchant side to test the integration of our
> prototype for the recurring payments. We modified the 'Payment Request
> Generator' from Gavin to include a new check box 'set recurring'. We forked
> the code and checked in our modification here:
> https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3
>
> We also found a few issues with the code diff that we sent yesterday for
> bitcoinj and checked in the bug fixes  in our fork-- so the diff sent
> yesterday is slightly outdated.
>
> So at this point we have a working prototype for bitcoinj and we are
> waiting for your feedbacks. We also started to look at integrating the
> protocol in Kill Bill to check that what is proposed supports indeed the
> business cases of a full recurring billing platform.
>
> Hope to hear from you guys soon!
>
>
> On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org>
> wrote:
>
> Mike and all,
>
> Pierre and I just committed a prototype implementation of the recurring
> payment protocol using bitcoinj. You can find the diff on our fork:
>
> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7
>
> We did not write the server (merchant side), but wanted to have some
> feedback before going deeper (merchant implementation and tests). We did
> our best to build it on top of the existing BIP-0070 protocol-- only a few
> additions in the messages, but no new calls and no new uri scheme. We
> created a new package 'recurring' where most of the new code lives.
>
> At a high level:
>
> 1. Creation of the subscription:
>
> The initial handshake for creating the subscription is exactly similar to
> the one for the payment protocol (PaymentRequest is used to provide the
> contract)
>
> 2. Wallet can decide to poll the merchants for its active subscriptions.
>
> Here the flow is exactly similar to the payment protocol but the wallet
> receives a callback to verify the payment matches the contract and should
> go through.
>
> Please give us some feedback whenever you have the chance. In the meantime
> we will start implementing the merchant side and test the code.
>
> Cheers!
>
>
>
> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:
>
> That looks OK at a very high level. Things you probably want to think
> about:
>
>    - How to trigger it off the existing payment protocol (no new top
>    level messages or mime types or uri extensions please)
>    - Data structures to define the payment schedule
>    - Do you allow pre-submission of time locked transactions or not?
>
> I think as you prototype these things will become clearer.  You could try
> prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the
> PaymentSession class).
>
>
>
> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org
> > wrote:
>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>> *From what I have seen so far, there seems to be an agreement that this
>> is a nice feature to add. We are pretty new to that community and so we
>> don't know exactly what the process is, and in particular how we reach
>> consensus via email. I am certainly open to follow 'the way' if there is
>> one, but one solution would be to follow Mike's suggestion on providing a
>> (prototype) implementation first and then defining/refining the BIP. Odinn
>> also suggested a possible retribution for our time through crowd-sourcing
>> which I am interested to pursue if that makes sense. We have quite some
>> experience on the subscription side of things and while we are growing our
>> knowledge on the Bitcoin technology (and ecosystem at large) we would
>> benefit from: * some feedbacks on the high level proposal * additional
>> requirements we might have missed So, below is a high level description of
>> what we have in mind. If this sounds reasonable, we could start working on
>> an implementation. I. Abstract --------------- This describes a protocol to
>> enable recurring payments in bitcoins and can be seen as an extension of
>> BIP-0070. The main goal here is to have the customer subscribe to a service
>> of some kind (that is, agreeing on the terms of that subscription
>> contract), and then have the wallet make recurring payments without any
>> intervention from the customer as long as the payments match what the
>> customer agreed on paying. An example of such service would be an online
>> streaming website, to which a user pays a fixed recurring monthly fee to
>> access videos (a.k.a. resources). Note that there is also usage based
>> billing: for example, the user may need to purchase additional access for
>> premium videos (overage charges). This type of billing is more complicated
>> and there are many variations to it used in the industry (pre-paid, ...). For
>> the sake of discussion, we'll focus on fixed recurring payments only, but
>> we will keep usage in mind to make sure the protocol will be able to
>> support it as well. II. Motivation ------------------ Subscription based
>> services have been growing in the past few years and so the intent it to
>> make it possible for customers to pay in bitcoins. Bitcoin's push model
>> presents new advantages for the customer compared to traditional payment
>> methods: the user has control over the subscription (for example, there is
>> no need to call the merchant to explicitly cancel the credit card
>> payments). It also opens the door to subscription management tools in
>> wallets (e.g. Hive apps), which would give user an overview of what they
>> are paying each month. III. Flow of
>> Operations----------------------------------------*
>>
>>
>>
>>
>> * Creation of the subscription: - - - - - - - - - - - - - - - - - - - - -
>> - 1. The customer clicks 'subscribe' -> A message is sent to the merchant.
>> 2. The merchant sends back a message to the wallet with the details of the
>> subscription such as the amount to be paid. In reality, there will be more
>> information but for the purpose of the prototype implementation this is
>> sufficient. 3. The wallet prompts the customer for authorization. 4. The
>> customer authorizes (or denies) it. 5. The wallet sends the confirmation to
>> the merchant. 6. The merchant confirms the subscription was created.
>> Ongoing payments: *
>>
>> *- - - - - - - - - - - - - - - - *
>>
>>
>>
>>
>>
>>
>> * From that time on and since Bitcoin is a 'push' model, the wallet is
>> responsible to poll the merchant for due payments associated with that
>> subscription. Note that the merchant could specify hints to the wallet on
>> when to poll (specific dates) or not during the registration of the
>> subscription. Note that we can't simply have the wallet push X bitcoins
>> every month: the user account on the merchant side may have gotten credits,
>> invoice adjustments, etc. since the last invoice, so the amount to pay for
>> a given billing period may be lower than the regular amount. It could even
>> be zero if the user decides to make a one-time payment to the merchant
>> directly using a different wallet. Hence, the wallet needs to get the
>> latest invoice balance to make sure how much it should pay. This also opens
>> the door for the support of overage charges. Quick note on the
>> implementation on the merchant side: an entitlement system is a piece of
>> logic on the merchant side which grants the user access to certain
>> resources depending on the account status (unpaid invoices, etc.). This
>> goes often hand in hand with a dunning system, which progressively
>> restricts access as the user's account is more and more overdue. Since
>> wallets can be offline for an extended period of time, payments may be
>> missed and lead to an overdue state (e.g. extra fees, service degraded). It
>> is the responsibility of the customer to ensure the wallet is up often
>> enough for payments to happen. In that recurring phase where the wallet
>> polls the merchant, the wallet is responsible to check that payments match
>> the subscription contract; that is, the amount, frequency of payments, ...
>> match what the customer agreed on. If so, the payment is made without
>> asking for explicit approval from customer, and the flow is similar to
>> BIP-0070: The message is sent to the merchant, and in parallel, a
>> transaction is sent to the btcnet. The merchant sends an ACK to the wallet
>> and of course checks the states of the transactions on the btcnet to mark
>> that payment as successful. Subscription change (optional): *
>>
>> *- - - - - - - - - - - - - - - - - - - - - - - - *
>>
>>
>> * Optionally we could implement a change in the ongoing subscription to
>> address the upgrade/downgrade scenarios. Of course, we could also simply
>> support a cancellation followed by a creation of a new subscription, but
>> having that as a one atomic message is probably better. The steps are very
>> similar to the initial registration. 1. The customer clicks 'upgrade',
>> 'downgrade', ... -> A msg is sent to the merchant. 2. The merchant sends back
>> a msg to the wallet with the detail of the NEW subscription. 3. The wallet
>> prompts the customer for authorization. 4. The customer authorizes (or
>> denies) it. 5. The wallet sends the confirmation to the merchant. 6. The
>> merchant confirms the change in the subscription. Cancellation of the
>> subscription: *
>>
>> *- - - - - - - - - - - - - - - - - - - - - - - - - *
>>
>>
>>
>> * The cancellation is initiated from the customer: 1. The customer clicks
>> 'cancel' -> The wallet is informed that it  should not accept any new
>> payment associated to that subscription. 2. The wallet sends a message to
>> the merchant to inform about the cancellation. 3. The merchant confirms the
>> subscription was cancelled. *
>>
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/6c0620d6/attachment.html>

From mike at plan99.net  Tue Feb 11 16:24:12 2014
From: mike at plan99.net (Mike Hearn)
Date: Tue, 11 Feb 2014 17:24:12 +0100
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
Message-ID: <CANEZrP0Pzux7R5fJAa57JhLOn3AskD5tVSNNf9OQj7S=P3gJcw@mail.gmail.com>

Hey guys,

I'm on vacation now so won't be able to take a look until I'm back in a
couple of weeks but the approach sounds reasonable based on your
description.
On 8 Feb 2014 08:28, "Stephane Brossier" <stephane at kill-bill.org> wrote:

> Mike and all,
>
> Pierre and I just committed a prototype implementation of the recurring
> payment protocol using bitcoinj. You can find the diff on our fork:
>
> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7
>
> We did not write the server (merchant side), but wanted to have some
> feedback before going deeper (merchant implementation and tests). We did
> our best to build it on top of the existing BIP-0070 protocol-- only a few
> additions in the messages, but no new calls and no new uri scheme. We
> created a new package 'recurring' where most of the new code lives.
>
> At a high level:
>
> 1. Creation of the subscription:
>
> The initial handshake for creating the subscription is exactly similar to
> the one for the payment protocol (PaymentRequest is used to provide the
> contract)
>
> 2. Wallet can decide to poll the merchants for its active subscriptions.
>
> Here the flow is exactly similar to the payment protocol but the wallet
> receives a callback to verify the payment matches the contract and should
> go through.
>
> Please give us some feedback whenever you have the chance. In the meantime
> we will start implementing the merchant side and test the code.
>
> Cheers!
>
>
>
> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:
>
> That looks OK at a very high level. Things you probably want to think
> about:
>
>    - How to trigger it off the existing payment protocol (no new top
>    level messages or mime types or uri extensions please)
>    - Data structures to define the payment schedule
>    - Do you allow pre-submission of time locked transactions or not?
>
> I think as you prototype these things will become clearer.  You could try
> prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the
> PaymentSession class).
>
>
>
> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org
> > wrote:
>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>>
>> *From what I have seen so far, there seems to be an agreement that this
>> is a nice feature to add. We are pretty new to that community and so we
>> don't know exactly what the process is, and in particular how we reach
>> consensus via email. I am certainly open to follow 'the way' if there is
>> one, but one solution would be to follow Mike's suggestion on providing a
>> (prototype) implementation first and then defining/refining the BIP. Odinn
>> also suggested a possible retribution for our time through crowd-sourcing
>> which I am interested to pursue if that makes sense. We have quite some
>> experience on the subscription side of things and while we are growing our
>> knowledge on the Bitcoin technology (and ecosystem at large) we would
>> benefit from: * some feedbacks on the high level proposal * additional
>> requirements we might have missed So, below is a high level description of
>> what we have in mind. If this sounds reasonable, we could start working on
>> an implementation. I. Abstract --------------- This describes a protocol to
>> enable recurring payments in bitcoins and can be seen as an extension of
>> BIP-0070. The main goal here is to have the customer subscribe to a service
>> of some kind (that is, agreeing on the terms of that subscription
>> contract), and then have the wallet make recurring payments without any
>> intervention from the customer as long as the payments match what the
>> customer agreed on paying. An example of such service would be an online
>> streaming website, to which a user pays a fixed recurring monthly fee to
>> access videos (a.k.a. resources). Note that there is also usage based
>> billing: for example, the user may need to purchase additional access for
>> premium videos (overage charges). This type of billing is more complicated
>> and there are many variations to it used in the industry (pre-paid, ?). For
>> the sake of discussion, we?ll focus on fixed recurring payments only, but
>> we will keep usage in mind to make sure the protocol will be able to
>> support it as well. II. Motivation ------------------ Subscription based
>> services have been growing in the past few years and so the intent it to
>> make it possible for customers to pay in bitcoins. Bitcoin?s push model
>> presents new advantages for the customer compared to traditional payment
>> methods: the user has control over the subscription (for example, there is
>> no need to call the merchant to explicitly cancel the credit card
>> payments). It also opens the door to subscription management tools in
>> wallets (e.g. Hive apps), which would give user an overview of what they
>> are paying each month. III. Flow of
>> Operations----------------------------------------*
>>
>>
>>
>>
>> * Creation of the subscription: - - - - - - - - - - - - - - - - - - - - -
>> - 1. The customer clicks 'subscribe' -> A message is sent to the merchant.
>> 2. The merchant sends back a message to the wallet with the details of the
>> subscription such as the amount to be paid. In reality, there will be more
>> information but for the purpose of the prototype implementation this is
>> sufficient. 3. The wallet prompts the customer for authorization. 4. The
>> customer authorizes (or denies) it. 5. The wallet sends the confirmation to
>> the merchant. 6. The merchant confirms the subscription was created.
>> Ongoing payments: *
>>
>> *- - - - - - - - - - - - - - - - *
>>
>>
>>
>>
>>
>>
>> * From that time on and since Bitcoin is a 'push' model, the wallet is
>> responsible to poll the merchant for due payments associated with that
>> subscription. Note that the merchant could specify hints to the wallet on
>> when to poll (specific dates) or not during the registration of the
>> subscription. Note that we can't simply have the wallet push X bitcoins
>> every month: the user account on the merchant side may have gotten credits,
>> invoice adjustments, etc. since the last invoice, so the amount to pay for
>> a given billing period may be lower than the regular amount. It could even
>> be zero if the user decides to make a one-time payment to the merchant
>> directly using a different wallet. Hence, the wallet needs to get the
>> latest invoice balance to make sure how much it should pay. This also opens
>> the door for the support of overage charges. Quick note on the
>> implementation on the merchant side: an entitlement system is a piece of
>> logic on the merchant side which grants the user access to certain
>> resources depending on the account status (unpaid invoices, etc.). This
>> goes often hand in hand with a dunning system, which progressively
>> restricts access as the user's account is more and more overdue. Since
>> wallets can be offline for an extended period of time, payments may be
>> missed and lead to an overdue state (e.g. extra fees, service degraded). It
>> is the responsibility of the customer to ensure the wallet is up often
>> enough for payments to happen. In that recurring phase where the wallet
>> polls the merchant, the wallet is responsible to check that payments match
>> the subscription contract; that is, the amount, frequency of payments, ?
>> match what the customer agreed on. If so, the payment is made without
>> asking for explicit approval from customer, and the flow is similar to
>> BIP-0070: The message is sent to the merchant, and in parallel, a
>> transaction is sent to the btcnet. The merchant sends an ACK to the wallet
>> and of course checks the states of the transactions on the btcnet to mark
>> that payment as successful. Subscription change (optional): *
>>
>> *- - - - - - - - - - - - - - - - - - - - - - - - *
>>
>>
>> * Optionally we could implement a change in the ongoing subscription to
>> address the upgrade/downgrade scenarios. Of course, we could also simply
>> support a cancellation followed by a creation of a new subscription, but
>> having that as a one atomic message is probably better. The steps are very
>> similar to the initial registration. 1. The customer clicks 'upgrade',
>> 'downgrade', ? -> A msg is sent to the merchant. 2. The merchant sends back
>> a msg to the wallet with the detail of the NEW subscription. 3. The wallet
>> prompts the customer for authorization. 4. The customer authorizes (or
>> denies) it. 5. The wallet sends the confirmation to the merchant. 6. The
>> merchant confirms the change in the subscription. Cancellation of the
>> subscription: *
>>
>> *- - - - - - - - - - - - - - - - - - - - - - - - - *
>>
>>
>>
>> * The cancellation is initiated from the customer: 1. The customer clicks
>> 'cancel' -> The wallet is informed that it  should not accept any new
>> payment associated to that subscription. 2. The wallet sends a message to
>> the merchant to inform about the cancellation. 3. The merchant confirms the
>> subscription was cancelled. *
>>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/e4c7d1b9/attachment.html>

From hozer at hozed.org  Tue Feb 11 17:59:19 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Tue, 11 Feb 2014 11:59:19 -0600
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140210193247.GC17359@savin>
References: <20140209180458.GB20126@savin> <20140209204434.GA11488@savin>
	<20140210193247.GC17359@savin>
Message-ID: <20140211175919.GV3180@nl.grid.coop>

Is there any code that does this? I would like to develop a multicoin-qt
wallet that runs on two blockchains from one binary, and allows trading
using this mechanism between the two chains.

On Mon, Feb 10, 2014 at 02:32:47PM -0500, Peter Todd wrote:
> On Sun, Feb 09, 2014 at 03:44:34PM -0500, Peter Todd wrote:
> > On Sun, Feb 09, 2014 at 01:04:58PM -0500, Peter Todd wrote:
> > > Alex Mizrahi recently outlined a mechanism(1) based on SIGHASH_SINGLE
> > > that allows colored coins and similar embedded consensus system assets
> > > to be securely transferred to another party in exchange for Bitcoins
> > > atomically. In summary his p2p 2-step-trade mechanism operates as
> > > follows:
> > 
> > I'm told there's probably at least one if not more earlier
> > attributions/reinventions for the 2-step-trade protocol using
> > SIGHASH_SINGLE. Please reply with them if you have them so we can give
> > credit where credit is due.
> 
> Got this:
> 
> Message-ID: <52418EBA.3080602 at monetize.io>
> Date: Tue, 24 Sep 2013 06:08:10 -0700
> From: Mark Friedenbach <mark at monetize.io>
> Organization: Monetize.io Inc.
> To: Meni Rosenfeld <meni at bitcoil.co.il>
> Subject: Re: Freimarkets and investment
> 
> If assets were tagged you could do a very limited form of pre-signed offers:
> 
> in: 10 btc SINGLE|ANYONECANPAY
> out: 1 AAA
> 
> These are composable, in that you can append the inputs and outputs of
> multiple offers together and result in a valid transaction. However this
> is pretty much the limit of what is possible without adding new SIGHASH
> modes, and if you're going to hard-fork to add tagging, then you might
> as well go the whole distance with explicit hierarchical
> sub-transactions as we did with Freimarkets.
> 
> Cheers,
> Mark
> 
> On 9/24/13 5:44 AM, Meni Rosenfeld wrote:
> > Hi Jorge,
> > 
> > The video was sent to me by Amos Meiri, I think eToro funded its production.
> > 
> > Maybe I don't understand SIGHASH_ANYONECANPAY very well. In the
> > transaction, there will be an output of 1 "my stock" to an initially
> > unknown address. Can I provide a signature for my input of 1 "my stock"
> > that will be valid even with the output details provided later?
> > 
> > In any case, I think that's out of scope for the presentation.
> > 
> > Meni
> > 
> > On 24/09/2013 13:10, Jorge Tim?n wrote:
> >> Yes, it's a nice presentation.
> >> I love the video with the chameleons that you link at the end !!
> >>
> >> As a little sugestion, I think the biggest advantage of tagging is not
> >> inflatable assets, it's open binding orders. Even without granular
> >> subtransactions as freimarket has, you could sign your input (say,
> >> representing 1 "My stock") and only the output you're interested in
> >> (say 100 bitstampUSD to myAddress) with SIGHASH_SINGLE |
> >> SIGHASH_ANYONECANPAY.
> >>
> >> Without tagging, you need to know where the inputs come from to check
> >> they're really bitstampUSD, because the network won't enforce the "100
> >> bistampUSD" in your output, any uncolored coins filling the btc
> >> quantity you wanted to represent those 100 usd will be ok, for miners.
> >>
> >> Goog luck with the talk, I'm eager to hear it.
> >>
> >> By the way, Mark, the explanation of the blockchain image sounds a
> >> little bit like hashcasttle, no? well, just merged mining every new
> >> asset, sounds like jaromil's freecoin too.
> >>
> >>
> >> On 9/24/13, Meni Rosenfeld <meni at bitcoil.co.il> wrote:
> >>> Hi Mark,
> >>>
> >>> We currently have a more general mathematical framework for the concept of
> >>> colored coins - a color is a combination of initial state and a kernel
> >>> function that maps input colors to output colors. Order-based coloring is
> >>> one such kernel function, tagging is another. As long as you can point at an
> >>> output and say what its color is, we call it a colored coin system.
> >>>
> >>> The blockchain image is a stand-in for "using a new block chain for each
> >>> asset".
> >>>
> >>> Meni
> >>>
> >>> On 24/09/2013 00:42, Mark Friedenbach wrote:
> > Hi Meni,
> > 
> > I did call Freimarkets "colored coins" in the early days, but the term
> > colored coin itself within the community seems to have become
> > identified with the specific proposal of assigning value to specific
> > satoshis, and running an order based coloring algorithm to determine
> > asset flow, e.g. Bitcoin-X. Freimarkets allows issuance of entirely
> > new assets and has explicit tagging of outputs, so we decided to avoid
> > the phrase "colored coin" so as to keep from confusing people. But as
> > an academic, yes you are correct.
> > 
> > You presentation looks great. BTW, what's the first logo for the
> > "Alternative token systems" slide? Or is that just a stand-in for the
> > block chain?
> > 
> > Mark
> > 
> > On 9/23/13 12:24 PM, Meni Rosenfeld wrote:
> >>>>>> Hi,
> >>>>>>
> >>>>>> As you might know I'm giving a talk about Colored Coins in
> >>>>>> Amsterdam.
> >>>>>>
> >>>>>> My presentation is available at
> >>>>>> https://bitcoil.co.il/files/Colored Coins.pptx (I'm not posting
> >>>>>> this link publicly until after the talk).
> >>>>>>
> >>>>>> I'll be happy for any feedback.
> >>>>>>
> >>>>>> I'm listing Freimarkets as an implementation of Colored Coins. It
> >>>>>> doesn't look like you're identifying with the term, but it does fit
> >>>>>> the definition (and though it does obviously do much more than
> >>>>>> just implement colored coins.)
> >>>>>>
> >>>>>> Thanks, Meni
> >>>>
> >>>
> >>
> > 
> 
> -- 
> 'peter'[:-1]@petertodd.org
> 0000000076654614e7bf72ac80d47c57bca12503989f4d602538d3cd7892ca7d



> ------------------------------------------------------------------------------
> Androi apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk

> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development




From namanhd at gmail.com  Tue Feb 11 20:42:02 2014
From: namanhd at gmail.com (naman naman)
Date: Wed, 12 Feb 2014 02:12:02 +0530
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <52F9377D.9010405@gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop> <20140210192308.GA17359@savin>
	<CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>
	<20140210194032.GD17359@savin> <52F9377D.9010405@gmail.com>
Message-ID: <CA+SxJWBM0USWETNeDh-oRgOfrU64GiPbL_Qt5hrFN53C42yNxg@mail.gmail.com>

I was talking about a DOS attack in
https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only applicable
to entitys doing the tracking with txids).

Amazing how I did not get a response from any of the devs (except Greg's
response
https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but
that too was short and not concerning the attack scenario plausibiity as I
replied to him).

Today they are apparently at work here
https://github.com/bitcoin/bitcoin/pull/3651

Amazing how nobody acknowledges it until later when the attack already
happens. The devs need to show some greater level of responsibility.

Don't get me wrong - I am not trying to claim credit for the attack scheme
described (though I do not know of any other place where this was mentioned
earlier as an attack scheme), but I am trying to make the point that people
should just be around and at least make others feel that their concerns are
being read. Now putting this on some place like reddit will only give the
community a bad name.

On a lighter note I messaged some of the devs (as my previous mail says)
saying the attack should be called "thenoblebot" attack (after my handle,
which would inspire me to pursue crypto studies further). It was meant to
be a lame joke. But I had no idea how it would start causing so much
disruption in the ecosystem.

Regards
thenoblebot


On Tue, Feb 11, 2014 at 2:03 AM, Vocatus Gate <vocatus.gate at gmail.com>wrote:

>  It's quite simple, really:
>
> Unique transaction == (Inputs+Outputs+ReceivingAddress)
>
> Problem solved. Simply don't rely on TxID for tracking. Can we put this
> issue to rest and move on?
>
>
>
>
> On 2014-02-10 12:40 PM, Peter Todd wrote:
>
> On Tue, Feb 11, 2014 at 01:00:21AM +0530, naman naman wrote:
>
>  Hi guys,
>
> Please check this threadhttps://bitcointalk.org/index.php?topic=458608.0for a possible attack
> scenario.
>
> Already mailed Gavin, Mike Hearn and Adam about this :
>
> See if it makes sense.
>
>  That's basically what appears to have happened with Mt. Gox.
>
> Preventing the attack is as simple as training your customer service
> people to ask the customer if their wallet software shows a payment to a
> specific address of a specific amount at some approximate time. Making
> exact payment amounts unique - add a few satoshis - is a trivial if
> slightly ugly way of making sure payments can be identified uniquely
> over the phone. That the procedure at Mt. Gox let front-line customer
> service reps manually send funds to customers without a proper
> investigation of why the funds didn't arrive was a serious mistake on
> their part.
>
> Ultimately this is more of a social engineering attack than a technical
> one, and a good example of why well-thought-out payment protocols are
> helpful. Though the BIP70 payment protocol doesn't yet handle busines to
> individual, or individual to indivudal, payments a future iteration can
> and this kind of problem will be less of an issue.
>
> Similarly stealth addresses have an inherent per-tx unique identifier,
> the derived pubkey, which a UI might be able to take advantage of.
>
>
>
>
> ------------------------------------------------------------------------------
> Androi apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
>
>
>
> _______________________________________________
> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/2c00092c/attachment.html>

From gmaxwell at gmail.com  Tue Feb 11 20:49:49 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Tue, 11 Feb 2014 12:49:49 -0800
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CA+SxJWBM0USWETNeDh-oRgOfrU64GiPbL_Qt5hrFN53C42yNxg@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop> <20140210192308.GA17359@savin>
	<CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>
	<20140210194032.GD17359@savin> <52F9377D.9010405@gmail.com>
	<CA+SxJWBM0USWETNeDh-oRgOfrU64GiPbL_Qt5hrFN53C42yNxg@mail.gmail.com>
Message-ID: <CAAS2fgS5=-=6Ws0ofWsyKNHLYQop71kOjBCtF6TUMOmVgHtU_g@mail.gmail.com>

On Tue, Feb 11, 2014 at 12:42 PM, naman naman <namanhd at gmail.com> wrote:
> I was talking about a DOS attack in
> https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only applicable
> to entitys doing the tracking with txids).
>
> Amazing how I did not get a response from any of the devs (except Greg's
> response
> https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but
> that too was short and not concerning the attack scenario plausibiity as I
> replied to him).

Try paying a consultant if your ego demands that you have a technical
expert to entertain your musing with immediate response.

My response was absolutely relevant.

If you reissue a transaction without respending the prior transactions
coins, you will end up double paying. Only spending the inputs in
question can prevent the prior transaction (itself or in other form)
from going through.

Once you respend the inputs there is no risk of actually losing funds
due to an issue regardless of how you track coins in your higher level
application.



From namanhd at gmail.com  Tue Feb 11 20:56:50 2014
From: namanhd at gmail.com (naman naman)
Date: Wed, 12 Feb 2014 02:26:50 +0530
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CAAS2fgS5=-=6Ws0ofWsyKNHLYQop71kOjBCtF6TUMOmVgHtU_g@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop> <20140210192308.GA17359@savin>
	<CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>
	<20140210194032.GD17359@savin> <52F9377D.9010405@gmail.com>
	<CA+SxJWBM0USWETNeDh-oRgOfrU64GiPbL_Qt5hrFN53C42yNxg@mail.gmail.com>
	<CAAS2fgS5=-=6Ws0ofWsyKNHLYQop71kOjBCtF6TUMOmVgHtU_g@mail.gmail.com>
Message-ID: <CA+SxJWArhdVyfGL=V6wa_EFRC3yGDo6vWus+jx9E=u4i_RJc6Q@mail.gmail.com>

Gregory Maxwell says : "Try paying a consultant if your ego demands that
you have a technical
expert to entertain your musing with immediate response."

I don't know why your resorting to such an adhominem. But I have already
said that you were the only one who responded. Your response was correct as
is reflected in the conversation on the forums. No doubting that. But it
does not address the full scope of the attack where a small pool would
intentionally (or out of whatever reason) make the hash invalid for the txs
they recieve. So that leaves a whole lot of businesses in the lurch who
have relied on txid (albeit wrongly that) for their tracking purposes.
Thats all I'm trying to say, without blaming anyone.

Hope it makes sense.


On Wed, Feb 12, 2014 at 2:19 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> On Tue, Feb 11, 2014 at 12:42 PM, naman naman <namanhd at gmail.com> wrote:
> > I was talking about a DOS attack in
> > https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only
> applicable
> > to entitys doing the tracking with txids).
> >
> > Amazing how I did not get a response from any of the devs (except Greg's
> > response
> > https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789 but
> > that too was short and not concerning the attack scenario plausibiity as
> I
> > replied to him).
>
> Try paying a consultant if your ego demands that you have a technical
> expert to entertain your musing with immediate response.
>
> My response was absolutely relevant.
>
> If you reissue a transaction without respending the prior transactions
> coins, you will end up double paying. Only spending the inputs in
> question can prevent the prior transaction (itself or in other form)
> from going through.
>
> Once you respend the inputs there is no risk of actually losing funds
> due to an issue regardless of how you track coins in your higher level
> application.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/3f232766/attachment.html>

From kgreenek at gmail.com  Wed Feb 12 06:37:00 2014
From: kgreenek at gmail.com (Kevin Greene)
Date: Tue, 11 Feb 2014 22:37:00 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
Message-ID: <CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>

Sending this again and truncating since apparently the message body was too
long.

Thanks for humoring my questions!

>I think reporting such errors to the wallet would make complete sense.
However i am not clear why we would a separate url for that?

Hmm, thinking about this more, adding a simple status_code in
PaymentRequest would be a much easier way to achieve this. However,
continuing to think about this even more, maybe the simple memo field along
with an empty set of outputs is enough already.

In bitcoinj, right now the code will throw a
PaymentRequestException.InvalidOutputs exception if the set of outputs is
empty with a message of "No Outputs". Because of that, there isn't a good
way to tell the difference between a payment request that had no outputs
and a payment request that had some invalid output(s).

*Question to everyone:*
How does bitcoin-qt handle a PaymentRequest with no outputs?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/e0972311/attachment.html>

From runesvend at gmail.com  Wed Feb 12 15:12:25 2014
From: runesvend at gmail.com (=?ISO-8859-1?Q?Rune_Kj=E6r_Svendsen?=)
Date: Wed, 12 Feb 2014 16:12:25 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <20140210030048.GB31925@savin>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
Message-ID: <CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>

Instead of trying to remove the possibility of transaction
malleability, would it make sense to define a new, "canonical
transaction hash/ID" (cTxID), which would be a hash of the part of the
transaction data which we know is not malleable, and have clients use
this cTxID internally, thus making the traditional transaction hash
irrelevant for a client to function correctly?

We already have a non-malleable transaction hash: the hash that is
signed, ie. the transaction with each scriptSig replaced by the
scriptPubKey it redeems. This could be the cTxID.

Or is this simply a too fundamental change to the way bitcoin-qt (and
all other clients) work in order to be feasible?

As far as I can see, it completely solves the issue of not having a
canonical ID for a transaction, but it also increases the
computational requirements for a node. For one, as far as I can see,
it requires the node to index all transactions, because in order to
calculate a cTxID, it would be necessary to fetch all transactions
referred to by the transaction in question, in order to pull in the
scriptPubKeys that are redeemed.


On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:
> On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:
>> Hello all,
>>
>> it was something I planned to do since a long time, but with the
>> recent related issues popping up, I finally got around to writing a
>> BIP about how we can get rid of transaction malleability over time.
>>
>> The proposed document is here: https://gist.github.com/sipa/8907691
>>
>> I expect most rules to not be controversial. Maybe rules 1 and 3, as
>> they require modifications to wallet software (Bitcoin Core 0.9 and
>> BitcoinJ already implement it, though) and potentially invalidate some
>> script functionality. However, these new rules remain optional and
>> controlled by an nVersion increase.
>>
>> Comments please!
>
> You should probably add making CHECKMULTISIG require the dummy value to
> be exactly equal to OP_FALSE; verifying that in the transaction itself is
> laborious. A more subtle example is we may want both CHECKSIG and
> CHECKMULTISIG to fail the transaction if the signature is invalid but
> not exactly equal to OP_FALSE; some transaction forms are significantly
> more compact if you can have failed signatures, but that's a source of
> malleability. (are there counter examples people can think of?)
>
>
> But as I said on IRC, I'm a bit hesitant to bake in assumptions about
> malleability when we have no solid idea if ECC signatures are or are not
> malleable on a fundemental level; if "whack-a-mole" anti-malleability is
> all we've got it could be ugly if a break is found. Similarly, we may
> find we missed something, or some needed change makes the malleability
> rules difficult to work with for some new script type that is required.
>
> I'd rather see a new CHECKSIG mode for the case where malleability
> absolutely must be eliminated - certain multi-party protocols - and fix
> wallet software instead. (the malleability problems people see are
> closely related to inability to handle double-spends and reorgs) But I
> can easily see that being an impossible goal engineering wise...
>
> --
> 'peter'[:-1]@petertodd.org
> 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



From etotheipi at gmail.com  Wed Feb 12 16:22:19 2014
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 12 Feb 2014 11:22:19 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
Message-ID: <CALf2ePyDTZ_43uBfS9-5znhTyBR-5H10SpZ=N-z1DBacM_rDgA@mail.gmail.com>

I think the solution is simply to encourage Bitcoin software developers to
design their software to use this static ID, instead of the full
transaction hash.    If MtGox had talked those IDs instead of the TX ID,
their software would've correctly identified the mutated transactions and
there would be  no problem.

Armory is slightly different, since it doesn't deal with the same stuff as
exchanges do.  But it didn't have any problems with malleability because it
doesn't track anything by ID, it only pays attention to whether inputs and
outputs are related to your wallets.  It's not necessarily hard to do it
this way, people just have to be aware of it.

-Alan

Sent from my overpriced smartphone
On Feb 12, 2014 10:15 AM, "Rune Kj?r Svendsen" <runesvend at gmail.com> wrote:

> Instead of trying to remove the possibility of transaction
> malleability, would it make sense to define a new, "canonical
> transaction hash/ID" (cTxID), which would be a hash of the part of the
> transaction data which we know is not malleable, and have clients use
> this cTxID internally, thus making the traditional transaction hash
> irrelevant for a client to function correctly?
>
> We already have a non-malleable transaction hash: the hash that is
> signed, ie. the transaction with each scriptSig replaced by the
> scriptPubKey it redeems. This could be the cTxID.
>
> Or is this simply a too fundamental change to the way bitcoin-qt (and
> all other clients) work in order to be feasible?
>
> As far as I can see, it completely solves the issue of not having a
> canonical ID for a transaction, but it also increases the
> computational requirements for a node. For one, as far as I can see,
> it requires the node to index all transactions, because in order to
> calculate a cTxID, it would be necessary to fetch all transactions
> referred to by the transaction in question, in order to pull in the
> scriptPubKeys that are redeemed.
>
>
> On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:
> > On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:
> >> Hello all,
> >>
> >> it was something I planned to do since a long time, but with the
> >> recent related issues popping up, I finally got around to writing a
> >> BIP about how we can get rid of transaction malleability over time.
> >>
> >> The proposed document is here: https://gist.github.com/sipa/8907691
> >>
> >> I expect most rules to not be controversial. Maybe rules 1 and 3, as
> >> they require modifications to wallet software (Bitcoin Core 0.9 and
> >> BitcoinJ already implement it, though) and potentially invalidate some
> >> script functionality. However, these new rules remain optional and
> >> controlled by an nVersion increase.
> >>
> >> Comments please!
> >
> > You should probably add making CHECKMULTISIG require the dummy value to
> > be exactly equal to OP_FALSE; verifying that in the transaction itself is
> > laborious. A more subtle example is we may want both CHECKSIG and
> > CHECKMULTISIG to fail the transaction if the signature is invalid but
> > not exactly equal to OP_FALSE; some transaction forms are significantly
> > more compact if you can have failed signatures, but that's a source of
> > malleability. (are there counter examples people can think of?)
> >
> >
> > But as I said on IRC, I'm a bit hesitant to bake in assumptions about
> > malleability when we have no solid idea if ECC signatures are or are not
> > malleable on a fundemental level; if "whack-a-mole" anti-malleability is
> > all we've got it could be ugly if a break is found. Similarly, we may
> > find we missed something, or some needed change makes the malleability
> > rules difficult to work with for some new script type that is required.
> >
> > I'd rather see a new CHECKSIG mode for the case where malleability
> > absolutely must be eliminated - certain multi-party protocols - and fix
> > wallet software instead. (the malleability problems people see are
> > closely related to inability to handle double-spends and reorgs) But I
> > can easily see that being an impossible goal engineering wise...
> >
> > --
> > 'peter'[:-1]@petertodd.org
> > 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
> >
> >
> ------------------------------------------------------------------------------
> > Managing the Performance of Cloud-Based Applications
> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> > Read the Whitepaper.
> >
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
>
>
> ------------------------------------------------------------------------------
> Android apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/5c046193/attachment.html>

From stephane at kill-bill.org  Tue Feb 11 18:01:23 2014
From: stephane at kill-bill.org (Stephane Brossier)
Date: Tue, 11 Feb 2014 10:01:23 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
Message-ID: <EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>

Hi Kevin,

On Feb 11, 2014, at 2:00 AM, Kevin Greene <kgreenek at gmail.com> wrote:

> Figured I would have a crack at reviewing this since Mike is out for a bit. It was great running into you guys at the bitcoin fair in SF! Small world :)

Indeed! It was great meeting you! It's always nice to meet people in person...

> I like how simple this is. You just give it an url to fetch the next payment request and a date to fetch it.
> 
> What should happen if the client tries to fetch the PaymentRequest early or late?

If the client tries to fetch too early, then  the merchant will return a PaymentRequest with no output (there is nothing to pay yet). If it fetches too late, this is merchant specific. It could be that the service got discontinued -- extreme case -- or that there are now multiple PaymentRequest pending or that the merchant decided to aggregate those into one. In that scenario, it could lead to a case where the amount to pay goes beyond the contract and the wallet would refuse to make the recurring payment.

> Does it become valid after some date and stay valid for some length of time?

The protocol we sketched does not include (yet) an expiration date. At this point the contract is fairly minimal, and we could envision adding more parameters such as expiration date. So at this point the behavior would be dictated by the merchant.

> Also, what should happen if the client tries to consume the same PaymentRequest twice (or multiple times) during the same period?

The merchant initiates the PaymentRequest and is in charge to make sure they match the invoices that the client should pay. On the client side, the wallet is responsible to verify that the contract is respected, so if a merchant were to issue multiple times the same PaymentRequest, the wallet would detect it goes beyond the bonds defined in the contract and would refuse to make the additional Payments.

> I do not think daily/weekly/monthly is flexible enough. What do you think about having a concrete start time and end time when the next PaymentRequest will be valid?

I agree that daily/weekly/monthly may not be flexible enough. However specifying a fixed date may be very tricky because in some cases a monthly subscription may start on a 31st of a month, and depending on the month, the due date will vary -- could be 30th, 28th, 29th, ... Also note that the frequency (daily/weekly/monthly) is not used as a polling interval, but is only used to verify the contract is respected. 

There are multiple viable options to specify that contract and ideally we could/should support multiple schemes; different merchants could use different schemes, and the client would decide wether or not he is ready to accept the terms that will later be enforced by the wallet. But of course all this flexibility goes against simplicity and so this is tradeoff...


> This also prevents the wallet from having to remember when it last sent a payment and getting skewed over time.

Today, our current prototype is polling every day -- which is the lowest granularity we introduced -- and so there is no risk of getting skewed.


> When a wallet hits the polling_url to download the next PaymentRequest, it seems we need a way to communicate an error code to the wallet, for example if the server canceled the contract without the wallet knowing. Perhaps a separate polling_status_url, with a corresponding ACK message to indicate if the PaymentRequest is available. What do you think of that idea?

I think reporting such errors to the wallet would make complete sense. However i am not clear why we would a separate url for that?

> One high-level comment -- the wallet in this design doesn't have any way of knowing when the payments are supposed to end. I feel this is important to show to the user before they start their wallet polling infinitely.

Subscriptions are non ending by definition, but at any time the client (through the wallet) or the merchant can decide to terminate the subscriptions -- we did not yet implement cancellation in that prototype but we are planning to add it later this week. Think of your Netflix subscriptions, this is never ending (evergreen) until you decide to terminate it or Netflix does it (abuse, bills not paid,...)

Thanks for taking a look!

> 
> On Sat, Feb 8, 2014 at 6:48 PM, Stephane Brossier <stephane at kill-bill.org> wrote:
> Mike, Gavin,
> 
> 
> We started to work on the merchant side to test the integration of our prototype for the recurring payments. We modified the 'Payment Request Generator' from Gavin to include a new check box 'set recurring'. We forked the code and checked in our modification here: https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3
> 
> We also found a few issues with the code diff that we sent yesterday for bitcoinj and checked in the bug fixes  in our fork-- so the diff sent yesterday is slightly outdated.
> 
> So at this point we have a working prototype for bitcoinj and we are waiting for your feedbacks. We also started to look at integrating the protocol in Kill Bill to check that what is proposed supports indeed the business cases of a full recurring billing platform.
> 
> Hope to hear from you guys soon!
> 
> 
> On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org> wrote:
> 
>> Mike and all,
>> 
>> Pierre and I just committed a prototype implementation of the recurring payment protocol using bitcoinj. You can find the diff on our fork: 
>> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7
>> 
>> We did not write the server (merchant side), but wanted to have some feedback before going deeper (merchant implementation and tests). We did our best to build it on top of the existing BIP-0070 protocol-- only a few additions in the messages, but no new calls and no new uri scheme. We created a new package 'recurring' where most of the new code lives.
>> 
>> At a high level:
>> 
>> 1. Creation of the subscription:
>> 
>> The initial handshake for creating the subscription is exactly similar to the one for the payment protocol (PaymentRequest is used to provide the contract)
>> 
>> 2. Wallet can decide to poll the merchants for its active subscriptions.
>> 
>> Here the flow is exactly similar to the payment protocol but the wallet receives a callback to verify the payment matches the contract and should go through.
>> 
>> Please give us some feedback whenever you have the chance. In the meantime we will start implementing the merchant side and test the code.
>> 
>> Cheers!
>> 
>> 
>> 
>> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:
>> 
>>> That looks OK at a very high level. Things you probably want to think about:
>>> How to trigger it off the existing payment protocol (no new top level messages or mime types or uri extensions please)
>>> Data structures to define the payment schedule
>>> Do you allow pre-submission of time locked transactions or not?
>>> I think as you prototype these things will become clearer.  You could try prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the PaymentSession class).
>>> 
>>> 
>>> 
>>> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <stephane at kill-bill.org> wrote:
>>> From what I have seen so far, there seems to be an agreement that this is a nice feature to add.   We are pretty new to that community and so we don't know exactly what the process is, and in particular how we reach consensus via email. I am certainly open to follow 'the way' if there is one, but one solution would be to follow Mike's suggestion on providing a (prototype) implementation first and then defining/refining the BIP. Odinn also suggested a possible retribution for our time through crowd-sourcing which I am interested to pursue if that makes sense.
>>> 
>>> 
>>> We have quite some experience on the subscription side of things and while we are growing our knowledge on the Bitcoin technology (and ecosystem at large) we would benefit from:
>>> * some feedbacks on the high level proposal
>>> * additional requirements we might have missed
>>> 
>>> So, below is a high level description of what we have in mind. If this sounds reasonable, we could start working on an implementation.
>>> 
>>> 
>>>  
>>> I. Abstract
>>> ---------------
>>> 
>>> This describes a protocol to enable recurring payments in bitcoins and can be seen as an extension of BIP-0070. The main goal here is to have the customer subscribe to a service of some kind (that is, agreeing on the terms of that subscription contract), and then have the wallet make recurring payments without any intervention from the customer as long as the payments match what the customer agreed on paying.
>>> 
>>> An example of such service would be an online streaming website, to which a user pays a fixed recurring monthly fee to access videos (a.k.a. resources). Note that there is also usage based billing: for example, the user may need to purchase additional access for premium videos (overage charges). This type of billing is more complicated and there are many variations to it used in the industry (pre-paid, ?). For the sake of discussion, we?ll focus on fixed recurring payments only, but we will keep usage in mind to make sure the protocol will be able to support it as well.
>>> 
>>> 
>>> II. Motivation
>>> ------------------
>>> 
>>> Subscription based services have been growing in the past few years and so the intent it to make it possible for customers to pay in bitcoins. 
>>> 
>>> Bitcoin?s push model presents new advantages for the customer compared to traditional payment methods: the user has control over the subscription (for example, there is no need to call the merchant to explicitly cancel the credit card payments). It also opens the door to subscription management tools in wallets (e.g. Hive apps), which would give user an overview of what they are paying each month.
>>> 
>>> 
>>> III. Flow of Operations
>>> ----------------------------------------
>>> 
>>> 
>>> Creation of the subscription:
>>> - - - - - - - - - - - - - - - - - - - - - - 
>>> 
>>> 1. The customer clicks 'subscribe' -> A message is sent to the merchant.
>>> 2. The merchant sends back a message to the wallet with the details of the subscription such as the amount to be paid. In reality, there will be more information but for the purpose of the prototype implementation this is sufficient.
>>> 3. The wallet prompts the customer for authorization.
>>> 4. The customer authorizes (or denies) it.
>>> 5. The wallet sends the confirmation to the merchant.
>>> 6. The merchant confirms the subscription was created.
>>> 
>>> Ongoing payments:
>>> - - - - - - - - - - - - - - - -
>>> 
>>> From that time on and since Bitcoin is a 'push' model, the wallet is responsible to poll the merchant for due payments associated with that subscription. Note that the merchant could specify hints to the wallet on when to poll (specific dates) or not during the registration of the subscription.
>>> 
>>> Note that we can't simply have the wallet push X bitcoins every month: the user account on the merchant side may have gotten credits, invoice adjustments, etc. since the last invoice, so the amount to pay for a given billing period may be lower than the regular amount. It could even be zero if the user decides to make a one-time payment to the merchant directly using a different wallet. Hence, the wallet needs to get the latest invoice balance to make sure how much it should pay. This also opens the door for the support of overage charges.
>>> 
>>> 
>>> Quick note on the implementation on the merchant side: an entitlement system is a piece of logic on the merchant side which grants the user access to certain resources depending on the account status (unpaid invoices, etc.). This goes often hand in hand with a dunning system, which progressively restricts access as the user's account is more and more overdue. Since wallets can be offline for an extended period of time, payments may be missed and lead to an overdue state (e.g. extra fees, service degraded). It is the responsibility of the customer to ensure the wallet is up often enough for payments to happen.
>>> 
>>> 
>>> In that recurring phase where the wallet polls the merchant, the wallet is responsible to check that payments match the subscription contract; that is, the amount, frequency of payments, ? match what the customer agreed on. If so, the payment is made without asking for explicit approval from customer, and the flow is similar to BIP-0070: The message is sent to the merchant, and in parallel, a transaction is sent to the btcnet. The merchant sends an ACK to the wallet and of course checks the states of the transactions on the btcnet to mark that payment as successful.
>>> 
>>> Subscription change (optional):
>>> - - - - - - - - - - - - - - - - - - - - - - - - 
>>> 
>>> Optionally we could implement a change in the ongoing subscription to address the upgrade/downgrade scenarios. Of course, we could also simply support a cancellation followed by a creation of a new subscription, but having that as a one atomic message is probably better. The steps are very similar to the initial registration.
>>> 
>>> 1. The customer clicks 'upgrade', 'downgrade', ? -> A msg is sent to the merchant.
>>> 2. The merchant sends back a msg to the wallet with the detail of the NEW subscription. 
>>> 3. The wallet prompts the customer for authorization.
>>> 4. The customer authorizes (or denies) it.
>>> 5. The wallet sends the confirmation to the merchant.
>>> 6. The merchant confirms the change in the subscription.
>>> 
>>> Cancellation of the subscription:
>>> - - - - - - - - - - - - - - - - - - - - - - - - - 
>>> 
>>> The cancellation is initiated from the customer:
>>> 
>>> 1. The customer clicks 'cancel' -> The wallet is informed that it  should not accept any new payment associated to that subscription.
>>> 2. The wallet sends a message to the merchant to inform about the cancellation.
>>> 3. The merchant confirms the subscription was cancelled.
>>> 
>>> 
>>> 
>> 
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/f7dc5236/attachment.html>

From kgreenek at gmail.com  Wed Feb 12 06:32:18 2014
From: kgreenek at gmail.com (Kevin Greene)
Date: Tue, 11 Feb 2014 22:32:18 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
Message-ID: <CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>

Thanks for humoring my questions!

>I think reporting such errors to the wallet would make complete sense.
However i am not clear why we would a separate url for that?

Hmm, thinking about this more, adding a simple status_code in
PaymentRequest would be a much easier way to achieve this. However,
continuing to think about this even more, maybe the simple memo field along
with an empty set of outputs is enough already.

In bitcoinj, right now the code will throw a
PaymentRequestException.InvalidOutputs exception if the set of outputs is
empty with a message of "No Outputs". There isn't a good way to tell the
difference between a payment request that had no outputs and a payment
request that had some invalid output(s).

*Question to everyone:*
How does bitcoin-qt handle a PaymentRequest with no outputs?



On Tue, Feb 11, 2014 at 10:01 AM, Stephane Brossier
<stephane at kill-bill.org>wrote:

> Hi Kevin,
>
> On Feb 11, 2014, at 2:00 AM, Kevin Greene <kgreenek at gmail.com> wrote:
>
> Figured I would have a crack at reviewing this since Mike is out for a
> bit. It was great running into you guys at the bitcoin fair in SF! Small
> world :)
>
>
> Indeed! It was great meeting you! It's always nice to meet people in
> person...
>
> I like how simple this is. You just give it an url to fetch the next
> payment request and a date to fetch it.
>
> What should happen if the client tries to fetch the PaymentRequest early
> or late?
>
>
> If the client tries to fetch too early, then  the merchant will return a
> PaymentRequest with no output (there is nothing to pay yet). If it fetches
> too late, this is merchant specific. It could be that the service got
> discontinued -- extreme case -- or that there are now multiple
> PaymentRequest pending or that the merchant decided to aggregate those into
> one. In that scenario, it could lead to a case where the amount to pay goes
> beyond the contract and the wallet would refuse to make the recurring
> payment.
>
> Does it become valid after some date and stay valid for some length of
> time?
>
>
> The protocol we sketched does not include (yet) an expiration date. At
> this point the contract is fairly minimal, and we could envision adding
> more parameters such as expiration date. So at this point the behavior
> would be dictated by the merchant.
>
> Also, what should happen if the client tries to consume the same
> PaymentRequest twice (or multiple times) during the same period?
>
>
> The merchant initiates the PaymentRequest and is in charge to make sure
> they match the invoices that the client should pay. On the client side, the
> wallet is responsible to verify that the contract is respected, so if a
> merchant were to issue multiple times the same PaymentRequest, the wallet
> would detect it goes beyond the bonds defined in the contract and would
> refuse to make the additional Payments.
>
> I do not think daily/weekly/monthly is flexible enough. What do you think
> about having a concrete start time and end time when the next
> PaymentRequest will be valid?
>
>
> I agree that daily/weekly/monthly may not be flexible enough. However
> specifying a fixed date may be very tricky because in some cases a monthly
> subscription may start on a 31st of a month, and depending on the month,
> the due date will vary -- could be 30th, 28th, 29th, ... Also note that the
> frequency (daily/weekly/monthly) is not used as a polling interval, but is
> only used to verify the contract is respected.
>
> There are multiple viable options to specify that contract and ideally we
> could/should support multiple schemes; different merchants could use
> different schemes, and the client would decide wether or not he is ready to
> accept the terms that will later be enforced by the wallet. But of course
> all this flexibility goes against simplicity and so this is tradeoff...
>
>
> This also prevents the wallet from having to remember when it last sent a
> payment and getting skewed over time.
>
>
> Today, our current prototype is polling every day -- which is the lowest
> granularity we introduced -- and so there is no risk of getting skewed.
>
>
> When a wallet hits the polling_url to download the next PaymentRequest, it
> seems we need a way to communicate an error code to the wallet, for example
> if the server canceled the contract without the wallet knowing. Perhaps a
> separate polling_status_url, with a corresponding ACK message to indicate
> if the PaymentRequest is available. What do you think of that idea?
>
>
> I think reporting such errors to the wallet would make complete sense.
> However i am not clear why we would a separate url for that?
>
>  One high-level comment -- the wallet in this design doesn't have any way
> of knowing when the payments are supposed to end. I feel this is important
> to show to the user before they start their wallet polling infinitely.
>
>
> Subscriptions are non ending by definition, but at any time the client
> (through the wallet) or the merchant can decide to terminate the
> subscriptions -- we did not yet implement cancellation in that prototype
> but we are planning to add it later this week. Think of your Netflix
> subscriptions, this is never ending (evergreen) until you decide to
> terminate it or Netflix does it (abuse, bills not paid,...)
>
> Thanks for taking a look!
>
>
> On Sat, Feb 8, 2014 at 6:48 PM, Stephane Brossier <stephane at kill-bill.org>wrote:
>
>> Mike, Gavin,
>>
>>
>> We started to work on the merchant side to test the integration of our
>> prototype for the recurring payments. We modified the 'Payment Request
>> Generator' from Gavin to include a new check box 'set recurring'. We forked
>> the code and checked in our modification here:
>> https://github.com/killbill/paymentrequest/commit/e530f6ec528266aacfd076d7c3154ad39267c3f3
>>
>> We also found a few issues with the code diff that we sent yesterday for
>> bitcoinj and checked in the bug fixes  in our fork-- so the diff sent
>> yesterday is slightly outdated.
>>
>> So at this point we have a working prototype for bitcoinj and we are
>> waiting for your feedbacks. We also started to look at integrating the
>> protocol in Kill Bill to check that what is proposed supports indeed the
>> business cases of a full recurring billing platform.
>>
>> Hope to hear from you guys soon!
>>
>>
>> On Feb 7, 2014, at 6:57 PM, Stephane Brossier <stephane at kill-bill.org>
>> wrote:
>>
>> Mike and all,
>>
>> Pierre and I just committed a prototype implementation of the recurring
>> payment protocol using bitcoinj. You can find the diff on our fork:
>>
>> https://github.com/killbill/bitcoinj/commit/40c657c4191498f12539c60316116aa68af368a7
>>
>> We did not write the server (merchant side), but wanted to have some
>> feedback before going deeper (merchant implementation and tests). We did
>> our best to build it on top of the existing BIP-0070 protocol-- only a few
>> additions in the messages, but no new calls and no new uri scheme. We
>> created a new package 'recurring' where most of the new code lives.
>>
>> At a high level:
>>
>> 1. Creation of the subscription:
>>
>> The initial handshake for creating the subscription is exactly similar to
>> the one for the payment protocol (PaymentRequest is used to provide the
>> contract)
>>
>> 2. Wallet can decide to poll the merchants for its active subscriptions.
>>
>> Here the flow is exactly similar to the payment protocol but the wallet
>> receives a callback to verify the payment matches the contract and should
>> go through.
>>
>> Please give us some feedback whenever you have the chance. In the
>> meantime we will start implementing the merchant side and test the code.
>>
>> Cheers!
>>
>>
>>
>> On Jan 31, 2014, at 10:13 AM, Mike Hearn <mike at plan99.net> wrote:
>>
>> That looks OK at a very high level. Things you probably want to think
>> about:
>>
>>    - How to trigger it off the existing payment protocol (no new top
>>    level messages or mime types or uri extensions please)
>>    - Data structures to define the payment schedule
>>    - Do you allow pre-submission of time locked transactions or not?
>>
>> I think as you prototype these things will become clearer.  You could try
>> prototyping either in Bitcoin Core (C++) or bitcoinj (java, look at the
>> PaymentSession class).
>>
>>
>>
>> On Wed, Jan 29, 2014 at 3:47 AM, Stephane Brossier <
>> stephane at kill-bill.org> wrote:
>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>> *From what I have seen so far, there seems to be an agreement that this
>>> is a nice feature to add. We are pretty new to that community and so we
>>> don't know exactly what the process is, and in particular how we reach
>>> consensus via email. I am certainly open to follow 'the way' if there is
>>> one, but one solution would be to follow Mike's suggestion on providing a
>>> (prototype) implementation first and then defining/refining the BIP. Odinn
>>> also suggested a possible retribution for our time through crowd-sourcing
>>> which I am interested to pursue if that makes sense. We have quite some
>>> experience on the subscription side of things and while we are growing our
>>> knowledge on the Bitcoin technology (and ecosystem at large) we would
>>> benefit from: * some feedbacks on the high level proposal * additional
>>> requirements we might have missed So, below is a high level description of
>>> what we have in mind. If this sounds reasonable, we could start working on
>>> an implementation. I. Abstract --------------- This describes a protocol to
>>> enable recurring payments in bitcoins and can be seen as an extension of
>>> BIP-0070. The main goal here is to have the customer subscribe to a service
>>> of some kind (that is, agreeing on the terms of that subscription
>>> contract), and then have the wallet make recurring payments without any
>>> intervention from the customer as long as the payments match what the
>>> customer agreed on paying. An example of such service would be an online
>>> streaming website, to which a user pays a fixed recurring monthly fee to
>>> access videos (a.k.a. resources). Note that there is also usage based
>>> billing: for example, the user may need to purchase additional access for
>>> premium videos (overage charges). This type of billing is more complicated
>>> and there are many variations to it used in the industry (pre-paid, ...). For
>>> the sake of discussion, we'll focus on fixed recurring payments only, but
>>> we will keep usage in mind to make sure the protocol will be able to
>>> support it as well. II. Motivation ------------------ Subscription based
>>> services have been growing in the past few years and so the intent it to
>>> make it possible for customers to pay in bitcoins. Bitcoin's push model
>>> presents new advantages for the customer compared to traditional payment
>>> methods: the user has control over the subscription (for example, there is
>>> no need to call the merchant to explicitly cancel the credit card
>>> payments). It also opens the door to subscription management tools in
>>> wallets (e.g. Hive apps), which would give user an overview of what they
>>> are paying each month. III. Flow of
>>> Operations----------------------------------------*
>>>
>>>
>>>
>>>
>>> * Creation of the subscription: - - - - - - - - - - - - - - - - - - - -
>>> - - 1. The customer clicks 'subscribe' -> A message is sent to the
>>> merchant. 2. The merchant sends back a message to the wallet with the
>>> details of the subscription such as the amount to be paid. In reality,
>>> there will be more information but for the purpose of the prototype
>>> implementation this is sufficient. 3. The wallet prompts the customer for
>>> authorization. 4. The customer authorizes (or denies) it. 5. The wallet
>>> sends the confirmation to the merchant. 6. The merchant confirms the
>>> subscription was created. Ongoing payments: *
>>>
>>> *- - - - - - - - - - - - - - - - *
>>>
>>>
>>>
>>>
>>>
>>>
>>> * From that time on and since Bitcoin is a 'push' model, the wallet is
>>> responsible to poll the merchant for due payments associated with that
>>> subscription. Note that the merchant could specify hints to the wallet on
>>> when to poll (specific dates) or not during the registration of the
>>> subscription. Note that we can't simply have the wallet push X bitcoins
>>> every month: the user account on the merchant side may have gotten credits,
>>> invoice adjustments, etc. since the last invoice, so the amount to pay for
>>> a given billing period may be lower than the regular amount. It could even
>>> be zero if the user decides to make a one-time payment to the merchant
>>> directly using a different wallet. Hence, the wallet needs to get the
>>> latest invoice balance to make sure how much it should pay. This also opens
>>> the door for the support of overage charges. Quick note on the
>>> implementation on the merchant side: an entitlement system is a piece of
>>> logic on the merchant side which grants the user access to certain
>>> resources depending on the account status (unpaid invoices, etc.). This
>>> goes often hand in hand with a dunning system, which progressively
>>> restricts access as the user's account is more and more overdue. Since
>>> wallets can be offline for an extended period of time, payments may be
>>> missed and lead to an overdue state (e.g. extra fees, service degraded). It
>>> is the responsibility of the customer to ensure the wallet is up often
>>> enough for payments to happen. In that recurring phase where the wallet
>>> polls the merchant, the wallet is responsible to check that payments match
>>> the subscription contract; that is, the amount, frequency of payments, ...
>>> match what the customer agreed on. If so, the payment is made without
>>> asking for explicit approval from customer, and the flow is similar to
>>> BIP-0070: The message is sent to the merchant, and in parallel, a
>>> transaction is sent to the btcnet. The merchant sends an ACK to the wallet
>>> and of course checks the states of the transactions on the btcnet to mark
>>> that payment as successful. Subscription change (optional): *
>>>
>>> *- - - - - - - - - - - - - - - - - - - - - - - - *
>>>
>>>
>>> * Optionally we could implement a change in the ongoing subscription to
>>> address the upgrade/downgrade scenarios. Of course, we could also simply
>>> support a cancellation followed by a creation of a new subscription, but
>>> having that as a one atomic message is probably better. The steps are very
>>> similar to the initial registration. 1. The customer clicks 'upgrade',
>>> 'downgrade', ... -> A msg is sent to the merchant. 2. The merchant sends back
>>> a msg to the wallet with the detail of the NEW subscription. 3. The wallet
>>> prompts the customer for authorization. 4. The customer authorizes (or
>>> denies) it. 5. The wallet sends the confirmation to the merchant. 6. The
>>> merchant confirms the change in the subscription. Cancellation of the
>>> subscription: *
>>>
>>> *- - - - - - - - - - - - - - - - - - - - - - - - - *
>>>
>>>
>>>
>>> * The cancellation is initiated from the customer: 1. The customer
>>> clicks 'cancel' -> The wallet is informed that it  should not accept any
>>> new payment associated to that subscription. 2. The wallet sends a message
>>> to the merchant to inform about the cancellation. 3. The merchant confirms
>>> the subscription was cancelled. *
>>>
>>
>>
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140211/2b958bf7/attachment.html>

From allen.piscitello at gmail.com  Wed Feb 12 16:38:18 2014
From: allen.piscitello at gmail.com (Allen Piscitello)
Date: Wed, 12 Feb 2014 10:38:18 -0600
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CALf2ePyDTZ_43uBfS9-5znhTyBR-5H10SpZ=N-z1DBacM_rDgA@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
	<CALf2ePyDTZ_43uBfS9-5znhTyBR-5H10SpZ=N-z1DBacM_rDgA@mail.gmail.com>
Message-ID: <CAJfRnm5pVA+gd3t=bXO188S4uwtUvx5F8V_bO_YV+74Ev4Q9jg@mail.gmail.com>

While that solution does work for many use cases, it does make it much
harder to do anything needing chained transactions.  Granted, this is the
short term solution for current implementations, but having a transaction
identifier that does not change does open up other use cases.

For example, Alice wants to send coins to a multisignature address with
Bob, such that both parties are required to spend the coins.  Alice also
requires for Bob to send coins to this address as well before they will
proceed.  Alice cannot guarantee that Bob will cooperate (and vice versa),
so before she broadcasts the transaction to send to A+B, she sends Bob a
transaction that spends her incoming transaction back to herself, but has a
time lock of far into the future.  Bob signs this, returns it to Alice, and
she broadcasts her funding transaction.  At this point, Bob disappears,
loses his key, or just decides to spite Alice and her coins are locked.
 Since she has a refund transaction, she can broadcast it in a month and
get her coins back.  Except her funding transaction has been modified such
that the txhash is different, so her refund is now invalid.  She would need
Bob to issue a new refund as soon as her funding transaction hits the
blockchain if it is modified, which defeats the point of the trustless
refund transaction.

Longer term it would be more ideal have a canonical identifier for the
transaction before it even gets to the chain to support these use cases,
even if wallets are able to properly identify the status of it's
transactions.  Obviously this is a difficult problem to solve and cannot be
implemented without breaking changes, but it would be a nice goal to be
able to completely remove malleability.  There are other important use
cases where having a unique identifier just for internal accounting is
insufficient.

-Allen


On Wed, Feb 12, 2014 at 10:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:

> I think the solution is simply to encourage Bitcoin software developers to
> design their software to use this static ID, instead of the full
> transaction hash.    If MtGox had talked those IDs instead of the TX ID,
> their software would've correctly identified the mutated transactions and
> there would be  no problem.
>
> Armory is slightly different, since it doesn't deal with the same stuff as
> exchanges do.  But it didn't have any problems with malleability because it
> doesn't track anything by ID, it only pays attention to whether inputs and
> outputs are related to your wallets.  It's not necessarily hard to do it
> this way, people just have to be aware of it.
>
> -Alan
>
> Sent from my overpriced smartphone
> On Feb 12, 2014 10:15 AM, "Rune Kj?r Svendsen" <runesvend at gmail.com>
> wrote:
>
>> Instead of trying to remove the possibility of transaction
>> malleability, would it make sense to define a new, "canonical
>> transaction hash/ID" (cTxID), which would be a hash of the part of the
>> transaction data which we know is not malleable, and have clients use
>> this cTxID internally, thus making the traditional transaction hash
>> irrelevant for a client to function correctly?
>>
>> We already have a non-malleable transaction hash: the hash that is
>> signed, ie. the transaction with each scriptSig replaced by the
>> scriptPubKey it redeems. This could be the cTxID.
>>
>> Or is this simply a too fundamental change to the way bitcoin-qt (and
>> all other clients) work in order to be feasible?
>>
>> As far as I can see, it completely solves the issue of not having a
>> canonical ID for a transaction, but it also increases the
>> computational requirements for a node. For one, as far as I can see,
>> it requires the node to index all transactions, because in order to
>> calculate a cTxID, it would be necessary to fetch all transactions
>> referred to by the transaction in question, in order to pull in the
>> scriptPubKeys that are redeemed.
>>
>>
>> On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:
>> > On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:
>> >> Hello all,
>> >>
>> >> it was something I planned to do since a long time, but with the
>> >> recent related issues popping up, I finally got around to writing a
>> >> BIP about how we can get rid of transaction malleability over time.
>> >>
>> >> The proposed document is here: https://gist.github.com/sipa/8907691
>> >>
>> >> I expect most rules to not be controversial. Maybe rules 1 and 3, as
>> >> they require modifications to wallet software (Bitcoin Core 0.9 and
>> >> BitcoinJ already implement it, though) and potentially invalidate some
>> >> script functionality. However, these new rules remain optional and
>> >> controlled by an nVersion increase.
>> >>
>> >> Comments please!
>> >
>> > You should probably add making CHECKMULTISIG require the dummy value to
>> > be exactly equal to OP_FALSE; verifying that in the transaction itself
>> is
>> > laborious. A more subtle example is we may want both CHECKSIG and
>> > CHECKMULTISIG to fail the transaction if the signature is invalid but
>> > not exactly equal to OP_FALSE; some transaction forms are significantly
>> > more compact if you can have failed signatures, but that's a source of
>> > malleability. (are there counter examples people can think of?)
>> >
>> >
>> > But as I said on IRC, I'm a bit hesitant to bake in assumptions about
>> > malleability when we have no solid idea if ECC signatures are or are not
>> > malleable on a fundemental level; if "whack-a-mole" anti-malleability is
>> > all we've got it could be ugly if a break is found. Similarly, we may
>> > find we missed something, or some needed change makes the malleability
>> > rules difficult to work with for some new script type that is required.
>> >
>> > I'd rather see a new CHECKSIG mode for the case where malleability
>> > absolutely must be eliminated - certain multi-party protocols - and fix
>> > wallet software instead. (the malleability problems people see are
>> > closely related to inability to handle double-spends and reorgs) But I
>> > can easily see that being an impossible goal engineering wise...
>> >
>> > --
>> > 'peter'[:-1]@petertodd.org
>> > 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
>> >
>> >
>> ------------------------------------------------------------------------------
>> > Managing the Performance of Cloud-Based Applications
>> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>> > Read the Whitepaper.
>> >
>> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
>> > _______________________________________________
>> > Bitcoin-development mailing list
>> > Bitcoin-development at lists.sourceforge.net
>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>> >
>>
>>
>> ------------------------------------------------------------------------------
>> Android apps run on BlackBerry 10
>> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
>> Now with support for Jelly Bean, Bluetooth, Mapview and more.
>> Get your Android app in front of a whole new audience.  Start now.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
> ------------------------------------------------------------------------------
> Android apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/af6a7c54/attachment.html>

From carterd at gmail.com  Wed Feb 12 16:34:48 2014
From: carterd at gmail.com (Dan Carter)
Date: Wed, 12 Feb 2014 08:34:48 -0800
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140209180458.GB20126@savin>
References: <20140209180458.GB20126@savin>
Message-ID: <ldg7qs$6rn$1@ger.gmane.org>

I'm not sure how well this would work.

Sure it would provide honest historical pricing, but those who wait for 
publication confirmation may be at a disadvantage -- to get the best 
deal possible Bob would connect to as many nodes as he could, examine 
the stream of unconfirmed asks coming in and sign the best ones before 
someone else does.  The network would gravitate towards an O(n^2) fully 
connected network, because being fully connected means one is fully 
aware of all unconfirmed asks at any moment so one can make the best 
judgement and buy before someone else does.

The seller needs a guarantee that all bidders can act on the ask 
transaction simultaneously. Maybe the partial ask transaction could be 
time-locked with a network propagation delay, there would be multiple 
bidder responses and the winner is chosen by lottery (and fee priority) 
by the bitcoin/alt-coin miner who confirms the atomic transaction in 
their block.  That would eliminate the advantage to being fully 
connected as it would no longer matter that one can act first, so you 
have a more sane network.

On 2014-02-09 10:04 AM, Peter Todd wrote:
> Proof-of-publication(2) offers a solution. Alice can embed her
> incomplete transaction as data in a second, valid, transaction. She
> broadcasts this secondary transaction to some agreed upon blockchain,
> either the one the colored coin is in, or potentially a secondary system
> with suitable proof-of-publication security. Bidders such as Bob can now
> scan the blockchain for offers with an acceptable price. (the offers can
> make use of techniques like prefix filters to allow Bob to only scan
> part of the blockchain, although Bob needs to know the status of all
> assets of the type he is interested in anyway)




From etotheipi at gmail.com  Wed Feb 12 16:44:13 2014
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 12 Feb 2014 11:44:13 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAJfRnm5pVA+gd3t=bXO188S4uwtUvx5F8V_bO_YV+74Ev4Q9jg@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
	<CALf2ePyDTZ_43uBfS9-5znhTyBR-5H10SpZ=N-z1DBacM_rDgA@mail.gmail.com>
	<CAJfRnm5pVA+gd3t=bXO188S4uwtUvx5F8V_bO_YV+74Ev4Q9jg@mail.gmail.com>
Message-ID: <CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>

Agreed.  I'm not suggesting that malleability shouldn't be fixed or isn't a
problem.  I would love to be able to leverage chained TX for Bitcoin
contracts.  But that in its current state it doesn't have to be complicated
to deal with  it.

Changing the protocol to use these static IDs is a pretty fundamental
change that would never happen in Bitcoin.   But they can still be useful
at the application level to mitigate these issues.

Sent from my overpriced smartphone
On Feb 12, 2014 11:38 AM, "Allen Piscitello" <allen.piscitello at gmail.com>
wrote:

> While that solution does work for many use cases, it does make it much
> harder to do anything needing chained transactions.  Granted, this is the
> short term solution for current implementations, but having a transaction
> identifier that does not change does open up other use cases.
>
> For example, Alice wants to send coins to a multisignature address with
> Bob, such that both parties are required to spend the coins.  Alice also
> requires for Bob to send coins to this address as well before they will
> proceed.  Alice cannot guarantee that Bob will cooperate (and vice versa),
> so before she broadcasts the transaction to send to A+B, she sends Bob a
> transaction that spends her incoming transaction back to herself, but has a
> time lock of far into the future.  Bob signs this, returns it to Alice, and
> she broadcasts her funding transaction.  At this point, Bob disappears,
> loses his key, or just decides to spite Alice and her coins are locked.
>  Since she has a refund transaction, she can broadcast it in a month and
> get her coins back.  Except her funding transaction has been modified such
> that the txhash is different, so her refund is now invalid.  She would need
> Bob to issue a new refund as soon as her funding transaction hits the
> blockchain if it is modified, which defeats the point of the trustless
> refund transaction.
>
> Longer term it would be more ideal have a canonical identifier for the
> transaction before it even gets to the chain to support these use cases,
> even if wallets are able to properly identify the status of it's
> transactions.  Obviously this is a difficult problem to solve and cannot be
> implemented without breaking changes, but it would be a nice goal to be
> able to completely remove malleability.  There are other important use
> cases where having a unique identifier just for internal accounting is
> insufficient.
>
> -Allen
>
>
> On Wed, Feb 12, 2014 at 10:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:
>
>> I think the solution is simply to encourage Bitcoin software developers
>> to design their software to use this static ID, instead of the full
>> transaction hash.    If MtGox had talked those IDs instead of the TX ID,
>> their software would've correctly identified the mutated transactions and
>> there would be  no problem.
>>
>> Armory is slightly different, since it doesn't deal with the same stuff
>> as exchanges do.  But it didn't have any problems with malleability because
>> it doesn't track anything by ID, it only pays attention to whether inputs
>> and outputs are related to your wallets.  It's not necessarily hard to do
>> it this way, people just have to be aware of it.
>>
>> -Alan
>>
>> Sent from my overpriced smartphone
>> On Feb 12, 2014 10:15 AM, "Rune Kj?r Svendsen" <runesvend at gmail.com>
>> wrote:
>>
>>> Instead of trying to remove the possibility of transaction
>>> malleability, would it make sense to define a new, "canonical
>>> transaction hash/ID" (cTxID), which would be a hash of the part of the
>>> transaction data which we know is not malleable, and have clients use
>>> this cTxID internally, thus making the traditional transaction hash
>>> irrelevant for a client to function correctly?
>>>
>>> We already have a non-malleable transaction hash: the hash that is
>>> signed, ie. the transaction with each scriptSig replaced by the
>>> scriptPubKey it redeems. This could be the cTxID.
>>>
>>> Or is this simply a too fundamental change to the way bitcoin-qt (and
>>> all other clients) work in order to be feasible?
>>>
>>> As far as I can see, it completely solves the issue of not having a
>>> canonical ID for a transaction, but it also increases the
>>> computational requirements for a node. For one, as far as I can see,
>>> it requires the node to index all transactions, because in order to
>>> calculate a cTxID, it would be necessary to fetch all transactions
>>> referred to by the transaction in question, in order to pull in the
>>> scriptPubKeys that are redeemed.
>>>
>>>
>>> On Mon, Feb 10, 2014 at 4:00 AM, Peter Todd <pete at petertodd.org> wrote:
>>> > On Mon, Feb 10, 2014 at 12:33:02AM +0100, Pieter Wuille wrote:
>>> >> Hello all,
>>> >>
>>> >> it was something I planned to do since a long time, but with the
>>> >> recent related issues popping up, I finally got around to writing a
>>> >> BIP about how we can get rid of transaction malleability over time.
>>> >>
>>> >> The proposed document is here: https://gist.github.com/sipa/8907691
>>> >>
>>> >> I expect most rules to not be controversial. Maybe rules 1 and 3, as
>>> >> they require modifications to wallet software (Bitcoin Core 0.9 and
>>> >> BitcoinJ already implement it, though) and potentially invalidate some
>>> >> script functionality. However, these new rules remain optional and
>>> >> controlled by an nVersion increase.
>>> >>
>>> >> Comments please!
>>> >
>>> > You should probably add making CHECKMULTISIG require the dummy value to
>>> > be exactly equal to OP_FALSE; verifying that in the transaction itself
>>> is
>>> > laborious. A more subtle example is we may want both CHECKSIG and
>>> > CHECKMULTISIG to fail the transaction if the signature is invalid but
>>> > not exactly equal to OP_FALSE; some transaction forms are significantly
>>> > more compact if you can have failed signatures, but that's a source of
>>> > malleability. (are there counter examples people can think of?)
>>> >
>>> >
>>> > But as I said on IRC, I'm a bit hesitant to bake in assumptions about
>>> > malleability when we have no solid idea if ECC signatures are or are
>>> not
>>> > malleable on a fundemental level; if "whack-a-mole" anti-malleability
>>> is
>>> > all we've got it could be ugly if a break is found. Similarly, we may
>>> > find we missed something, or some needed change makes the malleability
>>> > rules difficult to work with for some new script type that is required.
>>> >
>>> > I'd rather see a new CHECKSIG mode for the case where malleability
>>> > absolutely must be eliminated - certain multi-party protocols - and fix
>>> > wallet software instead. (the malleability problems people see are
>>> > closely related to inability to handle double-spends and reorgs) But I
>>> > can easily see that being an impossible goal engineering wise...
>>> >
>>> > --
>>> > 'peter'[:-1]@petertodd.org
>>> > 0000000000000001465bc2730ffed7493d166d18d288f6cf15e8cdb5d4a3c7b1
>>> >
>>> >
>>> ------------------------------------------------------------------------------
>>> > Managing the Performance of Cloud-Based Applications
>>> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>>> > Read the Whitepaper.
>>> >
>>> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
>>> > _______________________________________________
>>> > Bitcoin-development mailing list
>>> > Bitcoin-development at lists.sourceforge.net
>>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>> >
>>>
>>>
>>> ------------------------------------------------------------------------------
>>> Android apps run on BlackBerry 10
>>> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
>>> Now with support for Jelly Bean, Bluetooth, Mapview and more.
>>> Get your Android app in front of a whole new audience.  Start now.
>>>
>>> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
>>> _______________________________________________
>>> Bitcoin-development mailing list
>>> Bitcoin-development at lists.sourceforge.net
>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>
>>
>>
>> ------------------------------------------------------------------------------
>> Android apps run on BlackBerry 10
>> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
>> Now with support for Jelly Bean, Bluetooth, Mapview and more.
>> Get your Android app in front of a whole new audience.  Start now.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/aab9621c/attachment.html>

From jgarzik at bitpay.com  Wed Feb 12 17:13:03 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 12 Feb 2014 12:13:03 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
Message-ID: <CAJHLa0P0M+DZ-NUzfwp7up==RXYOD8ZpRKEXckfTY5cMTUaSZQ@mail.gmail.com>

On Wed, Feb 12, 2014 at 10:12 AM, Rune Kj?r Svendsen
<runesvend at gmail.com> wrote:
> Instead of trying to remove the possibility of transaction
> malleability, would it make sense to define a new, "canonical
> transaction hash/ID" (cTxID),

Yes, that is one proposal:  https://github.com/sipa/bitcoin/commits/normtxid

But it is not a complete solution for all transaction types.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From stick at gk2.sk  Wed Feb 12 16:56:35 2014
From: stick at gk2.sk (Pavol Rusnak)
Date: Wed, 12 Feb 2014 17:56:35 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
Message-ID: <52FBA7C3.4060603@gk2.sk>

On 02/10/2014 12:33 AM, Pieter Wuille wrote:
> The proposed document is here: https://gist.github.com/sipa/8907691

If we are bumping nVersion, how about dropping DER encoding completely
and using just 64 bytes directly for signature?

Also using 2 different variable integer encodings (in addition to what
DER already does) is very confusing.

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick at gk2.sk>



From pieter.wuille at gmail.com  Wed Feb 12 17:21:39 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 12 Feb 2014 18:21:39 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAJHLa0P0M+DZ-NUzfwp7up==RXYOD8ZpRKEXckfTY5cMTUaSZQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
	<CAJHLa0P0M+DZ-NUzfwp7up==RXYOD8ZpRKEXckfTY5cMTUaSZQ@mail.gmail.com>
Message-ID: <CAPg+sBhvYu3Z8DGiNLAYQi_y9QJAEZdajXWeTWrHZgBX_QricA@mail.gmail.com>

It's also not necessary for wallet software - it's really just for
human consumption.

A wallet can easily detect inputs being respent in another
transaction. You don't need a static hash for that (which wouldn't
need with all hash types, non-malleability double spends, ...).

On Wed, Feb 12, 2014 at 6:13 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:
> On Wed, Feb 12, 2014 at 10:12 AM, Rune Kj?r Svendsen
> <runesvend at gmail.com> wrote:
>> Instead of trying to remove the possibility of transaction
>> malleability, would it make sense to define a new, "canonical
>> transaction hash/ID" (cTxID),
>
> Yes, that is one proposal:  https://github.com/sipa/bitcoin/commits/normtxid
>
> But it is not a complete solution for all transaction types.
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>
> ------------------------------------------------------------------------------
> Android apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From pieter.wuille at gmail.com  Wed Feb 12 17:22:50 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 12 Feb 2014 18:22:50 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <52FBA7C3.4060603@gk2.sk>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<52FBA7C3.4060603@gk2.sk>
Message-ID: <CAPg+sBizBm2MX2xFWOt7maT-DZirVDOPnOCHoNoVQ_VcNMcCog@mail.gmail.com>

On Wed, Feb 12, 2014 at 5:56 PM, Pavol Rusnak <stick at gk2.sk> wrote:
> On 02/10/2014 12:33 AM, Pieter Wuille wrote:
>> The proposed document is here: https://gist.github.com/sipa/8907691
>
> If we are bumping nVersion, how about dropping DER encoding completely
> and using just 64 bytes directly for signature?

That would be a hard fork. Certainly something to be discussed if we
ever introduce a version-2 scripting language, but that's a long-term
thing.

-- 
Pieter



From gmaxwell at gmail.com  Wed Feb 12 18:03:21 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Wed, 12 Feb 2014 10:03:21 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
Message-ID: <CAAS2fgShVqU+T6q56H2ePZhuHvGgftdXh=zUvgeQRRG2pOP8NQ@mail.gmail.com>

On Wed, Feb 12, 2014 at 7:12 AM, Rune Kj?r Svendsen <runesvend at gmail.com> wrote:
> Instead of trying to remove the possibility of transaction
> malleability, would it make sense to define a new, "canonical
> transaction hash/ID" (cTxID), which would be a hash of the part of the
> transaction data which we know is not malleable, and have clients use
> this cTxID internally, thus making the traditional transaction hash
> irrelevant for a client to function correctly?

This is fine and good. But it only scratches the surface of the
problems created by malleability, especially for fancier transaction
protocols.

Mutation allows you to invalidate a chain of unconfirmed transaction
by mutating the parent. This breaks any protocol which depends on
creating a precomputed nlocked time refund transaction.

So a canonical ID can be used to prevent some buggy behavior it
doesn't actually fix the problem. Fortunately the non-fixed parts
aren't too critical today.

On Wed, Feb 12, 2014 at 8:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:
> I think the solution is simply to encourage Bitcoin software developers to
> design their software to use this static ID, instead of the full transaction
> hash.    If MtGox had talked those IDs instead of the TX ID, their software
> would've correctly identified the mutated transactions and there would be
> no problem.

This is incorrect.  MtGox was automatically issuing replacement
transactions resulting in double payments.

When you attempt to replace/reissue/cancel a transaction you __MUST__
double-spend the original transaction. If the original transaction has
not been conflicted then it is possible someone will pull the original
transaction out of a hat and both your replacement and the original
will be confirmed.  It is not safe at any time to look to see if the
original has been confirmed yet, and if not reissue? not because
mutation may mean you're looking in the wrong place? but because the
state of the world could change nano-seconds after you looked.

If you do double-spend the original then there is no chance that both
will go through, you'll have atomic exclusion and only one transaction
or the other will be confirmed.



From etotheipi at gmail.com  Wed Feb 12 18:21:23 2014
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 12 Feb 2014 13:21:23 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CALf2ePyQeOxL3d+QoaWSYy_cCKaF9qq1StBwXFms9NyedUg3eg@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
	<CAAS2fgShVqU+T6q56H2ePZhuHvGgftdXh=zUvgeQRRG2pOP8NQ@mail.gmail.com>
	<CALf2ePyQeOxL3d+QoaWSYy_cCKaF9qq1StBwXFms9NyedUg3eg@mail.gmail.com>
Message-ID: <CALf2ePw2jtA3UOrdqk_DS1kfpKZm39RdSUw3FoP9Bkyog5=QRg@mail.gmail.com>

We're talking about two slightly different things.  If their system had
tracked by inputs and outputs (or some kind of static ID) , their system
wouldn't have been issuing refunds/replacements/cancellations in the first
place.

I agree with you that the reissuing code should also guarantee that both TX
can't be valid... But really their system should do both.   Without the I/O
based tracking their bookkeeping will be off, regardless of the reissuing
code,  because they can't properly associate outgoing transactions with
customer accounts/actions.

Sent from my overpriced smartphone
On Feb 12, 2014 1:06 PM, "Gregory Maxwell" <gmaxwell at gmail.com> wrote:

On Wed, Feb 12, 2014 at 7:12 AM, Rune Kj?r Svendsen <runesvend at gmail.com>
wrote:
> Instead of trying to remove the possibility of transaction
> malleability, would it make sense to define a new, "canonical
> transaction hash/ID" (cTxID), which would be a hash of the part of the
> transaction data which we know is not malleable, and have clients use
> this cTxID internally, thus making the traditional transaction hash
> irrelevant for a client to function correctly?

This is fine and good. But it only scratches the surface of the
problems created by malleability, especially for fancier transaction
protocols.

Mutation allows you to invalidate a chain of unconfirmed transaction
by mutating the parent. This breaks any protocol which depends on
creating a precomputed nlocked time refund transaction.

So a canonical ID can be used to prevent some buggy behavior it
doesn't actually fix the problem. Fortunately the non-fixed parts
aren't too critical today.

On Wed, Feb 12, 2014 at 8:22 AM, Alan Reiner <etotheipi at gmail.com> wrote:
> I think the solution is simply to encourage Bitcoin software developers to
> design their software to use this static ID, instead of the full
transaction
> hash.    If MtGox had talked those IDs instead of the TX ID, their
software
> would've correctly identified the mutated transactions and there would be
> no problem.

This is incorrect.  MtGox was automatically issuing replacement
transactions resulting in double payments.

When you attempt to replace/reissue/cancel a transaction you __MUST__
double-spend the original transaction. If the original transaction has
not been conflicted then it is possible someone will pull the original
transaction out of a hat and both your replacement and the original
will be confirmed.  It is not safe at any time to look to see if the
original has been confirmed yet, and if not reissue-- not because
mutation may mean you're looking in the wrong place-- but because the
state of the world could change nano-seconds after you looked.

If you do double-spend the original then there is no chance that both
will go through, you'll have atomic exclusion and only one transaction
or the other will be confirmed.

------------------------------------------------------------------------------
Android apps run on BlackBerry 10
Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
Now with support for Jelly Bean, Bluetooth, Mapview and more.
Get your Android app in front of a whole new audience.  Start now.
http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/332272c2/attachment.html>

From mark at monetize.io  Wed Feb 12 20:27:52 2014
From: mark at monetize.io (Mark Friedenbach)
Date: Wed, 12 Feb 2014 12:27:52 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>	<20140210030048.GB31925@savin>	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>	<CALf2ePyDTZ_43uBfS9-5znhTyBR-5H10SpZ=N-z1DBacM_rDgA@mail.gmail.com>	<CAJfRnm5pVA+gd3t=bXO188S4uwtUvx5F8V_bO_YV+74Ev4Q9jg@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
Message-ID: <52FBD948.906@monetize.io>

On 02/12/2014 08:44 AM, Alan Reiner wrote:
> Changing the protocol to use these static IDs is a pretty fundamental
> change that would never happen in Bitcoin.   But they can still be
> useful at the application level to mitigate these issues.

Not to mention that it would be potentially very insecure to have
consensus depend on data (scriptSigs) which are not hashed in the Merkle
structure of a block.

Not that anyone on this list has suggested such a change, but I've seen
it raised multiple times on the forum....

Mark



From luke at dashjr.org  Wed Feb 12 22:52:30 2014
From: luke at dashjr.org (Luke-Jr)
Date: Wed, 12 Feb 2014 22:52:30 +0000
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <52FBD948.906@monetize.io>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io>
Message-ID: <201402122252.31060.luke@dashjr.org>

On Wednesday, February 12, 2014 8:27:52 PM Mark Friedenbach wrote:
> On 02/12/2014 08:44 AM, Alan Reiner wrote:
> > Changing the protocol to use these static IDs is a pretty fundamental
> > change that would never happen in Bitcoin.   But they can still be
> > useful at the application level to mitigate these issues.
> 
> Not to mention that it would be potentially very insecure to have
> consensus depend on data (scriptSigs) which are not hashed in the Merkle
> structure of a block.
> 
> Not that anyone on this list has suggested such a change, but I've seen
> it raised multiple times on the forum....

This would be a problem if it was used in the merkle tree, but I'm pretty sure 
using it for input selection would be pretty safe. One could even avoid the 
index by simply using the hashScript as the sole input value; then even 
CoinJoins would be safe without breaking chains of transactions (although this 
would break address reuse entirely - but I don't see that as a problem in a 
theoretical world). One of those things that an altcoin could improve upon 
Bitcoin with... ;)



From morcos at gmail.com  Thu Feb 13 00:39:11 2014
From: morcos at gmail.com (Alex Morcos)
Date: Wed, 12 Feb 2014 19:39:11 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <201402122252.31060.luke@dashjr.org>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
Message-ID: <CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>

I apologize if this has been discussed many times before.

As a long term solution to malleable transactions, wouldn't it be possible
to modify the signatures to be of the entire transaction.  Why do you have
to zero out the inputs?  I can see that this would be a hard fork, and
maybe it would be somewhat tricky to extract signatures first (since you
can sign everything except the signatures), but it would seem to me that
this is an important enough change to consider making.








On Wed, Feb 12, 2014 at 5:52 PM, Luke-Jr <luke at dashjr.org> wrote:

> On Wednesday, February 12, 2014 8:27:52 PM Mark Friedenbach wrote:
> > On 02/12/2014 08:44 AM, Alan Reiner wrote:
> > > Changing the protocol to use these static IDs is a pretty fundamental
> > > change that would never happen in Bitcoin.   But they can still be
> > > useful at the application level to mitigate these issues.
> >
> > Not to mention that it would be potentially very insecure to have
> > consensus depend on data (scriptSigs) which are not hashed in the Merkle
> > structure of a block.
> >
> > Not that anyone on this list has suggested such a change, but I've seen
> > it raised multiple times on the forum....
>
> This would be a problem if it was used in the merkle tree, but I'm pretty
> sure
> using it for input selection would be pretty safe. One could even avoid the
> index by simply using the hashScript as the sole input value; then even
> CoinJoins would be safe without breaking chains of transactions (although
> this
> would break address reuse entirely - but I don't see that as a problem in a
> theoretical world). One of those things that an altcoin could improve upon
> Bitcoin with... ;)
>
>
> ------------------------------------------------------------------------------
> Android apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140212/1bd41008/attachment.html>

From gmaxwell at gmail.com  Thu Feb 13 00:47:05 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Wed, 12 Feb 2014 16:47:05 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
Message-ID: <CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>

On Wed, Feb 12, 2014 at 4:39 PM, Alex Morcos <morcos at gmail.com> wrote:
> I apologize if this has been discussed many times before.

It has been, but there are probably many people like you who have not
bothered researching who may also be curious.

> As a long term solution to malleable transactions, wouldn't it be possible
> to modify the signatures to be of the entire transaction.  Why do you have
> to zero out the inputs?  I can see that this would be a hard fork, and maybe
> it would be somewhat tricky to extract signatures first (since you can sign
> everything except the signatures), but it would seem to me that this is an
> important enough change to consider making.

Because doing so would be both unnecessary and ineffective.

Unnecessary because we can very likely eliminate malleability without
changing what is signed. It will take time, but we have been
incrementally moving towards that, e.g. v0.8 made many kinds of
non-canonical encoding non-standard.

Ineffective? at least as you describe it? because the signatures
_themselves_ are malleable.



From namanhd at gmail.com  Thu Feb 13 12:20:55 2014
From: namanhd at gmail.com (naman naman)
Date: Thu, 13 Feb 2014 17:50:55 +0530
Subject: [Bitcoin-development] MtGox blames bitcoin
In-Reply-To: <CA+SxJWArhdVyfGL=V6wa_EFRC3yGDo6vWus+jx9E=u4i_RJc6Q@mail.gmail.com>
References: <CANAnSg1LgpHGf-vTV0to1Z7sogf1ic6WTbogEsrQy1wh4C5zfw@mail.gmail.com>
	<20140210144003.2BDCCDDAEFC@quidecco.de>
	<20140210163055.GJ3180@nl.grid.coop>
	<CAAS2fgQjKHK4ReQOEtLsTt9KOLxT4G-MiZJ7UKU=qH9ifpuN8g@mail.gmail.com>
	<20140210182506.GM3180@nl.grid.coop> <52F91E66.6060305@gmail.com>
	<20140210190703.GO3180@nl.grid.coop> <20140210192308.GA17359@savin>
	<CA+SxJWBbWH_amgpst9N7nfT4twvfreAhGaxVWZYfTiLjyN8m3g@mail.gmail.com>
	<20140210194032.GD17359@savin> <52F9377D.9010405@gmail.com>
	<CA+SxJWBM0USWETNeDh-oRgOfrU64GiPbL_Qt5hrFN53C42yNxg@mail.gmail.com>
	<CAAS2fgS5=-=6Ws0ofWsyKNHLYQop71kOjBCtF6TUMOmVgHtU_g@mail.gmail.com>
	<CA+SxJWArhdVyfGL=V6wa_EFRC3yGDo6vWus+jx9E=u4i_RJc6Q@mail.gmail.com>
Message-ID: <CA+SxJWAm7mDLG7ymggsJb9M=CgrLObuM7z8XVyEs+ty+266XoA@mail.gmail.com>

Hi guys,

I with all thats happening now I think (yea no hard proof) most of it is
being done on purpose (transaction mutation) by some pool/entity.
I have posted here https://bitcointalk.org/index.php?topic=463350.0 of how
to go about finding out if its some pool doing it. This does in no way
solve "fix" the malleability issue BUT IMHO it might help "alleviate" the
problem we are facing at a network level.
Please have a look if possible.

Kind Regards,
thenoblebot


On Wed, Feb 12, 2014 at 2:26 AM, naman naman <namanhd at gmail.com> wrote:

> Gregory Maxwell says : "Try paying a consultant if your ego demands that
> you have a technical
>
> expert to entertain your musing with immediate response."
>
> I don't know why your resorting to such an adhominem. But I have already
> said that you were the only one who responded. Your response was correct as
> is reflected in the conversation on the forums. No doubting that. But it
> does not address the full scope of the attack where a small pool would
> intentionally (or out of whatever reason) make the hash invalid for the txs
> they recieve. So that leaves a whole lot of businesses in the lurch who
> have relied on txid (albeit wrongly that) for their tracking purposes.
> Thats all I'm trying to say, without blaming anyone.
>
> Hope it makes sense.
>
>
> On Wed, Feb 12, 2014 at 2:19 AM, Gregory Maxwell <gmaxwell at gmail.com>wrote:
>
>> On Tue, Feb 11, 2014 at 12:42 PM, naman naman <namanhd at gmail.com> wrote:
>> > I was talking about a DOS attack in
>> > https://bitcointalk.org/index.php?topic=458608.0 (ofcourse only
>> applicable
>> > to entitys doing the tracking with txids).
>> >
>> > Amazing how I did not get a response from any of the devs (except Greg's
>> > response
>> > https://bitcointalk.org/index.php?topic=458608.msg5063789#msg5063789but
>> > that too was short and not concerning the attack scenario plausibiity
>> as I
>> > replied to him).
>>
>> Try paying a consultant if your ego demands that you have a technical
>> expert to entertain your musing with immediate response.
>>
>> My response was absolutely relevant.
>>
>> If you reissue a transaction without respending the prior transactions
>> coins, you will end up double paying. Only spending the inputs in
>> question can prevent the prior transaction (itself or in other form)
>> from going through.
>>
>> Once you respend the inputs there is no risk of actually losing funds
>> due to an issue regardless of how you track coins in your higher level
>> application.
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140213/4b7aa898/attachment.html>

From pete at petertodd.org  Fri Feb 14 05:20:36 2014
From: pete at petertodd.org (Peter Todd)
Date: Fri, 14 Feb 2014 00:20:36 -0500
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <ldg7qs$6rn$1@ger.gmane.org>
References: <20140209180458.GB20126@savin>
 <ldg7qs$6rn$1@ger.gmane.org>
Message-ID: <20140214052036.GE31437@savin>

On Wed, Feb 12, 2014 at 08:34:48AM -0800, Dan Carter wrote:
> I'm not sure how well this would work.
> 
> Sure it would provide honest historical pricing, but those who wait for 
> publication confirmation may be at a disadvantage -- to get the best 
> deal possible Bob would connect to as many nodes as he could, examine 
> the stream of unconfirmed asks coming in and sign the best ones before 
> someone else does.  The network would gravitate towards an O(n^2) fully 
> connected network, because being fully connected means one is fully 
> aware of all unconfirmed asks at any moment so one can make the best 
> judgement and buy before someone else does.
> 
> The seller needs a guarantee that all bidders can act on the ask 
> transaction simultaneously. Maybe the partial ask transaction could be 
> time-locked with a network propagation delay, there would be multiple 
> bidder responses and the winner is chosen by lottery (and fee priority) 
> by the bitcoin/alt-coin miner who confirms the atomic transaction in 
> their block.  That would eliminate the advantage to being fully 
> connected as it would no longer matter that one can act first, so you 
> have a more sane network.

You're assuming the seller cares about fairness - why should they? They
offered a price for an asset and someone bought it; exactly which buyer
willing to buy at that price was able to complete the trade is
irrelevant to them. What they do care about is being sure that at
whatever given price they offered 100% of the buyers willing to buy at
that price actually see the offer in a reasonable amount of time - at
the best price the seller will get there will be only a single buyer
after all so you need that solid proof that said buyer was actually able
to get the offer.

-- 
'peter'[:-1]@petertodd.org
0000000000000000c34e2307bf2d8e1de9db0351acfe7320a08826a5de3c146a
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/06fddd97/attachment.sig>

From pete at petertodd.org  Fri Feb 14 05:21:59 2014
From: pete at petertodd.org (Peter Todd)
Date: Fri, 14 Feb 2014 00:21:59 -0500
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140211175919.GV3180@nl.grid.coop>
References: <20140209180458.GB20126@savin> <20140209204434.GA11488@savin>
	<20140210193247.GC17359@savin> <20140211175919.GV3180@nl.grid.coop>
Message-ID: <20140214052159.GF31437@savin>

On Tue, Feb 11, 2014 at 11:59:19AM -0600, Troy Benjegerdes wrote:
> Is there any code that does this? I would like to develop a multicoin-qt
> wallet that runs on two blockchains from one binary, and allows trading
> using this mechanism between the two chains.

Cross-chain trading is a different thing entirely; it doesn't allow for
the clever 2-party-trade trick. (as far as I know)

-- 
'peter'[:-1]@petertodd.org
0000000000000000c34e2307bf2d8e1de9db0351acfe7320a08826a5de3c146a
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/51eae451/attachment.sig>

From da.colonel at gmail.com  Fri Feb 14 12:20:45 2014
From: da.colonel at gmail.com (Denis Andrejew)
Date: Fri, 14 Feb 2014 13:20:45 +0100
Subject: [Bitcoin-development] working with the blockchain: transaction fees
 & sum(inputs) != sum(outputs) (newbie questions)
Message-ID: <CAPc1t_8kp7dRpjPkK0K6K+mBz4dF9tsVx9n55eaW30FeFvU1EA@mail.gmail.com>

Hi all!

I'm new to development with bitcoin and I have a question for you guys:

What I'm trying to do is read the blockchain in order to find all unspent
outputs. I'm using bitcoind via rpc as my source of information about the
blockchain.

Now one thing that I don't understand fully yet when working with the
transaction data I'm being given is:

How do transaction fees work? More specifically: I can see that there is
often a gap between the sum of the ins and the sum of the outs in a
transaction and I understand that this is the transaction fee. But how can
the miner spend it if it is not assigned as an output of any transaction?
Is there special code somewhere that keeps track of all the btc not spent
in all the transactions of a block and allows the miner's address (ie the
address in the first tx of that block) to spend that? But if so, how would
that work then? I should be finding transactions then where the sum of the
ouputs is higher than the sum of the inputs and one of the inputs should
have the miner's address attached to it or what?

I am a bit confused about this part. Other than that it's quite fascinating
to see how bitcoin works and work with it. :)

So if one of you could kindly explain to me the technical view of
transaction fees (i.e. how exactly do I find them and account for them in
the blockchain), that would be brilliant!

And the other question would be this one (directly related):

What are the cases where the sum of the input values (from the referenced
transactions) can be different from the sum of the output values?

These cases I have found and understand:

1) "coinbase" transactions that "print money" have no inputs, only 50/25
coins output (less in the future)
2) transaction fees when in > out

Are there other cases?

Thanks,
Denis

"Be the change you want to see in the world." (Mahatma Gandhi)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/bf2c5aec/attachment.html>

From laanwj at gmail.com  Fri Feb 14 12:42:56 2014
From: laanwj at gmail.com (Wladimir)
Date: Fri, 14 Feb 2014 13:42:56 +0100
Subject: [Bitcoin-development] working with the blockchain: transaction
 fees & sum(inputs) != sum(outputs) (newbie questions)
In-Reply-To: <CAPc1t_8kp7dRpjPkK0K6K+mBz4dF9tsVx9n55eaW30FeFvU1EA@mail.gmail.com>
References: <CAPc1t_8kp7dRpjPkK0K6K+mBz4dF9tsVx9n55eaW30FeFvU1EA@mail.gmail.com>
Message-ID: <CA+s+GJCrLv60TKC-C1cHRq+om9fMVSiVwjKL-vR9bBOy5kU=wQ@mail.gmail.com>

>
> Is there special code somewhere that keeps track of all the btc not spent
> in all the transactions of a block and allows the miner's address (ie the
> address in the first tx of that block) to spend that?
>

Something like that:
Every block has a coinbase transaction at the beginning.
The coinbase transaction is special, in that it can pay coins to its
outputs without having to specify an input.

The total value of the outputs of the coinbase transaction can be at most
the block value (the fixed amount per block) + the fees (summed over all
transactions in the block).

This is checked in ConnectBlock in
https://github.com/bitcoin/bitcoin/blob/master/src/main.cpp#L1711
The value of the coinbase transaction is being checked on line 1731.

But if so, how would that work then? I should be finding transactions then
> where the sum of the ouputs is higher than the sum of the inputs and one of
> the inputs should have the miner's address attached to it or what?
>

The only transactions in which the sum of the outputs can be larger than
the sum of the inputs are the aforementioned coinbase transactions (which
cannot have inputs).

The outputs from the coinbase transaction can be spent as any other output.

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/f5b662dd/attachment.html>

From stephane at kill-bill.org  Fri Feb 14 20:28:24 2014
From: stephane at kill-bill.org (Stephane Brossier)
Date: Fri, 14 Feb 2014 12:28:24 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
Message-ID: <5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>

Kevin,

We did a second iteration on the prototype to implement subscription cancellation and upgrade/downgrade. We checked in both the bitcoinj and php server to be able to test it.
We also worked on our side of the merchant implementation (Kill Bill) to feel confident that the protocol will support advanced business cases. At this point it is looking promising, but more work is needed to conclude.

We wanted to follow up on a few pervious points you raised:

> However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.

From our merchant side (Kill Bill), we do indeed use this field to report successes or errors. Maybe it would be useful to extend PaymentACK with a boolean success field (so the wallet doesn't commit the transaction in case of failures)?

> One high-level comment -- the wallet in this design doesn't have any way of knowing when the payments are supposed to end. I feel this is important to show to the user before they start their wallet polling infinitely.

We extended our RecurringPaymentDetails message to support this use case, as it solves the problem of subscription changes and cancellations for free.

We introduced the concept of a subscription, referred to by a unique id (the tuple merchant_id,subscription_id should be globally unique), which has multiple contracts (RecurringPaymentContract). Besides payment bounds, each contract has a validity period: generally, a subscription will have a unique active contract at a given time and potentially one or more pending ones.

For example, say you are on the gold plan (1 BTC/mo.) and want to downgrade to a bronze plan (0.5 BTC/mo.) at your next billing date. Wshen you click "Downgrade" on the merchant site, you will update your wallet with two contracts: the current valid one until your next billing date (for up to 1 BTC), and a pending one, starting at your next billing date (for up to 0.5 BTC/mo. and without an ending date).
Upon cancellation of the bronze plan, the end date of the contract will be updated and polling will stop eventually.

All of this contract metadata is returned to the wallet so the user can make an informed decision.


Thanks for your feedbacks!

S.


On Feb 11, 2014, at 10:37 PM, Kevin Greene <kgreenek at gmail.com> wrote:

> Sending this again and truncating since apparently the message body was too long.
> 
> Thanks for humoring my questions!
> 
> >I think reporting such errors to the wallet would make complete sense. However i am not clear why we would a separate url for that?
> 
> Hmm, thinking about this more, adding a simple status_code in PaymentRequest would be a much easier way to achieve this. However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.
> 
> In bitcoinj, right now the code will throw a PaymentRequestException.InvalidOutputs exception if the set of outputs is empty with a message of "No Outputs". Because of that, there isn't a good way to tell the difference between a payment request that had no outputs and a payment request that had some invalid output(s).
> 
> Question to everyone:
> How does bitcoin-qt handle a PaymentRequest with no outputs?

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/3987523b/attachment.html>

From da.colonel at gmail.com  Fri Feb 14 20:56:56 2014
From: da.colonel at gmail.com (Denis Andrejew)
Date: Fri, 14 Feb 2014 21:56:56 +0100
Subject: [Bitcoin-development] working with the blockchain: transaction
 fees & sum(inputs) != sum(outputs) (newbie questions)
In-Reply-To: <52FE4782.6020001@monetize.io>
References: <CAPc1t_8kp7dRpjPkK0K6K+mBz4dF9tsVx9n55eaW30FeFvU1EA@mail.gmail.com>
	<52FE4782.6020001@monetize.io>
Message-ID: <CAPc1t_8DPeEZnHHhxNNYs9YXP+C78kW-u_hgxahAAGQVLDzpFw@mail.gmail.com>

Thanks Wladimir, perfect info!

Mark, sounds good. But most likely this DB is keeping this information only
for the current state of the blockchain and what I need really is to be
able to get the unspent outputs (and calculate the balance for all
addresses) for any particular block I happen to be interested in :)

- Denis

"Be the change you want to see in the world." (Mahatma Gandhi)


On Fri, Feb 14, 2014 at 5:42 PM, Mark Friedenbach <mark at monetize.io> wrote:

> On 02/14/2014 04:20 AM, Denis Andrejew wrote:
> > What I'm trying to do is read the blockchain in order to find all
> > unspent outputs. I'm using bitcoind via rpc as my source of
> > information about the blockchain.
>
> By the way, bitcoind keeps this information in a special LevelDB
> database in the chainstate directory. It would be rather simple to
> iterate over the database for the list of al unspent outputs.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140214/0e563299/attachment.html>

From mark at monetize.io  Fri Feb 14 23:01:41 2014
From: mark at monetize.io (Mark Friedenbach)
Date: Fri, 14 Feb 2014 15:01:41 -0800
Subject: [Bitcoin-development] working with the blockchain: transaction
 fees & sum(inputs) != sum(outputs) (newbie questions)
In-Reply-To: <CAPc1t_8DPeEZnHHhxNNYs9YXP+C78kW-u_hgxahAAGQVLDzpFw@mail.gmail.com>
References: <CAPc1t_8kp7dRpjPkK0K6K+mBz4dF9tsVx9n55eaW30FeFvU1EA@mail.gmail.com>
	<52FE4782.6020001@monetize.io>
	<CAPc1t_8DPeEZnHHhxNNYs9YXP+C78kW-u_hgxahAAGQVLDzpFw@mail.gmail.com>
Message-ID: <52FEA055.7010408@monetize.io>

Still straightforward: get a list of transaction hashes for the block
from bitcoind, then query these transactions from the UTXO changestate
database.

On 02/14/2014 12:56 PM, Denis Andrejew wrote:
> Thanks Wladimir, perfect info!
> 
> Mark, sounds good. But most likely this DB is keeping this
> information only for the current state of the blockchain and what I
> need really is to be able to get the unspent outputs (and calculate
> the balance for all addresses) for any particular block I happen to
> be interested in :)
> 
> - Denis
> 
> "Be the change you want to see in the world." (Mahatma Gandhi)
> 
> 
> On Fri, Feb 14, 2014 at 5:42 PM, Mark Friedenbach
> <mark at monetize.io <mailto:mark at monetize.io>> wrote:
> 
> On 02/14/2014 04:20 AM, Denis Andrejew wrote:
>> What I'm trying to do is read the blockchain in order to find
>> all unspent outputs. I'm using bitcoind via rpc as my source of 
>> information about the blockchain.
> 
> By the way, bitcoind keeps this information in a special LevelDB 
> database in the chainstate directory. It would be rather simple to 
> iterate over the database for the list of al unspent outputs.
> 
> 



From jtimon at monetize.io  Sat Feb 15 14:43:08 2014
From: jtimon at monetize.io (=?ISO-8859-1?Q?Jorge_Tim=F3n?=)
Date: Sat, 15 Feb 2014 15:43:08 +0100
Subject: [Bitcoin-development] Embedded consensus system upgrade
	procedures
In-Reply-To: <20140209190249.GG3180@nl.grid.coop>
References: <20140209171214.GA20126@savin> <201402091725.42306.luke@dashjr.org>
	<20140209181132.GF3180@nl.grid.coop> <20140209183831.GA8878@savin>
	<20140209190249.GG3180@nl.grid.coop>
Message-ID: <CAC1+kJNnK0qAT+gY98GKgcXkUjVeZUL3Uj3LRHq8a+JPCxZCtw@mail.gmail.com>

Not a lawyer, but I don't see what would prevent me from writing contracts like:

"I owe the holder of this contract 10 usd" (IOU)

"I owe the holder of this contract 10 usd in beer" (voucher)

"I owe the holder of this p2p asset 10 usd in beer" (p2p voucher)

Of course, there must be a legal contract outside of the chain for
this contracts to be enforceable.
Some p2p assets will have them and other's won't. Say Alice pays the
dinner (20 usd) and her friend Bob pays her half of the price in p2p
usd not legally enforceable IOUs issued by him (10 bob:USD).
That's not legally enforceable, so what?
If Bob doesn't pay back Alice would lose 10 usd and would not accept
bob's IOUs anymore, much like it would had happen with a verbal IOU.
The difference is that Alice can sell those bob:USD to other people
who trust Bob.

Different p2p assets have different legal needs.

In any case, I think Peter summarized it very well:

"[...]no amount of code can, **by itself**, make data
represent a physical or legal entity. Only consensus and/or authorities
in the "real world" can do that."


On 2/9/14, Troy Benjegerdes <hozer at hozed.org> wrote:
>> > The only 'assertion' of central authority here is people who download
>> > and
>> > run the code and submit to whatever the code asserts they are supposed
>> > to do.
>> >
>> > At least with the 'central authority' of the big-business bitcoin
>> > developer
>> > cabal I can read the code before I submit to it's central authority,
>> > and
>> > this is a significant improvement over amgibuous legislation or
>> > proprietary
>> > high-frequency trading algorithms.
>>
>> Standard Disclaimer: Digital asset transfer systems are fundementally
>> fancy accounting systems; no amount of code can, by itself, make data
>> represent a physical or legal entity. Only consensus and/or authorities
>> in the "real world" can do that. Crypto-currencies are only a partial
>> exception to that rule, and only because a scarce asset that can be
>> transferred digitally appears to have potential to be broadly useful.
>
> How do I document in the embedded consensus system what the ruling in
> a small-claims court about the ownership of a contested asset was?
>
> Good accounting systems (such as mercurial, and proper double-entry
> financial accounting tools) allow reverting a bad commit, or bad data
> entry, while maintaining records of the history. Not as good accounting
> systems (like git) allow you to re-write history. What's the equivalent
> user interface, process, and wire protocol for reversing a fraudulent
> transaction while maintaining a full audit trail?
>
> Courts can't legislate our code, and we can't expect them to download
> and trust our 'distributed de-centralized' digital asset tracking system
> that will be downloaded from a single centralized developer website
> unless we meet them at least halfway, and probably need to propose model
> municipal and county ordinances that go along with our code releases.
>
>> Those considering investing in or otherwise devoting resources to the
>> creation of digital asset transfer systems should be warned that their
>> value in general remains unproven and losing some or all of your
>> investment is very possible, even probable. I myself have doubts that
>> these systems serve real-world business needs, but the only way to find
>> out is to build them and see.
>
> I would agree 100% that we need to build them, test the code, use them,
> and then *try them in court*, and make sure we can explain in very simple
> plain language what an 'embedded consensus system' is to the distributed
> de-centralized local court systems.
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121051231&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>


-- 
Jorge Tim?n

http://freico.in/



From melvincarvalho at gmail.com  Sun Feb 16 13:45:23 2014
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Sun, 16 Feb 2014 14:45:23 +0100
Subject: [Bitcoin-development] Testnet block explorer
In-Reply-To: <CANEZrP398MCW6CdQLo78DtQ7HWY4f1TMkj32Fm2dTrKcUT09cg@mail.gmail.com>
References: <CANEZrP398MCW6CdQLo78DtQ7HWY4f1TMkj32Fm2dTrKcUT09cg@mail.gmail.com>
Message-ID: <CAKaEYhJkUcntKY=mVDh6y1f5FeOiuzqQ9sFRzXpyFOxuXAw+jw@mail.gmail.com>

On 27 December 2013 19:05, Mike Hearn <mike at plan99.net> wrote:

> For a long time the only block explorer for testnet has been the original
> blockexplorer.com, which is unfortunately often broken / behind / slow
> and not really maintained any more.
>
> There is now a new one, here:
>
> https://www.biteasy.com/testnet/blocks
>
> There's also a REST/JSON API for it.
>
> Please note one curiosity of this block explorer is that the coinbase tx
> doesn't necessarily come first in the listing (it's sorted by "time
> received", see).
>
> Other interesting thing to note: this site is built using bitcoinj. The
> author can be contacted on IRC sometimes using the nick damethos.
>

Some more information on testnet3 explorers ...

Here is a free software testnet explorer based on javascript/node

http://test.bitcore.io/

I've been working on a testnet explorer, but I think I will fork this and
add semantic web style markup attributes to the HTML.

Also a message I got from blockr.io "yes testnet will be added. I cannot
give you an estimate on when, but it'll probably happen in couple of weeks
(hopefully sooner)."


>
>
> ------------------------------------------------------------------------------
> Rapidly troubleshoot problems before they affect your business. Most IT
> organizations don't have a clear picture of how application performance
> affects their revenue. With AppDynamics, you get 100% visibility into your
> Java,.NET, & PHP application. Start your 15-day FREE TRIAL of AppDynamics
> Pro!
> http://pubads.g.doubleclick.net/gampad/clk?id=84349831&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140216/dd6344fe/attachment.html>

From mat at matiu.com.ar  Sun Feb 16 14:49:40 2014
From: mat at matiu.com.ar (Matias Alejo Garcia)
Date: Sun, 16 Feb 2014 11:49:40 -0300
Subject: [Bitcoin-development] Testnet block explorer
In-Reply-To: <CAKaEYhJkUcntKY=mVDh6y1f5FeOiuzqQ9sFRzXpyFOxuXAw+jw@mail.gmail.com>
References: <CANEZrP398MCW6CdQLo78DtQ7HWY4f1TMkj32Fm2dTrKcUT09cg@mail.gmail.com>
	<CAKaEYhJkUcntKY=mVDh6y1f5FeOiuzqQ9sFRzXpyFOxuXAw+jw@mail.gmail.com>
Message-ID: <CA+vKqYftNvtgGrawNNRZw7MXBjJoBZRnvhEShuwNo0guDv9kMA@mail.gmail.com>

Hi Melvin / Mike,

Ive been working on Bitcore and Insight next to a BitPay team for the last
few weeks. We are happy to receive patches, suggestions and bug reports
from you guys at:

https://github.com/bitpay/insight

Insight also provides some blockchain query capabilities at its
REST/Websockets API described on the Readme document.

Please note that Insight is meant as a software package that you can
download, install and use next to a trusted bitcoind instance.
live.bitcore.io / test.bitcore.io are just demo installations.

best,
mat?as




On Sun, Feb 16, 2014 at 10:45 AM, Melvin Carvalho
<melvincarvalho at gmail.com>wrote:

>
>
>
> On 27 December 2013 19:05, Mike Hearn <mike at plan99.net> wrote:
>
>> For a long time the only block explorer for testnet has been the original
>> blockexplorer.com, which is unfortunately often broken / behind / slow
>> and not really maintained any more.
>>
>> There is now a new one, here:
>>
>> https://www.biteasy.com/testnet/blocks
>>
>> There's also a REST/JSON API for it.
>>
>> Please note one curiosity of this block explorer is that the coinbase tx
>> doesn't necessarily come first in the listing (it's sorted by "time
>> received", see).
>>
>> Other interesting thing to note: this site is built using bitcoinj. The
>> author can be contacted on IRC sometimes using the nick damethos.
>>
>
> Some more information on testnet3 explorers ...
>
> Here is a free software testnet explorer based on javascript/node
>
> http://test.bitcore.io/
>
> I've been working on a testnet explorer, but I think I will fork this and
> add semantic web style markup attributes to the HTML.
>
> Also a message I got from blockr.io "yes testnet will be added. I cannot
> give you an estimate on when, but it'll probably happen in couple of weeks
> (hopefully sooner)."
>
>
>>
>>
>> ------------------------------------------------------------------------------
>> Rapidly troubleshoot problems before they affect your business. Most IT
>> organizations don't have a clear picture of how application performance
>> affects their revenue. With AppDynamics, you get 100% visibility into your
>> Java,.NET, & PHP application. Start your 15-day FREE TRIAL of AppDynamics
>> Pro!
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=84349831&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
>
> ------------------------------------------------------------------------------
> Android apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
Mat?as Alejo Garcia
CinemaKi.com
Skype/Twitter: @ematiu
Roads? Where we're going, we don't need roads!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140216/20ac0eef/attachment.html>

From hozer at hozed.org  Mon Feb 17 05:47:51 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Sun, 16 Feb 2014 23:47:51 -0600
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140214052159.GF31437@savin>
References: <20140209180458.GB20126@savin> <20140209204434.GA11488@savin>
	<20140210193247.GC17359@savin> <20140211175919.GV3180@nl.grid.coop>
	<20140214052159.GF31437@savin>
Message-ID: <20140217054751.GY3180@nl.grid.coop>

On Fri, Feb 14, 2014 at 12:21:59AM -0500, Peter Todd wrote:
> On Tue, Feb 11, 2014 at 11:59:19AM -0600, Troy Benjegerdes wrote:
> > Is there any code that does this? I would like to develop a multicoin-qt
> > wallet that runs on two blockchains from one binary, and allows trading
> > using this mechanism between the two chains.
> 
> Cross-chain trading is a different thing entirely; it doesn't allow for
> the clever 2-party-trade trick. (as far as I know)

Is there a simple way to do cross-chain trades that doesn't need a third 
chain to somehow facilitate things?



From da.colonel at gmail.com  Tue Feb 18 00:01:40 2014
From: da.colonel at gmail.com (Denis Andrejew)
Date: Tue, 18 Feb 2014 01:01:40 +0100
Subject: [Bitcoin-development] bitcoind json API (gettx/raw) (newbie
	questions #2)
Message-ID: <CAPc1t_-GS7DjvdqwPMg6cC68buSqO_rN5spfmkacw7gPxMqUeg@mail.gmail.com>

Hey everybody,

here's another question that I have:

I'd like a small bit of clarification about the gettx / getrawtransaction
(decoded) api call. I understand that I can find the address that a
transaction output is directed at / available to for future use sits in the
vout array in the scriptPubKey.addresses array. I'm a little uncertain as
to why that piece of information would be typed as an array when all it
ever seems to contain is one (not more, not less) address(es).

Are there any cases of transactions right now that don't contain exactly 1
item in that array, i.e. more or less than a single address (per single
vout element, not per tx)? Or is the thinking behind this array to somehow
make the data structure more extensible for potential future use? But then
I can't think of any use cases where it appears to make any sense to put
more than 1 address there...

Or am I even asking the wrong questions? For spending those coins, i.e.
using them in a future transaction it's all about owning the public/private
key that is contained in the vout script, right? So the address doesn't
really matter and it could be 2 or more (or none at all?) addresses in
there, and what matters is just that the next guy has the key to spending
those coins... ?

Once again I'm coming to these questions from a project where I'm trying to
calculate unspent outputs and from that balances for all accounts and I'm
not sure yet what other special cases there might be in the blockchain that
I need to be aware of and handle properly in order to (re-)produce accurate
data!

Thanks for your help, much appreciated!
- Denis

"Be the change you want to see in the world." (Mahatma Gandhi)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/b71995c6/attachment.html>

From odinn.cyberguerrilla at riseup.net  Tue Feb 18 08:17:15 2014
From: odinn.cyberguerrilla at riseup.net (Odinn Cyberguerrilla)
Date: Tue, 18 Feb 2014 00:17:15 -0800
Subject: [Bitcoin-development] bitcoind json API (gettx/raw) (newbie
 questions #2)
In-Reply-To: <CAPc1t_-GS7DjvdqwPMg6cC68buSqO_rN5spfmkacw7gPxMqUeg@mail.gmail.com>
References: <CAPc1t_-GS7DjvdqwPMg6cC68buSqO_rN5spfmkacw7gPxMqUeg@mail.gmail.com>
Message-ID: <85767ed60882da6fe3675cba9733777e.squirrel@fruiteater.riseup.net>

> Hey everybody,
>
> here's another question that I have:
>
> I'd like a small bit of clarification about the gettx / getrawtransaction
> (decoded) api call. I understand that I can find the address that a
> transaction output is directed at / available to for future use sits in
> the
> vout array in the scriptPubKey.addresses array. I'm a little uncertain as
> to why that piece of information would be typed as an array when all it
> ever seems to contain is one (not more, not less) address(es).
>
> Are there any cases of transactions right now that don't contain exactly 1
> item in that array, i.e. more or less than a single address (per single
> vout element, not per tx)? Or is the thinking behind this array to somehow
> make the data structure more extensible for potential future use? But then
> I can't think of any use cases where it appears to make any sense to put
> more than 1 address there...

This might be such a use case, just maybe --> https://coinb.in/multisig
Also I recommend checking out http://abis.io
These may be things you are thinking about in the context of this.

> Or am I even asking the wrong questions? For spending those coins, i.e.
> using them in a future transaction it's all about owning the
> public/private
> key that is contained in the vout script, right? So the address doesn't
> really matter and it could be 2 or more (or none at all?) addresses in
> there, and what matters is just that the next guy has the key to spending
> those coins... ?
>
> Once again I'm coming to these questions from a project where I'm trying
> to
> calculate unspent outputs and from that balances for all accounts and I'm
> not sure yet what other special cases there might be in the blockchain
> that
> I need to be aware of and handle properly in order to (re-)produce
> accurate
> data!
>
> Thanks for your help, much appreciated!
> - Denis
>
> "Be the change you want to see in the world." (Mahatma Gandhi)
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk_______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>





From andreas at schildbach.de  Tue Feb 18 17:31:04 2014
From: andreas at schildbach.de (Andreas Schildbach)
Date: Tue, 18 Feb 2014 18:31:04 +0100
Subject: [Bitcoin-development] BIP70 proposed changes
Message-ID: <le05ca$qn5$1@ger.gmane.org>

I'm starting a thread on proposed changes on BIP70 based on my
experience in implementing the payment protocol in Bitcoin Wallet:

- certificate chain in pki_data: I think it should be required that is
most contain the first certificate PLUS all intermediate certificates
(if any), but NOT the root certificate. Reason: We want to be able to
verify offline.

- definition of timezone: Its not clear if times (e.g. expires) are in
UTC or local. I suggest to require UTC. If if we can't agree on this,
there should be a sentence about timezones in the spec.

(probably more to be added...)




From ryan at bitpay.com  Tue Feb 18 19:14:24 2014
From: ryan at bitpay.com (Ryan X. Charles)
Date: Tue, 18 Feb 2014 14:14:24 -0500
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <le05ca$qn5$1@ger.gmane.org>
References: <le05ca$qn5$1@ger.gmane.org>
Message-ID: <5303B110.70603@bitpay.com>

Here are my complementary thoughts after working on the payment protocol
on the merchant side at BitPay.

The most important missing piece of the payment protocol is that is has
no concept of the status of a payment after it has been made. What if
the payment is too little? Too much? What if it is never confirmed? What
if it is confirmed, but very late? These are regular occurrences at
BitPay (although hopefully they will be a lot fewer after the payment
protocol is widely adopted).

One way to handle this would be to add another type of message, say with
content-type bitcoin-paymentstatus, that can return the merchant's view
of the status of the transaction(s). Are the transactions under or
overpaid? Are they confirmed? How many confirmations? Is the payment
"accepted" even if the transactions aren't confirmed?

I think it would be great if wallets could check the status of a
payment, and if anything goes wrong, request a refund, all within the
payment protocol.

The payment protocol is also the perfect opportunity to implement merge
avoidance to increase customer and merchant privacy. The merchant can
simply deliver multiple outputs in the payment details, say 10 or so,
and the customer can spend multiple outputs to those outputs in separate
transactions. It would be great if BitPay could work with wallet authors
to make merge avoidance a reality in the near-term.

Merge avoidance would increase the need to have a bitcoin-paymentstatus
message since it's possible that some, but not all, of the transactions
would confirm, and so knowing the status of payment would be a complex
question that should be handled automatically by the software.

On an unrelated note, X.509 is a terrible standard that should be
abandoned as quickly as possible. BitPay is working on a new standard
based on bitcoin-like addresses for authentication. It would be great if
we could work with the community to establish a complete, decentralized
authentication protocol. The sooner we can evolve beyond X.509 the better.

One more thing. The new bitcoin URI in BIP 72 is extremely long and
makes for very dense QR codes. BitPay has proposed a new standard, BIP
73, for shorter URIs and less dense QR codes. We hope wallet authors
will implement this better standard.

My response to Andreas' thoughts:

On 2/18/14, 12:31 PM, Andreas Schildbach wrote:
> I'm starting a thread on proposed changes on BIP70 based on my
> experience in implementing the payment protocol in Bitcoin Wallet:
> 
> - certificate chain in pki_data: I think it should be required that is
> most contain the first certificate PLUS all intermediate certificates
> (if any), but NOT the root certificate. Reason: We want to be able to
> verify offline.

So long as the root certificate remains an optional addition, this seems
like a good idea. My experience with tls in node is that it is required
for the root certificate to be present, so we don't want to require that
the root certificate be absent, since that would make it painful to make
code that is interoperable between the two. IIRC setting
rejectUnauthorized=true will reject connections that do not deliver the
root certificate, so allowing the root certificate to be present would
be compatible with this and presumably other tls code.

Would be great if someone with more experience with tls weighed in on
whether the root certificate can/should be present.

> 
> - definition of timezone: Its not clear if times (e.g. expires) are in
> UTC or local. I suggest to require UTC. If if we can't agree on this,
> there should be a sentence about timezones in the spec.

The world needs to abandon timezones altogether for everything and only
use UTC. So, agreed. Require UTC.

> 
> (probably more to be added...)
> 
> 
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 

-- 
Ryan X. Charles
Software Engineer, BitPay
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0xA11B4DDE.asc
Type: application/pgp-keys
Size: 5627 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/00805bee/attachment.bin>

From gavinandresen at gmail.com  Tue Feb 18 20:15:45 2014
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Tue, 18 Feb 2014 15:15:45 -0500
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <5303B110.70603@bitpay.com>
References: <le05ca$qn5$1@ger.gmane.org>
	<5303B110.70603@bitpay.com>
Message-ID: <CABsx9T2Sz+_OubqUpA1LsZxn5sUCN6A2M-BKjrW-sdzh9NK4fg@mail.gmail.com>

Fantastic feedback, thanks Ryan and Andreas!

Please don't let me being busy get in the way of progress, so submit pull
requests to the BIP (the UTC timezone issue seems obvious and
non-controversial) or write up draft specs for extensions.

RE: wallets checking the status of payment:  excellent idea. A URL that can
be polled to check payment processing status sounds like the right thing to
do.

That feels very similar to the proposal for recurring payments; I think
they would be separate mechanisms, but maybe their specs could share some
of the same concepts / field names....


On Tue, Feb 18, 2014 at 2:14 PM, Ryan X. Charles <ryan at bitpay.com> wrote:

> Here are my complementary thoughts after working on the payment protocol
> on the merchant side at BitPay.
>
> The most important missing piece of the payment protocol is that is has
> no concept of the status of a payment after it has been made. What if
> the payment is too little? Too much? What if it is never confirmed? What
> if it is confirmed, but very late? These are regular occurrences at
> BitPay (although hopefully they will be a lot fewer after the payment
> protocol is widely adopted).
>
> One way to handle this would be to add another type of message, say with
> content-type bitcoin-paymentstatus, that can return the merchant's view
> of the status of the transaction(s). Are the transactions under or
> overpaid? Are they confirmed? How many confirmations? Is the payment
> "accepted" even if the transactions aren't confirmed?
>
> I think it would be great if wallets could check the status of a
> payment, and if anything goes wrong, request a refund, all within the
> payment protocol.
>
> The payment protocol is also the perfect opportunity to implement merge
> avoidance to increase customer and merchant privacy. The merchant can
> simply deliver multiple outputs in the payment details, say 10 or so,
> and the customer can spend multiple outputs to those outputs in separate
> transactions. It would be great if BitPay could work with wallet authors
> to make merge avoidance a reality in the near-term.
>
> Merge avoidance would increase the need to have a bitcoin-paymentstatus
> message since it's possible that some, but not all, of the transactions
> would confirm, and so knowing the status of payment would be a complex
> question that should be handled automatically by the software.
>
> On an unrelated note, X.509 is a terrible standard that should be
> abandoned as quickly as possible. BitPay is working on a new standard
> based on bitcoin-like addresses for authentication. It would be great if
> we could work with the community to establish a complete, decentralized
> authentication protocol. The sooner we can evolve beyond X.509 the better.
>
> One more thing. The new bitcoin URI in BIP 72 is extremely long and
> makes for very dense QR codes. BitPay has proposed a new standard, BIP
> 73, for shorter URIs and less dense QR codes. We hope wallet authors
> will implement this better standard.
>
> My response to Andreas' thoughts:
>
> On 2/18/14, 12:31 PM, Andreas Schildbach wrote:
> > I'm starting a thread on proposed changes on BIP70 based on my
> > experience in implementing the payment protocol in Bitcoin Wallet:
> >
> > - certificate chain in pki_data: I think it should be required that is
> > most contain the first certificate PLUS all intermediate certificates
> > (if any), but NOT the root certificate. Reason: We want to be able to
> > verify offline.
>
> So long as the root certificate remains an optional addition, this seems
> like a good idea. My experience with tls in node is that it is required
> for the root certificate to be present, so we don't want to require that
> the root certificate be absent, since that would make it painful to make
> code that is interoperable between the two. IIRC setting
> rejectUnauthorized=true will reject connections that do not deliver the
> root certificate, so allowing the root certificate to be present would
> be compatible with this and presumably other tls code.
>
> Would be great if someone with more experience with tls weighed in on
> whether the root certificate can/should be present.
>
> >
> > - definition of timezone: Its not clear if times (e.g. expires) are in
> > UTC or local. I suggest to require UTC. If if we can't agree on this,
> > there should be a sentence about timezones in the spec.
>
> The world needs to abandon timezones altogether for everything and only
> use UTC. So, agreed. Require UTC.
>
> >
> > (probably more to be added...)
> >
> >
> >
> ------------------------------------------------------------------------------
> > Managing the Performance of Cloud-Based Applications
> > Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> > Read the Whitepaper.
> >
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
>
> --
> Ryan X. Charles
> Software Engineer, BitPay
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/560522b2/attachment.html>

From andreas at schildbach.de  Tue Feb 18 21:40:13 2014
From: andreas at schildbach.de (Andreas Schildbach)
Date: Tue, 18 Feb 2014 22:40:13 +0100
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <5303B110.70603@bitpay.com>
References: <le05ca$qn5$1@ger.gmane.org> <5303B110.70603@bitpay.com>
Message-ID: <le0jvf$i7d$1@ger.gmane.org>

On 02/18/2014 08:14 PM, Ryan X. Charles wrote:

> The most important missing piece of the payment protocol is that is has
> no concept of the status of a payment after it has been made. What if
> the payment is too little? Too much? What if it is never confirmed? What
> if it is confirmed, but very late? These are regular occurrences at
> BitPay (although hopefully they will be a lot fewer after the payment
> protocol is widely adopted).

I would like to understand why this happens at BitPay? If this is
because people use cut and paste to copy the address and then type the
amount by hand... well this kind of usage will go away.

A program (like an app) should be capable of paying the exact amount. If
not, that's a bug of the app not the protocol.

> On an unrelated note, X.509 is a terrible standard that should be
> abandoned as quickly as possible.

+1

> BitPay is working on a new standard
> based on bitcoin-like addresses for authentication. It would be great if
> we could work with the community to establish a complete, decentralized
> authentication protocol.

Sounds interesting, let us know as soon as you have anything.

>> - certificate chain in pki_data: I think it should be required that is
>> most contain the first certificate PLUS all intermediate certificates
>> (if any), but NOT the root certificate. Reason: We want to be able to
>> verify offline.
>
> So long as the root certificate remains an optional addition, this seems
> like a good idea.

In which case does it make sense to duplicate the root cert? I'm asking
because it should already be present in the trusted root store, right?

Maybe can you tell about which measures you needed to take to get X.509
working? To me it felt there very several problems.

> My experience with tls in node is that it is required

TLS? We're not using that for pki_data -- its just a byte array.

>> - definition of timezone: Its not clear if times (e.g. expires) are in
>> UTC or local. I suggest to require UTC. If if we can't agree on this,
>> there should be a sentence about timezones in the spec.
>
> The world needs to abandon timezones altogether for everything and only
> use UTC. So, agreed. Require UTC.

--> https://github.com/bitcoin/bips/pull/20





From pete at petertodd.org  Tue Feb 18 21:47:22 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 18 Feb 2014 16:47:22 -0500
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <5303B110.70603@bitpay.com>
References: <le05ca$qn5$1@ger.gmane.org>
 <5303B110.70603@bitpay.com>
Message-ID: <20140218214721.GA25356@savin>

On Tue, Feb 18, 2014 at 02:14:24PM -0500, Ryan X. Charles wrote:
> The payment protocol is also the perfect opportunity to implement merge
> avoidance to increase customer and merchant privacy. The merchant can
> simply deliver multiple outputs in the payment details, say 10 or so,
> and the customer can spend multiple outputs to those outputs in separate
> transactions. It would be great if BitPay could work with wallet authors
> to make merge avoidance a reality in the near-term.
> 
> Merge avoidance would increase the need to have a bitcoin-paymentstatus
> message since it's possible that some, but not all, of the transactions
> would confirm, and so knowing the status of payment would be a complex
> question that should be handled automatically by the software.

Note that merge-avoidance implemented in conjunction CoinJoin doesn't
have this problem - the CoinJoin'd transaction either does or doesn't
confirm. Meanwhile being able to avoid merges, or more precisely, being
able to be flexible with them, makes achiving good value-privacy much
easier.

Secondly merge-flexibility also makes cut-thru payments possible. For
example BitPay can direct customers paying for goods to pay to addresses
controlled by merchants and other parties who are owed money by BitPay.
This skips a step, saving on transction fees as well as increasing
privacy. Notably in this case the only parties that have to deal with
accounting complexity are BitPay and the merchants - consumers' wallet
software needs no changes beyond generic payment protocol support, and
notably you can even use this technique without the payment protocol.

See my post "DarkWallet Best Practices" for more info:

http://www.mail-archive.com/bitcoin-development at lists.sourceforge.net/msg03508.html

> On an unrelated note, X.509 is a terrible standard that should be
> abandoned as quickly as possible. BitPay is working on a new standard
> based on bitcoin-like addresses for authentication. It would be great if
> we could work with the community to establish a complete, decentralized
> authentication protocol. The sooner we can evolve beyond X.509 the better.

What specifically do you dislike about X.509? The technical standard or
the infrastructure around it? (IE the centralized authorities)

-- 
'peter'[:-1]@petertodd.org
000000000000000051ad2df596f45df71320fb44b3c5f1b50231a591ffeb1d24
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/debb3f9f/attachment.sig>

From rderber at gmail.com  Tue Feb 18 22:02:34 2014
From: rderber at gmail.com (Derber)
Date: Tue, 18 Feb 2014 15:02:34 -0700
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <5303B110.70603@bitpay.com>
References: <le05ca$qn5$1@ger.gmane.org>
	<5303B110.70603@bitpay.com>
Message-ID: <CAKwc68wQFtuowgCw3-B5WSAPocdhzv62oS=wM1wfW7Ta-W6Jcg@mail.gmail.com>

Any possibility of a UNIX UTC timestamp field in the customer payment
message?

For many transactions, the exact time of payment is when it is 'made' by
the customer and not when 'requested' by the retailer or later mined. The
blockchain time is an aggregate for the block and can differ significantly
from transaction time so its value is limited.

Small slices of time can greatly impact the transaction value.  If we are
ultimately taxed as a currency, an exact time will for the transaction will
impact US GAAP accounting and the transaction's tax accounting. A time
field may also support 'first come first served' retailer programs and time
sensitive promotions.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140218/ed97e9f2/attachment.html>

From bitcoin at bpj-code.co.za  Tue Feb 18 23:41:36 2014
From: bitcoin at bpj-code.co.za (Bernd Jendrissek)
Date: Wed, 19 Feb 2014 01:41:36 +0200
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <20140218214721.GA25356@savin>
References: <le05ca$qn5$1@ger.gmane.org> <5303B110.70603@bitpay.com>
	<20140218214721.GA25356@savin>
Message-ID: <CAF7PVPq+g98J-Q8Mssp5ap9cfrhPmwh91E8qn4gSEiHPApgx5g@mail.gmail.com>

[Ick, resending to list due to From: snafu]

On Tue, Feb 18, 2014 at 11:47 PM, Peter Todd <pete at petertodd.org> wrote:
> What specifically do you dislike about X.509? The technical standard or
> the infrastructure around it? (IE the centralized authorities)

I'm not the one who was complaining, but what I dislike is that a
certificate can have only one issuer. Cross-signing doesn't address my
dislike: it's different enough from being a certificate's single
issuer that it leaves too much power in the CAs' hands, IMHO.

It isn't so much the centralization per se that I object to, but the
way that the technical standard encourages concentration in the
infrastructure. See
http://lair.fifthhorseman.net/~dkg/tls-centralization/#Why_does_the_architecture_encourage_concentration%3F

I've been (slowly) working on a patch to allow pki_data to contain
more than just the single certificate chain that the
single-issuer-only format insists on, but I'm making as many steps
back as forward, being unsure of the right way to do it. Implementing
an OpenPGP-based pki_type would probably be better, but hacking x509+*
seems like a lower-hanging fruit.



From bitcoin at bpj-code.co.za  Tue Feb 18 23:41:36 2014
From: bitcoin at bpj-code.co.za (Bernd Jendrissek)
Date: Wed, 19 Feb 2014 01:41:36 +0200
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <20140218214721.GA25356@savin>
References: <le05ca$qn5$1@ger.gmane.org> <5303B110.70603@bitpay.com>
	<20140218214721.GA25356@savin>
Message-ID: <CAF7PVPq+g98J-Q8Mssp5ap9cfrhPmwh91E8qn4gSEiHPApgx5g@mail.gmail.com>

[Ick, resending to list due to From: snafu(s)]

On Tue, Feb 18, 2014 at 11:47 PM, Peter Todd <pete at petertodd.org> wrote:
> What specifically do you dislike about X.509? The technical standard or
> the infrastructure around it? (IE the centralized authorities)

I'm not the one who was complaining, but what I dislike is that a
certificate can have only one issuer. Cross-signing doesn't address my
dislike: it's different enough from being a certificate's single
issuer that it leaves too much power in the CAs' hands, IMHO.

It isn't so much the centralization per se that I object to, but the
way that the technical standard encourages concentration in the
infrastructure. See
http://lair.fifthhorseman.net/~dkg/tls-centralization/#Why_does_the_architecture_encourage_concentration%3F

I've been (slowly) working on a patch to allow pki_data to contain
more than just the single certificate chain that the
single-issuer-only format insists on, but I'm making as many steps
back as forward, being unsure of the right way to do it. Implementing
an OpenPGP-based pki_type would probably be better, but hacking x509+*
seems like a lower-hanging fruit.



From jgarzik at bitpay.com  Wed Feb 19 14:10:49 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 19 Feb 2014 09:10:49 -0500
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <le0jvf$i7d$1@ger.gmane.org>
References: <le05ca$qn5$1@ger.gmane.org> <5303B110.70603@bitpay.com>
	<le0jvf$i7d$1@ger.gmane.org>
Message-ID: <CAJHLa0MGaxJTGPR-bduW36-4Msb348FANqFmw67jqFxq1CLwbw@mail.gmail.com>

On Tue, Feb 18, 2014 at 4:40 PM, Andreas Schildbach
<andreas at schildbach.de> wrote:
> On 02/18/2014 08:14 PM, Ryan X. Charles wrote:
>> BitPay is working on a new standard
>> based on bitcoin-like addresses for authentication. It would be great if
>> we could work with the community to establish a complete, decentralized
>> authentication protocol.
>
> Sounds interesting, let us know as soon as you have anything.

SINs.  See https://en.bitcoin.it/wiki/Identity_protocol_v1

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From gronager at mac.com  Wed Feb 19 14:11:51 2014
From: gronager at mac.com (Michael Gronager)
Date: Wed, 19 Feb 2014 15:11:51 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
 malleability
In-Reply-To: <CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
Message-ID: <EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>

Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:

1. the next bitcoin version "prettify" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash. 

2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.

To non-standard conforming clients this "prettify" change of hash would be seen as a constant malleability attack, but given the "prettify" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.

There is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:
* Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.


On Feb 13, 2014, at 1:47 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> On Wed, Feb 12, 2014 at 4:39 PM, Alex Morcos <morcos at gmail.com> wrote:
>> I apologize if this has been discussed many times before.
> 
> It has been, but there are probably many people like you who have not
> bothered researching who may also be curious.
> 
>> As a long term solution to malleable transactions, wouldn't it be possible
>> to modify the signatures to be of the entire transaction.  Why do you have
>> to zero out the inputs?  I can see that this would be a hard fork, and maybe
>> it would be somewhat tricky to extract signatures first (since you can sign
>> everything except the signatures), but it would seem to me that this is an
>> important enough change to consider making.
> 
> Because doing so would be both unnecessary and ineffective.
> 
> Unnecessary because we can very likely eliminate malleability without
> changing what is signed. It will take time, but we have been
> incrementally moving towards that, e.g. v0.8 made many kinds of
> non-canonical encoding non-standard.
> 
> Ineffective? at least as you describe it? because the signatures
> _themselves_ are malleable.
> 
> ------------------------------------------------------------------------------
> Android apps run on BlackBerry 10
> Introducing the new BlackBerry 10.2.1 Runtime for Android apps.
> Now with support for Jelly Bean, Bluetooth, Mapview and more.
> Get your Android app in front of a whole new audience.  Start now.
> http://pubads.g.doubleclick.net/gampad/clk?id=124407151&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/95dc03a4/attachment.sig>

From pieter.wuille at gmail.com  Wed Feb 19 14:38:19 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 19 Feb 2014 15:38:19 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
Message-ID: <CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>

On Wed, Feb 19, 2014 at 3:11 PM, Michael Gronager <gronager at mac.com> wrote:
> Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:
>
> 1. the next bitcoin version "prettify" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash.

I consider actively mutating other's transactions worse than not
relaying them. If we want people to make their software deal with
malleability, either will work.

Regarding deterministic hash: that's impossible. Some signature hash
types are inherently (and intentionally) malleable. I don't think we
should pretend to want to change that. The purpose is making
non-malleability a choice the sender of a transaction can make.

Most of the rules actually are enforced by IsStandard already now.
Only #1 and #7 aren't. #1 affects the majority of all transactions, so
changing it right now would be painful. #7 only affects multisig.

> 2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.
>
> To non-standard conforming clients this "prettify" change of hash would be seen as a constant malleability attack, but given the "prettify" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.
>
> There is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:
> * Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.

The problem in making these rules into consensus rule (affecting
tx/block validity) is that some rules (in particular #3) may not be
wanted by everyone, as they effectively limit the possibilities of the
script language further. As it is ultimately only about protecting
senders who care about non-malleability, introducing a new transaction
version is a very neat way of accomplishing that. The new block
version number is only there to coordinate the rollout, and choosing
an automatic forking point.

-- 
Pieter



From mike at plan99.net  Wed Feb 19 16:44:00 2014
From: mike at plan99.net (Mike Hearn)
Date: Wed, 19 Feb 2014 16:44:00 +0000
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <CAJHLa0MGaxJTGPR-bduW36-4Msb348FANqFmw67jqFxq1CLwbw@mail.gmail.com>
References: <le05ca$qn5$1@ger.gmane.org> <5303B110.70603@bitpay.com>
	<le0jvf$i7d$1@ger.gmane.org>
	<CAJHLa0MGaxJTGPR-bduW36-4Msb348FANqFmw67jqFxq1CLwbw@mail.gmail.com>
Message-ID: <CANEZrP1QS1Z0_=-sUjK2H5CkrnuCUsCu5PZhggAvEbW4Y2Y_kA@mail.gmail.com>

Thanks for the feedback guys!

I would also like to understand the problems you've been having with
certificates in node.js. FYI the CA cert is *not* supposed to be included,
this matches what the code in Bitcoin Core and bitcoinj expects. It may be
that Bitcoin Core accepts a redundant CA cert being provided, but if so
that'd fall in the category of openssl being generous. If there are issues
here, it sounds like an issue with node and not the spec. I'm not even sure
why it would matter - certs are just byte arrays so if node can sign a hash
with a private key, the rest should be easy.

With regards to the PKI I'd appreciate it if we don't go around that circle
again. Please remember one of the primary goals of all of this is to show
to the user on their hardware wallet a meaningful name. Almost all
merchants on the Internet already went through the process of associating a
public key with their name, using X.509.

Whilst for now your payment requests will have to be signed as BitPay, this
isn't ideal for the longer term and I'd like to design a protocol extension
to allow merchants to delegate their signature authority to you. In this
way they would be able to sign a secondary key with their own ssl key as
part of the enrolment process, and after that you could sign payment
requests on their behalf. Kind of like a Bitcoin  specific subcert (and
there would be no reason to use X.509 format for that).

Re: feedback url. How is this different to a result code in PaymentAck
which already caused much debate? Surely we want a payment to either work
out boy work and for that decision to be made immediately? Your invoice
page switches to a completed state once you see a tx be broadcast so that's
the "done" state today even if there are caveats. I'd like to see a status
code added to PaymentAck so receivers can reject payments if they are bad
in some way.
 On 19 Feb 2014 19:41, "Jeff Garzik" <jgarzik at bitpay.com> wrote:

> On Tue, Feb 18, 2014 at 4:40 PM, Andreas Schildbach
> <andreas at schildbach.de> wrote:
> > On 02/18/2014 08:14 PM, Ryan X. Charles wrote:
> >> BitPay is working on a new standard
> >> based on bitcoin-like addresses for authentication. It would be great if
> >> we could work with the community to establish a complete, decentralized
> >> authentication protocol.
> >
> > Sounds interesting, let us know as soon as you have anything.
>
> SINs.  See https://en.bitcoin.it/wiki/Identity_protocol_v1
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/26590536/attachment.html>

From jeremy at taplink.co  Wed Feb 19 19:15:39 2014
From: jeremy at taplink.co (Jeremy Spilman)
Date: Wed, 19 Feb 2014 11:15:39 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
 malleability
In-Reply-To: <CAJfRnm5pVA+gd3t=bXO188S4uwtUvx5F8V_bO_YV+74Ev4Q9jg@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<20140210030048.GB31925@savin>
	<CAH2=CKzNGN7mpe1NLtsLRNSszSD2ZNwjoAsaH40EvGtA5ezDeQ@mail.gmail.com>
	<CALf2ePyDTZ_43uBfS9-5znhTyBR-5H10SpZ=N-z1DBacM_rDgA@mail.gmail.com>
	<CAJfRnm5pVA+gd3t=bXO188S4uwtUvx5F8V_bO_YV+74Ev4Q9jg@mail.gmail.com>
Message-ID: <op.xbjmgdcfyldrnw@laptop-air>


> Longer term it would be more ideal have a canonical identifier for the  
> transaction before it even gets to the chain to support these use cases,  
> even if >wallets are able to properly identify the status of it's  
> transactions.  
> -Allen
>
>

One possible work-around to get back trusted transaction chaining for  
payment channels and locked refunds from multi-sig would be to make the  
initial transaction include zero fee, and depend on child-pays-for-parent  
in order to get the first and follow-on transactions into a block. This of  
course only works for protocols where the parties don't need the initial  
funding transaction to actually hit the blockchain right away.

But this relies on two assumptions; 1) that miners won't include a  
zero-fee transaction in the blockchain, and 2) that miners actually  
implement child-pays-for-parent. It's definitely not the same security  
as-if you had immutable txid, but it's something to consider.

1) Mutants may cause wallet spam and difficulty calculating balance (and  
wallets will evolve to deal with it)
2) Mutants cause DoS because they can interfere with your own transaction  
chains, which for example makes batch off-line processing much more  
difficult
3) Mutants introduce a 3rd party attacker into any two-party protocol that  
relies on chains

There's a lot to digest in the 'v3' transaction/block proposal. It sounds  
like there may be some uncertainty over whether we can *prove* that v3  
transactions in v3 blocks would actually be guaranteed immutable with  
these changes?

If we cannot fully prove a Tx is immutable, then is it actually worth  
taking steps to make it seem immutable, or is that just a false sense of  
security in the cases where chained transactions were actually expected to  
be reliable? Under that thinking, maybe it's best to accept mutants as a  
fact of life, and only consider protocols and techniques that cannot be  
broken by mutants.

In what cases does reducing the sources of malleability, but not  
necessarily eliminating from a security proof perspective, actually help?  
Basically, if we don't know that we will succeed, isn't there really no  
point in trying?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/d695d83f/attachment.html>

From gronager at mac.com  Wed Feb 19 20:28:24 2014
From: gronager at mac.com (Michael Gronager)
Date: Wed, 19 Feb 2014 21:28:24 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
 malleability
In-Reply-To: <CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
Message-ID: <601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>

Twisting your words a bit I read:

* you want to support relay of transactions that can be changed on the fly, but you consider it wrong to modify them.
* #3 is already not forwarded, but you still find it relevant to support it.

Rational use cases of #3 will be pretty hard to find given the fact that they can be changed on the fly. We are down to inclusion in blocks by miners for special purposes - or did I miss out something?

I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.

/M


On Feb 19, 2014, at 3:38 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:

> On Wed, Feb 19, 2014 at 3:11 PM, Michael Gronager <gronager at mac.com> wrote:
>> Why introduce a new transaction version for this purpose ? Wouldn't it be more elegant to simply let:
>> 
>> 1. the next bitcoin version "prettify" all relayed transactions as deterministic transactions fulfilling the scheme 1-6 effectively blocking any malleability attack? If miners would upgrade then all transactions in blocks would have a deterministic hash.
> 
> I consider actively mutating other's transactions worse than not
> relaying them. If we want people to make their software deal with
> malleability, either will work.
> 
> Regarding deterministic hash: that's impossible. Some signature hash
> types are inherently (and intentionally) malleable. I don't think we
> should pretend to want to change that. The purpose is making
> non-malleability a choice the sender of a transaction can make.
> 
> Most of the rules actually are enforced by IsStandard already now.
> Only #1 and #7 aren't. #1 affects the majority of all transactions, so
> changing it right now would be painful. #7 only affects multisig.
> 
>> 2. In a version later one could block relay of non deterministic transactions, as well as the acceptance of blocks with non-confirming transactions.
>> 
>> To non-standard conforming clients this "prettify" change of hash would be seen as a constant malleability attack, but given the "prettify" code it is to fix any client into producing only conforming transactions, just by running the transaction through it before broadcast.
>> 
>> There is a possible fork risk in step 2. above - if a majority of miners still havn't upgraded to 1 when 2 is introduced. We could monitor % non conforming transaction in a block and only introduce 2. once that number is sufficiently small for a certain duration - criteria:
>> * Switch on forcing of unmalleable transactions in blocks when there has been only conforming transactions for 1000 blocks.
> 
> The problem in making these rules into consensus rule (affecting
> tx/block validity) is that some rules (in particular #3) may not be
> wanted by everyone, as they effectively limit the possibilities of the
> script language further. As it is ultimately only about protecting
> senders who care about non-malleability, introducing a new transaction
> version is a very neat way of accomplishing that. The new block
> version number is only there to coordinate the rollout, and choosing
> an automatic forking point.
> 
> -- 
> Pieter

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/f91a05d2/attachment.sig>

From gmaxwell at gmail.com  Wed Feb 19 20:39:07 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Wed, 19 Feb 2014 12:39:07 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
Message-ID: <CAAS2fgR_OBw1LMe=AUU8ZUANPeNXizAvThexz=rYjnqE8RoFdQ@mail.gmail.com>

On Wed, Feb 19, 2014 at 12:28 PM, Michael Gronager <gronager at mac.com> wrote:
> Twisting your words a bit I read:
>
> * you want to support relay of transactions that can be changed on the fly, but you consider it wrong to modify them.
> * #3 is already not forwarded, but you still find it relevant to support it.
>
> Rational use cases of #3 will be pretty hard to find given the fact that they can be changed on the fly. We are down to inclusion in blocks by miners for special purposes - or did I miss out something?

You did. See the other sighash flags.

> I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.

In exchange you make the behavior basically impossible do deploy
without first blocking all ongoing transactions. This seems foolish.
All signers need to be updated to change their behavior to be
anti-malleability compatible, they can change their version at the
same time... and leave things actually working for the things which
can't be easily updated.



From pete at petertodd.org  Wed Feb 19 20:49:32 2014
From: pete at petertodd.org (Peter Todd)
Date: Wed, 19 Feb 2014 15:49:32 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
Message-ID: <ec7ad616-1596-420f-8101-6f1d86429638@email.android.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

While we might be able to get away with a retroactive change in meaning right now in the future that won't be so easy. There are lots if proposed applications for nLockTime-using protocols that depend on transactions (or parts of transactions) being possible to mine as is. Making existing transactions impossible to mine in the future will break those types of applications. We might as well use this as a learning experience for what a version bump would look like infrastructures wise.

Note how the above is a particularly bad example of gmaxwell's generic "don't break things" objection. Equally, remember that lots of infrastructure *does* handle malleability just fine already.

On February 19, 2014 3:28:24 PM EST, Michael Gronager <gronager at mac.com> wrote:
>Twisting your words a bit I read:
>
>* you want to support relay of transactions that can be changed on the
>fly, but you consider it wrong to modify them.
>* #3 is already not forwarded, but you still find it relevant to
>support it.
>
>Rational use cases of #3 will be pretty hard to find given the fact
>that they can be changed on the fly. We are down to inclusion in blocks
>by miners for special purposes - or did I miss out something?
>
>I think that we could guarantee fewer incidents by making version 1
>transactions unmalleable and then optionally introduce a version 3 that
>supported the malleability feature. That way most existing problematic
>implementations would be fixed and no doors were closed for people
>experimenting with other stuff - tx v 3 would probably then be called
>experimental transactions.
>
>/M
>
>
>On Feb 19, 2014, at 3:38 PM, Pieter Wuille <pieter.wuille at gmail.com>
>wrote:
>
>> On Wed, Feb 19, 2014 at 3:11 PM, Michael Gronager <gronager at mac.com>
>wrote:
>>> Why introduce a new transaction version for this purpose ? Wouldn't
>it be more elegant to simply let:
>>>
>>> 1. the next bitcoin version "prettify" all relayed transactions as
>deterministic transactions fulfilling the scheme 1-6 effectively
>blocking any malleability attack? If miners would upgrade then all
>transactions in blocks would have a deterministic hash.
>>
>> I consider actively mutating other's transactions worse than not
>> relaying them. If we want people to make their software deal with
>> malleability, either will work.
>>
>> Regarding deterministic hash: that's impossible. Some signature hash
>> types are inherently (and intentionally) malleable. I don't think we
>> should pretend to want to change that. The purpose is making
>> non-malleability a choice the sender of a transaction can make.
>>
>> Most of the rules actually are enforced by IsStandard already now.
>> Only #1 and #7 aren't. #1 affects the majority of all transactions,
>so
>> changing it right now would be painful. #7 only affects multisig.
>>
>>> 2. In a version later one could block relay of non deterministic
>transactions, as well as the acceptance of blocks with non-confirming
>transactions.
>>>
>>> To non-standard conforming clients this "prettify" change of hash
>would be seen as a constant malleability attack, but given the
>"prettify" code it is to fix any client into producing only conforming
>transactions, just by running the transaction through it before
>broadcast.
>>>
>>> There is a possible fork risk in step 2. above - if a majority of
>miners still havn't upgraded to 1 when 2 is introduced. We could
>monitor % non conforming transaction in a block and only introduce 2.
>once that number is sufficiently small for a certain duration -
>criteria:
>>> * Switch on forcing of unmalleable transactions in blocks when there
>has been only conforming transactions for 1000 blocks.
>>
>> The problem in making these rules into consensus rule (affecting
>> tx/block validity) is that some rules (in particular #3) may not be
>> wanted by everyone, as they effectively limit the possibilities of
>the
>> script language further. As it is ultimately only about protecting
>> senders who care about non-malleability, introducing a new
>transaction
>> version is a very neat way of accomplishing that. The new block
>> version number is only there to coordinate the rollout, and choosing
>> an automatic forking point.
>>
>> --
>> Pieter
>
>
>
>------------------------------------------------------------------------
>
>------------------------------------------------------------------------------
>Managing the Performance of Cloud-Based Applications
>Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>Read the Whitepaper.
>http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
>
>------------------------------------------------------------------------
>
>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-----BEGIN PGP SIGNATURE-----
Version: APG v1.0.9

iQFQBAEBCAA6BQJTBRjcMxxQZXRlciBUb2RkIChsb3cgc2VjdXJpdHkga2V5KSA8
cGV0ZUBwZXRlcnRvZGQub3JnPgAKCRAZnIM7qOfwhbuuCADHHZvCbWNR+hj3lq2u
Xjr8POSsMWk4XorvLftgXSzAzypr7n0BP7+fmz/v0J98XfeOHxf8NHB2VXzFMCzI
mstYyFC+gdsPf9eIMoN2S9EB9d4Lh1Y7Zv5BGqopuHCUIVMpzk2QDaFlLe+gW8Ai
p4Yv/jGib8ym1ahJ24nZ89l7Psa+uXDw8N2VX5PcyDNVRwzuXwa0h2Kix/gt8uJb
RV5Sj3duxUE6mOGN07j6lPu9VcrtD0ydvAO3DoEJqkBqjhbC33h05H96KPQKuGcg
5DOKXUV5ChW5CF3DH5HN/LdduLgbTevtLbkBhdLKo+z5GKaU7Qpc5i6dIeAKl3uA
KCQE
=DiAE
-----END PGP SIGNATURE-----




From gmaxwell at gmail.com  Wed Feb 19 21:05:03 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Wed, 19 Feb 2014 13:05:03 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <ec7ad616-1596-420f-8101-6f1d86429638@email.android.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<ec7ad616-1596-420f-8101-6f1d86429638@email.android.com>
Message-ID: <CAAS2fgSRbsaxDr_w0HL2zGwcQtG96XMaqeE5QXLo3tz0+OydUg@mail.gmail.com>

dOn Wed, Feb 19, 2014 at 12:49 PM, Peter Todd <pete at petertodd.org> wrote:
> While we might be able to get away with a retroactive change in meaning right now in the future that won't be so easy. There are lots if proposed applications for nLockTime-using protocols that depend on transactions (or parts of transactions) being possible to mine as is. Making existing transactions impossible to mine in the future will break those types of applications. We might as well use this as a learning experience for what a version bump would look like infrastructures wise.

For some reason it took me a couple reads to get this so I thought I'd
restate it in a more blunt form.

There may exist people today who have send funds to addresses,
authored nlocktime releases, and destroyed the key the funds are at
now in order to achieve a timelock.  This might be a foolish thing to
do, but it's the kind of thing that you have to worry about when
potentially breaking existing transactions.

(This kind of us is, fwiw, another example of why ANYONE_CAN_PAY is useful).



From pieter.wuille at gmail.com  Wed Feb 19 21:11:14 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 19 Feb 2014 22:11:14 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
Message-ID: <CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>

On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com> wrote:
> I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.

Just to be clear: this change is not directly intended to avoid
"incidents". It will take way too long to deploy this. Software should
deal with malleability. This is a longer-term solution intended to
provide non-malleability guarantees for clients that a) are upgraded
to use them  b) willing to restrict their functionality. As there are
several intended use cases for malleable transactions (the sighash
flags pretty directly are a way to signify what malleabilities are
*wanted*), this is not about outlawing malleability.

While we could right now make all these rules non-standard, and
schedule a soft fork in a year or so to make them illegal, it would
mean removing potential functionality that can only be re-enabled
through a hard fork. This is significantly harder, so we should think
about it very well in advance.

About new transaction and block versions: this allows implementing and
automatically scheduling a softfork without waiting for wallets to
upgrade. The non-DER signature change was discussed for over two
years, and implemented almost a year ago, and we still notice wallets
that don't support it. We can't expect every wallet to be instantly
modified (what about hardware wallets like the Trezor, for example?
they may not just be able to be upgraded). Nor is it necessary: if
your software only spends confirmed change, and tracks all debits
correctly, there is no need.

-- 
Pieter



From natanael.l at gmail.com  Thu Feb 20 00:22:15 2014
From: natanael.l at gmail.com (Natanael)
Date: Thu, 20 Feb 2014 01:22:15 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
Message-ID: <CAAt2M1-YC8Bv=11AuT=0ATpX60R=g-PhhK+mBK=VHfEO3xLvxQ@mail.gmail.com>

Regarding chains of transactions intended to be published at once together,
wouldn't it be easier to add a "only-mine-with-child flag"?

That way the parent transactions aren't actually valid unless spent
together with the transaction that depends on it, and only the original
will have a child referencing it.

Then malleability is not an issue at all for transaction chains if you only
need to broadcast your full transaction chain once, and don't need to
extend it in two or more occasions, *after* broadcasting subchains to the
network, from the same set of pregenerated transactions.

If you need to broadcast pregenerated subchains separately, then you need
the last child in the chain to be non-malleable.

This would require all miners to start to respect it at once in order to
avoid forking the network.

- Sent from my phone
Den 19 feb 2014 22:13 skrev "Pieter Wuille" <pieter.wuille at gmail.com>:

> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>
> wrote:
> > I think that we could guarantee fewer incidents by making version 1
> transactions unmalleable and then optionally introduce a version 3 that
> supported the malleability feature. That way most existing problematic
> implementations would be fixed and no doors were closed for people
> experimenting with other stuff - tx v 3 would probably then be called
> experimental transactions.
>
> Just to be clear: this change is not directly intended to avoid
> "incidents". It will take way too long to deploy this. Software should
> deal with malleability. This is a longer-term solution intended to
> provide non-malleability guarantees for clients that a) are upgraded
> to use them  b) willing to restrict their functionality. As there are
> several intended use cases for malleable transactions (the sighash
> flags pretty directly are a way to signify what malleabilities are
> *wanted*), this is not about outlawing malleability.
>
> While we could right now make all these rules non-standard, and
> schedule a soft fork in a year or so to make them illegal, it would
> mean removing potential functionality that can only be re-enabled
> through a hard fork. This is significantly harder, so we should think
> about it very well in advance.
>
> About new transaction and block versions: this allows implementing and
> automatically scheduling a softfork without waiting for wallets to
> upgrade. The non-DER signature change was discussed for over two
> years, and implemented almost a year ago, and we still notice wallets
> that don't support it. We can't expect every wallet to be instantly
> modified (what about hardware wallets like the Trezor, for example?
> they may not just be able to be upgraded). Nor is it necessary: if
> your software only spends confirmed change, and tracks all debits
> correctly, there is no need.
>
> --
> Pieter
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/d3b847d3/attachment.html>

From allen.piscitello at gmail.com  Thu Feb 20 01:29:05 2014
From: allen.piscitello at gmail.com (Allen Piscitello)
Date: Wed, 19 Feb 2014 19:29:05 -0600
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAAt2M1-YC8Bv=11AuT=0ATpX60R=g-PhhK+mBK=VHfEO3xLvxQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<CAAt2M1-YC8Bv=11AuT=0ATpX60R=g-PhhK+mBK=VHfEO3xLvxQ@mail.gmail.com>
Message-ID: <CAJfRnm6itmEv6wsFyZGMYVLXSms5v9Q9BfhFfZEoJLxMMiP_2g@mail.gmail.com>

This is somewhat problematic in my use case since some parts need to be in
the chain earlier than others and have the same ID as expected.

https://bitcointalk.org/index.php?topic=260898.10

I haven't gone back to see if there are any ways around it, but the main
problem here is I need the Contract TX to be in the chain much earlier than
redeeming, but I need the refund transaction to be in the chain much
earlier.  Perhaps there are some tricks to pull off to get it to work, but
I haven't been working on this for a while so I'm a bit rusty in that area.

This might be helpful enough to help a lot of use cases, but shouldn't be
final.

-Allen

On Wed, Feb 19, 2014 at 6:22 PM, Natanael <natanael.l at gmail.com> wrote:

> Regarding chains of transactions intended to be published at once
> together, wouldn't it be easier to add a "only-mine-with-child flag"?
>
> That way the parent transactions aren't actually valid unless spent
> together with the transaction that depends on it, and only the original
> will have a child referencing it.
>
> Then malleability is not an issue at all for transaction chains if you
> only need to broadcast your full transaction chain once, and don't need to
> extend it in two or more occasions, *after* broadcasting subchains to the
> network, from the same set of pregenerated transactions.
>
> If you need to broadcast pregenerated subchains separately, then you need
> the last child in the chain to be non-malleable.
>
> This would require all miners to start to respect it at once in order to
> avoid forking the network.
>
> - Sent from my phone
> Den 19 feb 2014 22:13 skrev "Pieter Wuille" <pieter.wuille at gmail.com>:
>
> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>
>> wrote:
>> > I think that we could guarantee fewer incidents by making version 1
>> transactions unmalleable and then optionally introduce a version 3 that
>> supported the malleability feature. That way most existing problematic
>> implementations would be fixed and no doors were closed for people
>> experimenting with other stuff - tx v 3 would probably then be called
>> experimental transactions.
>>
>> Just to be clear: this change is not directly intended to avoid
>> "incidents". It will take way too long to deploy this. Software should
>> deal with malleability. This is a longer-term solution intended to
>> provide non-malleability guarantees for clients that a) are upgraded
>> to use them  b) willing to restrict their functionality. As there are
>> several intended use cases for malleable transactions (the sighash
>> flags pretty directly are a way to signify what malleabilities are
>> *wanted*), this is not about outlawing malleability.
>>
>> While we could right now make all these rules non-standard, and
>> schedule a soft fork in a year or so to make them illegal, it would
>> mean removing potential functionality that can only be re-enabled
>> through a hard fork. This is significantly harder, so we should think
>> about it very well in advance.
>>
>> About new transaction and block versions: this allows implementing and
>> automatically scheduling a softfork without waiting for wallets to
>> upgrade. The non-DER signature change was discussed for over two
>> years, and implemented almost a year ago, and we still notice wallets
>> that don't support it. We can't expect every wallet to be instantly
>> modified (what about hardware wallets like the Trezor, for example?
>> they may not just be able to be upgraded). Nor is it necessary: if
>> your software only spends confirmed change, and tracks all debits
>> correctly, there is no need.
>>
>> --
>> Pieter
>>
>>
>> ------------------------------------------------------------------------------
>> Managing the Performance of Cloud-Based Applications
>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>> Read the Whitepaper.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140219/42627c75/attachment.html>

From natanael.l at gmail.com  Thu Feb 20 07:50:51 2014
From: natanael.l at gmail.com (Natanael)
Date: Thu, 20 Feb 2014 08:50:51 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAJfRnm6itmEv6wsFyZGMYVLXSms5v9Q9BfhFfZEoJLxMMiP_2g@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<CAAt2M1-YC8Bv=11AuT=0ATpX60R=g-PhhK+mBK=VHfEO3xLvxQ@mail.gmail.com>
	<CAJfRnm6itmEv6wsFyZGMYVLXSms5v9Q9BfhFfZEoJLxMMiP_2g@mail.gmail.com>
Message-ID: <CAAt2M1-wLn9n00ADjGni+i1JTDEAg5a8QEz83K+dCSRsMZRCLA@mail.gmail.com>

You could pregenerate entire "trees" of alternative outcomes where you pick
one branch / chain to broadcast based on the real world events as they
happen.

But I see another problem regarding use of oracles, if you have a P2SH
address with 2-of-3 signatures or similar in the chain, amd some
transactions following it, then the oracle needs to pregenerate both
transactions for both outcomes in advance. But the oracle probably don't
want to actually share it in advance to any third party before the event
happened.

This can be solved if the oracle only shares the transaction hash in
advance and then hands out a Zero-knowledge proof of that transaction with
the given hash is following the agreed upon rules, so you can trust the
transaction chain anyway and still being able to pregenerate a full tree of
transactions.

And then the oracle will release one of the possible transactions after the
event in question has happened, so you can broadcast the chain of choice.

This unfortunately breaks down if the number of possible outcomes becomes
too many as you would need to both generate and store a tree of possible
outcomes that is massive.

- Sent from my phone
Den 20 feb 2014 02:29 skrev "Allen Piscitello" <allen.piscitello at gmail.com>:

> This is somewhat problematic in my use case since some parts need to be in
> the chain earlier than others and have the same ID as expected.
>
> https://bitcointalk.org/index.php?topic=260898.10
>
> I haven't gone back to see if there are any ways around it, but the main
> problem here is I need the Contract TX to be in the chain much earlier than
> redeeming, but I need the refund transaction to be in the chain much
> earlier.  Perhaps there are some tricks to pull off to get it to work, but
> I haven't been working on this for a while so I'm a bit rusty in that area.
>
> This might be helpful enough to help a lot of use cases, but shouldn't be
> final.
>
> -Allen
>
> On Wed, Feb 19, 2014 at 6:22 PM, Natanael <natanael.l at gmail.com> wrote:
>
>> Regarding chains of transactions intended to be published at once
>> together, wouldn't it be easier to add a "only-mine-with-child flag"?
>>
>> That way the parent transactions aren't actually valid unless spent
>> together with the transaction that depends on it, and only the original
>> will have a child referencing it.
>>
>> Then malleability is not an issue at all for transaction chains if you
>> only need to broadcast your full transaction chain once, and don't need to
>> extend it in two or more occasions, *after* broadcasting subchains to the
>> network, from the same set of pregenerated transactions.
>>
>> If you need to broadcast pregenerated subchains separately, then you need
>> the last child in the chain to be non-malleable.
>>
>> This would require all miners to start to respect it at once in order to
>> avoid forking the network.
>>
>> - Sent from my phone
>> Den 19 feb 2014 22:13 skrev "Pieter Wuille" <pieter.wuille at gmail.com>:
>>
>> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>
>>> wrote:
>>> > I think that we could guarantee fewer incidents by making version 1
>>> transactions unmalleable and then optionally introduce a version 3 that
>>> supported the malleability feature. That way most existing problematic
>>> implementations would be fixed and no doors were closed for people
>>> experimenting with other stuff - tx v 3 would probably then be called
>>> experimental transactions.
>>>
>>> Just to be clear: this change is not directly intended to avoid
>>> "incidents". It will take way too long to deploy this. Software should
>>> deal with malleability. This is a longer-term solution intended to
>>> provide non-malleability guarantees for clients that a) are upgraded
>>> to use them  b) willing to restrict their functionality. As there are
>>> several intended use cases for malleable transactions (the sighash
>>> flags pretty directly are a way to signify what malleabilities are
>>> *wanted*), this is not about outlawing malleability.
>>>
>>> While we could right now make all these rules non-standard, and
>>> schedule a soft fork in a year or so to make them illegal, it would
>>> mean removing potential functionality that can only be re-enabled
>>> through a hard fork. This is significantly harder, so we should think
>>> about it very well in advance.
>>>
>>> About new transaction and block versions: this allows implementing and
>>> automatically scheduling a softfork without waiting for wallets to
>>> upgrade. The non-DER signature change was discussed for over two
>>> years, and implemented almost a year ago, and we still notice wallets
>>> that don't support it. We can't expect every wallet to be instantly
>>> modified (what about hardware wallets like the Trezor, for example?
>>> they may not just be able to be upgraded). Nor is it necessary: if
>>> your software only spends confirmed change, and tracks all debits
>>> correctly, there is no need.
>>>
>>> --
>>> Pieter
>>>
>>>
>>> ------------------------------------------------------------------------------
>>> Managing the Performance of Cloud-Based Applications
>>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>>> Read the Whitepaper.
>>>
>>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
>>> _______________________________________________
>>> Bitcoin-development mailing list
>>> Bitcoin-development at lists.sourceforge.net
>>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>
>>
>>
>> ------------------------------------------------------------------------------
>> Managing the Performance of Cloud-Based Applications
>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>> Read the Whitepaper.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/00054c41/attachment.html>

From gronager at mac.com  Thu Feb 20 10:59:22 2014
From: gronager at mac.com (Michael Gronager)
Date: Thu, 20 Feb 2014 11:59:22 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
 malleability
In-Reply-To: <CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
Message-ID: <81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>

As I see the BIP it is basically stressing that ver 1 transactions are malleable.

It then addresses the need for unmalleable transactions for e.g. spending unconfirmed outputs in a deterministic way (i.e. no 3rd party can sabotage) - this transaction type is defined as ver 3.

A lot of clients today spend unconfirmed outputs (even bitcoin-qt) and as such make an implicit assumption that this is kind of safe, which it is not - it can be intervened and sabotaged through tx malleability.

What I suggested was to ensure that a subclass of version 1 transactions become unmalleable - namely those with sighash=all. Note that only the sender can modify the sighash as it is part of the hash signed. So instead of defining a version 3, we could constrain version 1 txes with sighash=all to have a unmalleable hash. If you e.g. would like to still have a sighash=all type of transaction with malleable features you can simply use that sighash=all today is checked for using sighash&0x1f=sighash_all, so just OR'ing with 0x20 or 0x40 will get you the 'old' feature.

I do however buy the argument of Peter and Gregory that there might exist unpublished transactions out there that does not even conform to the DER rules etc, and as such we cannot forbid them from being mined, nor can we timestamp them and include 'only the old ones'. Hence we cannot change the consensus rule for version 1 transactions - and only changing the relay rules will not provide a certain guarantee.

So, I think the two line argument for the BIP is as follows:
1. We cannot change the consensus rules for version 1 transactions as that might invalidate unpublished non-standard transactions (= voiding peoples money, which is a line we don't want to cross)
2. The prime usecase for unmalleable transactions is being able to spend unconfirmed outputs - this is done today by almost all clients, but it is really broken. Hence a need for a fix asap.

I am all in favor for the BIP, but I expect the realistic timeline for enforced version 3 transactions is roughly one year, which is better than two, but it would have been nice to get it faster...

/M


On Feb 19, 2014, at 10:11 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:

> On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com> wrote:
>> I think that we could guarantee fewer incidents by making version 1 transactions unmalleable and then optionally introduce a version 3 that supported the malleability feature. That way most existing problematic implementations would be fixed and no doors were closed for people experimenting with other stuff - tx v 3 would probably then be called experimental transactions.
> 
> Just to be clear: this change is not directly intended to avoid
> "incidents". It will take way too long to deploy this. Software should
> deal with malleability. This is a longer-term solution intended to
> provide non-malleability guarantees for clients that a) are upgraded
> to use them  b) willing to restrict their functionality. As there are
> several intended use cases for malleable transactions (the sighash
> flags pretty directly are a way to signify what malleabilities are
> *wanted*), this is not about outlawing malleability.
> 
> While we could right now make all these rules non-standard, and
> schedule a soft fork in a year or so to make them illegal, it would
> mean removing potential functionality that can only be re-enabled
> through a hard fork. This is significantly harder, so we should think
> about it very well in advance.
> 
> About new transaction and block versions: this allows implementing and
> automatically scheduling a softfork without waiting for wallets to
> upgrade. The non-DER signature change was discussed for over two
> years, and implemented almost a year ago, and we still notice wallets
> that don't support it. We can't expect every wallet to be instantly
> modified (what about hardware wallets like the Trezor, for example?
> they may not just be able to be upgraded). Nor is it necessary: if
> your software only spends confirmed change, and tracks all debits
> correctly, there is no need.
> 
> -- 
> Pieter

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 496 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/d16136fe/attachment.sig>

From mike at plan99.net  Thu Feb 20 14:08:59 2014
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Feb 2014 14:08:59 +0000
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
Message-ID: <CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>

We've done forking changes before much faster than a year and that was with
less experience. If we want, we can get this done within months.
On 20 Feb 2014 16:30, "Michael Gronager" <gronager at mac.com> wrote:

> As I see the BIP it is basically stressing that ver 1 transactions are
> malleable.
>
> It then addresses the need for unmalleable transactions for e.g. spending
> unconfirmed outputs in a deterministic way (i.e. no 3rd party can sabotage)
> - this transaction type is defined as ver 3.
>
> A lot of clients today spend unconfirmed outputs (even bitcoin-qt) and as
> such make an implicit assumption that this is kind of safe, which it is not
> - it can be intervened and sabotaged through tx malleability.
>
> What I suggested was to ensure that a subclass of version 1 transactions
> become unmalleable - namely those with sighash=all. Note that only the
> sender can modify the sighash as it is part of the hash signed. So instead
> of defining a version 3, we could constrain version 1 txes with sighash=all
> to have a unmalleable hash. If you e.g. would like to still have a
> sighash=all type of transaction with malleable features you can simply use
> that sighash=all today is checked for using sighash&0x1f=sighash_all, so
> just OR'ing with 0x20 or 0x40 will get you the 'old' feature.
>
> I do however buy the argument of Peter and Gregory that there might exist
> unpublished transactions out there that does not even conform to the DER
> rules etc, and as such we cannot forbid them from being mined, nor can we
> timestamp them and include 'only the old ones'. Hence we cannot change the
> consensus rule for version 1 transactions - and only changing the relay
> rules will not provide a certain guarantee.
>
> So, I think the two line argument for the BIP is as follows:
> 1. We cannot change the consensus rules for version 1 transactions as that
> might invalidate unpublished non-standard transactions (= voiding peoples
> money, which is a line we don't want to cross)
> 2. The prime usecase for unmalleable transactions is being able to spend
> unconfirmed outputs - this is done today by almost all clients, but it is
> really broken. Hence a need for a fix asap.
>
> I am all in favor for the BIP, but I expect the realistic timeline for
> enforced version 3 transactions is roughly one year, which is better than
> two, but it would have been nice to get it faster...
>
> /M
>
>
> On Feb 19, 2014, at 10:11 PM, Pieter Wuille <pieter.wuille at gmail.com>
> wrote:
>
> > On Wed, Feb 19, 2014 at 9:28 PM, Michael Gronager <gronager at mac.com>
> wrote:
> >> I think that we could guarantee fewer incidents by making version 1
> transactions unmalleable and then optionally introduce a version 3 that
> supported the malleability feature. That way most existing problematic
> implementations would be fixed and no doors were closed for people
> experimenting with other stuff - tx v 3 would probably then be called
> experimental transactions.
> >
> > Just to be clear: this change is not directly intended to avoid
> > "incidents". It will take way too long to deploy this. Software should
> > deal with malleability. This is a longer-term solution intended to
> > provide non-malleability guarantees for clients that a) are upgraded
> > to use them  b) willing to restrict their functionality. As there are
> > several intended use cases for malleable transactions (the sighash
> > flags pretty directly are a way to signify what malleabilities are
> > *wanted*), this is not about outlawing malleability.
> >
> > While we could right now make all these rules non-standard, and
> > schedule a soft fork in a year or so to make them illegal, it would
> > mean removing potential functionality that can only be re-enabled
> > through a hard fork. This is significantly harder, so we should think
> > about it very well in advance.
> >
> > About new transaction and block versions: this allows implementing and
> > automatically scheduling a softfork without waiting for wallets to
> > upgrade. The non-DER signature change was discussed for over two
> > years, and implemented almost a year ago, and we still notice wallets
> > that don't support it. We can't expect every wallet to be instantly
> > modified (what about hardware wallets like the Trezor, for example?
> > they may not just be able to be upgraded). Nor is it necessary: if
> > your software only spends confirmed change, and tracks all debits
> > correctly, there is no need.
> >
> > --
> > Pieter
>
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/41fc69a7/attachment.html>

From gmaxwell at gmail.com  Thu Feb 20 14:15:21 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 20 Feb 2014 06:15:21 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
Message-ID: <CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>

On Thu, Feb 20, 2014 at 6:08 AM, Mike Hearn <mike at plan99.net> wrote:
> We've done forking changes before much faster than a year and that was with
> less experience. If we want, we can get this done within months.

You mean P2SH... which your implementation has only picked up support
for in the last month or so?



From gavinandresen at gmail.com  Thu Feb 20 14:29:40 2014
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 20 Feb 2014 09:29:40 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
Message-ID: <CABsx9T1R+2rBa1VkaJiS3ktAgoMaBHfkUb3kXxwpHSxjtqNrRw@mail.gmail.com>

I think we should get Pieter's proposal done and implemented quickly. I
agree with Mike, it doesn't have to take a long time for the core network
to fully support this.

Getting wallets to start generating transaction.version=3 might take years,
but that is OK.

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/5383f456/attachment.html>

From gmaxwell at gmail.com  Thu Feb 20 14:36:39 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 20 Feb 2014 06:36:39 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CABsx9T1R+2rBa1VkaJiS3ktAgoMaBHfkUb3kXxwpHSxjtqNrRw@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
	<CABsx9T1R+2rBa1VkaJiS3ktAgoMaBHfkUb3kXxwpHSxjtqNrRw@mail.gmail.com>
Message-ID: <CAAS2fgTBxSfpuANP0+J1UM2nWOxQASYFBCQFW1D5L2j3DWRx-A@mail.gmail.com>

On Thu, Feb 20, 2014 at 6:29 AM, Gavin Andresen <gavinandresen at gmail.com> wrote:
> I think we should get Pieter's proposal done and implemented quickly. I
> agree with Mike, it doesn't have to take a long time for the core network to
> fully support this.
>
> Getting wallets to start generating transaction.version=3 might take years,
> but that is OK.

Sure I'm all for doing what Pieter suggested? it's basically the plan
we've been executing for some time already but with the version check
to make it sane to complete.

My reserved sounding comments were relative to the proposals to do
things with nversion=1 transactions, frankly I think thats completely
insane. Though while we're on the subject of reservations, I am far
from confident that we've uncovered all the possible malleability
routes? that list gained a new, never before discussed entry, when
Pieter was writing it a couple weeks ago.  We also have no proof of
the absence of further algebraic malleability in DSA (though I think
its somewhat unlikely, a solid proof of it has been somewhat elusive).



From gavinandresen at gmail.com  Thu Feb 20 14:58:30 2014
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 20 Feb 2014 09:58:30 -0500
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAAS2fgTBxSfpuANP0+J1UM2nWOxQASYFBCQFW1D5L2j3DWRx-A@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
	<CABsx9T1R+2rBa1VkaJiS3ktAgoMaBHfkUb3kXxwpHSxjtqNrRw@mail.gmail.com>
	<CAAS2fgTBxSfpuANP0+J1UM2nWOxQASYFBCQFW1D5L2j3DWRx-A@mail.gmail.com>
Message-ID: <CABsx9T3bf-f7VhuRMQhvce16mSent5SzUn1ZbwpbnWAvvU6S8Q@mail.gmail.com>

Great, I'm hearing rough consensus to proceed with Pieter's plan.

RE: far from confident on malleability routes:  I'm reasonably confident
that we can squash malleability for IsStandard, SIGHASH_ALL transactions. A
proper proof of DSA signature un-malleability (or an lower bound for how
much work it would be to create a valid doppleganger signature) would be
great, but I don't think it is necessary to proceed.


On Thu, Feb 20, 2014 at 9:36 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:

> On Thu, Feb 20, 2014 at 6:29 AM, Gavin Andresen <gavinandresen at gmail.com>
> wrote:
> > I think we should get Pieter's proposal done and implemented quickly. I
> > agree with Mike, it doesn't have to take a long time for the core
> network to
> > fully support this.
> >
> > Getting wallets to start generating transaction.version=3 might take
> years,
> > but that is OK.
>
> Sure I'm all for doing what Pieter suggested-- it's basically the plan
> we've been executing for some time already but with the version check
> to make it sane to complete.
>
> My reserved sounding comments were relative to the proposals to do
> things with nversion=1 transactions, frankly I think thats completely
> insane. Though while we're on the subject of reservations, I am far
> from confident that we've uncovered all the possible malleability
> routes-- that list gained a new, never before discussed entry, when
> Pieter was writing it a couple weeks ago.  We also have no proof of
> the absence of further algebraic malleability in DSA (though I think
> its somewhat unlikely, a solid proof of it has been somewhat elusive).
>



-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/3a8746e1/attachment.html>

From pieter.wuille at gmail.com  Thu Feb 20 15:11:27 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 20 Feb 2014 16:11:27 +0100
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CABsx9T3bf-f7VhuRMQhvce16mSent5SzUn1ZbwpbnWAvvU6S8Q@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
	<CABsx9T1R+2rBa1VkaJiS3ktAgoMaBHfkUb3kXxwpHSxjtqNrRw@mail.gmail.com>
	<CAAS2fgTBxSfpuANP0+J1UM2nWOxQASYFBCQFW1D5L2j3DWRx-A@mail.gmail.com>
	<CABsx9T3bf-f7VhuRMQhvce16mSent5SzUn1ZbwpbnWAvvU6S8Q@mail.gmail.com>
Message-ID: <CAPg+sBhdOdR=BeDKo47C1qr7R7i38VfYT5LfNijbby8CRPTqng@mail.gmail.com>

I hereby request a BIP number.


On Thu, Feb 20, 2014 at 3:58 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:
> Great, I'm hearing rough consensus to proceed with Pieter's plan.
>
> RE: far from confident on malleability routes:  I'm reasonably confident
> that we can squash malleability for IsStandard, SIGHASH_ALL transactions. A
> proper proof of DSA signature un-malleability (or an lower bound for how
> much work it would be to create a valid doppleganger signature) would be
> great, but I don't think it is necessary to proceed.
>
>
> On Thu, Feb 20, 2014 at 9:36 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>>
>> On Thu, Feb 20, 2014 at 6:29 AM, Gavin Andresen <gavinandresen at gmail.com>
>> wrote:
>> > I think we should get Pieter's proposal done and implemented quickly. I
>> > agree with Mike, it doesn't have to take a long time for the core
>> > network to
>> > fully support this.
>> >
>> > Getting wallets to start generating transaction.version=3 might take
>> > years,
>> > but that is OK.
>>
>> Sure I'm all for doing what Pieter suggested-- it's basically the plan
>> we've been executing for some time already but with the version check
>> to make it sane to complete.
>>
>> My reserved sounding comments were relative to the proposals to do
>> things with nversion=1 transactions, frankly I think thats completely
>> insane. Though while we're on the subject of reservations, I am far
>> from confident that we've uncovered all the possible malleability
>> routes-- that list gained a new, never before discussed entry, when
>> Pieter was writing it a couple weeks ago.  We also have no proof of
>> the absence of further algebraic malleability in DSA (though I think
>> its somewhat unlikely, a solid proof of it has been somewhat elusive).
>
>
>
>
> --
> --
> Gavin Andresen
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



From gmaxwell at gmail.com  Thu Feb 20 15:24:17 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 20 Feb 2014 07:24:17 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAPg+sBhdOdR=BeDKo47C1qr7R7i38VfYT5LfNijbby8CRPTqng@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
	<CABsx9T1R+2rBa1VkaJiS3ktAgoMaBHfkUb3kXxwpHSxjtqNrRw@mail.gmail.com>
	<CAAS2fgTBxSfpuANP0+J1UM2nWOxQASYFBCQFW1D5L2j3DWRx-A@mail.gmail.com>
	<CABsx9T3bf-f7VhuRMQhvce16mSent5SzUn1ZbwpbnWAvvU6S8Q@mail.gmail.com>
	<CAPg+sBhdOdR=BeDKo47C1qr7R7i38VfYT5LfNijbby8CRPTqng@mail.gmail.com>
Message-ID: <CAAS2fgStTMy3m6TGEPHrJ3d9XYUG1+J5ggFRN8vmmTWjp_5H7g@mail.gmail.com>

On Thu, Feb 20, 2014 at 7:11 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> I hereby request a BIP number.

62 assigned.



From gavinandresen at gmail.com  Thu Feb 20 15:40:34 2014
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 20 Feb 2014 10:40:34 -0500
Subject: [Bitcoin-development] Transaction malleability in the core code:
	update
Message-ID: <CABsx9T3+TOQ6c7=qEhOoc+tYSp=jba-o8MA3Z8N9t05BDdYS5w@mail.gmail.com>

A quick update on the state of transaction malleability work in
Bitcoind/Bitcoin-Qt (aka Bitcoin Core). This is not about longer-term
malleability issues, just the very short-term work being done (or already
done) to the reference implementation.

First, the problems:

We've had a longstanding TODO to improve the way the core code deals with
double-spends. From the core code's point of view, malleable transactions
are just one particular form of double-spend.

Improving double-spend handling never made it to the top of the TODO list,
because the cases where it happened involved doing unsupported things (like
copying your wallet.dat to another machine and then spending on both
machines).

And because there is a heavy-handed workaround if a wallet becomes confused
because of a double-spend:  restore all of the keys, rescan for
transactions confirmed in the blockchain, and any outputs tied up in
double-spends get released. Coins (really, unspent transaction outputs)
were never permanently lost, but they could be tied up and unspendable when
associated with a 0-confirmation transaction that would never confirm.

So, work in progress or done:

https://github.com/bitcoin/bitcoin/pull/3659
https://github.com/bitcoin/bitcoin/pull/3674

These implements a kinder, gentler sledgehammer (-zapwallettxes) to fix a
confused wallet. If you have a wallet with 0-confirmation transactions that
are tying up bitcoins these should fix it.


https://github.com/bitcoin/bitcoin/pull/3651
https://github.com/bitcoin/bitcoin/pull/3657
https://github.com/bitcoin/bitcoin/pull/3676

These three merged pull requests implement a new command-line option:
-nospendzeroconfchange .  The best way to get a wallet confused is to spend
zero-confirmation change outputs that you created yourself; if the
transaction creating the change gets mutated, then the subsequent
transaction is invalid and will never confirm.

The core code spends unconfirmed change only as a last resort. If you are a
service using bitcoind that generates a lot of transactions then best
practice would be to run with -nospendzeroconfchange, and use "sendmany" to
batch payments only after previous payments have confirmed.

https://github.com/bitcoin/bitcoin/pull/3025

This tightens up the IsStandard() rule, so the easiest-to-implement method
of mutating transactions is blocked. Many big mining pools are already
running this patch.

https://github.com/bitcoin/bitcoin/pull/3669
https://github.com/bitcoin/bitcoin/pull/3671
https://github.com/bitcoin/bitcoin/pull/3694

These three get at the root of the problem; they rework the core wallet
code to implement "handle double spends better."  See the pull requests for
details.

How can you help:

Testing and code review is, as always, the bottleneck for getting out a
release with these changes.

We have a chronic problem with people running Bitcoin services on top of
the core code waiting until there is an "official" release, and then
assuming that somebody else has done the hard work of reviewing and testing
the changes.

YOU SHOULD NOT BE MAKING THAT ASSUMPTION!  Your particular RPC call usage
might trigger some edge-case bug that was missed, or perhaps the size of
your wallet triggers a performance problem introduced by a fix.

Or, in other words: do not treat the core development team as if we were a
commercial company that sold you a software library. That is not how open
source works; if you are making a profit using the software, you are
expected to help develop, debug, test, and review it.

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140220/6ba57731/attachment.html>

From mark at monetize.io  Fri Feb 21 02:41:05 2014
From: mark at monetize.io (Mark Friedenbach)
Date: Thu, 20 Feb 2014 18:41:05 -0800
Subject: [Bitcoin-development] Base-32 error correction coding
Message-ID: <5306BCC1.8040004@monetize.io>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

What follows is a proposed BIP for human-friendly base-32
serialization with error correction encoding. A formatted version is
viewable as part of a gist with related code:

https://gist.github.com/maaku/8996338#file-bip-ecc32-mediawiki

An implementation of this BIP and associated APIs is made available as
a pull request, with comprehensive testing:

https://github.com/bitcoin/bitcoin/pull/3713

This format is anticipated to be useful for helpdesk-related data
(e.g. the proposed normalized transaction ID), and future wallet
backup & paper wallet serialization formats.


== Abstract ==

The BIP proposes an human-centered encoding format for base-32 data
serialization. It differs from the presumptive default hexadecimal or
base58 encodings in the following ways:

1. Visually distinctive in that it includes the full range of
alphanumeric digits in its base-32 encoding, except the characters 0,
l, v, and 2. which are too easily confused with 1, i, u, r, or z in
font or handwriting.

2. Automatic correction of up to 1 transcription error per 31 coded
digits (130 bits of payload data). For a 256-bit hash or secret key,
this enables seamless recovery from up to two transcription errors so
long as they occur in separate halves of the coded representation.

3. Highly probable detection of errors beyond the error correction
threshold, with a false negative rate on the order of 25 bits, or 1 in
33 million likelihood.

4. Case-insensitive encoding ensures that it may be displayed in an
easier to read uniform case, and it is faster and more comfortable to
vocally read off a base-32 encoded number than the alternatives of
hexadecimal or base58.

In addition to the error correction code transformation of base-32
data, a padding scheme is specified for extending numbers or bit
vectors of any length to a multiple of 5 bits suitable for base-32
encoding.

== z-base-32 ==

The bitcoin reference client already has one implementation of base-32
encoding following the RFC 3548 standard, using the following alphabet:

    const char *pbase32 = "abcdefghijklmnopqrstuvwxyz234567";

For error correction coded strings this BIP specifies usage of Phil
Zimmermann's z-base-32 encoding alphabet[], which provides better
resistance to transcriptive errors than the RFC 3548 standard:

    const char *pzbase32 = "ybndrfg8ejkmcpqxot1uwisza345h769";

The same RFC 3548 coder is used for z-base-32, except that unnecessary
'=' padding characters are stripped before performing the alphabet
substitution. For example, the hexadecimal string 'ae653be0049be3' is
RFC 3548 encoded as 'vzstxyaetprq====', and z-base-32 encoded as
'i31uzayruxto'.

== CRC-5-USB error correction coding ==

Herein we describe an error correction encoding using cyclic
redundancy check polynomial division[], which requires 5 error
correction digits per 26 digits of input, instead of the theoretically
optimal 4, but is much, much easier to implement correctly then
available non-patented error correction codes. Cyclic redundancy check
polynomial division provides a very straightforward, patent-free
mechanism for reliably detecting transcription errors in input, and
performing up to 1-digit corrections per 26 digit block.

=== Encoding ===

The input to this error correction encoder is a sequence of 26 base-32
digits. These digits are decoded into 5-bit unsigned integers with
values equal to their offset into the base-32 alphabet string. If the
input is less than 26 digits in length, it is extended with
zero-valued digits. If For example, the string 'vzstxyaetprq' using
the RFC 3548 alphabet becomes the code point sequence:

    <21 25 18 19 23 24 0 4 19 15 17 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0>'
     |--------------input-------------|---------padding----------|

Expositionally it helps to think of this array as a 26-element column
vector of 5-bit binary integers:

    <0b10101
     0b11001
     0b10010
     0b10011
     0b10111
     0b11000
     0b00000
     0b00100
     0b10011
     0b01111
     0b10001
     0b10000
     ... 14 zero elements ...>

If we explode the bits of each element into 5, 1-bit columns, we get a
26 x 5 matrix:

    <1 0 1 0 1
     1 1 0 0 1
     1 0 0 1 0
     1 0 0 1 1
     1 0 1 1 1
     1 1 0 0 0
     0 0 0 0 0
     0 0 1 0 0
     1 0 0 1 1
     0 1 1 1 1
     1 0 0 0 1
     1 0 0 0 0
     ... 14 x 5 zero elements ...>

The array is then transposed, such that we get a 5 x 26 matrix where
each row represents the 5th, 4th, 3rd, 2nd, or 1st bit, respectfully,
of each element:

    <1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
     1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0>
     |---------input--------|----------padding---------|

We then use each of these rows separately as input into a cyclic
redundancy check polynomial division operation, using the CRC-5-USB
generating polynomial <code>x^5 + x^2 + 1</code>. The result is 5
element column vector:

    <10111
     01000
     10010
     00111
     00110>

The elements of this vector are then exploded horizontally, and
affixed to the end of the bit matrix.

    <1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1
     0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
     1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0
     0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1
     1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0>
     |---------input--------|----------padding----------|--crc---|

At this point, calculating the CRC checksum for each row should result
in zero:

    <0 0 0 0 0>

Now we reverse the process in order to encode the output. First the
padding bits are removed:

    <1 1 1 1 1 1 0 0 1 0 1 1 1 0 1 1 1
     0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0
     1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0
     0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1
     1 1 0 1 1 0 0 0 1 1 1 0 0 0 1 1 0>
     |---------input--------|--crc---|

Then the matrix is once again transposed, to yield an (l+5) x 5
matrix, where l is the number of digits in the original input:

<1 0 1 0 1  -
 1 1 0 0 1  |
 1 0 0 1 0  |
 1 0 0 1 1  |
 1 0 1 1 1  i
 1 1 0 0 0  n
 0 0 0 0 0  p
 0 0 1 0 0  u
 1 0 0 1 1  t
 0 1 1 1 1  |
 1 0 0 0 1  |
 1 0 0 0 0  -
 1 0 1 0 0  -
 0 1 0 0 0  c
 1 0 0 1 1  r
 1 0 1 1 1  c
 1 0 0 1 0> -

And the rows are imploded:

    <21 25 18 19 23 24 0 4 19 15 17 16 20 8 19 23 18>'
     |--------------input-------------|----crc-----|

And the result is converted into z-base-32: 'i31uzayruxtoweuz1'.

=== Decoding and error recovery ===

The process of decoding and error detection and recovery is similar to
encoding, and this section will not explain steps that were adequately
covered in the encoder description.

First, the input is converted from z-base-32 into a sequence of up to
31 (26+5) 5-bit integers, with zero-valued padding inserted between
the end of the input and the 5-digit checksum. Using our running
example of 'i31uzayruxtoweuz1', this result is the following:

    <21 25 18 19 23 24 0 4 19 15 17 16 0 0 0 0 0 0 0 0 0 0 0 0 0 0 20
8 19 23 18>'

|--------------input-------------|----------padding----------|----crc-----|

The binary representation of each element is exploded horizontally,
and the matrix transposed to yield the following 5 x 31 bit matrix:

    <1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1
     0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0
     1 0 0 0 1 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0
     0 0 1 1 1 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1
     1 1 0 1 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0>
     |---------input--------|----------padding----------|--crc---|

A CRC calculation of each row should yield zero if the encoded string
was transcribed correctly. If, however, a digit was wrong, that would
result in some or all of the bits of the corresponding column being
flipped. A property of the CRC generating polynomial used is that in
the case of a single digit error, each row with a flipped bit would
result in the same checksum, and that checksum value can be used as
the index into a table indicating which bit was flipped:

    // EC[0] has no meaning, because offsets are 1-based
    const unsigned char EC[32] =
        { 32,  4,  3, 17,  2, 30, 16, 24,
           1,  6, 29,  8, 15, 27, 23, 12,
           0, 25,  5, 18, 28, 13,  7,  9,
          14, 10, 26, 19, 22, 21, 11, 20 };

If all checksum values are zero, the decoder assumes the input is
correct. If all non-zero checksum values are equal valued, the decoder
assumes the corresponding digit was transcribed incorrectly and flips
the bit in that column of the rows with non-zero checksums.

If any of the five checksum values are non-zero, and not equal to each
other, then there is an unrecoverable error in the input. The
probability of two or more digits being incorrect and yet by chance
the checksums being zero or equal valued is less than 1 in 33 million.

Now that errors have been detected and single-digit errors corrected,
the padding bits and CRC checksum bits are removed. The matrix is
transposed, it's rows imploded, and the resulting sequence of up to 26
characters converted into base-32 using the RFC 3548 alphabet:
'vzstxyaetprq'.

== CodedBase32 integer encoding ==

Although providing an error correction coder for base-32 data
interesting and useful in contexts where base-32 is already deployed,
many applications involve encoding of integers which are powers of two
in length. This section provides a standard scheme for the encoding of
any sized bitstring into a multiple of 5 bits in length, suitable for
direct encoding into base-32.

First the size in bits of the integer is rounded up to the next
highest power of two greater than or equal to 128. This value with a
factor of 128 removed is known as <code>n</code>, and its base-2
logorithm as <code>e</code>. Pseudocode:

    int n = max(next_power_of_two(BITS), 128) / 128;
    int e = log2(n);

A total of <code>2*n</code> padding bits are prefixed to the
bitstring. These consist of <code>e</code> 1 bits, a single 0 bit, and
<code>2*n-e-1</code> user-specified bits (the "extra" field).

The bitstring is now a multiple of 5 in length and can be directly
converted into base-32.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJTBry9AAoJEAdzVfsmodw45UwP/1kjvfFMe0I+F+0Ma+sl8o3a
U3/FlyOapIL8wZPyjXItts7/5V8kPOSPiEjnG/Oes7eBmiod2UYy+73qIHaHI6Ug
88OMjX8hSHYz+EfxrUkb8Uiios4FNS6vo/SVjELR8vLiQoJ30T4l56QMJvMle1wj
+GDdHjNfL0F9NzqA7WY1rRRXllBCmDfLUeYS3raOx9tmGgfj/4h451RLwXouIwT6
oBMBIJzkGLHi//0SF+xlNJb/zebD421qXLgg28ci0fz+bxMEtPM7HktCpHS+pzUu
V211rA3eP6/gb617SHD7XcxROubpsZ0y1ieaCzjfrQ0NUDqEkYyydDh4rf2AF99R
ODwy8bDNikhN62480Gd2PuqKftf66tUdycXMcnC9Cwe3Ejli+RKBGnTBh5ekPO3+
Pmu/vgILuL8WojOKcAnMSk0tvA+w0kBf/b7mUzLsBpJfOMxtk3KgKrWWbuxotz0C
VKGVICpvtrA87jpOqB36Hn1tFYRknCX9PCzPEENpJg/aK26xNTid4jtbg9MhopdS
GuH4SBNYvvgq7VkCbq5zggh37npgHy/mmBhAmDw7ecBPw/O9jtGEUSFbSTMoaL5s
hK5WTlsSNvvuAaFlv0qvreI1gQiJBhR9+JuZfFS1fzBXWcmDf7n8kqkbLOQr6nVJ
O6AhIj7iHRCNfSTuhElY
=ZHxf
-----END PGP SIGNATURE-----



From mike at plan99.net  Fri Feb 21 06:07:42 2014
From: mike at plan99.net (Mike Hearn)
Date: Fri, 21 Feb 2014 06:07:42 +0000
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
Message-ID: <CANEZrP1B8d4FBm9zgKSUC=o9JdeRG4K6NdV5fD9hrWsBVV--jw@mail.gmail.com>

No, I was thinking of the height in coinbase change. At any rate, p2sh was
supported by the consensus code in bitcoinj for a long time already, since
it was first written.

Support for sending to such addresses in the wallet appeared once an app
that wanted that support also appeared, which seems OK - the market for
wallets is very competitive so there will always be some skew in what
features are worked on in what order. V3 transactions are a consensus
change that wallets will pick up at different times like any other feature.
On 20 Feb 2014 19:45, "Gregory Maxwell" <gmaxwell at gmail.com> wrote:

> On Thu, Feb 20, 2014 at 6:08 AM, Mike Hearn <mike at plan99.net> wrote:
> > We've done forking changes before much faster than a year and that was
> with
> > less experience. If we want, we can get this done within months.
>
> You mean P2SH... which your implementation has only picked up support
> for in the last month or so?
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/7742db8c/attachment.html>

From jgarzik at bitpay.com  Fri Feb 21 06:09:55 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Fri, 21 Feb 2014 01:09:55 -0500
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
	blockchain engine and wallet
Message-ID: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>

[Meta: "Bitcoin Core" is the newfangled branding of bitcoind /
Bitcoin-Qt reference implementation, in case you wondering.]

Several sites, including BitPay, use bitcoind outside the standard
role of wallet software.  bitcoind can be used purely for payment
network access and management.  I call this the "border router" role.
Upcoming version 0.9 will feature the ability to disable the bitcoind
wallet at compile time or runtime. This permits a more optimized
border router profile, reducing process size by 40-200MB according to
some reports.

Recent IRC discussion have floated a rough proposal for a wallet
next-step:  Running the Bitcoin Core wallet as a separate process, a
separate binary, from the blockchain engine.  The wallet process would
communicate with the blockchain engine using existing RPC and P2P
channels, becoming a real SPV client.  This accomplishes a
longstanding security goal of sandboxing away wallet keys and
sensitive data from the network-exposed P2P engine, in a separate
process, among other benefits.

Simple forking was explored a bit.  I did some hacking in that
direction, as it seemed potentially lightweight and somewhat easy to
me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine
for Linux and OSX/BSD.  However, Windows requires an exec-like
solution to create a new process.  MSDN does give us a Unix-pipe-like
solution: http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx
 Others pointed to boost interprocess communication APIs, which come
with their own set of caveats.  Such a solution would involve a brand
new IPC protocol, and lots of brand new glue code.

Separate programs seems better.  Windows forces us to achieve process
separation via exec-like method.  We already have IPC: RPC + P2P.
Modern OS's make localhost sockets just about as fast as other IPCs
methods.  Linux, at least, employs zero-copy for localhost sockets in
many situations, similar to the kernel's pipe tricks.

Pieter has been working on headers-first sync:
https://github.com/bitcoin/bitcoin/pull/2964  Moving along this
wallet/blockchain engine split requires upping the review&test
bandwidth on Pieter's PRs, such as
https://github.com/bitcoin/bitcoin/pull/3514

Unsure how much of the separate-binary discussion Gavin saw, so cc'd
for emphasis.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From mike at plan99.net  Fri Feb 21 06:27:02 2014
From: mike at plan99.net (Mike Hearn)
Date: Fri, 21 Feb 2014 06:27:02 +0000
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
Message-ID: <CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>

Bear in mind a separate process doesn't buy you anything without a sandbox,
and those are expensive (in terms of complexity).
On 21 Feb 2014 11:40, "Jeff Garzik" <jgarzik at bitpay.com> wrote:

> [Meta: "Bitcoin Core" is the newfangled branding of bitcoind /
> Bitcoin-Qt reference implementation, in case you wondering.]
>
> Several sites, including BitPay, use bitcoind outside the standard
> role of wallet software.  bitcoind can be used purely for payment
> network access and management.  I call this the "border router" role.
> Upcoming version 0.9 will feature the ability to disable the bitcoind
> wallet at compile time or runtime. This permits a more optimized
> border router profile, reducing process size by 40-200MB according to
> some reports.
>
> Recent IRC discussion have floated a rough proposal for a wallet
> next-step:  Running the Bitcoin Core wallet as a separate process, a
> separate binary, from the blockchain engine.  The wallet process would
> communicate with the blockchain engine using existing RPC and P2P
> channels, becoming a real SPV client.  This accomplishes a
> longstanding security goal of sandboxing away wallet keys and
> sensitive data from the network-exposed P2P engine, in a separate
> process, among other benefits.
>
> Simple forking was explored a bit.  I did some hacking in that
> direction, as it seemed potentially lightweight and somewhat easy to
> me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine
> for Linux and OSX/BSD.  However, Windows requires an exec-like
> solution to create a new process.  MSDN does give us a Unix-pipe-like
> solution:
> http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx
>  Others pointed to boost interprocess communication APIs, which come
> with their own set of caveats.  Such a solution would involve a brand
> new IPC protocol, and lots of brand new glue code.
>
> Separate programs seems better.  Windows forces us to achieve process
> separation via exec-like method.  We already have IPC: RPC + P2P.
> Modern OS's make localhost sockets just about as fast as other IPCs
> methods.  Linux, at least, employs zero-copy for localhost sockets in
> many situations, similar to the kernel's pipe tricks.
>
> Pieter has been working on headers-first sync:
> https://github.com/bitcoin/bitcoin/pull/2964  Moving along this
> wallet/blockchain engine split requires upping the review&test
> bandwidth on Pieter's PRs, such as
> https://github.com/bitcoin/bitcoin/pull/3514
>
> Unsure how much of the separate-binary discussion Gavin saw, so cc'd
> for emphasis.
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/64ccb077/attachment.html>

From gmaxwell at gmail.com  Fri Feb 21 06:30:25 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 20 Feb 2014 22:30:25 -0800
Subject: [Bitcoin-development] [RFC] [BIP proposal] Dealing with
	malleability
In-Reply-To: <CANEZrP1B8d4FBm9zgKSUC=o9JdeRG4K6NdV5fD9hrWsBVV--jw@mail.gmail.com>
References: <CAPg+sBgPG+2AMbEHSRQNFn6FikbRzxkWduj5MSZLz-O6Wh940w@mail.gmail.com>
	<CALf2ePwc=es-aDSeJO2DZwu9kyHwq9dcp5TrMAhN-dvYwNjy-w@mail.gmail.com>
	<52FBD948.906@monetize.io> <201402122252.31060.luke@dashjr.org>
	<CAPWm=eV9YP3wAbCFt1JcSqJ6Jc3kY_546MVk3cHT+X8seC8vRw@mail.gmail.com>
	<CAAS2fgSwjGohhiXuwhG3bJ5mLxSS8Dx0Hytmg7PhhRzwnw7FNQ@mail.gmail.com>
	<EFA82A3F-2907-4B2B-9FCB-DCA02CA4EC63@mac.com>
	<CAPg+sBgnuNygR7_yny1=+wGWmeLcub0A8_ep3U-5ewmQJk71jw@mail.gmail.com>
	<601EE159-9022-4ADF-80AC-7E1C39E86A65@mac.com>
	<CAPg+sBg9=XK=PGSW8DcU1LR85oeTDmpS4U-vYUXbraZQpU+edg@mail.gmail.com>
	<81A62AB7-9EC6-439E-96CF-F064F0151BB9@mac.com>
	<CANEZrP26U3BjEi66xjD9SRxrAupGmYC6mKiYYw27BH3q1b1hLQ@mail.gmail.com>
	<CAAS2fgSm9o-Xz4i0_wPGPfh_108ttnNPkXtxv5hCj9CsJh=AXQ@mail.gmail.com>
	<CANEZrP1B8d4FBm9zgKSUC=o9JdeRG4K6NdV5fD9hrWsBVV--jw@mail.gmail.com>
Message-ID: <CAAS2fgS-KKEmjkKyBch4Q5QzqNuqXn5Q2KsrY86bA4G8MQJtnQ@mail.gmail.com>

On Thu, Feb 20, 2014 at 10:07 PM, Mike Hearn <mike at plan99.net> wrote:
> No, I was thinking of the height in coinbase change. At any rate, p2sh was
> supported by the consensus code in bitcoinj for a long time already, since
> it was first written.
>
> Support for sending to such addresses in the wallet appeared once an app
> that wanted that support also appeared, which seems OK - the market for
> wallets is very competitive so there will always be some skew in what
> features are worked on in what order. V3 transactions are a consensus change
> that wallets will pick up at different times like any other feature.

We're in agreement.  I had mistakenly believed you were supporting the
discussion about trying to force these constraints on current version
transactions, in which case "wallets will pick up at different times"
is an absolute deal breaker.  :)



From laanwj at gmail.com  Fri Feb 21 06:43:36 2014
From: laanwj at gmail.com (Wladimir)
Date: Fri, 21 Feb 2014 07:43:36 +0100
Subject: [Bitcoin-development] Fwd: Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
Message-ID: <CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>

On Fri, Feb 21, 2014 at 7:27 AM, Mike Hearn <mike at plan99.net> wrote:

> Bear in mind a separate process doesn't buy you anything without a
> sandbox, and those are expensive (in terms of complexity).
>
Sandboxing in user space is complex, agreed,

The most straightforward way would be to run the blockchain daemon as a
system service (with its own uid/gid and set of Apparmor/SELinux
restrictions) and the wallet daemon as the user.

This would also allow sharing one blockchain daemon between multiple users
and wallet processes (not necessarily on the same machine), something I've
wanted to be able to do for a long time.

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/b96c1925/attachment.html>

From will.yager at gmail.com  Fri Feb 21 06:50:01 2014
From: will.yager at gmail.com (William Yager)
Date: Fri, 21 Feb 2014 00:50:01 -0600
Subject: [Bitcoin-development] Fwd: Bitcoin Core trial balloon:
	splitting blockchain engine and wallet
In-Reply-To: <CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
	<CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
Message-ID: <AB055C1C-76B1-4CE3-B92E-253C1C9541F6@gmail.com>

Running the network part of the core as a system service might make sense for server implementations, but it?s a pain in the rear for most users. 

That said, I think segregating the two processes is a great idea. Let?s just try to avoid some complicated scheme that involves necessarily running things under multiple users.

Will

On Feb 21, 2014, at 0:43, Wladimir <laanwj at gmail.com> wrote:

> The most straightforward way would be to run the blockchain daemon as a system service (with its own uid/gid and set of Apparmor/SELinux restrictions) and the wallet daemon as the user.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/65630db5/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/65630db5/attachment.sig>

From jgarzik at bitpay.com  Fri Feb 21 06:50:35 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Fri, 21 Feb 2014 01:50:35 -0500
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
Message-ID: <CAJHLa0Pfc5wfGT6Rk3ZoRS-rE8Cw6AaRXDyxUCOjAYUesoCxJg@mail.gmail.com>

RE "doesn't buy you anything"   Today, when unlocked, plaintext
private keys reside in the same address space as the blockchain engine
(BCE).  Process separation increases the difficulty of accessing key
data from the BCE, even presuming a normal, no-chroot, same-uid,
parent-child process relationship.  The attack surface is clearly
changed from "one buffer overflow can touch this data."

Regardless, the split makes sense given existing modularity and coding
directions.  I wouldn't micro-focus on the "sandbox" word.

On Fri, Feb 21, 2014 at 1:27 AM, Mike Hearn <mike at plan99.net> wrote:
> Bear in mind a separate process doesn't buy you anything without a sandbox,
> and those are expensive (in terms of complexity).
>
> On 21 Feb 2014 11:40, "Jeff Garzik" <jgarzik at bitpay.com> wrote:
>>
>> [Meta: "Bitcoin Core" is the newfangled branding of bitcoind /
>> Bitcoin-Qt reference implementation, in case you wondering.]
>>
>> Several sites, including BitPay, use bitcoind outside the standard
>> role of wallet software.  bitcoind can be used purely for payment
>> network access and management.  I call this the "border router" role.
>> Upcoming version 0.9 will feature the ability to disable the bitcoind
>> wallet at compile time or runtime. This permits a more optimized
>> border router profile, reducing process size by 40-200MB according to
>> some reports.
>>
>> Recent IRC discussion have floated a rough proposal for a wallet
>> next-step:  Running the Bitcoin Core wallet as a separate process, a
>> separate binary, from the blockchain engine.  The wallet process would
>> communicate with the blockchain engine using existing RPC and P2P
>> channels, becoming a real SPV client.  This accomplishes a
>> longstanding security goal of sandboxing away wallet keys and
>> sensitive data from the network-exposed P2P engine, in a separate
>> process, among other benefits.
>>
>> Simple forking was explored a bit.  I did some hacking in that
>> direction, as it seemed potentially lightweight and somewhat easy to
>> me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine
>> for Linux and OSX/BSD.  However, Windows requires an exec-like
>> solution to create a new process.  MSDN does give us a Unix-pipe-like
>> solution:
>> http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx
>>  Others pointed to boost interprocess communication APIs, which come
>> with their own set of caveats.  Such a solution would involve a brand
>> new IPC protocol, and lots of brand new glue code.
>>
>> Separate programs seems better.  Windows forces us to achieve process
>> separation via exec-like method.  We already have IPC: RPC + P2P.
>> Modern OS's make localhost sockets just about as fast as other IPCs
>> methods.  Linux, at least, employs zero-copy for localhost sockets in
>> many situations, similar to the kernel's pipe tricks.
>>
>> Pieter has been working on headers-first sync:
>> https://github.com/bitcoin/bitcoin/pull/2964  Moving along this
>> wallet/blockchain engine split requires upping the review&test
>> bandwidth on Pieter's PRs, such as
>> https://github.com/bitcoin/bitcoin/pull/3514
>>
>> Unsure how much of the separate-binary discussion Gavin saw, so cc'd
>> for emphasis.
>>
>> --
>> Jeff Garzik
>> Bitcoin core developer and open source evangelist
>> BitPay, Inc.      https://bitpay.com/
>>
>>
>> ------------------------------------------------------------------------------
>> Managing the Performance of Cloud-Based Applications
>> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
>> Read the Whitepaper.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From laanwj at gmail.com  Fri Feb 21 06:54:01 2014
From: laanwj at gmail.com (Wladimir)
Date: Fri, 21 Feb 2014 07:54:01 +0100
Subject: [Bitcoin-development] Fwd: Bitcoin Core trial balloon:
 splitting blockchain engine and wallet
In-Reply-To: <AB055C1C-76B1-4CE3-B92E-253C1C9541F6@gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
	<CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
	<AB055C1C-76B1-4CE3-B92E-253C1C9541F6@gmail.com>
Message-ID: <CA+s+GJC+1Dxa1bJ_CBQjZ6x=hb6yKbe9x3c6haQDzQvhkbYJOg@mail.gmail.com>

On Fri, Feb 21, 2014 at 7:50 AM, William Yager <will.yager at gmail.com> wrote:

> Running the network part of the core as a system service might make sense
> for server implementations, but it?s a pain in the rear for most users.
>

Come on, making it a possibility doesn't affect other kinds of use cases in
any way. Are you just arguing for the sake of arguing?

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/d393af47/attachment.html>

From mike at plan99.net  Fri Feb 21 10:41:06 2014
From: mike at plan99.net (Mike Hearn)
Date: Fri, 21 Feb 2014 16:11:06 +0530
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <CAJHLa0Pfc5wfGT6Rk3ZoRS-rE8Cw6AaRXDyxUCOjAYUesoCxJg@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CAJHLa0Pfc5wfGT6Rk3ZoRS-rE8Cw6AaRXDyxUCOjAYUesoCxJg@mail.gmail.com>
Message-ID: <CANEZrP3x368f66LyZr_Kfp=4JULqxUn_6eDCEzc_ALe20xZYJQ@mail.gmail.com>

I'm not sure it does really - typical C/C++ exploits let you run arbitrary
code, at which point you can quite easily ptrace the other process and do
whatever you want with it, or read /proc/pid/mem etc. But process
separation is certainly a prerequisite for sandboxing so I'm not arguing
against such a change, just pointing out that it requires some work to
really get the benefits. Also an SPV Bitcoin Core would obviously be of
tremendous utility all by itself ...


On Fri, Feb 21, 2014 at 12:20 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:

> RE "doesn't buy you anything"   Today, when unlocked, plaintext
> private keys reside in the same address space as the blockchain engine
> (BCE).  Process separation increases the difficulty of accessing key
> data from the BCE, even presuming a normal, no-chroot, same-uid,
> parent-child process relationship.  The attack surface is clearly
> changed from "one buffer overflow can touch this data."
>
> Regardless, the split makes sense given existing modularity and coding
> directions.  I wouldn't micro-focus on the "sandbox" word.
>
> On Fri, Feb 21, 2014 at 1:27 AM, Mike Hearn <mike at plan99.net> wrote:
> > Bear in mind a separate process doesn't buy you anything without a
> sandbox,
> > and those are expensive (in terms of complexity).
> >
> > On 21 Feb 2014 11:40, "Jeff Garzik" <jgarzik at bitpay.com> wrote:
> >>
> >> [Meta: "Bitcoin Core" is the newfangled branding of bitcoind /
> >> Bitcoin-Qt reference implementation, in case you wondering.]
> >>
> >> Several sites, including BitPay, use bitcoind outside the standard
> >> role of wallet software.  bitcoind can be used purely for payment
> >> network access and management.  I call this the "border router" role.
> >> Upcoming version 0.9 will feature the ability to disable the bitcoind
> >> wallet at compile time or runtime. This permits a more optimized
> >> border router profile, reducing process size by 40-200MB according to
> >> some reports.
> >>
> >> Recent IRC discussion have floated a rough proposal for a wallet
> >> next-step:  Running the Bitcoin Core wallet as a separate process, a
> >> separate binary, from the blockchain engine.  The wallet process would
> >> communicate with the blockchain engine using existing RPC and P2P
> >> channels, becoming a real SPV client.  This accomplishes a
> >> longstanding security goal of sandboxing away wallet keys and
> >> sensitive data from the network-exposed P2P engine, in a separate
> >> process, among other benefits.
> >>
> >> Simple forking was explored a bit.  I did some hacking in that
> >> direction, as it seemed potentially lightweight and somewhat easy to
> >> me: https://github.com/jgarzik/bitcoin/tree/fork  fork+pipe is fine
> >> for Linux and OSX/BSD.  However, Windows requires an exec-like
> >> solution to create a new process.  MSDN does give us a Unix-pipe-like
> >> solution:
> >> http://msdn.microsoft.com/en-us/library/edze9h7e%28v=vs.80%29.aspx
> >>  Others pointed to boost interprocess communication APIs, which come
> >> with their own set of caveats.  Such a solution would involve a brand
> >> new IPC protocol, and lots of brand new glue code.
> >>
> >> Separate programs seems better.  Windows forces us to achieve process
> >> separation via exec-like method.  We already have IPC: RPC + P2P.
> >> Modern OS's make localhost sockets just about as fast as other IPCs
> >> methods.  Linux, at least, employs zero-copy for localhost sockets in
> >> many situations, similar to the kernel's pipe tricks.
> >>
> >> Pieter has been working on headers-first sync:
> >> https://github.com/bitcoin/bitcoin/pull/2964  Moving along this
> >> wallet/blockchain engine split requires upping the review&test
> >> bandwidth on Pieter's PRs, such as
> >> https://github.com/bitcoin/bitcoin/pull/3514
> >>
> >> Unsure how much of the separate-binary discussion Gavin saw, so cc'd
> >> for emphasis.
> >>
> >> --
> >> Jeff Garzik
> >> Bitcoin core developer and open source evangelist
> >> BitPay, Inc.      https://bitpay.com/
> >>
> >>
> >>
> ------------------------------------------------------------------------------
> >> Managing the Performance of Cloud-Based Applications
> >> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> >> Read the Whitepaper.
> >>
> >>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> >> _______________________________________________
> >> Bitcoin-development mailing list
> >> Bitcoin-development at lists.sourceforge.net
> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/d754e4fd/attachment.html>

From pete at petertodd.org  Fri Feb 21 11:06:02 2014
From: pete at petertodd.org (Peter Todd)
Date: Fri, 21 Feb 2014 06:06:02 -0500
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <CANEZrP3x368f66LyZr_Kfp=4JULqxUn_6eDCEzc_ALe20xZYJQ@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CAJHLa0Pfc5wfGT6Rk3ZoRS-rE8Cw6AaRXDyxUCOjAYUesoCxJg@mail.gmail.com>
	<CANEZrP3x368f66LyZr_Kfp=4JULqxUn_6eDCEzc_ALe20xZYJQ@mail.gmail.com>
Message-ID: <20140221110602.GA29940@savin>

On Fri, Feb 21, 2014 at 04:11:06PM +0530, Mike Hearn wrote:
> On Fri, Feb 21, 2014 at 12:20 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:
> 
> > RE "doesn't buy you anything"   Today, when unlocked, plaintext
> > private keys reside in the same address space as the blockchain engine
> > (BCE).  Process separation increases the difficulty of accessing key
> > data from the BCE, even presuming a normal, no-chroot, same-uid,
> > parent-child process relationship.  The attack surface is clearly
> > changed from "one buffer overflow can touch this data."
> >
> > Regardless, the split makes sense given existing modularity and coding
> > directions.  I wouldn't micro-focus on the "sandbox" word.
>
> I'm not sure it does really - typical C/C++ exploits let you run arbitrary
> code, at which point you can quite easily ptrace the other process and do
> whatever you want with it, or read /proc/pid/mem etc. But process
> separation is certainly a prerequisite for sandboxing so I'm not arguing
> against such a change, just pointing out that it requires some work to
> really get the benefits. Also an SPV Bitcoin Core would obviously be of
> tremendous utility all by itself ...

The seccomp mechanism would work well here - it's a syscall whitelister,
which makes ptrace useless, among other things. Used by Chrome as of v23
to sandbox the renderers.

We'd probably need to use it with chroot and whitelist the open() call
so that the existing code can create new blockfiles and do whatever
leveldb does.

-- 
'peter'[:-1]@petertodd.org
000000000000000112c53364597954e79cc38f1ba7826a6420ad22a6f3be2932
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/28b1def7/attachment.sig>

From mike at plan99.net  Fri Feb 21 15:34:31 2014
From: mike at plan99.net (Mike Hearn)
Date: Fri, 21 Feb 2014 21:04:31 +0530
Subject: [Bitcoin-development] BIP70 proposed changes
In-Reply-To: <5303B110.70603@bitpay.com>
References: <le05ca$qn5$1@ger.gmane.org>
	<5303B110.70603@bitpay.com>
Message-ID: <CANEZrP25u1V2rv_XM1pKzxm4YvUec89Vf1OmVujJLFBzEmmbXA@mail.gmail.com>

>
> One more thing. The new bitcoin URI in BIP 72 is extremely long and
> makes for very dense QR codes.


BIP 73 seems OK except that existing wallets that can scan QR codes will
choke. One reason the new URIs are long is for backwards compatibility.

One thing that makes the URI smaller is not escaping the payment URL -
bitcoinj/Bitcoin Wallet at least does not require it, and it reduces the
size of the QR code by a non-trivial amount.

Removing the https:// and just defaulting to it also saves some bytes.

Finally, BitPay is using rather long invoice IDs. Do you really need an ID
like JkLdFhQVFqmUurXpPXZcRp? That's a really huge ID space and the invoices
expire fast. So you could potentially implement a short mapping on the
server side and make much smaller IDs that way.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/353ad9f4/attachment.html>

From dtrammell at dustintrammell.com  Sat Feb 22 01:09:00 2014
From: dtrammell at dustintrammell.com (Dustin D. Trammell)
Date: Fri, 21 Feb 2014 19:09:00 -0600
Subject: [Bitcoin-development] Fwd: Bitcoin Core trial balloon:
 splitting blockchain engine and wallet
In-Reply-To: <CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
	<CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
Message-ID: <1393031340.6897.90.camel@staypuft>

On Fri, 2014-02-21 at 07:43 +0100, Wladimir wrote:
> The most straightforward way would be to run the blockchain daemon as
> a system service (with its own uid/gid and set of Apparmor/SELinux
> restrictions) and the wallet daemon as the user.

This assumes you as a user have the rights to do so.  This would be
preferred, but in some cases may not be possible.  Perhaps it should be
optional?

> This would also allow sharing one blockchain daemon between multiple
> users and wallet processes (not necessarily on the same machine),
> something I've wanted to be able to do for a long time.

Agreed (:

-- 
Dustin D. Trammell
dtrammell at dustintrammell.com
http://www.dustintrammell.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: This is a digitally signed message part
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/9cc5f046/attachment.sig>

From dtrammell at dustintrammell.com  Sat Feb 22 01:04:12 2014
From: dtrammell at dustintrammell.com (Dustin D. Trammell)
Date: Fri, 21 Feb 2014 19:04:12 -0600
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
Message-ID: <1393031052.6897.89.camel@staypuft>

On Fri, 2014-02-21 at 01:09 -0500, Jeff Garzik wrote:
> Recent IRC discussion have floated a rough proposal for a wallet
> next-step:  Running the Bitcoin Core wallet as a separate process, a
> separate binary, from the blockchain engine.  The wallet process would
> communicate with the blockchain engine using existing RPC and P2P
> channels, becoming a real SPV client.  This accomplishes a
> longstanding security goal of sandboxing away wallet keys and
> sensitive data from the network-exposed P2P engine, in a separate
> process, among other benefits.

PLEASE.

For those of us that prefer the reference software and also manage
multiple wallets, having to store a copy of the blockchain for each one
eats up disk space quite quickly.  If I could run a local blockchain
server (or a local network one, even) and then have whichever wallet I
start up use that instead of maintain its own copy of the blockchain, my
world would be much, much happier.

Sandboxing keys and sensitive wallet data away from the attack surface
introduced by the network interfaces into another separate process is
also a good security move.  Don't forget to sanitize your IPC inputs (:

Thanks,

-- 
Dustin D. Trammell
dtrammell at dustintrammell.com
http://www.dustintrammell.com
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: This is a digitally signed message part
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/c850e81c/attachment.sig>

From jgarzik at bitpay.com  Sat Feb 22 02:08:19 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Fri, 21 Feb 2014 21:08:19 -0500
Subject: [Bitcoin-development] Bitcoin Core trial balloon: splitting
 blockchain engine and wallet
In-Reply-To: <1393031052.6897.89.camel@staypuft>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<1393031052.6897.89.camel@staypuft>
Message-ID: <CAJHLa0OwtCja6XgmyVkiur9VtLdJ5Ra-F4R-ocpThyBVWrNHow@mail.gmail.com>

On Fri, Feb 21, 2014 at 8:04 PM, Dustin D. Trammell
<dtrammell at dustintrammell.com> wrote:
> For those of us that prefer the reference software and also manage
> multiple wallets, having to store a copy of the blockchain for each one
> eats up disk space quite quickly.  If I could run a local blockchain
> server (or a local network one, even) and then have whichever wallet I
> start up use that instead of maintain its own copy of the blockchain, my
> world would be much, much happier.

You mean running multiple wallets simultaneously?  Agreed.

Multiple wallets, used serially, works fine today.  I manage multiple
wallets using symlink replacement.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From ronald.hoffman6 at gmail.com  Sat Feb 22 02:56:10 2014
From: ronald.hoffman6 at gmail.com (Ronald Hoffman)
Date: Fri, 21 Feb 2014 21:56:10 -0500
Subject: [Bitcoin-development] getpeerinfo results
Message-ID: <CAARg+Ed-bWCSHYQqSu=UqU3WscpjF1ewQYArSB4wdM7dWUW-=A@mail.gmail.com>

I noticed that the 'services' field appears to be garbled in the latest
source code level from github.  Bitcoind is connected to my Java node
server at 127.0.0.1:8333.  I thought I was sending a bad 'version' message
but I get the correct results using 0.8.6.  So it appears that something
changed in 0.9.0.

Here is bitcoin-cli talking to bitcoind (0.9.0)

$ bitcoin-cli getpeerinfo
[
    {
        "addr" : "127.0.0.1:8333",
        "services" : "0000000164x",
        "lastsend" : 1393036635,
        "lastrecv" : 1393036635,
        "bytessent" : 100169,
        "bytesrecv" : 53633565,
        "conntime" : 1393036133,
        "pingtime" : 0.00000000,
        "version" : 70002,
        "subver" : "/JavaBitcoin:1.0/",
        "inbound" : false,
        "startingheight" : 287125,
        "banscore" : 0,
        "syncnode" : true
    }
]

Here is the same bitcoin-cli talking to bidcoind (0.8.6)

$ bitcoin-cli getpeerinfo
[
    {
        "addr" : "127.0.0.1:8333",
        "services" : "00000001",
        "lastsend" : 1393037165,
        "lastrecv" : 1393037165,
        "bytessent" : 77494,
        "bytesrecv" : 13054,
        "conntime" : 1393037135,
        "version" : 70002,
        "subver" : "/JavaBitcoin:1.0/",
        "inbound" : false,
        "startingheight" : 287126,
        "banscore" : 0,
        "syncnode" : true
    }
]

Ron
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140221/1acd415c/attachment.html>

From laanwj at gmail.com  Sat Feb 22 06:53:33 2014
From: laanwj at gmail.com (Wladimir)
Date: Sat, 22 Feb 2014 07:53:33 +0100
Subject: [Bitcoin-development] Fwd: Bitcoin Core trial balloon:
 splitting blockchain engine and wallet
In-Reply-To: <1393031340.6897.90.camel@staypuft>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
	<CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
	<1393031340.6897.90.camel@staypuft>
Message-ID: <CA+s+GJD=-Y5e7jfBt8Ced-2wXkjYcODBKrre2jqT-k-tQO8fCQ@mail.gmail.com>

On Sat, Feb 22, 2014 at 2:09 AM, Dustin D. Trammell <
dtrammell at dustintrammell.com> wrote:

> On Fri, 2014-02-21 at 07:43 +0100, Wladimir wrote:
> > The most straightforward way would be to run the blockchain daemon as
> > a system service (with its own uid/gid and set of Apparmor/SELinux
> > restrictions) and the wallet daemon as the user.
>
> This assumes you as a user have the rights to do so.  This would be
> preferred, but in some cases may not be possible.  Perhaps it should be
> optional?
>

No! I'm proposing that we force everyone to do it. Using all means
necessary. There should be regular audits that everyone is running the
software exactly in my configuration, and if not, a special task force will
take care that spankings are carried out on the spot.

Repeated offenders will lose their BitLicense.
</s>

Please stop kicking this dead horse. It was just a random idea. Maybe a way
how Linux distributions could structure it, but it may or may not apply in
your case. And that's fine, this is free software development, you can do
whatever you want!

Let's try to bring this discussion back to its original intention: for
anyone that wants to concretely help this along, please help reviewing and
testing the pull requests that jgarzik mentions.

Wladimir
BTW: All of those patches are helpful for monolithic-bitcoind as well as
they (lay the groundwork for) speeding up block synchronization.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140222/b0c5a3ef/attachment.html>

From laanwj at gmail.com  Sat Feb 22 08:08:43 2014
From: laanwj at gmail.com (Wladimir)
Date: Sat, 22 Feb 2014 09:08:43 +0100
Subject: [Bitcoin-development] getpeerinfo results
In-Reply-To: <CAARg+Ed-bWCSHYQqSu=UqU3WscpjF1ewQYArSB4wdM7dWUW-=A@mail.gmail.com>
References: <CAARg+Ed-bWCSHYQqSu=UqU3WscpjF1ewQYArSB4wdM7dWUW-=A@mail.gmail.com>
Message-ID: <CA+s+GJA=bgC60N-RUhiPBt36XVfpWghQp-uzQozACWMwxJbNRg@mail.gmail.com>

On Sat, Feb 22, 2014 at 3:56 AM, Ronald Hoffman
<ronald.hoffman6 at gmail.com>wrote:

> I noticed that the 'services' field appears to be garbled in the latest
> source code level from github.  Bitcoind is connected to my Java node
> server at 127.0.0.1:8333.  I thought I was sending a bad 'version'
> message but I get the correct results using 0.8.6.  So it appears that
> something changed in 0.9.0.
>

This warrants an issue on github:
https://github.com/bitcoin/bitcoin/issues/new


> Here is bitcoin-cli talking to bitcoind (0.9.0)
>
> $ bitcoin-cli getpeerinfo
> [
>     {
>         "addr" : "127.0.0.1:8333",
>         "services" : "0000000164x",
>

What git revision are you testing with? Built with what compiler on which
platform?

Do all peers in getpeerinfo show up garbled, or just yours? Does it
literally show as "164x"?

I just tried getpeerinfo locally and all my peers show as: ""services" :
"00000001" as expected.

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140222/87ec0606/attachment.html>

From laanwj at gmail.com  Sat Feb 22 08:54:14 2014
From: laanwj at gmail.com (Wladimir)
Date: Sat, 22 Feb 2014 09:54:14 +0100
Subject: [Bitcoin-development] getpeerinfo results
In-Reply-To: <CA+s+GJA=bgC60N-RUhiPBt36XVfpWghQp-uzQozACWMwxJbNRg@mail.gmail.com>
References: <CAARg+Ed-bWCSHYQqSu=UqU3WscpjF1ewQYArSB4wdM7dWUW-=A@mail.gmail.com>
	<CA+s+GJA=bgC60N-RUhiPBt36XVfpWghQp-uzQozACWMwxJbNRg@mail.gmail.com>
Message-ID: <CA+s+GJAc9=UzCVb+QRTCQzQVDUQRNUkNFCiF_MeeR-woOEvokg@mail.gmail.com>

On Sat, Feb 22, 2014 at 9:08 AM, Wladimir <laanwj at gmail.com> wrote:

> On Sat, Feb 22, 2014 at 3:56 AM, Ronald Hoffman <ronald.hoffman6 at gmail.com
> > wrote:
>
>> I noticed that the 'services' field appears to be garbled in the latest
>> source code level from github.  Bitcoind is connected to my Java node
>> server at 127.0.0.1:8333.  I thought I was sending a bad 'version'
>> message but I get the correct results using 0.8.6.  So it appears that
>> something changed in 0.9.0.
>>
>
> This warrants an issue on github:
> https://github.com/bitcoin/bitcoin/issues/new
>

I think I found (and fixed) the problem already. This is some windows
inttypes.h bordercase. Can you test with this?:

https://github.com/bitcoin/bitcoin/pull/3729

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140222/c9c37e5f/attachment.html>

From jgarzik at bitpay.com  Mon Feb 24 16:03:04 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 24 Feb 2014 11:03:04 -0500
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
Message-ID: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>

An update in forthcoming 0.9 release includes a change to make
OP_RETURN standard, permitted a small amount of metadata to be
attached to a transaction:
https://github.com/bitcoin/bitcoin/pull/2738

There was always going to be some level of controversy attached to
this.  However, some issues, perceptions and questions are bubbling
up, and it seemed fair to cover them on the list, not just IRC.

1) FAQ:  Why 80 bytes of data?  This is the leading programmer
question, and it was not really documented well at all.  Simple
answer:  2x SHA256 or 1x SHA512, plus some tiny bit of metadata.  Some
schemes are of the nature "BOND<hash>" rather than just plain hash.
A common IRC proposal seems to lean towards reducing that from 80.
I'll leave it to the crowd to argue about size from there. I do think
regular transactions should have the ability to include some metadata.

2) Endorsement of chain data storage.  Listening to bitcoin conference
corridor discussions, reading forum posts and the occasional article
have over-simplified the situation to "core devs endorse data storage
over blockchain!  let me start uploading my naughty movie collection!
IM over blockchain, woo hoo!"

Nothing could be further from the truth.  It's a way to make data
/less damaging/, not an endorsement of data storage in chain as a good
idea.  MasterCoin and other projects were doing -even worse- things,
such as storing data in forever-unspendable TX outputs, bloating the
UTXO for eternity.

It seems reasonable to have a release note to this effect in the 0.9
release announcement, IMO.

-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From pieter.wuille at gmail.com  Mon Feb 24 16:16:32 2014
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 24 Feb 2014 17:16:32 +0100
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
Message-ID: <CAPg+sBi0ehdE4TszJGYNBcY0VNJtDNsOfOuaz+QpH9fBjr5z7g@mail.gmail.com>

On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:

> I do think
> regular transactions should have the ability to include some metadata.

and

> 2) Endorsement of chain data storage.
>
> Nothing could be further from the truth.

These two statements are in direct contradiction with each other.

-- 
Pieter



From jgarzik at bitpay.com  Mon Feb 24 16:32:52 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 24 Feb 2014 11:32:52 -0500
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAPg+sBi0ehdE4TszJGYNBcY0VNJtDNsOfOuaz+QpH9fBjr5z7g@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CAPg+sBi0ehdE4TszJGYNBcY0VNJtDNsOfOuaz+QpH9fBjr5z7g@mail.gmail.com>
Message-ID: <CAJHLa0Nwyfs_VJcGeSEgix5wb00LfpDGmdS4u378+XO8QKwiJA@mail.gmail.com>

Not really -- a MasterCoin transaction or JPEG

On Mon, Feb 24, 2014 at 11:16 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:
>
>> I do think
>> regular transactions should have the ability to include some metadata.
>
> and
>
>> 2) Endorsement of chain data storage.
>>
>> Nothing could be further from the truth.
>
> These two statements are in direct contradiction with each other.
>
> --
> Pieter



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From jgarzik at bitpay.com  Mon Feb 24 16:33:27 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 24 Feb 2014 11:33:27 -0500
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAPg+sBi0ehdE4TszJGYNBcY0VNJtDNsOfOuaz+QpH9fBjr5z7g@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CAPg+sBi0ehdE4TszJGYNBcY0VNJtDNsOfOuaz+QpH9fBjr5z7g@mail.gmail.com>
Message-ID: <CAJHLa0OxO=nABzVOqg4QB4Rj8Rtv1JJXWxQcgw65m71KneACig@mail.gmail.com>

(fscking 'send' hotkey in GMail)

Not really - a MasterCoin or JPEG image transaction is not a "regular"
transaction.

On Mon, Feb 24, 2014 at 11:16 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:
>
>> I do think
>> regular transactions should have the ability to include some metadata.
>
> and
>
>> 2) Endorsement of chain data storage.
>>
>> Nothing could be further from the truth.
>
> These two statements are in direct contradiction with each other.
>
> --
> Pieter



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From laanwj at gmail.com  Mon Feb 24 16:39:37 2014
From: laanwj at gmail.com (Wladimir)
Date: Mon, 24 Feb 2014 17:39:37 +0100
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
Message-ID: <CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>

On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:

> A common IRC proposal seems to lean towards reducing that from 80.
> I'll leave it to the crowd to argue about size from there. I do think
> regular transactions should have the ability to include some metadata.
>

I'd be in favor of bringing it down to 40 for 0.9.

That'd be enough for <8 byte header/identifier><32 byte hash>.

80, as the standard line length, is almost asking for "insert your graffiti
message here". I also see no need for 64 bytes hashes such as SHA512 in the
context of bitcoin, as that only offers 256-bit security (at most) in the
first place.

And if this is not abused, these kind of transactions become popular, and
more space is really needed, the limit can always be increased in a future
version.

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/4ca2e66e/attachment.html>

From gavinandresen at gmail.com  Mon Feb 24 16:45:16 2014
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Mon, 24 Feb 2014 11:45:16 -0500
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
Message-ID: <CABsx9T1qrmgu7nBF4yOsFfUjMrqpGK-J_GeCqWswZskO59B0ZA@mail.gmail.com>

40 bytes is small enough to never require an OP_PUSHDATA1, too, which will
make writing the OP_RETURN-as-standard BIP simpler.


On Mon, Feb 24, 2014 at 11:39 AM, Wladimir <laanwj at gmail.com> wrote:

>
> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:
>
>> A common IRC proposal seems to lean towards reducing that from 80.
>> I'll leave it to the crowd to argue about size from there. I do think
>> regular transactions should have the ability to include some metadata.
>>
>
> I'd be in favor of bringing it down to 40 for 0.9.
>
> That'd be enough for <8 byte header/identifier><32 byte hash>.
>
> 80, as the standard line length, is almost asking for "insert your
> graffiti message here". I also see no need for 64 bytes hashes such as
> SHA512 in the context of bitcoin, as that only offers 256-bit security (at
> most) in the first place.
>
> And if this is not abused, these kind of transactions become popular, and
> more space is really needed, the limit can always be increased in a future
> version.
>
> Wladimir
>



-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/9c038dc0/attachment.html>

From stick at gk2.sk  Mon Feb 24 16:50:09 2014
From: stick at gk2.sk (Pavol Rusnak)
Date: Mon, 24 Feb 2014 17:50:09 +0100
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CABsx9T1qrmgu7nBF4yOsFfUjMrqpGK-J_GeCqWswZskO59B0ZA@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
	<CABsx9T1qrmgu7nBF4yOsFfUjMrqpGK-J_GeCqWswZskO59B0ZA@mail.gmail.com>
Message-ID: <530B7841.9010200@gk2.sk>

On 02/24/2014 05:45 PM, Gavin Andresen wrote:
> 40 bytes is small enough to never require an OP_PUSHDATA1, too

So are 75 bytes. (I'm not trying to push anything. Just saying ...)

-- 
Best Regards / S pozdravom,

Pavol Rusnak <stick at gk2.sk>



From jgarzik at bitpay.com  Mon Feb 24 17:10:26 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 24 Feb 2014 12:10:26 -0500
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
Message-ID: <CAJHLa0NP-78iK7dpB96YnJ0D3VftaahvZ1k4U0ziV-jAUKqdFQ@mail.gmail.com>

This PR reduces the size to 40 bytes:
https://github.com/bitcoin/bitcoin/pull/3737

(Note - this is not intended to close the discussion... please do keep
sending in feedback)

On Mon, Feb 24, 2014 at 11:03 AM, Jeff Garzik <jgarzik at bitpay.com> wrote:
> An update in forthcoming 0.9 release includes a change to make
> OP_RETURN standard, permitted a small amount of metadata to be
> attached to a transaction:
> https://github.com/bitcoin/bitcoin/pull/2738
>
> There was always going to be some level of controversy attached to
> this.  However, some issues, perceptions and questions are bubbling
> up, and it seemed fair to cover them on the list, not just IRC.
>
> 1) FAQ:  Why 80 bytes of data?  This is the leading programmer
> question, and it was not really documented well at all.  Simple
> answer:  2x SHA256 or 1x SHA512, plus some tiny bit of metadata.  Some
> schemes are of the nature "BOND<hash>" rather than just plain hash.
> A common IRC proposal seems to lean towards reducing that from 80.
> I'll leave it to the crowd to argue about size from there. I do think
> regular transactions should have the ability to include some metadata.
>
> 2) Endorsement of chain data storage.  Listening to bitcoin conference
> corridor discussions, reading forum posts and the occasional article
> have over-simplified the situation to "core devs endorse data storage
> over blockchain!  let me start uploading my naughty movie collection!
> IM over blockchain, woo hoo!"
>
> Nothing could be further from the truth.  It's a way to make data
> /less damaging/, not an endorsement of data storage in chain as a good
> idea.  MasterCoin and other projects were doing -even worse- things,
> such as storing data in forever-unspendable TX outputs, bloating the
> UTXO for eternity.
>
> It seems reasonable to have a release note to this effect in the 0.9
> release announcement, IMO.
>
> --
> Jeff Garzik
> Bitcoin core developer and open source evangelist
> BitPay, Inc.      https://bitpay.com/



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From mark at monetize.io  Mon Feb 24 17:23:12 2014
From: mark at monetize.io (Mark Friedenbach)
Date: Mon, 24 Feb 2014 09:23:12 -0800
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
Message-ID: <530B8000.1070801@monetize.io>

Given our standardization on 128-bit security / 256-bit primitives, I
can't think of any crypto related data payload which requires more than
40 bytes. Even DER encoded compressed public keys will fit in there. A
signature won't fit, but why would you need one in there?

There's no need to design for 64-byte hashes, and the 80-char line
length comparison is a good point. As an Engineer I'd want to have a
little more room as a 32-byte hash or EC point + 8 bytes identifying
prefix data is the bare minimum, but it is also very important that we
send a message: This is for payment related applications like stealth
addresses only. Don't burden everybody by putting your junk on the block
chain.

On 02/24/2014 08:39 AM, Wladimir wrote:
> 
> On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com
> <mailto:jgarzik at bitpay.com>> wrote:
> 
>     A common IRC proposal seems to lean towards reducing that from 80.
>     I'll leave it to the crowd to argue about size from there. I do think
>     regular transactions should have the ability to include some metadata.
> 
> 
> I'd be in favor of bringing it down to 40 for 0.9.
> 
> That'd be enough for <8 byte header/identifier><32 byte hash>.
> 
> 80, as the standard line length, is almost asking for "insert your
> graffiti message here". I also see no need for 64 bytes hashes such as
> SHA512 in the context of bitcoin, as that only offers 256-bit security
> (at most) in the first place.
> 
> And if this is not abused, these kind of transactions become popular,
> and more space is really needed, the limit can always be increased in a
> future version.
> 
> Wladimir
> 
> 
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> 
> 
> 
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 



From stephane at kill-bill.org  Mon Feb 24 18:04:21 2014
From: stephane at kill-bill.org (Stephane Brossier)
Date: Mon, 24 Feb 2014 10:04:21 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
Message-ID: <81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>

Mike,


Just want to follow up with you and the community in general regarding the BIP0070 extension for recurring billing. At this point we have a working prototype that we checked-in in our fork of bitcoinj (https://github.com/killbill/bitcoinj). We tested it by extending the php 'payment server' from Gavin which we also check-in in a fork (https://github.com/killbill/paymentrequest). I think it does not make much sense from our side to invest more efforts until we hear some feedbacks.

Once we agree/integrate any feedbacks you guys may have-- a proposal for next steps would be:
* Turn that into a actual BIP so as to detail how that works, 
* Write some more serious unit tests
* Merge back code into bitconj trunk

Down the line write the C++ code, but of course that would assume BIP0070 is also implemented in C++ as we rely on it.

I understand you guys may have more important matters to solve these days with the recent malleability issue, but i want to make it clear that we are waiting for feedbacks to make additional progress.

Thanks!

S.




On Feb 14, 2014, at 12:28 PM, Stephane Brossier <stephane at kill-bill.org> wrote:

> Kevin,
> 
> We did a second iteration on the prototype to implement subscription cancellation and upgrade/downgrade. We checked in both the bitcoinj and php server to be able to test it.
> We also worked on our side of the merchant implementation (Kill Bill) to feel confident that the protocol will support advanced business cases. At this point it is looking promising, but more work is needed to conclude.
> 
> We wanted to follow up on a few pervious points you raised:
> 
> > However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.
> 
> From our merchant side (Kill Bill), we do indeed use this field to report successes or errors. Maybe it would be useful to extend PaymentACK with a boolean success field (so the wallet doesn't commit the transaction in case of failures)?
> 
> > One high-level comment -- the wallet in this design doesn't have any way of knowing when the payments are supposed to end. I feel this is important to show to the user before they start their wallet polling infinitely.
> 
> We extended our RecurringPaymentDetails message to support this use case, as it solves the problem of subscription changes and cancellations for free.
> 
> We introduced the concept of a subscription, referred to by a unique id (the tuple merchant_id,subscription_id should be globally unique), which has multiple contracts (RecurringPaymentContract). Besides payment bounds, each contract has a validity period: generally, a subscription will have a unique active contract at a given time and potentially one or more pending ones.
> 
> For example, say you are on the gold plan (1 BTC/mo.) and want to downgrade to a bronze plan (0.5 BTC/mo.) at your next billing date. Wshen you click "Downgrade" on the merchant site, you will update your wallet with two contracts: the current valid one until your next billing date (for up to 1 BTC), and a pending one, starting at your next billing date (for up to 0.5 BTC/mo. and without an ending date).
> Upon cancellation of the bronze plan, the end date of the contract will be updated and polling will stop eventually.
> 
> All of this contract metadata is returned to the wallet so the user can make an informed decision.
> 
> 
> Thanks for your feedbacks!
> 
> S.
> 
> 
> On Feb 11, 2014, at 10:37 PM, Kevin Greene <kgreenek at gmail.com> wrote:
> 
>> Sending this again and truncating since apparently the message body was too long.
>> 
>> Thanks for humoring my questions!
>> 
>> >I think reporting such errors to the wallet would make complete sense. However i am not clear why we would a separate url for that?
>> 
>> Hmm, thinking about this more, adding a simple status_code in PaymentRequest would be a much easier way to achieve this. However, continuing to think about this even more, maybe the simple memo field along with an empty set of outputs is enough already.
>> 
>> In bitcoinj, right now the code will throw a PaymentRequestException.InvalidOutputs exception if the set of outputs is empty with a message of "No Outputs". Because of that, there isn't a good way to tell the difference between a payment request that had no outputs and a payment request that had some invalid output(s).
>> 
>> Question to everyone:
>> How does bitcoin-qt handle a PaymentRequest with no outputs?
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/d3d56e7d/attachment.html>

From tamas at bitsofproof.com  Mon Feb 24 18:13:29 2014
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Mon, 24 Feb 2014 19:13:29 +0100
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9
Message-ID: <449F9E79-7B1B-4821-93C3-F1DC1B5B1DEA@bitsofproof.com>

It costs at least 5430 satoshis to create an output at the moment. 
Is the same spam limit applied if the script is OP_RETURN?
If not, I would be concerned od opening a cheap spam.

Tamas Blummer

On Mon, Feb 24, 2014 at 11:39 AM, Wladimir <laanwj at gmail.com> wrote:

> 
> And if this is not abused, these kind of transactions become popular, and
> more space is really needed, the limit can always be increased in a future
> version.
> 
> Wladimir
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/926df719/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 495 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/926df719/attachment.sig>

From jim at jtan.com  Mon Feb 24 18:29:31 2014
From: jim at jtan.com (Jim Paris)
Date: Mon, 24 Feb 2014 13:29:31 -0500
Subject: [Bitcoin-development] Base-32 error correction coding
In-Reply-To: <5306BCC1.8040004@monetize.io>
References: <5306BCC1.8040004@monetize.io>
Message-ID: <20140224182931.GA16588@psychosis.jim.sh>

Mark Friedenbach wrote:
> What follows is a proposed BIP for human-friendly base-32
> serialization with error correction encoding.
...
> 2. Automatic correction of up to 1 transcription error per 31 coded
> digits (130 bits of payload data). For a 256-bit hash or secret key,
> this enables seamless recovery from up to two transcription errors so
> long as they occur in separate halves of the coded representation.

Can we do better than correcting single transcription errors?  I'd
imagine that transposition of two adjacent characters, or insertion or
deletion of a single character, would be very common.  At the very
least, a transposition could be corrected by interleaving the two
"halves of the coded representation", e.g.:

   ABABABABABABABABABABABABABABABABABABABABABABABABABABABABABABAB

insead of
   
   AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB

Jim



From jeremy at taplink.co  Mon Feb 24 22:12:10 2014
From: jeremy at taplink.co (Jeremy Spilman)
Date: Mon, 24 Feb 2014 14:12:10 -0800
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
Message-ID: <op.xbs3yki1yldrnw@laptop-air>

On Mon, 24 Feb 2014 09:10:26 -0800, Jeff Garzik <jgarzik at bitpay.com> wrote:
> This PR reduces the size to 40 bytes:
> https://github.com/bitcoin/bitcoin/pull/3737

Just quickly GLANCED at it, but if I understand correctly how the template  
matching code works, that will change max size of the <data> to 40 bytes  
but does not do anything to enforce most-efficient encoding.

   else if (opcode2 == OP_SMALLDATA)
   {
       // small pushdata, <= MAX_OP_RETURN_RELAY bytes
       if (vch1.size() > MAX_OP_RETURN_RELAY)
          break;
   }

This code was a bit hard for me to parse since it's not actually requiring  
any data, just disallowing more than a certain number of bytes of data. So  
a bare OP_RETURN would be allowed as well, for whatever good that will do.

If you want to strictly require no PUSHDATA, perhaps you could do:

   else if (opcode2 == OP_SMALLDATA)
   {
       // small pushdata, <= MAX_OP_RETURN_RELAY bytes
       if (opcode1 >= OP_PUSHDATA1 || vch1.size() > MAX_OP_RETURN_RELAY)
          break;
   }

Thanks,
Jeremy




From fastest963 at gmail.com  Mon Feb 24 22:16:12 2014
From: fastest963 at gmail.com (James Hartig)
Date: Mon, 24 Feb 2014 17:16:12 -0500
Subject: [Bitcoin-development] Fwd: Bitcoin Core trial balloon:
 splitting blockchain engine and wallet
In-Reply-To: <CA+s+GJD=-Y5e7jfBt8Ced-2wXkjYcODBKrre2jqT-k-tQO8fCQ@mail.gmail.com>
References: <CAJHLa0OD7w0Rs5ygAE4C14EWm1=x57YHG2kOee1pzxvj3FQ38g@mail.gmail.com>
	<CANEZrP2siw9hGPVsPjQ6WyohacOrs8rqs5p9ZsFY5kF0URnPWg@mail.gmail.com>
	<CA+s+GJCRqqmoHkmsq+6x9Wm6btKzdXoPjw5Af8zRDEkDE+6+zw@mail.gmail.com>
	<CA+s+GJAgs7otQB_tQNCntZ5gR+gp3+PfA+iiKPsjLu2oenaSUA@mail.gmail.com>
	<1393031340.6897.90.camel@staypuft>
	<CA+s+GJD=-Y5e7jfBt8Ced-2wXkjYcODBKrre2jqT-k-tQO8fCQ@mail.gmail.com>
Message-ID: <CAM6j61sSKqeZFOjovV+oUhg6G+r+eusLHhK9chY07m_Wqxd_Cw@mail.gmail.com>

Setting aside all security benefits (which the user can obviously choose to
implement or ignore), a major benefit here is being able to have multiple
wallets use the same blockchain process. I have 3 different bitcoind
processes running on the same server to utilize multiple wallets. Using
them serially isn't an option in my case. Also, peers can run the cheaper
process instead of having the wallet functionality which isn't even used.

On the security front, this doesn't seem to be any less secure and it gives
the user the flexibility to make it as secure as they feel comfortable. If
they want to run them both as the same user with no SELinux or file
protections (this isn't stopping or encouraging that) they're already doing
that now with bitcoind, albeit with possibly a larger attack surface.

Thanks,
--
James Hartig
Software Engineer @ Grooveshark.com
http://twitter.com/jameshartig





On Sat, Feb 22, 2014 at 1:53 AM, Wladimir <laanwj at gmail.com> wrote:

>
> On Sat, Feb 22, 2014 at 2:09 AM, Dustin D. Trammell <
> dtrammell at dustintrammell.com> wrote:
>
>> On Fri, 2014-02-21 at 07:43 +0100, Wladimir wrote:
>> > The most straightforward way would be to run the blockchain daemon as
>> > a system service (with its own uid/gid and set of Apparmor/SELinux
>> > restrictions) and the wallet daemon as the user.
>>
>> This assumes you as a user have the rights to do so.  This would be
>> preferred, but in some cases may not be possible.  Perhaps it should be
>> optional?
>>
>
> No! I'm proposing that we force everyone to do it. Using all means
> necessary. There should be regular audits that everyone is running the
> software exactly in my configuration, and if not, a special task force will
> take care that spankings are carried out on the spot.
>
> Repeated offenders will lose their BitLicense.
> </s>
>
> Please stop kicking this dead horse. It was just a random idea. Maybe a
> way how Linux distributions could structure it, but it may or may not apply
> in your case. And that's fine, this is free software development, you can
> do whatever you want!
>
> Let's try to bring this discussion back to its original intention: for
> anyone that wants to concretely help this along, please help reviewing and
> testing the pull requests that jgarzik mentions.
>
> Wladimir
> BTW: All of those patches are helpful for monolithic-bitcoind as well as
> they (lay the groundwork for) speeding up block synchronization.
>
>
>
> ------------------------------------------------------------------------------
> Managing the Performance of Cloud-Based Applications
> Take advantage of what the Cloud has to offer - Avoid Common Pitfalls.
> Read the Whitepaper.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=121054471&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/efb926ae/attachment.html>

From mark at monetize.io  Mon Feb 24 22:35:57 2014
From: mark at monetize.io (Mark Friedenbach)
Date: Mon, 24 Feb 2014 14:35:57 -0800
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9
In-Reply-To: <449F9E79-7B1B-4821-93C3-F1DC1B5B1DEA@bitsofproof.com>
References: <449F9E79-7B1B-4821-93C3-F1DC1B5B1DEA@bitsofproof.com>
Message-ID: <530BC94D.3030301@monetize.io>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

OP_RETURN outputs are provably unspendable *and* not included in the
UTXO set, so they're not dust (the client makes this check and handles
TX_NULL_DATA outputs separately).

On 02/24/2014 10:13 AM, Tamas Blummer wrote:
> It costs at least 5430 satoshis to create an output at the moment.
>  Is the same spam limit applied if the script is OP_RETURN? If not,
> I would be concerned od opening a cheap spam.
> 
> Tamas Blummer
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJTC8lNAAoJEAdzVfsmodw4vpAP/1/wJFRq9x3rhETtUlS/3+F3
UrgBhfNDP7rq1P9wqZm20cssF0VcG+SVG94m/kH/H8cfJsjGB3/NW2IGxf9J6wOT
vWiGqz4b7lkh5nywBe0TK0smkqMFtyNAESX1WdJpdNLAd5OK/wj2X7Dl3/r7K9tk
SN1Oi4nlQD+GkbQBNeqf659BKlFAIYONl9SrPXvrEoSuTm0CjFLsST3Go3El0tyx
rLrApXCAR+iGs9bZONdkC3rRWGGa3V8HLNeCyBaLA7dsipnk2kMsjbrLB9NZU54L
Dz07e1oelFJErsbYKD+AQy3KiZ4+7dZRoi9FtPqlXtCGAObW0fi5Rm2HDzCG+iMU
f+6xgCCyyP++fET/EnJj1Jxjrn6suoAl2hjZLpaGgJ67lsxq5rqmXetID5X+cGRU
HX6Ar5+LIjRixfoCF3dJoZT0Ko1S0b58oRzyapwbB+2Fi0/G7ujEwErWE33ARXad
vTYznlAXG5YzIrjAJUF3PG3MlbaX4TWywJxRCMRcTQC7Ak+dP2cdOBuzvLdAsYXG
xcmqfl3ETH5xLxLWYnzNplTkt9ENs8UHrG0StWOyCg4+MG8yC/jPFp6qzRlAaZEv
vFsIPGD+jzftrqBQ1GgjbG8bofUYCMnYRKQtQ377GNw8s8wVASb8CxyI8yhXKpdv
zdCwIlvHM0A8CofmDDot
=6Jux
-----END PGP SIGNATURE-----



From jgarzik at bitpay.com  Mon Feb 24 22:50:50 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 24 Feb 2014 17:50:50 -0500
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <op.xbs3yki1yldrnw@laptop-air>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<op.xbs3yki1yldrnw@laptop-air>
Message-ID: <CAJHLa0O2XbJ8TOAdE-oJd7V0NuO-0T5BNa+8cPZU20y=enGfJQ@mail.gmail.com>

Sure, no objection to that.


On Mon, Feb 24, 2014 at 5:12 PM, Jeremy Spilman <jeremy at taplink.co> wrote:
> On Mon, 24 Feb 2014 09:10:26 -0800, Jeff Garzik <jgarzik at bitpay.com> wrote:
>>
>> This PR reduces the size to 40 bytes:
>> https://github.com/bitcoin/bitcoin/pull/3737
>
>
> Just quickly GLANCED at it, but if I understand correctly how the template
> matching code works, that will change max size of the <data> to 40 bytes but
> does not do anything to enforce most-efficient encoding.
>
>   else if (opcode2 == OP_SMALLDATA)
>   {
>       // small pushdata, <= MAX_OP_RETURN_RELAY bytes
>       if (vch1.size() > MAX_OP_RETURN_RELAY)
>          break;
>   }
>
> This code was a bit hard for me to parse since it's not actually requiring
> any data, just disallowing more than a certain number of bytes of data. So a
> bare OP_RETURN would be allowed as well, for whatever good that will do.
>
> If you want to strictly require no PUSHDATA, perhaps you could do:
>
>   else if (opcode2 == OP_SMALLDATA)
>   {
>       // small pushdata, <= MAX_OP_RETURN_RELAY bytes
>       if (opcode1 >= OP_PUSHDATA1 || vch1.size() > MAX_OP_RETURN_RELAY)
>          break;
>   }
>
> Thanks,
> Jeremy
>



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From andreas at petersson.at  Mon Feb 24 23:06:30 2014
From: andreas at petersson.at (Andreas Petersson)
Date: Tue, 25 Feb 2014 00:06:30 +0100
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <530B8000.1070801@monetize.io>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
	<530B8000.1070801@monetize.io>
Message-ID: <530BD076.3020606@petersson.at>

Regarding 80 bytes vs smaller: The objectives should be that if you are
determined to put some extra data in the blockchain, OP_RETURN should be
the superior alternative. if a user can include more data with less fees
using a multisig TX, then this will happen.

eventually dust-limit rules will not be the deciding factor here, since
i suspect block propagation times will have a stronger effect on
effective fees. therefore a slightly larger payload than the biggest
multisig TX is the right answer. - that would be >= 64x3 bytes = 192 bytes.
(this is my understanding of how large a 3-of-3 multisig tx can be, plus
1.5 bits encoded in the "n" parameter)



From gmaxwell at gmail.com  Mon Feb 24 23:13:28 2014
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Mon, 24 Feb 2014 15:13:28 -0800
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <530BD076.3020606@petersson.at>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
	<530B8000.1070801@monetize.io> <530BD076.3020606@petersson.at>
Message-ID: <CAAS2fgT6qFHBojoB-teCjF_YAd9TePdQ3+NWnO0dwf9Bv583_Q@mail.gmail.com>

On Mon, Feb 24, 2014 at 3:06 PM, Andreas Petersson <andreas at petersson.at> wrote:
> Regarding 80 bytes vs smaller: The objectives should be that if you are
> determined to put some extra data in the blockchain, OP_RETURN should be
> the superior alternative. if a user can include more data with less fees
> using a multisig TX, then this will happen.
>
> eventually dust-limit rules will not be the deciding factor here, since
> i suspect block propagation times will have a stronger effect on
> effective fees. therefore a slightly larger payload than the biggest
> multisig TX is the right answer. - that would be >= 64x3 bytes = 192 bytes.
> (this is my understanding of how large a 3-of-3 multisig tx can be, plus
> 1.5 bits encoded in the "n" parameter)

At least there is no ambiguity that such usage is abusive. Adoption of
the practices matters too. Right now I've seen a lot of people
promoting data storage as a virtuous use, and gearing up to directly
store data when a commitment would work.

If it turns out that encouraging people to use hashes is a lost cause
it can always be further relaxed in the future, going the other way is
much harder.



From luke at dashjr.org  Mon Feb 24 23:13:38 2014
From: luke at dashjr.org (Luke-Jr)
Date: Mon, 24 Feb 2014 23:13:38 +0000
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <530BD076.3020606@petersson.at>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<530B8000.1070801@monetize.io> <530BD076.3020606@petersson.at>
Message-ID: <201402242313.39891.luke@dashjr.org>

On Monday, February 24, 2014 11:06:30 PM Andreas Petersson wrote:
> Regarding 80 bytes vs smaller: The objectives should be that if you are
> determined to put some extra data in the blockchain, OP_RETURN should be
> the superior alternative. if a user can include more data with less fees
> using a multisig TX, then this will happen.
> 
> eventually dust-limit rules will not be the deciding factor here, since
> i suspect block propagation times will have a stronger effect on
> effective fees. therefore a slightly larger payload than the biggest
> multisig TX is the right answer. - that would be >= 64x3 bytes = 192 bytes.
> (this is my understanding of how large a 3-of-3 multisig tx can be, plus
> 1.5 bits encoded in the "n" parameter)

Perhaps I ought to redo my data carrier configuration option as a max size?

Luke



From pete at petertodd.org  Tue Feb 25 04:41:16 2014
From: pete at petertodd.org (Peter Todd)
Date: Mon, 24 Feb 2014 23:41:16 -0500
Subject: [Bitcoin-development] Fee drop
Message-ID: <20140225044116.GA28050@savin>

So, just to be clear, we're adding, say, a memory limited mempool or
something prior to release so this fee drop doesn't open up an obvious
low-risk DDoS exploit.... right? As we all know, the network bandwidth
DoS attack mitigation strategy relies on transactions we accept to
mempools getting mined, and the clearance rate of the new low-fee
transactions is going to be pretty small; we've already had problems in
the past with mempool growth in periods of high demand. Equally it
should be obvious to people how you can create large groups of low-fee
transactions, and then cheaply double-spend them with higher fee
transactions to suck up network bandwidth - just like I raised for the
equally foolish double-spend propagation pull-req.

Of course, there's also the problem that we're basically lying to people
about whether or not Bitcoin is a good medium for microtransactions.
It's not. Saying otherwise by releasing software that has known and
obvious DoS attack vulnerabilities that didn't exist in the previous
version is irresponsible on multiple levels.

-- 
'peter'[:-1]@petertodd.org
0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140224/83183399/attachment.sig>

From namanhd at gmail.com  Tue Feb 25 07:34:41 2014
From: namanhd at gmail.com (naman naman)
Date: Tue, 25 Feb 2014 13:04:41 +0530
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <20140225044116.GA28050@savin>
References: <20140225044116.GA28050@savin>
Message-ID: <CA+SxJWDKgv6W2N+FFod6sbBCeS8ScXqBUm_STdw0-m=kKTKkiw@mail.gmail.com>

I quite agree with Peter, anything that can be exploited will be exploited,
just like malleability was.


On Tue, Feb 25, 2014 at 10:11 AM, Peter Todd <pete at petertodd.org> wrote:

> So, just to be clear, we're adding, say, a memory limited mempool or
> something prior to release so this fee drop doesn't open up an obvious
> low-risk DDoS exploit.... right? As we all know, the network bandwidth
> DoS attack mitigation strategy relies on transactions we accept to
> mempools getting mined, and the clearance rate of the new low-fee
> transactions is going to be pretty small; we've already had problems in
> the past with mempool growth in periods of high demand. Equally it
> should be obvious to people how you can create large groups of low-fee
> transactions, and then cheaply double-spend them with higher fee
> transactions to suck up network bandwidth - just like I raised for the
> equally foolish double-spend propagation pull-req.
>
> Of course, there's also the problem that we're basically lying to people
> about whether or not Bitcoin is a good medium for microtransactions.
> It's not. Saying otherwise by releasing software that has known and
> obvious DoS attack vulnerabilities that didn't exist in the previous
> version is irresponsible on multiple levels.
>
> --
> 'peter'[:-1]@petertodd.org
> 0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2
>
>
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/e62944d2/attachment.html>

From odinn.cyberguerrilla at riseup.net  Tue Feb 25 12:40:03 2014
From: odinn.cyberguerrilla at riseup.net (Odinn Cyberguerrilla)
Date: Tue, 25 Feb 2014 04:40:03 -0800
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <20140225044116.GA28050@savin>
References: <20140225044116.GA28050@savin>
Message-ID: <f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>

> So, just to be clear, we're adding, say, a memory limited mempool or
> something prior to release so this fee drop doesn't open up an obvious
> low-risk DDoS exploit.... right? As we all know, the network bandwidth
> DoS attack mitigation strategy relies on transactions we accept to
> mempools getting mined, and the clearance rate of the new low-fee
> transactions is going to be pretty small; we've already had problems in
> the past with mempool growth in periods of high demand. Equally it
> should be obvious to people how you can create large groups of low-fee
> transactions, and then cheaply double-spend them with higher fee
> transactions to suck up network bandwidth - just like I raised for the
> equally foolish double-spend propagation pull-req.

It's good that the core devs keep doing good work on these topics, thanks.

>
> Of course, there's also the problem that we're basically lying to people
> about whether or not Bitcoin is a good medium for microtransactions.

I don't hear anyone lying.


> It's not.

Actually, it is, and comparatively speaking, Bitcoin is better than the
most common alternatives in use by people around the world.  There are
obvious issues (dust, how to handle fee issues moving forward, one could
blather on forever about that), but again, I think core devs have done
fairly well and will probably continue to do so along with many others. 
That's just my own 0.00004 BTC though (my way of saying, at time of
posting this, "my own 2 cents").

>Saying otherwise by releasing software that has known and
> obvious DoS attack vulnerabilities that didn't exist in the previous
> version is irresponsible on multiple levels.

That was not very specific.  Could you be more specific?

>
> --
> 'peter'[:-1]@petertodd.org
> 0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk_______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>





From mike at plan99.net  Tue Feb 25 12:55:18 2014
From: mike at plan99.net (Mike Hearn)
Date: Tue, 25 Feb 2014 18:25:18 +0530
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
Message-ID: <CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>

Given that the fee drop puts fees in "real" (i.e. dollar) terms back to
where they were some months ago, it seems odd to claim this is creating
vulnerabilities that didn't exist in the previous version. The cost of an
attack would be the same as before.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/51e0f2da/attachment.html>

From pete at petertodd.org  Tue Feb 25 14:49:22 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 25 Feb 2014 09:49:22 -0500
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
	<CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
Message-ID: <20140225144922.GA25549@savin>

On Tue, Feb 25, 2014 at 06:25:18PM +0530, Mike Hearn wrote:
> Given that the fee drop puts fees in "real" (i.e. dollar) terms back to
> where they were some months ago, it seems odd to claim this is creating
> vulnerabilities that didn't exist in the previous version. The cost of an
> attack would be the same as before.

No it's not. The cost is only incurred in the transactions actually get
mined, and unlike before the drop appears to be well under the
break-even orphan cost of transactions; we've got no reason to think the
clearance rate of these low-fee transactions will be significant.


But anyway, mostly I'm writing this to register my strong opposition
knowing full well that I don't expect it to change your minds.

-- 
'peter'[:-1]@petertodd.org
0000000000000000eb671d932a8d310e8ab963c53b2be8a27bd5de2a712c2f59
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/952b63e3/attachment.sig>

From mike at plan99.net  Tue Feb 25 16:29:44 2014
From: mike at plan99.net (Mike Hearn)
Date: Tue, 25 Feb 2014 21:59:44 +0530
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
	<81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
Message-ID: <CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>

Hey there,

So the essence of this protocol is as follows:

enum PaymentFrequencyType {
        WEEKLY = 1;
        MONTHLY = 2;
        QUARTERLY = 3;
        ANNUAL = 4;
}
message RecurringPaymentDetails {
        // Namespace for the merchant such as org.foo.bar
        required string merchant_id = 1;
        // Id for the recurring subscription
        required bytes subscription_id = 2;
        // Contracts associated with a given subscription
        repeated RecurringPaymentContract contracts = 3;
}
message RecurringPaymentContract {
        // Unique id for a given contract
        required bytes contract_id = 1;
        // URL to poll to get the next PaymentRequest
        required string polling_url = 2;
        // Timestamp; when this contract starts
        required uint64 starts = 3;
        // Timestamp; when this contract should be considered invalid
        optional uint64 ends = 4;
        // Expected payment frequency
        optional PaymentFrequencyType payment_frequency_type = 5;
        // Max payment amount within that frequency (e.g. no more than
5 BTC per month)
        optional uint64 max_payment_per_period  = 6;
        // Max payment amount (e.g. no more than 3 BTC per payment)
        optional uint64 max_payment_amount = 7;
}

I have the following comments:

   1. There's no need to serialize RecurringPaymentDetails as bytes here.
   It's done that way outside of PaymentDetails in order to support digital
   signatures over protobufs that may have extensions the wallet app isn't
   aware of, but it's a pain and inside PaymentDetails (and therefore for most
   extensions) it shouldn't be necessary. So you can just use "optional
   RecurringPamentDetails recurring_payments = 8;"

   2. There's only 4 possibilities here for recurrences. That seems rather
   restrictive. Is the cost of being more expressive really so high? Why not
   allow more flexible specification of periods?

   3. If there's no payment_frequency_type field then what happens? A quirk
   of protobufs to be aware of is that making an enum field "required" can
   hurt backwards compatibility. Because it will be expressed using a
   languages underlying enum type, if there's a new enum member added later
   old software that attempts to deserialize this will throw exceptions
   because the new "unknown" member would be unrepresentable in the old model.
   Making the field optional avoids this problem (it will be treated as
   missing instead) but means software needs to be written to know what to do
   when it can't read the enum value / sees enum values from the future.

   4. I assume the amounts are specified in terms of satoshi, and
   timestamps are UNIX time, but better to make that explicit.

   5. Seems there's an implicit value constraint that max_payment_amount <=
   max_payment_per_period. What happens if that constraint is violated? Best
   to document that.

   6. What's the "merchant ID" namespace thing about? What's it for? What
   happens if I set my competitors merchant ID there?

   7. What's the "subscription ID"? Is this stuff not duplicative/redundant
   with the existing merchant_data field?

   8. In what situations would you have >1 contract per payment request?
   I'm not sure I understand why it's repeated. Presumably if there are zero
   contracts included the data should be ignored, or an error thrown and the
   entire payment request rejected? Which should it be?

   9. It's unclear to me given such a contract when the payment should
   actually occur. For instance if it's "monthly" then what day in the month
   would the payment occur?

   10. You'll notice I moved the comments to be above the field
   definitions. I know the current proto isn't done that way, but let's change
   it - long comments are good and putting them above the field definitions
   encourages people to write enough detail without being put off by line
   length constraints


I think the next step would be to talk to BitPay/get Jeff+Stephen involved
because I know they have customers that really want recurring payments, and
those guys will have a clearer idea of customer requirements than we do. I
feel uncomfortable with designing or reviewing in a vacuum without some
actual people who would use it chiming in, as I don't really know much
about the underlying business processes.

I have some other comments about the bitcoinj implementation specifically -
for instance, we don't have a "wallet directory" concept: everything goes
into the wallet file. So we'll need to think about how to structure the
code to allow that. Also, just using a background polling thread is likely
not flexible enough, as on some platforms you can't stay running all the
time (e.g. Android) without upsetting people, but the underlying OS can
wake you up at the right times, so wallet apps should have an ability to
control wakeup tasks. But we can discuss that over on the bitcoinj list
specifically. Let's keep this thread for the general protocol design.

BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that isn't
a concern. It could be done there too.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/bb748c61/attachment.html>

From mike at plan99.net  Tue Feb 25 16:55:58 2014
From: mike at plan99.net (Mike Hearn)
Date: Tue, 25 Feb 2014 22:25:58 +0530
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <20140225144922.GA25549@savin>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
	<CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
	<20140225144922.GA25549@savin>
Message-ID: <CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>

There are two possibilities.

One is that the value of transactions with the new lower fee is outweighed
by increased orphan costs and miners refuse to include them en-masse.
Wallet authors lose the staring match and go back to setting higher fees
until such a time as block propagation is optimised and the orphan costs go
down. Nodes that are encountering memory pressure can increase their min
relay fee locally until their usage fits inside their resources. It's
annoying to do this by hand but by no means infeasible.

The other is that the total value of transactions even with the lower fee
is not outweighed by orphan costs. The value of a transaction is higher
than its simple monetary value - the fact that Bitcoin is useful, growing
and considered cheap also has a value which is impossible to calculate, but
we know it's there (because Bitcoin does not exist in a vacuum and has
competitors). In this case miners stop including lots of useful
transactions that represent desired economic activity and are put under
pressure by the community to change their policies. If all miners do this
and making small blocks is considered errant behaviour, then we're back to
the same situation we're in today.

The possibility you're worried about - that someone does a DoS attack by
flooding the network with small transactions - is only an issue in the
first situation, and it is by no means the easiest or cheapest way to DoS
Bitcoin. We all want to see more DoS resistance but basically any change to
Bitcoin can be objected to on anti-DoS grounds at the moment, and this will
remain the case until someone steps up to spend significant time on
resource scheduling and code audits.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/1ab5018a/attachment.html>

From pete at petertodd.org  Tue Feb 25 17:13:34 2014
From: pete at petertodd.org (Peter Todd)
Date: Tue, 25 Feb 2014 12:13:34 -0500
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
	<CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
	<20140225144922.GA25549@savin>
	<CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
Message-ID: <20140225171334.GA30819@savin>

On Tue, Feb 25, 2014 at 10:25:58PM +0530, Mike Hearn wrote:

Well, I've done my responsible disclosure, and I've got better things to
do than argue with wishful thinking.

> There are two possibilities.
> 
> One is that the value of transactions with the new lower fee is outweighed
> by increased orphan costs and miners refuse to include them en-masse.
> Wallet authors lose the staring match and go back to setting higher fees
> until such a time as block propagation is optimised and the orphan costs go
> down. Nodes that are encountering memory pressure can increase their min
> relay fee locally until their usage fits inside their resources. It's
> annoying to do this by hand but by no means infeasible.
> 
> The other is that the total value of transactions even with the lower fee
> is not outweighed by orphan costs. The value of a transaction is higher
> than its simple monetary value - the fact that Bitcoin is useful, growing
> and considered cheap also has a value which is impossible to calculate, but
> we know it's there (because Bitcoin does not exist in a vacuum and has
> competitors). In this case miners stop including lots of useful
> transactions that represent desired economic activity and are put under
> pressure by the community to change their policies. If all miners do this
> and making small blocks is considered errant behaviour, then we're back to
> the same situation we're in today.
> 
> The possibility you're worried about - that someone does a DoS attack by
> flooding the network with small transactions - is only an issue in the
> first situation, and it is by no means the easiest or cheapest way to DoS
> Bitcoin. We all want to see more DoS resistance but basically any change to
> Bitcoin can be objected to on anti-DoS grounds at the moment, and this will
> remain the case until someone steps up to spend significant time on
> resource scheduling and code audits.

-- 
'peter'[:-1]@petertodd.org
0000000000000000445db8e568846d542c86ab395137b32b2a05577afcc7c6a3
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/f44181ab/attachment.sig>

From jeremy at taplink.co  Tue Feb 25 18:09:23 2014
From: jeremy at taplink.co (Jeremy Spilman)
Date: Tue, 25 Feb 2014 10:09:23 -0800
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
	<CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
	<20140225144922.GA25549@savin>
	<CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
Message-ID: <op.xbundx2eyldrnw@laptop-air>

If I understand correctly, the risk here is this would open a historically  
large discrepancy between MIN_RELAY and the expected minimum fee to  
actually obtain block inclusion. I don't know if that's true, but I think  
that's what Peter is saying makes it different this time.

The relay network does anti-spam with MIN_RELAY and MIN_DUST, but of  
course only transactions which hit the blockchain actually PAY the fee, so  
this allows lower-cost spam in the true dollar sense.

I guess it comes down to how 'sharp' the edge is between staying above  
MIN_RELAY and staying OUT of the blockchain. In the worst case, there's a  
completely deterministic boundary, so an attacker can generate an infinite  
number of transactions which are guaranteed never to see the inside of a  
block, and so therefore completely free for the attacker, and all of which  
the network will relay (by default).

On Tue, 25 Feb 2014 08:55:58 -0800, Mike Hearn <mike at plan99.net> wrote:
> Nodes that are encountering memory pressure can increase their min relay  
> fee locally until their usage fits inside their resources. It's annoying  
> to do this >by hand but by no means infeasible.

Perhaps this is just another way to think of the floating fee problem.  
What does MIN_RELAY need to be so that my local resources stay within some  
reasonable limit (and 'reasonable' means different things to different  
nodes).

We have an input gate on transactions entering mempool, we persist  
mempool, and I don't know the specifics but, I assume there's some  
expiration policy other than block inclusion to clear out a Tx from  
mempool. But are transactions prioritized in any way after they make it  
into mempool today?

How closely should mempool selection align with the expected block  
inclusion? I think if they align perfectly in theory that means optimal  
mempool resource allocation. For example, a miner would push out cheaper  
transactions which they were previously hashing against to make room for  
higher fee transactions (bsaed on max block size or orphan rate  
projections), but do we do the same for mempool? E.g.

   - After hitting X number of transactions, the fee has to be larger than  
a transaction in mempool in order to get in,
   - That in turn that ejects a random transaction which paid less fees  
than the incoming Tx from mempool
   - We would have to consider how ejection would work with chains of  
unconfirmed transactions (cumulative average fee/kb?) but again in this  
case, you would want to 'do what miners would do' if you could

Thanks,
Jeremy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/2bd6429a/attachment.html>

From drak at zikula.org  Tue Feb 25 18:40:03 2014
From: drak at zikula.org (Drak)
Date: Tue, 25 Feb 2014 18:40:03 +0000
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
	<81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
	<CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
Message-ID: <CANAnSg3LF6m9u-MV8XiiomMPrbihJh7hm5o=menOWY71bLkdAg@mail.gmail.com>

Forgive me if I missed it, but the spec doesnt look like it can handle only
handle periods of per week, per month, per quarter rather than 'n period'.
I take Paypal as a reference example for subscription payments where you
can set recurring to every: n days, n weeks, n months, n years. That way a
quarterly payment is every 3 months. This fine granularity is necessary
because sometime a payment scheme can be per 4 weekly rather than per
monthly.

So in summary the spec needs daily as an option, and to specify the
recurring cycle as every n*period (one of daily, weekly, monthly, yearly):
and you can drop quarterly since it's just expressed as per 3*monthly.

Drak


On 25 February 2014 16:29, Mike Hearn <mike at plan99.net> wrote:

> Hey there,
>
> So the essence of this protocol is as follows:
>
> enum PaymentFrequencyType {
>
>         WEEKLY = 1;
>
>         MONTHLY = 2;
>
>         QUARTERLY = 3;
>
>         ANNUAL = 4;
> }
> message RecurringPaymentDetails {
>         // Namespace for the merchant such as org.foo.bar
>
>         required string merchant_id = 1;
>
>         // Id for the recurring subscription
>         required bytes subscription_id = 2;
>
>         // Contracts associated with a given subscription
>
>         repeated RecurringPaymentContract contracts = 3;
>
> }
> message RecurringPaymentContract {
>
>         // Unique id for a given contract
>
>         required bytes contract_id = 1;
>
>         // URL to poll to get the next PaymentRequest
>
>         required string polling_url = 2;
>
>         // Timestamp; when this contract starts
>         required uint64 starts = 3;
>
>         // Timestamp; when this contract should be considered invalid
>
>         optional uint64 ends = 4;
>
>         // Expected payment frequency
>         optional PaymentFrequencyType payment_frequency_type = 5;
>
>         // Max payment amount within that frequency (e.g. no more than 5 BTC per month)
>
>         optional uint64 max_payment_per_period  = 6;
>
>         // Max payment amount (e.g. no more than 3 BTC per payment)
>
>         optional uint64 max_payment_amount = 7;
>
> }
>
> I have the following comments:
>
>    1. There's no need to serialize RecurringPaymentDetails as bytes here.
>    It's done that way outside of PaymentDetails in order to support digital
>    signatures over protobufs that may have extensions the wallet app isn't
>    aware of, but it's a pain and inside PaymentDetails (and therefore for most
>    extensions) it shouldn't be necessary. So you can just use "optional
>    RecurringPamentDetails recurring_payments = 8;"
>
>    2. There's only 4 possibilities here for recurrences. That seems
>    rather restrictive. Is the cost of being more expressive really so high?
>    Why not allow more flexible specification of periods?
>
>    3. If there's no payment_frequency_type field then what happens? A
>    quirk of protobufs to be aware of is that making an enum field "required"
>    can hurt backwards compatibility. Because it will be expressed using a
>    languages underlying enum type, if there's a new enum member added later
>    old software that attempts to deserialize this will throw exceptions
>    because the new "unknown" member would be unrepresentable in the old model.
>    Making the field optional avoids this problem (it will be treated as
>    missing instead) but means software needs to be written to know what to do
>    when it can't read the enum value / sees enum values from the future.
>
>    4. I assume the amounts are specified in terms of satoshi, and
>    timestamps are UNIX time, but better to make that explicit.
>
>    5. Seems there's an implicit value constraint that max_payment_amount
>    <= max_payment_per_period. What happens if that constraint is violated?
>    Best to document that.
>
>    6. What's the "merchant ID" namespace thing about? What's it for? What
>    happens if I set my competitors merchant ID there?
>
>    7. What's the "subscription ID"? Is this stuff not
>    duplicative/redundant with the existing merchant_data field?
>
>    8. In what situations would you have >1 contract per payment request?
>    I'm not sure I understand why it's repeated. Presumably if there are zero
>    contracts included the data should be ignored, or an error thrown and the
>    entire payment request rejected? Which should it be?
>
>    9. It's unclear to me given such a contract when the payment should
>    actually occur. For instance if it's "monthly" then what day in the month
>    would the payment occur?
>
>    10. You'll notice I moved the comments to be above the field
>    definitions. I know the current proto isn't done that way, but let's change
>    it - long comments are good and putting them above the field definitions
>    encourages people to write enough detail without being put off by line
>    length constraints
>
>
> I think the next step would be to talk to BitPay/get Jeff+Stephen involved
> because I know they have customers that really want recurring payments, and
> those guys will have a clearer idea of customer requirements than we do. I
> feel uncomfortable with designing or reviewing in a vacuum without some
> actual people who would use it chiming in, as I don't really know much
> about the underlying business processes.
>
> I have some other comments about the bitcoinj implementation specifically
> - for instance, we don't have a "wallet directory" concept: everything goes
> into the wallet file. So we'll need to think about how to structure the
> code to allow that. Also, just using a background polling thread is likely
> not flexible enough, as on some platforms you can't stay running all the
> time (e.g. Android) without upsetting people, but the underlying OS can
> wake you up at the right times, so wallet apps should have an ability to
> control wakeup tasks. But we can discuss that over on the bitcoinj list
> specifically. Let's keep this thread for the general protocol design.
>
> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that
> isn't a concern. It could be done there too.
>
>
>
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
>
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/02825c0e/attachment.html>

From jeremy at taplink.co  Tue Feb 25 19:03:24 2014
From: jeremy at taplink.co (Jeremy Spilman)
Date: Tue, 25 Feb 2014 11:03:24 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
 recurring payments
In-Reply-To: <CANAnSg3LF6m9u-MV8XiiomMPrbihJh7hm5o=menOWY71bLkdAg@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
	<81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
	<CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
	<CANAnSg3LF6m9u-MV8XiiomMPrbihJh7hm5o=menOWY71bLkdAg@mail.gmail.com>
Message-ID: <op.xbupvyvryldrnw@laptop-air>


>
> So in summary the spec needs daily as an option, and to specify the  
> recurring cycle as every n*period >(one of daily, weekly, monthly,  
> yearly): and you can drop quarterly since it's just expressed as per  
> >3*monthly.

If you're going to go the direction of a {unitType, unitsPerInterval}  
tuple, then I think the only two units you could ever want are minutes and  
months. All other standard units of time can be expressed in terms of  
those two, right?

Also consider changing "optional uint64 ends = 4;" to be a interval count  
instead of a UTC timestamp, to avoid any ambiguity over how the 'while'  
loop should be implemented.








From christophe.biocca at gmail.com  Tue Feb 25 19:06:20 2014
From: christophe.biocca at gmail.com (Christophe Biocca)
Date: Tue, 25 Feb 2014 14:06:20 -0500
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CANAnSg3LF6m9u-MV8XiiomMPrbihJh7hm5o=menOWY71bLkdAg@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
	<81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
	<CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
	<CANAnSg3LF6m9u-MV8XiiomMPrbihJh7hm5o=menOWY71bLkdAg@mail.gmail.com>
Message-ID: <CANOOu=-uijS7TxYcC+MD_OPYbZ4BFg-Cy6qOHv5u=TiUq2JenQ@mail.gmail.com>

Given the enormous number of variations on time periods for a
recurring payment, might it be better to simple allow a list of
timestamps? It costs almost nothing, bandwidth wise, and shifts the
thinking to the merchant platform. That doesn't give you an infinite
time frame, but you just get a new list of timestamps every time you
pay the service.

Continuing that thought, is a "next_payment_time" field with each
incremental transaction enough to cover everything?

On Tue, Feb 25, 2014 at 1:40 PM, Drak <drak at zikula.org> wrote:
> Forgive me if I missed it, but the spec doesnt look like it can handle only
> handle periods of per week, per month, per quarter rather than 'n period'. I
> take Paypal as a reference example for subscription payments where you can
> set recurring to every: n days, n weeks, n months, n years. That way a
> quarterly payment is every 3 months. This fine granularity is necessary
> because sometime a payment scheme can be per 4 weekly rather than per
> monthly.
>
> So in summary the spec needs daily as an option, and to specify the
> recurring cycle as every n*period (one of daily, weekly, monthly, yearly):
> and you can drop quarterly since it's just expressed as per 3*monthly.
>
> Drak
>
>
> On 25 February 2014 16:29, Mike Hearn <mike at plan99.net> wrote:
>>
>> Hey there,
>>
>> So the essence of this protocol is as follows:
>>
>>
>> enum PaymentFrequencyType {
>>         WEEKLY = 1;
>>         MONTHLY = 2;
>>         QUARTERLY = 3;
>>         ANNUAL = 4;
>> }
>> message RecurringPaymentDetails {
>>         // Namespace for the merchant such as org.foo.bar
>>         required string merchant_id = 1;
>>
>>
>>         // Id for the recurring subscription
>>         required bytes subscription_id = 2;
>>
>>
>>         // Contracts associated with a given subscription
>>         repeated RecurringPaymentContract contracts = 3;
>>
>>
>> }
>> message RecurringPaymentContract {
>>
>>
>>         // Unique id for a given contract
>>         required bytes contract_id = 1;
>>
>>
>>         // URL to poll to get the next PaymentRequest
>>         required string polling_url = 2;
>>
>>
>>         // Timestamp; when this contract starts
>>         required uint64 starts = 3;
>>
>>
>>         // Timestamp; when this contract should be considered invalid
>>         optional uint64 ends = 4;
>>
>>
>>         // Expected payment frequency
>>         optional PaymentFrequencyType payment_frequency_type = 5;
>>
>>
>>         // Max payment amount within that frequency (e.g. no more than 5
>> BTC per month)
>>         optional uint64 max_payment_per_period  = 6;
>>
>>
>>         // Max payment amount (e.g. no more than 3 BTC per payment)
>>         optional uint64 max_payment_amount = 7;
>>
>>
>> }
>>
>> I have the following comments:
>>
>> There's no need to serialize RecurringPaymentDetails as bytes here. It's
>> done that way outside of PaymentDetails in order to support digital
>> signatures over protobufs that may have extensions the wallet app isn't
>> aware of, but it's a pain and inside PaymentDetails (and therefore for most
>> extensions) it shouldn't be necessary. So you can just use "optional
>> RecurringPamentDetails recurring_payments = 8;"
>>
>> There's only 4 possibilities here for recurrences. That seems rather
>> restrictive. Is the cost of being more expressive really so high? Why not
>> allow more flexible specification of periods?
>>
>> If there's no payment_frequency_type field then what happens? A quirk of
>> protobufs to be aware of is that making an enum field "required" can hurt
>> backwards compatibility. Because it will be expressed using a languages
>> underlying enum type, if there's a new enum member added later old software
>> that attempts to deserialize this will throw exceptions because the new
>> "unknown" member would be unrepresentable in the old model. Making the field
>> optional avoids this problem (it will be treated as missing instead) but
>> means software needs to be written to know what to do when it can't read the
>> enum value / sees enum values from the future.
>>
>> I assume the amounts are specified in terms of satoshi, and timestamps are
>> UNIX time, but better to make that explicit.
>>
>> Seems there's an implicit value constraint that max_payment_amount <=
>> max_payment_per_period. What happens if that constraint is violated? Best to
>> document that.
>>
>> What's the "merchant ID" namespace thing about? What's it for? What
>> happens if I set my competitors merchant ID there?
>>
>> What's the "subscription ID"? Is this stuff not duplicative/redundant with
>> the existing merchant_data field?
>>
>> In what situations would you have >1 contract per payment request? I'm not
>> sure I understand why it's repeated. Presumably if there are zero contracts
>> included the data should be ignored, or an error thrown and the entire
>> payment request rejected? Which should it be?
>>
>> It's unclear to me given such a contract when the payment should actually
>> occur. For instance if it's "monthly" then what day in the month would the
>> payment occur?
>>
>> You'll notice I moved the comments to be above the field definitions. I
>> know the current proto isn't done that way, but let's change it - long
>> comments are good and putting them above the field definitions encourages
>> people to write enough detail without being put off by line length
>> constraints
>>
>>
>> I think the next step would be to talk to BitPay/get Jeff+Stephen involved
>> because I know they have customers that really want recurring payments, and
>> those guys will have a clearer idea of customer requirements than we do. I
>> feel uncomfortable with designing or reviewing in a vacuum without some
>> actual people who would use it chiming in, as I don't really know much about
>> the underlying business processes.
>>
>> I have some other comments about the bitcoinj implementation specifically
>> - for instance, we don't have a "wallet directory" concept: everything goes
>> into the wallet file. So we'll need to think about how to structure the code
>> to allow that. Also, just using a background polling thread is likely not
>> flexible enough, as on some platforms you can't stay running all the time
>> (e.g. Android) without upsetting people, but the underlying OS can wake you
>> up at the right times, so wallet apps should have an ability to control
>> wakeup tasks. But we can discuss that over on the bitcoinj list
>> specifically. Let's keep this thread for the general protocol design.
>>
>> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that
>> isn't a concern. It could be done there too.
>>
>>
>>
>> ------------------------------------------------------------------------------
>> Flow-based real-time traffic analytics software. Cisco certified tool.
>> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
>> Customize your own dashboards, set traffic alerts and generate reports.
>> Network behavioral analysis & security monitoring. All-in-one tool.
>>
>> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
>>
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



From odinn.cyberguerrilla at riseup.net  Tue Feb 25 22:43:58 2014
From: odinn.cyberguerrilla at riseup.net (Odinn Cyberguerrilla)
Date: Tue, 25 Feb 2014 14:43:58 -0800
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
	<CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
	<20140225144922.GA25549@savin>
	<CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
Message-ID: <4aa09921d781ac54695325935fa36920.squirrel@fulvetta.riseup.net>

Am suggesting a (possible) mitigation of [possible flooding, etc], via
some kind of discussion (potentially process BIP, related to bundling and
/ or randomization) not now, but down the road.  However, needs more
thought and analysis (you mentioned code audit?) before it could be
floated around or acted on in any way shape or form.  Thanks for this
discussion, things to think about.... am watching, listening (...)

> There are two possibilities.
>
> One is that the value of transactions with the new lower fee is outweighed
> by increased orphan costs and miners refuse to include them en-masse.
> Wallet authors lose the staring match and go back to setting higher fees
> until such a time as block propagation is optimised and the orphan costs
> go
> down. Nodes that are encountering memory pressure can increase their min
> relay fee locally until their usage fits inside their resources. It's
> annoying to do this by hand but by no means infeasible.
>
> The other is that the total value of transactions even with the lower fee
> is not outweighed by orphan costs. The value of a transaction is higher
> than its simple monetary value - the fact that Bitcoin is useful, growing
> and considered cheap also has a value which is impossible to calculate,
> but
> we know it's there (because Bitcoin does not exist in a vacuum and has
> competitors). In this case miners stop including lots of useful
> transactions that represent desired economic activity and are put under
> pressure by the community to change their policies. If all miners do this
> and making small blocks is considered errant behaviour, then we're back to
> the same situation we're in today.
>
> The possibility you're worried about - that someone does a DoS attack by
> flooding the network with small transactions - is only an issue in the
> first situation, and it is by no means the easiest or cheapest way to DoS
> Bitcoin. We all want to see more DoS resistance but basically any change
> to
> Bitcoin can be objected to on anti-DoS grounds at the moment, and this
> will
> remain the case until someone steps up to spend significant time on
> resource scheduling and code audits.
>





From stephane at kill-bill.org  Wed Feb 26 03:53:08 2014
From: stephane at kill-bill.org (Stephane Brossier)
Date: Tue, 25 Feb 2014 19:53:08 -0800
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
	<81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
	<CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
Message-ID: <BFA4F8CD-529B-418D-B3B9-599C89914CD1@kill-bill.org>

Hi Mike, Jeremy, Drak,

Before going through your questions, I would like to bring some clarity on a few key elements in that protocol. There are really two aspects to it:
The contract negotiation; when the user first subscribes, it is prompted by a contract that will define the payment bounds associated with that subscription. 
Once accepted, the wallet is in charge and the user does not have to interact anymore -- this is the point of the recurring payment protocol. The wallet will poll the merchant and issue payments as they are requested by the merchant as long as they stay within the bounds of what was specified by the contract (and accepted by the customer).

I think it would help to explain how we ended up with the type of contract we introduced in that protocol. In an ideal world and in a NON recurring scheme, the contract should simply be the exact amount to be paid. In our case the exact amount may not be completely known in advance -- for e.g taxes, shipping, pro-rations, ? and so we decided to introduce first a max amount per payment, and also a max amount per period. It is up to the merchant to decide whether to specify none, any or both bounds (max amount per payment and max amount per period). By specifying both, the contract is tighter and the client would feel safer to accept it. In the extreme case, by specifying none, the client would be presented with a contract to pay whatever is requested -- probably not a good option in the Bitcoin world unless there is a high sense of trust with the merchant.   

From reading your comments, it appears we have not been clear on how that frequency (PaymentFrequencyType) is being used. Its sole purpose is to define the max amount per period in the contract. The frequency of the payment is implicitly dictated by the merchant but not specified in the protocol by design: the wallet has to poll with a fine granularity (ideally each day when it is up) to understand if there is something pending. In the same way, a specified amount was not enough in the contract, we feel it would be restrictive to specify in advance when payments are due. There are a lot of complex scenarios in the billing space, and having the wallet poll the merchant to inquire for pending payments is the most flexible option and the contract is there to ensure the client will not be abused. To give a concrete example, imagine a data plan where you pay a base recurring price of $70 per month, but you are charged $10 per GB of data used beyond your included limit. If you exceed your limit on the 15th and the 23rd of a given month, two extra payment attempts will be requested by the merchant, that you couldn?t predict (this scenario is often referred to as usage billing with Prepay Credits and Top-up, where the customer pays in advance for blocks of N units, and once they are consumed another N are purchased).


See answers in your questions inlined below:

> 
> I have the following comments:
> There's no need to serialize RecurringPaymentDetails as bytes here. It's done that way outside of PaymentDetails in order to support digital signatures over protobufs that may have extensions the wallet app isn't aware of, but it's a pain and inside PaymentDetails (and therefore for most extensions) it shouldn't be necessary. So you can just use "optional RecurringPamentDetails recurring_payments = 8;"
> 

OK, we'll fix it.


> There's only 4 possibilities here for recurrences. That seems rather restrictive. Is the cost of being more expressive really so high? Why not allow more flexible specification of periods?
> If there's no payment_frequency_type field then what happens? A quirk of protobufs to be aware of is that making an enum field "required" can hurt backwards compatibility. Because it will be expressed using a languages underlying enum type, if there's a new enum member added later old software that attempts to deserialize this will throw exceptions because the new "unknown" member would be unrepresentable in the old model. Making the field optional avoids this problem (it will be treated as missing instead) but means software needs to be written to know what to do when it can't read the enum value / sees enum values from the future.
> 

I hope the explanation above answers the questions.

> I assume the amounts are specified in terms of satoshi, and timestamps are UNIX time, but better to make that explicit.
> 

Yes.

> Seems there's an implicit value constraint that max_payment_amount <= max_payment_per_period. What happens if that constraint is violated? Best to document that.
> 

As explained above, contract would define none, 1 or both conditions.  First the merchant should not return such 'conditions' but if it does the client should not accept the contract. If the client decides to accept it anyway, then the wallet just verifies both conditions are met separately regardless of whether there is such violation and if so, makes the payment.

> What's the "merchant ID" namespace thing about? What's it for? What happens if I set my competitors merchant ID there?

I agree, we can easily get rid of it.

> What's the "subscription ID"? Is this stuff not duplicative/redundant with the existing merchant_data field?

In an ideal world the merchant should return unique subscriptionId (UUID for instance). That subscriptionId is used in the code to identify the contracts associated with the subscription. The merchant_data if i understand correctly the payment protocol is opaque from the client point of view, so it cannot be used by the client for that purpose. 
> In what situations would you have >1 contract per payment request? I'm not sure I understand why it's repeated. Presumably if there are zero contracts included the data should be ignored, or an error thrown and the entire payment request rejected? Which should it be?
> 


There are many example where that could  happen; for instance if you subscribe to a service,  then later decide to downgrade to a lower product. The merchant may decide to only let you downgrade at the end of your paid period-- to avoid generating extra credit-- and in that situation you end up with two contracts: One for the current product you are in and one for the future product you will end up on when the downgrade becomes effective.


> It's unclear to me given such a contract when the payment should actually occur. For instance if it's "monthly" then what day in the month would the payment occur?
> 

As outlined above in the introduction, the protocol is designed in such a way that the wallet does not have to know what is the exact date when payment should occur, but instead polls the merchant for pending payments. There are many situations when specifying an exact payment date is not an option so that flexibility is essential. A simple example would be for a customer who started subscribing on the 31th of a month. Since there will be months with 28/29/30 days, the payment date would change depending on the month.




> You'll notice I moved the comments to be above the field definitions. I know the current proto isn't done that way, but let's change it - long comments are good and putting them above the field definitions encourages people to write enough detail without being put off by line length constraints
> 

Fine.


> I think the next step would be to talk to BitPay/get Jeff+Stephen involved because I know they have customers that really want recurring payments, and those guys will have a clearer idea of customer requirements than we do. I feel uncomfortable with designing or reviewing in a vacuum without some actual people who would use it chiming in, as I don't really know much about the underlying business processes.


We are totally open to receive feedbacks from them.. How do we bring them in the discussion?

> 
> I have some other comments about the bitcoinj implementation specifically - for instance, we don't have a "wallet directory" concept: everything goes into the wallet file. So we'll need to think about how to structure the code to allow that. Also, just using a background polling thread is likely not flexible enough, as on some platforms you can't stay running all the time (e.g. Android) without upsetting people, but the underlying OS can wake you up at the right times, so wallet apps should have an ability to control wakeup tasks. But we can discuss that over on the bitcoinj list specifically. Let's keep this thread for the general protocol design.

Ok that makes sense.

> 
> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that isn't a concern. It could be done there too.
> 

Great to know.



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140225/e95b3c10/attachment.html>

From mike at plan99.net  Wed Feb 26 10:30:46 2014
From: mike at plan99.net (Mike Hearn)
Date: Wed, 26 Feb 2014 16:00:46 +0530
Subject: [Bitcoin-development] Extension for BIP-0070 to support
	recurring payments
In-Reply-To: <BFA4F8CD-529B-418D-B3B9-599C89914CD1@kill-bill.org>
References: <E1FDB3F2-25ED-4B99-979E-12CE943CBD66@kill-bill.org>
	<CANEZrP10z6_UAHD97mj22kVEGyXgHPQ2PdP_8RxHT5Py+xRP_A@mail.gmail.com>
	<D6BCC0C4-EF22-4DE8-868E-825D19C387E3@kill-bill.org>
	<CANEZrP0FzTGmp1zbaW1VHJLk5117ZnTSehfF4uMX=+UFS+R_Dw@mail.gmail.com>
	<0CC0BE1D-1DAA-4994-B034-EB7712F845CF@kill-bill.org>
	<DBA255DB-4839-4C3A-BA62-BD3926995C12@kill-bill.org>
	<CAEY8wq6F33814d2+97AqDoAicvh=0PigHZ03wHadMq6JqtQMLg@mail.gmail.com>
	<EAEC76DA-A490-4A61-BFB7-611D4ADF1680@kill-bill.org>
	<CAEY8wq5=pAMTqDPM8yeCF+Z2=1GWmD0UDQdgacN1o3jAUh_BYA@mail.gmail.com>
	<CAEY8wq40RxeUYYJS2m=xq26iTd2NE64WR7QOUO0+yR-MJQCoxQ@mail.gmail.com>
	<5F91BEBF-ECDD-4CBD-A85E-FD7E7DB3F01F@kill-bill.org>
	<81FBEA67-45A9-4531-BEA0-071CE9FAEF7E@kill-bill.org>
	<CANEZrP0-LqFC8N500=mnKbKE+=UtFw_Y5cHR8JRC-zmmGsSAjA@mail.gmail.com>
	<BFA4F8CD-529B-418D-B3B9-599C89914CD1@kill-bill.org>
Message-ID: <CANEZrP2opmZhsgLvJ_WRAT0THHbtnGTZVFbcVkUYhM-DHiGxNA@mail.gmail.com>

Thanks for the explanation. I agree that makes sense, and you did actually
explain this before, I just didn't connect the dots :)

The accompanying BIP should explain all this, so the rationale for the
design and how you use it is made clear to developers.

I've CCd Jeff and Stephen on this thread, so they can go review it and
weigh in with any comments. They may want to go back to customers who
requested this feature and ask if it'd satisfy their needs.


On Wed, Feb 26, 2014 at 9:23 AM, Stephane Brossier
<stephane at kill-bill.org>wrote:

>
>
>
>
>
>
> *Hi Mike, Jeremy, Drak,Before going through your questions, I would like
> to bring some clarity on a few key elements in that protocol. There are
> really two aspects to it: 1. The contract negotiation; when the user first
> subscribes, it is prompted by a contract that will define the payment
> bounds associated with that subscription. 2. Once accepted, the wallet is
> in charge and the user does not have to interact anymore -- this is the
> point of the recurring payment protocol. The wallet will poll the merchant
> and issue payments as they are requested by the merchant as long as they
> stay within the bounds of what was specified by the contract (and accepted
> by the customer).I think it would help to explain how we ended up with the
> type of contract we introduced in that protocol. In an ideal world and in a
> NON recurring scheme, the contract should simply be the exact amount to be
> paid. In our case the exact amount may not be completely known in advance
> -- for e.g taxes, shipping, pro-rations, ? and so we decided to introduce
> first a max amount per payment, and also a max amount per period. It is up
> to the merchant to decide whether to specify none, any or both bounds (max
> amount per payment and max amount per period). By specifying both, the
> contract is tighter and the client would feel safer to accept it. In the
> extreme case, by specifying none, the client would be presented with a
> contract to pay whatever is requested -- probably not a good option in the
> Bitcoin world unless there is a high sense of trust with the merchant.
>   From reading your comments, it appears we have not been clear on how that
> frequency (PaymentFrequencyType) is being used. Its sole purpose is to
> define the max amount per period in the contract. The frequency of the
> payment is implicitly dictated by the merchant but not specified in the
> protocol by design: the wallet has to poll with a fine granularity (ideally
> each day when it is up) to understand if there is something pending. In the
> same way, a specified amount was not enough in the contract, we feel it
> would be restrictive to specify in advance when payments are due. There are
> a lot of complex scenarios in the billing space, and having the wallet poll
> the merchant to inquire for pending payments is the most flexible option
> and the contract is there to ensure the client will not be abused. To give
> a concrete example, imagine a data plan where you pay a base recurring
> price of $70 per month, but you are charged $10 per GB of data used beyond
> your included limit. If you exceed your limit on the 15th and the 23rd of a
> given month, two extra payment attempts will be requested by the merchant,
> that you couldn?t predict (this scenario is often referred to as usage
> billing with Prepay Credits and Top-up, where the customer pays in advance
> for blocks of N units, and once they are consumed another N are purchased).*
>
>
> *See answers in your questions inlined below:*
>
>
> I have the following comments:
>
>    1. There's no need to serialize RecurringPaymentDetails as bytes here.
>    It's done that way outside of PaymentDetails in order to support digital
>    signatures over protobufs that may have extensions the wallet app isn't
>    aware of, but it's a pain and inside PaymentDetails (and therefore for most
>    extensions) it shouldn't be necessary. So you can just use "optional
>    RecurringPamentDetails recurring_payments = 8;"
>
>
>
> OK, we'll fix it.
>
>
>
>    1. There's only 4 possibilities here for recurrences. That seems
>    rather restrictive. Is the cost of being more expressive really so high?
>    Why not allow more flexible specification of periods?
>
>
>    1. If there's no payment_frequency_type field then what happens? A
>    quirk of protobufs to be aware of is that making an enum field "required"
>    can hurt backwards compatibility. Because it will be expressed using a
>    languages underlying enum type, if there's a new enum member added later
>    old software that attempts to deserialize this will throw exceptions
>    because the new "unknown" member would be unrepresentable in the old model.
>    Making the field optional avoids this problem (it will be treated as
>    missing instead) but means software needs to be written to know what to do
>    when it can't read the enum value / sees enum values from the future.
>
>
>
> I hope the explanation above answers the questions.
>
>
>    1. I assume the amounts are specified in terms of satoshi, and
>    timestamps are UNIX time, but better to make that explicit.
>
>
>
> Yes.
>
>
>    1. Seems there's an implicit value constraint that max_payment_amount
>    <= max_payment_per_period. What happens if that constraint is violated?
>    Best to document that.
>
>
>
> As explained above, contract would define none, 1 or both conditions.
>  First the merchant should not return such 'conditions' but if it does the
> client should not accept the contract. If the client decides to accept it
> anyway, then the wallet just verifies both conditions are met separately
> regardless of whether there is such violation and if so, makes the payment.
>
>
>    1. What's the "merchant ID" namespace thing about? What's it for? What
>    happens if I set my competitors merchant ID there?
>
>
> I agree, we can easily get rid of it.
>
>
>    1. What's the "subscription ID"? Is this stuff not
>    duplicative/redundant with the existing merchant_data field?
>
>
> In an ideal world the merchant should return unique subscriptionId (UUID
> for instance). That subscriptionId is used in the code to identify the
> contracts associated with the subscription. The merchant_data if i
> understand correctly the payment protocol is opaque from the client point
> of view, so it cannot be used by the client for that purpose.
>
>
>    1. In what situations would you have >1 contract per payment request?
>    I'm not sure I understand why it's repeated. Presumably if there are zero
>    contracts included the data should be ignored, or an error thrown and the
>    entire payment request rejected? Which should it be?
>
>
>
>
> There are many example where that could  happen; for instance if you
> subscribe to a service,  then later decide to downgrade to a lower product.
> The merchant may decide to only let you downgrade at the end of your paid
> period-- to avoid generating extra credit-- and in that situation you end
> up with two contracts: One for the current product you are in and one for
> the future product you will end up on when the downgrade becomes effective.
>
>
>
>    1. It's unclear to me given such a contract when the payment should
>    actually occur. For instance if it's "monthly" then what day in the month
>    would the payment occur?
>
>
>
> As outlined above in the introduction, the protocol is designed in such a
> way that the wallet does not have to know what is the exact date when
> payment should occur, but instead polls the merchant for pending payments.
> There are many situations when specifying an exact payment date is not an
> option so that flexibility is essential. A simple example would be for a
> customer who started subscribing on the 31th of a month. Since there will
> be months with 28/29/30 days, the payment date would change depending on
> the month.
>
>
>
>
>
>    1. You'll notice I moved the comments to be above the field
>    definitions. I know the current proto isn't done that way, but let's change
>    it - long comments are good and putting them above the field definitions
>    encourages people to write enough detail without being put off by line
>    length constraints
>
>
>
> Fine.
>
>
> I think the next step would be to talk to BitPay/get Jeff+Stephen involved
> because I know they have customers that really want recurring payments, and
> those guys will have a clearer idea of customer requirements than we do. I
> feel uncomfortable with designing or reviewing in a vacuum without some
> actual people who would use it chiming in, as I don't really know much
> about the underlying business processes.
>
>
>
> We are totally open to receive feedbacks from them.. How do we bring them
> in the discussion?
>
>
> I have some other comments about the bitcoinj implementation specifically
> - for instance, we don't have a "wallet directory" concept: everything goes
> into the wallet file. So we'll need to think about how to structure the
> code to allow that. Also, just using a background polling thread is likely
> not flexible enough, as on some platforms you can't stay running all the
> time (e.g. Android) without upsetting people, but the underlying OS can
> wake you up at the right times, so wallet apps should have an ability to
> control wakeup tasks. But we can discuss that over on the bitcoinj list
> specifically. Let's keep this thread for the general protocol design.
>
>
> Ok that makes sense.
>
>
> BIP 70 is indeed implemented in Bitcoin Core on the C++ side, so that
> isn't a concern. It could be done there too.
>
>
> Great to know.
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140226/88923335/attachment.html>

From jgarzik at bitpay.com  Wed Feb 26 22:51:32 2014
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Wed, 26 Feb 2014 17:51:32 -0500
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <20140225044116.GA28050@savin>
References: <20140225044116.GA28050@savin>
Message-ID: <CAJHLa0PhQqgPLRFG8h2-Xo0t-ooBAVgOwJ_w3Y0nxRZ5jfmzZA@mail.gmail.com>

Just pushed out a mempool janitor change to
https://github.com/bitcoin/bitcoin/pull/3753   The goal was to create
a simple bolt-on change, and /not/ rewrite the mempool code.

I'll be running some metrics on what does and does not get into the
mempools of my public nodes for 48 hours, ending Friday ~midnight EST.

On Mon, Feb 24, 2014 at 11:41 PM, Peter Todd <pete at petertodd.org> wrote:
> So, just to be clear, we're adding, say, a memory limited mempool or
> something prior to release so this fee drop doesn't open up an obvious
> low-risk DDoS exploit.... right? As we all know, the network bandwidth
> DoS attack mitigation strategy relies on transactions we accept to
> mempools getting mined, and the clearance rate of the new low-fee
> transactions is going to be pretty small; we've already had problems in
> the past with mempool growth in periods of high demand. Equally it
> should be obvious to people how you can create large groups of low-fee
> transactions, and then cheaply double-spend them with higher fee
> transactions to suck up network bandwidth - just like I raised for the
> equally foolish double-spend propagation pull-req.
>
> Of course, there's also the problem that we're basically lying to people
> about whether or not Bitcoin is a good medium for microtransactions.
> It's not. Saying otherwise by releasing software that has known and
> obvious DoS attack vulnerabilities that didn't exist in the previous
> version is irresponsible on multiple levels.
>
> --
> 'peter'[:-1]@petertodd.org
> 0000000000000000b28e2818c4d8019fb71e33ec2d223f5e09394a89caccf4e2
>
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



-- 
Jeff Garzik
Bitcoin core developer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From jtimon at monetize.io  Thu Feb 27 23:48:33 2014
From: jtimon at monetize.io (=?ISO-8859-1?Q?Jorge_Tim=F3n?=)
Date: Fri, 28 Feb 2014 00:48:33 +0100
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140217054751.GY3180@nl.grid.coop>
References: <20140209180458.GB20126@savin> <20140209204434.GA11488@savin>
	<20140210193247.GC17359@savin> <20140211175919.GV3180@nl.grid.coop>
	<20140214052159.GF31437@savin> <20140217054751.GY3180@nl.grid.coop>
Message-ID: <CAC1+kJNTq2sMbORAU-HBSpTVE3ohzsxHrxXw9JOXZp5ux32Gtw@mail.gmail.com>

First of all, sorry for the delayed answer.

On 2/10/14, Peter Todd <pete at petertodd.org> wrote:
> Got this:
[...]
Thank you, I knew this wasn't new for us but I doubted we had written
it anywhere.
As said in those mails, being only able to offer AAA for BTC and not
BTC for AAA nor AAA for BBB is enough of a limitation to justify a
hardfork IMO.

On 2/17/14, Troy Benjegerdes <hozer at hozed.org> wrote:
> Is there a simple way to do cross-chain trades that doesn't need a third
> chain to somehow facilitate things?

These are the two methods I know for cross-chain trading (no third
chain needed in any of them):

https://en.bitcoin.it/wiki/Contracts#Example_5:_Trading_across_chains
https://bitcointalk.org/index.php?topic=321228

On 2/14/14, Peter Todd <pete at petertodd.org> wrote:
> You're assuming the seller cares about fairness - why should they? They
> offered a price for an asset and someone bought it; exactly which buyer
> willing to buy at that price was able to complete the trade is
> irrelevant to them. What they do care about is being sure that at
> whatever given price they offered 100% of the buyers willing to buy at
> that price actually see the offer in a reasonable amount of time - at
> the best price the seller will get there will be only a single buyer
> after all so you need that solid proof that said buyer was actually able
> to get the offer.

In fact, I don't think the seller will care enough about this to pay
the proof of publication fee either. Assuming sellers can either
broadcast the order on a bitmessage-like network or use your proof of
publication scheme, the later will be always be more expensive. So my
prediction is that most people will just use the simplest, fastest and
cheapest method, but I guess only time can tell.
I don't think this will be a tragedy, because like we discussed on
IRC, I don't think the primary goal of markets is price discovery, but
trade itself.

About historic data, the actual trades are always public, and some
kind of "archivers" could collect and maintain old orders for historic
bid and asks, etc.

As an aside, nLockTime would be nice not to always have to
double-spend the inputs of an order to cancel it.

-- 
Jorge Tim?n

http://freico.in/



From pete at petertodd.org  Fri Feb 28 01:37:19 2014
From: pete at petertodd.org (Peter Todd)
Date: Thu, 27 Feb 2014 20:37:19 -0500
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <CAC1+kJNTq2sMbORAU-HBSpTVE3ohzsxHrxXw9JOXZp5ux32Gtw@mail.gmail.com>
References: <20140209180458.GB20126@savin> <20140209204434.GA11488@savin>
	<20140210193247.GC17359@savin> <20140211175919.GV3180@nl.grid.coop>
	<20140214052159.GF31437@savin> <20140217054751.GY3180@nl.grid.coop>
	<CAC1+kJNTq2sMbORAU-HBSpTVE3ohzsxHrxXw9JOXZp5ux32Gtw@mail.gmail.com>
Message-ID: <20140228013719.GA5786@savin>

On Fri, Feb 28, 2014 at 12:48:33AM +0100, Jorge Tim?n wrote:
> First of all, sorry for the delayed answer.
> 
> On 2/10/14, Peter Todd <pete at petertodd.org> wrote:
> > Got this:
> [...]
> Thank you, I knew this wasn't new for us but I doubted we had written
> it anywhere.
> As said in those mails, being only able to offer AAA for BTC and not
> BTC for AAA nor AAA for BBB is enough of a limitation to justify a
> hardfork IMO.

As usual, you don't need a hardfork.

Anyway, one-sided trade is sufficient to get a functioning marketplace
up and running and test out the many other issues with this stuff prior
to forking anything.

> On 2/14/14, Peter Todd <pete at petertodd.org> wrote:
> > You're assuming the seller cares about fairness - why should they? They
> > offered a price for an asset and someone bought it; exactly which buyer
> > willing to buy at that price was able to complete the trade is
> > irrelevant to them. What they do care about is being sure that at
> > whatever given price they offered 100% of the buyers willing to buy at
> > that price actually see the offer in a reasonable amount of time - at
> > the best price the seller will get there will be only a single buyer
> > after all so you need that solid proof that said buyer was actually able
> > to get the offer.
> 
> In fact, I don't think the seller will care enough about this to pay
> the proof of publication fee either. Assuming sellers can either
> broadcast the order on a bitmessage-like network or use your proof of
> publication scheme, the later will be always be more expensive. So my
> prediction is that most people will just use the simplest, fastest and
> cheapest method, but I guess only time can tell.

You can make the same argument against Bitcoin itself you know...

A Bitmessage-like network would be trivial to front-run via a sybil
attack. It's the fundemental problem with marketplaces - the data
they're trying to publish has to be public.

> I don't think this will be a tragedy, because like we discussed on
> IRC, I don't think the primary goal of markets is price discovery, but
> trade itself.
>
> About historic data, the actual trades are always public, and some
> kind of "archivers" could collect and maintain old orders for historic
> bid and asks, etc.

And again, how do you know that record is honest? Fact is without
proof-of-publication you just don't.

> As an aside, nLockTime would be nice not to always have to
> double-spend the inputs of an order to cancel it.

You mean a reverse nLockTime that makes a transaction invalid after a
certain amount of time - that's dangerous in a reorg unfortunately as it
can make transactions permenantly invalid.

-- 
'peter'[:-1]@petertodd.org
0000000000000000b52709f0485161e764ac0198960885ccab019a978322cc6e
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140227/58a08669/attachment.sig>

From hozer at hozed.org  Fri Feb 28 04:50:51 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Thu, 27 Feb 2014 22:50:51 -0600
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <20140225044116.GA28050@savin>
References: <20140225044116.GA28050@savin>
Message-ID: <20140228045051.GM3180@nl.grid.coop>

On Mon, Feb 24, 2014 at 11:41:16PM -0500, Peter Todd wrote:
> So, just to be clear, we're adding, say, a memory limited mempool or
> something prior to release so this fee drop doesn't open up an obvious
> low-risk DDoS exploit.... right? As we all know, the network bandwidth
> DoS attack mitigation strategy relies on transactions we accept to
> mempools getting mined, and the clearance rate of the new low-fee
> transactions is going to be pretty small; we've already had problems in
> the past with mempool growth in periods of high demand. Equally it
> should be obvious to people how you can create large groups of low-fee
> transactions, and then cheaply double-spend them with higher fee
> transactions to suck up network bandwidth - just like I raised for the
> equally foolish double-spend propagation pull-req.
> 
> Of course, there's also the problem that we're basically lying to people
> about whether or not Bitcoin is a good medium for microtransactions.
> It's not. Saying otherwise by releasing software that has known and
> obvious DoS attack vulnerabilities that didn't exist in the previous
> version is irresponsible on multiple levels.

Well, if your investors take money with market manipulating news stories,
this is absolutely the responsible thing to do to increase shareholder
value with a future opportunity to cause a crash-on-demand.

Besides, if you really want microtransactions, you should be using an
altcoin with faster block times, smaller market cap, and larger 'human'
readable currency supply.

That being said, I'd say include the change, we all know about it. What
would be nice would be some exploits and attack signatures for what the
DOS will look like when it hits so that those of us paying attention
can make some money trading in anticipation of the market crash instead
of just the guys paying for the attack.

The real killer feature of Bitcoin is that we can learn from it's mistakes
(and bitcoin can learn from the copycatcoins), instead of one-size-fits
all fiat.

-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer at hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash




From hozer at hozed.org  Fri Feb 28 05:25:23 2014
From: hozer at hozed.org (Troy Benjegerdes)
Date: Thu, 27 Feb 2014 23:25:23 -0600
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <530B8000.1070801@monetize.io>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
	<530B8000.1070801@monetize.io>
Message-ID: <20140228052523.GO3180@nl.grid.coop>

To each his own, but if I say "Please don't charge me for YOUR privacy
by putting junk like stealth addresses in the blockchain", I think I'd
get laughed out of most rooms.

Either the transaction fees are sufficient to pay the cost for whatever
random junk anyone wants to put there, or they are not, and if they are
not, then I suggest you re-think the fee structure rather than trying
to pre-regulate me putting 80 character pithy quotes in the blockhain.


On Mon, Feb 24, 2014 at 09:23:12AM -0800, Mark Friedenbach wrote:
> Given our standardization on 128-bit security / 256-bit primitives, I
> can't think of any crypto related data payload which requires more than
> 40 bytes. Even DER encoded compressed public keys will fit in there. A
> signature won't fit, but why would you need one in there?
> 
> There's no need to design for 64-byte hashes, and the 80-char line
> length comparison is a good point. As an Engineer I'd want to have a
> little more room as a 32-byte hash or EC point + 8 bytes identifying
> prefix data is the bare minimum, but it is also very important that we
> send a message: This is for payment related applications like stealth
> addresses only. Don't burden everybody by putting your junk on the block
> chain.
> 
> On 02/24/2014 08:39 AM, Wladimir wrote:
> > 
> > On Mon, Feb 24, 2014 at 5:03 PM, Jeff Garzik <jgarzik at bitpay.com
> > <mailto:jgarzik at bitpay.com>> wrote:
> > 
> >     A common IRC proposal seems to lean towards reducing that from 80.
> >     I'll leave it to the crowd to argue about size from there. I do think
> >     regular transactions should have the ability to include some metadata.
> > 
> > 
> > I'd be in favor of bringing it down to 40 for 0.9.
> > 
> > That'd be enough for <8 byte header/identifier><32 byte hash>.
> > 
> > 80, as the standard line length, is almost asking for "insert your
> > graffiti message here". I also see no need for 64 bytes hashes such as
> > SHA512 in the context of bitcoin, as that only offers 256-bit security
> > (at most) in the first place.
> > 
> > And if this is not abused, these kind of transactions become popular,
> > and more space is really needed, the limit can always be increased in a
> > future version.
> > 
> > Wladimir
> > 
> > 
> > ------------------------------------------------------------------------------
> > Flow-based real-time traffic analytics software. Cisco certified tool.
> > Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> > Customize your own dashboards, set traffic alerts and generate reports.
> > Network behavioral analysis & security monitoring. All-in-one tool.
> > http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> > 
> > 
> > 
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> > 
> 
> ------------------------------------------------------------------------------
> Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow Analyzer
> Customize your own dashboards, set traffic alerts and generate reports.
> Network behavioral analysis & security monitoring. All-in-one tool.
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-- 
----------------------------------------------------------------------------
Troy Benjegerdes                 'da hozer'                  hozer at hozed.org
7 elements      earth::water::air::fire::mind::spirit::soul        grid.coop

      Never pick a fight with someone who buys ink by the barrel,
         nor try buy a hacker who makes money by the megahash




From pete at petertodd.org  Fri Feb 28 11:18:26 2014
From: pete at petertodd.org (Peter Todd)
Date: Fri, 28 Feb 2014 06:18:26 -0500
Subject: [Bitcoin-development] Fee drop
In-Reply-To: <op.xbundx2eyldrnw@laptop-air>
References: <20140225044116.GA28050@savin>
	<f35865264f37315d580a30dc49789a5a.squirrel@fulvetta.riseup.net>
	<CANEZrP1wB9zpnD+DOnmCNycEGB+nZMt8gQrjpn5V92MMkausaA@mail.gmail.com>
	<20140225144922.GA25549@savin>
	<CANEZrP0pDjHr3v2w_zKnME+6GjVdvV5HYjrLH7xthbNdBniK4g@mail.gmail.com>
	<op.xbundx2eyldrnw@laptop-air>
Message-ID: <20140228111826.GA6798@savin>

On Tue, Feb 25, 2014 at 10:09:23AM -0800, Jeremy Spilman wrote:
> If I understand correctly, the risk here is this would open a
> historically large discrepancy between MIN_RELAY and the expected
> minimum fee to actually obtain block inclusion. I don't know if
> that's true, but I think that's what Peter is saying makes it
> different this time.

That's exactly the problem.

Of course every time we make a new transaction type standard we also run
that risk, but at least it's a temporary situation and we can expect to
get hashing power on-board fairly quickly. With such a low MIN_RELAY
that's not true, and in an absolute sense, the funds required to DoS
attack the network are fairly low.

> On Tue, 25 Feb 2014 08:55:58 -0800, Mike Hearn <mike at plan99.net> wrote:
> >Nodes that are encountering memory pressure can increase their min
> >relay fee locally until their usage fits inside their resources.
> >It's annoying to do this >by hand but by no means infeasible.
> 
> Perhaps this is just another way to think of the floating fee
> problem. What does MIN_RELAY need to be so that my local resources
> stay within some reasonable limit (and 'reasonable' means different
> things to different nodes).
> 
> We have an input gate on transactions entering mempool, we persist
> mempool, and I don't know the specifics but, I assume there's some
> expiration policy other than block inclusion to clear out a Tx from
> mempool. But are transactions prioritized in any way after they make
> it into mempool today?

There's currently no expiration policy at all; that's the root of the
DoS problem I was referring too.

> How closely should mempool selection align with the expected block
> inclusion? I think if they align perfectly in theory that means
> optimal mempool resource allocation. For example, a miner would push
> out cheaper transactions which they were previously hashing against
> to make room for higher fee transactions (bsaed on max block size or
> orphan rate projections), but do we do the same for mempool? E.g.
> 
>   - After hitting X number of transactions, the fee has to be larger
> than a transaction in mempool in order to get in,
>   - That in turn that ejects a random transaction which paid less
> fees than the incoming Tx from mempool
>   - We would have to consider how ejection would work with chains of
> unconfirmed transactions (cumulative average fee/kb?) but again in
> this case, you would want to 'do what miners would do' if you could

Have you seen the mempool superblock design that keeps getting
suggested? jgarzik has the most recent write-up here:
https://github.com/bitcoin/bitcoin/issues/3723

I was working on a relatively ambitious version of it last summer that
calculated the fee/KB for transactions, including depedencies, and then
simply ordered the mempool with highest fee/KB first. The idea was you
could then easily limit the total size of the mempool and drop
transactions with the lowest fee/KB first. Transactions that paid less
than the lowest fee/KB in a max-size mempool simply would not get
relayed at all. Pity had to put it off for higher-priority work.

What's interesting is how this makes zero-conf transactions even less
safe: all you have to do to double-spend one (or more!) that pay X
fee/KB is broadcast enough transactions paying X+e fee/KB to push out
the unconfirmed tx from mepools around the network, then broadcast your
double-spend. Obviously the economics of this are going to make attacks
frequently profitable, especially if you can attack multiple targets at
once. You can of course have schemes where you don't entirely drop
transactions, saving, say, the inputs they spend and a transaction id,
(so a rebroadcast can succeed) but that just reduces the effectiveness
of the attack by a constant factor and makes it possible to get into
complex situations where your funds are locked and unspendable.

-- 
'peter'[:-1]@petertodd.org
00000000000000011ffdfe2bfdf8f1f983bebfa160670b85afeebbd815fdf484
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 685 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/c9dec419/attachment.sig>

From mike at plan99.net  Fri Feb 28 11:46:49 2014
From: mike at plan99.net (Mike Hearn)
Date: Fri, 28 Feb 2014 12:46:49 +0100
Subject: [Bitcoin-development] BIP70 extension to allow for identity
	delegation
Message-ID: <CANEZrP1eABw_x8o-Z9ac23e-dVvUWfZJ-hKfAak=-NicPhUv9g@mail.gmail.com>

Now we're starting to see the first companies deploy BIP70, we're
encountering a need for identity delegation. This need was long foreseen by
the way: it's not in BIP70 because, well, we had to draw the line for v1
somewhere, and this is an issue that mostly affects payment processors. But
I figured I'd start a thread anyway because people keep asking me about it
:)

*Objective*

Identity delegation means that a payment request can be signed by someone
who is not holding the certified private key. The most obvious use case for
this is payment processors like BitPay and Coinbase who currently have to
sign payment requests as themselves. Other use cases might involve
untrusted sales agents who want to be able to accept payment as their
employer, but cannot be trusted with a long-term valuable secret, e.g.
because they take their phone into areas with high crime rates.

The lack of this is ok for v1 but not great, because:

1) It requires the name of the *actual* recipient to be put in the memo
field, otherwise you don't have the nice receipt-like properties. The memo
field is just plain text though, it doesn't have any exploitable structure.

2) It gives a confusing UI, the user thinks they're paying e.g. Overstock
but their wallet UI tells them they're paying Coinbase

3) Whilst these payment processors currently verify merchants so the
security risk is low, in future a lighter-weight model or competing sites
that allow open signups would give a weak security situation:  a hacker who
compromised your computer could sign up for some popular payment processor
under a false identity (or no identity), and wait until you use your hacked
computer to make a payment to someone else using the same payment
processor. They could then do an identity swap of the real payment request
for one of their own, and your Trezor would still look the same. Avoiding
this is a major motivation for the entire system!

Also it just looks more professional if the name you see in the wallet UI
is correct.

*Proposed implementation*

We can fix this with a simple extension:

enum KeyType {
  SECP256K1 = 1
}

message ExtensionCert {
  required bytes signature = 1;
  required bytes public_key = 2;
  required KeyType key_type = 3;
  required uint32 expiry_time = 4;
  optional string memo = 5;
}

// modification
message X509Certificates {
  repeated bytes certificate = 1;
  repeated ExtensionCert extended_certs = 2;
}

message PaymentRequest {
  // new field
  optional bytes extended_signature = 6;
}

This allow us to define a so-called *extended certificate*, which is
conceptually the same as an X.509 certificate except simpler and Bitcoin
specific. To create one, you just format a ExtensionCert message with an
ECDSA public key from the payment processor (PP), set signature to an empty
array and then sign it using your SSL private key. Obviously the resulting
(most likely RSA) signature then goes into the signature field of the
ExtensionCert. The memo field could optionally indicate the purpose of this
cert, like "Delegation to BitPay" but I don't think it'd ever appear in the
UI, rather, it should be there for debugging purposes.

The new ExtensionCert can then be provided back to the PP who adds it to
the X509Certificates message. In the PaymentRequest, there are now
*two* signature
fields (this is for backwards compatibility). Because of how the mechanism
is designed they should not interfere with each other - old implementations
that don't understand the new extended_signature field will drop it during
reserialization to set signature to the empty array, and thus signature
should not cover that field. On the other hand, extended_signature would
cover signature. Thus, for full backwards compatibility, you would:

1) Sign the payment request using the PP's SSL cert, i.e. sign as
coinbase.com

2) Then sign again using the PP's delegated ECDSA key, i.e. sign as the
merchant

The finished protobuf would show up in old clients as signed by
coinbase.comand by new clients as signed by
overstock.com even though Overstock did not provide their SSL key to
coinbase.

If you have *only* an ExtensionCert and not any X.509 cert of your own,
then you cannot of course make backwards compatible signatures in this way,
and in that case you would miss out the signature field and set the
pki_type to a new value:  "x509+sha256+excert". Old wallets would see that
they don't understand this pki_type and treat the request as unverified.

For maximum security the merchant may choose to set very short expiry times
(like, a day) and then have a cron job that uploads a new ExtensionCert at
the end of each expiry period. This means in the case of PP compromise, the
system reseals very fast.

*Alternatives considered*

We could always use a new pki_type and not bother with the two signature
fields. However, this means old wallets will show payment requests as
untrusted during the transition period. Some signing is still better than
none, security-wise.

We could attempt to fix the above by introducing a use of User-Agent field
to the case where a payment request is fetched via HTTP, so the server can
customise the PaymentRequest according to the capabilities of the client.
However, sometimes payment requests are not fetched via HTTP, for example,
they may be attached to an email, sent via an IM network or sent over a
Bluetooth socket. Nonetheless this may be a useful thing to consider for
future cases where the protocol may not be extended in a backwards
compatible manner.

We could create the extension cert as an X.509 cert, rather than a custom
type. However most CA's set path length constraints on their intermediate
certs that forbid this kind of extension (I forgot why, possibly some kind
of anti-DoS mitigation). Also re-using X.509 for the extension cert would
open up the risk of it being accepted by a bogus SSL stack that didn't
check the key usage constraints extension, and that would allow for SSL
delegation as well. It seems safer to just use a different format that
definitely won't be accepted.



Feedback welcome.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/35b5bc97/attachment.html>

From wtogami at gmail.com  Fri Feb 28 14:42:14 2014
From: wtogami at gmail.com (Warren Togami Jr.)
Date: Fri, 28 Feb 2014 04:42:14 -1000
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <20140228052523.GO3180@nl.grid.coop>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
	<530B8000.1070801@monetize.io> <20140228052523.GO3180@nl.grid.coop>
Message-ID: <CAEz79Po37XkoQ=+kQOTdagVn-vYuqYwotQf58YcgTndaaAmXNw@mail.gmail.com>

On Thu, Feb 27, 2014 at 7:25 PM, Troy Benjegerdes <hozer at hozed.org> wrote:

>
> Either the transaction fees are sufficient to pay the cost for whatever
> random junk anyone wants to put there, or they are not, and if they are
> not, then I suggest you re-think the fee structure rather than trying
> to pre-regulate me putting 80 character pithy quotes in the blockhain.
>
>
https://github.com/litecoin-project/litecoin/commit/db4d8e21d99551bef4c807aa1534a074e4b7964d

In one way in particular, the transaction fees per kilobyte completely
failed to account for the actual cost to the network.  If Bitcoin had
adopted a common-sense rule like this, I would have had no reason to join
Litecoin development last year.  This is one of the few economic design
flaws that Satoshi overlooked in the original design.

As much as I personally hate the idea of data storage in the blockchain,
this at least discourages the creation of permanent UTXO.

Warren Togami
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/9c9281f9/attachment.html>

From jtimon at monetize.io  Fri Feb 28 17:49:52 2014
From: jtimon at monetize.io (=?ISO-8859-1?Q?Jorge_Tim=F3n?=)
Date: Fri, 28 Feb 2014 18:49:52 +0100
Subject: [Bitcoin-development] Decentralized digital asset exchange with
 honest pricing and market depth
In-Reply-To: <20140228013719.GA5786@savin>
References: <20140209180458.GB20126@savin> <20140209204434.GA11488@savin>
	<20140210193247.GC17359@savin> <20140211175919.GV3180@nl.grid.coop>
	<20140214052159.GF31437@savin> <20140217054751.GY3180@nl.grid.coop>
	<CAC1+kJNTq2sMbORAU-HBSpTVE3ohzsxHrxXw9JOXZp5ux32Gtw@mail.gmail.com>
	<20140228013719.GA5786@savin>
Message-ID: <CAC1+kJPL0NpzihMUfuOvEaE8LoKZehS0PbXFCVMu4_N5MJCJfA@mail.gmail.com>

On 2/28/14, Peter Todd <pete at petertodd.org> wrote:
> As usual, you don't need a hardfork.
>
> Anyway, one-sided trade is sufficient to get a functioning marketplace
> up and running and test out the many other issues with this stuff prior
> to forking anything.

I'm totally FOR experimenting with this as it is and I'm happy that
Alex/Killerstorm is working on "regular" colored coins.

> You can make the same argument against Bitcoin itself you know...
>
> A Bitmessage-like network would be trivial to front-run via a sybil
> attack. It's the fundemental problem with marketplaces - the data
> they're trying to publish has to be public.

I don't see the Bitcoin analogy...
Anyway, I still don't think the seller cares, if he sells at the price
he was asking, what would he care about "front running" those parallel
networks.
I've seen many street markets without "public information" and they
work just well.

>> I don't think this will be a tragedy, because like we discussed on
>> IRC, I don't think the primary goal of markets is price discovery, but
>> trade itself.
>>
>> About historic data, the actual trades are always public, and some
>> kind of "archivers" could collect and maintain old orders for historic
>> bid and asks, etc.
>
> And again, how do you know that record is honest? Fact is without
> proof-of-publication you just don't.

Well, the trades that appeared in the chain actually occurred.
Buying to yourself at fake prices? Be careful, the miner could just
separate the order and fill it himself. Or anyone paying a higher fee,
for that matter.
Again, you haven't addressed why the seller cares more about "accurate
historic market data" than just his own fees and sell.

> You mean a reverse nLockTime that makes a transaction invalid after a
> certain amount of time - that's dangerous in a reorg unfortunately as it
> can make transactions permenantly invalid.

Yes, I'm aware this is a concern for many people and that's why I
bring it up when there's an useful use case (we have several important
uses in freimarkets).
Probably this belongs to another thread or just #wizards, but if I
remember correctly, the last discussion we had about this, I think
with you and gmaxwell, was more or less like this:

-Valid transactions could get invalid with a regorg
-Just like with any transaction if a double-spend appears, this just
means that you would need to wait for expiry transactions to be
somewhat buried to accept payments from it.
-That introduces fungibility problems.
-True, but doesn't seem a particularly difficult problem (I think we
actually drafted some potential solutions, like introducing a maturity
rule for expiry transactions) and the advantages outweigh that
potential problem IMO.

So in summary, I feel like before actually solving the problem we need
to rise more awareness on how nice and necessary nExpiryTime would be.
Anyway, sorry, I just wanted to point out another use, a deeper
discussion about this belongs to another thread.

-- 
Jorge Tim?n

http://freico.in/



From mark at monetize.io  Fri Feb 28 19:25:27 2014
From: mark at monetize.io (Mark Friedenbach)
Date: Fri, 28 Feb 2014 11:25:27 -0800
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAEz79Po37XkoQ=+kQOTdagVn-vYuqYwotQf58YcgTndaaAmXNw@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>	<530B8000.1070801@monetize.io>
	<20140228052523.GO3180@nl.grid.coop>
	<CAEz79Po37XkoQ=+kQOTdagVn-vYuqYwotQf58YcgTndaaAmXNw@mail.gmail.com>
Message-ID: <5310E2A7.3060809@monetize.io>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Transaction fees are a DoS mitigating cost to the person making the
transaction, but they are generally not paid to the people who
actually incur costs in validating the blockchain. Actual transaction
processing costs are an externality that is completely unpaid for.

When I add a 1Kb transaction to the blockchain, there is an attached
fee which probabilistically goes to one of the miners. But every other
full node on the network also receives this transaction, processes it,
and adds it to local storage. From now until the heat death of the
universe that 1Kb of data will be redundantly stored and transmitted
to every single person who validates the block chain. None of these
countless people are reimbursed for their storage, bandwidth, and
processing costs. Not even a single satoshi.

Yes, transaction fees are broken. But it is their very nature which is
broken (sending coins to the miners, not the greater validator set),
and no little tweak like the one Warren links to will fix this.

But, in the absence of a reformed fee regime - which it is not clear
is even possible - one could at least make the hand-wavey argument
that people who validate the block chain receive benefit from it as a
payment network. Therefore processing of the block chain is "paid for"
by the utility it provides once fully synced.

However even this weak argument does not extend to general data
storage. If you want to put all of wikileaks or whatever in the block
chain, then you are extracting a rent from every full node which is
forced to process and store this data for eternity without
compensation or derived utility. You are extorting users of the
payment network into providing a storage service at no cost, because
the alternative (losing bitcoin as a payment network) would cost them
more.

That is not ethical behavior. That is not behavior which responsible
developers should allow in the reference client.

Mark

On 02/28/2014 06:42 AM, Warren Togami Jr. wrote:
> On Thu, Feb 27, 2014 at 7:25 PM, Troy Benjegerdes <hozer at hozed.org 
> <mailto:hozer at hozed.org>> wrote:
> 
> 
> Either the transaction fees are sufficient to pay the cost for
> whatever random junk anyone wants to put there, or they are not,
> and if they are not, then I suggest you re-think the fee structure
> rather than trying to pre-regulate me putting 80 character pithy
> quotes in the blockhain.
> 
> 
> https://github.com/litecoin-project/litecoin/commit/db4d8e21d99551bef4c807aa1534a074e4b7964d
>
>  In one way in particular, the transaction fees per kilobyte
> completely failed to account for the actual cost to the network.
> If Bitcoin had adopted a common-sense rule like this, I would have
> had no reason to join Litecoin development last year.  This is one
> of the few economic design flaws that Satoshi overlooked in the
> original design.
> 
> As much as I personally hate the idea of data storage in the
> blockchain, this at least discourages the creation of permanent
> UTXO.
> 
> Warren Togami
> 
> 
> ------------------------------------------------------------------------------
>
> 
Flow-based real-time traffic analytics software. Cisco certified tool.
> Monitor traffic, SLAs, QoS, Medianet, WAAS etc. with NetFlow
> Analyzer Customize your own dashboards, set traffic alerts and
> generate reports. Network behavioral analysis & security
> monitoring. All-in-one tool. 
> http://pubads.g.doubleclick.net/gampad/clk?id=126839071&iu=/4140/ostg.clktrk
>
> 
> 
> 
> _______________________________________________ Bitcoin-development
> mailing list Bitcoin-development at lists.sourceforge.net 
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.14 (GNU/Linux)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJTEOKjAAoJEAdzVfsmodw4vGIQAJ9OQvHl1+dIaDelrf03lGIf
kQsiuB4JG1rRghsZZiW4NixPbB/Bdm4+m4pep01eiVOPXa+/32AgWVzSYyyMVRYB
oTu24ITgtCu5vkjiHyzSavFnqsi+zMxVpscUekA6l6Tkr3RBNnrIssMiazYc+Bkx
fP2vZehmPHQtp09WkapZ3DMqbMzQ7qPTGlKd1V+9X4S5uUNTdfT6JkC0HIqUSdVQ
PHjjbuulgkdz4b7A6C2dE5kwXVKF9YFHL3zEtObfWDCiyY8wf2XHYI6nVGLbyQeN
nrYCsMH99lUy+zmnbccqSPKhe0p5IaBLauk75zcLxEfzxuKVTvVg2LCaCXQaworv
vBoAURdrB2pCfK8dZ7mllVLLLcNk+iOG0NDZHYE9e884OBfeuaG/zNgmgOD8GC1H
FaDkIpm79x/i3ti3h8vdZPeY0fWdI8yuD9aCQZtvONM9hXdd7Qb07eHqIk7tY/In
7h6zdq27GQUdWN37yslxtDENY2q3yQ39+fjMGQEKVIE6rNwDyjurMCNHAWJp0hZO
7S/rDe2W2tHGPYakscHQh1g/uMAEEb4mGGc5yrfWxyOn5eb9OZiZb8RVXlnDwwH9
qr8qwLJ1b0Uxo981lyEmnLZSpCpAZvDLpjmocqirycNZpvyPnJJbE809vS/koD3d
OutJkMja4TBuqaMSdKEI
=KbW/
-----END PGP SIGNATURE-----



From justusranvier at gmail.com  Fri Feb 28 19:36:31 2014
From: justusranvier at gmail.com (Justus Ranvier)
Date: Fri, 28 Feb 2014 19:36:31 +0000
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <5310E2A7.3060809@monetize.io>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>	<530B8000.1070801@monetize.io>	<20140228052523.GO3180@nl.grid.coop>	<CAEz79Po37XkoQ=+kQOTdagVn-vYuqYwotQf58YcgTndaaAmXNw@mail.gmail.com>
	<5310E2A7.3060809@monetize.io>
Message-ID: <5310E53F.6010601@gmail.com>

On 02/28/2014 07:25 PM, Mark Friedenbach wrote:
> Transaction fees are a DoS mitigating cost to the person making the
> transaction, but they are generally not paid to the people who
> actually incur costs in validating the blockchain. Actual transaction
> processing costs are an externality that is completely unpaid for.

What that means is the network layer is broken and needs to be fixed.

Bitcoin is the blockchain, not the P2P network. If the existing network
is not incentive compatible, then that's the root cause which should be
addressed.

There's no reason to enshrine the broken behavior and use it as a
roadblock to stop progress.


-- 
Support online privacy by using email encryption whenever possible.
Learn how here: http://www.youtube.com/watch?v=bakOKJFtB-k
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0x1B438BF4.asc
Type: application/pgp-keys
Size: 21191 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/28259854/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 555 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/28259854/attachment.sig>

From drak at zikula.org  Fri Feb 28 20:10:32 2014
From: drak at zikula.org (Drak)
Date: Fri, 28 Feb 2014 20:10:32 +0000
Subject: [Bitcoin-development] On OP_RETURN in upcoming 0.9 release
In-Reply-To: <CAEz79Po37XkoQ=+kQOTdagVn-vYuqYwotQf58YcgTndaaAmXNw@mail.gmail.com>
References: <CAJHLa0PXHY1qisXhN98DMxgp11ouqkzYMBvrTTNOtwX09T1kZg@mail.gmail.com>
	<CA+s+GJC1FgCW9spkViMPvuWNS84Ys33pj=RP1ZpzBCa++e-iMQ@mail.gmail.com>
	<530B8000.1070801@monetize.io> <20140228052523.GO3180@nl.grid.coop>
	<CAEz79Po37XkoQ=+kQOTdagVn-vYuqYwotQf58YcgTndaaAmXNw@mail.gmail.com>
Message-ID: <CANAnSg346s0FqhP+57f1TdnCj3=MVht--qGTCpO+BxOpHA=9Uw@mail.gmail.com>

On 28 February 2014 14:42, Warren Togami Jr. <wtogami at gmail.com> wrote:

>
> https://github.com/litecoin-project/litecoin/commit/db4d8e21d99551bef4c807aa1534a074e4b7964d
>
> In one way in particular, the transaction fees per kilobyte completely
> failed to account for the actual cost to the network.  If Bitcoin had
> adopted a common-sense rule like this, I would have had no reason to join
> Litecoin development last year.  This is one of the few economic design
> flaws that Satoshi overlooked in the original design.
>

Is there any particular reason that patch would not make it into bitcoin if
submitted?

Drak
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20140228/c3739720/attachment.html>

