From teekhan42 at gmail.com  Thu Feb  2 19:39:51 2017
From: teekhan42 at gmail.com (t. khan)
Date: Thu, 2 Feb 2017 14:39:51 -0500
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
Message-ID: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>

Please comment on this work-in-progress BIP.

Thanks,

- t.k.

----------------------
BIP: ?
Layer: Process
Title: Community Consensus Voting System
Author: t.khan <teekhan42 at gmail.com>
Comments-Summary: No comments yet.
Comments-URI: TBD
Status: Draft
Type: Standards Track
Created: 2017-02-02
License: BSD-2
Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an example, don?t
send to this!)

Abstract
Community Consensus Voting System (CCVS) will allow developers to measure
support for BIPs prior to implementation.

Motivation
We currently have no way of measuring consensus for potential changes to
the Bitcoin protocol. This is especially problematic for controversial
changes such as the max block size limit. As a result, we have many
proposed solutions but no clear direction.

Also, due to our lack of ability to measure consensus, there is a general
feeling among many in the community that developers aren?t listening to
their concerns. This is a valid complaint, as it?s not possible to listen
to thousands of voices all shouting different things in a crowded
room?basically the situation in the Bitcoin community today.

The CCVS will allow the general public, miners, companies using Bitcoin,
and developers to vote for their preferred BIP in a way that?s public and
relatively difficult (expensive) to manipulate.

Specification
Each competing BIP will be assigned a unique bitcoin address which is added
to each header. Anyone who wanted to vote would cast their ballot by
sending a small amount (0.0001 btc) to their preferred BIP's address. Each
transaction counts as 1 vote.

Confirmed Vote Multiplier:
Mining Pools, companies using Bitcoin, and Core maintainers/contributors
are allowed one confirmed vote each. A confirmed vote is worth 10,000x a
regular vote.

For example:

Slush Pool casts a vote for their preferred BIP and then states publicly
(on their blog) their vote and the transaction ID and emails the URL to the
admin of this system. In the final tally, this vote will count as 10,000
votes.

Coinbase, Antpool, BitPay, BitFury, etc., all do the same.

Confirmed votes would be added to a new section in each respective BIP as a
public record.

Voting would run for a pre-defined period, ending when a particular block
number is mined.


Rationale
Confirmed Vote Multiplier - The purpose of this is twofold; it gives a
larger voice to organizations and the people who will have to do the work
to implement whatever BIP the community prefers, and it will negate the
effect of anyone trying to skew the results by voting repeatedly.

Definitions
Miner: any individual or organization that has mined at least one valid
block in the last 2016 blocks.

Company using Bitcoin: any organization using Bitcoin for financial, asset
or other purposes, with either under development and released solutions.

Developer: any individual who has or had commit access, and any individual
who has authored a BIP

Unresolved Issues
Node voting: It would be desirable for any full node running an up-to-date
blockchain to also be able to vote with a multiplier (e.g. 100x). But as
this would require code changes, it is outside the scope of this BIP.

Copyright
This BIP is licensed under the BSD 2-clause license.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170202/b354d474/attachment.html>

From david.vorick at gmail.com  Thu Feb  2 23:19:39 2017
From: david.vorick at gmail.com (David Vorick)
Date: Thu, 2 Feb 2017 18:19:39 -0500
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
Message-ID: <CAFVRnyqGp9S8HDbHD4Byv26w1afcAorP0JxFq3awMunw6bG=eQ@mail.gmail.com>

I like the idea of having some way for developers to show that they've
given an idea legitimate consideration, as I feel some proposals are often
considered much more in depth before rejection than the proposer realizes,
however I don't think any sort of on-chain system really makes sense. It
complicates things a lot, adds code, incentives, etc. when really all you
care about is some sort of indication of consideration, support, or
rejection.

I also prefer to think of Bitcoin as a system of vetos rather than a system
of approvals. A lot of times changes will be small, highly technical, and
have no visible impact to your every day user. These types of changes don't
really need support outside the devs. Furthermore, I frankly don't give a
crap if we proposal has support from 85% of the participants if there is a
legitimate technical, social, or political reason that it is a bad idea.

And finally, I don't think it should cost money or political power to raise
an objection. A 13yo who has never been seen before should be able to raise
an objection if they indeed have a legitimate objection. Involving money is
almost certainly going to shut down important valid opinions.

And again, I mostly agree with the motivation. It would be good if it were
easier to figure out who had considered a proposal and what their
objections or praises were. But I would like to see that without any
systemization around what is required to pass or fail a proposal, and with
no barrier to entry (such as voting or sending coins or having a recognized
name like 'Bitfury') to provide an opinion.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170202/da014829/attachment.html>

From luke at dashjr.org  Fri Feb  3 00:24:09 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 3 Feb 2017 00:24:09 +0000
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
Message-ID: <201702030024.10232.luke@dashjr.org>

Strongly disagree with buying "votes", or portraying open standards as a 
voting process. Also, this depends on address reuse, so it's fundamentally 
flawed in design.

Some way for people to express their support weighed by coins (without 
losing/spending them), and possibly weighed by running a full node, might 
still be desirable. The most straightforward way to do this is to support 
message signatures somehow (ideally without using the same pubkey as 
spending), and some [inherently unreliable, but perhaps useful if the 
community "colludes" to not-cheat] way to sign with ones' full node.

Note also that the BIP process already has BIP Comments for leaving textual 
opinions on the BIP unrelated to stake. See BIP 2 for details on that.

Luke


On Thursday, February 02, 2017 7:39:51 PM t. khan via bitcoin-dev wrote:
> Please comment on this work-in-progress BIP.
> 
> Thanks,
> 
> - t.k.
> 
> ----------------------
> BIP: ?
> Layer: Process
> Title: Community Consensus Voting System
> Author: t.khan <teekhan42 at gmail.com>
> Comments-Summary: No comments yet.
> Comments-URI: TBD
> Status: Draft
> Type: Standards Track
> Created: 2017-02-02
> License: BSD-2
> Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an example, don?t
> send to this!)
> 
> Abstract
> Community Consensus Voting System (CCVS) will allow developers to measure
> support for BIPs prior to implementation.
> 
> Motivation
> We currently have no way of measuring consensus for potential changes to
> the Bitcoin protocol. This is especially problematic for controversial
> changes such as the max block size limit. As a result, we have many
> proposed solutions but no clear direction.
> 
> Also, due to our lack of ability to measure consensus, there is a general
> feeling among many in the community that developers aren?t listening to
> their concerns. This is a valid complaint, as it?s not possible to listen
> to thousands of voices all shouting different things in a crowded
> room?basically the situation in the Bitcoin community today.
> 
> The CCVS will allow the general public, miners, companies using Bitcoin,
> and developers to vote for their preferred BIP in a way that?s public and
> relatively difficult (expensive) to manipulate.
> 
> Specification
> Each competing BIP will be assigned a unique bitcoin address which is added
> to each header. Anyone who wanted to vote would cast their ballot by
> sending a small amount (0.0001 btc) to their preferred BIP's address. Each
> transaction counts as 1 vote.
> 
> Confirmed Vote Multiplier:
> Mining Pools, companies using Bitcoin, and Core maintainers/contributors
> are allowed one confirmed vote each. A confirmed vote is worth 10,000x a
> regular vote.
> 
> For example:
> 
> Slush Pool casts a vote for their preferred BIP and then states publicly
> (on their blog) their vote and the transaction ID and emails the URL to the
> admin of this system. In the final tally, this vote will count as 10,000
> votes.
> 
> Coinbase, Antpool, BitPay, BitFury, etc., all do the same.
> 
> Confirmed votes would be added to a new section in each respective BIP as a
> public record.
> 
> Voting would run for a pre-defined period, ending when a particular block
> number is mined.
> 
> 
> Rationale
> Confirmed Vote Multiplier - The purpose of this is twofold; it gives a
> larger voice to organizations and the people who will have to do the work
> to implement whatever BIP the community prefers, and it will negate the
> effect of anyone trying to skew the results by voting repeatedly.
> 
> Definitions
> Miner: any individual or organization that has mined at least one valid
> block in the last 2016 blocks.
> 
> Company using Bitcoin: any organization using Bitcoin for financial, asset
> or other purposes, with either under development and released solutions.
> 
> Developer: any individual who has or had commit access, and any individual
> who has authored a BIP
> 
> Unresolved Issues
> Node voting: It would be desirable for any full node running an up-to-date
> blockchain to also be able to vote with a multiplier (e.g. 100x). But as
> this would require code changes, it is outside the scope of this BIP.
> 
> Copyright
> This BIP is licensed under the BSD 2-clause license.

From dscotese at litmocracy.com  Fri Feb  3 01:32:34 2017
From: dscotese at litmocracy.com (Dave Scotese)
Date: Thu, 2 Feb 2017 17:32:34 -0800
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <201702030024.10232.luke@dashjr.org>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
Message-ID: <CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>

There are two ideas here for "on-chain" voting, both of which require
changes to the software.  I agree with David that on-chain solutions
complicate things.  Both proposals can be effected without any software
changes:

Those who wish to use proof of stake can provide a service for making
vanity addresses containing some indicator of the proposal to be supported
- 1bigblock or 12mbblk or whatever - based on a supporter-provided secret
key, and then supporters can move their bitcoin into their own vanity
address and then whoever wants to can create a website to display the
matching addresses and explain that this is the financial power in the
hands of supporters and how to add your "financial power vote."

Those who simply want to "buy votes" can use their funds in marketing
efforts to promote the proposal they support.

This second method, of course, can be abused.  The first actually requires
people to control bitcoin in order to represent support.  Counting actual,
real people is still a technology in its infancy, and I don't think I want
to see it progress much. People are not units, but individuals, and their
value only becomes correlated to their net worth after they've been alive
for many years, and even then, some of the best people have died paupers.
If bitcoin-discuss got more traffic, I think this discussion would be
better had on that list.

notplato

On Thu, Feb 2, 2017 at 4:24 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Strongly disagree with buying "votes", or portraying open standards as a
> voting process. Also, this depends on address reuse, so it's fundamentally
> flawed in design.
>
> Some way for people to express their support weighed by coins (without
> losing/spending them), and possibly weighed by running a full node, might
> still be desirable. The most straightforward way to do this is to support
> message signatures somehow (ideally without using the same pubkey as
> spending), and some [inherently unreliable, but perhaps useful if the
> community "colludes" to not-cheat] way to sign with ones' full node.
>
> Note also that the BIP process already has BIP Comments for leaving textual
> opinions on the BIP unrelated to stake. See BIP 2 for details on that.
>
> Luke
>
>
> On Thursday, February 02, 2017 7:39:51 PM t. khan via bitcoin-dev wrote:
> > Please comment on this work-in-progress BIP.
> >
> > Thanks,
> >
> > - t.k.
> >
> > ----------------------
> > BIP: ?
> > Layer: Process
> > Title: Community Consensus Voting System
> > Author: t.khan <teekhan42 at gmail.com>
> > Comments-Summary: No comments yet.
> > Comments-URI: TBD
> > Status: Draft
> > Type: Standards Track
> > Created: 2017-02-02
> > License: BSD-2
> > Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an example,
> don?t
> > send to this!)
> >
> > Abstract
> > Community Consensus Voting System (CCVS) will allow developers to measure
> > support for BIPs prior to implementation.
> >
> > Motivation
> > We currently have no way of measuring consensus for potential changes to
> > the Bitcoin protocol. This is especially problematic for controversial
> > changes such as the max block size limit. As a result, we have many
> > proposed solutions but no clear direction.
> >
> > Also, due to our lack of ability to measure consensus, there is a general
> > feeling among many in the community that developers aren?t listening to
> > their concerns. This is a valid complaint, as it?s not possible to listen
> > to thousands of voices all shouting different things in a crowded
> > room?basically the situation in the Bitcoin community today.
> >
> > The CCVS will allow the general public, miners, companies using Bitcoin,
> > and developers to vote for their preferred BIP in a way that?s public and
> > relatively difficult (expensive) to manipulate.
> >
> > Specification
> > Each competing BIP will be assigned a unique bitcoin address which is
> added
> > to each header. Anyone who wanted to vote would cast their ballot by
> > sending a small amount (0.0001 btc) to their preferred BIP's address.
> Each
> > transaction counts as 1 vote.
> >
> > Confirmed Vote Multiplier:
> > Mining Pools, companies using Bitcoin, and Core maintainers/contributors
> > are allowed one confirmed vote each. A confirmed vote is worth 10,000x a
> > regular vote.
> >
> > For example:
> >
> > Slush Pool casts a vote for their preferred BIP and then states publicly
> > (on their blog) their vote and the transaction ID and emails the URL to
> the
> > admin of this system. In the final tally, this vote will count as 10,000
> > votes.
> >
> > Coinbase, Antpool, BitPay, BitFury, etc., all do the same.
> >
> > Confirmed votes would be added to a new section in each respective BIP
> as a
> > public record.
> >
> > Voting would run for a pre-defined period, ending when a particular block
> > number is mined.
> >
> >
> > Rationale
> > Confirmed Vote Multiplier - The purpose of this is twofold; it gives a
> > larger voice to organizations and the people who will have to do the work
> > to implement whatever BIP the community prefers, and it will negate the
> > effect of anyone trying to skew the results by voting repeatedly.
> >
> > Definitions
> > Miner: any individual or organization that has mined at least one valid
> > block in the last 2016 blocks.
> >
> > Company using Bitcoin: any organization using Bitcoin for financial,
> asset
> > or other purposes, with either under development and released solutions.
> >
> > Developer: any individual who has or had commit access, and any
> individual
> > who has authored a BIP
> >
> > Unresolved Issues
> > Node voting: It would be desirable for any full node running an
> up-to-date
> > blockchain to also be able to vote with a multiplier (e.g. 100x). But as
> > this would require code changes, it is outside the scope of this BIP.
> >
> > Copyright
> > This BIP is licensed under the BSD 2-clause license.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170202/b5c28eed/attachment-0001.html>

From alp.bitcoin at gmail.com  Fri Feb  3 16:19:19 2017
From: alp.bitcoin at gmail.com (alp alp)
Date: Fri, 3 Feb 2017 10:19:19 -0600
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
Message-ID: <CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>

This proposal seems hopelessly broken.

Who decides on which companies are eligible?  Is there some kind of
centralized database that one registers?  Who administers this?  What is to
stop someone from creating a million fake companies to sway the voting?
How does a company make it's vote?  How does one verify that the person
voting on behalf of a company is actually the correct person?



On Thu, Feb 2, 2017 at 7:32 PM, Dave Scotese via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> There are two ideas here for "on-chain" voting, both of which require
> changes to the software.  I agree with David that on-chain solutions
> complicate things.  Both proposals can be effected without any software
> changes:
>
> Those who wish to use proof of stake can provide a service for making
> vanity addresses containing some indicator of the proposal to be supported
> - 1bigblock or 12mbblk or whatever - based on a supporter-provided secret
> key, and then supporters can move their bitcoin into their own vanity
> address and then whoever wants to can create a website to display the
> matching addresses and explain that this is the financial power in the
> hands of supporters and how to add your "financial power vote."
>
> Those who simply want to "buy votes" can use their funds in marketing
> efforts to promote the proposal they support.
>
> This second method, of course, can be abused.  The first actually requires
> people to control bitcoin in order to represent support.  Counting actual,
> real people is still a technology in its infancy, and I don't think I want
> to see it progress much. People are not units, but individuals, and their
> value only becomes correlated to their net worth after they've been alive
> for many years, and even then, some of the best people have died paupers.
> If bitcoin-discuss got more traffic, I think this discussion would be
> better had on that list.
>
> notplato
>
> On Thu, Feb 2, 2017 at 4:24 PM, Luke Dashjr via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Strongly disagree with buying "votes", or portraying open standards as a
>> voting process. Also, this depends on address reuse, so it's fundamentally
>> flawed in design.
>>
>> Some way for people to express their support weighed by coins (without
>> losing/spending them), and possibly weighed by running a full node, might
>> still be desirable. The most straightforward way to do this is to support
>> message signatures somehow (ideally without using the same pubkey as
>> spending), and some [inherently unreliable, but perhaps useful if the
>> community "colludes" to not-cheat] way to sign with ones' full node.
>>
>> Note also that the BIP process already has BIP Comments for leaving
>> textual
>> opinions on the BIP unrelated to stake. See BIP 2 for details on that.
>>
>> Luke
>>
>>
>> On Thursday, February 02, 2017 7:39:51 PM t. khan via bitcoin-dev wrote:
>> > Please comment on this work-in-progress BIP.
>> >
>> > Thanks,
>> >
>> > - t.k.
>> >
>> > ----------------------
>> > BIP: ?
>> > Layer: Process
>> > Title: Community Consensus Voting System
>> > Author: t.khan <teekhan42 at gmail.com>
>> > Comments-Summary: No comments yet.
>> > Comments-URI: TBD
>> > Status: Draft
>> > Type: Standards Track
>> > Created: 2017-02-02
>> > License: BSD-2
>> > Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an example,
>> don?t
>> > send to this!)
>> >
>> > Abstract
>> > Community Consensus Voting System (CCVS) will allow developers to
>> measure
>> > support for BIPs prior to implementation.
>> >
>> > Motivation
>> > We currently have no way of measuring consensus for potential changes to
>> > the Bitcoin protocol. This is especially problematic for controversial
>> > changes such as the max block size limit. As a result, we have many
>> > proposed solutions but no clear direction.
>> >
>> > Also, due to our lack of ability to measure consensus, there is a
>> general
>> > feeling among many in the community that developers aren?t listening to
>> > their concerns. This is a valid complaint, as it?s not possible to
>> listen
>> > to thousands of voices all shouting different things in a crowded
>> > room?basically the situation in the Bitcoin community today.
>> >
>> > The CCVS will allow the general public, miners, companies using Bitcoin,
>> > and developers to vote for their preferred BIP in a way that?s public
>> and
>> > relatively difficult (expensive) to manipulate.
>> >
>> > Specification
>> > Each competing BIP will be assigned a unique bitcoin address which is
>> added
>> > to each header. Anyone who wanted to vote would cast their ballot by
>> > sending a small amount (0.0001 btc) to their preferred BIP's address.
>> Each
>> > transaction counts as 1 vote.
>> >
>> > Confirmed Vote Multiplier:
>> > Mining Pools, companies using Bitcoin, and Core maintainers/contributors
>> > are allowed one confirmed vote each. A confirmed vote is worth 10,000x a
>> > regular vote.
>> >
>> > For example:
>> >
>> > Slush Pool casts a vote for their preferred BIP and then states publicly
>> > (on their blog) their vote and the transaction ID and emails the URL to
>> the
>> > admin of this system. In the final tally, this vote will count as 10,000
>> > votes.
>> >
>> > Coinbase, Antpool, BitPay, BitFury, etc., all do the same.
>> >
>> > Confirmed votes would be added to a new section in each respective BIP
>> as a
>> > public record.
>> >
>> > Voting would run for a pre-defined period, ending when a particular
>> block
>> > number is mined.
>> >
>> >
>> > Rationale
>> > Confirmed Vote Multiplier - The purpose of this is twofold; it gives a
>> > larger voice to organizations and the people who will have to do the
>> work
>> > to implement whatever BIP the community prefers, and it will negate the
>> > effect of anyone trying to skew the results by voting repeatedly.
>> >
>> > Definitions
>> > Miner: any individual or organization that has mined at least one valid
>> > block in the last 2016 blocks.
>> >
>> > Company using Bitcoin: any organization using Bitcoin for financial,
>> asset
>> > or other purposes, with either under development and released solutions.
>> >
>> > Developer: any individual who has or had commit access, and any
>> individual
>> > who has authored a BIP
>> >
>> > Unresolved Issues
>> > Node voting: It would be desirable for any full node running an
>> up-to-date
>> > blockchain to also be able to vote with a multiplier (e.g. 100x). But as
>> > this would require code changes, it is outside the scope of this BIP.
>> >
>> > Copyright
>> > This BIP is licensed under the BSD 2-clause license.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
>
> --
> I like to provide some work at no charge to prove my value. Do you need a
> techie?
> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
> <http://www.memeracing.net> (in alpha).
> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
> which now accepts Bitcoin.
> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> "He ought to find it more profitable to play by the rules" - Satoshi
> Nakamoto
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170203/1e9eea61/attachment.html>

From teekhan42 at gmail.com  Fri Feb  3 18:20:13 2017
From: teekhan42 at gmail.com (t. khan)
Date: Fri, 3 Feb 2017 13:20:13 -0500
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
	<CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
Message-ID: <CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>

Most of these are answered in the BIP, but for clarity:

>Who decides on which companies are eligible?
Preferably no one decides. The company would have to exist prior to the
vote, and would need a public-facing website. In the event of contested
votes (meaning someone finds evidence of a fake company), the admin could
investigate and post results.

>Is there some kind of centralized database that one registers?
No.

>Who administers this?
I don't know. I'm happy to volunteer, if no one else wants to be
responsible for it. The only task would be adding the confirmed votes to
each respective BIP. From there, everything's public and can be confirmed
by everyone.

>What is to stop someone from creating a million fake companies to sway the
voting?
The logistics of doing that prevent it. But let's say 10 fake companies ...
first, you'd need to register ten domain names, host and customize the
website, all before the vote and in a way that no one would notice.

>How does a company make it's vote?
Someone at the company sends a very small transaction to the BIP's vote
address. Someone at the company then posts what the vote was and its
transaction ID on the company's blog/twitter, etc., and then emails the URL
to the administrator.

>How does one verify that the person voting on behalf of a company is
actually the correct person?
They post it on their company blog.

On Fri, Feb 3, 2017 at 11:19 AM, alp alp via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This proposal seems hopelessly broken.
>
> Who decides on which companies are eligible?  Is there some kind of
> centralized database that one registers?  Who administers this?  What is to
> stop someone from creating a million fake companies to sway the voting?
> How does a company make it's vote?  How does one verify that the person
> voting on behalf of a company is actually the correct person?
>
>
>
> On Thu, Feb 2, 2017 at 7:32 PM, Dave Scotese via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> There are two ideas here for "on-chain" voting, both of which require
>> changes to the software.  I agree with David that on-chain solutions
>> complicate things.  Both proposals can be effected without any software
>> changes:
>>
>> Those who wish to use proof of stake can provide a service for making
>> vanity addresses containing some indicator of the proposal to be supported
>> - 1bigblock or 12mbblk or whatever - based on a supporter-provided secret
>> key, and then supporters can move their bitcoin into their own vanity
>> address and then whoever wants to can create a website to display the
>> matching addresses and explain that this is the financial power in the
>> hands of supporters and how to add your "financial power vote."
>>
>> Those who simply want to "buy votes" can use their funds in marketing
>> efforts to promote the proposal they support.
>>
>> This second method, of course, can be abused.  The first actually
>> requires people to control bitcoin in order to represent support.  Counting
>> actual, real people is still a technology in its infancy, and I don't think
>> I want to see it progress much. People are not units, but individuals, and
>> their value only becomes correlated to their net worth after they've been
>> alive for many years, and even then, some of the best people have died
>> paupers. If bitcoin-discuss got more traffic, I think this discussion would
>> be better had on that list.
>>
>> notplato
>>
>> On Thu, Feb 2, 2017 at 4:24 PM, Luke Dashjr via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Strongly disagree with buying "votes", or portraying open standards as a
>>> voting process. Also, this depends on address reuse, so it's
>>> fundamentally
>>> flawed in design.
>>>
>>> Some way for people to express their support weighed by coins (without
>>> losing/spending them), and possibly weighed by running a full node, might
>>> still be desirable. The most straightforward way to do this is to support
>>> message signatures somehow (ideally without using the same pubkey as
>>> spending), and some [inherently unreliable, but perhaps useful if the
>>> community "colludes" to not-cheat] way to sign with ones' full node.
>>>
>>> Note also that the BIP process already has BIP Comments for leaving
>>> textual
>>> opinions on the BIP unrelated to stake. See BIP 2 for details on that.
>>>
>>> Luke
>>>
>>>
>>> On Thursday, February 02, 2017 7:39:51 PM t. khan via bitcoin-dev wrote:
>>> > Please comment on this work-in-progress BIP.
>>> >
>>> > Thanks,
>>> >
>>> > - t.k.
>>> >
>>> > ----------------------
>>> > BIP: ?
>>> > Layer: Process
>>> > Title: Community Consensus Voting System
>>> > Author: t.khan <teekhan42 at gmail.com>
>>> > Comments-Summary: No comments yet.
>>> > Comments-URI: TBD
>>> > Status: Draft
>>> > Type: Standards Track
>>> > Created: 2017-02-02
>>> > License: BSD-2
>>> > Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an example,
>>> don?t
>>> > send to this!)
>>> >
>>> > Abstract
>>> > Community Consensus Voting System (CCVS) will allow developers to
>>> measure
>>> > support for BIPs prior to implementation.
>>> >
>>> > Motivation
>>> > We currently have no way of measuring consensus for potential changes
>>> to
>>> > the Bitcoin protocol. This is especially problematic for controversial
>>> > changes such as the max block size limit. As a result, we have many
>>> > proposed solutions but no clear direction.
>>> >
>>> > Also, due to our lack of ability to measure consensus, there is a
>>> general
>>> > feeling among many in the community that developers aren?t listening to
>>> > their concerns. This is a valid complaint, as it?s not possible to
>>> listen
>>> > to thousands of voices all shouting different things in a crowded
>>> > room?basically the situation in the Bitcoin community today.
>>> >
>>> > The CCVS will allow the general public, miners, companies using
>>> Bitcoin,
>>> > and developers to vote for their preferred BIP in a way that?s public
>>> and
>>> > relatively difficult (expensive) to manipulate.
>>> >
>>> > Specification
>>> > Each competing BIP will be assigned a unique bitcoin address which is
>>> added
>>> > to each header. Anyone who wanted to vote would cast their ballot by
>>> > sending a small amount (0.0001 btc) to their preferred BIP's address.
>>> Each
>>> > transaction counts as 1 vote.
>>> >
>>> > Confirmed Vote Multiplier:
>>> > Mining Pools, companies using Bitcoin, and Core
>>> maintainers/contributors
>>> > are allowed one confirmed vote each. A confirmed vote is worth 10,000x
>>> a
>>> > regular vote.
>>> >
>>> > For example:
>>> >
>>> > Slush Pool casts a vote for their preferred BIP and then states
>>> publicly
>>> > (on their blog) their vote and the transaction ID and emails the URL
>>> to the
>>> > admin of this system. In the final tally, this vote will count as
>>> 10,000
>>> > votes.
>>> >
>>> > Coinbase, Antpool, BitPay, BitFury, etc., all do the same.
>>> >
>>> > Confirmed votes would be added to a new section in each respective BIP
>>> as a
>>> > public record.
>>> >
>>> > Voting would run for a pre-defined period, ending when a particular
>>> block
>>> > number is mined.
>>> >
>>> >
>>> > Rationale
>>> > Confirmed Vote Multiplier - The purpose of this is twofold; it gives a
>>> > larger voice to organizations and the people who will have to do the
>>> work
>>> > to implement whatever BIP the community prefers, and it will negate the
>>> > effect of anyone trying to skew the results by voting repeatedly.
>>> >
>>> > Definitions
>>> > Miner: any individual or organization that has mined at least one valid
>>> > block in the last 2016 blocks.
>>> >
>>> > Company using Bitcoin: any organization using Bitcoin for financial,
>>> asset
>>> > or other purposes, with either under development and released
>>> solutions.
>>> >
>>> > Developer: any individual who has or had commit access, and any
>>> individual
>>> > who has authored a BIP
>>> >
>>> > Unresolved Issues
>>> > Node voting: It would be desirable for any full node running an
>>> up-to-date
>>> > blockchain to also be able to vote with a multiplier (e.g. 100x). But
>>> as
>>> > this would require code changes, it is outside the scope of this BIP.
>>> >
>>> > Copyright
>>> > This BIP is licensed under the BSD 2-clause license.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>>
>>
>> --
>> I like to provide some work at no charge to prove my value. Do you need a
>> techie?
>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
>> <http://www.memeracing.net> (in alpha).
>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
>> which now accepts Bitcoin.
>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
>> "He ought to find it more profitable to play by the rules" - Satoshi
>> Nakamoto
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170203/062e0401/attachment-0001.html>

From mirelo at deugh-ausgam-valis.com  Sat Feb  4 12:39:45 2017
From: mirelo at deugh-ausgam-valis.com (Mirelo)
Date: Sat, 04 Feb 2017 07:39:45 -0500
Subject: [bitcoin-dev] Proof-of-Loss
Message-ID: <xDk8CtqtLEE1SOMmY3ztYPDFREGNIm4OvJESS_TlQpGerVbz4MNI0uOmE3ERXSsHSYEZE7gG1rfRAyXg9x-ziA0BrMkW1RdhNIQwO1MqYao=@deugh-ausgam-valis.com>

An alternative consensus algorithm to both proof-of-work and proof-of-stake, proof-of-loss addresses all their deficiencies, including the lack of an organic block size limit, the risks of mining centralization, and the "nothing at stake" problem:

https://proof-of-loss.money/
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170204/e577c789/attachment.html>

From john at seebitcoin.com  Fri Feb  3 00:13:04 2017
From: john at seebitcoin.com (John Hardy)
Date: Fri, 3 Feb 2017 00:13:04 +0000
Subject: [bitcoin-dev] Transaction signalling through output address hashing
Message-ID: <BL2PR03MB4358286BE7F0D51F99B8EC6EE4C0@BL2PR03MB435.namprd03.prod.outlook.com>

Currently in order to signal support for changes to Bitcoin, only miners are able to do so on the blockchain through BIP9.


One criticism is that the rest of the community is not able to participate in consensus, and other methods of assessing community support are fuzzy and easily manipulated through Sybil.


I was trying to think if there was a way community support could be signaled through transactions without requiring a hard fork, and without increasing the size of transactions at all.


My solution is basically inspired by hashcash and vanity addresses.


The output address of a transaction could basically have the last 4 characters used to signal support for a particular proposal.

To generate an address with 4 consecutive case-insensitive characters should be roughly 34^4 which is just over a million attempts. On typical hardware this should take less than a second.

An example bitcoin address that wanted to support the core roadmap might be:

1CLNgjuu8s51umTA76Zi8v6EdvDp8qCorE


or to signal support for a big block proposal might be:

1N62SRhBioRFrigS5eJ8kR1WYcfcYr16mB


Popularity could be measured weighted by fee paid per voting kb.


Issues are that this could lead to transactions been censored by particular miners for political reasons. Also miners might attempt to manipulate the results by stuffing their block with 'fake' transactions. Such attempts could be identified if a large number of voting transactions were not in the mempool.


Despite the limitations, I believe this offers a very accessible way to immediately allow the entire economic community to signal their support within transactions. The only cost is that of a tiny hashing PoW that should tie up a CPU for a barely noticeable amount of time, and could be implemented relatively easily into wallet software.


For its weaknesses, surely it is better than the existing methods we use to assess support from the wider economic community?


While it could just be used for signaling support and giving users a 'voice' on chain, if considered effective it could also be used to activate changes in the future.


Any thoughts welcome.


Thanks,


John Hardy

john at seebitcoin.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170203/1916d1f2/attachment-0001.html>

From alp.bitcoin at gmail.com  Fri Feb  3 19:22:10 2017
From: alp.bitcoin at gmail.com (alp alp)
Date: Fri, 3 Feb 2017 13:22:10 -0600
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
	<CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
	<CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
Message-ID: <CAMBsKS91EAe=Jk9=QRgaPJ2ev6n=i3OU42F6Pu3eVqS9=P6p=w@mail.gmail.com>

These are non-answers.  Someone must decide.  Someone must decide what kind
of company counts (e.g. does a dark market seller count as a business?
Does some guy who sells $10/year worth of goods using Bitcoin count the
same as large companies like Coinbase/BitPay/Blockstream).  Someone must
decide which websites are checked for votes or addresses.  Someone must
decide if a rogue employee made a transaction on behalf of the company or
not.

Registering domain names is trivial and can be automated if the incentives
were needed for it.

You mention developers who have commit access.  This excludes the vast
majority of developers.  You also don't mention which repositories count.
Do the developers of bcoin count or not?

These questions all would need to be answered before any kind of proposal
like this can be taken seriously.  Without these kinds of answers, this
proposal is far from complete.


On Fri, Feb 3, 2017 at 12:20 PM, t. khan <teekhan42 at gmail.com> wrote:

> Most of these are answered in the BIP, but for clarity:
>
> >Who decides on which companies are eligible?
> Preferably no one decides. The company would have to exist prior to the
> vote, and would need a public-facing website. In the event of contested
> votes (meaning someone finds evidence of a fake company), the admin could
> investigate and post results.
>
> >Is there some kind of centralized database that one registers?
> No.
>
> >Who administers this?
> I don't know. I'm happy to volunteer, if no one else wants to be
> responsible for it. The only task would be adding the confirmed votes to
> each respective BIP. From there, everything's public and can be confirmed
> by everyone.
>
> >What is to stop someone from creating a million fake companies to sway
> the voting?
> The logistics of doing that prevent it. But let's say 10 fake companies
> ... first, you'd need to register ten domain names, host and customize the
> website, all before the vote and in a way that no one would notice.
>
> >How does a company make it's vote?
> Someone at the company sends a very small transaction to the BIP's vote
> address. Someone at the company then posts what the vote was and its
> transaction ID on the company's blog/twitter, etc., and then emails the URL
> to the administrator.
>
> >How does one verify that the person voting on behalf of a company is
> actually the correct person?
> They post it on their company blog.
>
> On Fri, Feb 3, 2017 at 11:19 AM, alp alp via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> This proposal seems hopelessly broken.
>>
>> Who decides on which companies are eligible?  Is there some kind of
>> centralized database that one registers?  Who administers this?  What is to
>> stop someone from creating a million fake companies to sway the voting?
>> How does a company make it's vote?  How does one verify that the person
>> voting on behalf of a company is actually the correct person?
>>
>>
>>
>> On Thu, Feb 2, 2017 at 7:32 PM, Dave Scotese via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> There are two ideas here for "on-chain" voting, both of which require
>>> changes to the software.  I agree with David that on-chain solutions
>>> complicate things.  Both proposals can be effected without any software
>>> changes:
>>>
>>> Those who wish to use proof of stake can provide a service for making
>>> vanity addresses containing some indicator of the proposal to be supported
>>> - 1bigblock or 12mbblk or whatever - based on a supporter-provided secret
>>> key, and then supporters can move their bitcoin into their own vanity
>>> address and then whoever wants to can create a website to display the
>>> matching addresses and explain that this is the financial power in the
>>> hands of supporters and how to add your "financial power vote."
>>>
>>> Those who simply want to "buy votes" can use their funds in marketing
>>> efforts to promote the proposal they support.
>>>
>>> This second method, of course, can be abused.  The first actually
>>> requires people to control bitcoin in order to represent support.  Counting
>>> actual, real people is still a technology in its infancy, and I don't think
>>> I want to see it progress much. People are not units, but individuals, and
>>> their value only becomes correlated to their net worth after they've been
>>> alive for many years, and even then, some of the best people have died
>>> paupers. If bitcoin-discuss got more traffic, I think this discussion would
>>> be better had on that list.
>>>
>>> notplato
>>>
>>> On Thu, Feb 2, 2017 at 4:24 PM, Luke Dashjr via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Strongly disagree with buying "votes", or portraying open standards as a
>>>> voting process. Also, this depends on address reuse, so it's
>>>> fundamentally
>>>> flawed in design.
>>>>
>>>> Some way for people to express their support weighed by coins (without
>>>> losing/spending them), and possibly weighed by running a full node,
>>>> might
>>>> still be desirable. The most straightforward way to do this is to
>>>> support
>>>> message signatures somehow (ideally without using the same pubkey as
>>>> spending), and some [inherently unreliable, but perhaps useful if the
>>>> community "colludes" to not-cheat] way to sign with ones' full node.
>>>>
>>>> Note also that the BIP process already has BIP Comments for leaving
>>>> textual
>>>> opinions on the BIP unrelated to stake. See BIP 2 for details on that.
>>>>
>>>> Luke
>>>>
>>>>
>>>> On Thursday, February 02, 2017 7:39:51 PM t. khan via bitcoin-dev wrote:
>>>> > Please comment on this work-in-progress BIP.
>>>> >
>>>> > Thanks,
>>>> >
>>>> > - t.k.
>>>> >
>>>> > ----------------------
>>>> > BIP: ?
>>>> > Layer: Process
>>>> > Title: Community Consensus Voting System
>>>> > Author: t.khan <teekhan42 at gmail.com>
>>>> > Comments-Summary: No comments yet.
>>>> > Comments-URI: TBD
>>>> > Status: Draft
>>>> > Type: Standards Track
>>>> > Created: 2017-02-02
>>>> > License: BSD-2
>>>> > Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an
>>>> example, don?t
>>>> > send to this!)
>>>> >
>>>> > Abstract
>>>> > Community Consensus Voting System (CCVS) will allow developers to
>>>> measure
>>>> > support for BIPs prior to implementation.
>>>> >
>>>> > Motivation
>>>> > We currently have no way of measuring consensus for potential changes
>>>> to
>>>> > the Bitcoin protocol. This is especially problematic for controversial
>>>> > changes such as the max block size limit. As a result, we have many
>>>> > proposed solutions but no clear direction.
>>>> >
>>>> > Also, due to our lack of ability to measure consensus, there is a
>>>> general
>>>> > feeling among many in the community that developers aren?t listening
>>>> to
>>>> > their concerns. This is a valid complaint, as it?s not possible to
>>>> listen
>>>> > to thousands of voices all shouting different things in a crowded
>>>> > room?basically the situation in the Bitcoin community today.
>>>> >
>>>> > The CCVS will allow the general public, miners, companies using
>>>> Bitcoin,
>>>> > and developers to vote for their preferred BIP in a way that?s public
>>>> and
>>>> > relatively difficult (expensive) to manipulate.
>>>> >
>>>> > Specification
>>>> > Each competing BIP will be assigned a unique bitcoin address which is
>>>> added
>>>> > to each header. Anyone who wanted to vote would cast their ballot by
>>>> > sending a small amount (0.0001 btc) to their preferred BIP's address.
>>>> Each
>>>> > transaction counts as 1 vote.
>>>> >
>>>> > Confirmed Vote Multiplier:
>>>> > Mining Pools, companies using Bitcoin, and Core
>>>> maintainers/contributors
>>>> > are allowed one confirmed vote each. A confirmed vote is worth
>>>> 10,000x a
>>>> > regular vote.
>>>> >
>>>> > For example:
>>>> >
>>>> > Slush Pool casts a vote for their preferred BIP and then states
>>>> publicly
>>>> > (on their blog) their vote and the transaction ID and emails the URL
>>>> to the
>>>> > admin of this system. In the final tally, this vote will count as
>>>> 10,000
>>>> > votes.
>>>> >
>>>> > Coinbase, Antpool, BitPay, BitFury, etc., all do the same.
>>>> >
>>>> > Confirmed votes would be added to a new section in each respective
>>>> BIP as a
>>>> > public record.
>>>> >
>>>> > Voting would run for a pre-defined period, ending when a particular
>>>> block
>>>> > number is mined.
>>>> >
>>>> >
>>>> > Rationale
>>>> > Confirmed Vote Multiplier - The purpose of this is twofold; it gives a
>>>> > larger voice to organizations and the people who will have to do the
>>>> work
>>>> > to implement whatever BIP the community prefers, and it will negate
>>>> the
>>>> > effect of anyone trying to skew the results by voting repeatedly.
>>>> >
>>>> > Definitions
>>>> > Miner: any individual or organization that has mined at least one
>>>> valid
>>>> > block in the last 2016 blocks.
>>>> >
>>>> > Company using Bitcoin: any organization using Bitcoin for financial,
>>>> asset
>>>> > or other purposes, with either under development and released
>>>> solutions.
>>>> >
>>>> > Developer: any individual who has or had commit access, and any
>>>> individual
>>>> > who has authored a BIP
>>>> >
>>>> > Unresolved Issues
>>>> > Node voting: It would be desirable for any full node running an
>>>> up-to-date
>>>> > blockchain to also be able to vote with a multiplier (e.g. 100x). But
>>>> as
>>>> > this would require code changes, it is outside the scope of this BIP.
>>>> >
>>>> > Copyright
>>>> > This BIP is licensed under the BSD 2-clause license.
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>
>>>
>>>
>>> --
>>> I like to provide some work at no charge to prove my value. Do you need
>>> a techie?
>>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
>>> <http://www.memeracing.net> (in alpha).
>>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
>>> which now accepts Bitcoin.
>>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
>>> "He ought to find it more profitable to play by the rules" - Satoshi
>>> Nakamoto
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170203/6273c7f4/attachment-0001.html>

From cp368202 at ohiou.edu  Sat Feb  4 00:57:52 2017
From: cp368202 at ohiou.edu (Chris Priest)
Date: Fri, 3 Feb 2017 16:57:52 -0800
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
	<CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
	<CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
Message-ID: <CAAcC9yuzgKWGXxbZLM+21pvRZmYV+nDAMBWMpZXCg6RUYHXRWQ@mail.gmail.com>

Personally I think once the blocksize arguments are solved, there will
be no more contentious changes for this voting system to deal with.
What other contentious issues have come up in the past 3 years or so
that wasn't blocksize/scaling related? Do other protocols like TCP/IP
and the HTTP protocol have developers arguing every day over issues no
one can agree on?

On 2/3/17, t. khan via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Most of these are answered in the BIP, but for clarity:
>
>>Who decides on which companies are eligible?
> Preferably no one decides. The company would have to exist prior to the
> vote, and would need a public-facing website. In the event of contested
> votes (meaning someone finds evidence of a fake company), the admin could
> investigate and post results.
>
>>Is there some kind of centralized database that one registers?
> No.
>
>>Who administers this?
> I don't know. I'm happy to volunteer, if no one else wants to be
> responsible for it. The only task would be adding the confirmed votes to
> each respective BIP. From there, everything's public and can be confirmed
> by everyone.
>
>>What is to stop someone from creating a million fake companies to sway the
> voting?
> The logistics of doing that prevent it. But let's say 10 fake companies ...
> first, you'd need to register ten domain names, host and customize the
> website, all before the vote and in a way that no one would notice.
>
>>How does a company make it's vote?
> Someone at the company sends a very small transaction to the BIP's vote
> address. Someone at the company then posts what the vote was and its
> transaction ID on the company's blog/twitter, etc., and then emails the URL
> to the administrator.
>
>>How does one verify that the person voting on behalf of a company is
> actually the correct person?
> They post it on their company blog.
>
> On Fri, Feb 3, 2017 at 11:19 AM, alp alp via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> This proposal seems hopelessly broken.
>>
>> Who decides on which companies are eligible?  Is there some kind of
>> centralized database that one registers?  Who administers this?  What is
>> to
>> stop someone from creating a million fake companies to sway the voting?
>> How does a company make it's vote?  How does one verify that the person
>> voting on behalf of a company is actually the correct person?
>>
>>
>>
>> On Thu, Feb 2, 2017 at 7:32 PM, Dave Scotese via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> There are two ideas here for "on-chain" voting, both of which require
>>> changes to the software.  I agree with David that on-chain solutions
>>> complicate things.  Both proposals can be effected without any software
>>> changes:
>>>
>>> Those who wish to use proof of stake can provide a service for making
>>> vanity addresses containing some indicator of the proposal to be
>>> supported
>>> - 1bigblock or 12mbblk or whatever - based on a supporter-provided
>>> secret
>>> key, and then supporters can move their bitcoin into their own vanity
>>> address and then whoever wants to can create a website to display the
>>> matching addresses and explain that this is the financial power in the
>>> hands of supporters and how to add your "financial power vote."
>>>
>>> Those who simply want to "buy votes" can use their funds in marketing
>>> efforts to promote the proposal they support.
>>>
>>> This second method, of course, can be abused.  The first actually
>>> requires people to control bitcoin in order to represent support.
>>> Counting
>>> actual, real people is still a technology in its infancy, and I don't
>>> think
>>> I want to see it progress much. People are not units, but individuals,
>>> and
>>> their value only becomes correlated to their net worth after they've
>>> been
>>> alive for many years, and even then, some of the best people have died
>>> paupers. If bitcoin-discuss got more traffic, I think this discussion
>>> would
>>> be better had on that list.
>>>
>>> notplato
>>>
>>> On Thu, Feb 2, 2017 at 4:24 PM, Luke Dashjr via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Strongly disagree with buying "votes", or portraying open standards as
>>>> a
>>>> voting process. Also, this depends on address reuse, so it's
>>>> fundamentally
>>>> flawed in design.
>>>>
>>>> Some way for people to express their support weighed by coins (without
>>>> losing/spending them), and possibly weighed by running a full node,
>>>> might
>>>> still be desirable. The most straightforward way to do this is to
>>>> support
>>>> message signatures somehow (ideally without using the same pubkey as
>>>> spending), and some [inherently unreliable, but perhaps useful if the
>>>> community "colludes" to not-cheat] way to sign with ones' full node.
>>>>
>>>> Note also that the BIP process already has BIP Comments for leaving
>>>> textual
>>>> opinions on the BIP unrelated to stake. See BIP 2 for details on that.
>>>>
>>>> Luke
>>>>
>>>>
>>>> On Thursday, February 02, 2017 7:39:51 PM t. khan via bitcoin-dev
>>>> wrote:
>>>> > Please comment on this work-in-progress BIP.
>>>> >
>>>> > Thanks,
>>>> >
>>>> > - t.k.
>>>> >
>>>> > ----------------------
>>>> > BIP: ?
>>>> > Layer: Process
>>>> > Title: Community Consensus Voting System
>>>> > Author: t.khan <teekhan42 at gmail.com>
>>>> > Comments-Summary: No comments yet.
>>>> > Comments-URI: TBD
>>>> > Status: Draft
>>>> > Type: Standards Track
>>>> > Created: 2017-02-02
>>>> > License: BSD-2
>>>> > Voting Address: 3CoFA3JiK5wxe9ze2HoDGDTmZvkE5Uuwh8  (just an example,
>>>> don?t
>>>> > send to this!)
>>>> >
>>>> > Abstract
>>>> > Community Consensus Voting System (CCVS) will allow developers to
>>>> measure
>>>> > support for BIPs prior to implementation.
>>>> >
>>>> > Motivation
>>>> > We currently have no way of measuring consensus for potential changes
>>>> to
>>>> > the Bitcoin protocol. This is especially problematic for
>>>> > controversial
>>>> > changes such as the max block size limit. As a result, we have many
>>>> > proposed solutions but no clear direction.
>>>> >
>>>> > Also, due to our lack of ability to measure consensus, there is a
>>>> general
>>>> > feeling among many in the community that developers aren?t listening
>>>> > to
>>>> > their concerns. This is a valid complaint, as it?s not possible to
>>>> listen
>>>> > to thousands of voices all shouting different things in a crowded
>>>> > room?basically the situation in the Bitcoin community today.
>>>> >
>>>> > The CCVS will allow the general public, miners, companies using
>>>> Bitcoin,
>>>> > and developers to vote for their preferred BIP in a way that?s public
>>>> and
>>>> > relatively difficult (expensive) to manipulate.
>>>> >
>>>> > Specification
>>>> > Each competing BIP will be assigned a unique bitcoin address which is
>>>> added
>>>> > to each header. Anyone who wanted to vote would cast their ballot by
>>>> > sending a small amount (0.0001 btc) to their preferred BIP's address.
>>>> Each
>>>> > transaction counts as 1 vote.
>>>> >
>>>> > Confirmed Vote Multiplier:
>>>> > Mining Pools, companies using Bitcoin, and Core
>>>> maintainers/contributors
>>>> > are allowed one confirmed vote each. A confirmed vote is worth
>>>> > 10,000x
>>>> a
>>>> > regular vote.
>>>> >
>>>> > For example:
>>>> >
>>>> > Slush Pool casts a vote for their preferred BIP and then states
>>>> publicly
>>>> > (on their blog) their vote and the transaction ID and emails the URL
>>>> to the
>>>> > admin of this system. In the final tally, this vote will count as
>>>> 10,000
>>>> > votes.
>>>> >
>>>> > Coinbase, Antpool, BitPay, BitFury, etc., all do the same.
>>>> >
>>>> > Confirmed votes would be added to a new section in each respective
>>>> > BIP
>>>> as a
>>>> > public record.
>>>> >
>>>> > Voting would run for a pre-defined period, ending when a particular
>>>> block
>>>> > number is mined.
>>>> >
>>>> >
>>>> > Rationale
>>>> > Confirmed Vote Multiplier - The purpose of this is twofold; it gives
>>>> > a
>>>> > larger voice to organizations and the people who will have to do the
>>>> work
>>>> > to implement whatever BIP the community prefers, and it will negate
>>>> > the
>>>> > effect of anyone trying to skew the results by voting repeatedly.
>>>> >
>>>> > Definitions
>>>> > Miner: any individual or organization that has mined at least one
>>>> > valid
>>>> > block in the last 2016 blocks.
>>>> >
>>>> > Company using Bitcoin: any organization using Bitcoin for financial,
>>>> asset
>>>> > or other purposes, with either under development and released
>>>> solutions.
>>>> >
>>>> > Developer: any individual who has or had commit access, and any
>>>> individual
>>>> > who has authored a BIP
>>>> >
>>>> > Unresolved Issues
>>>> > Node voting: It would be desirable for any full node running an
>>>> up-to-date
>>>> > blockchain to also be able to vote with a multiplier (e.g. 100x). But
>>>> as
>>>> > this would require code changes, it is outside the scope of this BIP.
>>>> >
>>>> > Copyright
>>>> > This BIP is licensed under the BSD 2-clause license.
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>
>>>
>>>
>>> --
>>> I like to provide some work at no charge to prove my value. Do you need
>>> a
>>> techie?
>>> I own Litmocracy <http://www.litmocracy.com> and Meme Racing
>>> <http://www.memeracing.net> (in alpha).
>>> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com>
>>> which now accepts Bitcoin.
>>> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
>>> "He ought to find it more profitable to play by the rules" - Satoshi
>>> Nakamoto
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>

From teekhan42 at gmail.com  Sat Feb  4 21:23:19 2017
From: teekhan42 at gmail.com (t. khan)
Date: Sat, 4 Feb 2017 16:23:19 -0500
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAMBsKS91EAe=Jk9=QRgaPJ2ev6n=i3OU42F6Pu3eVqS9=P6p=w@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
	<CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
	<CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
	<CAMBsKS91EAe=Jk9=QRgaPJ2ev6n=i3OU42F6Pu3eVqS9=P6p=w@mail.gmail.com>
Message-ID: <CAGCNRJqJ-9RxMpPg7CTyd_+zn-+eR8gKSLRQjR15p8Ubv5pJbw@mail.gmail.com>

On Fri, Feb 3, 2017 at 2:22 PM, alp alp <alp.bitcoin at gmail.com> wrote:

> These are non-answers.  Someone must decide.  Someone must decide what
> kind of company counts (e.g. does a dark market seller count as a
> business?  Does some guy who sells $10/year worth of goods using Bitcoin
> count the same as large companies like Coinbase/BitPay/Blockstream).
> Someone must decide which websites are checked for votes or addresses.
> Someone must decide if a rogue employee made a transaction on behalf of the
> company or not.
>

The less centralized decision making there is, the better. All confirmed
votes will be added to each BIP, so everyone can make their own decision as
to whether or not they want to count it. Remember, this is about gauging
community support.

Rogue employees?: The company in question would have to deal with that.


> Registering domain names is trivial and can be automated if the incentives
> were needed for it.
>

Mountains out of mole hills here?if the domain name is registered after
voting is called, that would be a pretty clear indicator it's a fake
company.


> You mention developers who have commit access.  This excludes the vast
> majority of developers.  You also don't mention which repositories count.
> Do the developers of bcoin count or not?
>

After further consideration, and as the goal of this is to determine what
the community will support, developers won't have a confirmed vote. They
would get a standard vote though, just like everyone else.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170204/7406b738/attachment.html>

From teekhan42 at gmail.com  Sat Feb  4 22:02:00 2017
From: teekhan42 at gmail.com (t. khan)
Date: Sat, 4 Feb 2017 17:02:00 -0500
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <201702030024.10232.luke@dashjr.org>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
Message-ID: <CAGCNRJp6vpqqaf8=8CwPP6iXB6UULWh8Kezw2i-2GfLn3b1bxg@mail.gmail.com>

On Thu, Feb 2, 2017 at 7:24 PM, Luke Dashjr <luke at dashjr.org> wrote:

> Strongly disagree with buying "votes", or portraying open standards as a
> voting process. Also, this depends on address reuse, so it's fundamentally
> flawed in design.
>

The point of this is it's available right now. It's not ideal, but it will
work. It doesn't require any code and we can do it today.

In case you haven't been paying attention; there's already enough support
for Unlimited to prevent SegWit from ever being adopted. Without
significant community outreach (which is the purpose of the CCVS) and a
compelling solution to max block size, Core as a product is dead.

Also, you need to be pretty paranoid to believe that address reuse is an
issue in this situation.

Note also that the BIP process already has BIP Comments for leaving textual
> opinions on the BIP unrelated to stake. See BIP 2 for details on that.
>

This does nothing for the community in general. Plus there's no way to
measure that sort of feedback.

- t.k.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170204/1e55de20/attachment.html>

From natanael.l at gmail.com  Sun Feb  5 16:22:11 2017
From: natanael.l at gmail.com (Natanael)
Date: Sun, 5 Feb 2017 17:22:11 +0100
Subject: [bitcoin-dev] Transaction signalling through output address
	hashing
In-Reply-To: <BL2PR03MB4358286BE7F0D51F99B8EC6EE4C0@BL2PR03MB435.namprd03.prod.outlook.com>
References: <BL2PR03MB4358286BE7F0D51F99B8EC6EE4C0@BL2PR03MB435.namprd03.prod.outlook.com>
Message-ID: <CAAt2M18uMt7BA_brpFM+zipodDkj_bdnZ3SXMxOpVPN+YqgMoA@mail.gmail.com>

Den 5 feb. 2017 16:33 skrev "John Hardy via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:

Currently in order to signal support for changes to Bitcoin, only miners
are able to do so on the blockchain through BIP9.

One criticism is that the rest of the community is not able to participate
in consensus, and other methods of assessing community support are fuzzy
and easily manipulated through Sybil.

I was trying to think if there was a way community support could be
signaled through transactions without requiring a hard fork, and without
increasing the size of transactions at all.

My solution is basically inspired by hashcash and vanity addresses


Censorship by miners isn't the only problem. Existing and normal
transactions will probabilistically collide with these schemes, and most
wallets have no straightforward way of supporting it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170205/019c529b/attachment-0001.html>

From achow101 at gmail.com  Sun Feb  5 16:26:30 2017
From: achow101 at gmail.com (Andrew C)
Date: Sun, 5 Feb 2017 11:26:30 -0500
Subject: [bitcoin-dev] Transaction signalling through output address
 hashing
In-Reply-To: <BL2PR03MB4358286BE7F0D51F99B8EC6EE4C0@BL2PR03MB435.namprd03.prod.outlook.com>
References: <BL2PR03MB4358286BE7F0D51F99B8EC6EE4C0@BL2PR03MB435.namprd03.prod.outlook.com>
Message-ID: <b5648b1d-b18d-c82c-8bb7-6ed9139c0a9f@gmail.com>

Instead of using vanity addresses, the transactions could just use an
OP_RETURN output and express the signalling there.


However, such a system could be easily gamed by people who simply spam
the network with transactions and by miners who choose what transactions
to include in their blocks.


On 2/2/2017 7:13 PM, John Hardy via bitcoin-dev wrote:
>
> Currently in order to signal support for changes to Bitcoin, only
> miners are able to do so on the blockchain through BIP9.
>
>
> One criticism is that the rest of the community is not able to
> participate in consensus, and other methods of assessing community
> support are fuzzy and easily manipulated through Sybil.
>
>
> I was trying to think if there was a way community support could be
> signaled through transactions without requiring a hard fork, and
> without increasing the size of transactions at all.
>
>
> My solution is basically inspired by hashcash and vanity addresses.
>
>
> The output address of a transaction could basically have the last 4
> characters used to signal support for a particular proposal.
>
> To generate an address with 4 consecutive case-insensitive characters
> should be roughly 34^4 which is just over a million attempts. On
> typical hardware this should take less than a second.
>
> An example bitcoin address that wanted to support the core roadmap
> might be:
>
> 1CLNgjuu8s51umTA76Zi8v6EdvDp8q*CorE*
>
>
> or to signal support for a big block proposal might be:
>
> 1N62SRhBioRFrigS5eJ8kR1WYcfcYr*16mB*
>
>
> Popularity could be measured weighted by fee paid per voting kb.
>
>
> Issues are that this could lead to transactions been censored by
> particular miners for political reasons. Also miners might attempt to
> manipulate the results by stuffing their block with 'fake'
> transactions. Such attempts could be identified if a large number of
> voting transactions were not in the mempool.
>
>
> Despite the limitations, I believe this offers a very accessible way
> to immediately allow the entire economic community to signal their
> support within transactions. The only cost is that of a tiny hashing
> PoW that should tie up a CPU for a barely noticeable amount of time,
> and could be implemented relatively easily into wallet software.
>
>
> For its weaknesses, surely it is better than the existing methods we
> use to assess support from the wider economic community?
>
>
> While it could just be used for signaling support and giving users a
> 'voice' on chain, if considered effective it could also be used to
> activate changes in the future.
>
>
> Any thoughts welcome.
>
>
> Thanks,
>
>
> John Hardy
>
> john at seebitcoin.com
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170205/a28d872f/attachment.html>

From achow101 at gmail.com  Sun Feb  5 21:50:26 2017
From: achow101 at gmail.com (Andrew C)
Date: Sun, 5 Feb 2017 16:50:26 -0500
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
Message-ID: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>

Hello all,

Many people have expressed discontent with Luke-jr's proposed block size
BIP, in particular with the decrease in size that would occur if it were
to be activated prior to 2024.

I have decided to modify the proposal to instead begin the increase
steps at the current 1000000 byte limit. The increases and the time spam
of each increase will remain the same, just that the increase begins
from 1000000 bytes instead of 300000 bytes.

Furthermore, instead of a fixed schedule from a fixed point in time, the
increases will instead be calculated off of the MTP of the activation
block (the first block to be in the active state for this fork).

While this proposal shares many of the same issues with the one it
modifies, I hope that it will be slightly less controversial and can
allow us to move forward with scaling Bitcoin.

The full text of the proposal can be found at
https://github.com/achow101/bips/blob/bip-blksize/bip-blksize.mediawiki.
My implementation of it is available at
https://github.com/achow101/bitcoin/tree/bip-blksize


Andrew


From luke at dashjr.org  Sun Feb  5 23:02:28 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 5 Feb 2017 23:02:28 +0000
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
Message-ID: <201702052302.29599.luke@dashjr.org>

My BIP draft didn't make progress because the community opposes any block size 
increase hardfork ever. Your version doesn't address the current block size 
issues (ie, the blocks being too large). So you've retained the only certain-
DOA parts of my proposal, and removed the most useful part... I'm not sure the 
point. Also, your version is now EXCLUSIVELY a hardfork, so it makes no sense 
to keep the BIP 9 deployment at all - either it gets consensus or it doesn't, 
but miners have no part in deployment of it.

On Sunday, February 05, 2017 9:50:26 PM Andrew C via bitcoin-dev wrote:
> Hello all,
> 
> Many people have expressed discontent with Luke-jr's proposed block size
> BIP, in particular with the decrease in size that would occur if it were
> to be activated prior to 2024.
> 
> I have decided to modify the proposal to instead begin the increase
> steps at the current 1000000 byte limit. The increases and the time spam
> of each increase will remain the same, just that the increase begins
> from 1000000 bytes instead of 300000 bytes.
> 
> Furthermore, instead of a fixed schedule from a fixed point in time, the
> increases will instead be calculated off of the MTP of the activation
> block (the first block to be in the active state for this fork).
> 
> While this proposal shares many of the same issues with the one it
> modifies, I hope that it will be slightly less controversial and can
> allow us to move forward with scaling Bitcoin.
> 
> The full text of the proposal can be found at
> https://github.com/achow101/bips/blob/bip-blksize/bip-blksize.mediawiki.
> My implementation of it is available at
> https://github.com/achow101/bitcoin/tree/bip-blksize
> 
> 
> Andrew
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From achow101 at gmail.com  Sun Feb  5 23:53:03 2017
From: achow101 at gmail.com (Andrew C)
Date: Sun, 5 Feb 2017 18:53:03 -0500
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <201702052302.29599.luke@dashjr.org>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
Message-ID: <03b80a7b-6c8c-cdff-1826-6535bef12993@gmail.com>


On 2/5/2017 6:02 PM, Luke Dashjr wrote:
> My BIP draft didn't make progress because the community opposes any block size 
> increase hardfork ever.
From what I have observed, it seems to be that people are more so
opposed to a hard fork when there is a comparable soft fork available
than simply opposed to any block size increase hard fork ever. From the
various threads discussing your proposal, it seemed that many would
favor it if it increased over 1 MB sooner or if it never even decreased
in the first place.

>  Your version doesn't address the current block size 
> issues (ie, the blocks being too large). 
Many users are of the opposite opinion, that the block size is too
small. I understand that the decrease is to allow the blockchain size to
grow more slowly thereby allowing users to be more likely to run full
nodes. Unfortunately, I think that we are way past the point of no
return on that. The blockchain is already 100+ GB. Decreasing the block
size is not going to make that any smaller and is not going to make it
any less painful to run a full node. Given that in order to start up a
new full node will still require downloading at least 100 GB of data, I
don't think that decreasing the block size will better facilitate full
node creation. Furthermore, the current trend with ISPs (at least in the
US) is implementing data and bandwidth caps so users are still unlikely
to start up new full nodes regardless of any changes that we can
currently do.

> So you've retained the only certain-
> DOA parts of my proposal, and removed the most useful part... I'm not sure the 
> point. Also, your version is now EXCLUSIVELY a hardfork, so it makes no sense 
> to keep the BIP 9 deployment at all - either it gets consensus or it doesn't, 
> but miners have no part in deployment of it.
Yes, I know deployment needs to be fixed. I was more proposing this for
comment on the modified block size schedule. I just kept the deployment
as it was originally. However, we could use a modified version of BIP 9
by using one of the top three bits and a longer locked-in period as a
grace period for all users to upgrade.
>
> On Sunday, February 05, 2017 9:50:26 PM Andrew C via bitcoin-dev wrote:
>> Hello all,
>>
>> Many people have expressed discontent with Luke-jr's proposed block size
>> BIP, in particular with the decrease in size that would occur if it were
>> to be activated prior to 2024.
>>
>> I have decided to modify the proposal to instead begin the increase
>> steps at the current 1000000 byte limit. The increases and the time spam
>> of each increase will remain the same, just that the increase begins
>> from 1000000 bytes instead of 300000 bytes.
>>
>> Furthermore, instead of a fixed schedule from a fixed point in time, the
>> increases will instead be calculated off of the MTP of the activation
>> block (the first block to be in the active state for this fork).
>>
>> While this proposal shares many of the same issues with the one it
>> modifies, I hope that it will be slightly less controversial and can
>> allow us to move forward with scaling Bitcoin.
>>
>> The full text of the proposal can be found at
>> https://github.com/achow101/bips/blob/bip-blksize/bip-blksize.mediawiki.
>> My implementation of it is available at
>> https://github.com/achow101/bitcoin/tree/bip-blksize
>>
>>
>> Andrew
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jl2012 at xbt.hk  Mon Feb  6 12:39:21 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Mon, 6 Feb 2017 20:39:21 +0800
Subject: [bitcoin-dev] Spoonnet: another experimental hardfork
Message-ID: <15A0A5F0-726F-4E8F-9F16-F33D5A30C5F4@xbt.hk>

Finally got some time over the Chinese New Year holiday to code and write this up. This is not the same as my previous forcenet ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013472.html ). It is much simpler. Trying to activate it on testnet will get you banned. Trying to activate it on mainnet before consensus is reached will make you lose money.

This proposal includes the following features:

1. A fixed starting time. Not dependent on miner signalling. However, it requires at least 51% of miners to actually build the new block format in order to get activated.

2. It has no mechanism to prevent a split. If 49% of miners insist on the original chain, they could keep going. Split prevention is a social problem, not a technical one.

3. It is compatible with existing Stratum mining protocol. Only pool software upgrade is needed

4. A new extended and flexible header is located at the witness field of the coinbase transaction

5. It is backward compatible with existing light wallets

6. Dedicated space for miners to put anything they want, which bitcoin users could completely ignore. Merge-mining friendly.

7. Small header space for miners to include non-consensus enforced bitcoin related data, useful for fee estimation etc.

8. A new transaction weight formula to encourage responsible use of UTXO

9. A linear growth of actual block size until certain limit

10. Sighash O(n^2) protection for legacy (non-segwit) outputs

11. Optional anti-transaction replay

12. A new optional coinbase tx format that allows additional inputs, including spending of immature previous coinbase outputs



Specification [Rationales]:


Activation:

* A "hardfork signalling block" is a block with the sign bit of header nVersion is set [Clearly invalid for old nodes; easy opt-out for light wallets]

* If the median-time-past of the past 11 blocks is smaller than the HardForkTime (exact time to be determined), a hardfork signalling block is invalid.

* Child of a hardfork signalling block MUST also be a hardfork signalling block

* Initial hardfork signalling is optional, even if the HardForkTime has past [requires at least 51% of miners to actually build the new block format]

* HardForkTime is determined by a broad consensus of the Bitcoin community. This is the only way to prevent a split.


Extended header:

* Main header refers to the original 80 bytes bitcoin block header

* A hardfork signalling block MUST have a additional extended header

* The extended header is placed at the witness field of the coinbase transaction [There are 2 major advantages: 1. coinbase witness is otherwise useless; 2. Significantly simply the implementation with its stack structure]

* There must be exactly 3 witness items (Header1; Header2 ; Header3)
**Header1 must be exactly 32 bytes of the original transaction hash Merkle root.
**Header2 is the secondary header. It must be 36-80 bytes. The first 4 bytes must be little-endian encoded number of transactions (minimum 1). The next 32 bytes must be the witness Merkle root (to be defined later). The rest, if any, has no consensus meaning. However, miners MUST NOT use this space of non-bitcoin purpose [the additional space allows non-censensus enforced data to be included, easily accessible to light wallets]
**Header3 is the miner dedicated space. It must not be larger than 252 bytes. Anything put here has no consensus meaning [space for merge mining; non-full nodes could completely ignore data in this space; 252 is the maximum size allowed for signal byte CompactSize]

* The main header commitment is H(Header1|H(H(Header2)|H(Header3)))  H() = dSHA256() [The hardfork is transparent to light wallets, except one more 32-byte hash is needed to connect a transaction to the root]

* To place the ext header, segwit becomes mandatory after hardfork


A ?backdoor? softfork the relax the size limit of Header 2 and Header 3:

* A special BIP9 softfork is defined with bit-15. If this softfork is activated, full nodes will not enforce the size limit for Header 2 and Header 3. [To allow header expansion without a hardfork. Avoid miner abuse while providing flexibility. Expansion might be needed for new commitments like fraud proof commitments]


Anti-tx-replay:

* Hardfork network version bit is 0x02000000. A tx is invalid if the highest nVersion byte is not zero, and the network version bit is not set.

* Masked tx version is nVersion with the highest byte masked. If masked version is 3 or above, sighash for OP_CHECKSIG alike is calculated using BIP143, except 0x02000000 is added to the nHashType (the nHashType in signature is still a 1-byte value) [ensure a clean split of signatures; optionally fix the O(n^2) problem]

* Pre-hardfork policy change: nVersion is determined by the masked tx version for policy purpose. Setting of Pre-hardfork network version bit 0x01000000 is allowed.

* Details: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013473.html


Sighash limitation:

* Sighash impact is estimated by ?Loose estimation? in https://github.com/jl2012/bips/blob/065ea7429035d43ff90965f42b086fb7e1517291/bip-sighash.mediawiki

* Only txs with masked version below 3 are counted. [because they are fixed by the BIP-143 like signature]

* Each SigHashSize is defined as 1 tx weight (defined later).

* SIGHASH_SCALE_FACTOR is 90 (see the BIP above)


New tx weight definition:

* Weight of a transaction is the maximum of the 4 following metrics:

** The total serialised size * 2 * SIGHASH_SCALE_FACTOR  (size defined by the witness tx format in BIP144)

** The adjusted size = (Transaction weight by BIP141 - (number of inputs - number of non-OP_RETURN outputs) * 41) * SIGHASH_SCALE_FACTOR

** nSigOps * 50 * SIGHASH_SCALE_FACTOR. All SigOps are equal (no witness scaling). For non-segwit txs, the sigops in output scriptPubKey are not counted, while the sigops in input scriptPubKey are counted.

** SigHashSize defined in the last section

Translating to new metric, the current BIP141 limit is 360,000,000. This is equivalent to 360MB of sighashing, 2MB of serialised size, 4MB of adjusted size, or 80000 nSigOp.

See rationales in this post: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013472.html


Block weight growing by time:

* Numbers for example only. Exact number to be determined.

* Block weight at HardForkTime is (5,000,000 * SIGHASH_SCALE_FACTOR)

* By every 16 seconds growth of the median-time-past, the weight is increased by (1 * SIGHASH_SCALE_FACTOR)

* The growth stops at (16,000,000 * SIGHASH_SCALE_FACTOR)

* The growth does not dependent on the actual hardfork time. It?s only based on median-time-past [using median-time-past so miners have no incentive to use a fake timestamp]

* The limit for serialized size is 2.5 to 8MB in about 8 years. [again, numbers for example only]


New coinbase transaction format:

* Existing coinbase format is allowed, except the new extended header in the coinbase witness. No OP_RETURN witness commitment is needed.

* A new coinbase format is defined. The tx may have 1 or more inputs. The outpoint of the first input MUST have an n value of 0xffffffff, and use the previous block hash as the outpoint hash [This allows paying to the child of a particular block by signing the block hash]

* ScriptSig of the first (coinbase) input is not executed. The size limit increased from 100 to 252 (same for old coinbase format)

* Additional inputs MUST provide a valid scriptSig and/or witness for spending

* Additional inputs may come from premature previous coinbase outputs [this allows previous blocks paying subsequent blocks to encourage confirmations]


Witness merkle root:

* If the coinbase is in old format, the witness merkle root is same as BIP141 by setting the witness hash of the coinbase tx as 0 (without the 32 byte witness reserved value)

* If the coinbase is in new format, the witness hash of the coinbase tx is calculated by first removing the extended header

* The witness merkle root is put in the extended header 2, not as an OP_RETURN output in coinbase tx.

* The witness merkle root becomes mandatory. (It was optional in BIP141)


Other consensus changes:

* BIP9 will ignore the sign bit. [Setting the sign bit now is invalid so this has no real consensus impact]

========

An experimental implementation of the above spec could be found at https://github.com/jl2012/bitcoin/tree/spoonnet1

Not the same as my previous effort on the ?forcenet?, the ?spoonnet? is a full hardfork that will get you banned on the existing network.

Haven?t got the time to test the codes yet, not independently reviewed. But it passes all existing tests in Bitcoin Core. No one should use this in production, but I *think* it works fine on testnet like a normal bitcoind (as long as it is not activated)

Things not implemented yet:

1. Automated testing

2. Post-hardfork support for old light wallets

3. Wallet support, especially anti-tx-replay

4. New p2p message to transmit secondary header (lower priority)

5. Full mining and mempool support (not my priority)

========

Potential second stage change:

Relative to the actual activation time, there could be a second stage with more drastic changes to fix one or both of the following problems:

1. SHA256 shortcut like ASICBoost. All fixes to ASICBoost are not very elegant. But the question is, is it acceptable to have bitcoin-specific patent in the consensus protocol? Still, I believe the best way to solve this problem is the patent holder(s) to kindly somehow release the right to the community. 

2. Providing more nonce space in the 80-byte main header. However, this depends on ASICBoost being a free technology.

3. Block withholding attack. There are pros and cons, but I generally agree with the analysis by Peter Todd at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/012046.html . One point he didn?t mention is that only small really needs pool mining, for the purpose of variance reduction. Big miners using pools are just lazy, and they work well without pool. That means only big solo miners are able to attack pools (i.e. small miners), while pools cannot do any counterattack. This obviously shows why fixing this is pro-small-miners. Also, with same hash rate, block withholding attack is more effective against a smaller pool than a big pool.

All of these changes involve a header change and require light wallets to upgrade. They also require firmware upgrade for all existing miners (change 2 doesn?t). I think these shouldn?t happen at least 2 years after the actual activation of the hardfork so people will have enough time to upgrade.

From jl2012 at xbt.hk  Mon Feb  6 18:06:22 2017
From: jl2012 at xbt.hk (Johnson Lau)
Date: Tue, 7 Feb 2017 02:06:22 +0800
Subject: [bitcoin-dev] Spoonnet: another experimental hardfork
In-Reply-To: <15A0A5F0-726F-4E8F-9F16-F33D5A30C5F4@xbt.hk>
References: <15A0A5F0-726F-4E8F-9F16-F33D5A30C5F4@xbt.hk>
Message-ID: <D5B37586-3A96-4BD4-97A8-8A9335BFA698@xbt.hk>

I fixed a flaw in my original design. It allowed a miner to create a fake transaction to cheat light wallets.

Also, with a second thought, I removed the backward compatibility with light wallets. Everyone, light or full, should opt-in to a hardfork.

The extended header is amended as follow

* There must be exactly 2 witness items in coinbase witness (Header1; Header2)
**Header1 is the miner dedicated space. Nothing here has no consensus meaning and is used for extranonce and merge mining. However, if the size is larger than 14 bytes, the first 6 bytes must be 0. For a legacy light node, this will look like a version 0 transaction with zero input and output. [No need for 14 bytes or below: even with the most broken design, a wallet can?t misinterpret data with this small size as a valid tx]
**Header2 is the secondary header. It must be 70-128 bytes. The first 4 bytes must be little-endian encoded number of transactions (minimum 1). The next 2 bytes must be 0. The next 32 bytes must be the transaction Merkle root. The next 32 bytes must be the witness Merkle root (to be defined later). The rest, if any, has no consensus meaning. However, miners MUST NOT use this space of non-bitcoin purpose [the additional space allows non-censensus enforced data to be included, easily accessible to light wallets; the structure of the first 6 bytes make it looks like an empty tx]
* The main header commitment is H(H(Header1)|H(Header2))  H() = dSHA256() [legacy light wallets are broken and they must upgrade to join the new network]

The implementation is updated accordingly


> On 6 Feb 2017, at 20:39, Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Finally got some time over the Chinese New Year holiday to code and write this up. This is not the same as my previous forcenet ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013472.html ). It is much simpler. Trying to activate it on testnet will get you banned. Trying to activate it on mainnet before consensus is reached will make you lose money.
> 
> This proposal includes the following features:
> 
> 1. A fixed starting time. Not dependent on miner signalling. However, it requires at least 51% of miners to actually build the new block format in order to get activated.
> 
> 2. It has no mechanism to prevent a split. If 49% of miners insist on the original chain, they could keep going. Split prevention is a social problem, not a technical one.
> 
> 3. It is compatible with existing Stratum mining protocol. Only pool software upgrade is needed
> 
> 4. A new extended and flexible header is located at the witness field of the coinbase transaction
> 
> 5. It is backward compatible with existing light wallets
> 
> 6. Dedicated space for miners to put anything they want, which bitcoin users could completely ignore. Merge-mining friendly.
> 
> 7. Small header space for miners to include non-consensus enforced bitcoin related data, useful for fee estimation etc.
> 
> 8. A new transaction weight formula to encourage responsible use of UTXO
> 
> 9. A linear growth of actual block size until certain limit
> 
> 10. Sighash O(n^2) protection for legacy (non-segwit) outputs
> 
> 11. Optional anti-transaction replay
> 
> 12. A new optional coinbase tx format that allows additional inputs, including spending of immature previous coinbase outputs
> 
> 
> 
> Specification [Rationales]:
> 
> 
> Activation:
> 
> * A "hardfork signalling block" is a block with the sign bit of header nVersion is set [Clearly invalid for old nodes; easy opt-out for light wallets]
> 
> * If the median-time-past of the past 11 blocks is smaller than the HardForkTime (exact time to be determined), a hardfork signalling block is invalid.
> 
> * Child of a hardfork signalling block MUST also be a hardfork signalling block
> 
> * Initial hardfork signalling is optional, even if the HardForkTime has past [requires at least 51% of miners to actually build the new block format]
> 
> * HardForkTime is determined by a broad consensus of the Bitcoin community. This is the only way to prevent a split.
> 
> 
> Extended header:
> 
> * Main header refers to the original 80 bytes bitcoin block header
> 
> * A hardfork signalling block MUST have a additional extended header
> 
> * The extended header is placed at the witness field of the coinbase transaction [There are 2 major advantages: 1. coinbase witness is otherwise useless; 2. Significantly simply the implementation with its stack structure]
> 
> * There must be exactly 3 witness items (Header1; Header2 ; Header3)
> **Header1 must be exactly 32 bytes of the original transaction hash Merkle root.
> **Header2 is the secondary header. It must be 36-80 bytes. The first 4 bytes must be little-endian encoded number of transactions (minimum 1). The next 32 bytes must be the witness Merkle root (to be defined later). The rest, if any, has no consensus meaning. However, miners MUST NOT use this space of non-bitcoin purpose [the additional space allows non-censensus enforced data to be included, easily accessible to light wallets]
> **Header3 is the miner dedicated space. It must not be larger than 252 bytes. Anything put here has no consensus meaning [space for merge mining; non-full nodes could completely ignore data in this space; 252 is the maximum size allowed for signal byte CompactSize]
> 
> * The main header commitment is H(Header1|H(H(Header2)|H(Header3)))  H() = dSHA256() [The hardfork is transparent to light wallets, except one more 32-byte hash is needed to connect a transaction to the root]
> 
> * To place the ext header, segwit becomes mandatory after hardfork
> 
> 
> A ?backdoor? softfork the relax the size limit of Header 2 and Header 3:
> 
> * A special BIP9 softfork is defined with bit-15. If this softfork is activated, full nodes will not enforce the size limit for Header 2 and Header 3. [To allow header expansion without a hardfork. Avoid miner abuse while providing flexibility. Expansion might be needed for new commitments like fraud proof commitments]
> 
> 
> Anti-tx-replay:
> 
> * Hardfork network version bit is 0x02000000. A tx is invalid if the highest nVersion byte is not zero, and the network version bit is not set.
> 
> * Masked tx version is nVersion with the highest byte masked. If masked version is 3 or above, sighash for OP_CHECKSIG alike is calculated using BIP143, except 0x02000000 is added to the nHashType (the nHashType in signature is still a 1-byte value) [ensure a clean split of signatures; optionally fix the O(n^2) problem]
> 
> * Pre-hardfork policy change: nVersion is determined by the masked tx version for policy purpose. Setting of Pre-hardfork network version bit 0x01000000 is allowed.
> 
> * Details: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013473.html
> 
> 
> Sighash limitation:
> 
> * Sighash impact is estimated by ?Loose estimation? in https://github.com/jl2012/bips/blob/065ea7429035d43ff90965f42b086fb7e1517291/bip-sighash.mediawiki
> 
> * Only txs with masked version below 3 are counted. [because they are fixed by the BIP-143 like signature]
> 
> * Each SigHashSize is defined as 1 tx weight (defined later).
> 
> * SIGHASH_SCALE_FACTOR is 90 (see the BIP above)
> 
> 
> New tx weight definition:
> 
> * Weight of a transaction is the maximum of the 4 following metrics:
> 
> ** The total serialised size * 2 * SIGHASH_SCALE_FACTOR  (size defined by the witness tx format in BIP144)
> 
> ** The adjusted size = (Transaction weight by BIP141 - (number of inputs - number of non-OP_RETURN outputs) * 41) * SIGHASH_SCALE_FACTOR
> 
> ** nSigOps * 50 * SIGHASH_SCALE_FACTOR. All SigOps are equal (no witness scaling). For non-segwit txs, the sigops in output scriptPubKey are not counted, while the sigops in input scriptPubKey are counted.
> 
> ** SigHashSize defined in the last section
> 
> Translating to new metric, the current BIP141 limit is 360,000,000. This is equivalent to 360MB of sighashing, 2MB of serialised size, 4MB of adjusted size, or 80000 nSigOp.
> 
> See rationales in this post: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-January/013472.html
> 
> 
> Block weight growing by time:
> 
> * Numbers for example only. Exact number to be determined.
> 
> * Block weight at HardForkTime is (5,000,000 * SIGHASH_SCALE_FACTOR)
> 
> * By every 16 seconds growth of the median-time-past, the weight is increased by (1 * SIGHASH_SCALE_FACTOR)
> 
> * The growth stops at (16,000,000 * SIGHASH_SCALE_FACTOR)
> 
> * The growth does not dependent on the actual hardfork time. It?s only based on median-time-past [using median-time-past so miners have no incentive to use a fake timestamp]
> 
> * The limit for serialized size is 2.5 to 8MB in about 8 years. [again, numbers for example only]
> 
> 
> New coinbase transaction format:
> 
> * Existing coinbase format is allowed, except the new extended header in the coinbase witness. No OP_RETURN witness commitment is needed.
> 
> * A new coinbase format is defined. The tx may have 1 or more inputs. The outpoint of the first input MUST have an n value of 0xffffffff, and use the previous block hash as the outpoint hash [This allows paying to the child of a particular block by signing the block hash]
> 
> * ScriptSig of the first (coinbase) input is not executed. The size limit increased from 100 to 252 (same for old coinbase format)
> 
> * Additional inputs MUST provide a valid scriptSig and/or witness for spending
> 
> * Additional inputs may come from premature previous coinbase outputs [this allows previous blocks paying subsequent blocks to encourage confirmations]
> 
> 
> Witness merkle root:
> 
> * If the coinbase is in old format, the witness merkle root is same as BIP141 by setting the witness hash of the coinbase tx as 0 (without the 32 byte witness reserved value)
> 
> * If the coinbase is in new format, the witness hash of the coinbase tx is calculated by first removing the extended header
> 
> * The witness merkle root is put in the extended header 2, not as an OP_RETURN output in coinbase tx.
> 
> * The witness merkle root becomes mandatory. (It was optional in BIP141)
> 
> 
> Other consensus changes:
> 
> * BIP9 will ignore the sign bit. [Setting the sign bit now is invalid so this has no real consensus impact]
> 
> ========
> 
> An experimental implementation of the above spec could be found at https://github.com/jl2012/bitcoin/tree/spoonnet1
> 
> Not the same as my previous effort on the ?forcenet?, the ?spoonnet? is a full hardfork that will get you banned on the existing network.
> 
> Haven?t got the time to test the codes yet, not independently reviewed. But it passes all existing tests in Bitcoin Core. No one should use this in production, but I *think* it works fine on testnet like a normal bitcoind (as long as it is not activated)
> 
> Things not implemented yet:
> 
> 1. Automated testing
> 
> 2. Post-hardfork support for old light wallets
> 
> 3. Wallet support, especially anti-tx-replay
> 
> 4. New p2p message to transmit secondary header (lower priority)
> 
> 5. Full mining and mempool support (not my priority)
> 
> ========
> 
> Potential second stage change:
> 
> Relative to the actual activation time, there could be a second stage with more drastic changes to fix one or both of the following problems:
> 
> 1. SHA256 shortcut like ASICBoost. All fixes to ASICBoost are not very elegant. But the question is, is it acceptable to have bitcoin-specific patent in the consensus protocol? Still, I believe the best way to solve this problem is the patent holder(s) to kindly somehow release the right to the community. 
> 
> 2. Providing more nonce space in the 80-byte main header. However, this depends on ASICBoost being a free technology.
> 
> 3. Block withholding attack. There are pros and cons, but I generally agree with the analysis by Peter Todd at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/012046.html . One point he didn?t mention is that only small really needs pool mining, for the purpose of variance reduction. Big miners using pools are just lazy, and they work well without pool. That means only big solo miners are able to attack pools (i.e. small miners), while pools cannot do any counterattack. This obviously shows why fixing this is pro-small-miners. Also, with same hash rate, block withholding attack is more effective against a smaller pool than a big pool.
> 
> All of these changes involve a header change and require light wallets to upgrade. They also require firmware upgrade for all existing miners (change 2 doesn?t). I think these shouldn?t happen at least 2 years after the actual activation of the hardfork so people will have enough time to upgrade.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From achow101 at gmail.com  Mon Feb  6 21:00:18 2017
From: achow101 at gmail.com (Andrew C)
Date: Mon, 6 Feb 2017 16:00:18 -0500
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <C5621135-FBC8-44E7-9EC0-AFDEEBB6031E@thomaslerin.io>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<03b80a7b-6c8c-cdff-1826-6535bef12993@gmail.com>
	<C5621135-FBC8-44E7-9EC0-AFDEEBB6031E@thomaslerin.io>
Message-ID: <a86a5d01-088f-5242-12ab-eea374858899@gmail.com>

I looked at the discussions about the block size and about Luke-Jr's
proposal on Reddit and Bitcointalk. From what I observed of all of the
discussions is that few users are in favor of the status quo, and even
fewer are in favor of decreasing the block size. The majority of users
favored Segwit because it was a block size increase (that was a commonly
used reason in support of it and in arguments about increasing the block
size).

Discussions about Luke-Jr's proposal indicated that many users disagreed
with the decrease in block size and the time that it took to increase
again to 1 MB. There was not only disagreement but explicit ridicule and
mocking of that aspect of the proposal.


On 2/6/2017 3:28 PM, Thomas Kerin wrote:
> "Many users are of the opposite opinion, that the block size is too
> small." - That is newspeak, the users can speak for themselves.
>
> From whom did you gather feedback from before you changed Luke-Jrs BIP?
>
> If people don't agree with the proposal, changing it an infinite
> number of times light well lead to the same result.
>
> Have the users spoken, in their response to what Luke-Jr proposed?
>
> On 6 February 2017 00:53:03 CET, Andrew C via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>     On 2/5/2017 6:02 PM, Luke Dashjr wrote:
>
>         My BIP draft didn't make progress because the community
>         opposes any block size increase hardfork ever. 
>
>     From what I have observed, it seems to be that people are more so
>     opposed to a hard fork when there is a comparable soft fork available
>     than simply opposed to any block size increase hard fork ever. From the
>     various threads discussing your proposal, it seemed that many would
>     favor it if it increased over 1 MB sooner or if it never even decreased
>     in the first place.
>
>         Your version doesn't address the current block size issues
>         (ie, the blocks being too large). 
>
>     Many users are of the opposite opinion, that the block size is too
>     small. I understand that the decrease is to allow the blockchain size to
>     grow more slowly thereby allowing users to be more likely to run full
>     nodes. Unfortunately, I think that we are way past the point of no
>     return on that. The blockchain is already 100+ GB. Decreasing the block
>     size is not going to make that any smaller and is not going to make it
>     any less painful to run a full node. Given that in order to start up a
>     new full node will still require downloading at least 100 GB of data, I
>     don't think that decreasing the block size will better facilitate full
>     node creation. Furthermore, the current trend with ISPs (at least in the
>     US) is implementing data and bandwidth caps so users are still unlikely
>     to start up new full nodes regardless of any changes that we can
>     currently do.
>
>         So you've retained the only certain- DOA parts of my proposal,
>         and removed the most useful part... I'm not sure the point.
>         Also, your version is now EXCLUSIVELY a hardfork, so it makes
>         no sense to keep the BIP 9 deployment at all - either it gets
>         consensus or it doesn't, but miners have no part in deployment
>         of it. 
>
>     Yes, I know deployment needs to be fixed. I was more proposing this for
>     comment on the modified block size schedule. I just kept the deployment
>     as it was originally. However, we could use a modified version of BIP 9
>     by using one of the top three bits and a longer locked-in period as a
>     grace period for all users to upgrade.
>
>         On Sunday, February 05, 2017 9:50:26 PM Andrew C via
>         bitcoin-dev wrote:
>
>             Hello all, Many people have expressed discontent with
>             Luke-jr's proposed block size BIP, in particular with the
>             decrease in size that would occur if it were to be
>             activated prior to 2024. I have decided to modify the
>             proposal to instead begin the increase steps at the
>             current 1000000 byte limit. The increases and the time
>             spam of each increase will remain the same, just that the
>             increase begins from 1000000 bytes instead of 300000
>             bytes. Furthermore, instead of a fixed schedule from a
>             fixed point in time, the increases will instead be
>             calculated off of the MTP of the activation block (the
>             first block to be in the active state for this fork).
>             While this proposal shares many of the same issues with
>             the one it modifies, I hope that it will be slightly less
>             controversial and can allow us to move forward with
>             scaling Bitcoin. The full text of the proposal can be
>             found at
>             https://github.com/achow101/bips/blob/bip-blksize/bip-blksize.mediawiki.
>             My implementation of it is available at
>             https://github.com/achow101/bitcoin/tree/bip-blksize Andrew
>             ------------------------------------------------------------------------
>             bitcoin-dev mailing list
>             bitcoin-dev at lists.linuxfoundation.org
>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
>     ------------------------------------------------------------------------
>
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> -- Sent from my Android device with K-9 Mail. Please excuse my brevity. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170206/a67c0b89/attachment-0001.html>

From john at seebitcoin.com  Sun Feb  5 21:06:19 2017
From: john at seebitcoin.com (John Hardy)
Date: Sun, 5 Feb 2017 21:06:19 +0000
Subject: [bitcoin-dev] Fw: Transaction signalling through output address
 hashing
In-Reply-To: <BL2PR03MB435D7E36434A342BBEBC735EE410@BL2PR03MB435.namprd03.prod.outlook.com>
References: <BL2PR03MB4358286BE7F0D51F99B8EC6EE4C0@BL2PR03MB435.namprd03.prod.outlook.com>,
	<CAAt2M18uMt7BA_brpFM+zipodDkj_bdnZ3SXMxOpVPN+YqgMoA@mail.gmail.com>,
	<BL2PR03MB435D7E36434A342BBEBC735EE410@BL2PR03MB435.namprd03.prod.outlook.com>
Message-ID: <BL2PR03MB435DEA7CFB526C4DB58F740EE410@BL2PR03MB435.namprd03.prod.outlook.com>

Probabilistic collisions, while present, would be statistically insignificant at 4 chars length.


Implementation by wallets would just require a loop of their existing address generation until a match is found, trivial to implement. Wallets could provide a dropdown which shows the most commonly used signals as seen on the block chain, or a write-in.

Signalling within OP_RETURN increases the tx size and cost. This address hashing method keeps the very small economic cost of voting off the chain, rather than passing it cumulatively to everyone with the insertion of additional data.


Since I wrote this I have come across a similar idea called CryptoVoter which I think deserves more attention than it has had.

________________________________
From: Natanael <natanael.l at gmail.com>
Sent: Sunday, February 5, 2017 4:22 PM
To: Bitcoin Dev; John Hardy
Subject: Re: [bitcoin-dev] Transaction signalling through output address hashing

Censorship by miners isn't the only problem. Existing and normal transactions will probabilistically collide with these schemes, and most wallets have no straightforward way of supporting it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170205/e1d82fb4/attachment.html>

From mbtc-dev at xe0.me  Mon Feb  6 16:24:10 2017
From: mbtc-dev at xe0.me (mbtc-dev at xe0.me)
Date: Mon, 06 Feb 2017 08:24:10 -0800
Subject: [bitcoin-dev] Three hardfork-related BIPs
In-Reply-To: <201701280403.05558.luke@dashjr.org>
References: <201701270107.01092.luke@dashjr.org> <20170127212810.GA5856@nex>
	<CAAy62_KUSNTjivwJT87K9f1c=k-6gdaLXEBJjcy2KK+uLSTWDA@mail.gmail.com>
	<201701280403.05558.luke@dashjr.org>
Message-ID: <af8301fc246c8c3fae857167968d94d4@xe0.me>

On 27.01.2017 20:03, Luke Dashjr via bitcoin-dev wrote:
> Assume as a premise (despite your apparent disagreement below) that for
> Bitcoin to function, a supermajority of economic activity needs to be 
> verified
> using full nodes operated by the recipient. Evidence suggests that at 
> this
> current time, at best 10% of economic activity is in fact using a full 
> node to
> verify the transaction. On this basis, it seems pretty clear that 
> serious
> action must be taken to change the status quo, and so for efforts to do 
> so
> without dropping the block size have proven ineffective.
> 
Lets think like people in sales and marketing for a moment.

There's an implicit assumption here that ANY protocol or consensus-rule 
based solution exists that would reverse the trend of diminishing full 
node verified economic activity. Since there's no economic advantage to 
running a full node, there's no inherent motivation for implementation 
(or outright purchase) of full nodes by the very large percentage of 
people who fall in the non-technical "I just want it to work, and I 
don't want my money stolen" category. Yes, anyone on this list 
understands that "don't want my money stolen" is inherently connected to 
running your own node and using it for transactions, but the average 
user does not, and even if they did, they don't have the resources (time 
and/or money) to do anything about it. Running your own full node 
increases the protection agains double spend attacks and other protocol 
bases shenanigans, but now you've taken on another set of security 
exposures related to the physical box that is running the node. 
Anti-virus, off and on-site backups, multiple boxes/devices for 
multi-sig, backup of key seeds.

Reducing (or even maintaining) the block size doesn't somehow increase 
the number of people who are capable of running full nodes, and it 
doesn't add any incentive for people already in that "capable" set to 
suddenly take up the task of running and transacting via a full node. 
I'd argue that the size of the block-chain and the time to download it 
are the least concerning aspects to anyone faced with running their own 
node and actually storing some of their wealth on it and using it for 
transactions.

You're looking for a (maybe dangerous/maybe impossible) balance between 
choking off casual (not full node) usage of bitcoin and yet trying to 
make it more popular among the people (and organizations) who have the 
capability and resources to run and transact on full nodes.

We should sit with this for a moment.

On one hand, Bitcoin may ultimately end up as digital currency "only for 
geeks and B2B transactions." I'd speculate we'd loose a big subset of 
the geeks that way too, unless they happen to do a lot of transactions 
with medium to large size businesses. (Small businesses won't be able to 
afford the expense of or the time to maintain the node.) There's some 
level of risk that this pushes bitcoin into oblivion. And is it really a 
decentralized P2P currency if it's only used by medium and large 
businesses and a small set of technically capable individuals that 
transact with those entities directly in BTC? And is it really a 
decentralized currency in this scenario if its used mainly by medium and 
large businesses, banks, and exchanges? (I've purposely excluded small 
businesses because while they like the benefits of flexible payment 
systems, more don't have the time or skill (or resources to hire the 
skill) needed to do a full node implementation.)

I feel inherent cognitive dissonance between "keep it decentralized" and 
"not useful to small business and individuals." One can make the 
argument that L2 solutions will be available for the small businesses 
and individuals but that doesn't solve the stated intent of reversing 
the trend of transactions not originating from or being received by full 
nodes. I guess you're saying bitcoin will be stronger, more resistant to 
outside power agency and censorship if its only used by exchanges, 
banks, large businesses, and die-hard technically inclined people.


On the other hand, maybe there's a scenario where an average person 
walks into a big box electronics store in any developed country and buys 
a "personal digital bank" appliance. I frame it this way because the 
majority of the worlds population is never going to run a full node on 
their desktop or laptop. There's no viable scenario where that happens. 
Laptops and desktops are already diminishing in market share due to the 
introduction of tablets and smartphones. General purpose OS's are also 
inherently un-secure, so  going down this route means we are immediately 
in the realm of lots of theft. Preventing theft (or loss due to errors) 
requires additional digital key devices, or additional devices for 
multi-sig transactions just for basic financial safety, not to mention a 
functioning backup plan, including off-site backups. 
Ransomeware/phishing protection? Checking email and surfing the web on 
the computer that holds your standard (non-multi-sig) wallet? 
Forgetaboutit. It'll never reach critical mass. It's not a viable 
proposal. Not to mention, you can't physically carry your laptop with 
you when you go to the shopping mall. In order for this appliance model 
to function, smartphone based implementations will need to interact with 
your personal or family server/appliance, and you'll need to be able to 
do multi-sig with a smartphone and another physical token you carry with 
you. Imagine a 2 of 5 multi-sig wallet where your phone and an NFC or LE 
bluetooth device are sufficient to create a transaction on your home 
node while shopping. Or your phone has a single sig wallet and you top 
it up from your appliance and it never has a high balance. In any case, 
I've made the argument before that the definition of "bitcoin protocol" 
should, in addition to the consensus protocol, probably include a secure 
API protocol between wallet client and full node, and it still seems to 
be an important missing piece. I want to be able to travel and spend BTC 
and I DON'T want to do general purpose computing like email and web 
surfing on the same computer where I have a big chunk of life savings 
stored! I think defining this API will actually really support the use 
of user controlled full nodes for transactions! Imagine Trezor owners 
using their own node for transactions! Bitpay is the only player I know 
of that provides enough of a software stack to set this up for yourself.

I think reversing the non-full node transaction trend will have to be 
based the appliance usage model. You buy a new 200-500Gb nvme SSD every 
year and put it in one of the free slots. You upgrade when all slots are 
full. This is one scenario that could put us on a trend of increasing 
transactions originating and being received by personal full nodes, i.e. 
reversing centralization trends.


If there is any solution to this problem, it will need to recognize the 
fact that the supermajority of people on the planet are not technically 
savvy nor are they inclined to take the time to learn how to protect 
themselves with basic computer security much less how to use a full node 
for bitcoin transactions. The solution, if it exists, will need to be 
handed to them, and they'll need a reason to buy it. Any solution will 
also need to recognize the fact that it will cost resources (time and 
money) to run a full node. Lots of people spend a huge portion of their 
income just to get a smartphone because it's a useful communication 
device that does lots of other useful things. There's not nearly the 
same level of need to spend on a full node for bitcoin security.

Any solution to this problem should also recognize the fact that there's 
a significant amount of work to do to have a functioning personal 
implementation of a node and to use it for transactions. Even in my 
imagined future of polished and easy to use appliances, if you have 
enough capital in BTC that you need it and you can afford to buy it, 
you're now only starting to deal with implementation issues. You've now 
become your own bank. Now you have to secure that appliance physically, 
secure and back up the key seed material, secure the devices used to 
access it, connect an app on your smartphone to the appliance so you can 
create transactions while out of your home, connect your home 
computer(s) to the appliance, do key exchange with the app/PC and the 
appliance or implement some sort of PKI on all devices. You've just 
taken on the responsibility of a bank and a sysadmin! The higher the 
balance, the more of a target you are, and the more time/money you have 
to spend mitigating risk. This is a huge centralizing force that no one 
really seems to talk about. If you're the average person, you want to 
find a trustworthy company or trusted friend/family to take care of that 
stuff for you. If you're a technically inclined person AND maybe there's 
a way to reap some of the mining reward on a small scale, you're 
slightly more interested.

As a sysadmin for many years, I've seen first hand that most people want 
tools that just work, whether its software to make spreadsheets, 
operating systems, phones, or thermostats. My point here is that the 
number of people in the world who have the technical chops to run a node 
is ALWAYS going to be vastly lower than the number of people who will be 
using bitcoin (or cryptocurrency).

Of course we can make the argument that the definition of "bitcoin" is 
by design something to be used exclusively by institutions and geeks, 
and that this definition falls out of the necessity to ensure that it 
remains decentralized and censorship resistant. However, I'm not sure 
that logic holds or that it doesn't introduce risk that that sort of 
definition drives bitcoin toward diminished relevance.

At the end of all this though experiment, I'm still convinced that if 
the tools are built to enable flexible usage of full nodes (i.e. my 
phone, tablet or desktop app interfaces with the full node) then there's 
a large potential for increased usage of full nodes.

Thanks,
G

From eric at voskuil.org  Tue Feb  7 20:32:46 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 7 Feb 2017 12:32:46 -0800
Subject: [bitcoin-dev] Three hardfork-related BIPs
In-Reply-To: <af8301fc246c8c3fae857167968d94d4@xe0.me>
References: <201701270107.01092.luke@dashjr.org> <20170127212810.GA5856@nex>
	<CAAy62_KUSNTjivwJT87K9f1c=k-6gdaLXEBJjcy2KK+uLSTWDA@mail.gmail.com>
	<201701280403.05558.luke@dashjr.org>
	<af8301fc246c8c3fae857167968d94d4@xe0.me>
Message-ID: <52CB8F39-6810-4235-836D-4E9ED0F58DD0@voskuil.org>

The semantics of a necessarily secure and private client-server protocol differ from that of a necessarily distributed and public P2P protocol. I realize you refer to the C/S as a distinct API, but this point is worthy of clarification and emphasis.

The introduction of client-server sub-protocols into the Bitcoin P2P protocol has resulted in large scale privacy loss, weakened end-user security and reduced access to the public network. Plans to mitigate these issues stand to make matters worse by restricting access to the public network through the introduction of strong identity to the P2P protocol.

It is not the case that C/S APIs against private full nodes do not exist. Electrum (stratum) and Libbitcoin (zeromq) are notable examples. The management difficulties are not small, but there are also fundamental issues that must first be addressed.

In your example you imagine pluggsble SSD space, but Satoshi derivatives have scale deficiencies unrelated to storage. If we are going to get to reliable, cheap, performant personal full nodes (which I agree is essential to Bitcoin survival) we need nodes that scale (i.e. to the available hardware). We also require a robust, reliable and performant node/server development stack, not just the impossible choice between a fragile monolith and centralizing web APIs/wallets.

All centralized interfaces to Bitcoin (wallets, web APIs, payment services) shrink the economic consensus and thereby weaken its defense of sound and fungible money. The only solution is personally-controlled full nodes, as you say. The incentives for running a full node are sufficient if the cost of doing so is low. Getting there requires a node/server architecture intended for this outcome. Then maybe appliances are feasible.

e


> On Feb 6, 2017, at 8:24 AM, netkn0t (marcus) via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> On 27.01.2017 20:03, Luke Dashjr via bitcoin-dev wrote:
>> Assume as a premise (despite your apparent disagreement below) that for
>> Bitcoin to function, a supermajority of economic activity needs to be verified
>> using full nodes operated by the recipient. Evidence suggests that at this
>> current time, at best 10% of economic activity is in fact using a full node to
>> verify the transaction. On this basis, it seems pretty clear that serious
>> action must be taken to change the status quo, and so for efforts to do so
>> without dropping the block size have proven ineffective.
> Lets think like people in sales and marketing for a moment.
> 
> There's an implicit assumption here that ANY protocol or consensus-rule based solution exists that would reverse the trend of diminishing full node verified economic activity. Since there's no economic advantage to running a full node, there's no inherent motivation for implementation (or outright purchase) of full nodes by the very large percentage of people who fall in the non-technical "I just want it to work, and I don't want my money stolen" category. Yes, anyone on this list understands that "don't want my money stolen" is inherently connected to running your own node and using it for transactions, but the average user does not, and even if they did, they don't have the resources (time and/or money) to do anything about it. Running your own full node increases the protection agains double spend attacks and other protocol bases shenanigans, but now you've taken on another set of security exposures related to the physical box that is running the node. Anti-virus, off and on-site backups, multiple boxes/devices for multi-sig, backup of key seeds.
> 
> Reducing (or even maintaining) the block size doesn't somehow increase the number of people who are capable of running full nodes, and it doesn't add any incentive for people already in that "capable" set to suddenly take up the task of running and transacting via a full node. I'd argue that the size of the block-chain and the time to download it are the least concerning aspects to anyone faced with running their own node and actually storing some of their wealth on it and using it for transactions.
> 
> You're looking for a (maybe dangerous/maybe impossible) balance between choking off casual (not full node) usage of bitcoin and yet trying to make it more popular among the people (and organizations) who have the capability and resources to run and transact on full nodes.
> 
> We should sit with this for a moment.
> 
> On one hand, Bitcoin may ultimately end up as digital currency "only for geeks and B2B transactions." I'd speculate we'd loose a big subset of the geeks that way too, unless they happen to do a lot of transactions with medium to large size businesses. (Small businesses won't be able to afford the expense of or the time to maintain the node.) There's some level of risk that this pushes bitcoin into oblivion. And is it really a decentralized P2P currency if it's only used by medium and large businesses and a small set of technically capable individuals that transact with those entities directly in BTC? And is it really a decentralized currency in this scenario if its used mainly by medium and large businesses, banks, and exchanges? (I've purposely excluded small businesses because while they like the benefits of flexible payment systems, more don't have the time or skill (or resources to hire the skill) needed to do a full node implementation.)
> 
> I feel inherent cognitive dissonance between "keep it decentralized" and "not useful to small business and individuals." One can make the argument that L2 solutions will be available for the small businesses and individuals but that doesn't solve the stated intent of reversing the trend of transactions not originating from or being received by full nodes. I guess you're saying bitcoin will be stronger, more resistant to outside power agency and censorship if its only used by exchanges, banks, large businesses, and die-hard technically inclined people.
> 
> 
> On the other hand, maybe there's a scenario where an average person walks into a big box electronics store in any developed country and buys a "personal digital bank" appliance. I frame it this way because the majority of the worlds population is never going to run a full node on their desktop or laptop. There's no viable scenario where that happens. Laptops and desktops are already diminishing in market share due to the introduction of tablets and smartphones. General purpose OS's are also inherently un-secure, so  going down this route means we are immediately in the realm of lots of theft. Preventing theft (or loss due to errors) requires additional digital key devices, or additional devices for multi-sig transactions just for basic financial safety, not to mention a functioning backup plan, including off-site backups. Ransomeware/phishing protection? Checking email and surfing the web on the computer that holds your standard (non-multi-sig) wallet? Forgetaboutit. It'll never reach critical mass. It's not a viable proposal. Not to mention, you can't physically carry your laptop with you when you go to the shopping mall. In order for this appliance model to function, smartphone based implementations will need to interact with your personal or family server/appliance, and you'll need to be able to do multi-sig with a smartphone and another physical token you carry with you. Imagine a 2 of 5 multi-sig wallet where your phone and an NFC or LE bluetooth device are sufficient to create a transaction on your home node while shopping. Or your phone has a single sig wallet and you top it up from your appliance and it never has a high balance. In any case, I've made the argument before that the definition of "bitcoin protocol" should, in addition to the consensus protocol, probably include a secure API protocol between wallet client and full node, and it still seems to be an important missing piece. I want to be able to travel and spend BTC and I DON'T want to do general purpose computing like email and web surfing on the same computer where I have a big chunk of life savings stored! I think defining this API will actually really support the use of user controlled full nodes for transactions! Imagine Trezor owners using their own node for transactions! Bitpay is the only player I know of that provides enough of a software stack to set this up for yourself.
> 
> I think reversing the non-full node transaction trend will have to be based the appliance usage model. You buy a new 200-500Gb nvme SSD every year and put it in one of the free slots. You upgrade when all slots are full. This is one scenario that could put us on a trend of increasing transactions originating and being received by personal full nodes, i.e. reversing centralization trends.
> 
> 
> If there is any solution to this problem, it will need to recognize the fact that the supermajority of people on the planet are not technically savvy nor are they inclined to take the time to learn how to protect themselves with basic computer security much less how to use a full node for bitcoin transactions. The solution, if it exists, will need to be handed to them, and they'll need a reason to buy it. Any solution will also need to recognize the fact that it will cost resources (time and money) to run a full node. Lots of people spend a huge portion of their income just to get a smartphone because it's a useful communication device that does lots of other useful things. There's not nearly the same level of need to spend on a full node for bitcoin security.
> 
> Any solution to this problem should also recognize the fact that there's a significant amount of work to do to have a functioning personal implementation of a node and to use it for transactions. Even in my imagined future of polished and easy to use appliances, if you have enough capital in BTC that you need it and you can afford to buy it, you're now only starting to deal with implementation issues. You've now become your own bank. Now you have to secure that appliance physically, secure and back up the key seed material, secure the devices used to access it, connect an app on your smartphone to the appliance so you can create transactions while out of your home, connect your home computer(s) to the appliance, do key exchange with the app/PC and the appliance or implement some sort of PKI on all devices. You've just taken on the responsibility of a bank and a sysadmin! The higher the balance, the more of a target you are, and the more time/money you have to spend mitigating risk. This is a huge centralizing force that no one really seems to talk about. If you're the average person, you want to find a trustworthy company or trusted friend/family to take care of that stuff for you. If you're a technically inclined person AND maybe there's a way to reap some of the mining reward on a small scale, you're slightly more interested.
> 
> As a sysadmin for many years, I've seen first hand that most people want tools that just work, whether its software to make spreadsheets, operating systems, phones, or thermostats. My point here is that the number of people in the world who have the technical chops to run a node is ALWAYS going to be vastly lower than the number of people who will be using bitcoin (or cryptocurrency).
> 
> Of course we can make the argument that the definition of "bitcoin" is by design something to be used exclusively by institutions and geeks, and that this definition falls out of the necessity to ensure that it remains decentralized and censorship resistant. However, I'm not sure that logic holds or that it doesn't introduce risk that that sort of definition drives bitcoin toward diminished relevance.
> 
> At the end of all this though experiment, I'm still convinced that if the tools are built to enable flexible usage of full nodes (i.e. my phone, tablet or desktop app interfaces with the full node) then there's a large potential for increased usage of full nodes.
> 
> Thanks,
> G
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From teekhan42 at gmail.com  Mon Feb  6 18:19:43 2017
From: teekhan42 at gmail.com (t. khan)
Date: Mon, 6 Feb 2017 13:19:43 -0500
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <201702052302.29599.luke@dashjr.org>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
Message-ID: <CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>

>My BIP draft didn't make progress because the community opposes any block
size
>increase hardfork ever.

Luke, how do you know the community opposes that? Specifically, how did you
come to this conclusion?

>Your version doesn't address the current block size
>issues (ie, the blocks being too large).

Why do you think blocks are "too large"? Please cite some evidence. I've
asked this before and you ignored it, but an answer would be helpful to the
discussion.

- t.k.

On Sun, Feb 5, 2017 at 6:02 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> My BIP draft didn't make progress because the community opposes any block
> size
> increase hardfork ever. Your version doesn't address the current block size
> issues (ie, the blocks being too large). So you've retained the only
> certain-
> DOA parts of my proposal, and removed the most useful part... I'm not sure
> the
> point. Also, your version is now EXCLUSIVELY a hardfork, so it makes no
> sense
> to keep the BIP 9 deployment at all - either it gets consensus or it
> doesn't,
> but miners have no part in deployment of it.
>
> On Sunday, February 05, 2017 9:50:26 PM Andrew C via bitcoin-dev wrote:
> > Hello all,
> >
> > Many people have expressed discontent with Luke-jr's proposed block size
> > BIP, in particular with the decrease in size that would occur if it were
> > to be activated prior to 2024.
> >
> > I have decided to modify the proposal to instead begin the increase
> > steps at the current 1000000 byte limit. The increases and the time spam
> > of each increase will remain the same, just that the increase begins
> > from 1000000 bytes instead of 300000 bytes.
> >
> > Furthermore, instead of a fixed schedule from a fixed point in time, the
> > increases will instead be calculated off of the MTP of the activation
> > block (the first block to be in the active state for this fork).
> >
> > While this proposal shares many of the same issues with the one it
> > modifies, I hope that it will be slightly less controversial and can
> > allow us to move forward with scaling Bitcoin.
> >
> > The full text of the proposal can be found at
> > https://github.com/achow101/bips/blob/bip-blksize/bip-blksize.mediawiki.
> > My implementation of it is available at
> > https://github.com/achow101/bitcoin/tree/bip-blksize
> >
> >
> > Andrew
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170206/fcf1d14b/attachment.html>

From teekhan42 at gmail.com  Mon Feb  6 20:25:13 2017
From: teekhan42 at gmail.com (t. khan)
Date: Mon, 6 Feb 2017 15:25:13 -0500
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <201702061953.40774.luke@dashjr.org>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
Message-ID: <CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>

On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Monday, February 06, 2017 6:19:43 PM you wrote:
> > >My BIP draft didn't make progress because the community opposes any
> block
> > >size increase hardfork ever.
> >
> > Luke, how do you know the community opposes that? Specifically, how did
> you
> > come to this conclusion?
>
> http://www.strawpoll.me/12228388/r


That poll shows 63% of votes want a larger than 1 MB block by this summer.
How do you go from that to "the community opposes any block increase ever"?
It shows the exact opposite of that.


> > >Your version doesn't address the current block size
> > >issues (ie, the blocks being too large).
> >
> > Why do you think blocks are "too large"? Please cite some evidence. I've
> > asked this before and you ignored it, but an answer would be helpful to
> the
> > discussion.
>
> Full node count is far below the safe minimum of 85% of economic activity.
>

Is this causing a problem now? If so, what?


> Typically reasons given for people not using full nodes themselves come
> down
> to the high resource requirements caused by the block size.


The reason people stop running nodes is because there's no incentive to
counteract the resource costs. Attempting to solve this by making blocks
*smaller* is like curing a disease by killing the patient. (Incentivizing
full node operation would fix that problem.)

- t.k.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170206/097c2546/attachment-0001.html>

From alp.bitcoin at gmail.com  Wed Feb  8 14:44:52 2017
From: alp.bitcoin at gmail.com (alp alp)
Date: Wed, 8 Feb 2017 08:44:52 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
Message-ID: <CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>

10% say literally never.  That seems like a significant disenfranchisement
and lack of consensus.

On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>
>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>> > >My BIP draft didn't make progress because the community opposes any
>> block
>> > >size increase hardfork ever.
>> >
>> > Luke, how do you know the community opposes that? Specifically, how did
>> you
>> > come to this conclusion?
>>
>> http://www.strawpoll.me/12228388/r
>
>
> That poll shows 63% of votes want a larger than 1 MB block by this summer.
> How do you go from that to "the community opposes any block increase ever"?
> It shows the exact opposite of that.
>
>
>> > >Your version doesn't address the current block size
>> > >issues (ie, the blocks being too large).
>> >
>> > Why do you think blocks are "too large"? Please cite some evidence. I've
>> > asked this before and you ignored it, but an answer would be helpful to
>> the
>> > discussion.
>>
>> Full node count is far below the safe minimum of 85% of economic activity.
>>
>
> Is this causing a problem now? If so, what?
>
>
>> Typically reasons given for people not using full nodes themselves come
>> down
>> to the high resource requirements caused by the block size.
>
>
> The reason people stop running nodes is because there's no incentive to
> counteract the resource costs. Attempting to solve this by making blocks
> *smaller* is like curing a disease by killing the patient. (Incentivizing
> full node operation would fix that problem.)
>
> - t.k.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/18d9cda5/attachment.html>

From john at seebitcoin.com  Tue Feb  7 11:27:55 2017
From: john at seebitcoin.com (John Hardy)
Date: Tue, 7 Feb 2017 11:27:55 +0000
Subject: [bitcoin-dev] Proof of Nodework (PoNW) - a method to trustlessly
 reward nodes for storing and verifying the blockchain
Message-ID: <BL2PR03MB435AA04A0AB8AC0E7781CA7EE430@BL2PR03MB435.namprd03.prod.outlook.com>

Proof of Nodework (PoNW) is a way to reward individual nodes for keeping a full copy of and verifying the blockchain.


Hopefully they also do useful ?traditional? node activities too like relay transactions and blocks, but there isn?t really any way I can think of to trustlessly verify this also.


PoNW would require a new separate area of block space, a nodeblock, purely concerned with administering the system. A nodeblock is committed to a block as with SegWit. A recent history of nodeblocks needs to be stored by nodes, however the data eventually becomes obsolete and so does not need to be retained forever.


In order to prevent Sybil, a node must register an Bitcoin address by submitting an addNode transaction - along with a security deposit to prevent cheating.


This transaction will be stored in the nodeblock. Once a node can see that its addNode transaction has been added it can begin the PoNW process. The node?s registered address will be hashed with the block header of the block it wants to work on. This will determine exactly where within the blockchain to begin the PoNW.


The PoNW method could be as simple as creating a Merkle tree from the randomly generated point on the blockchain, though a method that is CPU/Memory heavy and less likely to be replaced by dedicated hardware like ASICs would be better. This process could not begin until the most recent block has been fully verified, and while being carried out should still enable normal relay activities to proceed as normal, since it shouldn?t tie up network at all. The data processed should also be mixed with data from the latest block so that it cannot be computed in advance.


A node can do as much PoNW for a block as it likes. Once finished it will then create a nodeWorkComplete transaction for that block with its final proof value, add how much ?work? it did - and create a couple of assertions about what it processed (such as there were x number of pieces of data matching a particular value during calculating). These assertions can be accurate or inaccurate.


The system will run in epochs. During each epoch of say 2016 blocks, there will be an extended window for PoNW transactions to be added to nodeblocks to limit minor censorship.


The random hash generated from a node?s address and blockhash will also be used to determine nodeWorkComplete transactions from a previous block that the node must also verify, and correctly calculate whether the assertions it made were true or false. The average PoNW that a node performed in its previous x nodeblocks will be used to determine the target PoNW for the node to verify - and this will randomly be a large number of smaller PoNW transactions, or a smaller number of large PoNW. This process will be deterministic based on that block and address hash. All the data will be put together in a transaction and then signed by the node addresses private key.


If a nodeWorkComplete transaction contains any incorrect information in an attempt to cheat the validation process a challenge transaction can be created. This begins a refereeing process where other nodes check the challenge and vote whether it is to be upheld or not. The losing node is punished by losing their accrued PoNW for that epoch and a percentage of their security deposit.


Nodes will also be punished if they broadcast more than one signed transaction per block.


In order to prevent nodes from having multiple keys registered - which would enable them choose to perform PoNW on a subset of the data that they hold - the share of reward that the node gets will be multiplied based on the number of blocks within an epoch that the node performs PoNW on. The share of reward is limited based on how much security deposit has been staked. The higher the PoNW the higher the deposit needed in order to claim their full allocation of any reward.


At the end of an epoch, with a wait period for any delayed or censored transactions or challenges to be included and settled up, the process of calculating the reward each node is due can begin. This will then be then paid in a regular block, and means for all the data involved in PoNW, the only permanent mark it makes on the main blockchain is for a transaction that pays all addresses their share of the reward at the end of epoch. Any miner who creates a block without correctly calculating and paying the due reward will have mined an invalid block and be orphaned.


The question of where and how much the reward comes from is a different one. It could come from the existing miner reward, or a special new tx donation fee for nodes. If there was some way for users to ?donate? to the reward pool for nodes this would increase the incentive for additional nodes to participate on the network in the event of centralisation.


This is a relatively effective way to create a reward for all nodes participating on a network. I?d be keen to field any questions or critiques.

Thanks,


John Hardy

john at seebitcoin.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170207/ff6c8c31/attachment-0001.html>

From mirelo at deugh-ausgam-valis.com  Wed Feb  8 01:34:29 2017
From: mirelo at deugh-ausgam-valis.com (Mirelo)
Date: Tue, 07 Feb 2017 20:34:29 -0500
Subject: [bitcoin-dev] Proof-of-Loss -- Errata
Message-ID: <SxMWjK2t9ewJnV8EYSUY9hIccG_MDsVduGIFHbabUmIcv__L46iNj42pWntzyLiknSr8-IZlHZAFI6ynX2zU8TwyhPBPRIs5o5Wi5vGuwUA=@deugh-ausgam-valis.com>

There was an error on page 5 of the paper, which made the block-chaining odds formula confusing. The error was in the text, not in the formula, and consisted of assuming the affected route as always being the rewarded one, which is false. The corrected version is already available at the same URL ([https://proof-of-loss.money](https://proof-of-loss.money/)). The new file's date is 02/07/2017, and downloading it will probably require clearing the browser's cache.

I would greatly appreciate any feedback, preferably directly to my email, to avoid overloading this list with something not directly related to Bitcoin.

Mirelo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170207/a5c052d8/attachment-0001.html>

From andrew.johnson83 at gmail.com  Wed Feb  8 15:51:24 2017
From: andrew.johnson83 at gmail.com (Andrew Johnson)
Date: Wed, 8 Feb 2017 09:51:24 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
Message-ID: <CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>

You're never going to reach 100% agreement, and stifling the network
literally forever to please a tiny minority is daft.

On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

10% say literally never.  That seems like a significant disenfranchisement
and lack of consensus.

On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <bitcoin-dev at lists.
linuxfoundation.org> wrote:

> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>
>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>> > >My BIP draft didn't make progress because the community opposes any
>> block
>> > >size increase hardfork ever.
>> >
>> > Luke, how do you know the community opposes that? Specifically, how did
>> you
>> > come to this conclusion?
>>
>> http://www.strawpoll.me/12228388/r
>
>
> That poll shows 63% of votes want a larger than 1 MB block by this summer.
> How do you go from that to "the community opposes any block increase ever"?
> It shows the exact opposite of that.
>
>
>> > >Your version doesn't address the current block size
>> > >issues (ie, the blocks being too large).
>> >
>> > Why do you think blocks are "too large"? Please cite some evidence. I've
>> > asked this before and you ignored it, but an answer would be helpful to
>> the
>> > discussion.
>>
>> Full node count is far below the safe minimum of 85% of economic activity.
>>
>
> Is this causing a problem now? If so, what?
>
>
>> Typically reasons given for people not using full nodes themselves come
>> down
>> to the high resource requirements caused by the block size.
>
>
> The reason people stop running nodes is because there's no incentive to
> counteract the resource costs. Attempting to solve this by making blocks
> *smaller* is like curing a disease by killing the patient. (Incentivizing
> full node operation would fix that problem.)
>
> - t.k.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/fab8e0e5/attachment-0001.html>

From alp.bitcoin at gmail.com  Wed Feb  8 15:57:21 2017
From: alp.bitcoin at gmail.com (alp alp)
Date: Wed, 8 Feb 2017 09:57:21 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
Message-ID: <CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>

10% is not a tiny minority.

On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com> wrote:

> You're never going to reach 100% agreement, and stifling the network
> literally forever to please a tiny minority is daft.
>
> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> wrote:
>
> 10% say literally never.  That seems like a significant disenfranchisement
> and lack of consensus.
>
> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>
>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>> > >My BIP draft didn't make progress because the community opposes any
>>> block
>>> > >size increase hardfork ever.
>>> >
>>> > Luke, how do you know the community opposes that? Specifically, how
>>> did you
>>> > come to this conclusion?
>>>
>>> http://www.strawpoll.me/12228388/r
>>
>>
>> That poll shows 63% of votes want a larger than 1 MB block by this
>> summer. How do you go from that to "the community opposes any block
>> increase ever"? It shows the exact opposite of that.
>>
>>
>>> > >Your version doesn't address the current block size
>>> > >issues (ie, the blocks being too large).
>>> >
>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>> I've
>>> > asked this before and you ignored it, but an answer would be helpful
>>> to the
>>> > discussion.
>>>
>>> Full node count is far below the safe minimum of 85% of economic
>>> activity.
>>>
>>
>> Is this causing a problem now? If so, what?
>>
>>
>>> Typically reasons given for people not using full nodes themselves come
>>> down
>>> to the high resource requirements caused by the block size.
>>
>>
>> The reason people stop running nodes is because there's no incentive to
>> counteract the resource costs. Attempting to solve this by making blocks
>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>> full node operation would fix that problem.)
>>
>> - t.k.
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/b9d35e07/attachment-0001.html>

From andrew.johnson83 at gmail.com  Wed Feb  8 16:28:55 2017
From: andrew.johnson83 at gmail.com (Andrew Johnson)
Date: Wed, 8 Feb 2017 10:28:55 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
	<CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
Message-ID: <CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>

It is when you're talking about making a choice and 6.3x more people prefer
something else. Doing nothing is a choice as well.

Put another way, if 10% supported increasing the 21M coin cap and 63% were
against, would you seriously consider doing it?

On Feb 8, 2017 9:57 AM, "alp alp" <alp.bitcoin at gmail.com> wrote:

> 10% is not a tiny minority.
>
> On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
> wrote:
>
>> You're never going to reach 100% agreement, and stifling the network
>> literally forever to please a tiny minority is daft.
>>
>> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> 10% say literally never.  That seems like a significant
>> disenfranchisement and lack of consensus.
>>
>> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>>
>>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>>> > >My BIP draft didn't make progress because the community opposes any
>>>> block
>>>> > >size increase hardfork ever.
>>>> >
>>>> > Luke, how do you know the community opposes that? Specifically, how
>>>> did you
>>>> > come to this conclusion?
>>>>
>>>> http://www.strawpoll.me/12228388/r
>>>
>>>
>>> That poll shows 63% of votes want a larger than 1 MB block by this
>>> summer. How do you go from that to "the community opposes any block
>>> increase ever"? It shows the exact opposite of that.
>>>
>>>
>>>> > >Your version doesn't address the current block size
>>>> > >issues (ie, the blocks being too large).
>>>> >
>>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>>> I've
>>>> > asked this before and you ignored it, but an answer would be helpful
>>>> to the
>>>> > discussion.
>>>>
>>>> Full node count is far below the safe minimum of 85% of economic
>>>> activity.
>>>>
>>>
>>> Is this causing a problem now? If so, what?
>>>
>>>
>>>> Typically reasons given for people not using full nodes themselves come
>>>> down
>>>> to the high resource requirements caused by the block size.
>>>
>>>
>>> The reason people stop running nodes is because there's no incentive to
>>> counteract the resource costs. Attempting to solve this by making blocks
>>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>>> full node operation would fix that problem.)
>>>
>>> - t.k.
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/4a68bd99/attachment-0001.html>

From alp.bitcoin at gmail.com  Wed Feb  8 18:16:07 2017
From: alp.bitcoin at gmail.com (alp alp)
Date: Wed, 8 Feb 2017 12:16:07 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
	<CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
	<CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>
Message-ID: <CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>

Doing nothing is the rules we all agreed to.  If those rules are to be
changed,nearly everyone will need to consent.  The same rule applies to the
cap, we all agreed to 21m, and if someone wants to change that, nearly
everyone would need to agree.

On Feb 8, 2017 10:28 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
wrote:

It is when you're talking about making a choice and 6.3x more people prefer
something else. Doing nothing is a choice as well.

Put another way, if 10% supported increasing the 21M coin cap and 63% were
against, would you seriously consider doing it?

On Feb 8, 2017 9:57 AM, "alp alp" <alp.bitcoin at gmail.com> wrote:

> 10% is not a tiny minority.
>
> On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
> wrote:
>
>> You're never going to reach 100% agreement, and stifling the network
>> literally forever to please a tiny minority is daft.
>>
>> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> 10% say literally never.  That seems like a significant
>> disenfranchisement and lack of consensus.
>>
>> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>>
>>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>>> > >My BIP draft didn't make progress because the community opposes any
>>>> block
>>>> > >size increase hardfork ever.
>>>> >
>>>> > Luke, how do you know the community opposes that? Specifically, how
>>>> did you
>>>> > come to this conclusion?
>>>>
>>>> http://www.strawpoll.me/12228388/r
>>>
>>>
>>> That poll shows 63% of votes want a larger than 1 MB block by this
>>> summer. How do you go from that to "the community opposes any block
>>> increase ever"? It shows the exact opposite of that.
>>>
>>>
>>>> > >Your version doesn't address the current block size
>>>> > >issues (ie, the blocks being too large).
>>>> >
>>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>>> I've
>>>> > asked this before and you ignored it, but an answer would be helpful
>>>> to the
>>>> > discussion.
>>>>
>>>> Full node count is far below the safe minimum of 85% of economic
>>>> activity.
>>>>
>>>
>>> Is this causing a problem now? If so, what?
>>>
>>>
>>>> Typically reasons given for people not using full nodes themselves come
>>>> down
>>>> to the high resource requirements caused by the block size.
>>>
>>>
>>> The reason people stop running nodes is because there's no incentive to
>>> counteract the resource costs. Attempting to solve this by making blocks
>>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>>> full node operation would fix that problem.)
>>>
>>> - t.k.
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/fe125147/attachment-0001.html>

From teekhan42 at gmail.com  Wed Feb  8 19:53:15 2017
From: teekhan42 at gmail.com (t. khan)
Date: Wed, 8 Feb 2017 14:53:15 -0500
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
	<CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
	<CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>
	<CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>
Message-ID: <CAGCNRJq3sj5Y2PHPc=Ckrpn0RGBj=OyoU3+e-1p-19znE=RnVg@mail.gmail.com>

Even ignoring the obvious flaws of that poll, Andrew is still correct: you
cannot reach 100% consensus. It's statistically impossible in any large
group.

Only the majority needs to consent, though what is considered a majority
varies depending on the context (95%, 75%, 51%). Nowhere does it say
"everyone needs to agree".

On Wed, Feb 8, 2017 at 1:16 PM, alp alp <alp.bitcoin at gmail.com> wrote:

> Doing nothing is the rules we all agreed to.  If those rules are to be
> changed,nearly everyone will need to consent.  The same rule applies to the
> cap, we all agreed to 21m, and if someone wants to change that, nearly
> everyone would need to agree.
>
>
> On Feb 8, 2017 10:28 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
> wrote:
>
> It is when you're talking about making a choice and 6.3x more people
> prefer something else. Doing nothing is a choice as well.
>
> Put another way, if 10% supported increasing the 21M coin cap and 63% were
> against, would you seriously consider doing it?
>
> On Feb 8, 2017 9:57 AM, "alp alp" <alp.bitcoin at gmail.com> wrote:
>
>> 10% is not a tiny minority.
>>
>> On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
>> wrote:
>>
>>> You're never going to reach 100% agreement, and stifling the network
>>> literally forever to please a tiny minority is daft.
>>>
>>> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> 10% say literally never.  That seems like a significant
>>> disenfranchisement and lack of consensus.
>>>
>>> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>>>
>>>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>>>> > >My BIP draft didn't make progress because the community opposes any
>>>>> block
>>>>> > >size increase hardfork ever.
>>>>> >
>>>>> > Luke, how do you know the community opposes that? Specifically, how
>>>>> did you
>>>>> > come to this conclusion?
>>>>>
>>>>> http://www.strawpoll.me/12228388/r
>>>>
>>>>
>>>> That poll shows 63% of votes want a larger than 1 MB block by this
>>>> summer. How do you go from that to "the community opposes any block
>>>> increase ever"? It shows the exact opposite of that.
>>>>
>>>>
>>>>> > >Your version doesn't address the current block size
>>>>> > >issues (ie, the blocks being too large).
>>>>> >
>>>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>>>> I've
>>>>> > asked this before and you ignored it, but an answer would be helpful
>>>>> to the
>>>>> > discussion.
>>>>>
>>>>> Full node count is far below the safe minimum of 85% of economic
>>>>> activity.
>>>>>
>>>>
>>>> Is this causing a problem now? If so, what?
>>>>
>>>>
>>>>> Typically reasons given for people not using full nodes themselves
>>>>> come down
>>>>> to the high resource requirements caused by the block size.
>>>>
>>>>
>>>> The reason people stop running nodes is because there's no incentive to
>>>> counteract the resource costs. Attempting to solve this by making blocks
>>>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>>>> full node operation would fix that problem.)
>>>>
>>>> - t.k.
>>>>
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/444cd354/attachment-0001.html>

From andrew.johnson83 at gmail.com  Wed Feb  8 19:56:19 2017
From: andrew.johnson83 at gmail.com (Andrew Johnson)
Date: Wed, 8 Feb 2017 13:56:19 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
	<CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
	<CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>
	<CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>
Message-ID: <CAAy62_L7G6aY0hpw-wc6Z+2DWiFUNOX003iTWbbvsZywLV+orA@mail.gmail.com>

If a small dissenting minority can block all forward progress then bitcoin
is no longer interesting.  What an incredibly simple attack vector...

No need to break any cryptography, find a bug to exploit, build tens of
millions of dollars in mining hardware, spend lots of bitcoin on fees to
flood the network, or be clever or expend any valuable resources in any
way, shape, or form.

Just convince(or pay, if you do want to expend some resources) a few
people(or make up a few online personas) to staunchly refuse to accept
anything at all and the entire system is stuck in 2013(when we first
started widely discussing a blocksize increase seriously).

Is that really the bitcoin that you want to be a part of?

When the 1MB cap was implemented it was stated specifically that we could
increase it when we needed it.  The white paper even talks about scaling to
huge capacity.  Not sure where you got the idea that we all agreed to stay
at 1MB forever, I certainly didn't.  It was never stated or implied that we
could change the coin cap later(please cite if I'm mistaken).


On Feb 8, 2017 12:16 PM, "alp alp" <alp.bitcoin at gmail.com> wrote:

Doing nothing is the rules we all agreed to.  If those rules are to be
changed,nearly everyone will need to consent.  The same rule applies to the
cap, we all agreed to 21m, and if someone wants to change that, nearly
everyone would need to agree.


On Feb 8, 2017 10:28 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
wrote:

It is when you're talking about making a choice and 6.3x more people prefer
something else. Doing nothing is a choice as well.

Put another way, if 10% supported increasing the 21M coin cap and 63% were
against, would you seriously consider doing it?

On Feb 8, 2017 9:57 AM, "alp alp" <alp.bitcoin at gmail.com> wrote:

> 10% is not a tiny minority.
>
> On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
> wrote:
>
>> You're never going to reach 100% agreement, and stifling the network
>> literally forever to please a tiny minority is daft.
>>
>> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> 10% say literally never.  That seems like a significant
>> disenfranchisement and lack of consensus.
>>
>> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>>
>>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>>> > >My BIP draft didn't make progress because the community opposes any
>>>> block
>>>> > >size increase hardfork ever.
>>>> >
>>>> > Luke, how do you know the community opposes that? Specifically, how
>>>> did you
>>>> > come to this conclusion?
>>>>
>>>> http://www.strawpoll.me/12228388/r
>>>
>>>
>>> That poll shows 63% of votes want a larger than 1 MB block by this
>>> summer. How do you go from that to "the community opposes any block
>>> increase ever"? It shows the exact opposite of that.
>>>
>>>
>>>> > >Your version doesn't address the current block size
>>>> > >issues (ie, the blocks being too large).
>>>> >
>>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>>> I've
>>>> > asked this before and you ignored it, but an answer would be helpful
>>>> to the
>>>> > discussion.
>>>>
>>>> Full node count is far below the safe minimum of 85% of economic
>>>> activity.
>>>>
>>>
>>> Is this causing a problem now? If so, what?
>>>
>>>
>>>> Typically reasons given for people not using full nodes themselves come
>>>> down
>>>> to the high resource requirements caused by the block size.
>>>
>>>
>>> The reason people stop running nodes is because there's no incentive to
>>> counteract the resource costs. Attempting to solve this by making blocks
>>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>>> full node operation would fix that problem.)
>>>
>>> - t.k.
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/eb653e44/attachment-0001.html>

From alp.bitcoin at gmail.com  Wed Feb  8 20:13:18 2017
From: alp.bitcoin at gmail.com (alp alp)
Date: Wed, 8 Feb 2017 14:13:18 -0600
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAAy62_L7G6aY0hpw-wc6Z+2DWiFUNOX003iTWbbvsZywLV+orA@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
	<CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
	<CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>
	<CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>
	<CAAy62_L7G6aY0hpw-wc6Z+2DWiFUNOX003iTWbbvsZywLV+orA@mail.gmail.com>
Message-ID: <CAMBsKS9O2VXtC+m1w_NbcP96d2Fk+6NqfP3SxHG8Ce2gL=mRBA@mail.gmail.com>

>Only the majority needs to consent, though what is considered a majority
varies depending on the context (95%, 75%, 51%). Nowhere does it say
"everyone needs to agree".

There's a pretty huge gap between 90% and nearly 100%.  90% excluding 10%
only 7 times results in only 48% of the original base.

>If a small dissenting minority can block all forward progress then bitcoin
is no longer interesting.

Your definition of forward may be different than other users.

>Is that really the bitcoin that you want to be a part of?

Yes, I chose Bitcoin because it relies on a strictly held consensus
mechanism and not one that changes on the whims of the majority.  We have
tens of dozens of political currencies for that.

>When the 1MB cap was implemented it was stated specifically that we could
increase it when we needed it.  The white paper even talks about scaling to
huge capacity.  Not sure where you got the idea that we all agreed to stay
at 1MB forever, I certainly didn't.  It was never stated or implied that we
could change the coin cap later(please cite if I'm mistaken).

The community has not agreed that it is needed at this time.  Perhaps they
will change their mind at some point in the future.  We have also learned a
great deal since the publication of the initial whitepaper, such as the
unstable state without a backlog or subsidy.  Fortunately, participation in
this system is voluntary, and you are free to leave at any time.

This seems to be venturing quite off topic, and perhaps would be better
suited for the bitcoin-discuss list.

On Wed, Feb 8, 2017 at 1:56 PM, Andrew Johnson <andrew.johnson83 at gmail.com>
wrote:

> If a small dissenting minority can block all forward progress then bitcoin
> is no longer interesting.  What an incredibly simple attack vector...
>
> No need to break any cryptography, find a bug to exploit, build tens of
> millions of dollars in mining hardware, spend lots of bitcoin on fees to
> flood the network, or be clever or expend any valuable resources in any
> way, shape, or form.
>
> Just convince(or pay, if you do want to expend some resources) a few
> people(or make up a few online personas) to staunchly refuse to accept
> anything at all and the entire system is stuck in 2013(when we first
> started widely discussing a blocksize increase seriously).
>
> Is that really the bitcoin that you want to be a part of?
>
> When the 1MB cap was implemented it was stated specifically that we could
> increase it when we needed it.  The white paper even talks about scaling to
> huge capacity.  Not sure where you got the idea that we all agreed to stay
> at 1MB forever, I certainly didn't.  It was never stated or implied that we
> could change the coin cap later(please cite if I'm mistaken).
>
>
> On Feb 8, 2017 12:16 PM, "alp alp" <alp.bitcoin at gmail.com> wrote:
>
> Doing nothing is the rules we all agreed to.  If those rules are to be
> changed,nearly everyone will need to consent.  The same rule applies to the
> cap, we all agreed to 21m, and if someone wants to change that, nearly
> everyone would need to agree.
>
>
> On Feb 8, 2017 10:28 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
> wrote:
>
> It is when you're talking about making a choice and 6.3x more people
> prefer something else. Doing nothing is a choice as well.
>
> Put another way, if 10% supported increasing the 21M coin cap and 63% were
> against, would you seriously consider doing it?
>
> On Feb 8, 2017 9:57 AM, "alp alp" <alp.bitcoin at gmail.com> wrote:
>
>> 10% is not a tiny minority.
>>
>> On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
>> wrote:
>>
>>> You're never going to reach 100% agreement, and stifling the network
>>> literally forever to please a tiny minority is daft.
>>>
>>> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> 10% say literally never.  That seems like a significant
>>> disenfranchisement and lack of consensus.
>>>
>>> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>>>
>>>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>>>> > >My BIP draft didn't make progress because the community opposes any
>>>>> block
>>>>> > >size increase hardfork ever.
>>>>> >
>>>>> > Luke, how do you know the community opposes that? Specifically, how
>>>>> did you
>>>>> > come to this conclusion?
>>>>>
>>>>> http://www.strawpoll.me/12228388/r
>>>>
>>>>
>>>> That poll shows 63% of votes want a larger than 1 MB block by this
>>>> summer. How do you go from that to "the community opposes any block
>>>> increase ever"? It shows the exact opposite of that.
>>>>
>>>>
>>>>> > >Your version doesn't address the current block size
>>>>> > >issues (ie, the blocks being too large).
>>>>> >
>>>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>>>> I've
>>>>> > asked this before and you ignored it, but an answer would be helpful
>>>>> to the
>>>>> > discussion.
>>>>>
>>>>> Full node count is far below the safe minimum of 85% of economic
>>>>> activity.
>>>>>
>>>>
>>>> Is this causing a problem now? If so, what?
>>>>
>>>>
>>>>> Typically reasons given for people not using full nodes themselves
>>>>> come down
>>>>> to the high resource requirements caused by the block size.
>>>>
>>>>
>>>> The reason people stop running nodes is because there's no incentive to
>>>> counteract the resource costs. Attempting to solve this by making blocks
>>>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>>>> full node operation would fix that problem.)
>>>>
>>>> - t.k.
>>>>
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/672a9a83/attachment-0001.html>

From rjmarti2 at millersville.edu  Fri Feb 10 04:10:15 2017
From: rjmarti2 at millersville.edu (Ryan J Martin)
Date: Fri, 10 Feb 2017 04:10:15 +0000
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
Message-ID: <127281C1AA02374F8AAD9EE04FAE878A02154E80BD@STUDMail1.muad.local>

"10% say literally never.  That seems like a significant disenfranchisement
and lack of consensus."

Certainly the poll results should be taken with a grain of salt and not a definitive answer or measure . 
However if we agree the poll has some worth (or even if not, then lets use it as hyptothetical): If we split it into two groups: those okay with a hardfork at some point > now, and those never okay with hardfork, that means there is 90% that agree a hardfork is acceptable in the future. That said, what threshold defines consensus then? 98%? 100%?       
 
Personally I think pursuing paths that maximize net social benefit in terms of cost surplus/burden is the best way to go since consensus is such an impossible to define, variable, case-by-case thing that doesn't always lead to the best choice.

-Ryan J. MArtin
 

________________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org [bitcoin-dev-bounces at lists.linuxfoundation.org] on behalf of bitcoin-dev-request at lists.linuxfoundation.org [bitcoin-dev-request at lists.linuxfoundation.org]
Sent: Thursday, February 09, 2017 7:00 AM
To: bitcoin-dev at lists.linuxfoundation.org
Subject: bitcoin-dev Digest, Vol 21, Issue 10

Send bitcoin-dev mailing list submissions to
        bitcoin-dev at lists.linuxfoundation.org

To subscribe or unsubscribe via the World Wide Web, visit
        https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
or, via email, send a message with subject or body 'help' to
        bitcoin-dev-request at lists.linuxfoundation.org

You can reach the person managing the list at
        bitcoin-dev-owner at lists.linuxfoundation.org

When replying, please edit your Subject line so it is more specific
than "Re: Contents of bitcoin-dev digest..."


Today's Topics:

   1. Re: A Modified Version of Luke-jr's Block Size BIP (alp alp)


----------------------------------------------------------------------

Message: 1
Date: Wed, 8 Feb 2017 08:44:52 -0600
From: alp alp <alp.bitcoin at gmail.com>
To: "t. khan" <teekhan42 at gmail.com>,    Bitcoin Protocol Discussion
        <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] A Modified Version of Luke-jr's Block Size
        BIP
Message-ID:
        <CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

10% say literally never.  That seems like a significant disenfranchisement
and lack of consensus.

On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>
>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>> > >My BIP draft didn't make progress because the community opposes any
>> block
>> > >size increase hardfork ever.
>> >
>> > Luke, how do you know the community opposes that? Specifically, how did
>> you
>> > come to this conclusion?
>>
>> http://www.strawpoll.me/12228388/r
>
>
> That poll shows 63% of votes want a larger than 1 MB block by this summer.
> How do you go from that to "the community opposes any block increase ever"?
> It shows the exact opposite of that.
>
>
>> > >Your version doesn't address the current block size
>> > >issues (ie, the blocks being too large).
>> >
>> > Why do you think blocks are "too large"? Please cite some evidence. I've
>> > asked this before and you ignored it, but an answer would be helpful to
>> the
>> > discussion.
>>
>> Full node count is far below the safe minimum of 85% of economic activity.
>>
>
> Is this causing a problem now? If so, what?
>
>
>> Typically reasons given for people not using full nodes themselves come
>> down
>> to the high resource requirements caused by the block size.
>
>
> The reason people stop running nodes is because there's no incentive to
> counteract the resource costs. Attempting to solve this by making blocks
> *smaller* is like curing a disease by killing the patient. (Incentivizing
> full node operation would fix that problem.)
>
> - t.k.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170208/18d9cda5/attachment-0001.html>

------------------------------

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


End of bitcoin-dev Digest, Vol 21, Issue 10
*******************************************

From btcdrak at gmail.com  Fri Feb 10 10:33:52 2017
From: btcdrak at gmail.com (Btc Drak)
Date: Fri, 10 Feb 2017 10:33:52 +0000
Subject: [bitcoin-dev] A Modified Version of Luke-jr's Block Size BIP
In-Reply-To: <CAMBsKS9O2VXtC+m1w_NbcP96d2Fk+6NqfP3SxHG8Ce2gL=mRBA@mail.gmail.com>
References: <ea63ed5a-4280-c063-4984-5bc8a4b2aafa@gmail.com>
	<201702052302.29599.luke@dashjr.org>
	<CAGCNRJrNRb4Eo5T8+KsKnazOCm15g89RFLtRW07k1KjN6TpTDw@mail.gmail.com>
	<201702061953.40774.luke@dashjr.org>
	<CAGCNRJo3zM2kYePPw-=JpMQWtn_M1Eg=SpShC_z-d-_Nv6KqcQ@mail.gmail.com>
	<CAMBsKS9OS2tA4bG-JG96XNZTiPyuq322Qu=fyJcZ1BtVj3TtxQ@mail.gmail.com>
	<CAAy62_LcpgXss9hMTG_kwoGbuTOmfpmEc-awi5gNybq0fYErfQ@mail.gmail.com>
	<CAMBsKS-Zek5qHB=Yvf0=8EKZkZL8qxAK3n=Cn7Kq6GCwt774_w@mail.gmail.com>
	<CAAy62_+AhknwH38fadiT2WTHZsiCZp-sPbVhDnKCHXwatCypnQ@mail.gmail.com>
	<CAMBsKS_JKNJFLB_ao8-dcWgWB8o5bGLbNPrPtvSmobrryZVEmQ@mail.gmail.com>
	<CAAy62_L7G6aY0hpw-wc6Z+2DWiFUNOX003iTWbbvsZywLV+orA@mail.gmail.com>
	<CAMBsKS9O2VXtC+m1w_NbcP96d2Fk+6NqfP3SxHG8Ce2gL=mRBA@mail.gmail.com>
Message-ID: <CADJgMzsYokNbCuxAwiGi0gdcJvKFrR4A8jx4RjO6CLDwtyT=NA@mail.gmail.com>

Agreed, this thread is venturing somewhat out of scope for the list. Please
can we redirect philosophical discussion to another forum/list such as
bitcoin-discuss, which can be found at
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-discuss

Repost of the bitcoin-dev posting guidelines are:

- Posts must concern development of bitcoin protocol.
- Posts should be technical or academic in nature.
- Generally encouraged: patches, notification of pull requests, BIP
proposals, academic paper announcements. And discussions that follow.
- Generally discouraged: shower thoughts, wild speculation, jokes, +1s,
non-technical bitcoin issues, rehashing settled topics without new data,
moderation concerns.
- Detailed patch discussion generally better on a GitHub PR.
- Meta-discussion is better on bitcoin-discuss.

On Wed, Feb 8, 2017 at 8:13 PM, alp alp via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> >Only the majority needs to consent, though what is considered a majority
> varies depending on the context (95%, 75%, 51%). Nowhere does it say
> "everyone needs to agree".
>
> There's a pretty huge gap between 90% and nearly 100%.  90% excluding 10%
> only 7 times results in only 48% of the original base.
>
> >If a small dissenting minority can block all forward progress then
> bitcoin is no longer interesting.
>
> Your definition of forward may be different than other users.
>
> >Is that really the bitcoin that you want to be a part of?
>
> Yes, I chose Bitcoin because it relies on a strictly held consensus
> mechanism and not one that changes on the whims of the majority.  We have
> tens of dozens of political currencies for that.
>
> >When the 1MB cap was implemented it was stated specifically that we
> could increase it when we needed it.  The white paper even talks about
> scaling to huge capacity.  Not sure where you got the idea that we all
> agreed to stay at 1MB forever, I certainly didn't.  It was never stated or
> implied that we could change the coin cap later(please cite if I'm
> mistaken).
>
> The community has not agreed that it is needed at this time.  Perhaps they
> will change their mind at some point in the future.  We have also learned a
> great deal since the publication of the initial whitepaper, such as the
> unstable state without a backlog or subsidy.  Fortunately, participation in
> this system is voluntary, and you are free to leave at any time.
>
> This seems to be venturing quite off topic, and perhaps would be better
> suited for the bitcoin-discuss list.
>
> On Wed, Feb 8, 2017 at 1:56 PM, Andrew Johnson <andrew.johnson83 at gmail.com
> > wrote:
>
>> If a small dissenting minority can block all forward progress then
>> bitcoin is no longer interesting.  What an incredibly simple attack
>> vector...
>>
>> No need to break any cryptography, find a bug to exploit, build tens of
>> millions of dollars in mining hardware, spend lots of bitcoin on fees to
>> flood the network, or be clever or expend any valuable resources in any
>> way, shape, or form.
>>
>> Just convince(or pay, if you do want to expend some resources) a few
>> people(or make up a few online personas) to staunchly refuse to accept
>> anything at all and the entire system is stuck in 2013(when we first
>> started widely discussing a blocksize increase seriously).
>>
>> Is that really the bitcoin that you want to be a part of?
>>
>> When the 1MB cap was implemented it was stated specifically that we could
>> increase it when we needed it.  The white paper even talks about scaling to
>> huge capacity.  Not sure where you got the idea that we all agreed to stay
>> at 1MB forever, I certainly didn't.  It was never stated or implied that we
>> could change the coin cap later(please cite if I'm mistaken).
>>
>>
>> On Feb 8, 2017 12:16 PM, "alp alp" <alp.bitcoin at gmail.com> wrote:
>>
>> Doing nothing is the rules we all agreed to.  If those rules are to be
>> changed,nearly everyone will need to consent.  The same rule applies to the
>> cap, we all agreed to 21m, and if someone wants to change that, nearly
>> everyone would need to agree.
>>
>>
>> On Feb 8, 2017 10:28 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
>> wrote:
>>
>> It is when you're talking about making a choice and 6.3x more people
>> prefer something else. Doing nothing is a choice as well.
>>
>> Put another way, if 10% supported increasing the 21M coin cap and 63%
>> were against, would you seriously consider doing it?
>>
>> On Feb 8, 2017 9:57 AM, "alp alp" <alp.bitcoin at gmail.com> wrote:
>>
>>> 10% is not a tiny minority.
>>>
>>> On Feb 8, 2017 9:51 AM, "Andrew Johnson" <andrew.johnson83 at gmail.com>
>>> wrote:
>>>
>>>> You're never going to reach 100% agreement, and stifling the network
>>>> literally forever to please a tiny minority is daft.
>>>>
>>>> On Feb 8, 2017 8:52 AM, "alp alp via bitcoin-dev" <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>> 10% say literally never.  That seems like a significant
>>>> disenfranchisement and lack of consensus.
>>>>
>>>> On Mon, Feb 6, 2017 at 2:25 PM, t. khan via bitcoin-dev <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> On Mon, Feb 6, 2017 at 2:53 PM, Luke Dashjr <luke at dashjr.org> wrote:
>>>>>
>>>>>> On Monday, February 06, 2017 6:19:43 PM you wrote:
>>>>>> > >My BIP draft didn't make progress because the community opposes
>>>>>> any block
>>>>>> > >size increase hardfork ever.
>>>>>> >
>>>>>> > Luke, how do you know the community opposes that? Specifically, how
>>>>>> did you
>>>>>> > come to this conclusion?
>>>>>>
>>>>>> http://www.strawpoll.me/12228388/r
>>>>>
>>>>>
>>>>> That poll shows 63% of votes want a larger than 1 MB block by this
>>>>> summer. How do you go from that to "the community opposes any block
>>>>> increase ever"? It shows the exact opposite of that.
>>>>>
>>>>>
>>>>>> > >Your version doesn't address the current block size
>>>>>> > >issues (ie, the blocks being too large).
>>>>>> >
>>>>>> > Why do you think blocks are "too large"? Please cite some evidence.
>>>>>> I've
>>>>>> > asked this before and you ignored it, but an answer would be
>>>>>> helpful to the
>>>>>> > discussion.
>>>>>>
>>>>>> Full node count is far below the safe minimum of 85% of economic
>>>>>> activity.
>>>>>>
>>>>>
>>>>> Is this causing a problem now? If so, what?
>>>>>
>>>>>
>>>>>> Typically reasons given for people not using full nodes themselves
>>>>>> come down
>>>>>> to the high resource requirements caused by the block size.
>>>>>
>>>>>
>>>>> The reason people stop running nodes is because there's no incentive
>>>>> to counteract the resource costs. Attempting to solve this by making blocks
>>>>> *smaller* is like curing a disease by killing the patient. (Incentivizing
>>>>> full node operation would fix that problem.)
>>>>>
>>>>> - t.k.
>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>>
>>>>
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170210/f18dc28a/attachment.html>

From staf at stafverhaegen.be  Sat Feb 11 15:26:33 2017
From: staf at stafverhaegen.be (Staf Verhaegen)
Date: Sat, 11 Feb 2017 16:26:33 +0100
Subject: [bitcoin-dev] Three hardfork-related BIPs
In-Reply-To: <4C206BDC-CCAB-4F4B-9356-6FA7652E467A@voskuil.org>
References: <201701270107.01092.luke@dashjr.org> <20170127212810.GA5856@nex>
	<CAAy62_KUSNTjivwJT87K9f1c=k-6gdaLXEBJjcy2KK+uLSTWDA@mail.gmail.com>
	<201701280403.05558.luke@dashjr.org>
	<CAAt2M183=L=9N3HKVgGbsFbug4LWkGfMQzzcDQu9xxMJL+L1oA@mail.gmail.com>
	<A6A9E83E-6A5A-4583-A4E3-A52DF33DCF4F@petertodd.org>
	<583ef2d2-8315-da9f-7815-768cb4ccb515@thinlink.com>
	<4C206BDC-CCAB-4F4B-9356-6FA7652E467A@voskuil.org>
Message-ID: <1486826793.21100.114.camel@stafverhaegen.be>

Eric Voskuil via bitcoin-dev schreef op zo 29-01-2017 om 11:37 [-0800]:
> > On Jan 29, 2017, at 11:15 AM, Tom Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > 
> >> On 1/28/2017 10:29 AM, Peter Todd via bitcoin-dev wrote:
> >> a world of nodes in large datacenters is a world where it's very easy
> >> to force the few Bitcoin nodes remaining to follow AML/KYC rules
> > 
> > If that's true, why haven't we already seen AML/KYC required of mining
> > pools?  That would be comparatively trivial.
> 
> It is true, there is no question. The fact that an attack does not appear to have occurred does not mean that the vulnerability exists. It is as you say a trivial exploit, which means it will happen when the economic incentive is great enough. Analogous attacks on other points of centralization are already well underway.

What on first sight seems trivial may be totally different when looking
deeper. People here seem to not realise that a lot of data centers (the
IAAS ones) just are just grouping the computers and provide remote
access. The client have full control over the machines. The center thus
just provides the hardware, the power and the internet access. They
typically don't inspect your internet traffic only reduce the speed if
you are going above certain threshold. Additionally there are countries
like Iceland that specifically make laws to not let the government get
power over data and network traffic in data centers.
Domestic ISP services typically want to prioritize traffic and thus have
most of the time network traffic deep packet inspection (DPI)
capabilities. These are thus much easier forced by government to filter
certain traffic. Additionally these companies often fall under
telecommunication laws also given government more control over them than
in a typical data center.

I host my Bitcoin node in a German datacenter and am sure it is more
censorship resistant that a node going through any American ISP.

greets,
Staf.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 230 bytes
Desc: This is a digitally signed message part
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170211/df91ff2d/attachment.sig>

From staf at stafverhaegen.be  Sat Feb 11 15:57:46 2017
From: staf at stafverhaegen.be (Staf Verhaegen)
Date: Sat, 11 Feb 2017 16:57:46 +0100
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <CAAcC9yuzgKWGXxbZLM+21pvRZmYV+nDAMBWMpZXCg6RUYHXRWQ@mail.gmail.com>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
	<CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
	<CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
	<CAAcC9yuzgKWGXxbZLM+21pvRZmYV+nDAMBWMpZXCg6RUYHXRWQ@mail.gmail.com>
Message-ID: <1486828666.21100.115.camel@stafverhaegen.be>

Chris Priest via bitcoin-dev schreef op vr 03-02-2017 om 16:57 [-0800]:
> Personally I think once the blocksize arguments are solved, there will
> be no more contentious changes for this voting system to deal with.
> What other contentious issues have come up in the past 3 years or so
> that wasn't blocksize/scaling related? Do other protocols like TCP/IP
> and the HTTP protocol have developers arguing every day over issues no
> one can agree on?

Yes, DRM for example.
Staf.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 230 bytes
Desc: This is a digitally signed message part
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170211/96521608/attachment.sig>

From sergio.d.lerner at gmail.com  Sun Feb 12 20:22:33 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Sun, 12 Feb 2017 17:22:33 -0300
Subject: [bitcoin-dev] Proof of Nodework (PoNW) - a method to
 trustlessly reward nodes for storing and verifying the blockchain
In-Reply-To: <BL2PR03MB435AA04A0AB8AC0E7781CA7EE430@BL2PR03MB435.namprd03.prod.outlook.com>
References: <BL2PR03MB435AA04A0AB8AC0E7781CA7EE430@BL2PR03MB435.namprd03.prod.outlook.com>
Message-ID: <CAKzdR-qvDcUMcFDyS_w5XvuYi+zBzH_z9rp=EqBkN3o+MyuubA@mail.gmail.com>

Hi John,
 RSK platform (a Bitcoin sidechain) is already prepared to do something
similar to this, although very efficiently. We set apart 1% of the block
reward to automatically reward full nodes.

We have two systems being evaluated: the first is based on PoUBS (Proof of
Unique Blockchain Storage) which uses asymmetric-time operations to encode
the blockchain based on each user public key such that decoding is fast,
but encoding is slow. The second is more traditional proof of
retrievability, but it requires some ASIC-resistance assumptions.

In both cases, a special smart contract is being called at every block that
creates periodic challenges. Every full node that wants to participate can
submits a commitment to the Merkle hash root of a pseudo-random sequence of
encoded blocks. Then the smart contract chooses random elements from the
committed dataset, and each full node has a period to submit Merkle-proofs
that such random elements belong to the commitment.

To prevent blockchain bloat we designed a very cool new type of transaction
payload: Ephemeral Payload. Ephemeral payload is a payload in a transaction
that gets discarded after N blocks if no smart contract does reference it.
If is does, it's solidified forever in the blockchain.
Then there is a challenge phase where other full nodes can inform the smart
contract if they find an error in the submitted responses. Then the smart
contract ONLY evaluates the responses which have been questioned by users.

This way the smart contract does very little computation (only when a user
misbehaves) and the blockchain normally does not store any proof forever
(only the ones created by misbehaving users).

Because RSK/Rootstock has a very short block interval (10 seconds), all
this happens very quickly and does not require much computation.

Best regards,
 Sergio Lerner
 Chief Scientist RSK (aka Roostock)


On Tue, Feb 7, 2017 at 8:27 AM, John Hardy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Proof of Nodework (PoNW) is a way to reward individual nodes for keeping a
> full copy of and verifying the blockchain.
>
> Hopefully they also do useful ?traditional? node activities too like relay
> transactions and blocks, but there isn?t really any way I can think of to
> trustlessly verify this also.
>
> PoNW would require a new separate area of block space, a nodeblock, purely
> concerned with administering the system. A nodeblock is committed to a
> block as with SegWit. A recent history of nodeblocks needs to be stored by
> nodes, however the data eventually becomes obsolete and so does not need to
> be retained forever.
>
> In order to prevent Sybil, a node must register an Bitcoin address by
> submitting an addNode transaction - along with a security deposit to
> prevent cheating.
>
> This transaction will be stored in the nodeblock. Once a node can see that
> its addNode transaction has been added it can begin the PoNW process. The
> node?s registered address will be hashed with the block header of the block
> it wants to work on. This will determine exactly where within the
> blockchain to begin the PoNW.
>
> The PoNW method could be as simple as creating a Merkle tree from the
> randomly generated point on the blockchain, though a method that is
> CPU/Memory heavy and less likely to be replaced by dedicated hardware like
> ASICs would be better. This process could not begin until the most recent
> block has been fully verified, and while being carried out should still
> enable normal relay activities to proceed as normal, since it shouldn?t tie
> up network at all. The data processed should also be mixed with data from
> the latest block so that it cannot be computed in advance.
>
> A node can do as much PoNW for a block as it likes. Once finished it will
> then create a nodeWorkComplete transaction for that block with its final
> proof value, add how much ?work? it did - and create a couple of assertions
> about what it processed (such as there were x number of pieces of data
> matching a particular value during calculating). These assertions can be
> accurate or inaccurate.
>
> The system will run in epochs. During each epoch of say 2016 blocks, there
> will be an extended window for PoNW transactions to be added to nodeblocks
> to limit minor censorship.
>
> The random hash generated from a node?s address and blockhash will also be
> used to determine nodeWorkComplete transactions from a previous block that
> the node must also verify, and correctly calculate whether the assertions
> it made were true or false. The average PoNW that a node performed in its
> previous x nodeblocks will be used to determine the target PoNW for the
> node to verify - and this will randomly be a large number of smaller PoNW
> transactions, or a smaller number of large PoNW. This process will be
> deterministic based on that block and address hash. All the data will be
> put together in a transaction and then signed by the node addresses private
> key.
>
> If a nodeWorkComplete transaction contains any incorrect information in an
> attempt to cheat the validation process a challenge transaction can be
> created. This begins a refereeing process where other nodes check the
> challenge and vote whether it is to be upheld or not. The losing node is
> punished by losing their accrued PoNW for that epoch and a percentage of
> their security deposit.
>
> Nodes will also be punished if they broadcast more than one signed
> transaction per block.
>
> In order to prevent nodes from having multiple keys registered - which
> would enable them choose to perform PoNW on a subset of the data that they
> hold - the share of reward that the node gets will be multiplied based on
> the number of blocks within an epoch that the node performs PoNW on. The
> share of reward is limited based on how much security deposit has been
> staked. The higher the PoNW the higher the deposit needed in order to claim
> their full allocation of any reward.
>
> At the end of an epoch, with a wait period for any delayed or censored
> transactions or challenges to be included and settled up, the process of
> calculating the reward each node is due can begin. This will then be then
> paid in a regular block, and means for all the data involved in PoNW, the
> only permanent mark it makes on the main blockchain is for a transaction
> that pays all addresses their share of the reward at the end of epoch. Any
> miner who creates a block without correctly calculating and paying the due
> reward will have mined an invalid block and be orphaned.
>
> The question of where and how much the reward comes from is a different
> one. It could come from the existing miner reward, or a special new tx
> donation fee for nodes. If there was some way for users to ?donate? to the
> reward pool for nodes this would increase the incentive for additional
> nodes to participate on the network in the event of centralisation.
>
> This is a relatively effective way to create a reward for all nodes
> participating on a network. I?d be keen to field any questions or critiques.
>
> Thanks,
>
>
> John Hardy
>
> john at seebitcoin.com
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170212/71eb46b5/attachment.html>

From eric at voskuil.org  Mon Feb 13 05:18:41 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 12 Feb 2017 21:18:41 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
Message-ID: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>

The BIP151 proposal states:

> This proposal is backward compatible. Non-supporting peers will ignore
the encinit messages.

This statement is incorrect. Sending content that existing nodes do not
expect is clearly an incompatibility. An implementation that ignores
invalid content leaves itself wide open to DOS attacks. The version
handshake must be complete before the protocol level can be determined.
While it may be desirable for this change to precede the version
handshake it cannot be described as backward compatible.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170212/6275a29b/attachment.sig>

From pieter.wuille at gmail.com  Mon Feb 13 08:47:38 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 13 Feb 2017 00:47:38 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
Message-ID: <CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>

On Feb 12, 2017 23:58, "Eric Voskuil via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

The BIP151 proposal states:

> This proposal is backward compatible. Non-supporting peers will ignore
the encinit messages.

This statement is incorrect. Sending content that existing nodes do not
expect is clearly an incompatibility. An implementation that ignores
invalid content leaves itself wide open to DOS attacks. The version
handshake must be complete before the protocol level can be determined.
While it may be desirable for this change to precede the version
handshake it cannot be described as backward compatible.


The worst possible effect of ignoring unknown messages is a waste of
downstream bandwidth. The same is already possible by being sent addr
messages.

Using the protocol level requires a strict linear progression of (allowed)
network protocol features, which I expect to become harder and harder to
maintain.

Using otherwise ignored messages for determining optional features is
elegant, simple and opens no new attack vectors. I think it's very much
preferable over continued increments of the protocol version.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/78920df7/attachment-0001.html>

From eric at voskuil.org  Mon Feb 13 09:36:21 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 13 Feb 2017 01:36:21 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
Message-ID: <dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>

On 02/13/2017 12:47 AM, Pieter Wuille wrote:
> On Feb 12, 2017 23:58, "Eric Voskuil via bitcoin-dev"
> <bitcoin-dev at lists.linuxfoundation.org wrote:
> 
>     The BIP151 proposal states:
> 
>     > This proposal is backward compatible. Non-supporting peers will ignore
>     the encinit messages.
> 
>     This statement is incorrect. Sending content that existing nodes do not
>     expect is clearly an incompatibility. An implementation that ignores
>     invalid content leaves itself wide open to DOS attacks. The version
>     handshake must be complete before the protocol level can be determined.
>     While it may be desirable for this change to precede the version
>     handshake it cannot be described as backward compatible.
> 
> The worst possible effect of ignoring unknown messages is a waste of
> downstream bandwidth. The same is already possible by being sent addr
> messages.
> 
> Using the protocol level requires a strict linear progression of
> (allowed) network protocol features, which I expect to become harder and
> harder to maintain.
> 
> Using otherwise ignored messages for determining optional features is
> elegant, simple and opens no new attack vectors. I think it's very much
> preferable over continued increments of the protocol version.

As I said, it *may* be desirable, but it is *not* backward compatible,
and you do not actually dispute that above.

There are other control messages that qualify as "optional messages" but
these are only sent if the peer is at a version to expect them -
explicit in their BIPs. All adopted BIPs to date have followed this
pattern. This is not the same and it is not helpful to imply that it is
just following that pattern.

As for DOS, waste of bandwidth is not something to be ignored. If a peer
is flooding a node with addr message the node can manage it because it
understands the semantics of addr messages. If a node is required to
allow any message that it cannot understand it has no recourse. It
cannot determine whether it is under attack or if the behavior is
correct and for proper continued operation must be ignored.

This approach breaks any implementation that validates traffic, which is
clearly correct behavior given the existence of the version handshake.
Your comments make it clear that this is a *change* in network behavior
- essentially abandoning the version handshake. Whether is is harder to
maintain is irrelevant to the question of whether it is a break with
existing protocol.

If you intend for the network to abandon the version handshake and/or
promote changes that break it I propose that you write up this new
behavior as a BIP and solicit community feedback. There are a lot of
devices connected to the network and it would be irresponsible to break
something as fundamental as the P2P protocol handshake because you have
a feeling it's going to be hard to maintain.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/21d7d014/attachment.sig>

From dev at jonasschnelli.ch  Mon Feb 13 10:07:12 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Mon, 13 Feb 2017 11:07:12 +0100
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
Message-ID: <ff7c24ba-7c70-efaf-a319-b1aebfd8a3bd@jonasschnelli.ch>


> All adopted BIPs to date have followed this
> pattern. This is not the same and it is not helpful to imply that it is
> just following that pattern.

Look at feefilter BIP 133
(https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki#backward-compatibility)
or sendheaders BIP130
(https://github.com/bitcoin/bips/blob/master/bip-0130.mediawiki#backward-compatibility)
Isn't it the same there?
Once BIP151 is implemented, it would make sense to bump the protocol
version, but this needs to be done once this has been
implemented/deployed. Or do I make a mistake somewhere?
>
> As for DOS, waste of bandwidth is not something to be ignored. If a peer
> is flooding a node with addr message the node can manage it because it
> understands the semantics of addr messages. If a node is required to
> allow any message that it cannot understand it has no recourse. It
> cannot determine whether it is under attack or if the behavior is
> correct and for proper continued operation must be ignored.
How do you threat any other not known message types? Any peer can send
you any type of message anytime. Why would your implementation how you
threat unknown messages be different for messages specified in BIP151?


</jonas>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/310f938e/attachment.sig>

From lf-lists at mattcorallo.com  Mon Feb 13 10:16:13 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 13 Feb 2017 10:16:13 +0000
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
Message-ID: <424C9E40-0B90-46A6-9C5E-30AE3E84E119@mattcorallo.com>

For the reasons Pieter listed, an explicit part of our version handshake and protocol negotiation is the exchange of otherwise-ignored messages to set up optional features.

Peers that do not support this ignore such messages, just as if they had indicated they wouldn't support it, see, eg BIP 152's handshake. Not sure why you consider this backwards incompatible, as I would say it's pretty clearly allowing old nodes to communicate just fine.

On February 13, 2017 10:36:21 AM GMT+01:00, Eric Voskuil via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>On 02/13/2017 12:47 AM, Pieter Wuille wrote:
>> On Feb 12, 2017 23:58, "Eric Voskuil via bitcoin-dev"
>> <bitcoin-dev at lists.linuxfoundation.org wrote:
>> 
>>     The BIP151 proposal states:
>> 
>>     > This proposal is backward compatible. Non-supporting peers will
>ignore
>>     the encinit messages.
>> 
>>     This statement is incorrect. Sending content that existing nodes
>do not
>>     expect is clearly an incompatibility. An implementation that
>ignores
>>     invalid content leaves itself wide open to DOS attacks. The
>version
>>     handshake must be complete before the protocol level can be
>determined.
>>     While it may be desirable for this change to precede the version
>>     handshake it cannot be described as backward compatible.
>> 
>> The worst possible effect of ignoring unknown messages is a waste of
>> downstream bandwidth. The same is already possible by being sent addr
>> messages.
>> 
>> Using the protocol level requires a strict linear progression of
>> (allowed) network protocol features, which I expect to become harder
>and
>> harder to maintain.
>> 
>> Using otherwise ignored messages for determining optional features is
>> elegant, simple and opens no new attack vectors. I think it's very
>much
>> preferable over continued increments of the protocol version.
>
>As I said, it *may* be desirable, but it is *not* backward compatible,
>and you do not actually dispute that above.
>
>There are other control messages that qualify as "optional messages"
>but
>these are only sent if the peer is at a version to expect them -
>explicit in their BIPs. All adopted BIPs to date have followed this
>pattern. This is not the same and it is not helpful to imply that it is
>just following that pattern.
>
>As for DOS, waste of bandwidth is not something to be ignored. If a
>peer
>is flooding a node with addr message the node can manage it because it
>understands the semantics of addr messages. If a node is required to
>allow any message that it cannot understand it has no recourse. It
>cannot determine whether it is under attack or if the behavior is
>correct and for proper continued operation must be ignored.
>
>This approach breaks any implementation that validates traffic, which
>is
>clearly correct behavior given the existence of the version handshake.
>Your comments make it clear that this is a *change* in network behavior
>- essentially abandoning the version handshake. Whether is is harder to
>maintain is irrelevant to the question of whether it is a break with
>existing protocol.
>
>If you intend for the network to abandon the version handshake and/or
>promote changes that break it I propose that you write up this new
>behavior as a BIP and solicit community feedback. There are a lot of
>devices connected to the network and it would be irresponsible to break
>something as fundamental as the P2P protocol handshake because you have
>a feeling it's going to be hard to maintain.
>
>e

From lf-lists at mattcorallo.com  Mon Feb 13 11:11:11 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 13 Feb 2017 11:11:11 +0000
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <9ca02a65-23df-5eb4-f9bd-7e05b54ec4ea@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<424C9E40-0B90-46A6-9C5E-30AE3E84E119@mattcorallo.com>
	<9ca02a65-23df-5eb4-f9bd-7e05b54ec4ea@voskuil.org>
Message-ID: <9ECDD902-1D2C-4500-8FC2-4DADF46E4318@mattcorallo.com>

I believe many, if not all, of those messages are sent irrespective of version number.

In any case, I fail to see how adding any additional messages which are ignored by old peers amounts to a lack of backward compatibility.

On February 13, 2017 11:54:23 AM GMT+01:00, Eric Voskuil <eric at voskuil.org> wrote:
>On 02/13/2017 02:16 AM, Matt Corallo wrote:
>> For the reasons Pieter listed, an explicit part of our version
>handshake and protocol negotiation is the exchange of otherwise-ignored
>messages to set up optional features.
>
>Only if the peer is at the protocol level that allows the message:
>
>compact blocks:
>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L217-L242
>
>fee filter:
>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L211-L216
>
>send headers:
>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L204-L210
>
>filters:
>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L170-L196
>
>> Peers that do not support this ignore such messages, just as if they
>had indicated they wouldn't support it, see, eg BIP 152's handshake.
>Not
>sure why you consider this backwards incompatible, as I would say it's
>pretty clearly allowing old nodes to communicate just fine.
>
>No, it is not the same as BIP152. Control messages apart from BIP151
>are
>not sent until *after* the version is negotiated.
>
>I assume that BIP151 is different in this manner because it has a
>desire
>to negotiate encryption before any other communications, including
>version.
>
>e

From dev at jonasschnelli.ch  Mon Feb 13 11:14:01 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Mon, 13 Feb 2017 12:14:01 +0100
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <638deacd-c117-f1a7-10de-a7e36a47c3c7@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<ff7c24ba-7c70-efaf-a319-b1aebfd8a3bd@jonasschnelli.ch>
	<638deacd-c117-f1a7-10de-a7e36a47c3c7@voskuil.org>
Message-ID: <e153823d-e38e-b4b6-01d5-b9d981381e01@jonasschnelli.ch>


>> Look at feefilter BIP 133
>> (https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki#backward-compatibility)
>> or sendheaders BIP130
>> (https://github.com/bitcoin/bips/blob/master/bip-0130.mediawiki#backward-compatibility)
>> Isn't it the same there?
> No. This is what I was referring to. These messages are enabled by
> protocol version. If they are received by a node below the version at
> which they are activated, they are unknown messages, implying an invalid
> peer. The above messages cannot be sent until *after* the version is
> negotiated. BIP151 violates this rule by allowing the new control
> message to be sent *before* the version handshake.
This indeed is not ideal for compatibility checks, but increases security.
I could not find a protocol specification that said communication must
be terminated when messages are transmitted before the version handshake
has been done. I mostly looked into Bitcoin-Cores implementation (which
means also into BitcoinXT/UT, where this is allowed).

Also. BIP151 clearly says that the requesting peer needs to initiate the
encryption (encinit).
In case of light clients not supporting BIP151 connecting to peers
supporting BIP151, there should never be transmission of new message
types specified in BIP151.
>
>> Once BIP151 is implemented, it would make sense to bump the protocol
>> version, but this needs to be done once this has been
>> implemented/deployed.
> There are already nodes out there breaking connections based on the BIP.
It could very likely be possible that the initial responding peer tries
to initiate a encryption session which would mean that BIP151 was not
implemented correctly.
Correct me if I'm wrong please.
>
>> Or do I make a mistake somewhere?
> Yes, the ordering of the messages. New messages can only be added after
> the handshake negotiates the higher version. Otherwise the handshake is
> both irrelevant (as Pieter is implying) and broken (for all existing
> protocol versions).
I could not find evidence of the protocol specification that would
forbid (=terminate connection) such messages and I think allowing
unknown-messages before the version handshake makes the protocol flexible.

Are there any reasons we should drop peers if they send us unknown, but
correctly formatted p2p packages (magic, checksum, etc.) before the
version handshake, ... but not drop them if we have received unknown
messages after the version handshake?

I can't see that a such spec. would reduce the DOS attack vector?

>
>>> As for DOS, waste of bandwidth is not something to be ignored. If a peer
>>> is flooding a node with addr message the node can manage it because it
>>> understands the semantics of addr messages. If a node is required to
>>> allow any message that it cannot understand it has no recourse. It
>>> cannot determine whether it is under attack or if the behavior is
>>> correct and for proper continued operation must be ignored.
>> How do you threat any other not known message types?
> You may be more familiar with non-validating peers. If a message type is
> not known it is an invalid message and the peer is immediately dropped.
> We started seeing early drops in handshakes with bcoin nodes because of
> this issue.
If this had happened, it's very likely because the responding peer tried
to initiate a encryption session which is against BIP151 specs.
>
>> Any peer can send you any type of message anytime.
> Sure, a peer can do what it wants. It can send photos. But I'm not sure
> what makes you think it would be correct to maintain the connection when
> an *invalid* message is received.
Check:
https://github.com/bitcoin/bitcoin/blob/a06ede9a138d0fb86b0de17c42b936d9fe6e2158/src/net_processing.cpp#L2595
I think it was a wise implementation decision to allow unknown (not
invalid) messages.
This had allowed us to deploy stuff like compact blocks, feefilter, etc.
without breaking backward compatibility.
IMO, without a such flexibility, the deployment complexity would be
irresponsible high without really solving the DOS problem.
>
>> Why would your implementation how you threat unknown messages be
> different for messages specified in BIP151?
>
> Because it properly validates the protocol.
For feefilter or compact block or sendheaders?
You can't link a (unimplemented) specification (improvement process) to
a protocol version before deployment. Or can you?
Once it has been widely deployed, we should set a protocol minversion
for BIP151, right.

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/ec9da1fb/attachment-0001.sig>

From eric at voskuil.org  Mon Feb 13 10:30:14 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 13 Feb 2017 02:30:14 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <ff7c24ba-7c70-efaf-a319-b1aebfd8a3bd@jonasschnelli.ch>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<ff7c24ba-7c70-efaf-a319-b1aebfd8a3bd@jonasschnelli.ch>
Message-ID: <638deacd-c117-f1a7-10de-a7e36a47c3c7@voskuil.org>

On 02/13/2017 02:07 AM, Jonas Schnelli via bitcoin-dev wrote:
>> All adopted BIPs to date have followed this
>> pattern. This is not the same and it is not helpful to imply that it is
>> just following that pattern.
> 
> Look at feefilter BIP 133
> (https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki#backward-compatibility)
> or sendheaders BIP130
> (https://github.com/bitcoin/bips/blob/master/bip-0130.mediawiki#backward-compatibility)
> Isn't it the same there?

No. This is what I was referring to. These messages are enabled by
protocol version. If they are received by a node below the version at
which they are activated, they are unknown messages, implying an invalid
peer. The above messages cannot be sent until *after* the version is
negotiated. BIP151 violates this rule by allowing the new control
message to be sent *before* the version handshake.

> Once BIP151 is implemented, it would make sense to bump the protocol
> version, but this needs to be done once this has been
> implemented/deployed.

There are already nodes out there breaking connections based on the BIP.

> Or do I make a mistake somewhere?

Yes, the ordering of the messages. New messages can only be added after
the handshake negotiates the higher version. Otherwise the handshake is
both irrelevant (as Pieter is implying) and broken (for all existing
protocol versions).

>> As for DOS, waste of bandwidth is not something to be ignored. If a peer
>> is flooding a node with addr message the node can manage it because it
>> understands the semantics of addr messages. If a node is required to
>> allow any message that it cannot understand it has no recourse. It
>> cannot determine whether it is under attack or if the behavior is
>> correct and for proper continued operation must be ignored.

> How do you threat any other not known message types?

You may be more familiar with non-validating peers. If a message type is
not known it is an invalid message and the peer is immediately dropped.
We started seeing early drops in handshakes with bcoin nodes because of
this issue.

> Any peer can send you any type of message anytime.

Sure, a peer can do what it wants. It can send photos. But I'm not sure
what makes you think it would be correct to maintain the connection when
an *invalid* message is received.

> Why would your implementation how you threat unknown messages be
different for messages specified in BIP151?

Because it properly validates the protocol.

More than that it supports a configurable protocol range. So by setting
the min protocol (below which the node won't connect) and the max
protocol (at which it desires to connect) we can observe the behavior of
the network at any protocol levels (currently between 31402 and 70013).
This is very helpful for a development stack as it allows one to easily
test against each protocol level that one wishes to support.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/7fd2b845/attachment.sig>

From eric at voskuil.org  Mon Feb 13 10:54:23 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 13 Feb 2017 02:54:23 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <424C9E40-0B90-46A6-9C5E-30AE3E84E119@mattcorallo.com>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<424C9E40-0B90-46A6-9C5E-30AE3E84E119@mattcorallo.com>
Message-ID: <9ca02a65-23df-5eb4-f9bd-7e05b54ec4ea@voskuil.org>

On 02/13/2017 02:16 AM, Matt Corallo wrote:
> For the reasons Pieter listed, an explicit part of our version
handshake and protocol negotiation is the exchange of otherwise-ignored
messages to set up optional features.

Only if the peer is at the protocol level that allows the message:

compact blocks:

https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L217-L242

fee filter:

https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L211-L216

send headers:

https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L204-L210

filters:

https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L170-L196

> Peers that do not support this ignore such messages, just as if they
had indicated they wouldn't support it, see, eg BIP 152's handshake. Not
sure why you consider this backwards incompatible, as I would say it's
pretty clearly allowing old nodes to communicate just fine.

No, it is not the same as BIP152. Control messages apart from BIP151 are
not sent until *after* the version is negotiated.

I assume that BIP151 is different in this manner because it has a desire
to negotiate encryption before any other communications, including version.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/db42ecc6/attachment.sig>

From eric at voskuil.org  Mon Feb 13 11:17:11 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 13 Feb 2017 03:17:11 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <9ECDD902-1D2C-4500-8FC2-4DADF46E4318@mattcorallo.com>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<424C9E40-0B90-46A6-9C5E-30AE3E84E119@mattcorallo.com>
	<9ca02a65-23df-5eb4-f9bd-7e05b54ec4ea@voskuil.org>
	<9ECDD902-1D2C-4500-8FC2-4DADF46E4318@mattcorallo.com>
Message-ID: <0983c823-e517-2821-1398-24bc7467b364@voskuil.org>

On 02/13/2017 03:11 AM, Matt Corallo wrote:
> I believe many, if not all, of those messages are sent irrespective of version number.

In the interest of perfect clarity, see your code:

https://github.com/bitcoin/bitcoin/blob/master/src/net_processing.cpp#L1372-L1403

Inside of the VERACK handler (i.e. after the handshake) there is a peer
version test before sending SENDCMPCT (and SENDHEADERS).

I have no idea where the fee filter message is sent, if it is sent at
all. But I have *never* seen any control messages arrive before the
handshake is complete.

> In any case, I fail to see how adding any additional messages which
are ignored by old peers amounts to a lack of backward compatibility.

See preceding messages in this thread, I think it's pretty clearly
spelled out.

e

> On February 13, 2017 11:54:23 AM GMT+01:00, Eric Voskuil <eric at voskuil.org> wrote:
>> On 02/13/2017 02:16 AM, Matt Corallo wrote:
>>> For the reasons Pieter listed, an explicit part of our version
>> handshake and protocol negotiation is the exchange of otherwise-ignored
>> messages to set up optional features.
>>
>> Only if the peer is at the protocol level that allows the message:
>>
>> compact blocks:
>>
>> https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L217-L242
>>
>> fee filter:
>>
>> https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L211-L216
>>
>> send headers:
>>
>> https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L204-L210
>>
>> filters:
>>
>> https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L170-L196
>>
>>> Peers that do not support this ignore such messages, just as if they
>> had indicated they wouldn't support it, see, eg BIP 152's handshake.
>> Not
>> sure why you consider this backwards incompatible, as I would say it's
>> pretty clearly allowing old nodes to communicate just fine.
>>
>> No, it is not the same as BIP152. Control messages apart from BIP151
>> are
>> not sent until *after* the version is negotiated.
>>
>> I assume that BIP151 is different in this manner because it has a
>> desire
>> to negotiate encryption before any other communications, including
>> version.
>>
>> e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/58969eab/attachment.sig>

From hampus.sjoberg at gmail.com  Mon Feb 13 11:21:44 2017
From: hampus.sjoberg at gmail.com (=?UTF-8?Q?Hampus_Sj=C3=B6berg?=)
Date: Mon, 13 Feb 2017 12:21:44 +0100
Subject: [bitcoin-dev] BIP - 'Block75' - New algorithm
In-Reply-To: <201701022119.11115.luke@dashjr.org>
References: <CAGCNRJoN7u3yvzitH2KSmVty-p0tX9jxWLHPb8uO5CPZmxmoRg@mail.gmail.com>
	<CAGCNRJp71NCxQ3jk4hu-kXF94RiqfeD=AVnxR37TrJ7bDG310w@mail.gmail.com>
	<1944321.hguq3JoYe1@cherry> <201701022119.11115.luke@dashjr.org>
Message-ID: <CAFMkqK_hKFZc0bnO17ONpM1v5D2nDgu5-u5MTByJF0xEYZ3tAQ@mail.gmail.com>

> It gives miners complete control over the limit. They can make blocks of
any size (within the current limit), thus triggering the conditions by
which your proposal would raise the limit further.

There might be a long term incentive to keep increasing the blocksize, to
further centralize the network (and kick smaller miners out), but it comes
with the cost of losing out on transaction fees.
Miners have always needed to plan for the short term, I see no rational
scenario where miners would spam their blocks with their own transactions
(or low fee transactions) to keep increasing the blocksize limit.

Hampus
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/f4a99243/attachment.html>

From john at seebitcoin.com  Mon Feb 13 11:58:09 2017
From: john at seebitcoin.com (John Hardy)
Date: Mon, 13 Feb 2017 11:58:09 +0000
Subject: [bitcoin-dev] Proof of Nodework (PoNW) - a method to
 trustlessly reward nodes for storing and verifying the blockchain
In-Reply-To: <CAKzdR-qvDcUMcFDyS_w5XvuYi+zBzH_z9rp=EqBkN3o+MyuubA@mail.gmail.com>
References: <BL2PR03MB435AA04A0AB8AC0E7781CA7EE430@BL2PR03MB435.namprd03.prod.outlook.com>,
	<CAKzdR-qvDcUMcFDyS_w5XvuYi+zBzH_z9rp=EqBkN3o+MyuubA@mail.gmail.com>
Message-ID: <BL2PR03MB4355F39BE003DBF200591EBEE590@BL2PR03MB435.namprd03.prod.outlook.com>

Hi Sergio,


Thanks for your response, interesting work, very excited for RSK.


I like the ephemeral payload, I suppose that aspect of my proposal could be described as ephemeral blockspace.


I'm curious about the challenge phase, what incentive do nodes to have to check other nodes' responses? Is any validation of responses mandatory, or does policing the system rely on altruism?


I also wondered how time-based responses are enforced? What prevents a miner censoring challenge responses so they do not get included in a block 'in time' - if  inclusion within a block is the mechanism used?


I saw your tweet on Lumino - sounds very promising. Would be keen to take a look at the paper if you're looking for any additional review at this stage.


Regards,


John Hardy


________________________________
From: Sergio Demian Lerner <sergio.d.lerner at gmail.com>
Sent: Sunday, February 12, 2017 8:22 PM
To: John Hardy; Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] Proof of Nodework (PoNW) - a method to trustlessly reward nodes for storing and verifying the blockchain

Hi John,
 RSK platform (a Bitcoin sidechain) is already prepared to do something similar to this, although very efficiently. We set apart 1% of the block reward to automatically reward full nodes.

We have two systems being evaluated: the first is based on PoUBS (Proof of Unique Blockchain Storage) which uses asymmetric-time operations to encode the blockchain based on each user public key such that decoding is fast, but encoding is slow. The second is more traditional proof of retrievability, but it requires some ASIC-resistance assumptions.

In both cases, a special smart contract is being called at every block that creates periodic challenges. Every full node that wants to participate can submits a commitment to the Merkle hash root of a pseudo-random sequence of encoded blocks. Then the smart contract chooses random elements from the committed dataset, and each full node has a period to submit Merkle-proofs that such random elements belong to the commitment.

To prevent blockchain bloat we designed a very cool new type of transaction payload: Ephemeral Payload. Ephemeral payload is a payload in a transaction that gets discarded after N blocks if no smart contract does reference it. If is does, it's solidified forever in the blockchain.
Then there is a challenge phase where other full nodes can inform the smart contract if they find an error in the submitted responses. Then the smart contract ONLY evaluates the responses which have been questioned by users.

This way the smart contract does very little computation (only when a user misbehaves) and the blockchain normally does not store any proof forever (only the ones created by misbehaving users).

Because RSK/Rootstock has a very short block interval (10 seconds), all this happens very quickly and does not require much computation.

Best regards,
 Sergio Lerner
 Chief Scientist RSK (aka Roostock)


On Tue, Feb 7, 2017 at 8:27 AM, John Hardy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:

Proof of Nodework (PoNW) is a way to reward individual nodes for keeping a full copy of and verifying the blockchain.


Hopefully they also do useful ?traditional? node activities too like relay transactions and blocks, but there isn?t really any way I can think of to trustlessly verify this also.


PoNW would require a new separate area of block space, a nodeblock, purely concerned with administering the system. A nodeblock is committed to a block as with SegWit. A recent history of nodeblocks needs to be stored by nodes, however the data eventually becomes obsolete and so does not need to be retained forever.


In order to prevent Sybil, a node must register an Bitcoin address by submitting an addNode transaction - along with a security deposit to prevent cheating.


This transaction will be stored in the nodeblock. Once a node can see that its addNode transaction has been added it can begin the PoNW process. The node?s registered address will be hashed with the block header of the block it wants to work on. This will determine exactly where within the blockchain to begin the PoNW.


The PoNW method could be as simple as creating a Merkle tree from the randomly generated point on the blockchain, though a method that is CPU/Memory heavy and less likely to be replaced by dedicated hardware like ASICs would be better. This process could not begin until the most recent block has been fully verified, and while being carried out should still enable normal relay activities to proceed as normal, since it shouldn?t tie up network at all. The data processed should also be mixed with data from the latest block so that it cannot be computed in advance.


A node can do as much PoNW for a block as it likes. Once finished it will then create a nodeWorkComplete transaction for that block with its final proof value, add how much ?work? it did - and create a couple of assertions about what it processed (such as there were x number of pieces of data matching a particular value during calculating). These assertions can be accurate or inaccurate.


The system will run in epochs. During each epoch of say 2016 blocks, there will be an extended window for PoNW transactions to be added to nodeblocks to limit minor censorship.


The random hash generated from a node?s address and blockhash will also be used to determine nodeWorkComplete transactions from a previous block that the node must also verify, and correctly calculate whether the assertions it made were true or false. The average PoNW that a node performed in its previous x nodeblocks will be used to determine the target PoNW for the node to verify - and this will randomly be a large number of smaller PoNW transactions, or a smaller number of large PoNW. This process will be deterministic based on that block and address hash. All the data will be put together in a transaction and then signed by the node addresses private key.


If a nodeWorkComplete transaction contains any incorrect information in an attempt to cheat the validation process a challenge transaction can be created. This begins a refereeing process where other nodes check the challenge and vote whether it is to be upheld or not. The losing node is punished by losing their accrued PoNW for that epoch and a percentage of their security deposit.


Nodes will also be punished if they broadcast more than one signed transaction per block.


In order to prevent nodes from having multiple keys registered - which would enable them choose to perform PoNW on a subset of the data that they hold - the share of reward that the node gets will be multiplied based on the number of blocks within an epoch that the node performs PoNW on. The share of reward is limited based on how much security deposit has been staked. The higher the PoNW the higher the deposit needed in order to claim their full allocation of any reward.


At the end of an epoch, with a wait period for any delayed or censored transactions or challenges to be included and settled up, the process of calculating the reward each node is due can begin. This will then be then paid in a regular block, and means for all the data involved in PoNW, the only permanent mark it makes on the main blockchain is for a transaction that pays all addresses their share of the reward at the end of epoch. Any miner who creates a block without correctly calculating and paying the due reward will have mined an invalid block and be orphaned.


The question of where and how much the reward comes from is a different one. It could come from the existing miner reward, or a special new tx donation fee for nodes. If there was some way for users to ?donate? to the reward pool for nodes this would increase the incentive for additional nodes to participate on the network in the event of centralisation.


This is a relatively effective way to create a reward for all nodes participating on a network. I?d be keen to field any questions or critiques.

Thanks,


John Hardy

john at seebitcoin.com<mailto:john at seebitcoin.com>

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/1173c865/attachment.html>

From lf-lists at mattcorallo.com  Mon Feb 13 13:04:15 2017
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 13 Feb 2017 13:04:15 +0000
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <0983c823-e517-2821-1398-24bc7467b364@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<424C9E40-0B90-46A6-9C5E-30AE3E84E119@mattcorallo.com>
	<9ca02a65-23df-5eb4-f9bd-7e05b54ec4ea@voskuil.org>
	<9ECDD902-1D2C-4500-8FC2-4DADF46E4318@mattcorallo.com>
	<0983c823-e517-2821-1398-24bc7467b364@voskuil.org>
Message-ID: <D863B756-565E-46A2-9731-2B8133653823@mattcorallo.com>

Sorry, I'm still missing it...
So your claim is that a) ignoring incoming messages of a type you do not recognize is bad, and thus b) we should be disconnecting/banning peers which send us messages we do not recognize (can you spell out why? Anyone is free to send your host address messages/transactions they are generating/etc/etc, we don't ban nodes for such messages, as that would be crazy - why should we ban a peer for sending us an extra 50 bytes which we ignore?), and thus c) this would be backwards incompatible with software which does not currently exist?

Usually "backwards incompatible" refers to breaking existing software, not breaking theoretical software. Note that, last I heard, BIP 151 is still a draft, if such software actually exists we can discuss changing it, but there are real wins in sending these messages before VERSION.

On February 13, 2017 12:17:11 PM GMT+01:00, Eric Voskuil <eric at voskuil.org> wrote:
>On 02/13/2017 03:11 AM, Matt Corallo wrote:
>> I believe many, if not all, of those messages are sent irrespective
>of version number.
>
>In the interest of perfect clarity, see your code:
>
>https://github.com/bitcoin/bitcoin/blob/master/src/net_processing.cpp#L1372-L1403
>
>Inside of the VERACK handler (i.e. after the handshake) there is a peer
>version test before sending SENDCMPCT (and SENDHEADERS).
>
>I have no idea where the fee filter message is sent, if it is sent at
>all. But I have *never* seen any control messages arrive before the
>handshake is complete.
>
>> In any case, I fail to see how adding any additional messages which
>are ignored by old peers amounts to a lack of backward compatibility.
>
>See preceding messages in this thread, I think it's pretty clearly
>spelled out.
>
>e
>
>> On February 13, 2017 11:54:23 AM GMT+01:00, Eric Voskuil
><eric at voskuil.org> wrote:
>>> On 02/13/2017 02:16 AM, Matt Corallo wrote:
>>>> For the reasons Pieter listed, an explicit part of our version
>>> handshake and protocol negotiation is the exchange of
>otherwise-ignored
>>> messages to set up optional features.
>>>
>>> Only if the peer is at the protocol level that allows the message:
>>>
>>> compact blocks:
>>>
>>>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L217-L242
>>>
>>> fee filter:
>>>
>>>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L211-L216
>>>
>>> send headers:
>>>
>>>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L204-L210
>>>
>>> filters:
>>>
>>>
>https://github.com/bitcoin/bitcoin/blob/master/src/protocol.h#L170-L196
>>>
>>>> Peers that do not support this ignore such messages, just as if
>they
>>> had indicated they wouldn't support it, see, eg BIP 152's handshake.
>>> Not
>>> sure why you consider this backwards incompatible, as I would say
>it's
>>> pretty clearly allowing old nodes to communicate just fine.
>>>
>>> No, it is not the same as BIP152. Control messages apart from BIP151
>>> are
>>> not sent until *after* the version is negotiated.
>>>
>>> I assume that BIP151 is different in this manner because it has a
>>> desire
>>> to negotiate encryption before any other communications, including
>>> version.
>>>
>>> e

From sergio.d.lerner at gmail.com  Mon Feb 13 14:48:24 2017
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Mon, 13 Feb 2017 11:48:24 -0300
Subject: [bitcoin-dev] Proof of Nodework (PoNW) - a method to
 trustlessly reward nodes for storing and verifying the blockchain
In-Reply-To: <BL2PR03MB4355F39BE003DBF200591EBEE590@BL2PR03MB435.namprd03.prod.outlook.com>
References: <BL2PR03MB435AA04A0AB8AC0E7781CA7EE430@BL2PR03MB435.namprd03.prod.outlook.com>
	<CAKzdR-qvDcUMcFDyS_w5XvuYi+zBzH_z9rp=EqBkN3o+MyuubA@mail.gmail.com>
	<BL2PR03MB4355F39BE003DBF200591EBEE590@BL2PR03MB435.namprd03.prod.outlook.com>
Message-ID: <CAKzdR-p25HXQty_o0y+rS2dBz568tCjyW9kvAoBJxJuii8k9eA@mail.gmail.com>

On Mon, Feb 13, 2017 at 8:58 AM, John Hardy <john at seebitcoin.com> wrote:

> Hi Sergio,
>
>
> Thanks for your response, interesting work, very excited for RSK.
>
>
> I like the ephemeral payload, I suppose that aspect of my proposal could
> be described as ephemeral blockspace.
>
>
> I'm curious about the challenge phase, what incentive do nodes to have to
> check other nodes' responses?
>
The reward is split between all full nodes. Therefore each full node has an
incentive to check at least some other full nodes responses because there
is a competition for the full node reward. At the end, each full node
response will be checked by more than other node with high probability.
Also each full node does a small pre-deposit, that is consumed if the node
cheats.

Is any validation of responses mandatory, or does policing the system rely
> on altruism?
>
>
> As previously said,  validation is not mandatory.

> I also wondered how time-based responses are enforced? What prevents a
> miner censoring challenge responses so they do not get included in a block
> 'in time' - if  inclusion within a block is the mechanism used?
>
There is not many defenses against censorship but try to hide your identity
until the end of the protocol. But if somebody knows that your transactions
belong to you, then there is little defense. We just wait more than a
single block for the commitments, so several miners must collude in order
to censor a transaction.

>
> I saw your tweet on Lumino - sounds very promising. Would be keen to take
> a look at the paper if you're looking for any additional review at this
> stage.
>
I'm keeping it private against all my desire because I want it to be
reviewed before I publish it. Credibility is very easily lost.
The same idea (Ephemeral Data) has been used to design the Lumino Network.

>
> Regards,
>
>
> John Hardy
>
>
> ------------------------------
> *From:* Sergio Demian Lerner <sergio.d.lerner at gmail.com>
> *Sent:* Sunday, February 12, 2017 8:22 PM
> *To:* John Hardy; Bitcoin Protocol Discussion
> *Subject:* Re: [bitcoin-dev] Proof of Nodework (PoNW) - a method to
> trustlessly reward nodes for storing and verifying the blockchain
>
> Hi John,
>  RSK platform (a Bitcoin sidechain) is already prepared to do something
> similar to this, although very efficiently. We set apart 1% of the block
> reward to automatically reward full nodes.
>
> We have two systems being evaluated: the first is based on PoUBS (Proof of
> Unique Blockchain Storage) which uses asymmetric-time operations to encode
> the blockchain based on each user public key such that decoding is fast,
> but encoding is slow. The second is more traditional proof of
> retrievability, but it requires some ASIC-resistance assumptions.
>
> In both cases, a special smart contract is being called at every block
> that creates periodic challenges. Every full node that wants to participate
> can submits a commitment to the Merkle hash root of a pseudo-random
> sequence of encoded blocks. Then the smart contract chooses random elements
> from the committed dataset, and each full node has a period to submit
> Merkle-proofs that such random elements belong to the commitment.
>
> To prevent blockchain bloat we designed a very cool new type of
> transaction payload: Ephemeral Payload. Ephemeral payload is a payload in a
> transaction that gets discarded after N blocks if no smart contract does
> reference it. If is does, it's solidified forever in the blockchain.
> Then there is a challenge phase where other full nodes can inform the
> smart contract if they find an error in the submitted responses. Then the
> smart contract ONLY evaluates the responses which have been questioned by
> users.
>
> This way the smart contract does very little computation (only when a user
> misbehaves) and the blockchain normally does not store any proof forever
> (only the ones created by misbehaving users).
>
> Because RSK/Rootstock has a very short block interval (10 seconds), all
> this happens very quickly and does not require much computation.
>
> Best regards,
>  Sergio Lerner
>  Chief Scientist RSK (aka Roostock)
>
>
> On Tue, Feb 7, 2017 at 8:27 AM, John Hardy via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Proof of Nodework (PoNW) is a way to reward individual nodes for keeping
>> a full copy of and verifying the blockchain.
>>
>> Hopefully they also do useful ?traditional? node activities too like
>> relay transactions and blocks, but there isn?t really any way I can think
>> of to trustlessly verify this also.
>>
>> PoNW would require a new separate area of block space, a nodeblock,
>> purely concerned with administering the system. A nodeblock is committed to
>> a block as with SegWit. A recent history of nodeblocks needs to be stored
>> by nodes, however the data eventually becomes obsolete and so does not need
>> to be retained forever.
>>
>> In order to prevent Sybil, a node must register an Bitcoin address by
>> submitting an addNode transaction - along with a security deposit to
>> prevent cheating.
>>
>> This transaction will be stored in the nodeblock. Once a node can see
>> that its addNode transaction has been added it can begin the PoNW process.
>> The node?s registered address will be hashed with the block header of the
>> block it wants to work on. This will determine exactly where within the
>> blockchain to begin the PoNW.
>>
>> The PoNW method could be as simple as creating a Merkle tree from the
>> randomly generated point on the blockchain, though a method that is
>> CPU/Memory heavy and less likely to be replaced by dedicated hardware like
>> ASICs would be better. This process could not begin until the most recent
>> block has been fully verified, and while being carried out should still
>> enable normal relay activities to proceed as normal, since it shouldn?t tie
>> up network at all. The data processed should also be mixed with data from
>> the latest block so that it cannot be computed in advance.
>>
>> A node can do as much PoNW for a block as it likes. Once finished it will
>> then create a nodeWorkComplete transaction for that block with its final
>> proof value, add how much ?work? it did - and create a couple of assertions
>> about what it processed (such as there were x number of pieces of data
>> matching a particular value during calculating). These assertions can be
>> accurate or inaccurate.
>>
>> The system will run in epochs. During each epoch of say 2016 blocks,
>> there will be an extended window for PoNW transactions to be added to
>> nodeblocks to limit minor censorship.
>>
>> The random hash generated from a node?s address and blockhash will also
>> be used to determine nodeWorkComplete transactions from a previous block
>> that the node must also verify, and correctly calculate whether the
>> assertions it made were true or false. The average PoNW that a node
>> performed in its previous x nodeblocks will be used to determine the target
>> PoNW for the node to verify - and this will randomly be a large number of
>> smaller PoNW transactions, or a smaller number of large PoNW. This process
>> will be deterministic based on that block and address hash. All the data
>> will be put together in a transaction and then signed by the node addresses
>> private key.
>>
>> If a nodeWorkComplete transaction contains any incorrect information in
>> an attempt to cheat the validation process a challenge transaction can be
>> created. This begins a refereeing process where other nodes check the
>> challenge and vote whether it is to be upheld or not. The losing node is
>> punished by losing their accrued PoNW for that epoch and a percentage of
>> their security deposit.
>>
>> Nodes will also be punished if they broadcast more than one signed
>> transaction per block.
>>
>> In order to prevent nodes from having multiple keys registered - which
>> would enable them choose to perform PoNW on a subset of the data that they
>> hold - the share of reward that the node gets will be multiplied based on
>> the number of blocks within an epoch that the node performs PoNW on. The
>> share of reward is limited based on how much security deposit has been
>> staked. The higher the PoNW the higher the deposit needed in order to claim
>> their full allocation of any reward.
>>
>> At the end of an epoch, with a wait period for any delayed or censored
>> transactions or challenges to be included and settled up, the process of
>> calculating the reward each node is due can begin. This will then be then
>> paid in a regular block, and means for all the data involved in PoNW, the
>> only permanent mark it makes on the main blockchain is for a transaction
>> that pays all addresses their share of the reward at the end of epoch. Any
>> miner who creates a block without correctly calculating and paying the due
>> reward will have mined an invalid block and be orphaned.
>>
>> The question of where and how much the reward comes from is a different
>> one. It could come from the existing miner reward, or a special new tx
>> donation fee for nodes. If there was some way for users to ?donate? to the
>> reward pool for nodes this would increase the incentive for additional
>> nodes to participate on the network in the event of centralisation.
>>
>> This is a relatively effective way to create a reward for all nodes
>> participating on a network. I?d be keen to field any questions or critiques.
>>
>> Thanks,
>>
>>
>> John Hardy
>>
>> john at seebitcoin.com
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170213/2d644e4a/attachment-0001.html>

From pete at petertodd.org  Tue Feb 14 12:33:17 2017
From: pete at petertodd.org (Peter Todd)
Date: Tue, 14 Feb 2017 07:33:17 -0500
Subject: [bitcoin-dev] [Pre-BIP] Community Consensus Voting System
In-Reply-To: <1486828666.21100.115.camel@stafverhaegen.be>
References: <CAGCNRJqNg9-aYG62OxTz5RJyx+JJkx-kt2odooZWs92f5teZiw@mail.gmail.com>
	<201702030024.10232.luke@dashjr.org>
	<CAGLBAhdzPOC6MppMyuL6SwnoY_D829ZRs78pTF47k3rnHPjE1A@mail.gmail.com>
	<CAMBsKS9Jmah6jc-pYNNOmJSJS+mHSJ9PchWnQ=BixX0C-hg4ig@mail.gmail.com>
	<CAGCNRJpgvoyjKR8RcsOacWD0YboVK+enFPEV+heXFZp9Svau_A@mail.gmail.com>
	<CAAcC9yuzgKWGXxbZLM+21pvRZmYV+nDAMBWMpZXCg6RUYHXRWQ@mail.gmail.com>
	<1486828666.21100.115.camel@stafverhaegen.be>
Message-ID: <20170214123317.GA8613@savin.petertodd.org>

On Sat, Feb 11, 2017 at 04:57:46PM +0100, Staf Verhaegen via bitcoin-dev wrote:
> Chris Priest via bitcoin-dev schreef op vr 03-02-2017 om 16:57 [-0800]:
> > Personally I think once the blocksize arguments are solved, there will
> > be no more contentious changes for this voting system to deal with.
> > What other contentious issues have come up in the past 3 years or so
> > that wasn't blocksize/scaling related? Do other protocols like TCP/IP
> > and the HTTP protocol have developers arguing every day over issues no
> > one can agree on?
> 
> Yes, DRM for example.

...and note how, like blocksize, the roots of the DRM argument at W3C aren't a
technical disagreement, but rather a political disagreement.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/042791b2/attachment.sig>

From dev at jonasschnelli.ch  Tue Feb 14 16:10:15 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 14 Feb 2017 17:10:15 +0100
Subject: [bitcoin-dev] BIP150/151 concerns and some comments
Message-ID: <c949a1a2-ca6c-1fa8-6712-0846c5519f66@jonasschnelli.ch>


Hi

Recently I read some concerns about BIP150/151 and its ?identity system?.
I think we should take those concerns seriously and I wrote some
comments for some of the concerns I'm aware of. In my opinion, most of
these worries are unfounded.


Concern 1: BIP150 introduces a identity system that could partition the
network

###############################################################################

- Users already filtering/authenticate peers by IP tables, ?addnode?
command, peer banning in app-layer. Fast block relay is a good example
(example: FIBRE).
- BIP150 allows to switch from IP based authentication (which is
obviously not ideal) to a secure form of authentication with pre-shared
keys (ECDH).
- We can?t stop peer operators to selectively manage peers and there are
valid reasons to do that

Concern 2: But BIP150 makes it simpler and increase the risk of network
partitioning

####################################################################################

- What is simpler, presharing a pubkey over a secure channel (PGP /
Signal) and store in on both peers or calling a ?addnode <ip>?, or
?iptables-DROP <ip>??

Concern 3: Identity is not something we want in Bitcoin

#######################################################

- BIP150 introduces an **optional** authentication over a EC pubkey. The
EC pubkey can be changed. It?s different per network interface. You only
reveal it to peers that already have proven the know your identity.
- IP addresses are also a form of identity and way more inflexible and
different to hide.


Concern 4: But peers can fingerprint my node and ban me after BIP150 has
been deployed

######################################################################################

- They can?t fingerprint you over BIP150 messages, it does not reveal
your identity unless the responding peer has proven he knows your identity.


Concern 5: BIP150/151 is not necessary, we have already Tor and STunnel,
etc.

#############################################################################

- Tor is an alternative, right. But do we want to depend on those
technologies? Using tor for a single secure channel seems like using
a sledgehammer to crack a nut.

- How many SPV users have encrypted channels to trusted nodes today? Is
it accessible for the novice user? 

- Peer operators who depend on designated connections (with addnode),
what security do they have today (IP address, really?)?

- I think tor is great, it can be an alternative or an additional
security enhancement (encrypt twice). IMO the focus of Tor is not on
securing single channels (it's rather onion routing / anonymity).

 

Concern 6: BIP151 gives a false sense of security and has no MITM detection

###########################################################################

- BIP151 (pure encryption) has no MITM detection, correct.

- Without BIP151 encryption, everyone can hook into the stream and read
what?s going on. With BIP151, an attacker needs to actively substitute
ephemeral keys in both direction. This attack is A) more complex to
achieve and B) it?s an active attack (no excuse of ?I just made some
statistics?), C) it requires the attacker to accept the risk of being
detected.

- C) is true because an optional authentication (can be BIP150 or
different) would reveal the attack.

- Some attacks are worthless if you have to take the risk mentioned in C)

 

Concern 7: But Bitcoin traffic is trustless, why the hell you want to
encrypt it?

#################################################################################

- If you use one of the todays available SPV clients, you will reveal
your complete wallet content (?~all your addresses") to every network
observer between you and the node you have connected to. This means, if
you pay for a coffee (while being on the owners WIFI), the coffee owner
and all the involved ISPs can correlate your wallet with your other
internet behavior. Same is true for your cellphone provider if you use
cellular.

- They still can, if you don?t have a trusted node, by performing the
attack that involves the risk mentioned in Concern 6.

 

Concern 8: If you want to have a light client, you should use a
different channel to communicate with your full node then the p2p layer

#######################################################################################################################################

- From a design perspective, this could make sense

- From an end user?s perspective, this is undesirable (enabled different
port, lack of a (RPC / ZMQ, etc.) standard, no fallback option if the
trusted node is down, hard to setup)

- Using the p2p channel as the todays SPV do, seems very reasonable to
me. Keep the users on the p2p layer! If we don?t want the users on that
channel, we automatically form a different layer, the wallet-com wild-west.

- Keeping the users on the p2p layer also allows future changes where
they can help the network in some ways.

- Using the p2p layer for a trusted connection also allows to fallback
anytime to non-trusted nodes (if your trusted node is no longer
reachable). If your SPV peer needs to catch up a couple of hours while
your trusted peer was done, fine, download full blocks or change your
bloom filters FP rate significant (or sacrifices your privacy in this case).



</jonas>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/8559c0c1/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/8559c0c1/attachment-0001.sig>

From tomz at freedommail.ch  Tue Feb 14 18:01:03 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Tue, 14 Feb 2017 19:01:03 +0100
Subject: [bitcoin-dev] BIP150/151 concerns and some comments
In-Reply-To: <c949a1a2-ca6c-1fa8-6712-0846c5519f66@jonasschnelli.ch>
References: <c949a1a2-ca6c-1fa8-6712-0846c5519f66@jonasschnelli.ch>
Message-ID: <1850609.e9N5m2HcLf@strawberry>

On Tuesday, 14 February 2017 17:10:15 CET Jonas Schnelli via bitcoin-dev 
wrote:
> - If you use one of the todays available SPV clients, you will reveal
> your complete wallet content (?~all your addresses") to every network
> observer between you and the node you have connected to. This means, if
> you pay for a coffee (while being on the owners WIFI), the coffee owner
> and all the involved ISPs can correlate your wallet with your other
> internet behavior. Same is true for your cellphone provider if you use
> cellular.

What about allowing trusted users connecting on a different connection. Much 
like the RPC one.
Make that one encrypted. Different usecase, different connection.

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From vitteaymeric at gmail.com  Tue Feb 14 18:44:26 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Tue, 14 Feb 2017 19:44:26 +0100
Subject: [bitcoin-dev] Proof of Nodework (PoNW) - a method to
 trustlessly reward nodes for storing and verifying the blockchain
In-Reply-To: <CAKzdR-p25HXQty_o0y+rS2dBz568tCjyW9kvAoBJxJuii8k9eA@mail.gmail.com>
References: <BL2PR03MB435AA04A0AB8AC0E7781CA7EE430@BL2PR03MB435.namprd03.prod.outlook.com>
	<CAKzdR-qvDcUMcFDyS_w5XvuYi+zBzH_z9rp=EqBkN3o+MyuubA@mail.gmail.com>
	<BL2PR03MB4355F39BE003DBF200591EBEE590@BL2PR03MB435.namprd03.prod.outlook.com>
	<CAKzdR-p25HXQty_o0y+rS2dBz568tCjyW9kvAoBJxJuii8k9eA@mail.gmail.com>
Message-ID: <9d41572e-a1c4-6a7b-f1d7-373f7c656b41@gmail.com>

I started writing this
https://gist.github.com/Ayms/aab6f8e08fef0792ab3448f542a826bf some time
ago, but stopped since I was under the impression that this was of very
little interest for the Bitcoin community

It's not final and finished at all, but since I wrote it and don't have
plans right now to pursue it, I placed it in a gist and publish the
link, probably not everything is correct and this does not cover
everything but it can maybe give some ideas (which are for some the
combination of concepts from former/other projects) that could be
reused, addressing:

- incentive to run full nodes

- make sure that they are indeed full nodes

- make sure that they participate to the network and are efficient enough

- make sure that they don't collude in pools to get the rewards and are
independent

- set up quickly a full node (incremental torrent-like download)

As this was written this was supposed to add some modifications to the
bitcoin protocol but I don't think that's necessarily a good idea, most
likely this can be handled via sidechains and/or external systems


Le 13/02/2017 ? 15:48, Sergio Demian Lerner via bitcoin-dev a ?crit :
>
>
> On Mon, Feb 13, 2017 at 8:58 AM, John Hardy <john at seebitcoin.com
> <mailto:john at seebitcoin.com>> wrote:
>
>     Hi Sergio,
>
>
>     Thanks for your response, interesting work, very excited for RSK.
>
>
>     I like the ephemeral payload, I suppose that aspect of my proposal
>     could be described as ephemeral blockspace.
>
>
>     I'm curious about the challenge phase, what incentive do nodes to
>     have to check other nodes' responses?
>
> The reward is split between all full nodes. Therefore each full node
> has an incentive to check at least some other full nodes responses
> because there is a competition for the full node reward. At the end,
> each full node response will be checked by more than other node with
> high probability. Also each full node does a small pre-deposit, that
> is consumed if the node cheats.
>
>     Is any validation of responses mandatory, or does policing the
>     system rely on altruism?
>
>
> As previously said,  validation is not mandatory.
>
>     I also wondered how time-based responses are enforced? What
>     prevents a miner censoring challenge responses so they do not get
>     included in a block 'in time' - if  inclusion within a block is
>     the mechanism used?
>
> There is not many defenses against censorship but try to hide your
> identity until the end of the protocol. But if somebody knows that
> your transactions belong to you, then there is little defense. We just
> wait more than a single block for the commitments, so several miners
> must collude in order to censor a transaction. 
>
>
>     I saw your tweet on Lumino - sounds very promising. Would be keen
>     to take a look at the paper if you're looking for any additional
>     review at this stage.
>
> I'm keeping it private against all my desire because I want it to be
> reviewed before I publish it. Credibility is very easily lost. 
> The same idea (Ephemeral Data) has been used to design the Lumino Network.
>
>
>     Regards,
>
>
>     John Hardy
>
>
>
>     ------------------------------------------------------------------------
>     *From:* Sergio Demian Lerner <sergio.d.lerner at gmail.com
>     <mailto:sergio.d.lerner at gmail.com>>
>     *Sent:* Sunday, February 12, 2017 8:22 PM
>     *To:* John Hardy; Bitcoin Protocol Discussion
>     *Subject:* Re: [bitcoin-dev] Proof of Nodework (PoNW) - a method
>     to trustlessly reward nodes for storing and verifying the blockchain
>      
>     Hi John,
>      RSK platform (a Bitcoin sidechain) is already prepared to do
>     something similar to this, although very efficiently. We set apart
>     1% of the block reward to automatically reward full nodes.
>
>     We have two systems being evaluated: the first is based on PoUBS
>     (Proof of Unique Blockchain Storage) which uses asymmetric-time
>     operations to encode the blockchain based on each user public key
>     such that decoding is fast, but encoding is slow. The second is
>     more traditional proof of retrievability, but it requires some
>     ASIC-resistance assumptions. 
>
>     In both cases, a special smart contract is being called at every
>     block that creates periodic challenges. Every full node that wants
>     to participate can submits a commitment to the Merkle hash root of
>     a pseudo-random sequence of encoded blocks. Then the smart
>     contract chooses random elements from the committed dataset, and
>     each full node has a period to submit Merkle-proofs that such
>     random elements belong to the commitment.
>
>     To prevent blockchain bloat we designed a very cool new type of
>     transaction payload: Ephemeral Payload. Ephemeral payload is a
>     payload in a transaction that gets discarded after N blocks if no
>     smart contract does reference it. If is does, it's solidified
>     forever in the blockchain.
>     Then there is a challenge phase where other full nodes can inform
>     the smart contract if they find an error in the submitted
>     responses. Then the smart contract ONLY evaluates the responses
>     which have been questioned by users.
>
>     This way the smart contract does very little computation (only
>     when a user misbehaves) and the blockchain normally does not store
>     any proof forever (only the ones created by misbehaving users).
>
>     Because RSK/Rootstock has a very short block interval (10
>     seconds), all this happens very quickly and does not require much
>     computation. 
>
>     Best regards,
>      Sergio Lerner
>      Chief Scientist RSK (aka Roostock)
>
>
>     On Tue, Feb 7, 2017 at 8:27 AM, John Hardy via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>         Proof of Nodework (PoNW) is a way to reward individual nodes
>         for keeping a full copy of and verifying the blockchain.
>
>
>         Hopefully they also do useful ?traditional? node activities
>         too like relay transactions and blocks, but there isn?t really
>         any way I can think of to trustlessly verify this also.
>
>
>         PoNW would require a new separate area of block space, a
>         nodeblock, purely concerned with administering the system. A
>         nodeblock is committed to a block as with SegWit. A recent
>         history of nodeblocks needs to be stored by nodes, however the
>         data eventually becomes obsolete and so does not need to be
>         retained forever.
>
>
>         In order to prevent Sybil, a node must register an Bitcoin
>         address by submitting an addNode transaction - along with a
>         security deposit to prevent cheating.
>
>
>         This transaction will be stored in the nodeblock. Once a node
>         can see that its addNode transaction has been added it can
>         begin the PoNW process. The node?s registered address will be
>         hashed with the block header of the block it wants to work on.
>         This will determine exactly where within the blockchain to
>         begin the PoNW.
>
>
>         The PoNW method could be as simple as creating a Merkle tree
>         from the randomly generated point on the blockchain, though a
>         method that is CPU/Memory heavy and less likely to be replaced
>         by dedicated hardware like ASICs would be better. This process
>         could not begin until the most recent block has been fully
>         verified, and while being carried out should still enable
>         normal relay activities to proceed as normal, since it
>         shouldn?t tie up network at all. The data processed should
>         also be mixed with data from the latest block so that it
>         cannot be computed in advance.
>
>
>         A node can do as much PoNW for a block as it likes. Once
>         finished it will then create a nodeWorkComplete transaction
>         for that block with its final proof value, add how much ?work?
>         it did - and create a couple of assertions about what it
>         processed (such as there were x number of pieces of data
>         matching a particular value during calculating). These
>         assertions can be accurate or inaccurate.
>
>
>         The system will run in epochs. During each epoch of say 2016
>         blocks, there will be an extended window for PoNW transactions
>         to be added to nodeblocks to limit minor censorship.
>
>
>         The random hash generated from a node?s address and blockhash
>         will also be used to determine nodeWorkComplete transactions
>         from a previous block that the node must also verify, and
>         correctly calculate whether the assertions it made were true
>         or false. The average PoNW that a node performed in its
>         previous x nodeblocks will be used to determine the target
>         PoNW for the node to verify - and this will randomly be a
>         large number of smaller PoNW transactions, or a smaller number
>         of large PoNW. This process will be deterministic based on
>         that block and address hash. All the data will be put together
>         in a transaction and then signed by the node addresses private
>         key.
>
>
>         If a nodeWorkComplete transaction contains any incorrect
>         information in an attempt to cheat the validation process a
>         challenge transaction can be created. This begins a refereeing
>         process where other nodes check the challenge and vote whether
>         it is to be upheld or not. The losing node is punished by
>         losing their accrued PoNW for that epoch and a percentage of
>         their security deposit.
>
>
>         Nodes will also be punished if they broadcast more than one
>         signed transaction per block.
>
>
>         In order to prevent nodes from having multiple keys registered
>         - which would enable them choose to perform PoNW on a subset
>         of the data that they hold - the share of reward that the node
>         gets will be multiplied based on the number of blocks within
>         an epoch that the node performs PoNW on. The share of reward
>         is limited based on how much security deposit has been staked.
>         The higher the PoNW the higher the deposit needed in order to
>         claim their full allocation of any reward.
>
>
>         At the end of an epoch, with a wait period for any delayed or
>         censored transactions or challenges to be included and settled
>         up, the process of calculating the reward each node is due can
>         begin. This will then be then paid in a regular block, and
>         means for all the data involved in PoNW, the only permanent
>         mark it makes on the main blockchain is for a transaction that
>         pays all addresses their share of the reward at the end of
>         epoch. Any miner who creates a block without correctly
>         calculating and paying the due reward will have mined an
>         invalid block and be orphaned.
>
>
>         The question of where and how much the reward comes from is a
>         different one. It could come from the existing miner reward,
>         or a special new tx donation fee for nodes. If there was some
>         way for users to ?donate? to the reward pool for nodes this
>         would increase the incentive for additional nodes to
>         participate on the network in the event of centralisation.
>
>
>         This is a relatively effective way to create a reward for all
>         nodes participating on a network. I?d be keen to field any
>         questions or critiques.
>
>         Thanks,
>
>
>         John Hardy
>
>         john at seebitcoin.com <mailto:john at seebitcoin.com>
>
>
>         _______________________________________________
>         bitcoin-dev mailing list
>         bitcoin-dev at lists.linuxfoundation.org
>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/5d088c81/attachment-0001.html>

From eric at voskuil.org  Tue Feb 14 19:54:37 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 14 Feb 2017 11:54:37 -0800
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <e153823d-e38e-b4b6-01d5-b9d981381e01@jonasschnelli.ch>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<ff7c24ba-7c70-efaf-a319-b1aebfd8a3bd@jonasschnelli.ch>
	<638deacd-c117-f1a7-10de-a7e36a47c3c7@voskuil.org>
	<e153823d-e38e-b4b6-01d5-b9d981381e01@jonasschnelli.ch>
Message-ID: <17f2f92c-68fc-7a7d-c015-9bad810365e3@voskuil.org>

On 02/13/2017 03:14 AM, Jonas Schnelli wrote:
>>> Look at feefilter BIP 133
>>> (https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki#backward-compatibility)
>>> or sendheaders BIP130
>>> (https://github.com/bitcoin/bips/blob/master/bip-0130.mediawiki#backward-compatibility)
>>> Isn't it the same there?
>> No. This is what I was referring to. These messages are enabled by
>> protocol version. If they are received by a node below the version at
>> which they are activated, they are unknown messages, implying an invalid
>> peer. The above messages cannot be sent until *after* the version is
>> negotiated. BIP151 violates this rule by allowing the new control
>> message to be sent *before* the version handshake.

> This indeed is not ideal for compatibility checks, but increases security.

The issue I raised is that it is not backward compatible. It sounds like
you agree but consider it a fair trade. My suggesting was that the BIP
be updated to reflect the lack of compatibility.

> I could not find a protocol specification that said communication must
> be terminated when messages are transmitted before the version handshake
> has been done.

It doesn't need to be specified, most of Bitcoin is unspecified. The
version handshake establishes the negotiated version. It is not possible
to determine if a message is of the negotiated version before the
version is negotiated. All messages apart from this one have followed
that rule.

> Also. BIP151 clearly says that the requesting peer needs to initiate the
> encryption (encinit).

An incoming connection will be dropped due to invalid protocol and
potentially banned depending on the implementation.

> In case of light clients not supporting BIP151 connecting to peers
> supporting BIP151, there should never be transmission of new message
> types specified in BIP151.

Not working with peers not supporting BIP151 is the compatibility issue.
But it sort of seems the intent in this case is to rely on that
incompatibility (expecting connections to nonsupporting peers to fail as
opposed to negotiating).

>>> Once BIP151 is implemented, it would make sense to bump the protocol
>>> version, but this needs to be done once this has been
>>> implemented/deployed.
>> There are already nodes out there breaking connections based on the BIP.

> It could very likely be possible that the initial responding peer tries
> to initiate a encryption session which would mean that BIP151 was not
> implemented correctly.
> Correct me if I'm wrong please.

I did consider the possibility, but there's this:

"Encryption initialization must happen before sending any other messages
to the responding peer (encinit message after a version message must be
ignored)."

https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki#specification

The BIP does not define "responding" and "requesting" peers, but:

"A peer that supports encryption must accept encryption requests from
all peers... The responding peer accepts the encryption request by
sending a encack message."

This implies the requesting peer is the peer that sends the message. You
seem to be saying that the requesting peer is the one that initiated
the connection and the responding peer is the connection receiver. If
this is the case it should be more clearly documented. But in the
case I experienced the "requester" of an encrypted session was also
the "receiver" of the connection.

>>> Or do I make a mistake somewhere?
>> Yes, the ordering of the messages. New messages can only be added after
>> the handshake negotiates the higher version. Otherwise the handshake is
>> both irrelevant (as Pieter is implying) and broken (for all existing
>> protocol versions).

> I could not find evidence of the protocol specification that would
> forbid (=terminate connection) such messages and I think allowing
> unknown-messages before the version handshake makes the protocol flexible.

Flexible is certainly one word for it. Another way to describe it is
dirty. Allowing invalid messages in a protocol encourages protocol
incompatibility. You end up with various implementations and eventually
have no way of knowing how they are impacted by changes. There could be
a range of peers inter-operating with the full network while running
their own sub-protocols. Given the network is public and strong
identification of peers is undesirable, the invalid messages would
reasonably just get sent to everyone. So over time, what is the
protocol? Due to certain "flexibility" it is already a hassle to
properly implement.

> Are there any reasons we should drop peers if they send us unknown, but
> correctly formatted p2p packages (magic, checksum, etc.) before the
> version handshake, ... but not drop them if we have received unknown
> messages after the version handshake?

There is no reason to treat invalid messages differently based on where
they occur in the communication. After the handshake the agreed version
is known to both peers. As a result there is never a reason for an
invalid message to be sent. Therefore it is always proper to drop a peer
that sends an invalid message.

> I can't see that a such spec. would reduce the DOS attack vector?

This was previously addressed (immediately below).

>>>> As for DOS, waste of bandwidth is not something to be ignored. If a peer
>>>> is flooding a node with addr message the node can manage it because it
>>>> understands the semantics of addr messages. If a node is required to
>>>> allow any message that it cannot understand it has no recourse. It
>>>> cannot determine whether it is under attack or if the behavior is
>>>> correct and for proper continued operation must be ignored.
>>> How do you threat any other not known message types?
>> You may be more familiar with non-validating peers. If a message type is
>> not known it is an invalid message and the peer is immediately dropped.
>> We started seeing early drops in handshakes with bcoin nodes because of
>> this issue.

> If this had happened, it's very likely because the responding peer tried
> to initiate a encryption session which is against BIP151 specs.

See above.

>>> Any peer can send you any type of message anytime.
>> Sure, a peer can do what it wants. It can send photos. But I'm not sure
>> what makes you think it would be correct to maintain the connection when
>> an *invalid* message is received.

> Check:
> https://github.com/bitcoin/bitcoin/blob/a06ede9a138d0fb86b0de17c42b936d9fe6e2158/src/net_processing.cpp#L2595
> I think it was a wise implementation decision to allow unknown (not
> invalid) messages.
> This had allowed us to deploy stuff like compact blocks, feefilter, etc.
> without breaking backward compatibility.
> IMO, without a such flexibility, the deployment complexity would be
> irresponsible high without really solving the DOS problem.

This is a misinterpretation. The failure to validate did not enable
anything except possibly some broken peers not getting dropped. None of
the protocol changes previously deployed require the older version peer
to allow invalid messages. While it may appear otherwise, due to a
particular implementation, it is never necessary to send a message to a
peer that the peer does not understand. The handshake gives each peer
the other peer's version. That obligates the newer peer to conform to
the older (or disconnect if the old is insufficient). That's the nature
of backward compatibility.

>>> Why would your implementation how you threat unknown messages be
>> different for messages specified in BIP151?
>>
>> Because it properly validates the protocol.

> For feefilter or compact block or sendheaders?

Yes, this is the purpose of version negotiation, which is why there are
version and verack messages. And this is also why, in the satoshi
client, two of the above messages are sent from the verack handler. The
feefilter message is sent dynamically but only if the peer's version
allows it.

> You can't link a (unimplemented) specification (improvement process) to
> a protocol version before deployment. Or can you?

I'm not sure I follow your question. The BIP should presumably declare a
version number if one is necessary.

> Once it has been widely deployed, we should set a protocol minversion
> for BIP151, right.

In general you should set a version before it's ever live on the
network. But if it precedes the protocol version negotiation the
protocol version number is moot.

I've been asked to throttle the discussion in the interest of reducing
list volume. I think the issue is pretty clearly addressed at this
point, but feel free to follow up directly and/or via the libbitcoin
development list (copied).

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/031fe7e7/attachment.sig>

From dev at jonasschnelli.ch  Tue Feb 14 20:58:54 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 14 Feb 2017 21:58:54 +0100
Subject: [bitcoin-dev] BIP151 protocol incompatibility
In-Reply-To: <17f2f92c-68fc-7a7d-c015-9bad810365e3@voskuil.org>
References: <ba422d5e-8e96-3475-2a29-80d89fd67322@voskuil.org>
	<CAPg+sBhDjVuN6=tdvUcSY5OCdJD7s3Jp90K1qx0iRX+2WppUQQ@mail.gmail.com>
	<dde5349d-c430-ad57-30c7-77954ff1a94d@voskuil.org>
	<ff7c24ba-7c70-efaf-a319-b1aebfd8a3bd@jonasschnelli.ch>
	<638deacd-c117-f1a7-10de-a7e36a47c3c7@voskuil.org>
	<e153823d-e38e-b4b6-01d5-b9d981381e01@jonasschnelli.ch>
	<17f2f92c-68fc-7a7d-c015-9bad810365e3@voskuil.org>
Message-ID: <2c059f3c-620e-4324-0726-4c56dfab0b43@jonasschnelli.ch>


>> This indeed is not ideal for compatibility checks, but increases security.
> The issue I raised is that it is not backward compatible. It sounds like
> you agree but consider it a fair trade. My suggesting was that the BIP
> be updated to reflect the lack of compatibility.
It's still backward compatible. All (?) SPV clients and full node
implementation would still work if BIP151 has been implemented.
Isn't that backward compatibility?
>> I could not find a protocol specification that said communication must
>> be terminated when messages are transmitted before the version handshake
>> has been done.
> It doesn't need to be specified, most of Bitcoin is unspecified. The
> version handshake establishes the negotiated version. It is not possible
> to determine if a message is of the negotiated version before the
> version is negotiated. All messages apart from this one have followed
> that rule.
Yes. But encryption negotiation must be done before the version
handshake (security).
>
>> Also. BIP151 clearly says that the requesting peer needs to initiate the
>> encryption (encinit).
> An incoming connection will be dropped due to invalid protocol and
> potentially banned depending on the implementation.
This is not true. If the connecting peer (assume the SPV client) will
not request encryption, the responding peer (the node) will not enforce
or ask for encryption.
This is clearly written in the BIP.
>> It could very likely be possible that the initial responding peer tries
>> to initiate a encryption session which would mean that BIP151 was not
>> implemented correctly.
>> Correct me if I'm wrong please.
> I did consider the possibility, but there's this:
>
> "Encryption initialization must happen before sending any other messages
> to the responding peer (encinit message after a version message must be
> ignored)."
>
> https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki#specification
>
> The BIP does not define "responding" and "requesting" peers, but:
>
> "A peer that supports encryption must accept encryption requests from
> all peers... The responding peer accepts the encryption request by
> sending a encack message."
>
> This implies the requesting peer is the peer that sends the message. You
> seem to be saying that the requesting peer is the one that initiated
> the connection and the responding peer is the connection receiver. If
> this is the case it should be more clearly documented. But in the
> case I experienced the "requester" of an encrypted session was also
> the "receiver" of the connection.
I think the BIP makes this very clear. IMO you are trying to hide your
standpoint behind a wired interpretations of the BIP.

From the BIP:
?To request encrypted communication, the requesting peer generates an EC
ephemeral-session-keypair and sends an encinit message to the responding
peer and waits for a encack message. The responding node must do the
same encinit/encack interaction for the opposite communication direction.?

This seems to be pretty clear to me. You can interpret the "requesting
peer" and "responding peer" per message interaction. But then the whole
BIP would make no sense.

I'm happy if you can do a PR on the BIP that makes the wording better.
This would actually be a productive step.
>
>>>> Or do I make a mistake somewhere?
>>> Yes, the ordering of the messages. New messages can only be added after
>>> the handshake negotiates the higher version. Otherwise the handshake is
>>> both irrelevant (as Pieter is implying) and broken (for all existing
>>> protocol versions).
>> I could not find evidence of the protocol specification that would
>> forbid (=terminate connection) such messages and I think allowing
>> unknown-messages before the version handshake makes the protocol flexible.
> Flexible is certainly one word for it. Another way to describe it is
> dirty. Allowing invalid messages in a protocol encourages protocol
> incompatibility. You end up with various implementations and eventually
> have no way of knowing how they are impacted by changes. There could be
> a range of peers inter-operating with the full network while running
> their own sub-protocols. Given the network is public and strong
> identification of peers is undesirable, the invalid messages would
> reasonably just get sent to everyone. So over time, what is the
> protocol? Due to certain "flexibility" it is already a hassle to
> properly implement.
Then you would have to go after all BIPs deployed this way. This
argument has nothing to do with BIP151 it questions the whole new
protocol features deployment.
Again, check this code part:

https://github.com/bitcoin/bitcoin/blob/a06ede9a138d0fb86b0de17c42b936d9fe6e2158/src/net_processing.cpp#L2595


>
>> Are there any reasons we should drop peers if they send us unknown, but
>> correctly formatted p2p packages (magic, checksum, etc.) before the
>> version handshake, ... but not drop them if we have received unknown
>> messages after the version handshake?
> There is no reason to treat invalid messages differently based on where
> they occur in the communication. After the handshake the agreed version
> is known to both peers. As a result there is never a reason for an
> invalid message to be sent. Therefore it is always proper to drop a peer
> that sends an invalid message.
That's up to the implementation. But the current flexibility exists
because we not drop.
Again, see above.
>> I can't see that a such spec. would reduce the DOS attack vector?
> This was previously addressed (immediately below).
No. I'd like to hear from you why the DOS attack vector would be larger
if the encryption neg. would be after the version handshake.
>
>>>>> As for DOS, waste of bandwidth is not something to be ignored. If a peer
>>>>> is flooding a node with addr message the node can manage it because it
>>>>> understands the semantics of addr messages. If a node is required to
>>>>> allow any message that it cannot understand it has no recourse. It
>>>>> cannot determine whether it is under attack or if the behavior is
>>>>> correct and for proper continued operation must be ignored.
>>>> How do you threat any other not known message types?
>>> You may be more familiar with non-validating peers. If a message type is
>>> not known it is an invalid message and the peer is immediately dropped.
>>> We started seeing early drops in handshakes with bcoin nodes because of
>>> this issue.
> Yes, this is the purpose of version negotiation, which is why there are
> version and verack messages. And this is also why, in the satoshi
> client, two of the above messages are sent from the verack handler. The
> feefilter message is sent dynamically but only if the peer's version
> allows it.

Again. Encryption ? for the sake of security ? must be the first
interaction.
This is exceptional for BIP151 and I'd like to hear the real downsides
of doing that.
>
>> You can't link a (unimplemented) specification (improvement process) to
>> a protocol version before deployment. Or can you?
> I'm not sure I follow your question. The BIP should presumably declare a
> version number if one is necessary.
What? You want to define protocol version number in draft improvement
specifications?
How should that be possible?
It's like defining a new HTML version number if you propose/draft a new
video streaming format.


</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/0b660431/attachment.sig>

From dev at jonasschnelli.ch  Tue Feb 14 21:01:51 2017
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 14 Feb 2017 22:01:51 +0100
Subject: [bitcoin-dev] BIP150/151 concerns and some comments
In-Reply-To: <1850609.e9N5m2HcLf@strawberry>
References: <c949a1a2-ca6c-1fa8-6712-0846c5519f66@jonasschnelli.ch>
	<1850609.e9N5m2HcLf@strawberry>
Message-ID: <302c0b13-1951-faec-7266-f42bf748163d@jonasschnelli.ch>


>> - If you use one of the todays available SPV clients, you will reveal
>> your complete wallet content (?~all your addresses") to every network
>> observer between you and the node you have connected to. This means, if
>> you pay for a coffee (while being on the owners WIFI), the coffee owner
>> and all the involved ISPs can correlate your wallet with your other
>> internet behavior. Same is true for your cellphone provider if you use
>> cellular.
> What about allowing trusted users connecting on a different connection. Much 
> like the RPC one.
> Make that one encrypted. Different usecase, different connection.
>
- What protocol would you use? The same p2p protocol but different port
and/or different process? Why?
- If not the p2p protocol, how would you form a standard? Would it be
worth doing a standard?
- Could you fall back to the current SPV model against random untrusted
peers if you additional channel is not available?
- What are the downsides using current p2p network?
- Would this also solve the security problem of creating designated
channels between peers (the "addnode" thing is based on IPs)?

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170214/1e198586/attachment-0001.sig>

From tomz at freedommail.ch  Thu Feb 16 15:10:46 2017
From: tomz at freedommail.ch (Tom Zander)
Date: Thu, 16 Feb 2017 16:10:46 +0100
Subject: [bitcoin-dev] BIP150/151 concerns and some comments
In-Reply-To: <302c0b13-1951-faec-7266-f42bf748163d@jonasschnelli.ch>
References: <c949a1a2-ca6c-1fa8-6712-0846c5519f66@jonasschnelli.ch>
	<1850609.e9N5m2HcLf@strawberry>
	<302c0b13-1951-faec-7266-f42bf748163d@jonasschnelli.ch>
Message-ID: <1853296.U0XO7RE0lo@strawberry>

On Tuesday, 14 February 2017 22:01:51 CET Jonas Schnelli via bitcoin-dev 
wrote:
> >> - If you use one of the todays available SPV clients, you will reveal
> >> your complete wallet content (?~all your addresses") to every network
> >> observer between you and the node you have connected to. This means, if
> >> you pay for a coffee (while being on the owners WIFI), the coffee owner
> >> and all the involved ISPs can correlate your wallet with your other
> >> internet behavior. Same is true for your cellphone provider if you use
> >> cellular.
> > 
> > What about allowing trusted users connecting on a different connection.
> > Much like the RPC one.
> > Make that one encrypted. Different usecase, different connection.
> 
> - What protocol would you use?

The RPC one. Which I think is JSON.

Your usecase is essentially just calling sendRawTransaction. Don?t 
overcomplicate things.

-- 
Tom Zander
Blog: https://zander.github.io
Vlog: https://vimeo.com/channels/tomscryptochannel

From belcher at riseup.net  Fri Feb 17 00:28:59 2017
From: belcher at riseup.net (Chris Belcher)
Date: Fri, 17 Feb 2017 00:28:59 +0000
Subject: [bitcoin-dev] Committed bloom filters for improved wallet
 performance and SPV security
In-Reply-To: <71d822e413ac457a530e1c367811cc24@cock.lu>
References: <71d822e413ac457a530e1c367811cc24@cock.lu>
Message-ID: <f8511114-4bcd-32a0-f654-414a723781fa@riseup.net>

I believe this proposal still suffers from one problem that bip37 did,
albiet by a much lesser extent. Combining the partial information from
the block downloads with the transaction subgraph information from the
blockchain can in some cases still reveal which addresses belong to the
wallet. Nonetheless this proposal still has many benefits and is well
worth working on.

==BIP37==

As a recap, probably the biggest and most problematic way that bip37 was
broken was by combining the partial wallet information from the bloom
filter with the transaction subgraph information from the blockchain

Suppose a wallet synchronizes it's history, if it spent a coin from its
address A, it must also also add the change address B to the bloom
filter, which is connected to A directly on transaction graph.

As an example, consider five typical transactions that consume one input
each and produce two outputs.
A, B, C, D, E refer to transactions. A1, A2, etc refer to addresses
within those transactions

          -> C1
A1 -> B2  -> C2
   -> B2  -> D1
          -> D2 -> E1
                -> E2

If a bip37 bloom filter matches addresses A1, B2, D2, E1 then it can be
seen that they form a "peel chain" [this terminology comes from
https://cseweb.ucsd.edu/~smeiklejohn/files/imc13.pdf]

          -> X
A1 -> X   -> X
   -> B2  -> X
          -> D2 -> E1
                -> X

The same five transactions with non-matching addresses replaced by X.
The peel chain is visible, it's clear that B2, D2, E1 are change
addresses which belong to the same wallet as A1.

For a given false-positive rate fp and given length of peel chain C, the
odds of a false positive peel chain happening by chance is fp^C which
rapidly gets very small as the wallet makes more transactions (increases C).

If only one address was matched from the above group (for example B2)
then it likely to be a false positive by the fact that it doesn't make
any transactions to another address that also matches the bloom filter.
Another possibility is that the address is a payment output that the
wallet received but hasn't spent yet, but the wallet cant spend it
without adding the change address to the bloom filter and thus revealing
itself to the spy.

I believe the committed bloom filter proposal is vulnerability to this
same kind of attack because it still leaks information about which
addresses the wallet is interested in.

==Committed Bloom Filter Maths==

I'll try to analyze this now. I'll find the expectation value of the
number of transaction subgraphs in those blocks that appear just by
chance. If this expectation goes to zero, then the only transaction
subgraph left will be the real one that the wallet is actually
interested in. In that case it will be possible to spy on the wallet.

Assuming outputs have the same probability of being spent in each time
interval (i.e. they are spent in a Poisson process) This is
approximately true, see the graphs from
[https://letstalkbitcoin.com/blog/post/rise-of-the-zombie-bitcoins].
This means we can assign
a single probability P that an output is spent in each block.

Assume every transaction has one change address only and spending of
unconfirmed change doesn't happen (its more efficient to use RBF to add
additional outputs anyway)

Number of transactions per block = Q (about 1800 today)
Number of outputs per block = Z = 2*Q (approximately)
Length of peel chain = Number of transactions in wallet = C
Average time an output is unspent for = T (about 1 month, very roughly
estimating from the above blog post)
Probability an output being spent in any particular later block = P =
10minutes/T

Assume no false positive blocks
Say wallet downloaded two blocks and they are ordered by block height
The expected number of tx subgraphs between them, E(#G)
E(#G) = number of outputs created in block 1 that get spent in block 2
      = Z*P

Say the wallet downloaded three blocks
Expected number of subgraphs going through them all
E(#G) = number of outputs created in block 1 get spent in block 2, that
create a change address which gets spent in block 3
      = Z*P*P

Say the wallet downloaded C blocks
Expected number of tx subgraphs going through all the blocks by chance
E(#G) = Z*P^C
which gets small quickly as C goes up, because P < 1

Now drop the assumption about no false positive blocks.

Let the number of candidate blocks be D.
This is how many blocks the wallet scans, it's related to how far in the
past the wallet's keys was created. At one extreme wallet was created at
genesis block and so D = ~450000, at other extreme created now so D = 0.
Note that D = 0 must also imply C = 0

Expected number of false positive blocks downloaded = F = fp*D

In all these situations the blocks are sorted by block height

Suppose have C=2, F=1, and false one is in the middle.
I want to find E(#G|CF), the expected number of transaction subgraphs
that appear just by chance, given C and F.
E(#G|CF) = how many outputs which are created in block 1 get spent in
block 3
         = Z*P

Same situation, but false one at the start instead of middle.
E(#G|CF) = how many outputs which are created in block 2 get spent in
block 3
         = Z*P

Same situation but false one could be anywhere, result in the sum of the
probability for any false block position
E(#G|CF) = C(3, 1)*Z*P = 3*Z*P

where C() is the number of order-independent ways of choosing 1 element
out of a set of 3 elements, also known as the binomial coefficient

Now suppose C=3 and F=1
The same argument leads to
E(#G|CF) = C(4, 1)*Z*P^2 = 4*Z*P^2


Now suppose C=3 and F=2, with fp blocks at the end
E(#G|CF)
= how many outputs are created in block 1, are spent in block 2 and
change address spent in block 3
= Z*P^2

Same situation but fp blocks can be anywhere, add up all the possible
combinations of them within the rest
E(#G|CF) = C(5, 2)*Z*P^2 = 5*Z*P^2

With these same rules, its clear the general expression for any F and C
E(#G|CF) = C(F + C, F)*Z*P^(C - 1)

A more interesting value might be the time evolution of E(#G)
Let B be the blocks in the blockchain since the wallet creation date, as you
know it increases at an average rate of one every ten minutes

w = wallet transaction creation rate, expressed per-block
C = w * B
F = fp * B

J = average blocks between wallet transactions = 1440 (10 days)
w = 1/J

E(#G|B) = C((fp + w)*B, fp*B)*Z*P^(w*B - 1)

This goes to zero as B becomes big, although choosing very high values
of fp makes it go to zero slower.

This is only approximate maths, in actuality you cannot take the number
of false positive blocks to be fp*B, you have to sum over all blocks
weighted by probability. And outputs might not be spent in an exact
Poisson process so you cant just multiply by P each time. Plus if your
false positive rate is very high then some of your false positive blocks
will actually contain your real transactions, this analysis
double-counts them.

Using some reasonable values and plotting E(#G|B) against B can show how
quickly it drops and therefore leaves only the true transaction subgraph.

(note: in LibreOffice Math and Microsoft Excel the binomial coefficient
function is COMBIN)

==Notes==

*) The expected number of transaction subgraphs that happen by chance
goes to zero eventually as the blockchain steps ahead. Unless the fp
rate is very high (close to 1) and time between wallet transaction very
long, in which case the binomial coefficient term gets larger more
quicker than the exponential decay P^B term gets smaller.
*) fp rate doesn't help in most cases that much compared to the
exponential drop-off from time ticking ahead requiring more downloading
of blocks
*) its good for privacy if bitcoin outputs are spent more frequently so
P is higher, because that creates more transaction subgraphs in the
anonymity set.
*) its good for privacy if more outputs are made per block, although
still only linearly which is no match for the exponential reduction from
the P^B term.
*) its good for privacy to make less of your own transactions (increase
J and reduce w), for low-activity users the privacy of committed bloom
filters can be actually pretty good, for high-activity users who use
bitcoin's blockchain all the time it's not very good
*) For the reasonable values I tried for a once-a-month user with fp=1%,
their chance-transaction-subgraph-count drops below 1 in about eight months.
*) Because of the exponential nature, E(#G) goes from "billions of
billions" to "about 10" fairly quickly.

==Discussion of ways to mitigate this==

One way is to not use change outputs. This is unrealistic, doesn't match
people's behavior and money must be divisible.

A better way to mitigate this is to not leak the information that all
those blocks are interesting to the same wallet. Don't download all
blocks from the same archival node. If you download blocks from many
different nodes, it gives an incentive for surveillance startups to
create lots of sybil nodes they control and can then correlate together
block downloads with the wallet IP address. Many such startups are
already doing this today to try to detect the origin IP address of
broadcasted transactions.

Another solution could be to download a few blocks from different nodes
with new tor circuits used. This would delink the wallet IP address from
the downloads and would help a lot. This has the issue that tor is
slower (but still not as slow as downloading the entire blockchain)

Another way a wallet could be correlated with its block downloads is
timing correlations. At any one time only a certain number of peers
would be downloading blocks which narrows down which wallets are
downloading what. However even today Bitcoin Core downloads blocks in
parallel from many nodes so there's probably quite a large anonymity set
for lightweight wallets using committed bloom filters. Plus timing
correlation can be reduced simply by waiting longer. Wallets are not
sync'd from backup very often so it might be okay to wait.

Another way to improve privacy could be for the wallet to choose random
transaction subgraphs and download all the blocks related to them as well.

Wallet developers might choose to allow the user to configure their own
fp rate. This is probably not a good idea since the relationship between
fp rate and anonymity set is non-obvious. It might be better to ask the
user how often they expect to make transactions.

==Conclusion==

I think this committed bloom filter idea is very good and much better
than bip37, but for good privacy for when bitcoin is used often still
requires certain behavior namely downloading blocks
from many different peers with new tor circuits.

Note that I've been dealing with counting transaction subgraphs but
actually finding them from blocks might also be computationally
infeasible. Although a Bayesian approach worked very
well for similar transaction subgraph linking
[https://arxiv.org/pdf/1612.06747v3.pdf]

It would also be interesting to analyze what information a spy can get
if they are missing some blocks that the wallet downloaded.

For the long term, private and high-volume bitcoin use will be best
served by off-chain transactions. They will probably be a huge win just
because the large and public blockchain is such a non-private
way of doing things.

On 09/05/16 09:26, bfd--- via bitcoin-dev wrote:
> We introduce several concepts that rework the lightweight Bitcoin
> client model in a manner which is secure, efficient and privacy
> compatible.
> 
> Thea properties of BIP37 SPV [0] are unfortunately not as strong as
> originally thought:
> 
>     * The expected privacy of the probabilistic nature of bloom
>       filters does not exist [1][2], any user with a BIP37 SPV wallet
>       should be operating under no expectation of privacy.
>       Implementation flaws make this effect significantly worse, the
>       behavior meaning that no matter how high the false positive
>       rate (up to simply downloading the whole blocks verbatim) the
>       intent of the client connection is recoverable.
> 
>     * Significant processing load is placed on nodes in the Bitcoin
>       network by lightweight clients, a single syncing wallet causes
>       (at the time of writing) 80GB of disk reads and a large amount
>       of CPU time to be consumed processing this data. This carries
>       significant denial of service risk [3], non-distinguishable
>       clients can repeatedly request taxing blocks causing
>       reprocessing on every request. Processed data is unique to every
>       client, and can not be cached or made more efficient while
>       staying within specification.
> 
>     * Wallet clients can not have strong consistency or security
>       expectations, BIP37 merkle paths allow for a wallet to validate
>       that an output was spendable at some point in time but does not
>       prove that this output is not spent today.
> 
>     * Nodes in the network can denial of service attack all BIP37 SPV
>       wallet clients by simply returning null filter results for
>       requests, the wallet has no way of discerning if it has been
>       lied to and may be made simply unaware that any payment has been
>       made to them. Many nodes can be queried in a probabilistic manor
>       but this increases the already heavy network load with little
>       benefit.
> 
> 
> 
> We propose a new concept which can work towards addressing these
> shortcomings.
> 
> 
> A Bloom Filter Digest is deterministically created of every block
> encompassing the inputs and outputs of the containing transactions,
> the filter parameters being tuned such that the filter is a small
> portion of the size of the total block data. To determine if a block
> has contents which may be interesting a second bloom filter of all
> relevant key material is created. A binary comparison between the two
> filters returns true if there is probably matching transactions, and
> false if there is certainly no matching transactions. Any matched
> blocks can be downloaded in full and processed for transactions which
> may be relevant.
> 
> The BFD can be used verbatim in replacement of BIP37, where the filter
> can be cached between clients without needing to be recomputed. It can
> also be used by normal pruned nodes to do re-scans locally of their
> wallet without needing to have the block data available to scan, or
> without reading the entire block chain from disk.
> 
> -
> 
> For improved probabilistic security the bloom filters can be presented
> to lightweight clients by semi-trusted oracles. A client wallet makes
> an assumption that they trust a set, or subset of remote parties
> (wallet vendors, services) which all all sign the BFD for each block.
> The BFD can be downloaded from a single remote source, and the hash of
> the filters compared against others in the trust set. Agreement is a
> weak suggestion that the filter has not been tampered with, assuming
> that these parties are not conspiring to defraud the client.
> 
> The oracles do not learn any additional information about the client
> wallet, the client can download the block data from either nodes on
> the network, HTTP services, NTTP, or any other out of band
> communication method that provides the privacy desired by the client.
> 
> -
> 
> The security model of the oracle bloom filter can be vastly improved
> by instead committing a hash of the BFD inside every block as a soft-
> fork consensus rule change. After this, every node in the network would
> build the filter and validate that the hash in the block is correct,
> then make a conscious choice discard it for space savings or cache the
> data to disk.
> 
> With a commitment to the filter it becomes impossible to lie to
> lightweight clients by omission. Lightweight clients are provided with
> a block header, merkle path, and the BFD. Altering the BFD invalidates
> the merkle proof, it's validity is a strong indicator that the client
> has an unadulterated picture of the UTXO condition without needing to
> build one itself. A strong assurance that the hash of the BFD means
> that the filters can be downloaded out of band along with the block
> data at the leisure of the client, allowing for significantly greater
> privacy and taking load away from the P2P Bitcoin network.
> 
> Committing the BFD is not a hard forking change, and does not require
> alterations to mining software so long as the coinbase transaction
> scriptSig is not included in the bloom filter.
> 
> 
> [0] https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki
> [1] https://eprint.iacr.org/2014/763.pdf
> [2] https://jonasnick.github.io/blog/2015/02/12/privacy-in-bitcoinj/
> [3] https://github.com/petertodd/bloom-io-attack
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From luke at dashjr.org  Sun Feb 19 12:12:55 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 19 Feb 2017 12:12:55 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.14.0 release candidate 1 available
Message-ID: <201702191213.01101.luke@dashjr.org>

Release candidate 1 of a new major Bitcoin Knots release, version 0.14.0, has
been made available.

This is a release candidate for a new major version release, including new
features, various bugfixes and performance improvements.

Preliminary release notes for the release can be found here:

    https://github.com/bitcoinknots/bitcoin/blob/v0.14.0.knots20170218.rc1/doc/release-notes.md

Binaries can be downloaded from:

    http://bitcoinknots.org/files/0.14.x/0.14.0.knots20170218.rc1/

Please take care to verify the PGP signature of all downloads.

Source code can be found on GitHub under the signed tag

    https://github.com/bitcoinknots/bitcoin/tree/v0.14.0.knots20170218.rc1

Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.14.0 final, otherwise
a new rc will be made available after these are solved.

Please report bugs using the issue tracker at GitHub:

    https://github.com/bitcoinknots/bitcoin/issues
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170219/4d5b3d03/attachment.sig>

From pete at petertodd.org  Sun Feb 19 21:30:01 2017
From: pete at petertodd.org (Peter Todd)
Date: Sun, 19 Feb 2017 16:30:01 -0500
Subject: [bitcoin-dev] replace-by-fee-v0.14.0rc1 available
In-Reply-To: <201702191213.01101.luke@dashjr.org>
References: <201702191213.01101.luke@dashjr.org>
Message-ID: <20170219213001.GA10603@savin.petertodd.org>

My full-RBF patched branch of Bitcoin Core v0.14.0rc1 is now available:
https://github.com/petertodd/bitcoin/tree/replace-by-fee-v0.14.0rc1

As with replace-by-fee-v0.13.2, this version uses the nRelevantServices
machinery to do preferential peering, so it's just a few lines of code changed
between it and Bitcoin Core v0.14.0rc1.

The relevant services machinery is less agressive at connecting to full-RBF
peers than the earlier custom code previous versions used. But it seems to work
well enough to keep RBF peers connected to each other, so I'm inclined to keep
using it as doing so makes maintaining this patched branch pretty trivial every
time a new upstream version is released.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170219/3336b9b3/attachment.sig>

From bram at bittorrent.com  Tue Feb 21 22:00:23 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Tue, 21 Feb 2017 14:00:23 -0800
Subject: [bitcoin-dev] Proposal for utxo commitment format
Message-ID: <CA+KqGkpVLfGjQUJEYdRppqvN263rHrY-rGL2k22eMryQbb6Q8g@mail.gmail.com>

Here is a Merkle set data structure, whose format may be useful for utxo
commitments in Bitcoin blocks. It may also be useful for any other
distributed computation which wants an audit trail:

https://github.com/bramcohen/MerkleSet

This is a fairly straightforward Patricia Trie, with a simple format and a
simple reference implementation plus a performance optimized non-reference
implementation which is much more cache coherent. It will need to be ported
to C and be properly turned before the potential performance gains can be
realized though.

The clever things which affect the format spec are:

It uses blake2s as the internal hash function. This is the fastest hash
function to use on 512 bit inputs because blake2b uses a 1024 bit block
size. It might make sense to use a hypothetical variant of blake which is
optimized for 64 bits with a 512 bit block size, but that hasn't been
specified. Sha256 would take advantage of hardware acceleration, but that
isn't available everywhere.

Two bits of security are sacrificed to include metadata inline which halves
the CPU cost of hashing.

When one side of a node is empty and the other contains exactly two things
the secure hash of the child is adopted verbatim rather than rehashing it.
This roughly halves the amount of hashing done, and makes it more resistant
to malicious data, and cleans up some implementation details, at the cost
of some extra complexity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170221/a52234ed/attachment.html>

From pete at petertodd.org  Thu Feb 23 01:11:47 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 22 Feb 2017 20:11:47 -0500
Subject: [bitcoin-dev] TXO commitments do not need a soft-fork to be useful
Message-ID: <20170223011147.GB905@savin.petertodd.org>

Something I've recently realised is that TXO commitments do not need to be
implemented as a consensus protocol change to be useful. All the benefits they
provide to full nodes with regard to allowing for old UTXO data to be pruned -
and thus solving the UTXO bloat problem - can be implemented even without
having miners commit to the TXO commitment itself. This has a significant
deployment advantage too: we can try out multiple TXO commitment schemes, in
production, without the need for consensus changes.


# Reasoning

1) Like any other merkelized data structure, a TXO commitment allows a data set
- the TXO set - to be securely provided by an untrusted third party, allowing
the data itself to be discarded. So if you have a valid TXO commitment, you can
discard the TXO data itself, and rely on untrusted entities to provide you that
data on demand.

2) The TXO set is a super-set of the UTXO set; all data in the UTXO set is also
present in the TXO set. Thus a TXO commitment with spent TXO's pruned is
equivalent to a UTXO set, doubly so if inner nodes in the commitment tree
commit to the sum-unspent of their children.

3) Where a outpoint-indexed UTXO set has a uniform access pattern, an
insertion-ordered TXO set has a delibrately *non-uniform* access pattern: not
only are new entries to the TXO set always appended to the end - an operation
that requires a known, log2(n), sized set of merkle tips - but due to lost
coins alone we can guarantee that older entries in the TXO set will be less
frequently updated than newer entries.

4) Thus a full node that doesn't have enough local storage to maintain the full
UTXO set can instead keep track of a TXO commitment, and prune older UTXO's
from it that are unlikely to be spent. In the event those UTXO's are spent,
transactions and blocks spending them can trustlessly provide the necessary
data to temporarily fill-in the node's local TXO set database, allowing the
next commitment to be calculated.

5) By *not* committing the TXO commitment in the block itself, we obsolete my
concept of delayed TXO commitments: you don't need to have calculated the TXO
commitment digest to validate a block anyway!


# Deployment Plan

1) Implement a TXO commitment scheme with the ability to efficiently store the
last n versions of the commitment state for the purpose of reorgs (a
reference-counted scheme naturally does this).

2) Add P2P support for advertising to peers what parts of the TXO set you've
pruned.

3) Add P2P support to produce, consume, and update TXO unspentness proofs as
part of transaction and block relaying.

4) Profit.


# Bootstrapping New Nodes

With a TXO commitment scheme implemented, it's also possible to produce
serialized UTXO snapshots for bootstrapping new nodes. Equally, it's obviously
possible to distribute those snapshots, and have people you trust attest to the
validity of those snapshots.

I argue that a snapshot with an attestation from known individuals that you
trust is a *better* security model than having miners attest to validity: the
latter is trusting an unknown set of unaccountable, anonymous, miners.

This security model is not unlike the recently implemented -assumevalid
scheme(1), in that auditing the validity of the assumed valid TXO commitments
is something anyone can do provided they have a full node. Similarly, we could
ship Bitcoin nodes with an assumed-valid TXO commitment, and have those nodes
fill in the UTXO data from their peers.

However it is a weaker security model, in that a false TXO commitment can more
easily be used to trick a node into accepting invalid transactions/blocks;
assumed valid blocks requires proof-of-work to pull off this attack. A
compromise may be to use assumed valid TXO commitments, extending my partial
UTXO set(2) suggestion of having nodes validate the chain backwards, to
eventually validate 100% of the chain.


# References

1) https://github.com/bitcoin/bitcoin/pull/9484
2) [Bitcoin-development] SPV bitcoind? (was: Introducing BitcoinKit.framework),
   Peter Todd, Jul 17th 2013, Bitcoin development mailing list,
   https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-July/002917.html

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170222/70a0a773/attachment.sig>

From pete at petertodd.org  Thu Feb 23 01:15:06 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 22 Feb 2017 20:15:06 -0500
Subject: [bitcoin-dev] A Better MMR Definition
Message-ID: <20170223011506.GC905@savin.petertodd.org>

Reposting something that came up recently in a private discussion with some
academics:

Concretely, let's define a prunable MMR with the following grammar. This
definition is an improvement on whats in the python-proofmarshal by committing
to the number of items in the tree implicitly; an obvious max-log2(n)-sized
proof-of-tree-size can be obtained by following the right-most nodes:

    Maybe(T) := UNPRUNED <T> | PRUNED <Commitment(T)>

    FullNode(0) := <Value>
    FullNode(n) := <Maybe(FullNode(n-1)> <Maybe(FullNode(n-1))>

    PartialNode(0) := SOME <FullNode(0)> | NONE
    PartialNode(n) := <Maybe(FullNode(n-1))> <Maybe(PartialNode(n-1))>

    MMR := FULL <N> <FullNode(n)> | PARTIAL <N> <PartialNode(n)>

Basically we define it in four parts. First we define Maybe(T) to represent
pruned and unpruned (hash only) data. Secondly we define full nodes within 2^n
sized trees. Third we define partial nodes. And finally we define the MMR
itself as being either a full or partial node.

First of all, with pruning we can define a rule that if any operation (other
than checking commitment hashes) attempts to access pruned data, it should
immediately fail. In particular, no operation should be able to determine if
data is or isn't pruned. Equally, note how an implementation can keep track of
what data was accessed during any given operation, and prune the rest, which
means a proof is just the parts of the data structure accessed during one or
more operations.

With that, notice how proving the soundness of the proofs becomes trivial: if
validation is deterministic, it is obviously impossible to construct two
different proofs that prove contradictory statements, because a proof is simply
part of the data structure itself. Contradiction would imply that the two
proofs are different, but that's easily rejected by simply checking the hash of
the data.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170222/1412af52/attachment.sig>

From pete at petertodd.org  Thu Feb 23 01:26:11 2017
From: pete at petertodd.org (Peter Todd)
Date: Wed, 22 Feb 2017 20:26:11 -0500
Subject: [bitcoin-dev] Generalized Commitments
In-Reply-To: <CA+KqGkpVLfGjQUJEYdRppqvN263rHrY-rGL2k22eMryQbb6Q8g@mail.gmail.com>
References: <CA+KqGkpVLfGjQUJEYdRppqvN263rHrY-rGL2k22eMryQbb6Q8g@mail.gmail.com>
Message-ID: <20170223012611.GA1454@savin.petertodd.org>

On Tue, Feb 21, 2017 at 02:00:23PM -0800, Bram Cohen via bitcoin-dev wrote:
> When one side of a node is empty and the other contains exactly two things
> the secure hash of the child is adopted verbatim rather than rehashing it.
> This roughly halves the amount of hashing done, and makes it more resistant
> to malicious data, and cleans up some implementation details, at the cost
> of some extra complexity.

Note that this is a use-case specific concept of an idea I'm calling a
"generalized commitment"

A commitment scheme needs only have the property that it's not feasible to find
two messages m1 and m2 that map to the same commitment; it is *not* required
that it be difficult to find m given the commitment. Equally, it's not required
that commitments always be the same size.

So a perfectly reasonable thing to do is design your scheme such that the
commitment to short messages is the message itself! This adds just a single bit
of data to the minimum serialized size(1) of the commitment, and in situations
where sub-digest-sized messages are common, may overall be a savings.


Another advantage is that the scheme becomes more user-friendly: you *want*
programmers to notice when a commitment is not effectively hiding the message!
If you need message privacy, you should implement an explicit nonce, rather
than relying on the data to not be brute-forcable.


1) The more I look at these systems, the more I'm inclined to consider
bit-granularity serialization schemes... Heck, sub-bit granularity has
advantages too in some cases, e.g. by making all possible inputs to the
deserializer be valid.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170222/c6df5d46/attachment.sig>

From bram at bittorrent.com  Thu Feb 23 02:56:35 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Wed, 22 Feb 2017 18:56:35 -0800
Subject: [bitcoin-dev] Generalized Commitments
In-Reply-To: <20170223012611.GA1454@savin.petertodd.org>
References: <CA+KqGkpVLfGjQUJEYdRppqvN263rHrY-rGL2k22eMryQbb6Q8g@mail.gmail.com>
	<20170223012611.GA1454@savin.petertodd.org>
Message-ID: <CA+KqGkq4LuUw1b2sMW-GdjFPH53U9uoAVUVP33hht5vLvWPBWw@mail.gmail.com>

On Wed, Feb 22, 2017 at 5:26 PM, Peter Todd <pete at petertodd.org> wrote:

>
> A commitment scheme needs only have the property that it's not feasible to
> find
> two messages m1 and m2 that map to the same commitment; it is *not*
> required
> that it be difficult to find m given the commitment. Equally, it's not
> required
> that commitments always be the same size.


> So a perfectly reasonable thing to do is design your scheme such that the
> commitment to short messages is the message itself! This adds just a
> single bit
> of data to the minimum serialized size(1) of the commitment, and in
> situations
> where sub-digest-sized messages are common, may overall be a savings.
>

Yes I'm basically doing that but to make things be all the same size I'm
including the bit inline, sacrificing one bit of security. Actually I'm
sacrificing two bits of security, to allow for four values: terminal,
middle, empty, and invalid. Invalid is used internally when a value has yet
to be calculated lazily and in proofs to mean 'this is a middle node but
the children are not included'. One effect of this is that the root of a
set containing a single value is just that value with the two high order
bits of the first byte reset to the appropriate value.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170222/10b8cd50/attachment.html>

From bram at bittorrent.com  Thu Feb 23 03:07:08 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Wed, 22 Feb 2017 19:07:08 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170223011506.GC905@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
Message-ID: <CA+KqGkqXmWgyU+4ZaR9w7e3xVBUyWwAixVAEzT9hT8V_1kwnuw@mail.gmail.com>

On Wed, Feb 22, 2017 at 5:15 PM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> With that, notice how proving the soundness of the proofs becomes trivial:
> if
> validation is deterministic, it is obviously impossible to construct two
> different proofs that prove contradictory statements, because a proof is
> simply
> part of the data structure itself. Contradiction would imply that the two
> proofs are different, but that's easily rejected by simply checking the
> hash of
> the data.
>

My code works this way. Proofs are serialization of a subset of the tree,
and to validate a proof you ask a single function whether a particular
value is included in that tree subset, and it answers yes or no, so
obviously it's impossible for a single value to both validate and not
validate. The proof code was quite terrifying before I made this change
(which I did on your suggestion), and it's much cleaner and simpler now. It
also in principle supports compact proofs of multiple inclusions and
exclusions in the same serialization of a subset of the tree because the
upper branches won't have to be repeated. I haven't written code for
generating those, but the validation code will happily accept them.

I'm not sure what you mean by MMRs though. Are you talking about MMRs where
each mountain is a set of diffs to the old things and are periodically
consolidated? Or do later mountains refer to internals of earlier ones? Or
do they have 'maybe' values which mean that the earlier mountain should be
referred to? Are these patricia tries or something flatter and more fixed
depth?

My code doesn't keep track of tree size, by the way. It would be trivial to
add that functionality to the library, and including it in the hashing
creates complexity and doesn't seem to have any benefit over sending that
data in a side channel.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170222/4a48d1ae/attachment-0001.html>

From elombrozo at gmail.com  Thu Feb 23 03:30:37 2017
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Wed, 22 Feb 2017 19:30:37 -0800
Subject: [bitcoin-dev] TXO commitments do not need a soft-fork to be
	useful
In-Reply-To: <20170223011147.GB905@savin.petertodd.org>
References: <20170223011147.GB905@savin.petertodd.org>
Message-ID: <CABr1YTfSak2d199=_-ifRAmZkx6X3d5pMRqsU0ke_QwDmsiOnA@mail.gmail.com>

This kind of thing is long overdue!

I think it?s a great idea to attempt this without soft forking TXO
commitments yet so we can see what works best.


- E

On Wed, Feb 22, 2017 at 5:11 PM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Something I've recently realised is that TXO commitments do not need to be
> implemented as a consensus protocol change to be useful. All the benefits
> they
> provide to full nodes with regard to allowing for old UTXO data to be
> pruned -
> and thus solving the UTXO bloat problem - can be implemented even without
> having miners commit to the TXO commitment itself. This has a significant
> deployment advantage too: we can try out multiple TXO commitment schemes,
> in
> production, without the need for consensus changes.
>
>
> # Reasoning
>
> 1) Like any other merkelized data structure, a TXO commitment allows a
> data set
> - the TXO set - to be securely provided by an untrusted third party,
> allowing
> the data itself to be discarded. So if you have a valid TXO commitment,
> you can
> discard the TXO data itself, and rely on untrusted entities to provide you
> that
> data on demand.
>
> 2) The TXO set is a super-set of the UTXO set; all data in the UTXO set is
> also
> present in the TXO set. Thus a TXO commitment with spent TXO's pruned is
> equivalent to a UTXO set, doubly so if inner nodes in the commitment tree
> commit to the sum-unspent of their children.
>
> 3) Where a outpoint-indexed UTXO set has a uniform access pattern, an
> insertion-ordered TXO set has a delibrately *non-uniform* access pattern:
> not
> only are new entries to the TXO set always appended to the end - an
> operation
> that requires a known, log2(n), sized set of merkle tips - but due to lost
> coins alone we can guarantee that older entries in the TXO set will be less
> frequently updated than newer entries.
>
> 4) Thus a full node that doesn't have enough local storage to maintain the
> full
> UTXO set can instead keep track of a TXO commitment, and prune older UTXO's
> from it that are unlikely to be spent. In the event those UTXO's are spent,
> transactions and blocks spending them can trustlessly provide the necessary
> data to temporarily fill-in the node's local TXO set database, allowing the
> next commitment to be calculated.
>
> 5) By *not* committing the TXO commitment in the block itself, we obsolete
> my
> concept of delayed TXO commitments: you don't need to have calculated the
> TXO
> commitment digest to validate a block anyway!
>
>
> # Deployment Plan
>
> 1) Implement a TXO commitment scheme with the ability to efficiently store
> the
> last n versions of the commitment state for the purpose of reorgs (a
> reference-counted scheme naturally does this).
>
> 2) Add P2P support for advertising to peers what parts of the TXO set
> you've
> pruned.
>
> 3) Add P2P support to produce, consume, and update TXO unspentness proofs
> as
> part of transaction and block relaying.
>
> 4) Profit.
>
>
> # Bootstrapping New Nodes
>
> With a TXO commitment scheme implemented, it's also possible to produce
> serialized UTXO snapshots for bootstrapping new nodes. Equally, it's
> obviously
> possible to distribute those snapshots, and have people you trust attest
> to the
> validity of those snapshots.
>
> I argue that a snapshot with an attestation from known individuals that you
> trust is a *better* security model than having miners attest to validity:
> the
> latter is trusting an unknown set of unaccountable, anonymous, miners.
>
> This security model is not unlike the recently implemented -assumevalid
> scheme(1), in that auditing the validity of the assumed valid TXO
> commitments
> is something anyone can do provided they have a full node. Similarly, we
> could
> ship Bitcoin nodes with an assumed-valid TXO commitment, and have those
> nodes
> fill in the UTXO data from their peers.
>
> However it is a weaker security model, in that a false TXO commitment can
> more
> easily be used to trick a node into accepting invalid transactions/blocks;
> assumed valid blocks requires proof-of-work to pull off this attack. A
> compromise may be to use assumed valid TXO commitments, extending my
> partial
> UTXO set(2) suggestion of having nodes validate the chain backwards, to
> eventually validate 100% of the chain.
>
>
> # References
>
> 1) https://github.com/bitcoin/bitcoin/pull/9484
> 2) [Bitcoin-development] SPV bitcoind? (was: Introducing
> BitcoinKit.framework),
>    Peter Todd, Jul 17th 2013, Bitcoin development mailing list,
>    https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2013-July/002917.html
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170222/cabff956/attachment.html>

From pete at petertodd.org  Thu Feb 23 07:23:10 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 02:23:10 -0500
Subject: [bitcoin-dev] TXO commitments do not need a soft-fork to be
 useful
In-Reply-To: <20170223011147.GB905@savin.petertodd.org>
References: <20170223011147.GB905@savin.petertodd.org>
Message-ID: <20170223072310.GA3122@savin.petertodd.org>

On Wed, Feb 22, 2017 at 08:11:47PM -0500, Peter Todd via bitcoin-dev wrote:
> 5) By *not* committing the TXO commitment in the block itself, we obsolete my
> concept of delayed TXO commitments: you don't need to have calculated the TXO
> commitment digest to validate a block anyway!

Thinking about this a bit more, by not being forced to calculate a TXO
commitment for every block, we may be able to do significantly better than
delayed TXO commitments by lazily hashing.

Suppose we have the following perfect merkle tree, which we're using as a
key-value map. We'll represent inner nodes for which we've calculated digests
with "0"'s to represent what version of the tree they correspond too:

               0
              / \
             /   \
            /     \
           /       \
          /         \
         0           0
        / \         / \
       /   \       /   \
      0     0     0     0
     / \   / \   / \   / \
    a   b c   d e   f g   h

If a value is updated, digests above it become out of date and need to be
recalculated:


               1
              / \
             /   \
            /     \
           /       \
          /         \
         0           1
        / \         / \
       /   \       /   \
      0     0     0     1
     / \   / \   / \   / \
    a   b c   d e   f g   H

               2
              / \
             /   \
            /     \
           /       \
          /         \
         0           2
        / \         / \
       /   \       /   \
      0     0     2     1
     / \   / \   / \   / \
    A   b c   d e   F g   H

               3
              / \
             /   \
            /     \
           /       \
          /         \
         0           3
        / \         / \
       /   \       /   \
      0     0     2     3
     / \   / \   / \   / \
    a   b c   d e   F G   H

Suppose however that your implementation does lazy hashing; after the 3rd
update your state will be:

               .
              / \
             /   \
            /     \
           /       \
          /         \
         0           .
        / \         / \
       /   \       /   \
      0     0     .     .
     / \   / \   / \   / \
    a   b c   d e   F G   H

Basically all the digests on the right side is out of date and need to be
recalculated. Now, first of all it's obviously possible for your implementation
to keep updating values in the tree given their keys - you've essentially
regressed to a bog standard binary tree.

But what happens if you discard part of your dataset? Let's suppose you've
discarded the left half:

               .
              / \
             /   \
            /     \
           /       \
          /         \
         0           .
                    / \
                   /   \
                  .     .
                 / \   / \
                e   F G   H

Note how you still have sufficient information to calculate the current merkle
tip commitment: the left side hasn't changed yet. But what happens when someone
gives you an update proof? Specifically, suppose they want to change b -> B.
That requires them to provide you with the part of the merkle tree proving that
position #1 is b. Now you might think that's this data:

               3
              / \
             /   \
            /     \
           /       \
          /         \
         0           3
        / \
       /   \
      0     0
     / \
    a   b

But the inner node digests marked "3" are useless to you: you haven't
calculated those digests yet so you can't compare them to anything. What you
can compare is the following:

         0
        / \
       /   \
      0     0
     / \
    a   b

With that extra data your local knowledge is now:

               .
              / \
             /   \
            /     \
           /       \
          /         \
         0           .
        / \         / \
       /   \       /   \
      0     0     .     .
     / \         / \   / \
    a   b       e   F G   H

Allowing you to apply the update:

               .
              / \
             /   \
            /     \
           /       \
          /         \
         .           .
        / \         / \
       /   \       /   \
      .     0     .     .
     / \         / \   / \
    a   B       e   F G   H

If you want to again prune that data, simply recalculate the digests so you
can verify a copy given to you by a peer in the future:

               .
              / \
             /   \
            /     \
           /       \
          /         \
         4           .
        / \         / \
       /   \       /   \
      4     0     .     .
     / \         / \   / \
    a   B       e   F G   H

And prune, leaving you with:

               .
              / \
             /   \
            /     \
           /       \
          /         \
         4           .
                    / \
                   /   \
                  .     .
                 / \   / \
                e   F G   H


So tl;dr: the reason this works is that we can substitute commitments for
pointers: our merkle tree can also be viewed as a binary tree. So a reasonable
real-world implementation would be to delay computation of digests for anything
we have in RAM, and only compute digests as in-RAM data is flushed to disk.
Equally, on disk we can use standard time-space tradeoffs to only store a
subset of the digests, recalculating the rest on the fly. Given that'd we could
effectively combine both a cryptographic data structure and a standard
pointer-based data structure in one, I suspect we can get good performance out
of this.

The main subtlety of this approach will be how exactly to handle the proofs:
the level of verification possible depends on what digests a given node has
calculated, and we want to avoid making network splitting attacks possible by
attackers deliberately giving nodes proofs with upper digests that are
incorrect, something only some nodes can detect. Not sure yet exactly what's
the right approach there.

Finally, notice how this entire approach depends on schemes like MMR's where
the overall structure of the tree does not change as nodes are added and
updated; it would be much harder to implement this idea for something like a
merklized red-black tree where the structure changes as the tree is rebalanced.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/9d5d9e70/attachment.sig>

From pete at petertodd.org  Thu Feb 23 07:41:37 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 02:41:37 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkqXmWgyU+4ZaR9w7e3xVBUyWwAixVAEzT9hT8V_1kwnuw@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CA+KqGkqXmWgyU+4ZaR9w7e3xVBUyWwAixVAEzT9hT8V_1kwnuw@mail.gmail.com>
Message-ID: <20170223074137.GA3395@savin.petertodd.org>

On Wed, Feb 22, 2017 at 07:07:08PM -0800, Bram Cohen wrote:
> On Wed, Feb 22, 2017 at 5:15 PM, Peter Todd via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> >
> > With that, notice how proving the soundness of the proofs becomes trivial:
> > if
> > validation is deterministic, it is obviously impossible to construct two
> > different proofs that prove contradictory statements, because a proof is
> > simply
> > part of the data structure itself. Contradiction would imply that the two
> > proofs are different, but that's easily rejected by simply checking the
> > hash of
> > the data.
> >
> 
> My code works this way. Proofs are serialization of a subset of the tree,
> and to validate a proof you ask a single function whether a particular
> value is included in that tree subset, and it answers yes or no, so
> obviously it's impossible for a single value to both validate and not
> validate. The proof code was quite terrifying before I made this change
> (which I did on your suggestion), and it's much cleaner and simpler now. It
> also in principle supports compact proofs of multiple inclusions and
> exclusions in the same serialization of a subset of the tree because the
> upper branches won't have to be repeated. I haven't written code for
> generating those, but the validation code will happily accept them.

That's an improvement, but I think we can do even better if we think of missing
pruned data as analogous to virtual memory: pruned data is the same as a page
that has been swapped to disk, with the magical property that hashing allows us
to swap it back in from an untrusted source.

Thus a proof should actually be whatever data we expect our counterparty to
have flushed, ranging from none at all, to 100% (modulo a root hash). An
implementation should then do operations as normal, using parts of the proof on
an as-needed basis where pruned data is encountered.

Thus if you have a key-value map and do a get() operation, you'd expect the
proof to *not* be what the get operates on, but rather be a *context* argument
to the get() operation. The other way around is actually an example of doing
computations on untrusted data, and bad API design!

> I'm not sure what you mean by MMRs though. Are you talking about MMRs where
> each mountain is a set of diffs to the old things and are periodically
> consolidated? Or do later mountains refer to internals of earlier ones? Or
> do they have 'maybe' values which mean that the earlier mountain should be
> referred to? Are these patricia tries or something flatter and more fixed
> depth?

I'm talking about these MMR's: https://github.com/proofchains/python-proofmarshal/blob/master/proofmarshal/mmr.py

Notably I'm talking about an insertion ordered list, indexed by position, that
supports append and update operations, but *not* insertions; this is different
than what you've recently published re: UTXO commitments. That's a full
key-value map, something MMR's are delibrately are not doing.

Draw out a MMR based on the formal definition you're replying too and you'll
see the new structure.

> My code doesn't keep track of tree size, by the way. It would be trivial to
> add that functionality to the library, and including it in the hashing
> creates complexity and doesn't seem to have any benefit over sending that
> data in a side channel.

Like I say above, you're solving a different problem than MMR's solve.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/91289920/attachment-0001.sig>

From cp368202 at ohiou.edu  Thu Feb 23 17:53:58 2017
From: cp368202 at ohiou.edu (Chris Priest)
Date: Thu, 23 Feb 2017 09:53:58 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170223011506.GC905@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
Message-ID: <CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>

On 2/22/17, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Reposting something that came up recently in a private discussion with some
> academics:
>
> Concretely, let's define a prunable MMR with the following grammar. This
> definition is an improvement on whats in the python-proofmarshal by
> committing
> to the number of items in the tree implicitly; an obvious max-log2(n)-sized
> proof-of-tree-size can be obtained by following the right-most nodes:
>
>     Maybe(T) := UNPRUNED <T> | PRUNED <Commitment(T)>
>
>     FullNode(0) := <Value>
>     FullNode(n) := <Maybe(FullNode(n-1)> <Maybe(FullNode(n-1))>
>
>     PartialNode(0) := SOME <FullNode(0)> | NONE
>     PartialNode(n) := <Maybe(FullNode(n-1))> <Maybe(PartialNode(n-1))>
>
>     MMR := FULL <N> <FullNode(n)> | PARTIAL <N> <PartialNode(n)>
>
> Basically we define it in four parts. First we define Maybe(T) to represent
> pruned and unpruned (hash only) data. Secondly we define full nodes within
> 2^n
> sized trees. Third we define partial nodes. And finally we define the MMR
> itself as being either a full or partial node.
>
> First of all, with pruning we can define a rule that if any operation
> (other
> than checking commitment hashes) attempts to access pruned data, it should
> immediately fail. In particular, no operation should be able to determine
> if
> data is or isn't pruned. Equally, note how an implementation can keep track
> of
> what data was accessed during any given operation, and prune the rest,
> which
> means a proof is just the parts of the data structure accessed during one
> or
> more operations.
>
> With that, notice how proving the soundness of the proofs becomes trivial:
> if
> validation is deterministic, it is obviously impossible to construct two
> different proofs that prove contradictory statements, because a proof is
> simply
> part of the data structure itself. Contradiction would imply that the two
> proofs are different, but that's easily rejected by simply checking the hash
> of
> the data.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>


What problem does this try to solve, and what does it have to do with bitcoin?

From pete at petertodd.org  Thu Feb 23 18:14:09 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 13:14:09 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
Message-ID: <20170223181409.GA6085@savin.petertodd.org>

Worth noting: the impact of the SHA1 collison attack on Git is *not* limited
only to maintainers making maliciously colliding Git commits, but also
third-party's submitting pull-reqs containing commits, trees, and especially
files for which collisions have been found. This is likely to be exploitable in
practice with binary files, as reviewers aren't going to necessarily notice
garbage at the end of a file needed for the attack; if the attack can be
extended to constricted character sets like unicode or ASCII, we're in trouble
in general.

Concretely, I could prepare a pair of files with the same SHA1 hash, taking
into account the header that Git prepends when hashing files. I'd then submit
that pull-req to a project with the "clean" version of that file. Once the
maintainer merges my pull-req, possibly PGP signing the git commit, I then take
that signature and distribute the same repo, but with the "clean" version
replaced by the malicious version of the file.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/fe8c9937/attachment.sig>

From pete at petertodd.org  Thu Feb 23 18:19:29 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 13:19:29 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
Message-ID: <20170223181929.GA6268@savin.petertodd.org>

On Thu, Feb 23, 2017 at 09:53:58AM -0800, Chris Priest wrote:
> On 2/22/17, Peter Todd via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Reposting something that came up recently in a private discussion with some
> > academics:
> >
> > Concretely, let's define a prunable MMR with the following grammar. This
> > definition is an improvement on whats in the python-proofmarshal by
> > committing
> > to the number of items in the tree implicitly; an obvious max-log2(n)-sized
> > proof-of-tree-size can be obtained by following the right-most nodes:
> 
> What problem does this try to solve, and what does it have to do with bitcoin?

See the discussion on TXO commitments for how MMR's could be used; a better MMR
makes for a better TXO commitment.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/8a77c8e5/attachment.sig>

From g.andrew.stone at gmail.com  Thu Feb 23 18:28:18 2017
From: g.andrew.stone at gmail.com (G. Andrew Stone)
Date: Thu, 23 Feb 2017 13:28:18 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170223181929.GA6268@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<20170223181929.GA6268@savin.petertodd.org>
Message-ID: <CAHUwRvs=f4=4cQPQoNa2ESJAydztZ3VRQg+SOY66UgDDB5i03w@mail.gmail.com>

Can an insertion ordered MMR allow an efficient nonexistence proof?
On Feb 23, 2017 1:20 PM, "Peter Todd via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thu, Feb 23, 2017 at 09:53:58AM -0800, Chris Priest wrote:
> > On 2/22/17, Peter Todd via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > Reposting something that came up recently in a private discussion with
> some
> > > academics:
> > >
> > > Concretely, let's define a prunable MMR with the following grammar.
> This
> > > definition is an improvement on whats in the python-proofmarshal by
> > > committing
> > > to the number of items in the tree implicitly; an obvious
> max-log2(n)-sized
> > > proof-of-tree-size can be obtained by following the right-most nodes:
> >
> > What problem does this try to solve, and what does it have to do with
> bitcoin?
>
> See the discussion on TXO commitments for how MMR's could be used; a
> better MMR
> makes for a better TXO commitment.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/07c5af54/attachment.html>

From pete at petertodd.org  Thu Feb 23 18:31:40 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 13:31:40 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CAHUwRvs=f4=4cQPQoNa2ESJAydztZ3VRQg+SOY66UgDDB5i03w@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<20170223181929.GA6268@savin.petertodd.org>
	<CAHUwRvs=f4=4cQPQoNa2ESJAydztZ3VRQg+SOY66UgDDB5i03w@mail.gmail.com>
Message-ID: <20170223183140.GA6393@savin.petertodd.org>

On Thu, Feb 23, 2017 at 01:28:18PM -0500, G. Andrew Stone wrote:
> Can an insertion ordered MMR allow an efficient nonexistence proof?

Why do you want a non-existance proof?

It supports an efficient *spentness* proof, which is sufficient for what we
need in Bitcoin, and much more scalable.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/74acf29d/attachment.sig>

From pete at petertodd.org  Thu Feb 23 21:28:02 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 16:28:02 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170223181409.GA6085@savin.petertodd.org>
References: <20170223181409.GA6085@savin.petertodd.org>
Message-ID: <20170223212802.GA7608@savin.petertodd.org>

On Thu, Feb 23, 2017 at 01:14:09PM -0500, Peter Todd via bitcoin-dev wrote:
> Worth noting: the impact of the SHA1 collison attack on Git is *not* limited
> only to maintainers making maliciously colliding Git commits, but also
> third-party's submitting pull-reqs containing commits, trees, and especially
> files for which collisions have been found. This is likely to be exploitable in
> practice with binary files, as reviewers aren't going to necessarily notice
> garbage at the end of a file needed for the attack; if the attack can be
> extended to constricted character sets like unicode or ASCII, we're in trouble
> in general.
> 
> Concretely, I could prepare a pair of files with the same SHA1 hash, taking
> into account the header that Git prepends when hashing files. I'd then submit
> that pull-req to a project with the "clean" version of that file. Once the
> maintainer merges my pull-req, possibly PGP signing the git commit, I then take
> that signature and distribute the same repo, but with the "clean" version
> replaced by the malicious version of the file.

Thinking about this a bit more, the most concerning avenue of attack is likely
to be tree objects, as I'll bet you you can construct tree objs with garbage at
the end that many review tools don't pick up on. :(

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/29fe50b5/attachment-0001.sig>

From bram at bittorrent.com  Thu Feb 23 23:13:43 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Thu, 23 Feb 2017 15:13:43 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
Message-ID: <CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>

On Thu, Feb 23, 2017 at 9:53 AM, Chris Priest via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> What problem does this try to solve, and what does it have to do with
> bitcoin?
>

I can't speak to MMRs (they look a bit redundant with the actual blockchain
history to my eye) but circling back to utxo commitments, the benefits are
that it enables actual proofs of non-fraud: You can prove the validity of a
block based on just the previous block (and maybe some previous headers
because of mining rewards) and can prove to a light node that a utxo hasn't
been spent yet.

A major factor in the way of getting utxo commitments in blocks is
performance. The txo set is of course vastly larger and more unwieldy. If
you make the utxo commitments trail by a small fixed number of blocks
(between 2 and 5) their latency problems shouldn't be a big deal as long as
the overall performance is good enough. My thesis is that with appropriate
format and implementation tricks it's possible to get performance good
enough to no longer be a gating factor to deployment.

Disappointingly there hasn't been any feedback about my implementation,
just discussion about merkle sets generally.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/5dbd72da/attachment.html>

From pete at petertodd.org  Thu Feb 23 23:51:05 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 18:51:05 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
Message-ID: <20170223235105.GA28497@savin.petertodd.org>

On Thu, Feb 23, 2017 at 03:13:43PM -0800, Bram Cohen wrote:
> On Thu, Feb 23, 2017 at 9:53 AM, Chris Priest via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> >
> > What problem does this try to solve, and what does it have to do with
> > bitcoin?
> >
> 
> I can't speak to MMRs (they look a bit redundant with the actual blockchain
> history to my eye) but circling back to utxo commitments, the benefits are

In what way do you see MMRs as redundant?

Remember that with UTXO commitments because access patterns are uniform, you'll
over time have a lot more "redundancy" in the form of lost-coins evenly spread
out across the whole keyspace.

> that it enables actual proofs of non-fraud: You can prove the validity of a
> block based on just the previous block (and maybe some previous headers
> because of mining rewards) and can prove to a light node that a utxo hasn't
> been spent yet.
>
> A major factor in the way of getting utxo commitments in blocks is
> performance. The txo set is of course vastly larger and more unwieldy. If

That statement is incorrect with pruning: you can maintain a commitment to the
TXO set, without actually storing the entire TXO set, because you don't need to
store anything for nodes that have already been spent.

Concretely, this can be done with nothing more than adding a FullySpent node
type to the MMR definition I published earlier, with the rule being that only a
left or right child of an inner node be a FullySpent node, not both; if both
sides are spent, the inner node itself becomes FullySpent. Equally, I think you
can re-use the Empty node for this, but I need to think a little about the
implications re: partial inner nodes.

Regardless, with a generalized commitment scheme, the serialization/commitment
to an Empty node is simply '0', the encoding of an unspent txout surrounded by
spent txouts will be similar in size to a position integer followed by the
txout...


A subtlety of this construction is that you can only prove that a specific
txout # is unspent, but that's actually sufficient, as you can also prove what
# a txout txid corresponds too with a previous version of the MMR.

> you make the utxo commitments trail by a small fixed number of blocks
> (between 2 and 5) their latency problems shouldn't be a big deal as long as
> the overall performance is good enough. My thesis is that with appropriate
> format and implementation tricks it's possible to get performance good
> enough to no longer be a gating factor to deployment.
> 
> Disappointingly there hasn't been any feedback about my implementation,
> just discussion about merkle sets generally.

Well, I think at this point there's still discussion over whether or not a UTXO
set commitment is the right approach to begin with; if it's not your
implementation isn't relevant.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/7dfb1ea7/attachment.sig>

From vitteaymeric at gmail.com  Thu Feb 23 23:57:45 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 24 Feb 2017 00:57:45 +0100
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170223212802.GA7608@savin.petertodd.org>
References: <20170223181409.GA6085@savin.petertodd.org>
	<20170223212802.GA7608@savin.petertodd.org>
Message-ID: <76fa5d76-6c54-e13e-7b55-a4409ef536f5@gmail.com>

Maybe not, unlike frozen objects (certificates, etc), trees are supposed
to extend

Then you can perform progressive hash operations on the objects, ie
instead of hashing the intermediate hash of the objects you do it
continuously (ie instead of hashing the hash of hash file a + hash file
b + hash file c, wait for file d and then do the same, instead hash(file
a + file b + file c), when d comes compute the hash of (file a + file b
+ file c + file d), which implies each time to keep the intermediary
hash state because you are not going to recompute everything from the
beginning)

I have not worked on this since some time, so that's just thoughts, but
maybe it can render things much more difficult than computing two files
until the same hash is found

The only living example I know implementing this is the Tor protocol,
fact apparently unknown, this is probably why nobody cares and nobody is
willing to take it into account (please follow bwd/fwd [1] and see [2]),
this is not existing in any crypto implementations, unless you hack into
it, and this applies to progressive encryption too

[1]
https://lists.w3.org/Archives/Public/public-webcrypto-comments/2013Feb/0018.html


[2] https://github.com/whatwg/streams/issues/33#issuecomment-28554151


Le 23/02/2017 ? 22:28, Peter Todd via bitcoin-dev a ?crit :
> On Thu, Feb 23, 2017 at 01:14:09PM -0500, Peter Todd via bitcoin-dev wrote:
>> Worth noting: the impact of the SHA1 collison attack on Git is *not* limited
>> only to maintainers making maliciously colliding Git commits, but also
>> third-party's submitting pull-reqs containing commits, trees, and especially
>> files for which collisions have been found. This is likely to be exploitable in
>> practice with binary files, as reviewers aren't going to necessarily notice
>> garbage at the end of a file needed for the attack; if the attack can be
>> extended to constricted character sets like unicode or ASCII, we're in trouble
>> in general.
>>
>> Concretely, I could prepare a pair of files with the same SHA1 hash, taking
>> into account the header that Git prepends when hashing files. I'd then submit
>> that pull-req to a project with the "clean" version of that file. Once the
>> maintainer merges my pull-req, possibly PGP signing the git commit, I then take
>> that signature and distribute the same repo, but with the "clean" version
>> replaced by the malicious version of the file.
> Thinking about this a bit more, the most concerning avenue of attack is likely
> to be tree objects, as I'll bet you you can construct tree objs with garbage at
> the end that many review tools don't pick up on. :(
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170224/7bfa2399/attachment.html>

From bram at bittorrent.com  Fri Feb 24 00:49:01 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Thu, 23 Feb 2017 16:49:01 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170223235105.GA28497@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
Message-ID: <CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>

On Thu, Feb 23, 2017 at 3:51 PM, Peter Todd <pete at petertodd.org> wrote:

> On Thu, Feb 23, 2017 at 03:13:43PM -0800, Bram Cohen wrote:
> >
> > I can't speak to MMRs (they look a bit redundant with the actual
> blockchain
> > history to my eye) but circling back to utxo commitments, the benefits
> are
>
> In what way do you see MMRs as redundant?
>

You can readily prove something is in the TXO or STXO set using the actual
blockchain, and the proofs will be nice and compact because even light
nodes are expected to already have all the historical headers.

What you can't do with MMRs or the blockchain is make a compact proof that
something is still in the utxo set, which is the whole point of utxo
commitments.

It's totally reasonable for full nodes to independently update and
recalculate the utxo set as part of their validation process. The same
can't be done for a balanced version of the txo set because it's too big.
Relying on proofs as a crutch for using the full txo set would badly
exacerbate the already extant problem of miners doing spv mining, and
increase the bandwidth a full validating node had to use by a multiple.

This whole conversation is badly sidetracked. If people have comments on my
merkle set I'd like to engage further with them, but mmrs need to be argued
independently on their own merits before being used as a counterpoint to
utxo commitments.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/c2fc2e57/attachment-0001.html>

From pete at petertodd.org  Fri Feb 24 01:09:43 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 20:09:43 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
Message-ID: <20170224010943.GA29218@savin.petertodd.org>

On Thu, Feb 23, 2017 at 04:49:01PM -0800, Bram Cohen wrote:
> On Thu, Feb 23, 2017 at 3:51 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > On Thu, Feb 23, 2017 at 03:13:43PM -0800, Bram Cohen wrote:
> > >
> > > I can't speak to MMRs (they look a bit redundant with the actual
> > blockchain
> > > history to my eye) but circling back to utxo commitments, the benefits
> > are
> >
> > In what way do you see MMRs as redundant?
> >
> 
> You can readily prove something is in the TXO or STXO set using the actual
> blockchain, and the proofs will be nice and compact because even light
> nodes are expected to already have all the historical headers.
> 
> What you can't do with MMRs or the blockchain is make a compact proof that
> something is still in the utxo set, which is the whole point of utxo
> commitments.

I think you've misunderstood what TXO commitments are. From my article:

"A merkle tree committing to the state of all transaction outputs, both spent
and unspent, can provide a method of compactly proving the current state of an
output."
-https://petertodd.org/2016/delayed-txo-commitments#txo-commitments:

I'm proposing that we commit to not just the set of transaction outputs, but
also the current *state* of those outputs, with the same commitment structure.

Concretely, each leaf node in the TXO commitment tree needs to commit to - at
minimum - the outpoint (txid:n) and spent/unspent status (possibly structurally
as mentioned elsewhere in this thread). It's probably also valuable to commit
to the scriptPubKey, nValue, as well, though technically that's redundant as
the txid already commits to that (there's some implementation options here).

> It's totally reasonable for full nodes to independently update and
> recalculate the utxo set as part of their validation process. The same
> can't be done for a balanced version of the txo set because it's too big.

Why would you commit to a balanced version of the TXO set? I'm proposing
committing to an insertion-ordered list, indexed by txout #.

> Relying on proofs as a crutch for using the full txo set would badly
> exacerbate the already extant problem of miners doing spv mining, and
> increase the bandwidth a full validating node had to use by a multiple.
> 
> This whole conversation is badly sidetracked. If people have comments on my
> merkle set I'd like to engage further with them, but mmrs need to be argued
> independently on their own merits before being used as a counterpoint to
> utxo commitments.

Hmm? That's exactly what I'm doing. Also, as per the above, I think you've
misunderstood what my TXO commitment proposal is.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/6b0f13f2/attachment.sig>

From bram at bittorrent.com  Fri Feb 24 02:50:10 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Thu, 23 Feb 2017 18:50:10 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170224010943.GA29218@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
Message-ID: <CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>

On Thu, Feb 23, 2017 at 5:09 PM, Peter Todd <pete at petertodd.org> wrote:

> I think you've misunderstood what TXO commitments are. From my article:
>
> "A merkle tree committing to the state of all transaction outputs, both
> spent
> and unspent, can provide a method of compactly proving the current state
> of an
> output."
> -https://petertodd.org/2016/delayed-txo-commitments#txo-commitments:
>

The proposal on that page is of a tree which does require random access
updates, it just positions entries in the order they happened to be added
instead of sorting by their hash. Once you start updating it to indicate
spent status all the exact same issues of TXO size and cache coherence on
updates show up again, but now you're using a more complex bespoke data
structure instead of a basic fundamental one.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/e1b6fe16/attachment.html>

From pete at petertodd.org  Fri Feb 24 02:58:11 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 21:58:11 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
Message-ID: <20170224025811.GA31911@savin.petertodd.org>

On Thu, Feb 23, 2017 at 06:50:10PM -0800, Bram Cohen wrote:
> On Thu, Feb 23, 2017 at 5:09 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > I think you've misunderstood what TXO commitments are. From my article:
> >
> > "A merkle tree committing to the state of all transaction outputs, both
> > spent
> > and unspent, can provide a method of compactly proving the current state
> > of an
> > output."
> > -https://petertodd.org/2016/delayed-txo-commitments#txo-commitments:
> >
> 
> The proposal on that page is of a tree which does require random access
> updates, it just positions entries in the order they happened to be added
> instead of sorting by their hash. Once you start updating it to indicate
> spent status all the exact same issues of TXO size and cache coherence on
> updates show up again, but now you're using a more complex bespoke data
> structure instead of a basic fundamental one.

Sorry, but I was replying to your statement:

> What you can't do with MMRs or the blockchain is make a compact proof that
> something is still in the utxo set, which is the whole point of utxo
> commitments.

So to be clear, do you agree or disagree with me that you *can* extract a
compact proof from a MMR that a given output is unspent?

I just want to make sure we're on the same page here before we discuss
performance characteristics.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/5d17c853/attachment.sig>

From bram at bittorrent.com  Fri Feb 24 03:02:36 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Thu, 23 Feb 2017 19:02:36 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170224025811.GA31911@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
Message-ID: <CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>

On Thu, Feb 23, 2017 at 6:58 PM, Peter Todd <pete at petertodd.org> wrote:

>
> So to be clear, do you agree or disagree with me that you *can* extract a
> compact proof from a MMR that a given output is unspent?
>

After wading through your logic on how updates are done, I agree that that
can be done, but apples to apples compact proofs can also be done in a utxo
commitment, and proofs of the validity of updates can be done in a utxo
commitment, so there isn't any performance advantage to all that extra
complexity.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/a93584fd/attachment.html>

From pete at petertodd.org  Fri Feb 24 03:15:31 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 22:15:31 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
Message-ID: <20170224031531.GA32118@savin.petertodd.org>

On Thu, Feb 23, 2017 at 07:02:36PM -0800, Bram Cohen wrote:
> On Thu, Feb 23, 2017 at 6:58 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> >
> > So to be clear, do you agree or disagree with me that you *can* extract a
> > compact proof from a MMR that a given output is unspent?
> >
> 
> After wading through your logic on how updates are done, I agree that that
> can be done, but apples to apples compact proofs can also be done in a utxo
> commitment, and proofs of the validity of updates can be done in a utxo
> commitment, so there isn't any performance advantage to all that extra
> complexity.

Glad we're on the same page with regard to what's possible in TXO commitments.

Secondly, am I correct in saying your UTXO commitments scheme requires random
access? While you describe it as a "merkle set", obviously to be merkelized
it'll have to have an ordering of some kind. What do you propose that ordering
to be?

Maybe more specifically, what exact values do you propose to be in the set?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/4f1075da/attachment-0001.sig>

From bram at bittorrent.com  Fri Feb 24 03:32:43 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Thu, 23 Feb 2017 19:32:43 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170224031531.GA32118@savin.petertodd.org>
References: <20170223011506.GC905@savin.petertodd.org>
	<CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
Message-ID: <CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>

On Thu, Feb 23, 2017 at 7:15 PM, Peter Todd <pete at petertodd.org> wrote:

>
> Glad we're on the same page with regard to what's possible in TXO
> commitments.
>
> Secondly, am I correct in saying your UTXO commitments scheme requires
> random
> access? While you describe it as a "merkle set", obviously to be merkelized
> it'll have to have an ordering of some kind. What do you propose that
> ordering
> to be?
>

The ordering is by the bits in the hash. Technically it's a Patricia Trie.
I'm using 'merkle tree' to refer to basically anything with a hash root.


> Maybe more specifically, what exact values do you propose to be in the set?
>
>
That is unspecified in the implementation, it just takes a 256 bit value
which is presumably a hash of something. The intention is to nail down a
simple format and demonstrate good performance and leave those semantics to
a higher layer. The simplest thing would be to hash together the txid and
output number.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/ebb642c9/attachment.html>

From pete at petertodd.org  Fri Feb 24 04:36:13 2017
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Feb 2017 23:36:13 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
References: <CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
Message-ID: <20170224043613.GA32502@savin.petertodd.org>

On Thu, Feb 23, 2017 at 07:32:43PM -0800, Bram Cohen wrote:
> On Thu, Feb 23, 2017 at 7:15 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> >
> > Glad we're on the same page with regard to what's possible in TXO
> > commitments.
> >
> > Secondly, am I correct in saying your UTXO commitments scheme requires
> > random
> > access? While you describe it as a "merkle set", obviously to be merkelized
> > it'll have to have an ordering of some kind. What do you propose that
> > ordering
> > to be?
> >
> 
> The ordering is by the bits in the hash. Technically it's a Patricia Trie.
> I'm using 'merkle tree' to refer to basically anything with a hash root.

The hash of what? The values in the set?

> > Maybe more specifically, what exact values do you propose to be in the set?
> >
> >
> That is unspecified in the implementation, it just takes a 256 bit value
> which is presumably a hash of something. The intention is to nail down a
> simple format and demonstrate good performance and leave those semantics to
> a higher layer. The simplest thing would be to hash together the txid and
> output number.

Ok, so let's assume the values in the set are the unspent outpoints.

Since we're ordering by the hash of the values in the set, outpoints will be
distributed uniformly in the set, and thus the access pattern of data in the
set is uniform.

Now let's fast-forward 10 years. For the sake of argument, assume that for
every 1 UTXO in the set that corresponds to funds in someone's wallet that are
likely to be spent, there are 2^12 = 4096 UTXO's that have been permanently
lost (and/or created in spam attacks) and thus will never be spent.

Since lost UTXO's are *also* uniformly distributed, if I'm processing a new
block that spends 2^12 = 4096 UTXO's, on average for each UTXO spent, I'll
have to update log2(4096) = 12 more digests than I would have had those "dead"
UTXO's not existed.

Concretely, imagine our UTXO set had just 8 values in it, and we were updating
two of them:

               #
              / \
             /   \
            /     \
           /       \
          /         \
         #           #
        / \         / \
       /   \       /   \
      #     .     .     #
     / \   / \   / \   / \
    .   X .   . .   . X   .

To mark two coins as spent, we've had to update 5 inner nodes.


Now let's look at what happens in an insertion-ordered TXO commitment scheme.
For sake of argument, let's assume the best possible case, where every UTXO
spent in that same block was recently created. Since the UTXO's are recently
created, chances are almost every single one of those "dead" UTXO's will have
been created in the past. Thus, since this is an insertion-ordered data
structure, those UTXO's exist in an older part of the data structure that our
new block doesn't need to modify at all.

Concretely, again let's imagine a TXO commitment with 8 values in it, and two
of them being spent:

               #
              / \
             /   \
            /     \
           /       \
          /         \
         .           #
        / \         / \
       /   \       /   \
      .     .     .     #
     / \   / \   / \   / \
    .   . .   . .   . X   X

To mark two coins as spent, we've only had to update 3 inner nodes; while our
tree is higher with those lost coins, those extra inner nodes are amortised
across all the coins we have to update.


The situation gets even better when we look at the *new* UTXO's that our block
creates. Suppose our UTXO set has size n. To mark a single coin as spent, we
have to update log2(n) inner nodes. We do get to amortise this a bit at the top
levels in the tree, but even if we assume the amortisation is totally free,
we're updating at least log2(n) - log2(m) inner nodes "under" the amortised
nodes at the top of the tree for *each* new node.

Meanwhile with an insertion-ordered TXO commitment, each new UTXO added to the
data set goes in the same place - the end. So almost none of the existing data
needs to be touched to add the new UTXOs. Equally, the hashing required for the
new UTXO's can be done in an incremental fashion that's very L1/L2 cache
friendly.


tl;dr: Precisely because access patterns in TXO commitments are *not* uniform,
I think we'll find that from a L1/L2/etc cache perspective alone, TXO
commitments will result in better performance than UTXO commitments.


Now it is true that Bitcoin's current design means we'll need a map of
confirmed outpoints to TXO insertion order indexes. But it's not particularly
hard to add that "metadata" to transactions on the P2P layer in the same way
that segwit added witnesses to transactions without modifying how txids were
calculated; if you only connect to peers who provide you with TXO index
information in blocks and transactions, you don't need to keep that map
yourself.

Finally, note how this makes transactions *smaller* in many circumstances: it's
just a 8-byte max index rather than a 40 byte outpoint.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170223/6a611ba3/attachment.sig>

From tim.ruffing at mmci.uni-saarland.de  Fri Feb 24 10:04:54 2017
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Fri, 24 Feb 2017 11:04:54 +0100
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <76fa5d76-6c54-e13e-7b55-a4409ef536f5@gmail.com>
References: <20170223181409.GA6085@savin.petertodd.org>
	<20170223212802.GA7608@savin.petertodd.org>
	<76fa5d76-6c54-e13e-7b55-a4409ef536f5@gmail.com>
Message-ID: <1487930694.1528.1.camel@mmci.uni-saarland.de>

On Fri, 2017-02-24 at 00:57 +0100, Aymeric Vitte via bitcoin-dev wrote:
> 
> I have not worked on this since some time, so that's just thoughts,
> but maybe it can render things much more difficult
> than???????computing two files until the same hash is found
> 

You basically rely on the idea that specific collisions are more
difficult to find.?This trick or similar tricks will not help.?(And
actually, the more files you add to the hash, the more freedom you give
the attacker.)

Even if certain collisions are more difficult to find today (which is
certainly true), the general rule is that someone will prove you wrong
in a year.

Even if ignore security entirely, switching to new hash function is
much simpler trying to fix the usage of a broken hash function.

Relying on SHA1 is hopeless. We have to get rid of it.

Best,
Tim




From vitteaymeric at gmail.com  Fri Feb 24 15:18:43 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 24 Feb 2017 16:18:43 +0100
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <1487930694.1528.1.camel@mmci.uni-saarland.de>
References: <20170223181409.GA6085@savin.petertodd.org>
	<20170223212802.GA7608@savin.petertodd.org>
	<76fa5d76-6c54-e13e-7b55-a4409ef536f5@gmail.com>
	<1487930694.1528.1.camel@mmci.uni-saarland.de>
Message-ID: <15848c1b-2873-35e8-0588-c636126257df@gmail.com>

Not sure that you really read deeply what I sent, because stating that
hashing files continuously instead of hashing the intermediate steps
just gives more latitude to the attacker can't be true when the attacker
has absolutely no control over the past files

I did not write this as a workaround to fix SHA1, which will be dead
soon or later but as maybe some general concept that could possibly help
whatever hash function you are using for objects that are not frozen but
extending (ie the original email stating that trees might be some kind
of worse candidates for collisions reminded me this), indeed it makes no
sense to patch SHA1 or play around, but this kind of proposal could
accompany the defunct

The drawback is that you have to keep the hash state when you close the
latest hash computation in order to start the next one

Then the question is: knowing the hash state, is it as easy to find a
collision between two files that will be computed in the next round than
finding a collision between two files only?

Knowing that you can probably modify the hash state with some
unpredictable patterns

Most likely the answer is: no, it's (astronomically?) more difficult

Please take it as a suggestion that might be explored (ps: I have the
code for this if needed) rather than an affirmation, still amazed as
shown in the few links provided (among others) that each time I raise
this subject nobody really pays attention (what's the use case?, etc)
and by the fact that it's apparently used by only one project in the
world and not supported by any library


Le 24/02/2017 ? 11:04, Tim Ruffing via bitcoin-dev a ?crit :
> On Fri, 2017-02-24 at 00:57 +0100, Aymeric Vitte via bitcoin-dev wrote:
>> I have not worked on this since some time, so that's just thoughts,
>> but maybe it can render things much more difficult
>> than       computing two files until the same hash is found
>>
> You basically rely on the idea that specific collisions are more
> difficult to find. This trick or similar tricks will not help. (And
> actually, the more files you add to the hash, the more freedom you give
> the attacker.)
>
> Even if certain collisions are more difficult to find today (which is
> certainly true), the general rule is that someone will prove you wrong
> in a year.
>
> Even if ignore security entirely, switching to new hash function is
> much simpler trying to fix the usage of a broken hash function.
>
> Relying on SHA1 is hopeless. We have to get rid of it.
>
> Best,
> Tim
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From tim.ruffing at mmci.uni-saarland.de  Fri Feb 24 16:30:49 2017
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Fri, 24 Feb 2017 17:30:49 +0100
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <15848c1b-2873-35e8-0588-c636126257df@gmail.com>
References: <20170223181409.GA6085@savin.petertodd.org>
	<20170223212802.GA7608@savin.petertodd.org>
	<76fa5d76-6c54-e13e-7b55-a4409ef536f5@gmail.com>
	<1487930694.1528.1.camel@mmci.uni-saarland.de>
	<15848c1b-2873-35e8-0588-c636126257df@gmail.com>
Message-ID: <1487953849.5148.2.camel@mmci.uni-saarland.de>

On Fri, 2017-02-24 at 16:18 +0100, Aymeric Vitte via bitcoin-dev wrote:
> Not sure that you really read deeply what I sent, because stating
> that
> hashing files continuously instead of hashing the intermediate steps
> just gives more latitude to the attacker can't be true when the
> attacker
> has absolutely no control over the past files
What prevents the attacker to provide different past files when talking
to parties who are still in the initial state?

Then the question is: knowing the hash state, is it as easy to find a
> collision between two files that will be computed in the next round
> than
> finding a collision between two files only?
With the original usage of the hash function, the hash state is always
the initial state. Now that the attacker has some control over the hash
state even. In other words, if the original use of the hash function
was vulnerable, then your scheme is vulnerable for the initial state.

Concrete attack: If you can find x != y with H(x) = H(y), then you can
also find m, x != y, with H(m||x) = H(m||y), just by setting m = "". 

Not sure if this is the right place to discuss that issue though...

Best,
Tim

From vitteaymeric at gmail.com  Fri Feb 24 17:29:50 2017
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 24 Feb 2017 18:29:50 +0100
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <1487953849.5148.2.camel@mmci.uni-saarland.de>
References: <20170223181409.GA6085@savin.petertodd.org>
	<20170223212802.GA7608@savin.petertodd.org>
	<76fa5d76-6c54-e13e-7b55-a4409ef536f5@gmail.com>
	<1487930694.1528.1.camel@mmci.uni-saarland.de>
	<15848c1b-2873-35e8-0588-c636126257df@gmail.com>
	<1487953849.5148.2.camel@mmci.uni-saarland.de>
Message-ID: <b557a0de-2492-80a1-eff7-229503ae382d@gmail.com>

??? apparently we are not discussing the same thing

Maybe I did not provide the right links (reading them again I myself
don't find them so clear), see maybe again
https://github.com/whatwg/streams/issues/33#issuecomment-28045860

a - b - c -d

hash(a)

hash(a+b)

etc

But you are not going to rehash from the beginning, then:

update a --> keep the remaining bytes a_ (+ hash state 1) --> digest
a=hash(a)

update a_+b from hash state 1--> keep the remaining bytes b_ (+ hash
state 2) --> digest a_+b=hash(a+b)

etc

Basically that's similar to a real time progressive hash of chunks of a
file that you are streaming and therefore don't know what will come next
(per opposition to hashing a file that you already have), this could
apply to trees

This is different from something like:

hash(a)

hash(hash(a) +hash(b))

etc

There is no initial state, and the attacker can't modify what was
already hashed, to make it more difficult you can probably modify the
hash state N


Le 24/02/2017 ? 17:30, Tim Ruffing via bitcoin-dev a ?crit :
> On Fri, 2017-02-24 at 16:18 +0100, Aymeric Vitte via bitcoin-dev wrote:
>> Not sure that you really read deeply what I sent, because stating
>> that
>> hashing files continuously instead of hashing the intermediate steps
>> just gives more latitude to the attacker can't be true when the
>> attacker
>> has absolutely no control over the past files
> What prevents the attacker to provide different past files when talking
> to parties who are still in the initial state?
>
> Then the question is: knowing the hash state, is it as easy to find a
>> collision between two files that will be computed in the next round
>> than
>> finding a collision between two files only?
> With the original usage of the hash function, the hash state is always
> the initial state. Now that the attacker has some control over the hash
> state even. In other words, if the original use of the hash function
> was vulnerable, then your scheme is vulnerable for the initial state.
>
> Concrete attack: If you can find x != y with H(x) = H(y), then you can
> also find m, x != y, with H(m||x) = H(m||y), just by setting m = "". 
>
> Not sure if this is the right place to discuss that issue though...
>
> Best,
> Tim
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From bram at bittorrent.com  Fri Feb 24 22:20:19 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Fri, 24 Feb 2017 14:20:19 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170224043613.GA32502@savin.petertodd.org>
References: <CAAcC9ys5sUxVfOjogFiF3gzk51D_L=QQkOYevTH=qbh_RkA3Hw@mail.gmail.com>
	<CA+KqGkrUneGe4yORi=JAAWzoO0UftMUuJm3S-__W5sBh-+T1vQ@mail.gmail.com>
	<20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
	<20170224043613.GA32502@savin.petertodd.org>
Message-ID: <CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>

So your idea is to cluster entries by entry time because newer things are
more likely to leave and updating multiple things near each other is
cheaper?

That can be done with my tool. Instead of using hashes for the values being
stored, you use position entries. The first entry gets a value of all
zeros, the next one a one followed by all zeros, then the next two
correspond to the first two with the second bit flipped to one, then the
next four the first four with the third bit flipped to one, etc. It
probably performs a little bit better to do it two bits at a time instead
of one so that the entries are 00, 01, 10, 11, 0001, 0010, 0011, 0101,
0110, 0111, 1001, etc. If you were to really use this you'd probably want
to to add some optimizations to use the fact that the terminals fit in 64
bits instead of 256, but it mostly works unchanged, and gets whatever
benefits there are to this clustering plus the high performance
implementation tricks I've built which I keep complaining that nobody's
giving feedback on.

I'm not sold on this being a win: The empirical access patterns are
unknown, it requires an extra cache miss per lookup to find the entry
number, it may be that everything is optimized well enough without it for
there to be no meaningful gains, and it's a bunch of extra complexity. What
should be done is that a plain vanilla UTXO set solution is optimized as
well as it can be first, and then the insertion ordering trick is tried as
an optimization to see if it's an improvement. Without that baseline
there's no meaningful basis for comparison, and I'm quite confident that a
naive implementation which just allocates individual nodes will
underperform the thing I've come up with, even without adding optimizations
related to fitting in 64 bits.

On Thu, Feb 23, 2017 at 8:36 PM, Peter Todd <pete at petertodd.org> wrote:

> On Thu, Feb 23, 2017 at 07:32:43PM -0800, Bram Cohen wrote:
> > On Thu, Feb 23, 2017 at 7:15 PM, Peter Todd <pete at petertodd.org> wrote:
> >
> > >
> > > Glad we're on the same page with regard to what's possible in TXO
> > > commitments.
> > >
> > > Secondly, am I correct in saying your UTXO commitments scheme requires
> > > random
> > > access? While you describe it as a "merkle set", obviously to be
> merkelized
> > > it'll have to have an ordering of some kind. What do you propose that
> > > ordering
> > > to be?
> > >
> >
> > The ordering is by the bits in the hash. Technically it's a Patricia
> Trie.
> > I'm using 'merkle tree' to refer to basically anything with a hash root.
>
> The hash of what? The values in the set?
>
> > > Maybe more specifically, what exact values do you propose to be in the
> set?
> > >
> > >
> > That is unspecified in the implementation, it just takes a 256 bit value
> > which is presumably a hash of something. The intention is to nail down a
> > simple format and demonstrate good performance and leave those semantics
> to
> > a higher layer. The simplest thing would be to hash together the txid and
> > output number.
>
> Ok, so let's assume the values in the set are the unspent outpoints.
>
> Since we're ordering by the hash of the values in the set, outpoints will
> be
> distributed uniformly in the set, and thus the access pattern of data in
> the
> set is uniform.
>
> Now let's fast-forward 10 years. For the sake of argument, assume that for
> every 1 UTXO in the set that corresponds to funds in someone's wallet that
> are
> likely to be spent, there are 2^12 = 4096 UTXO's that have been permanently
> lost (and/or created in spam attacks) and thus will never be spent.
>
> Since lost UTXO's are *also* uniformly distributed, if I'm processing a new
> block that spends 2^12 = 4096 UTXO's, on average for each UTXO spent, I'll
> have to update log2(4096) = 12 more digests than I would have had those
> "dead"
> UTXO's not existed.
>
> Concretely, imagine our UTXO set had just 8 values in it, and we were
> updating
> two of them:
>
>                #
>               / \
>              /   \
>             /     \
>            /       \
>           /         \
>          #           #
>         / \         / \
>        /   \       /   \
>       #     .     .     #
>      / \   / \   / \   / \
>     .   X .   . .   . X   .
>
> To mark two coins as spent, we've had to update 5 inner nodes.
>
>
> Now let's look at what happens in an insertion-ordered TXO commitment
> scheme.
> For sake of argument, let's assume the best possible case, where every UTXO
> spent in that same block was recently created. Since the UTXO's are
> recently
> created, chances are almost every single one of those "dead" UTXO's will
> have
> been created in the past. Thus, since this is an insertion-ordered data
> structure, those UTXO's exist in an older part of the data structure that
> our
> new block doesn't need to modify at all.
>
> Concretely, again let's imagine a TXO commitment with 8 values in it, and
> two
> of them being spent:
>
>                #
>               / \
>              /   \
>             /     \
>            /       \
>           /         \
>          .           #
>         / \         / \
>        /   \       /   \
>       .     .     .     #
>      / \   / \   / \   / \
>     .   . .   . .   . X   X
>
> To mark two coins as spent, we've only had to update 3 inner nodes; while
> our
> tree is higher with those lost coins, those extra inner nodes are amortised
> across all the coins we have to update.
>
>
> The situation gets even better when we look at the *new* UTXO's that our
> block
> creates. Suppose our UTXO set has size n. To mark a single coin as spent,
> we
> have to update log2(n) inner nodes. We do get to amortise this a bit at
> the top
> levels in the tree, but even if we assume the amortisation is totally free,
> we're updating at least log2(n) - log2(m) inner nodes "under" the amortised
> nodes at the top of the tree for *each* new node.
>
> Meanwhile with an insertion-ordered TXO commitment, each new UTXO added to
> the
> data set goes in the same place - the end. So almost none of the existing
> data
> needs to be touched to add the new UTXOs. Equally, the hashing required
> for the
> new UTXO's can be done in an incremental fashion that's very L1/L2 cache
> friendly.
>
>
> tl;dr: Precisely because access patterns in TXO commitments are *not*
> uniform,
> I think we'll find that from a L1/L2/etc cache perspective alone, TXO
> commitments will result in better performance than UTXO commitments.
>
>
> Now it is true that Bitcoin's current design means we'll need a map of
> confirmed outpoints to TXO insertion order indexes. But it's not
> particularly
> hard to add that "metadata" to transactions on the P2P layer in the same
> way
> that segwit added witnesses to transactions without modifying how txids
> were
> calculated; if you only connect to peers who provide you with TXO index
> information in blocks and transactions, you don't need to keep that map
> yourself.
>
> Finally, note how this makes transactions *smaller* in many circumstances:
> it's
> just a 8-byte max index rather than a 40 byte outpoint.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170224/63ab2731/attachment-0001.html>

From steven.charles.davis at gmail.com  Fri Feb 24 23:49:36 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Fri, 24 Feb 2017 17:49:36 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>

If the 20 byte SHA1 is now considered insecure (with good reason), what about RIPEMD-160 which is the foundation of Bitcoin addresses?

Is that also susceptible to such an attack vector?

What does that mean for old addresses?

etc

/s


> Date: Fri, 24 Feb 2017 11:04:54 +0100
> From: Tim Ruffing <tim.ruffing at mmci.uni-saarland.de>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] SHA1 collisions make Git vulnerable to
> 	attakcs by third-parties, not just repo maintainers
> Message-ID: <1487930694.1528.1.camel at mmci.uni-saarland.de>
> Content-Type: text/plain; charset="UTF-8"
> 
> On Fri, 2017-02-24 at 00:57 +0100, Aymeric Vitte via bitcoin-dev wrote:
>> 
>> I have not worked on this since some time, so that's just thoughts,
>> but maybe it can render things much more difficult
>> than???????computing two files until the same hash is found
>> 
> 
> You basically rely on the idea that specific collisions are more
> difficult to find.?This trick or similar tricks will not help.?(And
> actually, the more files you add to the hash, the more freedom you give
> the attacker.)
> 
> Even if certain collisions are more difficult to find today (which is
> certainly true), the general rule is that someone will prove you wrong
> in a year.
> 
> Even if ignore security entirely, switching to new hash function is
> much simpler trying to fix the usage of a broken hash function.
> 
> Relying on SHA1 is hopeless. We have to get rid of it.
> 
> Best,
> Tim
> 
> 
> 
> 
> 
> ------------------------------
> 
> Message: 2
> Date: Fri, 24 Feb 2017 16:18:43 +0100
> From: Aymeric Vitte <vitteaymeric at gmail.com>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] SHA1 collisions make Git vulnerable to
> 	attakcs by third-parties, not just repo maintainers
> Message-ID: <15848c1b-2873-35e8-0588-c636126257df at gmail.com>
> Content-Type: text/plain; charset=utf-8
> 
> Not sure that you really read deeply what I sent, because stating that
> hashing files continuously instead of hashing the intermediate steps
> just gives more latitude to the attacker can't be true when the attacker
> has absolutely no control over the past files
> 
> I did not write this as a workaround to fix SHA1, which will be dead
> soon or later but as maybe some general concept that could possibly help
> whatever hash function you are using for objects that are not frozen but
> extending (ie the original email stating that trees might be some kind
> of worse candidates for collisions reminded me this), indeed it makes no
> sense to patch SHA1 or play around, but this kind of proposal could
> accompany the defunct
> 
> The drawback is that you have to keep the hash state when you close the
> latest hash computation in order to start the next one
> 
> Then the question is: knowing the hash state, is it as easy to find a
> collision between two files that will be computed in the next round than
> finding a collision between two files only?
> 
> Knowing that you can probably modify the hash state with some
> unpredictable patterns
> 
> Most likely the answer is: no, it's (astronomically?) more difficult
> 
> Please take it as a suggestion that might be explored (ps: I have the
> code for this if needed) rather than an affirmation, still amazed as
> shown in the few links provided (among others) that each time I raise
> this subject nobody really pays attention (what's the use case?, etc)
> and by the fact that it's apparently used by only one project in the
> world and not supported by any library
> 
> 
> Le 24/02/2017 ? 11:04, Tim Ruffing via bitcoin-dev a ?crit :
>> On Fri, 2017-02-24 at 00:57 +0100, Aymeric Vitte via bitcoin-dev wrote:
>>> I have not worked on this since some time, so that's just thoughts,
>>> but maybe it can render things much more difficult
>>> than       computing two files until the same hash is found
>>> 
>> You basically rely on the idea that specific collisions are more
>> difficult to find. This trick or similar tricks will not help. (And
>> actually, the more files you add to the hash, the more freedom you give
>> the attacker.)
>> 
>> Even if certain collisions are more difficult to find today (which is
>> certainly true), the general rule is that someone will prove you wrong
>> in a year.
>> 
>> Even if ignore security entirely, switching to new hash function is
>> much simpler trying to fix the usage of a broken hash function.
>> 
>> Relying on SHA1 is hopeless. We have to get rid of it.
>> 
>> Best,
>> Tim
>> 
>> 
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> -- 
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
> 
> 
> 
> ------------------------------
> 
> Message: 3
> Date: Fri, 24 Feb 2017 17:30:49 +0100
> From: Tim Ruffing <tim.ruffing at mmci.uni-saarland.de>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: Re: [bitcoin-dev] SHA1 collisions make Git vulnerable to
> 	attakcs by third-parties, not just repo maintainers
> Message-ID: <1487953849.5148.2.camel at mmci.uni-saarland.de>
> Content-Type: text/plain; charset="UTF-8"
> 
> On Fri, 2017-02-24 at 16:18 +0100, Aymeric Vitte via bitcoin-dev wrote:
>> Not sure that you really read deeply what I sent, because stating
>> that
>> hashing files continuously instead of hashing the intermediate steps
>> just gives more latitude to the attacker can't be true when the
>> attacker
>> has absolutely no control over the past files
> What prevents the attacker to provide different past files when talking
> to parties who are still in the initial state?
> 
> Then the question is: knowing the hash state, is it as easy to find a
>> collision between two files that will be computed in the next round
>> than
>> finding a collision between two files only?
> With the original usage of the hash function, the hash state is always
> the initial state. Now that the attacker has some control over the hash
> state even. In other words, if the original use of the hash function
> was vulnerable, then your scheme is vulnerable for the initial state.
> 
> Concrete attack: If you can find x != y with H(x) = H(y), then you can
> also find m, x != y, with H(m||x) = H(m||y), just by setting m = "". 
> 
> Not sure if this is the right place to discuss that issue though...
> 
> Best,
> Tim
> 
> 
> ------------------------------
> 
> Message: 4
> Date: Fri, 24 Feb 2017 18:29:50 +0100
> From: Aymeric Vitte <vitteaymeric at gmail.com>
> To: Tim Ruffing <tim.ruffing at mmci.uni-saarland.de>,	Bitcoin Protocol
> 	Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] SHA1 collisions make Git vulnerable to
> 	attakcs by third-parties, not just repo maintainers
> Message-ID: <b557a0de-2492-80a1-eff7-229503ae382d at gmail.com>
> Content-Type: text/plain; charset=windows-1252
> 
> ??? apparently we are not discussing the same thing
> 
> Maybe I did not provide the right links (reading them again I myself
> don't find them so clear), see maybe again
> https://github.com/whatwg/streams/issues/33#issuecomment-28045860
> 
> a - b - c -d
> 
> hash(a)
> 
> hash(a+b)
> 
> etc
> 
> But you are not going to rehash from the beginning, then:
> 
> update a --> keep the remaining bytes a_ (+ hash state 1) --> digest
> a=hash(a)
> 
> update a_+b from hash state 1--> keep the remaining bytes b_ (+ hash
> state 2) --> digest a_+b=hash(a+b)
> 
> etc
> 
> Basically that's similar to a real time progressive hash of chunks of a
> file that you are streaming and therefore don't know what will come next
> (per opposition to hashing a file that you already have), this could
> apply to trees
> 
> This is different from something like:
> 
> hash(a)
> 
> hash(hash(a) +hash(b))
> 
> etc
> 
> There is no initial state, and the attacker can't modify what was
> already hashed, to make it more difficult you can probably modify the
> hash state N
> 
> 
> Le 24/02/2017 ? 17:30, Tim Ruffing via bitcoin-dev a ?crit :
>> On Fri, 2017-02-24 at 16:18 +0100, Aymeric Vitte via bitcoin-dev wrote:
>>> Not sure that you really read deeply what I sent, because stating
>>> that
>>> hashing files continuously instead of hashing the intermediate steps
>>> just gives more latitude to the attacker can't be true when the
>>> attacker
>>> has absolutely no control over the past files
>> What prevents the attacker to provide different past files when talking
>> to parties who are still in the initial state?
>> 
>> Then the question is: knowing the hash state, is it as easy to find a
>>> collision between two files that will be computed in the next round
>>> than
>>> finding a collision between two files only?
>> With the original usage of the hash function, the hash state is always
>> the initial state. Now that the attacker has some control over the hash
>> state even. In other words, if the original use of the hash function
>> was vulnerable, then your scheme is vulnerable for the initial state.
>> 
>> Concrete attack: If you can find x != y with H(x) = H(y), then you can
>> also find m, x != y, with H(m||x) = H(m||y), just by setting m = "". 
>> 
>> Not sure if this is the right place to discuss that issue though...
>> 
>> Best,
>> Tim
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> -- 
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms
> 
> 
> 
> ------------------------------
> 
> Message: 5
> Date: Fri, 24 Feb 2017 14:20:19 -0800
> From: Bram Cohen <bram at bittorrent.com>
> To: Peter Todd <pete at petertodd.org>
> Cc: Bitcoin Protocol Discussion
> 	<bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] A Better MMR Definition
> Message-ID:
> 	<CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
> 
> So your idea is to cluster entries by entry time because newer things are
> more likely to leave and updating multiple things near each other is
> cheaper?
> 
> That can be done with my tool. Instead of using hashes for the values being
> stored, you use position entries. The first entry gets a value of all
> zeros, the next one a one followed by all zeros, then the next two
> correspond to the first two with the second bit flipped to one, then the
> next four the first four with the third bit flipped to one, etc. It
> probably performs a little bit better to do it two bits at a time instead
> of one so that the entries are 00, 01, 10, 11, 0001, 0010, 0011, 0101,
> 0110, 0111, 1001, etc. If you were to really use this you'd probably want
> to to add some optimizations to use the fact that the terminals fit in 64
> bits instead of 256, but it mostly works unchanged, and gets whatever
> benefits there are to this clustering plus the high performance
> implementation tricks I've built which I keep complaining that nobody's
> giving feedback on.
> 
> I'm not sold on this being a win: The empirical access patterns are
> unknown, it requires an extra cache miss per lookup to find the entry
> number, it may be that everything is optimized well enough without it for
> there to be no meaningful gains, and it's a bunch of extra complexity. What
> should be done is that a plain vanilla UTXO set solution is optimized as
> well as it can be first, and then the insertion ordering trick is tried as
> an optimization to see if it's an improvement. Without that baseline
> there's no meaningful basis for comparison, and I'm quite confident that a
> naive implementation which just allocates individual nodes will
> underperform the thing I've come up with, even without adding optimizations
> related to fitting in 64 bits.
> 
> On Thu, Feb 23, 2017 at 8:36 PM, Peter Todd <pete at petertodd.org> wrote:
> 
>> On Thu, Feb 23, 2017 at 07:32:43PM -0800, Bram Cohen wrote:
>>> On Thu, Feb 23, 2017 at 7:15 PM, Peter Todd <pete at petertodd.org> wrote:
>>> 
>>>> 
>>>> Glad we're on the same page with regard to what's possible in TXO
>>>> commitments.
>>>> 
>>>> Secondly, am I correct in saying your UTXO commitments scheme requires
>>>> random
>>>> access? While you describe it as a "merkle set", obviously to be
>> merkelized
>>>> it'll have to have an ordering of some kind. What do you propose that
>>>> ordering
>>>> to be?
>>>> 
>>> 
>>> The ordering is by the bits in the hash. Technically it's a Patricia
>> Trie.
>>> I'm using 'merkle tree' to refer to basically anything with a hash root.
>> 
>> The hash of what? The values in the set?
>> 
>>>> Maybe more specifically, what exact values do you propose to be in the
>> set?
>>>> 
>>>> 
>>> That is unspecified in the implementation, it just takes a 256 bit value
>>> which is presumably a hash of something. The intention is to nail down a
>>> simple format and demonstrate good performance and leave those semantics
>> to
>>> a higher layer. The simplest thing would be to hash together the txid and
>>> output number.
>> 
>> Ok, so let's assume the values in the set are the unspent outpoints.
>> 
>> Since we're ordering by the hash of the values in the set, outpoints will
>> be
>> distributed uniformly in the set, and thus the access pattern of data in
>> the
>> set is uniform.
>> 
>> Now let's fast-forward 10 years. For the sake of argument, assume that for
>> every 1 UTXO in the set that corresponds to funds in someone's wallet that
>> are
>> likely to be spent, there are 2^12 = 4096 UTXO's that have been permanently
>> lost (and/or created in spam attacks) and thus will never be spent.
>> 
>> Since lost UTXO's are *also* uniformly distributed, if I'm processing a new
>> block that spends 2^12 = 4096 UTXO's, on average for each UTXO spent, I'll
>> have to update log2(4096) = 12 more digests than I would have had those
>> "dead"
>> UTXO's not existed.
>> 
>> Concretely, imagine our UTXO set had just 8 values in it, and we were
>> updating
>> two of them:
>> 
>>               #
>>              / \
>>             /   \
>>            /     \
>>           /       \
>>          /         \
>>         #           #
>>        / \         / \
>>       /   \       /   \
>>      #     .     .     #
>>     / \   / \   / \   / \
>>    .   X .   . .   . X   .
>> 
>> To mark two coins as spent, we've had to update 5 inner nodes.
>> 
>> 
>> Now let's look at what happens in an insertion-ordered TXO commitment
>> scheme.
>> For sake of argument, let's assume the best possible case, where every UTXO
>> spent in that same block was recently created. Since the UTXO's are
>> recently
>> created, chances are almost every single one of those "dead" UTXO's will
>> have
>> been created in the past. Thus, since this is an insertion-ordered data
>> structure, those UTXO's exist in an older part of the data structure that
>> our
>> new block doesn't need to modify at all.
>> 
>> Concretely, again let's imagine a TXO commitment with 8 values in it, and
>> two
>> of them being spent:
>> 
>>               #
>>              / \
>>             /   \
>>            /     \
>>           /       \
>>          /         \
>>         .           #
>>        / \         / \
>>       /   \       /   \
>>      .     .     .     #
>>     / \   / \   / \   / \
>>    .   . .   . .   . X   X
>> 
>> To mark two coins as spent, we've only had to update 3 inner nodes; while
>> our
>> tree is higher with those lost coins, those extra inner nodes are amortised
>> across all the coins we have to update.
>> 
>> 
>> The situation gets even better when we look at the *new* UTXO's that our
>> block
>> creates. Suppose our UTXO set has size n. To mark a single coin as spent,
>> we
>> have to update log2(n) inner nodes. We do get to amortise this a bit at
>> the top
>> levels in the tree, but even if we assume the amortisation is totally free,
>> we're updating at least log2(n) - log2(m) inner nodes "under" the amortised
>> nodes at the top of the tree for *each* new node.
>> 
>> Meanwhile with an insertion-ordered TXO commitment, each new UTXO added to
>> the
>> data set goes in the same place - the end. So almost none of the existing
>> data
>> needs to be touched to add the new UTXOs. Equally, the hashing required
>> for the
>> new UTXO's can be done in an incremental fashion that's very L1/L2 cache
>> friendly.
>> 
>> 
>> tl;dr: Precisely because access patterns in TXO commitments are *not*
>> uniform,
>> I think we'll find that from a L1/L2/etc cache perspective alone, TXO
>> commitments will result in better performance than UTXO commitments.
>> 
>> 
>> Now it is true that Bitcoin's current design means we'll need a map of
>> confirmed outpoints to TXO insertion order indexes. But it's not
>> particularly
>> hard to add that "metadata" to transactions on the P2P layer in the same
>> way
>> that segwit added witnesses to transactions without modifying how txids
>> were
>> calculated; if you only connect to peers who provide you with TXO index
>> information in blocks and transactions, you don't need to keep that map
>> yourself.
>> 
>> Finally, note how this makes transactions *smaller* in many circumstances:
>> it's
>> just a 8-byte max index rather than a 40 byte outpoint.
>> 
>> --
>> https://petertodd.org 'peter'[:-1]@petertodd.org
>> 
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170224/63ab2731/attachment.html>
> 
> ------------------------------
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> End of bitcoin-dev Digest, Vol 21, Issue 34
> *******************************************


From pete at petertodd.org  Sat Feb 25 01:01:22 2017
From: pete at petertodd.org (Peter Todd)
Date: Fri, 24 Feb 2017 20:01:22 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
Message-ID: <20170225010122.GA10233@savin.petertodd.org>

On Fri, Feb 24, 2017 at 05:49:36PM -0600, Steve Davis via bitcoin-dev wrote:
> If the 20 byte SHA1 is now considered insecure (with good reason), what about RIPEMD-160 which is the foundation of Bitcoin addresses?

SHA1 is insecure because the SHA1 algorithm is insecure, not because 160bits isn't enough.

AFAIK there aren't any known weaknesses in RIPEMD160, but it also hasn't been
as closely studied as more common hash algorithms. That said, Bitcoin uses
RIPEMD160(SHA256(msg)), which may make creating collisions harder if an attack
is found than if it used RIPEMD160 alone.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170224/85794f98/attachment.sig>

From pete at petertodd.org  Sat Feb 25 04:12:02 2017
From: pete at petertodd.org (Peter Todd)
Date: Fri, 24 Feb 2017 23:12:02 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>
References: <20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
	<20170224043613.GA32502@savin.petertodd.org>
	<CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>
Message-ID: <20170225041202.GA11152@savin.petertodd.org>

On Fri, Feb 24, 2017 at 02:20:19PM -0800, Bram Cohen wrote:
> So your idea is to cluster entries by entry time because newer things are
> more likely to leave and updating multiple things near each other is
> cheaper?

Yes, exactly.

> That can be done with my tool. Instead of using hashes for the values being
> stored, you use position entries. The first entry gets a value of all
> zeros, the next one a one followed by all zeros, then the next two
> correspond to the first two with the second bit flipped to one, then the
> next four the first four with the third bit flipped to one, etc. It
> probably performs a little bit better to do it two bits at a time instead
> of one so that the entries are 00, 01, 10, 11, 0001, 0010, 0011, 0101,
> 0110, 0111, 1001, etc. If you were to really use this you'd probably want
> to to add some optimizations to use the fact that the terminals fit in 64
> bits instead of 256, but it mostly works unchanged, and gets whatever

So to be clear, what you're proposing there is to use the insertion order as
the index - once you go that far you've almost entirely re-invented my
proposal!

In fact, when I was working my proofchains/proofmarshal libraries I put some
thought into whether or not I could leave out the MMR merkelized list
implementation and use only the key-value map I also wrote. I decided to
include both as they aren't quite the same datastructure - using a list for a
list has advantages.

> benefits there are to this clustering plus the high performance
> implementation tricks I've built which I keep complaining that nobody's
> giving feedback on.

Your merkle-set implementation is 1500 lines of densely written Python with
almost no comments, and less than a 100 lines of (also uncommented) tests. By
comparison, my Python MMR implementation is 300 lines of very readable Python
with lots of comments, a 200 line explanation at the top, and 200 lines of
(commented) tests. Yet no-one is taking the (still considerable) effort to
understand and comment on my implementation. :)

Fact is, what you've written is really daunting to review, and given it's not
in the final language anyway, it's unclear what basis to review it on anyway. I
suspect you'd get more feedback if the codebase was better commented, in a
production language, and you have actual real-world benchmarks and performance
figures.

In particular, while at the top of merkle_set.py you have a list of advantages,
and a bunch of TODO's, you don't explain *why* the code has any of these
advantages. To figure that out, I'd have to read and understand 1500 lines of
densely written Python. Without a human-readable pitch, not many people are
going to do that, myself included.

> I'm not sold on this being a win: The empirical access patterns are
> unknown,

Lost coins alone guarantees that access patterns will be biased towards new
coins being more likely to be spent. That basis alone is sufficient to justify
an insertion-ordered data structure. Additionally, people have done graphs of
the average age of UTXO's when spent, and that data clearly shows that newer
coins are more likely to be spent than older coins.

> unknown, it requires an extra cache miss per lookup to find the entry
> number,

Like I mentioned in the email you're replying to, that extra lookup can be
easily avoided with a change to how transactions/blocks are serialized; if all
your peers support TXO commitments you can even discard the lookup database
entirely, as it's only a backwards compatibility measure.

> it may be that everything is optimized well enough without it for
> there to be no meaningful gains, and it's a bunch of extra complexity. What

Optimization is itself extra complexity. If you're data structure has worse
inherent performance, and you have to make up the different with a highly
optimized implementation, that's likely to lead to more overall complexity than
using a data structure with better inherent performance.

Your current merkle-set implementation definitely _is_ very complex. An
apples-to-apples comparison is with my merkelized key:value tree(1), also a
patricia tree, which like the MMR is only about 300 lines of well-commented and
straight-forward code.

1) https://github.com/proofchains/python-proofmarshal/blob/master/proofmarshal/merbinnertree.py

> should be done is that a plain vanilla UTXO set solution is optimized as
> well as it can be first, and then the insertion ordering trick is tried as
> an optimization to see if it's an improvement. Without that baseline
> there's no meaningful basis for comparison, and I'm quite confident that a
> naive implementation which just allocates individual nodes will
> underperform the thing I've come up with, even without adding optimizations
> related to fitting in 64 bits.

To be clear, "insertion ordering" isn't a simple trick, it's a fundamental
change to what the data structure is. Once you do that, you're talking about my
proposal.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170224/9ad10e61/attachment-0001.sig>

From bram at bittorrent.com  Sat Feb 25 06:23:20 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Fri, 24 Feb 2017 22:23:20 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <20170225041202.GA11152@savin.petertodd.org>
References: <20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
	<20170224043613.GA32502@savin.petertodd.org>
	<CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>
	<20170225041202.GA11152@savin.petertodd.org>
Message-ID: <CA+KqGkqs8F1hK6y-JnLFRpqhQ5i8i+MXVmtGUQBYmE5d1OCAAg@mail.gmail.com>

On Fri, Feb 24, 2017 at 8:12 PM, Peter Todd <pete at petertodd.org> wrote:

>
> So to be clear, what you're proposing there is to use the insertion order
> as
> the index - once you go that far you've almost entirely re-invented my
> proposal!
>

I'm not 'proposing' this, I'm saying it could be done simply but I'm
skeptical of the utility. Probably the most compelling argument for it is
that the insertion indexed values are much smaller so they can be compacted
down a lot resulting in using less memory and more locality and fewer
hashes, but your implementation doesn't take advantage of that.


> Your merkle-set implementation is 1500 lines of densely written Python


The reference implementation which is included in those 1500 lines is less
than 300 lines and fairly straightforward. The non-reference implementation
always behaves semantically identically to the reference implementation, it
just does so faster and using less memory.


> with
> almost no comments,


The comments at the top explain both the proof format and the in-memory
data structures very precisely. The whole codebase was reviewed by a
coworker of mine and comments were added explaining the subtleties which
tripped him up.


> and less than a 100 lines of (also uncommented) tests.


Those tests get 98% code coverage and extensively hit not only the lines of
code but the semantic edge cases as well. The lines which aren't hit are
convenience functions and error conditions of the parsing code for when
it's passed bad data.


> By
> comparison, my Python MMR implementation is 300 lines of very readable
> Python
> with lots of comments, a 200 line explanation at the top, and 200 lines of
> (commented) tests. Yet no-one is taking the (still considerable) effort to
> understand and comment on my implementation. :)
>

Given that maaku's Merkle prefix trees were shelved because of performance
problems despite being written in C and operating in basically the same way
as your code and my reference code, it's clear that non-optimized Python
won't be touching the bitcoin codebase any time soon.


>
> Fact is, what you've written is really daunting to review, and given it's
> not
> in the final language anyway, it's unclear what basis to review it on
> anyway.


It should reviewed based on semantic correctness and performance.
Performance can only be accurately and convincingly determined by porting
to C and optimizing it, which mostly involves experimenting with different
values for the two passed in magic numbers.


> I
> suspect you'd get more feedback if the codebase was better commented, in a
> production language, and you have actual real-world benchmarks and
> performance
> figures.
>

Porting to C should be straightforward. Several people have already
expressed interest in doing so, and it's written in intentionally C-ish
Python, resulting in some rather odd idioms which is a bit part of why you
think it looks 'dense'. A lot of that weird offset math should be much more
readable in C because it's all structs and x.y notation can be used instead
of adding offsets.


> In particular, while at the top of merkle_set.py you have a list of
> advantages,
> and a bunch of TODO's, you don't explain *why* the code has any of these
> advantages. To figure that out, I'd have to read and understand 1500 lines
> of
> densely written Python. Without a human-readable pitch, not many people are
> going to do that, myself included.
>

It's all about cache coherence. When doing operations it pulls in a bunch
of things which are near each other in memory instead of jumping all over
the place. The improvements it gets should be much greater than the ones
gained from insertion ordering, although the two could be accretive.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170224/f104455e/attachment.html>

From steven.charles.davis at gmail.com  Sat Feb 25 12:04:28 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Sat, 25 Feb 2017 06:04:28 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170225010122.GA10233@savin.petertodd.org>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
Message-ID: <208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>


> On Feb 24, 2017, at 7:01 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> On Fri, Feb 24, 2017 at 05:49:36PM -0600, Steve Davis via bitcoin-dev wrote:
>> If the 20 byte SHA1 is now considered insecure (with good reason), what about RIPEMD-160 which is the foundation of Bitcoin addresses?
> 
> SHA1 is insecure because the SHA1 algorithm is insecure, not because 160bits isn't enough.
> 
> AFAIK there aren't any known weaknesses in RIPEMD160,

?so far. I wonder how long that vacation will last?

> but it also hasn't been
> as closely studied as more common hash algorithms.

...but we can be sure that it will be, since the dollar value held in existing utxos continues to increase...

> That said, Bitcoin uses
> RIPEMD160(SHA256(msg)), which may make creating collisions harder if an attack
> is found than if it used RIPEMD160 alone.

Does that offer any greater protection? That?s not so clear to me as the outputs (at least for p2pkh) only verify the public key against the final 20 byte hash. Specifically, in the first (notional) case the challenge would be to find a private key that has a public key that hashes to the final hash. In the second (realistic) case, you merely need to add the sha256 hash into the problem, which doesn?t seem to me to increase the difficulty by any significant amount? 


/s

From lescoutinhovr at gmail.com  Sat Feb 25 14:50:30 2017
From: lescoutinhovr at gmail.com (Leandro Coutinho)
Date: Sat, 25 Feb 2017 11:50:30 -0300
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
Message-ID: <CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>

Google recommeds "migrate to safer cryptographic hashes such as SHA-256 and
SHA-3"
It does not mention RIPEMD-160

https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html?m=1


Em 25/02/2017 10:47, "Steve Davis via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> escreveu:


> On Feb 24, 2017, at 7:01 PM, Peter Todd <pete at petertodd.org> wrote:
>
> On Fri, Feb 24, 2017 at 05:49:36PM -0600, Steve Davis via bitcoin-dev
wrote:
>> If the 20 byte SHA1 is now considered insecure (with good reason), what
about RIPEMD-160 which is the foundation of Bitcoin addresses?
>
> SHA1 is insecure because the SHA1 algorithm is insecure, not because
160bits isn't enough.
>
> AFAIK there aren't any known weaknesses in RIPEMD160,

?so far. I wonder how long that vacation will last?

> but it also hasn't been
> as closely studied as more common hash algorithms.

...but we can be sure that it will be, since the dollar value held in
existing utxos continues to increase...

> That said, Bitcoin uses
> RIPEMD160(SHA256(msg)), which may make creating collisions harder if an
attack
> is found than if it used RIPEMD160 alone.

Does that offer any greater protection? That?s not so clear to me as the
outputs (at least for p2pkh) only verify the public key against the final
20 byte hash. Specifically, in the first (notional) case the challenge
would be to find a private key that has a public key that hashes to the
final hash. In the second (realistic) case, you merely need to add the
sha256 hash into the problem, which doesn?t seem to me to increase the
difficulty by any significant amount?


/s
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/30468d23/attachment.html>

From eth3rs at gmail.com  Sat Feb 25 16:10:02 2017
From: eth3rs at gmail.com (Ethan Heilman)
Date: Sat, 25 Feb 2017 11:10:02 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
Message-ID: <CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>

>SHA1 is insecure because the SHA1 algorithm is insecure, not because
160bits isn't enough.

I would argue that 160-bits isn't enough for collision resistance. Assuming
RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle), collisions
can be generated in 2^80 queries (actually detecting these collisions
requires some time-memory additional trade-offs). The Bitcoin network at
the current hash rate performs roughly SHA-256 ~2^78 queries a day or 2^80
queries every four days. Without any break in RIPEMD-160(SHA-256(msg)) the
US could build an ASIC datacenter and produce RIPEMD-160 collisions for a
fraction of its yearly cryptologic budget.

The impact of collisions in RIPEMD-160(SHA-256(msg)) according to "On
Bitcoin Security in the Presence of Broken Crypto Primitives"(
https://eprint.iacr.org/2016/167.pdf):

>Collisions are similar, though in this case both public keys are under the
adversary?s control, and again the adversary does not have access to the
private keys. In both scenarios, there is a question of nonrepudiation
external to the protocol itself: by presenting a second pre-image of a key
used to sign a transaction, a user/adversary can claim that his coins were
stolen.

How would such an event effect the price of Bitcoin when headlines are
"Bitcoin's Cryptography Broken"? How much money could someone make by
playing the market in this way?

For both reasons of credibility and good engineering (safety
margins) Bitcoin should strive to always use cryptography which is beyond
reproach.


On Sat, Feb 25, 2017 at 9:50 AM, Leandro Coutinho via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Google recommeds "migrate to safer cryptographic hashes such as SHA-256
> and SHA-3"
> It does not mention RIPEMD-160
>
> https://security.googleblog.com/2017/02/announcing-first-
> sha1-collision.html?m=1
>
>
> Em 25/02/2017 10:47, "Steve Davis via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> escreveu:
>
>
> > On Feb 24, 2017, at 7:01 PM, Peter Todd <pete at petertodd.org> wrote:
> >
> > On Fri, Feb 24, 2017 at 05:49:36PM -0600, Steve Davis via bitcoin-dev
> wrote:
> >> If the 20 byte SHA1 is now considered insecure (with good reason), what
> about RIPEMD-160 which is the foundation of Bitcoin addresses?
> >
> > SHA1 is insecure because the SHA1 algorithm is insecure, not because
> 160bits isn't enough.
> >
> > AFAIK there aren't any known weaknesses in RIPEMD160,
>
> ?so far. I wonder how long that vacation will last?
>
> > but it also hasn't been
> > as closely studied as more common hash algorithms.
>
> ...but we can be sure that it will be, since the dollar value held in
> existing utxos continues to increase...
>
> > That said, Bitcoin uses
> > RIPEMD160(SHA256(msg)), which may make creating collisions harder if an
> attack
> > is found than if it used RIPEMD160 alone.
>
> Does that offer any greater protection? That?s not so clear to me as the
> outputs (at least for p2pkh) only verify the public key against the final
> 20 byte hash. Specifically, in the first (notional) case the challenge
> would be to find a private key that has a public key that hashes to the
> final hash. In the second (realistic) case, you merely need to add the
> sha256 hash into the problem, which doesn?t seem to me to increase the
> difficulty by any significant amount?
>
>
> /s
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/99b5f0a3/attachment.html>

From alice at librelamp.com  Sat Feb 25 18:19:11 2017
From: alice at librelamp.com (Alice Wonder)
Date: Sat, 25 Feb 2017 10:19:11 -0800
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
Message-ID: <f309ea73-053d-c3e9-134e-4561e89715f1@librelamp.com>

On 02/25/2017 08:10 AM, Ethan Heilman via bitcoin-dev wrote:
>>SHA1 is insecure because the SHA1 algorithm is insecure, not because
> 160bits isn't enough.
>
> I would argue that 160-bits isn't enough for collision resistance.
> Assuming RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random
> oracle), collisions can be generated in 2^80 queries (actually detecting
> these collisions requires some time-memory additional trade-offs). The
> Bitcoin network at the current hash rate performs roughly SHA-256 ~2^78
> queries a day or 2^80 queries every four days.

You have to not only produce a ripemd160 collision, you have to produce 
a collision that is also a valid sha-256 hash - and that's much much 
much more difficult.


From eth3rs at gmail.com  Sat Feb 25 18:36:49 2017
From: eth3rs at gmail.com (Ethan Heilman)
Date: Sat, 25 Feb 2017 13:36:49 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <f309ea73-053d-c3e9-134e-4561e89715f1@librelamp.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<f309ea73-053d-c3e9-134e-4561e89715f1@librelamp.com>
Message-ID: <CAEM=y+U7khq4FVift9aKewmasbdnFvn99pEkkYORmTCD-5thyQ@mail.gmail.com>

>You have to not only produce a ripemd160 collision, you have to produce a
collision that is also a valid sha-256 hash - and that's much much much
more difficult.

I agree that merely finding a collision in RIPEMD-160 will be hard to use
in Bitcoin.

However finding a collision in RIPEMD-160(SHA-256(msg)) via bruteforce
(2^80 queries) is not particular more difficult than finding a collision in
RIPEMD-160 via brute force. Furthermore if you find a collision in
RIPEMD-160(SHA-256(msg)) you also get a valid SHA-256 hash for which you
know the preimage.


On Sat, Feb 25, 2017 at 1:19 PM, Alice Wonder via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 02/25/2017 08:10 AM, Ethan Heilman via bitcoin-dev wrote:
>
>> SHA1 is insecure because the SHA1 algorithm is insecure, not because
>>>
>> 160bits isn't enough.
>>
>> I would argue that 160-bits isn't enough for collision resistance.
>> Assuming RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random
>> oracle), collisions can be generated in 2^80 queries (actually detecting
>> these collisions requires some time-memory additional trade-offs). The
>> Bitcoin network at the current hash rate performs roughly SHA-256 ~2^78
>> queries a day or 2^80 queries every four days.
>>
>
> You have to not only produce a ripemd160 collision, you have to produce a
> collision that is also a valid sha-256 hash - and that's much much much
> more difficult.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/11c54e30/attachment.html>

From matsuo at mac.com  Sat Feb 25 17:45:36 2017
From: matsuo at mac.com (Shin'ichiro Matsuo)
Date: Sat, 25 Feb 2017 09:45:36 -0800
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
Message-ID: <81BE82BA-EDFC-45D1-84DE-D65EC24C9F41@mac.com>

We should distinguish collision resistance from 2nd pre-image resistance, in general.

As previously written, we should care both hash output length and algorithm itself. The weakness of SHA-0 (preliminary version of SHA-1) was reported in 2004, then many research on the structure of SHA-1 were conducted. In the case of SHA-2, it is harder than SHA-1 to find collisions.

Existing security consideration and evaluation criteria were extensively discussed in the NIST SHA-3 competition. Please see the following sites.

https://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo
https://ehash.iaik.tugraz.at/wiki/Cryptanalysis_Categories

We need similar analysis on RIPEMD160 and impacts of attacks on (RIPEMD160(SHA2(msg)). 

We can also refer the security assumption of hash chain in Asiacrypt 2004 Paper. 
https://home.cyber.ee/~ahtbu/timestampsec.pdf

In the discussion of SHA3 competition, we choose another hash design structure, so called "sponge structure." This leads diversity of design principles of hash function and gives resilience even when one hash design structure becomes vulnerable. As Peter Todd wrote, discussion on design structure and algorithm is important. Discussions on all of algorithm, output length and security requirements are needed.

At some future moment, we should think about transition of underlying hash functions. I?m working on this subject and will present an idea at IEEE S&B.

Shin?ichiro Matsuo


> On Feb 25, 2017, at 8:10 AM, Ethan Heilman via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> >SHA1 is insecure because the SHA1 algorithm is insecure, not because 160bits isn't enough.
> 
> I would argue that 160-bits isn't enough for collision resistance. Assuming RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle), collisions can be generated in 2^80 queries (actually detecting these collisions requires some time-memory additional trade-offs). The Bitcoin network at the current hash rate performs roughly SHA-256 ~2^78 queries a day or 2^80 queries every four days. Without any break in RIPEMD-160(SHA-256(msg)) the US could build an ASIC datacenter and produce RIPEMD-160 collisions for a fraction of its yearly cryptologic budget.
> 
> The impact of collisions in RIPEMD-160(SHA-256(msg)) according to "On Bitcoin Security in the Presence of Broken Crypto Primitives"(https://eprint.iacr.org/2016/167.pdf):
> 
> >Collisions are similar, though in this case both public keys are under the adversary?s control, and again the adversary does not have access to the private keys. In both scenarios, there is a question of nonrepudiation external to the protocol itself: by presenting a second pre-image of a key used to sign a transaction, a user/adversary can claim that his coins were stolen. 
> 
> How would such an event effect the price of Bitcoin when headlines are "Bitcoin's Cryptography Broken"? How much money could someone make by playing the market in this way? 
> 
> For both reasons of credibility and good engineering (safety margins) Bitcoin should strive to always use cryptography which is beyond reproach.
> 
> 
> On Sat, Feb 25, 2017 at 9:50 AM, Leandro Coutinho via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Google recommeds "migrate to safer cryptographic hashes such as SHA-256 and SHA-3"
> It does not mention RIPEMD-160
> 
> https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html?m=1
> 
> 
> Em 25/02/2017 10:47, "Steve Davis via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> escreveu:
> 
> > On Feb 24, 2017, at 7:01 PM, Peter Todd <pete at petertodd.org> wrote:
> >
> > On Fri, Feb 24, 2017 at 05:49:36PM -0600, Steve Davis via bitcoin-dev wrote:
> >> If the 20 byte SHA1 is now considered insecure (with good reason), what about RIPEMD-160 which is the foundation of Bitcoin addresses?
> >
> > SHA1 is insecure because the SHA1 algorithm is insecure, not because 160bits isn't enough.
> >
> > AFAIK there aren't any known weaknesses in RIPEMD160,
> 
> ?so far. I wonder how long that vacation will last?
> 
> > but it also hasn't been
> > as closely studied as more common hash algorithms.
> 
> ...but we can be sure that it will be, since the dollar value held in existing utxos continues to increase...
> 
> > That said, Bitcoin uses
> > RIPEMD160(SHA256(msg)), which may make creating collisions harder if an attack
> > is found than if it used RIPEMD160 alone.
> 
> Does that offer any greater protection? That?s not so clear to me as the outputs (at least for p2pkh) only verify the public key against the final 20 byte hash. Specifically, in the first (notional) case the challenge would be to find a private key that has a public key that hashes to the final hash. In the second (realistic) case, you merely need to add the sha256 hash into the problem, which doesn?t seem to me to increase the difficulty by any significant amount?
> 
> 
> /s
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From pete at petertodd.org  Sat Feb 25 19:12:01 2017
From: pete at petertodd.org (Peter Todd)
Date: Sat, 25 Feb 2017 14:12:01 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
Message-ID: <20170225191201.GA15472@savin.petertodd.org>

On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev wrote:
> >SHA1 is insecure because the SHA1 algorithm is insecure, not because
> 160bits isn't enough.
> 
> I would argue that 160-bits isn't enough for collision resistance. Assuming
> RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle), collisions

That's something that we're well aware of; there have been a few discussions on
this list about how P2SH's 160-bits is insufficient in certain use-cases such
as multisig.

However, remember that a 160-bit *security level* is sufficient, and RIPEMD160
has 160-bit security against preimage attacks. Thus things like
pay-to-pubkey-hash are perfectly secure: sure you could generate two pubkeys
that have the same RIPEMD160(SHA256()) digest, but if someone does that it
doesn't cause the Bitcoin network itself any harm, and doing so is something
you choose to do to yourself.

In any case, segwit will provide a 256-bit pay-to-witness-script-hash(1), which
provides a 128-bit security level against collision attacks.

1) https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#Native_P2WSH

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/ffedd518/attachment.sig>

From roconnor at blockstream.io  Sat Feb 25 20:53:12 2017
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 25 Feb 2017 15:53:12 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170225191201.GA15472@savin.petertodd.org>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
Message-ID: <CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>

On Sat, Feb 25, 2017 at 2:12 PM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev
> wrote:
> > >SHA1 is insecure because the SHA1 algorithm is insecure, not because
> > 160bits isn't enough.
> >
> > I would argue that 160-bits isn't enough for collision resistance.
> Assuming
> > RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle),
> collisions
>
> That's something that we're well aware of; there have been a few
> discussions on
> this list about how P2SH's 160-bits is insufficient in certain use-cases
> such
> as multisig.
>
> However, remember that a 160-bit *security level* is sufficient, and
> RIPEMD160
> has 160-bit security against preimage attacks. Thus things like
> pay-to-pubkey-hash are perfectly secure: sure you could generate two
> pubkeys
> that have the same RIPEMD160(SHA256()) digest, but if someone does that it
> doesn't cause the Bitcoin network itself any harm, and doing so is
> something
> you choose to do to yourself.
>

Be aware that the issue is more problematic for more complex contracts.
For example, you are building a P2SH 2-of-2 multisig together with someone
else if you are not careful, party A can hand their key over to party B,
who can may try to generate a collision between their second key and
another 2-of-2 multisig where they control both keys. See
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012205.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/aec6b098/attachment-0001.html>

From pete at petertodd.org  Sat Feb 25 20:57:06 2017
From: pete at petertodd.org (Peter Todd)
Date: Sat, 25 Feb 2017 15:57:06 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CACsn0ckikbifubOMoZphHcreXHzg=ELcPhOD02VhD-J8-MyaBA@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CACsn0ckikbifubOMoZphHcreXHzg=ELcPhOD02VhD-J8-MyaBA@mail.gmail.com>
Message-ID: <20170225205706.GA16059@savin.petertodd.org>

On Sat, Feb 25, 2017 at 12:42:56PM -0800, Watson Ladd wrote:
> On Sat, Feb 25, 2017 at 11:12 AM, Peter Todd via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev wrote:
> >> >SHA1 is insecure because the SHA1 algorithm is insecure, not because
> >> 160bits isn't enough.
> >>
> >> I would argue that 160-bits isn't enough for collision resistance. Assuming
> >> RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle), collisions
> >
> > That's something that we're well aware of; there have been a few discussions on
> > this list about how P2SH's 160-bits is insufficient in certain use-cases such
> > as multisig.
> >
> > However, remember that a 160-bit *security level* is sufficient, and RIPEMD160
> > has 160-bit security against preimage attacks. Thus things like
> > pay-to-pubkey-hash are perfectly secure: sure you could generate two pubkeys
> > that have the same RIPEMD160(SHA256()) digest, but if someone does that it
> > doesn't cause the Bitcoin network itself any harm, and doing so is something
> > you choose to do to yourself.
> 
> P2SH is not secure against collision. I could write two scripts with
> the same hash, one of which is an escrow script and the other which
> pays it to me, have someone pay to the escrow script, and then get the
> payment. Some formal analysis tools would ignore the unused
> instructions even if human analysis would not.

That's what I said: "P2SH's 160-bits is insufficient in certain use-cases such
as multisig"

Obviously any usecase where multiple people are creating a P2SH redeemScript
collaboratively is potentially vulnerable. Use-cases where the redeemScript was
created by a single-party however are _not_ vulnerable, as that party has
complete control over whether or not collisions are possible, by virtue of the
fact that they're the ones who have to make the collision happen!

Similarly, even in the multisig case, commit-reveal techniques can mitigate the
vulnerability, by forcing parties to commit to what pubkeys/hashlocks/etc.
they'll use for the script prior to pubkeys/hashlocks/etc. being revealed.
Though a better long-term approach is to use a 256-bit digest size, as segwit
does.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/5ab478f4/attachment.sig>

From pete at petertodd.org  Sat Feb 25 21:04:06 2017
From: pete at petertodd.org (Peter Todd)
Date: Sat, 25 Feb 2017 16:04:06 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
Message-ID: <20170225210406.GA16196@savin.petertodd.org>

On Sat, Feb 25, 2017 at 03:53:12PM -0500, Russell O'Connor wrote:
> On Sat, Feb 25, 2017 at 2:12 PM, Peter Todd via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev
> > wrote:
> > > >SHA1 is insecure because the SHA1 algorithm is insecure, not because
> > > 160bits isn't enough.
> > >
> > > I would argue that 160-bits isn't enough for collision resistance.
> > Assuming
> > > RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle),
> > collisions
> >
> > That's something that we're well aware of; there have been a few
> > discussions on
> > this list about how P2SH's 160-bits is insufficient in certain use-cases
> > such
> > as multisig.
> >
> > However, remember that a 160-bit *security level* is sufficient, and
> > RIPEMD160
> > has 160-bit security against preimage attacks. Thus things like
> > pay-to-pubkey-hash are perfectly secure: sure you could generate two
> > pubkeys
> > that have the same RIPEMD160(SHA256()) digest, but if someone does that it
> > doesn't cause the Bitcoin network itself any harm, and doing so is
> > something
> > you choose to do to yourself.
> >
> 
> Be aware that the issue is more problematic for more complex contracts.
> For example, you are building a P2SH 2-of-2 multisig together with someone
> else if you are not careful, party A can hand their key over to party B,
> who can may try to generate a collision between their second key and
> another 2-of-2 multisig where they control both keys. See
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012205.html

I'm very aware of that, in fact I think I may have even been the first person
to post on this list the commit-reveal mitigation.

Note how I said earlier in the message you're replying to that "P2SH's 160-bits
is insufficient in certain use-cases such as multisig"

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/4cc07c5c/attachment.sig>

From watsonbladd at gmail.com  Sat Feb 25 20:42:56 2017
From: watsonbladd at gmail.com (Watson Ladd)
Date: Sat, 25 Feb 2017 12:42:56 -0800
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170225191201.GA15472@savin.petertodd.org>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
Message-ID: <CACsn0ckikbifubOMoZphHcreXHzg=ELcPhOD02VhD-J8-MyaBA@mail.gmail.com>

On Sat, Feb 25, 2017 at 11:12 AM, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev wrote:
>> >SHA1 is insecure because the SHA1 algorithm is insecure, not because
>> 160bits isn't enough.
>>
>> I would argue that 160-bits isn't enough for collision resistance. Assuming
>> RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle), collisions
>
> That's something that we're well aware of; there have been a few discussions on
> this list about how P2SH's 160-bits is insufficient in certain use-cases such
> as multisig.
>
> However, remember that a 160-bit *security level* is sufficient, and RIPEMD160
> has 160-bit security against preimage attacks. Thus things like
> pay-to-pubkey-hash are perfectly secure: sure you could generate two pubkeys
> that have the same RIPEMD160(SHA256()) digest, but if someone does that it
> doesn't cause the Bitcoin network itself any harm, and doing so is something
> you choose to do to yourself.

P2SH is not secure against collision. I could write two scripts with
the same hash, one of which is an escrow script and the other which
pays it to me, have someone pay to the escrow script, and then get the
payment. Some formal analysis tools would ignore the unused
instructions even if human analysis would not.

>
> In any case, segwit will provide a 256-bit pay-to-witness-script-hash(1), which
> provides a 128-bit security level against collision attacks.
>
> 1) https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#Native_P2WSH
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
"Man is born free, but everywhere he is in chains".
--Rousseau.

From dscotese at litmocracy.com  Sat Feb 25 21:21:56 2017
From: dscotese at litmocracy.com (Dave Scotese)
Date: Sat, 25 Feb 2017 13:21:56 -0800
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170225210406.GA16196@savin.petertodd.org>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
Message-ID: <CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>

I was under the impression that RIPEMD160(SHA256(msg)) is used to turn a
PUBLIC key (msg) into a bitcoin address, so yeah, you could identify
ANOTHER (or the same, I guess - how would you know?) public key that has
the same bitcoin address if RIPEMD-160 collisions are easy, but I don't see
how that has any effect on anyone.  Maybe I'm restating what Peter wrote.
If so, confirmation would be nice.

On Sat, Feb 25, 2017 at 1:04 PM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sat, Feb 25, 2017 at 03:53:12PM -0500, Russell O'Connor wrote:
> > On Sat, Feb 25, 2017 at 2:12 PM, Peter Todd via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev
> > > wrote:
> > > > >SHA1 is insecure because the SHA1 algorithm is insecure, not because
> > > > 160bits isn't enough.
> > > >
> > > > I would argue that 160-bits isn't enough for collision resistance.
> > > Assuming
> > > > RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle),
> > > collisions
> > >
> > > That's something that we're well aware of; there have been a few
> > > discussions on
> > > this list about how P2SH's 160-bits is insufficient in certain
> use-cases
> > > such
> > > as multisig.
> > >
> > > However, remember that a 160-bit *security level* is sufficient, and
> > > RIPEMD160
> > > has 160-bit security against preimage attacks. Thus things like
> > > pay-to-pubkey-hash are perfectly secure: sure you could generate two
> > > pubkeys
> > > that have the same RIPEMD160(SHA256()) digest, but if someone does
> that it
> > > doesn't cause the Bitcoin network itself any harm, and doing so is
> > > something
> > > you choose to do to yourself.
> > >
> >
> > Be aware that the issue is more problematic for more complex contracts.
> > For example, you are building a P2SH 2-of-2 multisig together with
> someone
> > else if you are not careful, party A can hand their key over to party B,
> > who can may try to generate a collision between their second key and
> > another 2-of-2 multisig where they control both keys. See
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2016-January/012205.html
>
> I'm very aware of that, in fact I think I may have even been the first
> person
> to post on this list the commit-reveal mitigation.
>
> Note how I said earlier in the message you're replying to that "P2SH's
> 160-bits
> is insufficient in certain use-cases such as multisig"
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/6b3b227c/attachment-0001.html>

From pete at petertodd.org  Sat Feb 25 21:40:18 2017
From: pete at petertodd.org (Peter Todd)
Date: Sat, 25 Feb 2017 16:40:18 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
Message-ID: <20170225214018.GA16524@savin.petertodd.org>

On Sat, Feb 25, 2017 at 03:34:33PM -0600, Steve Davis wrote:
> Yea, well. I don?t think it is ethical to post instructions without an associated remediation (BIP) if you don?t see the potential attack.

I can't agree with you at all there: we're still at the point where the
computational costs of such attacks limit their real-world impact, which is
exactly when you want the *maximum* exposure to what they are and what the
risks are, so that people develop mitigations.

Keeping details secret tends to keep the attacks out of public view, which
might be a good trade-off in a situation where the attacks are immediately
practical and the need to deploy a fix is well understood. But we're in the
exact opposite situation.

> I was rather hoping that we could have a fuller discussion of what the best practical response would be to such an issue?

Deploying segwit's 256-bit digests is a response that's already fully coded and
ready to deploy, with the one exception of a new address format. That address
format is being actively worked on, and could be deployed relatively quickly if
needed.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/5ef5ac64/attachment.sig>

From steven.charles.davis at gmail.com  Sat Feb 25 21:34:33 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Sat, 25 Feb 2017 15:34:33 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
Message-ID: <4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>

Yea, well. I don?t think it is ethical to post instructions without an associated remediation (BIP) if you don?t see the potential attack.

I was rather hoping that we could have a fuller discussion of what the best practical response would be to such an issue?


> On Feb 25, 2017, at 3:21 PM, Dave Scotese <dscotese at litmocracy.com> wrote:
> 
> I was under the impression that RIPEMD160(SHA256(msg)) is used to turn a PUBLIC key (msg) into a bitcoin address, so yeah, you could identify ANOTHER (or the same, I guess - how would you know?) public key that has the same bitcoin address if RIPEMD-160 collisions are easy, but I don't see how that has any effect on anyone.  Maybe I'm restating what Peter wrote.  If so, confirmation would be nice.
> 
> On Sat, Feb 25, 2017 at 1:04 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> On Sat, Feb 25, 2017 at 03:53:12PM -0500, Russell O'Connor wrote:
> > On Sat, Feb 25, 2017 at 2:12 PM, Peter Todd via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> >
> > > On Sat, Feb 25, 2017 at 11:10:02AM -0500, Ethan Heilman via bitcoin-dev
> > > wrote:
> > > > >SHA1 is insecure because the SHA1 algorithm is insecure, not because
> > > > 160bits isn't enough.
> > > >
> > > > I would argue that 160-bits isn't enough for collision resistance.
> > > Assuming
> > > > RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle),
> > > collisions
> > >
> > > That's something that we're well aware of; there have been a few
> > > discussions on
> > > this list about how P2SH's 160-bits is insufficient in certain use-cases
> > > such
> > > as multisig.
> > >
> > > However, remember that a 160-bit *security level* is sufficient, and
> > > RIPEMD160
> > > has 160-bit security against preimage attacks. Thus things like
> > > pay-to-pubkey-hash are perfectly secure: sure you could generate two
> > > pubkeys
> > > that have the same RIPEMD160(SHA256()) digest, but if someone does that it
> > > doesn't cause the Bitcoin network itself any harm, and doing so is
> > > something
> > > you choose to do to yourself.
> > >
> >
> > Be aware that the issue is more problematic for more complex contracts.
> > For example, you are building a P2SH 2-of-2 multisig together with someone
> > else if you are not careful, party A can hand their key over to party B,
> > who can may try to generate a collision between their second key and
> > another 2-of-2 multisig where they control both keys. See
> > https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012205.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012205.html>
> 
> I'm very aware of that, in fact I think I may have even been the first person
> to post on this list the commit-reveal mitigation.
> 
> Note how I said earlier in the message you're replying to that "P2SH's 160-bits
> is insufficient in certain use-cases such as multisig"
> 
> --
> https://petertodd.org <https://petertodd.org/> 'peter'[:-1]@petertodd.org <http://petertodd.org/>
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 
> 
> 
> -- 
> I like to provide some work at no charge to prove my value. Do you need a techie?  
> I own Litmocracy <http://www.litmocracy.com/> and Meme Racing <http://www.memeracing.net/> (in alpha). 
> I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com/> which now accepts Bitcoin.
> I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
> "He ought to find it more profitable to play by the rules" - Satoshi Nakamoto

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/461ac05d/attachment.html>

From steven.charles.davis at gmail.com  Sat Feb 25 21:54:16 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Sat, 25 Feb 2017 15:54:16 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170225214018.GA16524@savin.petertodd.org>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
Message-ID: <D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>

Hi Peter,

> On Feb 25, 2017, at 3:40 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> On Sat, Feb 25, 2017 at 03:34:33PM -0600, Steve Davis wrote:
>> Yea, well. I don?t think it is ethical to post instructions without an associated remediation (BIP) if you don?t see the potential attack.
> 
> I can't agree with you at all there: we're still at the point where the
> computational costs of such attacks limit their real-world impact, which is
> exactly when you want the *maximum* exposure to what they are and what the
> risks are, so that people develop mitigations.
> 

I agree with the latter part of your statement but am actually much less confident about the first part? I need to run some numbers on that.

> Keeping details secret tends to keep the attacks out of public view, which
> might be a good trade-off in a situation where the attacks are immediately
> practical and the need to deploy a fix is well understood. But we're in the
> exact opposite situation.
> 
>> I was rather hoping that we could have a fuller discussion of what the best practical response would be to such an issue?
> 
> Deploying segwit's 256-bit digests is a response that's already fully coded and
> ready to deploy, with the one exception of a new address format. That address
> format is being actively worked on, and could be deployed relatively quickly if
> needed.
> 

I really, really don?t want to get into it but segwit has many aspects that are less appealing, not least of which being the amount of time it would take to reach the critical mass. 

Surely there's a number of alternative approaches which could be explored, even if only to make a fair assessment of a best response?

/s

From pieter.wuille at gmail.com  Sat Feb 25 22:14:44 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sat, 25 Feb 2017 14:14:44 -0800
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
	<D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
Message-ID: <CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>

On Feb 25, 2017 14:09, "Steve Davis via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Hi Peter,


I really, really don?t want to get into it but segwit has many aspects that
are less appealing, not least of which being the amount of time it would
take to reach the critical mass.

Surely there's a number of alternative approaches which could be explored,
even if only to make a fair assessment of a best response?


Any alternative to move us away from RIPEMD160 would require:
* A drafting of a softfork proposal, implementation, testing, review.
* A new address format
* Miners accepting the new consensus rules
* Wallets adopting the new address format, both on the sender side and
receiver side (which requires new signatures).

I.e., exactly the same as segwit, for which most of these are already done.
And it would still only apply to wallets adopting it.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/e3856947/attachment-0001.html>

From eth3rs at gmail.com  Sat Feb 25 22:34:38 2017
From: eth3rs at gmail.com (Ethan Heilman)
Date: Sat, 25 Feb 2017 17:34:38 -0500
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
	<D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
	<CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
Message-ID: <CAEM=y+XEXuf+BPOH0h=Hn3_9PeL4Dv9G3ySN6fe5zH7bJVkSDA@mail.gmail.com>

I strongly encourage Bitcoin to move from 80-bit collision resistance
(RIPEMD-160) to 128-bit collision resistance (SHA-256).

On Sat, Feb 25, 2017 at 5:14 PM, Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
>
> On Feb 25, 2017 14:09, "Steve Davis via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> wrote:
>
> Hi Peter,
>
>
> I really, really don?t want to get into it but segwit has many aspects
> that are less appealing, not least of which being the amount of time it
> would take to reach the critical mass.
>
> Surely there's a number of alternative approaches which could be explored,
> even if only to make a fair assessment of a best response?
>
>
> Any alternative to move us away from RIPEMD160 would require:
> * A drafting of a softfork proposal, implementation, testing, review.
> * A new address format
> * Miners accepting the new consensus rules
> * Wallets adopting the new address format, both on the sender side and
> receiver side (which requires new signatures).
>
> I.e., exactly the same as segwit, for which most of these are already
> done. And it would still only apply to wallets adopting it.
>
> --
> Pieter
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/7fecc6c7/attachment.html>

From lescoutinhovr at gmail.com  Sat Feb 25 23:09:18 2017
From: lescoutinhovr at gmail.com (Leandro Coutinho)
Date: Sat, 25 Feb 2017 20:09:18 -0300
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <20170225214018.GA16524@savin.petertodd.org>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
Message-ID: <CAN6UTaz5Y9hRjCgHAETF2HMxZ7TPdAe06NmjQ1cQgHvBsf0RSQ@mail.gmail.com>

If people split their bitcoins in multiple addresses, then maybe there
would be no need to worry(?), because the computational cost would be
higher than what the attacker would get.


>From Google:
https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html

*Here are some numbers that give a sense of how large scale this
computation was: *

   - *Nine quintillion (9,223,372,036,854,775,808) SHA1 computations in
   total*
   - *6,500 years of CPU computation to complete the attack first phase*
   - *110 years of GPU computation to complete the second phase*


https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html
Richest address: 124,178 BTC ($142,853,079 USD)



On Sat, Feb 25, 2017 at 6:40 PM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sat, Feb 25, 2017 at 03:34:33PM -0600, Steve Davis wrote:
> > Yea, well. I don?t think it is ethical to post instructions without an
> associated remediation (BIP) if you don?t see the potential attack.
>
> I can't agree with you at all there: we're still at the point where the
> computational costs of such attacks limit their real-world impact, which is
> exactly when you want the *maximum* exposure to what they are and what the
> risks are, so that people develop mitigations.
>
> Keeping details secret tends to keep the attacks out of public view, which
> might be a good trade-off in a situation where the attacks are immediately
> practical and the need to deploy a fix is well understood. But we're in the
> exact opposite situation.
>
> > I was rather hoping that we could have a fuller discussion of what the
> best practical response would be to such an issue?
>
> Deploying segwit's 256-bit digests is a response that's already fully
> coded and
> ready to deploy, with the one exception of a new address format. That
> address
> format is being actively worked on, and could be deployed relatively
> quickly if
> needed.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/3c3e4b53/attachment.html>

From shaolinfry at protonmail.ch  Sat Feb 25 23:55:51 2017
From: shaolinfry at protonmail.ch (shaolinfry)
Date: Sat, 25 Feb 2017 18:55:51 -0500
Subject: [bitcoin-dev] Moving towards user activated soft fork activation
Message-ID: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>

Some thoughts about the activation mechanism for soft forks. In the past we used IsSuperMajority and currently use BIP9 as soft fork activation methods, where a supermajority of hashrate triggers nodes to begin enforcing new rules. Hashrate based activation is convenient because it is the simplest and most straightforward process. While convenient there are a number limitations with this method.

Firstly, it requires trusting the hash power will validate after activation. The BIP66 soft fork was a case where 95% of the hashrate was signaling readiness but in reality about half was not actually validating the upgraded rules and mined upon an invalid block by mistake[1].

Secondly, miner signalling has a natural veto which allows a small percentage of hashrate to veto node activation of the upgrade for everyone. To date, soft forks have taken advantage of the relatively centralised mining landscape where there are relatively few mining pools building valid blocks; as we move towards more hashrate decentralization, it's likely that we will suffer more and more from "upgrade inertia" which will veto most upgrades.

Upgrade inertia in inevitable for widely deployed software and can be seen for example, with Microsoft Windows. At the time of writing 5.72% of all Microsoft Windows installations are still running Windows XP, despite mainstream support ending in 2009 and being superseded by 4 software generations, Vista, 7, 8 and 10.

Thirdly, the signaling methodology is widely misinterpreted to mean the hash power is voting on a proposal and it seems difficult to correct this misunderstanding in the wider community. The hash powers' role is to select valid transactions, and to extend the blockchain with valid blocks. Fully validating economic nodes ensure that blocks are valid. Nodes therefore define validity according to the software they run, but miners decide what already valid transactions gets included in the block chain.

As such, soft forks rules are actually always enforced by the nodes, not the miners. Miners of course can opt-out by simply not including transactions that use the new soft fork feature, but they cannot produce blocks that are invalid to the soft fork. The P2SH soft fork is a good example of this, where non-upgraded miners would see P2SH as spendable without a signature and consider them valid. If such an transaction were to be included in a block, the block would be invalid and the miner would lose the block reward and fees.

So-called "censorship" soft forks do not require nodes to opt in, because >51% of the hash power already have the ability to orphan blocks that contain transactions they have blacklisted. Since this is not a change in validity, nodes will accept the censored block chain automatically.

The fourth problem with supermajority hash power signaling is it draws unnecessary attention to miners which can become unnecessarily political. Already misunderstood as a vote, miners may feel pressure to "make a decision" on behalf of the community: who is and isn't signalling becomes a huge public focus and may put pressures onto miners they are unprepared for. Some miners may not be in a position to upgrade, or may prefer not to participate in the soft fork which is their right. However, that miner may now become a lone reason that vetoes activation for everyone, where the soft fork is an opt-in feature! This situation seems to be against the voluntary nature of the Bitcoin system where participation at all levels is voluntary and kept honest by well balanced incentives.

Since miners already have the protocol level right to select whatever transaction they prefer (and not mine those they don't), it would be better if a miner could chose to not participate in triggering activation of something they won't use, but, without being a veto to the process (and all the ire they may have to experience as a consequence).

The alternative discussed here is "flag day activation" where nodes begin enforcement at a predetermined time in the future. This method needs a longer lead time than a hash power based activation trigger, but offers a number of advantages and perhaps provides a better tradeoff.

Soft forks are still entirely optional to use post activation. For example, with P2SH, many participants in the Bitcoin ecosystem still do not use P2SH. Only 11% of bitcoins[2] are stored in P2SH addresses at the time of writing. Miners are free to not mine P2SH transactions, however, the incentives are such that miners should still validate transactions so they don't accidentally include invalid transactions and cause their block to be rejected. As an additional safety measure for well designed soft forks, relay policy rules prevent non-standard and invalid transactions from being relayed and mined by default; a miner would have to purposefully mine an invalid transaction, which is against their own economic interest.

Since the incentives of the Bitcoin system rely on self validation, economic nodes (miners and users) should always remain safe by ensuring their nodes either validate the current rules, or, they can place their network behind a full node that will filter out invalid transactions and blocks at the edge of their network (so called firewall or border nodes).

A user activated soft fork is permissive. Miners do not have to produce new version blocks and non-upgraded miners' blocks will not be orphaned as was the case with IsSuperMajority soft forks (e.g. BIP34, BIP66, BIP65-CLTV) which made it a compulsory upgrade for miners.

BIP9 "versionbits" soft fork activation method is also permissive in so far as non-upgraded miners are not forced to upgrade after activation because their blocks wont be orphaned. A recent case was the "CSV" soft fork that activated BIP68, BIP112 and BIP113. As such, the CSV soft fork allows non-upgraded miners to continue mining so long as they didn't produce invalid blocks.

Miners always retain discretion on which transactions to mine. However, regardless of whether they actively include transactions using the new soft fork feature, or not, the incentive for hash power to upgrade in order to validate is strong: if they do not, they could be vulnerable to a rogue miner willing to waste 12.5BTC to create an invalid block, which may cause non-validating miners to build on an invalid chain similar to the BIP66 incident. Validation has always had a strong requirement.

A user activated soft fork is win-win because it adds an option that some people want that does not detract from other peoples' enjoyment. Even if only 10% of users ever wanted a feature, so long as the benefit outweighed the technical risks, it would not be rational to deny others the ability to opt-in.

My suggestion is to have the best of both worlds. Since a user activated soft fork needs a relatively long lead time before activation, we can combine with BIP9 to give the option of a faster hash power coordinated activation or activation by flag day, whichever is the sooner. In both cases, we can leverage the warning systems in BIP9. The change is relatively simple, adding an activation-time parameter which will transition the BIP9 state to LOCKED_IN before the end of the BIP9 deployment timeout.

You can find the proposal here https://gist.github.com/shaolinfry/0f7d1fd22743bb966da0c0b1682ea2ab

References:

[1]: https://bitcoin.org/en/alert/2015-07-04-spv-mining
[2]: http://p2sh.info/dashboard/db/p2sh-statistics?from=1472043312917&to=1488030912918
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/e6ed76b3/attachment-0001.html>

From pieter.wuille at gmail.com  Sun Feb 26 06:36:25 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sat, 25 Feb 2017 22:36:25 -0800
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <4F6C2972-A320-429A-BD13-623B01F390A3@gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
	<D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
	<CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
	<4F6C2972-A320-429A-BD13-623B01F390A3@gmail.com>
Message-ID: <CAPg+sBgndv+Q-MGhz6Th9A3xhtqouz6D9AENqRusnCz_m+2O2g@mail.gmail.com>

On Feb 25, 2017 22:26, "Steve Davis" <steven.charles.davis at gmail.com> wrote:

Hi Pieter,

> On Feb 25, 2017, at 4:14 PM, Pieter Wuille <pieter.wuille at gmail.com>
wrote:
>
> Any alternative to move us away from RIPEMD160 would require:

> <snipped>

?Any alternative?? What about reverting to:

[<public_key>, OP_CHECKSIG]


snip


Could that be the alternative?


Ok, fair enough, that is an alternative that avoids the 160-bit hash
function, but not where it matters. The 80-bit collision attack only
applies to jointly constructed addresses like multisig P2SH, not single-key
ones. As far as I know for those we only rely preimage security, and
RIPEMD160 has 160 bit security there, which is even more than our ECDSA
signatures offer.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170225/6f7d3907/attachment.html>

From steven.charles.davis at gmail.com  Sun Feb 26 06:26:45 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Sun, 26 Feb 2017 00:26:45 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
	<D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
	<CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
Message-ID: <4F6C2972-A320-429A-BD13-623B01F390A3@gmail.com>

Hi Pieter,

> On Feb 25, 2017, at 4:14 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> 
> Any alternative to move us away from RIPEMD160 would require:

> <snipped>

?Any alternative?? What about reverting to:

[<public_key>, OP_CHECKSIG]

or perhaps later

[<?compressed? public_key>, OP_CHECKSIG]

This appears to get away from the issue without introducing a lot of other concerns?

(IIRC the RIPEMD thing was justified on convenience and compactness).

Could that be the alternative?

/s


From steven.charles.davis at gmail.com  Sun Feb 26 07:16:37 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Sun, 26 Feb 2017 01:16:37 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAPg+sBgndv+Q-MGhz6Th9A3xhtqouz6D9AENqRusnCz_m+2O2g@mail.gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
	<D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
	<CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
	<4F6C2972-A320-429A-BD13-623B01F390A3@gmail.com>
	<CAPg+sBgndv+Q-MGhz6Th9A3xhtqouz6D9AENqRusnCz_m+2O2g@mail.gmail.com>
Message-ID: <C3BDCE95-6DA6-44E4-AFB8-14F9B84ABC02@gmail.com>


> On Feb 26, 2017, at 12:36 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> 
> The 80-bit collision attack only applies to jointly constructed addresses like multisig P2SH, not single-key ones.

That?s the part I?m less convinced about, and why I asked the original question re SHA1 vs RIPEMD. 

I?m checking my own numbers (and as you?ll appreciate it?s a powers of ten thing), but I do see a vector. Which would mean that if RIPEMD were weakened in any way, single-key transactions could suddenly become badly exposed.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170226/9aeaf1d0/attachment.html>

From steven.charles.davis at gmail.com  Sun Feb 26 16:53:29 2017
From: steven.charles.davis at gmail.com (Steve Davis)
Date: Sun, 26 Feb 2017 10:53:29 -0600
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <CAPg+sBirowtHqUT5GUJf9hmDEACKVX19HAon-rrz7GmO8OBsNg@mail.gmail.com>
References: <8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<20170225191201.GA15472@savin.petertodd.org>
	<CAMZUoK=sq_sRoXuySca-VAGwA3AzeoZ5iNFSnKULbj+NtPjHFA@mail.gmail.com>
	<20170225210406.GA16196@savin.petertodd.org>
	<CAGLBAhdCb+QLWRm4FWkPvaM2sU24HuafdgNiS=wgnPTGzrW05w@mail.gmail.com>
	<4FE38F6A-0560-4989-9C53-7F8C94EA4C76@gmail.com>
	<20170225214018.GA16524@savin.petertodd.org>
	<D36DB0BD-C805-4346-B425-77D5B29582E5@gmail.com>
	<CAPg+sBhZ1UqOLqz_PVjjrE8Cbte_Y160Gq7P7EWf6cRKjMcDEQ@mail.gmail.com>
	<4F6C2972-A320-429A-BD13-623B01F390A3@gmail.com>
	<CAPg+sBgndv+Q-MGhz6Th9A3xhtqouz6D9AENqRusnCz_m+2O2g@mail.gmail.com>
	<C3BDCE95-6DA6-44E4-AFB8-14F9B84ABC02@gmail.com>
	<CAPg+sBirowtHqUT5GUJf9hmDEACKVX19HAon-rrz7GmO8OBsNg@mail.gmail.com>
Message-ID: <D7E6E9C1-54D9-4BF8-B0DA-0C26C14EB9E5@gmail.com>


> On Feb 26, 2017, at 1:36 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> 
> Typical hash function breaks produce collision attacks, while a preimage attack is needed to reduce single-key address security.

Thank you Pieter - that was really helpful. I realize now that I was thinking of a preimage attack but had mistakenly assumed that the birthday bound applied...

So the unit operation: [genkeypair; ripemd160(sha256(pubkey));check_utxoset] would need to be performed 2.9*10^42 and not (as I had first calculated) 2.4*10^18. 

Oops. My bad.

From jameson.lopp at gmail.com  Sun Feb 26 17:34:57 2017
From: jameson.lopp at gmail.com (Jameson Lopp)
Date: Sun, 26 Feb 2017 12:34:57 -0500
Subject: [bitcoin-dev] Moving towards user activated soft fork activation
In-Reply-To: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>
References: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>
Message-ID: <CADL_X_fUuTexNYBt=rZUXRuXpKrpyTiiXYkxTxquispLGV6ezQ@mail.gmail.com>

You've made many salient points, Shaolin, though I have a few questions:

1) How well does this model work under adversarial conditions? Fair point
about signaling not being reliable, though it seems more vague in terms of
safety given that you can't actually know what percentage of hashrate that
is /not/ signaling for the soft fork has taken the necessary precautions to
avoid mining an invalid block and potentially causing a hard fork. It's
probably safe to say that if a flag-day soft fork is activated, there will
be at least a few parties who will attempt to trigger a chain fork by
crafting transactions that are valid via non-fork rules but invalid via the
soft fork rules.

2) If the flag day soft fork is activated with only a minority of hashrate
support + safely opted-out hashrate, isn't it possible for the rest of
miners to coordinate orphaning any soft fork compatible blocks to kill the
soft fork chain? This would be a major difference from a miner-activated
soft fork, correct? Unless perhaps many miners colluded to signal soft fork
support while not actually supporting it...

3) In terms of complexity for mining pool operators, how well does this
model scale if there are N soft forks and the pool doesn't want to opt-in
to any of them? Couldn't this result in those pool operators having to run
not just one border node, but a multitude of "chained" border nodes if the
soft forks are spread across different software implementations?

It seems to me that this type of user-driven approach would preferably be
coupled with assurances from major Bitcoin wallets / exchanges / payment
processors that they will not honor coins from a chain fork that results
from invalid spends of outputs encumbered by soft fork rules. Though on the
other hand, I don't see such an assurance being possible given that
exchanges have an incentive to take the first mover advantage in listing a
new coin.

- Jameson

On Sat, Feb 25, 2017 at 6:55 PM, shaolinfry via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Some thoughts about the activation mechanism for soft forks. In the past
> we used IsSuperMajority and currently use BIP9 as soft fork activation
> methods, where a supermajority of hashrate triggers nodes to begin
> enforcing new rules. Hashrate based activation is convenient because it is
> the simplest and most straightforward process. While convenient there are a
> number limitations with this method.
>
> Firstly, it requires trusting the hash power will validate after
> activation. The BIP66 soft fork was a case where 95% of the hashrate was
> signaling readiness but in reality about half was not actually validating
> the upgraded rules and mined upon an invalid block by mistake[1].
>
> Secondly, miner signalling has a natural veto which allows a small
> percentage of hashrate to veto node activation of the upgrade for everyone.
> To date, soft forks have taken advantage of the relatively centralised
> mining landscape where there are relatively few mining pools building valid
> blocks; as we move towards more hashrate decentralization, it's likely that
> we will suffer more and more from "upgrade inertia" which will veto most
> upgrades.
>
> Upgrade inertia in inevitable for widely deployed software and can be seen
> for example, with Microsoft Windows. At the time of writing 5.72% of all
> Microsoft Windows installations are still running Windows XP, despite
> mainstream support ending in 2009 and being superseded by 4 software
> generations, Vista, 7, 8 and 10.
>
> Thirdly, the signaling methodology is widely misinterpreted to mean the
> hash power is voting on a proposal and it seems difficult to correct this
> misunderstanding in the wider community. The hash powers' role is to select
> valid transactions, and to extend the blockchain with valid blocks. Fully
> validating economic nodes ensure that blocks are valid. Nodes therefore
> define validity according to the software they run, but miners decide what
> already valid transactions gets included in the block chain.
>
> As such, soft forks rules are actually always enforced by the nodes, not
> the miners. Miners of course can opt-out by simply not including
> transactions that use the new soft fork feature, but they cannot produce
> blocks that are invalid to the soft fork. The P2SH soft fork is a good
> example of this, where non-upgraded miners would see P2SH as spendable
> without a signature and consider them valid. If such an transaction were to
> be included in a block, the block would be invalid and the miner would lose
> the block reward and fees.
>
> So-called "censorship" soft forks do not require nodes to opt in, because
> >51% of the hash power already have the ability to orphan blocks that
> contain transactions they have blacklisted. Since this is not a change in
> validity, nodes will accept the censored block chain automatically.
>
> The fourth problem with supermajority hash power signaling is it draws
> unnecessary attention to miners which can become unnecessarily political.
> Already misunderstood as a vote, miners may feel pressure to "make a
> decision" on behalf of the community: who is and isn't signalling becomes a
> huge public focus and may put pressures onto miners they are unprepared
> for. Some miners may not be in a position to upgrade, or may prefer not to
> participate in the soft fork which is their right. However, that miner may
> now become a lone reason that vetoes activation for everyone, where the
> soft fork is an opt-in feature! This situation seems to be against the
> voluntary nature of the Bitcoin system where participation at all levels is
> voluntary and kept honest by well balanced incentives.
>
> Since miners already have the protocol level right to select whatever
> transaction they prefer (and not mine those they don't), it would be better
> if a miner could chose to not participate in triggering activation of
> something they won't use, but, without being a veto to the process (and all
> the ire they may have to experience as a consequence).
>
> The alternative discussed here is "flag day activation" where nodes begin
> enforcement at a predetermined time in the future. This method needs a
> longer lead time than a hash power based activation trigger, but offers a
> number of advantages and perhaps provides a better tradeoff.
>
> Soft forks are still entirely optional to use post activation. For
> example, with P2SH, many participants in the Bitcoin ecosystem still do not
> use P2SH. Only 11% of bitcoins[2] are stored in P2SH addresses at the time
> of writing. Miners are free to not mine P2SH transactions, however, the
> incentives are such that miners should still validate transactions so they
> don't accidentally include invalid transactions and cause their block to be
> rejected. As an additional safety measure for well designed soft forks,
> relay policy rules prevent non-standard and invalid transactions from being
> relayed and mined by default; a miner would have to purposefully mine an
> invalid transaction, which is against their own economic interest.
>
> Since the incentives of the Bitcoin system rely on self validation,
> economic nodes (miners and users) should always remain safe by ensuring
> their nodes either validate the current rules, or, they can place their
> network behind a full node that will filter out invalid transactions and
> blocks at the edge of their network (so called firewall or border nodes).
>
> A user activated soft fork is permissive. Miners do not have to produce
> new version blocks and non-upgraded miners' blocks will not be orphaned as
> was the case with IsSuperMajority soft forks (e.g. BIP34, BIP66,
> BIP65-CLTV) which made it a compulsory upgrade for miners.
>
> BIP9 "versionbits" soft fork activation method is also permissive in so
> far as non-upgraded miners are not forced to upgrade after activation
> because their blocks wont be orphaned. A recent case was the "CSV" soft
> fork that activated BIP68, BIP112 and BIP113. As such, the CSV soft fork
> allows non-upgraded miners to continue mining so long as they didn't
> produce invalid blocks.
>
> Miners always retain discretion on which transactions to mine. However,
> regardless of whether they actively include transactions using the new soft
> fork feature, or not, the incentive for hash power to upgrade in order to
> validate is strong: if they do not, they could be vulnerable to a rogue
> miner willing to waste 12.5BTC to create an invalid block, which may cause
> non-validating miners to build on an invalid chain similar to the BIP66
> incident. Validation has always had a strong requirement.
>
> A user activated soft fork is win-win because it adds an option that some
> people want that does not detract from other peoples' enjoyment. Even if
> only 10% of users ever wanted a feature, so long as the benefit outweighed
> the technical risks, it would not be rational to deny others the ability to
> opt-in.
>
> My suggestion is to have the best of both worlds. Since a user activated
> soft fork needs a relatively long lead time before activation, we can
> combine with BIP9 to give the option of a faster hash power coordinated
> activation or activation by flag day, whichever is the sooner. In both
> cases, we can leverage the warning systems in BIP9. The change is
> relatively simple, adding an activation-time parameter which will
> transition the BIP9 state to LOCKED_IN before the end of the BIP9
> deployment timeout.
>
> You can find the proposal here https://gist.github.com/shaolinfry/
> 0f7d1fd22743bb966da0c0b1682ea2ab
>
> References:
>
> [1]: https://bitcoin.org/en/alert/2015-07-04-spv-mining
> [2]: http://p2sh.info/dashboard/db/p2sh-statistics?from=
> 1472043312917&to=1488030912918
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170226/82166427/attachment-0001.html>

From henning.kopp at uni-ulm.de  Mon Feb 27 09:15:29 2017
From: henning.kopp at uni-ulm.de (Henning Kopp)
Date: Mon, 27 Feb 2017 10:15:29 +0100
Subject: [bitcoin-dev] SHA1 collisions make Git vulnerable to attakcs by
 third-parties, not just repo maintainers
In-Reply-To: <81BE82BA-EDFC-45D1-84DE-D65EC24C9F41@mac.com>
References: <mailman.22137.1487974823.31141.bitcoin-dev@lists.linuxfoundation.org>
	<8F096BE1-D305-43D4-AF10-2CC48837B14F@gmail.com>
	<20170225010122.GA10233@savin.petertodd.org>
	<208F93FE-B7C8-46BE-8E00-52DBD0F43415@gmail.com>
	<CAN6UTayzQRowtWhLKr8LyFuXjw3m+GjQGtHfkDj-Xu41Hym32w@mail.gmail.com>
	<CAEM=y+WkgSkc07ZsU6APAkcu37zVZ7dwSc=jAg1nho31S5ZyxQ@mail.gmail.com>
	<81BE82BA-EDFC-45D1-84DE-D65EC24C9F41@mac.com>
Message-ID: <20170227091529.GB2538@banane.informatik.uni-ulm.de>

Hi all,

I did not follow the whole discussion, but wanted to throw in some
literature on the failure of crypto primitives in Bitcoin.

There is a paper which discusses the problems, but does not give any
remedies: https://eprint.iacr.org/2016/167.pdf

And there are also contingency plans on the wiki:
https://en.bitcoin.it/wiki/Contingency_plans These are not very
detailed and my impression is that this information should be viewed
very critically (E.g., when ECDSA is broken, the suggested vague
response is "Switch to the stronger algorithm." Yeah. And "Code for
all of this should be prepared." Surely. As far as I know, there is no
such code and no-one is working on it).

Best,
Henning


On Sat, Feb 25, 2017 at 09:45:36AM -0800, Shin'ichiro Matsuo via bitcoin-dev wrote:
> We should distinguish collision resistance from 2nd pre-image resistance, in general.
> 
> As previously written, we should care both hash output length and algorithm itself. The weakness of SHA-0 (preliminary version of SHA-1) was reported in 2004, then many research on the structure of SHA-1 were conducted. In the case of SHA-2, it is harder than SHA-1 to find collisions.
> 
> Existing security consideration and evaluation criteria were extensively discussed in the NIST SHA-3 competition. Please see the following sites.
> 
> https://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo
> https://ehash.iaik.tugraz.at/wiki/Cryptanalysis_Categories
> 
> We need similar analysis on RIPEMD160 and impacts of attacks on (RIPEMD160(SHA2(msg)). 
> 
> We can also refer the security assumption of hash chain in Asiacrypt 2004 Paper. 
> https://home.cyber.ee/~ahtbu/timestampsec.pdf
> 
> In the discussion of SHA3 competition, we choose another hash design structure, so called "sponge structure." This leads diversity of design principles of hash function and gives resilience even when one hash design structure becomes vulnerable. As Peter Todd wrote, discussion on design structure and algorithm is important. Discussions on all of algorithm, output length and security requirements are needed.
> 
> At some future moment, we should think about transition of underlying hash functions. I?m working on this subject and will present an idea at IEEE S&B.
> 
> Shin?ichiro Matsuo
> 
> 
> > On Feb 25, 2017, at 8:10 AM, Ethan Heilman via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > 
> > >SHA1 is insecure because the SHA1 algorithm is insecure, not because 160bits isn't enough.
> > 
> > I would argue that 160-bits isn't enough for collision resistance. Assuming RIPEMD-160(SHA-256(msg)) has no flaws (i.e. is a random oracle), collisions can be generated in 2^80 queries (actually detecting these collisions requires some time-memory additional trade-offs). The Bitcoin network at the current hash rate performs roughly SHA-256 ~2^78 queries a day or 2^80 queries every four days. Without any break in RIPEMD-160(SHA-256(msg)) the US could build an ASIC datacenter and produce RIPEMD-160 collisions for a fraction of its yearly cryptologic budget.
> > 
> > The impact of collisions in RIPEMD-160(SHA-256(msg)) according to "On Bitcoin Security in the Presence of Broken Crypto Primitives"(https://eprint.iacr.org/2016/167.pdf):
> > 
> > >Collisions are similar, though in this case both public keys are under the adversary?s control, and again the adversary does not have access to the private keys. In both scenarios, there is a question of nonrepudiation external to the protocol itself: by presenting a second pre-image of a key used to sign a transaction, a user/adversary can claim that his coins were stolen. 
> > 
> > How would such an event effect the price of Bitcoin when headlines are "Bitcoin's Cryptography Broken"? How much money could someone make by playing the market in this way? 
> > 
> > For both reasons of credibility and good engineering (safety margins) Bitcoin should strive to always use cryptography which is beyond reproach.
> > 
> > 
> > On Sat, Feb 25, 2017 at 9:50 AM, Leandro Coutinho via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Google recommeds "migrate to safer cryptographic hashes such as SHA-256 and SHA-3"
> > It does not mention RIPEMD-160
> > 
> > https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html?m=1
> > 
> > 
> > Em 25/02/2017 10:47, "Steve Davis via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> escreveu:
> > 
> > > On Feb 24, 2017, at 7:01 PM, Peter Todd <pete at petertodd.org> wrote:
> > >
> > > On Fri, Feb 24, 2017 at 05:49:36PM -0600, Steve Davis via bitcoin-dev wrote:
> > >> If the 20 byte SHA1 is now considered insecure (with good reason), what about RIPEMD-160 which is the foundation of Bitcoin addresses?
> > >
> > > SHA1 is insecure because the SHA1 algorithm is insecure, not because 160bits isn't enough.
> > >
> > > AFAIK there aren't any known weaknesses in RIPEMD160,
> > 
> > ?so far. I wonder how long that vacation will last?
> > 
> > > but it also hasn't been
> > > as closely studied as more common hash algorithms.
> > 
> > ...but we can be sure that it will be, since the dollar value held in existing utxos continues to increase...
> > 
> > > That said, Bitcoin uses
> > > RIPEMD160(SHA256(msg)), which may make creating collisions harder if an attack
> > > is found than if it used RIPEMD160 alone.
> > 
> > Does that offer any greater protection? That?s not so clear to me as the outputs (at least for p2pkh) only verify the public key against the final 20 byte hash. Specifically, in the first (notional) case the challenge would be to find a private key that has a public key that hashes to the final hash. In the second (realistic) case, you merely need to add the sha256 hash into the problem, which doesn?t seem to me to increase the difficulty by any significant amount?
> > 
> > 
> > /s
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > 
> > 
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > 
> > 
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-- 
Henning Kopp
Institute of Distributed Systems
Ulm University, Germany

Office: O27 - 3402
Phone: +49 731 50-24138
Web: http://www.uni-ulm.de/in/vs/~kopp

From shaolinfry at protonmail.ch  Mon Feb 27 16:02:52 2017
From: shaolinfry at protonmail.ch (shaolinfry)
Date: Mon, 27 Feb 2017 11:02:52 -0500
Subject: [bitcoin-dev] Moving towards user activated soft fork activation
In-Reply-To: <CADL_X_fUuTexNYBt=rZUXRuXpKrpyTiiXYkxTxquispLGV6ezQ@mail.gmail.com>
References: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>
	<CADL_X_fUuTexNYBt=rZUXRuXpKrpyTiiXYkxTxquispLGV6ezQ@mail.gmail.com>
Message-ID: <EMmw5p_aZLoAKdZKan47iSwAq_X9flneBX-1nOOpIpk08NzihG0yZedl0R5G2HLwlrjUCqscSa9uVTKPc83ewQIXbjKOHXSDeX-i8AV7Suw=@protonmail.ch>

Dear Jameson,

Thank you for your questions. Answers inline below:

Jameson Lopp via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


You've made many salient points, Shaolin, though I have a few questions:

1) How well does this model work under adversarial conditions? Fair point about signaling not being reliable, though it seems more vague in terms of safety given that you can't actually know what percentage of hashrate that is /not/ signaling for the soft fork has taken the necessary precautions to avoid mining an invalid block and potentially causing a hard fork. It's probably safe to say that if a flag-day soft fork is activated, there will be at least a few parties who will attempt to trigger a chain fork by crafting transactions that are valid via non-fork rules but invalid via the soft fork rules.

In a well designed soft fork, transactions under the old rules are non-standard by default and will not propagate or be mined. A miner would have to deliberately include the invalid transaction in a block and mine it. The invalid block would be rejected by the network costing the miner block reward and fees.

If >51% of the hashrate does not upgrade or does not take steps to protect themselves from invalid blocks, they will fork if someone produces an invalid block. Game theory suggests the incentive for those who do not wish to participate, would be to do so safely. There is no incentive to allow an attacker to cause you to split off from the network and it is trivial to prevent it.

There is a valid concern about "spy" mining and I cited a previous incident with BIP66 activation and we should be working towards solutions that remove the incentive to spy mine. "Weak blocks", where miners propagate their proposed blocks before solving the PoW may provide better incentives against spy mining, while delivering more (~no propagation delay and full validation, and thus more security).



2) If the flag day soft fork is activated with only a minority of hashrate support + safely opted-out hashrate, isn't it possible for the rest of miners to coordinate orphaning any soft fork compatible blocks to kill the soft fork chain? This would be a major difference from a miner-activated soft fork, correct? Unless perhaps many miners colluded to signal soft fork support while not actually supporting it...

The basic assumption in the Bitcoin system is that miners will remain honest because it is in their economic interest to do so. Of course 51% of the hashrate can censor the minority hash by orphaning blacklisted transactions or blocks. I am fairly certain it would be considered an attack by as well as being very conspicuous. A 51% attack would likely cause a dramatic loss in confidence in the Bitcoin system and adversely affect price. It is reasonable to assume miners would not do that because mining has to remain profitable. Additionally, such a scenario would draw much ire from users who may escalate demands for a PoW change.

It is assuming good-faith and that miners would not want to deny people the ability to opt into something they wanted. All that is required of miners is to upgrade their border node. Miners should update their software anyway for security reasons.



3) In terms of complexity for mining pool operators, how well does this model scale if there are N soft forks and the pool doesn't want to opt-in to any of them? Couldn't this result in those pool operators having to run not just one border node, but a multitude of "chained" border nodes if the soft forks are spread across different software implementations?

While BIP9 allows for 29 parallel deployments I think it is unrealistic to expect there would be such a high number of active parallel deployments at any one time: History shows soft forks take a minimum of 6 months design, consensus building, coding and testing before deployment. With such a high bar, I do not envisage more than a couple of parallel deployments at any given time. I also do not envisage "conflicting" soft forks, as that would not meet consensus from the technical community on the basis of safety and sanity. In any case, the deployment strategy of each soft fork should be considered on a case by case basis.



It seems to me that this type of user-driven approach would preferably be coupled with assurances from major Bitcoin wallets / exchanges / payment processors that they will not honor coins from a chain fork that results from invalid spends of outputs encumbered by soft fork rules. Though on the other hand, I don't see such an assurance being possible given that exchanges have an incentive to take the first mover advantage in listing a new coin.

Soft fork consensus proposals should be sane, uncontroversial and have a reasonably high bar in terms of technical consensus as we have seen with other soft forks to date. There is an implicit assumption in my text, that the decision to deploy a soft fork (regardless of the activation method) is based on a reasonable expectation that users will make use of the new feature. Hashrate signalling is not a vote, but a coordination trigger. Soft forks are backwards compatible and opt-in; so long as they are well written and bug free, users should at worst, be agnostic towards them because they have a choice whether to safely use the new feature or not, without preventing others' enjoyment of the feature. A controversial or unreasonable soft fork would not gain traction and I believe it would be fairly self evident.

In short, I do expect wide ecosystem collaboration as part of any deployment strategy, both hashrate or flag day based.

Many thanks for taking the time to read over and consider my thoughts and proposal. I would be happy to discuss more if you have any further questions or suggestions.



- Jameson



On Sat, Feb 25, 2017 at 6:55 PM, shaolinfry via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

Some thoughts about the activation mechanism for soft forks. In the past we used IsSuperMajority and currently use BIP9 as soft fork activation methods, where a supermajority of hashrate triggers nodes to begin enforcing new rules. Hashrate based activation is convenient because it is the simplest and most straightforward process. While convenient there are a number limitations with this method.

Firstly, it requires trusting the hash power will validate after activation. The BIP66 soft fork was a case where 95% of the hashrate was signaling readiness but in reality about half was not actually validating the upgraded rules and mined upon an invalid block by mistake[1].

Secondly, miner signalling has a natural veto which allows a small percentage of hashrate to veto node activation of the upgrade for everyone. To date, soft forks have taken advantage of the relatively centralised mining landscape where there are relatively few mining pools building valid blocks; as we move towards more hashrate decentralization, it's likely that we will suffer more and more from "upgrade inertia" which will veto most upgrades.

Upgrade inertia in inevitable for widely deployed software and can be seen for example, with Microsoft Windows. At the time of writing 5.72% of all Microsoft Windows installations are still running Windows XP, despite mainstream support ending in 2009 and being superseded by 4 software generations, Vista, 7, 8 and 10.

Thirdly, the signaling methodology is widely misinterpreted to mean the hash power is voting on a proposal and it seems difficult to correct this misunderstanding in the wider community. The hash powers' role is to select valid transactions, and to extend the blockchain with valid blocks. Fully validating economic nodes ensure that blocks are valid. Nodes therefore define validity according to the software they run, but miners decide what already valid transactions gets included in the block chain.

As such, soft forks rules are actually always enforced by the nodes, not the miners. Miners of course can opt-out by simply not including transactions that use the new soft fork feature, but they cannot produce blocks that are invalid to the soft fork. The P2SH soft fork is a good example of this, where non-upgraded miners would see P2SH as spendable without a signature and consider them valid. If such an transaction were to be included in a block, the block would be invalid and the miner would lose the block reward and fees.

So-called "censorship" soft forks do not require nodes to opt in, because >51% of the hash power already have the ability to orphan blocks that contain transactions they have blacklisted. Since this is not a change in validity, nodes will accept the censored block chain automatically.

The fourth problem with supermajority hash power signaling is it draws unnecessary attention to miners which can become unnecessarily political. Already misunderstood as a vote, miners may feel pressure to "make a decision" on behalf of the community: who is and isn't signalling becomes a huge public focus and may put pressures onto miners they are unprepared for. Some miners may not be in a position to upgrade, or may prefer not to participate in the soft fork which is their right. However, that miner may now become a lone reason that vetoes activation for everyone, where the soft fork is an opt-in feature! This situation seems to be against the voluntary nature of the Bitcoin system where participation at all levels is voluntary and kept honest by well balanced incentives.

Since miners already have the protocol level right to select whatever transaction they prefer (and not mine those they don't), it would be better if a miner could chose to not participate in triggering activation of something they won't use, but, without being a veto to the process (and all the ire they may have to experience as a consequence).

The alternative discussed here is "flag day activation" where nodes begin enforcement at a predetermined time in the future. This method needs a longer lead time than a hash power based activation trigger, but offers a number of advantages and perhaps provides a better tradeoff.

Soft forks are still entirely optional to use post activation. For example, with P2SH, many participants in the Bitcoin ecosystem still do not use P2SH. Only 11% of bitcoins[2] are stored in P2SH addresses at the time of writing. Miners are free to not mine P2SH transactions, however, the incentives are such that miners should still validate transactions so they don't accidentally include invalid transactions and cause their block to be rejected. As an additional safety measure for well designed soft forks, relay policy rules prevent non-standard and invalid transactions from being relayed and mined by default; a miner would have to purposefully mine an invalid transaction, which is against their own economic interest.

Since the incentives of the Bitcoin system rely on self validation, economic nodes (miners and users) should always remain safe by ensuring their nodes either validate the current rules, or, they can place their network behind a full node that will filter out invalid transactions and blocks at the edge of their network (so called firewall or border nodes).

A user activated soft fork is permissive. Miners do not have to produce new version blocks and non-upgraded miners' blocks will not be orphaned as was the case with IsSuperMajority soft forks (e.g. BIP34, BIP66, BIP65-CLTV) which made it a compulsory upgrade for miners.

BIP9 "versionbits" soft fork activation method is also permissive in so far as non-upgraded miners are not forced to upgrade after activation because their blocks wont be orphaned. A recent case was the "CSV" soft fork that activated BIP68, BIP112 and BIP113. As such, the CSV soft fork allows non-upgraded miners to continue mining so long as they didn't produce invalid blocks.

Miners always retain discretion on which transactions to mine. However, regardless of whether they actively include transactions using the new soft fork feature, or not, the incentive for hash power to upgrade in order to validate is strong: if they do not, they could be vulnerable to a rogue miner willing to waste 12.5BTC to create an invalid block, which may cause non-validating miners to build on an invalid chain similar to the BIP66 incident. Validation has always had a strong requirement.

A user activated soft fork is win-win because it adds an option that some people want that does not detract from other peoples' enjoyment. Even if only 10% of users ever wanted a feature, so long as the benefit outweighed the technical risks, it would not be rational to deny others the ability to opt-in.

My suggestion is to have the best of both worlds. Since a user activated soft fork needs a relatively long lead time before activation, we can combine with BIP9 to give the option of a faster hash power coordinated activation or activation by flag day, whichever is the sooner. In both cases, we can leverage the warning systems in BIP9. The change is relatively simple, adding an activation-time parameter which will transition the BIP9 state to LOCKED_IN before the end of the BIP9 deployment timeout.

You can find the proposal here https://gist.github.com/shaolinfry/0f7d1fd22743bb966da0c0b1682ea2ab

References:

[1]: https://bitcoin.org/en/alert/2015-07-04-spv-mining
[2]: http://p2sh.info/dashboard/db/p2sh-statistics?from=1472043312917&to=1488030912918

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170227/5f3d5943/attachment-0001.html>

From eric at voskuil.org  Mon Feb 27 16:50:07 2017
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 27 Feb 2017 08:50:07 -0800
Subject: [bitcoin-dev] Moving towards user activated soft fork activation
In-Reply-To: <EMmw5p_aZLoAKdZKan47iSwAq_X9flneBX-1nOOpIpk08NzihG0yZedl0R5G2HLwlrjUCqscSa9uVTKPc83ewQIXbjKOHXSDeX-i8AV7Suw=@protonmail.ch>
References: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>
	<CADL_X_fUuTexNYBt=rZUXRuXpKrpyTiiXYkxTxquispLGV6ezQ@mail.gmail.com>
	<EMmw5p_aZLoAKdZKan47iSwAq_X9flneBX-1nOOpIpk08NzihG0yZedl0R5G2HLwlrjUCqscSa9uVTKPc83ewQIXbjKOHXSDeX-i8AV7Suw=@protonmail.ch>
Message-ID: <09746CD6-10FB-4F3B-B4E1-AE12E504141B@voskuil.org>

On Feb 27, 2017, at 8:02 AM, shaolinfry via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

>> 3) In terms of complexity for mining pool operators, how well does this model scale if there are N soft forks and the pool doesn't want to opt-in to any of them? Couldn't this result in those pool operators having to run not just one border node, but a multitude of "chained" border nodes if the soft forks are spread across different software implementations?
> 
> While BIP9 allows for 29 parallel deployments I think it is unrealistic to expect there would be such a high number of active parallel deployments at any one time: History shows soft forks take a minimum of 6 months design, consensus building, coding and testing before deployment. With such a high bar, I do not envisage more than a couple of parallel deployments at any given time. I also do not envisage "conflicting" soft forks, as that would not meet consensus from the technical community on the basis of safety and sanity. In any case, the deployment strategy of each soft fork should be considered on a case by case basis.

The relationship between a codebase and chain fork implementations is similar to vendor lock-in, and is being used in a similar manner.

There is nothing preventing a single codebase from implementing all forks and exposing the option to apply any non-conflicting combination of them.

While this has not been the norm libbitcoin now utilizes this approach. Currently the options to apply any activated Bitcoin forks are exposed via config. I personally am not working to implement non-activated forks at this point, but that's just prioritization.

Recently I objected to BIP90. This hard fork is presented as a code simplification and a performance optimization. I showed in the discussion that it was neither. Nevertheless we implemented this additional code and give the user the option to apply it or not. It's application produces no performance benefit, but it ensures that the choice of forks remains in the hands of the user.

e

From g.andrew.stone at gmail.com  Tue Feb 28 16:43:29 2017
From: g.andrew.stone at gmail.com (G. Andrew Stone)
Date: Tue, 28 Feb 2017 11:43:29 -0500
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkqs8F1hK6y-JnLFRpqhQ5i8i+MXVmtGUQBYmE5d1OCAAg@mail.gmail.com>
References: <20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
	<20170224043613.GA32502@savin.petertodd.org>
	<CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>
	<20170225041202.GA11152@savin.petertodd.org>
	<CA+KqGkqs8F1hK6y-JnLFRpqhQ5i8i+MXVmtGUQBYmE5d1OCAAg@mail.gmail.com>
Message-ID: <CAHUwRvtseXUx_ShfHd9r9LW1_8cJYcofQ4s1vEpkpKJEniDTzA@mail.gmail.com>

I can understand how Bram's transaction double sha256 hashed UTXO set
patricia trie allows a client to quickly validate inputs because the inputs
of a transaction are specified in the same manner.  So to verify that an
input is unspent the client simply traverses the patricia trie.

It also makes sense that if transaction inputs were specified by a [block
height, tx index, output index] triple we'd have a much more size-efficient
transaction format.  This format would make look up pretty simple in
Peter's pruned time-ordered TXO merkle mountain range, although you'd have
translate the triple to an index, which means we'd have to at a minimum
keep track of the number of TXOs in each block, and then probably do a
linear search starting from the location where the block's TXOs begin in
the MMR.  (The ultimate option I guess is to specify transaction inputs by
a single number which is essentially the index of the TXO in a (never
actually created) insertion-ordered TXO array...)

But since transactions' prevouts are not specified by [block height, tx
index, output index] or by TXO index, I don't understand how an insertion
ordered TXO tree can result in efficient lookups.  Can you help me
understand this?



On Sat, Feb 25, 2017 at 1:23 AM, Bram Cohen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, Feb 24, 2017 at 8:12 PM, Peter Todd <pete at petertodd.org> wrote:
>
>>
>> So to be clear, what you're proposing there is to use the insertion order
>> as
>> the index - once you go that far you've almost entirely re-invented my
>> proposal!
>>
>
> I'm not 'proposing' this, I'm saying it could be done simply but I'm
> skeptical of the utility. Probably the most compelling argument for it is
> that the insertion indexed values are much smaller so they can be compacted
> down a lot resulting in using less memory and more locality and fewer
> hashes, but your implementation doesn't take advantage of that.
>
>
>> Your merkle-set implementation is 1500 lines of densely written Python
>
>
> The reference implementation which is included in those 1500 lines is less
> than 300 lines and fairly straightforward. The non-reference implementation
> always behaves semantically identically to the reference implementation, it
> just does so faster and using less memory.
>
>
>> with
>> almost no comments,
>
>
> The comments at the top explain both the proof format and the in-memory
> data structures very precisely. The whole codebase was reviewed by a
> coworker of mine and comments were added explaining the subtleties which
> tripped him up.
>
>
>> and less than a 100 lines of (also uncommented) tests.
>
>
> Those tests get 98% code coverage and extensively hit not only the lines
> of code but the semantic edge cases as well. The lines which aren't hit are
> convenience functions and error conditions of the parsing code for when
> it's passed bad data.
>
>
>> By
>> comparison, my Python MMR implementation is 300 lines of very readable
>> Python
>> with lots of comments, a 200 line explanation at the top, and 200 lines of
>> (commented) tests. Yet no-one is taking the (still considerable) effort to
>> understand and comment on my implementation. :)
>>
>
> Given that maaku's Merkle prefix trees were shelved because of performance
> problems despite being written in C and operating in basically the same way
> as your code and my reference code, it's clear that non-optimized Python
> won't be touching the bitcoin codebase any time soon.
>
>
>>
>> Fact is, what you've written is really daunting to review, and given it's
>> not
>> in the final language anyway, it's unclear what basis to review it on
>> anyway.
>
>
> It should reviewed based on semantic correctness and performance.
> Performance can only be accurately and convincingly determined by porting
> to C and optimizing it, which mostly involves experimenting with different
> values for the two passed in magic numbers.
>
>
>> I
>> suspect you'd get more feedback if the codebase was better commented, in a
>> production language, and you have actual real-world benchmarks and
>> performance
>> figures.
>>
>
> Porting to C should be straightforward. Several people have already
> expressed interest in doing so, and it's written in intentionally C-ish
> Python, resulting in some rather odd idioms which is a bit part of why you
> think it looks 'dense'. A lot of that weird offset math should be much more
> readable in C because it's all structs and x.y notation can be used instead
> of adding offsets.
>
>
>> In particular, while at the top of merkle_set.py you have a list of
>> advantages,
>> and a bunch of TODO's, you don't explain *why* the code has any of these
>> advantages. To figure that out, I'd have to read and understand 1500
>> lines of
>> densely written Python. Without a human-readable pitch, not many people
>> are
>> going to do that, myself included.
>>
>
> It's all about cache coherence. When doing operations it pulls in a bunch
> of things which are near each other in memory instead of jumping all over
> the place. The improvements it gets should be much greater than the ones
> gained from insertion ordering, although the two could be accretive.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170228/0d77e5d7/attachment.html>

From luke at dashjr.org  Tue Feb 28 20:59:44 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 28 Feb 2017 20:59:44 +0000
Subject: [bitcoin-dev]  Bitcoin Knots 0.14.0 release candidate 2 available
Message-ID: <201702282059.44714.luke@dashjr.org>

Release candidate 2 of a new major Bitcoin Knots release, version 0.14.0, has
been made available.

This is a release candidate for a new major version release, including new
features, various bugfixes and performance improvements.

Preliminary release notes for the release can be found here:

    https://github.com/bitcoinknots/bitcoin/blob/v0.14.0.knots20170227.rc2/doc/release-notes.md

Binaries can be downloaded from:

    http://bitcoinknots.org/files/0.14.x/0.14.0.knots20170227.rc2/

Please take care to verify the PGP signature of all downloads.

Source code can be found on GitHub under the signed tag

    https://github.com/bitcoinknots/bitcoin/tree/v0.14.0.knots20170227.rc2

Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.14.0 final, otherwise
a new rc will be made available after these are solved.

Please report bugs using the issue tracker at GitHub:

    https://github.com/bitcoinknots/bitcoin/issues

From luke at dashjr.org  Tue Feb 28 21:20:29 2017
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 28 Feb 2017 21:20:29 +0000
Subject: [bitcoin-dev] Moving towards user activated soft fork activation
In-Reply-To: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>
References: <jo5-7HCZX7tgdMpIQgK85HCPP14FWxvOIbjV_oerIfc-HOP1GbK3SxFX82Ls23yU1L7y95QsFFggddMNdo5Sxy7YhTJhRFN1f8d6PaA8b7s=@protonmail.ch>
Message-ID: <201702282120.29614.luke@dashjr.org>

Without at least a majority hashrate validating blocks, it is possible just a 
single invalid block could split the chain such that the majority continue 
building a most-work on that invalid block.

This failure to validate a softfork is similar in some respects to a hardfork, 
but with one critical difference: the default behaviour of old nodes will be 
to follow the chain with the most-work that was valid under the pre-softfork 
rules. This actually *inverts* the benefit of the softfork over a hardfork, 
and makes a softfork deployed in such a manner de facto behave as if it had 
been a hardfork, IF someone ever mines a single malicious block.

For this reason, I think a minority-hashrate softfork requires a much higher 
degree of social support than merely the widespread agreement typical of 
softforks. It might perhaps require less than the full ~100% consensus 
hardforks require, but it likely comes somewhat close.

Once it gets over 50% hashrate enforcement, however, the situation improves a 
lot more: a malicious block may split obsolete miners off the valid chain, but 
it will eventually resolve on its own given enough time. Due to natural 
fluctuations in block finding, however, automatic measurement may need to look 
for >75%.

So I would suggest that instead of a simple flag day activation, this proposal 
would be improved by changing the flag day to merely reduce the hashrate 
requirement from 95% to 75%.

(In addition to the above concerns, if >50% of miners are hostile to the 
network, we likely have other problems.)

Luke

From bram at bittorrent.com  Tue Feb 28 23:10:16 2017
From: bram at bittorrent.com (Bram Cohen)
Date: Tue, 28 Feb 2017 15:10:16 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CAHUwRvtseXUx_ShfHd9r9LW1_8cJYcofQ4s1vEpkpKJEniDTzA@mail.gmail.com>
References: <20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
	<20170224043613.GA32502@savin.petertodd.org>
	<CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>
	<20170225041202.GA11152@savin.petertodd.org>
	<CA+KqGkqs8F1hK6y-JnLFRpqhQ5i8i+MXVmtGUQBYmE5d1OCAAg@mail.gmail.com>
	<CAHUwRvtseXUx_ShfHd9r9LW1_8cJYcofQ4s1vEpkpKJEniDTzA@mail.gmail.com>
Message-ID: <CA+KqGkrNDEUB8yzkX+ya1ikb46zmKA6Bt4-skqUgLzo=nnNtUw@mail.gmail.com>

On Tue, Feb 28, 2017 at 8:43 AM, G. Andrew Stone <g.andrew.stone at gmail.com>
wrote:

>
> But since transactions' prevouts are not specified by [block height, tx
> index, output index] or by TXO index, I don't understand how an insertion
> ordered TXO tree can result in efficient lookups.  Can you help me
> understand this?
>

You have to have a lookup table going from prevouts to txo index. Lookups
on that are relatively fast because looking up things in a hashtable is a
single cache miss, while looking up things in a tree is logarithmic cache
misses.

The purported benefit of using txout is that because recent things are
spent much more than old things, there's a lot of clustering of updates. If
you update two things near each other they share the top branches of
updates in the tree, resulting in less hashing and cache misses. But since
everything is log scale I suspect such benefits are small. My guess is
transaction ordering has much larger potential from compression because you
cram information about lots of things into a single leaf node because they
have very small diffs from each other. That said, those benefits are also
smaller than and accretive to the simple implementation tricks I already
implemented which cause things near each other in the tree to be near each
other in memory.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170228/aa032a07/attachment-0001.html>

From pieter.wuille at gmail.com  Tue Feb 28 23:24:28 2017
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 28 Feb 2017 15:24:28 -0800
Subject: [bitcoin-dev] A Better MMR Definition
In-Reply-To: <CA+KqGkrNDEUB8yzkX+ya1ikb46zmKA6Bt4-skqUgLzo=nnNtUw@mail.gmail.com>
References: <20170223235105.GA28497@savin.petertodd.org>
	<CA+KqGkowxEZeAFYa2JJchBDtRkg1p3YZNocivzu3fAtgRLDRBQ@mail.gmail.com>
	<20170224010943.GA29218@savin.petertodd.org>
	<CA+KqGkrOK76S3ffPJmpqYcBwtSeKESqN16yZsrwzDR6JZZmwFA@mail.gmail.com>
	<20170224025811.GA31911@savin.petertodd.org>
	<CA+KqGkq7gavAnAk-tcA+gxL2sWpv3ENhEmHrQHaPdyAsKrLjGg@mail.gmail.com>
	<20170224031531.GA32118@savin.petertodd.org>
	<CA+KqGkrfhg3GnbWwvKXHQ2NWuCnfzYyTPUxRhzYMuDBiNQR4eA@mail.gmail.com>
	<20170224043613.GA32502@savin.petertodd.org>
	<CA+KqGkpi4GvgU-K6vt-U5ZN4AkpjZ0rruzddoJS4-V0TcnyqUQ@mail.gmail.com>
	<20170225041202.GA11152@savin.petertodd.org>
	<CA+KqGkqs8F1hK6y-JnLFRpqhQ5i8i+MXVmtGUQBYmE5d1OCAAg@mail.gmail.com>
	<CAHUwRvtseXUx_ShfHd9r9LW1_8cJYcofQ4s1vEpkpKJEniDTzA@mail.gmail.com>
	<CA+KqGkrNDEUB8yzkX+ya1ikb46zmKA6Bt4-skqUgLzo=nnNtUw@mail.gmail.com>
Message-ID: <CAPg+sBgyToj8NcYSFJ376WNLGXO7aSwpZRvd0zuFeB=rF14rfg@mail.gmail.com>

On Feb 28, 2017 15:10, "Bram Cohen via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

On Tue, Feb 28, 2017 at 8:43 AM, G. Andrew Stone <g.andrew.stone at gmail.com>
wrote:

>
> But since transactions' prevouts are not specified by [block height, tx
> index, output index] or by TXO index, I don't understand how an insertion
> ordered TXO tree can result in efficient lookups.  Can you help me
> understand this?
>

You have to have a lookup table going from prevouts to txo index. Lookups
on that are relatively fast because looking up things in a hashtable is a
single cache miss, while looking up things in a tree is logarithmic cache
misses.


I'm wondering if there is some confusion here.

Yes, someone needs to have a lookup table from prevouts to TXO tree
positions. But because an insertion-ordered TXO tree does not rebalance,
that table can be maintained by wallets or service providers for just their
own coins, instead of by every full node and miner individually for
everyone's coins.

In the simplest committed TXO model, full nodes simply maintain the TXO
root hash, and every transaction/block comes with a proof that its inputs
are in the TXO tree, and the necessary information to update the root after
spending the inputs and adding the outputs.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170228/f1adfec6/attachment.html>

From praxeology_guy at protonmail.com  Tue Feb 28 16:26:40 2017
From: praxeology_guy at protonmail.com (praxeology_guy)
Date: Tue, 28 Feb 2017 11:26:40 -0500
Subject: [bitcoin-dev] TXO commitments do not need a soft-fork to be
	useful
Message-ID: <36Wl_TAWzRgoaNizB_2tyZG9i285MWuPhnmO7RE9KbXbOG9mtFOHrbs2J33bby-nO2JDNnsK07fGKOYjjkMdPc1l-OWtuMH3G9CJgCEI0ao=@protonmail.com>

Peter Todd & Eric Lombrozo,

I also think communicating the UTXO would be increadibly useful. I just made a writeup called "Synchronization Checkpoints" on github. "https://github.com/bitcoin/bitcoin/issues/9885" This idea also doesn't use commitments.

But... Commitments would be a plus, because then we having all of the miners verifying the UTXO. Below I brainstorm on how to make this happen with my "Synchronization Checkpoints" idea.

I think if there were commitments, such would not be feasible without it being a commitment on the UTXO as it was N blocks in the past rather than the highest block's UTXO set... because just one little fork of height 1 would be a big waste of effort for the miners.

- Miners would put a commitment at the current Checkpoint Block that would be a hash of the full state of the UTXO at the previous Checkpoint Block.
- I'll point out that blocks are like "incremental diffs" to the UTXO state.

I was thinking that say if a miner and other nodes are OK with storing multiple copies/backups of the UTXO state then to make this work with high performance:
1. Maintain a DB table who's only purpose is to sort UTXO.txid concat UTXO.vout.index.
2. Some Wait for no Forks blocks after a CheckPoint Block is made, begin populating a new UTXO Checkpoint File that is a serialized sorted UTXO set.
3. Merkle tree or bittorrent style hash the UTXO Checkpoint File
4. Party!

Cheers,
Praxeology
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20170228/354c0708/attachment.html>

