From runesvend at gmail.com  Sat Jun  1 13:12:32 2013
From: runesvend at gmail.com (=?ISO-8859-1?Q?Rune_Kj=E6r_Svendsen?=)
Date: Sat, 1 Jun 2013 15:12:32 +0200
Subject: [Bitcoin-development] Implementing batch processing for
	-blocknotify
In-Reply-To: <CALn1vHGFWSbKDhm0_hkJOoZzMGicERJ9=1uHUqFhOyw8xMNqgA@mail.gmail.com>
References: <CAH2=CKzW41TYbX6c1F8oknA_LttOaA8vmDPmojuowXgEADY61g@mail.gmail.com>
	<CALn1vHG5VbT4BeFW89DCAx0fzkjaGpABEMEZO42pAs-wdi-e5Q@mail.gmail.com>
	<CA+s+GJBo18mC84=09vEYZ0n7WVeA0MV2OfdvFDap0_sW7TinyA@mail.gmail.com>
	<CALn1vHGFWSbKDhm0_hkJOoZzMGicERJ9=1uHUqFhOyw8xMNqgA@mail.gmail.com>
Message-ID: <CAH2=CKy5=s3MvNMS6gLj2HZG-5EW5buy5odcnYYf0rZa84t+TQ@mail.gmail.com>

Thanks for the input all! You make a lot of sense :). I will go with the
Unix socket method, I think. It's about time I learn about those.

/Rune


On Sat, Jun 1, 2013 at 1:47 AM, Chris Double <chris.double at double.co.nz>wrote:

> On Sat, Jun 1, 2013 at 11:29 AM, Wladimir <laanwj at gmail.com> wrote:
> > Using zmq is a great fit for high-speed notifications such as this. Have
> you
> > seen the pull request to integrate zmq directly into bitcoind, so that
> you
> > don't even need -blocknotify?
> >
> > https://github.com/bitcoin/bitcoin/pull/2415
> >
> > If not: we could use some testing there!
>
> I hadn't seen this, thanks! I've integrated zmq myself for block
> notifications in bitcoin and the alt coins I use it on my bitparking
> merge mining pool. I would love to see something official. I'll try
> out the patch in the pull request.
>
> Chris.
> --
> http://www.bluishcoder.co.nz
>
>
> ------------------------------------------------------------------------------
> Get 100% visibility into Java/.NET code with AppDynamics Lite
> It's a free troubleshooting tool designed for production
> Get down to code-level detail for bottlenecks, with <2% overhead.
> Download for free and get started troubleshooting in minutes.
> http://p.sf.net/sfu/appdyn_d2d_ap2
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/b17539b1/attachment.html>

From pete at petertodd.org  Sat Jun  1 19:30:36 2013
From: pete at petertodd.org (Peter Todd)
Date: Sat, 1 Jun 2013 15:30:36 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make anyone-can-spend
 outputs unspendable for 100 blocks
Message-ID: <20130601193036.GA13873@savin>

Currently the most compact way (proof-size) to sacrifice Bitcoins that
does not involve making them unspendable is to create a anyone-can-spend
output as the last txout in the coinbase of a block:

scriptPubKey: <data> OP_TRUE

The proof is then the SHA256 midstate, the txout, and the merkle path to
the block header. However this mechanism needs miner support, and it is
not possible to pay for such a sacrifice securely, or create an
assurance contract to create one.

A anyone-can-spend in a regular txout is another option, but there is no
way to prevent a miner from including a transaction spending that txout
in the same block. Once that happens, there is no way to prove the miner
didn't create both, thus invalidating the sacrifice. The announce-commit
protocol solves that problem, but at the cost of a much larger proof,
especially if multiple parties want to get together to pay the cost of
the sacrifice. (the proof must include the entire tx used to make the
sacrifice)

However if we add a rule where txouts ending in OP_TRUE are unspendable
for 100 blocks, similar to coinbases, we fix these problems. The rule
can be done as a soft-fork with 95% support in the same way the
blockheight rule was implemented. Along with that change
anyone-can-spend outputs should be make IsStandard() so they will be
relayed.

The alternative is sacrifices to unspendable outputs, which is very
undesirable compared to sending the money to miners to further
strengthen the security of the network.

We should always make it easy for people to write code that does what is
best for Bitcoin.

-- 
'peter'[:-1]@petertodd.org
00000000000000ce3427502ee6a254fed27e1cd21a656a335cd2ada79b7b5293
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/9a4fd0e7/attachment.sig>

From pete at petertodd.org  Sat Jun  1 20:58:53 2013
From: pete at petertodd.org (Peter Todd)
Date: Sat, 1 Jun 2013 16:58:53 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <201306012034.31543.luke@dashjr.org>
References: <20130601193036.GA13873@savin> <201306012034.31543.luke@dashjr.org>
Message-ID: <20130601205853.GA24956@savin>

On Sat, Jun 01, 2013 at 08:34:29PM +0000, Luke-Jr wrote:
> On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:
> > scriptPubKey: <data> OP_TRUE
> > 
> > ...
> > Along with that change anyone-can-spend outputs should be make IsStandard()
> > so they will be relayed.
> 
> Data does not belong in the blockchain. People running nodes have all 
> implicitly agreed to store the blocks for financial purposes, and storing data 
> is a violation of that social contract. Proof-of-stake may be arguably 
> financial, but I'm sure there must be a way to do it without spamming people 
> against their consent.

We have no way of preventing this, so ensure it's done in a way that
minimizes harm. For instance, my zookeyv key-value consensus system can
be implemented using transactions with txout pairs of the following
form:

Let H(d) = RIPEMD160(SHA256(d))

txout_k*2  : OP_DUP H(key) OP_EQUALVERIFY
txout_k*2+1: OP_DUP H(value) OP_EQUALVERIFY

With an additional rule to allow for references to previous sacrifices
with txouts of the form:

txout_n: OP_DUP H(txid:vout) OP_EQUALVERIFY

This is perfectly compatible with Gregory Maxwell's address pre-image
fix to data-in-chain storage, and at the same time is completely
unblockable by making such transactions more expensive - the whole point
is to prove you've sacrificed funds.

Yet another reason why increasing the blocksize is madness.

-- 
'peter'[:-1]@petertodd.org
0000000000000018235c41836eb88ea45343c746a3704c5a155bb90c7d2d9a48
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130601/857d9a1c/attachment.sig>

From pete at petertodd.org  Sun Jun  2 06:13:27 2013
From: pete at petertodd.org (Peter Todd)
Date: Sun, 2 Jun 2013 02:13:27 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <38A06794-B6B4-45F3-99C1-24B08434536D@gmail.com>
References: <20130601193036.GA13873@savin>
	<38A06794-B6B4-45F3-99C1-24B08434536D@gmail.com>
Message-ID: <20130602061327.GA14148@savin>

On Sat, Jun 01, 2013 at 10:32:07PM -0400, Gavin wrote:
> Feels like a new opcode might be better.
> 
> Eg  <data> 100 OP_NOP1
> 
> ... Where op_nop1 is redefined to be 'verify depth' ... 

Good idea.

Either way, looks like complex announce-commit logic isn't needed and a
simple txout with one of a few possible forms will work.

I'd say we tell people to sacrifice to (provably) unspendable for now
and do a soft-fork later if there is real demand for this stuff in the
future.

> On Jun 1, 2013, at 3:30 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > Currently the most compact way (proof-size) to sacrifice Bitcoins that
> > does not involve making them unspendable is to create a anyone-can-spend
> > output as the last txout in the coinbase of a block:
> > 
> > scriptPubKey: <data> OP_TRUE
> > 
> > The proof is then the SHA256 midstate, the txout, and the merkle path to
> > the block header. However this mechanism needs miner support, and it is
> > not possible to pay for such a sacrifice securely, or create an
> > assurance contract to create one.
> > 
> > A anyone-can-spend in a regular txout is another option, but there is no
> > way to prevent a miner from including a transaction spending that txout
> > in the same block. Once that happens, there is no way to prove the miner
> > didn't create both, thus invalidating the sacrifice. The announce-commit
> > protocol solves that problem, but at the cost of a much larger proof,
> > especially if multiple parties want to get together to pay the cost of
> > the sacrifice. (the proof must include the entire tx used to make the
> > sacrifice)
> > 
> > However if we add a rule where txouts ending in OP_TRUE are unspendable
> > for 100 blocks, similar to coinbases, we fix these problems. The rule
> > can be done as a soft-fork with 95% support in the same way the
> > blockheight rule was implemented. Along with that change
> > anyone-can-spend outputs should be make IsStandard() so they will be
> > relayed.
> > 
> > The alternative is sacrifices to unspendable outputs, which is very
> > undesirable compared to sending the money to miners to further
> > strengthen the security of the network.
> > 
> > We should always make it easy for people to write code that does what is
> > best for Bitcoin.

-- 
'peter'[:-1]@petertodd.org
0000000000000092f448c7630e47584650efa7e27604161c0b5984d603d944ea
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130602/e4620fb3/attachment.sig>

From jgarzik at bitpay.com  Sun Jun  2 17:35:10 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Sun, 2 Jun 2013 13:35:10 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <20130602061327.GA14148@savin>
References: <20130601193036.GA13873@savin>
	<38A06794-B6B4-45F3-99C1-24B08434536D@gmail.com>
	<20130602061327.GA14148@savin>
Message-ID: <CAJHLa0OEUfsZX5caF-urE+Tu9tpgf9xuVjskfoEC8nXO2yZ4ow@mail.gmail.com>

On Sun, Jun 2, 2013 at 2:13 AM, Peter Todd <pete at petertodd.org> wrote:
> I'd say we tell people to sacrifice to (provably) unspendable for now
> and do a soft-fork later if there is real demand for this stuff in the
> future.

That seems fair.

In general, people are actively bloating the UTXO set with unspendable
outputs (that cannot be 100% proven unspendable).  Provably
unspendable seems like an improvement on long term UTXO health.

It is a fair criticism that this inches the incentives, a bit, towards
timestamping and other non-currency uses.  But those uses (a) cannot
be prevented and (b) have already been automated anyway (e.g. the
python upload/download tools stored in-chain).

I do think the overwhelming majority of users are invested in
bitcoin-the-currency (or bitcoin-the-commodity, take your pick), i.e.
the value proposition.  That's our 98% use case.  Given the relative
volumes of traffic, timestamping/data storage/messaging is essentially
getting a free ride.  So IMO it is worth continuing to explore
/disincentives/ for use of the blockchain for data storage and
messaging, for the rare times where a clear currency-or-data-storage
incentive is available.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From pete at petertodd.org  Sun Jun  2 18:41:13 2013
From: pete at petertodd.org (Peter Todd)
Date: Sun, 2 Jun 2013 14:41:13 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAJHLa0OEUfsZX5caF-urE+Tu9tpgf9xuVjskfoEC8nXO2yZ4ow@mail.gmail.com>
References: <20130601193036.GA13873@savin>
	<38A06794-B6B4-45F3-99C1-24B08434536D@gmail.com>
	<20130602061327.GA14148@savin>
	<CAJHLa0OEUfsZX5caF-urE+Tu9tpgf9xuVjskfoEC8nXO2yZ4ow@mail.gmail.com>
Message-ID: <20130602184113.GA19604@savin>

On Sun, Jun 02, 2013 at 01:35:10PM -0400, Jeff Garzik wrote:
> It is a fair criticism that this inches the incentives, a bit, towards
> timestamping and other non-currency uses.  But those uses (a) cannot
> be prevented and (b) have already been automated anyway (e.g. the
> python upload/download tools stored in-chain).

Yeah, and Bitcoin sacrifices are kind of an odd middle ground there.
It's been suggested to make provably unspendable OP_RETURN IsStandard()
only if the txout value is zero, but considering the sacrifice use-case
I'm thinking we should allow people to throw away coins in a
non-UTXO-bloating way if they choose too.

> I do think the overwhelming majority of users are invested in
> bitcoin-the-currency (or bitcoin-the-commodity, take your pick), i.e.
> the value proposition.  That's our 98% use case.  Given the relative
> volumes of traffic, timestamping/data storage/messaging is essentially
> getting a free ride.  So IMO it is worth continuing to explore
> /disincentives/ for use of the blockchain for data storage and
> messaging, for the rare times where a clear currency-or-data-storage
> incentive is available.

Indeed, just recognize that those disincentives must be implemented in a
way that makes doing the less-harmful thing is to your advantage. For
instance people keep arguing for OP_RETURN to only be allowed as one
txout in a tx, which puts it at a disadvantage relative to just using
unspendable outputs. Similarly because people can play OP_CHECKMULTISIG
games, allow as much data as can be included in that form, 195 bytes.


Of course, you can't block everything:

----- Forwarded message from aitahk2l <aitahk2l at tormail.org> -----

Date: Sun, 02 Jun 2013 02:40:10 +0100
From: aitahk2l <aitahk2l at tormail.org>
To: pete at petertodd.org
Subject: Your timestamper

We spoke a few months back and I sent you some funds to run your
timestamper.

I'm letting you know we're going back to unspendable txout timestamps
for our needs. Your service is great, but I think you have written it
prematurely. Like you said in your recent bitcoin-development post on
sacrifices if the technology enables a use, people will use it. 
Inefficient timestamping is one such use and threatens the blockchain
with unlimited bloat, but from what I hear from Gavin he doesn't see 
decentralization as particularly important.

You really should turn off your OpenTimestamps servers. They mislead
people into a sense of scalability that just isn't there. You'll see 
some of our efforts at 1MBGavinWuiJCF6thGfEriB2WhDD5nhB2a soon;
frankly I think he is the biggest threat Bitcoin faces in the long
term and will back us all into a scalability corner with no good
solutions.

Feel free to forward this message to others.


----- End forwarded message -----

Seems legit - traffic on my timestamper is significantly reduced from
what it was before. Incidentally, I've left the opentimestamps client
deliberately broken for months now to see if anyone used it, and other
than this guy I've had zero bug reports.

-- 
'peter'[:-1]@petertodd.org
0000000000000046da2c6f02bf57f3bdc48a08388e0030fc4490f5fc048516e6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130602/68f8b3a6/attachment.sig>

From adam at cypherspace.org  Sun Jun  2 21:45:54 2013
From: adam at cypherspace.org (Adam Back)
Date: Sun, 2 Jun 2013 23:45:54 +0200
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <20130601193036.GA13873@savin>
References: <20130601193036.GA13873@savin>
Message-ID: <20130602214553.GA11528@netbook.cypherspace.org>

So the idea is that people may want to use proof-of-work unrelated to
bitcoin, and abuse bitcoin to obtain that proof, in a way denominated in BTC
(and with a published USD exchange rate).  And the ways they can do that are
to:

a) create unspendable addresses (which maybe you cant compact in the UTXO
set if the unspendable address choices are not standardized)

b) spend to anyone which I take it goes to a random person who happens to
see the address first and race the "spend to me" out on to the network, and
hope miners dnt replace it with "spend to miner", which is insecure

c) doesnt delay by 100 blocks just delay the "spend to me" race?  Also most
likely to be one by a big miner once they adapt and join the race.

d) some new standardized spend to fees (only miners can claim).

e) spend to charity/non-profit of choice could be useful also

f) I guess we see something related in zerocoin - locked but unlockable via
another type of transaction later.

g) why not instead make the beneficiary the address of the service the user
is consuming that is being DoS protected by the proof-of-sacrifice?  Seems
more useful than burning virtual money, then it helps the bitcoin network
AND it helps the service provide better service!

so if I understand what you proposed d) seems like a useful concept if that
is not currently possible.  eg alternatively could we not just propose a
standard recognized address that clearly no-one knows the EC discrete log
of?

Adam

On Sat, Jun 01, 2013 at 03:30:36PM -0400, Peter Todd wrote:
>Currently the most compact way (proof-size) to sacrifice Bitcoins that
>does not involve making them unspendable is to create a anyone-can-spend
>output as the last txout in the coinbase of a block:
>
>scriptPubKey: <data> OP_TRUE
>
>The proof is then the SHA256 midstate, the txout, and the merkle path to
>the block header. However this mechanism needs miner support, and it is
>not possible to pay for such a sacrifice securely, or create an
>assurance contract to create one.
>
>A anyone-can-spend in a regular txout is another option, but there is no
>way to prevent a miner from including a transaction spending that txout
>in the same block. Once that happens, there is no way to prove the miner
>didn't create both, thus invalidating the sacrifice. The announce-commit
>protocol solves that problem, but at the cost of a much larger proof,
>especially if multiple parties want to get together to pay the cost of
>the sacrifice. (the proof must include the entire tx used to make the
>sacrifice)
>
>However if we add a rule where txouts ending in OP_TRUE are unspendable
>for 100 blocks, similar to coinbases, we fix these problems. The rule
>can be done as a soft-fork with 95% support in the same way the
>blockheight rule was implemented. Along with that change
>anyone-can-spend outputs should be make IsStandard() so they will be
>relayed.
>
>The alternative is sacrifices to unspendable outputs, which is very
>undesirable compared to sending the money to miners to further
>strengthen the security of the network.
>
>We should always make it easy for people to write code that does what is
>best for Bitcoin.
>
>-- 
>'peter'[:-1]@petertodd.org
>00000000000000ce3427502ee6a254fed27e1cd21a656a335cd2ada79b7b5293



>------------------------------------------------------------------------------
>Get 100% visibility into Java/.NET code with AppDynamics Lite
>It's a free troubleshooting tool designed for production
>Get down to code-level detail for bottlenecks, with <2% overhead.
>Download for free and get started troubleshooting in minutes.
>http://p.sf.net/sfu/appdyn_d2d_ap2

>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development




From melvincarvalho at gmail.com  Mon Jun  3 23:43:27 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Tue, 4 Jun 2013 01:43:27 +0200
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <20130601193036.GA13873@savin>
References: <20130601193036.GA13873@savin>
Message-ID: <CAKaEYh+9BZ5WdoyzFSRp+k3_R5TW2qBy+aihK2g_22DWYWgnTQ@mail.gmail.com>

On 1 June 2013 21:30, Peter Todd <pete at petertodd.org> wrote:

> Currently the most compact way (proof-size) to sacrifice Bitcoins that
> does not involve making them unspendable is to create a anyone-can-spend
> output as the last txout in the coinbase of a block:
>
> scriptPubKey: <data> OP_TRUE
>
> The proof is then the SHA256 midstate, the txout, and the merkle path to
> the block header. However this mechanism needs miner support, and it is
> not possible to pay for such a sacrifice securely, or create an
> assurance contract to create one.
>

Sorry if this is a stupid question, but why would someone want to sacrifice
their bitcoins?


>
> A anyone-can-spend in a regular txout is another option, but there is no
> way to prevent a miner from including a transaction spending that txout
> in the same block. Once that happens, there is no way to prove the miner
> didn't create both, thus invalidating the sacrifice. The announce-commit
> protocol solves that problem, but at the cost of a much larger proof,
> especially if multiple parties want to get together to pay the cost of
> the sacrifice. (the proof must include the entire tx used to make the
> sacrifice)
>
> However if we add a rule where txouts ending in OP_TRUE are unspendable
> for 100 blocks, similar to coinbases, we fix these problems. The rule
> can be done as a soft-fork with 95% support in the same way the
> blockheight rule was implemented. Along with that change
> anyone-can-spend outputs should be make IsStandard() so they will be
> relayed.
>
> The alternative is sacrifices to unspendable outputs, which is very
> undesirable compared to sending the money to miners to further
> strengthen the security of the network.
>
> We should always make it easy for people to write code that does what is
> best for Bitcoin.
>
> --
> 'peter'[:-1]@petertodd.org
> 00000000000000ce3427502ee6a254fed27e1cd21a656a335cd2ada79b7b5293
>
>
> ------------------------------------------------------------------------------
> Get 100% visibility into Java/.NET code with AppDynamics Lite
> It's a free troubleshooting tool designed for production
> Get down to code-level detail for bottlenecks, with <2% overhead.
> Download for free and get started troubleshooting in minutes.
> http://p.sf.net/sfu/appdyn_d2d_ap2
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130604/0230ef96/attachment.html>

From mark at monetize.io  Tue Jun  4 00:22:43 2013
From: mark at monetize.io (Mark Friedenbach)
Date: Mon, 03 Jun 2013 17:22:43 -0700
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <20130602061327.GA14148@savin>
References: <20130601193036.GA13873@savin>
	<38A06794-B6B4-45F3-99C1-24B08434536D@gmail.com>
	<20130602061327.GA14148@savin>
Message-ID: <51AD3353.10702@monetize.io>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On Sat, Jun 01, 2013 at 10:32:07PM -0400, Gavin wrote:
>> Feels like a new opcode might be better.
>>
>> Eg  <data> 100 OP_NOP1
>>
>> ... Where op_nop1 is redefined to be 'verify depth' ...
I would suggest the more general 'push depth onto stack'. You can then
use the usual math/relational operators which otherwise have seen little
use.

Assuming it's even a good idea to go down this route at all.

Mark
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.19 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJRrTNTAAoJEAdzVfsmodw4mf0QAJAej83Pth0ZVfua3I5+RR58
7gHpt2rBHP8KuwDH6J3VbxZDKy0n+6/nC5+kjI+G0tYGt3yU4wARJA+afB+zxScT
DPO1iMRxcwOz6KtPWpyCEEOW4ZlILQmbhGyA7XZ+Oy+hZZMBWvPCt4BQsyTjUJ4Y
+gTDqdkNk9B2HZh5gskXRkOYWGB9517tTQ0zYWLtVm2sgeJvRkd73WLZGHm4nrLI
20OLaTP0RuW5+qfV4BSQp/Y3k/9OqrAFXiXo5NAs6PL81x3/IDGKpsfnZNLxPU0i
QLg9RdHZ9769fTgACO8822pLaWQ4LtLB4FA/mVYBhr/ORWSIKfod7TPGF3AYiIpF
db2IESX2HFAxMQ9xTi/2R9zYwCvVpQWwZNse+DEMhoQhykcNv/+sZBE93xHGSgsq
XKBOXLJGCxnUwszz+CSmwrQVmwPqLAU/fFybnAI/6VHMMd8phgNV5oLluAaZyBTi
DpImUul2fqKaJeRjQBB1Qya7az0Qvf4LSHFDQKYYWG/H03R5CxFkxiM/XsiyuzpK
7+MVh6gnWaoayB/eAh0KVgWXUrQQGUBwvVmSk6DU73yQ8Db0BHaxBaUihlsJrMTX
Ybh8d8GSbXsaUjolvJ/dSclcAw7ovW91jqEhRoBq9AKQA23RjHChzT8M1UkXZclZ
8k6XWOJy+NaNmklEwMqF
=iDLz
-----END PGP SIGNATURE-----




From michael at ndrix.org  Tue Jun  4 02:26:16 2013
From: michael at ndrix.org (Michael Hendricks)
Date: Mon, 3 Jun 2013 20:26:16 -0600
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAKaEYh+9BZ5WdoyzFSRp+k3_R5TW2qBy+aihK2g_22DWYWgnTQ@mail.gmail.com>
References: <20130601193036.GA13873@savin>
	<CAKaEYh+9BZ5WdoyzFSRp+k3_R5TW2qBy+aihK2g_22DWYWgnTQ@mail.gmail.com>
Message-ID: <CAFHuXuZpOY5pg2JtNKn773QroqVAkz4Bu-oE_+4aNKU2=C740Q@mail.gmail.com>

On Mon, Jun 3, 2013 at 5:43 PM, Melvin Carvalho <melvincarvalho at gmail.com>wrote:

> Sorry if this is a stupid question, but why would someone want to
> sacrifice their bitcoins?
>

Good question.  One reason is https://en.bitcoin.it/wiki/Fidelity_bonds

Cheers,
Michael
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130603/2d82b7c7/attachment.html>

From jgarzik at bitpay.com  Tue Jun  4 14:12:44 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Tue, 4 Jun 2013 10:12:44 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <20130602214553.GA11528@netbook.cypherspace.org>
References: <20130601193036.GA13873@savin>
	<20130602214553.GA11528@netbook.cypherspace.org>
Message-ID: <CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>

On Sun, Jun 2, 2013 at 5:45 PM, Adam Back <adam at cypherspace.org> wrote:
> d) some new standardized spend to fees (only miners can claim).

> so if I understand what you proposed d) seems like a useful concept if that
> is not currently possible.  eg alternatively could we not just propose a
> standard recognized address that clearly no-one knows the EC discrete log
> of?

I'm one of the people experimenting in this area.  I've long argued
that a zero-output transaction should be permitted -- 100% miner fee
-- as an elegant proof of sacrifice.  Unfortunately that requires a
hard fork.  Also, for most people, it seems likely that a change
transaction would be generated.  That, then, would generate an
already-standard transaction, where inputs > outputs.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From john.dillon892 at googlemail.com  Tue Jun  4 14:55:36 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Tue, 4 Jun 2013 14:55:36 +0000
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>
References: <20130601193036.GA13873@savin>
	<20130602214553.GA11528@netbook.cypherspace.org>
	<CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>
Message-ID: <CAPaL=UUJ+Qu2ejXO6YYOzzDW0jPUpCPAmcw4j30niaT2e7+=Nw@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> I'm one of the people experimenting in this area.  I've long argued
> that a zero-output transaction should be permitted -- 100% miner fee
> -- as an elegant proof of sacrifice.  Unfortunately that requires a
> hard fork.  Also, for most people, it seems likely that a change
> transaction would be generated.  That, then, would generate an
> already-standard transaction, where inputs > outputs.

100% miner fee is not a proof of anything because the miner could have created
that transaction for themselves. You must have proof that all miners had an
equal opportunity at collecting the fee, and the only way to do that is by
Peter's announce-commit protocol, or his unspendable until after n blocks
proposal.

Also the idea of a zero-output transaction is silly. In almost all cases you
are making the sarifice to link that act to an identity, and linking that act
to arbitrary data is far more flexible than any scheme relying on the pubkeys
that paid for the transaction. With a arbitrary data you can slice up the
sacrifice for instance with a merkle-sum-tree, as well as hide what the
sacrifice was for to preserve anonymity. The extra cost in size of the provably
unspendable OP_RETURN scriptPubKey is minimal for the rare time when it isn't
required.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRrf/BAAoJEEWCsU4mNhiP7+MH/RGfo2k+Zd0VoGzv3KSTzBrM
auK9Do2fYp2YvMnT/JFYbz2MgbTcCiKGyZfxjaH+zrqdTFgkgAE53midIv/Rd5/w
kjjifJuqw5AyIN6ANA1TuLQ64elPOXXymsaMqWO8ou0angG6DBI/LZZEG7SXM7+I
Jwk3MXLhFswvvuRif4G2C9v29WqSj4XRxxl3o63ziSYvZPPCHLYHAL9BJaMpDhaw
LxebM088RofzJAoGL1QIeQhDS3aAK4jKSZtJ/6+fwYZQB2Qc3sa1v9IAcCQHE+M3
6oQY0tzEEFg9+xdnSM7J6pW7qW28nFS8Fdr6UkUUlwhI5c4KnIKCtQa3o1mYDFE=
=SHWS
-----END PGP SIGNATURE-----



From jgarzik at bitpay.com  Tue Jun  4 17:42:53 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Tue, 4 Jun 2013 13:42:53 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAPaL=UUJ+Qu2ejXO6YYOzzDW0jPUpCPAmcw4j30niaT2e7+=Nw@mail.gmail.com>
References: <20130601193036.GA13873@savin>
	<20130602214553.GA11528@netbook.cypherspace.org>
	<CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>
	<CAPaL=UUJ+Qu2ejXO6YYOzzDW0jPUpCPAmcw4j30niaT2e7+=Nw@mail.gmail.com>
Message-ID: <CAJHLa0PRNxS7K3YeCx_eXkZQdO8vOCefuGyXMXD7ESq0QEhr+g@mail.gmail.com>

On Tue, Jun 4, 2013 at 10:55 AM, John Dillon
<john.dillon892 at googlemail.com> wrote:
>> I'm one of the people experimenting in this area.  I've long argued
>> that a zero-output transaction should be permitted -- 100% miner fee
>> -- as an elegant proof of sacrifice.  Unfortunately that requires a
>> hard fork.  Also, for most people, it seems likely that a change
>> transaction would be generated.  That, then, would generate an
>> already-standard transaction, where inputs > outputs.
>
> 100% miner fee is not a proof of anything because the miner could have created
> that transaction for themselves. You must have proof that all miners had an
> equal opportunity at collecting the fee, and the only way to do that is by
> Peter's announce-commit protocol, or his unspendable until after n blocks
> proposal.

Absolutely.  It wholly depends on the security model, and
economic-incentives model.  Some use models simply don't care if the
miner created a transaction that gave the fee to themselves.  It might
even be /encouraged/ to do this!  Sure they are paying themselves, but
given bitcoin network difficulty is so high, simply obtaining
payments-go-myself-as-miner transactions is itself difficult.
Producing an identity (my goal) or whatever is just fine, and in such
case becomes simply an additional block reward -- an additional
incentive to buy into this identity creation/management system.

Or exchange "identity" with another token, for another data service of
your choice.

This is no longer a strict "proof of sacrifice" system, if such
behavior is encouraged, but it is nonetheless valid.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From jgarzik at bitpay.com  Tue Jun  4 18:49:54 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Tue, 4 Jun 2013 14:49:54 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <20130604183652.GI45035@giles.gnomon.org.uk>
References: <20130601193036.GA13873@savin>
	<20130602214553.GA11528@netbook.cypherspace.org>
	<CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>
	<CAPaL=UUJ+Qu2ejXO6YYOzzDW0jPUpCPAmcw4j30niaT2e7+=Nw@mail.gmail.com>
	<CAJHLa0PRNxS7K3YeCx_eXkZQdO8vOCefuGyXMXD7ESq0QEhr+g@mail.gmail.com>
	<20130604183652.GI45035@giles.gnomon.org.uk>
Message-ID: <CAJHLa0PjAU-MWfUNRtK9zysQdLsCnNx3EiUjdbqQcCcco=g1=A@mail.gmail.com>

On Tue, Jun 4, 2013 at 2:36 PM, Roy Badami <roy at gnomon.org.uk> wrote:
>> Sure they are paying themselves, but given bitcoin network
>> difficulty is uso high, simply obtaining payments-go-myself-as-miner
>> transactions is itself difficult.
>
> Not for pool operators it isn't.  Nor for people buying hashing power
> from a GPUMAX-type service, if such services still exist (or should
> they exist again in future).

Re-read what I wrote.  That's perfectly OK.  It is analogous to a pool
operator receiving merged mined coins, each time they mine a bitcoin
block.

If you achieve the very high difficulty needed to create a valid
bitcoin block, you have achieved a very high bar.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From roy at gnomon.org.uk  Tue Jun  4 18:36:53 2013
From: roy at gnomon.org.uk (Roy Badami)
Date: Tue, 4 Jun 2013 19:36:53 +0100
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAJHLa0PRNxS7K3YeCx_eXkZQdO8vOCefuGyXMXD7ESq0QEhr+g@mail.gmail.com>
References: <20130601193036.GA13873@savin>
	<20130602214553.GA11528@netbook.cypherspace.org>
	<CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>
	<CAPaL=UUJ+Qu2ejXO6YYOzzDW0jPUpCPAmcw4j30niaT2e7+=Nw@mail.gmail.com>
	<CAJHLa0PRNxS7K3YeCx_eXkZQdO8vOCefuGyXMXD7ESq0QEhr+g@mail.gmail.com>
Message-ID: <20130604183652.GI45035@giles.gnomon.org.uk>

> Sure they are paying themselves, but given bitcoin network
> difficulty is uso high, simply obtaining payments-go-myself-as-miner
> transactions is itself difficult.

Not for pool operators it isn't.  Nor for people buying hashing power
from a GPUMAX-type service, if such services still exist (or should
they exist again in future).



From pete at petertodd.org  Tue Jun  4 20:25:18 2013
From: pete at petertodd.org (Peter Todd)
Date: Tue, 4 Jun 2013 16:25:18 -0400
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAJHLa0PjAU-MWfUNRtK9zysQdLsCnNx3EiUjdbqQcCcco=g1=A@mail.gmail.com>
References: <20130601193036.GA13873@savin>
	<20130602214553.GA11528@netbook.cypherspace.org>
	<CAJHLa0P2qARDGk45Cs0jThp14J+YVvxRGE=wZMhO1XMemP-cWA@mail.gmail.com>
	<CAPaL=UUJ+Qu2ejXO6YYOzzDW0jPUpCPAmcw4j30niaT2e7+=Nw@mail.gmail.com>
	<CAJHLa0PRNxS7K3YeCx_eXkZQdO8vOCefuGyXMXD7ESq0QEhr+g@mail.gmail.com>
	<20130604183652.GI45035@giles.gnomon.org.uk>
	<CAJHLa0PjAU-MWfUNRtK9zysQdLsCnNx3EiUjdbqQcCcco=g1=A@mail.gmail.com>
Message-ID: <20130604202518.GA24069@petertodd.org>

On Tue, Jun 04, 2013 at 02:49:54PM -0400, Jeff Garzik wrote:
> On Tue, Jun 4, 2013 at 2:36 PM, Roy Badami <roy at gnomon.org.uk> wrote:
> >> Sure they are paying themselves, but given bitcoin network
> >> difficulty is uso high, simply obtaining payments-go-myself-as-miner
> >> transactions is itself difficult.
> >
> > Not for pool operators it isn't.  Nor for people buying hashing power
> > from a GPUMAX-type service, if such services still exist (or should
> > they exist again in future).
> 
> Re-read what I wrote.  That's perfectly OK.  It is analogous to a pool
> operator receiving merged mined coins, each time they mine a bitcoin
> block.
> 
> If you achieve the very high difficulty needed to create a valid
> bitcoin block, you have achieved a very high bar.

"High" is relative.

I could make a 100BTC apparently sacrifice via fees by just waiting a
month or two for my mining hardware to find a block that had a
pre-prepared fake sacrifice. It'd cost me roughly 1BTC when you take
orphans into account. Similarly I could hack into a pool and have them
do it on my behalf, or a pool could just offer the service for a fee.

I already worry enough that announce-commit sacrifices to mining fees
aren't secure enough given the potential of a few large pools teaming
up to create them cheaply, let alone what you're talking about...


Hey Luke: so what's the going rate to get Eligius to mine a fake mining
fee sacrifice? Can I get a discount on repeat orders? :)

-- 
'peter'[:-1]@petertodd.org
000000000000014c5bfacfca559fd6a9519dcd338f9fca6590eda7d156120013
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130604/0f3549cf/attachment.sig>

From melvincarvalho at gmail.com  Wed Jun  5 17:01:42 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Wed, 5 Jun 2013 19:01:42 +0200
Subject: [Bitcoin-development] Fwd: Creating a Currency for the (Read /
	Write) Web
In-Reply-To: <CAKaEYhK0UWzQ8TbU3cCXvUSbz-f82n-BFaRmLdSjXzO8bGrdsA@mail.gmail.com>
References: <CAKaEYhK0UWzQ8TbU3cCXvUSbz-f82n-BFaRmLdSjXzO8bGrdsA@mail.gmail.com>
Message-ID: <CAKaEYhJySt48jonHEKaG=jtDfs2VoHYXGtXimKf1MAAzJVE6nQ@mail.gmail.com>

FYI: I think this may be a possible blue print for a web version of
bitcoin+ripple combined.

---------- Forwarded message ----------
From: Melvin Carvalho <melvincarvalho at gmail.com>
Date: 5 June 2013 18:50
Subject: Creating a Currency for the (Read / Write) Web
To: public-rww <public-rww at w3.org>, Nathan Rixham <nrixham at gmail.com>, Web
Payments <public-webpayments at w3.org>


I've been thinking for a while about how to create a currency for the read
write web.  And I thought I'd share some preliminary ideas.  Essentially
this is bitcoin+ripple translated to the Web.

*Introduction

*
For those not familiar with the bitcoin concept it's essentially a
distributed ledger where each subject is a primary key in the ledger and
can hold 0 or more coins.  Coins are transferred using a signed and
timestamped PKI transaction log from one address to another, in a
distributed data base.

*Addresses

*
I think using a portable URI for addresses is the thing that makes most
sense.  So possibilities for this may be a URN, or schemes such as di:
(digest) or ni: (named information).  Anyone should be able to generate an
address, and they should be wide ranging to improve liquidity.

*Balances

*
Balances can be calculated by summing all inputs to that address.  You can
additionally keep a state of balances using the payswarm vocab, or perhaps,
goodRelations

*Transactions

*
I think a distributed data base could be maintained using read / write web
technologies, such as HTTP POST / PATCH or SPARQL Update.  The signatures
could be added using the WebKeys spec.

*Distributed Database

*
There are challenges associated with maintaining a distributed database.  I
suggest we start small and whoever opts in can become part of the
verification process.  There are two recent methods for mitigating race
conditions an important one of which is called "double spend".  One is
proof of work, the other is consensus based on a unique node list.  I would
suggest using both techniques.  I'd like it to be possible to use both HTTP
(with self signed certificates), HTTP, and (secure) websockets too as the
transport layer.

*Coin Creation

*
This tends to be the most contentious point, with people tending not to
like the "premine" concept where you allocate coins to yourself.  However
companies like opencoin have successfully rolled out multi million or even
billion dollar premine schemes.  I would suggest coin creation in line with
bitcoin, where they are created proportionally to those maintaining the
integrity of rhe shared database.

*Spam Protection

*
Given the nature of the system, it may be easy to spam the network with
micro transactions.  As such there should be a transaction fee where those
that pay the highest fee are prioritized.

*Trust and Reputation

*
I think it would also help to have a trust and reputation system added to
the process, such that honest nodes benefit from acting honestly, and nodes
which are dishonest or not up to date are considered less dubious.  The
nature of the function should be that it's exponentially harder to gain
trust after you have a certain score.  Similar to chess ELO ratings.

*Linked Data and Exensibility

*
I think there should be a deep integration with web principles and linked
data to promote an app eco system and allow unexpected reuse.  Also it
should allow extensions such as the ripple protocol's trust lines, IOUs and
distributed markets, which are not initially scoped out.  Reusing existing
concepts such as the bitcon blockchain (e.g. so-called coloured coins),
ripple ledger, opentransactions, payswarm and web credits should all be
doable.


Just some food for thought.  Criticisms welcome.  Please let me know if
you're interested in running a node, and maybe we an get a reference
implementation going, as proof of concept.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/348483b9/attachment.html>

From peter at coinlab.com  Thu Jun  6 00:19:16 2013
From: peter at coinlab.com (Peter Vessenes)
Date: Wed, 5 Jun 2013 17:19:16 -0700
Subject: [Bitcoin-development] Revocability with known trusted escrow
	services?
Message-ID: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>

So, this
http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1
article got posted today, noting that FinCEN thinks irrevocable
payments
are money laundering tools.

I will hold my thoughts about the net social good of rent-seeking large
corporations taking money from consumers over fraudulent reversals.
Actually, I won't, I just said it.

At any rate, it got me thinking, can we layer on revocability somehow
without any protocol change, as an opt-in?

My initial scheme is a trusted (hah) escrow service that issues time
promises for signing. If it doesn't receive a cancel message, it will sign
at the end of the time.

The addresses would be listed by the escrow service, or in an open
registry, so you could see if you were going to have a delay period when
you saw a transaction go out.

This seems sort of poor to me, it imagines that mythical thing, a trusted
escrow service, and is vulnerable to griefing, but I thought I'd see if
some of the brighter minds than me can come up with a layer-on approach
here.

When I think about it, I can imagine that I would put a good number of my
coins in a one day reversible system, because I would have warning if
someone wanted to try and spend them, and could do something about it. I'm
not sure if it gets me anything over a standard escrow arrangement, though.

Peter

-- 

------------------------------

[image: CoinLab Logo]PETER VESSENES
CEO

*peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes
71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/a980c720/attachment.html>

From etotheipi at gmail.com  Thu Jun  6 00:34:55 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 05 Jun 2013 20:34:55 -0400
Subject: [Bitcoin-development] Revocability with known trusted escrow
 services?
In-Reply-To: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
Message-ID: <51AFD92F.1020206@gmail.com>

The two most basic ways would be simply:

(1) You create your transactions having a locktime of X days and has
sequence numbers such that it can be replaced exactly once.  The
replacement, can be executed within 30 days.

(2) You simply send money to 1-of-2 transactions:  me-or-you.  If the
person who is receiving it wants it, they have to sign for it by sending
it to one of their own single-sig addresses.  Otherwise, you can return
it to yourself at some point in the future.

I don't totally understand the goal, and how/if these solutions actually
achieve such goal.  But it does add a way for transactions to exist a
non-final state for some amount of time.  But in both cases,
accessibility is still binary:  you have complete access to it, until
you don't.   Which might be seen as the point of irrevocable transfer.

-Alan



On 06/05/2013 08:19 PM, Peter Vessenes wrote:
> So, this
> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1
>  article got posted today, noting that FinCEN thinks irrevocable
> payments are money laundering tools. 
>
> I will hold my thoughts about the net social good of rent-seeking
> large corporations taking money from consumers over fraudulent
> reversals. Actually, I won't, I just said it.
>
> At any rate, it got me thinking, can we layer on revocability somehow
> without any protocol change, as an opt-in?
>
> My initial scheme is a trusted (hah) escrow service that issues time
> promises for signing. If it doesn't receive a cancel message, it will
> sign at the end of the time. 
>
> The addresses would be listed by the escrow service, or in an open
> registry, so you could see if you were going to have a delay period
> when you saw a transaction go out.
>
> This seems sort of poor to me, it imagines that mythical thing, a
> trusted escrow service, and is vulnerable to griefing, but I thought
> I'd see if some of the brighter minds than me can come up with a
> layer-on approach here.
>
> When I think about it, I can imagine that I would put a good number of
> my coins in a one day reversible system, because I would have warning
> if someone wanted to try and spend them, and could do something about
> it. I'm not sure if it gets me anything over a standard escrow
> arrangement, though.
>
> Peter
>
> -- 
>
> ------------------------------------------------------------------------
>
> CoinLab LogoPETER VESSENES 
> CEO
>
> *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856
>  / SKYPE: vessenes 
> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104
>
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/a7e538e5/attachment.html>

From marko.otbalkana at gmail.com  Thu Jun  6 00:53:16 2013
From: marko.otbalkana at gmail.com (Marko Otbalkana)
Date: Wed, 5 Jun 2013 17:53:16 -0700
Subject: [Bitcoin-development] Blockchain alternative storage
Message-ID: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>

Could anyone point me to work/project(s) related to storing the block chain
in a database, like PostgreSQL, MySQL? How about any tools that can read
the block chain from the Satoshi client and convert it into different
formats?

Thanks,
-Marko
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/557f0d62/attachment.html>

From melvincarvalho at gmail.com  Thu Jun  6 01:06:56 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Thu, 6 Jun 2013 03:06:56 +0200
Subject: [Bitcoin-development] Revocability with known trusted escrow
	services?
In-Reply-To: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
Message-ID: <CAKaEYhKsWx4AhLZF+OkKTQwYWxPYe5V8P6MKzcW3hC23ijEReg@mail.gmail.com>

On 6 June 2013 02:19, Peter Vessenes <peter at coinlab.com> wrote:

> So, this
> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1 article got posted today, noting that FinCEN thinks irrevocable payments
> are money laundering tools.
>

It's great that this article quotes the first page of Sasoshi's white
paper.  There are some other text that they missed, though, which I think
may be relevant.

[[
Completely non-reversible transactions are not really possible, since
financial institutions cannot
avoid mediating disputes. The cost of mediation increases transaction
costs, limiting the
minimum practical transaction size and cutting off the possibility for
small casual transactions,
and there is a broader cost in the loss of ability to make non-reversible
payments for non-
reversible services. With the possibility of reversal, the need for trust
spreads. Merchants must
be wary of their customers, hassling them for more information than they
would otherwise need.
A certain percentage of fraud is accepted as unavoidable. These costs and
payment uncertainties
can be avoided in person by using physical currency, but no mechanism
exists to make payments
over a communications channel without a trusted party.

What is needed is an electronic payment system based on cryptographic proof
instead of trust,
allowing any two willing parties to transact directly with each other
without the need for a trusted
third party. Transactions that are computationally impractical to reverse
would protect sellers
from fraud, and routine escrow mechanisms could easily be implemented to
protect buyers.
]]


>
> I will hold my thoughts about the net social good of rent-seeking large
> corporations taking money from consumers over fraudulent reversals.
> Actually, I won't, I just said it.
>
> At any rate, it got me thinking, can we layer on revocability somehow
> without any protocol change, as an opt-in?
>
> My initial scheme is a trusted (hah) escrow service that issues time
> promises for signing. If it doesn't receive a cancel message, it will sign
> at the end of the time.
>
> The addresses would be listed by the escrow service, or in an open
> registry, so you could see if you were going to have a delay period when
> you saw a transaction go out.
>
> This seems sort of poor to me, it imagines that mythical thing, a trusted
> escrow service, and is vulnerable to griefing, but I thought I'd see if
> some of the brighter minds than me can come up with a layer-on approach
> here.
>
> When I think about it, I can imagine that I would put a good number of my
> coins in a one day reversible system, because I would have warning if
> someone wanted to try and spend them, and could do something about it. I'm
> not sure if it gets me anything over a standard escrow arrangement, though.
>
> Peter
>
> --
>
> ------------------------------
>
> [image: CoinLab Logo]PETER VESSENES
> CEO
>
> *peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes
> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/592bb5b3/attachment.html>

From patrick at intersango.com  Thu Jun  6 01:17:30 2013
From: patrick at intersango.com (Patrick Strateman)
Date: Wed, 05 Jun 2013 18:17:30 -0700
Subject: [Bitcoin-development] Blockchain alternative storage
In-Reply-To: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>
References: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>
Message-ID: <51AFE32A.2020301@intersango.com>

If you're only interested in storing the best chain then a fairly simple
schema is possible.

CREATE TABLE blocks (
    hash bytea NOT NULL PRIMARY KEY,
    index integer NOT NULL UNIQUE,
    CONSTRAINT block_hash_size_check CHECK ((octet_length(hash) = (256 /
8)))
);

CREATE TABLE transaction_inputs (
    output_transaction_id bytea NOT NULL,
    output_index integer NOT NULL,
    block_index integer NOT NULL,
    CONSTRAINT transaction_id_size_check CHECK
((octet_length(output_transaction_id) = (256 / 8))),
    PRIMARY KEY (output_transaction_id, output_index)
);

CREATE INDEX transaction_inputs_block_index_idx ON transaction_inputs
USING btree (block_index)

CREATE TABLE transaction_outputs (
    transaction_id bytea NOT NULL,
    index integer NOT NULL,
    amount numeric(16,8) NOT NULL,
    type character varying NOT NULL,
    addresses character varying[],
    block_index integer NOT NULL,
    spent boolean DEFAULT false NOT NULL,
    CONSTRAINT transaction_id_size_check CHECK
((octet_length(transaction_id) = (256 / 8))),
    PRIMARY KEY (transaction_id, index)
);

CREATE INDEX transaction_outputs_addresses_idx ON transaction_outputs
USING gin (addresses);
CREATE INDEX transaction_outputs_block_index_idx ON transaction_outputs
USING btree (block_index);

On 06/05/2013 05:53 PM, Marko Otbalkana wrote:
> Could anyone point me to work/project(s) related to storing the block
> chain in a database, like PostgreSQL, MySQL? How about any tools that
> can read the block chain from the Satoshi client and convert it into
> different formats?
>
> Thanks,
> -Marko
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/3673d6e4/attachment.html>

From petr at praus.net  Thu Jun  6 01:49:22 2013
From: petr at praus.net (Petr Praus)
Date: Wed, 5 Jun 2013 20:49:22 -0500
Subject: [Bitcoin-development] Blockchain alternative storage
In-Reply-To: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>
References: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>
Message-ID: <CACezXZ-KecLVkw3j2fE7ZmXkjVG4ZjdNu_rExo_xDhcbrWCnGQ@mail.gmail.com>

BitcoinJ is storing parsed blocks (not the whole chunks of bytes) in H2, an
embedded SQL database for Java.


On 5 June 2013 19:53, Marko Otbalkana <marko.otbalkana at gmail.com> wrote:

> Could anyone point me to work/project(s) related to storing the block
> chain in a database, like PostgreSQL, MySQL? How about any tools that can
> read the block chain from the Satoshi client and convert it into different
> formats?
>
> Thanks,
> -Marko
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130605/26287145/attachment.html>

From pete at petertodd.org  Thu Jun  6 08:31:16 2013
From: pete at petertodd.org (Peter Todd)
Date: Thu, 6 Jun 2013 04:31:16 -0400
Subject: [Bitcoin-development] Revocability with known trusted escrow
 services?
In-Reply-To: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
Message-ID: <20130606083116.GA23658@savin>

On Wed, Jun 05, 2013 at 05:19:16PM -0700, Peter Vessenes wrote:
> So, this
> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1
> article got posted today, noting that FinCEN thinks irrevocable
> payments
> are money laundering tools.
> 
> I will hold my thoughts about the net social good of rent-seeking large
> corporations taking money from consumers over fraudulent reversals.
> Actually, I won't, I just said it.
> 
> At any rate, it got me thinking, can we layer on revocability somehow
> without any protocol change, as an opt-in?
> 
> My initial scheme is a trusted (hah) escrow service that issues time
> promises for signing. If it doesn't receive a cancel message, it will sign
> at the end of the time.
> 
> The addresses would be listed by the escrow service, or in an open
> registry, so you could see if you were going to have a delay period when
> you saw a transaction go out.
> 
> This seems sort of poor to me, it imagines that mythical thing, a trusted
> escrow service, and is vulnerable to griefing, but I thought I'd see if
> some of the brighter minds than me can come up with a layer-on approach
> here.
> 
> When I think about it, I can imagine that I would put a good number of my
> coins in a one day reversible system, because I would have warning if
> someone wanted to try and spend them, and could do something about it. I'm
> not sure if it gets me anything over a standard escrow arrangement, though.

A few issues:

Revocable payments are almost always invoked in cases where the decision
that a payment needs to be revoked is done by humans. To worry about the
difficulty of finding a "trusted escrow service" is irrelevant at the
protocol level - this isn't a problem that can be solved by math.

Legally speaking revocation can generally happen any time in the future,
even years in the future. Note the controversies involved around a
variety of land transactions that occured hundreds of years in the past
in North America and other parts of the world, where distant relatives
of those who made the transactions are attempting to have them reversed
partially or fully. Technical solutions with a limited revocation window
are likely to be found unacceptable in the eyes of the law.

Focusing on the need to "revoke" a transaction is taking a banking idea,
and applying it very incorrectly to the Bitcoin world; in banking
revoking a transaction can result in your balance being negative.

What you need to focus on is the spirit of what revoking a transaction
is about, which is to take money from someone who thought they had it,
and give it to someone else. We can easily replicate this effect in
Bitcoin by simply giving the private keys for our wallets to the
relevant revocation authority, or, if more auditing is desired, storing
our coins in 1-of-2 multisig addresses spendable by either us or that
authority.

In the event that a transaction needs to be revoked, simply have the
escrow service make a transaction that takes the correct amount of coins
from your wallet, and gives it to the person who sent you the money.

Problem solved.

-- 
'peter'[:-1]@petertodd.org
0000000000000108f8cf27a2a2f49384346d915ff0970554358b9544bc7f5bfd
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/f92a83c2/attachment.sig>

From jouke at bitonic.nl  Thu Jun  6 08:20:50 2013
From: jouke at bitonic.nl (Jouke Hofman)
Date: Thu, 06 Jun 2013 10:20:50 +0200
Subject: [Bitcoin-development] Blockchain alternative storage
In-Reply-To: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>
References: <CALG7eYpKj9Ev2a1PZ7qsiqsazS4pHTPiGF22r64=s1buWm2aLQ@mail.gmail.com>
Message-ID: <51B04662.8060902@bitonic.nl>

Abe is able to do what you want.

https://github.com/jtobey/bitcoin-abe
https://bitcointalk.org/index.php?topic=22785.0

With kind regards,

Jouke Hofman
Bitonic.nl



On 06/06/2013 02:53 AM, Marko Otbalkana wrote:
> Could anyone point me to work/project(s) related to storing the block
> chain in a database, like PostgreSQL, MySQL? How about any tools that
> can read the block chain from the Satoshi client and convert it into
> different formats?
> 
> Thanks,
> -Marko
> 
> 
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> 
> 
> 
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 




From mike at plan99.net  Thu Jun  6 09:03:19 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 6 Jun 2013 11:03:19 +0200
Subject: [Bitcoin-development] Revocability with known trusted escrow
	services?
In-Reply-To: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
Message-ID: <CANEZrP1HhNGeSeD7TbsZtVZLxYKSJZtv8+8VnU6UFLA38tfs9Q@mail.gmail.com>

On Thu, Jun 6, 2013 at 2:19 AM, Peter Vessenes <peter at coinlab.com> wrote:

> So, this
> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1 article got posted today, noting that FinCEN thinks irrevocable payments
> are money laundering tools.
>

That's not how I read it, I don't see how one could argue that irreversible
transactions are a money laundering tool. Credit card transactions aren't
completely reversible either, you have to either claim that the card was
stolen or that the merchant didn't deliver. If you charge back routinely,
then the card companies are supposed to crack down on you. Though I don't
know if that really happens.

I think we should expect the head of FinCEN to argue that more or less
anything can be seen as money laundering. She directly and personally
profits from expansion of the notion of money laundering. That doesn't mean
other people have to agree.


> At any rate, it got me thinking, can we layer on revocability somehow
> without any protocol change, as an opt-in?
>

I think we need 2-of-3 dispute mediation and have thought that for a long
time, indeed, Satoshi's paper says so:

https://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation

It doesn't require any core protocol changes but it does require deployment
of the payment protocol first, as that's the foundation on which we can add
lots of other useful features like that. And then it needs a whole lot of
work to define how you open a dispute from your wallet, how you find
mutually agreeable mediators, etc. Having reversible payments in which one
of the trading parties gets to decide whether to reverse seems pointless to
me. If the buyer decides it's simply equivalent to post pay, and if the
seller decides then it's just a refund, which the payment protocol already
supports.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/2ca93083/attachment.html>

From leszek at bioinfo.pl  Thu Jun  6 09:01:52 2013
From: leszek at bioinfo.pl (Leszek Rychlewski)
Date: Thu, 6 Jun 2013 11:01:52 +0200
Subject: [Bitcoin-development] Revocability with known trusted escrow
	services?
In-Reply-To: <20130606083116.GA23658@savin>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
	<20130606083116.GA23658@savin>
Message-ID: <99A37B1BAC174809801AB928F07F4F46@Leszek>

Transactions with cash are even less revocable (there is no negative cash
balance while a btc wallet can have a negative balance) so it looks like the
authorities are exploiting differences between crypto currencies and the
banking system as an excuse to prosecute members of the new industry.

Collecting arguments against such accusations should suffice [but I like the
maturation concept for dedicated accounts/transactions :-)].

Leszek




From melvincarvalho at gmail.com  Thu Jun  6 11:37:26 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Thu, 6 Jun 2013 13:37:26 +0200
Subject: [Bitcoin-development] address collision and undependability
Message-ID: <CAKaEYhKQ9vyis3X7PLDgFbYijWck-D_hVnp_xt+muhdzjyXeFQ@mail.gmail.com>

There was a discussion on #bitcon-dev yesterday

I stated that it would be impractical to generate two bitcoin addresses,
such that they differed in exactly one character (modulo different
checksums).

The corollary to this is that if you find an address with a verifiable
signature.  Changing one character of that address would have no known
private key, and hence be normally undependable.

Does that sound correct?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/4bd0ab7f/attachment.html>

From bytecoin at gmx.com  Thu Jun  6 12:00:42 2013
From: bytecoin at gmx.com (Byte Coin)
Date: Thu, 06 Jun 2013 14:00:42 +0200
Subject: [Bitcoin-development] address collision and undependability
Message-ID: <20130606120042.96680@gmx.com>

>From https://bitcointalk.org/index.php?topic=20955.msg264038#msg264038

This may be an appropriate thread to mention that the the "checksum" at the end of an address does not effectively prevent single character errors or transpositions.

For instance https://blockexplorer.com/search/1ByteCoin  shows that

1ByteCoinAddressesMatch1kpCWNXmHKW 1ByteCoinAddressesMatch1kpCxNXmHKW 
are both valid addresses even though they only differ by one character.

Similarly, the valid addresses

1ByteCoinAddressesMatchcNN781jjwLY 1ByteCoinAddressesMatchcNN718jjwLY 
only differ by one transposition.

ByteCoin
----- Original Message -----
From: Melvin Carvalho
Sent: 06/06/13 12:37 PM
To: Bitcoin Dev
Subject: [Bitcoin-development] address collision and undependability

There was a discussion on #bitcon-dev yesterday
I stated that it would be impractical to generate two bitcoin addresses, such that they differed in exactly one character (modulo different checksums).
The corollary to this is that if you find an address with a verifiable signature. Changing one character of that address would have no known private key, and hence be normally undependable.
Does that sound correct?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/ec2b4c4c/attachment.html>

From jtimon at monetize.io  Thu Jun  6 16:31:34 2013
From: jtimon at monetize.io (=?ISO-8859-1?Q?Jorge_Tim=F3n?=)
Date: Thu, 6 Jun 2013 18:31:34 +0200
Subject: [Bitcoin-development] Revocability with known trusted escrow
	services?
In-Reply-To: <99A37B1BAC174809801AB928F07F4F46@Leszek>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
	<20130606083116.GA23658@savin>
	<99A37B1BAC174809801AB928F07F4F46@Leszek>
Message-ID: <CAC1+kJMtt5JWULMUDqyVVQrdOB+2NEnG3pez6qpeRvfwWsrHmQ@mail.gmail.com>

P2SH with 2 of 3: the payer, recipient and a trusted third party.
It is explained here:

https://en.bitcoin.it/wiki/Contracts#Example_2:_Escrow_and_dispute_mediation

Nothing can be done at the protocol level if you want it to remain
p2p. Much like the tainted coins stuff.
Maybe offtopic but I disliked what everyone but Alan said in that
bitcoin2013 "security panel" about it.
Well, I didn't like several claims on that panel...


On 6/6/13, Leszek Rychlewski <leszek at bioinfo.pl> wrote:
> Transactions with cash are even less revocable (there is no negative cash
> balance while a btc wallet can have a negative balance) so it looks like
> the
> authorities are exploiting differences between crypto currencies and the
> banking system as an excuse to prosecute members of the new industry.
>
> Collecting arguments against such accusations should suffice [but I like
> the
> maturation concept for dedicated accounts/transactions :-)].
>
> Leszek
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>


-- 
Jorge Tim?n

http://freico.in/



From mark at monetize.io  Thu Jun  6 18:18:26 2013
From: mark at monetize.io (Mark Friedenbach)
Date: Thu, 06 Jun 2013 11:18:26 -0700
Subject: [Bitcoin-development] Revocability with known trusted escrow
 services?
In-Reply-To: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
Message-ID: <51B0D272.5000304@monetize.io>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

If a technical solution could be found, I don't doubt that it will
quickly become the only legal way to do transfers in the U.S.

Peter, you are Executive Director of the Bitcoin Foundation. I would
like to know that your efforts are focused on fighting this archaic
world view, not bending over backwards to comply with it.

Mark
On 6/5/13 5:19 PM, Peter Vessenes wrote:
> So, this http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1  article got posted today, noting that FinCEN thinks irrevocable payments are money laundering tools.
>
> I will hold my thoughts about the net social good of rent-seeking
large corporations taking money from consumers over fraudulent
reversals. Actually, I won't, I just said it.
>
> At any rate, it got me thinking, can we layer on revocability somehow
without any protocol change, as an opt-in?
>
> My initial scheme is a trusted (hah) escrow service that issues time
promises for signing. If it doesn't receive a cancel message, it will
sign at the end of the time.
>
> The addresses would be listed by the escrow service, or in an open
registry, so you could see if you were going to have a delay period when
you saw a transaction go out.
>
> This seems sort of poor to me, it imagines that mythical thing, a
trusted escrow service, and is vulnerable to griefing, but I thought I'd
see if some of the brighter minds than me can come up with a layer-on
approach here.
>
> When I think about it, I can imagine that I would put a good number of
my coins in a one day reversible system, because I would have warning if
someone wanted to try and spend them, and could do something about it.
I'm not sure if it gets me anything over a standard escrow arrangement,
though.
>
> Peter
>
> --
>
> -------------------------
>
> CoinLab LogoPETER VESSENES
> CEO
>
> *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856  /
SKYPE: vessenes
> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104
>
>
>
>
------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.19 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJRsNJyAAoJEAdzVfsmodw4KBgP/A0ozXRdY0YbaFYL5tyWp+xO
OdOKbVFSQynHMws+CyA47x/DgiUbzrRwmx3fN7N67pPizYpjQLfJEwNkr6oy0Ga6
bbubYIz+TLI7sPS0B+ENg6XboChP+ZE7TPC56SyNgPUALwzsvcGZEYCHwwvIUx3F
EcUtXTw+VsBu935nRTvKj2HXruU94CaCiapS0knvgWg1/sB/PRFDQzu+fbBiLSL0
xWiuRaPs4dt+LCK2rfYtysKSv2S0FjOOwZ/Cj2J3KRtqTOnTSE2MZNAfNcMGA89u
LwWAfZohXywk2mBOk6avYxi5I0nNOndzfKQZgyHMH6zYdIP8B4gtBMxNP4CtsLaH
GWNdvYcxILcbeYqJUqlZfJamKkI0rAxgdk20YSaCAgU6rmJ8PQ4Ryl4uTS5i0xOb
xfMmHT68SOsvfL8XWobpMidVIUA+vKDZbd5AmJ9RCvJV5mj0Mrt/nJQM04NEQmtE
gb29fA1vh+nNKkPoVkyU02ghBYznurV+GMd5iFe8LObg6WxcIImadI1tdPpgINoK
glHeUl0zGXsbZDodk7imeZA3DXIf5xa9LfoVmJZrMMB/c3SQqRMwtUX04dMYQiCG
Gq4eisPXrUwepZ6hSgXqGktXYKn9dIlXR43zl4+ZBDjsAIiRiipK12WCz3pUTDow
/Xcx2iVrRWcZQefxJ3dz
=o0rL
-----END PGP SIGNATURE-----

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/83c47ef2/attachment.html>

From luke at dashjr.org  Thu Jun  6 19:14:17 2013
From: luke at dashjr.org (Luke-Jr)
Date: Thu, 6 Jun 2013 19:14:17 +0000
Subject: [Bitcoin-development] Proposal: soft-fork to make
	anyone-can-spend outputs unspendable for 100 blocks
Message-ID: <201306061914.20006.luke@dashjr.org>

On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:
> scriptPubKey: <data> OP_TRUE
> 
> ...
> Along with that change anyone-can-spend outputs should be make IsStandard()
> so they will be relayed.

Data does not belong in the blockchain. People running nodes have all 
implicitly agreed to store the blocks for financial purposes, and storing data 
is a violation of that social contract. Proof-of-stake may be arguably 
financial, but I'm sure there must be a way to do it without spamming people 
against their consent.

> The alternative is sacrifices to unspendable outputs, which is very
> undesirable compared to sending the money to miners to further
> strengthen the security of the network.

The alternative is to make other standard outputs unable to store data as 
well.

Luke



From luke at dashjr.org  Thu Jun  6 20:07:38 2013
From: luke at dashjr.org (Luke-Jr)
Date: Thu, 6 Jun 2013 20:07:38 +0000
Subject: [Bitcoin-development] Proposal: soft-fork to make
	anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAFmyj8zG7iLnwm7iUwxyOXTe3SZxAOFoZdy3=oRa2WqYbiWsHQ@mail.gmail.com>
References: <201306061914.20006.luke@dashjr.org>
	<CAFmyj8zG7iLnwm7iUwxyOXTe3SZxAOFoZdy3=oRa2WqYbiWsHQ@mail.gmail.com>
Message-ID: <201306062007.41398.luke@dashjr.org>

On Thursday, June 06, 2013 7:59:16 PM Andreas M. Antonopoulos wrote:
> Is there any consideration given to the fact that bitcoin can operate as a
> platform for many other services, if it is able to be neutral to payload,
> as long as the fee is paid for the transaction size?

This doesn't work like you might think: first of all, the fees today are 
greatly subsidized - the actual cost to store data in the blockchain is much 
higher than most storage solutions. Secondly, only the miner receives the 
fees, not the majority of nodes which have to bear the burden of the data.
That is, the fee system is setup as an antispam/deterrant, not as payment for 
storage.

> Unless I have misunderstood this discussion, it seems to me that this is a
> bit like saying in 1990 "IP Is only for email, the majority of users want
> email, we shouldn't allow video, voice or images". Ooops, there goes the
> web.

Not the same thing at all; nobody is forced to store/relay video/voice/images 
without reimbursement. On the other hand, any full Bitcoin node is required to 
at least download the entire blockchain once. And the network as a whole 
suffers if nodes decide to start not-storing parts of the blockchain they 
don't want to deal with.

> Is it possible to solve this by solving the issue of provably un-spendable
> outputs without foreclosing on the possibility of other types of
> transaction payloads (ie, not money), that would open the possibility for a
> myriad of layered apps above? For example, hashes of content that is
> external to bitcoin, that people want to pay to have timestamped in the
> blockchain, as provably unspendable outputs.

This is how merged mining solves the problem. A single extra hash in the 
coinbase can link the bitcoin blockchain up with unlimited other data.

> The social compact is to accept transaction for fee. I think it is a major
> mistake to make decisions that discriminate on the content of the
> transaction, saying that some uses are not appropriate. If the fee is paid
> and it covers the size of the transaction, why would it matter if it is not
> a payment?

See above.

> I could be totally misreading this thread, too, so please allow me some
> slack if I have!
> 
> On Thu, Jun 6, 2013 at 12:14 PM, Luke-Jr <luke at dashjr.org> wrote:
> > On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:
> > > scriptPubKey: <data> OP_TRUE
> > > 
> > > ...
> > > Along with that change anyone-can-spend outputs should be make
> > 
> > IsStandard()
> > 
> > > so they will be relayed.
> > 
> > Data does not belong in the blockchain. People running nodes have all
> > implicitly agreed to store the blocks for financial purposes, and storing
> > data
> > is a violation of that social contract. Proof-of-stake may be arguably
> > financial, but I'm sure there must be a way to do it without spamming
> > people
> > against their consent.
> > 
> > > The alternative is sacrifices to unspendable outputs, which is very
> > > undesirable compared to sending the money to miners to further
> > > strengthen the security of the network.
> > 
> > The alternative is to make other standard outputs unable to store data as
> > well.
> > 
> > Luke
> > 
> > 
> > -------------------------------------------------------------------------
> > ----- How ServiceNow helps IT people transform IT departments:
> > 1. A cloud service to automate IT design, transition and operations
> > 2. Dashboards that offer high-level views of enterprise services
> > 3. A single system of record for all IT processes
> > http://p.sf.net/sfu/servicenow-d2d-j
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From andreas at rooteleven.com  Thu Jun  6 20:16:40 2013
From: andreas at rooteleven.com (Andreas M. Antonopoulos)
Date: Thu, 6 Jun 2013 13:16:40 -0700
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <201306062007.41398.luke@dashjr.org>
References: <201306061914.20006.luke@dashjr.org>
	<CAFmyj8zG7iLnwm7iUwxyOXTe3SZxAOFoZdy3=oRa2WqYbiWsHQ@mail.gmail.com>
	<201306062007.41398.luke@dashjr.org>
Message-ID: <CAFmyj8zDCjGR6cLUXQnWP4G0k6A85vdNW03k5NPAVyoJj0eEnQ@mail.gmail.com>

> This doesn't work like you might think: first of all, the fees today are
> greatly subsidized - the actual cost to store data in the blockchain is
> much
> higher than most storage solutions. Secondly, only the miner receives the
> fees, not the majority of nodes which have to bear the burden of the data.
> That is, the fee system is setup as an antispam/deterrant, not as payment
> for
> storage.
>

There's a difference between storing the content itself, and storing just a
hash to content (which however is not spendable payment). I undertand why
content itself doesn't belong. But it goes too far to say that only
payments should be allowed.

If the fees are not enough, fix the fee structure, don't stop incredibly
innovative and promising uses of the distributed timestamping database.
That is definitely throwing the baby out with the bathwater. If the issue
is size, then address that, rather than the content itself.

Have I misunderstood this discussion or are some proposing than nothing
except payments be allowed?

Discriminating based on transaction content violates neutrality of the
protocol and in my mind removes a very very large possibility of future
innovation. If bitcoin is a *platform* and not just a payment system, then
it needs to be neutral to content, like TCP/IP so that other protocols can
be layered. Solve the size problem itself, without picking and chosing
which uses of bitcoin are good and which are "bad" or "spam". I think it
risks killing a tremendous amount of innovation just as it is starting.

>
>
>
> Not the same thing at all; nobody is forced to store/relay
> video/voice/images
> without reimbursement. On the other hand, any full Bitcoin node is
> required to
> at least download the entire blockchain once. And the network as a whole
> suffers if nodes decide to start not-storing parts of the blockchain they
> don't want to deal with.
>
> So don't store content, but allow hashes of content.
Again, I think it is extreme and extremely restrictive to say that ONLY
payments are allowed.



> This is how merged mining solves the problem. A single extra hash in the
> coinbase can link the bitcoin blockchain up with unlimited other data.
>
>
>
Can you explain this part or refer me to some docs? What do you mean by
"coinbase", I assume not the company.


Thanks for the reply and explanation!

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/bd951646/attachment.html>

From andreas at rooteleven.com  Thu Jun  6 19:59:16 2013
From: andreas at rooteleven.com (Andreas M. Antonopoulos)
Date: Thu, 6 Jun 2013 12:59:16 -0700
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <201306061914.20006.luke@dashjr.org>
References: <201306061914.20006.luke@dashjr.org>
Message-ID: <CAFmyj8zG7iLnwm7iUwxyOXTe3SZxAOFoZdy3=oRa2WqYbiWsHQ@mail.gmail.com>

Is there any consideration given to the fact that bitcoin can operate as a
platform for many other services, if it is able to be neutral to payload,
as long as the fee is paid for the transaction size?

Unless I have misunderstood this discussion, it seems to me that this is a
bit like saying in 1990 "IP Is only for email, the majority of users want
email, we shouldn't allow video, voice or images". Ooops, there goes the
web.

Is it possible to solve this by solving the issue of provably un-spendable
outputs without foreclosing on the possibility of other types of
transaction payloads (ie, not money), that would open the possibility for a
myriad of layered apps above? For example, hashes of content that is
external to bitcoin, that people want to pay to have timestamped in the
blockchain, as provably unspendable outputs.

The social compact is to accept transaction for fee. I think it is a major
mistake to make decisions that discriminate on the content of the
transaction, saying that some uses are not appropriate. If the fee is paid
and it covers the size of the transaction, why would it matter if it is not
a payment?

I could be totally misreading this thread, too, so please allow me some
slack if I have!




On Thu, Jun 6, 2013 at 12:14 PM, Luke-Jr <luke at dashjr.org> wrote:

> On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:
> > scriptPubKey: <data> OP_TRUE
> >
> > ...
> > Along with that change anyone-can-spend outputs should be make
> IsStandard()
> > so they will be relayed.
>
> Data does not belong in the blockchain. People running nodes have all
> implicitly agreed to store the blocks for financial purposes, and storing
> data
> is a violation of that social contract. Proof-of-stake may be arguably
> financial, but I'm sure there must be a way to do it without spamming
> people
> against their consent.
>
> > The alternative is sacrifices to unspendable outputs, which is very
> > undesirable compared to sending the money to miners to further
> > strengthen the security of the network.
>
> The alternative is to make other standard outputs unable to store data as
> well.
>
> Luke
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/89394efb/attachment.html>

From melvincarvalho at gmail.com  Thu Jun  6 20:25:54 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Thu, 6 Jun 2013 22:25:54 +0200
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAFmyj8zG7iLnwm7iUwxyOXTe3SZxAOFoZdy3=oRa2WqYbiWsHQ@mail.gmail.com>
References: <201306061914.20006.luke@dashjr.org>
	<CAFmyj8zG7iLnwm7iUwxyOXTe3SZxAOFoZdy3=oRa2WqYbiWsHQ@mail.gmail.com>
Message-ID: <CAKaEYh+yhfrUjqGLCZDiGuzyg5AQJqOdXS50uyrwgkcvP1xNnQ@mail.gmail.com>

On 6 June 2013 21:59, Andreas M. Antonopoulos <andreas at rooteleven.com>wrote:

> Is there any consideration given to the fact that bitcoin can operate as a
> platform for many other services, if it is able to be neutral to payload,
> as long as the fee is paid for the transaction size?
>
> Unless I have misunderstood this discussion, it seems to me that this is a
> bit like saying in 1990 "IP Is only for email, the majority of users want
> email, we shouldn't allow video, voice or images". Ooops, there goes the
> web.
>
> Is it possible to solve this by solving the issue of provably un-spendable
> outputs without foreclosing on the possibility of other types of
> transaction payloads (ie, not money), that would open the possibility for a
> myriad of layered apps above? For example, hashes of content that is
> external to bitcoin, that people want to pay to have timestamped in the
> blockchain, as provably unspendable outputs.
>
> The social compact is to accept transaction for fee. I think it is a major
> mistake to make decisions that discriminate on the content of the
> transaction, saying that some uses are not appropriate. If the fee is paid
> and it covers the size of the transaction, why would it matter if it is not
> a payment?
>
> I could be totally misreading this thread, too, so please allow me some
> slack if I have!
>

+1 we're still early into the bitcoin story ... unexpected reuse should not
be ruled out ...


>
>
>
>
> On Thu, Jun 6, 2013 at 12:14 PM, Luke-Jr <luke at dashjr.org> wrote:
>
>> On Saturday, June 01, 2013 7:30:36 PM Peter Todd wrote:
>> > scriptPubKey: <data> OP_TRUE
>> >
>> > ...
>> > Along with that change anyone-can-spend outputs should be make
>> IsStandard()
>> > so they will be relayed.
>>
>> Data does not belong in the blockchain. People running nodes have all
>> implicitly agreed to store the blocks for financial purposes, and storing
>> data
>> is a violation of that social contract. Proof-of-stake may be arguably
>> financial, but I'm sure there must be a way to do it without spamming
>> people
>> against their consent.
>>
>> > The alternative is sacrifices to unspendable outputs, which is very
>> > undesirable compared to sending the money to miners to further
>> > strengthen the security of the network.
>>
>> The alternative is to make other standard outputs unable to store data as
>> well.
>>
>> Luke
>>
>>
>> ------------------------------------------------------------------------------
>> How ServiceNow helps IT people transform IT departments:
>> 1. A cloud service to automate IT design, transition and operations
>> 2. Dashboards that offer high-level views of enterprise services
>> 3. A single system of record for all IT processes
>> http://p.sf.net/sfu/servicenow-d2d-j
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130606/befb429c/attachment.html>

From luke at dashjr.org  Thu Jun  6 21:48:13 2013
From: luke at dashjr.org (Luke-Jr)
Date: Thu, 6 Jun 2013 21:48:13 +0000
Subject: [Bitcoin-development] Proposal: soft-fork to make
	anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <CAFmyj8zDCjGR6cLUXQnWP4G0k6A85vdNW03k5NPAVyoJj0eEnQ@mail.gmail.com>
References: <201306061914.20006.luke@dashjr.org>
	<201306062007.41398.luke@dashjr.org>
	<CAFmyj8zDCjGR6cLUXQnWP4G0k6A85vdNW03k5NPAVyoJj0eEnQ@mail.gmail.com>
Message-ID: <201306062148.16611.luke@dashjr.org>

On Thursday, June 06, 2013 8:16:40 PM Andreas M. Antonopoulos wrote:
> > This doesn't work like you might think: first of all, the fees today are
> > greatly subsidized - the actual cost to store data in the blockchain is
> > much higher than most storage solutions. Secondly, only the miner receives
> > the fees, not the majority of nodes which have to bear the burden of the
> > data. That is, the fee system is setup as an antispam/deterrant, not as
> > payment for
> > storage.
> 
> There's a difference between storing the content itself, and storing just a
> hash to content (which however is not spendable payment). I undertand why
> content itself doesn't belong. But it goes too far to say that only
> payments should be allowed.

Because payments are the only thing everyone using Bitcoin has agreed to use 
the blockchain for. Furthermore, there is no *reason* to store non-payments in 
the blockchain. If there was in fact such a use case, things might be arguable 
- but there isn't any I'm aware of.

> If the fees are not enough, fix the fee structure, don't stop incredibly
> innovative and promising uses of the distributed timestamping database.
> That is definitely throwing the baby out with the bathwater. If the issue
> is size, then address that, rather than the content itself.

The issue is using other peoples' resources for something they did not agree 
to use it for. The fees aren't merely "not enough", they were never *intended* 
to be "cost of storage". They are "cost of security" and "prevent spamming".

> Discriminating based on transaction content violates neutrality of the
> protocol and in my mind removes a very very large possibility of future
> innovation. If bitcoin is a *platform* and not just a payment system, then
> it needs to be neutral to content, like TCP/IP so that other protocols can
> be layered. Solve the size problem itself, without picking and chosing
> which uses of bitcoin are good and which are "bad" or "spam". I think it
> risks killing a tremendous amount of innovation just as it is starting.

The concepts behind Bitcoin are applicable to future innovation, but this can 
all be accomplished without spamming Bitcoin itself.

> > Not the same thing at all; nobody is forced to store/relay
> > video/voice/images without reimbursement. On the other hand, any full
> > Bitcoin node is required to at least download the entire blockchain once.
> > And the network as a whole suffers if nodes decide to start not-storing
> > parts of the blockchain they don't want to deal with.
> > 
> > So don't store content, but allow hashes of content.
> 
> Again, I think it is extreme and extremely restrictive to say that ONLY
> payments are allowed.

Non-payments are quite possible without the Bitcoin blockchain itself. If 
you're worried that not enough people will store the alternative-non-payment 
data, then you are essentially saying that voluntary participation is not 
enough and that forced storage is your solution. I don't think this is what 
you intend...

> > This is how merged mining solves the problem. A single extra hash in the
> > coinbase can link the bitcoin blockchain up with unlimited other data.
> 
> Can you explain this part or refer me to some docs? What do you mean by
> "coinbase", I assume not the company.

The Bitcoin blockchain protocol has 95 bytes per block reserved for miners to 
put extra data. Currently, this is used for extranonces, political or other 
short messages (such as in the Genesis block), miner "signatures", and also, 
as I mentioned, merged mining. Merged mining works by tying a non-
transactional merkle tree to the blockchain. The block coinbase stores the 
hash of the top of this merkle tree, so any data within the merkle tree can 
prove it is associated to the block. The merged mining merkle tree then stores 
hashes of multiple other data sets: for example, a Namecoin block can be 
referenced in a merged mining merkle tree, to use the Bitcoin block's proof-
of-work for itself (so, miners can mine both Bitcoin and Namecoin using the 
same hashing effort). You could also add other non-transactional blocks to the 
merged mining merkle tree, for generic timestamping or really anything at all.

Luke



From melvincarvalho at gmail.com  Thu Jun  6 22:10:11 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Fri, 7 Jun 2013 00:10:11 +0200
Subject: [Bitcoin-development] Proposal: soft-fork to make
 anyone-can-spend outputs unspendable for 100 blocks
In-Reply-To: <201306062148.16611.luke@dashjr.org>
References: <201306061914.20006.luke@dashjr.org>
	<201306062007.41398.luke@dashjr.org>
	<CAFmyj8zDCjGR6cLUXQnWP4G0k6A85vdNW03k5NPAVyoJj0eEnQ@mail.gmail.com>
	<201306062148.16611.luke@dashjr.org>
Message-ID: <CAKaEYhKVmhrvYLVR7s-WkT+kC-DWm=faXj6fJ0rp1yhytoQ15Q@mail.gmail.com>

On 6 June 2013 23:48, Luke-Jr <luke at dashjr.org> wrote:

> On Thursday, June 06, 2013 8:16:40 PM Andreas M. Antonopoulos wrote:
> > > This doesn't work like you might think: first of all, the fees today
> are
> > > greatly subsidized - the actual cost to store data in the blockchain is
> > > much higher than most storage solutions. Secondly, only the miner
> receives
> > > the fees, not the majority of nodes which have to bear the burden of
> the
> > > data. That is, the fee system is setup as an antispam/deterrant, not as
> > > payment for
> > > storage.
> >
> > There's a difference between storing the content itself, and storing
> just a
> > hash to content (which however is not spendable payment). I undertand why
> > content itself doesn't belong. But it goes too far to say that only
> > payments should be allowed.
>
> Because payments are the only thing everyone using Bitcoin has agreed to
> use
> the blockchain for. Furthermore, there is no *reason* to store
> non-payments in
> the blockchain. If there was in fact such a use case, things might be
> arguable
> - but there isn't any I'm aware of.
>

Two quotes satoshi:

"Piling every proof-of-work quorum system in the world into one dataset
doesn't scale."

and

"I like Hal Finney's idea for user-friendly timestamping.  Convert the hash
of a file to a bitcoin address and send 0.01 to it"

This leads me to believe, that while bitcoin should not be over used as a
time stamp server, there could be a balance reached for casual time stamp
recording as part of satoshi's concept.

What we call "spam" is to a degree subjective, and I think not always
obvious, tho in some cases it clearly is.


> > If the fees are not enough, fix the fee structure, don't stop incredibly
> > innovative and promising uses of the distributed timestamping database.
> > That is definitely throwing the baby out with the bathwater. If the issue
> > is size, then address that, rather than the content itself.
>
> The issue is using other peoples' resources for something they did not
> agree
> to use it for. The fees aren't merely "not enough", they were never
> *intended*
> to be "cost of storage". They are "cost of security" and "prevent
> spamming".
>
> > Discriminating based on transaction content violates neutrality of the
> > protocol and in my mind removes a very very large possibility of future
> > innovation. If bitcoin is a *platform* and not just a payment system,
> then
> > it needs to be neutral to content, like TCP/IP so that other protocols
> can
> > be layered. Solve the size problem itself, without picking and chosing
> > which uses of bitcoin are good and which are "bad" or "spam". I think it
> > risks killing a tremendous amount of innovation just as it is starting.
>
> The concepts behind Bitcoin are applicable to future innovation, but this
> can
> all be accomplished without spamming Bitcoin itself.
>
> > > Not the same thing at all; nobody is forced to store/relay
> > > video/voice/images without reimbursement. On the other hand, any full
> > > Bitcoin node is required to at least download the entire blockchain
> once.
> > > And the network as a whole suffers if nodes decide to start not-storing
> > > parts of the blockchain they don't want to deal with.
> > >
> > > So don't store content, but allow hashes of content.
> >
> > Again, I think it is extreme and extremely restrictive to say that ONLY
> > payments are allowed.
>
> Non-payments are quite possible without the Bitcoin blockchain itself. If
> you're worried that not enough people will store the
> alternative-non-payment
> data, then you are essentially saying that voluntary participation is not
> enough and that forced storage is your solution. I don't think this is what
> you intend...
>
> > > This is how merged mining solves the problem. A single extra hash in
> the
> > > coinbase can link the bitcoin blockchain up with unlimited other data.
> >
> > Can you explain this part or refer me to some docs? What do you mean by
> > "coinbase", I assume not the company.
>
> The Bitcoin blockchain protocol has 95 bytes per block reserved for miners
> to
> put extra data. Currently, this is used for extranonces, political or other
> short messages (such as in the Genesis block), miner "signatures", and
> also,
> as I mentioned, merged mining. Merged mining works by tying a non-
> transactional merkle tree to the blockchain. The block coinbase stores the
> hash of the top of this merkle tree, so any data within the merkle tree can
> prove it is associated to the block. The merged mining merkle tree then
> stores
> hashes of multiple other data sets: for example, a Namecoin block can be
> referenced in a merged mining merkle tree, to use the Bitcoin block's
> proof-
> of-work for itself (so, miners can mine both Bitcoin and Namecoin using the
> same hashing effort). You could also add other non-transactional blocks to
> the
> merged mining merkle tree, for generic timestamping or really anything at
> all.
>
> Luke
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130607/79f171a4/attachment.html>

From melvincarvalho at gmail.com  Thu Jun  6 22:22:40 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Fri, 7 Jun 2013 00:22:40 +0200
Subject: [Bitcoin-development] Revocability with known trusted escrow
	services?
In-Reply-To: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
Message-ID: <CAKaEYhKiRutKYeQjLocJJ0L2Yra790WnUiF5Px64Kxv7Q-0z8w@mail.gmail.com>

On 6 June 2013 02:19, Peter Vessenes <peter at coinlab.com> wrote:

> So, this
> http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1 article got posted today, noting that FinCEN thinks irrevocable payments
> are money laundering tools.
>
> I will hold my thoughts about the net social good of rent-seeking large
> corporations taking money from consumers over fraudulent reversals.
> Actually, I won't, I just said it.
>
> At any rate, it got me thinking, can we layer on revocability somehow
> without any protocol change, as an opt-in?
>
> My initial scheme is a trusted (hah) escrow service that issues time
> promises for signing. If it doesn't receive a cancel message, it will sign
> at the end of the time.
>
> The addresses would be listed by the escrow service, or in an open
> registry, so you could see if you were going to have a delay period when
> you saw a transaction go out.
>
> This seems sort of poor to me, it imagines that mythical thing, a trusted
> escrow service, and is vulnerable to griefing, but I thought I'd see if
> some of the brighter minds than me can come up with a layer-on approach
> here.
>
> When I think about it, I can imagine that I would put a good number of my
> coins in a one day reversible system, because I would have warning if
> someone wanted to try and spend them, and could do something about it. I'm
> not sure if it gets me anything over a standard escrow arrangement, though.
>

Also see satoshi's comments on this, though it may be restating what others
have said:

https://bitcointalk.org/index.php?topic=750.0

"Here's an outline of the kind of escrow transaction that's possible in
software.  This is not implemented and I probably won't have time to
implement it soon, but just to let you know what's possible.

The basic escrow: The buyer commits a payment to escrow. The seller
receives a transaction with the money in escrow, but he can't spend it
until the buyer unlocks it. The buyer can release the payment at any time
after that, which could be never. This does not allow the buyer to take the
money back, but it does give him the option to burn the money out of spite
by never releasing it. The seller has the option to release the money back
to the buyer.

While this system does not guarantee the parties against loss, it takes the
profit out of cheating.

If the seller doesn't send the goods, he doesn't get paid. The buyer would
still be out the money, but at least the seller has no monetary motivation
to stiff him.

The buyer can't benefit by failing to pay. He can't get the escrow money
back. He can't fail to pay due to lack of funds. The seller can see that
the funds are committed to his key and can't be sent to anyone else.

Now, an economist would say that a fraudulent seller could start
negotiating, such as "release the money and I'll give you half of it back",
but at that point, there would be so little trust and so much spite that
negotiation is unlikely. Why on earth would the fraudster keep his word and
send you half if he's already breaking his word to steal it? I think for
modest amounts, almost everyone would refuse on principle alone."


>
> Peter
>
> --
>
> ------------------------------
>
> [image: CoinLab Logo]PETER VESSENES
> CEO
>
> *peter at coinlab.com * /  206.486.6856  / SKYPE: vessenes
> 71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130607/c8a04aa5/attachment.html>

From calebdelisle at lavabit.com  Fri Jun  7 05:46:04 2013
From: calebdelisle at lavabit.com (Caleb James DeLisle)
Date: Fri, 07 Jun 2013 01:46:04 -0400
Subject: [Bitcoin-development] Revocability with known trusted escrow
 services?
In-Reply-To: <CAKaEYhKiRutKYeQjLocJJ0L2Yra790WnUiF5Px64Kxv7Q-0z8w@mail.gmail.com>
References: <CAMGNxUv7wkiUYZ2nZjOP0mEW7bgR0a+CXKyDPq38joU-fMMQ9Q@mail.gmail.com>
	<CAKaEYhKiRutKYeQjLocJJ0L2Yra790WnUiF5Px64Kxv7Q-0z8w@mail.gmail.com>
Message-ID: <51B1739C.5000909@lavabit.com>

IMO this story falls somewhere between rose colored glasses and outright trolling.
Whereas LR was a (relatively shady) company, bitcoin is an entire branch of technology
and research, I can't think of any real caselaw in the US with regards to banning a
technology, perhaps the cryptography export regulation and we all know how well that
worked. Furthermore, the non-reversibility of LR is mostly because they didn't want
to deal with mediation while the non-reversibility of bitcoin is technological barrier.

It seems AmericanBanker has a record of hosting articles which urge policy decisions:
  http://www.americanbanker.com/bankthink/governments-must-co-opt-bitcoin-to-avert-disaster-1058380-1.html
that would obviously be of personal benefit to the article's author:
  http://www.clearbit.com/company_management.htm
It is the very job of governments to resist the efforts of lobbyists to line their
pockets at the public expense.

While I don't think significant risk of developed countries actually banning an entire
area of research such as bitcoin, I do suspect that bitcoin's popularity lead to LR's
downfall as it will other companies which allow people to transact anonymously.


The tragedy of bitcoin's irreversibility is that it makes kidnap/ransom schemes
profitable. The relative safety of the first world is largely due to the fact that
until now, there has never been any effective way to steal significant amounts of
money. While this problem is serious I don't think it's intractable. Bitcoin offers
us a modeling tool which like never before allows us to experiment with our
motivations and build something better than even bitcoin is today.

I believe regulators are intelligent people who understand this and would rather
legitimize bitcoin than ban it. If there ever were such a ban, I would be more
concerned for the future of the country imposing it than I would for bitcoin.


Thanks,
Caleb

tl;dr haters gonna hate



On 06/06/2013 06:22 PM, Melvin Carvalho wrote:
> 
> 
> 
> On 6 June 2013 02:19, Peter Vessenes <peter at coinlab.com <mailto:peter at coinlab.com>> wrote:
> 
>     So, this http://www.americanbanker.com/bankthink/the-last-straw-for-bitcoin-1059608-1.html?pg=1  article got posted today, noting that FinCEN thinks irrevocable payments are money laundering tools. 
> 
>     I will hold my thoughts about the net social good of rent-seeking large corporations taking money from consumers over fraudulent reversals. Actually, I won't, I just said it.
> 
>     At any rate, it got me thinking, can we layer on revocability somehow without any protocol change, as an opt-in?
> 
>     My initial scheme is a trusted (hah) escrow service that issues time promises for signing. If it doesn't receive a cancel message, it will sign at the end of the time. 
> 
>     The addresses would be listed by the escrow service, or in an open registry, so you could see if you were going to have a delay period when you saw a transaction go out.
> 
>     This seems sort of poor to me, it imagines that mythical thing, a trusted escrow service, and is vulnerable to griefing, but I thought I'd see if some of the brighter minds than me can come up with a layer-on approach here.
> 
>     When I think about it, I can imagine that I would put a good number of my coins in a one day reversible system, because I would have warning if someone wanted to try and spend them, and could do something about it. I'm not sure if it gets me anything over a standard escrow arrangement, though.
> 
> 
> Also see satoshi's comments on this, though it may be restating what others have said:
> 
> https://bitcointalk.org/index.php?topic=750.0
> 
> "Here's an outline of the kind of escrow transaction that's possible in software.  This is not implemented and I probably won't have time to implement it soon, but just to let you know what's possible.
> 
> The basic escrow: The buyer commits a payment to escrow. The seller receives a transaction with the money in escrow, but he can't spend it until the buyer unlocks it. The buyer can release the payment at any time after that, which could be never. This does not allow the buyer to take the money back, but it does give him the option to burn the money out of spite by never releasing it. The seller has the option to release the money back to the buyer.
> 
> While this system does not guarantee the parties against loss, it takes the profit out of cheating.
> 
> If the seller doesn't send the goods, he doesn't get paid. The buyer would still be out the money, but at least the seller has no monetary motivation to stiff him.
> 
> The buyer can't benefit by failing to pay. He can't get the escrow money back. He can't fail to pay due to lack of funds. The seller can see that the funds are committed to his key and can't be sent to anyone else.
> 
> Now, an economist would say that a fraudulent seller could start negotiating, such as "release the money and I'll give you half of it back", but at that point, there would be so little trust and so much spite that negotiation is unlikely. Why on earth would the fraudster keep his word and send you half if he's already breaking his word to steal it? I think for modest amounts, almost everyone would refuse on principle alone."
>  
> 
> 
>     Peter
> 
>     -- 
> 
>     --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
> 
>     CoinLab LogoPETER VESSENES 
>     CEO
> 
>     *peter at coinlab.com <mailto:peter at coinlab.com> * /  206.486.6856 <tel:206.486.6856>  / SKYPE: vessenes 
>     71 COLUMBIA ST / SUITE 300  /  SEATTLE, WA 98104
> 
> 
>     ------------------------------------------------------------------------------
>     How ServiceNow helps IT people transform IT departments:
>     1. A cloud service to automate IT design, transition and operations
>     2. Dashboards that offer high-level views of enterprise services
>     3. A single system of record for all IT processes
>     http://p.sf.net/sfu/servicenow-d2d-j
>     _______________________________________________
>     Bitcoin-development mailing list
>     Bitcoin-development at lists.sourceforge.net <mailto:Bitcoin-development at lists.sourceforge.net>
>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> 
> 
> 
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> 
> 
> 
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 




From john.dillon892 at googlemail.com  Mon Jun 10 04:09:26 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Mon, 10 Jun 2013 04:09:26 +0000
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit with
	proof-of-stake voting
Message-ID: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

It has been suggested that we leave the decision of what the blocksize to be
entirely up to miners. However this leaves a parameter that affects every
Bitcoin participant in the control of a small minority. Of course we can not
force miners to increase the blocksize if they choose to decrease it, because
the contents of the blocks they make are their decision and their decision
only. However proposals to leave the maximum size unlimited to allow miners to
force us to accept arbitrarily large blocks even if the will of the majority of
Bitcoin participants is that they wish to remain able to validate the
blockchain.

What we need is a way to balance this asymetrical power relationship.

Proof-of-stake voting gives us a way of achieving that balance. Essentially for
a miner to prove that the majority will of the poeple is to accept a larger
blocksize they must prove that the majority has in fact voted for that
increase. The upper limit on the blocksize is then determined by the median of
all votes, where each txout in the UTXO set is one vote, weighted by txout
value. A txout without a corresponding vote is considered to be a vote for the
status quo. To allow the voting process to continue even if coins are "lost"
votes, including default votes, are weighted inversely according to their age
in years after 1 year. IE a vote with weight 1BTC that is 1.5 years old will be
recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1 day old
and 6 months old UTXO are treated equivalently. The 1 year minimum is simply to
make voting required no more than once per year. (of course, a real
implementation should do all of these figures by block height, IE after 52,560
blocks instead of after 1 year)

A vote will consist of a txout with a scriptPubKey of the following form:

    OP_RETURN magic vote_id txid vout vote scriptSig

Where scriptSig is a valid signature for a transaction with nLockTime
500,000,000-1 spending txid:vout to scriptPubKey:

    OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL

vote_id is the ID of the specific vote being made, and magic is included to
allow UTXO proof implementations a as yet unspecified way of identifying votes
and including the weighted median as part of the UTXO tree sums. (it also
allows SPV clients to verify the vote if the UTXO set is a Patricia tree of
scriptPubKeys) vote is just the numerical vote itself. The vote must compute
the median, rather than the mean, so as to not allow someone to skew the vote
by simply setting their value extremely high. Someone who still remembers their
statistics classes should chime in on the right way to compute a median in a
merkle-sum-tree.

The slightly unusual construction of votes makes implementation by wallet
software as simple as possible within existing code-paths. Votes could still be
constructed even in wallets lacking specific voting capability provided the
wallet software does have the ability to set nLockTime.

Of course in the future the voting mechanism can be used for additional votes
with an additional vote_id. For instance the Bitcoin community could vote to
increase the inflation subsidy, another example of a situation where the wishes
of miners may conflict with the wishes of the broader community.

Users may of course actually create these specially encoded txouts themselves
and get them into the blockchain.  However doing so is not needed as a given
vote is only required to actually be in the chain by a miner wishing to
increase the blocksize. Thus we should extend the P2P protocol with a mechanism
by which votes can be broadcast independently of transactions. To prevent DoS
attacks only votes with known vote_id's will be accepted, and only for
txid:vout's already in the blockchain, and a record of txouts for whom votes
have already broadcast will be kept. (this record need not be authoritative as
its purpose is only to prevent DoS attacks) Miners wishing to increase the
blocksize can record these votes and include them in the blocks they mine as
required. To reduce the cost of including votes in blocks 5% of every block
should be assigned to voting only. (this can be implemented by a soft-fork)

For any given block actual limit in effect is then the rolling median of the
blocks in the last year. At the beginning of every year the value considered to
be the status quo resets to the mean of the limit at the beginning and end of
the interval.  (again, by "year" we really mean 52,560 blocks) The rolling
median and periodic reset process ensures that the limit changes gradually and
is not influenced by temporary events such as hacks to large exchanges or
malicious wallet software.  The rolling median also ensures that for a miner
the act of including a vote is never wasted due to the txout later being spent.

Implementing the voting system can happen prior to an actual hard-fork allowing
for an increase and can be an important part of determining if the hard-fork is
required at all.

Coercion and vote buying is of course possible in this system. A miner could
say that they will only accept transactions accompanied by a vote for a given
limit. However in a decentralized system completely preventing vote buying is
of course impossble, and the design of Bitcoin itself has a fundemental
assumption that a majority of miners will behave in a specific kind of "honest"
way.

A voting process ensures that any increase to the blocksize genuinely
represents the desires of the Bitcoin community, and the process described
above ensures that any changes happen at a rate that gives all participants
time to react. The process also gives a mechanism for the community to vote to
decrease the limit if it turns out that the new one was in fact too high. (note
how the way the status quo is set ensures the default action is for the limit
to gradually decrease even if everyone stops voting)

As many of you know I have been quite vocal that the 1MB limit should stay. But
I would be happy to support the outcome of a vote done properly, whatever that
outcome may be.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRtVFBAAoJEEWCsU4mNhiP6EAIAMjq4UgXxmEjOgHWf0KcmwmH
Ra/I3oY7krvg/lu1YCa+ACMBdoca9WODySUIe7R3niphKXEnknHGUIf8tm/Vrq4H
gPF4cgYEr18EYTVtvT9J1pZUB4f5dxkXXNpcQ60juaz9KervFQMOGnpr6Fyxi3dS
ghObNYcr3D2v1fjx56sp7BCNn0XHxTb1ZLUJB0BZhDKlamfgcxruKMbpsZmACJUj
gTNLNweaAomBIH++j7cnXeB0jZc/1ilv8qLA/f3TGb43FDkAQcvvSjGijI+OJOm6
Fh/WRBav1BJiV6PKs9xuHXsaxZ/T7Fb8Wg8EynSi0mSj47QXdKZgeZCi3XlSyxM=
=aKBD
-----END PGP SIGNATURE-----



From john.dillon892 at googlemail.com  Mon Jun 10 04:59:45 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Mon, 10 Jun 2013 04:59:45 +0000
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAFBxzACPpLd1gmoAzxviU2rLPry=cGNQhEZvYV=q_PLRQQ5wXw@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<CAFBxzACPpLd1gmoAzxviU2rLPry=cGNQhEZvYV=q_PLRQQ5wXw@mail.gmail.com>
Message-ID: <CAPaL=UWuYA6OaW9==5=TJdcq_+-dw57KNwCvabNUc50A+Pw7cg@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On Mon, Jun 10, 2013 at 4:44 AM, Edmund Broadley <rebroad at gmail.com> wrote:
> I really like this idea. I also like that users with no clue will leave
> their vote to the default chosen by the software developers, which hopefully
> will be 1MB. I like how coin age is factored in do votes are hopefully
> proportional to bitcoin assert ownership.

The default should *not* be set by wallets at all in fact. The default is that
by not voting, you accept the status quo, which is defined as the mean of the
old and new limits in the past year.

So lets say the limit is 1MB, and through voting it ends up at 2MB in one year.
Until that time by not voting you are in effect voting for the limit to be 1MB,
but after the next interval you not voting is equivalent to voting for a 1.5MB
limit. A subtle issue is then txout age, and at that point a 1.5 year old txout
should be like voting for the 1MB limit still, albeit weighted less. What you
don't want is your lack of vote to suddenly turn into a 1.5MB vote. This makes
sure that at all levels the increases are gradual rather than abrupt, although
the rate of increase may still be quite fast if the community votes that way.
(first derivative of the limit is a close approximation to a continuous
function)
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRtV0iAAoJEEWCsU4mNhiPRDIH+wapKxD0fc2div9gkhxZ4qVt
9Wh4u1vKM4RsxdPgh9uKFJomjErBXBROJ57cJqB1rwHt1xhUyHgbC8JstU0PWzUM
Ygwgibe9nsSjqHp2w15Bat+NmkYpxrjmVhf9woZkPQl+A1bWd3MFXOGoTIPPCl3I
KkMTaR3VbZDwqg0DlteZMR2im2DkT4zDsCkSb8KSCoaeTEdafkPceVHWU6isWxV9
Y0TGFCKaoMjxqxnkgH+vHsJlIM4E3rb0NHTo8rHD7Hm1txw/4/fVwE56/9U+8FaK
XAPXS0gkIR83V7cWMLa/q6LpZyzJmfFXCZhjT4YxVqeq/wB/SR9j2hhNdLnjuCo=
=y1c+
-----END PGP SIGNATURE-----



From pete at petertodd.org  Mon Jun 10 05:30:02 2013
From: pete at petertodd.org (Peter Todd)
Date: Mon, 10 Jun 2013 01:30:02 -0400
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
Message-ID: <20130610053002.GA8961@savin>

On Mon, Jun 10, 2013 at 04:09:26AM +0000, John Dillon wrote:

My general comments on the idea are that while it's hard to say if a
vote by proof-of-stake is really representative, it's likely the closest
thing we'll ever get to a fair vote. Proof-of-stake is certainely better
than just letting miners choose; as you point out miners can always
choose to decrease the blocksize anyway so we only need a vote on
allowable increases. Proof-of-stake also clearly favors those who
actually have invested in Bitcoin over those who only talk about
Bitcoin.

I'll also say that while I know people will complain about putting
politics into a technical problem, as I keep saying, is *is* a political
issue. The limitations may be technical, but the ultimate issue is a
very political decision about what we want Bitcoin to be. Yes, there
will be people campaigning left and right to get users to vote for
various limits with their coins, deal with it. Democracy is messy.

Voting would take a lot of the nastier politics out of the situation,
perhaps somewhat ironically. It would quite clearly take control away
from the core development team, and the Bitcoin Foundation, and put it
back in the hands of the community; you can't argue conspiracy theories
that the Foundation is trying to control Bitcoin when there is a
completely transparent voting system in place. People will complain that
big Bitcoin players are throwing their weight around, but the blockchain
itself is a voting mechanism that is anything but 1 person = 1 vote.

Of course I wouldn't be the slightest bit surprised if users happily
vote themselves into something looking like a centralized PayPal
replacement in the long run, but at least if that happens the process by
which they get there will be transparent and relatively democratic.


> A vote will consist of a txout with a scriptPubKey of the following form:
> 
>     OP_RETURN magic vote_id txid vout vote scriptSig
> 
> Where scriptSig is a valid signature for a transaction with nLockTime
> 500,000,000-1 spending txid:vout to scriptPubKey:
> 
>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL

I just wanted to point out how general this mechanism is. Regardless of
what the scriptPubKey form is, standard, P2SH, multisig, whatever to
vote is to simply prove you could have spent the txout.

> vote_id is the ID of the specific vote being made, and magic is included to
> allow UTXO proof implementations a as yet unspecified way of identifying votes
> and including the weighted median as part of the UTXO tree sums. (it also
> allows SPV clients to verify the vote if the UTXO set is a Patricia tree of
> scriptPubKeys) vote is just the numerical vote itself.

Ah, you're assuming a direct Patricia tree. Keep in mind that
scriptPubKey's can be up to 10,000 bytes long, and an attacker can use
that (with 10,000 other txouts) to create some extremely deep trees. I
said on IRC a few days ago about how skeptical I am of implementing
consensus critical systems with such huge differences in average and
worst case, but I'll admit this is a decent use-case.

Having said that, proof to SPV clients leaves open the interesting
possibility that a third-party holding Bitcoins on your behalf can prove
that they voted according to your wishes, or even prove they voted
according to all their users wishes. Basically we'd add a rule for the
UTXO tree where a specific OP_RETURN form is included in the UTXO tree,
even though it is unspendable, and is removed from the tree if the
master txout is spent. Note that in this case by "prove they voted" we
mean the service actually taking the step of ensuring their vote was
recorded in the blockchain.

> The vote must compute
> the median, rather than the mean, so as to not allow someone to skew the vote
> by simply setting their value extremely high. Someone who still remembers their
> statistics classes should chime in on the right way to compute a median in a
> merkle-sum-tree.

I think the definition of the median requires knowledge of all the points so
it'll have to be a separate sorted tree - kinda complex unfortunately if
you really do want to be able to do full proof to SPV clients. Maybe
just putting the hash of the overall results in the coinbase is enough
for now.

The term to google is "moving median" - looks complex.

> Of course in the future the voting mechanism can be used for additional votes
> with an additional vote_id. For instance the Bitcoin community could vote to
> increase the inflation subsidy, another example of a situation where the wishes
> of miners may conflict with the wishes of the broader community.

Good idea on keeping the code general.

> For any given block actual limit in effect is then the rolling median of the
> blocks in the last year. At the beginning of every year the value considered to
> be the status quo resets to the mean of the limit at the beginning and end of
> the interval.  (again, by "year" we really mean 52,560 blocks) The rolling
> median and periodic reset process ensures that the limit changes gradually and
> is not influenced by temporary events such as hacks to large exchanges or
> malicious wallet software.  The rolling median also ensures that for a miner
> the act of including a vote is never wasted due to the txout later being spent.

Good points, although keep in mind you've created a lot of consensus
critical code that is easiest to implement with floating point... not a
good thing.

One way to mitigate that risk might be to take advantage of the fact
that unless the rolling median code itself is buggy, a consensus failure
in the calculation is likely to result in different implementations
still having a close agreement on the limit. So maybe we write some code
where we won't build on top of a block that is larger than, say, 95% of
the hard-limit unless another miner does so too?

> Implementing the voting system can happen prior to an actual hard-fork allowing
> for an increase and can be an important part of determining if the hard-fork is
> required at all.

Step #0 would be to think about OP_RETURN actually. FWIW Jeff Garzik has
a pull-req (https://github.com/bitcoin/bitcoin/pull/2738) to enable it,
although only one txout per tx, and only with a 80-byte payload.

Even just some ad-hoc voting by the "raise-the-limit" crowd would be a
good first step to gaging interest.

> Coercion and vote buying is of course possible in this system. A miner could
> say that they will only accept transactions accompanied by a vote for a given
> limit. However in a decentralized system completely preventing vote buying is
> of course impossble, and the design of Bitcoin itself has a fundemental

Is it really? There might be someone clever with a cryptographic voting
protocol, although in the case of Bitcoin we have to let people vote
with arbitrary scriptPubKeys, so almost anything less general than full
on SCIP just means miners force people to use the protocol where
vote-buying is possible.

> A voting process ensures that any increase to the blocksize genuinely
> represents the desires of the Bitcoin community, and the process described
> above ensures that any changes happen at a rate that gives all participants
> time to react. The process also gives a mechanism for the community to vote to
> decrease the limit if it turns out that the new one was in fact too high. (note
> how the way the status quo is set ensures the default action is for the limit
> to gradually decrease even if everyone stops voting)

Good idea. So it'd decrease to the mean of the old and new limits
basically, and if Bitcoin becomes "too centralized" users can simply do
nothing and the process gradually reverses.

> As many of you know I have been quite vocal that the 1MB limit should stay. But
> I would be happy to support the outcome of a vote done properly, whatever that
> outcome may be.

Same here.

-- 
'peter'[:-1]@petertodd.org
0000000000000068a8ad033afa763246fe451e840eae5215eb3a64e8101a46c3
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/3963113e/attachment.sig>

From lidstrom83 at gmail.com  Mon Jun 10 06:34:33 2013
From: lidstrom83 at gmail.com (Daniel Lidstrom)
Date: Mon, 10 Jun 2013 03:34:33 -0300
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <20130610053002.GA8961@savin>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<20130610053002.GA8961@savin>
Message-ID: <CADjHg8HUkh6u1Nhp01DKqX+qLu3jqvDVYhTo55MKpRtcavSWvg@mail.gmail.com>

Reserving my judgement until I've though about it more (design by committee
scares me, and this voting sounds expensive), I think the SPV-verifiable
moving median can be done by binning the space of block size limits, and
for each node in the UTXO tree, a value for each bin is stored which is the
sum of the corresponding bins of each of the children.  The childless nodes
- which correspond to the individual UTXOs - increment the appropriate bin
of their parents according to the rules you mentioned.  The bin values in
the root node of the UTXO tree would then be added to those, weighted
appropriately, of the previous N blocks.

The hash of a node would be that of the bin values, concatenated with the
child nodes' hashes.  In this way, any step of the calculation of the
median would produce a localized error in the UTXO tree that's easily
verified.

The number of bins would have to be kept relatively small in order to keep
this from adding too much data to the UTXO tree branches though.


On Mon, Jun 10, 2013 at 2:30 AM, Peter Todd <pete at petertodd.org> wrote:

> On Mon, Jun 10, 2013 at 04:09:26AM +0000, John Dillon wrote:
>
> My general comments on the idea are that while it's hard to say if a
> vote by proof-of-stake is really representative, it's likely the closest
> thing we'll ever get to a fair vote. Proof-of-stake is certainely better
> than just letting miners choose; as you point out miners can always
> choose to decrease the blocksize anyway so we only need a vote on
> allowable increases. Proof-of-stake also clearly favors those who
> actually have invested in Bitcoin over those who only talk about
> Bitcoin.
>
> I'll also say that while I know people will complain about putting
> politics into a technical problem, as I keep saying, is *is* a political
> issue. The limitations may be technical, but the ultimate issue is a
> very political decision about what we want Bitcoin to be. Yes, there
> will be people campaigning left and right to get users to vote for
> various limits with their coins, deal with it. Democracy is messy.
>
> Voting would take a lot of the nastier politics out of the situation,
> perhaps somewhat ironically. It would quite clearly take control away
> from the core development team, and the Bitcoin Foundation, and put it
> back in the hands of the community; you can't argue conspiracy theories
> that the Foundation is trying to control Bitcoin when there is a
> completely transparent voting system in place. People will complain that
> big Bitcoin players are throwing their weight around, but the blockchain
> itself is a voting mechanism that is anything but 1 person = 1 vote.
>
> Of course I wouldn't be the slightest bit surprised if users happily
> vote themselves into something looking like a centralized PayPal
> replacement in the long run, but at least if that happens the process by
> which they get there will be transparent and relatively democratic.
>
>
> > A vote will consist of a txout with a scriptPubKey of the following form:
> >
> >     OP_RETURN magic vote_id txid vout vote scriptSig
> >
> > Where scriptSig is a valid signature for a transaction with nLockTime
> > 500,000,000-1 spending txid:vout to scriptPubKey:
> >
> >     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL
>
> I just wanted to point out how general this mechanism is. Regardless of
> what the scriptPubKey form is, standard, P2SH, multisig, whatever to
> vote is to simply prove you could have spent the txout.
>
> > vote_id is the ID of the specific vote being made, and magic is included
> to
> > allow UTXO proof implementations a as yet unspecified way of identifying
> votes
> > and including the weighted median as part of the UTXO tree sums. (it also
> > allows SPV clients to verify the vote if the UTXO set is a Patricia tree
> of
> > scriptPubKeys) vote is just the numerical vote itself.
>
> Ah, you're assuming a direct Patricia tree. Keep in mind that
> scriptPubKey's can be up to 10,000 bytes long, and an attacker can use
> that (with 10,000 other txouts) to create some extremely deep trees. I
> said on IRC a few days ago about how skeptical I am of implementing
> consensus critical systems with such huge differences in average and
> worst case, but I'll admit this is a decent use-case.
>
> Having said that, proof to SPV clients leaves open the interesting
> possibility that a third-party holding Bitcoins on your behalf can prove
> that they voted according to your wishes, or even prove they voted
> according to all their users wishes. Basically we'd add a rule for the
> UTXO tree where a specific OP_RETURN form is included in the UTXO tree,
> even though it is unspendable, and is removed from the tree if the
> master txout is spent. Note that in this case by "prove they voted" we
> mean the service actually taking the step of ensuring their vote was
> recorded in the blockchain.
>
> > The vote must compute
> > the median, rather than the mean, so as to not allow someone to skew the
> vote
> > by simply setting their value extremely high. Someone who still
> remembers their
> > statistics classes should chime in on the right way to compute a median
> in a
> > merkle-sum-tree.
>
> I think the definition of the median requires knowledge of all the points
> so
> it'll have to be a separate sorted tree - kinda complex unfortunately if
> you really do want to be able to do full proof to SPV clients. Maybe
> just putting the hash of the overall results in the coinbase is enough
> for now.
>
> The term to google is "moving median" - looks complex.
>
> > Of course in the future the voting mechanism can be used for additional
> votes
> > with an additional vote_id. For instance the Bitcoin community could
> vote to
> > increase the inflation subsidy, another example of a situation where the
> wishes
> > of miners may conflict with the wishes of the broader community.
>
> Good idea on keeping the code general.
>
> > For any given block actual limit in effect is then the rolling median of
> the
> > blocks in the last year. At the beginning of every year the value
> considered to
> > be the status quo resets to the mean of the limit at the beginning and
> end of
> > the interval.  (again, by "year" we really mean 52,560 blocks) The
> rolling
> > median and periodic reset process ensures that the limit changes
> gradually and
> > is not influenced by temporary events such as hacks to large exchanges or
> > malicious wallet software.  The rolling median also ensures that for a
> miner
> > the act of including a vote is never wasted due to the txout later being
> spent.
>
> Good points, although keep in mind you've created a lot of consensus
> critical code that is easiest to implement with floating point... not a
> good thing.
>
> One way to mitigate that risk might be to take advantage of the fact
> that unless the rolling median code itself is buggy, a consensus failure
> in the calculation is likely to result in different implementations
> still having a close agreement on the limit. So maybe we write some code
> where we won't build on top of a block that is larger than, say, 95% of
> the hard-limit unless another miner does so too?
>
> > Implementing the voting system can happen prior to an actual hard-fork
> allowing
> > for an increase and can be an important part of determining if the
> hard-fork is
> > required at all.
>
> Step #0 would be to think about OP_RETURN actually. FWIW Jeff Garzik has
> a pull-req (https://github.com/bitcoin/bitcoin/pull/2738) to enable it,
> although only one txout per tx, and only with a 80-byte payload.
>
> Even just some ad-hoc voting by the "raise-the-limit" crowd would be a
> good first step to gaging interest.
>
> > Coercion and vote buying is of course possible in this system. A miner
> could
> > say that they will only accept transactions accompanied by a vote for a
> given
> > limit. However in a decentralized system completely preventing vote
> buying is
> > of course impossble, and the design of Bitcoin itself has a fundemental
>
> Is it really? There might be someone clever with a cryptographic voting
> protocol, although in the case of Bitcoin we have to let people vote
> with arbitrary scriptPubKeys, so almost anything less general than full
> on SCIP just means miners force people to use the protocol where
> vote-buying is possible.
>
> > A voting process ensures that any increase to the blocksize genuinely
> > represents the desires of the Bitcoin community, and the process
> described
> > above ensures that any changes happen at a rate that gives all
> participants
> > time to react. The process also gives a mechanism for the community to
> vote to
> > decrease the limit if it turns out that the new one was in fact too
> high. (note
> > how the way the status quo is set ensures the default action is for the
> limit
> > to gradually decrease even if everyone stops voting)
>
> Good idea. So it'd decrease to the mean of the old and new limits
> basically, and if Bitcoin becomes "too centralized" users can simply do
> nothing and the process gradually reverses.
>
> > As many of you know I have been quite vocal that the 1MB limit should
> stay. But
> > I would be happy to support the outcome of a vote done properly,
> whatever that
> > outcome may be.
>
> Same here.
>
> --
> 'peter'[:-1]@petertodd.org
> 0000000000000068a8ad033afa763246fe451e840eae5215eb3a64e8101a46c3
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/214bfa8e/attachment.html>

From melvincarvalho at gmail.com  Mon Jun 10 08:14:01 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Mon, 10 Jun 2013 10:14:01 +0200
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
Message-ID: <CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>

On 10 June 2013 06:09, John Dillon <john.dillon892 at googlemail.com> wrote:

> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA256
>
> It has been suggested that we leave the decision of what the blocksize to
> be
> entirely up to miners. However this leaves a parameter that affects every
> Bitcoin participant in the control of a small minority. Of course we can
> not
> force miners to increase the blocksize if they choose to decrease it,
> because
> the contents of the blocks they make are their decision and their decision
> only. However proposals to leave the maximum size unlimited to allow
> miners to
> force us to accept arbitrarily large blocks even if the will of the
> majority of
> Bitcoin participants is that they wish to remain able to validate the
> blockchain.
>
> What we need is a way to balance this asymetrical power relationship.
>
> Proof-of-stake voting gives us a way of achieving that balance.
> Essentially for
> a miner to prove that the majority will of the poeple is to accept a larger
> blocksize they must prove that the majority has in fact voted for that
> increase. The upper limit on the blocksize is then determined by the
> median of
> all votes, where each txout in the UTXO set is one vote, weighted by txout
> value. A txout without a corresponding vote is considered to be a vote for
> the
> status quo. To allow the voting process to continue even if coins are
> "lost"
> votes, including default votes, are weighted inversely according to their
> age
> in years after 1 year. IE a vote with weight 1BTC that is 1.5 years old
> will be
> recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1 day
> old
> and 6 months old UTXO are treated equivalently. The 1 year minimum is
> simply to
> make voting required no more than once per year. (of course, a real
> implementation should do all of these figures by block height, IE after
> 52,560
> blocks instead of after 1 year)
>
> A vote will consist of a txout with a scriptPubKey of the following form:
>
>     OP_RETURN magic vote_id txid vout vote scriptSig
>
> Where scriptSig is a valid signature for a transaction with nLockTime
> 500,000,000-1 spending txid:vout to scriptPubKey:
>
>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL
>
> vote_id is the ID of the specific vote being made, and magic is included to
> allow UTXO proof implementations a as yet unspecified way of identifying
> votes
> and including the weighted median as part of the UTXO tree sums. (it also
> allows SPV clients to verify the vote if the UTXO set is a Patricia tree of
> scriptPubKeys) vote is just the numerical vote itself. The vote must
> compute
> the median, rather than the mean, so as to not allow someone to skew the
> vote
> by simply setting their value extremely high. Someone who still remembers
> their
> statistics classes should chime in on the right way to compute a median in
> a
> merkle-sum-tree.
>
> The slightly unusual construction of votes makes implementation by wallet
> software as simple as possible within existing code-paths. Votes could
> still be
> constructed even in wallets lacking specific voting capability provided the
> wallet software does have the ability to set nLockTime.
>
> Of course in the future the voting mechanism can be used for additional
> votes
> with an additional vote_id. For instance the Bitcoin community could vote
> to
> increase the inflation subsidy, another example of a situation where the
> wishes
> of miners may conflict with the wishes of the broader community.
>
> Users may of course actually create these specially encoded txouts
> themselves
> and get them into the blockchain.  However doing so is not needed as a
> given
> vote is only required to actually be in the chain by a miner wishing to
> increase the blocksize. Thus we should extend the P2P protocol with a
> mechanism
> by which votes can be broadcast independently of transactions. To prevent
> DoS
> attacks only votes with known vote_id's will be accepted, and only for
> txid:vout's already in the blockchain, and a record of txouts for whom
> votes
> have already broadcast will be kept. (this record need not be
> authoritative as
> its purpose is only to prevent DoS attacks) Miners wishing to increase the
> blocksize can record these votes and include them in the blocks they mine
> as
> required. To reduce the cost of including votes in blocks 5% of every block
> should be assigned to voting only. (this can be implemented by a soft-fork)
>
> For any given block actual limit in effect is then the rolling median of
> the
> blocks in the last year. At the beginning of every year the value
> considered to
> be the status quo resets to the mean of the limit at the beginning and end
> of
> the interval.  (again, by "year" we really mean 52,560 blocks) The rolling
> median and periodic reset process ensures that the limit changes gradually
> and
> is not influenced by temporary events such as hacks to large exchanges or
> malicious wallet software.  The rolling median also ensures that for a
> miner
> the act of including a vote is never wasted due to the txout later being
> spent.
>
> Implementing the voting system can happen prior to an actual hard-fork
> allowing
> for an increase and can be an important part of determining if the
> hard-fork is
> required at all.
>
> Coercion and vote buying is of course possible in this system. A miner
> could
> say that they will only accept transactions accompanied by a vote for a
> given
> limit. However in a decentralized system completely preventing vote buying
> is
> of course impossble, and the design of Bitcoin itself has a fundemental
> assumption that a majority of miners will behave in a specific kind of
> "honest"
> way.
>
> A voting process ensures that any increase to the blocksize genuinely
> represents the desires of the Bitcoin community, and the process described
> above ensures that any changes happen at a rate that gives all participants
> time to react. The process also gives a mechanism for the community to
> vote to
> decrease the limit if it turns out that the new one was in fact too high.
> (note
> how the way the status quo is set ensures the default action is for the
> limit
> to gradually decrease even if everyone stops voting)
>
> As many of you know I have been quite vocal that the 1MB limit should
> stay. But
> I would be happy to support the outcome of a vote done properly, whatever
> that
> outcome may be.
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v1.4.11 (GNU/Linux)
>
> iQEcBAEBCAAGBQJRtVFBAAoJEEWCsU4mNhiP6EAIAMjq4UgXxmEjOgHWf0KcmwmH
> Ra/I3oY7krvg/lu1YCa+ACMBdoca9WODySUIe7R3niphKXEnknHGUIf8tm/Vrq4H
> gPF4cgYEr18EYTVtvT9J1pZUB4f5dxkXXNpcQ60juaz9KervFQMOGnpr6Fyxi3dS
> ghObNYcr3D2v1fjx56sp7BCNn0XHxTb1ZLUJB0BZhDKlamfgcxruKMbpsZmACJUj
> gTNLNweaAomBIH++j7cnXeB0jZc/1ilv8qLA/f3TGb43FDkAQcvvSjGijI+OJOm6
> Fh/WRBav1BJiV6PKs9xuHXsaxZ/T7Fb8Wg8EynSi0mSj47QXdKZgeZCi3XlSyxM=
> =aKBD
> -----END PGP SIGNATURE-----
>

-1

Firstly I appreciate the ingenious thought that went into this post.

However, Bitcoin's fundamental philosophy was one CPU one vote.

Voting is easily gamed.  While this may work in one particular case, it is
perhaps a bad precedent to set.  Establishing methods of voting can lead to
single points of failure.

The asymmetry lies in psychological terms, in that new defaults tend to be
adopted 80% of the time, so core devs have disproportionate amount of power
as things stand.

Unless there's a very good reason not to, e.g. miners are clearly abusing
the system, we should stick with 1 CPU one vote.


>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/e22f5db1/attachment.html>

From john.dillon892 at googlemail.com  Mon Jun 10 08:26:39 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Mon, 10 Jun 2013 08:26:39 +0000
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>
Message-ID: <CAPaL=UUNMzBUD4FToh72H_YYpZ5X3zCCkOdyX1_8CB7fR9Ec5Q@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On Mon, Jun 10, 2013 at 8:14 AM, Melvin Carvalho
<melvincarvalho at gmail.com> wrote:
> -1
>
> Firstly I appreciate the ingenious thought that went into this post.
>
> However, Bitcoin's fundamental philosophy was one CPU one vote.

Indeed it was. Which is why as GPU's came onto the scene Satoshi was strongly
against them. I have to wonder what he thinks of ASICs where just a handful of
companies control the supply of Bitcoin hashing power.

Satoshi also never forsaw pools, which are why just 2 or 3 people control the
majority of Bitcoin hashing power.

> The asymmetry lies in psychological terms, in that new defaults tend to be
> adopted 80% of the time, so core devs have disproportionate amount of power
> as things stand.

That's why I'm very clear that doing nothing is a vote for the status quo. Of
course wallet authors can do what they want to try to get users to vote
according to their wishes, or for that matter simply steal your vote, but we
already must put a lot of faith into wallets to not steal our funds.

> Unless there's a very good reason not to, e.g. miners are clearly abusing
> the system, we should stick with 1 CPU one vote.

People are proposing we put control of the blocksize entirely into the hands of
miners, yet we all have an interest in auditing the blocks miners produce.
There must be balance.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRtY2jAAoJEEWCsU4mNhiPQEsH/0VNA7aJYdUbJjTnIiKoaCv3
JtWS1MKHjAJE6ZPDt+T/QPkEdZI4kNz3DGcZL6EDJtvZxZHfvEIaZDF1gpaH6OkC
oIZ0PkFPOxi0cncuAvT/a770evu7LzuT6fisY3EgGnlHujLQZ47LEa73Xo7pJVc7
RJHamGwkj+3HZRIuZIAn87qws/zRyTx5SXvb56xCKb0oxE4ZO0dn+8/nNSPWw13i
p3LpLlEQBBu+Du2nPSQupRjkz4MPP8v9EYefV5cjtNBK7ufAvA64OnwKB5dST+h+
N/vBcj3EIj/WEOf4myGcVxKp+skJ2SJDwxLigevgkKYPDNTVfXIverdXB0ANrQA=
=c8iU
-----END PGP SIGNATURE-----



From pieter.wuille at gmail.com  Mon Jun 10 08:35:19 2013
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 10 Jun 2013 10:35:19 +0200
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>
Message-ID: <CAPg+sBh68-AcAVEfkRBT-x2O+DYHROYkFtG4dmZ1JfNGRr__Mg@mail.gmail.com>

On Mon, Jun 10, 2013 at 10:14 AM, Melvin Carvalho
<melvincarvalho at gmail.com> wrote:
> However, Bitcoin's fundamental philosophy was one CPU one vote.

This is perhaps the largest misconception that keeps being repeated.
Bitcoin is not a democracy; it is a zero-trust system. The rules are
set in stone, and every full node verifies all rules and must
independently come to the same result as everyone else. Obviously, if
everyone changes their software, anything can change, but from within
the system there is no way to change which blocks are considered
valid, and there is certainly no voting mechanism about that.

What is voted about, is the one single thing that cannot be decided by
each node individually: namely the order of otherwise valid and
non-conflicting transactions, and that's just because it's a
necessity. Because deciding the order includes delaying transaction
potentially indefinitely, a majority of miners can indeed choose the
enforce an additional rule about which transactions are considered
valid, but the rules implemented in full nodes do not change without
changing the software. For example, miners cannot decide to raise the
block subsidy, even if every single miner out there would want that.
They'd just end up being ignored by everyone else.

> Voting is easily gamed.  While this may work in one particular case, it is
> perhaps a bad precedent to set.  Establishing methods of voting can lead to
> single points of failure.

The problem is that at some point, you have to look at the system from
a higher level than just the technical part. And because ultimately
the possibility exists where everyone changes their software, and
there is an exceedingly high incentive for consensus (a deliberate
hard-fork where two groups of users decide to use different and
incompatible rules, aware of eachother, is suicide for the system, in
my opinion). This results in the fact that proposed changes can indeed
become new adopted hard rules in the system, and I don't think there's
anything that can be done about it. Bitcoin is a consensus system - at
the technical level - but also a consensus of the people using it, and
ultimately they decide the rules.

> Unless there's a very good reason not to, e.g. miners are clearly abusing
> the system, we should stick with 1 CPU one vote.

So you're saying that instead of a zero-trust system, we should move
to a system where miners can decide _everything_ - as opposed to just
being in charge of ordering transactions? I don't think you understand
the system at all, if that is what you're proposing.

-- 
Pieter



From melvincarvalho at gmail.com  Mon Jun 10 08:39:09 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Mon, 10 Jun 2013 10:39:09 +0200
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAPaL=UUNMzBUD4FToh72H_YYpZ5X3zCCkOdyX1_8CB7fR9Ec5Q@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>
	<CAPaL=UUNMzBUD4FToh72H_YYpZ5X3zCCkOdyX1_8CB7fR9Ec5Q@mail.gmail.com>
Message-ID: <CAKaEYhJd==3qL3G326xo---Cw+i8X256ZyOppCumnLKYkqy-jg@mail.gmail.com>

On 10 June 2013 10:26, John Dillon <john.dillon892 at googlemail.com> wrote:

> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA256
>
> On Mon, Jun 10, 2013 at 8:14 AM, Melvin Carvalho
> <melvincarvalho at gmail.com> wrote:
> > -1
> >
> > Firstly I appreciate the ingenious thought that went into this post.
> >
> > However, Bitcoin's fundamental philosophy was one CPU one vote.
>
> Indeed it was. Which is why as GPU's came onto the scene Satoshi was
> strongly
> against them. I have to wonder what he thinks of ASICs where just a
> handful of
> companies control the supply of Bitcoin hashing power.
>

Thanks for your reply.  Do you have a pointer to Satoshi being strongly
against GPU?  I'd be interested to see that.  FWIW, I've read all his forum
posts a few times, I just dont recall this one, tho I'm sure it's there...


>
> Satoshi also never forsaw pools, which are why just 2 or 3 people control
> the
> majority of Bitcoin hashing power.
>
> > The asymmetry lies in psychological terms, in that new defaults tend to
> be
> > adopted 80% of the time, so core devs have disproportionate amount of
> power
> > as things stand.
>
> That's why I'm very clear that doing nothing is a vote for the status quo.
> Of
> course wallet authors can do what they want to try to get users to vote
> according to their wishes, or for that matter simply steal your vote, but
> we
> already must put a lot of faith into wallets to not steal our funds.
>
> > Unless there's a very good reason not to, e.g. miners are clearly abusing
> > the system, we should stick with 1 CPU one vote.
>
> People are proposing we put control of the blocksize entirely into the
> hands of
> miners, yet we all have an interest in auditing the blocks miners produce.
> There must be balance.
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v1.4.11 (GNU/Linux)
>
> iQEcBAEBCAAGBQJRtY2jAAoJEEWCsU4mNhiPQEsH/0VNA7aJYdUbJjTnIiKoaCv3
> JtWS1MKHjAJE6ZPDt+T/QPkEdZI4kNz3DGcZL6EDJtvZxZHfvEIaZDF1gpaH6OkC
> oIZ0PkFPOxi0cncuAvT/a770evu7LzuT6fisY3EgGnlHujLQZ47LEa73Xo7pJVc7
> RJHamGwkj+3HZRIuZIAn87qws/zRyTx5SXvb56xCKb0oxE4ZO0dn+8/nNSPWw13i
> p3LpLlEQBBu+Du2nPSQupRjkz4MPP8v9EYefV5cjtNBK7ufAvA64OnwKB5dST+h+
> N/vBcj3EIj/WEOf4myGcVxKp+skJ2SJDwxLigevgkKYPDNTVfXIverdXB0ANrQA=
> =c8iU
> -----END PGP SIGNATURE-----
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/d2971bec/attachment.html>

From melvincarvalho at gmail.com  Mon Jun 10 12:30:02 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Mon, 10 Jun 2013 14:30:02 +0200
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAPg+sBh68-AcAVEfkRBT-x2O+DYHROYkFtG4dmZ1JfNGRr__Mg@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<CAKaEYhLsSm6KTr3YV+GxQGiBBNX0psxxOYkgwR1pm4ZpBY0Ymw@mail.gmail.com>
	<CAPg+sBh68-AcAVEfkRBT-x2O+DYHROYkFtG4dmZ1JfNGRr__Mg@mail.gmail.com>
Message-ID: <CAKaEYh+6eKm0FxGnWQA6RLXC4WO37JJ3nHNqsnNbFqAuAmuUOA@mail.gmail.com>

On 10 June 2013 10:35, Pieter Wuille <pieter.wuille at gmail.com> wrote:

> On Mon, Jun 10, 2013 at 10:14 AM, Melvin Carvalho
> <melvincarvalho at gmail.com> wrote:
> > However, Bitcoin's fundamental philosophy was one CPU one vote.
>
> This is perhaps the largest misconception that keeps being repeated.
> Bitcoin is not a democracy; it is a zero-trust system. The rules are
> set in stone, and every full node verifies all rules and must
> independently come to the same result as everyone else. Obviously, if
> everyone changes their software, anything can change, but from within
> the system there is no way to change which blocks are considered
> valid, and there is certainly no voting mechanism about that.
>
> What is voted about, is the one single thing that cannot be decided by
> each node individually: namely the order of otherwise valid and
> non-conflicting transactions, and that's just because it's a
> necessity. Because deciding the order includes delaying transaction
> potentially indefinitely, a majority of miners can indeed choose the
> enforce an additional rule about which transactions are considered
> valid, but the rules implemented in full nodes do not change without
> changing the software. For example, miners cannot decide to raise the
> block subsidy, even if every single miner out there would want that.
> They'd just end up being ignored by everyone else.
>
> > Voting is easily gamed.  While this may work in one particular case, it
> is
> > perhaps a bad precedent to set.  Establishing methods of voting can lead
> to
> > single points of failure.
>
> The problem is that at some point, you have to look at the system from
> a higher level than just the technical part. And because ultimately
> the possibility exists where everyone changes their software, and
> there is an exceedingly high incentive for consensus (a deliberate
> hard-fork where two groups of users decide to use different and
> incompatible rules, aware of eachother, is suicide for the system, in
> my opinion). This results in the fact that proposed changes can indeed
> become new adopted hard rules in the system, and I don't think there's
> anything that can be done about it. Bitcoin is a consensus system - at
> the technical level - but also a consensus of the people using it, and
> ultimately they decide the rules.
>

OK I accept that the timestamping is one CPU one vote.  However rule
changes seem rather arbitrary.

Towit if you use a voting/consensus system and want to destroy bitcion it
seems quite easy.

Iterate on picking a rule chance that will divide the consensus in such a
way as to create ensuing chaos.

I think voting is too easy gamed for it it to be meaningful other than a
straw poll.

If there's a bug, and everyone is unanimous that it's a bug, it can be
fixed.

If there's a controversial rule change, we should be extremely cautious and
not do it unless there's a very good reason.  Keeping to satoshi's model as
much as possible without introducing human factors, unnecessarily.


>
>
> > Unless there's a very good reason not to, e.g. miners are clearly abusing
> > the system, we should stick with 1 CPU one vote.
>
> So you're saying that instead of a zero-trust system, we should move
> to a system where miners can decide _everything_ - as opposed to just
> being in charge of ordering transactions? I don't think you understand
> the system at all, if that is what you're proposing.
>
> --
> Pieter
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/7686b617/attachment.html>

From mark at monetize.io  Mon Jun 10 16:46:16 2013
From: mark at monetize.io (Mark Friedenbach)
Date: Mon, 10 Jun 2013 09:46:16 -0700
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
Message-ID: <51B602D8.5030706@monetize.io>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

John,

What you are recommending is a drastic change that the conservative
bitcoin developers probably wouldn't get behind (but let's see). However
proof-of-stake voting on protocol soft-forks has vast implications even
beyond the block size limit. Within Freicoin, we have looked at is as a
possibility for determining how to distribute the demurrage, a proposal
we are calling 'Republicoin' due to the fact that with proxy voting we
expect a system to emerge similar to the government budgeting in
parliamentary republics. Distributed, non-coersive government by
protocol, if you will.

So anyway, even if you get shot down, please continue to pursue this
proposal. It very likely has uses that you haven't thought of yet.

Cheers,
Mark

On 6/9/13 9:09 PM, John Dillon wrote:
> It has been suggested that we leave the decision of what the blocksize to be
> entirely up to miners. However this leaves a parameter that affects every
> Bitcoin participant in the control of a small minority. Of course we
can not
> force miners to increase the blocksize if they choose to decrease it,
because
> the contents of the blocks they make are their decision and their decision
> only. However proposals to leave the maximum size unlimited to allow
miners to
> force us to accept arbitrarily large blocks even if the will of the
majority of
> Bitcoin participants is that they wish to remain able to validate the
> blockchain.
>
> What we need is a way to balance this asymetrical power relationship.
>
> Proof-of-stake voting gives us a way of achieving that balance.
Essentially for
> a miner to prove that the majority will of the poeple is to accept a
larger
> blocksize they must prove that the majority has in fact voted for that
> increase. The upper limit on the blocksize is then determined by the
median of
> all votes, where each txout in the UTXO set is one vote, weighted by txout
> value. A txout without a corresponding vote is considered to be a vote
for the
> status quo. To allow the voting process to continue even if coins are
"lost"
> votes, including default votes, are weighted inversely according to
their age
> in years after 1 year. IE a vote with weight 1BTC that is 1.5 years
old will be
> recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1
day old
> and 6 months old UTXO are treated equivalently. The 1 year minimum is
simply to
> make voting required no more than once per year. (of course, a real
> implementation should do all of these figures by block height, IE
after 52,560
> blocks instead of after 1 year)
>
> A vote will consist of a txout with a scriptPubKey of the following form:
>
>     OP_RETURN magic vote_id txid vout vote scriptSig
>
> Where scriptSig is a valid signature for a transaction with nLockTime
> 500,000,000-1 spending txid:vout to scriptPubKey:
>
>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL
>
> vote_id is the ID of the specific vote being made, and magic is
included to
> allow UTXO proof implementations a as yet unspecified way of
identifying votes
> and including the weighted median as part of the UTXO tree sums. (it also
> allows SPV clients to verify the vote if the UTXO set is a Patricia
tree of
> scriptPubKeys) vote is just the numerical vote itself. The vote must
compute
> the median, rather than the mean, so as to not allow someone to skew
the vote
> by simply setting their value extremely high. Someone who still
remembers their
> statistics classes should chime in on the right way to compute a
median in a
> merkle-sum-tree.
>
> The slightly unusual construction of votes makes implementation by wallet
> software as simple as possible within existing code-paths. Votes could
still be
> constructed even in wallets lacking specific voting capability
provided the
> wallet software does have the ability to set nLockTime.
>
> Of course in the future the voting mechanism can be used for
additional votes
> with an additional vote_id. For instance the Bitcoin community could
vote to
> increase the inflation subsidy, another example of a situation where
the wishes
> of miners may conflict with the wishes of the broader community.
>
> Users may of course actually create these specially encoded txouts
themselves
> and get them into the blockchain.  However doing so is not needed as a
given
> vote is only required to actually be in the chain by a miner wishing to
> increase the blocksize. Thus we should extend the P2P protocol with a
mechanism
> by which votes can be broadcast independently of transactions. To
prevent DoS
> attacks only votes with known vote_id's will be accepted, and only for
> txid:vout's already in the blockchain, and a record of txouts for whom
votes
> have already broadcast will be kept. (this record need not be
authoritative as
> its purpose is only to prevent DoS attacks) Miners wishing to increase the
> blocksize can record these votes and include them in the blocks they
mine as
> required. To reduce the cost of including votes in blocks 5% of every
block
> should be assigned to voting only. (this can be implemented by a
soft-fork)
>
> For any given block actual limit in effect is then the rolling median
of the
> blocks in the last year. At the beginning of every year the value
considered to
> be the status quo resets to the mean of the limit at the beginning and
end of
> the interval.  (again, by "year" we really mean 52,560 blocks) The rolling
> median and periodic reset process ensures that the limit changes
gradually and
> is not influenced by temporary events such as hacks to large exchanges or
> malicious wallet software.  The rolling median also ensures that for a
miner
> the act of including a vote is never wasted due to the txout later
being spent.
>
> Implementing the voting system can happen prior to an actual hard-fork
allowing
> for an increase and can be an important part of determining if the
hard-fork is
> required at all.
>
> Coercion and vote buying is of course possible in this system. A miner
could
> say that they will only accept transactions accompanied by a vote for
a given
> limit. However in a decentralized system completely preventing vote
buying is
> of course impossble, and the design of Bitcoin itself has a fundemental
> assumption that a majority of miners will behave in a specific kind of
"honest"
> way.
>
> A voting process ensures that any increase to the blocksize genuinely
> represents the desires of the Bitcoin community, and the process described
> above ensures that any changes happen at a rate that gives all
participants
> time to react. The process also gives a mechanism for the community to
vote to
> decrease the limit if it turns out that the new one was in fact too
high. (note
> how the way the status quo is set ensures the default action is for
the limit
> to gradually decrease even if everyone stops voting)
>
> As many of you know I have been quite vocal that the 1MB limit should
stay. But
> I would be happy to support the outcome of a vote done properly,
whatever that
> outcome may be.
>
>
------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> .
>

-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.19 (Darwin)
Comment: GPGTools - http://gpgtools.org
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQIcBAEBAgAGBQJRtgLYAAoJEAdzVfsmodw4vWEQAIWxuEXMZb80qTMFyvWiR0Tt
Cn/yx8iG2tPa4xGUq0ypwBU3doFEzYBj3bMyQuluGRP7BBhGat4qhrmI/qGVwYXW
RSQdbdgnp4DXhaOD2QzYh/5zDbN/1jCkuxyUvx/QNAeNEpmN1BoDKhDlM/ywCKdj
qfFZWj30pTzADJiY7P5upCu3TiYuQtTWTHlap2c4fToNsLxAMiLZJTOE1Ytdc31Q
O8iwkV7eFlueawtfFLh/dNz5zVKXSOoNz1sFmgjkO3QQaSqSzinBE1z3vR9QYL+A
R7X1v0sQXDpE0XiPymWE8adjGIai3CBUVZcvnJrPtUznydmpe+OvLf3UZE+QfCuJ
tLP9u42e+gjOb6r9qp4tLZBGlTR2moY/IPtVs8KiMDWt9Nq1fO94IBGyJgFYOxRn
Zq6/funKTO6SO8d+ppQ158s2faVmN3OKMrn6BNnfddWD3/EBhGzEDzuNuNAvfKqQ
nrqEusWrfOZOh66pIs6qvROSamaC42FXMUwBU0wA3W3MEuQhXrGM1S2huKykgZ9W
WsOpC6ng6j5H5dSIs4tvnsDY9hUa9zWIB1+i368pXDv8biOs7ULKEP3mdC1q+4YD
tM/MkC0xKax2zG4wbbez8FpwTpUOOznpYPMZqXkLOkGCAdiAyg2UnLPduudaAkQz
adXXe284XHjjOcZUDvGw
=trsn
-----END PGP SIGNATURE-----

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/42ceb624/attachment.html>

From etotheipi at gmail.com  Mon Jun 10 17:25:05 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Mon, 10 Jun 2013 13:25:05 -0400
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <51B602D8.5030706@monetize.io>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<51B602D8.5030706@monetize.io>
Message-ID: <51B60BF1.3020701@gmail.com>

One major problem I see with this, no matter how well-thought-out it is,
it's unlikely that those with money will participate.  Those with the
most stake, likely have their private keys behind super-secure
accessibility barriers, and are not likely to go through the effort just
to sign votes.  Not only that, but it would require them to reveal their
public key, which while isn't technically so terrible, large amounts of
money intended to be kept in storage for 10+ years will prefer to avoid
any exposure at all, in the oft-chance that QCs come around a lot
earlier than we expected.  Sure, the actual risk should be pretty much
non-existent, but some of the most paranoid folks are probably the same
ones who have a lot of funds and want 100.00% of the security that is
possible.   They will see this as wildly inconvenient.

I think this a great thought experiment, and I'd like to see where this
idea goes, in terms of designing ways for a decentralized community to
find consensus for important decisions, but I don't think that any idea
that requires users to dig up their private keys is going to be feasible
(or possibly reconstruct them from pieces and/or get multiple
signatures).  Especially if the system requires some kind of persistent
voting.

-Alan


On 06/10/2013 12:46 PM, Mark Friedenbach wrote:
>
> John,
>
> What you are recommending is a drastic change that the conservative
> bitcoin developers probably wouldn't get behind (but let's see).
> However proof-of-stake voting on protocol soft-forks has vast
> implications even beyond the block size limit. Within Freicoin, we
> have looked at is as a possibility for determining how to distribute
> the demurrage, a proposal we are calling 'Republicoin' due to the fact
> that with proxy voting we expect a system to emerge similar to the
> government budgeting in parliamentary republics. Distributed,
> non-coersive government by protocol, if you will.
>
> So anyway, even if you get shot down, please continue to pursue this
> proposal. It very likely has uses that you haven't thought of yet.
>
> Cheers,
> Mark
>
> On 6/9/13 9:09 PM, John Dillon wrote:
> > It has been suggested that we leave the decision of what the
> blocksize to be
> > entirely up to miners. However this leaves a parameter that affects
> every
> > Bitcoin participant in the control of a small minority. Of course we
> can not
> > force miners to increase the blocksize if they choose to decrease
> it, because
> > the contents of the blocks they make are their decision and their
> decision
> > only. However proposals to leave the maximum size unlimited to allow
> miners to
> > force us to accept arbitrarily large blocks even if the will of the
> majority of
> > Bitcoin participants is that they wish to remain able to validate the
> > blockchain.
>
> > What we need is a way to balance this asymetrical power relationship.
>
> > Proof-of-stake voting gives us a way of achieving that balance.
> Essentially for
> > a miner to prove that the majority will of the poeple is to accept a
> larger
> > blocksize they must prove that the majority has in fact voted for that
> > increase. The upper limit on the blocksize is then determined by the
> median of
> > all votes, where each txout in the UTXO set is one vote, weighted by
> txout
> > value. A txout without a corresponding vote is considered to be a
> vote for the
> > status quo. To allow the voting process to continue even if coins
> are "lost"
> > votes, including default votes, are weighted inversely according to
> their age
> > in years after 1 year. IE a vote with weight 1BTC that is 1.5 years
> old will be
> > recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1
> day old
> > and 6 months old UTXO are treated equivalently. The 1 year minimum
> is simply to
> > make voting required no more than once per year. (of course, a real
> > implementation should do all of these figures by block height, IE
> after 52,560
> > blocks instead of after 1 year)
>
> > A vote will consist of a txout with a scriptPubKey of the following
> form:
>
> >     OP_RETURN magic vote_id txid vout vote scriptSig
>
> > Where scriptSig is a valid signature for a transaction with nLockTime
> > 500,000,000-1 spending txid:vout to scriptPubKey:
>
> >     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL
>
> > vote_id is the ID of the specific vote being made, and magic is
> included to
> > allow UTXO proof implementations a as yet unspecified way of
> identifying votes
> > and including the weighted median as part of the UTXO tree sums. (it
> also
> > allows SPV clients to verify the vote if the UTXO set is a Patricia
> tree of
> > scriptPubKeys) vote is just the numerical vote itself. The vote must
> compute
> > the median, rather than the mean, so as to not allow someone to skew
> the vote
> > by simply setting their value extremely high. Someone who still
> remembers their
> > statistics classes should chime in on the right way to compute a
> median in a
> > merkle-sum-tree.
>
> > The slightly unusual construction of votes makes implementation by
> wallet
> > software as simple as possible within existing code-paths. Votes
> could still be
> > constructed even in wallets lacking specific voting capability
> provided the
> > wallet software does have the ability to set nLockTime.
>
> > Of course in the future the voting mechanism can be used for
> additional votes
> > with an additional vote_id. For instance the Bitcoin community could
> vote to
> > increase the inflation subsidy, another example of a situation where
> the wishes
> > of miners may conflict with the wishes of the broader community.
>
> > Users may of course actually create these specially encoded txouts
> themselves
> > and get them into the blockchain.  However doing so is not needed as
> a given
> > vote is only required to actually be in the chain by a miner wishing to
> > increase the blocksize. Thus we should extend the P2P protocol with
> a mechanism
> > by which votes can be broadcast independently of transactions. To
> prevent DoS
> > attacks only votes with known vote_id's will be accepted, and only for
> > txid:vout's already in the blockchain, and a record of txouts for
> whom votes
> > have already broadcast will be kept. (this record need not be
> authoritative as
> > its purpose is only to prevent DoS attacks) Miners wishing to
> increase the
> > blocksize can record these votes and include them in the blocks they
> mine as
> > required. To reduce the cost of including votes in blocks 5% of
> every block
> > should be assigned to voting only. (this can be implemented by a
> soft-fork)
>
> > For any given block actual limit in effect is then the rolling
> median of the
> > blocks in the last year. At the beginning of every year the value
> considered to
> > be the status quo resets to the mean of the limit at the beginning
> and end of
> > the interval.  (again, by "year" we really mean 52,560 blocks) The
> rolling
> > median and periodic reset process ensures that the limit changes
> gradually and
> > is not influenced by temporary events such as hacks to large
> exchanges or
> > malicious wallet software.  The rolling median also ensures that for
> a miner
> > the act of including a vote is never wasted due to the txout later
> being spent.
>
> > Implementing the voting system can happen prior to an actual
> hard-fork allowing
> > for an increase and can be an important part of determining if the
> hard-fork is
> > required at all.
>
> > Coercion and vote buying is of course possible in this system. A
> miner could
> > say that they will only accept transactions accompanied by a vote
> for a given
> > limit. However in a decentralized system completely preventing vote
> buying is
> > of course impossble, and the design of Bitcoin itself has a fundemental
> > assumption that a majority of miners will behave in a specific kind
> of "honest"
> > way.
>
> > A voting process ensures that any increase to the blocksize genuinely
> > represents the desires of the Bitcoin community, and the process
> described
> > above ensures that any changes happen at a rate that gives all
> participants
> > time to react. The process also gives a mechanism for the community
> to vote to
> > decrease the limit if it turns out that the new one was in fact too
> high. (note
> > how the way the status quo is set ensures the default action is for
> the limit
> > to gradually decrease even if everyone stops voting)
>
> > As many of you know I have been quite vocal that the 1MB limit
> should stay. But
> > I would be happy to support the outcome of a vote done properly,
> whatever that
> > outcome may be.
>
> >
> ------------------------------------------------------------------------------
> > How ServiceNow helps IT people transform IT departments:
> > 1. A cloud service to automate IT design, transition and operations
> > 2. Dashboards that offer high-level views of enterprise services
> > 3. A single system of record for all IT processes
> > http://p.sf.net/sfu/servicenow-d2d-j
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> > .
>
>
>
>
>
>
------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/6c87044b/attachment.html>

From pete at petertodd.org  Mon Jun 10 17:43:06 2013
From: pete at petertodd.org (Peter Todd)
Date: Mon, 10 Jun 2013 13:43:06 -0400
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <51B60BF1.3020701@gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<51B602D8.5030706@monetize.io> <51B60BF1.3020701@gmail.com>
Message-ID: <20130610174306.GA16549@petertodd.org>

On Mon, Jun 10, 2013 at 01:25:05PM -0400, Alan Reiner wrote:
> to sign votes.  Not only that, but it would require them to reveal their
> public key, which while isn't technically so terrible, large amounts of
> money intended to be kept in storage for 10+ years will prefer to avoid
> any exposure at all, in the oft-chance that QCs come around a lot
> earlier than we expected.  Sure, the actual risk should be pretty much
> non-existent, but some of the most paranoid folks are probably the same
> ones who have a lot of funds and want 100.00% of the security that is
> possible.   They will see this as wildly inconvenient.

Solving that problem is pretty easy actually: just add a voting only
public key to your outputs. Specifically you would have an opcode called
something like "OP_VOTE" and put a code-path in your script that only
executes for that specific key.

It'd work best if we implement merklized abstract syntax trees to allow
you to reveal only the part of a script that is actually executed rather
than the whole script, a feature useful for a lot of other things.


Incidentally remember that we can implement as many new opcodes as we
want with a soft-fork by redefining one of the OP_NOP's to be a
OP_VERSION opcode that returns false for a given version:

    version OP_VERSION OP_IFNOT {new opcodes} OP_ENDIF

Nodes with the existing codebase will think the script always succeeds,
because the IFNOT branch isn't taken, leaving the non-false version on
the stack, while new nodes will take that branch.

-- 
'peter'[:-1]@petertodd.org
0000000000000109243df1322b7b5173c5796cf979318e933d887210c981c1f8
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/0edca47a/attachment.sig>

From pete at petertodd.org  Mon Jun 10 21:09:13 2013
From: pete at petertodd.org (Peter Todd)
Date: Mon, 10 Jun 2013 17:09:13 -0400
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <20130531165758.GA29135@petertodd.org>
References: <20130527111149.GB8955@tilt> <20130531165445.GA29104@petertodd.org>
	<20130531165758.GA29135@petertodd.org>
Message-ID: <20130610210913.GA17242@petertodd.org>

So here's the parts that need to be done for step #1:


# Protocol Work

Basic idea is the miner makes two connections, their pool, and a local
bitcoind.

They always (usually?) work on the subset of transactions common to both
the pool's getblocktemplate and their local one. When they find a share
if it doesn't meet difficulty they just hand it to the pool. Currently
that is done by handing the whole block over, correct? I know the BIP
says otherwise, but we should optimize this to just hand over tx hashes
where possible.

If the share does meet difficulty, hand it to both the pool and the
local bitcoind. Should hand it to the pool first though, because the
pool likely has the fastest block propagation, then hand it to local
bitcoind. An optimized version may want to have some record of measured
bandwidth - this applies Bitcoin in general too, although also has other
issues.


## Reducing bandwidth

How about for normal shares we just pass the block header, and have the
pool randomly pick a subset of transactions to audit? Any fraud cancels
the users shares. This will work best in conjunction with a UTXO proof
tree to prove fees, or by just picking whole shares randomly to audit.

We'll need persistent share storage so if your connection disconnects
you can provide the pool with the full share later though.

Incedentally, note how the miner can do the reverse: pick random block
headers and challenge the pool to prove that they correspond to a valid
block. With some modifications Stratum can support this approach.


## Delibrate orphaning of slow to propagate blocks

Block headers can be flooded-filled much faster than blocks themselves.
They are also small enough to fit into a UDP packet. Nodes should pass
headers around separately via UDP, optinally with some tiny number of
transactions. When we see a valid block header whose contents we do not
know about a miner should switch to mining empty or near empty blocks in
solo mode that would orphan the still propagating block. Doing this is
safe, we'll never build on an invalid block, economically rational while
the inflation subsidy is still high, and helps reduce (although not
eliminate!) the advantage a large miner with high-bandwidth connections
has over those who don't.

Of course, the other option is to build a block extending the one you
don't know about, which is even more rational, but doing poses major
risks to Bitcoin...

This functionality can be implemented later - it's not strictly part of
pooled-solo mode.


# Pool work

So does eliopool already accept arbitrary shares like this and do the
correct accounting already? (IE adjust share amount based on fees?) What
happens when the pool doesn't get the share directly, but does see the
new block?

+ possible protocol extensions


# Miner work

Basically we need code to merge the two block templates together to find
commonality. I guess you probably want to implement this in bfgminer
first, so add the code to libblkmaker first, then maybe python-blkmaker.

We also want an automatic fallback to local solo mining if the pool
can't be contacted.

+ possible protocol extensions


-- 
'peter'[:-1]@petertodd.org
000000000000005576673e616271f762a5d8779d5fe7796c6e43ed43df5aa189
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/ee10beed/attachment.sig>

From luke at dashjr.org  Mon Jun 10 21:23:14 2013
From: luke at dashjr.org (Luke-Jr)
Date: Mon, 10 Jun 2013 21:23:14 +0000
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <20130610210913.GA17242@petertodd.org>
References: <20130527111149.GB8955@tilt> <20130531165758.GA29135@petertodd.org>
	<20130610210913.GA17242@petertodd.org>
Message-ID: <201306102123.15732.luke@dashjr.org>

On Monday, June 10, 2013 9:09:13 PM Peter Todd wrote:
> # Protocol Work

This is basically done.

> Basic idea is the miner makes two connections, their pool, and a local
> bitcoind.
> 
> They always (usually?) work on the subset of transactions common to both
> the pool's getblocktemplate and their local one. When they find a share
> if it doesn't meet difficulty they just hand it to the pool. Currently
> that is done by handing the whole block over, correct? I know the BIP
> says otherwise, but we should optimize this to just hand over tx hashes
> where possible.

The plan was to tell the pool it doesn't need to send transactions at all, and 
only work on the ones from bitcoind. Currently, share submissions are just the 
block header and coinbase transaction; in this case, however, the miner will 
need to send merkle links also, possibly just once via a block proposal in 
advance.

> If the share does meet difficulty, hand it to both the pool and the
> local bitcoind. Should hand it to the pool first though, because the
> pool likely has the fastest block propagation, then hand it to local
> bitcoind. An optimized version may want to have some record of measured
> bandwidth - this applies Bitcoin in general too, although also has other
> issues.

Currently, BFGMiner is doing submission to the pool, waiting for a response, 
then submitting to a local bitcoind. This is because the pool might need to 
receive/record the share before it processes the block on bitcoind, or you 
could lose credit for it. The response from the pool is rather small (a single 
TCP packet), so this shouldn't delay much longer.

> ## Reducing bandwidth
> 
> How about for normal shares we just pass the block header, and have the
> pool randomly pick a subset of transactions to audit? Any fraud cancels
> the users shares. This will work best in conjunction with a UTXO proof
> tree to prove fees, or by just picking whole shares randomly to audit.

Might as well just use higher difficulty shares (each one audited) for the 
same effect. Block proposals allow the miner to tell the pool its transaction 
set once (per txset change) for any number of shares.

IF bandwidth becomes a real problem, I have a draft of a "GBT 2.0" that does 
some more improvement in this area.

> # Pool work
> 
> So does eliopool already accept arbitrary shares like this and do the
> correct accounting already? (IE adjust share amount based on fees?) What
> happens when the pool doesn't get the share directly, but does see the
> new block?
> 
> + possible protocol extensions

I don't follow.

> # Miner work
> 
> Basically we need code to merge the two block templates together to find
> commonality. I guess you probably want to implement this in bfgminer
> first, so add the code to libblkmaker first, then maybe python-blkmaker.

libblkmaker's API was designed for this from the start, so it should be fairly 
easily implemented.

> We also want an automatic fallback to local solo mining if the pool
> can't be contacted.
> 
> + possible protocol extensions

Failover already functions, but probably could use a rewrite...

Luke



From melvincarvalho at gmail.com  Mon Jun 10 21:31:18 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Mon, 10 Jun 2013 23:31:18 +0200
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <20130610210913.GA17242@petertodd.org>
References: <20130527111149.GB8955@tilt> <20130531165445.GA29104@petertodd.org>
	<20130531165758.GA29135@petertodd.org>
	<20130610210913.GA17242@petertodd.org>
Message-ID: <CAKaEYhKDhPmORRgXSYg+4wrCFcCdvmRW9nJcbzWba4NraEqkQA@mail.gmail.com>

On 10 June 2013 23:09, Peter Todd <pete at petertodd.org> wrote:

> So here's the parts that need to be done for step #1:
>
>
> # Protocol Work
>
> Basic idea is the miner makes two connections, their pool, and a local
> bitcoind.
>
> They always (usually?) work on the subset of transactions common to both
> the pool's getblocktemplate and their local one. When they find a share
> if it doesn't meet difficulty they just hand it to the pool. Currently
> that is done by handing the whole block over, correct? I know the BIP
> says otherwise, but we should optimize this to just hand over tx hashes
> where possible.
>
> If the share does meet difficulty, hand it to both the pool and the
> local bitcoind. Should hand it to the pool first though, because the
> pool likely has the fastest block propagation, then hand it to local
> bitcoind. An optimized version may want to have some record of measured
> bandwidth - this applies Bitcoin in general too, although also has other
> issues.
>
>
> ## Reducing bandwidth
>
> How about for normal shares we just pass the block header, and have the
> pool randomly pick a subset of transactions to audit? Any fraud cancels
> the users shares. This will work best in conjunction with a UTXO proof
> tree to prove fees, or by just picking whole shares randomly to audit.
>
> We'll need persistent share storage so if your connection disconnects
> you can provide the pool with the full share later though.
>
> Incedentally, note how the miner can do the reverse: pick random block
> headers and challenge the pool to prove that they correspond to a valid
> block. With some modifications Stratum can support this approach.
>
>
> ## Delibrate orphaning of slow to propagate blocks
>
> Block headers can be flooded-filled much faster than blocks themselves.
> They are also small enough to fit into a UDP packet. Nodes should pass
> headers around separately via UDP, optinally with some tiny number of
> transactions. When we see a valid block header whose contents we do not
> know about a miner should switch to mining empty or near empty blocks in
> solo mode that would orphan the still propagating block. Doing this is
> safe, we'll never build on an invalid block, economically rational while
> the inflation subsidy is still high, and helps reduce (although not
> eliminate!) the advantage a large miner with high-bandwidth connections
> has over those who don't.
>
> Of course, the other option is to build a block extending the one you
> don't know about, which is even more rational, but doing poses major
> risks to Bitcoin...
>
> This functionality can be implemented later - it's not strictly part of
> pooled-solo mode.
>
>
> # Pool work
>
> So does eliopool already accept arbitrary shares like this and do the
> correct accounting already? (IE adjust share amount based on fees?) What
> happens when the pool doesn't get the share directly, but does see the
> new block?
>
> + possible protocol extensions
>
>
> # Miner work
>
> Basically we need code to merge the two block templates together to find
> commonality. I guess you probably want to implement this in bfgminer
> first, so add the code to libblkmaker first, then maybe python-blkmaker.
>
> We also want an automatic fallback to local solo mining if the pool
> can't be contacted.
>
> + possible protocol extensions
>

Sounds very promising.  Suspect it will need a fair amount of testing ...


>
>
> --
> 'peter'[:-1]@petertodd.org
> 000000000000005576673e616271f762a5d8779d5fe7796c6e43ed43df5aa189
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130610/78f5d4ac/attachment.html>

From melvincarvalho at gmail.com  Tue Jun 11 13:11:33 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Tue, 11 Jun 2013 15:11:33 +0200
Subject: [Bitcoin-development] Bitcoin addresses -- opaque or not
Message-ID: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>

There was some confusion on IRC as to whether bitcoin addresses are opaque
or not.

https://en.bitcoin.it/wiki/Address

For the sake of argument let's say that opaque means that you can tell
nothing about the address by examining the characters.

My understanding was that they are NOT opaque, and that if that has
changed, it will invalidate much at least some wiki page, for examples at
least some of the following would now be false:

--------
"A Bitcoin address, or simply address, is an identifier of 27-34
alphanumeric characters" -- FALSE

"with the number 1 or 3" -- FALSE

"you can send bitcoins to a person by sending bitcoins to one of their
addresses" -- FALSE

"Addresses are created simply by generating random numbers and then
performing mathematical operations to derive matching pairs of "public" and
"private" keys" -- FALSE

"The probability that a mistyped address is accepted as being valid is 1 in
232, that is, approximately 1 in 4.29 billion" -- FALSE

"If you would like to validate a Bitcoin address in an application, it is
advisable to use a method from this thread rather than to just check for
string length, allowed characters, or that the address starts with a 1 or
3." -- FALSE

"For most properly-generated Bitcoin addresses, there is at least one
secret number known as a private key" -- FALSE

"They consist of random digits and uppercase and lowercase letters, with
the exception that the uppercase letter "O", uppercase letter "I",
lowercase letter "l", and the number "0" are never used to prevent visual
ambiguity" -- FALSE

"Some Bitcoin addresses can be shorter than 34 characters (as few as 27)"
-- FALSE

"Several of the characters inside a Bitcoin address are used as a checksum
so that typographical errors can be automatically found and rejected" --
FALSE

"The checksum also allows Bitcoin software to confirm that a 33-character
(or shorter) address is in fact valid and isn't simply an address with a
missing character" -- FALSE
--------

I also here that there is a LIKELY change from the base58 encoding ... when
was this established?

There's either been some bit changes to the fundamentals of bitcoin here or
there's been some misunderstandings.  It would be good to clear things up
as to what exactly an address is now beleived to be, and reflect that in
the wiki.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130611/8d2e4750/attachment.html>

From laanwj at gmail.com  Tue Jun 11 13:44:39 2013
From: laanwj at gmail.com (Wladimir)
Date: Tue, 11 Jun 2013 15:44:39 +0200
Subject: [Bitcoin-development] Bitcoin addresses -- opaque or not
In-Reply-To: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
References: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
Message-ID: <CA+s+GJAsmH_LVqV5qs5fPX8NSGyJtzOs6kyC7M27e8JdCLooEg@mail.gmail.com>

On Tue, Jun 11, 2013 at 3:11 PM, Melvin Carvalho
<melvincarvalho at gmail.com>wrote:

> There was some confusion on IRC as to whether bitcoin addresses are opaque
> or not.
>
> https://en.bitcoin.it/wiki/Address
>
> For the sake of argument let's say that opaque means that you can tell
> nothing about the address by examining the characters.
>
> My understanding was that they are NOT opaque, and that if that has
> changed, it will invalidate much at least some wiki page, for examples at
> least some of the following would now be false:
>

How do you define opaque? As far as humans are concerned the addresses are
opaque. They don't tell anything about your country or location, your bank,
your name, they don't even form some kind of hierarchy.

>From the viewpoint of the code you could argue they have a meaning "address
type + hashed public key, base58 encoded" thus are not fully opaque. But
it's a long shot, as a hashed value is still very opaque.


> I also here that there is a LIKELY change from the base58 encoding ...
> when was this established?
>

No, there have been no changes to base58. The encoding is still exactly the
same as when Satoshi coined it. Can you show an example of what you mean?

Wladimir
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130611/a763d832/attachment.html>

From pieter.wuille at gmail.com  Tue Jun 11 14:12:52 2013
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 11 Jun 2013 16:12:52 +0200
Subject: [Bitcoin-development] Bitcoin addresses -- opaque or not
In-Reply-To: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
References: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
Message-ID: <CAPg+sBgpFx5vOWWL9izdC1UMvRCV19Lmerm0bw2xwSzf01DW2g@mail.gmail.com>

On Tue, Jun 11, 2013 at 3:11 PM, Melvin Carvalho
<melvincarvalho at gmail.com> wrote:
> There was some confusion on IRC as to whether bitcoin addresses are opaque
> or not.
>
> https://en.bitcoin.it/wiki/Address
>
> For the sake of argument let's say that opaque means that you can tell
> nothing about the address by examining the characters.
>
> My understanding was that they are NOT opaque, and that if that has changed,
> it will invalidate much at least some wiki page, for examples at least some
> of the following would now be false:

I'm afraid this is the result of a misunderstanding.

Yesterday on IRC you were asking why the URI specification doesn't
include the semantics and encoding of addresses. Some people,
including me, argued that addresses should be considered opaque. That
doesn't mean they don't have well-specified definition, only that for
the purposes of URI parsing and handling, code shouldn't know or care
what they represent or how they are formatted. Addresses are specified
in one place, and the URI format simply passes addresses through.

The reason for keeping them independent is that the address format
could change (say, a new type is added, like P2SH (BIP13) before), and
there is no reason why this should break or even concern URI handling
code. Clearly, anything that actually interprets addresses in order to
construct transactions will need changing. It's just two separate
concerns, and they should be dealt with separately.

-- 
Pieter



From luke at dashjr.org  Tue Jun 11 15:29:11 2013
From: luke at dashjr.org (Luke-Jr)
Date: Tue, 11 Jun 2013 15:29:11 +0000
Subject: [Bitcoin-development] Bitcoin addresses -- opaque or not
In-Reply-To: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
References: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
Message-ID: <201306111529.13657.luke@dashjr.org>

On Tuesday, June 11, 2013 1:11:33 PM Melvin Carvalho wrote:
> For the sake of argument let's say that opaque means that you can tell
> nothing about the address by examining the characters.

This is true or false based on CONTEXT.

Obviously, an implementation of transaction handling (eg, wallets) needs to be 
able to translate addresses to and from what they represent.

On the other hand, things like URI handlers do not (and should not) try to 
interpret the address as anything other than an arbitrary word (\w+).

> My understanding was that they are NOT opaque, and that if that has
> changed, it will invalidate much at least some wiki page, for examples at
> least some of the following would now be false:

The wiki goes into much detail on how addresses work, which is not the concern 
of most software in the Bitcoin ecosystem, but may be of interest to humans 
and developers working on the one component that operates the "black box" that 
addresses are.

> --------
> <snip>
> --------

These aren't FALSE, they are "true at the moment, but subject to revision by 
newer standards".

> I also here that there is a LIKELY change from the base58 encoding ... when
> was this established?

I stated (on IRC) that it was likely Bitcoin would change from the base58 
encoding for addresses ... at some unspecified time in the future, to some 
unspecified new encoding that addressed known limitations of base58. What 
those changes will be, or when, are not all established at this time. The only 
currently-planned change to addresses (very loosely defined) is inclusion of 
the Payment Protocol URIs. But the point is that software developers shouldn't 
assume that addresses will remain base58 forever.

Luke



From melvincarvalho at gmail.com  Wed Jun 12 17:46:13 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Wed, 12 Jun 2013 19:46:13 +0200
Subject: [Bitcoin-development] Fwd: The "pay it forward approach" to crypto
	currencies
In-Reply-To: <CAKaEYhJf8O+0nTWxO+GaF5JygOr4O6D0rjF68gSkdreNixcSEg@mail.gmail.com>
References: <CAKaEYhJf8O+0nTWxO+GaF5JygOr4O6D0rjF68gSkdreNixcSEg@mail.gmail.com>
Message-ID: <CAKaEYhJqG7m-y3RbidZAxbgjqJw9bg54F-n2XtNh0md2PZV0_A@mail.gmail.com>

FYI: some musings on how crypto currencies might be combined with social
good ...

---------- Forwarded message ----------
From: Melvin Carvalho <melvincarvalho at gmail.com>
Date: 12 June 2013 19:39
Subject: The "pay it forward approach" to crypto currencies
To: building-a-distributed-decentralized-internet at googlegroups.com


Crypto currencies are doing quite well, but they have yet to make a
meaningful impact on any economy, nor have they achieved much in the way of
social good, however there is a tangible excitement about ways that it can
modernize the way we live our lives

We live in a world where 10,000 children under the age of five die every
day, which can be prevented by simple, affordable interventions ... why do
we let this happen?

Turning he question on its head, what interventions do crypto currencies
enable us to perform, that could help solve this problem

Well certainly crypto currencies have opened pandora's box in terms of
technology being able to create money, let it float, and let it appreciate
in value ... something that the alchemists of old (whose number include
Aristotle, Newton and Keynes) would have been proud.  Well done Satoshi,
now what shall we do with this gift?

The optimal principle should be that we beam new money to the people that
need it most, on a relatively uniform basis.  Something of a harder
problem, and one with no perfect solution.  But we could make some
approximations ... perhaps.

**
Suppose you were to credit 10,000 new coins to every person on the planet.
Then let it float on the free market (a la bitcoin).  Initially worth zero,
the coins would potentially rise in value to become a consensus driven
global dividend.  Certainly if it went higher it could do a lot to
alleviate many problems for poorer people.

Unfortunately we dont have a huge database of every person on the planet in
the public domain, so this strategy is problematic.  However we roughly do
have good statistics that most people have a mobile phone, so we could beam
coins to every mobile phone.  (technically you can do this using the tel:
URI scheme such that you get one phone, one share).

Phones are now banks, and also have the ability to send money via SMS.

The problem with this approach is that it favours people with multiple
phones, who are probably correlated to relatively wealthy people.  Not
great, but it's a start.

How about we then do it country by country and beam coins to the poorest
countries, say in proportion to GNP per capita.  Perhaps better.

Again, it's possible to systematically game the system, to an extent.  So
one way to reduce the risk would be to allocate coins on a lottery basis,
where a random number generator selects 'lucky' winners.  The net effect
will be generally positive, while preventing major systemic risk.

Little by little, we can bring people out of poverty using crypto coins and
make a better world.

Now, I know what you're thinking.  Money for nothing, that makes no sense.
Why would these coins ever be worth anything.

There is where the "pay it forward" concept comes in.  All coin recipients
are encouraged to "pay it forward" ... do good for the sake of good, and
allow that karma to flow back to you.  Eventually this can take the form of
rebuying the coins that saved your life when you were young, and enabled
you to become a successful businessman.

As the value, liquidity, trust, and importantly, social good of the system
build.  So it becomes easier for people to maintain societies, for
economies to thrive, and for governments to balance their budgets.

It becomes an ever increasing virtuous circle, that can transform the
planet.

I've left out a few gaps and technical details, but I'm sure it's possible
to join the dots and incrementally move towards an optimal solution.  I
think bitcoin and the internet have paved the way for "pay it forward"
crypto currencies.

And hopefully it can one day become "an idea worth spending".  :)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130612/b5b76c0c/attachment.html>

From adam at cypherspace.org  Thu Jun 13 13:39:32 2013
From: adam at cypherspace.org (Adam Back)
Date: Thu, 13 Jun 2013 15:39:32 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <20130519132359.GA12366@netbook.cypherspace.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
Message-ID: <20130613133932.GA13028@netbook.cypherspace.org>

I had one thought towards this which is a different kind of merged mining.

I think a "fair" merged mining aiming for price parity would be done by the
miner having to choose the altcoin or btc at mine time, and altcoin chain
considering btc mine unspendable and bitcoin considering ac unspendable.

In terms of validation which miners are currently doing to help SVP clients,
it implies verification of both chains.  Or more incrementally each mine
should indicate in its serialization which chain it has validated.  This wa
about a hypothethical pure zerocoin altcoin hence zc/zerocoin:

Maybe we can say that a mergemine does not count as a validation of the
network for the respective network unless there is serialization in the
coinbase indicating that the network is validated.  In that way you could
have zerocoin mined and zerocoin validated, zero mined and bitcoin validated
(strange but possible), zerocoin mined and both zero and bit coin validated,
and also the same for bitcoin mined and zerocoin validated (strange but
possible), bitcoin mined and bitcoin validated (normal bitcoin ignoring
zerocoin) and bitcoin mined and bitcoin and zerocoin validated.  Then the
validation events on zerocoin network might not be as frequent.  Maybe
miners will tend to validate both networks as then they can claim fees on
both networks, even if the protocol prevents direct merged mining on both
networks (one or the other mined, and whatever chains validated as indicated
by coinbase serialization).

(I described it in this thread
https://bitcointalk.org/index.php?topic=175156.msg2420768#msg2420768 which
is mostly about understanding zerocoin, but digressed at that point to a
hypothetical pure zerocoin alt-coin that retains a fair merged mine and
exchangeless tradeability with main bitcoin.)

I think another gap is the exchangeless tradeability.  Apparently the
contract based proposals have race conditions, and ransom issues (refuse to
complete agreed commitment phase without being part-paid again).  I didnt
follow that discussion yet but Greg Maxwell and Sergio Lerner were
discussing and that seemed to be their conclusion, and Sergio's proposed
solution relied on a non-standard and not-fully-worked-through assumption
for the alt-coin (probably non-SPV compatible I think).

ps I thought it was quite interesting that seemingly you could make a pure
zerocoin alt-coin, it turns out you could direct mine them, and do zc-zc
transactions.  

They are fixed denomination however I think you could extend them with
homomorphic amounts.  I noticed Matthew Green mentioned this idea in his
presentation at microsoft research (saw in the video they have put online). 
 From my perspective (he didnt specify how other than as an attribute) its
something like a Brands credential where you can prove in ZK that two
attributes sum to a given value without revealing the attributes at all. 
The missing last part is you have to prove that the attributes are less than
some threshold to avoid people cheating and adding q to their balance. 
(Arithmetic in the exponents is modulo q in the subgroup used in zerocoin). 
There are several approaches to doing this some of them not that cheap (eg
involving k DSA-like signatures to prove vale v < 2^k).  The idea of proving
it is less than k where k is say 128 is that then to add q, you have to
spend 2^128 coins which you cant do.  You can either make the values
uncertain by having v eg have 44 bits of useful precision and a few binary
00s and then 80-bits of randomness, or you can use a second never disclosed
random attribute like in a Pederson commitment or Brands credential eg 
c=g^v h^r mod p where r is random and never disclosed, but the user proves
knowledge of discrete log representation of c in terms of powers of g and h.
The downside of k signatures is validation CPU cost, and worse transaction
size.

There are several other approaches which seem to be able to prove v < 2^k
with less than k, eg even 1 DSA-like signature.  I need to gather that info
in one place and write something referencing the literature I found so far. 
A homomorphically verifiable coin balance transfer could be interesting
outside of zerocoin - eg for bitcoin, or an alt-coin.

Adam

On Sun, May 19, 2013 at 03:23:59PM +0200, Adam Back wrote:
>Is there a way to experiment with new features - eg committed coins - that
>doesnt involve an altcoin in the conventional sense, and also doesnt impose
>a big testing burden on bitcoin main which is a security and testing risk?
>
>eg lets say some form of merged mine where an alt-coin lets call it
>bitcoin-staging?  where the coins are the same coins as on bitcoin, the
>mining power goes to bitcoin main, so some aspect of merged mining, but no
>native mining.  and ability to use bitcoins by locking them on bitcoin to
>move them to bitcoin-staging and vice versa (ie exchange them 1:1
>cryptographically, no exchange).
>
>Did anyone figure anything like that out?  Seems vaguely doable and
>maybe productive.  The only people with coins at risk of defects in a new
>feature, or insufficiently well tested novel feature are people with coins
>on bitcoin-staging.
>
>Yes I know about bitcoin-test this is not it.  I mean a real live system,
>with live value, but that is intentionally wanting to avoid forking bitcoins
>parameters, nor value, nor mindshare dillution.  In this way something
>potentially interesting could move forward faster, and be les risky to the
>main bitcoin network.  eg particularly defenses against
>
>It might also be a more real world test test (after bitcoin-test) because
>some parameters are different on test, and some issues may not manifest
>without more real activity.
>
>Then also bitcoin could cherry pick interesting patches and merge them after
>extensive real-world validation with real-money at stake (by early
>adopters).
>
>Adam



From pete at petertodd.org  Fri Jun 14 19:20:58 2013
From: pete at petertodd.org (Peter Todd)
Date: Fri, 14 Jun 2013 15:20:58 -0400
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <20130613133932.GA13028@netbook.cypherspace.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<20130613133932.GA13028@netbook.cypherspace.org>
Message-ID: <20130614192058.GA11509@petertodd.org>

On Thu, Jun 13, 2013 at 03:39:32PM +0200, Adam Back wrote:
> I had one thought towards this which is a different kind of merged mining.
> 
> I think a "fair" merged mining aiming for price parity would be done by the
> miner having to choose the altcoin or btc at mine time, and altcoin chain
> considering btc mine unspendable and bitcoin considering ac unspendable.

One way to look at what you are describing is to say you want to prove
your sacrifice of potential BTC earnings. That goes back to the PoW
hashcash stuff I mentioned earlier, and is accomplished by simply mining
shares with an unspendable coinbase to prove you did work that could
have resulted in Bitcoins, but didn't.

-- 
'peter'[:-1]@petertodd.org
00000000000000b7dc90d34b08218b76687c0cd8a00878fea13d4ce98b0f4df0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130614/e7325843/attachment.sig>

From pete at petertodd.org  Fri Jun 14 20:06:54 2013
From: pete at petertodd.org (Peter Todd)
Date: Fri, 14 Jun 2013 16:06:54 -0400
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <201306102123.15732.luke@dashjr.org>
References: <20130527111149.GB8955@tilt> <20130531165758.GA29135@petertodd.org>
	<20130610210913.GA17242@petertodd.org>
	<201306102123.15732.luke@dashjr.org>
Message-ID: <20130614200654.GB11509@petertodd.org>

On Mon, Jun 10, 2013 at 09:23:14PM +0000, Luke-Jr wrote:
> > They always (usually?) work on the subset of transactions common to both
> > the pool's getblocktemplate and their local one. When they find a share
> > if it doesn't meet difficulty they just hand it to the pool. Currently
> > that is done by handing the whole block over, correct? I know the BIP
> > says otherwise, but we should optimize this to just hand over tx hashes
> > where possible.
> 
> The plan was to tell the pool it doesn't need to send transactions at all, and 
> only work on the ones from bitcoind. Currently, share submissions are just the 
> block header and coinbase transaction; in this case, however, the miner will 
> need to send merkle links also, possibly just once via a block proposal in 
> advance.

It strikes me that this would work best if the pool has a mempool with
child-pays-for-parent support where conflicts *are* allowed.

IE you record whatever transactions you know about, conflicting or not,
calculate which ones gives you the most fees/kb, and then figure out
which set of non-conflicting ones are optimal. Of course, "optimal" is
the knapsack problem...

Now you can easilly tell the miners working on shares for you which tx's
would be optimal if they wish to know, and at the same time whatever
shares they send you are most likely to include transactions in your
mempool inventory, and thus they can send just tx hashes to reduce
bandwidth.


Part of the broader issue that when we send peers INV advertisements we
should be telling them what the fee/kb is so our peers can prioritize
properly. That'd also help for the case where you want to broadcast two
transactions in a row, but the pair is only profitable because the
second is paying the fee for the first.

Speaking of, the way we tell peers about new blocks is really
suboptimal: we tell every peer, in no particular order, about a new
block via a block INV message, and then we give them the new block in
parallel. I was looking through comp-sci papers on optimal
flood-fill/gossip algorithms for random graph networks and it appears
that optimal is to spend all your bandwidth to send the message to your
fastest peer first, followed by your next fastest and so on. This works
best because you get the exponential growth scaling faster by
propagating the message as "deep" as possible in the network, and it
then can flood outwards from there. Just sorting the peer list by
#inv-recevied/time when doing INV pushes and when attending to incoming
messages would probably be a big improvement.

> > If the share does meet difficulty, hand it to both the pool and the
> > local bitcoind. Should hand it to the pool first though, because the
> > pool likely has the fastest block propagation, then hand it to local
> > bitcoind. An optimized version may want to have some record of measured
> > bandwidth - this applies Bitcoin in general too, although also has other
> > issues.
> 
> Currently, BFGMiner is doing submission to the pool, waiting for a response, 
> then submitting to a local bitcoind. This is because the pool might need to 
> receive/record the share before it processes the block on bitcoind, or you 
> could lose credit for it. The response from the pool is rather small (a single 
> TCP packet), so this shouldn't delay much longer.

Right, I guess the pool wants to be sure you were actually the one who
found the share, rather than just someone who was lucky enough to see it
on the network and submitted it as your own.

> > ## Reducing bandwidth
> > 
> > How about for normal shares we just pass the block header, and have the
> > pool randomly pick a subset of transactions to audit? Any fraud cancels
> > the users shares. This will work best in conjunction with a UTXO proof
> > tree to prove fees, or by just picking whole shares randomly to audit.
> 
> Might as well just use higher difficulty shares (each one audited) for the 
> same effect. Block proposals allow the miner to tell the pool its transaction 
> set once (per txset change) for any number of shares.

That's a good point - the current practice most pools seem to follow of
about a share per second seems very excessive to me. On the other hand,
it does have good user optics. The right solution might be something
akin to P2Pool where the UI level is telling the user shares are being
found so it's clear "stuff is happening", but under the hood only a
small subset are ever sent to the pool.

> > # Pool work
> > 
> > So does eliopool already accept arbitrary shares like this and do the
> > correct accounting already? (IE adjust share amount based on fees?) What
> > happens when the pool doesn't get the share directly, but does see the
> > new block?
> > 
> > + possible protocol extensions
> 
> I don't follow.

What part don't you follow?

> > # Miner work
> > 
> > Basically we need code to merge the two block templates together to find
> > commonality. I guess you probably want to implement this in bfgminer
> > first, so add the code to libblkmaker first, then maybe python-blkmaker.
> 
> libblkmaker's API was designed for this from the start, so it should be fairly 
> easily implemented.

Good.

> > We also want an automatic fallback to local solo mining if the pool
> > can't be contacted.
> > 
> > + possible protocol extensions
> 
> Failover already functions, but probably could use a rewrite...

Sounds good.

-- 
'peter'[:-1]@petertodd.org
000000000000006ed83d97e7266a66dcb057cd53750795bd209076fa0a34d4ec
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130614/e8f743c8/attachment.sig>

From adam at cypherspace.org  Fri Jun 14 20:50:31 2013
From: adam at cypherspace.org (Adam Back)
Date: Fri, 14 Jun 2013 22:50:31 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <20130614192058.GA11509@petertodd.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<20130613133932.GA13028@netbook.cypherspace.org>
	<20130614192058.GA11509@petertodd.org>
Message-ID: <20130614205031.GB10215@netbook.cypherspace.org>

Agreed.  What I mean is a coinbase for parity-priced alt-coin would be
intentionally considered (and required by the alt-coin to be considered) an
invalid bitcoin address, and vice versa.  The difference is for this purpose
it is both valid alt-coin coinbase (as well as unspendable bitcoin
coinbase).

Adam

On Fri, Jun 14, 2013 at 03:20:58PM -0400, Peter Todd wrote:
>On Thu, Jun 13, 2013 at 03:39:32PM +0200, Adam Back wrote:
>> I had one thought towards this which is a different kind of merged mining.
>>
>> I think a "fair" merged mining aiming for price parity would be done by the
>> miner having to choose the altcoin or btc at mine time, and altcoin chain
>> considering btc mine unspendable and bitcoin considering ac unspendable.
>
>One way to look at what you are describing is to say you want to prove
>your sacrifice of potential BTC earnings. That goes back to the PoW
>hashcash stuff I mentioned earlier, and is accomplished by simply mining
>shares with an unspendable coinbase to prove you did work that could
>have resulted in Bitcoins, but didn't.



From luke at dashjr.org  Fri Jun 14 21:05:28 2013
From: luke at dashjr.org (Luke-Jr)
Date: Fri, 14 Jun 2013 21:05:28 +0000
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <20130614200654.GB11509@petertodd.org>
References: <20130527111149.GB8955@tilt> <201306102123.15732.luke@dashjr.org>
	<20130614200654.GB11509@petertodd.org>
Message-ID: <201306142105.29597.luke@dashjr.org>

On Friday, June 14, 2013 8:06:54 PM Peter Todd wrote:
> On Mon, Jun 10, 2013 at 09:23:14PM +0000, Luke-Jr wrote:
> > Might as well just use higher difficulty shares (each one audited) for
> > the same effect. Block proposals allow the miner to tell the pool its
> > transaction set once (per txset change) for any number of shares.
> 
> That's a good point - the current practice most pools seem to follow of
> about a share per second seems very excessive to me. On the other hand,
> it does have good user optics. The right solution might be something
> akin to P2Pool where the UI level is telling the user shares are being
> found so it's clear "stuff is happening", but under the hood only a
> small subset are ever sent to the pool.

Share rate is relevant to more than user information - it also affects the 
variance of reward/payout. I disagree with claiming shares are found when 
they're not sent to the pool - this makes auditing and troubleshooting more 
difficult; for example, see the GUIMiner bug where it reports shares despite 
misinterpreting the pool's target and submitting nothing at all (this happens 
when the pool uses pdiff 1).

> > > # Pool work
> > > 
> > > So does eliopool already accept arbitrary shares like this and do the
> > > correct accounting already? (IE adjust share amount based on fees?)
> > > What happens when the pool doesn't get the share directly, but does
> > > see the new block?
> > > 
> > > + possible protocol extensions
> > 
> > I don't follow.
> 
> What part don't you follow?

I don't understand the first two questions here at all.

Luke



From luke at dashjr.org  Fri Jun 14 21:10:08 2013
From: luke at dashjr.org (Luke-Jr)
Date: Fri, 14 Jun 2013 21:10:08 +0000
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <20130614205031.GB10215@netbook.cypherspace.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<20130614192058.GA11509@petertodd.org>
	<20130614205031.GB10215@netbook.cypherspace.org>
Message-ID: <201306142110.09687.luke@dashjr.org>

Note that the "earn a mixture of BTC and TBC, but not both in full volume" 
only works for TBC because the price is by definition fixed with BTC.
I'm not sure how you could implement something like this for an altcoin where 
the price is floating independently of Bitcoin.. that is, how you would know 
the right amount of Bitcoin to require sacrificed.

Luke


On Friday, June 14, 2013 8:50:31 PM Adam Back wrote:
> Agreed.  What I mean is a coinbase for parity-priced alt-coin would be
> intentionally considered (and required by the alt-coin to be considered) an
> invalid bitcoin address, and vice versa.  The difference is for this
> purpose it is both valid alt-coin coinbase (as well as unspendable bitcoin
> coinbase).
> 
> Adam
> 
> On Fri, Jun 14, 2013 at 03:20:58PM -0400, Peter Todd wrote:
> >On Thu, Jun 13, 2013 at 03:39:32PM +0200, Adam Back wrote:
> >> I had one thought towards this which is a different kind of merged
> >> mining.
> >> 
> >> I think a "fair" merged mining aiming for price parity would be done by
> >> the miner having to choose the altcoin or btc at mine time, and altcoin
> >> chain considering btc mine unspendable and bitcoin considering ac
> >> unspendable.
> >
> >One way to look at what you are describing is to say you want to prove
> >your sacrifice of potential BTC earnings. That goes back to the PoW
> >hashcash stuff I mentioned earlier, and is accomplished by simply mining
> >shares with an unspendable coinbase to prove you did work that could
> >have resulted in Bitcoins, but didn't.
> 
> ---------------------------------------------------------------------------
> --- This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From andreas at petersson.at  Fri Jun 14 21:25:44 2013
From: andreas at petersson.at (Andreas Petersson)
Date: Fri, 14 Jun 2013 23:25:44 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <201306142110.09687.luke@dashjr.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<20130614192058.GA11509@petertodd.org>
	<20130614205031.GB10215@netbook.cypherspace.org>
	<201306142110.09687.luke@dashjr.org>
Message-ID: <51BB8A58.7000308@petersson.at>

my initial idea (not sure if it is good) was to have an asymetric market.
lets say you want to create altcoin ALC. ALC are merge-mined with btc,
though without block reward.
to create 1 ALC you have two choices: destroy 1 BTC, or buy 1 ALC for a
floating amount from an exchange.

in my book, this would automatically lead to a slightly lower price for
1 ALC, and an automatic ceiling of 1 BTC, since you could always
sacrifice BTC to gain ALC.
but it would not diverge drastically lower, since apparently somebody
was willing to destroy 1 BTC to create it. maybe it could even trade
slightly higher because traded ALC could be spendable instantly while
sacrificed ALC would need a 120 blocks maturing period.
the "beauty" of that system is also it does not inflate the
cryptocurrency realm.

Andreas

Am 14.06.2013 23:10, schrieb Luke-Jr:
> Note that the "earn a mixture of BTC and TBC, but not both in full volume" 
> only works for TBC because the price is by definition fixed with BTC.
> I'm not sure how you could implement something like this for an altcoin where 
> the price is floating independently of Bitcoin.. that is, how you would know 
> the right amount of Bitcoin to require sacrificed.




From dennison at dennisonbertram.com  Sat Jun 15 00:09:09 2013
From: dennison at dennisonbertram.com (Dennison Bertram)
Date: Sat, 15 Jun 2013 02:09:09 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <51BB8A58.7000308@petersson.at>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<20130614192058.GA11509@petertodd.org>
	<20130614205031.GB10215@netbook.cypherspace.org>
	<201306142110.09687.luke@dashjr.org>
	<51BB8A58.7000308@petersson.at>
Message-ID: <27BA300C-71B8-4AB1-9459-09975ABED8EB@dennisonbertram.com>

It seems so much easier to just allow bitcoin testnet to be used more widely for larger scale bitcoin staging. People can assign value as they wish to testnet bitcoins but at their own risk/peril. This incremental amount of value though would allow for testing of larger ideas, ideas that perhaps might not be appropriate in their nascent stages to apply for bitcoin. 

Have your seen 'proof of existence'? It's basically a bitcoin notary service that proves a document existed before it gets inserted into the blockchain. While a good idea- you could argue that it's blockchain spam as well- especially if one were to adapt it to high volumes in the future for notarizing permanently things like tweets (for example) or combining it with something like colored coins. These are great ideas, but maybe better suited to a proto bitcoin without needing to fashion a brand new coin. 

Sent from my iPhone

On Jun 14, 2013, at 11:25 PM, Andreas Petersson <andreas at petersson.at> wrote:

> my initial idea (not sure if it is good) was to have an asymetric market.
> lets say you want to create altcoin ALC. ALC are merge-mined with btc,
> though without block reward.
> to create 1 ALC you have two choices: destroy 1 BTC, or buy 1 ALC for a
> floating amount from an exchange.
> 
> in my book, this would automatically lead to a slightly lower price for
> 1 ALC, and an automatic ceiling of 1 BTC, since you could always
> sacrifice BTC to gain ALC.
> but it would not diverge drastically lower, since apparently somebody
> was willing to destroy 1 BTC to create it. maybe it could even trade
> slightly higher because traded ALC could be spendable instantly while
> sacrificed ALC would need a 120 blocks maturing period.
> the "beauty" of that system is also it does not inflate the
> cryptocurrency realm.
> 
> Andreas
> 
> Am 14.06.2013 23:10, schrieb Luke-Jr:
>> Note that the "earn a mixture of BTC and TBC, but not both in full volume" 
>> only works for TBC because the price is by definition fixed with BTC.
>> I'm not sure how you could implement something like this for an altcoin where 
>> the price is floating independently of Bitcoin.. that is, how you would know 
>> the right amount of Bitcoin to require sacrificed.
> 
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From luke at dashjr.org  Sat Jun 15 01:57:06 2013
From: luke at dashjr.org (Luke-Jr)
Date: Sat, 15 Jun 2013 01:57:06 +0000
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <27BA300C-71B8-4AB1-9459-09975ABED8EB@dennisonbertram.com>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<51BB8A58.7000308@petersson.at>
	<27BA300C-71B8-4AB1-9459-09975ABED8EB@dennisonbertram.com>
Message-ID: <201306150157.07228.luke@dashjr.org>

Timestamping ("proof of existence") doesn't need a coin at all. Just collect 
all the hashes you need timestamped into a PoE merkle tree and add that to the 
merged mining MT. It's pretty simple and straightforward, just needs someone 
to implement it.

On Saturday, June 15, 2013 12:09:09 AM Dennison Bertram wrote:
> Have your seen 'proof of existence'? It's basically a bitcoin notary
> service that proves a document existed before it gets inserted into the
> blockchain. While a good idea- you could argue that it's blockchain spam
> as well- especially if one were to adapt it to high volumes in the future
> for notarizing permanently things like tweets (for example) or combining
> it with something like colored coins. These are great ideas, but maybe
> better suited to a proto bitcoin without needing to fashion a brand new
> coin.



From dennison at dennisonbertram.com  Sat Jun 15 08:43:48 2013
From: dennison at dennisonbertram.com (Dennison Bertram)
Date: Sat, 15 Jun 2013 10:43:48 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <201306150157.07228.luke@dashjr.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<51BB8A58.7000308@petersson.at>
	<27BA300C-71B8-4AB1-9459-09975ABED8EB@dennisonbertram.com>
	<201306150157.07228.luke@dashjr.org>
Message-ID: <D357C141-129A-4FA3-8054-D16D2D77FD83@dennisonbertram.com>

That is true, but someone is already running it as a service on the blockchain itself. See:

https://www.proofofexistence.com/

You can imagine similar  services cropping up for things like torrents, sending btc tweets, etc. While I am not saying these things are particularly refined ideas in and of themselves, people should have an opportunity to play with them, and better testnet. 

Sent from my iPhone

On Jun 15, 2013, at 3:57 AM, "Luke-Jr" <luke at dashjr.org> wrote:

> Timestamping ("proof of existence") doesn't need a coin at all. Just collect 
> all the hashes you need timestamped into a PoE merkle tree and add that to the 
> merged mining MT. It's pretty simple and straightforward, just needs someone 
> to implement it.
> 
> On Saturday, June 15, 2013 12:09:09 AM Dennison Bertram wrote:
>> Have your seen 'proof of existence'? It's basically a bitcoin notary
>> service that proves a document existed before it gets inserted into the
>> blockchain. While a good idea- you could argue that it's blockchain spam
>> as well- especially if one were to adapt it to high volumes in the future
>> for notarizing permanently things like tweets (for example) or combining
>> it with something like colored coins. These are great ideas, but maybe
>> better suited to a proto bitcoin without needing to fashion a brand new
>> coin.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/0b5c737e/attachment.html>

From melvincarvalho at gmail.com  Sat Jun 15 09:50:30 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Sat, 15 Jun 2013 11:50:30 +0200
Subject: [Bitcoin-development] Bitcoin addresses -- opaque or not
In-Reply-To: <201306111529.13657.luke@dashjr.org>
References: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
	<201306111529.13657.luke@dashjr.org>
Message-ID: <CAKaEYhKjvtPf_Xs=Q8tAJt_7PuxCAnym2-kJadNoSdWCHjXNDA@mail.gmail.com>

On 11 June 2013 17:29, Luke-Jr <luke at dashjr.org> wrote:

> On Tuesday, June 11, 2013 1:11:33 PM Melvin Carvalho wrote:
> > For the sake of argument let's say that opaque means that you can tell
> > nothing about the address by examining the characters.
>
> This is true or false based on CONTEXT.
>
> Obviously, an implementation of transaction handling (eg, wallets) needs
> to be
> able to translate addresses to and from what they represent.
>
> On the other hand, things like URI handlers do not (and should not) try to
> interpret the address as anything other than an arbitrary word (\w+).
>

I think this statement may need to be justified.


>
> > My understanding was that they are NOT opaque, and that if that has
> > changed, it will invalidate much at least some wiki page, for examples at
> > least some of the following would now be false:
>
> The wiki goes into much detail on how addresses work, which is not the
> concern
> of most software in the Bitcoin ecosystem, but may be of interest to humans
> and developers working on the one component that operates the "black box"
> that
> addresses are.
>
> > --------
> > <snip>
> > --------
>
> These aren't FALSE, they are "true at the moment, but subject to revision
> by
> newer standards".
>

Got it.


>
> > I also here that there is a LIKELY change from the base58 encoding ...
> when
> > was this established?
>
> I stated (on IRC) that it was likely Bitcoin would change from the base58
> encoding for addresses ... at some unspecified time in the future, to some
> unspecified new encoding that addressed known limitations of base58. What
> those changes will be, or when, are not all established at this time. The
> only
> currently-planned change to addresses (very loosely defined) is inclusion
> of
> the Payment Protocol URIs. But the point is that software developers
> shouldn't
> assume that addresses will remain base58 forever.
>

Does this mean that people should not be investing in "vanity addresses"?


>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/7197e065/attachment.html>

From melvincarvalho at gmail.com  Sat Jun 15 11:18:43 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Sat, 15 Jun 2013 13:18:43 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <20130519132359.GA12366@netbook.cypherspace.org>
References: <20130519132359.GA12366@netbook.cypherspace.org>
Message-ID: <CAKaEYhJfrszqC=7L9inkSH5+9nzUzRLx6Oq+C6bA+fDXXLfh8Q@mail.gmail.com>

On 19 May 2013 15:23, Adam Back <adam at cypherspace.org> wrote:

> Is there a way to experiment with new features - eg committed coins - that
> doesnt involve an altcoin in the conventional sense, and also doesnt impose
> a big testing burden on bitcoin main which is a security and testing risk?
>
> eg lets say some form of merged mine where an alt-coin lets call it
> bitcoin-staging?  where the coins are the same coins as on bitcoin, the
> mining power goes to bitcoin main, so some aspect of merged mining, but no
> native mining.  and ability to use bitcoins by locking them on bitcoin to
> move them to bitcoin-staging and vice versa (ie exchange them 1:1
> cryptographically, no exchange).
>
> Did anyone figure anything like that out?  Seems vaguely doable and
> maybe productive.  The only people with coins at risk of defects in a new
> feature, or insufficiently well tested novel feature are people with coins
> on bitcoin-staging.
>
> Yes I know about bitcoin-test this is not it.  I mean a real live system,
> with live value, but that is intentionally wanting to avoid forking
> bitcoins
> parameters, nor value, nor mindshare dillution.  In this way something
> potentially interesting could move forward faster, and be les risky to the
> main bitcoin network.  eg particularly defenses against
>
> It might also be a more real world test test (after bitcoin-test) because
> some parameters are different on test, and some issues may not manifest
> without more real activity.
>
> Then also bitcoin could cherry pick interesting patches and merge them
> after
> extensive real-world validation with real-money at stake (by early
> adopters).
>

Interesting idea.  I wonder if ripple could be used to set up a transfer
system between the 'main' and 'staging' systems ...


>
> Adam
>
>
> ------------------------------------------------------------------------------
> AlienVault Unified Security Management (USM) platform delivers complete
> security visibility with the essential security capabilities. Easily and
> efficiently configure, manage, and operate all of your security controls
> from a single console and one unified framework. Download a free trial.
> http://p.sf.net/sfu/alienvault_d2d
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/ded41a25/attachment.html>

From dennison at dennisonbertram.com  Sat Jun 15 13:26:01 2013
From: dennison at dennisonbertram.com (Dennison Bertram)
Date: Sat, 15 Jun 2013 15:26:01 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <CAKaEYhJfrszqC=7L9inkSH5+9nzUzRLx6Oq+C6bA+fDXXLfh8Q@mail.gmail.com>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<CAKaEYhJfrszqC=7L9inkSH5+9nzUzRLx6Oq+C6bA+fDXXLfh8Q@mail.gmail.com>
Message-ID: <B19431AC-47B9-4BB2-9AA0-28C114556A01@dennisonbertram.com>

Why use ripple and not just use the testnet? 

The advantageous of allowing testnet to be used as an alt-coin are That Non standard transactions can be tested in a pseudo live environment where because the coins have some nominal value people are incentivized to try and steal and come up with clever ways of gamin the system. This sort of knowledge would be invaluable if non standard transactions are ever going to become a reality on main net. 

It also allows developers a chance to develop in advance new technologies and services that currently won't run on bitcoin main net but might be enabled in the future at which point they can switch over to main net. Additionally without any development happening with non standard transactions as currently there is no economic incentive , there might be a strong argument to never bother enabling non standard transactions as the risk of doing so might not justify in many people's minds  the benefits as if no one develops anything in advance  most users might not find the theoretical possibilities worth the risk, thus permanently hobbling the full potential of satoshis idea. Rather if testnet were allowed to act as an alt coin something cool might be developed that the main net users might desire enough to overcome the inertia of the status quo. 

Additionally it should be considered that the time in the future when non standard transactions might be enabled  might be so far in the future when bitcoin has hit mass adoption and changing anything might require far more political negotiations between users and devs then currently. Meaning that perhaps much more proof of functionality and value as well as testing might e required. 

Dennison

Sent from my iPhone

On Jun 15, 2013, at 1:18 PM, Melvin Carvalho <melvincarvalho at gmail.com> wrote:

> 
> 
> 
> On 19 May 2013 15:23, Adam Back <adam at cypherspace.org> wrote:
>> Is there a way to experiment with new features - eg committed coins - that
>> doesnt involve an altcoin in the conventional sense, and also doesnt impose
>> a big testing burden on bitcoin main which is a security and testing risk?
>> 
>> eg lets say some form of merged mine where an alt-coin lets call it
>> bitcoin-staging?  where the coins are the same coins as on bitcoin, the
>> mining power goes to bitcoin main, so some aspect of merged mining, but no
>> native mining.  and ability to use bitcoins by locking them on bitcoin to
>> move them to bitcoin-staging and vice versa (ie exchange them 1:1
>> cryptographically, no exchange).
>> 
>> Did anyone figure anything like that out?  Seems vaguely doable and
>> maybe productive.  The only people with coins at risk of defects in a new
>> feature, or insufficiently well tested novel feature are people with coins
>> on bitcoin-staging.
>> 
>> Yes I know about bitcoin-test this is not it.  I mean a real live system,
>> with live value, but that is intentionally wanting to avoid forking bitcoins
>> parameters, nor value, nor mindshare dillution.  In this way something
>> potentially interesting could move forward faster, and be les risky to the
>> main bitcoin network.  eg particularly defenses against
>> 
>> It might also be a more real world test test (after bitcoin-test) because
>> some parameters are different on test, and some issues may not manifest
>> without more real activity.
>> 
>> Then also bitcoin could cherry pick interesting patches and merge them after
>> extensive real-world validation with real-money at stake (by early
>> adopters).
> 
> Interesting idea.  I wonder if ripple could be used to set up a transfer system between the 'main' and 'staging' systems ...
>  
>> 
>> Adam
>> 
>> ------------------------------------------------------------------------------
>> AlienVault Unified Security Management (USM) platform delivers complete
>> security visibility with the essential security capabilities. Easily and
>> efficiently configure, manage, and operate all of your security controls
>> from a single console and one unified framework. Download a free trial.
>> http://p.sf.net/sfu/alienvault_d2d
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130615/2042ba06/attachment.html>

From john.dillon892 at googlemail.com  Sat Jun 15 18:28:23 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Sat, 15 Jun 2013 18:28:23 +0000
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <20130610174306.GA16549@petertodd.org>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<51B602D8.5030706@monetize.io> <51B60BF1.3020701@gmail.com>
	<20130610174306.GA16549@petertodd.org>
Message-ID: <CAPaL=UX1npMenVW64_SqF77JSP6T5doQ_e2hOAnshb4ts_0RxQ@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On Mon, Jun 10, 2013 at 5:43 PM, Peter Todd <pete at petertodd.org> wrote:
> On Mon, Jun 10, 2013 at 01:25:05PM -0400, Alan Reiner wrote:
>> to sign votes.  Not only that, but it would require them to reveal their
>> public key, which while isn't technically so terrible, large amounts of
>> money intended to be kept in storage for 10+ years will prefer to avoid
>> any exposure at all, in the oft-chance that QCs come around a lot
>> earlier than we expected.  Sure, the actual risk should be pretty much
>> non-existent, but some of the most paranoid folks are probably the same
>> ones who have a lot of funds and want 100.00% of the security that is
>> possible.   They will see this as wildly inconvenient.
>
> Solving that problem is pretty easy actually: just add a voting only
> public key to your outputs. Specifically you would have an opcode called
> something like "OP_VOTE" and put a code-path in your script that only
> executes for that specific key.

Rather than "OP_VOTE" all you really need is the "spending tx matches a
template" functionality that has been proposed for many other things.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRvLIoAAoJEEWCsU4mNhiPdtoIAKOeEwtWXw6fNKbSN0miGmcQ
rHxgoEh5EAPsbs0hkCRpsVF7OjvmAftOn0Z0K0X/a4UFVHI64bvvGUg0brmAMnh3
ha4Mu/o7UwxwVJmmd6vpUw4smjbQrKbRzheXXQKUsDG2HOmRzMabFjJG1F20mPdg
RobwYG49fKLcjAfqqTjOwSQE5KBjrugAUo32OUJWHZyNR5E3JYUXRHseHCfQ+1Fd
VOQ8rWA4OaqwiX7PXdrNMWXc7Ab1dK7j9U7n4FgzCGIJjAek2dGbYLdrjftGKI+z
Vje7o/RCJFLkJW5cC/wDoB/58XyJuvsvGOBAjvz01UrengUiapkhLRjKQwbveEo=
=P0Hm
-----END PGP SIGNATURE-----



From dennison at dennisonbertram.com  Sun Jun 16 15:46:41 2013
From: dennison at dennisonbertram.com (Dennison Bertram)
Date: Sun, 16 Jun 2013 17:46:41 +0200
Subject: [Bitcoin-development] is there a way to do bitcoin-staging?
In-Reply-To: <B19431AC-47B9-4BB2-9AA0-28C114556A01@dennisonbertram.com>
References: <20130519132359.GA12366@netbook.cypherspace.org>
	<CAKaEYhJfrszqC=7L9inkSH5+9nzUzRLx6Oq+C6bA+fDXXLfh8Q@mail.gmail.com>
	<B19431AC-47B9-4BB2-9AA0-28C114556A01@dennisonbertram.com>
Message-ID: <CANTZ12OEzOgK2Q7uO4KP94ojChSSpVL_M+p-+gTfqFDoJGjHJQ@mail.gmail.com>

Is there a relatively easy way to switch between Testnet versions in the
client? On the forums I am in discussion with one member who mentioned the
idea of a Main net, a testnet and a "beta-net" where the coins on the
beta-net would be allowed to have value. It seems like simple and logical
way to do this would be something like a "testnet=1, testnetversion=3" in
the bitcoin.conf file. Is this possible?


On Sat, Jun 15, 2013 at 3:26 PM, Dennison Bertram <
dennison at dennisonbertram.com> wrote:

> Why use ripple and not just use the testnet?
>
> The advantageous of allowing testnet to be used as an alt-coin are
> That Non standard transactions can be tested in a pseudo live environment
> where because the coins have some nominal value people are incentivized to
> try and steal and come up with clever ways of gamin the system. This sort
> of knowledge would be invaluable if non standard transactions are ever
> going to become a reality on main net.
>
> It also allows developers a chance to develop in advance new technologies
> and services that currently won't run on bitcoin main net but might be
> enabled in the future at which point they can switch over to main net.
> Additionally without any development happening with non standard
> transactions as currently there is no economic incentive , there might be a
> strong argument to never bother enabling non standard transactions as the
> risk of doing so might not justify in many people's minds  the benefits as
> if no one develops anything in advance  most users might not find the
> theoretical possibilities worth the risk, thus permanently hobbling the
> full potential of satoshis idea. Rather if testnet were allowed to act as
> an alt coin something cool might be developed that the main net users might
> desire enough to overcome the inertia of the status quo.
>
> Additionally it should be considered that the time in the future when non
> standard transactions might be enabled  might be so far in the future when
> bitcoin has hit mass adoption and changing anything might require far more
> political negotiations between users and devs then currently. Meaning that
> perhaps much more proof of functionality and value as well as testing might
> e required.
>
> Dennison
>
> Sent from my iPhone
>
> On Jun 15, 2013, at 1:18 PM, Melvin Carvalho <melvincarvalho at gmail.com>
> wrote:
>
>
>
>
> On 19 May 2013 15:23, Adam Back <adam at cypherspace.org> wrote:
>
>> Is there a way to experiment with new features - eg committed coins - that
>> doesnt involve an altcoin in the conventional sense, and also doesnt
>> impose
>> a big testing burden on bitcoin main which is a security and testing risk?
>>
>> eg lets say some form of merged mine where an alt-coin lets call it
>> bitcoin-staging?  where the coins are the same coins as on bitcoin, the
>> mining power goes to bitcoin main, so some aspect of merged mining, but no
>> native mining.  and ability to use bitcoins by locking them on bitcoin to
>> move them to bitcoin-staging and vice versa (ie exchange them 1:1
>> cryptographically, no exchange).
>>
>> Did anyone figure anything like that out?  Seems vaguely doable and
>> maybe productive.  The only people with coins at risk of defects in a new
>> feature, or insufficiently well tested novel feature are people with coins
>> on bitcoin-staging.
>>
>> Yes I know about bitcoin-test this is not it.  I mean a real live system,
>> with live value, but that is intentionally wanting to avoid forking
>> bitcoins
>> parameters, nor value, nor mindshare dillution.  In this way something
>> potentially interesting could move forward faster, and be les risky to the
>> main bitcoin network.  eg particularly defenses against
>>
>> It might also be a more real world test test (after bitcoin-test) because
>> some parameters are different on test, and some issues may not manifest
>> without more real activity.
>>
>> Then also bitcoin could cherry pick interesting patches and merge them
>> after
>> extensive real-world validation with real-money at stake (by early
>> adopters).
>>
>
> Interesting idea.  I wonder if ripple could be used to set up a transfer
> system between the 'main' and 'staging' systems ...
>
>
>>
>> Adam
>>
>>
>> ------------------------------------------------------------------------------
>> AlienVault Unified Security Management (USM) platform delivers complete
>> security visibility with the essential security capabilities. Easily and
>> efficiently configure, manage, and operate all of your security controls
>> from a single console and one unified framework. Download a free trial.
>> http://p.sf.net/sfu/alienvault_d2d
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
>
> _______________________________________________
>
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>


-- 

Dennison Bertram, photographer and film maker

www.dennisonbertram.com

dennison at dennisonbertram.com

Milan: +39 320 781 0128
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130616/1727472b/attachment.html>

From jgarzik at bitpay.com  Mon Jun 17 15:16:01 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Mon, 17 Jun 2013 11:16:01 -0400
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <20130614200654.GB11509@petertodd.org>
References: <20130527111149.GB8955@tilt> <20130531165758.GA29135@petertodd.org>
	<20130610210913.GA17242@petertodd.org>
	<201306102123.15732.luke@dashjr.org>
	<20130614200654.GB11509@petertodd.org>
Message-ID: <CAJHLa0P7gndRqubREeQqbVNy_nJgyu7CUdgK9no14RCahxx7Cg@mail.gmail.com>

On Fri, Jun 14, 2013 at 4:06 PM, Peter Todd <pete at petertodd.org> wrote:
> It strikes me that this would work best if the pool has a mempool with
> child-pays-for-parent support where conflicts *are* allowed.
>
> IE you record whatever transactions you know about, conflicting or not,
> calculate which ones gives you the most fees/kb, and then figure out
> which set of non-conflicting ones are optimal. Of course, "optimal" is
> the knapsack problem...
>
> Now you can easilly tell the miners working on shares for you which tx's
> would be optimal if they wish to know, and at the same time whatever
> shares they send you are most likely to include transactions in your
> mempool inventory, and thus they can send just tx hashes to reduce
> bandwidth.
>
>
> Part of the broader issue that when we send peers INV advertisements we
> should be telling them what the fee/kb is so our peers can prioritize
> properly. That'd also help for the case where you want to broadcast two
> transactions in a row, but the pair is only profitable because the
> second is paying the fee for the first.

Interesting proposals, particularly this last.  The net result impact
is, however, that which was criticized in at least one forum thread:
replace-with-higher-fee.


> Speaking of, the way we tell peers about new blocks is really
> suboptimal: we tell every peer, in no particular order, about a new
> block via a block INV message, and then we give them the new block in
> parallel. I was looking through comp-sci papers on optimal
> flood-fill/gossip algorithms for random graph networks and it appears
> that optimal is to spend all your bandwidth to send the message to your
> fastest peer first, followed by your next fastest and so on. This works
> best because you get the exponential growth scaling faster by
> propagating the message as "deep" as possible in the network, and it
> then can flood outwards from there. Just sorting the peer list by
> #inv-recevied/time when doing INV pushes and when attending to incoming
> messages would probably be a big improvement.

In terms of packet size, I would like to look into the network-wide
costs of simply broadcasting block header + coinbase TX + TX list.  I
bet miners would love to opt into that.


>> > If the share does meet difficulty, hand it to both the pool and the
>> > local bitcoind. Should hand it to the pool first though, because the
>> > pool likely has the fastest block propagation, then hand it to local
>> > bitcoind. An optimized version may want to have some record of measured
>> > bandwidth - this applies Bitcoin in general too, although also has other
>> > issues.
>>
>> Currently, BFGMiner is doing submission to the pool, waiting for a response,
>> then submitting to a local bitcoind. This is because the pool might need to
>> receive/record the share before it processes the block on bitcoind, or you
>> could lose credit for it. The response from the pool is rather small (a single
>> TCP packet), so this shouldn't delay much longer.
>
> Right, I guess the pool wants to be sure you were actually the one who
> found the share, rather than just someone who was lucky enough to see it
> on the network and submitted it as your own.
>
>> > ## Reducing bandwidth
>> >
>> > How about for normal shares we just pass the block header, and have the
>> > pool randomly pick a subset of transactions to audit? Any fraud cancels
>> > the users shares. This will work best in conjunction with a UTXO proof
>> > tree to prove fees, or by just picking whole shares randomly to audit.
>>
>> Might as well just use higher difficulty shares (each one audited) for the
>> same effect. Block proposals allow the miner to tell the pool its transaction
>> set once (per txset change) for any number of shares.
>
> That's a good point - the current practice most pools seem to follow of
> about a share per second seems very excessive to me. On the other hand,
> it does have good user optics. The right solution might be something
> akin to P2Pool where the UI level is telling the user shares are being
> found so it's clear "stuff is happening", but under the hood only a
> small subset are ever sent to the pool.

With the onslaught of ASIC mining, most big pools are past a share per
second.  Variable difficulty or set-to-higher-difficulty quickly
became the norm, almost out of necessity.

Personally, I think most pools should target at _least_ 5-10 seconds
per share, no matter the strength of the miner.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From pete at petertodd.org  Mon Jun 17 17:39:42 2013
From: pete at petertodd.org (Peter Todd)
Date: Mon, 17 Jun 2013 13:39:42 -0400
Subject: [Bitcoin-development] Decentralizing mining
In-Reply-To: <CAJHLa0P7gndRqubREeQqbVNy_nJgyu7CUdgK9no14RCahxx7Cg@mail.gmail.com>
References: <20130527111149.GB8955@tilt> <20130531165758.GA29135@petertodd.org>
	<20130610210913.GA17242@petertodd.org>
	<201306102123.15732.luke@dashjr.org>
	<20130614200654.GB11509@petertodd.org>
	<CAJHLa0P7gndRqubREeQqbVNy_nJgyu7CUdgK9no14RCahxx7Cg@mail.gmail.com>
Message-ID: <20130617173942.GA26623@petertodd.org>

On Mon, Jun 17, 2013 at 11:16:01AM -0400, Jeff Garzik wrote:
> > Part of the broader issue that when we send peers INV advertisements we
> > should be telling them what the fee/kb is so our peers can prioritize
> > properly. That'd also help for the case where you want to broadcast two
> > transactions in a row, but the pair is only profitable because the
> > second is paying the fee for the first.
> 
> Interesting proposals, particularly this last.  The net result impact
> is, however, that which was criticized in at least one forum thread:
> replace-with-higher-fee.

Actually the two are orthogonal: a low-priority no-fee tx might result
because it was from a customer paying a merchant via the payment
protocol. The merchant can then respend that tx with a fee to cover
both, but with the current mempool arrangement if the no-fee tx load is
high actually getting that first tx to propagate so the second can will
be difficult.

A nice way to do this would be to accept tx's into your mempool
indiscriminately but delay broadcasting INV messages until you find
child tx's that make the low-profit ones worth mining. When you do find
a child with a sufficiently high fee, send an INVGROUP message to notify
your peers of the new opportunity. Different nodes will have different
ideas of what priority TX deserves to be broadcast, but here provided
the group meets the threshold a peer will always find out.

> > Speaking of, the way we tell peers about new blocks is really
> > suboptimal: we tell every peer, in no particular order, about a new
> > block via a block INV message, and then we give them the new block in
> > parallel. I was looking through comp-sci papers on optimal
> > flood-fill/gossip algorithms for random graph networks and it appears
> > that optimal is to spend all your bandwidth to send the message to your
> > fastest peer first, followed by your next fastest and so on. This works
> > best because you get the exponential growth scaling faster by
> > propagating the message as "deep" as possible in the network, and it
> > then can flood outwards from there. Just sorting the peer list by
> > #inv-recevied/time when doing INV pushes and when attending to incoming
> > messages would probably be a big improvement.
> 
> In terms of packet size, I would like to look into the network-wide
> costs of simply broadcasting block header + coinbase TX + TX list.  I
> bet miners would love to opt into that.

Whether or not that is a improvement is a really complex question, even
without taking failure into account. If you agressively prioritize peers
that are the most connected and keep your # of peers reasonably low you
can afford the memory to keep track of what tx's your peers already know
about so to save on round trips for TX hash's they don't have. On the
other hand if you have a large number of peers and can't do that, or
need to cut down on bandwidth used up by the INV floods and have a
probabalistic scheme, you are risking more round-trip latency.

Not to mention the nasty problem of how *relying* on TX hashes to keep
your bandwidth down means that anything disrupting that system suddenly
has a big impact on the network. I don't think we really understand all
the nuances of that - look at how few people realize that you need
multiples of average bandwidth to have sufficient emergency bandwidth
available to catch up in the event of a chain fork.

-- 
'peter'[:-1]@petertodd.org
00000000000000a1c290ce20953d864a4b9c603abc8a9c77a04429c89c5e9fac
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 198 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130617/a764a270/attachment.sig>

From mike at plan99.net  Mon Jun 17 21:19:21 2013
From: mike at plan99.net (Mike Hearn)
Date: Mon, 17 Jun 2013 23:19:21 +0200
Subject: [Bitcoin-development] bitcoinj 0.9
Message-ID: <CANEZrP2fZbj4FeE675btQLJKFVDuXHTUh1vzPwmT++PQ-Ss3sQ@mail.gmail.com>

I'm pleased to announce the release of bitcoinj 0.9, a Java library for
working with the Bitcoin protocol. Both simplified and full verification
are supported. BitcoinJ has been used to create everything from end-user
wallet apps to network crawlers to SatoshiDice.

To get bitcoinj 0.9, check out our source from git and then run *git fetch
--all; git checkout **67b187c4c4c4*. This will place you on the 0.9 branch
in a secure manner. The roots of trust are the announcement sent to
bitcoinj-announce (which is signed by the google.comDKIM key) and the Maven
page of the bitcoinj website. This paragraph is signed with the same key as
the previous releases (16vSNFP5Acsa6RBbjEA7QYCCRDRGXRFH4m). In addition,
the 0.9 release is signed by Andreas Schildbach (GPG key id 0x8B877A60,
accessible via http://bitcoin.org/andreas_schildbach.asc) and can be
verified with *git tag -v 0.9* once you have his key.

Signature for the last paragraph:
 IEVMFkGVfE5Q7mezpNc2srdMXMkE66AEW2g7AtWa2KGa2PcK5ehqGbKPOWaL2oftcN/939VHWViMLnCKGrS3E9g=

We have a new article in the documentation library, Working with
contracts<https://code.google.com/p/bitcoinj/wiki/WorkingWithContracts>.
 It shows how to create and use multi-signature transactions, signed by
different parties, using a simple API.

*New in this release*

   - Thanks to Matt Corallo, we now have a basic *fee solver* that will
   attach the correct (minimum) fee per kilobyte to a created transaction
   using the 0.8.2+ fee rules. Note that there's no attempt to minimize the
   size of a calculated transaction and thus fee, but some other optimisations
   are applied. By default bitcoinj will always attach a fee, to learn how to
   customise this refer to the article *Working with the wallet*.
   - The wallet's re-org handling code was rewritten and simplified.
   - A new class, WalletAppKit, simplifies the process of instantiating all
   the objects and files that are needed to run a basic app that can
   send/receive money.
   - Add optional support for Pieter Wiulle's native secp256k1
   implementation, which is significantly faster than Bouncy Castle.
   - Improvements to coin selection in the wallet.
   - Many new functions and minor API improvements, for instance, it's now
   easier to tell the wallet to allow spending of unconfirmed coins.
   - A new ScriptBuilder class simplifies the process of constructing
   various kinds of scripts.
   - A new block importer tool can parse bitcoind block files and process
   them, which is faster than streaming them over a network connection.
   - Support for the regtest mode added by the C++ side pull req 2632. This
   makes app development and testing easier by eliminating the need to wait
   for a block.
   - Many bug fixes and testing improvements.

*API changes*

   - NetworkParameters has now been refactored into separate classes.
   - Wallet extensions have been tweaked, please refer to the javadocs for
   details.
   - Many other minor additions and changes that are mostly backwards
   compatible.

*Known issues*
*
*
Please see the limitations and missing features
page<https://code.google.com/p/bitcoinj/wiki/Limitations> on
our website.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130617/2a2df5ec/attachment.html>

From etotheipi at gmail.com  Tue Jun 18 03:48:22 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Mon, 17 Jun 2013 23:48:22 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format -
	Payment Protocol
Message-ID: <51BFD886.8000701@gmail.com>

_*Goal*_:  An alternative address format made possible by BIP 32, which
allows one to specify a "Wallet ID" and "One-time payment" code, instead
of the standard one-use Base58-Hash160 addresses.   This allows parties
with a persistent relationship to be able to prove that payment
addresses they provide each other are linked to a particular wallet,
reducing exposure to MitM attacks without the need for SSL or a web of
trust, and without compromising the privacy of either party.    For
instance, this could be used between businesses that frequently do
business, by exchanging and verifying public keys beforehand, or could
be used by an exchange to identify if a customer withdrawal address is
related to their last deposit address, and if not enforce extra
authentication measures.

_*Background*__:_
I haven't been following the payment protocol discussions/development
much, so I apologize if this has already been addressed.   I'm calling
it "wallet-linkable" addresses, which would be an optional second form
for sending someone your address.   With BIP 32, the address is computed
by the payee (the person sending the address to receive money):

   Standard Address ~ Base58(0x00 || hash160(PubKeyParent *
Multiplier[i]) || checksum)

What I'd like to do is have the option, when specifying an address
through the payment protocol, to send *just* the {PublicKeyParent,
Multiplier[i]} and let the receiver of that address compute the address
on their own.  This is no significant burden on the receiver, but it
does provide the useful property that they can recognize when addresses
specified in this way come from the same wallet -- because the
PubKeyParent will be the same.  Remember, this is _optional_ for the
person providing the address.

One nice, accidental feature of BIP 32 is that the Multiplier[i] used
above does not actually reveal the "chaincode" (I think Pieter started
calling it the "tweak").   It is derived from the chaincode but doesn't
reveal it.  Therefore, the payer sees the parent public key, but that's
not useful to derive any of the other addresses unless they also have
the chaincode.  But they can verify that the PublicKeyParent is
identical between transactions, and thus is accessible only to that
wallet.  It allows them validate a specific address provided by the
payee, but not generate or identify any other addresses.

*_Use Cases:_*
(1)  So, just like with PGP/GPG, when two parties decide they will start
a relationship, they can start by exchanging the public keys of their
wallet and verify them in a reliable manner.  After that, when one party
requests a payment address from the other, they can optionally send
{PubKey, Multiplier}, and the payer's software will identify the owner
of that address, or let you select who you think the address belongs to
and it will verify it.  If the payee's system is compromised and address
is replaced, the address received by the payer won't validate.  This
doesn't help if the side sending the money is compromised.

(2)  When a customer first provides a deposit to an exchange, it will
send money from an address in their wallet and the software will provide
the exchange the {PubKey,Mult}.  When the customer later provides a
withdrawal address, the site can automatically trust the address as long
it is provided in the alternate form and the public keys match.  If they
don't, it might be the same customer just requesting a withdrawal to a
different wallet, which is fine, but they'll have to go through an extra
verification step to do so. 


_*Downsides:*_ 
Multi-sig/P2SH  - The only way this works with P2SH, violates one of the
goals of P2SH slightly, but may not matter much if it's all done under
the hood by the software.  Instead of providing a 20-byte hash of a
script, you provide all the public keys and multipliers for the
individual addresses.  The payer's software automatically verifies all
addresses and creates the P2SH script itself (after a divine decree that
public keys will always be sorted lexicographically in the multi-sig
script).  The blockchain still benefits from the "compression" of moving
the bulky scripts to the TxIn, but it does require revealing more
information than is necessary for the payer to pay the payee.  But it
may not /really/ be a problem, given the benefits.  It might just be
slightly longer strings to exchange during initialization and for each
transaction.

I have various reasons I'd like to use this, and it'd be nice to have
some community backing, so I don't have to twist anyone's arm to trust
me that it's legit.

-Alan




-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130617/d52177a4/attachment.html>

From turkeybreast at yahoo.com  Tue Jun 18 17:45:55 2013
From: turkeybreast at yahoo.com (Turkey Breast)
Date: Tue, 18 Jun 2013 10:45:55 -0700 (PDT)
Subject: [Bitcoin-development] Missing fRelayTxes in version message
Message-ID: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>

See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.

https://en.bitcoin.it/wiki/BIP_0060#Code_Updates

This BIP details everything that needs to be done and proposes a protocol upgrade.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130618/4bb74b27/attachment.html>

From mike at plan99.net  Tue Jun 18 19:48:38 2013
From: mike at plan99.net (Mike Hearn)
Date: Tue, 18 Jun 2013 21:48:38 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>
References: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>
Message-ID: <CANEZrP0ViJSQr_UUxLqM-eFTir=-FGwZ2cSxuPgaVi=KiM8gsA@mail.gmail.com>

It's not a bug (although there was recently a change to make bitcoind/qt
always send this field anyway).

I don't know where Amir is going with BIP 60. Version messages have always
been variable length. There's nothing inherent in the Bitcoin protocol that
says all messages are fixed length, indeed, tx messages are allowed to have
arbitrary data appended after them that gets relayed.


On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:

> See this BIP. I'm not sure if this is a bug or what, but it would be good
> if messages always had a fixed number of fields per protocol version.
>
> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>
> This BIP details everything that needs to be done and proposes a protocol
> upgrade.
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130618/b5a7149b/attachment.html>

From turkeybreast at yahoo.com  Tue Jun 18 22:30:30 2013
From: turkeybreast at yahoo.com (Turkey Breast)
Date: Tue, 18 Jun 2013 15:30:30 -0700 (PDT)
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <CANEZrP0ViJSQr_UUxLqM-eFTir=-FGwZ2cSxuPgaVi=KiM8gsA@mail.gmail.com>
References: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>
	<CANEZrP0ViJSQr_UUxLqM-eFTir=-FGwZ2cSxuPgaVi=KiM8gsA@mail.gmail.com>
Message-ID: <1371594630.18036.YahooMailNeo@web162703.mail.bf1.yahoo.com>

That's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.



________________________________
 From: Mike Hearn <mike at plan99.net>
To: Turkey Breast <turkeybreast at yahoo.com> 
Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> 
Sent: Tuesday, June 18, 2013 9:48 PM
Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
 


It's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway).?

I don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.



On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:

See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.
>
>
>https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>
>
>This BIP details everything that needs to be done and proposes a protocol upgrade.
>
>------------------------------------------------------------------------------
>This SF.net email is sponsored by Windows:
>
>Build for Windows Store.
>
>http://p.sf.net/sfu/windows-dev2dev
>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130618/55556c86/attachment.html>

From mike at plan99.net  Wed Jun 19 09:39:34 2013
From: mike at plan99.net (Mike Hearn)
Date: Wed, 19 Jun 2013 11:39:34 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <1371594630.18036.YahooMailNeo@web162703.mail.bf1.yahoo.com>
References: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>
	<CANEZrP0ViJSQr_UUxLqM-eFTir=-FGwZ2cSxuPgaVi=KiM8gsA@mail.gmail.com>
	<1371594630.18036.YahooMailNeo@web162703.mail.bf1.yahoo.com>
Message-ID: <CANEZrP3D6TRzzJOZ-mW67nJk_hqApt9quCYyoM8oF=ugDW_F6g@mail.gmail.com>

It has to be optional because old clients don't send it, obviously.

Why is this even an issue? There's no problem with variable length messages
in any codebase that I'm aware of. Is this solving some actual problem?


On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:

> That's me. I never said to make all messages fixed length. I said to make
> a fixed number of fields per protocol. So given a protocol version number,
> you know the number of fields in a message. This is not only easier for
> parsing messages, but just good practice. I don't see why a 1 byte flag
> needs to be optional anyway.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>
> *Sent:* Tuesday, June 18, 2013 9:48 PM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It's not a bug (although there was recently a change to make bitcoind/qt
> always send this field anyway).
>
> I don't know where Amir is going with BIP 60. Version messages have always
> been variable length. There's nothing inherent in the Bitcoin protocol that
> says all messages are fixed length, indeed, tx messages are allowed to have
> arbitrary data appended after them that gets relayed.
>
>
> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> See this BIP. I'm not sure if this is a bug or what, but it would be good
> if messages always had a fixed number of fields per protocol version.
>
> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>
> This BIP details everything that needs to be done and proposes a protocol
> upgrade.
>
>
> ------------------------------------------------------------------------------
> This SF.net <http://sf.net/> email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/24060aea/attachment.html>

From turkeybreast at yahoo.com  Wed Jun 19 10:33:13 2013
From: turkeybreast at yahoo.com (Turkey Breast)
Date: Wed, 19 Jun 2013 03:33:13 -0700 (PDT)
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <CANEZrP3D6TRzzJOZ-mW67nJk_hqApt9quCYyoM8oF=ugDW_F6g@mail.gmail.com>
References: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>
	<CANEZrP0ViJSQr_UUxLqM-eFTir=-FGwZ2cSxuPgaVi=KiM8gsA@mail.gmail.com>
	<1371594630.18036.YahooMailNeo@web162703.mail.bf1.yahoo.com>
	<CANEZrP3D6TRzzJOZ-mW67nJk_hqApt9quCYyoM8oF=ugDW_F6g@mail.gmail.com>
Message-ID: <1371637993.17115.YahooMailNeo@web162701.mail.bf1.yahoo.com>

It's a problem if you work with iterators to deserialize the byte stream. Even failing that, it's just sloppy programming. What happens in the future when new fields are added to the version message? It's not a big deal to say that this protocol version has X number of fields, that (higher) protocol version message has X + N number of fields. Deterministic number of fields per protocol version is sensical and how Bitcoin has been for a long time.

And yes, it was a problem for me that caused a lot of confusion why this byte didn't exist in many version messages despite the standard saying it should and the code in bitcoind indicating it should. Nowhere was this written. It doesn't help other implementations to have an unclear behaviour that depends on some magic from one implementation.



________________________________
 From: Mike Hearn <mike at plan99.net>
To: Turkey Breast <turkeybreast at yahoo.com> 
Cc: "bitcoin-development at lists.sourceforge.net" <bitcoin-development at lists.sourceforge.net> 
Sent: Wednesday, June 19, 2013 11:39 AM
Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
 


It has to be optional because old clients don't send it, obviously.

Why is this even an issue? There's no problem with variable length messages in any codebase that I'm aware of. Is this solving some actual problem?



On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com> wrote:

That's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.
>
>
>
>
>________________________________
> From: Mike Hearn <mike at plan99.net>
>To: Turkey Breast <turkeybreast at yahoo.com> 
>Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> 
>Sent: Tuesday, June 18, 2013 9:48 PM
>Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
> 
>
>
>It's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway).?
>
>
>I don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.
>
>
>
>On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:
>
>See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.
>>
>>
>>https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>>
>>
>>This BIP details everything that needs to be done and proposes a protocol upgrade.
>>
>>------------------------------------------------------------------------------
>>This SF.net email is sponsored by Windows:
>>
>>Build for Windows Store.
>>
>>http://p.sf.net/sfu/windows-dev2dev
>>_______________________________________________
>>Bitcoin-development mailing list
>>Bitcoin-development at lists.sourceforge.net
>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
>
>
>------------------------------------------------------------------------------
>This SF.net email is sponsored by Windows:
>
>Build for Windows Store.
>
>http://p.sf.net/sfu/windows-dev2dev
>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/1a0bb11c/attachment.html>

From mike at plan99.net  Wed Jun 19 10:43:29 2013
From: mike at plan99.net (Mike Hearn)
Date: Wed, 19 Jun 2013 12:43:29 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <1371637993.17115.YahooMailNeo@web162701.mail.bf1.yahoo.com>
References: <1371577555.61696.YahooMailNeo@web162703.mail.bf1.yahoo.com>
	<CANEZrP0ViJSQr_UUxLqM-eFTir=-FGwZ2cSxuPgaVi=KiM8gsA@mail.gmail.com>
	<1371594630.18036.YahooMailNeo@web162703.mail.bf1.yahoo.com>
	<CANEZrP3D6TRzzJOZ-mW67nJk_hqApt9quCYyoM8oF=ugDW_F6g@mail.gmail.com>
	<1371637993.17115.YahooMailNeo@web162701.mail.bf1.yahoo.com>
Message-ID: <CANEZrP05z2gs7e=oVZOMpVxUbQRzWF1aBKTc5TLvgWSN+NY-sw@mail.gmail.com>

Bitcoin-Qt on master does send it now although it doesn't affect anything,
but as old pre-filtering versions will continue to exist, you'll always
have to be able to deserialize version messages without it.

Bitcoin version messages have always had variable length, look at how the
code is written in main.cpp. If you didn't experience issues until now all
it means is that no sufficiently old nodes were talking to yours.

The standard does not say it should appear. Read it again - BIP 37 says
about the new version message field:
If false then broadcast transactions will not be announced until a
filter{load,add,clear} command is received. *If missing or true*, no change
in protocol behaviour occurs.


On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:

> It's a problem if you work with iterators to deserialize the byte stream.
> Even failing that, it's just sloppy programming. What happens in the future
> when new fields are added to the version message? It's not a big deal to
> say that this protocol version has X number of fields, that (higher)
> protocol version message has X + N number of fields. Deterministic number
> of fields per protocol version is sensical and how Bitcoin has been for a
> long time.
>
> And yes, it was a problem for me that caused a lot of confusion why this
> byte didn't exist in many version messages despite the standard saying it
> should and the code in bitcoind indicating it should. Nowhere was this
> written. It doesn't help other implementations to have an unclear behaviour
> that depends on some magic from one implementation.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* "bitcoin-development at lists.sourceforge.net" <
> bitcoin-development at lists.sourceforge.net>
> *Sent:* Wednesday, June 19, 2013 11:39 AM
>
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It has to be optional because old clients don't send it, obviously.
>
> Why is this even an issue? There's no problem with variable length
> messages in any codebase that I'm aware of. Is this solving some actual
> problem?
>
>
> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> That's me. I never said to make all messages fixed length. I said to make
> a fixed number of fields per protocol. So given a protocol version number,
> you know the number of fields in a message. This is not only easier for
> parsing messages, but just good practice. I don't see why a 1 byte flag
> needs to be optional anyway.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>
> *Sent:* Tuesday, June 18, 2013 9:48 PM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It's not a bug (although there was recently a change to make bitcoind/qt
> always send this field anyway).
>
> I don't know where Amir is going with BIP 60. Version messages have always
> been variable length. There's nothing inherent in the Bitcoin protocol that
> says all messages are fixed length, indeed, tx messages are allowed to have
> arbitrary data appended after them that gets relayed.
>
>
> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> See this BIP. I'm not sure if this is a bug or what, but it would be good
> if messages always had a fixed number of fields per protocol version.
>
> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>
> This BIP details everything that needs to be done and proposes a protocol
> upgrade.
>
>
> ------------------------------------------------------------------------------
> This SF.net <http://sf.net/> email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/11b9537c/attachment.html>

From melvincarvalho at gmail.com  Wed Jun 19 12:19:40 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Wed, 19 Jun 2013 14:19:40 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51BFD886.8000701@gmail.com>
References: <51BFD886.8000701@gmail.com>
Message-ID: <CAKaEYhJh4ArCqxf+wFobNzMbyd8TDPWEDw_n7_mm78d_41oFbA@mail.gmail.com>

On 18 June 2013 05:48, Alan Reiner <etotheipi at gmail.com> wrote:

>  *Goal*:  An alternative address format made possible by BIP 32, which
> allows one to specify a "Wallet ID" and "One-time payment" code, instead of
> the standard one-use Base58-Hash160 addresses.   This allows parties with a
> persistent relationship to be able to prove that payment addresses they
> provide each other are linked to a particular wallet, reducing exposure to
> MitM attacks without the need for SSL or a web of trust, and without
> compromising the privacy of either party.    For instance, this could be
> used between businesses that frequently do business, by exchanging and
> verifying public keys beforehand, or could be used by an exchange to
> identify if a customer withdrawal address is related to their last deposit
> address, and if not enforce extra authentication measures.
>
> *Background**:*
> I haven't been following the payment protocol discussions/development
> much, so I apologize if this has already been addressed.   I'm calling it
> "wallet-linkable" addresses, which would be an optional second form for
> sending someone your address.   With BIP 32, the address is computed by the
> payee (the person sending the address to receive money):
>
>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i])
> || checksum)
>
> What I'd like to do is have the option, when specifying an address through
> the payment protocol, to send *just* the {PublicKeyParent, Multiplier[i]}
> and let the receiver of that address compute the address on their own.
> This is no significant burden on the receiver, but it does provide the
> useful property that they can recognize when addresses specified in this
> way come from the same wallet -- because the PubKeyParent will be the
> same.  Remember, this is *optional* for the person providing the address.
>
> One nice, accidental feature of BIP 32 is that the Multiplier[i] used
> above does not actually reveal the "chaincode" (I think Pieter started
> calling it the "tweak").   It is derived from the chaincode but doesn't
> reveal it.  Therefore, the payer sees the parent public key, but that's not
> useful to derive any of the other addresses unless they also have the
> chaincode.  But they can verify that the PublicKeyParent is identical
> between transactions, and thus is accessible only to that wallet.  It
> allows them validate a specific address provided by the payee, but not
> generate or identify any other addresses.
>
> *Use Cases:*
> (1)  So, just like with PGP/GPG, when two parties decide they will start a
> relationship, they can start by exchanging the public keys of their wallet
> and verify them in a reliable manner.  After that, when one party requests
> a payment address from the other, they can optionally send {PubKey,
> Multiplier}, and the payer's software will identify the owner of that
> address, or let you select who you think the address belongs to and it will
> verify it.  If the payee's system is compromised and address is replaced,
> the address received by the payer won't validate.  This doesn't help if the
> side sending the money is compromised.
>
> (2)  When a customer first provides a deposit to an exchange, it will send
> money from an address in their wallet and the software will provide the
> exchange the {PubKey,Mult}.  When the customer later provides a withdrawal
> address, the site can automatically trust the address as long it is
> provided in the alternate form and the public keys match.  If they don't,
> it might be the same customer just requesting a withdrawal to a different
> wallet, which is fine, but they'll have to go through an extra verification
> step to do so.
>
>
> *Downsides:*
> Multi-sig/P2SH  - The only way this works with P2SH, violates one of the
> goals of P2SH slightly, but may not matter much if it's all done under the
> hood by the software.  Instead of providing a 20-byte hash of a script, you
> provide all the public keys and multipliers for the individual addresses.
> The payer's software automatically verifies all addresses and creates the
> P2SH script itself (after a divine decree that public keys will always be
> sorted lexicographically in the multi-sig script).  The blockchain still
> benefits from the "compression" of moving the bulky scripts to the TxIn,
> but it does require revealing more information than is necessary for the
> payer to pay the payee.  But it may not *really* be a problem, given the
> benefits.  It might just be slightly longer strings to exchange during
> initialization and for each transaction.
>
> I have various reasons I'd like to use this, and it'd be nice to have some
> community backing, so I don't have to twist anyone's arm to trust me that
> it's legit.
>

Generally in favour of hierarchical deterministic wallets.

Will this new style of address make it into the block chain?  I'd be less
keen on that.

I'm finding BIP0032 quite hard to read right now, but perhaps that's
because I'm less familiar with the material than some.  However, there's
little things like it never actually defines a deterministic wallet in the
Abstract.  But, I'll keep trying to understand and see if I can use the
test vectors.


>
> -Alan
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/c32fc5bc/attachment.html>

From mike at plan99.net  Wed Jun 19 13:20:10 2013
From: mike at plan99.net (Mike Hearn)
Date: Wed, 19 Jun 2013 15:20:10 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>
References: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>
Message-ID: <CANEZrP0Pr=_L7CA4hdt9esVCHqf-EOjfDjnVrw8rFxL1OtUw7A@mail.gmail.com>

If you want to criticise the Bitcoin protocol for sloppyness, the variable
length of some messages isn't where I'd start.

Note that ping has the same issue, its length has changed over time to
include the nonce.

If your parser can't handle that kind of thing, you need to fix it. The
protocol has always worked that way.



On Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:

> I?m also running into this exact same issue with my parser, now I
> understand why the relay field behavior I was seeing doesn?t match the wiki.
>
> So to parse a version message, you can?t rely on the protocol version? You
> have to know how long the payload is, and then parse the message
> accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.
>
> Paul
>
> P.S. I?ve never used a dev mailing list before and I want to get involved
> with the Bitcoin dev community, so let me know if I?m horribly violating
> any mailing list etiquette. ?
>
> *From:* Mike Hearn
> *Sent:* ?Wednesday?, ?June? ?19?, ?2013 ?7?:?43? ?AM
> *To:* Turkey Breast
> *Cc:* bitcoin-development at lists.sourceforge.net
>
> Bitcoin-Qt on master does send it now although it doesn't affect anything,
> but as old pre-filtering versions will continue to exist, you'll always
> have to be able to deserialize version messages without it.
>
> Bitcoin version messages have always had variable length, look at how the
> code is written in main.cpp. If you didn't experience issues until now all
> it means is that no sufficiently old nodes were talking to yours.
>
> The standard does not say it should appear. Read it again - BIP 37 says
> about the new version message field:
> If false then broadcast transactions will not be announced until a
> filter{load,add,clear} command is received. *If missing or true*, no
> change in protocol behaviour occurs.
>
>
> On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
>> It's a problem if you work with iterators to deserialize the byte stream.
>> Even failing that, it's just sloppy programming. What happens in the future
>> when new fields are added to the version message? It's not a big deal to
>> say that this protocol version has X number of fields, that (higher)
>> protocol version message has X + N number of fields. Deterministic number
>> of fields per protocol version is sensical and how Bitcoin has been for a
>> long time.
>>
>> And yes, it was a problem for me that caused a lot of confusion why this
>> byte didn't exist in many version messages despite the standard saying it
>> should and the code in bitcoind indicating it should. Nowhere was this
>> written. It doesn't help other implementations to have an unclear behaviour
>> that depends on some magic from one implementation.
>>
>>   ------------------------------
>>  *From:* Mike Hearn <mike at plan99.net>
>> *To:* Turkey Breast <turkeybreast at yahoo.com>
>> *Cc:* "bitcoin-development at lists.sourceforge.net" <
>> bitcoin-development at lists.sourceforge.net>
>> *Sent:* Wednesday, June 19, 2013 11:39 AM
>>
>> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version
>> message
>>
>> It has to be optional because old clients don't send it, obviously.
>>
>> Why is this even an issue? There's no problem with variable length
>> messages in any codebase that I'm aware of. Is this solving some actual
>> problem?
>>
>>
>> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>>
>> That's me. I never said to make all messages fixed length. I said to make
>> a fixed number of fields per protocol. So given a protocol version number,
>> you know the number of fields in a message. This is not only easier for
>> parsing messages, but just good practice. I don't see why a 1 byte flag
>> needs to be optional anyway.
>>
>>   ------------------------------
>>  *From:* Mike Hearn <mike at plan99.net>
>> *To:* Turkey Breast <turkeybreast at yahoo.com>
>> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>
>> *Sent:* Tuesday, June 18, 2013 9:48 PM
>> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version
>> message
>>
>> It's not a bug (although there was recently a change to make bitcoind/qt
>> always send this field anyway).
>>
>> I don't know where Amir is going with BIP 60. Version messages have
>> always been variable length. There's nothing inherent in the Bitcoin
>> protocol that says all messages are fixed length, indeed, tx messages are
>> allowed to have arbitrary data appended after them that gets relayed.
>>
>>
>> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>>
>> See this BIP. I'm not sure if this is a bug or what, but it would be good
>> if messages always had a fixed number of fields per protocol version.
>>
>> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>>
>> This BIP details everything that needs to be done and proposes a protocol
>> upgrade.
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net <http://sf.net/> email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>>
>>
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>>
>>
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/9e7088a9/attachment.html>

From pmlyon at hotmail.ca  Wed Jun 19 13:03:32 2013
From: pmlyon at hotmail.ca (Paul Lyon)
Date: Wed, 19 Jun 2013 13:03:32 +0000
Subject: [Bitcoin-development]
	=?utf-8?q?Missing_fRelayTxes_in_version_mes?= =?utf-8?q?sage?=
Message-ID: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>

I?m also running into this exact same issue with my parser, now I understand why the relay field behavior I was seeing doesn?tmatch the wiki.


So to parse a version message, you can?t rely on the protocol version? You have to know how long the payload is, and then parse the message accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.


Paul


P.S. I?ve never used a dev mailing list before and I want to get involved with the Bitcoin dev community, so let me know if I?m horribly violating any mailing list etiquette. ?



From: Mike Hearn
Sent: ?Wednesday?, ?June? ?19?, ?2013 ?7?:?43? ?AM
To: Turkey Breast
Cc: bitcoin-development at lists.sourceforge.net


Bitcoin-Qt on master does send it now although it doesn't affect anything, but as old pre-filtering versions will continue to exist, you'll always have to be able to deserialize version messages without it.



Bitcoin version messages have always had variable length, look at how the code is written in main.cpp. If you didn't experience issues until now all it means is that no sufficiently old nodes were talking to yours.




The standard does not say it should appear. Read it again - BIP 37 says about the new version message field:


If false then broadcast transactions will not be announced until a filter{load,add,clear} command is received. If missing or true, no change in protocol behaviour occurs.





On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:




It's a problem if you work with iterators to deserialize the byte stream. Even failing that, it's just sloppy programming. What happens in the future when new fields are added to the version message? It's not a big deal to say that this protocol version has X number of fields, that (higher) protocol version message has X + N number of fields. Deterministic number of fields per protocol version is sensical and how Bitcoin has been for a long time.




And yes, it was a problem for me that caused a lot of confusion why this byte didn't exist in many version messages despite the standard saying it should and the code in bitcoind indicating it should. Nowhere was this written. It doesn't help other implementations to have an unclear behaviour that depends on some magic from one implementation.










From: Mike Hearn <mike at plan99.net>
To: Turkey Breast <turkeybreast at yahoo.com> 

Cc: "bitcoin-development at lists.sourceforge.net" <bitcoin-development at lists.sourceforge.net> 
Sent: Wednesday, June 19, 2013 11:39 AM


Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message

 





It has to be optional because old clients don't send it, obviously.



Why is this even an issue? There's no problem with variable length messages in any codebase that I'm aware of. Is this solving some actual problem?




On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com> wrote:




That's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.













From: Mike Hearn <mike at plan99.net>
To: Turkey Breast <turkeybreast at yahoo.com> 
Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> 
Sent: Tuesday, June 18, 2013 9:48 PM
Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
 






It's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway). 



I don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.




On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:




See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.




https://en.bitcoin.it/wiki/BIP_0060#Code_Updates




This BIP details everything that needs to be done and proposes a protocol upgrade.


------------------------------------------------------------------------------
This SF.net email is sponsored by Windows:

Build for Windows Store.

http://p.sf.net/sfu/windows-dev2dev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development





------------------------------------------------------------------------------
This SF.net email is sponsored by Windows:

Build for Windows Store.

http://p.sf.net/sfu/windows-dev2dev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development





------------------------------------------------------------------------------
This SF.net email is sponsored by Windows:

Build for Windows Store.

http://p.sf.net/sfu/windows-dev2dev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/0831e4ce/attachment.html>
-------------- next part --------------
------------------------------------------------------------------------------
This SF.net email is sponsored by Windows:

Build for Windows Store.

http://p.sf.net/sfu/windows-dev2dev
-------------- next part --------------
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development

From etotheipi at gmail.com  Wed Jun 19 13:37:36 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 19 Jun 2013 09:37:36 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <CAKaEYhJh4ArCqxf+wFobNzMbyd8TDPWEDw_n7_mm78d_41oFbA@mail.gmail.com>
References: <51BFD886.8000701@gmail.com>
	<CAKaEYhJh4ArCqxf+wFobNzMbyd8TDPWEDw_n7_mm78d_41oFbA@mail.gmail.com>
Message-ID: <51C1B420.6010304@gmail.com>

On 06/19/2013 08:19 AM, Melvin Carvalho wrote:
>
> Generally in favour of hierarchical deterministic wallets.
>
> Will this new style of address make it into the block chain?  I'd be
> less keen on that.
>
> I'm finding BIP0032 quite hard to read right now, but perhaps that's
> because I'm less familiar with the material than some.  However,
> there's little things like it never actually defines a deterministic
> wallet in the Abstract.  But, I'll keep trying to understand and see
> if I can use the test vectors.
>  
>
>

This has nothing to do with the blockchain.  This is simply an alternate
way to encode an address, in the event that you want to prove that this
address is linked to another address.  The same thing ends up in the
blockchain, either way.

Either:
(1) I give you a Hash160 address which shows up in the blockchain
or
(2) I give you {PubKey, Mult}, then you compute PubKey*Mult then hash it
to get the same Hash160 I would've given you in (1)

I can always give you version #1, and that's what everyone does right
now.  Version #2 is essentially the same, but used if you want to give
the other party extra information (such as the root public key, so that
the next time you send a version#2 address they can see they are from
the same root public key). 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/1038df24/attachment.html>

From pieter.wuille at gmail.com  Wed Jun 19 13:54:04 2013
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 19 Jun 2013 15:54:04 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51BFD886.8000701@gmail.com>
References: <51BFD886.8000701@gmail.com>
Message-ID: <20130619135403.GA1783@vps7135.xlshosting.net>

On Mon, Jun 17, 2013 at 11:48:22PM -0400, Alan Reiner wrote:
> _*Goal*_:  An alternative address format made possible by BIP 32, which
> allows one to specify a "Wallet ID" and "One-time payment" code, instead
> of the standard one-use Base58-Hash160 addresses.   This allows parties
> with a persistent relationship to be able to prove that payment
> addresses they provide each other are linked to a particular wallet,
> reducing exposure to MitM attacks without the need for SSL or a web of
> trust, and without compromising the privacy of either party.    For
> instance, this could be used between businesses that frequently do
> business, by exchanging and verifying public keys beforehand, or could
> be used by an exchange to identify if a customer withdrawal address is
> related to their last deposit address, and if not enforce extra
> authentication measures.

Have you seen Timo Hanke's pay-to-contract presentation at the San Jose
conference? It seems very related:

  http://www.youtube.com/watch?v=qwyALGlG33Q

-- 
Pieter




From timo.hanke at web.de  Wed Jun 19 14:25:10 2013
From: timo.hanke at web.de (Timo Hanke)
Date: Wed, 19 Jun 2013 16:25:10 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51BFD886.8000701@gmail.com>
References: <51BFD886.8000701@gmail.com>
Message-ID: <20130619142510.GA17239@crunch>

Since you mention to use this in conjunction with the payment protocol,
note the following subtlety. Suppose the payer has to paid this address
called "destination": 
>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||
> checksum)
Also suppose the payee has spent the output, i.e. the pubkey
corresponding to "destination", which is PubKeyParent * Multiplier[i],
is publicly known. Then anybody can (in retrospect) create arbitrary
many pairs {PublicKeyParent, Multiplier} (in particular different
PublicKeyParent) that lead to the same "destination".

Depending on what you have in mind that the transaction should "prove"
regarding its actual receiver or regarding the receiver's PubKeyParent,
this could be an unwanted feature (or it could be just fine). If it is
unwanted then I suggest replacing
PubKeyParent * Multiplier[i] by 
PubKeyParent * HMAC(Multiplier[i],PubKeyParent)
which eliminates from the destination all ambiguity about PubKeyParent.

This modification would not be directly compatible with BIP32 anymore
(unfortunately), but seems to be better suited for use in conjunction
with a payment protocol. 

Timo

On Mon, Jun 17, 2013 at 11:48:22PM -0400, Alan Reiner wrote:
> Goal:  An alternative address format made possible by BIP 32, which allows one
> to specify a "Wallet ID" and "One-time payment" code, instead of the standard
> one-use Base58-Hash160 addresses.   This allows parties with a persistent
> relationship to be able to prove that payment addresses they provide each other
> are linked to a particular wallet, reducing exposure to MitM attacks without
> the need for SSL or a web of trust, and without compromising the privacy of
> either party.    For instance, this could be used between businesses that
> frequently do business, by exchanging and verifying public keys beforehand, or
> could be used by an exchange to identify if a customer withdrawal address is
> related to their last deposit address, and if not enforce extra authentication
> measures.
> 
> Background:
> I haven't been following the payment protocol discussions/development much, so
> I apologize if this has already been addressed.   I'm calling it
> "wallet-linkable" addresses, which would be an optional second form for sending
> someone your address.   With BIP 32, the address is computed by the payee (the
> person sending the address to receive money):
> 
>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||
> checksum)
> 
> What I'd like to do is have the option, when specifying an address through the
> payment protocol, to send *just* the {PublicKeyParent, Multiplier[i]} and let
> the receiver of that address compute the address on their own.  This is no
> significant burden on the receiver, but it does provide the useful property
> that they can recognize when addresses specified in this way come from the same
> wallet -- because the PubKeyParent will be the same.  Remember, this is
> optional for the person providing the address.
> 
> One nice, accidental feature of BIP 32 is that the Multiplier[i] used above
> does not actually reveal the "chaincode" (I think Pieter started calling it the
> "tweak").   It is derived from the chaincode but doesn't reveal it.  Therefore,
> the payer sees the parent public key, but that's not useful to derive any of
> the other addresses unless they also have the chaincode.  But they can verify
> that the PublicKeyParent is identical between transactions, and thus is
> accessible only to that wallet.  It allows them validate a specific address
> provided by the payee, but not generate or identify any other addresses.
> 
> Use Cases:
> (1)  So, just like with PGP/GPG, when two parties decide they will start a
> relationship, they can start by exchanging the public keys of their wallet and
> verify them in a reliable manner.  After that, when one party requests a
> payment address from the other, they can optionally send {PubKey, Multiplier},
> and the payer's software will identify the owner of that address, or let you
> select who you think the address belongs to and it will verify it.  If the
> payee's system is compromised and address is replaced, the address received by
> the payer won't validate.  This doesn't help if the side sending the money is
> compromised.
> 
> (2)  When a customer first provides a deposit to an exchange, it will send
> money from an address in their wallet and the software will provide the
> exchange the {PubKey,Mult}.  When the customer later provides a withdrawal
> address, the site can automatically trust the address as long it is provided in
> the alternate form and the public keys match.  If they don't, it might be the
> same customer just requesting a withdrawal to a different wallet, which is
> fine, but they'll have to go through an extra verification step to do so. 
> 
> 
> Downsides: 
> Multi-sig/P2SH  - The only way this works with P2SH, violates one of the goals
> of P2SH slightly, but may not matter much if it's all done under the hood by
> the software.  Instead of providing a 20-byte hash of a script, you provide all
> the public keys and multipliers for the individual addresses.  The payer's
> software automatically verifies all addresses and creates the P2SH script
> itself (after a divine decree that public keys will always be sorted
> lexicographically in the multi-sig script).  The blockchain still benefits from
> the "compression" of moving the bulky scripts to the TxIn, but it does require
> revealing more information than is necessary for the payer to pay the payee. 
> But it may not really be a problem, given the benefits.  It might just be
> slightly longer strings to exchange during initialization and for each
> transaction.
> 
> I have various reasons I'd like to use this, and it'd be nice to have some
> community backing, so I don't have to twist anyone's arm to trust me that it's
> legit.
> 
> -Alan
> 
> 
> 
> 

-- 
Timo Hanke
PGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8



From etotheipi at gmail.com  Wed Jun 19 14:39:04 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 19 Jun 2013 10:39:04 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <20130619142510.GA17239@crunch>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
Message-ID: <51C1C288.4000305@gmail.com>


On 06/19/2013 10:25 AM, Timo Hanke wrote:
> Since you mention to use this in conjunction with the payment protocol,
> note the following subtlety. Suppose the payer has to paid this address
> called "destination": 
>>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||
>> checksum)
> Also suppose the payee has spent the output, i.e. the pubkey
> corresponding to "destination", which is PubKeyParent * Multiplier[i],
> is publicly known. Then anybody can (in retrospect) create arbitrary
> many pairs {PublicKeyParent, Multiplier} (in particular different
> PublicKeyParent) that lead to the same "destination".
>
> Depending on what you have in mind that the transaction should "prove"
> regarding its actual receiver or regarding the receiver's PubKeyParent,
> this could be an unwanted feature (or it could be just fine). If it is
> unwanted then I suggest replacing
> PubKeyParent * Multiplier[i] by 
> PubKeyParent * HMAC(Multiplier[i],PubKeyParent)
> which eliminates from the destination all ambiguity about PubKeyParent.
>
> This modification would not be directly compatible with BIP32 anymore
> (unfortunately), but seems to be better suited for use in conjunction
> with a payment protocol. 
>
> Timo

It's an interesting observation, but it looks like the most-obvious
attack vector is discrete log problem:  spoofing a relationship between
a target public key and one that you control.   For instance, if you see
{PubA, Mult} produces PubB and you have PubC already in your control
that you want to "prove" [maliciously] is related to PubB, then you have
to find the multiplier, M that solves:  M*PubC = PubB.  That's a
discrete logarithm problem.

I'm not as familiar as you are, with the available operations on
elliptic curves, but it sounds like you can produce essentially-random
pairs of {PubX, Mult} pairs that give the same PubB, but you won't have
the private key associated with those public keys.  It's an interesting
point, and there may be a reason to be concerned about it.  Though, I
don't see it yet.

-Alan



From adam at cypherspace.org  Wed Jun 19 15:28:15 2013
From: adam at cypherspace.org (Adam Back)
Date: Wed, 19 Jun 2013 17:28:15 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51C1C288.4000305@gmail.com>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
Message-ID: <20130619152815.GA14729@netbook.cypherspace.org>

I think Timo's point is that while you cant do discrete log, you can do y-th
root.  So if P = xG is a parent public key (x private key, G base point),
then your proposed multiplier address is hash of Q=yP.  However its easy to
find another P such that Q=zP'.  ie just "divide by z" (EC multiply by z^-1
mod n, n the order of the curve).  So P'=z^-1.Q, which will work because
Q=zP', substituting P' you get Q=z.z^-1.Q, Q=Q.

Of course the attacker has just performed an unspenable DoS (maybe, or maybe
a useless collision) because he wont know the discrete log of Q, nor P, nor
P'.  So thats the question, does the protocol have any reliance on knowing
the discrete log - is it a problem if someone can find different multipliers
of different (unknown, uncomputable discrete log) parent keys.

If it was a concern I guess you could require a proof of knowledge of
discrete log.  ie as well as public key parent, multiplier the address must
include ECDSA sig or Schnorr proof of knowledge (which both demonstrate
knowledge of the discrete log of Q to base G.)

So his defense could probably be more simply viewed as hash rather than MAC
(same thing approximately) you provide the pre-image of the multiplier.  So
provide P (public parent), x' (mutiplier pre-image).  And compute Q=xP where
x=H(x',P).  You cant use just x=H(x') because I could choose random x',
compute x=H(x') compute x^-1 and multiply Q to find P'=x^-1.Q=H(x')^-1.Q as
before.  Because x includes P as well, I would have to simultaneously choose
a P' such that Q=H(x',P').P' which requires a birthday attack on the hash
(or MAC).

Adam

On Wed, Jun 19, 2013 at 10:39:04AM -0400, Alan Reiner wrote:
>
>On 06/19/2013 10:25 AM, Timo Hanke wrote:
>> Since you mention to use this in conjunction with the payment protocol,
>> note the following subtlety. Suppose the payer has to paid this address
>> called "destination":
>>>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||
>>> checksum)
>> Also suppose the payee has spent the output, i.e. the pubkey
>> corresponding to "destination", which is PubKeyParent * Multiplier[i],
>> is publicly known. Then anybody can (in retrospect) create arbitrary
>> many pairs {PublicKeyParent, Multiplier} (in particular different
>> PublicKeyParent) that lead to the same "destination".
>>
>> Depending on what you have in mind that the transaction should "prove"
>> regarding its actual receiver or regarding the receiver's PubKeyParent,
>> this could be an unwanted feature (or it could be just fine). If it is
>> unwanted then I suggest replacing
>> PubKeyParent * Multiplier[i] by
>> PubKeyParent * HMAC(Multiplier[i],PubKeyParent)
>> which eliminates from the destination all ambiguity about PubKeyParent.
>>
>> This modification would not be directly compatible with BIP32 anymore
>> (unfortunately), but seems to be better suited for use in conjunction
>> with a payment protocol.
>>
>> Timo
>
>It's an interesting observation, but it looks like the most-obvious
>attack vector is discrete log problem:  spoofing a relationship between
>a target public key and one that you control.   For instance, if you see
>{PubA, Mult} produces PubB and you have PubC already in your control
>that you want to "prove" [maliciously] is related to PubB, then you have
>to find the multiplier, M that solves:  M*PubC = PubB.  That's a
>discrete logarithm problem.
>
>I'm not as familiar as you are, with the available operations on
>elliptic curves, but it sounds like you can produce essentially-random
>pairs of {PubX, Mult} pairs that give the same PubB, but you won't have
>the private key associated with those public keys.  It's an interesting
>point, and there may be a reason to be concerned about it.  Though, I
>don't see it yet.
>
>-Alan
>
>------------------------------------------------------------------------------
>This SF.net email is sponsored by Windows:
>
>Build for Windows Store.
>
>http://p.sf.net/sfu/windows-dev2dev
>_______________________________________________
>Bitcoin-development mailing list
>Bitcoin-development at lists.sourceforge.net
>https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From adam at cypherspace.org  Wed Jun 19 18:36:57 2013
From: adam at cypherspace.org (Adam Back)
Date: Wed, 19 Jun 2013 20:36:57 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <20130619152815.GA14729@netbook.cypherspace.org>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
	<20130619152815.GA14729@netbook.cypherspace.org>
Message-ID: <20130619183657.GA16708@netbook.cypherspace.org>

This maybe simpler and trivially compatible with existing type2 public keys
(ones that are multiples of a parent public key): send an ECDSA signature of
the multiplier, and as we know you can compute ("recover") the parent public
key from an the ECDSA signature made using it.

Adam

On Wed, Jun 19, 2013 at 05:28:15PM +0200, Adam Back wrote:
>[q-th root with unknown no discrete log artefact]
>
>If it was a concern I guess you could require a proof of knowledge of
>discrete log.  ie as well as public key parent, multiplier the address must
>include ECDSA sig or Schnorr proof of knowledge (which both demonstrate
>knowledge of the discrete log of Q to base G.)



From etotheipi at gmail.com  Wed Jun 19 19:00:42 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 19 Jun 2013 15:00:42 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <20130619183657.GA16708@netbook.cypherspace.org>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
	<20130619152815.GA14729@netbook.cypherspace.org>
	<20130619183657.GA16708@netbook.cypherspace.org>
Message-ID: <51C1FFDA.1050308@gmail.com>

On 06/19/2013 02:36 PM, Adam Back wrote:
> This maybe simpler and trivially compatible with existing type2 public
> keys
> (ones that are multiples of a parent public key): send an ECDSA
> signature of
> the multiplier, and as we know you can compute ("recover") the parent
> public
> key from an the ECDSA signature made using it.
>
> Adam
>
> On Wed, Jun 19, 2013 at 05:28:15PM +0200, Adam Back wrote:
>> [q-th root with unknown no discrete log artefact]
>>
>> If it was a concern I guess you could require a proof of knowledge of
>> discrete log.  ie as well as public key parent, multiplier the
>> address must
>> include ECDSA sig or Schnorr proof of knowledge (which both demonstrate
>> knowledge of the discrete log of Q to base G.)

It's a cool trick but requiring a signature on each multiplier defeats
one of the purposes of a deterministic wallet.  I don't want to have to
explicitly export a whole bunch of signatures from my offline system
just to exercise this address option.  The "observer wallet" should be
able to do anything it needs to on its own, without help from the
offline wallet. 

Unless you mean that there is a one-time signature from the offline
computer that works for all addresses, that can be exported with the
observer wallet...?  If all you want to do is prove that /someone/ owns
that private key, you could send {Sign(MagicString), Multiplier}.   So
it becomes one signature operation *per wallet*, but creating new
wallets would require going back to the offline computer for that
one-time signature.  That's better than the alternative, but it's still
extra bloat for the wallet apps.

Either way, I'm not convinced that these are a problem for the specified
use cases I outlined.   In cases where you have a persistent business
relationship, they need to verify the parent public key exchange
anyway.  After that, the software doesn't technically require the
transmission of the PubKey, it only needs the Name/ID of the party and
the multiplier and it will fetch the PubKey from its data store.  Or it
is transmitted and the payer verifies it's correct.  Computing an
alternate {PubKey', Mult'} that produces the same address and then using
it in a MitM attack doesn't work here if the two parties pre-verified
the public keys. 

In the case that a business is checking whether the cashout address of a
customer is the same as the last time:  if the first payout was not
replaced by an attacker, then the business already has the correct
public key in their DB and a replacement of further payout requests will
fail validation.  If the first payout was replaced... well that could've
been done anyway (with or without this alternate form), and the customer
wouldn't have received their money and the whole process would be
flagged and terminated before further transactions.

-Alan


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/55223863/attachment.html>

From jeremy at taplink.co  Wed Jun 19 19:29:19 2013
From: jeremy at taplink.co (Jeremy Spilman)
Date: Wed, 19 Jun 2013 12:29:19 -0700
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
Message-ID: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>

If you have two parties who want to form a persistent relationship, by exchanging and verifying public keys beforehand, then I think the canonical way to do this with BIP32 is for the parties to exchange PubKey and *ChainCode*.

I don?t understand the use case for handing out individual multipliers, if what you desire is a persistent relationship. If each party dedicates a child-wallet for receiving coins, and saves a PubKey/ChainCode for sending coins, the two parties can transaction securely forever without ever exchanging any more information, and without any address reuse.

I think ideally, the default behavior is that wallets always dedicate a new child node {PubKey, ChainCode} to each party they transact with. At the presentation layer, you have a ?contact? and each contact has a transaction history. You can send coins to a contact at any time, and internally the wallet picks the next address in their sequence. Any funds received on pubkeys from contact?s sequence are attributed to that contact. The wallet can organize the contacts, and roll-up the transaction history into ?ledgers? and ?balances? however they want ? it could be based on the underlying BIP32 hierarchy or perhaps not. The cost of watching large a number of pubkeys, even if you ?look ahead? 100 pubkeys for each contact, is relatively small versus the benefits.

What might be nice is a ?Contact Request? protocol, basically the same as a PaymentRequest but no actual payments are sent, just child wallets created:

message Contact {
    optional uint32 contact_version = 1 [default = 1];
    optional string pki_type = 2 [default = "none"];
    optional bytes pki_data = 3;
    required bytes serialized_contact_details = 4;
    optional bytes signature = 5;
}

message ContactDetails {
    optional string network = 1 [default = "main"];
    required bytes pubkey = 2;
    required bytes chaincode = 3;
    optional string memo = 4;
    optional string response_url = 5;
}

Alice sends a Contact+ContactDetails to Bob.  If Bob accepts, he sends his own Contact+ContactDetails (without a response_url) back to Alice. Basically just like adding a contact to your IM contacts.

Alice could send a Contact+ContactDetails to Bob without a response_url, in which case after accepting the contact, Bob could send funds to Alice, but not receive funds.

You could probably pack the whole message inside a bitcoin:// URI if you wanted to.

Thanks,
--Jeremy
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/81654330/attachment.html>

From timo.hanke at web.de  Wed Jun 19 20:03:07 2013
From: timo.hanke at web.de (Timo Hanke)
Date: Wed, 19 Jun 2013 22:03:07 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51C1C288.4000305@gmail.com>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
Message-ID: <20130619200307.GB20405@crunch>

On Wed, Jun 19, 2013 at 10:39:04AM -0400, Alan Reiner wrote:
> On 06/19/2013 10:25 AM, Timo Hanke wrote:
> > Since you mention to use this in conjunction with the payment protocol,
> > note the following subtlety. Suppose the payer has to paid this address
> > called "destination": 
> >>    Standard Address ~ Base58(0x00 || hash160(PubKeyParent * Multiplier[i]) ||
> >> checksum)
> > Also suppose the payee has spent the output, i.e. the pubkey
> > corresponding to "destination", which is PubKeyParent * Multiplier[i],
> > is publicly known. Then anybody can (in retrospect) create arbitrary
> > many pairs {PublicKeyParent, Multiplier} (in particular different
> > PublicKeyParent) that lead to the same "destination".
> >
> > Depending on what you have in mind that the transaction should "prove"
> > regarding its actual receiver or regarding the receiver's PubKeyParent,
> > this could be an unwanted feature (or it could be just fine). If it is
> > unwanted then I suggest replacing
> > PubKeyParent * Multiplier[i] by 
> > PubKeyParent * HMAC(Multiplier[i],PubKeyParent)
> > which eliminates from the destination all ambiguity about PubKeyParent.
> >
> > This modification would not be directly compatible with BIP32 anymore
> > (unfortunately), but seems to be better suited for use in conjunction
> > with a payment protocol. 
> >
> > Timo
> 
> It's an interesting observation, but it looks like the most-obvious
> attack vector is discrete log problem:  spoofing a relationship between
> a target public key and one that you control.   For instance, if you see
> {PubA, Mult} produces PubB and you have PubC already in your control
> that you want to "prove" [maliciously] is related to PubB, then you have
> to find the multiplier, M that solves:  M*PubC = PubB.  That's a
> discrete logarithm problem.

Correct, for a given PubC in advance you can't create such a "malicious"
relation to PubB. You can only "reversely" construct new PubC from given
PubB.

> I'm not as familiar as you are, with the available operations on
> elliptic curves, but it sounds like you can produce essentially-random
> pairs of {PubX, Mult} pairs that give the same PubB, but you won't have
> the private key associated with those public keys.  

Depends on who is "you". The arbitrary person who produces {PubX, Mult}
won't have the private key, but the person who knows the private key for
PubA will have it (assuming that PubB was computed from {PubA, Mult} in
the first place).

In the end, it all depends on your application. What proves enough for
one party doing repeated transactions with another may not suffice for a
third party doing auditing. On the other hand, ambiguity about PubA may
just as well be a wanted feature for deniability reasons.

Timo

-- 
Timo Hanke
PGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8



From etotheipi at gmail.com  Wed Jun 19 20:10:29 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 19 Jun 2013 16:10:29 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
References: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
Message-ID: <51C21035.9080407@gmail.com>

On 06/19/2013 03:29 PM, Jeremy Spilman wrote:
> If you have two parties who want to form a persistent relationship, by
> exchanging and verifying public keys beforehand, then I think the
> canonical way to do this with BIP32 is for the parties to exchange
> PubKey and *ChainCode*.
>  
> I don't understand the use case for handing out individual
> multipliers, if what you desire is a persistent relationship. If each
> party dedicates a child-wallet for receiving coins, and saves a
> PubKey/ChainCode for sending coins, the two parties can transaction
> securely forever without ever exchanging any more information, and
> without any address reuse.
>  
> I think ideally, the default behavior is that wallets always dedicate
> a new child node {PubKey, ChainCode} to each party they transact with.
> At the presentation layer, you have a "contact" and each contact has a
> transaction history. You can send coins to a contact at any time, and
> internally the wallet picks the next address in their sequence. Any
> funds received on pubkeys from contact's sequence are attributed to
> that contact. The wallet can organize the contacts, and roll-up the
> transaction history into 'ledgers' and 'balances' however they want --
> it could be based on the underlying BIP32 hierarchy or perhaps not.
> The cost of watching large a number of pubkeys, even if you 'look
> ahead' 100 pubkeys for each contact, is relatively small versus the
> benefits.
>  
>

What you just described is complimentary to what I am proposing.  There
is nothing stopping you from doing it that way, except that it may be
inconvenient in some circumstances.  BIP 32 does not prescribe a way to
use multiple chains like you described with the convenient type-2
derivation (though we could create a variant that does).  And all
separate chains with their 100-address look-aheads may be fine for your
desktop or mobile device, but maybe not a HW signing device with 128 kB
of memory. 

So, some use cases might prefer having a different parent public key
[and chaincode] per contact, some may prefer to synchronize across many
contacts.  For instance, maybe there's a benefit to using the same
parent pubkey across multiple services, as a form of identity.   If I
don't want that, I use your method.  If I do want that, I use my
method.  Given its simplicity, I don't know why both can't be options.

Actually, it doesn't have to be specific to the payment protocol, it can
just be alternative address encoding that some apps would use if they
have a need for it.

-Alan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/bc4628e8/attachment.html>

From jeremy at taplink.co  Wed Jun 19 21:58:06 2013
From: jeremy at taplink.co (Jeremy Spilman)
Date: Wed, 19 Jun 2013 14:58:06 -0700
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51C21035.9080407@gmail.com>
References: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
	<51C21035.9080407@gmail.com>
Message-ID: <53E406CF0D93498DAECAAE061555B7C9@LAPTOPAIR>

Hi Alan,

> ?BIP 32 does not prescribe a way to use multiple chains like you described 
> with the convenient type-2 derivation (though we could create a variant 
> that does)?

What do you think is missing from BIP32 for this? A wallet creates a 
child-node using the public / type-2 CDF, hands out the PubKey/ChainCode, 
and then generally expects transactions to come in starting at /0 and 
incrementing monotonically.

Also, I'm not sure I follow your point about the 128kB hardware wallet --  
it's a signing device, so assuming it's even validating output amounts, at 
worst it cares about the number of inputs to the outputs being spent, but in 
many cases you're just handing it a sighash and the BIP32 "path" 
(/1/54/27/0) to generate the right private key for signing. The hardware 
wallet is not actually listening on the P2P network and detecting payments, 
so it's unaffected by dedicating child-nodes to each contact.

Consider the benefits of gaining critical mass of support for a technique 
which [I think] can be used in all cases, and increases security and privacy 
for everyone. I think there are huge benefits to leaving the age of 'single 
address generation' behind us...

Thanks,
--Jeremy 





From etotheipi at gmail.com  Wed Jun 19 22:47:22 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 19 Jun 2013 18:47:22 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <53E406CF0D93498DAECAAE061555B7C9@LAPTOPAIR>
References: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
	<51C21035.9080407@gmail.com>
	<53E406CF0D93498DAECAAE061555B7C9@LAPTOPAIR>
Message-ID: <51C234FA.5030909@gmail.com>

On 06/19/2013 05:58 PM, Jeremy Spilman wrote:
> Hi Alan,
>
>> ?BIP 32 does not prescribe a way to use multiple chains like you described 
>> with the convenient type-2 derivation (though we could create a variant 
>> that does)?
> What do you think is missing from BIP32 for this? A wallet creates a 
> child-node using the public / type-2 CDF, hands out the PubKey/ChainCode, 
> and then generally expects transactions to come in starting at /0 and 
> incrementing monotonically.
>


You are suggesting that creating new wallet chains are the only
operation needed to achieve the functionality I'm requesting.  I
disagree.  I am okay with using different wallets for different parties
*/if the user wants to/*.  But there are orthogonal use-cases to having
a single wallet serve as a single identity that can be used across
multiple transactions or services.  And doing so is much simpler
conceptually for the user, and simpler in implementation for the app
developer.

BIP 32 already specifies how to use the first three tree levels: 
M/i/j/k, i~wallet, j~Internal/External, k~address.  The first level is
actually type-1 derived, and thus we cannot create an arbitrary number
of them without pre-computing them from the offline wallet.  So it's not
"free" to create new wallets unless we redefine how the levels work. 
Even if we assume the simplest case where the first level is actually
type-2 derived and it costs nothing to create separate wallets for each
contact/party:
 
-- Do these extra wallet chains behave as different wallets, or
sub-wallets? 
-- Should their balances be bundled into a single wallet or displayed
separately?
-- When a user tries to spend, does he have to specify which wallet(s)
he's spending from?
-- Should the app developer be required to implement a multiple-wallet
interface, and handle cross-wallet spending just to achieve this simple
mechanism?  Sure, they could instead implement a tiered wallet hierarchy
with primary wallets and sub-wallets... wait this just got complicated.

All that complexity just to support this identity mechanism that can be
included purely as an alternative address encoding with a single
wallet.  With my request, the user can't have one wallet and distribute
most of his addresses the normal/anonymous way, but certain apps would
choose to use the alternate encoding as a form of identity.  If the user
feels the need to create a separate wallet for certain operations to
separate his identities, that is his option if the software supports
multiple wallets.  But it's not the only way.

To achieve what I'm suggesting is useful and trivial to implement even
in the simplest wallet applications. 

-Alan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/350ab33e/attachment.html>

From jeremy at taplink.co  Thu Jun 20 03:54:18 2013
From: jeremy at taplink.co (Jeremy Spilman)
Date: Wed, 19 Jun 2013 20:54:18 -0700
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <51C234FA.5030909@gmail.com>
References: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
	<51C21035.9080407@gmail.com>
	<53E406CF0D93498DAECAAE061555B7C9@LAPTOPAIR>
	<51C234FA.5030909@gmail.com>
Message-ID: <9600E3D1DDC24D1391C1E4433F71684D@LAPTOPAIR>

> BIP 32 already specifies how to use the first three tree levels:  M/i/j/k, 
> i~wallet, j~Internal/External, k~address.  The first level is actually 
> type-1 derived, and thus we cannot create an arbitrary number of them 
> without pre-computing them from the offline wallet.  So it's not "free" to 
> create new wallets unless we redefine how the levels work.

Initially I was thinking that you would share the public key and chain code 
from [m/i'/0] so that you can receive payments at [m/i'/0/k], for a unique 
value of 'i' for each receive chain.

For the case of generating new receive chains from a *watch-only* wallet, as 
you say, the options are to either keep a cache of PubKey/ChainCode for 
unused [m/i'] or simply increment 'j' past 1 for an existing [m/i'/j] -- the 
concept of 'internal/'external' and change addresses at Depth=2 don't make 
sense for handing out receive chains to lots of people anyway, and certainly 
BIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j' is the way 
to go here...

The "default" layout of BIP32 does NOT mean that implementations should not 
check for transactions with j > 1. That would be a useless constraint and 
obviously self-limiting. It might be helpful to add to the 'Compatibility' 
section some minimum expectations about how a wallet should be 'probed' when 
imported. If you don't feel completely free to monotonically increment 'j' 
to your hearts content to achieve major usability benefits, then I say BIP32 
could use some clarifying.

BTW - the spec calls for addition not multiplication now, so we should call 
it the 'Addend' not the 'Multiplier' :-)

> Do these extra wallet chains behave as different wallets, or sub-wallets?

They could, but they certainly don't need to!  A single-wallet 
implementation treats this merely as an address-generation algorithm, and 
does not expose any hierarchy to the user interface.  The user just 
?magically? gets the ability to send multiple payments to their contacts 
without immediately sacrificing their privacy 
(http://www.wired.com/wiredenterprise/2013/06/bitcoin_retai/). Everything 
goes into the same ledger, balance, coin pool, etc. Most of the code base is 
unaware BIP32 is even in use.

While it is *possible* to support separate ledgers, balances, etc. it is 
certainly not required, and you get all the benefits either way.

I think, since your proposal generates and receives payments into 
BIP32-style addresses, we both need similar underlying wallet code. The only 
difference is that you are passing the Kpar for [m/i'/0/k] and the *result* 
of CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and cpar, and 
leaving 'k' out of it, letting the receive choose 'k'.

> For instance, maybe there's a benefit to using the same parent pubkey 
> across multiple services, as a form of identity.   If I don't want that, I 
> use your method.  If I do want that, I use my method.

I think it's a interesting idea using static public keys as a means for 
persistent identity and hence security from MitM. If you want a shared 
public key across multiple services we could just combine both ideas and get 
all the benefits, by making the data structure { ParentPubKey, Addend, 
ChainCode }:

   ParentPubKey: Public key of m/i' -- 33 bytes
   Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes
   ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes

All that remains secret is the ChainCode from [m/i'] -- and of course the 
private keys.  The ParentPubKey is a common value across multiple services, 
corresponding to user's identity rooted in [m/i'].  Each service gets their 
own 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].  With the 
ChainCode, the receiver then can generate [m/i'/j/k] for monotonically 
increasing 'k'. Again, from the user perspective all transactions under 
[m/i'] can be presented in a single ledger, or not.

Anyway, fundamentally my feedback is if you are designing for persistent 
long-term relationships, you could build in a mechanism for generating 
address chains so you don't need any further communication after the initial 
exchange, and it need not complicate the wallet.

Thanks,
--Jeremy 





From turkeybreast at yahoo.com  Thu Jun 20 06:20:37 2013
From: turkeybreast at yahoo.com (Turkey Breast)
Date: Wed, 19 Jun 2013 23:20:37 -0700 (PDT)
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <CANEZrP0Pr=_L7CA4hdt9esVCHqf-EOjfDjnVrw8rFxL1OtUw7A@mail.gmail.com>
References: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>
	<CANEZrP0Pr=_L7CA4hdt9esVCHqf-EOjfDjnVrw8rFxL1OtUw7A@mail.gmail.com>
Message-ID: <1371709237.57104.YahooMailNeo@web162701.mail.bf1.yahoo.com>

I never said that Bitcoin message field lengths should always be the same. But before this change they certainly were constant per protocol version. All I'm saying is that optional lengths shouldn't be used (a field exists or not) and for every field change, the protocol version should be upgraded.

Now that fRelayTxes is part of the protocol, the version number should be upgraded to reflect this fact.



________________________________
 From: Mike Hearn <mike at plan99.net>
To: Paul Lyon <pmlyon at hotmail.ca> 
Cc: Turkey Breast <turkeybreast at yahoo.com>; "bitcoin-development at lists.sourceforge.net" <bitcoin-development at lists.sourceforge.net> 
Sent: Wednesday, June 19, 2013 3:20 PM
Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
 


If you want to criticise the Bitcoin protocol for sloppyness, the variable length of some messages isn't where I'd start.

Note that ping has the same issue, its length has changed over time to include the nonce.

If your parser can't handle that kind of thing, you need to fix it. The protocol has always worked that way.




On Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:

I?m also running into this exact same issue with my parser, now I understand why the relay field behavior I was seeing?doesn?t match the wiki.
>?
>So to parse a version message, you can?t rely on the protocol version? You have to know how long the payload is, and then parse the message accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.
>?
>Paul
>?
>P.S. I?ve never used a dev mailing list before and I want to get involved with the Bitcoin dev community, so let me know if I?m horribly violating any?mailing list etiquette. ?
>?
>From:?Mike Hearn
>Sent:??Wednesday?, ?June? ?19?, ?2013 ?7?:?43? ?AM
>To:?Turkey Breast
>Cc:?bitcoin-development at lists.sourceforge.net
>?
>Bitcoin-Qt on master does send it now although it doesn't affect anything, but as old pre-filtering versions will continue to exist, you'll always have to be able to deserialize version messages without it.
>
>
>Bitcoin version messages have always had variable length, look at how the code is written in main.cpp. If you didn't experience issues until now all it means is that no sufficiently old nodes were talking to yours.
>
>
>The standard does not say it should appear. Read it again - BIP 37 says about the new version message field:
>If false then broadcast transactions will not be announced until a filter{load,add,clear} command is received. If missing or true, no change in protocol behaviour occurs.
> 
>
>
>
>On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:
>
>It's a problem if you work with iterators to deserialize the byte stream. Even failing that, it's just sloppy programming. What happens in the future when new fields are added to the version message? It's not a big deal to say that this protocol version has X number of fields, that (higher) protocol version message has X + N number of fields. Deterministic number of fields per protocol version is sensical and how Bitcoin has been for a long time.
>>
>>
>>And yes, it was a problem for me that caused a lot of confusion why this byte didn't exist in many version messages despite the standard saying it should and the code in bitcoind indicating it should. Nowhere was this written. It doesn't help other implementations to have an unclear behaviour that depends on some magic from one implementation.
>>
>>
>>
>>
>>________________________________
>> From: Mike Hearn <mike at plan99.net>
>>To: Turkey Breast <turkeybreast at yahoo.com> 
>>Cc: "bitcoin-development at lists.sourceforge.net" <bitcoin-development at lists.sourceforge.net> 
>>Sent: Wednesday, June 19, 2013 11:39 AM
>>
>>Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
>> 
>>
>>
>>It has to be optional because old clients don't send it, obviously.
>>
>>
>>Why is this even an issue? There's no problem with variable length messages in any codebase that I'm aware of. Is this solving some actual problem?
>>
>>
>>
>>On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com> wrote:
>>
>>That's me. I never said to make all messages fixed length. I said to make a fixed number of fields per protocol. So given a protocol version number, you know the number of fields in a message. This is not only easier for parsing messages, but just good practice. I don't see why a 1 byte flag needs to be optional anyway.
>>>
>>>
>>>
>>>
>>>________________________________
>>> From: Mike Hearn <mike at plan99.net>
>>>To: Turkey Breast <turkeybreast at yahoo.com> 
>>>Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net> 
>>>Sent: Tuesday, June 18, 2013 9:48 PM
>>>Subject: Re: [Bitcoin-development] Missing fRelayTxes in version message
>>> 
>>>
>>>
>>>It's not a bug (although there was recently a change to make bitcoind/qt always send this field anyway).?
>>>
>>>
>>>I don't know where Amir is going with BIP 60. Version messages have always been variable length. There's nothing inherent in the Bitcoin protocol that says all messages are fixed length, indeed, tx messages are allowed to have arbitrary data appended after them that gets relayed.
>>>
>>>
>>>
>>>On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com> wrote:
>>>
>>>See this BIP. I'm not sure if this is a bug or what, but it would be good if messages always had a fixed number of fields per protocol version.
>>>>
>>>>
>>>>https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>>>>
>>>>
>>>>This BIP details everything that needs to be done and proposes a protocol upgrade.
>>>>
>>>>------------------------------------------------------------------------------
>>>>This SF.net email is sponsored by Windows:
>>>>
>>>>Build for Windows Store.
>>>>
>>>>http://p.sf.net/sfu/windows-dev2dev
>>>>_______________________________________________
>>>>Bitcoin-development mailing list
>>>>Bitcoin-development at lists.sourceforge.net
>>>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>>
>>>>
>>>
>>>
>>>
>>>------------------------------------------------------------------------------
>>>This SF.net email is sponsored by Windows:
>>>
>>>Build for Windows Store.
>>>
>>>http://p.sf.net/sfu/windows-dev2dev
>>>_______________________________________________
>>>Bitcoin-development mailing list
>>>Bitcoin-development at lists.sourceforge.net
>>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>>
>>>
>>
>>
>>
>>------------------------------------------------------------------------------
>>This SF.net email is sponsored by Windows:
>>
>>Build for Windows Store.
>>
>>http://p.sf.net/sfu/windows-dev2dev
>>_______________________________________________
>>Bitcoin-development mailing list
>>Bitcoin-development at lists.sourceforge.net
>>https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130619/852f3ff4/attachment.html>

From mike at plan99.net  Thu Jun 20 07:10:05 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 09:10:05 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <1371709237.57104.YahooMailNeo@web162701.mail.bf1.yahoo.com>
References: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>
	<CANEZrP0Pr=_L7CA4hdt9esVCHqf-EOjfDjnVrw8rFxL1OtUw7A@mail.gmail.com>
	<1371709237.57104.YahooMailNeo@web162701.mail.bf1.yahoo.com>
Message-ID: <CANEZrP1vqXdODJz8naqbVO0iTcJWOk+4aU4Y=_Epgp2bwh1hKA@mail.gmail.com>

The protocol version was bumped when Bloom filtering was added so there's
not much point bumping it again - you have to handle the old clients no
matter what. Nobody brought this up as an issue when the BIP or code was
first written and as you can see from main.cpp, it was done this way to be
consistent with how other version fields are handled:

        if (!vRecv.empty())
            vRecv >> addrFrom >> nNonce;
        if (!vRecv.empty())
            vRecv >> pfrom->strSubVer;
        if (!vRecv.empty())
            vRecv >> pfrom->nStartingHeight;
        if (!vRecv.empty())
            vRecv >> pfrom->fRelayTxes; // set to true after we get the
first filter* message

The existence of the nStartingHeight field for instance depends on the
message length and not anything else.

Anyway, are you really asking for the protocol to be changed to work around
an issue specific to how you wrote your parsing code? This is the first
time anyone has suggested this minor detail is a problem. It doesn't
present any issues for the C++ code or bitcoinj where message objects know
their own length at parse time.



On Thu, Jun 20, 2013 at 8:20 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:

> I never said that Bitcoin message field lengths should always be the same.
> But before this change they certainly were constant per protocol version.
> All I'm saying is that optional lengths shouldn't be used (a field exists
> or not) and for every field change, the protocol version should be upgraded.
>
> Now that fRelayTxes is part of the protocol, the version number should be
> upgraded to reflect this fact.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Paul Lyon <pmlyon at hotmail.ca>
> *Cc:* Turkey Breast <turkeybreast at yahoo.com>; "
> bitcoin-development at lists.sourceforge.net" <
> bitcoin-development at lists.sourceforge.net>
> *Sent:* Wednesday, June 19, 2013 3:20 PM
>
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> If you want to criticise the Bitcoin protocol for sloppyness, the variable
> length of some messages isn't where I'd start.
>
> Note that ping has the same issue, its length has changed over time to
> include the nonce.
>
> If your parser can't handle that kind of thing, you need to fix it. The
> protocol has always worked that way.
>
>
>
> On Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:
>
>  I?m also running into this exact same issue with my parser, now I
> understand why the relay field behavior I was seeing doesn?t match the wiki.
>
> So to parse a version message, you can?t rely on the protocol version? You
> have to know how long the payload is, and then parse the message
> accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.
>
> Paul
>
> P.S. I?ve never used a dev mailing list before and I want to get involved
> with the Bitcoin dev community, so let me know if I?m horribly violating
> any mailing list etiquette. ?
>
> *From:* Mike Hearn
> *Sent:* ?Wednesday?, ?June? ?19?, ?2013 ?7?:?43? ?AM
> *To:* Turkey Breast
> *Cc:* bitcoin-development at lists.sourceforge.net
>
> Bitcoin-Qt on master does send it now although it doesn't affect anything,
> but as old pre-filtering versions will continue to exist, you'll always
> have to be able to deserialize version messages without it.
>
> Bitcoin version messages have always had variable length, look at how the
> code is written in main.cpp. If you didn't experience issues until now all
> it means is that no sufficiently old nodes were talking to yours.
>
> The standard does not say it should appear. Read it again - BIP 37 says
> about the new version message field:
> If false then broadcast transactions will not be announced until a
> filter{load,add,clear} command is received. *If missing or true*, no
> change in protocol behaviour occurs.
>
>
> On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> It's a problem if you work with iterators to deserialize the byte stream.
> Even failing that, it's just sloppy programming. What happens in the future
> when new fields are added to the version message? It's not a big deal to
> say that this protocol version has X number of fields, that (higher)
> protocol version message has X + N number of fields. Deterministic number
> of fields per protocol version is sensical and how Bitcoin has been for a
> long time.
>
> And yes, it was a problem for me that caused a lot of confusion why this
> byte didn't exist in many version messages despite the standard saying it
> should and the code in bitcoind indicating it should. Nowhere was this
> written. It doesn't help other implementations to have an unclear behaviour
> that depends on some magic from one implementation.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* "bitcoin-development at lists.sourceforge.net" <
> bitcoin-development at lists.sourceforge.net>
> *Sent:* Wednesday, June 19, 2013 11:39 AM
>
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It has to be optional because old clients don't send it, obviously.
>
> Why is this even an issue? There's no problem with variable length
> messages in any codebase that I'm aware of. Is this solving some actual
> problem?
>
>
> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> That's me. I never said to make all messages fixed length. I said to make
> a fixed number of fields per protocol. So given a protocol version number,
> you know the number of fields in a message. This is not only easier for
> parsing messages, but just good practice. I don't see why a 1 byte flag
> needs to be optional anyway.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>
> *Sent:* Tuesday, June 18, 2013 9:48 PM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It's not a bug (although there was recently a change to make bitcoind/qt
> always send this field anyway).
>
> I don't know where Amir is going with BIP 60. Version messages have always
> been variable length. There's nothing inherent in the Bitcoin protocol that
> says all messages are fixed length, indeed, tx messages are allowed to have
> arbitrary data appended after them that gets relayed.
>
>
> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> See this BIP. I'm not sure if this is a bug or what, but it would be good
> if messages always had a fixed number of fields per protocol version.
>
> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>
> This BIP details everything that needs to be done and proposes a protocol
> upgrade.
>
>
> ------------------------------------------------------------------------------
> This SF.net <http://sf.net/> email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/ace406cd/attachment.html>

From ayeowch at gmail.com  Thu Jun 20 07:13:11 2013
From: ayeowch at gmail.com (Addy Yeow)
Date: Thu, 20 Jun 2013 17:13:11 +1000
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <1371709237.57104.YahooMailNeo@web162701.mail.bf1.yahoo.com>
References: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>
	<CANEZrP0Pr=_L7CA4hdt9esVCHqf-EOjfDjnVrw8rFxL1OtUw7A@mail.gmail.com>
	<1371709237.57104.YahooMailNeo@web162701.mail.bf1.yahoo.com>
Message-ID: <CAA3bHnzrRijieFi5phXZfuHEU3eLrPcVJwXuPpUrepWCY7coQQ@mail.gmail.com>

I personally don't treat the relay field as optional, i.e. it is there as
0x01 if it is set. Otherwise, it is simply a trailing zero byte. Hence, the
right way of reading the packet as with any network packet is to first
retrieve the header information, get the actual payload length, then parse
the payload accordingly. I can also choose to include 0x00 for my relay
field in my outgoing packet and reflect that accordingly in my length field
in the header.


On Thu, Jun 20, 2013 at 4:20 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:

> I never said that Bitcoin message field lengths should always be the same.
> But before this change they certainly were constant per protocol version.
> All I'm saying is that optional lengths shouldn't be used (a field exists
> or not) and for every field change, the protocol version should be upgraded.
>
> Now that fRelayTxes is part of the protocol, the version number should be
> upgraded to reflect this fact.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Paul Lyon <pmlyon at hotmail.ca>
> *Cc:* Turkey Breast <turkeybreast at yahoo.com>; "
> bitcoin-development at lists.sourceforge.net" <
> bitcoin-development at lists.sourceforge.net>
> *Sent:* Wednesday, June 19, 2013 3:20 PM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> If you want to criticise the Bitcoin protocol for sloppyness, the variable
> length of some messages isn't where I'd start.
>
> Note that ping has the same issue, its length has changed over time to
> include the nonce.
>
> If your parser can't handle that kind of thing, you need to fix it. The
> protocol has always worked that way.
>
>
>
> On Wed, Jun 19, 2013 at 3:03 PM, Paul Lyon <pmlyon at hotmail.ca> wrote:
>
>  I?m also running into this exact same issue with my parser, now I
> understand why the relay field behavior I was seeing doesn?t match the wiki.
>
> So to parse a version message, you can?t rely on the protocol version? You
> have to know how long the payload is, and then parse the message
> accordingly? I agree with Turkey Breast, this seems a bit sloppy to me.
>
> Paul
>
> P.S. I?ve never used a dev mailing list before and I want to get involved
> with the Bitcoin dev community, so let me know if I?m horribly violating
> any mailing list etiquette. ?
>
> *From:* Mike Hearn
> *Sent:* ?Wednesday?, ?June? ?19?, ?2013 ?7?:?43? ?AM
> *To:* Turkey Breast
> *Cc:* bitcoin-development at lists.sourceforge.net
>
> Bitcoin-Qt on master does send it now although it doesn't affect anything,
> but as old pre-filtering versions will continue to exist, you'll always
> have to be able to deserialize version messages without it.
>
> Bitcoin version messages have always had variable length, look at how the
> code is written in main.cpp. If you didn't experience issues until now all
> it means is that no sufficiently old nodes were talking to yours.
>
> The standard does not say it should appear. Read it again - BIP 37 says
> about the new version message field:
> If false then broadcast transactions will not be announced until a
> filter{load,add,clear} command is received. *If missing or true*, no
> change in protocol behaviour occurs.
>
>
> On Wed, Jun 19, 2013 at 12:33 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> It's a problem if you work with iterators to deserialize the byte stream.
> Even failing that, it's just sloppy programming. What happens in the future
> when new fields are added to the version message? It's not a big deal to
> say that this protocol version has X number of fields, that (higher)
> protocol version message has X + N number of fields. Deterministic number
> of fields per protocol version is sensical and how Bitcoin has been for a
> long time.
>
> And yes, it was a problem for me that caused a lot of confusion why this
> byte didn't exist in many version messages despite the standard saying it
> should and the code in bitcoind indicating it should. Nowhere was this
> written. It doesn't help other implementations to have an unclear behaviour
> that depends on some magic from one implementation.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* "bitcoin-development at lists.sourceforge.net" <
> bitcoin-development at lists.sourceforge.net>
> *Sent:* Wednesday, June 19, 2013 11:39 AM
>
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It has to be optional because old clients don't send it, obviously.
>
> Why is this even an issue? There's no problem with variable length
> messages in any codebase that I'm aware of. Is this solving some actual
> problem?
>
>
> On Wed, Jun 19, 2013 at 12:30 AM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> That's me. I never said to make all messages fixed length. I said to make
> a fixed number of fields per protocol. So given a protocol version number,
> you know the number of fields in a message. This is not only easier for
> parsing messages, but just good practice. I don't see why a 1 byte flag
> needs to be optional anyway.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Turkey Breast <turkeybreast at yahoo.com>
> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>
> *Sent:* Tuesday, June 18, 2013 9:48 PM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version message
>
> It's not a bug (although there was recently a change to make bitcoind/qt
> always send this field anyway).
>
> I don't know where Amir is going with BIP 60. Version messages have always
> been variable length. There's nothing inherent in the Bitcoin protocol that
> says all messages are fixed length, indeed, tx messages are allowed to have
> arbitrary data appended after them that gets relayed.
>
>
> On Tue, Jun 18, 2013 at 7:45 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:
>
> See this BIP. I'm not sure if this is a bug or what, but it would be good
> if messages always had a fixed number of fields per protocol version.
>
> https://en.bitcoin.it/wiki/BIP_0060#Code_Updates
>
> This BIP details everything that needs to be done and proposes a protocol
> upgrade.
>
>
> ------------------------------------------------------------------------------
> This SF.net <http://sf.net/> email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/0683b160/attachment.html>

From tamas at bitsofproof.com  Thu Jun 20 07:30:29 2013
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Thu, 20 Jun 2013 09:30:29 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
Message-ID: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>

Hi Mike,

The issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.
If there will be further fields they will become manadory. 
 
Why not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner
going forward.

Tamas Blummer
http://bitsofproof.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/3b03828f/attachment.html>

From mike at plan99.net  Thu Jun 20 07:32:22 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 09:32:22 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <9600E3D1DDC24D1391C1E4433F71684D@LAPTOPAIR>
References: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
	<51C21035.9080407@gmail.com>
	<53E406CF0D93498DAECAAE061555B7C9@LAPTOPAIR>
	<51C234FA.5030909@gmail.com>
	<9600E3D1DDC24D1391C1E4433F71684D@LAPTOPAIR>
Message-ID: <CANEZrP3ZcQEPOPrO_O2-tdLZUSezj1nbhtVFt1e77KEwzhfZ-A@mail.gmail.com>

Agree with Jeremy and once the payment protocol work is further along I'd
like to see us define an extension that lets you send payment requests
containing public keys+chain codes, so further payments can be made
push-style with no recipient interaction (e.g. for repeated billing). How
apps choose to arrange their chains internally seems like an area for
experimentation. I definitely want to implement HD wallets in bitcoinj to
allow this and if that means not using the same tree structure as in the
BIP then so be it.


On Thu, Jun 20, 2013 at 5:54 AM, Jeremy Spilman <jeremy at taplink.co> wrote:

> > BIP 32 already specifies how to use the first three tree levels:
>  M/i/j/k,
> > i~wallet, j~Internal/External, k~address.  The first level is actually
> > type-1 derived, and thus we cannot create an arbitrary number of them
> > without pre-computing them from the offline wallet.  So it's not "free"
> to
> > create new wallets unless we redefine how the levels work.
>
> Initially I was thinking that you would share the public key and chain code
> from [m/i'/0] so that you can receive payments at [m/i'/0/k], for a unique
> value of 'i' for each receive chain.
>
> For the case of generating new receive chains from a *watch-only* wallet,
> as
> you say, the options are to either keep a cache of PubKey/ChainCode for
> unused [m/i'] or simply increment 'j' past 1 for an existing [m/i'/j] --
> the
> concept of 'internal/'external' and change addresses at Depth=2 don't make
> sense for handing out receive chains to lots of people anyway, and
> certainly
> BIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j' is the
> way
> to go here...
>
> The "default" layout of BIP32 does NOT mean that implementations should not
> check for transactions with j > 1. That would be a useless constraint and
> obviously self-limiting. It might be helpful to add to the 'Compatibility'
> section some minimum expectations about how a wallet should be 'probed'
> when
> imported. If you don't feel completely free to monotonically increment 'j'
> to your hearts content to achieve major usability benefits, then I say
> BIP32
> could use some clarifying.
>
> BTW - the spec calls for addition not multiplication now, so we should call
> it the 'Addend' not the 'Multiplier' :-)
>
> > Do these extra wallet chains behave as different wallets, or sub-wallets?
>
> They could, but they certainly don't need to!  A single-wallet
> implementation treats this merely as an address-generation algorithm, and
> does not expose any hierarchy to the user interface.  The user just
> ?magically? gets the ability to send multiple payments to their contacts
> without immediately sacrificing their privacy
> (http://www.wired.com/wiredenterprise/2013/06/bitcoin_retai/). Everything
> goes into the same ledger, balance, coin pool, etc. Most of the code base
> is
> unaware BIP32 is even in use.
>
> While it is *possible* to support separate ledgers, balances, etc. it is
> certainly not required, and you get all the benefits either way.
>
> I think, since your proposal generates and receives payments into
> BIP32-style addresses, we both need similar underlying wallet code. The
> only
> difference is that you are passing the Kpar for [m/i'/0/k] and the *result*
> of CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and cpar, and
> leaving 'k' out of it, letting the receive choose 'k'.
>
> > For instance, maybe there's a benefit to using the same parent pubkey
> > across multiple services, as a form of identity.   If I don't want that,
> I
> > use your method.  If I do want that, I use my method.
>
> I think it's a interesting idea using static public keys as a means for
> persistent identity and hence security from MitM. If you want a shared
> public key across multiple services we could just combine both ideas and
> get
> all the benefits, by making the data structure { ParentPubKey, Addend,
> ChainCode }:
>
>    ParentPubKey: Public key of m/i' -- 33 bytes
>    Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes
>    ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes
>
> All that remains secret is the ChainCode from [m/i'] -- and of course the
> private keys.  The ParentPubKey is a common value across multiple services,
> corresponding to user's identity rooted in [m/i'].  Each service gets their
> own 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].  With the
> ChainCode, the receiver then can generate [m/i'/j/k] for monotonically
> increasing 'k'. Again, from the user perspective all transactions under
> [m/i'] can be presented in a single ledger, or not.
>
> Anyway, fundamentally my feedback is if you are designing for persistent
> long-term relationships, you could build in a mechanism for generating
> address chains so you don't need any further communication after the
> initial
> exchange, and it need not complicate the wallet.
>
> Thanks,
> --Jeremy
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/6ee026aa/attachment.html>

From mike at plan99.net  Thu Jun 20 07:36:40 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 09:36:40 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
Message-ID: <CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>

Sure but why not do that when there's an actual new field to add? Does
anyone have a proposal for a feature that needs a new version field at the
moment? There's no point changing the protocol now unless there's actually
a new field to add.

Anyway I still don't see why anyone cares about this issue. The Bitcoin
protocol does not and never has required that all messages have a fixed
number of fields per version. Any parser written on the assumption it did
was just buggy. Look at how tx messages are relayed for the most obvious
example of that pattern in action - it's actually the raw byte stream
that's stored and relayed to ensure that fields added in new versions
aren't dropped during round-tripping. Old versions are supposed to preserve
fields from the future.



On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com>wrote:

> Hi Mike,
>
> The issue with the current parser is that those fields are conditionally
> optional on that there will be no subsequent fields added.
> If there will be further fields they will become manadory.
>
> Why not bump the version and parse the fields as mandatory from then on?
> This would be backward compatible and cleaner
> going forward.
>
> Tamas Blummer
> http://bitsofproof.com
>  <http://bitsofproof.com/>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/750bf247/attachment.html>

From timo.hanke at web.de  Thu Jun 20 07:48:30 2013
From: timo.hanke at web.de (Timo Hanke)
Date: Thu, 20 Jun 2013 09:48:30 +0200
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <20130619152815.GA14729@netbook.cypherspace.org>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
	<20130619152815.GA14729@netbook.cypherspace.org>
Message-ID: <20130620074830.GA21724@crunch>

On Wed, Jun 19, 2013 at 05:28:15PM +0200, Adam Back wrote:
> I think Timo's point is that while you cant do discrete log, you can do y-th
> root.  So if P = xG is a parent public key (x private key, G base point),
> then your proposed multiplier address is hash of Q=yP.  However its easy to
> find another P such that Q=zP'.  ie just "divide by z" (EC multiply by z^-1
> mod n, n the order of the curve).  So P'=z^-1.Q, which will work because
> Q=zP', substituting P' you get Q=z.z^-1.Q, Q=Q.
> 
> Of course the attacker has just performed an unspenable DoS (maybe, or maybe
> a useless collision) because he wont know the discrete log of Q, nor P, nor
> P'.  So thats the question, does the protocol have any reliance on knowing
> the discrete log - is it a problem if someone can find different multipliers
> of different (unknown, uncomputable discrete log) parent keys.
> 
> If it was a concern I guess you could require a proof of knowledge of
> discrete log.  ie as well as public key parent, multiplier the address must
> include ECDSA sig or Schnorr proof of knowledge (which both demonstrate
> knowledge of the discrete log of Q to base G.)

The "concern" (if there is any) would be that the owner of the parent
P=xG, i.e. the person knowing x, in addition to y creates another pair
(P',z) such that yP=Q=zP' and uses that second pair maliciously later on
(such as claiming the payment went to identity P' not P). Since the
owner of P knows the private key for P' (x*y*z^-1) he can also produce
proof of knowledge for discrete log for P'. I think adding proof of
knowledge or signatures on the multiplier don't help to eliminate all
possible concerns, which could involve proving something to a third
party that has not seen the communication between payer and payee. 

If you consider only payer and payee then Alan's original proposal is
just fine, as far as I can tell. Only if you start using it in a payment
protocol or, more precisely, if you start interpreting P as an identity
(as Alan suggested in subsequent posts) _and_ this identity is a
public/global one rather than a local one that only the payer uses, then
reasons can pop up to eliminate ambiguity about which identity each
payment went to.

Timo

ps the fact that this post used the multiplicative rather than additive
derivation scheme doesn't change the argument.

-- 
Timo Hanke
PGP 1EFF 69BC 6FB7 8744 14DB  631D 1BB5 D6E3 AB96 7DA8



From tamas at bitsofproof.com  Thu Jun 20 08:17:04 2013
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Thu, 20 Jun 2013 10:17:04 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
Message-ID: <E9A1F9E4-0A9A-4B5F-98D2-585306EB99AA@bitsofproof.com>

I agree that this can be deferred until there is an actual new field without any harm. But then remember to update the BIP37 too saying that it is optional only if flag added in BIPXX is not present.

Your argument is that this complexity is already there so why not preserve it. I think eliminating complexity (that has no benefit) strengthens the system.

Tam?s Blummer
http://bitsofproof.com

On 20.06.2013, at 09:36, Mike Hearn <mike at plan99.net> wrote:

> Sure but why not do that when there's an actual new field to add? Does anyone have a proposal for a feature that needs a new version field at the moment? There's no point changing the protocol now unless there's actually a new field to add.
> 
> Anyway I still don't see why anyone cares about this issue. The Bitcoin protocol does not and never has required that all messages have a fixed number of fields per version. Any parser written on the assumption it did was just buggy. Look at how tx messages are relayed for the most obvious example of that pattern in action - it's actually the raw byte stream that's stored and relayed to ensure that fields added in new versions aren't dropped during round-tripping. Old versions are supposed to preserve fields from the future.
> 
> 
> 
> On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com> wrote:
> Hi Mike,
> 
> The issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.
> If there will be further fields they will become manadory. 
>  
> Why not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner
> going forward.
> 
> Tamas Blummer
> http://bitsofproof.com
> 
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/b1e7c9e1/attachment.html>

From mike at plan99.net  Thu Jun 20 08:31:34 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 10:31:34 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <E9A1F9E4-0A9A-4B5F-98D2-585306EB99AA@bitsofproof.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<E9A1F9E4-0A9A-4B5F-98D2-585306EB99AA@bitsofproof.com>
Message-ID: <CANEZrP1rK3z5LXd+q-SRd3pzP5QLoJSL=CMPviH4fFVGKWT69g@mail.gmail.com>

You can't eliminate the complexity (yet), otherwise you wouldn't be able to
talk to old nodes. You'll have to wait until versions prior to a particular
version are hard-forked off and can be safely dropped at connect time.

That said the reason I'm being so grumpy about this is that compared to the
complexity in the rest of the system, this is such a trivial and minor
detail. It's hardly even worth thinking about. I mean, we have a scripting
language full of opcodes nobody ever figured out how to use and the
protocol uses a mixture of byte orders, so an optional field in the version
message is really not such a big deal :)


On Thu, Jun 20, 2013 at 10:17 AM, Tamas Blummer <tamas at bitsofproof.com>wrote:

> I agree that this can be deferred until there is an actual new field
> without any harm. But then remember to update the BIP37 too saying that it
> is optional only if flag added in BIPXX is not present.
>
> Your argument is that this complexity is already there so why not preserve
> it. I think eliminating complexity (that has no benefit) strengthens the
> system.
>
> *Tam?s Blummer*
> http://bitsofproof.com
>  <http://bitsofproof.com/>
>
> On 20.06.2013, at 09:36, Mike Hearn <mike at plan99.net> wrote:
>
> Sure but why not do that when there's an actual new field to add? Does
> anyone have a proposal for a feature that needs a new version field at the
> moment? There's no point changing the protocol now unless there's actually
> a new field to add.
>
> Anyway I still don't see why anyone cares about this issue. The Bitcoin
> protocol does not and never has required that all messages have a fixed
> number of fields per version. Any parser written on the assumption it did
> was just buggy. Look at how tx messages are relayed for the most obvious
> example of that pattern in action - it's actually the raw byte stream
> that's stored and relayed to ensure that fields added in new versions
> aren't dropped during round-tripping. Old versions are supposed to preserve
> fields from the future.
>
>
>
> On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com>wrote:
>
>>  Hi Mike,
>>
>> The issue with the current parser is that those fields are conditionally
>> optional on that there will be no subsequent fields added.
>> If there will be further fields they will become manadory.
>>
>> Why not bump the version and parse the fields as mandatory from then on?
>> This would be backward compatible and cleaner
>> going forward.
>>
>> Tamas Blummer
>> http://bitsofproof.com
>>  <http://bitsofproof.com/>
>>
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/561ebbf1/attachment.html>

From tamas at bitsofproof.com  Thu Jun 20 08:39:10 2013
From: tamas at bitsofproof.com (Tamas Blummer)
Date: Thu, 20 Jun 2013 10:39:10 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <CANEZrP1rK3z5LXd+q-SRd3pzP5QLoJSL=CMPviH4fFVGKWT69g@mail.gmail.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<E9A1F9E4-0A9A-4B5F-98D2-585306EB99AA@bitsofproof.com>
	<CANEZrP1rK3z5LXd+q-SRd3pzP5QLoJSL=CMPviH4fFVGKWT69g@mail.gmail.com>
Message-ID: <84938F7F-B75C-434B-9B7A-EC406CE42385@bitsofproof.com>

Yes it is trivial. I do not think greater complexity in the system should keep us from addressing low complexity issues.
You can't blame me or others not trying to simplify scripts, if there is such a headwind simplifying a version message.
You are right there is too much fuss about this.

Tam?s Blummer
Founder, CEO
http://bitsofproof.com

On 20.06.2013, at 10:31, Mike Hearn <mike at plan99.net> wrote:

> You can't eliminate the complexity (yet), otherwise you wouldn't be able to talk to old nodes. You'll have to wait until versions prior to a particular version are hard-forked off and can be safely dropped at connect time.
> 
> That said the reason I'm being so grumpy about this is that compared to the complexity in the rest of the system, this is such a trivial and minor detail. It's hardly even worth thinking about. I mean, we have a scripting language full of opcodes nobody ever figured out how to use and the protocol uses a mixture of byte orders, so an optional field in the version message is really not such a big deal :)
> 
> 
> On Thu, Jun 20, 2013 at 10:17 AM, Tamas Blummer <tamas at bitsofproof.com> wrote:
> I agree that this can be deferred until there is an actual new field without any harm. But then remember to update the BIP37 too saying that it is optional only if flag added in BIPXX is not present.
> 
> Your argument is that this complexity is already there so why not preserve it. I think eliminating complexity (that has no benefit) strengthens the system.
> 
> Tam?s Blummer
> http://bitsofproof.com
> 
> On 20.06.2013, at 09:36, Mike Hearn <mike at plan99.net> wrote:
> 
>> Sure but why not do that when there's an actual new field to add? Does anyone have a proposal for a feature that needs a new version field at the moment? There's no point changing the protocol now unless there's actually a new field to add.
>> 
>> Anyway I still don't see why anyone cares about this issue. The Bitcoin protocol does not and never has required that all messages have a fixed number of fields per version. Any parser written on the assumption it did was just buggy. Look at how tx messages are relayed for the most obvious example of that pattern in action - it's actually the raw byte stream that's stored and relayed to ensure that fields added in new versions aren't dropped during round-tripping. Old versions are supposed to preserve fields from the future.
>> 
>> 
>> 
>> On Thu, Jun 20, 2013 at 9:30 AM, Tamas Blummer <tamas at bitsofproof.com> wrote:
>> Hi Mike,
>> 
>> The issue with the current parser is that those fields are conditionally optional on that there will be no subsequent fields added.
>> If there will be further fields they will become manadory. 
>>  
>> Why not bump the version and parse the fields as mandatory from then on? This would be backward compatible and cleaner
>> going forward.
>> 
>> Tamas Blummer
>> http://bitsofproof.com
>> 
>> 
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>> 
>> Build for Windows Store.
>> 
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>> 
>> 
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/652c48ba/attachment.html>

From pieter.wuille at gmail.com  Thu Jun 20 09:06:50 2013
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 20 Jun 2013 11:06:50 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
Message-ID: <20130620090649.GA17765@vps7135.xlshosting.net>

On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:
> Sure but why not do that when there's an actual new field to add? Does
> anyone have a proposal for a feature that needs a new version field at the
> moment? There's no point changing the protocol now unless there's actually
> a new field to add.
> 
> Anyway I still don't see why anyone cares about this issue. The Bitcoin
> protocol does not and never has required that all messages have a fixed
> number of fields per version. Any parser written on the assumption it did
> was just buggy. Look at how tx messages are relayed for the most obvious
> example of that pattern in action - it's actually the raw byte stream
> that's stored and relayed to ensure that fields added in new versions
> aren't dropped during round-tripping. Old versions are supposed to preserve
> fields from the future.

Actually, that is not the same issue. What is being argued for here is that
the version in the version message itself should indicate which fields are
present, so a parser doesn't need to look at the length of the message. That
seems like a minor but very reasonable request to me, and it's trivial to do.
That doesn't mean that you may receive versions higher than what you know of,
and thus messages with fields you don't know about. That doesn't matter, you
can just ignore them.

I see no problem with raising the protocol version number to indicate
"all fields up to fRelayTxes are required, if the announced nVersion is above N".
In fact, I believe (though haven't checked) all previous additions to the version
message were accompanied with a protocol version (then: client version) increase
as well.

-- 
Pieter




From jeremy at taplink.co  Thu Jun 20 09:10:26 2013
From: jeremy at taplink.co (Jeremy Spilman)
Date: Thu, 20 Jun 2013 02:10:26 -0700
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <20130620074830.GA21724@crunch>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
	<20130619152815.GA14729@netbook.cypherspace.org>
	<20130620074830.GA21724@crunch>
Message-ID: <66577F722D29461D8651DF1D0684AAE1@LAPTOPAIR>

> which could involve proving something to a third party that has not seen 
> the communication between payer and payee.

OK - I think I follow now.  So a third-party who does not see any of the 
communication between the payer and payee only knows the HASH160.  Let's say 
the payee denies receipt of the funds....

It's easy to prove what public key it was sent to (it's the preimage), but 
you can't prove the parent of that public key. You can provide any number of 
ParentPubKey * Multiplier that could have been used, so the 3rd party is 
unconvinced by a "matching" ParentPubKey * Multiplier.

However, if you calculated the destination using: PubKeyParent * 
HMAC(Multiplier,PubKeyParent) as Timo said, now if you give the 3rd party a 
PubKeyParent and Multiplier (or Addend) that produces the destination 
address, you've proven the payment is in fact spendable by PubKeyParent, and 
they can't deny receipt. Very cool.

Sorry for "echoing" this back, it took me a little while to work it out, so 
I thought I'd write it down. Hope I got it right...

If you give {PubKey, ChainCode} you do get this feature. If you give 
{ParentPubKey, Addend} or {ParentPubKey, Addend, ChainCode} you're back to 
having plausible deniability.

If BIP32's CKD'((Kpar, cpar), i) was actually HMAC(HMAC(cpar, i), Kpar) you 
could give HMAC(cpar, i) instead of Addend, and then you would get this 
feature; a way to 'skip down' a level in the wallet hierarchy, keep the 
'chain of custody' so to speak back to the ParentPubKey intact, without 
having to disclose the ChainCode. Meh...

Thanks,
--Jeremy






From mike at plan99.net  Thu Jun 20 09:17:11 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 11:17:11 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <20130620090649.GA17765@vps7135.xlshosting.net>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<20130620090649.GA17765@vps7135.xlshosting.net>
Message-ID: <CANEZrP2cLR9sYZ59O-S6HNi9bKPtaY5yOkvVx+O8XAC792acZg@mail.gmail.com>

There's no problem, but there's no benefit either. It also locks us in to a
potentially problematic guarantee - what if in future we want to have, say,
two optional new pieces of data in two different messages. We don't want to
require that if version > X then you have to implement all features up to
and including that point.

Essentially the number of fields in a message is like a little version
number, just for that message. It adds flexibility to keep it that way, and
there's no downside, seeing as that bridge was already crossed and people
with parsers that can't handle it need to fix their code anyway.

So I have a slight preference for keeping things the way they are, it keeps
things flexible for future and costs nothing.



On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:

> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:
> > Sure but why not do that when there's an actual new field to add? Does
> > anyone have a proposal for a feature that needs a new version field at
> the
> > moment? There's no point changing the protocol now unless there's
> actually
> > a new field to add.
> >
> > Anyway I still don't see why anyone cares about this issue. The Bitcoin
> > protocol does not and never has required that all messages have a fixed
> > number of fields per version. Any parser written on the assumption it did
> > was just buggy. Look at how tx messages are relayed for the most obvious
> > example of that pattern in action - it's actually the raw byte stream
> > that's stored and relayed to ensure that fields added in new versions
> > aren't dropped during round-tripping. Old versions are supposed to
> preserve
> > fields from the future.
>
> Actually, that is not the same issue. What is being argued for here is that
> the version in the version message itself should indicate which fields are
> present, so a parser doesn't need to look at the length of the message.
> That
> seems like a minor but very reasonable request to me, and it's trivial to
> do.
> That doesn't mean that you may receive versions higher than what you know
> of,
> and thus messages with fields you don't know about. That doesn't matter,
> you
> can just ignore them.
>
> I see no problem with raising the protocol version number to indicate
> "all fields up to fRelayTxes are required, if the announced nVersion is
> above N".
> In fact, I believe (though haven't checked) all previous additions to the
> version
> message were accompanied with a protocol version (then: client version)
> increase
> as well.
>
> --
> Pieter
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/038a834a/attachment.html>

From turkeybreast at yahoo.com  Thu Jun 20 10:37:05 2013
From: turkeybreast at yahoo.com (Turkey Breast)
Date: Thu, 20 Jun 2013 03:37:05 -0700 (PDT)
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <CANEZrP2cLR9sYZ59O-S6HNi9bKPtaY5yOkvVx+O8XAC792acZg@mail.gmail.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<20130620090649.GA17765@vps7135.xlshosting.net>
	<CANEZrP2cLR9sYZ59O-S6HNi9bKPtaY5yOkvVx+O8XAC792acZg@mail.gmail.com>
Message-ID: <1371724625.50978.YahooMailNeo@web162706.mail.bf1.yahoo.com>

I don't get why this is such a contentious change?

Before I was able to use asserts to check the expected length of length of messages per protocol version, I could pass in dumb iterators that just parse the byte stream and I could serialize and deserialize a message to check the parser is correct (in debug mode).

This 'simple' change causes all that behaviour to be lost. You can no longer just use iterators but must know the remaining length (or if you use std::distance, you can only use specific std containers - not just anything with an iterator and an operator++). You cannot check the deserialization process by serializing the deserialized message and comparing it to the original data (because the bool is always present in the serializer).

It's a bit stupid you call it buggy code when this behaviour has never been present in Bitcoin. The BIP doesn't introduce any unwanted side-effects and is a trivial reasonable change.

If you want optional fields then the proper way to do it, is to either set a flag in the Services field of the "version" message to indicate different formats for messages (i.e use this template structure for a message, not that one), introduce a new message (if the changes are big), to approve/improve Stefan's BIP 32 for custom services or to have a value in the byte stream indicating which fields are present (maybe a bitfield or so).

Using a quirk of an implementation is just bad form and sloppy coding. Optional fields should have their own mechanism that allows them to remain as optional fields between protocol version upgrades.


The bitcoind software can probably be improved too, by checking that the length of the version message is consistent for the protocol version given by the connected node. Right now it makes no assumptions based on that which is a mistake (new clients can broadcast older version messages that don't have all the fields required). Probably the software should penalise hosts which do that.

What's the big deal to update the protocol version number from 70001 to 70002? It's not like we'll run out of integers. The field has now gone from optional to required now anyway - that's a behaviour change. It'd be good to enforce that. I see this as a bug.



________________________________
 From: Mike Hearn <mike at plan99.net>
To: Pieter Wuille <pieter.wuille at gmail.com> 
Cc: Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas Blummer <tamas at bitsofproof.com> 
Sent: Thursday, June 20, 2013 11:17 AM
Subject: Re: [Bitcoin-development] Missing fRelayTxes in version
 


There's no problem, but there's no benefit either. It also locks us in to a potentially problematic guarantee - what if in future we want to have, say, two optional new pieces of data in two different messages. We don't want to require that if version > X then you have to implement all features up to and including that point.

Essentially the number of fields in a message is like a little version number, just for that message. It adds flexibility to keep it that way, and there's no downside, seeing as that bridge was already crossed and people with parsers that can't handle it need to fix their code anyway.

So I have a slight preference for keeping things the way they are, it keeps things flexible for future and costs nothing.




On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:

On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:
>> Sure but why not do that when there's an actual new field to add? Does
>> anyone have a proposal for a feature that needs a new version field at the
>> moment? There's no point changing the protocol now unless there's actually
>> a new field to add.
>>
>> Anyway I still don't see why anyone cares about this issue. The Bitcoin
>> protocol does not and never has required that all messages have a fixed
>> number of fields per version. Any parser written on the assumption it did
>> was just buggy. Look at how tx messages are relayed for the most obvious
>> example of that pattern in action - it's actually the raw byte stream
>> that's stored and relayed to ensure that fields added in new versions
>> aren't dropped during round-tripping. Old versions are supposed to preserve
>> fields from the future.
>
>Actually, that is not the same issue. What is being argued for here is that
>the version in the version message itself should indicate which fields are
>present, so a parser doesn't need to look at the length of the message. That
>seems like a minor but very reasonable request to me, and it's trivial to do.
>That doesn't mean that you may receive versions higher than what you know of,
>and thus messages with fields you don't know about. That doesn't matter, you
>can just ignore them.
>
>I see no problem with raising the protocol version number to indicate
>"all fields up to fRelayTxes are required, if the announced nVersion is above N".
>In fact, I believe (though haven't checked) all previous additions to the version
>message were accompanied with a protocol version (then: client version) increase
>as well.
>
>--
>Pieter
>
>

------------------------------------------------------------------------------
This SF.net email is sponsored by Windows:

Build for Windows Store.

http://p.sf.net/sfu/windows-dev2dev
_______________________________________________
Bitcoin-development mailing list
Bitcoin-development at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/bitcoin-development
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/0b45aac2/attachment.html>

From mike at plan99.net  Thu Jun 20 10:50:28 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 12:50:28 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <1371724625.50978.YahooMailNeo@web162706.mail.bf1.yahoo.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<20130620090649.GA17765@vps7135.xlshosting.net>
	<CANEZrP2cLR9sYZ59O-S6HNi9bKPtaY5yOkvVx+O8XAC792acZg@mail.gmail.com>
	<1371724625.50978.YahooMailNeo@web162706.mail.bf1.yahoo.com>
Message-ID: <CANEZrP2aOUEqG_+AHsVp52d-815k04f6fXvnnq1qQAVN+jNRZw@mail.gmail.com>

Sure, the issue isn't running out of integers, it's that you have to handle
the case of truncated messages whether you like it or not so it doesn't add
any simplicity. Even if Bitcoin-Qt starts only sending the new field with a
new version number, there are tens of thousands of bitcoinj based wallets
out there now that send the current version number and the fRelayTx field
as well, so you cannot assume anything about whether the field will exist
or not based on the version number regardless of what is changed on the C++
side. Assuming you care about your code being able to serve Bloom-filtering
clients of course.

With regards to relying on quirks, etc, this is the old "is the protocol
defined by Satoshi's code" debate again ... as I said, version messages
have always had a variable number of fields. You didn't notice before
because it was a long time since any fields were added. Perhaps it's indeed
not ideal, perhaps if Bitcoin was designed in 2013 it'd be using protobufs
or some other pre-packaged serialization system. But it is what it is.



On Thu, Jun 20, 2013 at 12:37 PM, Turkey Breast <turkeybreast at yahoo.com>wrote:

> I don't get why this is such a contentious change?
>
> Before I was able to use asserts to check the expected length of length of
> messages per protocol version, I could pass in dumb iterators that just
> parse the byte stream and I could serialize and deserialize a message to
> check the parser is correct (in debug mode).
>
> This 'simple' change causes all that behaviour to be lost. You can no
> longer just use iterators but must know the remaining length (or if you use
> std::distance, you can only use specific std containers - not just anything
> with an iterator and an operator++). You cannot check the deserialization
> process by serializing the deserialized message and comparing it to the
> original data (because the bool is always present in the serializer).
>
> It's a bit stupid you call it buggy code when this behaviour has never
> been present in Bitcoin. The BIP doesn't introduce any unwanted
> side-effects and is a trivial reasonable change.
>
> If you want optional fields then the proper way to do it, is to either set
> a flag in the Services field of the "version" message to indicate different
> formats for messages (i.e use this template structure for a message, not
> that one), introduce a new message (if the changes are big), to
> approve/improve Stefan's BIP 32 for custom services or to have a value in
> the byte stream indicating which fields are present (maybe a bitfield or
> so).
>
> Using a quirk of an implementation is just bad form and sloppy coding.
> Optional fields should have their own mechanism that allows them to remain
> as optional fields between protocol version upgrades.
>
> The bitcoind software can probably be improved too, by checking that the
> length of the version message is consistent for the protocol version given
> by the connected node. Right now it makes no assumptions based on that
> which is a mistake (new clients can broadcast older version messages that
> don't have all the fields required). Probably the software should penalise
> hosts which do that.
>
> What's the big deal to update the protocol version number from 70001 to
> 70002? It's not like we'll run out of integers. The field has now gone from
> optional to required now anyway - that's a behaviour change. It'd be good
> to enforce that. I see this as a bug.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Pieter Wuille <pieter.wuille at gmail.com>
> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas
> Blummer <tamas at bitsofproof.com>
> *Sent:* Thursday, June 20, 2013 11:17 AM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version
>
> There's no problem, but there's no benefit either. It also locks us in to
> a potentially problematic guarantee - what if in future we want to have,
> say, two optional new pieces of data in two different messages. We don't
> want to require that if version > X then you have to implement all features
> up to and including that point.
>
> Essentially the number of fields in a message is like a little version
> number, just for that message. It adds flexibility to keep it that way, and
> there's no downside, seeing as that bridge was already crossed and people
> with parsers that can't handle it need to fix their code anyway.
>
> So I have a slight preference for keeping things the way they are, it
> keeps things flexible for future and costs nothing.
>
>
>
> On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:
>
> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:
> > Sure but why not do that when there's an actual new field to add? Does
> > anyone have a proposal for a feature that needs a new version field at
> the
> > moment? There's no point changing the protocol now unless there's
> actually
> > a new field to add.
> >
> > Anyway I still don't see why anyone cares about this issue. The Bitcoin
> > protocol does not and never has required that all messages have a fixed
> > number of fields per version. Any parser written on the assumption it did
> > was just buggy. Look at how tx messages are relayed for the most obvious
> > example of that pattern in action - it's actually the raw byte stream
> > that's stored and relayed to ensure that fields added in new versions
> > aren't dropped during round-tripping. Old versions are supposed to
> preserve
> > fields from the future.
>
> Actually, that is not the same issue. What is being argued for here is that
> the version in the version message itself should indicate which fields are
> present, so a parser doesn't need to look at the length of the message.
> That
> seems like a minor but very reasonable request to me, and it's trivial to
> do.
> That doesn't mean that you may receive versions higher than what you know
> of,
> and thus messages with fields you don't know about. That doesn't matter,
> you
> can just ignore them.
>
> I see no problem with raising the protocol version number to indicate
> "all fields up to fRelayTxes are required, if the announced nVersion is
> above N".
> In fact, I believe (though haven't checked) all previous additions to the
> version
> message were accompanied with a protocol version (then: client version)
> increase
> as well.
>
> --
> Pieter
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/3bc5a976/attachment.html>

From pieter.wuille at gmail.com  Thu Jun 20 10:52:51 2013
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 20 Jun 2013 12:52:51 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <1371724625.50978.YahooMailNeo@web162706.mail.bf1.yahoo.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<20130620090649.GA17765@vps7135.xlshosting.net>
	<CANEZrP2cLR9sYZ59O-S6HNi9bKPtaY5yOkvVx+O8XAC792acZg@mail.gmail.com>
	<1371724625.50978.YahooMailNeo@web162706.mail.bf1.yahoo.com>
Message-ID: <CAPg+sBiJvWckJYa-iw=qtjfj1PoY_bKhFD3sx6LqfUrFbWrGHA@mail.gmail.com>

Let's just increase the version number and be done with this discussion.
It's a small benefit, but it simplifies things and it's trivial to do.

I don't understand how a policy of requiring version increases could limit
future extensions: after the version/verack exchange, the protocol version
is negotiated between peers, and there is no need for anything optional
anymore.

Note thay this is just about parsing, not about relaying - you should still
relay parts of a message you haven't parsed. But that doesn't apply to the
version message anyway, which is the only place where this matters.

-- 
Pieter
 On 20 Jun 2013 12:38, "Turkey Breast" <turkeybreast at yahoo.com> wrote:

> I don't get why this is such a contentious change?
>
> Before I was able to use asserts to check the expected length of length of
> messages per protocol version, I could pass in dumb iterators that just
> parse the byte stream and I could serialize and deserialize a message to
> check the parser is correct (in debug mode).
>
> This 'simple' change causes all that behaviour to be lost. You can no
> longer just use iterators but must know the remaining length (or if you use
> std::distance, you can only use specific std containers - not just anything
> with an iterator and an operator++). You cannot check the deserialization
> process by serializing the deserialized message and comparing it to the
> original data (because the bool is always present in the serializer).
>
> It's a bit stupid you call it buggy code when this behaviour has never
> been present in Bitcoin. The BIP doesn't introduce any unwanted
> side-effects and is a trivial reasonable change.
>
> If you want optional fields then the proper way to do it, is to either set
> a flag in the Services field of the "version" message to indicate different
> formats for messages (i.e use this template structure for a message, not
> that one), introduce a new message (if the changes are big), to
> approve/improve Stefan's BIP 32 for custom services or to have a value in
> the byte stream indicating which fields are present (maybe a bitfield or
> so).
>
> Using a quirk of an implementation is just bad form and sloppy coding.
> Optional fields should have their own mechanism that allows them to remain
> as optional fields between protocol version upgrades.
>
> The bitcoind software can probably be improved too, by checking that the
> length of the version message is consistent for the protocol version given
> by the connected node. Right now it makes no assumptions based on that
> which is a mistake (new clients can broadcast older version messages that
> don't have all the fields required). Probably the software should penalise
> hosts which do that.
>
> What's the big deal to update the protocol version number from 70001 to
> 70002? It's not like we'll run out of integers. The field has now gone from
> optional to required now anyway - that's a behaviour change. It'd be good
> to enforce that. I see this as a bug.
>
>   ------------------------------
>  *From:* Mike Hearn <mike at plan99.net>
> *To:* Pieter Wuille <pieter.wuille at gmail.com>
> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas
> Blummer <tamas at bitsofproof.com>
> *Sent:* Thursday, June 20, 2013 11:17 AM
> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version
>
> There's no problem, but there's no benefit either. It also locks us in to
> a potentially problematic guarantee - what if in future we want to have,
> say, two optional new pieces of data in two different messages. We don't
> want to require that if version > X then you have to implement all features
> up to and including that point.
>
> Essentially the number of fields in a message is like a little version
> number, just for that message. It adds flexibility to keep it that way, and
> there's no downside, seeing as that bridge was already crossed and people
> with parsers that can't handle it need to fix their code anyway.
>
> So I have a slight preference for keeping things the way they are, it
> keeps things flexible for future and costs nothing.
>
>
>
> On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:
>
> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:
> > Sure but why not do that when there's an actual new field to add? Does
> > anyone have a proposal for a feature that needs a new version field at
> the
> > moment? There's no point changing the protocol now unless there's
> actually
> > a new field to add.
> >
> > Anyway I still don't see why anyone cares about this issue. The Bitcoin
> > protocol does not and never has required that all messages have a fixed
> > number of fields per version. Any parser written on the assumption it did
> > was just buggy. Look at how tx messages are relayed for the most obvious
> > example of that pattern in action - it's actually the raw byte stream
> > that's stored and relayed to ensure that fields added in new versions
> > aren't dropped during round-tripping. Old versions are supposed to
> preserve
> > fields from the future.
>
> Actually, that is not the same issue. What is being argued for here is that
> the version in the version message itself should indicate which fields are
> present, so a parser doesn't need to look at the length of the message.
> That
> seems like a minor but very reasonable request to me, and it's trivial to
> do.
> That doesn't mean that you may receive versions higher than what you know
> of,
> and thus messages with fields you don't know about. That doesn't matter,
> you
> can just ignore them.
>
> I see no problem with raising the protocol version number to indicate
> "all fields up to fRelayTxes are required, if the announced nVersion is
> above N".
> In fact, I believe (though haven't checked) all previous additions to the
> version
> message were accompanied with a protocol version (then: client version)
> increase
> as well.
>
> --
> Pieter
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/de57996b/attachment.html>

From mike at plan99.net  Thu Jun 20 10:58:31 2013
From: mike at plan99.net (Mike Hearn)
Date: Thu, 20 Jun 2013 12:58:31 +0200
Subject: [Bitcoin-development] Missing fRelayTxes in version
In-Reply-To: <CAPg+sBiJvWckJYa-iw=qtjfj1PoY_bKhFD3sx6LqfUrFbWrGHA@mail.gmail.com>
References: <4DE0E45E-BB48-4DFF-9C86-ACBE312B3049@bitsofproof.com>
	<CANEZrP1MVKSNU92UrQ36sPCN0LNLKrVRXnfVwEZKhgoBFXatBA@mail.gmail.com>
	<20130620090649.GA17765@vps7135.xlshosting.net>
	<CANEZrP2cLR9sYZ59O-S6HNi9bKPtaY5yOkvVx+O8XAC792acZg@mail.gmail.com>
	<1371724625.50978.YahooMailNeo@web162706.mail.bf1.yahoo.com>
	<CAPg+sBiJvWckJYa-iw=qtjfj1PoY_bKhFD3sx6LqfUrFbWrGHA@mail.gmail.com>
Message-ID: <CANEZrP3HM9j9XuieaccGy5nQ78F-2QR_s4avcbicGaKHG1=69Q@mail.gmail.com>

As I said, there's no benefit. Even if we do that on the C++ side, you
still have to handle connections from bitcoinj clients which will send the
field with the old version number. You can't assume they'll all be updated
simultaneously, even though both the Android app and MultiBit do have
update notifications these days and eventually old versions will presumably
disappear.

Re: flexibility. Let's say version V+1 adds a complicated new set of data
to some messages. Not every client wants or needs the feature enabled by
them.

Now version V+2 adds a simple extension to a basic message that everyone
wants/needs.

To get the latter feature, all clients now have to support the first
feature as well because the version number is monotonic.

OK, we can use a service bit to handle these cases, if we anticipate that
not all clients will want the first feature. But then again, we can also
use the presence of the additional data as the ground truth instead of
duplicating that fact. I don't really mind either way. It just seems that
parsing always requires you to be able to handle truncated messages anyway
(without asserting or crashing), because a bogus client can always send you
partial data. So I don't see what effort is saved.



On Thu, Jun 20, 2013 at 12:52 PM, Pieter Wuille <pieter.wuille at gmail.com>wrote:

> Let's just increase the version number and be done with this discussion.
> It's a small benefit, but it simplifies things and it's trivial to do.
>
> I don't understand how a policy of requiring version increases could limit
> future extensions: after the version/verack exchange, the protocol version
> is negotiated between peers, and there is no need for anything optional
> anymore.
>
> Note thay this is just about parsing, not about relaying - you should
> still relay parts of a message you haven't parsed. But that doesn't apply
> to the version message anyway, which is the only place where this matters.
>
> --
> Pieter
>  On 20 Jun 2013 12:38, "Turkey Breast" <turkeybreast at yahoo.com> wrote:
>
>> I don't get why this is such a contentious change?
>>
>> Before I was able to use asserts to check the expected length of length
>> of messages per protocol version, I could pass in dumb iterators that just
>> parse the byte stream and I could serialize and deserialize a message to
>> check the parser is correct (in debug mode).
>>
>> This 'simple' change causes all that behaviour to be lost. You can no
>> longer just use iterators but must know the remaining length (or if you use
>> std::distance, you can only use specific std containers - not just anything
>> with an iterator and an operator++). You cannot check the deserialization
>> process by serializing the deserialized message and comparing it to the
>> original data (because the bool is always present in the serializer).
>>
>> It's a bit stupid you call it buggy code when this behaviour has never
>> been present in Bitcoin. The BIP doesn't introduce any unwanted
>> side-effects and is a trivial reasonable change.
>>
>> If you want optional fields then the proper way to do it, is to either
>> set a flag in the Services field of the "version" message to indicate
>> different formats for messages (i.e use this template structure for a
>> message, not that one), introduce a new message (if the changes are big),
>> to approve/improve Stefan's BIP 32 for custom services or to have a value
>> in the byte stream indicating which fields are present (maybe a bitfield or
>> so).
>>
>> Using a quirk of an implementation is just bad form and sloppy coding.
>> Optional fields should have their own mechanism that allows them to remain
>> as optional fields between protocol version upgrades.
>>
>> The bitcoind software can probably be improved too, by checking that the
>> length of the version message is consistent for the protocol version given
>> by the connected node. Right now it makes no assumptions based on that
>> which is a mistake (new clients can broadcast older version messages that
>> don't have all the fields required). Probably the software should penalise
>> hosts which do that.
>>
>> What's the big deal to update the protocol version number from 70001 to
>> 70002? It's not like we'll run out of integers. The field has now gone from
>> optional to required now anyway - that's a behaviour change. It'd be good
>> to enforce that. I see this as a bug.
>>
>>   ------------------------------
>>  *From:* Mike Hearn <mike at plan99.net>
>> *To:* Pieter Wuille <pieter.wuille at gmail.com>
>> *Cc:* Bitcoin Dev <bitcoin-development at lists.sourceforge.net>; Tamas
>> Blummer <tamas at bitsofproof.com>
>> *Sent:* Thursday, June 20, 2013 11:17 AM
>> *Subject:* Re: [Bitcoin-development] Missing fRelayTxes in version
>>
>> There's no problem, but there's no benefit either. It also locks us in to
>> a potentially problematic guarantee - what if in future we want to have,
>> say, two optional new pieces of data in two different messages. We don't
>> want to require that if version > X then you have to implement all features
>> up to and including that point.
>>
>> Essentially the number of fields in a message is like a little version
>> number, just for that message. It adds flexibility to keep it that way, and
>> there's no downside, seeing as that bridge was already crossed and people
>> with parsers that can't handle it need to fix their code anyway.
>>
>> So I have a slight preference for keeping things the way they are, it
>> keeps things flexible for future and costs nothing.
>>
>>
>>
>> On Thu, Jun 20, 2013 at 11:06 AM, Pieter Wuille <pieter.wuille at gmail.com>wrote:
>>
>> On Thu, Jun 20, 2013 at 09:36:40AM +0200, Mike Hearn wrote:
>> > Sure but why not do that when there's an actual new field to add? Does
>> > anyone have a proposal for a feature that needs a new version field at
>> the
>> > moment? There's no point changing the protocol now unless there's
>> actually
>> > a new field to add.
>> >
>> > Anyway I still don't see why anyone cares about this issue. The Bitcoin
>> > protocol does not and never has required that all messages have a fixed
>> > number of fields per version. Any parser written on the assumption it
>> did
>> > was just buggy. Look at how tx messages are relayed for the most obvious
>> > example of that pattern in action - it's actually the raw byte stream
>> > that's stored and relayed to ensure that fields added in new versions
>> > aren't dropped during round-tripping. Old versions are supposed to
>> preserve
>> > fields from the future.
>>
>> Actually, that is not the same issue. What is being argued for here is
>> that
>> the version in the version message itself should indicate which fields are
>> present, so a parser doesn't need to look at the length of the message.
>> That
>> seems like a minor but very reasonable request to me, and it's trivial to
>> do.
>> That doesn't mean that you may receive versions higher than what you know
>> of,
>> and thus messages with fields you don't know about. That doesn't matter,
>> you
>> can just ignore them.
>>
>> I see no problem with raising the protocol version number to indicate
>> "all fields up to fRelayTxes are required, if the announced nVersion is
>> above N".
>> In fact, I believe (though haven't checked) all previous additions to the
>> version
>> message were accompanied with a protocol version (then: client version)
>> increase
>> as well.
>>
>> --
>> Pieter
>>
>>
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/64e336a0/attachment.html>

From jgarzik at bitpay.com  Thu Jun 20 13:35:11 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Thu, 20 Jun 2013 09:35:11 -0400
Subject: [Bitcoin-development] Missing fRelayTxes in version message
In-Reply-To: <CAA3bHnzrRijieFi5phXZfuHEU3eLrPcVJwXuPpUrepWCY7coQQ@mail.gmail.com>
References: <BLU404-EAS74077C5D43EACD319CCA3DA58D0@phx.gbl>
	<CANEZrP0Pr=_L7CA4hdt9esVCHqf-EOjfDjnVrw8rFxL1OtUw7A@mail.gmail.com>
	<1371709237.57104.YahooMailNeo@web162701.mail.bf1.yahoo.com>
	<CAA3bHnzrRijieFi5phXZfuHEU3eLrPcVJwXuPpUrepWCY7coQQ@mail.gmail.com>
Message-ID: <CAJHLa0MrG3wkfQMRoeTp5nOwAcpLOVKd+c96NozTz=w3-0g4Jg@mail.gmail.com>

On Thu, Jun 20, 2013 at 3:13 AM, Addy Yeow <ayeowch at gmail.com> wrote:
> I personally don't treat the relay field as optional, i.e. it is there as
> 0x01 if it is set. Otherwise, it is simply a trailing zero byte. Hence, the
> right way of reading the packet as with any network packet is to first
> retrieve the header information, get the actual payload length, then parse
> the payload accordingly. I can also choose to include 0x00 for my relay
> field in my outgoing packet and reflect that accordingly in my length field
> in the header.

That works until another field is added in the same manner.

Implementations are expected to follow the standard logic of

if (more data)
   parse field X
if (more data)
   parse field X+1
if (more data)
   parse field X+2
etc.

Ugly or not, there is no point in changing now.  Updating the version
message to a radically different design, for simply cleanliness
reasons, is not sufficient cause to migrate the entire bitcoin
universe to a new and different version/feature negotiation setup.

--
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From etotheipi at gmail.com  Thu Jun 20 16:09:10 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Thu, 20 Jun 2013 12:09:10 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <66577F722D29461D8651DF1D0684AAE1@LAPTOPAIR>
References: <51BFD886.8000701@gmail.com> <20130619142510.GA17239@crunch>
	<51C1C288.4000305@gmail.com>
	<20130619152815.GA14729@netbook.cypherspace.org>
	<20130620074830.GA21724@crunch>
	<66577F722D29461D8651DF1D0684AAE1@LAPTOPAIR>
Message-ID: <51C32926.10904@gmail.com>


On 06/20/2013 05:10 AM, Jeremy Spilman wrote:
>> which could involve proving something to a third party that has not seen 
>> the communication between payer and payee.
> OK - I think I follow now.  So a third-party who does not see any of the 
> communication between the payer and payee only knows the HASH160.  Let's say 
> the payee denies receipt of the funds....
>
> It's easy to prove what public key it was sent to (it's the preimage), but 
> you can't prove the parent of that public key. You can provide any number of 
> ParentPubKey * Multiplier that could have been used, so the 3rd party is 
> unconvinced by a "matching" ParentPubKey * Multiplier.
>
> However, if you calculated the destination using: PubKeyParent * 
> HMAC(Multiplier,PubKeyParent) as Timo said, now if you give the 3rd party a 
> PubKeyParent and Multiplier (or Addend) that produces the destination 
> address, you've proven the payment is in fact spendable by PubKeyParent, and 
> they can't deny receipt. Very cool.
>
> Sorry for "echoing" this back, it took me a little while to work it out, so 
> I thought I'd write it down. Hope I got it right...
>
> If you give {PubKey, ChainCode} you do get this feature. If you give 
> {ParentPubKey, Addend} or {ParentPubKey, Addend, ChainCode} you're back to 
> having plausible deniability.
>
> If BIP32's CKD'((Kpar, cpar), i) was actually HMAC(HMAC(cpar, i), Kpar) you 
> could give HMAC(cpar, i) instead of Addend, and then you would get this 
> feature; a way to 'skip down' a level in the wallet hierarchy, keep the 
> 'chain of custody' so to speak back to the ParentPubKey intact, without 
> having to disclose the ChainCode. Meh...
>
>

I agree, if we used Timo's suggestion, that seems to clean up the
remaining uncertainties with this recommendation.   I'm not convinced
those uncertainties matter in this situation, where there is no question
about the parent public key.  That is the part of the process that was
already verified, per my previous examples.  But certainly, for this to
be more versatile it would need that. 

If I modify my request to match Timo's recommendation, then it loses the
benefit of being a simple, non-disruptive extension of BIP 32.   I'm not
fond of deviating from BIP 32, as it kind of defeats one of the benefits
of BIP 32:  standardization.   And I'm not inclined to make an
Armory-specific wallet variant.

But I can't tell if the benefits are lost on you, or you just don't
think they are worth it (or I'm overstating them).  I'm strongly opposed
to bring extra wallets/chains into this equation /*just*/ to get a
benefit that can be had with a simple alternative encoding.  This isn't
a question of which is better, it's a matter of recognizing that both
forms have usefulness and should both be supported. 

-Alan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/a9b89205/attachment.html>

From marko.otbalkana at gmail.com  Fri Jun 21 00:54:38 2013
From: marko.otbalkana at gmail.com (Marko Otbalkana)
Date: Thu, 20 Jun 2013 17:54:38 -0700
Subject: [Bitcoin-development] CTxIn::nSequence
Message-ID: <CALG7eYrvRg7JF3ndq4wZ2cjUXuHkjYLRH9_FXH2mK+tuAWom0g@mail.gmail.com>

Could anyone tell me what CTxIn::nSequence is meant for?

Best Regards,
-Marko
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/55f82c57/attachment.html>

From patrick at intersango.com  Fri Jun 21 04:03:58 2013
From: patrick at intersango.com (Patrick Strateman)
Date: Thu, 20 Jun 2013 21:03:58 -0700
Subject: [Bitcoin-development] CTxIn::nSequence
In-Reply-To: <CALG7eYrvRg7JF3ndq4wZ2cjUXuHkjYLRH9_FXH2mK+tuAWom0g@mail.gmail.com>
References: <CALG7eYrvRg7JF3ndq4wZ2cjUXuHkjYLRH9_FXH2mK+tuAWom0g@mail.gmail.com>
Message-ID: <51C3D0AE.4080101@intersango.com>

It's well answered by this stack exchange question.

http://bitcoin.stackexchange.com/questions/2025/what-is-txins-sequence

On 06/20/2013 05:54 PM, Marko Otbalkana wrote:
> Could anyone tell me what CTxIn::nSequence is meant for?
>
> Best Regards,
> -Marko
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130620/1e2140bf/attachment.html>

From mike at plan99.net  Fri Jun 21 08:20:06 2013
From: mike at plan99.net (Mike Hearn)
Date: Fri, 21 Jun 2013 10:20:06 +0200
Subject: [Bitcoin-development] CTxIn::nSequence
In-Reply-To: <51C3D0AE.4080101@intersango.com>
References: <CALG7eYrvRg7JF3ndq4wZ2cjUXuHkjYLRH9_FXH2mK+tuAWom0g@mail.gmail.com>
	<51C3D0AE.4080101@intersango.com>
Message-ID: <CANEZrP3fRf5T+MtMs01iAoK6op3gte8Dv99=kwgW3Y5KwiUg-Q@mail.gmail.com>

Indeed, and for a higher level answer, see here:

https://en.bitcoin.it/wiki/Contracts


On Fri, Jun 21, 2013 at 6:03 AM, Patrick Strateman
<patrick at intersango.com>wrote:

>  It's well answered by this stack exchange question.
>
> http://bitcoin.stackexchange.com/questions/2025/what-is-txins-sequence
>
>
> On 06/20/2013 05:54 PM, Marko Otbalkana wrote:
>
>  Could anyone tell me what CTxIn::nSequence is meant for?
>
>  Best Regards,
>  -Marko
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
> http://p.sf.net/sfu/windows-dev2dev
>
>
>
> _______________________________________________
> Bitcoin-development mailing listBitcoin-development at lists.sourceforge.nethttps://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130621/dfa4b5a4/attachment.html>

From nadav at shesek.info  Fri Jun 21 20:25:59 2013
From: nadav at shesek.info (Nadav Ivgi)
Date: Fri, 21 Jun 2013 23:25:59 +0300
Subject: [Bitcoin-development] Standard public key base58-check address
	prefix?
Message-ID: <CAGXD5f1RRuwDJsLUiQVOXzeHFPA5HrBvatjvhDw9oFO7yNe-og@mail.gmail.com>

I'm working on a project that requires users to exchange public keys (for
multisig transactions).

It seems that hex encoding is usually used to display public keys (i.e. in
bitaddress and brainwallet), which results in longer strings and lacks the
4-bytes verification.

A standard way to encode public keys as base58-check addresses would make
it easier and safer to display and exchange public keys. All that is really
needed is deciding on a prefix byte.

Perhaps we can use 0x37/0x38, which results in the letter P (for "Public")?
It seems like those bytes aren't used for anything yet.

Thanks,
Nadav
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130621/b811ebcb/attachment.html>

From nadav at shesek.info  Fri Jun 21 20:15:55 2013
From: nadav at shesek.info (Nadav Ivgi)
Date: Fri, 21 Jun 2013 23:15:55 +0300
Subject: [Bitcoin-development] Standard public key base58-check address
	prefix?
Message-ID: <CAGXD5f1sOBT7qZdVvyTFLDRu5Bn4BfpWgm=aQi-=M=UMnrSCCg@mail.gmail.com>

I'm working on a project that requires users to exchange public keys (for
multisig transactions).

It seems that hex encoding is usually used to display public keys (i.e. in
bitaddress and brainwallet), which results in longer strings and lacks the
4-bytes verification.

A standard way to encode public keys as base58-check addresses would make
it easier and safer to display and exchange public keys. All that is really
needed is deciding on a prefix byte.

Perhaps we can use 0x37/0x38, which results in the letter P (for "Public")?
It seems like those bytes aren't used for anything yet.

Thanks,
Nadav
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130621/bcb99d60/attachment.html>

From nadav at shesek.info  Fri Jun 21 20:41:25 2013
From: nadav at shesek.info (Nadav Ivgi)
Date: Fri, 21 Jun 2013 23:41:25 +0300
Subject: [Bitcoin-development] Standard public key base58-check address
	prefix?
In-Reply-To: <CAGXD5f1RRuwDJsLUiQVOXzeHFPA5HrBvatjvhDw9oFO7yNe-og@mail.gmail.com>
References: <CAGXD5f1RRuwDJsLUiQVOXzeHFPA5HrBvatjvhDw9oFO7yNe-og@mail.gmail.com>
Message-ID: <CAGXD5f3ZDjVHROA5mzUJLgyTmyRZYOVYpZ2ErYYCFPoixxd+Vg@mail.gmail.com>

Just a small clarification: I was referring to the actual public key,
and not the hash160 of it used for Bitcoin addresses. Its usually not
used, but it is needed for multisig transaction.

On Fri, Jun 21, 2013 at 11:25 PM, Nadav Ivgi <nadav at shesek.info> wrote:
> I'm working on a project that requires users to exchange public keys (for
> multisig transactions).
>
> It seems that hex encoding is usually used to display public keys (i.e. in
> bitaddress and brainwallet), which results in longer strings and lacks the
> 4-bytes verification.
>
> A standard way to encode public keys as base58-check addresses would make it
> easier and safer to display and exchange public keys. All that is really
> needed is deciding on a prefix byte.
>
> Perhaps we can use 0x37/0x38, which results in the letter P (for "Public")?
> It seems like those bytes aren't used for anything yet.
>
> Thanks,
> Nadav



From melvincarvalho at gmail.com  Sat Jun 22 11:48:08 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Sat, 22 Jun 2013 13:48:08 +0200
Subject: [Bitcoin-development] Bitcoin addresses -- opaque or not
In-Reply-To: <201306111529.13657.luke@dashjr.org>
References: <CAKaEYhJ+v0NfbzVEDEUh69D-n_4=Nd544fsm0a++QwsqcS3RVw@mail.gmail.com>
	<201306111529.13657.luke@dashjr.org>
Message-ID: <CAKaEYhK0Lgpw3aNLo6LNQ=SwJ5TjquKYMWyh9K5+C-HFQfK1pw@mail.gmail.com>

On 11 June 2013 17:29, Luke-Jr <luke at dashjr.org> wrote:

> On Tuesday, June 11, 2013 1:11:33 PM Melvin Carvalho wrote:
> > For the sake of argument let's say that opaque means that you can tell
> > nothing about the address by examining the characters.
>
> This is true or false based on CONTEXT.
>
> Obviously, an implementation of transaction handling (eg, wallets) needs
> to be
> able to translate addresses to and from what they represent.
>
> On the other hand, things like URI handlers do not (and should not) try to
> interpret the address as anything other than an arbitrary word (\w+).
>

Luke, if you think that the sole purpose of a URI scheme is to be used as a
URI handler, I think you've not fully understood the concept.  URIs are the
global variable of the internet, and as such the need to play nicely with
all other URI schemes on the net.  They need to be able to be linked to, to
be defined and documented.  This is important for bitcoin to get right
because bitcoin: needs to treated in a special way on the internet, I just
saw today that it was treated by some software as a relative URL, which is
going to break a ton of stuff.


>
> > My understanding was that they are NOT opaque, and that if that has
> > changed, it will invalidate much at least some wiki page, for examples at
> > least some of the following would now be false:
>
> The wiki goes into much detail on how addresses work, which is not the
> concern
> of most software in the Bitcoin ecosystem, but may be of interest to humans
> and developers working on the one component that operates the "black box"
> that
> addresses are.
>
> > --------
> > <snip>
> > --------
>
> These aren't FALSE, they are "true at the moment, but subject to revision
> by
> newer standards".
>
> > I also here that there is a LIKELY change from the base58 encoding ...
> when
> > was this established?
>
> I stated (on IRC) that it was likely Bitcoin would change from the base58
> encoding for addresses ... at some unspecified time in the future, to some
> unspecified new encoding that addressed known limitations of base58. What
> those changes will be, or when, are not all established at this time. The
> only
> currently-planned change to addresses (very loosely defined) is inclusion
> of
> the Payment Protocol URIs. But the point is that software developers
> shouldn't
> assume that addresses will remain base58 forever.
>

I am opposed to address changes in general, until he wider implications are
fully understood.


>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130622/d05ef409/attachment.html>

From melvincarvalho at gmail.com  Sat Jun 22 12:05:41 2013
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Sat, 22 Jun 2013 14:05:41 +0200
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
Message-ID: <CAKaEYhL2YY6wWnUYJuwWo2czHq7hRiYsQouR1B64oE31ZEochg@mail.gmail.com>

On 10 June 2013 06:09, John Dillon <john.dillon892 at googlemail.com> wrote:

> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA256
>
> It has been suggested that we leave the decision of what the blocksize to
> be
> entirely up to miners. However this leaves a parameter that affects every
> Bitcoin participant in the control of a small minority. Of course we can
> not
> force miners to increase the blocksize if they choose to decrease it,
> because
> the contents of the blocks they make are their decision and their decision
> only. However proposals to leave the maximum size unlimited to allow
> miners to
> force us to accept arbitrarily large blocks even if the will of the
> majority of
> Bitcoin participants is that they wish to remain able to validate the
> blockchain.
>
> What we need is a way to balance this asymetrical power relationship.
>
> Proof-of-stake voting gives us a way of achieving that balance.
> Essentially for
> a miner to prove that the majority will of the poeple is to accept a larger
> blocksize they must prove that the majority has in fact voted for that
> increase. The upper limit on the blocksize is then determined by the
> median of
> all votes, where each txout in the UTXO set is one vote, weighted by txout
> value. A txout without a corresponding vote is considered to be a vote for
> the
> status quo. To allow the voting process to continue even if coins are
> "lost"
> votes, including default votes, are weighted inversely according to their
> age
> in years after 1 year. IE a vote with weight 1BTC that is 1.5 years old
> will be
> recorded the same as a <1 year old vote weighted as 0.67BTC, and a 1 day
> old
> and 6 months old UTXO are treated equivalently. The 1 year minimum is
> simply to
> make voting required no more than once per year. (of course, a real
> implementation should do all of these figures by block height, IE after
> 52,560
> blocks instead of after 1 year)
>
> A vote will consist of a txout with a scriptPubKey of the following form:
>
>     OP_RETURN magic vote_id txid vout vote scriptSig
>
> Where scriptSig is a valid signature for a transaction with nLockTime
> 500,000,000-1 spending txid:vout to scriptPubKey:
>
>     OP_HASH160 H(OP_RETURN magic vote_id txid vout vote) OP_EQUAL
>
> vote_id is the ID of the specific vote being made, and magic is included to
> allow UTXO proof implementations a as yet unspecified way of identifying
> votes
> and including the weighted median as part of the UTXO tree sums. (it also
> allows SPV clients to verify the vote if the UTXO set is a Patricia tree of
> scriptPubKeys) vote is just the numerical vote itself. The vote must
> compute
> the median, rather than the mean, so as to not allow someone to skew the
> vote
> by simply setting their value extremely high. Someone who still remembers
> their
> statistics classes should chime in on the right way to compute a median in
> a
> merkle-sum-tree.
>
> The slightly unusual construction of votes makes implementation by wallet
> software as simple as possible within existing code-paths. Votes could
> still be
> constructed even in wallets lacking specific voting capability provided the
> wallet software does have the ability to set nLockTime.
>
> Of course in the future the voting mechanism can be used for additional
> votes
> with an additional vote_id. For instance the Bitcoin community could vote
> to
> increase the inflation subsidy, another example of a situation where the
> wishes
> of miners may conflict with the wishes of the broader community.
>
> Users may of course actually create these specially encoded txouts
> themselves
> and get them into the blockchain.  However doing so is not needed as a
> given
> vote is only required to actually be in the chain by a miner wishing to
> increase the blocksize. Thus we should extend the P2P protocol with a
> mechanism
> by which votes can be broadcast independently of transactions. To prevent
> DoS
> attacks only votes with known vote_id's will be accepted, and only for
> txid:vout's already in the blockchain, and a record of txouts for whom
> votes
> have already broadcast will be kept. (this record need not be
> authoritative as
> its purpose is only to prevent DoS attacks) Miners wishing to increase the
> blocksize can record these votes and include them in the blocks they mine
> as
> required. To reduce the cost of including votes in blocks 5% of every block
> should be assigned to voting only. (this can be implemented by a soft-fork)
>
> For any given block actual limit in effect is then the rolling median of
> the
> blocks in the last year. At the beginning of every year the value
> considered to
> be the status quo resets to the mean of the limit at the beginning and end
> of
> the interval.  (again, by "year" we really mean 52,560 blocks) The rolling
> median and periodic reset process ensures that the limit changes gradually
> and
> is not influenced by temporary events such as hacks to large exchanges or
> malicious wallet software.  The rolling median also ensures that for a
> miner
> the act of including a vote is never wasted due to the txout later being
> spent.
>
> Implementing the voting system can happen prior to an actual hard-fork
> allowing
> for an increase and can be an important part of determining if the
> hard-fork is
> required at all.
>
> Coercion and vote buying is of course possible in this system. A miner
> could
> say that they will only accept transactions accompanied by a vote for a
> given
> limit. However in a decentralized system completely preventing vote buying
> is
> of course impossble, and the design of Bitcoin itself has a fundemental
> assumption that a majority of miners will behave in a specific kind of
> "honest"
> way.
>
> A voting process ensures that any increase to the blocksize genuinely
> represents the desires of the Bitcoin community, and the process described
> above ensures that any changes happen at a rate that gives all participants
> time to react. The process also gives a mechanism for the community to
> vote to
> decrease the limit if it turns out that the new one was in fact too high.
> (note
> how the way the status quo is set ensures the default action is for the
> limit
> to gradually decrease even if everyone stops voting)
>
> As many of you know I have been quite vocal that the 1MB limit should
> stay. But
> I would be happy to support the outcome of a vote done properly, whatever
> that
> outcome may be.
>

Thinking about this a little more, I guess it does not hurt to build some
kind of voting system into the clients.  But I think it's more useful for
straw polls.  For example a bug fix 100% of people should agree on.  A
protocol optimization perhaps 80% would agree on.  A protocol change that
redistributes wealth or incentives perhaps only 60% will agree on.

At this point in time it's far too easy to deliver contentious changes into
the hands of the general population.  I think that fortunately we're
blessed with a very strong dev team, but the fundamental philosophy of
bitcoin is to not put too much trust in single point, but rather, to
distribute and diversify trust to the edges.



> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v1.4.11 (GNU/Linux)
>
> iQEcBAEBCAAGBQJRtVFBAAoJEEWCsU4mNhiP6EAIAMjq4UgXxmEjOgHWf0KcmwmH
> Ra/I3oY7krvg/lu1YCa+ACMBdoca9WODySUIe7R3niphKXEnknHGUIf8tm/Vrq4H
> gPF4cgYEr18EYTVtvT9J1pZUB4f5dxkXXNpcQ60juaz9KervFQMOGnpr6Fyxi3dS
> ghObNYcr3D2v1fjx56sp7BCNn0XHxTb1ZLUJB0BZhDKlamfgcxruKMbpsZmACJUj
> gTNLNweaAomBIH++j7cnXeB0jZc/1ilv8qLA/f3TGb43FDkAQcvvSjGijI+OJOm6
> Fh/WRBav1BJiV6PKs9xuHXsaxZ/T7Fb8Wg8EynSi0mSj47QXdKZgeZCi3XlSyxM=
> =aKBD
> -----END PGP SIGNATURE-----
>
>
> ------------------------------------------------------------------------------
> How ServiceNow helps IT people transform IT departments:
> 1. A cloud service to automate IT design, transition and operations
> 2. Dashboards that offer high-level views of enterprise services
> 3. A single system of record for all IT processes
> http://p.sf.net/sfu/servicenow-d2d-j
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130622/230318e0/attachment.html>

From jgarzik at bitpay.com  Sat Jun 22 19:28:54 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Sat, 22 Jun 2013 15:28:54 -0400
Subject: [Bitcoin-development] bitcoind and C++ namespaces?
Message-ID: <CAJHLa0Mu+1jB8gPbzH3JTXk0uWTJiZOfogffj6+nUfekOgN-0A@mail.gmail.com>

Slowly warming to C++ namespaces.  How about starting small, and
wrapping most stuff inside a bitcoin namespace?  Bike shedding can be
done at any point; the main idea is to start small, and gain
experience.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From gavin at bitcoinfoundation.org  Tue Jun 25 17:57:15 2013
From: gavin at bitcoinfoundation.org (Gavin Andresen)
Date: Tue, 25 Jun 2013 13:57:15 -0400
Subject: [Bitcoin-development] Bitcoin-Qt/bitcoind version 0.8.3 released
Message-ID: <CABsx9T0PDmVhBd=275Yw3K9FbESmFybkFo3iZGBwivHxq176Wg@mail.gmail.com>

Bitcoin-Qt version 0.8.3 is now available from:
  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.3/

This is a maintenance release to fix a denial-of-service attack that
can cause nodes to crash.

Please report bugs using the issue tracker at github:
  https://github.com/bitcoin/bitcoin/issues

0.8.3 Release notes
===================

Truncate over-size messages to prevent a memory exhaustion attack.

Fix a regression that causes excessive re-writing of the 'peers.dat' file.


===================

Thanks to Peter Todd for responsibly disclosing the vulnerability
( CVE-2013-4627 ) and creating a fix.



From jcea at jcea.es  Tue Jun 25 23:13:25 2013
From: jcea at jcea.es (Jesus Cea)
Date: Wed, 26 Jun 2013 01:13:25 +0200
Subject: [Bitcoin-development] Bitcoin-Qt/bitcoind version 0.8.3 released
In-Reply-To: <CABsx9T0PDmVhBd=275Yw3K9FbESmFybkFo3iZGBwivHxq176Wg@mail.gmail.com>
References: <CABsx9T0PDmVhBd=275Yw3K9FbESmFybkFo3iZGBwivHxq176Wg@mail.gmail.com>
Message-ID: <51CA2415.4010803@jcea.es>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

On 25/06/13 19:57, Gavin Andresen wrote:
> Bitcoin-Qt version 0.8.3 is now available from: 
> http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.3/

The
> 
"splash" banner shows "0.8.3-BETA".

- -- 
Jes?s Cea Avi?n                         _/_/      _/_/_/        _/_/_/
jcea at jcea.es - http://www.jcea.es/     _/_/    _/_/  _/_/    _/_/  _/_/
Twitter: @jcea                        _/_/    _/_/          _/_/_/_/_/
jabber / xmpp:jcea at jabber.org  _/_/  _/_/    _/_/          _/_/  _/_/
"Things are not so easy"      _/_/  _/_/    _/_/  _/_/    _/_/  _/_/
"My name is Dump, Core Dump"   _/_/_/        _/_/_/      _/_/  _/_/
"El amor es poner tu felicidad en la felicidad de otro" - Leibniz
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.10 (GNU/Linux)
Comment: Using GnuPG with Thunderbird - http://www.enigmail.net/

iQCVAwUBUcokFZlgi5GaxT1NAQJ+HQP7Bs387bwW6sXrOx98Y2bkQBJfciaS/eyD
HvHho9xfoOcaCwuigh2lI78i2vxoVUa30sM0m/g4+isyJZDVLpbUENhy3bx0MAD/
4YAjJXdwScDI15m6xvAf706BDst2kXcWw/pudZQiX4Kw9YEs7rUWvdPS5BE6PXbK
QyCcBcrH7fo=
=+cZD
-----END PGP SIGNATURE-----



From pieter.wuille at gmail.com  Tue Jun 25 23:34:41 2013
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 26 Jun 2013 01:34:41 +0200
Subject: [Bitcoin-development] Bitcoin-Qt/bitcoind version 0.8.3 released
In-Reply-To: <51CA2415.4010803@jcea.es>
References: <CABsx9T0PDmVhBd=275Yw3K9FbESmFybkFo3iZGBwivHxq176Wg@mail.gmail.com>
	<51CA2415.4010803@jcea.es>
Message-ID: <20130625233440.GA459@vps7135.xlshosting.net>

On Wed, Jun 26, 2013 at 01:13:25AM +0200, Jesus Cea wrote:
> "splash" banner shows "0.8.3-BETA".

Just like every release ever, and probably until we reach 1.0.

-- 
Pieter




From etotheipi at gmail.com  Wed Jun 26 15:29:50 2013
From: etotheipi at gmail.com (Alan Reiner)
Date: Wed, 26 Jun 2013 11:29:50 -0400
Subject: [Bitcoin-development] Optional "wallet-linkable" address format
 - Payment Protocol
In-Reply-To: <CANEZrP3ZcQEPOPrO_O2-tdLZUSezj1nbhtVFt1e77KEwzhfZ-A@mail.gmail.com>
References: <5AC3FA1D9B1F4FA0A2FE9A67333642B5@LAPTOPAIR>
	<51C21035.9080407@gmail.com>
	<53E406CF0D93498DAECAAE061555B7C9@LAPTOPAIR>
	<51C234FA.5030909@gmail.com>
	<9600E3D1DDC24D1391C1E4433F71684D@LAPTOPAIR>
	<CANEZrP3ZcQEPOPrO_O2-tdLZUSezj1nbhtVFt1e77KEwzhfZ-A@mail.gmail.com>
Message-ID: <51CB08EE.1050403@gmail.com>

Although I'd still prefer my original request, I get much of what I want
from your guys' recommendation.  It complicates the wallet design,
because it requires tracking and associating a matrix of addresses for
each wallet, instead of a single linear list.  But if this is what it's
going to take then I will go along. 

Right now BIP 32 defines, m/i'/j/k, where j=0 is the "external" chain
used for distributing addresses, and j=1 is the "internal" chain for
sending change.  The CONOPs (concept of operations) for the extended
wallet would be like Jeremy described:

- Chains with j>=2 would be independent address chains carved out for
individuals relationships
- Add wallet code to individually associate each j-value with a
particular identity
- Update the wallet code to pool all the addresses in all j-chains when
calculating the balance of the wallet and/or creating transactions
- When choosing to generically "Receive Bitcoins", will pick the next
address from the j=0 chain
- Will have to add extra function to "Receive Bitcoins" button to allow
creation of new contacts/identities.
- Change will always go to the next address in j=1, no matter which
chains are used to provide inputs.
- Add code to figure out lookaheads for each alternate chain.  Not just
each chain, but looking ahead a couple chains, too.  Luckily, the
lookahead doesn't have to be very big for chains j>=1 
- Add an interface to display and choose the different chains in your
wallet, and export the pubkey&chaincode in some soon-to-be-standardized
format. 
- Add code and interface to receive and track alternate j-chains from
other clients/users, and maintain those.  Should we try associating
incoming and outgoing chains?  What happens if they do it wrong?  Meh...

Just as one final swipe at this idea, you can see that I gotta do quite
a bit of work to support the multi-chain idea, and adds a little extra
burden on the user to maintain the organization of the wallet.  This
would all be totally unnecessary with a simple alternate encoding. 
Granted, I think the multi-chain idea is good, and one that I will
probably implement anyway, but it seems like overkill in terms of
developer complexity, and interface complexity to achieve something much
simpler.  Developers of much simpler/lightweight clients would probably
find this prohibitive.

On another note:  I thought we weren't encouraging automatic payments
without requesting from the other party...?  It makes me uneasy, but it
sounds like group thought has converged on that being acceptable.  I
bring it up, because there are situations where it makes sense, but it
sounds unsafe for general users.   Alice will give Bob his own chain for
sending Alice money, then a year later Bob will send money automatically
to Alice not realizing that the wallet was lost, retired or
compromised.  It's not that Bob can't ask for a new address, it's that
if the interface says "Send Money to Alice", that looks legit enough
that Bob may not feel it necessary to check with Alice first.   That's
more of an interface issue though.  We can add a warning to "check with
the recipient that they still have access to wallet 3cQ398x", etc.   But
I just know someone is going to lose money anyway...

-Alan





On 06/20/2013 03:32 AM, Mike Hearn wrote:
> Agree with Jeremy and once the payment protocol work is further along
> I'd like to see us define an extension that lets you send payment
> requests containing public keys+chain codes, so further payments can
> be made push-style with no recipient interaction (e.g. for repeated
> billing). How apps choose to arrange their chains internally seems
> like an area for experimentation. I definitely want to implement HD
> wallets in bitcoinj to allow this and if that means not using the same
> tree structure as in the BIP then so be it.
>
>
> On Thu, Jun 20, 2013 at 5:54 AM, Jeremy Spilman <jeremy at taplink.co
> <mailto:jeremy at taplink.co>> wrote:
>
>     > BIP 32 already specifies how to use the first three tree levels:
>      M/i/j/k,
>     > i~wallet, j~Internal/External, k~address.  The first level is
>     actually
>     > type-1 derived, and thus we cannot create an arbitrary number of
>     them
>     > without pre-computing them from the offline wallet.  So it's not
>     "free" to
>     > create new wallets unless we redefine how the levels work.
>
>     Initially I was thinking that you would share the public key and
>     chain code
>     from [m/i'/0] so that you can receive payments at [m/i'/0/k], for
>     a unique
>     value of 'i' for each receive chain.
>
>     For the case of generating new receive chains from a *watch-only*
>     wallet, as
>     you say, the options are to either keep a cache of
>     PubKey/ChainCode for
>     unused [m/i'] or simply increment 'j' past 1 for an existing
>     [m/i'/j] -- the
>     concept of 'internal/'external' and change addresses at Depth=2
>     don't make
>     sense for handing out receive chains to lots of people anyway, and
>     certainly
>     BIP32 doesn't *require* 0 <= j <= 1.  So I think incrementing 'j'
>     is the way
>     to go here...
>
>     The "default" layout of BIP32 does NOT mean that implementations
>     should not
>     check for transactions with j > 1. That would be a useless
>     constraint and
>     obviously self-limiting. It might be helpful to add to the
>     'Compatibility'
>     section some minimum expectations about how a wallet should be
>     'probed' when
>     imported. If you don't feel completely free to monotonically
>     increment 'j'
>     to your hearts content to achieve major usability benefits, then I
>     say BIP32
>     could use some clarifying.
>
>     BTW - the spec calls for addition not multiplication now, so we
>     should call
>     it the 'Addend' not the 'Multiplier' :-)
>
>     > Do these extra wallet chains behave as different wallets, or
>     sub-wallets?
>
>     They could, but they certainly don't need to!  A single-wallet
>     implementation treats this merely as an address-generation
>     algorithm, and
>     does not expose any hierarchy to the user interface.  The user just
>     "magically" gets the ability to send multiple payments to their
>     contacts
>     without immediately sacrificing their privacy
>     (http://www.wired.com/wiredenterprise/2013/06/bitcoin_retai/).
>     Everything
>     goes into the same ledger, balance, coin pool, etc. Most of the
>     code base is
>     unaware BIP32 is even in use.
>
>     While it is *possible* to support separate ledgers, balances, etc.
>     it is
>     certainly not required, and you get all the benefits either way.
>
>     I think, since your proposal generates and receives payments into
>     BIP32-style addresses, we both need similar underlying wallet
>     code. The only
>     difference is that you are passing the Kpar for [m/i'/0/k] and the
>     *result*
>     of CKD'((Kpar, cpar), k), and instead I proposed passing Kpar and
>     cpar, and
>     leaving 'k' out of it, letting the receive choose 'k'.
>
>     > For instance, maybe there's a benefit to using the same parent
>     pubkey
>     > across multiple services, as a form of identity.   If I don't
>     want that, I
>     > use your method.  If I do want that, I use my method.
>
>     I think it's a interesting idea using static public keys as a
>     means for
>     persistent identity and hence security from MitM. If you want a shared
>     public key across multiple services we could just combine both
>     ideas and get
>     all the benefits, by making the data structure { ParentPubKey, Addend,
>     ChainCode }:
>
>        ParentPubKey: Public key of m/i' -- 33 bytes
>        Addend: I[L]*G from CDK'(m/i', j) -- 33 bytes
>        ChainCode: I[R] from CDK'(m/i', j) -- 32 bytes
>
>     All that remains secret is the ChainCode from [m/i'] -- and of
>     course the
>     private keys.  The ParentPubKey is a common value across multiple
>     services,
>     corresponding to user's identity rooted in [m/i'].  Each service
>     gets their
>     own 'j'.  ParentPubKey + Addend gives you the PubKey of [m/i'/j].
>      With the
>     ChainCode, the receiver then can generate [m/i'/j/k] for monotonically
>     increasing 'k'. Again, from the user perspective all transactions
>     under
>     [m/i'] can be presented in a single ledger, or not.
>
>     Anyway, fundamentally my feedback is if you are designing for
>     persistent
>     long-term relationships, you could build in a mechanism for generating
>     address chains so you don't need any further communication after
>     the initial
>     exchange, and it need not complicate the wallet.
>
>     Thanks,
>     --Jeremy
>
>
>
>     ------------------------------------------------------------------------------
>     This SF.net email is sponsored by Windows:
>
>     Build for Windows Store.
>
>     http://p.sf.net/sfu/windows-dev2dev
>     _______________________________________________
>     Bitcoin-development mailing list
>     Bitcoin-development at lists.sourceforge.net
>     <mailto:Bitcoin-development at lists.sourceforge.net>
>     https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
>
>
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130626/ab610b9b/attachment.html>

From arthur.gervais at inf.ethz.ch  Thu Jun 27 10:23:34 2013
From: arthur.gervais at inf.ethz.ch (Arthur Gervais)
Date: Thu, 27 Jun 2013 12:23:34 +0200
Subject: [Bitcoin-development] Double-Spending Fast Payments in Bitcoin due
	to Client versions 0.8.1
Message-ID: <51CC12A6.3090100@inf.ethz.ch>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Dear Bitcoin developers,

We would like to report a vulnerability which might lead, under some
assumptions, to a double-spending attack in a fast payment scenario.
The vulnerability has been introduced due to signature encoding
incompatibilities between versions 0.8.2 (or 0.8.3) and earlier
Bitcoin versions.

Please find at the following link a detailed description of this
vulnerability:
ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/7xx/789.pdf

We contacted and informed Gavin earlier about this problem.

With best regards,
Arthur Gervais
-----BEGIN PGP SIGNATURE-----
Version: GnuPG/MacGPG2 v2.0.18 (Darwin)
Comment: GPGTools - http://gpgtools.org

iQEcBAEBAgAGBQJRzBKLAAoJEI2AYXeasI8/eNYH/2b45o8JPjuiOXeE0MgiYO4g
HgGorNBvH3hLlSZkGh/7GxeGWi3tiEq8DKAgqFd8p+1Ay4YVHK86jJMBxAc8lzpx
TqS6Szrhlx7slamMGhjeem4BJ2RmfVqSRQjidYxwdee8bMQRVH5DiBzndpZwCeHa
AvlP8ojTUFozOJs5PvjEqE+sDKDe5nDC96uiZyMROK8neoiLZpJzV3+ScTUjLCeB
zg34wttX80WKpkXJFvq88FTIvO5E42NGP3APnt2J/HZcey4Mi9UIhLt+/TJ7Z07l
HuxFlzyXdCgRkJWvU13yn8bUP0cbeoox6Cwn7rDAIisVLn4KB9XPThPjfJbKEkg=
=Y6bs
-----END PGP SIGNATURE-----



From gmaxwell at gmail.com  Thu Jun 27 11:04:06 2013
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 27 Jun 2013 04:04:06 -0700
Subject: [Bitcoin-development] Double-Spending Fast Payments in Bitcoin
 due to Client versions 0.8.1
In-Reply-To: <51CC12A6.3090100@inf.ethz.ch>
References: <51CC12A6.3090100@inf.ethz.ch>
Message-ID: <CAAS2fgRg8B_j=Luf31R8-+vqOWQOUcUDof8wdq79_Ar9YuUm9g@mail.gmail.com>

On Thu, Jun 27, 2013 at 3:23 AM, Arthur Gervais
<arthur.gervais at inf.ethz.ch> wrote:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA1
>
> Dear Bitcoin developers,
>
> We would like to report a vulnerability which might lead, under some
> assumptions, to a double-spending attack in a fast payment scenario.
> The vulnerability has been introduced due to signature encoding
> incompatibilities between versions 0.8.2 (or 0.8.3) and earlier
> Bitcoin versions.
>
> Please find at the following link a detailed description of this
> vulnerability:
> ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/7xx/789.pdf

It would be kind if your paper cited the one of the prior discussions
of this transaction pattern:

E.g. https://bitcointalk.org/index.php?topic=196990.msg2048297#msg2048297
(I think there are a couple others)

The family of transaction patterns you describe is one of the ones I
specifically cite as an example of why taking non-reversible actions
on unconfirmed transactions is unsafe (and why most of the Bitcoin
community resources) council the same.  You can get similar patterns
absent changes in the IsStandard rule through a number of other means.
 One obvious one is through concurrent announcement: You announce
conflicting transactions at the same time to many nodes and one
excludes another.  By performing this many times and using chains of
unconfirmed transactions and seeing which family your victim observes
you can create input mixes that are only accepted by very specific
subsets of the network.



From bitcoin-list at bluematt.me  Thu Jun 27 12:29:30 2013
From: bitcoin-list at bluematt.me (bitcoin-list at bluematt.me)
Date: Thu, 27 Jun 2013 14:29:30 +0200
Subject: [Bitcoin-development] [ANN] Micropayment Channel Implementation
Message-ID: <44f8fd60-be4a-436d-a132-422b939d6de1@email.android.com>

As of today, a full implementation of micropayment channels has been merged
onto bitcoinj's master branch (to be released in the next version). It is
designed to make it easy for users to create payment channel servers and
clients based on the design at
https://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_party,
by creating a simple TCP socket and exchanging protobufs to initialize and
make payments.

It supports various levels of abstractions, allowing users to drive the
state machines which do basic channel init/verification themselves, allow
bitcoinj to handle all the complexity of channel management/expiry/etc and
simply exchange protobufs over whatever whatever connection they wish to
make with the server, or let bitcoinj handle opening a TCP socket and do
all the work. See
https://code.google.com/p/bitcoinj/wiki/WorkingWithMicropayments for
details on how to use the implementation in bitcoinj.

A more full protocol description will be written up in the form of a BIP as
the code matures a bit more (with the hope that other implementations can
appear), but, generally:

1. Client and server exchange version handshake, and client may
optionally request that an existing channel be reopened (the channels last
for 24 hours by default, so if the connection gets killed, reopening an
existing channel is useful).
2. The protocol described on the wiki is followed, exchanging
(canonical!) signatures and transactions until a multisignature contract is
established and broadcast which locks money into the channel, and a refund
transaction is created and signed which allows the client to spend the
entire multisignature transaction to wherever they want
(SIGHASH_NONE|SIGHASH_ANYONECANPAY) after some lock time (by default, 24
hours). Both client and server store a copy of the channel in their wallet
so that if the app itself crashes the refund transaction can still be
broadcast/the channel can still be resumed. At this point either the whole wallet should be backed up or the total value in payment channels at any
given time should be kept reasonably low (because payment channels are
designed to combine micropayments into confirmable payments, this shouldn't be an issue)
3. The client increments payments by sending the server new signatures
spending the multisig contract partially back to themselves and allowing
the server to do what they want with the rest
(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY).
4. When the client sends a CLOSE message or the channel approaches the
refund transaction unlock time, the server adds any necessary fees to the
latest payment transaction and broadcasts it, closing the channel, disconnecting the client if the connection is still open and removing the stored channel state from its wallet.

See https://code.google.com/p/bitcoinj/source/browse/core/src/paymentchannel.proto for the protobuf/protocol description.



From arthur.gervais at inf.ethz.ch  Thu Jun 27 16:03:37 2013
From: arthur.gervais at inf.ethz.ch (Arthur Gervais)
Date: Thu, 27 Jun 2013 18:03:37 +0200
Subject: [Bitcoin-development] Double-Spending Fast Payments in Bitcoin
 due to Client versions 0.8.1
In-Reply-To: <CAAS2fgRg8B_j=Luf31R8-+vqOWQOUcUDof8wdq79_Ar9YuUm9g@mail.gmail.com>
References: <51CC12A6.3090100@inf.ethz.ch>
	<CAAS2fgRg8B_j=Luf31R8-+vqOWQOUcUDof8wdq79_Ar9YuUm9g@mail.gmail.com>
Message-ID: <51CC6259.3060003@inf.ethz.ch>

On 6/27/13 1:04 PM, Gregory Maxwell wrote:
> On Thu, Jun 27, 2013 at 3:23 AM, Arthur Gervais
> <arthur.gervais at inf.ethz.ch> wrote:
>> -----BEGIN PGP SIGNED MESSAGE-----
>> Hash: SHA1
>>
>> Dear Bitcoin developers,
>>
>> We would like to report a vulnerability which might lead, under some
>> assumptions, to a double-spending attack in a fast payment scenario.
>> The vulnerability has been introduced due to signature encoding
>> incompatibilities between versions 0.8.2 (or 0.8.3) and earlier
>> Bitcoin versions.
>>
>> Please find at the following link a detailed description of this
>> vulnerability:
>> ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/7xx/789.pdf
> 
> It would be kind if your paper cited the one of the prior discussions
> of this transaction pattern:
> 
> E.g. https://bitcointalk.org/index.php?topic=196990.msg2048297#msg2048297
> (I think there are a couple others)
> 
> The family of transaction patterns you describe is one of the ones I
> specifically cite as an example of why taking non-reversible actions
> on unconfirmed transactions is unsafe (and why most of the Bitcoin
> community resources) council the same.  You can get similar patterns
> absent changes in the IsStandard rule through a number of other means.
>  One obvious one is through concurrent announcement: You announce
> conflicting transactions at the same time to many nodes and one
> excludes another.  By performing this many times and using chains of
> unconfirmed transactions and seeing which family your victim observes
> you can create input mixes that are only accepted by very specific
> subsets of the network.
> 

Thank you for the reference! This is indeed a very interesting issue,
affecting the same Bitcoin version. However we think it is
complementary, since our reported problem has nothing to do with fees,
dust, nor is it necessary to send the two double-spending transaction at
the same time. In our setting, double-spending still works if the second
transaction is sent after minutes (and the first transaction has not yet
been included into a block).

Clearly, we have outlined the limits of the security of
zero-confirmation payments in an earlier work.

Our only intention is to raise the awareness for merchants who have to
accept zero-confirmation transactions. They should be aware of the
signature encoding difference between Bitcoin versions and the possible
consequences.




From gmaxwell at gmail.com  Thu Jun 27 16:13:58 2013
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 27 Jun 2013 09:13:58 -0700
Subject: [Bitcoin-development] Double-Spending Fast Payments in Bitcoin
 due to Client versions 0.8.1
In-Reply-To: <51CC6259.3060003@inf.ethz.ch>
References: <51CC12A6.3090100@inf.ethz.ch>
	<CAAS2fgRg8B_j=Luf31R8-+vqOWQOUcUDof8wdq79_Ar9YuUm9g@mail.gmail.com>
	<51CC6259.3060003@inf.ethz.ch>
Message-ID: <CAAS2fgRkoY_vHXKyyh91Wfm0f_qW6d_FeKzO+mi-WpDRUxtsRw@mail.gmail.com>

On Thu, Jun 27, 2013 at 9:03 AM, Arthur Gervais
<arthur.gervais at inf.ethz.ch> wrote:
> affecting the same Bitcoin version. However we think it is
> complementary, since our reported problem has nothing to do with fees,
> dust, nor is it necessary to send the two double-spending transaction at
> the same time. In our setting, double-spending still works if the second
> transaction is sent after minutes (and the first transaction has not yet
> been included into a block).

It works just the same for dust based or any other criteria that makes
transactions non-standard? including the double spending working if
the second transaction is sent minutes after. Exactly the same code is
executed and the same behavior observed for any case of a non-standard
transaction being used to achieve inconsistent forwarding.

> Our only intention is to raise the awareness for merchants who have to
> accept zero-confirmation transactions.

That is great and I'm certainly glad to see people doing that.

Though take care it that your focus on signature encoding differences
doesn't create a misunderstanding. This isn't only an issue with these
particular versions: There is always mining and relay behavior
inhomogeneity in the network. The level of inhomogeneity changes over
time? I believe its greatest when new reference client software that
changes IsStandard but it is never zero as there are large miners with
customized acceptance rules (also mempool state also creates
inhomogeneity). The greater inhomogeneity results in higher success
rates which may be important since some service could conceivable only
be profitable exploited with a high enough success rate.



From jgarzik at bitpay.com  Thu Jun 27 16:16:04 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Thu, 27 Jun 2013 12:16:04 -0400
Subject: [Bitcoin-development] Double-Spending Fast Payments in Bitcoin
 due to Client versions 0.8.1
In-Reply-To: <51CC6259.3060003@inf.ethz.ch>
References: <51CC12A6.3090100@inf.ethz.ch>
	<CAAS2fgRg8B_j=Luf31R8-+vqOWQOUcUDof8wdq79_Ar9YuUm9g@mail.gmail.com>
	<51CC6259.3060003@inf.ethz.ch>
Message-ID: <CAJHLa0MVrQN6hyuAsYNRJ2CV6fsPnAbRDSUQH+n6jfKdMiFaLQ@mail.gmail.com>

On Thu, Jun 27, 2013 at 12:03 PM, Arthur Gervais
<arthur.gervais at inf.ethz.ch> wrote:
> Our only intention is to raise the awareness for merchants who have to
> accept zero-confirmation transactions. They should be aware of the
> signature encoding difference between Bitcoin versions and the possible
> consequences.

Certainly.  Though given current P2P network node version
distributions, it is increasing difficult to relay the older version
of transaction, and will only become more so in the future.

It also remains the case that merchants who accept zero confirmation
transactions are likely already aware of the risk level, and make a
business decision.  One can see tiny digital downloads often at zero
confirmation, but rarely a Porsche or house or bitcoin exchange
deposit.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From jim618 at fastmail.co.uk  Thu Jun 27 17:10:53 2013
From: jim618 at fastmail.co.uk (Jim)
Date: Thu, 27 Jun 2013 18:10:53 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop client
	on bitcoin.org
Message-ID: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>

Hello Everybody,

Over the last few months we have been steadily adding
functionality to MultiBit including:
+ encrypted wallets
+ sign and verify message
+ stability improvements and bug fixes.

As a result of these efforts I think MultiBit is now
suitable for the entry level Bitcoin user. I propose 
that we put MultiBit as the default desktop client 
on the bitcoin.org "Choose your wallet" page.

I think a typical new user comes to bitcoin.org from a 
google search or a Bitcoin news article. We want them to 
peruse the bitcoin.org site and try out a wallet. They 
should be able to get MultiBit up and running in a tea break. 
Then perhaps they get a colleague to send them some bitcoin 
from an Android phone by zapping a QR code. 

We say: "Welcome to the Bitcoin economy !"


There is plenty MultiBit cannot do of course. However if
in the first ten minutes we get the new user interested 
there is a good chance they will go on to explore other 
Bitcoin wallets and solutions. 

Let me know if you think this is a good idea (or not!)
and if you have any questions.

Jim

https://multibit.org



From jgarzik at bitpay.com  Thu Jun 27 17:30:21 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Thu, 27 Jun 2013 13:30:21 -0400
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
Message-ID: <CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>

On Thu, Jun 27, 2013 at 1:10 PM, Jim <jim618 at fastmail.co.uk> wrote:
> Hello Everybody,
>
> Over the last few months we have been steadily adding
> functionality to MultiBit including:
> + encrypted wallets
> + sign and verify message
> + stability improvements and bug fixes.
>
> As a result of these efforts I think MultiBit is now
> suitable for the entry level Bitcoin user. I propose
> that we put MultiBit as the default desktop client
> on the bitcoin.org "Choose your wallet" page.
>
> I think a typical new user comes to bitcoin.org from a
> google search or a Bitcoin news article. We want them to
> peruse the bitcoin.org site and try out a wallet. They
> should be able to get MultiBit up and running in a tea break.
> Then perhaps they get a colleague to send them some bitcoin
> from an Android phone by zapping a QR code.

This is definitely a great discussion to have.  Here are some initial,
unprioritized thoughts.  As an engineer, there is never a clear
answer, but a balance of costs and benefits.

Arguments in favor of moving away from Bitcoin-Qt/bitcoind for wallet services:
* Bitcoin-Qt is admittedly a very simple wallet.  I see it's core
strengths more as a "P2P router" for the public blockchain data.
* Wallet feature innovation moves more slowly than
Armory/bitcoinj/blockchain.info.
* Requires the full blockchain, which is resource-intensive versus SPV.

Arguments in favor of retaining Bitcoin-Qt/bitcoind default:
* More field experience, code review and testing on desktop than others
* Very real possibility of an overall net reduction of full nodes on P2P network

Arguments in favor of multibit default:
* Good user interface, perhaps more friendly for entry level users as
you describe
* Based on bitcoinj, which has field experience and a very large
installed base thanks to Bitcoin Wallet/Schildbach

Arguments against multibit default:
* Less testing, field experience on desktop

I'm sure others can come up with a few more.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From gmaxwell at gmail.com  Thu Jun 27 17:56:54 2013
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 27 Jun 2013 10:56:54 -0700
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
Message-ID: <CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>

On Thu, Jun 27, 2013 at 10:10 AM, Jim <jim618 at fastmail.co.uk> wrote:
> Let me know if you think this is a good idea (or not!)
> and if you have any questions.

Being able to promote a fast SPV desktop wallet would be great!

I went through an cycle of testing on multibit after I saw some
complaints when it went up on the page before without at lot of
discussion. There were a number of issues with it at the time, in
particular the frequent deadlocks? though Mike was saying that those
should be fixed.

I see some of the the other things that were concerning for me at the
time are still uncorrected though, e.g. no proxy support (so users
can't follow our recommended best practices of using it with Tor),
that it reuses addresses (esp for change), that it doesn't clearly
distinguish confirmation level. It also make repeated https
connections to 141.101.113.245? (I'm not seeing the IP in the source,
and it doesn't have a useful reverse dns entry, so I can't tell what
its for).  Is there any timeframe for changing any of this stuff?



From kravets at gmail.com  Thu Jun 27 18:05:47 2013
From: kravets at gmail.com (Alex Kravets)
Date: Thu, 27 Jun 2013 11:05:47 -0700
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
Message-ID: <CALMbsiKaeUginqwM7ABRc9HoVmHd_VCH1e1P8gNkgHx0JKSy4w@mail.gmail.com>

Hi guys,

This would be a big step forward.  Anecdotally I can report that <5% of *
non-nerds* who don't abandon Bitcoin after waiting for the initial
blockchain download and *ongoing* sync on every restart, end up using
blockchain.info simply because it just works and works on their iPads &
iPhones.

Conversely, all the serious nerds end up using Armory and/or Brainwallets
for ultimate control.




On Thu, Jun 27, 2013 at 10:56 AM, Gregory Maxwell <gmaxwell at gmail.com>wrote:

> On Thu, Jun 27, 2013 at 10:10 AM, Jim <jim618 at fastmail.co.uk> wrote:
> > Let me know if you think this is a good idea (or not!)
> > and if you have any questions.
>
> Being able to promote a fast SPV desktop wallet would be great!
>
> I went through an cycle of testing on multibit after I saw some
> complaints when it went up on the page before without at lot of
> discussion. There were a number of issues with it at the time, in
> particular the frequent deadlocks? though Mike was saying that those
> should be fixed.
>
> I see some of the the other things that were concerning for me at the
> time are still uncorrected though, e.g. no proxy support (so users
> can't follow our recommended best practices of using it with Tor),
> that it reuses addresses (esp for change), that it doesn't clearly
> distinguish confirmation level. It also make repeated https
> connections to 141.101.113.245? (I'm not seeing the IP in the source,
> and it doesn't have a useful reverse dns entry, so I can't tell what
> its for).  Is there any timeframe for changing any of this stuff?
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



-- 
Alex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '
Scala <http://www.scala-lang.org/>
[[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/3a327072/attachment.html>

From luke at dashjr.org  Thu Jun 27 18:04:49 2013
From: luke at dashjr.org (Luke-Jr)
Date: Thu, 27 Jun 2013 18:04:49 +0000
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
	client on bitcoin.org
In-Reply-To: <CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
Message-ID: <201306271804.51009.luke@dashjr.org>

On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
> * Very real possibility of an overall net reduction of full nodes on P2P
> network

Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or 
MultiBit node. :/

Jim, will MultiBit be adding p2p listening support?

> I'm sure others can come up with a few more.

Possibly against: Does MultiBit still promote Bitcoin misunderstandings with 
misinformation like "from" addresses? (my apologies if I am remembering a 
different client)



From gmaxwell at gmail.com  Thu Jun 27 18:41:56 2013
From: gmaxwell at gmail.com (Gregory Maxwell)
Date: Thu, 27 Jun 2013 11:41:56 -0700
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <201306271804.51009.luke@dashjr.org>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
Message-ID: <CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>

On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
> On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
>> * Very real possibility of an overall net reduction of full nodes on P2P
>> network
> Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or
> MultiBit node. :/
> Jim, will MultiBit be adding p2p listening support?

Without validation listening isn't currently very useful. :( Maybe it
could be somewhat more with some protocol additions.



From jim618 at fastmail.co.uk  Thu Jun 27 19:18:36 2013
From: jim618 at fastmail.co.uk (Jim)
Date: Thu, 27 Jun 2013 20:18:36 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
Message-ID: <1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>

A few replies, in order of point raised:

Jeff:
Arguments against multibit default:
* Less testing, field experience on desktop

Yes this is true - downloads of multibit have typically been around
1/7th to 1/5th of bitcoin-QT downloads. It helps of course that
the bitcoinj networking/ object model is also used by Andreas 
as you note.


Greg:
I think Mike has squashed the deadlocking problems with reentrant 
locks (primarily in the Wallet). I haven't seen one in at least a month.

We discussed proxy support on the bitcoinj mailing list a while ago 
and at the time the stumbling block was the Java library used for 
the networking (Netty) did not support it. Mike or Miron would 
know better than I if this is still the case.

Change address behaviour will improve significantly when HD
wallet support goes into multibit/ bitcoinj (I am hoping to get my
bit done over the summer). Matija Mazi has been working on a 
Java impl of HD wallets so it is coming down the pipe but
there is a lot to do yet.

Connections out from MultiBit are:
+ 4 bitcoind nodes on port 8333
+ multibit.org (188.138.113.201) for help, current version info
   (and probably more in future)
+ the currency ticker will make HTTP gets to the source of
   whichever exchange(s) you have set up e.g MtGox, CampBX.
   This calls should disappear if you switch the currency conversion
   and ticker off.

I think that is all the connections out I make.

Mainly due to the exchanges abruptly changing their APIs and
breaking things we are planning to put in intermediate 
"Exchange Data Provider" servers. Tim Molter is working on this
in his XChange project. That will enable us to patch the server
when things change and the multibits in the field won't be
affected. There will probably be a couple of these initially
for redundancy.

Alex: Yes I think most users migrate to blockchain.info or,
more recently coinbase.com. They are both good wallets
but I'd like to keep Bitcoin as P2P as possible.

Luke-Jr
I think you are right here on the number of full nodes versus
SPV nodes.
I don't think we even know yet what are the working ratios of
full nodes to SPV nodes. I haven't seen anybody do any 
analysis on this.

I doubt multibit will ever participate in the Bitcoin network 
other than as an SPV client. All the optimisation is to reduce
data traffic - it is effectively a mobile wallet that happens to
live on a desktop. It is not really intended to be more than
"a wallet for regular people to store and spend their bitcoin".

In English the nomenclature for direction of the transactions
is: "Sent to" and "Received with". To be honest I 
haven't transliterated the localisation files to check other
language packs but the localisers are pretty good in my
experience.





On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:
> On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
> > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
> >> * Very real possibility of an overall net reduction of full nodes on P2P
> >> network
> > Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or
> > MultiBit node. :/
> > Jim, will MultiBit be adding p2p listening support?
> 
> Without validation listening isn't currently very useful. :( Maybe it
> could be somewhat more with some protocol additions.
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-- 
https://multibit.org    Money, reinvented



From jim618 at fastmail.co.uk  Thu Jun 27 19:40:18 2013
From: jim618 at fastmail.co.uk (Jim)
Date: Thu, 27 Jun 2013 20:40:18 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
	<1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
Message-ID: <1372362018.21506.140661249289441.6E1B5441@webmail.messagingengine.com>

RE: 141.101.113.245

http://whois.domaintools.com/141.101.113.245
gives it as CloudFlare - I suspect it is protecting
Mt Gox when we make our get for currency ticker info.


On Thu, Jun 27, 2013, at 08:18 PM, Jim wrote:
> A few replies, in order of point raised:
> 
> Jeff:
> Arguments against multibit default:
> * Less testing, field experience on desktop
> 
> Yes this is true - downloads of multibit have typically been around
> 1/7th to 1/5th of bitcoin-QT downloads. It helps of course that
> the bitcoinj networking/ object model is also used by Andreas 
> as you note.
> 
> 
> Greg:
> I think Mike has squashed the deadlocking problems with reentrant 
> locks (primarily in the Wallet). I haven't seen one in at least a month.
> 
> We discussed proxy support on the bitcoinj mailing list a while ago 
> and at the time the stumbling block was the Java library used for 
> the networking (Netty) did not support it. Mike or Miron would 
> know better than I if this is still the case.
> 
> Change address behaviour will improve significantly when HD
> wallet support goes into multibit/ bitcoinj (I am hoping to get my
> bit done over the summer). Matija Mazi has been working on a 
> Java impl of HD wallets so it is coming down the pipe but
> there is a lot to do yet.
> 
> Connections out from MultiBit are:
> + 4 bitcoind nodes on port 8333
> + multibit.org (188.138.113.201) for help, current version info
>    (and probably more in future)
> + the currency ticker will make HTTP gets to the source of
>    whichever exchange(s) you have set up e.g MtGox, CampBX.
>    This calls should disappear if you switch the currency conversion
>    and ticker off.
> 
> I think that is all the connections out I make.
> 
> Mainly due to the exchanges abruptly changing their APIs and
> breaking things we are planning to put in intermediate 
> "Exchange Data Provider" servers. Tim Molter is working on this
> in his XChange project. That will enable us to patch the server
> when things change and the multibits in the field won't be
> affected. There will probably be a couple of these initially
> for redundancy.
> 
> Alex: Yes I think most users migrate to blockchain.info or,
> more recently coinbase.com. They are both good wallets
> but I'd like to keep Bitcoin as P2P as possible.
> 
> Luke-Jr
> I think you are right here on the number of full nodes versus
> SPV nodes.
> I don't think we even know yet what are the working ratios of
> full nodes to SPV nodes. I haven't seen anybody do any 
> analysis on this.
> 
> I doubt multibit will ever participate in the Bitcoin network 
> other than as an SPV client. All the optimisation is to reduce
> data traffic - it is effectively a mobile wallet that happens to
> live on a desktop. It is not really intended to be more than
> "a wallet for regular people to store and spend their bitcoin".
> 
> In English the nomenclature for direction of the transactions
> is: "Sent to" and "Received with". To be honest I 
> haven't transliterated the localisation files to check other
> language packs but the localisers are pretty good in my
> experience.
> 
> 
> 
> 
> 
> On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:
> > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
> > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
> > >> * Very real possibility of an overall net reduction of full nodes on P2P
> > >> network
> > > Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or
> > > MultiBit node. :/
> > > Jim, will MultiBit be adding p2p listening support?
> > 
> > Without validation listening isn't currently very useful. :( Maybe it
> > could be somewhat more with some protocol additions.
> > 
> > ------------------------------------------------------------------------------
> > This SF.net email is sponsored by Windows:
> > 
> > Build for Windows Store.
> > 
> > http://p.sf.net/sfu/windows-dev2dev
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> 
> -- 
> https://multibit.org    Money, reinvented
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-- 
https://multibit.org    Money, reinvented



From jim618 at fastmail.co.uk  Thu Jun 27 19:50:00 2013
From: jim618 at fastmail.co.uk (Jim)
Date: Thu, 27 Jun 2013 20:50:00 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <1372362018.21506.140661249289441.6E1B5441@webmail.messagingengine.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
	<1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
	<1372362018.21506.140661249289441.6E1B5441@webmail.messagingengine.com>
Message-ID: <1372362600.25810.140661249292685.2513C2E6@webmail.messagingengine.com>

I missed Greg's point on confirmations.
It is definitely a challenge to explain/ visualize both:
+ has the transaction propagated the network ?
and
+ it it confirmed/ buried in a block ?

when those words probably don't mean much to
the intended audience.

The transaction status icons I *think* do it
(explained here:
https://multibit.org/en/help/v0.5/help_transactions.html).

It basically boils down to:
1) triangle or square : bad.
2) filling circle : good
3) tick mark : great.


On Thu, Jun 27, 2013, at 08:40 PM, Jim wrote:
> RE: 141.101.113.245
> 
> http://whois.domaintools.com/141.101.113.245
> gives it as CloudFlare - I suspect it is protecting
> Mt Gox when we make our get for currency ticker info.
> 
> 
> On Thu, Jun 27, 2013, at 08:18 PM, Jim wrote:
> > A few replies, in order of point raised:
> > 
> > Jeff:
> > Arguments against multibit default:
> > * Less testing, field experience on desktop
> > 
> > Yes this is true - downloads of multibit have typically been around
> > 1/7th to 1/5th of bitcoin-QT downloads. It helps of course that
> > the bitcoinj networking/ object model is also used by Andreas 
> > as you note.
> > 
> > 
> > Greg:
> > I think Mike has squashed the deadlocking problems with reentrant 
> > locks (primarily in the Wallet). I haven't seen one in at least a month.
> > 
> > We discussed proxy support on the bitcoinj mailing list a while ago 
> > and at the time the stumbling block was the Java library used for 
> > the networking (Netty) did not support it. Mike or Miron would 
> > know better than I if this is still the case.
> > 
> > Change address behaviour will improve significantly when HD
> > wallet support goes into multibit/ bitcoinj (I am hoping to get my
> > bit done over the summer). Matija Mazi has been working on a 
> > Java impl of HD wallets so it is coming down the pipe but
> > there is a lot to do yet.
> > 
> > Connections out from MultiBit are:
> > + 4 bitcoind nodes on port 8333
> > + multibit.org (188.138.113.201) for help, current version info
> >    (and probably more in future)
> > + the currency ticker will make HTTP gets to the source of
> >    whichever exchange(s) you have set up e.g MtGox, CampBX.
> >    This calls should disappear if you switch the currency conversion
> >    and ticker off.
> > 
> > I think that is all the connections out I make.
> > 
> > Mainly due to the exchanges abruptly changing their APIs and
> > breaking things we are planning to put in intermediate 
> > "Exchange Data Provider" servers. Tim Molter is working on this
> > in his XChange project. That will enable us to patch the server
> > when things change and the multibits in the field won't be
> > affected. There will probably be a couple of these initially
> > for redundancy.
> > 
> > Alex: Yes I think most users migrate to blockchain.info or,
> > more recently coinbase.com. They are both good wallets
> > but I'd like to keep Bitcoin as P2P as possible.
> > 
> > Luke-Jr
> > I think you are right here on the number of full nodes versus
> > SPV nodes.
> > I don't think we even know yet what are the working ratios of
> > full nodes to SPV nodes. I haven't seen anybody do any 
> > analysis on this.
> > 
> > I doubt multibit will ever participate in the Bitcoin network 
> > other than as an SPV client. All the optimisation is to reduce
> > data traffic - it is effectively a mobile wallet that happens to
> > live on a desktop. It is not really intended to be more than
> > "a wallet for regular people to store and spend their bitcoin".
> > 
> > In English the nomenclature for direction of the transactions
> > is: "Sent to" and "Received with". To be honest I 
> > haven't transliterated the localisation files to check other
> > language packs but the localisers are pretty good in my
> > experience.
> > 
> > 
> > 
> > 
> > 
> > On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:
> > > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
> > > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
> > > >> * Very real possibility of an overall net reduction of full nodes on P2P
> > > >> network
> > > > Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or
> > > > MultiBit node. :/
> > > > Jim, will MultiBit be adding p2p listening support?
> > > 
> > > Without validation listening isn't currently very useful. :( Maybe it
> > > could be somewhat more with some protocol additions.
> > > 
> > > ------------------------------------------------------------------------------
> > > This SF.net email is sponsored by Windows:
> > > 
> > > Build for Windows Store.
> > > 
> > > http://p.sf.net/sfu/windows-dev2dev
> > > _______________________________________________
> > > Bitcoin-development mailing list
> > > Bitcoin-development at lists.sourceforge.net
> > > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> > 
> > 
> > -- 
> > https://multibit.org    Money, reinvented
> > 
> > ------------------------------------------------------------------------------
> > This SF.net email is sponsored by Windows:
> > 
> > Build for Windows Store.
> > 
> > http://p.sf.net/sfu/windows-dev2dev
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> 
> -- 
> https://multibit.org    Money, reinvented
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-- 
https://multibit.org    Money, reinvented



From kravets at gmail.com  Thu Jun 27 21:12:34 2013
From: kravets at gmail.com (Alex Kravets)
Date: Thu, 27 Jun 2013 14:12:34 -0700
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
	<1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
Message-ID: <CALMbsi+5JYYDvy5D=22RMQ5SGtaZ2dY=FLDTRhUAv7=dAvuTeQ@mail.gmail.com>

Hi Jim,

On Thu, Jun 27, 2013 at 12:18 PM, Jim <jim618 at fastmail.co.uk> wrote:

>
> Alex: Yes I think most users migrate to blockchain.info or,
> more recently coinbase.com. They are both good wallets
> but I'd like to keep Bitcoin as P2P as possible.
>

Guys, being a late comer/outsider (I got into bitcoin in early 2012), I can
tell you that this particular asylum is definitely run by its inmates.

What all the nerdy devs (and I am one so I know) seem unable to comprehend,
is that regular people out there don't wanna learn all this new stuff and
new terminology they simply have no attention span for it.

Simply channelling them to a decent client that

1. Just works (no blockchain downloads and no re-sync)
2. Allows to retain control of the private keys

Would be HUGE for mass adoption.

Old tired argument about "Bitcoin needs your nodes", so we'll channel you
to get bitcoin-qt client is both manipulative and unnecessary (there's
plenty of nodes and NAT'ed home nodes which don't mine are mostly useless
anyways)

P.S. coinbase.com is just another trust-me setup takes your coins in
exchange for IOUs, whereas blockchain.info does let you to retain control
of your private keys.

P.P.S. The reason why coinbase has gotten so big is precisely because they
don't trouble regular lawyers and doctors with all the nonsense but simply
give them a
"buy" and a "sell" button.





> Luke-Jr
> I think you are right here on the number of full nodes versus
> SPV nodes.
> I don't think we even know yet what are the working ratios of
> full nodes to SPV nodes. I haven't seen anybody do any
> analysis on this.
>
> I doubt multibit will ever participate in the Bitcoin network
> other than as an SPV client. All the optimisation is to reduce
> data traffic - it is effectively a mobile wallet that happens to
> live on a desktop. It is not really intended to be more than
> "a wallet for regular people to store and spend their bitcoin".
>
> In English the nomenclature for direction of the transactions
> is: "Sent to" and "Received with". To be honest I
> haven't transliterated the localisation files to check other
> language packs but the localisers are pretty good in my
> experience.
>
>
>
>
>
> On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:
> > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
> > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
> > >> * Very real possibility of an overall net reduction of full nodes on
> P2P
> > >> network
> > > Even a reduction of *nodes at all*, as I've never seen a listening
> bitcoinj or
> > > MultiBit node. :/
> > > Jim, will MultiBit be adding p2p listening support?
> >
> > Without validation listening isn't currently very useful. :( Maybe it
> > could be somewhat more with some protocol additions.
> >
> >
> ------------------------------------------------------------------------------
> > This SF.net email is sponsored by Windows:
> >
> > Build for Windows Store.
> >
> > http://p.sf.net/sfu/windows-dev2dev
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
> --
> https://multibit.org    Money, reinvented
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>



-- 
Alex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '
Scala <http://www.scala-lang.org/>
[[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/1571c8d1/attachment.html>

From jgarzik at bitpay.com  Thu Jun 27 21:56:46 2013
From: jgarzik at bitpay.com (Jeff Garzik)
Date: Thu, 27 Jun 2013 17:56:46 -0400
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CALMbsi+5JYYDvy5D=22RMQ5SGtaZ2dY=FLDTRhUAv7=dAvuTeQ@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
	<1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
	<CALMbsi+5JYYDvy5D=22RMQ5SGtaZ2dY=FLDTRhUAv7=dAvuTeQ@mail.gmail.com>
Message-ID: <CAJHLa0O2vRUS+eMcSa-ggVPUNX4d8Ffb7Bs_Gp0X1SB1qz_U2A@mail.gmail.com>

On Thu, Jun 27, 2013 at 5:12 PM, Alex Kravets <kravets at gmail.com> wrote:
> What all the nerdy devs (and I am one so I know) seem unable to comprehend,
> is that regular people out there don't wanna learn all this new stuff and
> new terminology they simply have no attention span for it.

Bitcoin Wallet for Android is a decentralized client w/ network sync,
and it works just fine.  Fast, easy to use.

-- 
Jeff Garzik
Senior Software Engineer and open source evangelist
BitPay, Inc.      https://bitpay.com/



From g.rowe at froot.co.uk  Thu Jun 27 22:03:18 2013
From: g.rowe at froot.co.uk (Gary Rowe)
Date: Thu, 27 Jun 2013 23:03:18 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CALMbsi+5JYYDvy5D=22RMQ5SGtaZ2dY=FLDTRhUAv7=dAvuTeQ@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
	<1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
	<CALMbsi+5JYYDvy5D=22RMQ5SGtaZ2dY=FLDTRhUAv7=dAvuTeQ@mail.gmail.com>
Message-ID: <CAKm8k+0pCGY53QyQpsdmmjPL5_1Kx7xXD3Lz0n0RSHgcx4Bz-g@mail.gmail.com>

Many people that I have introduced Bitcoin to have balked at the massive
blockchain download. When I showed them MultiBit (and Bitcoin Wallet) they
breathed a sigh of relief and got on with it.

A currency lives or dies by network effects. If we can provide the average
low-tech user with a great client experience right from the word go then we
can win them over quickly. Once that is accomplished then more techie users
will likely go on to use a full node which will continue to strengthen the
network overall.



On 27 June 2013 22:12, Alex Kravets <kravets at gmail.com> wrote:

> Hi Jim,
>
> On Thu, Jun 27, 2013 at 12:18 PM, Jim <jim618 at fastmail.co.uk> wrote:
>
>>
>> Alex: Yes I think most users migrate to blockchain.info or,
>> more recently coinbase.com. They are both good wallets
>> but I'd like to keep Bitcoin as P2P as possible.
>>
>
> Guys, being a late comer/outsider (I got into bitcoin in early 2012), I
> can tell you that this particular asylum is definitely run by its inmates.
>
> What all the nerdy devs (and I am one so I know) seem unable to
> comprehend, is that regular people out there don't wanna learn all this new
> stuff and new terminology they simply have no attention span for it.
>
> Simply channelling them to a decent client that
>
> 1. Just works (no blockchain downloads and no re-sync)
> 2. Allows to retain control of the private keys
>
> Would be HUGE for mass adoption.
>
> Old tired argument about "Bitcoin needs your nodes", so we'll channel you
> to get bitcoin-qt client is both manipulative and unnecessary (there's
> plenty of nodes and NAT'ed home nodes which don't mine are mostly useless
> anyways)
>
> P.S. coinbase.com is just another trust-me setup takes your coins in
> exchange for IOUs, whereas blockchain.info does let you to retain control
> of your private keys.
>
> P.P.S. The reason why coinbase has gotten so big is precisely because they
> don't trouble regular lawyers and doctors with all the nonsense but simply
> give them a
> "buy" and a "sell" button.
>
>
>
>
>
>> Luke-Jr
>> I think you are right here on the number of full nodes versus
>> SPV nodes.
>> I don't think we even know yet what are the working ratios of
>> full nodes to SPV nodes. I haven't seen anybody do any
>> analysis on this.
>>
>> I doubt multibit will ever participate in the Bitcoin network
>> other than as an SPV client. All the optimisation is to reduce
>> data traffic - it is effectively a mobile wallet that happens to
>> live on a desktop. It is not really intended to be more than
>> "a wallet for regular people to store and spend their bitcoin".
>>
>> In English the nomenclature for direction of the transactions
>> is: "Sent to" and "Received with". To be honest I
>> haven't transliterated the localisation files to check other
>> language packs but the localisers are pretty good in my
>> experience.
>>
>>
>>
>>
>>
>> On Thu, Jun 27, 2013, at 07:41 PM, Gregory Maxwell wrote:
>> > On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
>> > > On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
>> > >> * Very real possibility of an overall net reduction of full nodes on
>> P2P
>> > >> network
>> > > Even a reduction of *nodes at all*, as I've never seen a listening
>> bitcoinj or
>> > > MultiBit node. :/
>> > > Jim, will MultiBit be adding p2p listening support?
>> >
>> > Without validation listening isn't currently very useful. :( Maybe it
>> > could be somewhat more with some protocol additions.
>> >
>> >
>> ------------------------------------------------------------------------------
>> > This SF.net email is sponsored by Windows:
>> >
>> > Build for Windows Store.
>> >
>> > http://p.sf.net/sfu/windows-dev2dev
>> > _______________________________________________
>> > Bitcoin-development mailing list
>> > Bitcoin-development at lists.sourceforge.net
>> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>>
>> --
>> https://multibit.org    Money, reinvented
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
>
> --
> Alex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '
> Scala <http://www.scala-lang.org/>
> [[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/18284bb8/attachment.html>

From kravets at gmail.com  Thu Jun 27 22:53:05 2013
From: kravets at gmail.com (Alex Kravets)
Date: Thu, 27 Jun 2013 15:53:05 -0700
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAJHLa0O2vRUS+eMcSa-ggVPUNX4d8Ffb7Bs_Gp0X1SB1qz_U2A@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
	<1372360716.14869.140661249272837.1376DACB@webmail.messagingengine.com>
	<CALMbsi+5JYYDvy5D=22RMQ5SGtaZ2dY=FLDTRhUAv7=dAvuTeQ@mail.gmail.com>
	<CAJHLa0O2vRUS+eMcSa-ggVPUNX4d8Ffb7Bs_Gp0X1SB1qz_U2A@mail.gmail.com>
Message-ID: <CALMbsiL_NQ9P6yRKA3rK-qa_bs2U6WNTtxUBT1i=Dh-N7LwwuQ@mail.gmail.com>

Perhaps there should be two different sections on the web page.

Nerds  / Non-Nerds

With different recommendations for which clients to use.


On Thu, Jun 27, 2013 at 2:56 PM, Jeff Garzik <jgarzik at bitpay.com> wrote:

> On Thu, Jun 27, 2013 at 5:12 PM, Alex Kravets <kravets at gmail.com> wrote:
> > What all the nerdy devs (and I am one so I know) seem unable to
> comprehend,
> > is that regular people out there don't wanna learn all this new stuff and
> > new terminology they simply have no attention span for it.
>
> Bitcoin Wallet for Android is a decentralized client w/ network sync,
> and it works just fine.  Fast, easy to use.
>
> --
> Jeff Garzik
> Senior Software Engineer and open source evangelist
> BitPay, Inc.      https://bitpay.com/
>



-- 
Alex Kravets <http://www.linkedin.com/in/akravets>       def redPill = '
Scala <http://www.scala-lang.org/>
[[ brutal honesty <http://goo.gl/vwydt> is the best policy ]]
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130627/b4e6d949/attachment.html>

From calebdelisle at lavabit.com  Thu Jun 27 23:45:59 2013
From: calebdelisle at lavabit.com (Caleb James DeLisle)
Date: Thu, 27 Jun 2013 19:45:59 -0400
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
Message-ID: <51CCCEB7.1080504@lavabit.com>



On 06/27/2013 01:56 PM, Gregory Maxwell wrote:
> On Thu, Jun 27, 2013 at 10:10 AM, Jim <jim618 at fastmail.co.uk> wrote:
>> Let me know if you think this is a good idea (or not!)
>> and if you have any questions.
> 
> Being able to promote a fast SPV desktop wallet would be great!
> 
> I went through an cycle of testing on multibit after I saw some
> complaints when it went up on the page before without at lot of
> discussion. There were a number of issues with it at the time, in
> particular the frequent deadlocks? though Mike was saying that those
> should be fixed.
> 
> I see some of the the other things that were concerning for me at the
> time are still uncorrected though, e.g. no proxy support (so users
> can't follow our recommended best practices of using it with Tor),


If I were a Bitcoin dev, I would not want to talk about anonymity or
TOR because that's likely to attract people with paranoid dilutions
and they're really terrible users to support :)

Also yay for promoting fast, easy to use clients for casual users!

Thanks,
Caleb


> that it reuses addresses (esp for change), that it doesn't clearly
> distinguish confirmation level. It also make repeated https
> connections to 141.101.113.245? (I'm not seeing the IP in the source,
> and it doesn't have a useful reverse dns entry, so I can't tell what
> its for).  Is there any timeframe for changing any of this stuff?
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 




From mike at plan99.net  Fri Jun 28 09:05:51 2013
From: mike at plan99.net (Mike Hearn)
Date: Fri, 28 Jun 2013 11:05:51 +0200
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
Message-ID: <CANEZrP2gv2qus1CKTTSFMYcNQDbrSctKmA03YE_eZFDTQsQhXw@mail.gmail.com>

> There were a number of issues with it at the time, in
> particular the frequent deadlocks? though Mike was saying that those
> should be fixed.

Yes. There were a number of lock cycles that didn't cause issues so
much when traffic was lower and as Bitcoin got more popular it became
a critical problem. I redid a lot of the concurrency to fix that, and
now all the core locks are cycle detecting so regressions should be
detected fairly fast. I'm still making changes to the concurrency
design but mostly to improve the API at this point, not fix bugs.

There is one deadlock I'm still aware of, thanks to Netty. However
it's very rare and was only reported by someone who kept a server
running for many days in a row. We want to junk Netty soon anyway.
It's a network library but it doesn't really add much value for our
use case and it turned out to have some serious design issues
internally.

> I see some of the the other things that were concerning for me at the
> time are still uncorrected though, e.g. no proxy support (so users
> can't follow our recommended best practices of using it with Tor),

Yeah. That's not the primary privacy issue with bitcoinj though. I'm
much, much more concerned about leaks via the block chain than the
network layer. Especially as Tor is basically a giant man in the
middle, without any kind of authentication you can easily end up
connected to a sybil network without any idea. I'd be surprised if Tor
usage was very high amongst Bitcoin users.

> that it reuses addresses (esp for change), that it doesn't clearly
> distinguish confirmation level.

It does actually, but the iconography is not very clear. I'm not
convinced any users really care about the difference between two and
three blocks these days. Maybe exchanges and other security-critical
applications do, but I doubt desktop users do.

It's not a library limitation anyway, it's a case of how best to
present information to a user who is not familiar with how Bitcoin
works. "Safe" and "Not safe" is still a rather misleading distinction
given the general absence of double spends against mempool
transactions, but it's still a lot more meaningful than "2 confirms"
vs "3 confirms", something that would just make a new user ask what
the heck a confirm is.



From mike at plan99.net  Fri Jun 28 09:10:32 2013
From: mike at plan99.net (Mike Hearn)
Date: Fri, 28 Jun 2013 11:10:32 +0200
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
Message-ID: <CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>

> Arguments in favor of retaining Bitcoin-Qt/bitcoind default:
> * More field experience, code review and testing on desktop than others

I'm hoping that if we start promoting alternative wallets their dev
communities will get larger. Most bitcoinj code is peer reviewed, but
not to the same extent that Bitcoin-Qt is.

We're obviously not going to stop promoting Bitcoin-Qt as well. I
think the distinction should be:

 * Want to get started fast? Grab MultiBit and you'll be under way in
a couple of minutes.
 * Want to help out the Bitcoin network? Leave your computer switched
on all the time and run Bitcoin-Qt instead. It will donate some of
your computers resources to running the Bitcoin system.

The MultiBit interface is OK but all desktop wallets could use some
love from a friendly UI designer.



From john.dillon892 at googlemail.com  Fri Jun 28 10:09:16 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Fri, 28 Jun 2013 10:09:16 +0000
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CANEZrP2gv2qus1CKTTSFMYcNQDbrSctKmA03YE_eZFDTQsQhXw@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
	<CANEZrP2gv2qus1CKTTSFMYcNQDbrSctKmA03YE_eZFDTQsQhXw@mail.gmail.com>
Message-ID: <CAPaL=UV6vhVK6W0FiVoqM+=9C9TAUXVKwbuynq3NZYFzFR8TTQ@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On Fri, Jun 28, 2013 at 9:05 AM, Mike Hearn <mike at plan99.net> wrote:
>> I see some of the the other things that were concerning for me at the
>> time are still uncorrected though, e.g. no proxy support (so users
>> can't follow our recommended best practices of using it with Tor),
>
> Yeah. That's not the primary privacy issue with bitcoinj though. I'm
> much, much more concerned about leaks via the block chain than the
> network layer. Especially as Tor is basically a giant man in the
> middle, without any kind of authentication you can easily end up
> connected to a sybil network without any idea. I'd be surprised if Tor
> usage was very high amongst Bitcoin users.

Tor does not act as a particularly effective man in the middle for nodes
that support connections to hidden services because while your
connections to standard Bitcoin nodes go through your exit node, the
routing path for each hidden service peer is independent. Having said
that we should offer modes that send your self-generated transactions
out via Tor, while still maintaining non-Tor connections.

Anyway Sybil attacks aren't all that interesting if you are the one
sending the funds, and receivers are reasonably well protected simply
because generating false confirmations is extremely expensive and very
difficult to do quickly. After all, you always make the assumption that
nearly all hashing power in existence is honest when you talk about
replace-by-fee among other things, and that assumption naturally leads
to the conclusion that generating false confirmations with a sybil
attack would take more than long enough that the user would be
suspicious that something was wrong long before being defrauded.

I'd be surprised if anyone has ever bothered with a false confirmation
sybil attack. I wouldn't be the slightest bit surprised if the NSA is
recording all the Bitcoin traffic they can for future analysis to find
true transaction origins. Which reminds me, again, we need node-to-node
connections to be encrypted to at least protect against network-wide
passive sniffiing.

Regarding usage I would be interested to hear from those running Bitcoin
nodes advertising themselves as hidden services.

> It's not a library limitation anyway, it's a case of how best to
> present information to a user who is not familiar with how Bitcoin
> works. "Safe" and "Not safe" is still a rather misleading distinction
> given the general absence of double spends against mempool
> transactions, but it's still a lot more meaningful than "2 confirms"

For what it is worth I ran a double-spend generator a month or so ago
against the replace-by-fee node that Peter setup and I found that a
small number of the double-spends did in fact appear to be mined under
replace-by-fee rules.

Specifically the generator would create a transaction from confirmed
inputs, wait 60-180 seconds (randomized) to allow for full propagation,
and then create a double-spend if the transaction hadn't already been
mined. The transactions were randomized to look like normal traffic,
including occasional bets to Satoshidice and similar for fun. (for the
record the script had no way of knowing if a bet won and would happily
attempt to double-spend wins) Fees for the replacement were power-law
distributed IIRC, with some occasionally set to be quite hefty.

Though possibly just an artifact of unusually slow transaction
propagation it appeared that about 0.25% of hashing power was following
replace-by-fee rules. (not including transactions involving gambling, I
know Eligius and perhaps others block such transactions from their
mempools making double-spends easy to accomplish by including
Satoshidice outputs)

I'm actually surprised by that figure myself given Peter Todd and I
haven't made a serious attempt yet to get miners to use replace-by-fee
rules. An interesting experiment would be to advertise that money is
being given away by such a tx generator in the mining forum, although I
would prefer to see solid mempool support for the "scorched-earth"
double-spend countermeasure first; Peter sounds like he has some great
ideas there, although as usual I am seeing very little in the way of
code. :)
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRzWCOAAoJEEWCsU4mNhiPwhgH/ic/OJMCYwdIuEM2ArSAEQRY
l5bqafMYMcC/KE9xqZ1HVkLJ9Zg57MQ8VZw95WOsmRgNA0v1xIoCyREjI84QkCIq
R/hOgS97eJc+XXnPBVoB4Jadq5LQ6jNpJo7cmiLJjCEmE6rTxLZBBT4P3eQw8oIn
WAd7X7utP7/QAkjhaWB9FsfWT8QZseqpSPv8WucRftsRCABurzuD+eSfpRqYwk2z
XBD0zO+EyAtu6hB3dRAFhqnhVfEcOLJCtXpm76WO574H4AZ/8EN+HozLJSUtylCq
j1NZnpj/6pdFh2v5Pid4HEMEvuNNX60u6iXGJ560PUsdKmOh+LEhUBLKd9acJTw=
=QtjI
-----END PGP SIGNATURE-----



From mike at plan99.net  Fri Jun 28 10:20:03 2013
From: mike at plan99.net (Mike Hearn)
Date: Fri, 28 Jun 2013 12:20:03 +0200
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAPaL=UV6vhVK6W0FiVoqM+=9C9TAUXVKwbuynq3NZYFzFR8TTQ@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
	<CANEZrP2gv2qus1CKTTSFMYcNQDbrSctKmA03YE_eZFDTQsQhXw@mail.gmail.com>
	<CAPaL=UV6vhVK6W0FiVoqM+=9C9TAUXVKwbuynq3NZYFzFR8TTQ@mail.gmail.com>
Message-ID: <CANEZrP07LOEDK7wV3afJJN9cEw8xQHoqA=Jk_GrQs2jrpCBC7w@mail.gmail.com>

I suspect what you saw is mining nodes restarting and clearing their
mempools out rather than an explicit policy of replace by fee.

On Fri, Jun 28, 2013 at 12:09 PM, John Dillon
<john.dillon892 at googlemail.com> wrote:
> -----BEGIN PGP SIGNED MESSAGE-----
> Hash: SHA256
>
> On Fri, Jun 28, 2013 at 9:05 AM, Mike Hearn <mike at plan99.net> wrote:
>>> I see some of the the other things that were concerning for me at the
>>> time are still uncorrected though, e.g. no proxy support (so users
>>> can't follow our recommended best practices of using it with Tor),
>>
>> Yeah. That's not the primary privacy issue with bitcoinj though. I'm
>> much, much more concerned about leaks via the block chain than the
>> network layer. Especially as Tor is basically a giant man in the
>> middle, without any kind of authentication you can easily end up
>> connected to a sybil network without any idea. I'd be surprised if Tor
>> usage was very high amongst Bitcoin users.
>
> Tor does not act as a particularly effective man in the middle for nodes
> that support connections to hidden services because while your
> connections to standard Bitcoin nodes go through your exit node, the
> routing path for each hidden service peer is independent. Having said
> that we should offer modes that send your self-generated transactions
> out via Tor, while still maintaining non-Tor connections.
>
> Anyway Sybil attacks aren't all that interesting if you are the one
> sending the funds, and receivers are reasonably well protected simply
> because generating false confirmations is extremely expensive and very
> difficult to do quickly. After all, you always make the assumption that
> nearly all hashing power in existence is honest when you talk about
> replace-by-fee among other things, and that assumption naturally leads
> to the conclusion that generating false confirmations with a sybil
> attack would take more than long enough that the user would be
> suspicious that something was wrong long before being defrauded.
>
> I'd be surprised if anyone has ever bothered with a false confirmation
> sybil attack. I wouldn't be the slightest bit surprised if the NSA is
> recording all the Bitcoin traffic they can for future analysis to find
> true transaction origins. Which reminds me, again, we need node-to-node
> connections to be encrypted to at least protect against network-wide
> passive sniffiing.
>
> Regarding usage I would be interested to hear from those running Bitcoin
> nodes advertising themselves as hidden services.
>
>> It's not a library limitation anyway, it's a case of how best to
>> present information to a user who is not familiar with how Bitcoin
>> works. "Safe" and "Not safe" is still a rather misleading distinction
>> given the general absence of double spends against mempool
>> transactions, but it's still a lot more meaningful than "2 confirms"
>
> For what it is worth I ran a double-spend generator a month or so ago
> against the replace-by-fee node that Peter setup and I found that a
> small number of the double-spends did in fact appear to be mined under
> replace-by-fee rules.
>
> Specifically the generator would create a transaction from confirmed
> inputs, wait 60-180 seconds (randomized) to allow for full propagation,
> and then create a double-spend if the transaction hadn't already been
> mined. The transactions were randomized to look like normal traffic,
> including occasional bets to Satoshidice and similar for fun. (for the
> record the script had no way of knowing if a bet won and would happily
> attempt to double-spend wins) Fees for the replacement were power-law
> distributed IIRC, with some occasionally set to be quite hefty.
>
> Though possibly just an artifact of unusually slow transaction
> propagation it appeared that about 0.25% of hashing power was following
> replace-by-fee rules. (not including transactions involving gambling, I
> know Eligius and perhaps others block such transactions from their
> mempools making double-spends easy to accomplish by including
> Satoshidice outputs)
>
> I'm actually surprised by that figure myself given Peter Todd and I
> haven't made a serious attempt yet to get miners to use replace-by-fee
> rules. An interesting experiment would be to advertise that money is
> being given away by such a tx generator in the mining forum, although I
> would prefer to see solid mempool support for the "scorched-earth"
> double-spend countermeasure first; Peter sounds like he has some great
> ideas there, although as usual I am seeing very little in the way of
> code. :)
> -----BEGIN PGP SIGNATURE-----
> Version: GnuPG v1.4.11 (GNU/Linux)
>
> iQEcBAEBCAAGBQJRzWCOAAoJEEWCsU4mNhiPwhgH/ic/OJMCYwdIuEM2ArSAEQRY
> l5bqafMYMcC/KE9xqZ1HVkLJ9Zg57MQ8VZw95WOsmRgNA0v1xIoCyREjI84QkCIq
> R/hOgS97eJc+XXnPBVoB4Jadq5LQ6jNpJo7cmiLJjCEmE6rTxLZBBT4P3eQw8oIn
> WAd7X7utP7/QAkjhaWB9FsfWT8QZseqpSPv8WucRftsRCABurzuD+eSfpRqYwk2z
> XBD0zO+EyAtu6hB3dRAFhqnhVfEcOLJCtXpm76WO574H4AZ/8EN+HozLJSUtylCq
> j1NZnpj/6pdFh2v5Pid4HEMEvuNNX60u6iXGJ560PUsdKmOh+LEhUBLKd9acJTw=
> =QtjI
> -----END PGP SIGNATURE-----



From john.dillon892 at googlemail.com  Fri Jun 28 10:25:28 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Fri, 28 Jun 2013 10:25:28 +0000
Subject: [Bitcoin-development] Proposal: Vote on the blocksize limit
 with proof-of-stake voting
In-Reply-To: <CAKaEYhL2YY6wWnUYJuwWo2czHq7hRiYsQouR1B64oE31ZEochg@mail.gmail.com>
References: <CAPaL=UWcKmnChw0zYGVduzHHdQ-AgG7uqbCLvjjuW6Q67zmS0g@mail.gmail.com>
	<CAKaEYhL2YY6wWnUYJuwWo2czHq7hRiYsQouR1B64oE31ZEochg@mail.gmail.com>
Message-ID: <CAPaL=UUYOQQiLO4pn_83_VRihebq-n3892pxpar2mH_9fXYh0w@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

> Thinking about this a little more, I guess it does not hurt to build some
> kind of voting system into the clients.  But I think it's more useful for
> straw polls.  For example a bug fix 100% of people should agree on.  A
> protocol optimization perhaps 80% would agree on.  A protocol change that
> redistributes wealth or incentives perhaps only 60% will agree on.
>
> At this point in time it's far too easy to deliver contentious changes into
> the hands of the general population.  I think that fortunately we're blessed
> with a very strong dev team, but the fundamental philosophy of bitcoin is to
> not put too much trust in single point, but rather, to distribute and
> diversify trust to the edges.

I disagree entirely. Your example of "straw polls" for bug fixes and
features is precisely what the current method of rough consensus and
running code, an IETF expression, handles just fine.

What the method does not handle effectively are issues that are
fundementally political rather than technical in nature. Blocksize is
precisely the latter because while the tradeoffs are technical in
nature the fundemental issue at hand is what do we want Bitcoin to be?
Who are we going to allow to participate?
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRzWR7AAoJEEWCsU4mNhiPEYsIAME+VvS4vfE0PdOMv3vHWGSH
HwUJdtKPold4+p0jhPBKSMbgnpMvXsZezMIIxj8xehnblnVuUdyakibXAdgVNLvp
a6SCw+W/VnopYCw151zZ4FQS92KQuSbX+XmYTQy32oqZIXtBmTE1fydw5q6YhoXb
gCCygPRyLTIQxLZAxqqRrQ0nsSE5ID5kDcr+xRsmCvfIKrzoOCbYL+nXPCB4Zzgu
Gs7Lfa0yfTrUlQmoDseyoWrVuhfYuFNesTAs3z6imMTdHqZh8Z+a+gmC+G9qFO1h
y7hOmzW4oz7hH4R2F6M+UpV6rKdwMaNYwrDw5eHClDgGYNfjjVduQ/YMQnbjyAc=
=5mhd
-----END PGP SIGNATURE-----



From john.dillon892 at googlemail.com  Fri Jun 28 10:32:38 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Fri, 28 Jun 2013 10:32:38 +0000
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CANEZrP07LOEDK7wV3afJJN9cEw8xQHoqA=Jk_GrQs2jrpCBC7w@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
	<CANEZrP2gv2qus1CKTTSFMYcNQDbrSctKmA03YE_eZFDTQsQhXw@mail.gmail.com>
	<CAPaL=UV6vhVK6W0FiVoqM+=9C9TAUXVKwbuynq3NZYFzFR8TTQ@mail.gmail.com>
	<CANEZrP07LOEDK7wV3afJJN9cEw8xQHoqA=Jk_GrQs2jrpCBC7w@mail.gmail.com>
Message-ID: <CAPaL=UXD==EdqcjAQiR+jQMOJYJ7AqB9m8OyDzTwgqScTf33Hg@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On Fri, Jun 28, 2013 at 10:20 AM, Mike Hearn <mike at plan99.net> wrote:
> I suspect what you saw is mining nodes restarting and clearing their
> mempools out rather than an explicit policy of replace by fee.

Possibly, but it is a rather short window of opportunity and the mining node
would have to be connected directly, to Peter's replace-by-fee node. I also
took care to ensure transactions were only ever broadcast once. (I disabled the
wallet rebroadcast mechanism)
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRzWYWAAoJEEWCsU4mNhiP3fIIAJLFxMnjI4BGRrNLsxs0hXp0
zDCgiZ6UnZa5JRcd/6KjV3hnPHwweGEjChGfrzY/Fxo4Pga1lQFlp8E8PaFUJq50
r6LTNJQLW50r5mFkZ6Mkh877WwX/OHBzkp8SqbbD7+dDBV7R9LqLYqLTHgObKxg1
V9UjGRJiMohW8HLdOzEXOz1ugoBCjR+vyQW5ZD2nZVcQlIhxSIgeC/M46oxMN7pE
Y5EepCQehNPuc1On7TtJ9LlmFJ6Dvsl6dqwKNWMi1lgBTiw7abdTJne2B/KeDyom
vhGuhmpMLGKKgJns3hne3yQM+Ivi3jLIHKejcoCm1JkSCdjw48XkyGd0V359M3w=
=qyyq
-----END PGP SIGNATURE-----



From john.dillon892 at googlemail.com  Fri Jun 28 10:59:32 2013
From: john.dillon892 at googlemail.com (John Dillon)
Date: Fri, 28 Jun 2013 10:59:32 +0000
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<201306271804.51009.luke@dashjr.org>
	<CAAS2fgRE+gj0NrDMk-WamSU+mADJM1EqgR-6Sa2MNCbwq-0Gdw@mail.gmail.com>
Message-ID: <CAPaL=UWt3n6NDRB_N0sUvSH1k=RZotL+LchON75NpKVG2JKEHw@mail.gmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

On Thu, Jun 27, 2013 at 6:41 PM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
> On Thu, Jun 27, 2013 at 11:04 AM, Luke-Jr <luke at dashjr.org> wrote:
>> On Thursday, June 27, 2013 5:30:21 PM Jeff Garzik wrote:
>>> * Very real possibility of an overall net reduction of full nodes on P2P
>>> network
>> Even a reduction of *nodes at all*, as I've never seen a listening bitcoinj or
>> MultiBit node. :/
>> Jim, will MultiBit be adding p2p listening support?
>
> Without validation listening isn't currently very useful. :( Maybe it
> could be somewhat more with some protocol additions.

Possible non-validation data that can be usefully propagated:

1) Block headers.

2) *Confirmed* transactions linked to an aformentioned blockheader.

3) Proof-of-work/sacrifice limited P2P messages, for instance to
co-ordinate trust-free-mixes or act as a communication channel for
micropayment channels.

4) With UTXO existance proof support propagate transactions
accompanied by proofs that all inputs exist. This would also allow for
implementation of Peter's low-bandwidth decentralized P2Pool proposal.

5) UTXO fraud proofs. (one day)


Strictly speaking #2 doesn't even need the protocol to be changed
actually as it can be handled entirely within the existing INV/getdata
mechanism. Sure someone could throw away a lot of hashing power and
get an invalid block propagated, but really so what? SPV nodes should
always take confirmations with a grain of salt anyway.
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQEcBAEBCAAGBQJRzWx8AAoJEEWCsU4mNhiPlTkIAJKzFsT65o6LoU70hbaBsu3g
aBdjYZSCnJ9+qWI2tqqUBedq2etbt71hAfWNnTXvFus+0iVB1HWJClW155319vuH
Xi1m9G3O0NzX1d+cssMPxFBHsl4Rz6XYICrYyVEe2X554Zawdg6I53+1INHRfsBT
1vmq5Bxgopt0Tk9Vf8HNdRt/IXZJaPYm1PEzJHFppuOvl5+Fpypy3t/QXdsP8puP
LnRdL7Bxfu3BSWrSRZo7l5Fpww3Y/vdNYCL4jDD/ME+36wi4CUM3psL8lsk81lB4
3t/ytF4y/adT/dEEtMj7BGWS0TIMMH0NyeCjqBdStiQsVfoowLCVfpuDzouZ6yY=
=TI1m
-----END PGP SIGNATURE-----



From gavinandresen at gmail.com  Fri Jun 28 14:24:16 2013
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 28 Jun 2013 10:24:16 -0400
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
Message-ID: <CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>

I vote "yes" to have MultiBit replace Bitcoin-Qt as the recommended
desktop wallet app. I think most users will be happier with it.

If I'm wrong, it is easy to change back.



From billhees at gmail.com  Fri Jun 28 20:37:04 2013
From: billhees at gmail.com (Bill Hees)
Date: Fri, 28 Jun 2013 13:37:04 -0700
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAFtwHRewE0wgvWsf-785hpCb8ns7wiGaKHAQ-1QmDD-W+diBJA@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
	<CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>
	<CAFtwHRewE0wgvWsf-785hpCb8ns7wiGaKHAQ-1QmDD-W+diBJA@mail.gmail.com>
Message-ID: <CAFtwHReqVCZAuoik24Sm=K0eCF1CGtEtxkAYVnoueTgCRT10mA@mail.gmail.com>

There are good, valid arguments in support of promoting both the reference
client, Bitcoin-QT, and for offering a lighter-weight alternative. Why not
outline these arguments on bitcoin.org and provide links to each; or even
links to a variety of alternative wallet solutions alongside descriptions
of their respective benefits and drawbacks? Is there an advantage to having
a singular "recommended" client?


On Fri, Jun 28, 2013 at 1:35 PM, Bill Hees <billhees at gmail.com> wrote:

> There are good, valid arguments in support of promoting both the reference
> client, Bitcoin-QT, and for offering a lighter-weight alternative. Why not
> outline these arguments on bitcoin.org and provide links to each; or even
> links to a variety of alternative wallet solutions alongside descriptions
> of their respective benefits and drawbacks? Is there an advantage to having
> a singular "recommended" client?
>
>
> On Fri, Jun 28, 2013 at 7:24 AM, Gavin Andresen <gavinandresen at gmail.com>wrote:
>
>> I vote "yes" to have MultiBit replace Bitcoin-Qt as the recommended
>> desktop wallet app. I think most users will be happier with it.
>>
>> If I'm wrong, it is easy to change back.
>>
>>
>> ------------------------------------------------------------------------------
>> This SF.net email is sponsored by Windows:
>>
>> Build for Windows Store.
>>
>> http://p.sf.net/sfu/windows-dev2dev
>> _______________________________________________
>> Bitcoin-development mailing list
>> Bitcoin-development at lists.sourceforge.net
>> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130628/09f689ed/attachment.html>

From jim618 at fastmail.co.uk  Fri Jun 28 20:42:27 2013
From: jim618 at fastmail.co.uk (Jim)
Date: Fri, 28 Jun 2013 21:42:27 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAFtwHReqVCZAuoik24Sm=K0eCF1CGtEtxkAYVnoueTgCRT10mA@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
	<CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>
	<CAFtwHRewE0wgvWsf-785hpCb8ns7wiGaKHAQ-1QmDD-W+diBJA@mail.gmail.com>
	<CAFtwHReqVCZAuoik24Sm=K0eCF1CGtEtxkAYVnoueTgCRT10mA@mail.gmail.com>
Message-ID: <1372452147.8254.140661249720981.6D2C7437@webmail.messagingengine.com>

There are already descriptions as you describe on:
http://bitcoin.org/en/choose-your-wallet. 

If you hover over any of the wallet icons you get a description and a
link.

People being people, we find in practice that the very first wallet link 
on the page is what the majority of new users click.



On Fri, Jun 28, 2013, at 09:37 PM, Bill Hees wrote:
> There are good, valid arguments in support of promoting both the
> reference
> client, Bitcoin-QT, and for offering a lighter-weight alternative. Why
> not
> outline these arguments on bitcoin.org and provide links to each; or even
> links to a variety of alternative wallet solutions alongside descriptions
> of their respective benefits and drawbacks? Is there an advantage to
> having
> a singular "recommended" client?
> 
> 
> On Fri, Jun 28, 2013 at 1:35 PM, Bill Hees <billhees at gmail.com> wrote:
> 
> > There are good, valid arguments in support of promoting both the reference
> > client, Bitcoin-QT, and for offering a lighter-weight alternative. Why not
> > outline these arguments on bitcoin.org and provide links to each; or even
> > links to a variety of alternative wallet solutions alongside descriptions
> > of their respective benefits and drawbacks? Is there an advantage to having
> > a singular "recommended" client?
> >
> >
> > On Fri, Jun 28, 2013 at 7:24 AM, Gavin Andresen <gavinandresen at gmail.com>wrote:
> >
> >> I vote "yes" to have MultiBit replace Bitcoin-Qt as the recommended
> >> desktop wallet app. I think most users will be happier with it.
> >>
> >> If I'm wrong, it is easy to change back.
> >>
> >>
> >> ------------------------------------------------------------------------------
> >> This SF.net email is sponsored by Windows:
> >>
> >> Build for Windows Store.
> >>
> >> http://p.sf.net/sfu/windows-dev2dev
> >> _______________________________________________
> >> Bitcoin-development mailing list
> >> Bitcoin-development at lists.sourceforge.net
> >> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >>
> >
> >
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-- 
https://multibit.org    Money, reinvented



From pete at petertodd.org  Sun Jun 30 10:12:39 2013
From: pete at petertodd.org (Peter Todd)
Date: Sun, 30 Jun 2013 06:12:39 -0400
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CAPaL=UV6vhVK6W0FiVoqM+=9C9TAUXVKwbuynq3NZYFzFR8TTQ@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAAS2fgTka6Dw94V0-vHBHxG=zadu9EmhKmfVm7Y_dQUUgrTf6w@mail.gmail.com>
	<CANEZrP2gv2qus1CKTTSFMYcNQDbrSctKmA03YE_eZFDTQsQhXw@mail.gmail.com>
	<CAPaL=UV6vhVK6W0FiVoqM+=9C9TAUXVKwbuynq3NZYFzFR8TTQ@mail.gmail.com>
Message-ID: <20130630101239.GA1142@savin>

On Fri, Jun 28, 2013 at 10:09:16AM +0000, John Dillon wrote:
> true transaction origins. Which reminds me, again, we need node-to-node
> connections to be encrypted to at least protect against network-wide
> passive sniffiing.

Agreed.

Speaking of, I may have missed it but as far as I can tell Bitmessage
doesn't encrypt node-to-node communications, a serious oversight. Any
attacker that can sniff a large fraction of the network, like the NSA,
can easily use this to track down the originating node of any message,
just like they can do with Bitcoin.

> For what it is worth I ran a double-spend generator a month or so ago
> against the replace-by-fee node that Peter setup and I found that a
> small number of the double-spends did in fact appear to be mined under
> replace-by-fee rules.

Ah! I had a feeling that might be you. Were you the person who was
creating the 1BTC fee transactions as well?

> Though possibly just an artifact of unusually slow transaction
> propagation it appeared that about 0.25% of hashing power was following
> replace-by-fee rules. (not including transactions involving gambling, I
> know Eligius and perhaps others block such transactions from their
> mempools making double-spends easy to accomplish by including
> Satoshidice outputs)

I just got an email from someone saying they had a few Avalons with that
patch installed actually; that was probably them.

> I'm actually surprised by that figure myself given Peter Todd and I
> haven't made a serious attempt yet to get miners to use replace-by-fee
> rules. An interesting experiment would be to advertise that money is
> being given away by such a tx generator in the mining forum, although I
> would prefer to see solid mempool support for the "scorched-earth"
> double-spend countermeasure first; Peter sounds like he has some great
> ideas there, although as usual I am seeing very little in the way of
> code. :)

Keep in mind it's not just the mempool that needs changing - the network
protocol semantics need to change too. For the "scorched-earth" strategy
to work you need nodes tell their peers about the total fees a
transaction has attached in addition tot he tx hash. Essentially you are
advertising to your peers what would right now be an orphan, and your
peers need to recursively get dependencies; I'm sure there's a bunch of
edge cases there that would be need to thought out carefully. It's
useful for a lot of things though, for instance when a zero-fee,
zero-priority tx is given to a merchant who now wants to tell miners to
mine it anyway due to a child tx.

What I'd recommend actually for the nearer term is just adding recursive
fee evaluation with a depth*breadth anti-DoS limit, adding the rpc and
GUI adjfee and canceltx commands, adding better wallet support for
conflicts, (someone is already workng on this) and adding a service bit
with preferential peering.

By preferential peering I mean you set aside a portion of your outgoing
peer slots for peers with certain bits set and only fill those slots
with those peers. In addition you can have DNS seeds return peers with
specified service bits set: x0000000000000003.v1.seed.petertodd.org
could be nodes with the first and second bits set. (we might want to
define the upper 8 service bits as a service bit version field so we can
redefine the other 56 in the far off future if required)

-- 
'peter'[:-1]@petertodd.org
00000000000000b2b1f2ca2a2f937c2d93c41a5d089e1d3d4fe6bb663dd25db5
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130630/6b399767/attachment.sig>

From mike at plan99.net  Sun Jun 30 11:42:31 2013
From: mike at plan99.net (Mike Hearn)
Date: Sun, 30 Jun 2013 13:42:31 +0200
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
	<CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>
Message-ID: <CANEZrP3LGxZ6E+9UWQH+_RN66dfeGzo4+QYACjauKRufpqB2QA@mail.gmail.com>

Sounds like we have consensus, Saivann, shall we do it?

I'm also going to ask Theymos again to relax the newbie restrictions
for the alt client forums. It's probably too hard to get support at
the moment and "email jim" doesn't scale at all.

On Fri, Jun 28, 2013 at 4:24 PM, Gavin Andresen <gavinandresen at gmail.com> wrote:
> I vote "yes" to have MultiBit replace Bitcoin-Qt as the recommended
> desktop wallet app. I think most users will be happier with it.
>
> If I'm wrong, it is easy to change back.
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development



From jim618 at fastmail.co.uk  Sun Jun 30 15:19:29 2013
From: jim618 at fastmail.co.uk (Jim)
Date: Sun, 30 Jun 2013 16:19:29 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <CANEZrP3LGxZ6E+9UWQH+_RN66dfeGzo4+QYACjauKRufpqB2QA@mail.gmail.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
	<CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>
	<CANEZrP3LGxZ6E+9UWQH+_RN66dfeGzo4+QYACjauKRufpqB2QA@mail.gmail.com>
Message-ID: <1372605569.4937.140661250186789.39404E47@webmail.messagingengine.com>

Yeah "email jim' was never going to work so I have
bumped up MultiBit support (a bit) by:

+ having a dedicated Support page on the website
   https://multibit.org/support.html
   It has fixes and support notes for the most common gotchas.
+ the in-app help also now has a 'Support' section with 
   "Troubleshooting' and the commonest gotchas.
   I've also written more help to cover as much as possible.
+ Failing that people are directed first to bitcoin.stackchange.com
   (I have a notification set up for the 'multibit' keyword.
+ Then finally users are directed to the github issues to search 
   existing or raise a new issue. Gary and Tim often chip in on there to
   close 
   issues down as well as me.



On Sun, Jun 30, 2013, at 12:42 PM, Mike Hearn wrote:
> Sounds like we have consensus, Saivann, shall we do it?
> 
> I'm also going to ask Theymos again to relax the newbie restrictions
> for the alt client forums. It's probably too hard to get support at
> the moment and "email jim" doesn't scale at all.
> 
> On Fri, Jun 28, 2013 at 4:24 PM, Gavin Andresen <gavinandresen at gmail.com>
> wrote:
> > I vote "yes" to have MultiBit replace Bitcoin-Qt as the recommended
> > desktop wallet app. I think most users will be happier with it.
> >
> > If I'm wrong, it is easy to change back.
> >
> > ------------------------------------------------------------------------------
> > This SF.net email is sponsored by Windows:
> >
> > Build for Windows Store.
> >
> > http://p.sf.net/sfu/windows-dev2dev
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> 
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
> 
> Build for Windows Store.
> 
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development


-- 
https://multibit.org    Money, reinvented



From g.rowe at froot.co.uk  Sun Jun 30 16:39:02 2013
From: g.rowe at froot.co.uk (Gary Rowe)
Date: Sun, 30 Jun 2013 17:39:02 +0100
Subject: [Bitcoin-development] Proposal: MultiBit as default desktop
 client on bitcoin.org
In-Reply-To: <1372605569.4937.140661250186789.39404E47@webmail.messagingengine.com>
References: <1372353053.10405.140661249237317.77984E1F@webmail.messagingengine.com>
	<CAJHLa0Ncac9Xt-AQBnpghqqpfR-j6Xtd9qVQoUe2dPp0kJvz1A@mail.gmail.com>
	<CANEZrP0k1HDrJC9DOn6JYiVcaRRXwVwxW7ZPjE9XvfTCHXX6pw@mail.gmail.com>
	<CABsx9T3GJN0inGChebJt_dRLpVrPw7BTH8oQo6F4q6yFJaOoCA@mail.gmail.com>
	<CANEZrP3LGxZ6E+9UWQH+_RN66dfeGzo4+QYACjauKRufpqB2QA@mail.gmail.com>
	<1372605569.4937.140661250186789.39404E47@webmail.messagingengine.com>
Message-ID: <CAKm8k+20z0FkQjnYXjBwUSwY4ncTmMc-LXDH=hF6u55f_gWpkA@mail.gmail.com>

I've beefed up the supporting documentation for the website to make it more
accessible for developers who wish to contribute. It's a Java application
serving HTML.

It can be found here: https://github.com/jim618/multibit-website


On 30 June 2013 16:19, Jim <jim618 at fastmail.co.uk> wrote:

> Yeah "email jim' was never going to work so I have
> bumped up MultiBit support (a bit) by:
>
> + having a dedicated Support page on the website
>    https://multibit.org/support.html
>    It has fixes and support notes for the most common gotchas.
> + the in-app help also now has a 'Support' section with
>    "Troubleshooting' and the commonest gotchas.
>    I've also written more help to cover as much as possible.
> + Failing that people are directed first to bitcoin.stackchange.com
>    (I have a notification set up for the 'multibit' keyword.
> + Then finally users are directed to the github issues to search
>    existing or raise a new issue. Gary and Tim often chip in on there to
>    close
>    issues down as well as me.
>
>
>
> On Sun, Jun 30, 2013, at 12:42 PM, Mike Hearn wrote:
> > Sounds like we have consensus, Saivann, shall we do it?
> >
> > I'm also going to ask Theymos again to relax the newbie restrictions
> > for the alt client forums. It's probably too hard to get support at
> > the moment and "email jim" doesn't scale at all.
> >
> > On Fri, Jun 28, 2013 at 4:24 PM, Gavin Andresen <gavinandresen at gmail.com
> >
> > wrote:
> > > I vote "yes" to have MultiBit replace Bitcoin-Qt as the recommended
> > > desktop wallet app. I think most users will be happier with it.
> > >
> > > If I'm wrong, it is easy to change back.
> > >
> > >
> ------------------------------------------------------------------------------
> > > This SF.net email is sponsored by Windows:
> > >
> > > Build for Windows Store.
> > >
> > > http://p.sf.net/sfu/windows-dev2dev
> > > _______________________________________________
> > > Bitcoin-development mailing list
> > > Bitcoin-development at lists.sourceforge.net
> > > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
> >
> >
> ------------------------------------------------------------------------------
> > This SF.net email is sponsored by Windows:
> >
> > Build for Windows Store.
> >
> > http://p.sf.net/sfu/windows-dev2dev
> > _______________________________________________
> > Bitcoin-development mailing list
> > Bitcoin-development at lists.sourceforge.net
> > https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
>
> --
> https://multibit.org    Money, reinvented
>
>
> ------------------------------------------------------------------------------
> This SF.net email is sponsored by Windows:
>
> Build for Windows Store.
>
> http://p.sf.net/sfu/windows-dev2dev
> _______________________________________________
> Bitcoin-development mailing list
> Bitcoin-development at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/bitcoin-development
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20130630/37790ab0/attachment.html>

