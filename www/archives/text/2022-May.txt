From alicexbt at protonmail.com  Sun May  1 01:20:22 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Sun, 01 May 2022 01:20:22 +0000
Subject: [bitcoin-dev] What to do when contentious soft fork activations
	are attempted
In-Reply-To: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
Message-ID: <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>

Hi Michael,

> Maybe the whole thing worked as designed. Some users identified what was going on, well known Bitcoin educators such as Andreas Antonopoulos, Jimmy Song etc brought additional attention to the dangers, a URSF movement started to gain momentum and those attempting a contentious soft fork activation backed off. (Disappointingly Bitcoin Optech didn't cover my previous posts to this mailing list [1](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html), [2](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html), [3](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html) highlighting the dangers many months ago or recent posts. Normally Optech is very high signal.)

Some users have been misled and there is nothing great being achieved by doing this on social media. Andreas is clueless about BIP 119 and other covenant proposals. He is spreading misinformation and some of the URSF enthusiasts do not understand what are they even opposing or going to run with risks involved.

Answering the subject of this email: "What to do when contentious soft forks activations are attempted?"

- Do not consider something contentious because someone said it on mailing list
- Do not spread misinformation
- Read all posts in detail with different opinions
- Avoid personal attacks
- Look at the technical details, code etc. and comment on things that could be improved

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.
------- Original Message -------
On Saturday, April 30th, 2022 at 3:23 PM, Michael Folkson via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:

> I?ve been in two minds on whether to completely move on to other topics or to formulate some thoughts on the recent attempt to activate a contentious soft fork. In the interests of those of us who have wasted days/weeks/months of our time on this (with no personal upside) and who don?t want to repeat this exercise again I thought I should at least raise the issue for discussion of what should be done differently if this is tried again in future.
>
> This could be Jeremy with OP_CTV at a later point (assuming it is still contentious) or anyone who wants to pick up a single opcode that is not yet activated on Bitcoin and try to get miners to signal for it bypassing technical concerns from many developers, bypassing Bitcoin Core and bypassing users.
>
> Maybe the whole thing worked as designed. Some users identified what was going on, well known Bitcoin educators such as Andreas Antonopoulos, Jimmy Song etc brought additional attention to the dangers, a URSF movement started to gain momentum and those attempting a contentious soft fork activation backed off. (Disappointingly Bitcoin Optech didn't cover my previous posts to this mailing list [1](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html), [2](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html), [3](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html) highlighting the dangers many months ago or recent posts. Normally Optech is very high signal.)
>
> Alternatively this was the first time a contentious soft fork activation was attempted, we were all woefully unprepared for it and none of us knew what we were doing.
>
> I?m unsure on the above. I?d be interested to hear thoughts. What I am sure of is that it is totally unacceptable for one individual to bring the entire Bitcoin network to the brink of a chain split. There has to be a personal cost to that individual dissuading them from trying it again otherwise they?re motivated to try it again every week/month. Perhaps the personal cost that the community is now prepared if that individual tries it again is sufficient. I?m not sure. Obviously Bitcoin is a permissionless network, Bitcoin Core and other open source projects are easily forked and no authority (I?m certainly no authority) can stop things like this happening again.
>
> I?ll follow the responses if people have thoughts (I won't be responding to the instigators of this contentious soft fork activation attempt) but other than that I?d like to move on to other things than contentious soft fork activations. Thanks to those who have expressed concerns publicly (too many to name, Bob McElrath was often wording arguments better than I could) and who were willing to engage with the URSF conversation. If an individual can go directly to miners to get soft forks activated bypassing technical concerns from many developers, bypassing Bitcoin Core and bypassing users Bitcoin is fundamentally broken. The reason I still have hope that it isn't is that during a period of general apathy some people were willing to stand up and actively resist it.
>
> --
> Michael Folkson
> Email: michaelfolkson at protonmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/8aa2a818/attachment-0001.html>

From belcher at riseup.net  Sun May  1 08:57:25 2022
From: belcher at riseup.net (Chris Belcher)
Date: Sun, 1 May 2022 09:57:25 +0100
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond for
	BIP39 seeds
Message-ID: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>

See 
https://gist.github.com/chris-belcher/7257763cedcc014de2cd4239857cd36e 
for the latest version of this BIP.

<pre>
   BIP: TBD. Preferably a two-digit number to match the bip44, bip49, 
bip84, bip86 family of bips
   Layer: Applications
   Title: Derivation scheme for storing timelocked address fidelity 
bonds in BIP39 phrases
   Author: Chris Belcher <belcher at riseup dot net>
   Status: Draft
   Type: Standards Track
   Comments-Summary: No comments yet.
   Created: 2022-04-01
   License: CC0-1.0
</pre>

== Abstract ==

This BIP defines the derivation scheme for BIP39 seed phrases which 
create timelocked addresses used for creating fidelity bonds. It also 
defines how to sign fidelity bond certificates, which are needed when 
using fidelity bonds that are stored offline.

== Motivation ==

Fidelity bonds are used to resist sybil attacks in certain decentralized 
anonymous protocols. They are created by locking up bitcoins using the 
`OP_CHECKLOCKTIMEVERIFY` opcode.

It would be useful to have a common derivation scheme so that users of 
wallet software can have a backup of their fidelity bonds by storing 
only the BIP39 seed phrase and a reference to this BIP. Importantly the 
user does not need to backup any timelock values.

We largely use the same approach used in BIPs 49, 84 and 86 for ease of 
implementation.

This standard is already implemented and deployed in JoinMarket. As most 
changes would requires a protocol change of a live system, there is 
limited scope for changing this standard in review. This BIP is more 
about documenting something which already exists, warts and all.

== Background ==

=== Fidelity bonds ===

A fidelity bond is a mechanism where bitcoin value is deliberately 
sacrificed to make a cryptographic identity expensive to obtain. A way 
to create a fidelity bond is to lock up bitcoins by sending them to a 
timelocked address. The valuable thing being sacrificed is the 
time-value-of-money.

The sacrifice must be done in a way that can be proven to a third party. 
This proof can be made by showing the UTXO outpoint, the address 
redeemscript and a signature which signs a message using the private key 
corresponding to the public key in the redeemscript.

The sacrificed value is an objective measurement that can't be faked and 
which can be verified by anybody (just like, for example PoW mining). 
Sybil attacks can be made very expensive by forcing a hypothetical sybil 
attacker to lock up many bitcoins for a long time. JoinMarket implements 
fidelity bonds for protection from sybil attackers. At the time of 
writing over 600 BTC in total have been locked up with some for many 
years. Their UTXOs and signatures have been advertised to the world as 
proof. We can calculate that for a sybil attacker to succeed in unmixing 
all the CoinJoins, they would have to lock up over 100k BTC for several 
years.

=== Fidelity bonds in cold storage ===

It would be useful to be able to keep the private keys of timelocked 
addresses in cold storage. This would allow the sybil resistance of a 
system to increase without hot wallet risk. For this reason there is an 
intermediate keypair called the certificate.

     UTXO key ---signs---> certificate ---signs---> endpoint (e.g. IRC 
nickname or tor .onion hostname)

The certificate keypair can be kept online and used to prove ownership 
of the fidelity bond. Even if the hot wallet private keys are stolen, 
the coins in the timelocked address will still be safe, although the 
thief will be able to impersonate the fidelity bond until the expiry.

=== Fixed timelock values ===

It would be useful for the user to avoid having to keep a record of the 
timelocks in the time-locked addresses. So only a limited small set of 
timelocks are defined by this BIP. This way the user must only store 
their seed phrase, and knowledge that they have coins stored using this 
BIP standard. The user doesn't need to remember or store any dates.


== Specifications ==

This BIP defines the two needed steps to derive multiple deterministic 
addresses based on a [[bip-0032.mediawiki|BIP 32]] master private key. 
It also defines the format of the certificate can be signed by the 
deterministic address key.

=== Public key derivation ===

To derive a public key from the root account, this BIP uses a similar 
account-structure as defined in BIP [[bip-0084.mediawiki|44]] but with 
<tt>change</tt> set to <tt>2</tt>.

<pre>
m / 84' / 0' / 0' / 2 / index
</pre>

A key derived with this derivation path pattern will be referred to as 
<tt>derived_key</tt> further
in this document.

For <tt>index</tt>, addresses are numbered from 0 in a sequentially 
increasing manner, but index does not increase forever like in other 
similar standards. The index only goes up to <tt>959</tt> inclusive. 
Only 960 addresses can be derived for a given BIP32 master key. 
Furthermore there is no concept of a gap limit, instead wallets must 
always generate all 960 addresses and check all of them if they have a 
balance and history.

=== Timelock derivation ===

The timelock used in the time-locked address is derived from the 
<tt>index</tt>. The timelock is a unix time. It is always the first of 
the month at midnight. The <tt>index</tt> counts upwards the months from 
January 2020, ending in December 2099. At 12 months per year for 80 
years this totals 960 timelocks. Note that care must be taken with the 
year 2038 problem on 32-bit systems.

<pre>
year = 2020 + index // 12
month = 1 + index % 12
</pre>


=== Address derivation ===

To derive the address from the above calculated public key and timelock, 
we create a <tt>redeemScript</tt> which locks the funds until the 
<tt>timelock</tt>, and then checks the signature of the 
<tt>derived_key</tt>. The <tt>redeemScript</tt> is hashed with SHA256 to 
produce a 32-byte hash value that forms the <tt>scriptPubKey</tt> of the 
P2WSH address.

     redeemScript: <timelock> OP_CHECKLOCKTIMEVERIFY OP_DROP 
<derived_key> OP_CHECKSIG
     witness:      <signature> <pubkey>
     scriptSig:    (empty)
     scriptPubKey: 0 <32-byte-hash>
                   (0x0020{32-byte-hash})

=== Certificate message derivation ===

To create a certificate needed for using fidelity bonds in cold storage, 
another application external to this standard will create a ECDSA 
keypair. The public key of this keypair and an integer called the 
`expiry` will be used to create a certificate message.

The certificate message is defined as:

    'fidelity-bond-cert|' + cert_pubkey + '|' + cert_expiry

where + denotes concatenation. `cert_pubkey` is encoded as a hex string, 
and `cert_expiry` is encoded as an ascii string of the integer.

This certificate message is then prepended with the string `\x18Bitcoin 
Signed Message:\n` and a byte denoting the length of the certificate 
message. The whole thing is then signed with the private key of the 
<tt>derived_key</tt>. This part is identical to the "Sign Message" 
function which many wallets already implement.

Almost all wallets implementing this standard can use their 
already-existing "Sign Message" function to sign the certificate 
message. As the certificate message itself is always an ascii string, 
the wallet may not need to specially implement this section at all but 
just rely on users copypasting their certificate message into the 
already-existing "Sign Message" user interface. This works as long as 
the wallet knows how to use the private key of the timelocked address 
for signing messages.

It is most important for wallet implementions of this standard to 
support creating the certificate signature. Verifying the certificate 
signature is less important.


== Test vectors ==

<pre>
mnemonic = abandon abandon abandon abandon abandon abandon abandon 
abandon abandon abandon abandon about
rootpriv = 
xprv9s21ZrQH143K3GJpoapnV8SFfukcVBSfeCficPSGfubmSFDxo1kuHnLisriDvSnRRuL2Qrg5ggqHKNVpxR86QEC8w35uxmGoggxtQTPvfUu
rootpub  = 
xpub661MyMwAqRbcFkPHucMnrGNzDwb6teAX1RbKQmqtEF8kK3Z7LZ59qafCjB9eCRLiTVG3uxBxgKvRgbubRhqSKXnGGb1aoaqLrpMBDrVxga8

// First timelocked address = m/84'/0'/0'/2/0
derived private_key = L2tQBEdhC48YLeEWNg3e4msk94iKfyVa9hdfzRwUERabZ53TfH3d
derived public_key  = 
02a1b09f93073c63f205086440898141c0c3c6d24f69a18db608224bcf143fa011
unix locktime       = 1577836800
string locktime     = 2020-01-01 00:00:00
redeemscript        = 
0400e10b5eb1752102a1b09f93073c63f205086440898141c0c3c6d24f69a18db608224bcf143fa011ac
scriptPubKey        = 
0020bdee9515359fc9df912318523b4cd22f1c0b5410232dc943be73f9f4f07e39ad
address             = 
bc1qhhhf29f4nlyalyfrrpfrknxj9uwqk4qsyvkujsa7w0ulfur78xkspsqn84

// Test certificate using first timelocked address
// Note that as signatures contains a random nonce, it might not be 
exactly the same when your code generates it
// p2pkh address is the p2pkh address corresponding to the derived 
public key, it can be used to verify the message
//  signature in any wallet that supports Verify Message.
// As mentioned before, it is more important for implementors of this 
standard to support signing such messages, not verifying them
Message       = 
fidelity-bond-cert|020000000000000000000000000000000000000000000000000000000000000001|375
Address       = 
bc1qhhhf29f4nlyalyfrrpfrknxj9uwqk4qsyvkujsa7w0ulfur78xkspsqn84
p2pkh address = 16vmiGpY1rEaYnpGgtG7FZgr2uFCpeDgV6
Signature     = 
H2b/90XcKnIU/D1nSCPhk8OcxrHebMCr4Ok2d2yDnbKDTSThNsNKA64CT4v2kt+xA1JmGRG/dMnUUH1kKqCVSHo=

// 2nd timelocked address = m/84'/0'/0'/2/1
derived private_key = KxctaFBzetyc9KXeUr6jxESCZiCEXRuwnQMw7h7hroP6MqnWN6Pf
derived public_key  = 
02599f6db8b33265a44200fef0be79c927398ed0b46c6a82fa6ddaa5be2714002d
unix locktime       = 1580515200
string locktime     = 2020-02-01 00:00:00
redeemscript        = 
0480bf345eb1752102599f6db8b33265a44200fef0be79c927398ed0b46c6a82fa6ddaa5be2714002dac
scriptPubKey        = 
0020b8f898643991608524ed04e0c6779f632a57f1ffa3a3a306cd81432c5533e9ae
address             = 
bc1qhrufsepej9sg2f8dqnsvvaulvv490u0l5w36xpkds9pjc4fnaxhq7pcm4h

// timelocked address after the year 2038 problem = m/84'/0'/0'/2/240
derived private_key = L3SYqae23ZoDDcyEA8rRBK83h1MDqxaDG57imMc9FUx1J8o9anQe
derived public_key  = 
03ec8067418537bbb52d5d3e64e2868e67635c33cfeadeb9a46199f89ebfaab226
unix locktime       = 2208988800
string locktime     = 2040-01-01 00:00:00
redeemscript        = 
05807eaa8300b1752103ec8067418537bbb52d5d3e64e2868e67635c33cfeadeb9a46199f89ebfaab226ac
scriptPubKey        = 
0020e7de0ad2720ae1d6cc9b6ad91af57eb74646762cf594c91c18f6d5e7a873635a
address             = 
bc1qul0q45njptsadnymdtv34at7karyva3v7k2vj8qc7m2702rnvddq0z20u5

// last timelocked address = m/84'/0'/0'/2/959
derived private_key = L5Z9DDMnj5RZMyyPiQLCvN48Xt7GGmev6cjvJXD8uz5EqiY8trNJ
derived public_key  = 
0308c5751121b1ae5c973cdc7071312f6fc10ab864262f0cbd8134f056166e50f3
unix locktime       = 4099766400
string locktime     = 2099-12-01 00:00:00
redeemscript        = 
0580785df400b175210308c5751121b1ae5c973cdc7071312f6fc10ab864262f0cbd8134f056166e50f3ac
scriptPubKey        = 
0020803268e042008737cf439748cbb5a4449e311da9aa64ae3ac56d84d059654f85
address             = 
bc1qsqex3czzqzrn0n6rjayvhddygj0rz8df4fj2uwk9dkzdqkt9f7zs5c493u
</pre>

Code generating these test vectors can be found here: 
https://github.com/chris-belcher/timelocked-addresses-fidelity-bond-bip-testvectors

==Reference==

* 
[[https://gist.github.com/chris-belcher/18ea0e6acdb885a2bfbdee43dcd6b5af/|Design 
for improving JoinMarket's resistance to sybil attacks using fidelity 
bonds]]
* 
[[https://github.com/JoinMarket-Org/joinmarket-clientserver/blob/master/docs/fidelity-bonds.md|JoinMarket 
fidelity bonds doc page]]
* [[bip-0065.mediawiki|BIP86 - OP_CHECKLOCKTIMEVERIFY]]
* [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]
* [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic 
Wallets]]
* [[bip-0049.mediawiki|BIP49 - Derivation scheme for 
P2WPKH-nested-in-P2SH based accounts]]
* [[bip-0084.mediawiki|BIP84 - Derivation scheme for P2WPKH based accounts]]
* [[bip-0086.mediawiki|BIP86 - Key Derivation for Single Key P2TR Outputs]]

From ZmnSCPxj at protonmail.com  Sun May  1 09:43:39 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 01 May 2022 09:43:39 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
Message-ID: <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>

Good morning Chris,

Excellent BIP!

>From a quick read-over, it seems to me that the fidelity bond does not commit to any particular scheme or application.
This means (as I understand it) that the same fidelity bond can be used to prove existence across multiple applications.
I am uncertain whether this is potentially abusable or not.


Regards,
ZmnSCPxj

From belcher at riseup.net  Sun May  1 10:01:49 2022
From: belcher at riseup.net (Chris Belcher)
Date: Sun, 1 May 2022 11:01:49 +0100
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
 for BIP39 seeds
In-Reply-To: <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
Message-ID: <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>

Hello ZmnSCPxj,

This is an intended feature. I'm thinking that the same fidelity bond 
can be used to running a JoinMarket maker as well as a Teleport 
(Coinswap) maker.

I don't believe it's abusable. It would be a problem if the same 
fidelity bond is used by two makers in the _same_ application, but 
JoinMarket takers are already coded to check for this, and Teleport 
takers will soon as well. Using the same bond across different 
applications is fine.

Best,
CB

On 01/05/2022 10:43, ZmnSCPxj wrote:
> Good morning Chris,
> 
> Excellent BIP!
> 
>>From a quick read-over, it seems to me that the fidelity bond does not commit to any particular scheme or application.
> This means (as I understand it) that the same fidelity bond can be used to prove existence across multiple applications.
> I am uncertain whether this is potentially abusable or not.
> 
> 
> Regards,
> ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sun May  1 11:41:50 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 01 May 2022 11:41:50 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
Message-ID: <gp_6EV3OP368tCH4wMFnprOi6AJyQyzK2vZUsm1hIbTKUmfbqh-UaZ4qW_oAAHDgMYdlqGREFgTtdfkPGyzjxdzOiu_R26_rq_phnC1kAi8=@protonmail.com>

Good morning again Chris,

I wonder if there would be an incentive to *rent* out a fidelity bond, i.e. I am interested in application A, you are interested in application B, and you rent my fidelity bond for application B.
We can use a pay-for-signature protocol now that Taproot is available, so that the signature for the certificate for your usage of application B can only be completed if I reveal a secret via a signature on another Taproot UTXO that gets me the rent for the fidelity bond.

I do not know if this would count as "abuse" or just plain "economic sensibility".
But a time may come where people just offer fidelity bonds for lease without actually caring about the actual applications it is being used *for*.
If the point is simply to make it costly to show your existence, whether you pay for the fidelity bond by renting it, or by acquiring your own Bitcoins and foregoing the ability to utilize it for some amount of time (which should cost closely to renting the fidelity bond from a provider), should probably not matter economically.

You mention that JoinMarket clients now check for fidelity bonds not being used across multiple makers, how is this done exactly, and does the technique not deserve a section in this BIP?

Regards,
ZmnSCPxj

From nadav at shesek.info  Sun May  1 14:25:42 2022
From: nadav at shesek.info (Nadav Ivgi)
Date: Sun, 1 May 2022 17:25:42 +0300
Subject: [bitcoin-dev] ANYPREVOUT in place of CTV
In-Reply-To: <CAGXD5f1KgDzY5sc-zknHYUSiSa7kWsXOHkg7kDakY3Kh5QtxTQ@mail.gmail.com>
References: <p3P0m2_aNXd-4oYhFjCKJyI8zQXahmZed6bv7lnj9M9HbP9gMqMtJr-pP7XRAPs-rn_fJuGu1cv9ero5i8f0cvyZrMXYPzPx17CxJ2ZSvRk=@protonmail.com>
 <CAGXD5f1KgDzY5sc-zknHYUSiSa7kWsXOHkg7kDakY3Kh5QtxTQ@mail.gmail.com>
Message-ID: <CAGXD5f1EquTAx0j0uc_jzWr9ZG8WRutUxznpmXn_7xuav6H4cw@mail.gmail.com>

> via `sha_sequences`

Since you cannot expect txid stability with >1 inputs either way[0], it
should be sufficient to commit just to the current input's
nSequence/scriptSig to get txid stability for single input transactions. I
chatted with Jeremy about this and he appears to agree.

Not committing to the nSequence of other inputs gives them the freedom to
set it independently, so for example you can spend a CSV-encumbered output
alongside the covenant. And there seems to be no downside to doing this [1].

APO/APOAS already commits to the nSequence of the current input. And since
APO is Taproot-only, the scriptSig of the covenant input is guarrnated to
be empty, so it is also already committed to in a way.

However, without committing to all the nSequences which implicitly commits
to the number of inputs, the number has to be committed separately.

So my suggestion is to explicitly commit to the number of inputs, instead
of commiting to `sha_sequences`.

Cheers
shesek

[0] the additional input(s) will be third-party malleable, since their
prevouts can be replaced with an entirely different txid:vout
[1] BIP 119's rationale for committing to the nSequences is txid
malleability:
https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki#committing-to-the-sequences-hash



On Sat, Apr 30, 2022 at 11:09 AM Nadav Ivgi <nadav at shesek.info> wrote:

> Hi darosior,
>
> It's interesting to note that APOAS|SINGLE (with the ANYONECANPAY
> behaviour and without covering the spent input index) has some interesting
> uses for cases where the covenant only needs to restrict a single output
> (so useful for e.g. vaults or spacechains, but not for batch channels or
> congestion control).
>
> For example in the vault use-case, it makes it possible to bump fees on
> the unvault tx by adding more inputs and a change output, as well as
> unvault multiple vaulted outputs in a single transaction.
>
> For spacechains, it makes it possible to add the spaceblock hash OP_RETURN
> and pay fees directly in the tx chain, instead of having to use an
> additional tx to prepare an output that gets spent in the tx chain  (see
> the diagram in [0]).
>
> > via `sha_sequences` and maybe also `sha_amounts`
>
> CTV does not commit to the input amounts. This has some practical
> implications:
>
> 1. If it is committed, sending an even slightly incorrect amount will make
> the covenant-encumbered spend path unusable.
>
> With CTV, sending a slightly lower amount results in slightly lower fees,
> while any extra gets spent/burned on fees. The covenant spend path only
> becomes unusable if the amount is too low to cover for the outputs (+relay
> fee for it to also be standard).
>
> 2. The ability to allow for additional inputs with unknown amounts makes
> it possible to fee-bump the covenant spending transaction (with whole utxos
> and no change). You can have one tapleaf for spending the covenant output
> alone, and another one for attaching an extra fee input to it.
>
> This also makes it possible to resolve the under-payment issue described
> in (1), by adding an input that covers the original intended amount.
>
> So my suggestion would be to either not cover `sha_amounts` in the msg
> hash, or to make it optional behind a flag.
>
> shesek
>
> [0] https://github.com/fiatjaf/simple-ctv-spacechain
>
> On Fri, Apr 22, 2022 at 2:23 PM darosior via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I would like to know people's sentiment about doing (a very slightly
>> tweaked version of) BIP118 in place of
>> (or before doing) BIP119.
>>
>> SIGHASH_ANYPREVOUT and its precedent iterations have been discussed for
>> over 6 years. It presents proven and
>> implemented usecases, that are demanded and (please someone correct me if
>> i'm wrong) more widely accepted than
>> CTV's.
>>
>> SIGHASH_ANYPREVOUTANYSCRIPT, if its "ANYONECANPAY" behaviour is made
>> optional [0], can emulate CTV just fine.
>> Sure then you can't have bare or Segwit v0 CTV, and it's a bit more
>> expensive to use. But we can consider CTV
>> an optimization of APO-AS covenants.
>>
>> CTV advocates have been presenting vaults as the flagship usecase.
>> Although as someone who've been trying to
>> implement practical vaults for the past 2 years i doubt CTV is necessary
>> nor sufficient for this (but still
>> useful!), using APO-AS covers it. And it's not a couple dozen more
>> virtual bytes that are going to matter for
>> a potential vault user.
>>
>> If after some time all of us who are currently dubious about CTV's stated
>> usecases are proven wrong by onchain
>> usage of a less efficient construction to achieve the same goal, we could
>> roll-out CTV as an optimization.  In
>> the meantime others will have been able to deploy new applications
>> leveraging ANYPREVOUT (Eltoo, blind
>> statechains, etc..[1]).
>>
>>
>> Given the interest in, and demand for, both simple covenants and better
>> offchain protocols it seems to me that
>> BIP118 is a soft fork candidate that could benefit more (if not most of)
>> Bitcoin users.
>> Actually i'd also be interested in knowing if people would oppose the
>> APO-AS part of BIP118, since it enables
>> CTV's features, for the same reason they'd oppose BIP119.
>>
>>
>> [0] That is, to not commit to the other inputs of the transaction (via
>> `sha_sequences` and maybe also
>> `sha_amounts`). Cf
>> https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki#signature-message
>> .
>>
>> [1] https://anyprevout.xyz/ "Use Cases" section
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/515b1504/attachment.html>

From vjudeu at gazeta.pl  Sun May  1 16:18:40 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Sun, 01 May 2022 18:18:40 +0200
Subject: [bitcoin-dev] Password-protected wallet on Taproot
Message-ID: <68441995-c7d44f8b69d56a75112afa495bca5bf9@pmq6v.m5r2.onet>

It seems that Taproot allows us to protect each individual public key with a password. It could work in this way: we have some normal, Taproot-based public key, that is generated in a secure and random way, as it is today in Bitcoin Core wallet. Then, we can create another public key, just by taking password from the user, executing SHA-256 on that, and using it as a private key, so the second key will be just a brainwallet. Then, we can combine them in a Schnorr signature, forming 2-of-2 multisig, where the first key is totally random, and the second key is just a brainwallet that takes a password chosen by the user. By default, each key can be protected with the same password, used for the whole wallet, but it could be possible to choose different passwords for different addresses, if needed. Descriptors should handle that nicely, in the same way as they can be used to handle any other 2-of-2 multisig.

From jtimon at jtimon.cc  Sun May  1 12:47:54 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sun, 1 May 2022 13:47:54 +0100
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
 <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
Message-ID: <CABm2gDrQXbS=i8j+Ja5PTgYekyH2X06eTOs8SXP8X-dhTy-hiQ@mail.gmail.com>

On Sun, May 1, 2022, 09:22 alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Michael,
>
> Maybe the whole thing worked as designed. Some users identified what was
> going on, well known Bitcoin educators such as Andreas Antonopoulos, Jimmy
> Song etc brought additional attention to the dangers, a URSF movement
> started to gain momentum and those attempting a contentious soft fork
> activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> previous posts to this mailing list 1
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html>,
> 2
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html>,
> 3
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html>
> highlighting the dangers many months ago or recent posts. Normally Optech
> is very high signal.)
>
>
> Some users have been misled and there is nothing great being achieved by
> doing this on social media. Andreas is clueless about BIP 119 and other
> covenant proposals. He is spreading misinformation and some of the URSF
> enthusiasts do not understand what are they even opposing or going to run
> with risks involved.
>
Clueless and spreading disinformation, you say? What misinformation, could
you explain?


> - Avoid personal attacks
>
Could accusing someone of apreading misinformation without prove and
calling him clueless be considered a personal attack?
What do we do with hypocrites and liars?
People who knowingly lie to push their own agenda, how do we protect
against those?


> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
>
> ------- Original Message -------
> On Saturday, April 30th, 2022 at 3:23 PM, Michael Folkson via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
>
> I?ve been in two minds on whether to completely move on to other topics or
> to formulate some thoughts on the recent attempt to activate a contentious
> soft fork. In the interests of those of us who have wasted
> days/weeks/months of our time on this (with no personal upside) and who
> don?t want to repeat this exercise again I thought I should at least raise
> the issue for discussion of what should be done differently if this is
> tried again in future.
>
> This could be Jeremy with OP_CTV at a later point (assuming it is still
> contentious) or anyone who wants to pick up a single opcode that is not yet
> activated on Bitcoin and try to get miners to signal for it bypassing
> technical concerns from many developers, bypassing Bitcoin Core and
> bypassing users.
>
> Maybe the whole thing worked as designed. Some users identified what was
> going on, well known Bitcoin educators such as Andreas Antonopoulos, Jimmy
> Song etc brought additional attention to the dangers, a URSF movement
> started to gain momentum and those attempting a contentious soft fork
> activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> previous posts to this mailing list 1
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html>,
> 2
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html>,
> 3
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html>
> highlighting the dangers many months ago or recent posts. Normally Optech
> is very high signal.)
>
> Alternatively this was the first time a contentious soft fork activation
> was attempted, we were all woefully unprepared for it and none of us knew
> what we were doing.
>
> I?m unsure on the above. I?d be interested to hear thoughts. What I am
> sure of is that it is totally unacceptable for one individual to bring the
> entire Bitcoin network to the brink of a chain split. There has to be a
> personal cost to that individual dissuading them from trying it again
> otherwise they?re motivated to try it again every week/month. Perhaps the
> personal cost that the community is now prepared if that individual tries
> it again is sufficient. I?m not sure. Obviously Bitcoin is a permissionless
> network, Bitcoin Core and other open source projects are easily forked and
> no authority (I?m certainly no authority) can stop things like this
> happening again.
>
> I?ll follow the responses if people have thoughts (I won't be responding
> to the instigators of this contentious soft fork activation attempt) but
> other than that I?d like to move on to other things than contentious soft
> fork activations. Thanks to those who have expressed concerns publicly (too
> many to name, Bob McElrath was often wording arguments better than I could)
> and who were willing to engage with the URSF conversation. If an individual
> can go directly to miners to get soft forks activated bypassing technical
> concerns from many developers, bypassing Bitcoin Core and bypassing users
> Bitcoin is fundamentally broken. The reason I still have hope that it isn't
> is that during a period of general apathy some people were willing to stand
> up and actively resist it.
>
> --
> Michael Folkson
> Email: michaelfolkson at protonmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/4d78ed9f/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  1 19:14:29 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 1 May 2022 14:14:29 -0500
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
 <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
Message-ID: <CAGpPWDb-T4OB0NKv7O5k9yhDQJtmag1QLqM1jJN9fQMoNTPLug@mail.gmail.com>

+1 alicexbt

We of course want knowledgeable bitcoiners who aren't knowledgeable about a
certain proposal to be skeptical. But what we don't want is for that
natural skepticism-from-ignorance to be interpreted as opposition, or
really a strong signal of any kind. Any thoughts from ignorance, whether
self-aware or not, should be given small weight. It seems the vast majority
of push back has been this kind of skepticism from ignorance. And to a
certain degree I think we want to give time for understanding to those who
have not participated in the first, second, third, etc round of discussion
on a proposal. It may not be reasonable to say "you had the last 2 years of
time to voice your concern".

Now that CTV is being taken seriously as a proposal, we probably should
give the community who is finally taking a serious look at it time to
understand, get their questions answered, and come to terms with it. This
is not to say that CTV as a technology or proposal has been rushed, or has
not had enough work put into it, but rather that the community as a whole
has not paid enough attention to it for long enough.

The wrong approach is: "how do I yell more loudly next time I see something
I'm uncomfortable with?" The right approach is to educate those who aren't
educated on the proposal and gather consensus on what people think when
they understand enough about it to contribute to that consensus. If you
care about consensus, you should respect the consensus process and be ok
with consensus being not your preferred outcome. If you don't care about
consensus, then you're basically attacking the bitcoin community.

On Sun, May 1, 2022 at 3:22 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Michael,
>
> Maybe the whole thing worked as designed. Some users identified what was
> going on, well known Bitcoin educators such as Andreas Antonopoulos, Jimmy
> Song etc brought additional attention to the dangers, a URSF movement
> started to gain momentum and those attempting a contentious soft fork
> activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> previous posts to this mailing list 1
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html>,
> 2
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html>,
> 3
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html>
> highlighting the dangers many months ago or recent posts. Normally Optech
> is very high signal.)
>
>
> Some users have been misled and there is nothing great being achieved by
> doing this on social media. Andreas is clueless about BIP 119 and other
> covenant proposals. He is spreading misinformation and some of the URSF
> enthusiasts do not understand what are they even opposing or going to run
> with risks involved.
>
>
> Answering the subject of this email: "What to do when contentious soft
> forks activations are attempted?"
>
> - Do not consider something contentious because someone said it on mailing
> list
> - Do not spread misinformation
> - Read all posts in detail with different opinions
> - Avoid personal attacks
> - Look at the technical details, code etc. and comment on things that
> could be improved
>
>
>
> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
>
> ------- Original Message -------
> On Saturday, April 30th, 2022 at 3:23 PM, Michael Folkson via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
>
> I?ve been in two minds on whether to completely move on to other topics or
> to formulate some thoughts on the recent attempt to activate a contentious
> soft fork. In the interests of those of us who have wasted
> days/weeks/months of our time on this (with no personal upside) and who
> don?t want to repeat this exercise again I thought I should at least raise
> the issue for discussion of what should be done differently if this is
> tried again in future.
>
> This could be Jeremy with OP_CTV at a later point (assuming it is still
> contentious) or anyone who wants to pick up a single opcode that is not yet
> activated on Bitcoin and try to get miners to signal for it bypassing
> technical concerns from many developers, bypassing Bitcoin Core and
> bypassing users.
>
> Maybe the whole thing worked as designed. Some users identified what was
> going on, well known Bitcoin educators such as Andreas Antonopoulos, Jimmy
> Song etc brought additional attention to the dangers, a URSF movement
> started to gain momentum and those attempting a contentious soft fork
> activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> previous posts to this mailing list 1
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html>,
> 2
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html>,
> 3
> <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html>
> highlighting the dangers many months ago or recent posts. Normally Optech
> is very high signal.)
>
> Alternatively this was the first time a contentious soft fork activation
> was attempted, we were all woefully unprepared for it and none of us knew
> what we were doing.
>
> I?m unsure on the above. I?d be interested to hear thoughts. What I am
> sure of is that it is totally unacceptable for one individual to bring the
> entire Bitcoin network to the brink of a chain split. There has to be a
> personal cost to that individual dissuading them from trying it again
> otherwise they?re motivated to try it again every week/month. Perhaps the
> personal cost that the community is now prepared if that individual tries
> it again is sufficient. I?m not sure. Obviously Bitcoin is a permissionless
> network, Bitcoin Core and other open source projects are easily forked and
> no authority (I?m certainly no authority) can stop things like this
> happening again.
>
> I?ll follow the responses if people have thoughts (I won't be responding
> to the instigators of this contentious soft fork activation attempt) but
> other than that I?d like to move on to other things than contentious soft
> fork activations. Thanks to those who have expressed concerns publicly (too
> many to name, Bob McElrath was often wording arguments better than I could)
> and who were willing to engage with the URSF conversation. If an individual
> can go directly to miners to get soft forks activated bypassing technical
> concerns from many developers, bypassing Bitcoin Core and bypassing users
> Bitcoin is fundamentally broken. The reason I still have hope that it isn't
> is that during a period of general apathy some people were willing to stand
> up and actively resist it.
>
> --
> Michael Folkson
> Email: michaelfolkson at protonmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/7158d8ed/attachment.html>

From jeremy.l.rubin at gmail.com  Mon May  2 02:43:29 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Sun, 1 May 2022 19:43:29 -0700
Subject: [bitcoin-dev] Working Towards Consensus
Message-ID: <CAD5xwhhdEgADWwLwbjRKp-UFCw9hHjDsc-L=pkiwW=bmhFqBNw@mail.gmail.com>

Developers,

There is much to say about the events of the last two weeks and the
response to them. I've been searching for the right words to share here,
but I think it best that short of a more thoughtful writeup I start with a
timely small step with the below comments.

First, let me be clear: I am not advancing a Speedy Trial(ST) activation of
Bitcoin Improvement Proposal-119 (BIP-119) CheckTemplateVerify (CTV) at
this time.

I'm skipping any discussion of the drama here. Most of you are interested
in developing Bitcoin, not drama. Let's try to keep this thread focused on
the actual work. I'll make some limited comments on the drama in a separate
thread, for those who care to hear from me on the subject directly.

I believe that the disinformation spread around my post ("7 Theses on a
next step for BIP-119"[0]) created three main negative outcomes within the
Bitcoin community:

1. Confusion about how Bitcoin's "technical consensus" works and how
changes are "approved".
2. Fear about the safety of CTV and covenants more broadly.
3. Misunderstandings around the properties of Speedy Trial, User Activated
Soft Fork (UASF), User Resisted Soft Fork (URSF), Soft Forks, Hard Forks,
and more.

While I cannot take responsibility for the spread of the disinformation, I
do apologize to anyone dealing with it for the role my actions have had in
leading to the current circumstance.

I personally take some solace in knowing that the only way out of this is
through it. The conversations happening now seem to have been more or less
inevitable, this has brought them to the surface, and as a technical
community we are able to address them head on if -- as individuals and
collectively -- we choose to. And, viewed through a certain lens, these
conversations represent incredibly important opportunities to participate
in defining the future of Bitcoin that would not be happening otherwise.
Ultimately, I am grateful to live in a time where I am able to play a small
role in such an important process. This is the work.

In the coming months, I expect the discourse to be messy, but I think the
work is clear cut that we should undertake at least the following:

1. Make great efforts to better document how Bitcoin's technical consensus
process works today, how it can be improved, and how changes may be
formally reviewed while still being unofficially advanced.
2. Work diligently to address the concerns many in the community have
around the negative potential of covenants and better explain the
trade-offs between levels of functionality.
3. Renew conversations about activation and release mechanisms and
re-examine our priors around why Speedy Trial may have been acceptable for
Taproot, was not acceptable for BIP-119, but may not be optimal long
term[1], and work towards processes that better captures the Bitcoin
network's diverse interests and requirements.
4. Work towards thoroughly systematizing knowledge around covenant
technologies so that in the coming months we may work towards delivering a
coherent pathway for the Bitcoin technical community to evaluate and put up
for offer to the broader community an upgrade or set of upgrades to improve
Bitcoin's capabilities for self sovereignty, privacy, scalability, and
decentralization.

This may not be the easiest path to take, but I believe that this work is
critical to the future of Bitcoin. I welcome all reading this to share your
thoughts with this list on how we might work towards consensus going
forward, including any criticisms of my observations and recommendations
above. While I would expect nothing less than passionate debate when it
comes to Bitcoin, remember that at the end of the day we all largely share
a mission to make the world a freer place, even if we disagree about how we
get there.

Yours truly,

Jeremy

[0]: https://rubin.io/bitcoin/2022/04/17/next-steps-bip119/
[1]: http://r6.ca/blog/20210615T191422Z.html I quite enjoyed Roconnor's
detailed post on Speedy Trial

--
@JeremyRubin <https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/9009e65d/attachment-0001.html>

From jeremy.l.rubin at gmail.com  Mon May  2 03:16:58 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Sun, 1 May 2022 20:16:58 -0700
Subject: [bitcoin-dev] On The Drama
Message-ID: <CAD5xwhhZN63PmxytFxKy=8KCZUxpDCV8j3kyNj7jVW3+aqcVNA@mail.gmail.com>

Developers,

I know that some of you may be interested in hearing my perspective on what
happened and why. I still do not know exactly what happened and why.
However, I can offer a brief explanation of what I perceived my main
actions to be and the response to them:

1. I published and shared to this list a blog post encouraging review on
viability of having a Speedy Trial (ST) with signalling beginning around
3.5 weeks (May 12th), in line with previously communicated materials.
2. I held a regularly scheduled meeting to discuss the viability of an
activation attempt, "The Agenda for the meeting will be an open discussion
on the possibility of activating CTV[CheckTemplateVerify] in 2022, why we
may or may not wish to do that, if we did want to do that what would need
to be done, what the path might look like if we do not do that."
3. If ST was deemed viable, I provided a pathway for sufficient review to
occur and I also wrote User Resisted Soft Fork(URSF) software to be used
such that miners are not unilaterally in control, as well as encouragement
for someone to author a User Activated Soft Fork(UASF) as a follow up if
miners "vetoed".
4. If ST was not viable, I gave encouragement to more thoroughly "re-evaluate
the design of CTV against alternatives that would take more time to prepare
engineering wise (e.g., more general covenants, small tweaks to CTV)"
5. I Made clear that CTV activation was "not a must. All actors must decide
if it?s in their own rational self-interest to have the soft-fork proceed."
6. I provided a review of rationale for why I thought this to be the right
next step for CTV, and for future soft forks to follow.

Since I posted my blog, there have been a flurry of inaccurate claims
lobbed at me across various platforms that I am trying to route around
consensus, force miners to do a ST, force users to accept a patch they
don't want, calls for me to face various repercussions, attacks on my
character, and more. Anyone is free to read the material I actually
communicated myself and evaluate the claims of bad-faith being made. I
accept responsibility that ultimately I may not have communicated these
things clearly enough.

I've kept my word to listen to feedback on parameters before any release:

- I've not released binaries for a ST CTV client in May, and won't be.
- I've kept my promise not to run a UASF process.

I hope you can believe me that I am not trying to do anything wanton to
Bitcoin. I am trying to do my best to accurately communicate my exact
intentions and plans along the way, and learn from the ways I fell short.

I cannot thank enough the (majority!) of individuals who understand this
and have provided overwhelming amounts of personal support to me through
these last weeks. While I do not mistake that personal support for support
of my views, I wanted to share the depth of support and appreciation that
the community has for the difficult tasks developers engage in. This isn't
specific to me; the community has immense respect for the sacrifices every
developer makes in choosing to work on Bitcoin. The hate may be loud and
public on the shallow surface, but the love and support runs deep.

At the same time, it has been eye opening for me to see the processes by
which a kernel of disinformation blossoms into a panic across the Bitcoin
community. For any Bitcoin contributor who might engage in consensus
processes: Agree or disagree with the quality of my actions, it's worth
spending a little time to trace how the response to my proposal was
instigated so that you harden your own defenses against such disinformation
campaigns in the future. I encourage you to look closely at what various
"respected members of the community" have lobbied for because they
represent dangerous precedents for all Bitcoin developers. I've yet to
fully form my thoughts around this.

If you do not think that my actions lived up with my perception of them,
feel free to give me, either publicly or privately, any feedback on how I
can do better going forward.

With respect to this thread, I'll read whatever you send, but I won't be
reply-all'ing here as I view this as largely off-topic for this list,
unless anyone feels strongly otherwise.

Best,

Jeremy



--
@JeremyRubin <https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/6aecba60/attachment.html>

From john at synonym.to  Mon May  2 08:37:29 2022
From: john at synonym.to (John Carvalho)
Date: Mon, 2 May 2022 09:37:29 +0100
Subject: [bitcoin-dev] Working Towards Consensus
In-Reply-To: <mailman.51682.1651459425.8511.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.51682.1651459425.8511.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CAHTn92z3HaTu47O_3metXAhFEVN3QnLdug1BVt66a9GZGx6t=Q@mail.gmail.com>

Jeremy,

The path to consensus is to propose things that everyone needs. Demand
comes from the market, not the designers.

Designers (engineers) solve problems with designs, but when they speculate
and lead the process, they create problems instead. Bitcoin is not a place
for speculative feature additions. Bitcoin cannot afford a culture of
additive features no one is asking for. Bitcoin thrives in a culture of
"NO." Rejection of change is Bitcoin's primary feature.

There is NO HOPE of EVER getting the majority of Bitcoin users to be able
to grasp, audit, and meaningfully consent to complicated new features, nor
to assess how they may interact with existing features in undesirable ways
or affect Bitcoin's incentive structure. To ignore this is a selfish
egomania that too many devs succumb to. The public already trusts Core devs
more than they probably should, and it is unwise to lean on that trust.

You are of course welcome to try and research and document all of the
details about how this plays out in practice, but you will fail to specify
a path to approval or any sort of clear governance structure for ensuring
that speculative features get into Bitcoin. You will seek and only see a
bias that allows you to get what YOU want. Until you focus on what everyone
wants, you will not reach consensus on anything.

Bitcoin changes should solve obvious problems and provide easy wins on
optimization, security, and privacy. Seek simplicity and efficiency, not
complication.

We have yet to saturate usage of the features we have added already in the
past 5 years. Use those. It is becoming apparent over time that many
features can be accomplished off-chain, or without a blockchain, or by
merely anchoring into currently available bitcoin transaction types.

There is simply no urgency or problem that any of the proposed soft fork
features are trying to address. This includes APO, CTV, sidechain
proposals, etc, etc.

Your aggression to your purpose is the antithesis of consensus, as it
indicates your incentives are external to it.

--
John Carvalho
CEO, Synonym.to <http://synonym.to/>


On Mon, May 2, 2022 at 3:43 AM <
bitcoin-dev-request at lists.linuxfoundation.org> wrote:

> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: What to do when contentious soft fork activations are
>       attempted (Billy Tetrud)
>    2. Working Towards Consensus (Jeremy Rubin)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Sun, 1 May 2022 14:14:29 -0500
> From: Billy Tetrud <billy.tetrud at gmail.com>
> To: alicexbt <alicexbt at protonmail.com>,  Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] What to do when contentious soft fork
>         activations are attempted
> Message-ID:
>         <
> CAGpPWDb-T4OB0NKv7O5k9yhDQJtmag1QLqM1jJN9fQMoNTPLug at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> +1 alicexbt
>
> We of course want knowledgeable bitcoiners who aren't knowledgeable about a
> certain proposal to be skeptical. But what we don't want is for that
> natural skepticism-from-ignorance to be interpreted as opposition, or
> really a strong signal of any kind. Any thoughts from ignorance, whether
> self-aware or not, should be given small weight. It seems the vast majority
> of push back has been this kind of skepticism from ignorance. And to a
> certain degree I think we want to give time for understanding to those who
> have not participated in the first, second, third, etc round of discussion
> on a proposal. It may not be reasonable to say "you had the last 2 years of
> time to voice your concern".
>
> Now that CTV is being taken seriously as a proposal, we probably should
> give the community who is finally taking a serious look at it time to
> understand, get their questions answered, and come to terms with it. This
> is not to say that CTV as a technology or proposal has been rushed, or has
> not had enough work put into it, but rather that the community as a whole
> has not paid enough attention to it for long enough.
>
> The wrong approach is: "how do I yell more loudly next time I see something
> I'm uncomfortable with?" The right approach is to educate those who aren't
> educated on the proposal and gather consensus on what people think when
> they understand enough about it to contribute to that consensus. If you
> care about consensus, you should respect the consensus process and be ok
> with consensus being not your preferred outcome. If you don't care about
> consensus, then you're basically attacking the bitcoin community.
>
> On Sun, May 1, 2022 at 3:22 AM alicexbt via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Hi Michael,
> >
> > Maybe the whole thing worked as designed. Some users identified what was
> > going on, well known Bitcoin educators such as Andreas Antonopoulos,
> Jimmy
> > Song etc brought additional attention to the dangers, a URSF movement
> > started to gain momentum and those attempting a contentious soft fork
> > activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> > previous posts to this mailing list 1
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html
> >,
> > 2
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html
> >,
> > 3
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html
> >
> > highlighting the dangers many months ago or recent posts. Normally Optech
> > is very high signal.)
> >
> >
> > Some users have been misled and there is nothing great being achieved by
> > doing this on social media. Andreas is clueless about BIP 119 and other
> > covenant proposals. He is spreading misinformation and some of the URSF
> > enthusiasts do not understand what are they even opposing or going to run
> > with risks involved.
> >
> >
> > Answering the subject of this email: "What to do when contentious soft
> > forks activations are attempted?"
> >
> > - Do not consider something contentious because someone said it on
> mailing
> > list
> > - Do not spread misinformation
> > - Read all posts in detail with different opinions
> > - Avoid personal attacks
> > - Look at the technical details, code etc. and comment on things that
> > could be improved
> >
> >
> >
> > /dev/fd0
> >
> > Sent with ProtonMail <https://protonmail.com/> secure email.
> >
> > ------- Original Message -------
> > On Saturday, April 30th, 2022 at 3:23 PM, Michael Folkson via bitcoin-dev
> > bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> >
> > I?ve been in two minds on whether to completely move on to other topics
> or
> > to formulate some thoughts on the recent attempt to activate a
> contentious
> > soft fork. In the interests of those of us who have wasted
> > days/weeks/months of our time on this (with no personal upside) and who
> > don?t want to repeat this exercise again I thought I should at least
> raise
> > the issue for discussion of what should be done differently if this is
> > tried again in future.
> >
> > This could be Jeremy with OP_CTV at a later point (assuming it is still
> > contentious) or anyone who wants to pick up a single opcode that is not
> yet
> > activated on Bitcoin and try to get miners to signal for it bypassing
> > technical concerns from many developers, bypassing Bitcoin Core and
> > bypassing users.
> >
> > Maybe the whole thing worked as designed. Some users identified what was
> > going on, well known Bitcoin educators such as Andreas Antonopoulos,
> Jimmy
> > Song etc brought additional attention to the dangers, a URSF movement
> > started to gain momentum and those attempting a contentious soft fork
> > activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> > previous posts to this mailing list 1
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html
> >,
> > 2
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html
> >,
> > 3
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html
> >
> > highlighting the dangers many months ago or recent posts. Normally Optech
> > is very high signal.)
> >
> > Alternatively this was the first time a contentious soft fork activation
> > was attempted, we were all woefully unprepared for it and none of us knew
> > what we were doing.
> >
> > I?m unsure on the above. I?d be interested to hear thoughts. What I am
> > sure of is that it is totally unacceptable for one individual to bring
> the
> > entire Bitcoin network to the brink of a chain split. There has to be a
> > personal cost to that individual dissuading them from trying it again
> > otherwise they?re motivated to try it again every week/month. Perhaps the
> > personal cost that the community is now prepared if that individual tries
> > it again is sufficient. I?m not sure. Obviously Bitcoin is a
> permissionless
> > network, Bitcoin Core and other open source projects are easily forked
> and
> > no authority (I?m certainly no authority) can stop things like this
> > happening again.
> >
> > I?ll follow the responses if people have thoughts (I won't be responding
> > to the instigators of this contentious soft fork activation attempt) but
> > other than that I?d like to move on to other things than contentious soft
> > fork activations. Thanks to those who have expressed concerns publicly
> (too
> > many to name, Bob McElrath was often wording arguments better than I
> could)
> > and who were willing to engage with the URSF conversation. If an
> individual
> > can go directly to miners to get soft forks activated bypassing technical
> > concerns from many developers, bypassing Bitcoin Core and bypassing users
> > Bitcoin is fundamentally broken. The reason I still have hope that it
> isn't
> > is that during a period of general apathy some people were willing to
> stand
> > up and actively resist it.
> >
> > --
> > Michael Folkson
> > Email: michaelfolkson at protonmail.com
> > Keybase: michaelfolkson
> > PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/7158d8ed/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Sun, 1 May 2022 19:43:29 -0700
> From: Jeremy Rubin <jeremy.l.rubin at gmail.com>
> To: Bitcoin development mailing list
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: [bitcoin-dev] Working Towards Consensus
> Message-ID:
>         <CAD5xwhhdEgADWwLwbjRKp-UFCw9hHjDsc-L=pkiwW=
> bmhFqBNw at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Developers,
>
> There is much to say about the events of the last two weeks and the
> response to them. I've been searching for the right words to share here,
> but I think it best that short of a more thoughtful writeup I start with a
> timely small step with the below comments.
>
> First, let me be clear: I am not advancing a Speedy Trial(ST) activation of
> Bitcoin Improvement Proposal-119 (BIP-119) CheckTemplateVerify (CTV) at
> this time.
>
> I'm skipping any discussion of the drama here. Most of you are interested
> in developing Bitcoin, not drama. Let's try to keep this thread focused on
> the actual work. I'll make some limited comments on the drama in a separate
> thread, for those who care to hear from me on the subject directly.
>
> I believe that the disinformation spread around my post ("7 Theses on a
> next step for BIP-119"[0]) created three main negative outcomes within the
> Bitcoin community:
>
> 1. Confusion about how Bitcoin's "technical consensus" works and how
> changes are "approved".
> 2. Fear about the safety of CTV and covenants more broadly.
> 3. Misunderstandings around the properties of Speedy Trial, User Activated
> Soft Fork (UASF), User Resisted Soft Fork (URSF), Soft Forks, Hard Forks,
> and more.
>
> While I cannot take responsibility for the spread of the disinformation, I
> do apologize to anyone dealing with it for the role my actions have had in
> leading to the current circumstance.
>
> I personally take some solace in knowing that the only way out of this is
> through it. The conversations happening now seem to have been more or less
> inevitable, this has brought them to the surface, and as a technical
> community we are able to address them head on if -- as individuals and
> collectively -- we choose to. And, viewed through a certain lens, these
> conversations represent incredibly important opportunities to participate
> in defining the future of Bitcoin that would not be happening otherwise.
> Ultimately, I am grateful to live in a time where I am able to play a small
> role in such an important process. This is the work.
>
> In the coming months, I expect the discourse to be messy, but I think the
> work is clear cut that we should undertake at least the following:
>
> 1. Make great efforts to better document how Bitcoin's technical consensus
> process works today, how it can be improved, and how changes may be
> formally reviewed while still being unofficially advanced.
> 2. Work diligently to address the concerns many in the community have
> around the negative potential of covenants and better explain the
> trade-offs between levels of functionality.
> 3. Renew conversations about activation and release mechanisms and
> re-examine our priors around why Speedy Trial may have been acceptable for
> Taproot, was not acceptable for BIP-119, but may not be optimal long
> term[1], and work towards processes that better captures the Bitcoin
> network's diverse interests and requirements.
> 4. Work towards thoroughly systematizing knowledge around covenant
> technologies so that in the coming months we may work towards delivering a
> coherent pathway for the Bitcoin technical community to evaluate and put up
> for offer to the broader community an upgrade or set of upgrades to improve
> Bitcoin's capabilities for self sovereignty, privacy, scalability, and
> decentralization.
>
> This may not be the easiest path to take, but I believe that this work is
> critical to the future of Bitcoin. I welcome all reading this to share your
> thoughts with this list on how we might work towards consensus going
> forward, including any criticisms of my observations and recommendations
> above. While I would expect nothing less than passionate debate when it
> comes to Bitcoin, remember that at the end of the day we all largely share
> a mission to make the world a freer place, even if we disagree about how we
> get there.
>
> Yours truly,
>
> Jeremy
>
> [0]: https://rubin.io/bitcoin/2022/04/17/next-steps-bip119/
> [1]: http://r6.ca/blog/20210615T191422Z.html I quite enjoyed Roconnor's
> detailed post on Speedy Trial
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/9009e65d/attachment.html
> >
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> ------------------------------
>
> End of bitcoin-dev Digest, Vol 84, Issue 4
> ******************************************
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220502/82f69955/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  1 22:41:44 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 1 May 2022 17:41:44 -0500
Subject: [bitcoin-dev] Towards a means of measuring user support for
	Soft Forks
In-Reply-To: <kfX31euUWC2GP3A1aUwRECN4R9G-hTAmB2sOrvmwnOT3ChmO4G1SOje88cTu53JZqHRw-3pjrQp3s8M5r8unxDlcClV62QZiW48t1NRa1J0=@protonmail.com>
References: <CALeFGL2Orc6F567Wd9x7o1c5OPyLTV-RTqTmEBrGNbEz+oPaOQ@mail.gmail.com>
 <CABaSBayKH__f_ahUUiDt2SiKik9aNLR1AXtG9RtWrFmTLP5qKw@mail.gmail.com>
 <CAGpPWDbYj4+g4VPMT9FPqyUZWO+U98YQhgYan5fRqXjpd+dTyw@mail.gmail.com>
 <CAL5BAw1pKXh4HLrUQByVMwpUtYyWcE5JhjUP-JB_1HKkORB1dA@mail.gmail.com>
 <CAJowKg+-qy00X_nSvFDz0HtvfjdsaozzGq4Vr8Vbd06GGZ8k_A@mail.gmail.com>
 <CAGpPWDaDRROKQdQ0WcK-RHo5=dQL6tD=LcQbqfS6p8ZEWkpEmA@mail.gmail.com>
 <CAJowKgL5kgWkSB=8ioFkfCxmRJLif-P4VSvX04Ubz_h8A3XYtA@mail.gmail.com>
 <CAGpPWDZ_3gffJsdofpLQDg5F6Qg03G+5897SJENQEhVv0d-jrg@mail.gmail.com>
 <CAGpPWDaBcZfH=EhoSbsQHp5nKkJZheMPXudDkDjWX56n9PGB_A@mail.gmail.com>
 <CAGpPWDZqPcufktdNq5DGnpFH=u2VdQTFjJaHQiLaE7jwWhzPUQ@mail.gmail.com>
 <kfX31euUWC2GP3A1aUwRECN4R9G-hTAmB2sOrvmwnOT3ChmO4G1SOje88cTu53JZqHRw-3pjrQp3s8M5r8unxDlcClV62QZiW48t1NRa1J0=@protonmail.com>
Message-ID: <CAGpPWDZ=XwgfAqx=H9sSHs1egwyFRyouV1dQR9R+027yiGTQSA@mail.gmail.com>

>  if you are perfectly rational, you can certainly imagine a "what if"
where your goal is different from your current goal and figure out what you
would do ***if*** that were your goal instead.

I see what you're saying, and I'm a lot more on board with that. I still
think "rational" can't mean "perfect" - like "perfectly rational" is not
the same as "you magically get to the optimal answer". But I think my line
of thinking on this is a lot more pedantic than my previous contention. But
I will agree that for a given specific objective goal (that ignores other
goals), there is an objective set of answers that any logical person should
eventually be able to agree on. Of course, if there's any subjectivity in
the goal, then discussing the goal amongst two different people will really
mean that each of them are discussing slightly different goals, which
breaks the premise. So really for alignment to happen, the goal in question
needs to be really specific in order to remove any significant
subjectivity.

> better-than-human rationality

I like to think of rationality in the following way. Any economic actor is
a being that has goals they want to maximize for, and tools at their
disposal to analyze and affect their world. A rational actor is one that
attempts to use their tools to the best of their ability to maximize their
goals. Perhaps goals is a misleading word to use here, since it implies
something that can be achieved, whereas I really mean a set of weighted
metrics that can hypothetically always be improved upon. But in any case, a
human starts with goals built into their genetics, which in turn build
themselves into the structure of their body. The tools a human has is also
their body and their brain. The brain is not a perfect tool, and neither is
the rest of the body. However, humans use what they have to make decisions
and act on their world. The goals a human has evolve as they have
experiences in the world (which end up physically changing their brain). In
this sense, every human, and every possible actor really, must be a
rational actor. They're all doing the best they can, even if the tools at
their disposal are very suboptimal for maximizing their underlying goals.
What more can you ask of a rational actor than to use the tools they have
to achieve their goals?

So I don't think anyone is more or less "rational" than anyone else. They
just have different goals and different levels of ability to maximize those
goals. In my definition above, the goals are completely arbitrary. They
don't have to be anything in particular. A person could have the goal of
maximizing the number of paper clips in the world, at all other costs. This
would almost certainly be "bad" for that person, and "bad" for the world,
but if that's really what their goals are, then that "badness" is a
subjectivity that you and I would be placing on that goal because our goals
are completely different from it. To the being with that goal, it is a
totally perfect goal.

The idea that someone can be "more rational" than someone else kind of
boils everything down to one dimension. In reality, everyone has their
different skills and proficiencies. In a futures market, you might be
better at predicting the price of salmon, but you might be quite bad at
predicting human population changes over time. Does this mean you're "more
rational" about salmon but "less rational" about how human populations
change? I would say a better way to describe this is proficiency, rather
than rationality.

</digression>

> a future market

A futures market for predictions is an interesting idea. I haven't really
heard about such a thing really being done other than in little
experiments. Are you suggesting we use one to help make decisions about
bitcoin? One issue is that the questions a futures market answers have to,
like my conclusion in the above paragraph, be completely objective. So a
futures market can't answer the question "what's the best way to design
covenants?" tho it could answer the question "will CTV be activated by
2024?". But as a consequence, I don't think a future's market could help
much in the formulation of appropriate goals for bitcoin. That would need
to be hashed out by making a lot of different compromises amongst
everyone's various subjective opinion's about what is best.

And I think that's really what I'm suggesting here, is that we bitcoiners
discuss what the objective goals of bitcoin should be, or at least what
bounds on those goals there should be. And once we have these objective
goals, we can be aligned on how to appropriately solve them. It wouldn't
avoid the nashing of teeth needed to hash out the subjective parts of our
opinions in getting to those goals, but it could avoid much nashing of
teeth in the other half of the conversation: how to achieve the goals we
have reached consensus on.

Eg, should a goal of bitcoin be that 50% of the world's population should
require spending no more than 1% of their income to be able to run a full
node? Were we to decide on something akin to that, it would at least be a
question that has an objective truth value to it, even if we couldn't
feasibly confirm to 100% certainty whether we have achieved it, we could
probably confirm with some acceptable level of certainty below 100%.



On Sat, Apr 30, 2022 at 1:14 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Billy,
>
> > @Zman
> > > if two people are perfectly rational and start from the same
> information, they *will* agree
> > I take issue with this. I view the word "rational" to mean basically
> logical. Someone is rational if they advocate for things that are best for
> them. Two humans are not the same people. They have different circumstances
> and as a result different goals. Two actors with different goals will
> inevitably have things they rationally and logically disagree about. There
> is no universal rationality. Even an AI from outside space and time is
> incredibly likely to experience at least some value drift from its peers.
>
> Note that "the goal of this thing" is part of the information where both
> "start from" here.
>
> Even if you and I have different goals, if we both think about "given this
> goal, and these facts, is X the best solution available?" we will both
> agree, though our goals might not be the same as each other, or the same as
> "this goal" is in the sentence.
> What is material is simply that the laws of logic are universal and if you
> include the goal itself as part of the question, you will reach the same
> conclusion --- but refuse to act on it (and even oppose it) because the
> goal is not your own goal.
>
> E.g. "What is the best way to kill a person without getting caught?" will
> probably have us both come to the same broad conclusion, but I doubt either
> of us has a goal or sub-goal to kill a person.
> That is: if you are perfectly rational, you can certainly imagine a "what
> if" where your goal is different from your current goal and figure out what
> you would do ***if*** that were your goal instead.
>
> Is that better now?
>
> > > 3. Can we actually have the goals of all humans discussing this topic
> all laid out, *accurately*?
> > I think this would be a very useful exercise to do on a regular basis.
> This conversation is a good example, but conversations like this are rare.
> I tried to discuss some goals we might want bitcoin to have in a paper I
> wrote about throughput bottlenecks. Coming to a consensus around goals, or
> at very least identifying various competing groupings of goals would be
> quite useful to streamline conversations and to more effectively share
> ideas.
>
>
> Using a future market has the attractive property that, since money is
> often an instrumental sub-goal to achieve many of your REAL goals, you can
> get reasonably good information on the goals of people without them having
> to actually reveal their actual goals.
> Also, irrationality on the market tends to be punished over time, and a
> human who achieves better-than-human rationality can gain quite a lot of
> funds on the market, thus automatically re-weighing their thoughts higher.
>
> However, persistent irrationalities embedded in the design of the human
> mind will still be difficult to break (it is like a program attempting to
> escape a virtual machine).
> And an uninformed market is still going to behave pretty much randomly.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/c23d0f10/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  1 22:53:13 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 1 May 2022 17:53:13 -0500
Subject: [bitcoin-dev] Conjectures on solving the high interactivity
 issue in payment pools and channel factories
In-Reply-To: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
References: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
Message-ID: <CAGpPWDa2wofye=KSq-vVNS0SOU34st9wm-hMhiYzGLTKMGuP5w@mail.gmail.com>

Hi Antoine,

Very interesting exploration. I think you're right that there are issues
with the kind of partitioning you're talking about. Lightning works because
all participants sign all offchain states (barring data loss). If a
participant can be excluded from needing to agree to a new state, there
must be an additional mechanism to ensure the relevant state for that
participant isn't changed to their detriment.

To summarize my below email, the two techniques I can think for solving
this problem are:

A. Create sub-pools when the whole group is live that can be used by the
sub- pool participants later without the whole group's involvement. The
whole group is needed to change the whole group's state (eg close or open
sub-pools), but sub-pool states don't need to involve the whole group.
B. Have an always-online system empowered to sign only for group updates
that *do not* change the owner's balance in the group. This could be done
with a hardware-wallet like device, or could be done with some kind of new
set of opcodes that can be used to verify that a particular transaction
isn't to the owner's detriment.

I had some thoughts that I think don't pan out, but here they are anyway:

What if the pool state transaction (that returns everyone's money) has each
participant sign the input + their personal output (eg with sighash flags)?
That way the transaction could have outputs swapped out by a subset of
participants as needed. Some kind of eltoo mechanism could then ensure that
the latest transaction can override earlier transactions. As far as the
non-participating members are concerned, they don't care whether the newest
state is published or whether the newest state they participated in is
published - because their output is identical either way. However, I can
see that there might be problems related to separate groups of participants
creating conflicting transactions, ie A B & C create a partition like this,
and so do D E & F, but they don't know about each other's state. If they
have some always-online coordination mechanism, this could be solved as
long as the participants aren't malicious. But it still leaves open the
possibility that some participants could intentionally grief others by
intentionally creating conflicting state transactions. Theoretically it
could be structured so that no funds could be directly stolen, but it seems
unavoidable that some group of members could create a secret transaction
that when published makes the most recent honest state not minable.

Come to think of it tho, this doesn't actually solve the double spending
problem. The fundamental issue is that if you have a subset of participants
creating partitions like this, without the involvement of the whole group,
its impossible for any subset of participants to know for sure that there
isn't a double-spending partition amongst another set of members of the
group.

On-chain bitcoin transactions prevent double spending by ensuring that
everyone knows what outputs have been spent. Payment channels prevent
double spending by ensuring that everyone that's part of the channel knows
what the current channel state is. Any 3rd layer probably needs this exact
property: everyone involved must know the state. So you should be able to
create a partition when the whole group is live, and thereafter the members
of that partition can use that partition without involving the rest of the
group. I think that pattern can work to any level of depth. After thinking
about this, I conjecture it might be a fundamental property of the double
spending problem. All participants must be aware of the whole state
otherwise the double spending problem exists for those who aren't aware of
the whole state.

> this is forcing the pool/factory user to share their key materials with
potentially lower trusted entities, if they don't self-host the tower
instances.

I had a conceptual idea a while back (that I can't find at the moment)
about offline lightning receiving. The concept is that each lightning node
in a channel has two separate keys: a spending-key and a receiving-key. The
spending-key must be used manually by the node owner to send payments,
however the receiving-key can be given to an always-online service that can
use that key only to either receive funds (ie update the state to a more
favorable state).

Right now with just a single-hot-key setup you need to trust your online
system to only sign receiving transactions and would refuse to sign any
proposed channel update not in the owner's favor. However, if the node was
compromised all bets are off - the entire channel balance could be stolen.

You could do this logic inside a hardware-wallet-like device that checks
the proposed updates and verifies the new state is favorable before
signing. This could go a long way to hardening lightning nodes against
potential compromise.

But if we go a step further, what if we enable that logic of ensuring the
state is more favorable with an on-chain mechanism? This was where my idea
got a bit hand wavy, but I think it could theoretically be done. The
receiving-key would be able to sign receiving transactions that would only
be valid when the most recent state signed by the spending-key is also
included in the script sig in some way. Some Script would then validate
that the receiving-key state being published is more favorable than the
spending-key state in that transaction's outputs. You'd have a couple
guarantees:

1. The usual guarantee that if the presented last spending-key state is
actually out of date, the transaction could be overridden by the newer
state in some way (eg eltoo style or punishment).
2. The state being published can be no worse than the presented
spending-key state. Yes, your channel partner could compromise your
receiving/routing node and then publish an out of date receiving-key
channel state that's based on the most-recent spending-key state, but it
would limit your losses to at most the amount of money you've received
since the last time you manually signed a channel state with your
spending-key. Because the always-online system empowered to receive does
*not* have the spending-key, anyone that compromises that node can't spend
and the damage is limited.

While less straight-forward than for receiving, in principle it seems like
something similar could be done for routing (which would require presenting
the state of multiple channels, and so has some additional complexities
there I haven't worked out).

This kind of thing might be a way of working around interactivity
requirements of payment pools and the like. All participants still have to
be aware of the whole state (eg of the payment pool), but this awareness
can be delegated to a system you have limited trust in. Payment pool
participants could delegate an always-online system empowered with a
separate key to sign payment pool updates that user's state isn't changed
for, allowing the payment pool to do its thing without exposing the user to
hot-key vulnerabilities in that always-online system. Double spending is
prevented because the user can access their always-online system to get the
full payment pool state.

So in short, while I think there may be no way to fundamentally not require
interactivity, there are workarounds that can limit how often full
interactivity is needed as well as ways to make it easier to provide that
full interactivity without compromising other aspects of each participant's
security.

On Thu, Apr 28, 2022 at 8:20 AM Antoine Riard via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> This post recalls the noticeable interactivity issue encumbering payment
> pools and channel factories in the context of a high number of
> participants, describes how the problem can be understood and proposes few
> solutions with diverse trust-minizations and efficiency assumptions. It is
> intended to capture the theoretical bounds of the "interactivity issue",
> where technical completeness of the solutions is exposed in future works.
>
> The post assumes a familiarity with the CoinPool paper concepts and
> terminology [0].
>
> # The interactivity requirement grieving payment pools/channel factories
>
> Payment pools and channel factories are multi-party constructions enabling
> to share the ownership of a single on-chain UTXO among many
> off-chain/promised balances. Payment pool improves on the channel factory
> construction fault-tolerance by reducing the number of balance outputs
> disclosed  on-chain to a single one in case of unilateral user exits.
>
> However, those constructions require all the users to be online and
> exchange rounds of signatures to update the balance distribution. Those
> liveliness/interactivity requirements are increasing with the number of
> users, as there are higher odds of *one* lazzy/buggy/offline user stalling
> the pool/factory updates.
>
> In echo, the design of LN was envisioned for a network of
> always-online/self-hosted participants, the early deployment of LN showed
> the resort to delegated channel hosting solutions, relieving users from the
> liveliness requirement. While the trust trade-offs of those solutions are
> significant, they answer the reality of a world made of unreliable networks
> and mobile devices.
>
> Minding that observation, the attractiveness of pools/factories might be
> questioned.
>
> # The interactivity requirement palliatives and their limits
>
> Relatively straightforward solutions to lower the interactivity
> requirement, or its encumbered costs, can be drawn out. Pools/factories
> users could own (absolute) timelocked kick-out abilities to evict offline
> users who are not present before expiration.
>
> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
> Each of them owns a Withdraw transaction to exit their individual balances
> at any time. Each user should have received the pre-signed components from
> the others guaranteeing the unilateral ability to publish the Withdraw.
>
> A kick-out ability playable by any pool user could be provided by
> generating a second set of Withdraw transactions, with the difference of
> the nLocktime field setup to an absolute height T + X, where T is the
> height at which the corresponding Update transaction is generated and X the
> kick-out delay.  For this set of kick-out transactions, the complete
> witnesses should be fully shared among Alice, Bob, Caroll and Dave. That
> way, if Caroll is unresponsive to move the pool state forward after X, any
> one of Alice, Bob or Dave can publish the Caroll kick-out Withdraw
> transaction, and pursue operations without that unresponsive party.
>
> While decreasing the interactivity requirement to the timelock delay, this
> solution is constraining the kicked user to fallback on-chain encumbering
> the UTXO set with one more entry.
>
> Another solution could be to assume the widespread usage of node towers
> among the pool participants. Those towers would host the full logic and key
> state necessary to receive an update request and produce a user's approval
> of it. As long as one tower instance is online per-user, the pool/factory
> can move forward. Yet this is forcing the pool/factory user to share their
> key materials with potentially lower trusted entities, if they don't
> self-host the tower instances.
>
> Ideally, I think we would like a trust-minimized solution enabling
> non-interactive, off-chain updates of the pool/factory, with no or minimal
> consumption of blockspace.
>
> For the remainder of this post, only the pool use-case will be mentioned.
> Though, I think the observations/implications can be extended to factories
> as well.
>
> # Non-interactive Off-chain Pool Partitions
>
> If a pool update fails because of lack of online unanimity, a partition
> request could be exchanged among the online subset of users ("the
> actives"). They decide to partition the pool by introducing a new layer of
> transactions gathering the promised/off-chain outputs of the actives. The
> set of outputs belonging to the passive users remains unchanged.
>
> The actives spend their Withdraw transactions `user_balance` outputs back
> to a new intermediate Update transaction. This "intermediate" Update
> transaction is free to re-distribute the pool balances among the active
> users. To guarantee the unilateral withdraw ability of a partitioned-up
> balance, the private components of the partitioned Withdraw transactions
> should be revealed among the set of active users.
>
> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
> Pool is at state N, Bob and Dave are offline. Alice and Caroll agree to
> partition the pool, each of them owns a Withdraw transaction
> ready-to-be-attached on the Update transaction N. They generate a new
> partitioning Update transaction with two inputs spending respectively
> Alice's Withdraw transaction `user_balance` output and Caroll's Withdraw
> transaction `user-balance` output. From this partitioning Update
> transaction, two new second-layer Withdraw ones are issued.
>
> Alice and Caroll reveal to each other the private components of their
> first-layer Withdraw transactions, allowing to publish the full branch :
> first-layer Update transaction, first-layer Withdraw transactions,
> second-layer partitioning Update transaction, second-layer partitioned
> Withdraw transaction. At that step, I think the partitioning should be
> complete.
>
> Quickly, a safety issue arises with pool partitioning. A participant of
> the active set A could equivocate the partition state by signing another
> spend of her Withdraw transaction allocating her balance to an Update
> transaction of a "covert" set of active users B.
>
> This equivocation exists because there is no ordering of the off-chain
> spend of the Withdraw transactions and any Withdraw transaction can be
> freely spent by its owner. This issue appears as similar to solving the
> double-spend problem.
>
> Equivocation is a different case than multiple *parallel* partitions,
> where there is no intersection between the partitioned balances. The
> parallel partitions are still rooting from the same Update transaction N. I
> think the safety of parallel partitions is yet to be explored.
>
> # Current solutions to the double-spend problem : Bitcoin base-layer &
> Lightning Network
>
> Of course, the double-spend issue is already addressed on the Bitcoin
> base-layer due to nodes consensus convergence on the most-proof-of-work
> accumulated valid chain of blocks. While reorg can happen, a UTXO cannot be
> spent twice on the same chain. This security model can be said to be
> prophylactic, i.e an invalid block cannot be applied to a node's state and
> should be rejected.
>
> The double-spend issue is also solved in its own way in payment channels.
> If a transaction is published, of which the correctness has been revoked
> w.r.t negotiated, private channel state, the wronged channel users must
> react in consequence. This security model can be said to be corrective,
> states updates are applied first on the global ledger then eventually
> corrected.
>
> A solution to the pool partition equivocation issue appears as either
> based on a prophylactic one or a corrective security model.
>
> Let's examine first, a reactive security model similar to LN-Penalty. At
> pool partition proposals, the owners of the partitioned-up Withdraw
> transactions could reveal a revocation secret enabling correction in case
> of wrongdoing (e.g single-show signatures). However, such off-chain
> revocation can be committed towards multiple sets of honest "active" users.
> Only one equivocating balance spend can succeed, letting the remaining set
> of honest users still be deprived of their expected partitioned balances.
>
> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
> Alice contacts Bob to form a first partition, then Caroll to form a second
> one, then Dave to form a last one. If she is successful in that
> equivocation trick, she can *triple*-spend her balance against any goods or
> out-of-pool payments.
>
> Assuming the equivocation is discovered once realized, Bob, Caroll and
> Dave are all left with a branch of transactions all including Alice's
> Withdraw one. However only one branch can be fully published, as a Withdraw
> transaction can be played only once following the pool semantic.
> Game-theory-wise, Bob, Caroll and Dave have an interest to enter in a fee
> race to be the first to confirm and earn the Alice balance spend.
>
> The equivocation is only bounded by the maximal number of equivocating
> sets one can form, namely the number of pool users. However, correction can
> only be limited to the equivocated balance. Therefore, it appears that
> corrective security models in the context of multi-party are always
> producing an economic disequilibrium.
>
> An extension of this corrective model could be to require off-pool
> collaterals locked-up, against which the revocation secret would be
> revealed at partition generation. However, this fix is limited to the
> collateral liquidity available. One collateral balance should be guaranteed
> for each potential victim, thus the collateral liquidity should be equal to
> the number of pool users multiplied by the equivocatable balance amount.
>
> It sounds like a more economic-efficient security model of the pool
> partitioning can be established with a prophylactic technique.
>
> # Trusted coordinator
>
> A genuine solution could be to rely on a coordinator collecting the
> partition declaration and order them canonically. The pool partition
> candidates can then fetch them and decide their partitions acceptance
> decisions on that. Of course, the coordinator is trusted and can drop or
> dissimulate any partition, thus enabling partitioned balance equivocation.
>
> # Trust-minimized : Partition Statements
>
> A pool partition invalidity can be defined by the existence of two
> second-layer Update transactions at the same state number spending the same
> Withdraw transaction balance output. Each Update transaction signature can
> be considered as a "partition statement". A user wishing to join a
> partition should ensure there is no conflicting partition statement before
> applying the partition to her local state.
>
> The open question is from where the conflict should be observed. A
> partition statement log could be envisioned and monitored by pool users
> before to accept any partition.
>
> I think multiple partition statement publication spaces can be drawn out,
> with different trust-minization trade-offs.
>
> # Publication space : Distributed Bulletin Boards
>
> The set of "active" pool users could host their own boards of partition
> statements. They would coordinate on the statement order through a
> consensus algorithm (e.g Raft). For redundancy, a user can have multiple
> board instances. If a user falls offline, they can fetch the statement
> order from the other users boards.
>
> However, while this solution distributes the trust across all the other
> users, it's not safe in case of malicious user coalitions agreeing among
> themselves to drop a partition statement. Therefore, a user catching up
> online can be feeded with an incorrect view of the existing partitions, and
> thus enter into an equivocated partition.
>
> # Publication space : On-chain Authoritative Board
>
> Another solution could be to designate an authoritative UTXO at pool
> setup. This UTXO could be spent by any user of the pool set (1-of-N) to a
> covenanted transaction sending back to a Taproot output with the same
> internal key. The Merkelized tree tweaked could be modified by the spender
> to stamp the partition statements as leaves hashes. The statement data is
> not committed in the leaves itself and the storage can be delegated to
> out-of-band archive servers.
>
> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
> Alice and Bob decide to start a partition, they commit a hash of the
> partitioning Update transaction as a Taproot tree leaf and they spend the
> pool authoritative UTXO. They also send a copy of the Update transaction to
> an archive server.
>
> At a later time, Alice proposes to Caroll to start a partition. Caroll
> follows the chain of transactions forming the on-chain authoritative board,
> she fetches the merkle branches and leaves data payload from an archive
> server, verifying the authenticity of the branches and payload. As Alice
> has already published a partition statement spending her Withdraw, Caroll
> should refuse the partition proposal.
>
> Even if a pool user goes offline, she can recover the correct partition
> statement logs, as it has been committed in the chain from the
> authoritative UTXO. If the statement data is not available from servers,
> the pool user should not engage in partitions.
>
> Assuming the spend confirms in every block, this solution enables
> partitions every 10min. The cost can be shared across pool instances, if
> the authoritative signers set is made of multiple pool instances signers
> sets. A threshold signature scheme could be used to avoid interactivity
> beyond the aggregated key setup. However, batching across pool instances
> increases the set of data to verify by the partition candidate users, which
> could be a grievance for bandwidth-constrained clients.
>
> # Fiability of the Publication of Partition Statements
>
> Whatever ends up being used as a partition statement log, there is still
> the question of the incentives of pool users to publish the partition
> statements. A malicious user could act in coalition with the equivocating
> entity to retain the publication of her partition statement. Thus, an
> honest user would only be aware of her own partition statement and accept
> the partition proposal from the will-be equivocating entity.
>
> I think that leveraging covenants a revocation mechanism could be attached
> on any equivocating branch of transactions, allowing in the above case a
> single honest user to punish the publication. While a revocation mechanism
> does not work in case of multiple defrauded users, I believe the existence
> of a revocation mechanism makes the formation of malicious coalitions
> unsafe for their conjurers.
>
> Indeed, any user entering in the coalition is not guaranteed to be blinded
> to other equivocating branches generated by the partition initiator.
> Therefore, the publication of a partition statement by everyone is
> holistically optimal to discover any equivocating candidate among the pool
> users.
>
> Further research should establish the soundness of the partition statement
> publication game-theory.
>
> # Writing the Partition Statements to a new Consensus Data Structure
>
> To avoid a solution relying on game-theory, a new consensus data structure
> could be introduced to register and order the partition statements. This
> off-chain contract register could be a Merkle tree, where every leaf is a
> pool balance identified by a key. This register would be established
> on-chain at the same time the pool is set up.
>
> Every time the pool is partitioned, the tree leaves would be updated with
> the partition statement committed to. Only one partition could be
> registered per user by state number. The publication branch would be
> invalid if it doesn't point back to the corresponding contract register
> tree entries. When the first-layer pool Update transaction is replaced, the
> tree should transition to a blank state too.
>
> Beyond the high cost of yet-another softfork to introduce such consensus
> data structure, the size of the witness to write into the contract register
> could be so significant that the economic attractiveness of pool
> partitioning is decreased in consequence.
>
> If you have read so far, thank you. And curious if anyone has more ideas
> or thoughts on  the high interactivity issue ?
>
> Thanks Gleb for the review.
>
> Cheers,
> Antoine
>
> [0] https://coinpool.dev/
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/29523d35/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  1 23:02:55 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 1 May 2022 18:02:55 -0500
Subject: [bitcoin-dev] Multiple ways to do bitcoin covenants
In-Reply-To: <G9vcdh_vztl5qzsxlbEet6nBvtC164nvV-g5e6pzUrxY4edWVroTF_h-LWnSXL0VhGQeeGpFbZA2Dm-AesIWToJ-OzdebGpqSUckw8oQseM=@protonmail.com>
References: <G9vcdh_vztl5qzsxlbEet6nBvtC164nvV-g5e6pzUrxY4edWVroTF_h-LWnSXL0VhGQeeGpFbZA2Dm-AesIWToJ-OzdebGpqSUckw8oQseM=@protonmail.com>
Message-ID: <CAGpPWDaf=ZNh3OmZBfkkfxEFb=vE=-Q_LX5bnG3s_GM2R1eivg@mail.gmail.com>

I've been thinking about writing something about covenant proposals from
the viewpoint of wallet vaults specifically (mostly because that's the use
case I care most about).

CTV is basically the minimal covenant opcode you can do that doesn't have
malleability. Everything else either introduces malleability, infinite
recursion, or has interactions with other proposed opcodes that could
introduce potentially undesirable effects like those.

TXHASH+CSFS seems like on its own might enable pretty much
identical capabilities to CTV (including no malleability). But it can also
do other things (mostly because CSFS can do other things), which isn't
necessarily a bad thing, but its more stuff to be analyzed. TXHASH+CSFS in
terms of wallet vaults seems to provide no benefits over CTV as far as I
can imagine.

It seems pretty clear that anything involving OP_CAT is out for the time
being. There are so many things it can enable that it seems most people
aren't comfortable adding it at  the moment.

APO wallet vaults seem rather hacky, inefficient, and limited. Certainly
not easy to reason about. But this is somewhat a function of my limited
understanding of them. Its not clear to me if anyone is actually suggesting
that we should use APO for covenants, but it doesn't feel like the right
approach.

TLUV + IN_OUT_AMOUNT can do infinitely recursive covenants. IN_OUT_AMOUNT
wasn't very clearly specified that I know of, but its not a very robust way
of ensuring the correct amount goes where you want. If TLUV requires a
single input and a single output, IN_OUT_AMOUNT makes sense because you can
simply do opcode math to determine if the output is receiving enough coins
(and not eg being all lost as fees). Maybe it could be extended to allow
multiple outputs, but extending it to allow for multiple inputs would be
difficult and you'd probably want a completely different mechanism for
that. If you're doing any math the script itself around amounts and fees,
this doesn't work well in any scenario where multiple inputs might send to
the same address, or be combined into the same output, since each input's
script can't interact.

But since TLUV at its most basic should be able to say "remove the only
tapleaf in this tree and replace it with this other tap tree", it should be
able to do pretty arbitrary covenants. It ideally should be paired up with
something that has better control over how input amounts flow to outputs
than IN_OUT_AMOUNT allows (see the design considerations here
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md>).


TLUV is built for evictions, but it seems its likely not really very good
at that, as Zman mentioned in his post about OP_EVICT
<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019926.html>
(which is a covenant opcode that can't be used for wallet vaults, tho
perhaps its characteristics can be used in a kind of TLUV2 opcode that does
evictions better, but also can add tapleaves).

OP_CHECKOUTPUTVERIFY <https://fc16.ifca.ai/bitcoin/papers/MES16.pdf> is
another interesting one. Also has a form that allows recursive covenants.
It also has similar awkwardness as TLUV + IN_OUT_AMOUNT around multi-input
transactions. It has the half-spend problem if two outputs are combined
that specify the same output index and script pattern. It also seems like a
rather expensive opcode to use beyond very simple covenants, since the
scripts basically has to be duplicated in the transaction specifying the
covenant and then again when the subsequent transaction is spent. Its not
very taproot friendly either: would you have to specify the entire taproot
script tree? Any similar opcode that requires specifying the exact
script(s) fundamentally can't take advantage taproot's ability to keep
scripts private until that spend path is actually used.

As far as I can tell, few of these other covenant opcodes have even been
concretely specified, let alone analyzed enough to know whether they're
worth pursuing. It seems like all but CTV (potentially TXHASH+CSFS) have
significant flaws and would need reworking in order to fix them.

I guess in short, I agree with you. Over these other ideas that have gotten
significant attention, none really seem to be of high enough quality to be
put into bitcoin in their current state.




On Thu, Apr 28, 2022 at 3:47 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> CTV and other covenant proposals, tradeoffs, and overlapping features are
> among the topics being explored recently. I had some views and questions on
> this subject.:
>
> a) Does bitcoin already have opcodes with overlapping features? Yes
>
> b) Can we have multiple ways with some overlapping features to do bitcoin
> covenants with some tradeoffs? Yes
> _
> c) What are these tradeoffs if we compare CTV, APO, TLUV and TXHASH+CSFS?
>
> I am sure about a) because it was already answered in CTV chat by Jeremy
> and sheshek. Example: CHECKSIG and CHECKSIGADD is redundant with OP_IF and
> OP_ADD
>
> Not sure if we have "consensus" on b) but I don't see anything wrong with
> it.
>
> For c) I would prefer CTV because:
>
> - Simpler
> - Blockspace effient
> - Can be used even without taproot
>
> Covering bare script, as in segwit v0, is necessary. Exposing a pubkey in
> case of an EC break will be a disaster, and vaults imply very long lived
> storage. Root CA offline certificates can often have shelf life measured in
> decades. However, NSA has issued warnings, NIST has issued guidelines, and
> executive order to prepare for the quantum shift. As a result, forcing
> everyone into a quantum-unsafe position is unsustainable.
>
> Other developers might use a different way to do bitcoin covenant for
> other reasons. Example: Russel O'Connor would prefer general OP_TXHASH
> design
>
> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/84cd21d4/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  1 23:35:08 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 1 May 2022 18:35:08 -0500
Subject: [bitcoin-dev] ANYPREVOUT in place of CTV
In-Reply-To: <CAGXD5f1Tu4o9e_-JtBgAs81NezYkM8X8AAqm=T9vjda4=3WFig@mail.gmail.com>
References: <p3P0m2_aNXd-4oYhFjCKJyI8zQXahmZed6bv7lnj9M9HbP9gMqMtJr-pP7XRAPs-rn_fJuGu1cv9ero5i8f0cvyZrMXYPzPx17CxJ2ZSvRk=@protonmail.com>
 <CAGXD5f3CyoRytWi4rsTUJocBS3Kqb=T2z6fOe+eORc-uxALrDg@mail.gmail.com>
 <u_rOSYZh92yALI9zZLk2M7DwQEccOLpQpCQrWN3Sz2HrH8M4WNvTtyp17ByfWhee3d1Ler62Wi3PmlM7AZduC4G8_qRRJAUIB0Bw3UP9q2M=@protonmail.com>
 <CAGXD5f3z9q1ggUemHUvEkDhRDQa9Xb04=zPzzKdX=hLGNBadVQ@mail.gmail.com>
 <CAGXD5f1Tu4o9e_-JtBgAs81NezYkM8X8AAqm=T9vjda4=3WFig@mail.gmail.com>
Message-ID: <CAGpPWDbSS6QucG8dZz4jURaA2f9xMqnCDoLXg0hbGaTuE4q59Q@mail.gmail.com>

>   If a QC is able overnight to spend a large fraction of the supply, your
coins in your super non-QC vulnerable-bare-CTV-covenant (that would
eventually become vulnerable when trying to use it) are worthless.[1]

I know this has been debated to death, but I really don't think this
argument is very convincing. First of all, why are we assuming that if for
example, "satoshi's hoard" of 5+ million bitcoins was stolen, that it would
mean bitcoin becomes worthless? To me this is an absurd assumption to make.
The thief almost certainly wouldn't want to just destroy bitcoin. But even
if they did and put it all up for sale overnight, yes it would tank
bitcoin's price *temporarily*. But in the long run, this is less than 1/3
of the supply, and it at worst could be considered monetary inflation of <
30%, and so that's the amount that the price should take a hit of: less
than 30%. Plenty of fiat currencies have survived worse.

Second of all, its incredibly unlikely that someone is suddenly going to be
able to do QC so well that they jump straight to being able to find "a
large fraction" of the private keys out there, or enough private keys to
make up a large fraction of the supply. Its far more likely that the first
quantum computers that are able to derive *any* private keys will still
take a long time (weeks? months?) to do one. If you have your bitcoins in a
segwit address, you know that they can't be stolen by a quantum computer.
You can sit back calmly, and figure out what to do next. By contrast, if
your life savings is in a taproot address, you have to drop everything with
your underwear on fire and recklessly move that stuff ASAP. Chances for
hasty mistakes is high.

But lets say someone *does* jump to being able to derive 1 private key per
minute (pretty darn fast if you ask me). It would currently take such a
machine 152 years to crack all the 80 million UTXOs in existence. By the
time there are practical quantum machines, it'll probably be at least
double that many UTXOs. If it was trying to crack revealed private keys
from mempool transactions, it could only really hit 10 out of 2000
transactions. Hashing the public key is I think is quite an effective
protection to a quantum computing attack in the vast majority of likely QC
emergence scenarios. I honestly don't understand how someone could come to
a different conclusion.

It makes a lot of sense in a world where quantum computers are now a very
real thing, to store large amounts of bitcoin in a possibly slightly less
efficient way in order to ensure that those funds can't be snatched in a QC
disaster scenario. I would be very interested to see a proposal to add the
option of having a taproot address type that doesn't expose the bare public
key.


On Fri, Apr 29, 2022 at 6:53 AM Nadav Ivgi via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Correction: thinking about this some more, you can't actually expect to
> have a stable txid if you allow additional inputs at all...
>
> So yes, amending BIP 118 to commit to sha_sequences (which indirectly also
> commits to the number of inputs) as proposed in the OP should be sufficient
> to get stable txids for single-input transactions.
>
> (I initially thought that APO has to cover some additional tx parts for
> this, but it seems that it's really just the scriptSig which is guarrnated
> to be empty if you have a single input that is known to be the taproot APO
> spend.)
>
> So in overall, my (1) and (5) points are only applicable to
> APO-as-currently-spec'd and not to the suggested APO revision.
>
> On Fri, Apr 29, 2022 at 1:21 PM Nadav Ivgi <nadav at shesek.info> wrote:
>
>> > This is *literally* what the post you are replying to is proposing to
>> solve.
>>
>> I thought the changes mentioned in the OP (+ committing to the spent
>> input index) only solves the half-spend problem, but not the stable txids
>> one?
>>
>> There can be other inputs with a scriptSig, which doesn't get committed
>> to in the APO hash. I guess this isn't too common, but there might be some
>> cases where you would want to spend some (pre-selected) non-segwit inputs
>> alongside your covenant, maybe for fees. With CTV you would pre-commit to
>> the scriptSig which makes it non-malleable even if the script itself is.
>>
>> > Hmm? You can't have channel factories without Eltoo. (Well, you can in
>> theory but good luck.)
>> > Maybe you are refering to non-interactive channel creation?
>>
>> I was referring to what BIP 119 calls 'Batched Channel Creation' [0],
>> which is a sort of a channel factory construction under a broader
>> definition (and in fact was previously called that in the BIP [1]).
>>
>> > The case for stable txids is less strong if we have APO (and therefore
>> Eltoo).
>>
>> There's merit in using these factory constructs for Poon-Dryja channels
>> even if Eltoo was available.
>> I don't foresee Eltoo taking over the penalty approach entirely, but
>> rather the two living side by side.
>>
>> (It could theoretically be possible to use APO to open Poon-Dryja
>> channels on top of unstable funding txids, but having stable txids makes
>> this much more easily integratable with existing lightning implementations,
>> without the invasive changes that unstable txids would bring.)
>>
>> > This has been addressed over and over and over again. If a QC is able
>> overnight to spend a large fraction of
>> > the supply, your coins in your super
>> non-QC-vulnerable-bare-CTV-covenant (that would eventually become
>> > vulnerable when trying to use it) are worthless.
>>
>> It might be the case that a sufficient fraction of supply does switch
>> over to QC-protected outputs in time, with only some small minority that
>> didn't actively switch over *and* with revealed bare pubkeys losing
>> their funds, which wouldn't make BTC entirely worthless. It makes sense not
>> to want to be in that minority, ideally without requiring further
>> time-sensitive active action (esp if considering long-term deep cold
>> storage for inheritance etc).
>>
>> (This of course assumes a safe post-QC mechanism to later spend these
>> funds; IIUC there are some viable approaches for that using a two-step
>> spending procedure, where you prove knowledge of the pubkey/script preimage
>> while commiting to a future tx.)
>>
>> > Sorry for being sarcastic, but at this point it's not fair to use
>> quantum-computer FUD to justify the
>> > activation of CTV over APO, or encourage the use of legacy transactions
>> over Taproot ones.
>>
>> Sorry if it came off as FUDing. I don't know enough to hold a strong
>> opinion on whether the fear of QCs is justified or not. I know that many
>> people on this list don't think so, but I also think that this fear is
>> prevalent enough to warrant taking it into consideration (at least for
>> features that target long-term SoV use cases; less so for features
>> targeted at L2 MoE applications like lightning spacechains paypools etc).
>>
>> > you can also use the internal key optimization .. you can't have
>> NUMS-ness then
>>
>> Right, which makes this unsuitable for the vaulting use case.
>>
>> > Also, it's not 33 extra vbytes vs CTV-in-segwitv0, but 33 extra *
>> witness units* (8.25 vbytes).
>>
>> Ugh yes sorry about that! I realized after hitting send and meant to
>> clarify that it should've been s/vbyte/WU/ in my next reply.
>>
>> > Are APO signatures more expensive to verify? .. the cost for the
>> network of validating signatures already exists today
>>
>> Not compared to existing signature verifications, but compared to a
>> CTV/TXHASH-like construction.
>>
>> Can anyone quantify how much of a difference this makes in practice?
>>
>> > i appreciate your reply and your efforts to explore the tradeoffs
>> between the two approaches.
>>
>> Thank you, I appreciate your efforts on this too :-)
>>
>> shesek
>>
>> [0]
>> https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki#Batched_Channel_Creation
>> [1] https://github.com/bitcoin/bips/pull/1273
>>
>> On Fri, Apr 29, 2022 at 11:31 AM darosior <darosior at protonmail.com>
>> wrote:
>>
>>> Hi Shesek,
>>>
>>> 1. The resulting txids are not stable.
>>>
>>>
>>> This is *literally* what the post you are replying to is proposing to
>>> solve.
>>>
>>>
>>> This property could be important for some of the proposed CTV use-cases,
>>> like channel factories.
>>>
>>>
>>> Hmm? You can't have channel factories without Eltoo. (Well, you can in
>>> theory but good luck.)
>>> Maybe you are refering to non-interactive channel creation? The case for
>>> stable txids is less strong if we
>>> have APO (and therefore Eltoo). [0]
>>>
>>>
>>> 2. APO will only be available on Taproot, which some people might prefer
>>> to avoid for long-term multi-decade vault storage due to QC concerns. (also
>>> see my previous post on this thread [0])
>>>
>>>
>>> This has been addressed over and over and over again. If a QC is able
>>> overnight to spend a large fraction of
>>> the supply, your coins in your super non-QC-vulnerable-bare-CTV-covenant
>>> (that would eventually become
>>> vulnerable when trying to use it) are worthless.[1]
>>>
>>> Sorry for being sarcastic, but at this point it's not fair to use
>>> quantum-computer FUD to justify the
>>> activation of CTV over APO, or encourage the use of legacy transactions
>>> over Taproot ones.
>>>
>>>
>>> 3. Higher witness satisfaction cost of roughly 3x vbytes vs
>>> CTV-in-Taproot (plus 33 extra vbytes vs CTV-in-segwitv0 *in the case of
>>> a single CTV branch*, for the taproot control block. with more branches
>>> CTV-in-taproot eventually becomes preferable).
>>>
>>>
>>> Again, this is what my post discusses. Here are the arguments from my
>>> post about why i don't think it's a big deal:
>>>
>>>     1. You can in this case see CTV as an optimization of (tweaked)
>>> APOAS. A lot of us are doubtful about CTV
>>>        usecases for real people. So much that it was even proposed to
>>> temporarily activate it to see if it would
>>>        ever have any real traction! [2]
>>>        My point with this post was: what if we do (a slightly tweaked)
>>> BIP118, that is otherwise useful. And
>>>        if this use of covenants is really getting traction then we can
>>> roll out an optimization in the form of
>>>        CTV (or better covenants, as we'd have had more research put into
>>> it by this time).
>>>     2. CTV is mainly sold for its usage inside vaults. While i'm not
>>> convinced, a few more vbytes should not
>>>        matter for this usecase.
>>>
>>> Also, it's not 33 extra vbytes vs CTV-in-segwitv0, but 33 extra *
>>> witness units* (8.25 vbytes).
>>> Aside, you can also use the internal key optimization with APO. But i
>>> don't think it's desirable just to save
>>> 32 WU, as you can't have NUMS-ness then. [3]
>>>
>>>
>>> 4. Higher network-wide full-node validation costs (checking a signature
>>> is quite more expensive than hashing, and the hashing is done in both
>>> cases).
>>>
>>>
>>> Are APO signatures more expensive to verify? If not i don't think this
>>> should be a reason to constrain us to a
>>> much less useful construction, as the cost for the network of validating
>>> signatures already exists today. Even
>>> if it didn't, the tradeoff of cost/usefulness needs to be considered.
>>>
>>>
>>> 5. As APO is currently spec'd, it would suffer from the half-spend
>>> problem: if you have multiple outputs encumbered under an APO covenant that
>>> requires the same tx sigmsg hash, it becomes possible to spend all of them
>>> together as multiple inputs in a single transaction and burn the extra to
>>> mining fees.
>>>
>>> If I'm not mistaken, I believe this makes the simple-apo-vault
>>> implementation [1] vulnerable to spending multiple vaulted outputs of the
>>> same denomination together and burning all but the first one. I asked the
>>> author for a more definitive answer on twitter [2].
>>>
>>> Fixing this requires amending BIP 118 with some new sigmsg flags (making
>>> the ANYONECANPAY behaviour optional, as mentioned in the OP).
>>>
>>>
>>> Yes! And as i mentioned on Twitter also committing to the input index
>>> which i forgot to add in the OP here.
>>>
>>>
>>> While i don't think the specific points are valid, i appreciate your
>>> reply and your efforts to explore the
>>> tradeoffs between the two approaches.
>>>
>>> Thanks,
>>> Antoine
>>>
>>> [0]
>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019813.html
>>> [1] https://bitcoin.stackexchange.com/a/91050/101498
>>> [2]
>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020242.html
>>> [3]
>>> https://twitter.com/darosior/status/1518979155362254849?s=20&t=mGkw7K8mcyQwdLImFvdebw
>>>
>>>
>>> This is definitely possible but also means that APO as-is isn't a
>>> CTV-replacement candidate, without first going through some more design and
>>> review iterations.
>>>
>>> shesek
>>>
>>>
>>> [0]
>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020326.html
>>> [1] https://github.com/darosior/simple-anyprevout-vault
>>> [2] https://twitter.com/shesek/status/1519874493434544128
>>>
>>>
>>>
>>> On Fri, Apr 22, 2022 at 2:23 PM darosior via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> I would like to know people's sentiment about doing (a very slightly
>>>> tweaked version of) BIP118 in place of
>>>> (or before doing) BIP119.
>>>>
>>>> SIGHASH_ANYPREVOUT and its precedent iterations have been discussed for
>>>> over 6 years. It presents proven and
>>>> implemented usecases, that are demanded and (please someone correct me
>>>> if i'm wrong) more widely accepted than
>>>> CTV's.
>>>>
>>>> SIGHASH_ANYPREVOUTANYSCRIPT, if its "ANYONECANPAY" behaviour is made
>>>> optional [0], can emulate CTV just fine.
>>>> Sure then you can't have bare or Segwit v0 CTV, and it's a bit more
>>>> expensive to use. But we can consider CTV
>>>> an optimization of APO-AS covenants.
>>>>
>>>> CTV advocates have been presenting vaults as the flagship usecase.
>>>> Although as someone who've been trying to
>>>> implement practical vaults for the past 2 years i doubt CTV is
>>>> necessary nor sufficient for this (but still
>>>> useful!), using APO-AS covers it. And it's not a couple dozen more
>>>> virtual bytes that are going to matter for
>>>> a potential vault user.
>>>>
>>>> If after some time all of us who are currently dubious about CTV's
>>>> stated usecases are proven wrong by onchain
>>>> usage of a less efficient construction to achieve the same goal, we
>>>> could roll-out CTV as an optimization. In
>>>> the meantime others will have been able to deploy new applications
>>>> leveraging ANYPREVOUT (Eltoo, blind
>>>> statechains, etc..[1]).
>>>>
>>>>
>>>> Given the interest in, and demand for, both simple covenants and better
>>>> offchain protocols it seems to me that
>>>> BIP118 is a soft fork candidate that could benefit more (if not most
>>>> of) Bitcoin users.
>>>> Actually i'd also be interested in knowing if people would oppose the
>>>> APO-AS part of BIP118, since it enables
>>>> CTV's features, for the same reason they'd oppose BIP119.
>>>>
>>>>
>>>> [0] That is, to not commit to the other inputs of the transaction (via
>>>> `sha_sequences` and maybe also
>>>> `sha_amounts`). Cf
>>>> https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki#signature-message
>>>> .
>>>>
>>>> [1] https://anyprevout.xyz/ "Use Cases" section
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>
>>> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/8e6bc38d/attachment-0001.html>

From belcher at riseup.net  Mon May  2 09:23:50 2022
From: belcher at riseup.net (Chris Belcher)
Date: Mon, 2 May 2022 10:23:50 +0100
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
 for BIP39 seeds
In-Reply-To: <gp_6EV3OP368tCH4wMFnprOi6AJyQyzK2vZUsm1hIbTKUmfbqh-UaZ4qW_oAAHDgMYdlqGREFgTtdfkPGyzjxdzOiu_R26_rq_phnC1kAi8=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <gp_6EV3OP368tCH4wMFnprOi6AJyQyzK2vZUsm1hIbTKUmfbqh-UaZ4qW_oAAHDgMYdlqGREFgTtdfkPGyzjxdzOiu_R26_rq_phnC1kAi8=@protonmail.com>
Message-ID: <4a6ef305-cf67-dce3-aed3-ab0a28aa758f@riseup.net>

Hello ZmnSCPxj,

Renting out fidelity bonds is an interesting idea. It might happen in 
the situation where a hodler wants to generate yield but doesn't want 
the hassle of running a full node and yield generator. A big downside of 
it is that the yield generator income is random while the rent paid is a 
fixed cost, so there's a chance that the income won't cover the rent.

JoinMarket takers since the start have checked that a fidelity bond 
doesn't appear twice. The technique doesn't deserve a section in the BIP 
because this BIP is only about specifying the wallets that hold fidelity 
bond UTXOs for makers, not takers which receive fidelity bond messages.

In JoinMarket this is done in this code here:
https://github.com/JoinMarket-Org/joinmarket-clientserver/blob/6b05f65260a487cd22f175ba64d499fbe8122530/jmclient/jmclient/taker.py#L1020-L1021

Best,
CB

On 01/05/2022 12:41, ZmnSCPxj wrote:
> Good morning again Chris,
> 
> I wonder if there would be an incentive to *rent* out a fidelity bond, i.e. I am interested in application A, you are interested in application B, and you rent my fidelity bond for application B.
> We can use a pay-for-signature protocol now that Taproot is available, so that the signature for the certificate for your usage of application B can only be completed if I reveal a secret via a signature on another Taproot UTXO that gets me the rent for the fidelity bond.
> 
> I do not know if this would count as "abuse" or just plain "economic sensibility".
> But a time may come where people just offer fidelity bonds for lease without actually caring about the actual applications it is being used *for*.
> If the point is simply to make it costly to show your existence, whether you pay for the fidelity bond by renting it, or by acquiring your own Bitcoins and foregoing the ability to utilize it for some amount of time (which should cost closely to renting the fidelity bond from a provider), should probably not matter economically.
> 
> You mention that JoinMarket clients now check for fidelity bonds not being used across multiple makers, how is this done exactly, and does the technique not deserve a section in this BIP?
> 
> Regards,
> ZmnSCPxj

From jeremy.l.rubin at gmail.com  Mon May  2 15:59:49 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Mon, 2 May 2022 08:59:49 -0700
Subject: [bitcoin-dev] [Pre-BIP] Fee Accounts
In-Reply-To: <YmqFRlDIkfbyVIZ2@petertodd.org>
References: <YgS3sJvg6kG3WnVJ@petertodd.org>
 <CAD5xwhi3Ja8gdU2h_6-1ck4kdU0TiC2Kx5O-61=f9=6JQSMs=A@mail.gmail.com>
 <YhAwr7+9mGJAe2/p@petertodd.org>
 <CAD5xwhi=sKckFZew75tZTogoeFABraWtJ6qMC+RgZjcirxYyZw@mail.gmail.com>
 <YhC6yjoe3bAfBS+W@petertodd.org>
 <CAD5xwhjR06Lp3ka-MqZQE64tfE5uDQB6TrMh06khjYrDzuT95g@mail.gmail.com>
 <YlMw5NxXnGV9WrVg@petertodd.org>
 <CAD5xwhj1kaJf+QCcf1MOtaAec-xTTr2M9LkJPCu2Ej0L9_3iPg@mail.gmail.com>
 <YlmGv6WbDeDqGJKX@petertodd.org>
 <CAD5xwhgGgq30C7GniNh1_DobPe+P4NTJySUkDiBZBj=OjzO5KA@mail.gmail.com>
 <YmqFRlDIkfbyVIZ2@petertodd.org>
Message-ID: <CAD5xwhhB+8n+9pWiSCtx3DAPnSwV_7xHnXZ14mEj9H93eWUNEw@mail.gmail.com>

Ok, got it. Won't waste anyone's time on terminology pedantism.


The model that I proposed above is simply what *any* correct timestamping
service must do. If OTS does not follow that model, then I suspect whatever
OTS is, is provably incorrect or, in this context, unreliable, even when
servers and clients are honest. Unreliable might mean different things to
different people, I'm happy to detail the types of unreliability issue that
arise if you do not conform to the model I presented above (of which,
linearizability is one way to address it, there are others that still
implement epoch based recommitting that could be conceptually sound without
requiring linearizability).

Do you have any formal proof of what guarantees OTS provides against which
threat model? This is likely difficult to produce without a formal model of
what OTS is, but perhaps you can give your best shot at producing one and
we can carry the conversation on productively from there.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220502/af0d2b92/attachment.html>

From jeremy.l.rubin at gmail.com  Mon May  2 16:24:30 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Mon, 2 May 2022 09:24:30 -0700
Subject: [bitcoin-dev] CTV Meeting #8 Reminder + Agenda (Tuesday, May 3rd,
	12:00 PT / 7PM UTC)
Message-ID: <CAD5xwhgdJcPCmRDKYRpeH2fzgurQqKLe8Odp8iP_+h3XZ2obNQ@mail.gmail.com>

Developers,

A reminder that the regularly scheduled CTV Meeting is tomorrow at 12:00
Pacific Time in ##ctv-bip-review in Libera.

In terms of agenda, we'll keep it as an open forum for discussion guided by
the participants. Feel free to propose meeting topics in the IRC in advance
of the meeting to aid in allocating time to things that you would like to
have discussed.

Best,

Jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220502/7a4157b6/attachment.html>

From ZmnSCPxj at protonmail.com  Tue May  3 05:26:46 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 03 May 2022 05:26:46 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <4a6ef305-cf67-dce3-aed3-ab0a28aa758f@riseup.net>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <gp_6EV3OP368tCH4wMFnprOi6AJyQyzK2vZUsm1hIbTKUmfbqh-UaZ4qW_oAAHDgMYdlqGREFgTtdfkPGyzjxdzOiu_R26_rq_phnC1kAi8=@protonmail.com>
 <4a6ef305-cf67-dce3-aed3-ab0a28aa758f@riseup.net>
Message-ID: <dff38JBEJOVZezg16f-wUv3Mcxew_4g3F4_SzE78DBW3UUi87zKh5nz17U0KWnUs1KSC6OEPZsIcxboz86M6-VgJX4cJXY4PnNLvWDRc0RE=@protonmail.com>

Good morning Chris,

> Hello ZmnSCPxj,
>
> Renting out fidelity bonds is an interesting idea. It might happen in
> the situation where a hodler wants to generate yield but doesn't want
> the hassle of running a full node and yield generator. A big downside of
> it is that the yield generator income is random while the rent paid is a
> fixed cost, so there's a chance that the income won't cover the rent.

The fact that *renting* is at all possible suggests to me that the following situation *could* arise:

* A market of lessors arises.
* A surveillor creates multiple identities.
* Each fake identity rents separately from multiple lessors.
* Surveillor gets privacy data by paying out rent money to the lessor market.

In defiads, I and Tamas pretty much concluded that rental would happen inevitably.
One could say that defiads was a kind of fidelity bond system.
Our solution for defiads was to prioritize propagating advertisements (roughly equivalent to the certificates in your system, I think) with larger bonded values * min(bonded_time, 1 year).
However, do note that we did not intend defiads to be used for privacy-sensitive applications like JoinMarket/Teleport.


Regards,
ZmnSCPxj

From billy.tetrud at gmail.com  Tue May  3 00:04:45 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 2 May 2022 19:04:45 -0500
Subject: [bitcoin-dev] Working Towards Consensus
In-Reply-To: <CAHTn92z3HaTu47O_3metXAhFEVN3QnLdug1BVt66a9GZGx6t=Q@mail.gmail.com>
References: <mailman.51682.1651459425.8511.bitcoin-dev@lists.linuxfoundation.org>
 <CAHTn92z3HaTu47O_3metXAhFEVN3QnLdug1BVt66a9GZGx6t=Q@mail.gmail.com>
Message-ID: <CAGpPWDbRp8ZoT+JWV6mKBPQT=86rxcSD9vELFsTMyU96S3D4kw@mail.gmail.com>

John,

> The path to consensus is to propose things that everyone needs.

If there's an insight here, it isn't clear what it is to me. As stated,
this is something I can only 100% disagree with. Its possible that
literally nothing about bitcoin is something that "everyone needs". Its
pretty clear that not "everyone needs" taproot. Its even questionable
whether "everyone needs" bitcoin. Are you really saying that no change
should be added to bitcoin unless it is something literally all bitcoin
users are currently asking for, or maybe just will want to use sometime
soon? The majority of bitcoin users don't even custody their own funds, so
practically all features are something those users aren't using. If you
want to convince people of whatever argument you're making, you're going to
have to get a little more specific and rather less hyperbolic.

> Designers (engineers) solve problems with designs, but when they
speculate and lead the process, they create problems instead.

How do you expect any improvement to ever happen to bitcoin if designers
can't design things unless end-users have asked for it. Every good product
designer knows that users do not know how to design products. Users have
problems, designers create solutions. Companies that have implemented
features that users directly ask for end up with awful bloated confusing
products. Surely this isn't what you're suggesting we do in bitcoin, right?

> Seek simplicity and efficiency, not complication.

This is an extraordinarily ironic thing to say to Jeremy Rubin, who
designed CTV with exactly that in mind. It is an incredibly simple opcode
that doesn't allow recursive covenants or various other things that people
have been worried about in the past about covenants. I'm 99% confident that
there is no simpler, more efficient, and less complicated covenant opcode
than CTV that can even possibly be designed. The only one on par is
TXHASH+CSFS and that has more complex implications than CTV.

There are MANY people out there that would like more complex, more powerful
covenants. "The market" is  in fact demanding it. And yet because we must
move carefully in Bitcoin, CTV is a compromise that focuses on simplicity
and incremental change rather than radical change.

Do you really disagree that CTV was intended to be as simple as possible
and achieves that goal?

> There is simply no urgency or problem that any of the proposed soft fork
features are trying to address.

That is pretty subjective, and very debatable. But ignoring the
debatableness of it, why is urgency even necessary for an improvement to
bitcoin? Should we wait until a problem is urgent to fix it? Or should we
get ahead of it so we don't risk making hasty mistakes?

> Your aggression to your purpose is the antithesis of consensus, as it
indicates your incentives are external to it.

This is a personal attack John, and there have been too many of those
lately. This is a completely unacceptable thing to say on this mailing
list. I ask that you take your words back and apologize. Please be more
objective and temper your strong emotions.

You know what is antithetical to consensus? People throwing around personal
attacks, asserting that consensus is something without evidence, and
failing to acknowledge the many opinions out there that are different from
theirs. You write your email as if there's only one person in this world
who wants CTV. You know this isn't the case.


On Mon, May 2, 2022 at 3:56 AM John Carvalho via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Jeremy,
>
> The path to consensus is to propose things that everyone needs. Demand
> comes from the market, not the designers.
>
> Designers (engineers) solve problems with designs, but when they speculate
> and lead the process, they create problems instead. Bitcoin is not a place
> for speculative feature additions. Bitcoin cannot afford a culture of
> additive features no one is asking for. Bitcoin thrives in a culture of
> "NO." Rejection of change is Bitcoin's primary feature.
>
> There is NO HOPE of EVER getting the majority of Bitcoin users to be able
> to grasp, audit, and meaningfully consent to complicated new features, nor
> to assess how they may interact with existing features in undesirable ways
> or affect Bitcoin's incentive structure. To ignore this is a selfish
> egomania that too many devs succumb to. The public already trusts Core devs
> more than they probably should, and it is unwise to lean on that trust.
>
> You are of course welcome to try and research and document all of the
> details about how this plays out in practice, but you will fail to specify
> a path to approval or any sort of clear governance structure for ensuring
> that speculative features get into Bitcoin. You will seek and only see a
> bias that allows you to get what YOU want. Until you focus on what everyone
> wants, you will not reach consensus on anything.
>
> Bitcoin changes should solve obvious problems and provide easy wins on
> optimization, security, and privacy. Seek simplicity and efficiency, not
> complication.
>
> We have yet to saturate usage of the features we have added already in the
> past 5 years. Use those. It is becoming apparent over time that many
> features can be accomplished off-chain, or without a blockchain, or by
> merely anchoring into currently available bitcoin transaction types.
>
> There is simply no urgency or problem that any of the proposed soft fork
> features are trying to address. This includes APO, CTV, sidechain
> proposals, etc, etc.
>
> Your aggression to your purpose is the antithesis of consensus, as it
> indicates your incentives are external to it.
>
> --
> John Carvalho
> CEO, Synonym.to <http://synonym.to/>
>
>
> On Mon, May 2, 2022 at 3:43 AM <
> bitcoin-dev-request at lists.linuxfoundation.org> wrote:
>
>> Send bitcoin-dev mailing list submissions to
>>         bitcoin-dev at lists.linuxfoundation.org
>>
>> To subscribe or unsubscribe via the World Wide Web, visit
>>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> or, via email, send a message with subject or body 'help' to
>>         bitcoin-dev-request at lists.linuxfoundation.org
>>
>> You can reach the person managing the list at
>>         bitcoin-dev-owner at lists.linuxfoundation.org
>>
>> When replying, please edit your Subject line so it is more specific
>> than "Re: Contents of bitcoin-dev digest..."
>>
>>
>> Today's Topics:
>>
>>    1. Re: What to do when contentious soft fork activations are
>>       attempted (Billy Tetrud)
>>    2. Working Towards Consensus (Jeremy Rubin)
>>
>>
>> ----------------------------------------------------------------------
>>
>> Message: 1
>> Date: Sun, 1 May 2022 14:14:29 -0500
>> From: Billy Tetrud <billy.tetrud at gmail.com>
>> To: alicexbt <alicexbt at protonmail.com>,  Bitcoin Protocol Discussion
>>         <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: Re: [bitcoin-dev] What to do when contentious soft fork
>>         activations are attempted
>> Message-ID:
>>         <
>> CAGpPWDb-T4OB0NKv7O5k9yhDQJtmag1QLqM1jJN9fQMoNTPLug at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> +1 alicexbt
>>
>> We of course want knowledgeable bitcoiners who aren't knowledgeable about
>> a
>> certain proposal to be skeptical. But what we don't want is for that
>> natural skepticism-from-ignorance to be interpreted as opposition, or
>> really a strong signal of any kind. Any thoughts from ignorance, whether
>> self-aware or not, should be given small weight. It seems the vast
>> majority
>> of push back has been this kind of skepticism from ignorance. And to a
>> certain degree I think we want to give time for understanding to those who
>> have not participated in the first, second, third, etc round of discussion
>> on a proposal. It may not be reasonable to say "you had the last 2 years
>> of
>> time to voice your concern".
>>
>> Now that CTV is being taken seriously as a proposal, we probably should
>> give the community who is finally taking a serious look at it time to
>> understand, get their questions answered, and come to terms with it. This
>> is not to say that CTV as a technology or proposal has been rushed, or has
>> not had enough work put into it, but rather that the community as a whole
>> has not paid enough attention to it for long enough.
>>
>> The wrong approach is: "how do I yell more loudly next time I see
>> something
>> I'm uncomfortable with?" The right approach is to educate those who aren't
>> educated on the proposal and gather consensus on what people think when
>> they understand enough about it to contribute to that consensus. If you
>> care about consensus, you should respect the consensus process and be ok
>> with consensus being not your preferred outcome. If you don't care about
>> consensus, then you're basically attacking the bitcoin community.
>>
>> On Sun, May 1, 2022 at 3:22 AM alicexbt via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> > Hi Michael,
>> >
>> > Maybe the whole thing worked as designed. Some users identified what was
>> > going on, well known Bitcoin educators such as Andreas Antonopoulos,
>> Jimmy
>> > Song etc brought additional attention to the dangers, a URSF movement
>> > started to gain momentum and those attempting a contentious soft fork
>> > activation backed off. (Disappointingly Bitcoin Optech didn't cover my
>> > previous posts to this mailing list 1
>> > <
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html
>> >,
>> > 2
>> > <
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html
>> >,
>> > 3
>> > <
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html
>> >
>> > highlighting the dangers many months ago or recent posts. Normally
>> Optech
>> > is very high signal.)
>> >
>> >
>> > Some users have been misled and there is nothing great being achieved by
>> > doing this on social media. Andreas is clueless about BIP 119 and other
>> > covenant proposals. He is spreading misinformation and some of the URSF
>> > enthusiasts do not understand what are they even opposing or going to
>> run
>> > with risks involved.
>> >
>> >
>> > Answering the subject of this email: "What to do when contentious soft
>> > forks activations are attempted?"
>> >
>> > - Do not consider something contentious because someone said it on
>> mailing
>> > list
>> > - Do not spread misinformation
>> > - Read all posts in detail with different opinions
>> > - Avoid personal attacks
>> > - Look at the technical details, code etc. and comment on things that
>> > could be improved
>> >
>> >
>> >
>> > /dev/fd0
>> >
>> > Sent with ProtonMail <https://protonmail.com/> secure email.
>> >
>> > ------- Original Message -------
>> > On Saturday, April 30th, 2022 at 3:23 PM, Michael Folkson via
>> bitcoin-dev
>> > bitcoin-dev at lists.linuxfoundation.org wrote:
>> >
>> >
>> > I?ve been in two minds on whether to completely move on to other topics
>> or
>> > to formulate some thoughts on the recent attempt to activate a
>> contentious
>> > soft fork. In the interests of those of us who have wasted
>> > days/weeks/months of our time on this (with no personal upside) and who
>> > don?t want to repeat this exercise again I thought I should at least
>> raise
>> > the issue for discussion of what should be done differently if this is
>> > tried again in future.
>> >
>> > This could be Jeremy with OP_CTV at a later point (assuming it is still
>> > contentious) or anyone who wants to pick up a single opcode that is not
>> yet
>> > activated on Bitcoin and try to get miners to signal for it bypassing
>> > technical concerns from many developers, bypassing Bitcoin Core and
>> > bypassing users.
>> >
>> > Maybe the whole thing worked as designed. Some users identified what was
>> > going on, well known Bitcoin educators such as Andreas Antonopoulos,
>> Jimmy
>> > Song etc brought additional attention to the dangers, a URSF movement
>> > started to gain momentum and those attempting a contentious soft fork
>> > activation backed off. (Disappointingly Bitcoin Optech didn't cover my
>> > previous posts to this mailing list 1
>> > <
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html
>> >,
>> > 2
>> > <
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html
>> >,
>> > 3
>> > <
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html
>> >
>> > highlighting the dangers many months ago or recent posts. Normally
>> Optech
>> > is very high signal.)
>> >
>> > Alternatively this was the first time a contentious soft fork activation
>> > was attempted, we were all woefully unprepared for it and none of us
>> knew
>> > what we were doing.
>> >
>> > I?m unsure on the above. I?d be interested to hear thoughts. What I am
>> > sure of is that it is totally unacceptable for one individual to bring
>> the
>> > entire Bitcoin network to the brink of a chain split. There has to be a
>> > personal cost to that individual dissuading them from trying it again
>> > otherwise they?re motivated to try it again every week/month. Perhaps
>> the
>> > personal cost that the community is now prepared if that individual
>> tries
>> > it again is sufficient. I?m not sure. Obviously Bitcoin is a
>> permissionless
>> > network, Bitcoin Core and other open source projects are easily forked
>> and
>> > no authority (I?m certainly no authority) can stop things like this
>> > happening again.
>> >
>> > I?ll follow the responses if people have thoughts (I won't be responding
>> > to the instigators of this contentious soft fork activation attempt) but
>> > other than that I?d like to move on to other things than contentious
>> soft
>> > fork activations. Thanks to those who have expressed concerns publicly
>> (too
>> > many to name, Bob McElrath was often wording arguments better than I
>> could)
>> > and who were willing to engage with the URSF conversation. If an
>> individual
>> > can go directly to miners to get soft forks activated bypassing
>> technical
>> > concerns from many developers, bypassing Bitcoin Core and bypassing
>> users
>> > Bitcoin is fundamentally broken. The reason I still have hope that it
>> isn't
>> > is that during a period of general apathy some people were willing to
>> stand
>> > up and actively resist it.
>> >
>> > --
>> > Michael Folkson
>> > Email: michaelfolkson at protonmail.com
>> > Keybase: michaelfolkson
>> > PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <
>> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/7158d8ed/attachment-0001.html
>> >
>>
>> ------------------------------
>>
>> Message: 2
>> Date: Sun, 1 May 2022 19:43:29 -0700
>> From: Jeremy Rubin <jeremy.l.rubin at gmail.com>
>> To: Bitcoin development mailing list
>>         <bitcoin-dev at lists.linuxfoundation.org>
>> Subject: [bitcoin-dev] Working Towards Consensus
>> Message-ID:
>>         <CAD5xwhhdEgADWwLwbjRKp-UFCw9hHjDsc-L=pkiwW=
>> bmhFqBNw at mail.gmail.com>
>> Content-Type: text/plain; charset="utf-8"
>>
>> Developers,
>>
>> There is much to say about the events of the last two weeks and the
>> response to them. I've been searching for the right words to share here,
>> but I think it best that short of a more thoughtful writeup I start with a
>> timely small step with the below comments.
>>
>> First, let me be clear: I am not advancing a Speedy Trial(ST) activation
>> of
>> Bitcoin Improvement Proposal-119 (BIP-119) CheckTemplateVerify (CTV) at
>> this time.
>>
>> I'm skipping any discussion of the drama here. Most of you are interested
>> in developing Bitcoin, not drama. Let's try to keep this thread focused on
>> the actual work. I'll make some limited comments on the drama in a
>> separate
>> thread, for those who care to hear from me on the subject directly.
>>
>> I believe that the disinformation spread around my post ("7 Theses on a
>> next step for BIP-119"[0]) created three main negative outcomes within the
>> Bitcoin community:
>>
>> 1. Confusion about how Bitcoin's "technical consensus" works and how
>> changes are "approved".
>> 2. Fear about the safety of CTV and covenants more broadly.
>> 3. Misunderstandings around the properties of Speedy Trial, User Activated
>> Soft Fork (UASF), User Resisted Soft Fork (URSF), Soft Forks, Hard Forks,
>> and more.
>>
>> While I cannot take responsibility for the spread of the disinformation, I
>> do apologize to anyone dealing with it for the role my actions have had in
>> leading to the current circumstance.
>>
>> I personally take some solace in knowing that the only way out of this is
>> through it. The conversations happening now seem to have been more or less
>> inevitable, this has brought them to the surface, and as a technical
>> community we are able to address them head on if -- as individuals and
>> collectively -- we choose to. And, viewed through a certain lens, these
>> conversations represent incredibly important opportunities to participate
>> in defining the future of Bitcoin that would not be happening otherwise.
>> Ultimately, I am grateful to live in a time where I am able to play a
>> small
>> role in such an important process. This is the work.
>>
>> In the coming months, I expect the discourse to be messy, but I think the
>> work is clear cut that we should undertake at least the following:
>>
>> 1. Make great efforts to better document how Bitcoin's technical consensus
>> process works today, how it can be improved, and how changes may be
>> formally reviewed while still being unofficially advanced.
>> 2. Work diligently to address the concerns many in the community have
>> around the negative potential of covenants and better explain the
>> trade-offs between levels of functionality.
>> 3. Renew conversations about activation and release mechanisms and
>> re-examine our priors around why Speedy Trial may have been acceptable for
>> Taproot, was not acceptable for BIP-119, but may not be optimal long
>> term[1], and work towards processes that better captures the Bitcoin
>> network's diverse interests and requirements.
>> 4. Work towards thoroughly systematizing knowledge around covenant
>> technologies so that in the coming months we may work towards delivering a
>> coherent pathway for the Bitcoin technical community to evaluate and put
>> up
>> for offer to the broader community an upgrade or set of upgrades to
>> improve
>> Bitcoin's capabilities for self sovereignty, privacy, scalability, and
>> decentralization.
>>
>> This may not be the easiest path to take, but I believe that this work is
>> critical to the future of Bitcoin. I welcome all reading this to share
>> your
>> thoughts with this list on how we might work towards consensus going
>> forward, including any criticisms of my observations and recommendations
>> above. While I would expect nothing less than passionate debate when it
>> comes to Bitcoin, remember that at the end of the day we all largely share
>> a mission to make the world a freer place, even if we disagree about how
>> we
>> get there.
>>
>> Yours truly,
>>
>> Jeremy
>>
>> [0]: https://rubin.io/bitcoin/2022/04/17/next-steps-bip119/
>> [1]: http://r6.ca/blog/20210615T191422Z.html I quite enjoyed Roconnor's
>> detailed post on Speedy Trial
>>
>> --
>> @JeremyRubin <https://twitter.com/JeremyRubin>
>> -------------- next part --------------
>> An HTML attachment was scrubbed...
>> URL: <
>> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/9009e65d/attachment.html
>> >
>>
>> ------------------------------
>>
>> Subject: Digest Footer
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>> ------------------------------
>>
>> End of bitcoin-dev Digest, Vol 84, Issue 4
>> ******************************************
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220502/ee18ad51/attachment-0001.html>

From john at synonym.to  Tue May  3 05:24:23 2022
From: john at synonym.to (John Carvalho)
Date: Tue, 3 May 2022 06:24:23 +0100
Subject: [bitcoin-dev] Working Towards Consensus
In-Reply-To: <CAGpPWDbRp8ZoT+JWV6mKBPQT=86rxcSD9vELFsTMyU96S3D4kw@mail.gmail.com>
References: <mailman.51682.1651459425.8511.bitcoin-dev@lists.linuxfoundation.org>
 <CAHTn92z3HaTu47O_3metXAhFEVN3QnLdug1BVt66a9GZGx6t=Q@mail.gmail.com>
 <CAGpPWDbRp8ZoT+JWV6mKBPQT=86rxcSD9vELFsTMyU96S3D4kw@mail.gmail.com>
Message-ID: <CAHTn92xn9nr3n4wvFWfc6g=zVNceaRprZsHMSML0DC5JqnKFJw@mail.gmail.com>

>
> > The path to consensus is to propose things that everyone needs.
> If there's an insight here, it isn't clear what it is to me. As stated,
> this is something I can only 100% disagree with. Its possible that
> literally nothing about bitcoin is something that "everyone needs". Its
> pretty clear that not "everyone needs" taproot. Its even questionable
> whether "everyone needs" bitcoin. Are you really saying that no change
> should be added to bitcoin unless it is something literally all bitcoin
> users are currently asking for, or maybe just will want to use sometime
> soon? The majority of bitcoin users don't even custody their own funds, so
> practically all features are something those users aren't using. If you
> want to convince people of whatever argument you're making, you're going to
> have to get a little more specific and rather less hyperbolic.


Billy, the insight is quite simple: it is easier to get everyone to agree
when everyone has something to gain. Taproot getting activated is not proof
of a sound consensus process, it is proof that most users are either
apathetic or trusting in the developers that initiated it being activated.
This is a dangerous dynamic to lean on. I'm not trying to convince anyone
of anything, I'm trying to provide insight into Bitcoin's dynamics and
qualities so as to save everyone some time. Take it or leave it, but I'm
confident about how things will play out within this model.

> Designers (engineers) solve problems with designs, but when they
> speculate and lead the process, they create problems instead.
> How do you expect any improvement to ever happen to bitcoin if designers
> can't design things unless end-users have asked for it. Every good product
> designer knows that users do not know how to design products. Users have
> problems, designers create solutions. Companies that have implemented
> features that users directly ask for end up with awful bloated confusing
> products. Surely this isn't what you're suggesting we do in bitcoin, right?


I do not "expect" improvement by any other means than is typical in life:
competition and adaptation in response to an adverse and changing
environment. Designers can design whatever they please, they just need to
understand the dynamics at play and the risks they are taking in that they
are likely to waste their own time, and others, if they miss the mark on
providing for the greater good. Anyone can be a designer, like anyone can
be a Bitcoin user. Engineers are only special if their specialization
allows them to solve a problem faster than someone else might. Why are you
talking about companies and bloat while I am speaking about being
conservative?

> Seek simplicity and efficiency, not complication.
> This is an extraordinarily ironic thing to say to Jeremy Rubin, who
> designed CTV with exactly that in mind. It is an incredibly simple opcode
> that doesn't allow recursive covenants or various other things that people
> have been worried about in the past about covenants. I'm 99% confident that
> there is no simpler, more efficient, and less complicated covenant opcode
> than CTV that can even possibly be designed. The only one on par is
> TXHASH+CSFS and that has more complex implications than CTV.


No, you're ironic in thinking that adding complication to Bitcoin's base
layer is somehow a means of valuing simplicity. I don't know who you are,
and since you and Jeremy have no reputation with me, I have no reason to
care about your "99%" confidence in something that I cannot distinguish
from an attack and have no personal need for. This is how trust and
incentives work!

There are MANY people out there that would like more complex, more powerful
> covenants. "The market" is  in fact demanding it. And yet because we must
> move carefully in Bitcoin, CTV is a compromise that focuses on simplicity
> and incremental change rather than radical change. Do you really disagree
> that CTV was intended to be as simple as possible and achieves that goal?


Speaking for myself, and likely the great majority of the market: "Don't
know, don't care." Your self-ascribed ability to assess the market is
objectively overconfident because we all know there is no way to
confidently measure this market by polling or analysis, and that most of
this market does not even know CTV exists, and the portion that does know
of CTV is barely competent enough to audit or bless it. That is just
reality.

> There is simply no urgency or problem that any of the proposed soft fork
> features are trying to address.
> That is pretty subjective, and very debatable. But ignoring the
> debatableness of it, why is urgency even necessary for an improvement to
> bitcoin? Should we wait until a problem is urgent to fix it? Or should we
> get ahead of it so we don't risk making hasty mistakes?


What is necessary is demand. All forms of scale and complexity come at a
cost to Bitcoin users. That cost is only offset AFTER the feature has
reached saturation of usage. Not even Segwit has achieved saturation yet.
Taproot is dying on the vine so far. This is not a judgment of either
design so much as an observation that we might be too aggressive in our
pace of feature speculation. If we keep piling on features, we have more
chances of making a mistake, adding technical debt, and abstractly debasing
users. Complexity can yield centralization, we should be more careful.

> Your aggression to your purpose is the antithesis of consensus, as it
> indicates your incentives are external to it.
> This is a personal attack John, and there have been too many of those
> lately. This is a completely unacceptable thing to say on this mailing
> list. I ask that you take your words back and apologize. Please be more
> objective and temper your strong emotions.
> You know what is antithetical to consensus? People throwing around
> personal attacks, asserting that consensus is something without evidence,
> and failing to acknowledge the many opinions out there that are different
> from theirs. You write your email as if there's only one person in this
> world who wants CTV. You know this isn't the case.


Cry harder. Jeremy is his own champion and my assessment that his
incentives are external to consensus is based on analyzing the game and
dynamics at play. It is evident to anyone capable of being objective, and
your being offended is not important to this topic. However many people in
the world that may want CTV, that number is surely less than 1% of the
Bitcoin user base.

--
John Carvalho
CEO, Synonym.to <http://synonym.to/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220503/fefee1ae/attachment.html>

From vjudeu at gazeta.pl  Tue May  3 07:37:20 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Tue, 03 May 2022 09:37:20 +0200
Subject: [bitcoin-dev] Pay to signature hash as a covenant
Message-ID: <160600410-14147cd52da04b7e94af778dff5502bf@pmq7v.m5r2.onet>

Typical P2PK looks like that: "<signature> <pubkey> OP_CHECKSIG". In a typical scenario, we have "<signature>" in out input and "<pubkey> OP_CHECKSIG" in our output. I wonder if it is possible to use covenants right here and right now, with no consensus changes, just by requiring a specific signature. To start with, I am trying to play with P2PK and legacy signatures, but it may turn out, that doing such things with Schnorr signatures will be more flexible and will allow more use cases.

The simplest "pay to signature" script I can think of is: "<signature> OP_SWAP OP_CHECKSIG". Then, any user can provide just a "<pubkey>" in some input, as a part of a public key recovery. The problem with such scheme is that it is insecure. Another problem is that we should handle it carefully, because signatures are removed from outputs. However, we could replace it with some signature hash, then it will be untouched, for example: "OP_TOALTSTACK OP_DUP OP_HASH160 <signatureHash> OP_EQUALVERIFY OP_FROMALTSTACK OP_CHECKSIG".

And then, signatures are more flexible than public keys, because we can use many different sighashes to decide, what kind of transaction is allowed and what should be rejected. Then, if we could use the right signature with correct sighashes, it could be possible to disable key recovery and require some specific public key, then that scheme could be safely used again. I still have no idea, how to complete that puzzle, but it seems to be possible to use that trick, to restrict destination address. Maybe I should wrap such things in some kind of multisig or somehow combine it with OP_CHECKSIGADD, any ideas?


From vjudeu at gazeta.pl  Tue May  3 09:15:36 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Tue, 03 May 2022 11:15:36 +0200
Subject: [bitcoin-dev] CoinPool should focus on different sighashes
Message-ID: <160827995-4aa198ec768a1ec2f886b21056804946@pmq5v.m5r2.onet>

It seems that the current consensus with Taproot is enough to implement CoinPool. There are no needed changes if we want to form a basic version of that protocol, so it probably should be done now (or at least started, even in some signet or testnet3). Later, if some features like SIGHASH_ANYPREVOUT (or the same with ANYSCRIPT) would be added, then it could be improved, just in the same way, as Lightning Network is moving from P2WSH to P2TR.

To start with, we assume there are six participants that are going to form a CoinPool. They start their journey by moving all of their coins to a 6-of-6 multisig channel. Nothing is signed, first we focus on making transactions, then we will sign them backwards to make it trustless.

+------------------------------------------------+
| Alice   3.51 -> ABCDEF (6-of-6 multisig) 19.94 |
| Bob     0.90                                   |
| Charlie 6.81                                   |
| Daniel  7.29                                   |
| Elaine  0.84                                   |
| Frank   0.60                                   |
+------------------------------------------------+

That first transaction is simple, we could sign it later with SIGHASH_ALL. But it seems we can handle it better: what about SIGHASH_ANYONECANPAY? Then, all outputs (so just one) will be signed, but anyone could attach another inputs if needed. Also, the first person could use SIGHASH_SINGLE | SIGHASH_ANYONECANPAY, but it is optional, and I assume we don't need any "group leader" or "coordinator", so anyone will just use SIGHASH_ANYONECANPAY, they will only switch destination and amount, to form a channel in a P2P way. Channel forming could work in a similar way as mempools in Bitcoin: all messages will fly, until there will be some agreement, and some group will collect all needed signatures. But for now, nothing is signed, so let's go to the next transaction.

To close that channel, a group should still exist, and just detach some participant. Closing the whole group is not an option, we want to encourage CoinPool formation, so we don't want to continuously open and close the whole channel. Let's assume that Alice wants to leave. That means, we should get a group of five participants and Alice, nothing more is needed:

+-----------------------------------------------------------------+
| ABCDEF (6-of-6 multisig) 19.94 -> BCDEF (5-of-5 multisig) 16.43 |
|                                   Alice                    3.50 |
+-----------------------------------------------------------------+

When we talk about sighashes, that case is quite interesting. The group of five participants could use SIGHASH_SINGLE | SIGHASH_ANYONECANPAY, and just bind that to the first output. But Alice cannot use the same sighash, because then her funds could be stolen by miners. She can use SIGHASH_ANYONECANPAY, then all outputs will be protected by her signature. However, combining two different sighashes is not going to work well with Schnorr signatures. For that reason, we need two of them. So, the TapScript branch for that ABCDEF multisig could be: "<pubkeyBCDEF> OP_CHECKSIGVERIFY <pubkeyAlice> OP_CHECKSIG".

Also, this case is even more interesting: Alice could also use SIGHASH_SINGLE | SIGHASH_ANYONECANPAY in that ABCDEF multisig and spend by key, but then she needs some on-chain output. It could be anything, even some output she received from dust attack. Then, she could use SIGHASH_ANYONECANPAY on that dust output, just to protect her coins. The total transaction size will be roughly the same, but then she could hide the whole group under a single Schnorr signature.

The missing part here is of course SIGHASH_ANYPREVOUT, then less transactions are needed. But even without that, the basic protocol can be deployed here and now, the only overhead will be transaction storage, because we need to sign every possible transaction for closing the channel. Also, it will be larger in case where all participants are going to close the channel, then each detachment will be processed in a separate transaction.

When it comes to handling costs, the cost of leaving the channel is paid by the detached person. That means, even if going through the least compressed path is possible, it would be costly for all participants trying to do that, so it should discourage them and encourage to play by the rules, and move all coins through N-of-N multisig.

Also, when we talk about covenants, it is in fact some kind of covenant. By having different sighashes for different signatures, we can easily restrict outputs to any scripts we want (and every participant can just collect other signatures, and later decide, where to send its own coins, so it is possible to pay someone directly, instead of first moving coins to some personal address, so there is one less transaction; tldr: another payment can be done during closing the channel).

So, my conclusion is that changing sighashes is far easier and more powerful than my previous idea of "paying to signatures", so I will probably focus on that instead.

From ZmnSCPxj at protonmail.com  Tue May  3 09:35:31 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 03 May 2022 09:35:31 +0000
Subject: [bitcoin-dev] Pay to signature hash as a covenant
In-Reply-To: <160600410-14147cd52da04b7e94af778dff5502bf@pmq7v.m5r2.onet>
References: <160600410-14147cd52da04b7e94af778dff5502bf@pmq7v.m5r2.onet>
Message-ID: <9WZCDiqADRzJudttdoDBbzOf65MpFgxUHU-4Qf3b9tJRglu81V-UB4wvvNJntGS-_F3X4mEVJPFqNRAkykn935hVGrnvxeYeX9I2nRClmRI=@protonmail.com>

Good morning vjudeu,

> Typical P2PK looks like that: "<signature> <pubkey> OP_CHECKSIG". In a typical scenario, we have "<signature>" in out input and "<pubkey> OP_CHECKSIG" in our output. I wonder if it is possible to use covenants right here and right now, with no consensus changes, just by requiring a specific signature. To start with, I am trying to play with P2PK and legacy signatures, but it may turn out, that doing such things with Schnorr signatures will be more flexible and will allow more use cases.
>
>
> The simplest "pay to signature" script I can think of is: "<signature> OP_SWAP OP_CHECKSIG". Then, any user can provide just a "<pubkey>" in some input, as a part of a public key recovery. The problem with such scheme is that it is insecure. Another problem is that we should handle it carefully, because signatures are removed from outputs. However, we could replace it with some signature hash, then it will be untouched, for example: "OP_TOALTSTACK OP_DUP OP_HASH160 <signatureHash> OP_EQUALVERIFY OP_FROMALTSTACK OP_CHECKSIG".
>
> And then, signatures are more flexible than public keys, because we can use many different sighashes to decide, what kind of transaction is allowed and what should be rejected. Then, if we could use the right signature with correct sighashes, it could be possible to disable key recovery and require some specific public key, then that scheme could be safely used again. I still have no idea, how to complete that puzzle, but it seems to be possible to use that trick, to restrict destination address. Maybe I should wrap such things in some kind of multisig or somehow combine it with OP_CHECKSIGADD, any ideas?

You can do the same thing with P2SH, P2WSH, and P2TR (in a Tapscript) as well.

Note that it is generally known that you *can* use pre-signed transactions to implement vaults.
Usually what we refer to by "covenant" is something like "this output will definitely be constructed here" without necessarily requiring a signature.

HOWEVER, what you are proposing is not ***quite*** pre-signed transactions!
Instead, you are (ab)using signatures in order to commit to particular sighashes.

First, let me point out that you do not need to hash the signature and *then* use a raw `scriptPubKey`, which I should *also* point it is not going to pass `IsStandard` checks (and will not propagate on the mainnet network reliably, only on testnet).
Instead, you can use P2WSH and *include* the signature outright in the `redeemScript`.
Since the output `scriptPubKey` is really just the hash of the `redeemScript`, this is automatically a hash of a signature (plus a bunch of other bytes).

So your proposal boils down to using P2WSH and having a `redeemScript`:

    redeemScript = <fixedSignature> <fixPubKey> OP_CHECKSIG

Why include the `fixPubKey` in the `redeemScript`?
In your scheme, you would provide the signature and pubkey in the `scriptSig` that spends the `scriptPubKey`.
But in a post-P2WSH world, `redeemScript` will also be provided in the `witness`, so you *also* provide both the signature and the pubkey, and both are hashed before appearing on the `scriptPubKey` --- which is exactly what you are proposing anyway.

The above pre-commits to a particular transaction, depending on the `SIGHASH` flags of the `fixedSignature`.
Of note is that the `fixPubKey` can have a throwaway privkey, or even a ***publicly-shared*** privkey.
Even if an alternate signature is created from  well-known privkey, the `redeemScript` will not allow any other signature to be accepted, it will only use the one that is hardcoded into the script.
Using a publicly-shared privkey would allow us to compute just the expected `sighash`. them derove the `fixedSignature` that should be in the `redeemScript`.

In particular, this scheme would work just as well for the "congestion control" application proposed for `OP_CTV`.
`OP_CTV` still wins in raw WUs spent (just the 32-WU hash), but in the absence of `OP_CTV` because raisins, this would also work (but you reveal a 33-WU pubkey, and a 73-WU/64-WU signature, which is much larger).
Validation speed is also better for `OP_CTV`, as it is just a hash, while this scheme uses signature validation in order to commit to a specific hash anyway (a waste of CPU time, since you could just check the hash directly instead of going through the rigmarole of a signature, but one which allows us to make non-recursive covenants with some similarities to `OP_CTV`).

A purported `OP_CHECKSIGHASHVERIFY` which accepts a `SIGHASH` flag and a hash, and checks that the sighash of the transaction (as modified by the flags) is equal to the hash, would be more efficient, and would also not differ by much from `OP_CTV`.

This can be used in a specific branch of an `OP_IF` to allow, say, a cold privkey to override this branch, to start a vault construction.

The same technique should work with Tapscripts inside Taproot (but the `fixedPubKey` CANNOT be the same as the internal Taproot key!).

Regards,
ZmnSCPxj

From darosior at protonmail.com  Tue May  3 10:38:52 2022
From: darosior at protonmail.com (darosior)
Date: Tue, 03 May 2022 10:38:52 +0000
Subject: [bitcoin-dev] ANYPREVOUT in place of CTV
In-Reply-To: <VI1PR03MB5103AF9CB4D99A32F88B4BF6CCFC9@VI1PR03MB5103.eurprd03.prod.outlook.com>
References: <VI1PR03MB5103AF9CB4D99A32F88B4BF6CCFC9@VI1PR03MB5103.eurprd03.prod.outlook.com>
Message-ID: <WIe3ejSEYdjcCskUKAAmPkGqGlNYeaAVtIU5M2lniXI2A4rPw9JQmIDLNc57GNnjfm5PX6hitj5-zrYTCwgDNm-gBfcl8yBEDT7pkSSyxxo=@protonmail.com>

Hi Jacob,

I think you are a bit confused about how CTV and (tweaked) APO covenants compare. Both would commit to the
same template, so one isn't "safer" than the other. Just more efficient in how it commits to the template.
Replies on the specifics inline.

> While I agree with the arguments in favour of (optional ANYONECANPAY) APOAS in lieu of CTV in the short-term (given the additional benefit of enabling Eltoo), there's a point to add in favour of CTV (or similar) in the long-term beyond as an optimisation.

In the long term, we'd hopefully have more powerful covenants to enable more interesting applications. At this
point CTV would be an optimisation for these covenant constructions instead of an APO one.
My request for feedback was more about the short term, where some are requesting the activation of CTV to
start playing with covenants before we settle on the way forward to more useful covenant. Not that i'm in
favour of it, but if it gains sufficient traction then i believe there is a case for instead doing a tweaked
APO that would optionally commit to the input index, nSequences, etc..[0] I think this addresses the technical
debt concerns of CTV once we have more interesting covenants, as no covenant can entirely emulate a signature
hash type.

> With APOAS-based covenants, the signature message algorithm is tied to both the covenant commitment and transaction validation. Coupling these things introduces a trade-off between safety and flexibility with covenant-based applications.

What do you mean "tied to the transaction validation"? To me "transaction validation" is what a node does to
check whether a block is valid, but you probably mean something else here.
With APOAS-based covenants, the signature message *is* the covenant commitment. I don't see how it is coupled
to anything else. I also don't see how it could ever differ in safety or flexibility with another
hashed-template approach (CTV) if the template is the same.

> E.g. the maximally safe and restricted covenant commits to all inputs and outputs of the transaction (using SIGHASH ALL). However, a less restricted covenant commits to, for example, a single input and a single output (using ANYONECANPAY|SINGLE) but opens itself up to attacks making use of transaction malleability and signature replay.

Indeed the APO approach is more flexible as sighash types may be combined. You can opt-in to more
malleability. I don't think it's a bad thing. Now, sure, the commitment may be replayed, but it's inherent to
any commitment that doesn't commit to the prevout (whether it is CTV or APO, or any other type of templated
covenant that you'd place in the ScriptPubKey) otherwise you'd have a circular hash dependency.
If you are talking about the "half spend" by which two coins with the same covenant get spent in the same
transaction, then committing to the input index fixes this. Interestingly the instance you give *does* commit
to the input index without any tweak to the current APO proposal.

> If instead we separate the covenant commitment from the signatures to validate transactions (as with CTV and TXHASH + CHECKSIGFROMSTACK) then we by-pass this trade-off.

CTV doesn't "separate the signature and the commitment", it doesn't need a signature. Sure one can be added to
further restrict a spending path, but it isn't necessary since the transaction is pre-defined and can't be
malleated. It also sounds like you imply the APO covenant is using a "real" signature. It's not. The pubkey
may well be G. The signature is just a roundabout way to access the hash. So if you wanted to have, say, a
covenant only available to a participant you'd go the same way with either CTV or APO covenants:
<covenant sig> <0x01 G> OP_CHECKSIGVERIFY <Alice pubkey> OP_CHECKSIG
<tx hash> OP_CTV OP_VERIFY <Alice pubkey> OP_CHECKSIG

> The flexibility of additional templates with new CTV versions or with the TXHASH primitive seems to me to enable significantly more utility for covenant-based applications.

TXHASH would definitely enable more utility. Additional templates with new CTV versions would require a new
soft fork for new (hardcoded) usecases. But i'm not going to restart the conversation around the benefits of
slightly more general covenant primitives [1]. :-)

Antoine

[0] See the OP for rationale[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019813.html

[0] Cf the OP for the rationale
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220503/3644bbb9/attachment.html>

From bitcoin-dev at rgrant.org  Tue May  3 14:36:15 2022
From: bitcoin-dev at rgrant.org (Ryan Grant)
Date: Tue, 3 May 2022 14:36:15 +0000
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <CABm2gDrQXbS=i8j+Ja5PTgYekyH2X06eTOs8SXP8X-dhTy-hiQ@mail.gmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
 <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
 <CABm2gDrQXbS=i8j+Ja5PTgYekyH2X06eTOs8SXP8X-dhTy-hiQ@mail.gmail.com>
Message-ID: <CAMnpzfoLTecKQPmdDv7B=_JKgh1LZr_K5aahZ6JA5CsGbvomkA@mail.gmail.com>

On Sun, May 1, 2022 at 8:49 PM Jorge Tim?n via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Sun, May 1, 2022, 09:22 alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

>> [...] Andreas is clueless about BIP 119 and other covenant
>> proposals.  He is spreading misinformation and [...]

> Clueless and spreading disinformation, you say?  What
> misinformation, could you explain?

First, OP_CTV covenants cannot restrict any address that the sender
does not control.  OP_CTV just delivers auditable presigned
transactions.  That's it!  OP_CTV's primary design constraint is to
NOT empower new ways to do blacklists (which are already possible
using unwanted-multisig).  That's not a statement about what Bitcoin
should ultimately become, but rather what Bitcoin is likely ready for.
Much like Bitcoin's design, the simplest possible covenant solution
was chosen, so that it would be "dirt simple" to audit that the code
does only what it should, and no more.

Andreas used a few words of indecision to make excuses for not
code-reviewing BIP119 or the pull request, while using a lot of words
talking about: how dangerous any change is; conservative consensus
process; and GovCoin blacklists.  This gave the strong impression that
the change was dangerous and could easily lead to the creation of
blacklists enforced by L1 consensus itself (rather than enforced by
other signers in a sidechain or unwanted-multisig).

Andreas also didn't look into the reason that the proposed client was
safe and would not cause a chain split.  Speedy Trials by themselves
don't risk chain splits, they poll.  There was no UASF in the planned
executable.  Some devs hate ST because it puts the initiative in
miner's hands to gauge **user support and readiness** - which those
devs feel the miners have no reason to be good at - but that expires
speedily.  If everyone loved the change and the trial was about to
pass, except ornery users - who we love when UASF is needed, of
course - were going to cause a chain split of their own to block it,
then ST offers miners the capability to - very quickly, faster than a
release can be pushed out - change their signaling to again prevent a
chain split.

Russell O'Connor wrote the definitive explanation for how ST arose in
the consensus process and how it was designed to make everyone
unhappy.  It's a great explanation of what we went through last year.

  https://r6.ca/blog/20210615T191422Z.html

    "On Building Consensus and Speedy Trial"

    on | 2021-06-15T19:14:22Z
    by | Russell O'Connor

Andreas also didn't look for a non-attack reason for a separate binary
release.  (Here I feel like I should be naming a lot of devs as well,
hmm.)  Let's go back to O'Connor, who reminds us of a faction from the
last consensus change:

  > The "devs-do-not-decide" faction's concern is regarding the
  > appearance of Bitcoin developers deciding the rules of Bitcoin.
  > [...]  This faction would be fine with users building their own
  > alternative client for forced activation, or a configuration flag
  > for enabling some kind of forced activation that is not enabled by
  > default.

Maintainers of the repository and "Big Name" devs have very personal
reasons to take this stance.  Meanwhile, devs who want to form an
opinion on some given matter but who do not want to do their own code
reviews typically look to Big Name code reviewers for guidance, in a
"Consensus Beauty Contest" [note_kbc].  Contrast this with everyone
who restricts their opinion-formation to their own review of the code;
they are "Doing Consensus Right", rather than being stuck in the
Beauty Contest.  Now, if a "devs-do-not-decide" dev wrote some code,
they implicitly reviewed their own code, right?  But!  If they did not
write that code, then they **must avoid it** ...in proportion to how
much it affects consensus.  According to this theory of Bitcoin's
consensus, we would **expect** Big Names to be partly missing from the
OP_CTV code reviews.  This confuses people who are used to playing the
Consensus Beauty Contest.

  [note_kbc:] for another game about what everybody else thinks,
    see Keynesian beauty contest:
      https://en.wikipedia.org/wiki/Keynesian_beauty_contest

    (The connection is funny to me because we all have to individually
    play this game when deciding what money is, and in so doing pay a
    last homage to Keynes, during our multi-generational exit from his
    eponymous economics of manipulated interest rates.)

Jimmy Song, in a video best fitting the advocacy referred to by
Michael (who did not give any specific link), claims that the OP_CTV
review process is "routing around" some Big Names.  Jimmy is seemingly
unaware that some Big Names are explicitly not participating in
guiding what Bitcoin's consensus should be, and that some are even
using strategic ambiguity to do so.  With the context above, we have a
much less nefarious interpretation of motive for releasing a
binary - one that is part of the consensus process.

  https://www.youtube.com/watch?v=i5VNiiCYnIg
    "Bitcoin Brief - BIP119, Mexico CBDC & Bitcoin's Role in Russia vs
    Ukraine!"
    on | Apr 25, 2022

    (mark 1:13:52.0) Jimmy Song
    (mark 1:18:00.0) "routing around"

An alternative client must, by necessity, offer both its consensus
feature and its activation.  Releasing an alternative client is not a
decision made from impatience and disrespect.  It?s the result of
asking everyone, getting literal non-responses, and intuiting that the
landscape has changed, so something on this path must be different
from last time.  While the alternative client route surprised me when
I heard about it, I cannot say that I personally knew of any other way
to advance what has clearly been a blocked discussion, and so I did
not disassociate myself from the effort.  People do not understand how
blocked up consensus is, and no dev has verbalized a better solution
for maintainers than strategic ambiguity, which is most confusing when
it is delivering only silence.

The typical alternative offered by other devs is, "Wait."  Well, this
"Wait" has almost always meant "Never."  Take a look at CSFS and APO.
They've been waiting, but for what?  What's the bug that BIP authors
can't fix?  Where's the concrete pull request?  Who is going to anoint
them as done?  OP_CTV has made its rite of passage and transcended
these questions.  Its only competition is whether something better can
be imagined, but those arguments need to explain why learning from a
good opcode in the meantime is worth waiting years to work through new
safety concerns.  If any of this matters, then timing matters, too.
OP_CTV is sitting at the front of the bus.

Personally, I suspect that the "something better" crowd wants
recursive covenants, yet recognizes the argument is difficult and
would have put it off in a sense of misplaced priorities, but we'll
find out soon.  If there were some kind of assurance that could be
offered, something that would result in a less contentious soft fork,
instead of stonewalling resistance that makes all soft forks more
contentious, then a later "epsilon" upgrade to covenants would be
easier instead of harder.  This is because everyone who believes that
recursive covenants are not a new threat to Bitcoin could argue
towards a common purpose and resolve that in a binding consensus
agreement.  One such binding mechanism could be parties committing
matched coins locked under a future opcode, although this would be an
extreme departure from typical development and incur massive risk to
the parties if for other reasons phase two of the initiative fails.
It's too bad the game theory isn't simpler.

Finally, Andreas summarized the conservatism in his position as
basically, "If you want scripting and contracts, go buy ETH."  Which
is offensive to everyone trying to make bitcoins more protective of
individual freedom and thus more valuable; whether you're working on
scaling and privacy, the Lightning Network, Discreet Log Contracts,
CoinPool covenants, self-custody vault covenants, building out Taproot
capabilities, or working on other infrastructure.  What a clueless
shitcoiner!

  https://www.youtube.com/watch?v=vAE5fOZ2Luw

    "BIP119, EU regulatory attack, El Salvador, and much more in Q&A
    with aantonop (April 2022)"

    on | Apr 24, 2022
    by | aantonop

    (mark 30:34.0) "if you want to do smart contracts..."

The path to redemption in the Bitcoin community is to unequivocally
help Bitcoin.

Jeremy wasn't always Bitcoin-only, but his efforts have been sincere
and he works in the concrete realm where anyone can judge how pure his
contributions are.  Even if OP_CTV is never activated, or if no
covenant opcode is ever activated, Bitcoin is much more secure due to
the critical bug fixes that Jeremy has already seen merged just
planning ahead for a mempool that could handle dependent transactions.
Bitcoin was never under attack or at risk of harm from Jeremy's
actions to advance the covenants discussion.

Andreas is welcome to research technical merits better before
communicating, and to discover how a vision of powerful contract
covenants - in the most decentralized money that exists - can affect
people's freedom.  In so doing, join us.

From jeremy.l.rubin at gmail.com  Tue May  3 15:51:18 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Tue, 3 May 2022 08:51:18 -0700
Subject: [bitcoin-dev] ANYPREVOUT in place of CTV
In-Reply-To: <p3P0m2_aNXd-4oYhFjCKJyI8zQXahmZed6bv7lnj9M9HbP9gMqMtJr-pP7XRAPs-rn_fJuGu1cv9ero5i8f0cvyZrMXYPzPx17CxJ2ZSvRk=@protonmail.com>
References: <p3P0m2_aNXd-4oYhFjCKJyI8zQXahmZed6bv7lnj9M9HbP9gMqMtJr-pP7XRAPs-rn_fJuGu1cv9ero5i8f0cvyZrMXYPzPx17CxJ2ZSvRk=@protonmail.com>
Message-ID: <CAD5xwhjoMqja6Q8Lqtf9TzCWA9LYn+bUPPs-5DzX5mJUfFYN_Q@mail.gmail.com>

Antoine,

One high level reason to not prefer APO is that it gets 'dangerously close'
to fully recursive covenants.

E.g., just by tweaking APO to use a Schnorr signature without PK
commitment, Pubkey Recovery would be possible, and fully recursive
covenants could be done.

Short of that type of modification, you can still do a "trusted setup" key
deletion covenant with APO and have a fully recursive covenant set up. E.g.

<1 || N-N MuSig> APO

where the N-N MuSig pregenerates a signature of a transaction that commits
to an output with itself, e.g., using SIGHASH_SINGLE.

By itself, this is not super useful, but does create the type of thing that
people might worry about with a recursive covenant since after
initialization it is autonomous.

One use case for this might be, for example, a spacechain backbone that
infinitely iterates, so it isn't entirely useless.

If other opcodes are added, such as OP_IN_OUT_AMOUNT, then you can get all
sorts of recursive covenant interesting stuff on top of that, since you
could pre-sign e.g. for a quanitzed vault a number of different
deposit/withdraw programs as well as increasing balances depending on
timeout waited.


Therefore, I think reasonable people might discriminate the "complexity
class" of the design space available with just CTV v.s. APO.

In contrast, the approach of smaller independent steps:

1) Adding CTV
2) Adding CSFS (enables APO-like behavior, sufficient for Eltoo)
3) Adding flags to CTV, similar to TXHASH, or just adding TXHASH (enables
full covenants)
4) Ergonomic OPCodes for covenants like TLUV, EcTweak, MAST building, etc
(enables efficient covenants)

is a much more granular path where we are able to cleanly 'level up' into
each covenant complexity class only if we deem it to be safe.

<redacted>comment about timelines to produce a modified APO</redacted>

Best,

Jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>

On Fri, Apr 22, 2022 at 4:23 AM darosior via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I would like to know people's sentiment about doing (a very slightly
> tweaked version of) BIP118 in place of
> (or before doing) BIP119.
>
> SIGHASH_ANYPREVOUT and its precedent iterations have been discussed for
> over 6 years. It presents proven and
> implemented usecases, that are demanded and (please someone correct me if
> i'm wrong) more widely accepted than
> CTV's.
>
> SIGHASH_ANYPREVOUTANYSCRIPT, if its "ANYONECANPAY" behaviour is made
> optional [0], can emulate CTV just fine.
> Sure then you can't have bare or Segwit v0 CTV, and it's a bit more
> expensive to use. But we can consider CTV
> an optimization of APO-AS covenants.
>
> CTV advocates have been presenting vaults as the flagship usecase.
> Although as someone who've been trying to
> implement practical vaults for the past 2 years i doubt CTV is necessary
> nor sufficient for this (but still
> useful!), using APO-AS covers it. And it's not a couple dozen more virtual
> bytes that are going to matter for
> a potential vault user.
>
> If after some time all of us who are currently dubious about CTV's stated
> usecases are proven wrong by onchain
> usage of a less efficient construction to achieve the same goal, we could
> roll-out CTV as an optimization.  In
> the meantime others will have been able to deploy new applications
> leveraging ANYPREVOUT (Eltoo, blind
> statechains, etc..[1]).
>
>
> Given the interest in, and demand for, both simple covenants and better
> offchain protocols it seems to me that
> BIP118 is a soft fork candidate that could benefit more (if not most of)
> Bitcoin users.
> Actually i'd also be interested in knowing if people would oppose the
> APO-AS part of BIP118, since it enables
> CTV's features, for the same reason they'd oppose BIP119.
>
>
> [0] That is, to not commit to the other inputs of the transaction (via
> `sha_sequences` and maybe also
> `sha_amounts`). Cf
> https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki#signature-message
> .
>
> [1] https://anyprevout.xyz/ "Use Cases" section
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220503/b53717e0/attachment-0001.html>

From jacob.swambo at kcl.ac.uk  Tue May  3 16:40:22 2022
From: jacob.swambo at kcl.ac.uk (Swambo, Jacob)
Date: Tue, 3 May 2022 16:40:22 +0000
Subject: [bitcoin-dev] ANYPREVOUT in place of CTV
Message-ID: <VI1PR03MB51031D56CE0EFBAAB86CC370CCC09@VI1PR03MB5103.eurprd03.prod.outlook.com>

Thanks Darosior for your response.

I see now that APOAS (e.g. with ANYONECANPAY and/or SINGLE) and CTV (with less restrictive templates) fall prey to the same trade-off between flexibility and safety. So I retract my statement about that 'point in favour of OP_CTV'. It would be nice to by-pass the trade-off, but it seems to be unavoidable. That begs the question, why would we want to have a way to commit to less restrictive templates?

Firstly, I posit that if a transaction does not allow RBF, then it would be very difficult for an attacker to repackage parts of the transaction into a malicious alternative and rebroadcast it before it reaches the mempool of the majority of nodes, who would then reject the malicious alternative.

Secondly, some covenant-based applications aren't as critical as others, and it may well be acceptable to take the risk of using something like ANYONECANPAY|ALL even with RBF enabled.

Third, in a trusted multi-party context you can safely make use of flexible signature messages. Let's say there are 3 people and a UTXO with the following locking script as a single leaf in the tapscript:

<pk1> OP_CHECKSIG <pk2> OP_CHECKSIGADD <pk3> OP_CHECKSIGADD 2 OP_EQUAL <APOAS|SINGLE:signature_covenant_tx> <covenant_PK> OP_CHECKSIG

And they produce this witness:

<SINGLE:sig_1> <ALL:sig_2>

The second participant can, for example, add a change output before signing. <sig_1> is not sufficient and so can't be repackaged without the authorisation of participant 2.


The additional flexibility through composing APOAS with other SIGHASH modes, and the ability to re-bind covenant transactions to different UTXOs allows protocol designers to do more with APOAS covenants than with CTV covenants (as currently spec'd). I'm not yet convinced that BIP-118 is totally safe, but I think the debate recently is part of that maturation process and I'm glad for it.


Jacob Swambo

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220503/0dcb6bd3/attachment.html>

From belcher at riseup.net  Tue May  3 18:03:12 2022
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 3 May 2022 19:03:12 +0100
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
 for BIP39 seeds
In-Reply-To: <dff38JBEJOVZezg16f-wUv3Mcxew_4g3F4_SzE78DBW3UUi87zKh5nz17U0KWnUs1KSC6OEPZsIcxboz86M6-VgJX4cJXY4PnNLvWDRc0RE=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <gp_6EV3OP368tCH4wMFnprOi6AJyQyzK2vZUsm1hIbTKUmfbqh-UaZ4qW_oAAHDgMYdlqGREFgTtdfkPGyzjxdzOiu_R26_rq_phnC1kAi8=@protonmail.com>
 <4a6ef305-cf67-dce3-aed3-ab0a28aa758f@riseup.net>
 <dff38JBEJOVZezg16f-wUv3Mcxew_4g3F4_SzE78DBW3UUi87zKh5nz17U0KWnUs1KSC6OEPZsIcxboz86M6-VgJX4cJXY4PnNLvWDRc0RE=@protonmail.com>
Message-ID: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>

Hello ZmnSCPxj,

Such a system will have to be publicly advertised, in the same way we 
see centralized cryptocurrency staking shops buying ads all over the 
place. That's how they'll make retail hodlers aware that renting out 
your coins in this way is possible. If JoinMarket/Teleport users notice 
such ads appearing then we could change the taker code to remove the 
intermediate certificate keypair, and have the fidelity bond UTXO key 
sign the endpoint (IRC nickname or onion hostname) directly. This 
removes the possibility of fidelity bonds in cold storage. It would have 
to be done for privacy, and it wouldn't be too bad. Right now there's no 
cold storage solution for fidelity bonds yet JoinMarket has about 600 
bitcoins locked up and advertised, which must be all on hot wallets.

Best,
CB

On 03/05/2022 06:26, ZmnSCPxj wrote:
> Good morning Chris,
> 
>> Hello ZmnSCPxj,
>>
>> Renting out fidelity bonds is an interesting idea. It might happen in
>> the situation where a hodler wants to generate yield but doesn't want
>> the hassle of running a full node and yield generator. A big downside of
>> it is that the yield generator income is random while the rent paid is a
>> fixed cost, so there's a chance that the income won't cover the rent.
> 
> The fact that *renting* is at all possible suggests to me that the following situation *could* arise:
> 
> * A market of lessors arises.
> * A surveillor creates multiple identities.
> * Each fake identity rents separately from multiple lessors.
> * Surveillor gets privacy data by paying out rent money to the lessor market.
> 
> In defiads, I and Tamas pretty much concluded that rental would happen inevitably.
> One could say that defiads was a kind of fidelity bond system.
> Our solution for defiads was to prioritize propagating advertisements (roughly equivalent to the certificates in your system, I think) with larger bonded values * min(bonded_time, 1 year).
> However, do note that we did not intend defiads to be used for privacy-sensitive applications like JoinMarket/Teleport.
> 
> 
> Regards,
> ZmnSCPxj

From eric at voskuil.org  Tue May  3 18:26:52 2022
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 3 May 2022 11:26:52 -0700
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
Message-ID: <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>

It looks like you are talking about lending where the principal return is guaranteed by covenant at maturity. This make the net present value of the loan zero.

e

> On May 3, 2022, at 11:03, Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?Hello ZmnSCPxj,
> 
> Such a system will have to be publicly advertised, in the same way we see centralized cryptocurrency staking shops buying ads all over the place. That's how they'll make retail hodlers aware that renting out your coins in this way is possible. If JoinMarket/Teleport users notice such ads appearing then we could change the taker code to remove the intermediate certificate keypair, and have the fidelity bond UTXO key sign the endpoint (IRC nickname or onion hostname) directly. This removes the possibility of fidelity bonds in cold storage. It would have to be done for privacy, and it wouldn't be too bad. Right now there's no cold storage solution for fidelity bonds yet JoinMarket has about 600 bitcoins locked up and advertised, which must be all on hot wallets.
> 
> Best,
> CB
> 
>> On 03/05/2022 06:26, ZmnSCPxj wrote:
>> Good morning Chris,
>>> Hello ZmnSCPxj,
>>> 
>>> Renting out fidelity bonds is an interesting idea. It might happen in
>>> the situation where a hodler wants to generate yield but doesn't want
>>> the hassle of running a full node and yield generator. A big downside of
>>> it is that the yield generator income is random while the rent paid is a
>>> fixed cost, so there's a chance that the income won't cover the rent.
>> The fact that *renting* is at all possible suggests to me that the following situation *could* arise:
>> * A market of lessors arises.
>> * A surveillor creates multiple identities.
>> * Each fake identity rents separately from multiple lessors.
>> * Surveillor gets privacy data by paying out rent money to the lessor market.
>> In defiads, I and Tamas pretty much concluded that rental would happen inevitably.
>> One could say that defiads was a kind of fidelity bond system.
>> Our solution for defiads was to prioritize propagating advertisements (roughly equivalent to the certificates in your system, I think) with larger bonded values * min(bonded_time, 1 year).
>> However, do note that we did not intend defiads to be used for privacy-sensitive applications like JoinMarket/Teleport.
>> Regards,
>> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Wed May  4 02:37:10 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 04 May 2022 02:37:10 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
 <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
Message-ID: <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>

Good morning e,


> It looks like you are talking about lending where the principal return is guaranteed by covenant at maturity. This make the net present value of the loan zero.

I am talking about lending where:

* Lessor pays landlord X satoshis in rent.
* Landlord provides use of the fidelity bond coin (value Y) for N blocks.
* Landlord gets the entire fidelity bond amount (Y) back.

Thus, the landlord gets X + Y satoshis, earning X satoshis, at the cost of having Y satoshis locked for N blocks.

So I do not understand why the value of this, to the landlord, would be 0.
Compare to a simple HODL strategy, where I lock Y satoshis for N blocks and get Y satoshi back.
Or are you saying that a simple HODL strategy is of negative value and that "zero value" is the point where you actively invest all your savings?
Or are you saying that HODL strategy is of some value since it still allows you to spend funds freely in the N blocks you are HODLing them, and the option to spend is of value, while dedfinitely locking the value Y for N blocks is equal to the value X of the rent paid (and thus net zero value)?

Regards,
ZmnSCPxj

From eric at voskuil.org  Wed May  4 04:04:10 2022
From: eric at voskuil.org (eric at voskuil.org)
Date: Tue, 3 May 2022 21:04:10 -0700
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
 <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
 <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>
Message-ID: <03d701d85f6c$027c5900$07750b00$@voskuil.org>

Good evening ZmnSCPxj,

For the sake of simplicity, I'll use the terms lender (Landlord), borrower (Lessor), interest (X), principal (Y), period (N) and maturity (height after N).

The lender in your scenario "provides use" of the principal, and is paid interest in exchange. This is of course the nature of lending, as a period without one's capital incurs an opportunity cost that must be offset (by interest).

The borrower's "use" of the principal is what is being overlooked. To generate income from capital one must produce something and sell it. Production requires both capital and time. Borrowing the principle for the period allows the borrower to produce goods, sell them, and return the "profit" as interest to the lender. Use implies that the borrower is spending the principle - trading it with others. Eventually any number of others end up holding the principle. At maturity, the coin is returned to the lender (by covenant). At that point, all people the borrower traded with are bag holders. Knowledge of this scam results in an imputed net present zero value for the borrowed principal.

While the lack of usability is a cost to the lender, it is not a benefit to the borrower. The lender incurs no risk, and will obtain no reward - as the loan is of no value. Failure to deploy capital is an opportunity cost, and locking it up is not deployment.

Now, even if we accept the generous (economically irrational) assumption that money must increase in price (i.e. trades from more goods) over any given period, we are still left with the observation that the presumed appreciation would accrue to the lender absent lending, making it pointless.

e

> -----Original Message-----
> From: ZmnSCPxj <ZmnSCPxj at protonmail.com>
> Sent: Tuesday, May 3, 2022 7:37 PM
> To: Eric Voskuil <eric at voskuil.org>
> Cc: Chris Belcher <belcher at riseup.net>; Bitcoin Protocol Discussion <bitcoin-
> dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond for
> BIP39 seeds
> 
> Good morning e,
> 
> 
> > It looks like you are talking about lending where the principal return is
> guaranteed by covenant at maturity. This make the net present value of the
> loan zero.
> 
> I am talking about lending where:
> 
> * Lessor pays landlord X satoshis in rent.
> * Landlord provides use of the fidelity bond coin (value Y) for N blocks.
> * Landlord gets the entire fidelity bond amount (Y) back.
> 
> Thus, the landlord gets X + Y satoshis, earning X satoshis, at the cost of having Y
> satoshis locked for N blocks.
> 
> So I do not understand why the value of this, to the landlord, would be 0.
> Compare to a simple HODL strategy, where I lock Y satoshis for N blocks and
> get Y satoshi back.
> Or are you saying that a simple HODL strategy is of negative value and that
> "zero value" is the point where you actively invest all your savings?
> Or are you saying that HODL strategy is of some value since it still allows you
> to spend funds freely in the N blocks you are HODLing them, and the option to
> spend is of value, while dedfinitely locking the value Y for N blocks is equal to
> the value X of the rent paid (and thus net zero value)?
> 
> Regards,
> ZmnSCPxj


From ZmnSCPxj at protonmail.com  Wed May  4 04:19:25 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 04 May 2022 04:19:25 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <03d701d85f6c$027c5900$07750b00$@voskuil.org>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
 <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
 <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>
 <03d701d85f6c$027c5900$07750b00$@voskuil.org>
Message-ID: <eOgoO8s47NFSV5fH_lewnKmRPHTNq09XL6mGVrY6H9P8l0LyeXKtebXCzJkztyS3FZv3VRJVLzPXlnVcntt8CpuLdRq72-rIs2yS4AGyR_0=@protonmail.com>

Good morning e,

> Good evening ZmnSCPxj,
>
> For the sake of simplicity, I'll use the terms lender (Landlord), borrower (Lessor), interest (X), principal (Y), period (N) and maturity (height after N).
>
> The lender in your scenario "provides use" of the principal, and is paid interest in exchange. This is of course the nature of lending, as a period without one's capital incurs an opportunity cost that must be offset (by interest).
>
> The borrower's "use" of the principal is what is being overlooked. To generate income from capital one must produce something and sell it. Production requires both capital and time. Borrowing the principle for the period allows the borrower to produce goods, sell them, and return the "profit" as interest to the lender. Use implies that the borrower is spending the principle - trading it with others. Eventually any number of others end up holding the principle. At maturity, the coin is returned to the lender (by covenant). At that point, all people the borrower traded with are bag holders. Knowledge of this scam results in an imputed net present zero value for the borrowed principal.

But in this scheme, the principal is not being used as money, but as a billboard for an advertisement.
Thus, the bitcoins are not being used as money due to the use of the fidelity bond to back a "you can totally trust me I am not a bot!!" assertion.
This is not the same as your scenario --- the funds are never transferred, instead, a different use of the locked funds is invented.

As a better analogy: I am borrowing a piece of gold, smelting it down to make a nice shiny advertisement "I am totally not a bot!!", then at the end of the lease period, re-smelting it back and returning to you the same gold piece (with the exact same atoms constituting it), plus an interest from my business, which gained customers because of the shiny gold advertisement claiming "I am totally not a bot!!".

That you use the same piece of gold for money does not preclude me using the gold for something else of economic value, like making a nice shiny advertisement, so I think your analysis fails there.
Otherwise, your analysis is on point, but analyses something else entirely.

Regards,
ZmnSCPxj

From lloyd.fourn at gmail.com  Wed May  4 00:26:46 2022
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Wed, 4 May 2022 10:26:46 +1000
Subject: [bitcoin-dev] Password-protected wallet on Taproot
In-Reply-To: <68441995-c7d44f8b69d56a75112afa495bca5bf9@pmq6v.m5r2.onet>
References: <68441995-c7d44f8b69d56a75112afa495bca5bf9@pmq6v.m5r2.onet>
Message-ID: <CAH5Bsr0rUuRrVoWO+xBGqwrTrJNwCp0akUD4OGB0RvU2ttWx6g@mail.gmail.com>

Hi Vjudeu,

Perhaps this could make sense in some setting. e.g. instead of a hardware
device which protects your secret key via pin you use a pinless device but
you create a strong password and use a proper password hash to create
another key and put them in a 2-of-2. But make sure you don't use sha256 to
hash the password. Use a proper password hash. Keep in mind there's also
bip39 passwords which do a similar but this does involve entering them into
the possibly malicious hardware device.

Cheers,

LL

On Mon, 2 May 2022 at 03:56, vjudeu via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> It seems that Taproot allows us to protect each individual public key with
> a password. It could work in this way: we have some normal, Taproot-based
> public key, that is generated in a secure and random way, as it is today in
> Bitcoin Core wallet. Then, we can create another public key, just by taking
> password from the user, executing SHA-256 on that, and using it as a
> private key, so the second key will be just a brainwallet. Then, we can
> combine them in a Schnorr signature, forming 2-of-2 multisig, where the
> first key is totally random, and the second key is just a brainwallet that
> takes a password chosen by the user. By default, each key can be protected
> with the same password, used for the whole wallet, but it could be possible
> to choose different passwords for different addresses, if needed.
> Descriptors should handle that nicely, in the same way as they can be used
> to handle any other 2-of-2 multisig.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220504/f39b25f0/attachment.html>

From salvatore.ingala at gmail.com  Thu May  5 14:32:34 2022
From: salvatore.ingala at gmail.com (Salvatore Ingala)
Date: Thu, 5 May 2022 16:32:34 +0200
Subject: [bitcoin-dev] Wallet policies for descriptor wallets
Message-ID: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>

In the implementation work to implement descriptors and miniscript support
in hardware wallets [a][b], I encountered a number of challenges. Some of
them are technical in nature (e.g. due to constraints of embedded
development). Others are related to the attempts of shaping a good user
experience; with bitcoin reaching more people who are not tech-savvy,
self-custody is only as secure as what those newcomers can use easily
enough.

The main tool that I am using to address some of these challenges is a
layer that sits _on top_ of descriptors/miniscript, while staying very
close to it. Since there is nothing that is vendor-specific in the vast
majority of the approach I'm currently using, I tried to distill it here
for your comments, and will propose a BIP if this is deemed valuable.

I called the language "wallet policies" (suggestions for a better name are
welcome). I believe an approach based on wallet policies can benefit all
hardware wallets (stateless or not) that want to securely support complex
scripts; moreover, wallet policies are close enough to descriptors that
their integration should be extremely easy for any software wallet that is
currently using descriptors.

[a]: https://blog.ledger.com/bitcoin-2 - early demo
[b]: https://blog.ledger.com/miniscript-is-coming - miniscript example


Salvatore Ingala


======================================================

This document starts with a discussion on the motivation for wallet
policies, followed by their formal definition, and some recommendations for
implementations.

== Rationale ==

Output script descriptors [1] were introduced in bitcoin-core as a way to
represent collections of output scripts. It is a very general and flexible
language, designed to catch all the possible use-cases of bitcoin wallets
(that is, if you know the script and you have the necessary keys, it will
be possible to sign transactions with bitcoin-core's descriptor-based
wallets).

Unfortunately, descriptors are not a perfect match for the typical usage of
hardware wallets. Most hardware wallets have the following limitations
compared to a general-purpose machine running bitcoin-core:

- they are embedded devices with limited RAM and computational power;
- they might not be able to import additional private keys (all the keys
are generated from a single seed via [BIP-32](
https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki));
- they might not have permanent storage (*stateless* hardware wallet
design).

Moreover, other limitations like the limited size of the screen might
affect what design choices are available in practice. Therefore, minimizing
the size of the information shown on-screen is important for a good user
experience.

A more native, compact representation of the wallet receive/change would
also benefit the UX of software wallets using descriptors to represent
software wallets using descriptors/miniscript for multisignature or other
complex locking conditions.

=== Security and UX concerns of scripts in hardware wallets ===

For a hardware wallet, allowing the usage of complex scripts presents
challenges in terms of both security and user experience.

==== Security issues ====

One of the security properties that hardware wallets strive to guarantee is
the following: **as long as the user correctly verifies the information
that is shown on the hardware wallet's screen before approving, no action
can be performed without the user's consent**.
This must hold even in scenarios where the attacker has full control of the
machine that is connected to the hardware wallet, and can execute arbitrary
requests or tamper with the legitimate user's requests.

Therefore, it is not at all trivial to allow complex scripts, especially if
they contain keys that belong to third parties.
The hardware wallet must guarantee that the user knows precisely *what*
"policy" is being used to spend the funds, and that the "unspent" funds (if
any) will be protected by the same policy. This makes it impossible for an
attacker to surreptitiously modify the policy, therefore stealing or
burning user's funds.

==== UX issues ====

With miniscript (and taproot trees) allowing substantially more complex
spending policies to be used, it becomes more challenging to make sure that
the user is able _in practice_ to verify the information on the screen.
Therefore, there are two fundamental design goals to strive for:
- Minimize the amount of information that is shown on screen - so that the
user can actually validate it.
- Minimize the number of times the user has to validate such information.

Designing a secure protocol for the coordination of a descriptor wallet
among distant parties is also a challenging problem that is out of scope in
this document. See BIP-129 [2] for an approach designed for multisignature
wallets.

=== Policy registration as a solution ===

A solution to address the security concerns, and part of the UX concerns,
is to have a *registration* flow for the wallet policy in the hardware
wallet. The "wallet policy" must contain enough information to generate all
the relevant addresses/scripts, and for the hardware wallet to identify the
keys that it controls and that are needed to spend the funds sent to those
addresses.

Before a new policy is used for the first time, the user will register a
`wallet policy` into the hardware wallet. While the details of the process
are out of scope in this document, the flow should be something similar to
the following:

1) The software wallet initiates a _wallet policy registration_ on the
hardware wallet; the information should include the wallet policy, but also
a unique *name* that identifies the policy.
2) The hardware wallet shows the wallet policy to the user using the secure
screen.
3) After inspecting the policy and comparing it with a trusted source (for
example a printed backup), the user approves the policy.
4) If stateful, the hardware wallet persists the policy in its permanent
memory; if stateless, it returns a "proof of registration".

The details of how to create a proof of registration are out of scope for
this document; using a *message authentication codes* on a hash committing
to the wallet policy, its name and any additional metadata is an effective
solution if correctly executed.

Once a policy is registered, the hardware wallet can perform the usual
operations securely:
- generating receive and change addresses;
- showing addresses on the secure screen;
- sign transactions spending from a wallet, while correctly identifying
change addresses and computing the transaction fees.

Before any of the actions mentioned above, the hardware wallet will
retrieve the policy from its permanent storage if stateful; if stateless it
will validate the _proof of registration_ before using the wallet policy
provided by the client.
Once the previously registered policy is correctly identified and approved
by the user (for example by its name), and *as long as the policy
registration was executed securely*, hardware wallets can provide a user
experience similar to the usual one for single-signature transactions.

=== Avoiding blowup in descriptor size ===

While reusing a pubkey in different branches of a miniscript is explicitly
forbidden by miniscript (as it has certain negative security implications),
it is still reasonable to reuse the same *xpub* in multiple places, albeit
with different final steps of derivation (so that the actual pubkeys that
are used in the script are indeed different).

For example, using Taproot, a *3*-of-*5* multisignature wallet could use:
- a key path with a 5-of-5 MuSig
- a script tree with a tree of 10 different 3-of-3 MuSig2 scripts, that are
generated, plus a leaf with a fallback *3*-of-*5* multisignature using
plain multisignature (with `OP_CHECKSIGADD`).

This could look similar to:

```
tr(musig2(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {
  {
    {
      pk(musig2(xpubA,xpubB,xpubC)/<2;3>/*),
      {
        pk(musig2(xpubA,xpubB,xpubD)/<4;5>/*)
        pk(musig2(xpubA,xpubB,xpubE)/<6;7>/*),
      }
    },
    {
      pk(musig2(xpubA,xpubC,xpubD)/<8;9>/*),
      {
        pk(musig2(xpubA,xpubC,xpubE)/<10;11>/*),
        pk(musig2(xpubA,xpubD,xpubE)/<12;13>/*)
      }
    }
  },
  {
    {
      pk(musig2(xpubB,xpubC,xpubD)/<14;15>/*),
      pk(musig2(xpubB,xpubC,xpubE)/<16;17>/*)
    },
    {
      pk(musig2(xpubB,xpubD,xpubE)/<18;19>/*),
      {
        pk(musig2(xpubC,xpubD,xpubE)/<20;21>/*),
        sortedmulti_a(3,
          xpubA/<22;23>/*,
          xpubB/<22;23>/*,
          xpubC/<22;23>/*,
          xpubD/<22;23>/*,
          xpubE/<22;23>/*)
      }
    }
  }
})
```

Note that each root xpub appears 8 times. With xpubs being up to 118 bytes
long, the length of the full descriptor can get extremely long (the problem
gets *exponentially* worse with larger multisignature schemes).

Replacing the common part of the key with a short key placeholder and
moving the key expression separately helps to keep the size of the wallet
policy small, which is crucial to allow human inspection in the
registration flow.

=== Restrictions on the supported descriptors ====

The policy language proposed in this document purposely targets only a
stricter subset of the output descriptors language, and it attempts to
generalize in the most natural way the approach that is already used for
single-signature *accounts* (as described in BIP-44 [3], BIP-49 [4], BIP-84
[5], or BIP-86 [6]), or in multisignature setups (see for example BIP-48
[7] and BIP-87 [8]).

Unlike the BIPs mentioned above, it is not tied to any specific script
template, as it applies to arbitrary scripts that can be represented with
descriptors and miniscript.

Supporting only a reduced feature set when compared to output descriptors
helps in implementations (especially on hardware wallets), while attempting
to capture all the common use cases. More features can be added in the
future if motivated by real world necessity.

By keeping the structure of the wallet policy language very close to that
of descriptors, it should be straightforward to:
- write wallet policy parsers;
- extract the descriptors defined by a wallet policy;
- convert a pair of descriptors describing a wallet "account" used in
current implementations into the corresponding wallet policy.


== Wallet policies ==

This section formally defines wallet policies, and how they relate to
output script descriptors.

=== Formal definition ===

A wallet policy is composed by a wallet descriptor template, together with
a vector of key information items.

==== Wallet descriptor template ====

A wallet descriptor template is a `SCRIPT` expression.

`SCRIPT` expressions:
- `sh(SCRIPT)` (top level only): P2SH embed the argument.
- `wsh(SCRIPT)` (top level or inside `sh` only): P2WSH embed the argument.
- `pkh(KP)` (not inside `tr`): P2PKH output for the given public key (use
`addr` if you only know the pubkey hash).
- `wpkh(KP)` (top level or inside `sh` only): P2WPKH output for the given
compressed pubkey.
- `multi(k,KP_1,KP_2,...,KP_n)`: k-of-n multisig script.
- `sortedmulti(k,KP_1,KP_2,...,KP_n)`: k-of-n multisig script with keys
sorted lexicographically in the resulting script.
- `tr(KP)` or `tr(KP,TREE)` (top level only): P2TR output with the
specified key as internal key, and optionally a tree of script paths.
- any valid miniscript template (inside `wsh` or `tr` only).

`TREE` expressions:
- any `SCRIPT` expression
- An open brace `{`, a `TREE` expression, a comma `,`, a `TREE` expression,
and a closing brace `}`

Note: "miniscript templates" are not formally defined in this version of
the document, but it is straightforward to adapt this approach.

`KP` expressions (key placeholders) consist of
- a single character `@`
- followed by a non-negative decimal number, with no leading zeros (except
for `@0`).
- possibly followed by either:
  - the string  `/**`, or
  - a string of the form `/<NUM;NUM>/*`, for two distinct decimal numbers
`NUM` representing unhardened derivations

The `/**` in the placeholder template represents commonly used paths for
receive/change addresses, and is equivalent to `<0;1>`.

The placeholder `@i` for some number *i* represents the *i*-th key in the
vector of key origin information (which must be of size at least *i* + 1,
or the wallet policy is invalid).

==== Key informations vector ====

Each element of the key origin information vector is a `KEY` expression.

- Optionally, key origin information, consisting of:
  - An open bracket `[`
  - Exactly 8 hex characters for the fingerprint of the master key from
which this key is derived from (see [BIP32](
https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) for details)
  - Followed by zero or more `/NUM'` path elements to indicate hardened
derivation steps between the fingerprint and the xpub that follows
  - A closing bracket `]`
- Followed by the actual key, which is either
  - a hex-encoded pubkey, which is either
    - inside `wpkh` and `wsh`, only compressed public keys are permitted
(exactly 66 hex characters starting with `02` or `03`.
    - inside `tr`, x-only pubkeys are also permitted (exactly 64 hex
characters).
  - a serialized extended public key (`xpub`) (as defined in [BIP 32](
https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki))

The placeholder `@i` for some number *i* represents the *i*-th key in the
vector of key orIgin information (which must be of size at least *i* + 1,
or the wallet policy is invalid).

The policy template is invalid if any placeholder `@i` has derivation steps
while the corresponding `(i+1)`-th element of the keys vector is not an
xpub.

==== Additional rules ====

The wallet policy is invalid if any placeholder expression with additional
derivation steps is used when the corresponding key information is not an
xpub.

The key information vector *should* be ordered so that placeholder `@i`
never appear for the first time before an occurrence of `@j`  for some `j <
i`; for example, the first placeholder is always `@0`, the next one is
`@1`, etc.

=== Descriptor derivation ===

>From a wallet descriptor template (and the associated vector of key
informations), one can therefore obtain the 1-dimensional descriptor for
receive and change addresses by:

- replacing each key placeholder with the corresponding key origin
information;
- replacing every `/**`  with `/0/*` for the receive descriptor, and `/1/*`
for the change descriptor;
- replacing every `/<M,N>` with  `/M` for the receive descriptor, and `/N`
for the change descriptor.

For example, the wallet descriptor `pkh(@0/**)` with key information
`["[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL"]`
produces the following two descriptors:

- Receive descriptor:
`pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/0/*)`

- Change descriptor:
`pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*)`

=== Implementation guidelines ===

Implementations must not necessarily implement all of the possible wallet
policies defined by this standard, but it is recommended to clearly
document any limitation.

Implementations can add additional metadata that is stored together with
the wallet policy for the purpose of wallet policy registration and later
usage. Metadata can be vendor-specific and is out of the scope of this
document.

Any implementation in a general-purpose software wallet allowing arbitrary
scripts (or any scripts that involve external cosigners) should put great
care into a process for backing up a wallet policy. In fact, unlike typical
single-signature scenarios, the seed alone is no longer enough to discover
wallet policies with existing funds, and the loss of the backup is likely
to lead to permanent loss of funds.

Avoiding key reuse among different wallet accounts is also extremely
important, but out of scope for this document.

== Examples ==

Some examples of wallet descriptor templates (vectors of keys omitted for
simplicity):
- Template for a native segwit account:
  wpkh(@0/**)
- Template for a taproot BIP86 account:
  tr(@0/**)
- Template for a native segwit 2-of-3:
  wsh(sortedmulti(2, at 0/**, at 1/**, at 2/**))
- Template with miniscript for "1 of 2 equally likely keys":
  wsh(or_b(pk(@0/**),s:pk(@1/**)))

More examples (esp. targeting miniscript on taproot) will be added in the
future.

== References ==

* [1] - Output Script Descriptors:
https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
* [2] - BIP-129 (Bitcoin Secure Multisig Setup):
https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki
* [3] - BIP-44:
https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
* [4] - BIP-49:
https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
* [5] - BIP-84:
https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
* [6] - BIP-86:
https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
* [7] - BIP-48:
https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki
* [8] - BIP-87:
https://github.com/bitcoin/bips/blob/master/bip-0087.mediawiki
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220505/946462e7/attachment-0001.html>

From jtimon at jtimon.cc  Fri May  6 17:17:28 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 6 May 2022 19:17:28 +0200
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <CAMnpzfoLTecKQPmdDv7B=_JKgh1LZr_K5aahZ6JA5CsGbvomkA@mail.gmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
 <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
 <CABm2gDrQXbS=i8j+Ja5PTgYekyH2X06eTOs8SXP8X-dhTy-hiQ@mail.gmail.com>
 <CAMnpzfoLTecKQPmdDv7B=_JKgh1LZr_K5aahZ6JA5CsGbvomkA@mail.gmail.com>
Message-ID: <CABm2gDp6YvV0ZLgW2Mzp8LivMM-KWjAA4ZmV1XO-6R+WuD9zEg@mail.gmail.com>

On Tue, May 3, 2022 at 4:36 PM Ryan Grant <bitcoin-dev at rgrant.org> wrote:

> On Sun, May 1, 2022 at 8:49 PM Jorge Tim?n via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > On Sun, May 1, 2022, 09:22 alicexbt via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> >> [...] Andreas is clueless about BIP 119 and other covenant
> >> proposals.  He is spreading misinformation and [...]
>
> > Clueless and spreading disinformation, you say?  What
> > misinformation, could you explain?
>
> First, OP_CTV covenants cannot restrict any address that the sender
> does not control.  OP_CTV just delivers auditable presigned
> transactions.  That's it!  OP_CTV's primary design constraint is to
> NOT empower new ways to do blacklists (which are already possible
> using unwanted-multisig).  That's not a statement about what Bitcoin
> should ultimately become, but rather what Bitcoin is likely ready for.
> Much like Bitcoin's design, the simplest possible covenant solution
> was chosen, so that it would be "dirt simple" to audit that the code
> does only what it should, and no more.
>
> Andreas used a few words of indecision to make excuses for not
> code-reviewing BIP119 or the pull request, while using a lot of words
> talking about: how dangerous any change is; conservative consensus
> process; and GovCoin blacklists.  This gave the strong impression that
> the change was dangerous and could easily lead to the creation of
> blacklists enforced by L1 consensus itself (rather than enforced by
> other signers in a sidechain or unwanted-multisig).
>
> Andreas also didn't look into the reason that the proposed client was
> safe and would not cause a chain split.  Speedy Trials by themselves
> don't risk chain splits, they poll.  There was no UASF in the planned
> executable.  Some devs hate ST because it puts the initiative in
> miner's hands to gauge **user support and readiness** - which those
> devs feel the miners have no reason to be good at - but that expires
> speedily.  If everyone loved the change and the trial was about to
> pass, except ornery users - who we love when UASF is needed, of
> course - were going to cause a chain split of their own to block it,
> then ST offers miners the capability to - very quickly, faster than a
> release can be pushed out - change their signaling to again prevent a
> chain split.
>

I don't think that's enough of a reason to justify you calling andreas
"clueless". I'm sure whatever andreas said, he said it with the best
intentions.
Remember:

- Avoid personal attacks

Accusing andreas of being clueless is spreading misinformation.

Russell O'Connor wrote the definitive explanation for how ST arose in
> the consensus process and how it was designed to make everyone
> unhappy.  It's a great explanation of what we went through last year.
>
>   https://r6.ca/blog/20210615T191422Z.html
>
>     "On Building Consensus and Speedy Trial"
>
>     on | 2021-06-15T19:14:22Z
>     by | Russell O'Connor
>

That's a lot of text, are you sure he said in there he designed speedy
trial to make everyone unhappy?
Well, if we're still talking about it, that proves that it failed at its
own design criterion of failing fast.
But if you think my judgement about speedy trial (sorry, we discussed it
for so long that I forgot the BIP number, it wasn't eight, I remember that)
and I locked my mind in about speedy trial too soon and without giving
anyone a chance to coordinate about my personal signaling of the
proposal...I guess I can give you a grace period of 6 months to upgrade
your own mind about it and accept my judgment about it, so that concern
about my criticism on the proposal is addressed.
There may be a couple of people trying to create dissent about this opinion
of mine. But once all concerns are addressed...

Andreas also didn't look for a non-attack reason for a separate binary
> release.  (Here I feel like I should be naming a lot of devs as well,
> hmm.)  Let's go back to O'Connor, who reminds us of a faction from the
> last consensus change:
>
>   > The "devs-do-not-decide" faction's concern is regarding the
>   > appearance of Bitcoin developers deciding the rules of Bitcoin.
>   > [...]  This faction would be fine with users building their own
>   > alternative client for forced activation, or a configuration flag
>   > for enabling some kind of forced activation that is not enabled by
>   > default.
>

Yeah, I know, both speedy trial and CTV could be perceived as developers
trying to dictate rules.
I guess that criticism against bip8 can be applied from now on to any
proposal forever. what a great precedent.
It's not always that software designers should focus on making everyone
unhappy (like any other kind of designer, I guess), but some times it's
potential perceptions from vaguely defined groups that should be at the
heart of your design decisions.


> Maintainers of the repository and "Big Name" devs have very personal
> reasons to take this stance.  Meanwhile, devs who want to form an
> opinion on some given matter but who do not want to do their own code
> reviews typically look to Big Name code reviewers for guidance, in a
> "Consensus Beauty Contest" [note_kbc].  Contrast this with everyone
> who restricts their opinion-formation to their own review of the code;
> they are "Doing Consensus Right", rather than being stuck in the
> Beauty Contest.  Now, if a "devs-do-not-decide" dev wrote some code,
> they implicitly reviewed their own code, right?  But!  If they did not
> write that code, then they **must avoid it** ...in proportion to how
> much it affects consensus.  According to this theory of Bitcoin's
> consensus, we would **expect** Big Names to be partly missing from the
> OP_CTV code reviews.  This confuses people who are used to playing the
> Consensus Beauty Contest.
>
>   [note_kbc:] for another game about what everybody else thinks,
>     see Keynesian beauty contest:
>       https://en.wikipedia.org/wiki/Keynesian_beauty_contest
>
>     (The connection is funny to me because we all have to individually
>     play this game when deciding what money is, and in so doing pay a
>     last homage to Keynes, during our multi-generational exit from his
>     eponymous economics of manipulated interest rates.)
>
> Jimmy Song, in a video best fitting the advocacy referred to by
> Michael (who did not give any specific link), claims that the OP_CTV
> review process is "routing around" some Big Names.  Jimmy is seemingly
> unaware that some Big Names are explicitly not participating in
> guiding what Bitcoin's consensus should be, and that some are even
> using strategic ambiguity to do so.  With the context above, we have a
> much less nefarious interpretation of motive for releasing a
> binary - one that is part of the consensus process.
>
>   https://www.youtube.com/watch?v=i5VNiiCYnIg
>     "Bitcoin Brief - BIP119, Mexico CBDC & Bitcoin's Role in Russia vs
>     Ukraine!"
>     on | Apr 25, 2022
>
>     (mark 1:13:52.0) Jimmy Song
>     (mark 1:18:00.0) "routing around"
>
> An alternative client must, by necessity, offer both its consensus
> feature and its activation.  Releasing an alternative client is not a
> decision made from impatience and disrespect.  It?s the result of
> asking everyone, getting literal non-responses, and intuiting that the
> landscape has changed, so something on this path must be different
> from last time.  While the alternative client route surprised me when
> I heard about it, I cannot say that I personally knew of any other way
> to advance what has clearly been a blocked discussion, and so I did
> not disassociate myself from the effort.  People do not understand how
> blocked up consensus is, and no dev has verbalized a better solution
> for maintainers than strategic ambiguity, which is most confusing when
> it is delivering only silence.
>

I don't know about beauty contest or big names.
But if you want to speak in those terms...
If there was a beauty contest for activation proposals and I was part of
the jury, BIP8 would win.
I was once in love with bip9, but, no offense, she is getting old.
And regarding speedy trial, whatever its bip was...sorry, I was trying to
follow your analogy, but some times my instinct tells me not to make
certain jokes about the lord of the rings in certain contexts.
As it turns out, not everyone likes the lord of the rings, or beauty
contests.


> The typical alternative offered by other devs is, "Wait."  Well, this
> "Wait" has almost always meant "Never."  Take a look at CSFS and APO.
> They've been waiting, but for what?  What's the bug that BIP authors
> can't fix?  Where's the concrete pull request?  Who is going to anoint
> them as done?  OP_CTV has made its rite of passage and transcended
> these questions.  Its only competition is whether something better can
> be imagined, but those arguments need to explain why learning from a
> good opcode in the meantime is worth waiting years to work through new
> safety concerns.  If any of this matters, then timing matters, too.
> OP_CTV is sitting at the front of the bus
>

Speedy covenants (I will write an email explaining the proposal and asking
for a bip number) is I think a superior covenant prooposal in terms of not
waiting. Minor activation details aside, it has been implemented for longer
than OP_CTV, and discussed for longer too.
I know what you're thinking: but that would be a hardfork and necromancy.
No, it wouldn't, well, at least not the hardfork part. Can we undo a
softfork with another softfork?
Well, I don't know if always, but some times, in practice, yes we can.
I will explain how in the coming "speedy covenants".


> Personally, I suspect that the "something better" crowd wants
> recursive covenants, yet recognizes the argument is difficult and
> would have put it off in a sense of misplaced priorities, but we'll
> find out soon.  If there were some kind of assurance that could be
> offered, something that would result in a less contentious soft fork,
> instead of stonewalling resistance that makes all soft forks more
> contentious, then a later "epsilon" upgrade to covenants would be
> easier instead of harder.  This is because everyone who believes that
> recursive covenants are not a new threat to Bitcoin could argue
> towards a common purpose and resolve that in a binding consensus
> agreement.  One such binding mechanism could be parties committing
> matched coins locked under a future opcode, although this would be an
> extreme departure from typical development and incur massive risk to
> the parties if for other reasons phase two of the initiative fails.
> It's too bad the game theory isn't simpler.
>

Let's not allow perfection to be the enemy of the good sutff, or something
like that.
Hopefully speedy covenants will solve all the latest tensions around.
And OP_CTV can always be implemented afterwards if it is more optimal under
some criteria.

Finally, Andreas summarized the conservatism in his position as
> basically, "If you want scripting and contracts, go buy ETH."  Which
> is offensive to everyone trying to make bitcoins more protective of
> individual freedom and thus more valuable; whether you're working on
> scaling and privacy, the Lightning Network, Discreet Log Contracts,
> CoinPool covenants, self-custody vault covenants, building out Taproot
> capabilities, or working on other infrastructure.  What a clueless
> shitcoiner!
>
>   https://www.youtube.com/watch?v=vAE5fOZ2Luw
>
>     "BIP119, EU regulatory attack, El Salvador, and much more in Q&A
>     with aantonop (April 2022)"
>
>     on | Apr 24, 2022
>     by | aantonop
>
>     (mark 30:34.0) "if you want to do smart contracts..."
>
> The path to redemption in the Bitcoin community is to unequivocally
> help Bitcoin.
>

The path to redemption for whom?


> Jeremy wasn't always Bitcoin-only, but his efforts have been sincere
> and he works in the concrete realm where anyone can judge how pure his
> contributions are.  Even if OP_CTV is never activated, or if no
> covenant opcode is ever activated, Bitcoin is much more secure due to
> the critical bug fixes that Jeremy has already seen merged just
> planning ahead for a mempool that could handle dependent transactions.
> Bitcoin was never under attack or at risk of harm from Jeremy's
> actions to advance the covenants discussion.
>
> Andreas is welcome to research technical merits better before
> communicating, and to discover how a vision of powerful contract
> covenants - in the most decentralized money that exists - can affect
> people's freedom.  In so doing, join us.
>

yeah, jeremy is welcomed to understand bip8 and the analysis behind it.
He just needs to be open minded and not worry about "perceptions" for a few
minutes, so I don't think he will be able to, sadly.
But let's not personally attack andreas for his opinions.
The only reason you don't like bip8 is because you're ignorant about it and
you haven't reviewed it enough.
join bip8, join us. do it for freedom.

Speaking less specifically of ctv, SC or other covenants proposals, but
more generally about covenants...
What are your thoughts on "visacoin" (described on the technical bitcoin
forums) in the context of covenants?

Anyway, I should be working on a covenants proposal older than ctv myself.
Instead of just talking and criticizing what others have done.
You have a point there.

Jappy Janukka
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220506/d69f650c/attachment-0001.html>

From roconnor at blockstream.com  Fri May  6 18:23:51 2022
From: roconnor at blockstream.com (Russell O'Connor)
Date: Fri, 6 May 2022 14:23:51 -0400
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <CABm2gDp6YvV0ZLgW2Mzp8LivMM-KWjAA4ZmV1XO-6R+WuD9zEg@mail.gmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
 <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
 <CABm2gDrQXbS=i8j+Ja5PTgYekyH2X06eTOs8SXP8X-dhTy-hiQ@mail.gmail.com>
 <CAMnpzfoLTecKQPmdDv7B=_JKgh1LZr_K5aahZ6JA5CsGbvomkA@mail.gmail.com>
 <CABm2gDp6YvV0ZLgW2Mzp8LivMM-KWjAA4ZmV1XO-6R+WuD9zEg@mail.gmail.com>
Message-ID: <CAMZUoKnaj9eOkWcn5NaSJb+NtCe=5Uv_FZR-VAqR0De68G33hA@mail.gmail.com>

On Fri, May 6, 2022 at 2:01 PM Jorge Tim?n via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Russell O'Connor wrote the definitive explanation for how ST arose in
>> the consensus process and how it was designed to make everyone
>> unhappy.  It's a great explanation of what we went through last year.
>>
>>   https://r6.ca/blog/20210615T191422Z.html
>>
>>     "On Building Consensus and Speedy Trial"
>>
>>     on | 2021-06-15T19:14:22Z
>>     by | Russell O'Connor
>>
>
> That's a lot of text, are you sure he said in there he designed speedy
> trial to make everyone unhappy?
> Well, if we're still talking about it, that proves that it failed at its
> own design criterion of failing fast.
>

Quoting from https://r6.ca/blog/20210615T191422Z.html:

> Speedy Trial?s design is not based on any sort of activation philosophy
about failing fast.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220506/7b1fba52/attachment.html>

From john.tromp at gmail.com  Fri May  6 19:58:44 2022
From: john.tromp at gmail.com (John Tromp)
Date: Fri, 6 May 2022 21:58:44 +0200
Subject: [bitcoin-dev] What to do when contentious soft fork activations
	are attempted
In-Reply-To: <mailman.53264.1651860071.8511.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.53264.1651860071.8511.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <CAOU__fwuT8tuV+5KG28toxQO1kwgm0S7CHtsQrZqx7my9RwCtQ@mail.gmail.com>

On Fri, 6 May 2022 7:17PM Jorge Tim?n wrote
> But let's not personally attack andreas for his opinions.
> The only reason you don't like bip8 is because you're ignorant about it and
> you haven't reviewed it enough.

Can you see the irony in equating "clueless about BIP119" with a
personal attack and then calling Jeremy ignorant about BIP8?

-John

From jtimon at jtimon.cc  Fri May  6 22:30:01 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 7 May 2022 00:30:01 +0200
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
Message-ID: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>

OP_CAT was removed. If I remember correctly, some speculated that perhaps
it was removed because it could allow covenants.
I don't remember any technical concern about the OP besides enabling
covenants.
Before it was a common opinion that covenants shouldn't be enabled in
bitcoin because, despite having good use case, there are some nasty attacks
that are enabled with them too. These days it seems the opinion of the
benefits being worth the dangers is quite generalized. Which is quite
understandable given that more use cases have been thought since then.

Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating
a new OP_CAT2 that does the same would be a softfork.
As far a I know, this is the covenants proposal that has been implemented
for the longest time, if that's to be used as a selection criteria.
And as always, this is not incompatible with deploying other convenant
proposals later.
Personally I find the simplicity proposal the best one among all the
covenant proposals by far, including this one.
But I understand that despite the name, the proposal is harder to review
and test than other proposals, for it wouldn't simply add covenants, but a
complete new scripting language that is better in many senses.
Speedy covenants, on the other hand, is much simpler and has been
implemented for longer, so in principle, it should be easier to deploy in a
speedy manner.

What are the main arguments against speedy covenants (aka op_cat2) and
against deploying simplicity in bitcoin respectively?

Sorry if this was discussed before.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/2bd47223/attachment-0001.html>

From jtimon at jtimon.cc  Fri May  6 22:44:24 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 7 May 2022 00:44:24 +0200
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <CAMZUoKnaj9eOkWcn5NaSJb+NtCe=5Uv_FZR-VAqR0De68G33hA@mail.gmail.com>
References: <EpwH6R7Ol7S4DZ4r_UcSSMU9RysZiRHFKZ2WkWZatUIeU9YE9avRZ-YIiafnf6I6U4tBbEu5xHa4JwcGh0fxMuyY-fGMwpaesfo5XK6SzLc=@protonmail.com>
 <WtHCNGNhHAWBer9QnaWajdbJ341jMHQJa23WAPgNaRldKhopPIN7ry8wNAnmfnlAK6j0m7p3NEgckA6kIjWV5_rFla63Bh6HCfAlLHFODsE=@protonmail.com>
 <CABm2gDrQXbS=i8j+Ja5PTgYekyH2X06eTOs8SXP8X-dhTy-hiQ@mail.gmail.com>
 <CAMnpzfoLTecKQPmdDv7B=_JKgh1LZr_K5aahZ6JA5CsGbvomkA@mail.gmail.com>
 <CABm2gDp6YvV0ZLgW2Mzp8LivMM-KWjAA4ZmV1XO-6R+WuD9zEg@mail.gmail.com>
 <CAMZUoKnaj9eOkWcn5NaSJb+NtCe=5Uv_FZR-VAqR0De68G33hA@mail.gmail.com>
Message-ID: <CABm2gDooJ=HHmNdwncrthOn1deoCojhEUusWnNj_0ASsq9wybg@mail.gmail.com>

So, to be clear, you didn't design speedy trial "to make everyone unhappy"
as Ryan claims, no?
That's a really strange claim on his part.
When the grace period for slower activation after lock in was added, I
don't think it was added to make me or people like me who dislike that
proposal unhappy. On the contrary, I think the goal was precisely to
address some of our concerns.
But it doesn't address them all, as I've tried to explain other times.
I truly think you wanted to make everyone happy with speedy trial, but you
didn't do it, sorry.
I know it' not a lack of capacity because you did impressive and genius
things like simplicity.
But despite your best intentions and your great capacity, I still think
speedy trial is a very bad proposal because you got the analysis wrong.
Let me reiterate that this is not attack against you, but only against one
of your ideas.
Sorry if I sounded sarcastic, but I was trying to be sarcastic with ryan,
not with you.


On Fri, May 6, 2022 at 8:24 PM Russell O'Connor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, May 6, 2022 at 2:01 PM Jorge Tim?n via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>>
>> Russell O'Connor wrote the definitive explanation for how ST arose in
>>> the consensus process and how it was designed to make everyone
>>> unhappy.  It's a great explanation of what we went through last year.
>>>
>>>   https://r6.ca/blog/20210615T191422Z.html
>>>
>>>     "On Building Consensus and Speedy Trial"
>>>
>>>     on | 2021-06-15T19:14:22Z
>>>     by | Russell O'Connor
>>>
>>
>> That's a lot of text, are you sure he said in there he designed speedy
>> trial to make everyone unhappy?
>> Well, if we're still talking about it, that proves that it failed at its
>> own design criterion of failing fast.
>>
>
> Quoting from https://r6.ca/blog/20210615T191422Z.html:
>
> > Speedy Trial?s design is not based on any sort of activation philosophy
> about failing fast.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/fb08a129/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat May  7 03:06:23 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 07 May 2022 03:06:23 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
References: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
Message-ID: <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>

Good morning Jorge,

> OP_CAT was removed. If I remember correctly, some speculated that perhaps it was removed because it could allow covenants.I don't remember any technical concern about the OP besides enabling covenants.Before it was a common opinion that covenants shouldn't be enabled in bitcoin because, despite having good use case, there are some nasty attacks that are enabled with them too. These days it seems the opinion of the benefits being worth the dangers is quite generalized. Which is quite understandable given that more use cases have been thought since then.

I think the more accurate reason for why it was removed is because the following SCRIPT of N size would lead to 2^N memory usage:

    OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...

In particular it was removed at about the same time as `OP_MUL`, which has similar behavior (consider that multiplying two 32-bit numbers results in a 64-bit number, similar to `OP_CAT`ting a vector to itself).

`OP_CAT` was removed long before covenants were even expressed as a possibility.

Covenants were first expressed as a possibility, I believe, during discussions around P2SH.
Basically, at the time, the problem was this:

* Some receivers wanted to use k-of-n multisignature for improved security.
* The only way to implement this, pre-P2SH, was by putting in the `scriptPubKey` all the public keys.
* The sender is the one paying for the size of the `scriptPubKey`.
* It was considered unfair that the sender is paying for the security of the receiver.

Thus, `OP_EVAL` and the P2SH concept was conceived.
Instead of the `scriptPubKey` containing the k-of-n multisignature, you create a separate script containing the public keys, then hash it, and the `scriptPubKey` would contain the hash of the script.
By symmetry with the P2PKH template:

    OP_DUP OP_HASH160 <hash160(pubkey)> OP_EQUALVERIFY OP_CHECKSIG

The P2SH template would be:

    OP_DUP OP_HASH160 <hash160(redeemScript)> OP_EQUALVERIFY OP_EVAL

`OP_EVAL` would take the stack top vector and treat it as a Bitcoin SCRIPT.

It was then pointed out that `OP_EVAL` could be used to create recursive SCRIPTs by quining using `OP_CAT`.
`OP_CAT` was already disabled by then, but people were talking about re-enabling it somehow by restricting the output size of `OP_CAT` to limit the O(2^N) behavior.

Thus, since then, `OP_CAT` has been associated with ***recursive*** covenants (and people are now reluctant to re-enable it even with a limit on its output size, because recursive covenants).
In particular, `OP_CAT` in combination with `OP_CHECKSIGFROMSTACK` and `OP_CHECKSIG`, you could get a deferred `OP_EVAL` and then use `OP_CAT` too to quine.

Because of those concerns, the modern P2SH is now "just a template" with an implicit `OP_EVAL` of the `redeemScript`, but without any `OP_EVAL` being actually enabled.

(`OP_EVAL` cannot replace an `OP_NOP` in a softfork, but it is helpful to remember that P2SH was pretty much what codified the difference between softfork and hardfork, and the community at the time was small enough (or so it seemed) that a hardfork might not have been disruptive.)

> Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.

If you are willing to work in Taproot the same OP-code can be enabled in a softfork by using a new Tapscript version.

If you worry about quantum-computing-break, a new SegWit version (which is more limited than Tapscript versions, unfortunately) can also be used, creating a new P2WSHv2 (or whatever version) that enables these opcodes.

> As far a I know, this is the covenants proposal that has been implemented for the longest time, if that's to be used as a selection criteria.And as always, this is not incompatible with deploying other convenant proposals later.

No, it was `OP_EVAL`, not `OP_CAT`.
In particular if `OP_EVAL` was allowed in the `redeemScript` then it would enable covenants as well.
It was just pointed out that `OP_CAT` enables recursive covenenats in combination with `OP_EVAL`-in-`redeemScript`.

In particular, in combination with `OP_CAT`, `OP_EVAL` not only allows recursive covenants, but also recursion *within* a SCRIPT i.e. unbounded SCRIPT execution.
Thus, `OP_EVAL` is simply not going to fly, at all.

> Personally I find the simplicity proposal the best one among all the covenant proposals by far, including this one.But I understand that despite the name, the proposal is harder to review and test than other proposals, for it wouldn't simply add covenants, but a complete new scripting language that is better in many senses.Speedy covenants, on the other hand, is much simpler and has been implemented for longer, so in principle, it should be easier to deploy in a speedy manner.
>
> What are the main arguments against speedy covenants (aka op_cat2) and against deploying simplicity in bitcoin respectively?
> Sorry if this was discussed before.

`OP_CAT`, by itself, does not implement any covenants --- instead, it creates recursive covenants when combined with almost all covenant opcodes.

Regards,
ZmnSCPxj

From alicexbt at protonmail.com  Sat May  7 02:40:36 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Sat, 07 May 2022 02:40:36 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
Message-ID: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>

Hi Bitcoin Developers,

Summary for the last CTV meeting:

Topics:

1)APO version of the simple vault
2)APO as alternative to CTV
3)fiatjaf's CTV spacechain demo
4)Compare CTV with other covenant proposals
5)Recursive covenants
6)Responding to FUD

===================================================
APO version of the simple vault
===================================================

- It is vulnerable to the half-spend problem, where multiple vaulted outputs (of the same denomination) can be spent together, burning all but the first to fees. Fixing this requires amending APOAS to cover the current input index.
- The unvault transaction is third-party malleable (it can have more inputs added to it). One practical implication is that you can't hand a list of the unvault txids to a watchtower, you have to tell them which outpoints to watch which is less privacy-preserving. Fixing this requires amending APOAS to cover the number of inputs.
Both of these issues are fixed by the BIP 118 changes suggested by darosior (although they still not officially spec'd afaik), which would basically make APO have a CTV-equivalent hash mode (minus scriptSig of other inputs)
- simple-apo-vault could use APO-as-spec'd with SIGHASH_SINGLE|SIGHASH_ANYONECANPAY, which would solve the half-spend problem (but not malleability) and have some other interesting properties, like more natural dynamic fees (add inputs+change) and the ability spend multiple vaulted outputs together. This would, however, introduce a tx pinning attack vector and prevent rate-limited vaults.

===================================================
APO as alternative to CTV
===================================================

- Current APO is unusable as a CTV alternative, (revised)APO seems to be as useful as CTV is (plus some extra flexibility from existing sighash flags)
- Main drawbacks being the additional witness satisfaction cost, the network-side full-node validation costs of checking a signature instead of just a hash, and not being segwit0-compatible (meaning, among others, not quantumphobic-friendly)
- Its about 3x for APO-in-taproot vs CTV-in-taproot. CTV-in-segwitv0 and CTV-in-bare-spk get you even more savings
- APO is far from being ready, let alone (revised)APO
- APOv2 would be both better for Eltoo and better for CTV, since you can use a trick to make the signatures smaller
- "layered commitments" is essential for eltoo to be usable or not is unclear. AJ Towns thinks it is required while Christian Decker thinks it is not.

===================================================
fiatjaf's CTV spacechain demo
===================================================

https://github.com/fiatjaf/simple-ctv-spacechain

===================================================
Compare CTV with other covenant proposals
===================================================

Unlike crypto primitves (e.g., BLS vs Schnorr), there's not really actually a defined way to compare them. So one exercise of value would be if everyone tries to actually either agree to or come up with their own framework for comparing covenants.

Billy Tetrud's email: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020402.html

- Prefers CTV for several reasons. Mainly because of being simple, documentation, code, tools, review and testing.
- Everything else either introduces malleability, infinite recursion, or has interactions with other proposed opcodes that could introduce potentially undesirable effects like those.
- Anything involving OP_CAT is out for the time being. There are so many things it can enable that it seems most people aren't comfortable adding it at the moment.
- APO wallet vaults seem rather hacky, inefficient, and limited.
- TLUV is built for evictions, TLUV + IN_OUT_AMOUNT and OP_CHECKOUTPUTVERIFY allows recursive covenants

===================================================
Recursive covenants
===================================================

jamesob:
I don't particularly understand the aversion to infinite recursion, which seems no different than the risk of potentially burning your coins. It's not like infinite recursion on bitcoin is some kind of DoS vector or poses execution overhead like an Ethereum VM bug might.

rgrant:
i think people who want recursion for cool stuff are worried that pedestrian stuff will prevent it.

jeremyrubin:
i think people are afraid of weird shit happening, less so of recursion in particular

hsjoberg:
"Recursive covenants" is the boogie man

shesek:
"recursion" translates to "complex black magic" for nondevs' -- recursion is the new turing completeness

===================================================
Responding to FUD
===================================================

- It could be a good idea to include showing a way to do blacklists in the bug bounty offer
- The potential concerns about recursive covenants have to clearly explained so they can be properly examined.
- An article about CTV myths similar to segwit: : https://blog.blockstream.com/en-segwit-myths-debunked/
- Some users think CTV might delay eltoo

TL;DR
"The initial resistance came from the Speedy Trial proposal. Then later on rumors and FUD started spreading around regarding CTV and covenants."
- hsjoberg

https://gnusha.org/ctv-bip-review/2022-05-03.log

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/52f50052/attachment-0001.html>

From vjudeu at gazeta.pl  Sat May  7 03:52:48 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Sat, 07 May 2022 03:52:48 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
Message-ID: <629505ec-81ba-013d-43a0-009d61fada23@gazeta.pl>

> Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.

We have TapScript for that. OP_CAT is defined as OP_SUCCESS, it can be re-enabled in a soft-fork way. For now, OP_CAT in TapScript simply means "anyone can move those coins", so adding some restrictions is all we need to re-enable this opcode. Introducing OP_CAT2 is not needed at all, unless it will be totally different, but then it should not be named as OP_CAT2, but rather as OP_SOMETHING_ELSE, it depends how different it will be from OP_CAT.

> OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...

So we can use OP_SUBSTR instead. Maybe even OP_SPLIT will be enough, if data expansion is the only problem, then we can focus on getting it smaller. Or better, we could use OP_FIND that would return true/false answer if element A is a part of element B, when we do byte-to-byte comparison. In general, we can use many different string-based functions to do the same things, we can choose something that will not exponentially explode as OP_CAT.

> It was considered unfair that the sender is paying for the security of the receiver.

It can be changed by using different sighashes, for example, it is possible to create a "negative fee transaction", where all transaction costs are paid by receiver. Using SIGHASH_SINGLE | SIGHASH_ANYONECANPAY with a higher amount in outputs than inputs is enough to do that, see testnet3 transaction 495d2007ae8b741c70c3d278c02ce03702223b9675e954ecabbb634c6cd5bf40.

On 2022-05-07 05:06:46 user ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Good morning Jorge,

> OP_CAT was removed. If I remember correctly, some speculated that perhaps it was removed because it could allow covenants.I don't remember any technical concern about the OP besides enabling covenants.Before it was a common opinion that covenants shouldn't be enabled in bitcoin because, despite having good use case, there are some nasty attacks that are enabled with them too. These days it seems the opinion of the benefits being worth the dangers is quite generalized. Which is quite understandable given that more use cases have been thought since then.

I think the more accurate reason for why it was removed is because the following SCRIPT of N size would lead to 2^N memory usage:

    OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...

In particular it was removed at about the same time as `OP_MUL`, which has similar behavior (consider that multiplying two 32-bit numbers results in a 64-bit number, similar to `OP_CAT`ting a vector to itself).

`OP_CAT` was removed long before covenants were even expressed as a possibility.

Covenants were first expressed as a possibility, I believe, during discussions around P2SH.
Basically, at the time, the problem was this:

* Some receivers wanted to use k-of-n multisignature for improved security.
* The only way to implement this, pre-P2SH, was by putting in the `scriptPubKey` all the public keys.
* The sender is the one paying for the size of the `scriptPubKey`.
* It was considered unfair that the sender is paying for the security of the receiver.

Thus, `OP_EVAL` and the P2SH concept was conceived.
Instead of the `scriptPubKey` containing the k-of-n multisignature, you create a separate script containing the public keys, then hash it, and the `scriptPubKey` would contain the hash of the script.
By symmetry with the P2PKH template:

    OP_DUP OP_HASH160 <hash160(pubkey)> OP_EQUALVERIFY OP_CHECKSIG

The P2SH template would be:

    OP_DUP OP_HASH160 <hash160(redeemScript)> OP_EQUALVERIFY OP_EVAL

`OP_EVAL` would take the stack top vector and treat it as a Bitcoin SCRIPT.

It was then pointed out that `OP_EVAL` could be used to create recursive SCRIPTs by quining using `OP_CAT`.
`OP_CAT` was already disabled by then, but people were talking about re-enabling it somehow by restricting the output size of `OP_CAT` to limit the O(2^N) behavior.

Thus, since then, `OP_CAT` has been associated with ***recursive*** covenants (and people are now reluctant to re-enable it even with a limit on its output size, because recursive covenants).
In particular, `OP_CAT` in combination with `OP_CHECKSIGFROMSTACK` and `OP_CHECKSIG`, you could get a deferred `OP_EVAL` and then use `OP_CAT` too to quine.

Because of those concerns, the modern P2SH is now "just a template" with an implicit `OP_EVAL` of the `redeemScript`, but without any `OP_EVAL` being actually enabled.

(`OP_EVAL` cannot replace an `OP_NOP` in a softfork, but it is helpful to remember that P2SH was pretty much what codified the difference between softfork and hardfork, and the community at the time was small enough (or so it seemed) that a hardfork might not have been disruptive.)

> Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.

If you are willing to work in Taproot the same OP-code can be enabled in a softfork by using a new Tapscript version.

If you worry about quantum-computing-break, a new SegWit version (which is more limited than Tapscript versions, unfortunately) can also be used, creating a new P2WSHv2 (or whatever version) that enables these opcodes.

> As far a I know, this is the covenants proposal that has been implemented for the longest time, if that's to be used as a selection criteria.And as always, this is not incompatible with deploying other convenant proposals later.

No, it was `OP_EVAL`, not `OP_CAT`.
In particular if `OP_EVAL` was allowed in the `redeemScript` then it would enable covenants as well.
It was just pointed out that `OP_CAT` enables recursive covenenats in combination with `OP_EVAL`-in-`redeemScript`.

In particular, in combination with `OP_CAT`, `OP_EVAL` not only allows recursive covenants, but also recursion *within* a SCRIPT i.e. unbounded SCRIPT execution.
Thus, `OP_EVAL` is simply not going to fly, at all.

> Personally I find the simplicity proposal the best one among all the covenant proposals by far, including this one.But I understand that despite the name, the proposal is harder to review and test than other proposals, for it wouldn't simply add covenants, but a complete new scripting language that is better in many senses.Speedy covenants, on the other hand, is much simpler and has been implemented for longer, so in principle, it should be easier to deploy in a speedy manner.
>
> What are the main arguments against speedy covenants (aka op_cat2) and against deploying simplicity in bitcoin respectively?
> Sorry if this was discussed before.

`OP_CAT`, by itself, does not implement any covenants --- instead, it creates recursive covenants when combined with almost all covenant opcodes.

Regards,
ZmnSCPxj
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From vjudeu at gazeta.pl  Sat May  7 04:50:12 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Sat, 07 May 2022 04:50:12 +0000
Subject: [bitcoin-dev] Adding SIGHASH to TXID
Message-ID: <75be7180-709a-b735-a27b-50d0c6a2af5b@gazeta.pl>

For now, we have txid:vout as a previous transaction output. This means that to have a stable TXID, we are forced to use SIGHASH_ALL somewhere, just to prevent any transaction modifications that can happen during adding some inputs and outputs. But it seems that new sighashes could be far more powerful than we expected: it is technically possible to not only remove previous transaction output by using SIGHASH_ANYPREVOUT. We can do more and do it better, we could decide, how to calculate this txid at all!

So, something like SIGHASH_PREVOUT_NONE would be similar to SIGHASH_NONE (applied to the previous transaction, taken from txid). To have SIGHASH_ANYPREVOUT, we need to remove absolutely everything, I don't know any such sighashes, because even SIGHASH_NONE | SIGHASH_ANYONECANPAY will commit at least to some fields, for example to the locktime. But, if we introduce SIGHASH_PREVOUT_XYZ flags for all existing sighashes, we would have this:

SIGHASH_PREVOUT_NONE
SIGHASH_PREVOUT_SINGLE
SIGHASH_PREVOUT_ALL
SIGHASH_PREVOUT_ANYONECANPAY

Then, the procedure is as follows: we use txid:vout to find our previous transaction. Then, we apply those sighashes to this previous transaction, to form a new txid, that will be checked during every OP_CHECKSIG-based opcode. In this way, our txid:vout is used just to do transaction lookup, after that, sighashes can be applied to the previous transaction, so our txid could remain stable, even if someone will add some inputs and outputs.

By default, we could use SIGHASH_PREVOUT_ALL, that would mean our txid:vout remains unchanged. Then, SIGHASH_PREVOUT_SINGLE would obviously mean, that we want to commit only to this particular previous transaction output. That would allow adding any new outputs to the previous transaction, without affecting our replaced txid, but also without blindly accepting any txid, because some data of the previous transaction would be still hashed.

Then, SIGHASH_PREVOUT_NONE is an interesting case, because it would mean that no outputs of the previous transaction are checked. But still, the inputs will be! That would mean: "I don't care about in-between addresses, but I care that it was initiated from these inputs". In this case, it is possible to choose some input without those flags, and then apply SIGHASH_PREVOUT_NONE many times, to make sure that everything started from that input, but everything in-between can be anything.

All of those three SIGHASH_PREVOUT_XYZ flags could be combined with SIGHASH_PREVOUT_ANYONECANPAY. That would mean all inputs of the previous transaction are discarded, except from the input number matching "vout". Or we could just use SIGHASH_PREVOUT_ANY instead and discard all inputs from that previous transaction, that could also be combined with other sighashes.

So, to sum up, by applying sighashes to the previous transaction, instead of allowing for any transaction, we could still have some control of our txid, and I think it could be better than just saying "give me any txid, I will accept that". I think in most cases we don't want to allow any txid: we want to only "control the flow", just to make sure that our signatures will sign what we want and will not be invalidated by changing some transaction inputs and outputs, unrelated to the currently-checked signature.

From jeremy.l.rubin at gmail.com  Sat May  7 11:55:35 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Sat, 7 May 2022 07:55:35 -0400
Subject: [bitcoin-dev] Adding SIGHASH to TXID
In-Reply-To: <75be7180-709a-b735-a27b-50d0c6a2af5b@gazeta.pl>
References: <75be7180-709a-b735-a27b-50d0c6a2af5b@gazeta.pl>
Message-ID: <CAD5xwhjqF3b896vV=w7BPDMAnhe49qJO-KgPyAW+5qKjZywEhQ@mail.gmail.com>

Have you seen the inherited ID proposal from John Law on this list?

It's a pretty thorough treatment of this type of proposal, curious if you
think it overlaps what you had in mind?

Honestly, I've yet to fully load in exactly how the applications of it
work, but I'd be interested to hear your thoughts.

On Sat, May 7, 2022, 4:55 AM vjudeu via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> For now, we have txid:vout as a previous transaction output. This means
> that to have a stable TXID, we are forced to use SIGHASH_ALL somewhere,
> just to prevent any transaction modifications that can happen during adding
> some inputs and outputs. But it seems that new sighashes could be far more
> powerful than we expected: it is technically possible to not only remove
> previous transaction output by using SIGHASH_ANYPREVOUT. We can do more and
> do it better, we could decide, how to calculate this txid at all!
>
> So, something like SIGHASH_PREVOUT_NONE would be similar to SIGHASH_NONE
> (applied to the previous transaction, taken from txid). To have
> SIGHASH_ANYPREVOUT, we need to remove absolutely everything, I don't know
> any such sighashes, because even SIGHASH_NONE | SIGHASH_ANYONECANPAY will
> commit at least to some fields, for example to the locktime. But, if we
> introduce SIGHASH_PREVOUT_XYZ flags for all existing sighashes, we would
> have this:
>
> SIGHASH_PREVOUT_NONE
> SIGHASH_PREVOUT_SINGLE
> SIGHASH_PREVOUT_ALL
> SIGHASH_PREVOUT_ANYONECANPAY
>
> Then, the procedure is as follows: we use txid:vout to find our previous
> transaction. Then, we apply those sighashes to this previous transaction,
> to form a new txid, that will be checked during every OP_CHECKSIG-based
> opcode. In this way, our txid:vout is used just to do transaction lookup,
> after that, sighashes can be applied to the previous transaction, so our
> txid could remain stable, even if someone will add some inputs and outputs.
>
> By default, we could use SIGHASH_PREVOUT_ALL, that would mean our
> txid:vout remains unchanged. Then, SIGHASH_PREVOUT_SINGLE would obviously
> mean, that we want to commit only to this particular previous transaction
> output. That would allow adding any new outputs to the previous
> transaction, without affecting our replaced txid, but also without blindly
> accepting any txid, because some data of the previous transaction would be
> still hashed.
>
> Then, SIGHASH_PREVOUT_NONE is an interesting case, because it would mean
> that no outputs of the previous transaction are checked. But still, the
> inputs will be! That would mean: "I don't care about in-between addresses,
> but I care that it was initiated from these inputs". In this case, it is
> possible to choose some input without those flags, and then apply
> SIGHASH_PREVOUT_NONE many times, to make sure that everything started from
> that input, but everything in-between can be anything.
>
> All of those three SIGHASH_PREVOUT_XYZ flags could be combined with
> SIGHASH_PREVOUT_ANYONECANPAY. That would mean all inputs of the previous
> transaction are discarded, except from the input number matching "vout". Or
> we could just use SIGHASH_PREVOUT_ANY instead and discard all inputs from
> that previous transaction, that could also be combined with other sighashes.
>
> So, to sum up, by applying sighashes to the previous transaction, instead
> of allowing for any transaction, we could still have some control of our
> txid, and I think it could be better than just saying "give me any txid, I
> will accept that". I think in most cases we don't want to allow any txid:
> we want to only "control the flow", just to make sure that our signatures
> will sign what we want and will not be invalidated by changing some
> transaction inputs and outputs, unrelated to the currently-checked
> signature.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/032f51be/attachment.html>

From ZmnSCPxj at protonmail.com  Sat May  7 14:08:27 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 07 May 2022 14:08:27 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CABm2gDrdwMjLu=i0p2m4SZ_91xpr-RvwSSWOnS9jhaQ3uaCxPA@mail.gmail.com>
References: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
 <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
 <CABm2gDrdwMjLu=i0p2m4SZ_91xpr-RvwSSWOnS9jhaQ3uaCxPA@mail.gmail.com>
Message-ID: <CiNPwh37hW6iDk3mMg6G2QWMPS5ADUvSdySnNp6esOaloiVyoPwHGxOMLyG6mMGQnyf4iGcch12XfmOB2WnFcETwFwvRTSNSeBu27G9Cju8=@protonmail.com>

Good morning Jorge,

> Thanks a lot for the many clarifications.
> Yeah, I forgot it wasn't OP_CAT alone, but in combination with other things.
> I guess this wouldn't be a covenants proposal then.
> But simplicity would enable covenants too indeed, no?
> Or did I get that wrong too?

Yes, it would enable covenants.

However, it could also enable *recursive* covenants, depending on what introspection operations are actually implemented (though maybe not? Russell O'Connor should be the one that answers this).

It is helpful to delineate between non-recursive covenants from recursive covenants.

* Even ***with*** `OP_CAT`, the following will enable non-recursive covenants without enabling recursive covenants:
  * `OP_CTV`
  * `SIGHASH_ANYPREVOUT`
* With `OP_CAT`, the following would enable recursive covenants:
  * `OP_EVAL`
  * `OP_CHECKSIGFROMSTACK`
  * `OP_TX`/`OP_TXHASH`
  * ...possibly more.
    * It is actually *easier* to *design* an opcode which inadvertently supports recursive covenants than to design one which avoids recursive covenants.

Recursive covenants are very near to true Turing-completeness.
We want to avoid Turing-completeness due to the halting problem being unsolvable for Turing-complete languages.
That is, given just a program, we cannot determine for sure if for all possible inputs, it will terminate.
It is important in our context (Bitcoin) that any SCRIPT programs we write *must* terminate, or else we run the risk of a DoS on the network.

A fair amount of this is theoretical crap, but if you want to split hairs, recursive covenants are *not* Turing-complete, but are instead total functional programming with codata.

As a very rough bastardization, a program written in a total functional programming language with codata will always assuredly terminate.
However, the return value of a total functional programming language with codata can be another program.
An external program (written in a Turing-complete language) could then just keep invoking the interpreter of the total functional programming language with codata (taking the output program and running it, taking *its* output program and running it, ad infinitum, thus effectively able to loop indefinitely.

Translated to Bitcoin transactions, a recursive covenant system can force an output to be spent only if the output is spent on a transaction where one of the outputs is the same covenant (possibly with tweaks).
Then an external program can keep passing the output program to the Bitcoin SCRIPT interpreter --- by building transactions that spend the previous output.

This behavior is still of concern.
It may be possible to attack the network by eroding its supply, by such a recursive covenant.

--

Common reactions:

* We can just limit the number of opcodes we can process and then fail it if it takes too many operations!
  That way we can avoid DoS!
  * Yes, this indeed drops it from Turing-complete to total, possibly total functional programming **without** codata.
    But if it is possible to treat data as code, it may drop it "total but with codata" instead (i.e. recursive covenants).
    But if you want to avoid recursive covenants while allowing recursive ones (i.e. equivalent to total without codata), may I suggest you instead look at `OP_CTV` and `SIGHASH_ANYPREVOUT`?

* What is so wrong with total-with-codata anyway??
  So what if the recursive covenant could potentially consume all Bitcoins, nobody will pay to it except as a novelty!!
  If you want to burn your funds, 1BitcoinEater willingly accepts it!
  * The burden of proof-of-safety is on the proposer, so if you have some proof that total-with-codata is safe, by construction, then sure, we can add opcodes that may enable recursive covenants, and add `OP_CAT` back in too.

Regards,
ZmnSCPxj

From jtimon at jtimon.cc  Sat May  7 13:31:27 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 7 May 2022 15:31:27 +0200
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <629505ec-81ba-013d-43a0-009d61fada23@gazeta.pl>
References: <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
 <629505ec-81ba-013d-43a0-009d61fada23@gazeta.pl>
Message-ID: <CABm2gDpCNpy2j3hoV3-WsjrDYXx1wdsdwVGeagY+pVcjZ7Rk+Q@mail.gmail.com>

On Sat, May 7, 2022 at 5:52 AM <vjudeu at gazeta.pl> wrote:

> > Re-enabling OP_CAT with the exact same OP would be a hardfork, but
> creating a new OP_CAT2 that does the same would be a softfork.
>
> We have TapScript for that. OP_CAT is defined as OP_SUCCESS, it can be
> re-enabled in a soft-fork way. For now, OP_CAT in TapScript simply means
> "anyone can move those coins", so adding some restrictions is all we need
> to re-enable this opcode. Introducing OP_CAT2 is not needed at all, unless
> it will be totally different, but then it should not be named as OP_CAT2,
> but rather as OP_SOMETHING_ELSE, it depends how different it will be from
> OP_CAT.
>

Oh, well, I didn't know any of that. I guess it could be a modification of
OP_SUCCESS if it makes sense instead of a new opcode.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/6b3c1b24/attachment.html>

From jtimon at jtimon.cc  Sat May  7 13:27:16 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 7 May 2022 15:27:16 +0200
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
References: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
 <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
Message-ID: <CABm2gDrdwMjLu=i0p2m4SZ_91xpr-RvwSSWOnS9jhaQ3uaCxPA@mail.gmail.com>

Thanks a lot for the many clarifications.
Yeah, I forgot it wasn't OP_CAT alone, but in combination with other things.
I guess this wouldn't be a covenants proposal then.
But simplicity would enable covenants too indeed, no?
Or did I get that wrong too?

On Sat, May 7, 2022 at 5:06 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Jorge,
>
> > OP_CAT was removed. If I remember correctly, some speculated that
> perhaps it was removed because it could allow covenants.I don't remember
> any technical concern about the OP besides enabling covenants.Before it was
> a common opinion that covenants shouldn't be enabled in bitcoin because,
> despite having good use case, there are some nasty attacks that are enabled
> with them too. These days it seems the opinion of the benefits being worth
> the dangers is quite generalized. Which is quite understandable given that
> more use cases have been thought since then.
>
> I think the more accurate reason for why it was removed is because the
> following SCRIPT of N size would lead to 2^N memory usage:
>
>     OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP
> OP_CAT OP_DUP OP_CAT ...
>
> In particular it was removed at about the same time as `OP_MUL`, which has
> similar behavior (consider that multiplying two 32-bit numbers results in a
> 64-bit number, similar to `OP_CAT`ting a vector to itself).
>
> `OP_CAT` was removed long before covenants were even expressed as a
> possibility.
>
> Covenants were first expressed as a possibility, I believe, during
> discussions around P2SH.
> Basically, at the time, the problem was this:
>
> * Some receivers wanted to use k-of-n multisignature for improved security.
> * The only way to implement this, pre-P2SH, was by putting in the
> `scriptPubKey` all the public keys.
> * The sender is the one paying for the size of the `scriptPubKey`.
> * It was considered unfair that the sender is paying for the security of
> the receiver.
>
> Thus, `OP_EVAL` and the P2SH concept was conceived.
> Instead of the `scriptPubKey` containing the k-of-n multisignature, you
> create a separate script containing the public keys, then hash it, and the
> `scriptPubKey` would contain the hash of the script.
> By symmetry with the P2PKH template:
>
>     OP_DUP OP_HASH160 <hash160(pubkey)> OP_EQUALVERIFY OP_CHECKSIG
>
> The P2SH template would be:
>
>     OP_DUP OP_HASH160 <hash160(redeemScript)> OP_EQUALVERIFY OP_EVAL
>
> `OP_EVAL` would take the stack top vector and treat it as a Bitcoin SCRIPT.
>
> It was then pointed out that `OP_EVAL` could be used to create recursive
> SCRIPTs by quining using `OP_CAT`.
> `OP_CAT` was already disabled by then, but people were talking about
> re-enabling it somehow by restricting the output size of `OP_CAT` to limit
> the O(2^N) behavior.
>
> Thus, since then, `OP_CAT` has been associated with ***recursive***
> covenants (and people are now reluctant to re-enable it even with a limit
> on its output size, because recursive covenants).
> In particular, `OP_CAT` in combination with `OP_CHECKSIGFROMSTACK` and
> `OP_CHECKSIG`, you could get a deferred `OP_EVAL` and then use `OP_CAT` too
> to quine.
>
> Because of those concerns, the modern P2SH is now "just a template" with
> an implicit `OP_EVAL` of the `redeemScript`, but without any `OP_EVAL`
> being actually enabled.
>
> (`OP_EVAL` cannot replace an `OP_NOP` in a softfork, but it is helpful to
> remember that P2SH was pretty much what codified the difference between
> softfork and hardfork, and the community at the time was small enough (or
> so it seemed) that a hardfork might not have been disruptive.)
>
> > Re-enabling OP_CAT with the exact same OP would be a hardfork, but
> creating a new OP_CAT2 that does the same would be a softfork.
>
> If you are willing to work in Taproot the same OP-code can be enabled in a
> softfork by using a new Tapscript version.
>
> If you worry about quantum-computing-break, a new SegWit version (which is
> more limited than Tapscript versions, unfortunately) can also be used,
> creating a new P2WSHv2 (or whatever version) that enables these opcodes.
>
> > As far a I know, this is the covenants proposal that has been
> implemented for the longest time, if that's to be used as a selection
> criteria.And as always, this is not incompatible with deploying other
> convenant proposals later.
>
> No, it was `OP_EVAL`, not `OP_CAT`.
> In particular if `OP_EVAL` was allowed in the `redeemScript` then it would
> enable covenants as well.
> It was just pointed out that `OP_CAT` enables recursive covenenats in
> combination with `OP_EVAL`-in-`redeemScript`.
>
> In particular, in combination with `OP_CAT`, `OP_EVAL` not only allows
> recursive covenants, but also recursion *within* a SCRIPT i.e. unbounded
> SCRIPT execution.
> Thus, `OP_EVAL` is simply not going to fly, at all.
>
> > Personally I find the simplicity proposal the best one among all the
> covenant proposals by far, including this one.But I understand that despite
> the name, the proposal is harder to review and test than other proposals,
> for it wouldn't simply add covenants, but a complete new scripting language
> that is better in many senses.Speedy covenants, on the other hand, is much
> simpler and has been implemented for longer, so in principle, it should be
> easier to deploy in a speedy manner.
> >
> > What are the main arguments against speedy covenants (aka op_cat2) and
> against deploying simplicity in bitcoin respectively?
> > Sorry if this was discussed before.
>
> `OP_CAT`, by itself, does not implement any covenants --- instead, it
> creates recursive covenants when combined with almost all covenant opcodes.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/a95bab51/attachment-0001.html>

From jtimon at jtimon.cc  Sat May  7 13:22:49 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 7 May 2022 15:22:49 +0200
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
Message-ID: <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>

I think people may be scared of potential attacks based on covenants. For
example, visacoin.
But there was a thread with ideas of possible attacks based on covenants.
To me the most scary one is visacoin, specially seeing what happened in
canada and other places lately and the general censorship in the west, the
supposed war on "misinformation" going on (really a war against truth imo,
but whatever) it's getting really scary. But perhaps someone else can be
more scared about a covenant to add demurrage fees to coins or something, I
don't know.

https://bitcointalk.org/index.php?topic=278122

For example, what if Justin Castro, sorry, Justin Trudeu mandated a
visacoin covenant for all withdrawals from canadian exchanges?
What if ursula von der mengele, sorry, von der leyen wants to do the same
in europe?
What if nina Nina Jankowicz decides visacoin covenants are the best way to
"stop misinformation"?

Covenants can enable many attacks on bitcoin, not just new cool features.

Now, perhaps I am crazy for thinking there's a war against truth going on,
I don't know.
Perhaps most devs and bitcoin users love those lying politicians I
mentioned.
Perhaps I'm too biased because my political views. Or perhaps the people
who don't consider Justin a criminal against humanity are biased.

I guess this goes beyond the scope of this mailing list though. Perhaps we
should go back to the bitcoin forums to discuss this kind of thing.





On Sat, May 7, 2022 at 10:54 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Bitcoin Developers,
>
> Summary for the last CTV meeting:
>
> Topics:
>
> 1)APO version of the simple vault
> 2)APO as alternative to CTV
> 3)fiatjaf's CTV spacechain demo
> 4)Compare CTV with other covenant proposals
> 5)Recursive covenants
> 6)Responding to FUD
>
> ===================================================
> APO version of the simple vault
> ===================================================
>
> - It is vulnerable to the half-spend problem, where multiple vaulted
> outputs (of the same denomination) can be spent together, burning all but
> the first to fees. Fixing this requires amending APOAS to cover the current
> input index.
> - The unvault transaction is third-party malleable (it can have more
> inputs added to it). One practical implication is that you can't hand a
> list of the unvault txids to a watchtower, you have to tell them which
> outpoints to watch which is less privacy-preserving. Fixing this requires
> amending APOAS to cover the number of inputs.
> Both of these issues are fixed by the BIP 118 changes suggested by
> darosior (although they still not officially spec'd afaik), which would
> basically make APO have a CTV-equivalent hash mode (minus scriptSig of
> other inputs)
> - simple-apo-vault could use APO-as-spec'd with
> SIGHASH_SINGLE|SIGHASH_ANYONECANPAY, which would solve the half-spend
> problem (but not malleability) and have some other interesting properties,
> like more natural dynamic fees (add inputs+change) and the ability spend
> multiple vaulted outputs together. This would, however, introduce a tx
> pinning attack vector and prevent rate-limited vaults.
>
> ===================================================
> APO as alternative to CTV
> ===================================================
>
> - Current APO is unusable as a CTV alternative, (revised)APO seems to be
> as useful as CTV is (plus some extra flexibility from existing sighash
> flags)
> - Main drawbacks being the additional witness satisfaction cost, the
> network-side full-node validation costs of checking a signature instead of
> just a hash, and not being segwit0-compatible (meaning, among others, not
> quantumphobic-friendly)
> - Its about 3x for APO-in-taproot vs CTV-in-taproot. CTV-in-segwitv0 and
> CTV-in-bare-spk get you even more savings
> - APO is far from being ready, let alone (revised)APO
> - APOv2 would be both better for Eltoo and better for CTV, since you can
> use a trick to make the signatures smaller
> - "layered commitments" is essential for eltoo to be usable or not is
> unclear. AJ Towns thinks it is required while Christian Decker thinks it is
> not.
>
> ===================================================
> fiatjaf's CTV spacechain demo
> ===================================================
>
> https://github.com/fiatjaf/simple-ctv-spacechain
>
> ===================================================
> Compare CTV with other covenant proposals
> ===================================================
>
> Unlike crypto primitves (e.g., BLS vs Schnorr), there's not really
> actually a defined way to compare them. So one exercise of value would be
> if everyone tries to actually either agree to or come up with their own
> framework for comparing covenants.
>
> Billy Tetrud's email:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020402.html
>
> - Prefers CTV for several reasons. Mainly because of being simple,
> documentation, code, tools, review and testing.
> - Everything else either introduces malleability, infinite recursion, or
> has interactions with other proposed opcodes that could introduce
> potentially undesirable effects like those.
> - Anything involving OP_CAT is out for the time being. There are so many
> things it can enable that it seems most people aren't comfortable adding it
> at the moment.
> - APO wallet vaults seem rather hacky, inefficient, and limited.
> - TLUV is built for evictions, TLUV + IN_OUT_AMOUNT and
> OP_CHECKOUTPUTVERIFY allows recursive covenants
>
> ===================================================
> Recursive covenants
> ===================================================
>
> jamesob:
> I don't particularly understand the aversion to infinite recursion, which
> seems no different than the risk of potentially burning your coins. It's
> not like infinite recursion on bitcoin is some kind of DoS vector or poses
> execution overhead like an Ethereum VM bug might.
>
> rgrant:
> i think people who want recursion for cool stuff are worried that
> pedestrian stuff will prevent it.
>
> jeremyrubin:
> i think people are afraid of weird shit happening, less so of recursion in
> particular
>
> hsjoberg:
> "Recursive covenants" is the boogie man
>
> shesek:
> "recursion" translates to "complex black magic" for nondevs' -- recursion
> is the new turing completeness
>
> ===================================================
> Responding to FUD
> ===================================================
>
> - It could be a good idea to include showing a way to do blacklists in the
> bug bounty offer
> - The potential concerns about recursive covenants have to clearly
> explained so they can be properly examined.
> - An article about CTV myths similar to segwit: :
> https://blog.blockstream.com/en-segwit-myths-debunked/
> - Some users think CTV might delay eltoo
>
> TL;DR
> "The initial resistance came from the Speedy Trial proposal. Then later on
> rumors and FUD started spreading around regarding CTV and covenants."
> - hsjoberg
>
> https://gnusha.org/ctv-bip-review/2022-05-03.log
>
>
> /dev/fd0
> Sent with ProtonMail <https://protonmail.com/> secure email.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/dfa8dc5b/attachment.html>

From jtimon at jtimon.cc  Sat May  7 01:57:39 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 7 May 2022 03:57:39 +0200
Subject: [bitcoin-dev] What to do when contentious soft fork activations
 are attempted
In-Reply-To: <CAOU__fwuT8tuV+5KG28toxQO1kwgm0S7CHtsQrZqx7my9RwCtQ@mail.gmail.com>
References: <mailman.53264.1651860071.8511.bitcoin-dev@lists.linuxfoundation.org>
 <CAOU__fwuT8tuV+5KG28toxQO1kwgm0S7CHtsQrZqx7my9RwCtQ@mail.gmail.com>
Message-ID: <CABm2gDrJCo02E8AtJwGQ2jfJokeG9dMuxrO44kT9m1GZZ+1Z2w@mail.gmail.com>

It is quite ironic that yeah, it is quite ironic that the people who are
constantly basing their arguments on personal attack are also the ones who
complain the most about personal attacks. That's exactly the irony I was
trying to convey.
Just like some people claim that the only people against bip119 are people
ignorant about bip119, I can also claim that everyone against bip8 doesn't
really understand it, can't I?
The same people who spread the misinformation that bip8 "would be perceived
by most users as developers trying to dictate changes" are now complaining
about people spreading misinformation about their own proposals. I
personally find it as ironic as it can get.
I'm glad I'm not the only one who noticed how ironic the whole situation is.
How often are the people claiming to be concerned about misinformation
precisely the ones who spread the most misinformation?
Very ironic indeed.

On Fri, May 6, 2022 at 10:07 PM John Tromp via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Fri, 6 May 2022 7:17PM Jorge Tim?n wrote
> > But let's not personally attack andreas for his opinions.
> > The only reason you don't like bip8 is because you're ignorant about it
> and
> > you haven't reviewed it enough.
>
> Can you see the irony in equating "clueless about BIP119" with a
> personal attack and then calling Jeremy ignorant about BIP8?
>
> -John
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220507/421e13dc/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat May  7 22:28:58 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 07 May 2022 22:28:58 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CABm2gDo1wTOoWcNgJ4mUgSB3KCtBSnjqe3nwVBSL+7=ziDJ==w@mail.gmail.com>
References: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
 <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
 <CABm2gDrdwMjLu=i0p2m4SZ_91xpr-RvwSSWOnS9jhaQ3uaCxPA@mail.gmail.com>
 <CiNPwh37hW6iDk3mMg6G2QWMPS5ADUvSdySnNp6esOaloiVyoPwHGxOMLyG6mMGQnyf4iGcch12XfmOB2WnFcETwFwvRTSNSeBu27G9Cju8=@protonmail.com>
 <CABm2gDo1wTOoWcNgJ4mUgSB3KCtBSnjqe3nwVBSL+7=ziDJ==w@mail.gmail.com>
Message-ID: <7tAjoQcZRlYf9KAjaqu4vScMfCVBeOQIdnHIrWTHdbuIOtFdNXXzC4USIyQ5n2hNKAI9HoI1QyZp4-tOZ9o7ihJa6iRB881jkc4bsM8CX5c=@protonmail.com>

Good morning Jorge,

> Thanks again.
> I won't ask anything else about bitcoin, I guess, since it seems my questions are too "misinforming" for the list.
> I also agreed with vjudeu, also too much misinformation on my part to agree with him, it seems.
> I mean, I say that because it doesn't look like my emails are appearing on the mailing list:
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/thread.html#start
>
> Do any of you now who moderates the mailing list? I would like to ask him what was wrong with my latest messages.

Cannot remember.

> Can the censored messages me seen somewhere perhaps?

https://lists.ozlabs.org/pipermail/bitcoin-dev-moderation/

E.g.: https://lists.ozlabs.org/pipermail/bitcoin-dev-moderation/2022-May/000325.html

> That way the moderation could be audited.
>
> This is quite worrying in my opinion.
> But I'm biased, perhaps I deserve to be censored. It would still be nice to understand why, if you can help me.
> Now I wonder if this is the first time I was censored or I was censored in bip8 discussions too, and who else was censored, when, why and by whom.
> Perhaps I'm missing something about how the mailing list works and/or are giving this more importance than it has.

Sometimes the moderator is just busy living his or her life to moderate messages within 24 hours.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sat May  7 22:40:10 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 07 May 2022 22:40:10 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
Message-ID: <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>

Good morning Jorge,

> I think people may be scared of potential attacks based on covenants. For example, visacoin.
> But there was a thread with ideas of possible attacks based on covenants.
> To me the most scary one is visacoin, specially seeing what happened in canada and other places lately and the general censorship in the west, the supposed war on "misinformation" going on (really a war against truth imo, but whatever) it's getting really scary. But perhaps someone else can be more scared about a covenant to add demurrage fees to coins or something, I don't know.
> https://bitcointalk.org/index.php?topic=278122

This requires *recursive* covenants.

At the time the post was made, no distinction was seen between recursive and non-recursive covenants, which is why the post points out that covenants suck.
The idea then was that anything powerful enough to provide covenants would also be powerful enough to provide *recursive* covenants, so there was no distinction made between recursive and non-recursive covenants (the latter was thought to be impossible).

However, `OP_CTV` turns out to enable sort-of covenants, but by construction *cannot* provide recursion.
It is just barely powerful enough to make a covenant, but not powerful enough to make *recursive* covenants.

That is why today we distinguish between recursive and non-recursive covenant opcodes, because we now have opcode designs that provides non-recursive covenants (when previously it was thought all covenant opcodes would provide recursion).

`visacoin` can only work as a recursive covenant, thus it is not possible to use `OP_CTV` to implement `visacoin`, regardless of your political views.

(I was also misinformed in the past and ignored `OP_CTV` since I thought that, like all the other covenant opcodes, it would enable recursive covenants.)


Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sun May  8 02:19:57 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 08 May 2022 02:19:57 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CAGXD5f2vLaZgEUG7eu6S9YQSSLeJ0LAM+i2o1ngVb=VmxS3Rrg@mail.gmail.com>
References: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
 <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
 <CABm2gDrdwMjLu=i0p2m4SZ_91xpr-RvwSSWOnS9jhaQ3uaCxPA@mail.gmail.com>
 <CiNPwh37hW6iDk3mMg6G2QWMPS5ADUvSdySnNp6esOaloiVyoPwHGxOMLyG6mMGQnyf4iGcch12XfmOB2WnFcETwFwvRTSNSeBu27G9Cju8=@protonmail.com>
 <CAGXD5f2vLaZgEUG7eu6S9YQSSLeJ0LAM+i2o1ngVb=VmxS3Rrg@mail.gmail.com>
Message-ID: <6pDae6X_tAfMTldPPsad5CSHPF98NVbTf06JxRCs7RqJGyrOqLALsDHHa_3C5DbbfpAVnzLMWCn-7e0FwQO-TOk4XxWYIiaYomuA9NJjkEQ=@protonmail.com>

Good morning shesek,

> On Sat, May 7, 2022 at 5:08 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > * Even ***with*** `OP_CAT`, the following will enable non-recursive covenants without enabling recursive covenants:
> >? * `OP_CTV`, ...
> > * With `OP_CAT`, the following would enable recursive covenants:
> >? * `OP_CHECKSIGFROMSTACK`, ...
>
> Why does CTV+CAT not enable recursive covenants while CSFS+CAT does?
>
> CTV+CAT lets you similarly assert against the outputs and verify that they match some dynamically constructed script.
>
> Is it because CTV does not let you have a verified copy of the input's prevout scriptPubKey on the stack [0], while with OP_CSFS you can because the signature hash covers it?
>
> But you don't actually need this for recursion. Instead of having the user supply the script in the witness stack and verifying it against the input to obtain the quine, the script can simply contain a copy of itself as an initial push (minus this push). You can then reconstruct the full script quine using OP_CAT, as a PUSH(<script>) followed by the literal <script>.

    <OP_PUSH_length-of-script> OP_SWAP OP_DUP OP_CAT OP_CAT <rest of script...>

Ha, yes, looks like you are correct here.

`OP_CAT` makes *all* covenant opcodes recursive, because you can always quine using `OP_CAT`.

By itself it does not make recursive covenants, but with probably any opcode it would.

Looks like `OP_CAT` is not getting enabled until after we are reasonably sure that recursive covenants are not really unsafe.

Regards,
ZmnSCPxj

From nadav at shesek.info  Sun May  8 02:03:25 2022
From: nadav at shesek.info (Nadav Ivgi)
Date: Sun, 8 May 2022 05:03:25 +0300
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CiNPwh37hW6iDk3mMg6G2QWMPS5ADUvSdySnNp6esOaloiVyoPwHGxOMLyG6mMGQnyf4iGcch12XfmOB2WnFcETwFwvRTSNSeBu27G9Cju8=@protonmail.com>
References: <CABm2gDoivzQKFr6KqeqW6+Lx7xFVprRCUAn1k3X6P29NPzw+yQ@mail.gmail.com>
 <1JO1xrnJ9GwGM4TgLH_rL_LpnZgSb1SyeEOJ9Gzc1VMbKUrmxSh-zUXKwFNvp_5wyiDtRviOf-gRJbrfbhOJl-qym1eEHXpoDAgjE9juucw=@protonmail.com>
 <CABm2gDrdwMjLu=i0p2m4SZ_91xpr-RvwSSWOnS9jhaQ3uaCxPA@mail.gmail.com>
 <CiNPwh37hW6iDk3mMg6G2QWMPS5ADUvSdySnNp6esOaloiVyoPwHGxOMLyG6mMGQnyf4iGcch12XfmOB2WnFcETwFwvRTSNSeBu27G9Cju8=@protonmail.com>
Message-ID: <CAGXD5f2vLaZgEUG7eu6S9YQSSLeJ0LAM+i2o1ngVb=VmxS3Rrg@mail.gmail.com>

On Sat, May 7, 2022 at 5:08 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:
> * Even ***with*** `OP_CAT`, the following will enable non-recursive
covenants without enabling recursive covenants:
>  * `OP_CTV`, ...
> * With `OP_CAT`, the following would enable recursive covenants:
>  * `OP_CHECKSIGFROMSTACK`, ...

Why does CTV+CAT not enable recursive covenants while CSFS+CAT does?

CTV+CAT lets you similarly assert against the outputs and verify that they
match some dynamically constructed script.

Is it because CTV does not let you have a verified copy of the input's
prevout scriptPubKey on the stack [0], while with OP_CSFS you can because
the signature hash covers it?

But you don't actually need this for recursion. Instead of having the user
supply the script in the witness stack and verifying it against the input
to obtain the quine, the script can simply contain a copy of itself as an
initial push (minus this push). You can then reconstruct the full script
quine using OP_CAT, as a PUSH(<script>) followed by the literal <script>.

When I started experimenting with recursive covenants on liquid, I started
with the approach of verifying user-supplied witness data against the
input. It ended up being quite complex and verbose with taproot, because
you have to compute the tagged taptree hash from the tapscript and
TWEAKVERIFY it against the prevout's taproot output key (which also
requires the internal key and parity flag, provided as two extra witness
elements by the user).

I then realized that it is much simpler to have the tapscript hold a copy
of itself, that it's as safe and that it reduces the witness size cost
(because you don't need to do the entire taproot dance to verify the
tapscript), and switched to this approach.

Here are two examples of recursive covenants using this approach that I
played with (for liquid, rough sketches, very lightly tested and has some
known issues. the $label thing is a scriptwiz notation and can be ignored):

https://gist.github.com/shesek/be910619b247ce5e1aedd84e9ba9db42 (auction)
https://gist.github.com/shesek/ede9ca921a394580b23d301b8d84deea (listed
price sale with royalty)
(And here's the second example written in Minsc:
https://min.sc/next/#gist=e1c9914b4cb940137122d6d30972c25c)

shesek

[0] It does not cover it, and it cannot be done even by providing the full
prev tx because the prevout txid is not covered either.


On Sat, May 7, 2022 at 5:08 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Jorge,
>
> > Thanks a lot for the many clarifications.
> > Yeah, I forgot it wasn't OP_CAT alone, but in combination with other
> things.
> > I guess this wouldn't be a covenants proposal then.
> > But simplicity would enable covenants too indeed, no?
> > Or did I get that wrong too?
>
> Yes, it would enable covenants.
>
> However, it could also enable *recursive* covenants, depending on what
> introspection operations are actually implemented (though maybe not?
> Russell O'Connor should be the one that answers this).
>
> It is helpful to delineate between non-recursive covenants from recursive
> covenants.
>
> * Even ***with*** `OP_CAT`, the following will enable non-recursive
> covenants without enabling recursive covenants:
>   * `OP_CTV`
>   * `SIGHASH_ANYPREVOUT`
> * With `OP_CAT`, the following would enable recursive covenants:
>   * `OP_EVAL`
>   * `OP_CHECKSIGFROMSTACK`
>   * `OP_TX`/`OP_TXHASH`
>   * ...possibly more.
>     * It is actually *easier* to *design* an opcode which inadvertently
> supports recursive covenants than to design one which avoids recursive
> covenants.
>
> Recursive covenants are very near to true Turing-completeness.
> We want to avoid Turing-completeness due to the halting problem being
> unsolvable for Turing-complete languages.
> That is, given just a program, we cannot determine for sure if for all
> possible inputs, it will terminate.
> It is important in our context (Bitcoin) that any SCRIPT programs we write
> *must* terminate, or else we run the risk of a DoS on the network.
>
> A fair amount of this is theoretical crap, but if you want to split hairs,
> recursive covenants are *not* Turing-complete, but are instead total
> functional programming with codata.
>
> As a very rough bastardization, a program written in a total functional
> programming language with codata will always assuredly terminate.
> However, the return value of a total functional programming language with
> codata can be another program.
> An external program (written in a Turing-complete language) could then
> just keep invoking the interpreter of the total functional programming
> language with codata (taking the output program and running it, taking
> *its* output program and running it, ad infinitum, thus effectively able to
> loop indefinitely.
>
> Translated to Bitcoin transactions, a recursive covenant system can force
> an output to be spent only if the output is spent on a transaction where
> one of the outputs is the same covenant (possibly with tweaks).
> Then an external program can keep passing the output program to the
> Bitcoin SCRIPT interpreter --- by building transactions that spend the
> previous output.
>
> This behavior is still of concern.
> It may be possible to attack the network by eroding its supply, by such a
> recursive covenant.
>
> --
>
> Common reactions:
>
> * We can just limit the number of opcodes we can process and then fail it
> if it takes too many operations!
>   That way we can avoid DoS!
>   * Yes, this indeed drops it from Turing-complete to total, possibly
> total functional programming **without** codata.
>     But if it is possible to treat data as code, it may drop it "total but
> with codata" instead (i.e. recursive covenants).
>     But if you want to avoid recursive covenants while allowing recursive
> ones (i.e. equivalent to total without codata), may I suggest you instead
> look at `OP_CTV` and `SIGHASH_ANYPREVOUT`?
>
> * What is so wrong with total-with-codata anyway??
>   So what if the recursive covenant could potentially consume all
> Bitcoins, nobody will pay to it except as a novelty!!
>   If you want to burn your funds, 1BitcoinEater willingly accepts it!
>   * The burden of proof-of-safety is on the proposer, so if you have some
> proof that total-with-codata is safe, by construction, then sure, we can
> add opcodes that may enable recursive covenants, and add `OP_CAT` back in
> too.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220508/4b8325a8/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  8 16:32:45 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 8 May 2022 11:32:45 -0500
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
 <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
Message-ID: <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>

>  This requires *recursive* covenants.

Actually, for practical use, any walled-garden requires *dynamic*
covenants, not recursive covenants. CTV can get arbitrarily close to
recursive covenants, because you can have an arbitrarily long string of
covenants. But this doesn't help someone implement visacoin because CTV
only allows a specific predefined iteration of transactions, meaning that
while "locked" into the covenant sequence, the coins can't be used in any
way like normal coins - you can't choose who you pay, the sequence is
predetermined.

Even covenants that allow infinite recursion (like OP_TLUV and OP_CD
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md>)
don't automatically allow for practical walled gardens. Recursion
definitely allows creating walled gardens, but those gardens would be
impractically static. You could add millions of potential addresses to send
to, which would "only" quadruple the size of your transactions, but if
anyone creates a new address you want to send to, you wouldn't be able to.
Everyone would have to have a single address whitelisted into every
government-bitcoin output. If someone lost their key and needs to create a
new wallet, suddenly no one would be able to pay them.

In order to really build a wallet garden, infinite recursion isn't really
necessary nor sufficient. You need to be able to dynamically specify
destination addresses. For example, if you were a government that wants to
make a walled garden where you (the government) could confiscate the funds
whenever you wanted, you'd have to have a covenant that allows the end-user
to specify an arbitrary public key to send money to. The covenant might
require that user to send to another covenant that has a government spend
path, but also has a spend path for that user-defined public key. That way,
you (the government) could allow people to send to each other arbitrarily,
while still ensuring that you (the government) could spend the funds no
matter where they may have been sent. Even without recursive covenants, you
could have arbitrarily long chains of these, say 1 million long, where at
the end of the chain the user must send your coins back to the government
who can then send them back with another million-long chain of covenants to
work with.

OP_CHECKOUTPUTVERIFY <https://fc16.ifca.ai/bitcoin/papers/MES16.pdf> can do
this kind of dynamicness, and OP_PUSHOUTPUTSTACK
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/pos/bip-pushoutputstack.md>
can
enable it for things like OP_TLUV and OP_CD. I personally think dynamic
covenants are a *good* thing, as it enables more secure wallet vaults,
among other things. And I'm not worried about a government creating a
in-bitcoin visa-coin. Why? Because they can already do it today. They have
been able to do it for 9 years already. How?

Replace the covenant above with a multisig wallet. The government has 2
keys, you have 1 key. Every time you make a transaction, you request the
government's signature on it. The government then only signs if you're
sending to a wallet they approve of. They might only sign when you're
sending to another multisig wallet that the government has 2 of 3 keys for.
Its a very similar walled garden, where the only difference is that the
government needs to actively sign, which I'm sure wouldn't be a huge
challenge for the intrepid dictator of the land. You want to add
demurage fees? Easy, the government just spends the fee out of everyone's
wallets every so often.

On the other hand, OP_CTV *cannot* be used for such a thing. No combination
of future opcodes can enable either recursion or dynamicness to an OP_CTV
call.



On Sat, May 7, 2022 at 5:40 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Jorge,
>
> > I think people may be scared of potential attacks based on covenants.
> For example, visacoin.
> > But there was a thread with ideas of possible attacks based on covenants.
> > To me the most scary one is visacoin, specially seeing what happened in
> canada and other places lately and the general censorship in the west, the
> supposed war on "misinformation" going on (really a war against truth imo,
> but whatever) it's getting really scary. But perhaps someone else can be
> more scared about a covenant to add demurrage fees to coins or something, I
> don't know.
> > https://bitcointalk.org/index.php?topic=278122
>
> This requires *recursive* covenants.
>
> At the time the post was made, no distinction was seen between recursive
> and non-recursive covenants, which is why the post points out that
> covenants suck.
> The idea then was that anything powerful enough to provide covenants would
> also be powerful enough to provide *recursive* covenants, so there was no
> distinction made between recursive and non-recursive covenants (the latter
> was thought to be impossible).
>
> However, `OP_CTV` turns out to enable sort-of covenants, but by
> construction *cannot* provide recursion.
> It is just barely powerful enough to make a covenant, but not powerful
> enough to make *recursive* covenants.
>
> That is why today we distinguish between recursive and non-recursive
> covenant opcodes, because we now have opcode designs that provides
> non-recursive covenants (when previously it was thought all covenant
> opcodes would provide recursion).
>
> `visacoin` can only work as a recursive covenant, thus it is not possible
> to use `OP_CTV` to implement `visacoin`, regardless of your political views.
>
> (I was also misinformed in the past and ignored `OP_CTV` since I thought
> that, like all the other covenant opcodes, it would enable recursive
> covenants.)
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220508/6162df67/attachment.html>

From billy.tetrud at gmail.com  Sun May  8 17:36:01 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 8 May 2022 12:36:01 -0500
Subject: [bitcoin-dev] Working Towards Consensus
In-Reply-To: <PS2P216MB1089155348699F63A49A9D9D9DC39@PS2P216MB1089.KORP216.PROD.OUTLOOK.COM>
References: <mailman.51682.1651459425.8511.bitcoin-dev@lists.linuxfoundation.org>
 <CAHTn92z3HaTu47O_3metXAhFEVN3QnLdug1BVt66a9GZGx6t=Q@mail.gmail.com>
 <PS2P216MB1089155348699F63A49A9D9D9DC39@PS2P216MB1089.KORP216.PROD.OUTLOOK.COM>
Message-ID: <CAGpPWDbtVzbrH=ovLSpT66v65QThV04Ufmfm2WTn15dc64gcng@mail.gmail.com>

>  it is easier to get everyone to agree when everyone has something to gain

That's unquestionably true. It doesn't really sound like what you said
originally tho.

> most users are either apathetic or trusting in the developers that
initiated it being activated. This is a dangerous dynamic to lean on

I don't disagree.

> I do not "expect" improvement by any other means than is typical in life:
competition and adaptation in response to an adverse and changing
environment.
> Why are you talking about companies and bloat while I am speaking about
being conservative?

Sounds like we agree then. However, when you said "when [designers]
speculate and lead the process, they create problems instead" I took that
to mean that you think designers shouldn't lead the process. I think
designers and engineers should lead the process, as you said, "[when] their
specialization allows them to solve a problem faster than someone else
might."

> thinking that adding complication to Bitcoin's base layer is somehow a
means of valuing simplicity

You seem to be missing my point. I am certainly not saying the words you're
putting in my mouth there. What I am saying is that a number of people have
been calling covenants for a number of years before Jeremy created CTV, and
all discussed proposals were more powerful and complex than CTV. I do think
that the design of CTV had a goal of simplicity, and I believe it achieved
that goal. If CTV were not proposed and developed, we would very likely
have seen a more complex covenant opcode on the table. I certainly would
like to see a more powerful covenant opcode myself.

> I have no reason to care about your "99%" confidence in something

I'm not asking you to care about my confidence. I'm asking to consider my
logic. Feel free to take any claims about my confidence as an aside.

> Speaking for myself, and likely the great majority of the market

... are you trying to speak for yourself, or are you trying to assert that
your opinion is the market majority opinion? If I may echo your opinion of
me, I have no reason to care about your confidence that your opinion is
everyone else's opinion as well. I'll take that as an aside ; )

> Your self-ascribed ability to assess the market is objectively
overconfident

I'm not the one claiming to speak for the market ^ I'm only relaying the
fact that the vast majority of folks I see on the dev mailing list who talk
about covenants, even occasionally, are in support of them generally, and
it seems the majority of those people who generally support covenants, if
not the vast majority, support CTV. That's what I see. Feel free to not
believe me, but the dev mailing list records are all there for you to
verify.

> That cost [of a change to bitcoin] is only offset AFTER the feature has
reached saturation of usage.

I think that's objectively false. Were it true, it would mean that every
change can only at best reach break-even, which would mean that no change
is worth doing.

> we might be too aggressive in our pace of feature speculation
> If we keep piling on features...
> Complexity can yield centralization, we should be more careful.

Are you in the "ossification now" camp, John? Or perhaps, ossification
soon? I agree that the bar of quality should continually be raised for
making changes to bitcoin, and ossification (or as near as possible) should
be the eventual goal. Perhaps we just disagree on how quickly to raise the
bar.

> However many people in the world that may want CTV, that number is surely
less than 1% of the Bitcoin user base.

I don't disagree that 1% isn't an unlikely number for the fraction of
bitcoin users who currently want specifically CTV. However, I would guess
the percentage of users who hold something close to your opinion isn't much
different from that number. Measuring things like this as a percentage of
the total bitcoin userbase is kind of worthless.

> Cry harder.
> your being offended is not important to this topic

Perhaps not, but its still no reason to act like an asshole, John. If you
think personal attacks, childish jeers, and angry dismissals will be
convincing to people who read this mailing list, you're sorely mistaken.




On Wed, May 4, 2022 at 8:01 AM LORD HIS EXCELLENCY JAMES HRMH <
willtech at live.com.au> wrote:

> Good Afternoon,
>
> The basic principle of Bitcoin is operating the consensus fungibility. All
> transactions are published on the public ledger. What is valuable is the
> consensus as we have it, not what it may become from some proposal that may
> harm fungibility. Without consensus Bitcoin is not what is valued by the
> current consensus. Consensus is exactly why Bitcoin is fungible if that can
> be made clear. That is why it is important to defend consensus.  We have
> agreed Bitcoin has certain properties including being immutable,
> transparent, published, distributed, trustless. Consensus provides we make
> software to allow transfer of Bitcoin via ownership of a UTXO in a manner
> in accordance with consensus. If we do not value Bitcoin to defend the
> consensus we admin all kinds of features without purpose to complicate the
> operation of a wallet for a standard user. Bitcoin and the consensus is all
> about the standard user in order to be fungible. A valuable use-case does
> not approve an enhancement. Most users will never be involved in the
> consensus process and in the interest of  being fungible all developers and
> the consensus must ensure their interest in a wallet being upgraded is in
> their beneficial interest. Making a fidget toy that can do anything is not
> useful until it can make the bed, cook breakfast, and pour the coffee, that
> is, to do something useful that a user will want.
>
> One test of this is how many users will object if a feature is taken away.
>
> KING JAMES HRMH
> Great British Empire
>
> Regards,
> The Australian
> LORD HIS EXCELLENCY JAMES HRMH (& HMRH)
> of Hougun Manor & Glencoe & British Empire
> MR. Damian A. James Williamson
> Wills
>
> et al.
>
>
> Willtech
> www.willtech.com.au
> www.go-overt.com
> and other projects
>
> earn.com/willtech
> linkedin.com/in/damianwilliamson
>
>
> m. 0487135719
> f. +61261470192
>
>
> This email does not constitute a general advice. Please disregard this
> email if misdelivered.
> ------------------------------
> *From:* bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on
> behalf of John Carvalho via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>
> *Sent:* Monday, 2 May 2022 6:37 PM
> *To:* bitcoin-dev at lists.linuxfoundation.org <
> bitcoin-dev at lists.linuxfoundation.org>
> *Subject:* Re: [bitcoin-dev] Working Towards Consensus
>
> Jeremy,
>
> The path to consensus is to propose things that everyone needs. Demand
> comes from the market, not the designers.
>
> Designers (engineers) solve problems with designs, but when they speculate
> and lead the process, they create problems instead. Bitcoin is not a place
> for speculative feature additions. Bitcoin cannot afford a culture of
> additive features no one is asking for. Bitcoin thrives in a culture of
> "NO." Rejection of change is Bitcoin's primary feature.
>
> There is NO HOPE of EVER getting the majority of Bitcoin users to be able
> to grasp, audit, and meaningfully consent to complicated new features, nor
> to assess how they may interact with existing features in undesirable ways
> or affect Bitcoin's incentive structure. To ignore this is a selfish
> egomania that too many devs succumb to. The public already trusts Core devs
> more than they probably should, and it is unwise to lean on that trust.
>
> You are of course welcome to try and research and document all of the
> details about how this plays out in practice, but you will fail to specify
> a path to approval or any sort of clear governance structure for ensuring
> that speculative features get into Bitcoin. You will seek and only see a
> bias that allows you to get what YOU want. Until you focus on what everyone
> wants, you will not reach consensus on anything.
>
> Bitcoin changes should solve obvious problems and provide easy wins on
> optimization, security, and privacy. Seek simplicity and efficiency, not
> complication.
>
> We have yet to saturate usage of the features we have added already in the
> past 5 years. Use those. It is becoming apparent over time that many
> features can be accomplished off-chain, or without a blockchain, or by
> merely anchoring into currently available bitcoin transaction types.
>
> There is simply no urgency or problem that any of the proposed soft fork
> features are trying to address. This includes APO, CTV, sidechain
> proposals, etc, etc.
>
> Your aggression to your purpose is the antithesis of consensus, as it
> indicates your incentives are external to it.
>
> --
> John Carvalho
> CEO, Synonym.to <http://synonym.to/>
>
>
> On Mon, May 2, 2022 at 3:43 AM <
> bitcoin-dev-request at lists.linuxfoundation.org> wrote:
>
> Send bitcoin-dev mailing list submissions to
>         bitcoin-dev at lists.linuxfoundation.org
>
> To subscribe or unsubscribe via the World Wide Web, visit
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> or, via email, send a message with subject or body 'help' to
>         bitcoin-dev-request at lists.linuxfoundation.org
>
> You can reach the person managing the list at
>         bitcoin-dev-owner at lists.linuxfoundation.org
>
> When replying, please edit your Subject line so it is more specific
> than "Re: Contents of bitcoin-dev digest..."
>
>
> Today's Topics:
>
>    1. Re: What to do when contentious soft fork activations are
>       attempted (Billy Tetrud)
>    2. Working Towards Consensus (Jeremy Rubin)
>
>
> ----------------------------------------------------------------------
>
> Message: 1
> Date: Sun, 1 May 2022 14:14:29 -0500
> From: Billy Tetrud <billy.tetrud at gmail.com>
> To: alicexbt <alicexbt at protonmail.com>,  Bitcoin Protocol Discussion
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] What to do when contentious soft fork
>         activations are attempted
> Message-ID:
>         <
> CAGpPWDb-T4OB0NKv7O5k9yhDQJtmag1QLqM1jJN9fQMoNTPLug at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> +1 alicexbt
>
> We of course want knowledgeable bitcoiners who aren't knowledgeable about a
> certain proposal to be skeptical. But what we don't want is for that
> natural skepticism-from-ignorance to be interpreted as opposition, or
> really a strong signal of any kind. Any thoughts from ignorance, whether
> self-aware or not, should be given small weight. It seems the vast majority
> of push back has been this kind of skepticism from ignorance. And to a
> certain degree I think we want to give time for understanding to those who
> have not participated in the first, second, third, etc round of discussion
> on a proposal. It may not be reasonable to say "you had the last 2 years of
> time to voice your concern".
>
> Now that CTV is being taken seriously as a proposal, we probably should
> give the community who is finally taking a serious look at it time to
> understand, get their questions answered, and come to terms with it. This
> is not to say that CTV as a technology or proposal has been rushed, or has
> not had enough work put into it, but rather that the community as a whole
> has not paid enough attention to it for long enough.
>
> The wrong approach is: "how do I yell more loudly next time I see something
> I'm uncomfortable with?" The right approach is to educate those who aren't
> educated on the proposal and gather consensus on what people think when
> they understand enough about it to contribute to that consensus. If you
> care about consensus, you should respect the consensus process and be ok
> with consensus being not your preferred outcome. If you don't care about
> consensus, then you're basically attacking the bitcoin community.
>
> On Sun, May 1, 2022 at 3:22 AM alicexbt via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Hi Michael,
> >
> > Maybe the whole thing worked as designed. Some users identified what was
> > going on, well known Bitcoin educators such as Andreas Antonopoulos,
> Jimmy
> > Song etc brought additional attention to the dangers, a URSF movement
> > started to gain momentum and those attempting a contentious soft fork
> > activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> > previous posts to this mailing list 1
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html
> >,
> > 2
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html
> >,
> > 3
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html
> >
> > highlighting the dangers many months ago or recent posts. Normally Optech
> > is very high signal.)
> >
> >
> > Some users have been misled and there is nothing great being achieved by
> > doing this on social media. Andreas is clueless about BIP 119 and other
> > covenant proposals. He is spreading misinformation and some of the URSF
> > enthusiasts do not understand what are they even opposing or going to run
> > with risks involved.
> >
> >
> > Answering the subject of this email: "What to do when contentious soft
> > forks activations are attempted?"
> >
> > - Do not consider something contentious because someone said it on
> mailing
> > list
> > - Do not spread misinformation
> > - Read all posts in detail with different opinions
> > - Avoid personal attacks
> > - Look at the technical details, code etc. and comment on things that
> > could be improved
> >
> >
> >
> > /dev/fd0
> >
> > Sent with ProtonMail <https://protonmail.com/> secure email.
> >
> > ------- Original Message -------
> > On Saturday, April 30th, 2022 at 3:23 PM, Michael Folkson via bitcoin-dev
> > bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> >
> > I?ve been in two minds on whether to completely move on to other topics
> or
> > to formulate some thoughts on the recent attempt to activate a
> contentious
> > soft fork. In the interests of those of us who have wasted
> > days/weeks/months of our time on this (with no personal upside) and who
> > don?t want to repeat this exercise again I thought I should at least
> raise
> > the issue for discussion of what should be done differently if this is
> > tried again in future.
> >
> > This could be Jeremy with OP_CTV at a later point (assuming it is still
> > contentious) or anyone who wants to pick up a single opcode that is not
> yet
> > activated on Bitcoin and try to get miners to signal for it bypassing
> > technical concerns from many developers, bypassing Bitcoin Core and
> > bypassing users.
> >
> > Maybe the whole thing worked as designed. Some users identified what was
> > going on, well known Bitcoin educators such as Andreas Antonopoulos,
> Jimmy
> > Song etc brought additional attention to the dangers, a URSF movement
> > started to gain momentum and those attempting a contentious soft fork
> > activation backed off. (Disappointingly Bitcoin Optech didn't cover my
> > previous posts to this mailing list 1
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-October/019535.html
> >,
> > 2
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019728.html
> >,
> > 3
> > <
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020235.html
> >
> > highlighting the dangers many months ago or recent posts. Normally Optech
> > is very high signal.)
> >
> > Alternatively this was the first time a contentious soft fork activation
> > was attempted, we were all woefully unprepared for it and none of us knew
> > what we were doing.
> >
> > I?m unsure on the above. I?d be interested to hear thoughts. What I am
> > sure of is that it is totally unacceptable for one individual to bring
> the
> > entire Bitcoin network to the brink of a chain split. There has to be a
> > personal cost to that individual dissuading them from trying it again
> > otherwise they?re motivated to try it again every week/month. Perhaps the
> > personal cost that the community is now prepared if that individual tries
> > it again is sufficient. I?m not sure. Obviously Bitcoin is a
> permissionless
> > network, Bitcoin Core and other open source projects are easily forked
> and
> > no authority (I?m certainly no authority) can stop things like this
> > happening again.
> >
> > I?ll follow the responses if people have thoughts (I won't be responding
> > to the instigators of this contentious soft fork activation attempt) but
> > other than that I?d like to move on to other things than contentious soft
> > fork activations. Thanks to those who have expressed concerns publicly
> (too
> > many to name, Bob McElrath was often wording arguments better than I
> could)
> > and who were willing to engage with the URSF conversation. If an
> individual
> > can go directly to miners to get soft forks activated bypassing technical
> > concerns from many developers, bypassing Bitcoin Core and bypassing users
> > Bitcoin is fundamentally broken. The reason I still have hope that it
> isn't
> > is that during a period of general apathy some people were willing to
> stand
> > up and actively resist it.
> >
> > --
> > Michael Folkson
> > Email: michaelfolkson at protonmail.com
> > Keybase: michaelfolkson
> > PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/7158d8ed/attachment-0001.html
> >
>
> ------------------------------
>
> Message: 2
> Date: Sun, 1 May 2022 19:43:29 -0700
> From: Jeremy Rubin <jeremy.l.rubin at gmail.com>
> To: Bitcoin development mailing list
>         <bitcoin-dev at lists.linuxfoundation.org>
> Subject: [bitcoin-dev] Working Towards Consensus
> Message-ID:
>         <CAD5xwhhdEgADWwLwbjRKp-UFCw9hHjDsc-L=pkiwW=
> bmhFqBNw at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Developers,
>
> There is much to say about the events of the last two weeks and the
> response to them. I've been searching for the right words to share here,
> but I think it best that short of a more thoughtful writeup I start with a
> timely small step with the below comments.
>
> First, let me be clear: I am not advancing a Speedy Trial(ST) activation of
> Bitcoin Improvement Proposal-119 (BIP-119) CheckTemplateVerify (CTV) at
> this time.
>
> I'm skipping any discussion of the drama here. Most of you are interested
> in developing Bitcoin, not drama. Let's try to keep this thread focused on
> the actual work. I'll make some limited comments on the drama in a separate
> thread, for those who care to hear from me on the subject directly.
>
> I believe that the disinformation spread around my post ("7 Theses on a
> next step for BIP-119"[0]) created three main negative outcomes within the
> Bitcoin community:
>
> 1. Confusion about how Bitcoin's "technical consensus" works and how
> changes are "approved".
> 2. Fear about the safety of CTV and covenants more broadly.
> 3. Misunderstandings around the properties of Speedy Trial, User Activated
> Soft Fork (UASF), User Resisted Soft Fork (URSF), Soft Forks, Hard Forks,
> and more.
>
> While I cannot take responsibility for the spread of the disinformation, I
> do apologize to anyone dealing with it for the role my actions have had in
> leading to the current circumstance.
>
> I personally take some solace in knowing that the only way out of this is
> through it. The conversations happening now seem to have been more or less
> inevitable, this has brought them to the surface, and as a technical
> community we are able to address them head on if -- as individuals and
> collectively -- we choose to. And, viewed through a certain lens, these
> conversations represent incredibly important opportunities to participate
> in defining the future of Bitcoin that would not be happening otherwise.
> Ultimately, I am grateful to live in a time where I am able to play a small
> role in such an important process. This is the work.
>
> In the coming months, I expect the discourse to be messy, but I think the
> work is clear cut that we should undertake at least the following:
>
> 1. Make great efforts to better document how Bitcoin's technical consensus
> process works today, how it can be improved, and how changes may be
> formally reviewed while still being unofficially advanced.
> 2. Work diligently to address the concerns many in the community have
> around the negative potential of covenants and better explain the
> trade-offs between levels of functionality.
> 3. Renew conversations about activation and release mechanisms and
> re-examine our priors around why Speedy Trial may have been acceptable for
> Taproot, was not acceptable for BIP-119, but may not be optimal long
> term[1], and work towards processes that better captures the Bitcoin
> network's diverse interests and requirements.
> 4. Work towards thoroughly systematizing knowledge around covenant
> technologies so that in the coming months we may work towards delivering a
> coherent pathway for the Bitcoin technical community to evaluate and put up
> for offer to the broader community an upgrade or set of upgrades to improve
> Bitcoin's capabilities for self sovereignty, privacy, scalability, and
> decentralization.
>
> This may not be the easiest path to take, but I believe that this work is
> critical to the future of Bitcoin. I welcome all reading this to share your
> thoughts with this list on how we might work towards consensus going
> forward, including any criticisms of my observations and recommendations
> above. While I would expect nothing less than passionate debate when it
> comes to Bitcoin, remember that at the end of the day we all largely share
> a mission to make the world a freer place, even if we disagree about how we
> get there.
>
> Yours truly,
>
> Jeremy
>
> [0]: https://rubin.io/bitcoin/2022/04/17/next-steps-bip119/
> [1]: http://r6.ca/blog/20210615T191422Z.html I quite enjoyed Roconnor's
> detailed post on Speedy Trial
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> -------------- next part --------------
> An HTML attachment was scrubbed...
> URL: <
> http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220501/9009e65d/attachment.html
> >
>
> ------------------------------
>
> Subject: Digest Footer
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> ------------------------------
>
> End of bitcoin-dev Digest, Vol 84, Issue 4
> ******************************************
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220508/76fe3e01/attachment-0001.html>

From billy.tetrud at gmail.com  Sun May  8 17:41:07 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 8 May 2022 12:41:07 -0500
Subject: [bitcoin-dev] Wallet policies for descriptor wallets
In-Reply-To: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
References: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
Message-ID: <CAGpPWDag_i1f7eKc7cHe5BdsPA0vZRuh3+U+wzK7ypXoQ3_6hg@mail.gmail.com>

I took a look at the spec for the wallet descriptor format, and I like the
concept of having placeholder variables for keys. It reduces the size of
the descriptor, makes it substantially easier for a human to
read/verify, especially in the future when we have more complex
scripts, and provides a nice format for a script template which can make it
easier to verify that you're using the same script template as something
else (ie besides using different keys). I think the `/**` syntax is an
improvement over the current descriptor format, however it is a bit awkward
and inflexible. My understanding is that some of this inflexibility comes
from the goal of reducing memory usage, and I don't think I have a good
enough handle on that part of things to usefully comment. I've put
additional comments and suggestions on the format in this github issue
<https://github.com/LedgerHQ/app-bitcoin-new/issues/35>.

I think it would be very useful to come to agreement on a more flexible
format that can support a much broader set of use cases, and can
potentially be a widely supported standard. I understand low-ram devices
might have a much harder time using more flexible (and complex) formats.







On Thu, May 5, 2022 at 9:39 AM Salvatore Ingala via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> In the implementation work to implement descriptors and miniscript support
> in hardware wallets [a][b], I encountered a number of challenges. Some of
> them are technical in nature (e.g. due to constraints of embedded
> development). Others are related to the attempts of shaping a good user
> experience; with bitcoin reaching more people who are not tech-savvy,
> self-custody is only as secure as what those newcomers can use easily
> enough.
>
> The main tool that I am using to address some of these challenges is a
> layer that sits _on top_ of descriptors/miniscript, while staying very
> close to it. Since there is nothing that is vendor-specific in the vast
> majority of the approach I'm currently using, I tried to distill it here
> for your comments, and will propose a BIP if this is deemed valuable.
>
> I called the language "wallet policies" (suggestions for a better name are
> welcome). I believe an approach based on wallet policies can benefit all
> hardware wallets (stateless or not) that want to securely support complex
> scripts; moreover, wallet policies are close enough to descriptors that
> their integration should be extremely easy for any software wallet that is
> currently using descriptors.
>
> [a]: https://blog.ledger.com/bitcoin-2 - early demo
> [b]: https://blog.ledger.com/miniscript-is-coming - miniscript example
>
>
> Salvatore Ingala
>
>
> ======================================================
>
> This document starts with a discussion on the motivation for wallet
> policies, followed by their formal definition, and some recommendations for
> implementations.
>
> == Rationale ==
>
> Output script descriptors [1] were introduced in bitcoin-core as a way to
> represent collections of output scripts. It is a very general and flexible
> language, designed to catch all the possible use-cases of bitcoin wallets
> (that is, if you know the script and you have the necessary keys, it will
> be possible to sign transactions with bitcoin-core's descriptor-based
> wallets).
>
> Unfortunately, descriptors are not a perfect match for the typical usage
> of hardware wallets. Most hardware wallets have the following limitations
> compared to a general-purpose machine running bitcoin-core:
>
> - they are embedded devices with limited RAM and computational power;
> - they might not be able to import additional private keys (all the keys
> are generated from a single seed via [BIP-32](
> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki));
> - they might not have permanent storage (*stateless* hardware wallet
> design).
>
> Moreover, other limitations like the limited size of the screen might
> affect what design choices are available in practice. Therefore, minimizing
> the size of the information shown on-screen is important for a good user
> experience.
>
> A more native, compact representation of the wallet receive/change would
> also benefit the UX of software wallets using descriptors to represent
> software wallets using descriptors/miniscript for multisignature or other
> complex locking conditions.
>
> === Security and UX concerns of scripts in hardware wallets ===
>
> For a hardware wallet, allowing the usage of complex scripts presents
> challenges in terms of both security and user experience.
>
> ==== Security issues ====
>
> One of the security properties that hardware wallets strive to guarantee
> is the following: **as long as the user correctly verifies the information
> that is shown on the hardware wallet's screen before approving, no action
> can be performed without the user's consent**.
> This must hold even in scenarios where the attacker has full control of
> the machine that is connected to the hardware wallet, and can execute
> arbitrary requests or tamper with the legitimate user's requests.
>
> Therefore, it is not at all trivial to allow complex scripts, especially
> if they contain keys that belong to third parties.
> The hardware wallet must guarantee that the user knows precisely *what*
> "policy" is being used to spend the funds, and that the "unspent" funds (if
> any) will be protected by the same policy. This makes it impossible for an
> attacker to surreptitiously modify the policy, therefore stealing or
> burning user's funds.
>
> ==== UX issues ====
>
> With miniscript (and taproot trees) allowing substantially more complex
> spending policies to be used, it becomes more challenging to make sure that
> the user is able _in practice_ to verify the information on the screen.
> Therefore, there are two fundamental design goals to strive for:
> - Minimize the amount of information that is shown on screen - so that the
> user can actually validate it.
> - Minimize the number of times the user has to validate such information.
>
> Designing a secure protocol for the coordination of a descriptor wallet
> among distant parties is also a challenging problem that is out of scope in
> this document. See BIP-129 [2] for an approach designed for multisignature
> wallets.
>
> === Policy registration as a solution ===
>
> A solution to address the security concerns, and part of the UX concerns,
> is to have a *registration* flow for the wallet policy in the hardware
> wallet. The "wallet policy" must contain enough information to generate all
> the relevant addresses/scripts, and for the hardware wallet to identify the
> keys that it controls and that are needed to spend the funds sent to those
> addresses.
>
> Before a new policy is used for the first time, the user will register a
> `wallet policy` into the hardware wallet. While the details of the process
> are out of scope in this document, the flow should be something similar to
> the following:
>
> 1) The software wallet initiates a _wallet policy registration_ on the
> hardware wallet; the information should include the wallet policy, but also
> a unique *name* that identifies the policy.
> 2) The hardware wallet shows the wallet policy to the user using the
> secure screen.
> 3) After inspecting the policy and comparing it with a trusted source (for
> example a printed backup), the user approves the policy.
> 4) If stateful, the hardware wallet persists the policy in its permanent
> memory; if stateless, it returns a "proof of registration".
>
> The details of how to create a proof of registration are out of scope for
> this document; using a *message authentication codes* on a hash committing
> to the wallet policy, its name and any additional metadata is an effective
> solution if correctly executed.
>
> Once a policy is registered, the hardware wallet can perform the usual
> operations securely:
> - generating receive and change addresses;
> - showing addresses on the secure screen;
> - sign transactions spending from a wallet, while correctly identifying
> change addresses and computing the transaction fees.
>
> Before any of the actions mentioned above, the hardware wallet will
> retrieve the policy from its permanent storage if stateful; if stateless it
> will validate the _proof of registration_ before using the wallet policy
> provided by the client.
> Once the previously registered policy is correctly identified and approved
> by the user (for example by its name), and *as long as the policy
> registration was executed securely*, hardware wallets can provide a user
> experience similar to the usual one for single-signature transactions.
>
> === Avoiding blowup in descriptor size ===
>
> While reusing a pubkey in different branches of a miniscript is explicitly
> forbidden by miniscript (as it has certain negative security implications),
> it is still reasonable to reuse the same *xpub* in multiple places, albeit
> with different final steps of derivation (so that the actual pubkeys that
> are used in the script are indeed different).
>
> For example, using Taproot, a *3*-of-*5* multisignature wallet could use:
> - a key path with a 5-of-5 MuSig
> - a script tree with a tree of 10 different 3-of-3 MuSig2 scripts, that
> are generated, plus a leaf with a fallback *3*-of-*5* multisignature using
> plain multisignature (with `OP_CHECKSIGADD`).
>
> This could look similar to:
>
> ```
> tr(musig2(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {
>   {
>     {
>       pk(musig2(xpubA,xpubB,xpubC)/<2;3>/*),
>       {
>         pk(musig2(xpubA,xpubB,xpubD)/<4;5>/*)
>         pk(musig2(xpubA,xpubB,xpubE)/<6;7>/*),
>       }
>     },
>     {
>       pk(musig2(xpubA,xpubC,xpubD)/<8;9>/*),
>       {
>         pk(musig2(xpubA,xpubC,xpubE)/<10;11>/*),
>         pk(musig2(xpubA,xpubD,xpubE)/<12;13>/*)
>       }
>     }
>   },
>   {
>     {
>       pk(musig2(xpubB,xpubC,xpubD)/<14;15>/*),
>       pk(musig2(xpubB,xpubC,xpubE)/<16;17>/*)
>     },
>     {
>       pk(musig2(xpubB,xpubD,xpubE)/<18;19>/*),
>       {
>         pk(musig2(xpubC,xpubD,xpubE)/<20;21>/*),
>         sortedmulti_a(3,
>           xpubA/<22;23>/*,
>           xpubB/<22;23>/*,
>           xpubC/<22;23>/*,
>           xpubD/<22;23>/*,
>           xpubE/<22;23>/*)
>       }
>     }
>   }
> })
> ```
>
> Note that each root xpub appears 8 times. With xpubs being up to 118 bytes
> long, the length of the full descriptor can get extremely long (the problem
> gets *exponentially* worse with larger multisignature schemes).
>
> Replacing the common part of the key with a short key placeholder and
> moving the key expression separately helps to keep the size of the wallet
> policy small, which is crucial to allow human inspection in the
> registration flow.
>
> === Restrictions on the supported descriptors ====
>
> The policy language proposed in this document purposely targets only a
> stricter subset of the output descriptors language, and it attempts to
> generalize in the most natural way the approach that is already used for
> single-signature *accounts* (as described in BIP-44 [3], BIP-49 [4], BIP-84
> [5], or BIP-86 [6]), or in multisignature setups (see for example BIP-48
> [7] and BIP-87 [8]).
>
> Unlike the BIPs mentioned above, it is not tied to any specific script
> template, as it applies to arbitrary scripts that can be represented with
> descriptors and miniscript.
>
> Supporting only a reduced feature set when compared to output descriptors
> helps in implementations (especially on hardware wallets), while attempting
> to capture all the common use cases. More features can be added in the
> future if motivated by real world necessity.
>
> By keeping the structure of the wallet policy language very close to that
> of descriptors, it should be straightforward to:
> - write wallet policy parsers;
> - extract the descriptors defined by a wallet policy;
> - convert a pair of descriptors describing a wallet "account" used in
> current implementations into the corresponding wallet policy.
>
>
> == Wallet policies ==
>
> This section formally defines wallet policies, and how they relate to
> output script descriptors.
>
> === Formal definition ===
>
> A wallet policy is composed by a wallet descriptor template, together with
> a vector of key information items.
>
> ==== Wallet descriptor template ====
>
> A wallet descriptor template is a `SCRIPT` expression.
>
> `SCRIPT` expressions:
> - `sh(SCRIPT)` (top level only): P2SH embed the argument.
> - `wsh(SCRIPT)` (top level or inside `sh` only): P2WSH embed the argument.
> - `pkh(KP)` (not inside `tr`): P2PKH output for the given public key (use
> `addr` if you only know the pubkey hash).
> - `wpkh(KP)` (top level or inside `sh` only): P2WPKH output for the given
> compressed pubkey.
> - `multi(k,KP_1,KP_2,...,KP_n)`: k-of-n multisig script.
> - `sortedmulti(k,KP_1,KP_2,...,KP_n)`: k-of-n multisig script with keys
> sorted lexicographically in the resulting script.
> - `tr(KP)` or `tr(KP,TREE)` (top level only): P2TR output with the
> specified key as internal key, and optionally a tree of script paths.
> - any valid miniscript template (inside `wsh` or `tr` only).
>
> `TREE` expressions:
> - any `SCRIPT` expression
> - An open brace `{`, a `TREE` expression, a comma `,`, a `TREE`
> expression, and a closing brace `}`
>
> Note: "miniscript templates" are not formally defined in this version of
> the document, but it is straightforward to adapt this approach.
>
> `KP` expressions (key placeholders) consist of
> - a single character `@`
> - followed by a non-negative decimal number, with no leading zeros (except
> for `@0`).
> - possibly followed by either:
>   - the string  `/**`, or
>   - a string of the form `/<NUM;NUM>/*`, for two distinct decimal numbers
> `NUM` representing unhardened derivations
>
> The `/**` in the placeholder template represents commonly used paths for
> receive/change addresses, and is equivalent to `<0;1>`.
>
> The placeholder `@i` for some number *i* represents the *i*-th key in the
> vector of key origin information (which must be of size at least *i* + 1,
> or the wallet policy is invalid).
>
> ==== Key informations vector ====
>
> Each element of the key origin information vector is a `KEY` expression.
>
> - Optionally, key origin information, consisting of:
>   - An open bracket `[`
>   - Exactly 8 hex characters for the fingerprint of the master key from
> which this key is derived from (see [BIP32](
> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) for
> details)
>   - Followed by zero or more `/NUM'` path elements to indicate hardened
> derivation steps between the fingerprint and the xpub that follows
>   - A closing bracket `]`
> - Followed by the actual key, which is either
>   - a hex-encoded pubkey, which is either
>     - inside `wpkh` and `wsh`, only compressed public keys are permitted
> (exactly 66 hex characters starting with `02` or `03`.
>     - inside `tr`, x-only pubkeys are also permitted (exactly 64 hex
> characters).
>   - a serialized extended public key (`xpub`) (as defined in [BIP 32](
> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki))
>
> The placeholder `@i` for some number *i* represents the *i*-th key in the
> vector of key orIgin information (which must be of size at least *i* + 1,
> or the wallet policy is invalid).
>
> The policy template is invalid if any placeholder `@i` has derivation
> steps while the corresponding `(i+1)`-th element of the keys vector is not
> an xpub.
>
> ==== Additional rules ====
>
> The wallet policy is invalid if any placeholder expression with additional
> derivation steps is used when the corresponding key information is not an
> xpub.
>
> The key information vector *should* be ordered so that placeholder `@i`
> never appear for the first time before an occurrence of `@j`  for some `j <
> i`; for example, the first placeholder is always `@0`, the next one is
> `@1`, etc.
>
> === Descriptor derivation ===
>
> From a wallet descriptor template (and the associated vector of key
> informations), one can therefore obtain the 1-dimensional descriptor for
> receive and change addresses by:
>
> - replacing each key placeholder with the corresponding key origin
> information;
> - replacing every `/**`  with `/0/*` for the receive descriptor, and
> `/1/*` for the change descriptor;
> - replacing every `/<M,N>` with  `/M` for the receive descriptor, and `/N`
> for the change descriptor.
>
> For example, the wallet descriptor `pkh(@0/**)` with key information
> `["[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL"]`
> produces the following two descriptors:
>
> - Receive descriptor:
> `pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/0/*)`
>
> - Change descriptor:
> `pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*)`
>
> === Implementation guidelines ===
>
> Implementations must not necessarily implement all of the possible wallet
> policies defined by this standard, but it is recommended to clearly
> document any limitation.
>
> Implementations can add additional metadata that is stored together with
> the wallet policy for the purpose of wallet policy registration and later
> usage. Metadata can be vendor-specific and is out of the scope of this
> document.
>
> Any implementation in a general-purpose software wallet allowing arbitrary
> scripts (or any scripts that involve external cosigners) should put great
> care into a process for backing up a wallet policy. In fact, unlike typical
> single-signature scenarios, the seed alone is no longer enough to discover
> wallet policies with existing funds, and the loss of the backup is likely
> to lead to permanent loss of funds.
>
> Avoiding key reuse among different wallet accounts is also extremely
> important, but out of scope for this document.
>
> == Examples ==
>
> Some examples of wallet descriptor templates (vectors of keys omitted for
> simplicity):
> - Template for a native segwit account:
>   wpkh(@0/**)
> - Template for a taproot BIP86 account:
>   tr(@0/**)
> - Template for a native segwit 2-of-3:
>   wsh(sortedmulti(2, at 0/**, at 1/**, at 2/**))
> - Template with miniscript for "1 of 2 equally likely keys":
>   wsh(or_b(pk(@0/**),s:pk(@1/**)))
>
> More examples (esp. targeting miniscript on taproot) will be added in the
> future.
>
> == References ==
>
> * [1] - Output Script Descriptors:
> https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
> * [2] - BIP-129 (Bitcoin Secure Multisig Setup):
> https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki
> * [3] - BIP-44:
> https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
> * [4] - BIP-49:
> https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
> * [5] - BIP-84:
> https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
> * [6] - BIP-86:
> https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki
> * [7] - BIP-48:
> https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki
> * [8] - BIP-87:
> https://github.com/bitcoin/bips/blob/master/bip-0087.mediawiki
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220508/2f271848/attachment-0001.html>

From darosior at protonmail.com  Mon May  9 11:36:47 2022
From: darosior at protonmail.com (darosior)
Date: Mon, 09 May 2022 11:36:47 +0000
Subject: [bitcoin-dev] Wallet policies for descriptor wallets
In-Reply-To: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
References: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
Message-ID: <osdF1jSCUyGyaLZ6YytSB7ub1MwdbaP6PMCYEJZXmMRaSs4vS7bs_SZTErxZh_K7oLYLAtAqqgl0Vcdl1ftAusM_1DHSDHtz1kSUzqnmwsk=@protonmail.com>

Thanks for taking the time to write up about the implementation of output descriptors on signing devices, and
for proposing a method to overcome encountered difficulties for the following implementers.

I have some questions with regard to the modifications to the descriptor language required to make the
registration flow reasonable on a signing device.

To sum up, starting from the currently spec'd output descriptors [0] you need:
1. The `<NUM;NUM>` optimization for the common usecase of using 2 descriptors at different derivation indices
   for receive and change. [1]
2. The `/**` optimization for the common usecase of `/<0;1>` for point 1).
3. A new key expression `@i` referring to an index in a list of keys.

The first point was already discussed at great length [2]. Whether or not we agree using the derivation path
for change detection is a sane thing to do, most signing devices need to support this to not break
compatibility. I think the advantage boils down to not make the user write two almost-similar descriptors on
its backup, since it doesn't necessarily help readibility for human verification.

I'm not so sure about the second point. Is another deviation from the standard worth it just for saving 3
characters?
Disgressing, if we are to have a carve-out in the descriptor language for the common usecase of change/receive
keychains maybe your `/**` applies better than the proposed `/<NUM;NUM>` as the latter can open the door to
further carve-out requests.

For the third point, it does indeed seem unrealistic to check both the keys and the descriptor at the same
time. Even just because of the screen size (if the width an xpub is, what, 3 times the width of your screen,
by the time you finished verifying it you have forgotten the descriptor context in which this key was!). It
becomes harder as you get larger descriptors with Miniscript or Taproot, as you mentioned. Even the Miniscript
compiler at [3] supports key aliasing to workaround the inconvenience of long keys.
However, why does it need to be a change to the descriptor language? It looks a lot like something that needs
to be handled at the application level with key aliasing. The flow would be first to register known keys, and
then when registering a descriptor the keys would be replaced by their aliases for smoother verification. For
stateless devices, the registration of keys could use the same flow you described for descriptors.
In the end it's just replacing the vector and indices with a mapping and label, which make it a *much* better
UX (checking aliases vs looking up indices in a vector). For instance:
    Key registration:
        Alice: xpub6FLhTbeNidZkyC729yW6K6a5zuDxKUL8Q6oZm4XG2ov9PdxAyyDNEUm3jet8ENnvYsy6nCgsofN6FeVxakLDTdWGoxtmoYcu2exhqh9HjtV
        Bob: xpub6CoUua86qHYdDmnQL7imGN3zUMpVjRT4uDtRxYvfFj2v8JRvsaaGtf9ggv9NiL8sx3rFh6po92WBChwb37gDGuuU2Qo7zi3ZKC9cLjAsdQw
        Notary: xpub6DjUwtKmK7uqsd5p9w3eoJ4cjuML51nW85BTWuBaHEoxfmDGD3uPf6ZghsVeyuZUSuYEL4ajkVrfXzmotHHPtf6oBNYUQDSSBD4zUEiDoap

    Descriptor registration (policy language for simpl.):
        tr(NUMS,{
            multi(2,Alice,Bob),
            and(older(52560),and(Notary,Alice)),
            and(older(52560),and(Notary,Bob))
        })

In conclusion, if we were to have an optimization in the descriptor language for the common receive/change
usecase, i don't think you need another "wallet policy language" than the existing output descriptors language
with key aliasing/registration?


Unrelated question, since you mentioned `musig2` descriptors in this context. I thought Musig2 wasn't really
feasible for hardware signing devices, especially stateless ones. Do you think/know whether it is actually
possible for a HW to take part in a Musig2?


Thanks,
Antoine

[0] https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki
[1] https://github.com/bitcoin/bitcoin/pull/22838
[2] https://github.com/bitcoin/bitcoin/issues/17190
[3] https://bitcoin.sipa.be/miniscript/


------- Original Message -------
Le jeudi 5 mai 2022 ? 4:32 PM, Salvatore Ingala via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> a ?crit :


> In the implementation work to implement descriptors and miniscript support in hardware wallets [a][b], I encountered a number of challenges. Some of them are technical in nature (e.g. due to constraints of embedded development). Others are related to the attempts of shaping a good user experience; with bitcoin reaching more people who are not tech-savvy, self-custody is only as secure as what those newcomers can use easily enough.
>
> The main tool that I am using to address some of these challenges is a layer that sits _on top_ of descriptors/miniscript, while staying very close to it. Since there is nothing that is vendor-specific in the vast majority of the approach I'm currently using, I tried to distill it here for your comments, and will propose a BIP if this is deemed valuable.
>
> I called the language "wallet policies" (suggestions for a better name are welcome). I believe an approach based on wallet policies can benefit all hardware wallets (stateless or not) that want to securely support complex scripts; moreover, wallet policies are close enough to descriptors that their integration should be extremely easy for any software wallet that is currently using descriptors.
>
> [a]: https://blog.ledger.com/bitcoin-2 - early demo[b]: https://blog.ledger.com/miniscript-is-coming - miniscript example
>
> Salvatore Ingala
>
> ======================================================
>
> This document starts with a discussion on the motivation for wallet policies, followed by their formal definition, and some recommendations for implementations.
> == Rationale ==
> Output script descriptors [1] were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).
>
> Unfortunately, descriptors are not a perfect match for the typical usage of hardware wallets. Most hardware wallets have the following limitations compared to a general-purpose machine running bitcoin-core:
>
> - they are embedded devices with limited RAM and computational power;
> - they might not be able to import additional private keys (all the keys are generated from a single seed via [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki));
> - they might not have permanent storage (*stateless* hardware wallet design).
>
> Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience.
>
> A more native, compact representation of the wallet receive/change would also benefit the UX of software wallets using descriptors to represent software wallets using descriptors/miniscript for multisignature or other complex locking conditions.
>
> === Security and UX concerns of scripts in hardware wallets ===
> For a hardware wallet, allowing the usage of complex scripts presents challenges in terms of both security and user experience.
>
> ==== Security issues ====
> One of the security properties that hardware wallets strive to guarantee is the following: **as long as the user correctly verifies the information that is shown on the hardware wallet's screen before approving, no action can be performed without the user's consent**.
> This must hold even in scenarios where the attacker has full control of the machine that is connected to the hardware wallet, and can execute arbitrary requests or tamper with the legitimate user's requests.
>
> Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.
> The hardware wallet must guarantee that the user knows precisely *what* "policy" is being used to spend the funds, and that the "unspent" funds (if any) will be protected by the same policy. This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning user's funds.
>
> ==== UX issues ====
> With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is able _in practice_ to verify the information on the screen. Therefore, there are two fundamental design goals to strive for:
> - Minimize the amount of information that is shown on screen - so that the user can actually validate it.
> - Minimize the number of times the user has to validate such information.
>
> Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See BIP-129 [2] for an approach designed for multisignature wallets.
>
> === Policy registration as a solution ===
> A solution to address the security concerns, and part of the UX concerns, is to have a *registration* flow for the wallet policy in the hardware wallet. The "wallet policy" must contain enough information to generate all the relevant addresses/scripts, and for the hardware wallet to identify the keys that it controls and that are needed to spend the funds sent to those addresses.
>
> Before a new policy is used for the first time, the user will register a `wallet policy` into the hardware wallet. While the details of the process are out of scope in this document, the flow should be something similar to the following:
>
> 1) The software wallet initiates a _wallet policy registration_ on the hardware wallet; the information should include the wallet policy, but also a unique *name* that identifies the policy.
> 2) The hardware wallet shows the wallet policy to the user using the secure screen.
> 3) After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.
> 4) If stateful, the hardware wallet persists the policy in its permanent memory; if stateless, it returns a "proof of registration".
>
> The details of how to create a proof of registration are out of scope for this document; using a *message authentication codes* on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.
>
> Once a policy is registered, the hardware wallet can perform the usual operations securely:
> - generating receive and change addresses;
> - showing addresses on the secure screen;
> - sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.
>
> Before any of the actions mentioned above, the hardware wallet will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.
> Once the previously registered policy is correctly identified and approved by the user (for example by its name), and *as long as the policy registration was executed securely*, hardware wallets can provide a user experience similar to the usual one for single-signature transactions.
>
> === Avoiding blowup in descriptor size ===
> While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same *xpub* in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).
>
> For example, using Taproot, a *3*-of-*5* multisignature wallet could use:
> - a key path with a 5-of-5 MuSig
> - a script tree with a tree of 10 different 3-of-3 MuSig2 scripts, that are generated, plus a leaf with a fallback *3*-of-*5* multisignature using plain multisignature (with `OP_CHECKSIGADD`).
>
> This could look similar to:
>
> ```
> tr(musig2(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {
> {
> {
> pk(musig2(xpubA,xpubB,xpubC)/<2;3>/*),
> {
> pk(musig2(xpubA,xpubB,xpubD)/<4;5>/*)
> pk(musig2(xpubA,xpubB,xpubE)/<6;7>/*),
> }
> },
> {
> pk(musig2(xpubA,xpubC,xpubD)/<8;9>/*),
> {
> pk(musig2(xpubA,xpubC,xpubE)/<10;11>/*),
> pk(musig2(xpubA,xpubD,xpubE)/<12;13>/*)
> }
> }
> },
> {
> {
> pk(musig2(xpubB,xpubC,xpubD)/<14;15>/*),
> pk(musig2(xpubB,xpubC,xpubE)/<16;17>/*)
> },
> {
> pk(musig2(xpubB,xpubD,xpubE)/<18;19>/*),
> {
> pk(musig2(xpubC,xpubD,xpubE)/<20;21>/*),
> sortedmulti_a(3,
> xpubA/<22;23>/*,
> xpubB/<22;23>/*,
> xpubC/<22;23>/*,
> xpubD/<22;23>/*,
> xpubE/<22;23>/*)
> }
> }
> }
> })
> ```
>
> Note that each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem gets *exponentially* worse with larger multisignature schemes).
>
> Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection in the registration flow.
>
> === Restrictions on the supported descriptors ====
>
> The policy language proposed in this document purposely targets only a stricter subset of the output descriptors language, and it attempts to generalize in the most natural way the approach that is already used for single-signature *accounts* (as described in BIP-44 [3], BIP-49 [4], BIP-84 [5], or BIP-86 [6]), or in multisignature setups (see for example BIP-48 [7] and BIP-87 [8]).
> Unlike the BIPs mentioned above, it is not tied to any specific script template, as it applies to arbitrary scripts that can be represented with descriptors and miniscript.
>
> Supporting only a reduced feature set when compared to output descriptors helps in implementations (especially on hardware wallets), while attempting to capture all the common use cases. More features can be added in the future if motivated by real world necessity.
>
> By keeping the structure of the wallet policy language very close to that of descriptors, it should be straightforward to:
> - write wallet policy parsers;
> - extract the descriptors defined by a wallet policy;
> - convert a pair of descriptors describing a wallet "account" used in current implementations into the corresponding wallet policy.
>
>
> == Wallet policies ==
> This section formally defines wallet policies, and how they relate to output script descriptors.
> === Formal definition ===
> A wallet policy is composed by a wallet descriptor template, together with a vector of key information items.
>
> ==== Wallet descriptor template ====
>
> A wallet descriptor template is a `SCRIPT` expression.
>
> `SCRIPT` expressions:
> - `sh(SCRIPT)` (top level only): P2SH embed the argument.
> - `wsh(SCRIPT)` (top level or inside `sh` only): P2WSH embed the argument.
> - `pkh(KP)` (not inside `tr`): P2PKH output for the given public key (use `addr` if you only know the pubkey hash).
> - `wpkh(KP)` (top level or inside `sh` only): P2WPKH output for the given compressed pubkey.
> - `multi(k,KP_1,KP_2,...,KP_n)`: k-of-n multisig script.
> - `sortedmulti(k,KP_1,KP_2,...,KP_n)`: k-of-n multisig script with keys sorted lexicographically in the resulting script.
> - `tr(KP)` or `tr(KP,TREE)` (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.- any valid miniscript template (inside `wsh` or `tr` only).
> `TREE` expressions:
> - any `SCRIPT` expression
> - An open brace `{`, a `TREE` expression, a comma `,`, a `TREE` expression, and a closing brace `}`
>
> Note: "miniscript templates" are not formally defined in this version of the document, but it is straightforward to adapt this approach.
>
> `KP` expressions (key placeholders) consist of
> - a single character `@`
> - followed by a non-negative decimal number, with no leading zeros (except for `@0`).
> - possibly followed by either:
> - the string `/**`, or
> - a string of the form `/<NUM;NUM>/*`, for two distinct decimal numbers `NUM` representing unhardened derivations
>
> The `/**` in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to `<0;1>`.
>
> The placeholder `@i` for some number *i* represents the *i*-th key in the vector of key origin information (which must be of size at least *i* + 1, or the wallet policy is invalid).
>
> ==== Key informations vector ====
>
> Each element of the key origin information vector is a `KEY` expression.
>
> - Optionally, key origin information, consisting of:
> - An open bracket `[`
> - Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) for details)
> - Followed by zero or more `/NUM'` path elements to indicate hardened derivation steps between the fingerprint and the xpub that follows
> - A closing bracket `]`
> - Followed by the actual key, which is either
> - a hex-encoded pubkey, which is either
> - inside `wpkh` and `wsh`, only compressed public keys are permitted (exactly 66 hex characters starting with `02` or `03`.
> - inside `tr`, x-only pubkeys are also permitted (exactly 64 hex characters).
> - a serialized extended public key (`xpub`) (as defined in [BIP 32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki))
>
> The placeholder `@i` for some number *i* represents the *i*-th key in the vector of key orIgin information (which must be of size at least *i* + 1, or the wallet policy is invalid).
>
> The policy template is invalid if any placeholder `@i` has derivation steps while the corresponding `(i+1)`-th element of the keys vector is not an xpub.
>
> ==== Additional rules ====
> The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.
>
> The key information vector *should* be ordered so that placeholder `@i` never appear for the first time before an occurrence of `@j` for some `j < i`; for example, the first placeholder is always `@0`, the next one is `@1`, etc.
>
> === Descriptor derivation ===
> From a wallet descriptor template (and the associated vector of key informations), one can therefore obtain the 1-dimensional descriptor for receive and change addresses by:
>
> - replacing each key placeholder with the corresponding key origin information;
> - replacing every `/**` with `/0/*` for the receive descriptor, and `/1/*` for the change descriptor;
> - replacing every `/<M,N>` with `/M` for the receive descriptor, and `/N` for the change descriptor.
>
> For example, the wallet descriptor `pkh(@0/**)` with key information `["[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL"]` produces the following two descriptors:
>
> - Receive descriptor: `pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/0/*)`
>
> - Change descriptor: `pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*)`
>
> === Implementation guidelines ===
> Implementations must not necessarily implement all of the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.
>
> Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.
>
> Any implementation in a general-purpose software wallet allowing arbitrary scripts (or any scripts that involve external cosigners) should put great care into a process for backing up a wallet policy. In fact, unlike typical single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds.
>
> Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.
>
> == Examples ==
>
> Some examples of wallet descriptor templates (vectors of keys omitted for simplicity):- Template for a native segwit account:wpkh(@0/**)
> - Template for a taproot BIP86 account:tr(@0/**)
> - Template for a native segwit 2-of-3:wsh(sortedmulti(2, at 0/**, at 1/**, at 2/**))- Template with miniscript for "1 of 2 equally likely keys":wsh(or_b(pk(@0/**),s:pk(@1/**)))
> More examples (esp. targeting miniscript on taproot) will be added in the future.
> == References ==
>
> * [1] - Output Script Descriptors: https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md* [2] - BIP-129 (Bitcoin Secure Multisig Setup): https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki
> * [3] - BIP-44: https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki* [4] - BIP-49: https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki* [5] - BIP-84: https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki* [6] - BIP-86: https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki* [7] - BIP-48: https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki* [8] - BIP-87: https://github.com/bitcoin/bips/blob/master/bip-0087.mediawiki

From keagan.mcclelland at gmail.com  Mon May  9 15:23:39 2022
From: keagan.mcclelland at gmail.com (Keagan McClelland)
Date: Mon, 9 May 2022 09:23:39 -0600
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
 <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
 <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>
Message-ID: <CALeFGL18ULkGW4UA_5Fod4PVoe_LeF5e97eZdJja-ctf2paLWQ@mail.gmail.com>

> > > To me the most scary one is visacoin, specially seeing what happened
in canada and other places lately and the general censorship in the west,
the supposed war on "misinformation" going on (really a war against truth
imo, but whatever) it's getting really scary. But perhaps someone else can
be more scared about a covenant to add demurrage fees to coins or
something, I don't know.
> > > https://bitcointalk.org/index.php?topic=278122

> > This requires *recursive* covenants.

> Actually, for practical use, any walled-garden requires *dynamic*
covenants, not recursive covenants.

There's actually also a very straight forward defense for those who do not
want to receive "tainted" coins. In every covenant design I've seen to date
(including recursive designs) it requires that the receiver generate a
script that is "compliant" with the covenant provisions to which the sender
is bound. The consequence of this is that you can't receive coins that are
bound by covenants you weren't aware of*. So if you don't want to receive
restricted coins, just don't generate an address with those restrictions
embedded. As long as you can specify the spend conditions upon the receipt
of your funds, it really doesn't matter how others are structuring their
own spend conditions. So long as the verification of those conditions can
be predictably verified by the rest of the network, all risk incurred is
quarantined to the receiver of the funds. Worst case scenario is that no
one wants to agree to those conditions and the funds are effectively burned.

It's not hard to make the case that any time funds are being transferred
between organizations with incompatible interests (external to a firm),
that they will want to be completely free to choose their own spend
conditions and will not wish to inherit the conditions of the spender.
Correspondingly, any well implemented covenant contract will include
provisions for escaping the recursion loop if some sufficiently high bar is
met by the administrators of those funds. Unless governments can mandate
that you generate these addresses AND force you to accept funds bound by
them for your services**, I don't actually see how this is a real concern.

*This requires good wallet tooling and standards but that isn't materially
different than wallets experimenting with non-standard recovery policies.

**This is a reason to oppose legal tender laws for Bitcoin imo.

Keagan

On Sun, May 8, 2022 at 11:32 AM Billy Tetrud via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> >  This requires *recursive* covenants.
>
> Actually, for practical use, any walled-garden requires *dynamic*
> covenants, not recursive covenants. CTV can get arbitrarily close to
> recursive covenants, because you can have an arbitrarily long string of
> covenants. But this doesn't help someone implement visacoin because CTV
> only allows a specific predefined iteration of transactions, meaning that
> while "locked" into the covenant sequence, the coins can't be used in any
> way like normal coins - you can't choose who you pay, the sequence is
> predetermined.
>
> Even covenants that allow infinite recursion (like OP_TLUV and OP_CD
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md>)
> don't automatically allow for practical walled gardens. Recursion
> definitely allows creating walled gardens, but those gardens would be
> impractically static. You could add millions of potential addresses to send
> to, which would "only" quadruple the size of your transactions, but if
> anyone creates a new address you want to send to, you wouldn't be able to.
> Everyone would have to have a single address whitelisted into every
> government-bitcoin output. If someone lost their key and needs to create a
> new wallet, suddenly no one would be able to pay them.
>
> In order to really build a wallet garden, infinite recursion isn't really
> necessary nor sufficient. You need to be able to dynamically specify
> destination addresses. For example, if you were a government that wants to
> make a walled garden where you (the government) could confiscate the funds
> whenever you wanted, you'd have to have a covenant that allows the end-user
> to specify an arbitrary public key to send money to. The covenant might
> require that user to send to another covenant that has a government spend
> path, but also has a spend path for that user-defined public key. That way,
> you (the government) could allow people to send to each other arbitrarily,
> while still ensuring that you (the government) could spend the funds no
> matter where they may have been sent. Even without recursive covenants, you
> could have arbitrarily long chains of these, say 1 million long, where at
> the end of the chain the user must send your coins back to the government
> who can then send them back with another million-long chain of covenants to
> work with.
>
> OP_CHECKOUTPUTVERIFY <https://fc16.ifca.ai/bitcoin/papers/MES16.pdf> can
> do this kind of dynamicness, and OP_PUSHOUTPUTSTACK
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/pos/bip-pushoutputstack.md> can
> enable it for things like OP_TLUV and OP_CD. I personally think dynamic
> covenants are a *good* thing, as it enables more secure wallet vaults,
> among other things. And I'm not worried about a government creating a
> in-bitcoin visa-coin. Why? Because they can already do it today. They have
> been able to do it for 9 years already. How?
>
> Replace the covenant above with a multisig wallet. The government has 2
> keys, you have 1 key. Every time you make a transaction, you request the
> government's signature on it. The government then only signs if you're
> sending to a wallet they approve of. They might only sign when you're
> sending to another multisig wallet that the government has 2 of 3 keys for.
> Its a very similar walled garden, where the only difference is that the
> government needs to actively sign, which I'm sure wouldn't be a huge
> challenge for the intrepid dictator of the land. You want to add
> demurage fees? Easy, the government just spends the fee out of everyone's
> wallets every so often.
>
> On the other hand, OP_CTV *cannot* be used for such a thing. No
> combination of future opcodes can enable either recursion or dynamicness to
> an OP_CTV call.
>
>
>
> On Sat, May 7, 2022 at 5:40 PM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Good morning Jorge,
>>
>> > I think people may be scared of potential attacks based on covenants.
>> For example, visacoin.
>> > But there was a thread with ideas of possible attacks based on
>> covenants.
>> > To me the most scary one is visacoin, specially seeing what happened in
>> canada and other places lately and the general censorship in the west, the
>> supposed war on "misinformation" going on (really a war against truth imo,
>> but whatever) it's getting really scary. But perhaps someone else can be
>> more scared about a covenant to add demurrage fees to coins or something, I
>> don't know.
>> > https://bitcointalk.org/index.php?topic=278122
>>
>> This requires *recursive* covenants.
>>
>> At the time the post was made, no distinction was seen between recursive
>> and non-recursive covenants, which is why the post points out that
>> covenants suck.
>> The idea then was that anything powerful enough to provide covenants
>> would also be powerful enough to provide *recursive* covenants, so there
>> was no distinction made between recursive and non-recursive covenants (the
>> latter was thought to be impossible).
>>
>> However, `OP_CTV` turns out to enable sort-of covenants, but by
>> construction *cannot* provide recursion.
>> It is just barely powerful enough to make a covenant, but not powerful
>> enough to make *recursive* covenants.
>>
>> That is why today we distinguish between recursive and non-recursive
>> covenant opcodes, because we now have opcode designs that provides
>> non-recursive covenants (when previously it was thought all covenant
>> opcodes would provide recursion).
>>
>> `visacoin` can only work as a recursive covenant, thus it is not possible
>> to use `OP_CTV` to implement `visacoin`, regardless of your political views.
>>
>> (I was also misinformed in the past and ignored `OP_CTV` since I thought
>> that, like all the other covenant opcodes, it would enable recursive
>> covenants.)
>>
>>
>> Regards,
>> ZmnSCPxj
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220509/bfc87453/attachment.html>

From antoine.riard at gmail.com  Tue May 10 00:38:36 2022
From: antoine.riard at gmail.com (Antoine Riard)
Date: Mon, 9 May 2022 20:38:36 -0400
Subject: [bitcoin-dev] Conjectures on solving the high interactivity
 issue in payment pools and channel factories
In-Reply-To: <CAGpPWDa2wofye=KSq-vVNS0SOU34st9wm-hMhiYzGLTKMGuP5w@mail.gmail.com>
References: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
 <CAGpPWDa2wofye=KSq-vVNS0SOU34st9wm-hMhiYzGLTKMGuP5w@mail.gmail.com>
Message-ID: <CALZpt+FTB9y6zO4Ap44GwZKVGj17Hv8+fYP02eoevOFA1MO5LA@mail.gmail.com>

Hi Billy,

Thanks for reading.

> A. Create sub-pools when the whole group is live that can be used by the
> sub- pool participants later without the whole group's involvement. The
> whole group is needed to change the whole group's state (eg close or open
> sub-pools), but sub-pool states don't need to involve the whole group.

Yes this could be a direction. Assume you have a fan-out transaction
spending the Update transaction to a combination of sub-pools. I think you
have two problems arising.

The first one it's hard to predict in advance the subset of pool
participants which will be inactive, and thus guaranteeing stale-free
sub-pools. Further, it's also hard to predict in advance the liquidity
needs of the sub-pools. So I think this prediction of these two factors is
unlikely to be correct, this statement getting more sound as the number of
pool participants increases.

The second one, this fan-out transaction could interfere with the
confirmation of the simple withdraw transactions, and thus the uplifted
constructions (e.g a LN channel). So there is an open question about the
"honest" usage of the sub-pool states themselves.

> B. Have an always-online system empowered to sign only for group updates
> that *do not* change the owner's balance in the group. This could be done
> with a hardware-wallet like device, or could be done with some kind of new
> set of opcodes that can be used to verify that a particular transaction
> isn't to the owner's detriment.

Sure, one could envision an accumulator committing directly to balances
too. State transition would be allowed only if the non-involved users
balances are immutably preserved to, only the active users balances are
mixed. I think the challenge is to find a compact accumulator with those
properties.

About the "hardware-wallet like device"/"towers" solution, yes this is a
known technique to solve interactivity. Sadly, this can be a significant
requirement for a lot of users to run an additional always-online process.
It's more likely a lot of them will delegate this operation to third-party
providers, with the known reductions in terms of trust-minimizations.

> Come to think of it tho, this doesn't actually solve the double spending
> problem. The fundamental issue is that if you have a subset of
participants
> creating partitions like this, without the involvement of the whole group,
> its impossible for any subset of participants to know for sure that there
> isn't a double-spending partition amongst another set of members of the
> group.

Yes, it seems we agree that equivocation opening the way to balance
double-spend is the hard issue with partitioning multi-party constructions.

> I had a conceptual idea a while back (that I can't find at the moment)
> about offline lightning receiving. The concept is that each lightning node
> in a channel has two separate keys: a spending-key and a receiving-key.
The
> spending-key must be used manually by the node owner to send payments,
> however the receiving-key can be given to an always-online service that
can
> use that key only to either receive funds (ie update the state to a more
> favorable state).

Hmmm, how could you prevent the always-online service from using the
receiving-key in "spending" mode if the balance stacked there becomes
relevant ?

> You could do this logic inside a hardware-wallet-like device that checks
> the proposed updates and verifies the new state is favorable before
> signing. This could go a long way to hardening lightning nodes against
> potential compromise.

Yes, see https://gitlab.com/lightning-signer/docs for wip in that direction.

> This kind of thing might be a way of working around interactivity
> requirements of payment pools and the like. All participants still have to
> be aware of the whole state (eg of the payment pool), but this awareness
> can be delegated to a system you have limited trust in. Payment pool
> participants could delegate an always-online system empowered with a
> separate key to sign payment pool updates that user's state isn't changed
> for, allowing the payment pool to do its thing without exposing the user
to
> hot-key vulnerabilities in that always-online system. Double spending is
> prevented because the user can access their always-online system to get
the
> full payment pool state.

While I would be curious to see such Script-based "receiving-key" only
mechanism (maybe with IN_OUT_AMOUNT-style of covenant) I wonder if it would
solve equivocation fully. A malicious pool participant could still commit
her off-chain balance in two partitions and send spends to the A&B hosting
"receiving-keys" entities without them being aware of the conflict, in the
lack of a reconciliation such as a publication space ? Or do you have
another thinking ?

Antoine

Le dim. 1 mai 2022 ? 18:53, Billy Tetrud <billy.tetrud at gmail.com> a ?crit :

> Hi Antoine,
>
> Very interesting exploration. I think you're right that there are issues
> with the kind of partitioning you're talking about. Lightning works because
> all participants sign all offchain states (barring data loss). If a
> participant can be excluded from needing to agree to a new state, there
> must be an additional mechanism to ensure the relevant state for that
> participant isn't changed to their detriment.
>
> To summarize my below email, the two techniques I can think for solving
> this problem are:
>
> A. Create sub-pools when the whole group is live that can be used by the
> sub- pool participants later without the whole group's involvement. The
> whole group is needed to change the whole group's state (eg close or open
> sub-pools), but sub-pool states don't need to involve the whole group.
> B. Have an always-online system empowered to sign only for group updates
> that *do not* change the owner's balance in the group. This could be done
> with a hardware-wallet like device, or could be done with some kind of new
> set of opcodes that can be used to verify that a particular transaction
> isn't to the owner's detriment.
>
> I had some thoughts that I think don't pan out, but here they are anyway:
>
> What if the pool state transaction (that returns everyone's money) has
> each participant sign the input + their personal output (eg with sighash
> flags)? That way the transaction could have outputs swapped out by a subset
> of participants as needed. Some kind of eltoo mechanism could then ensure
> that the latest transaction can override earlier transactions. As far as
> the non-participating members are concerned, they don't care whether the
> newest state is published or whether the newest state they participated in
> is published - because their output is identical either way. However, I can
> see that there might be problems related to separate groups of participants
> creating conflicting transactions, ie A B & C create a partition like this,
> and so do D E & F, but they don't know about each other's state. If they
> have some always-online coordination mechanism, this could be solved as
> long as the participants aren't malicious. But it still leaves open the
> possibility that some participants could intentionally grief others by
> intentionally creating conflicting state transactions. Theoretically it
> could be structured so that no funds could be directly stolen, but it seems
> unavoidable that some group of members could create a secret transaction
> that when published makes the most recent honest state not minable.
>
> Come to think of it tho, this doesn't actually solve the double spending
> problem. The fundamental issue is that if you have a subset of participants
> creating partitions like this, without the involvement of the whole group,
> its impossible for any subset of participants to know for sure that there
> isn't a double-spending partition amongst another set of members of the
> group.
>
> On-chain bitcoin transactions prevent double spending by ensuring that
> everyone knows what outputs have been spent. Payment channels prevent
> double spending by ensuring that everyone that's part of the channel knows
> what the current channel state is. Any 3rd layer probably needs this exact
> property: everyone involved must know the state. So you should be able to
> create a partition when the whole group is live, and thereafter the members
> of that partition can use that partition without involving the rest of the
> group. I think that pattern can work to any level of depth. After thinking
> about this, I conjecture it might be a fundamental property of the double
> spending problem. All participants must be aware of the whole state
> otherwise the double spending problem exists for those who aren't aware of
> the whole state.
>
> > this is forcing the pool/factory user to share their key materials with
> potentially lower trusted entities, if they don't self-host the tower
> instances.
>
> I had a conceptual idea a while back (that I can't find at the moment)
> about offline lightning receiving. The concept is that each lightning node
> in a channel has two separate keys: a spending-key and a receiving-key. The
> spending-key must be used manually by the node owner to send payments,
> however the receiving-key can be given to an always-online service that can
> use that key only to either receive funds (ie update the state to a more
> favorable state).
>
> Right now with just a single-hot-key setup you need to trust your online
> system to only sign receiving transactions and would refuse to sign any
> proposed channel update not in the owner's favor. However, if the node was
> compromised all bets are off - the entire channel balance could be stolen.
>
> You could do this logic inside a hardware-wallet-like device that checks
> the proposed updates and verifies the new state is favorable before
> signing. This could go a long way to hardening lightning nodes against
> potential compromise.
>
> But if we go a step further, what if we enable that logic of ensuring the
> state is more favorable with an on-chain mechanism? This was where my idea
> got a bit hand wavy, but I think it could theoretically be done. The
> receiving-key would be able to sign receiving transactions that would only
> be valid when the most recent state signed by the spending-key is also
> included in the script sig in some way. Some Script would then validate
> that the receiving-key state being published is more favorable than the
> spending-key state in that transaction's outputs. You'd have a couple
> guarantees:
>
> 1. The usual guarantee that if the presented last spending-key state is
> actually out of date, the transaction could be overridden by the newer
> state in some way (eg eltoo style or punishment).
> 2. The state being published can be no worse than the presented
> spending-key state. Yes, your channel partner could compromise your
> receiving/routing node and then publish an out of date receiving-key
> channel state that's based on the most-recent spending-key state, but it
> would limit your losses to at most the amount of money you've received
> since the last time you manually signed a channel state with your
> spending-key. Because the always-online system empowered to receive does
> *not* have the spending-key, anyone that compromises that node can't spend
> and the damage is limited.
>
> While less straight-forward than for receiving, in principle it seems like
> something similar could be done for routing (which would require presenting
> the state of multiple channels, and so has some additional complexities
> there I haven't worked out).
>
> This kind of thing might be a way of working around interactivity
> requirements of payment pools and the like. All participants still have to
> be aware of the whole state (eg of the payment pool), but this awareness
> can be delegated to a system you have limited trust in. Payment pool
> participants could delegate an always-online system empowered with a
> separate key to sign payment pool updates that user's state isn't changed
> for, allowing the payment pool to do its thing without exposing the user to
> hot-key vulnerabilities in that always-online system. Double spending is
> prevented because the user can access their always-online system to get the
> full payment pool state.
>
> So in short, while I think there may be no way to fundamentally not
> require interactivity, there are workarounds that can limit how often full
> interactivity is needed as well as ways to make it easier to provide that
> full interactivity without compromising other aspects of each participant's
> security.
>
> On Thu, Apr 28, 2022 at 8:20 AM Antoine Riard via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi,
>>
>> This post recalls the noticeable interactivity issue encumbering payment
>> pools and channel factories in the context of a high number of
>> participants, describes how the problem can be understood and proposes few
>> solutions with diverse trust-minizations and efficiency assumptions. It is
>> intended to capture the theoretical bounds of the "interactivity issue",
>> where technical completeness of the solutions is exposed in future works.
>>
>> The post assumes a familiarity with the CoinPool paper concepts and
>> terminology [0].
>>
>> # The interactivity requirement grieving payment pools/channel factories
>>
>> Payment pools and channel factories are multi-party constructions
>> enabling to share the ownership of a single on-chain UTXO among many
>> off-chain/promised balances. Payment pool improves on the channel factory
>> construction fault-tolerance by reducing the number of balance outputs
>> disclosed  on-chain to a single one in case of unilateral user exits.
>>
>> However, those constructions require all the users to be online and
>> exchange rounds of signatures to update the balance distribution. Those
>> liveliness/interactivity requirements are increasing with the number of
>> users, as there are higher odds of *one* lazzy/buggy/offline user stalling
>> the pool/factory updates.
>>
>> In echo, the design of LN was envisioned for a network of
>> always-online/self-hosted participants, the early deployment of LN showed
>> the resort to delegated channel hosting solutions, relieving users from the
>> liveliness requirement. While the trust trade-offs of those solutions are
>> significant, they answer the reality of a world made of unreliable networks
>> and mobile devices.
>>
>> Minding that observation, the attractiveness of pools/factories might be
>> questioned.
>>
>> # The interactivity requirement palliatives and their limits
>>
>> Relatively straightforward solutions to lower the interactivity
>> requirement, or its encumbered costs, can be drawn out. Pools/factories
>> users could own (absolute) timelocked kick-out abilities to evict offline
>> users who are not present before expiration.
>>
>> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
>> Each of them owns a Withdraw transaction to exit their individual balances
>> at any time. Each user should have received the pre-signed components from
>> the others guaranteeing the unilateral ability to publish the Withdraw.
>>
>> A kick-out ability playable by any pool user could be provided by
>> generating a second set of Withdraw transactions, with the difference of
>> the nLocktime field setup to an absolute height T + X, where T is the
>> height at which the corresponding Update transaction is generated and X the
>> kick-out delay.  For this set of kick-out transactions, the complete
>> witnesses should be fully shared among Alice, Bob, Caroll and Dave. That
>> way, if Caroll is unresponsive to move the pool state forward after X, any
>> one of Alice, Bob or Dave can publish the Caroll kick-out Withdraw
>> transaction, and pursue operations without that unresponsive party.
>>
>> While decreasing the interactivity requirement to the timelock delay,
>> this solution is constraining the kicked user to fallback on-chain
>> encumbering the UTXO set with one more entry.
>>
>> Another solution could be to assume the widespread usage of node towers
>> among the pool participants. Those towers would host the full logic and key
>> state necessary to receive an update request and produce a user's approval
>> of it. As long as one tower instance is online per-user, the pool/factory
>> can move forward. Yet this is forcing the pool/factory user to share their
>> key materials with potentially lower trusted entities, if they don't
>> self-host the tower instances.
>>
>> Ideally, I think we would like a trust-minimized solution enabling
>> non-interactive, off-chain updates of the pool/factory, with no or minimal
>> consumption of blockspace.
>>
>> For the remainder of this post, only the pool use-case will be mentioned.
>> Though, I think the observations/implications can be extended to factories
>> as well.
>>
>> # Non-interactive Off-chain Pool Partitions
>>
>> If a pool update fails because of lack of online unanimity, a partition
>> request could be exchanged among the online subset of users ("the
>> actives"). They decide to partition the pool by introducing a new layer of
>> transactions gathering the promised/off-chain outputs of the actives. The
>> set of outputs belonging to the passive users remains unchanged.
>>
>> The actives spend their Withdraw transactions `user_balance` outputs back
>> to a new intermediate Update transaction. This "intermediate" Update
>> transaction is free to re-distribute the pool balances among the active
>> users. To guarantee the unilateral withdraw ability of a partitioned-up
>> balance, the private components of the partitioned Withdraw transactions
>> should be revealed among the set of active users.
>>
>> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
>> Pool is at state N, Bob and Dave are offline. Alice and Caroll agree to
>> partition the pool, each of them owns a Withdraw transaction
>> ready-to-be-attached on the Update transaction N. They generate a new
>> partitioning Update transaction with two inputs spending respectively
>> Alice's Withdraw transaction `user_balance` output and Caroll's Withdraw
>> transaction `user-balance` output. From this partitioning Update
>> transaction, two new second-layer Withdraw ones are issued.
>>
>> Alice and Caroll reveal to each other the private components of their
>> first-layer Withdraw transactions, allowing to publish the full branch :
>> first-layer Update transaction, first-layer Withdraw transactions,
>> second-layer partitioning Update transaction, second-layer partitioned
>> Withdraw transaction. At that step, I think the partitioning should be
>> complete.
>>
>> Quickly, a safety issue arises with pool partitioning. A participant of
>> the active set A could equivocate the partition state by signing another
>> spend of her Withdraw transaction allocating her balance to an Update
>> transaction of a "covert" set of active users B.
>>
>> This equivocation exists because there is no ordering of the off-chain
>> spend of the Withdraw transactions and any Withdraw transaction can be
>> freely spent by its owner. This issue appears as similar to solving the
>> double-spend problem.
>>
>> Equivocation is a different case than multiple *parallel* partitions,
>> where there is no intersection between the partitioned balances. The
>> parallel partitions are still rooting from the same Update transaction N. I
>> think the safety of parallel partitions is yet to be explored.
>>
>> # Current solutions to the double-spend problem : Bitcoin base-layer &
>> Lightning Network
>>
>> Of course, the double-spend issue is already addressed on the Bitcoin
>> base-layer due to nodes consensus convergence on the most-proof-of-work
>> accumulated valid chain of blocks. While reorg can happen, a UTXO cannot be
>> spent twice on the same chain. This security model can be said to be
>> prophylactic, i.e an invalid block cannot be applied to a node's state and
>> should be rejected.
>>
>> The double-spend issue is also solved in its own way in payment channels.
>> If a transaction is published, of which the correctness has been revoked
>> w.r.t negotiated, private channel state, the wronged channel users must
>> react in consequence. This security model can be said to be corrective,
>> states updates are applied first on the global ledger then eventually
>> corrected.
>>
>> A solution to the pool partition equivocation issue appears as either
>> based on a prophylactic one or a corrective security model.
>>
>> Let's examine first, a reactive security model similar to LN-Penalty. At
>> pool partition proposals, the owners of the partitioned-up Withdraw
>> transactions could reveal a revocation secret enabling correction in case
>> of wrongdoing (e.g single-show signatures). However, such off-chain
>> revocation can be committed towards multiple sets of honest "active" users.
>> Only one equivocating balance spend can succeed, letting the remaining set
>> of honest users still be deprived of their expected partitioned balances.
>>
>> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
>> Alice contacts Bob to form a first partition, then Caroll to form a second
>> one, then Dave to form a last one. If she is successful in that
>> equivocation trick, she can *triple*-spend her balance against any goods or
>> out-of-pool payments.
>>
>> Assuming the equivocation is discovered once realized, Bob, Caroll and
>> Dave are all left with a branch of transactions all including Alice's
>> Withdraw one. However only one branch can be fully published, as a Withdraw
>> transaction can be played only once following the pool semantic.
>> Game-theory-wise, Bob, Caroll and Dave have an interest to enter in a fee
>> race to be the first to confirm and earn the Alice balance spend.
>>
>> The equivocation is only bounded by the maximal number of equivocating
>> sets one can form, namely the number of pool users. However, correction can
>> only be limited to the equivocated balance. Therefore, it appears that
>> corrective security models in the context of multi-party are always
>> producing an economic disequilibrium.
>>
>> An extension of this corrective model could be to require off-pool
>> collaterals locked-up, against which the revocation secret would be
>> revealed at partition generation. However, this fix is limited to the
>> collateral liquidity available. One collateral balance should be guaranteed
>> for each potential victim, thus the collateral liquidity should be equal to
>> the number of pool users multiplied by the equivocatable balance amount.
>>
>> It sounds like a more economic-efficient security model of the pool
>> partitioning can be established with a prophylactic technique.
>>
>> # Trusted coordinator
>>
>> A genuine solution could be to rely on a coordinator collecting the
>> partition declaration and order them canonically. The pool partition
>> candidates can then fetch them and decide their partitions acceptance
>> decisions on that. Of course, the coordinator is trusted and can drop or
>> dissimulate any partition, thus enabling partitioned balance equivocation.
>>
>> # Trust-minimized : Partition Statements
>>
>> A pool partition invalidity can be defined by the existence of two
>> second-layer Update transactions at the same state number spending the same
>> Withdraw transaction balance output. Each Update transaction signature can
>> be considered as a "partition statement". A user wishing to join a
>> partition should ensure there is no conflicting partition statement before
>> applying the partition to her local state.
>>
>> The open question is from where the conflict should be observed. A
>> partition statement log could be envisioned and monitored by pool users
>> before to accept any partition.
>>
>> I think multiple partition statement publication spaces can be drawn out,
>> with different trust-minization trade-offs.
>>
>> # Publication space : Distributed Bulletin Boards
>>
>> The set of "active" pool users could host their own boards of partition
>> statements. They would coordinate on the statement order through a
>> consensus algorithm (e.g Raft). For redundancy, a user can have multiple
>> board instances. If a user falls offline, they can fetch the statement
>> order from the other users boards.
>>
>> However, while this solution distributes the trust across all the other
>> users, it's not safe in case of malicious user coalitions agreeing among
>> themselves to drop a partition statement. Therefore, a user catching up
>> online can be feeded with an incorrect view of the existing partitions, and
>> thus enter into an equivocated partition.
>>
>> # Publication space : On-chain Authoritative Board
>>
>> Another solution could be to designate an authoritative UTXO at pool
>> setup. This UTXO could be spent by any user of the pool set (1-of-N) to a
>> covenanted transaction sending back to a Taproot output with the same
>> internal key. The Merkelized tree tweaked could be modified by the spender
>> to stamp the partition statements as leaves hashes. The statement data is
>> not committed in the leaves itself and the storage can be delegated to
>> out-of-band archive servers.
>>
>> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
>> Alice and Bob decide to start a partition, they commit a hash of the
>> partitioning Update transaction as a Taproot tree leaf and they spend the
>> pool authoritative UTXO. They also send a copy of the Update transaction to
>> an archive server.
>>
>> At a later time, Alice proposes to Caroll to start a partition. Caroll
>> follows the chain of transactions forming the on-chain authoritative board,
>> she fetches the merkle branches and leaves data payload from an archive
>> server, verifying the authenticity of the branches and payload. As Alice
>> has already published a partition statement spending her Withdraw, Caroll
>> should refuse the partition proposal.
>>
>> Even if a pool user goes offline, she can recover the correct partition
>> statement logs, as it has been committed in the chain from the
>> authoritative UTXO. If the statement data is not available from servers,
>> the pool user should not engage in partitions.
>>
>> Assuming the spend confirms in every block, this solution enables
>> partitions every 10min. The cost can be shared across pool instances, if
>> the authoritative signers set is made of multiple pool instances signers
>> sets. A threshold signature scheme could be used to avoid interactivity
>> beyond the aggregated key setup. However, batching across pool instances
>> increases the set of data to verify by the partition candidate users, which
>> could be a grievance for bandwidth-constrained clients.
>>
>> # Fiability of the Publication of Partition Statements
>>
>> Whatever ends up being used as a partition statement log, there is still
>> the question of the incentives of pool users to publish the partition
>> statements. A malicious user could act in coalition with the equivocating
>> entity to retain the publication of her partition statement. Thus, an
>> honest user would only be aware of her own partition statement and accept
>> the partition proposal from the will-be equivocating entity.
>>
>> I think that leveraging covenants a revocation mechanism could be
>> attached on any equivocating branch of transactions, allowing in the above
>> case a single honest user to punish the publication. While a revocation
>> mechanism does not work in case of multiple defrauded users, I believe the
>> existence of a revocation mechanism makes the formation of malicious
>> coalitions unsafe for their conjurers.
>>
>> Indeed, any user entering in the coalition is not guaranteed to be
>> blinded to other equivocating branches generated by the partition
>> initiator. Therefore, the publication of a partition statement by everyone
>> is holistically optimal to discover any equivocating candidate among the
>> pool users.
>>
>> Further research should establish the soundness of the partition
>> statement publication game-theory.
>>
>> # Writing the Partition Statements to a new Consensus Data Structure
>>
>> To avoid a solution relying on game-theory, a new consensus data
>> structure could be introduced to register and order the partition
>> statements. This off-chain contract register could be a Merkle tree, where
>> every leaf is a pool balance identified by a key. This register would be
>> established on-chain at the same time the pool is set up.
>>
>> Every time the pool is partitioned, the tree leaves would be updated with
>> the partition statement committed to. Only one partition could be
>> registered per user by state number. The publication branch would be
>> invalid if it doesn't point back to the corresponding contract register
>> tree entries. When the first-layer pool Update transaction is replaced, the
>> tree should transition to a blank state too.
>>
>> Beyond the high cost of yet-another softfork to introduce such consensus
>> data structure, the size of the witness to write into the contract register
>> could be so significant that the economic attractiveness of pool
>> partitioning is decreased in consequence.
>>
>> If you have read so far, thank you. And curious if anyone has more ideas
>> or thoughts on  the high interactivity issue ?
>>
>> Thanks Gleb for the review.
>>
>> Cheers,
>> Antoine
>>
>> [0] https://coinpool.dev/
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220509/b1aa5fee/attachment-0001.html>

From salvatore.ingala at gmail.com  Tue May 10 09:37:26 2022
From: salvatore.ingala at gmail.com (Salvatore Ingala)
Date: Tue, 10 May 2022 11:37:26 +0200
Subject: [bitcoin-dev] Wallet policies for descriptor wallets
In-Reply-To: <osdF1jSCUyGyaLZ6YytSB7ub1MwdbaP6PMCYEJZXmMRaSs4vS7bs_SZTErxZh_K7oLYLAtAqqgl0Vcdl1ftAusM_1DHSDHtz1kSUzqnmwsk=@protonmail.com>
References: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
 <osdF1jSCUyGyaLZ6YytSB7ub1MwdbaP6PMCYEJZXmMRaSs4vS7bs_SZTErxZh_K7oLYLAtAqqgl0Vcdl1ftAusM_1DHSDHtz1kSUzqnmwsk=@protonmail.com>
Message-ID: <CAMhCMoGbrgrXbUwUm0EiNWTKKx0oyr4=mqBCLPWMktHpwgnXhg@mail.gmail.com>

Hi Antoine and Billy,

Thank you for your comments and for looking into the proposal.

On Mon, 9 May 2022 at 12:36, darosior <darosior at protonmail.com> wrote:

> 1. The `<NUM;NUM>` optimization for the common usecase of using 2
> descriptors at different derivation indices
>    for receive and change. [1]
> 2. The `/**` optimization for the common usecase of `/<0;1>` for point 1).
>
> [...]
>
> I'm not so sure about the second point. Is another deviation from the
> standard worth it just for saving 3
> characters?
>

I agree with the concerns of both you and Billy on the `\**` syntax, and it
is certainly not a crucial part of the proposal, as it is arguably
redundant once `\<0;1>` is available.
I have been using it since before the `\<0;1>` syntax was proposed (afaik),
and I thought I would leave it mostly for the sake of optimizing the UX in
the most common use cases. I think that

    sh(sortedmulti(2, at 0/**, at 1/**, at 2/**))

is quite a lot more readable (especially on a small screen) than

    sh(sortedmulti(2, at 0/<0;1>/*, at 1/<0;1>/*, at 2/<0;1>/*))

Apart from the additional 5 characters *per placeholder*, there are a lot
more numbers to parse for the user.

Yet, I'm not too attached to the feature as it is probably not very useful
in taptrees. For the future, I expect further improvements will come from
the hardware wallets analyzing the wallet policy and recognizing the
commonly used patterns. No reason to show the full taptree of a complex
3-of-5 multisig setup ? you can just say "Taproot 3-of-5 multisig". Show
the full taptree policy should be reserved for the 1% of advanced use-cases
that are not in the catalogue.

Slightly off-topic, but my impression is that descriptors are outgrowing
their original scope (probably the reason for sipa's comments[1] on the
early proposals for multiple derivation paths in one descriptor).
I think there is a case to be made for keeping the language of descriptors
limited to represent either (1) a single output, or (2) a list of outputs
with the `/*` syntax; in this interpretation, the `/<m;n>` syntax would
entirely be on a separate layer (the `combo` descriptor[2] would also be
extraneous in this interpretation).
I tried to design the policy wallet language in a way that is agnostic to
these details of descriptor specs (since I target a _subset_ of
descriptors, it will work either way).

However, why does it need to be a change to the descriptor language? It
> looks a lot like something that needs
> to be handled at the application level with key aliasing.


Key aliasing is not part of descriptors; therefore, "descriptors with key
aliasing" are still a language on top of descriptors.

Adding key aliases will indeed be a great UX improvement, but in my opinion
it is better built on top of wallet policies, rather than within the
language itself.
Note that by separating the *wallet descriptor template* from the keys
themselves, such a feature is already facilitated. Moreover, wallet
policies separate the KEY expressions of descriptors into two semantically
relevant parts: only the xpub and its origin info goes into the "vector of
key information", while the receive/change part of the derivation is kept
in the placeholder (therefore in the descriptor template). Adding
restrictions is also useful: `xpub/1/2/3/4/<0;1>/5/6/*` might be valid
miniscript, but supporting this kind of thing would be (arguably)
unreasonable and a lot more complicated for hardware wallets; therefore,
placeholders and key informations are a lot more limited in the wallet
policy language than their miniscript counterpart.

While I understand that descriptors are designed with a maximum flexibility
mindset, a minimized feature set is very valuable for hardware wallets, and
I believe it can be done with little to no practical loss of use cases.
Restrictions can be lifted in future versions when the need arises.

I think to better suit the needs of both hardware and software wallets, you
need both the *extensions* and the *restrictions*. That's why I propose to
keep them separated, rather than suggesting changes to descriptors.

Unrelated question, since you mentioned `musig2` descriptors in this
> context. I thought Musig2 wasn't really
> feasible for hardware signing devices, especially stateless ones. Do you
> think/know whether it is actually
> possible for a HW to take part in a Musig2?
>

I certainly have some more homework to do on musig2, and for this proposal
I was only concerned with making sure the wallet policy language won't
break with future upgrades to descriptors.
Yet, as far as I understand , the complications for hardware wallets are
(1) possible lack of good quality randomness, and (2) need to keep state
during a signing session. Ledger signers have a hardware TRNG, and while
the design is generally stateless, there is flash memory that can be used
to store the secret nonce during a signing session (or, more likely, a few
parallel signing sessions). Therefore, I don't think there are technical
blockers for musig2.

Salvatore


[1] https://github.com/bitcoin/bitcoin/issues/17190#issuecomment-543845642
[2] https://github.com/bitcoin/bips/blob/master/bip-0384.mediawiki
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220510/98ebf626/attachment.html>

From rusty at rustcorp.com.au  Tue May 10 10:35:54 2022
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 10 May 2022 20:05:54 +0930
Subject: [bitcoin-dev] [PROPOSAL] OP_TX: generalized covenants reduced to
	OP_CHECKTEMPLATEVERIFY
Message-ID: <87h75xoet1.fsf@rustcorp.com.au>

Hi all,

	TL;DR: a v1 tapscript opcode for generic covenants, but
OP_SUCCESS unless it's used a-la OP_CHECKTEMPLATEVERIFY.  This gives an
obvious use case, with clean future expansion.  OP_NOP4 can be
repurposed in future as a shortcut, if experience shows that to be a
useful optimization.

(This proposal builds on Russell O'Connor's TXHASH[1], with Anthony
Towns' modification via extending the opcode[2]; I also notice on
re-reading that James Lu had a similar restriction idea[3]).

Details
-------

OP_TX, when inside v1 tapscript, is followed by 4 bytes of flags.
Unknown flag patterns are OP_SUCCESS, though for thoroughness some future
potential uses are documented here.  Note that pushing more than 1000
elements on the stack or an element more than 512 bytes will hit the
BIP-342 resource limits and fail.

Defined bits
------------

(Only those marked with * have to be defined for this soft fork; the
 others can have semantics later).

OPTX_SEPARATELY: treat fields separately (vs concatenating)
OPTX_UNHASHED: push on the stack without hashing (vs SHA256 before push)

- The first nicely sidesteps the lack of OP_CAT, and the latter allows
  OP_TXHASH semantics (and avoid stack element limits).

OPTX_SELECT_VERSION*: version
OPTX_SELECT_LOCKTIME*: nLocktime
OPTX_SELECT_INPUTNUM*: current input number
OPTX_SELECT_INPUTCOUNT*: number of inputs
OPTX_SELECT_OUTPUTCOUNT*: number of outputs

OPTX_INPUT_SINGLE: if set, pop input number off stack to apply to
		OPTX_SELECT_INPUT_*, otherwise iterate through all.
OPTX_SELECT_INPUT_TXID: txid
OPTX_SELECT_INPUT_OUTNUM: txout index
OPTX_SELECT_INPUT_NSEQUENCE*: sequence number
OPTX_SELECT_INPUT_AMOUNT32x2: sats in, as a high-low u31 pair
OPTX_SELECT_INPUT_SCRIPT*: input scriptsig
OPTX_SELECT_INPUT_TAPBRANCH: ?
OPTX_SELECT_INPUT_TAPLEAF: ?

OPTX_OUTPUT_SINGLE: if set, pop input number off stack to apply to
		OPTX_SELECT_OUTPUT_*, otherwise iterate through all.
OPTX_SELECT_OUTPUT_AMOUNT32x2*: sats out, as a high-low u31 pair
OPTX_SELECT_OUTPUT_SCRIPTPUBKEY*: output scriptpubkey

OPTX_SELECT_19...OPTX_SELECT_31: future expansion.

OP_CHECKTEMPLATEVERIFY is approximated by the following flags:
	OPTX_SELECT_VERSION
	OPTX_SELECT_LOCKTIME
	OPTX_SELECT_INPUTCOUNT
	OPTX_SELECT_INPUT_SCRIPT
	OPTX_SELECT_INPUT_NSEQUENCE
	OPTX_SELECT_OUTPUTCOUNT
	OPTX_SELECT_OUTPUT_AMOUNT32x2
	OPTX_SELECT_OUTPUT_SCRIPTPUBKEY
	OPTX_SELECT_INPUTNUM

All other flag combinations result in OP_SUCCESS.

Discussion
----------

By enumerating exactly what can be committed to, it's absolutely clear
what is and isn't committed (and what you need to think about!).

The bits which separate concatenation and hashing provide a simple
mechanism for template-style (i.e. CTV-style) commitments, or for
programatic treatment of individual elements (e.g. amounts, though the
two s31 style is awkward: a 64-bit push flag could be added in future).

The lack of double-hashing of scriptsigs and other fields means we
cannot simply re-use hashing done for SIGHASH_ALL.

The OP_SUCCESS semantic is only valid in tapscript v1, so this does not
allow covenants for v0 segwit or pre-segwit inputs.  If covenants prove
useful, dedicated opcodes can be provided for those cases (a-la
OP_CHECKTEMPLATEVERIFY).

Cheers,
Rusty.

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019813.html
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019819.html
[3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019816.html

From AdamISZ at protonmail.com  Tue May 10 12:31:00 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Tue, 10 May 2022 12:31:00 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
Message-ID: <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>

------- Original Message -------
On Sunday, May 1st, 2022 at 11:01, Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Hello ZmnSCPxj,
>
> This is an intended feature. I'm thinking that the same fidelity bond
> can be used to running a JoinMarket maker as well as a Teleport
> (Coinswap) maker.
>
> I don't believe it's abusable. It would be a problem if the same
> fidelity bond is used by two makers in the same application, but
> JoinMarket takers are already coded to check for this, and Teleport
> takers will soon as well. Using the same bond across different
> applications is fine.
>
> Best,
> CB
>

Hi Chris, Zmn, list,
I've noodled about this a few times in the past (especially when trying to figure out an LSAG style ring sig based FB for privacy, but that does not seem workable), and I can't decide the right perspective on it.

A user sacrifices X amount of time-value-of-money (henceforth TVOM) by committing in Joinmarket with FB1. He then uses the same FB1 in Teleport, let's say. If he gets benefit Y from using FB1 in Joinmarket, and benefit Z in Teleport, then presumably he'll only do it if (probabilistically) he thinks Y+Z > X.

But as an assessor of FB1 in Joinmarket, I don't know if it's also being used for Teleport, and more importantly, if it's being used somewhere else I'm not even aware of. Now I'm not an economist I admit, so I might not be intuit-ing this situation right, but it fees to me like the right answer is "It's fine for a closed system, but not an open one." (i.e. if the set of possible usages is not something that all participants have fixed in advance, then there is an effective Sybilling problem, like I'm, as an assessor, thinking that sacrificed value 100 is there, whereas actually it's only 15, or whatever.)

As I mentioned in https://github.com/JoinMarket-Org/joinmarket-clientserver/issues/993#issuecomment-1110784059 , I did wonder about domain separation tags because of this, and as I vaguely alluded to there, I'm really not sure about it.

If it was me I'd want to include domain separation via part of the signed message, since I don't see how it hurts? For scenarios where reuse is fine, reuse can still happen.

Cheers,
waxwing/AdamISZ

From alicexbt at protonmail.com  Tue May 10 13:40:37 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Tue, 10 May 2022 13:40:37 +0000
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
Message-ID: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>

Hi Bitcoin Developers,

There were some disagreements with speedy trial activation method recently and BIP 8 became controversial because of LOT earlier. I have tried to solve these two problems after reading some arguments for/against different activation methods by removing LOT from BIP 8 and calculating MUST_SIGNAL state based on threshold reached.

BIP draft with no code and some changes in BIP 8: https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1

State transitions diagram: https://i.imgur.com/dj4bFVK.png

This proposal removes lockinontimeout flag, activation never fails although MUST_SIGNAL can be longer if miners signaling does not reach the threshold. Longer period for MUST_SIGNAL state is useful for coordination if LOCKED_IN was not reached.

MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached and blocks that fail to signal in MUST_SIGNAL phase are invalid.

Example:

- This activation method is used for a soft fork
- Only 60% miners signaled readiness and timeout height was reached
- MUST_SIGNAL phase starts and will last for 4*2016 blocks
- LOCKED_IN and ACTIVE states remain same as BIP 8
- Soft fork is activated with a delay of 2 months

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220510/1d4ece3d/attachment.html>

From billy.tetrud at gmail.com  Tue May 10 15:09:45 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 10 May 2022 10:09:45 -0500
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <CALeFGL18ULkGW4UA_5Fod4PVoe_LeF5e97eZdJja-ctf2paLWQ@mail.gmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
 <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
 <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>
 <CALeFGL18ULkGW4UA_5Fod4PVoe_LeF5e97eZdJja-ctf2paLWQ@mail.gmail.com>
Message-ID: <CAGpPWDYUTCsSgirR7iNmbUw+cjEqHSymtzH4EtH=BQnZRjvgmQ@mail.gmail.com>

>  So if you don't want to receive restricted coins, just don't generate an
address with those restrictions embedded.

This is an interesting point that I for some reason haven't thought of
before. However...

> Unless governments can mandate that you generate these addresses AND
force you to accept funds bound by them for your services**, I don't
actually see how this is a real concern.

Actually, I think only the second is necessary. For example, if there was a
law that compelled giving a good or service if payment of a publicly
advertised amount was paid, and someone pays to an address that can be
shown is spendable by the merchant's keys in a way that the government
accepts, it doesn't matter whether the recipient can or has generated the
address.

Regardless I do think its still important to note that a government could
do that today using multisig.

> This is a reason to oppose legal tender laws for Bitcoin imo.

I agree.

On Mon, May 9, 2022 at 10:23 AM Keagan McClelland <
keagan.mcclelland at gmail.com> wrote:

> > > > To me the most scary one is visacoin, specially seeing what happened
> in canada and other places lately and the general censorship in the west,
> the supposed war on "misinformation" going on (really a war against truth
> imo, but whatever) it's getting really scary. But perhaps someone else can
> be more scared about a covenant to add demurrage fees to coins or
> something, I don't know.
> > > > https://bitcointalk.org/index.php?topic=278122
>
> > > This requires *recursive* covenants.
>
> > Actually, for practical use, any walled-garden requires *dynamic*
> covenants, not recursive covenants.
>
> There's actually also a very straight forward defense for those who do not
> want to receive "tainted" coins. In every covenant design I've seen to date
> (including recursive designs) it requires that the receiver generate a
> script that is "compliant" with the covenant provisions to which the sender
> is bound. The consequence of this is that you can't receive coins that are
> bound by covenants you weren't aware of*. So if you don't want to receive
> restricted coins, just don't generate an address with those restrictions
> embedded. As long as you can specify the spend conditions upon the receipt
> of your funds, it really doesn't matter how others are structuring their
> own spend conditions. So long as the verification of those conditions can
> be predictably verified by the rest of the network, all risk incurred is
> quarantined to the receiver of the funds. Worst case scenario is that no
> one wants to agree to those conditions and the funds are effectively burned.
>
> It's not hard to make the case that any time funds are being transferred
> between organizations with incompatible interests (external to a firm),
> that they will want to be completely free to choose their own spend
> conditions and will not wish to inherit the conditions of the spender.
> Correspondingly, any well implemented covenant contract will include
> provisions for escaping the recursion loop if some sufficiently high bar is
> met by the administrators of those funds. Unless governments can mandate
> that you generate these addresses AND force you to accept funds bound by
> them for your services**, I don't actually see how this is a real concern.
>
> *This requires good wallet tooling and standards but that isn't materially
> different than wallets experimenting with non-standard recovery policies.
>
> **This is a reason to oppose legal tender laws for Bitcoin imo.
>
> Keagan
>
> On Sun, May 8, 2022 at 11:32 AM Billy Tetrud via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> >  This requires *recursive* covenants.
>>
>> Actually, for practical use, any walled-garden requires *dynamic*
>> covenants, not recursive covenants. CTV can get arbitrarily close to
>> recursive covenants, because you can have an arbitrarily long string of
>> covenants. But this doesn't help someone implement visacoin because CTV
>> only allows a specific predefined iteration of transactions, meaning that
>> while "locked" into the covenant sequence, the coins can't be used in any
>> way like normal coins - you can't choose who you pay, the sequence is
>> predetermined.
>>
>> Even covenants that allow infinite recursion (like OP_TLUV and OP_CD
>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md>)
>> don't automatically allow for practical walled gardens. Recursion
>> definitely allows creating walled gardens, but those gardens would be
>> impractically static. You could add millions of potential addresses to send
>> to, which would "only" quadruple the size of your transactions, but if
>> anyone creates a new address you want to send to, you wouldn't be able to.
>> Everyone would have to have a single address whitelisted into every
>> government-bitcoin output. If someone lost their key and needs to create a
>> new wallet, suddenly no one would be able to pay them.
>>
>> In order to really build a wallet garden, infinite recursion isn't really
>> necessary nor sufficient. You need to be able to dynamically specify
>> destination addresses. For example, if you were a government that wants to
>> make a walled garden where you (the government) could confiscate the funds
>> whenever you wanted, you'd have to have a covenant that allows the end-user
>> to specify an arbitrary public key to send money to. The covenant might
>> require that user to send to another covenant that has a government spend
>> path, but also has a spend path for that user-defined public key. That way,
>> you (the government) could allow people to send to each other arbitrarily,
>> while still ensuring that you (the government) could spend the funds no
>> matter where they may have been sent. Even without recursive covenants, you
>> could have arbitrarily long chains of these, say 1 million long, where at
>> the end of the chain the user must send your coins back to the government
>> who can then send them back with another million-long chain of covenants to
>> work with.
>>
>> OP_CHECKOUTPUTVERIFY <https://fc16.ifca.ai/bitcoin/papers/MES16.pdf> can
>> do this kind of dynamicness, and OP_PUSHOUTPUTSTACK
>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/pos/bip-pushoutputstack.md> can
>> enable it for things like OP_TLUV and OP_CD. I personally think dynamic
>> covenants are a *good* thing, as it enables more secure wallet vaults,
>> among other things. And I'm not worried about a government creating a
>> in-bitcoin visa-coin. Why? Because they can already do it today. They have
>> been able to do it for 9 years already. How?
>>
>> Replace the covenant above with a multisig wallet. The government has 2
>> keys, you have 1 key. Every time you make a transaction, you request the
>> government's signature on it. The government then only signs if you're
>> sending to a wallet they approve of. They might only sign when you're
>> sending to another multisig wallet that the government has 2 of 3 keys for.
>> Its a very similar walled garden, where the only difference is that the
>> government needs to actively sign, which I'm sure wouldn't be a huge
>> challenge for the intrepid dictator of the land. You want to add
>> demurage fees? Easy, the government just spends the fee out of everyone's
>> wallets every so often.
>>
>> On the other hand, OP_CTV *cannot* be used for such a thing. No
>> combination of future opcodes can enable either recursion or dynamicness to
>> an OP_CTV call.
>>
>>
>>
>> On Sat, May 7, 2022 at 5:40 PM ZmnSCPxj via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Good morning Jorge,
>>>
>>> > I think people may be scared of potential attacks based on covenants.
>>> For example, visacoin.
>>> > But there was a thread with ideas of possible attacks based on
>>> covenants.
>>> > To me the most scary one is visacoin, specially seeing what happened
>>> in canada and other places lately and the general censorship in the west,
>>> the supposed war on "misinformation" going on (really a war against truth
>>> imo, but whatever) it's getting really scary. But perhaps someone else can
>>> be more scared about a covenant to add demurrage fees to coins or
>>> something, I don't know.
>>> > https://bitcointalk.org/index.php?topic=278122
>>>
>>> This requires *recursive* covenants.
>>>
>>> At the time the post was made, no distinction was seen between recursive
>>> and non-recursive covenants, which is why the post points out that
>>> covenants suck.
>>> The idea then was that anything powerful enough to provide covenants
>>> would also be powerful enough to provide *recursive* covenants, so there
>>> was no distinction made between recursive and non-recursive covenants (the
>>> latter was thought to be impossible).
>>>
>>> However, `OP_CTV` turns out to enable sort-of covenants, but by
>>> construction *cannot* provide recursion.
>>> It is just barely powerful enough to make a covenant, but not powerful
>>> enough to make *recursive* covenants.
>>>
>>> That is why today we distinguish between recursive and non-recursive
>>> covenant opcodes, because we now have opcode designs that provides
>>> non-recursive covenants (when previously it was thought all covenant
>>> opcodes would provide recursion).
>>>
>>> `visacoin` can only work as a recursive covenant, thus it is not
>>> possible to use `OP_CTV` to implement `visacoin`, regardless of your
>>> political views.
>>>
>>> (I was also misinformed in the past and ignored `OP_CTV` since I thought
>>> that, like all the other covenant opcodes, it would enable recursive
>>> covenants.)
>>>
>>>
>>> Regards,
>>> ZmnSCPxj
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220510/06d05ed0/attachment-0001.html>

From freedom at reardencode.com  Tue May 10 15:16:10 2022
From: freedom at reardencode.com (Brandon Black)
Date: Tue, 10 May 2022 08:16:10 -0700
Subject: [bitcoin-dev] [PROPOSAL] OP_TX: generalized covenants reduced
 to OP_CHECKTEMPLATEVERIFY
In-Reply-To: <87h75xoet1.fsf@rustcorp.com.au>
References: <87h75xoet1.fsf@rustcorp.com.au>
Message-ID: <YnqBuhbUGKmT+NW8@console>

Hi Rusty,

Thanks for this. Seems like a productive direction to explore.

To me, one of the biggest limitations of CTV is that the script is
specific to the amount of the input being spent. OP_TX makes it
possible, although clumsy, to emulate OP_IN_OUT_AMOUNT, which could be
combined with CTV emulation less OPTX_SELECT_OUTPUT_AMOUNT32x2 to allow
a single script to be reused. Given that potential, I wonder if
OPTX_SELECT_IN_OUT_AMOUNT32x2 would be worth adding to the initial set
of flags.

With that addition, a small script can be constructed for a relocatable,
batchable construction (eg. as a building block for vaults):

OPTX_SEPARATELY|OPTX_UNHASHED|OPTX_INPUTNUM OP_TX OP_DUP

OPTX_SELECT_VERSION|
OPTX_SELECT_LOCKTIME|
OPTX_SELECT_INPUT_SINGLE|
OPTX_SELECT_INPUT_SCRIPT|
OPTX_SELECT_INPUT_NSEQUENCE|
OPTX_SELECT_OUTPUT_SINGLE|
OPTX_SELECT_OUTPUT_SCRIPTPUBKEY|
OPTX_SELECT_IN_OUT_AMOUNT32x2 OP_TX <expectedhash> OP_EQUAL

* Additional inputs and change outputs can be added
  * Could commit to 0 fee and still be useful
* Arbitrary amounts can be sent to the same script
* There is no txid predictability (unlike CTV)
  * Anyone could rearrange such input/output pairs after broadcast
	* Not suitable for some uses
	* Potentially helpful for others

Best,

--Brandon

On 2022-05-10 (Tue) at 20:05:54 +0930, Rusty Russell via bitcoin-dev wrote:
> Hi all,
> 
> 	TL;DR: a v1 tapscript opcode for generic covenants, but
> OP_SUCCESS unless it's used a-la OP_CHECKTEMPLATEVERIFY.  This gives an
> obvious use case, with clean future expansion.  OP_NOP4 can be
> repurposed in future as a shortcut, if experience shows that to be a
> useful optimization.
> 
> (This proposal builds on Russell O'Connor's TXHASH[1], with Anthony
> Towns' modification via extending the opcode[2]; I also notice on
> re-reading that James Lu had a similar restriction idea[3]).
> 
> Details
> -------
> 
> OP_TX, when inside v1 tapscript, is followed by 4 bytes of flags.
> Unknown flag patterns are OP_SUCCESS, though for thoroughness some future
> potential uses are documented here.  Note that pushing more than 1000
> elements on the stack or an element more than 512 bytes will hit the
> BIP-342 resource limits and fail.
> 
> Defined bits
> ------------
> 
> (Only those marked with * have to be defined for this soft fork; the
>  others can have semantics later).
> 
> OPTX_SEPARATELY: treat fields separately (vs concatenating)
> OPTX_UNHASHED: push on the stack without hashing (vs SHA256 before push)
> 
> - The first nicely sidesteps the lack of OP_CAT, and the latter allows
>   OP_TXHASH semantics (and avoid stack element limits).
> 
> OPTX_SELECT_VERSION*: version
> OPTX_SELECT_LOCKTIME*: nLocktime
> OPTX_SELECT_INPUTNUM*: current input number
> OPTX_SELECT_INPUTCOUNT*: number of inputs
> OPTX_SELECT_OUTPUTCOUNT*: number of outputs
> 
> OPTX_INPUT_SINGLE: if set, pop input number off stack to apply to
> 		OPTX_SELECT_INPUT_*, otherwise iterate through all.
> OPTX_SELECT_INPUT_TXID: txid
> OPTX_SELECT_INPUT_OUTNUM: txout index
> OPTX_SELECT_INPUT_NSEQUENCE*: sequence number
> OPTX_SELECT_INPUT_AMOUNT32x2: sats in, as a high-low u31 pair
> OPTX_SELECT_INPUT_SCRIPT*: input scriptsig
> OPTX_SELECT_INPUT_TAPBRANCH: ?
> OPTX_SELECT_INPUT_TAPLEAF: ?
> 
> OPTX_OUTPUT_SINGLE: if set, pop input number off stack to apply to
> 		OPTX_SELECT_OUTPUT_*, otherwise iterate through all.
> OPTX_SELECT_OUTPUT_AMOUNT32x2*: sats out, as a high-low u31 pair
> OPTX_SELECT_OUTPUT_SCRIPTPUBKEY*: output scriptpubkey
> 
> OPTX_SELECT_19...OPTX_SELECT_31: future expansion.
> 
> OP_CHECKTEMPLATEVERIFY is approximated by the following flags:
> 	OPTX_SELECT_VERSION
> 	OPTX_SELECT_LOCKTIME
> 	OPTX_SELECT_INPUTCOUNT
> 	OPTX_SELECT_INPUT_SCRIPT
> 	OPTX_SELECT_INPUT_NSEQUENCE
> 	OPTX_SELECT_OUTPUTCOUNT
> 	OPTX_SELECT_OUTPUT_AMOUNT32x2
> 	OPTX_SELECT_OUTPUT_SCRIPTPUBKEY
> 	OPTX_SELECT_INPUTNUM
> 
> All other flag combinations result in OP_SUCCESS.
> 
> Discussion
> ----------
> 
> By enumerating exactly what can be committed to, it's absolutely clear
> what is and isn't committed (and what you need to think about!).
> 
> The bits which separate concatenation and hashing provide a simple
> mechanism for template-style (i.e. CTV-style) commitments, or for
> programatic treatment of individual elements (e.g. amounts, though the
> two s31 style is awkward: a 64-bit push flag could be added in future).
> 
> The lack of double-hashing of scriptsigs and other fields means we
> cannot simply re-use hashing done for SIGHASH_ALL.
> 
> The OP_SUCCESS semantic is only valid in tapscript v1, so this does not
> allow covenants for v0 segwit or pre-segwit inputs.  If covenants prove
> useful, dedicated opcodes can be provided for those cases (a-la
> OP_CHECKTEMPLATEVERIFY).
> 
> Cheers,
> Rusty.
> 
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019813.html
> [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019819.html
> [3] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019816.html
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
--Brandon

From billy.tetrud at gmail.com  Tue May 10 15:31:17 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 10 May 2022 10:31:17 -0500
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
In-Reply-To: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
References: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
Message-ID: <CAGpPWDbHUqf5_APr3e_hr7npo=ObJvLuWooJc5azMDCDOVSfOA@mail.gmail.com>

I think this is a useful proposal. There are certainly things about BIP9
that BIP8 fixes. I believe taproot's speedy trial did kind of a hybrid, but
a BIP spec was never produced for it afaik. A possibly unhelpful comment:

> minimum_activation_height

I think a minor improvement would be to specify this as
minimum_activation_blocks, ie a number of blocks passed the start_height.
Slightly easier to reason about and change when necessary. I proposed
semantics like that here
<https://github.com/fresheneesz/bip-trinary-version-signaling/blob/master/bip-trinary-version-bits.md>
.

In any case, I'll give this a concept ACK. I would very much like future
soft forks to use a previously specified activation mechanism rather than
rolling out a rushed unspeced thing as part of the (very orthogonal) soft
fork implementation.

On Tue, May 10, 2022 at 9:02 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Bitcoin Developers,
>
> There were some disagreements with speedy trial activation method recently
> and BIP 8 became controversial because of LOT earlier. I have tried to
> solve these two problems after reading some arguments for/against different
> activation methods by removing LOT from BIP 8 and calculating MUST_SIGNAL
> state based on threshold reached.
>
> BIP draft with no code and some changes in BIP 8:
> https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1
>
> State transitions diagram: https://i.imgur.com/dj4bFVK.png
>
> This proposal removes lockinontimeout flag, activation never fails
> although MUST_SIGNAL can be longer if miners signaling does not reach the
> threshold. Longer period for MUST_SIGNAL state is useful for coordination
> if LOCKED_IN was not reached.
>
> MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached and
> blocks that fail to signal in MUST_SIGNAL phase are invalid.
>
> Example:
>
> - This activation method is used for a soft fork
> - Only 60% miners signaled readiness and timeout height was reached
> - MUST_SIGNAL phase starts and will last for 4*2016 blocks
> - LOCKED_IN and ACTIVE states remain same as BIP 8
> - Soft fork is activated with a delay of 2 months
>
>
> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220510/af6e90ce/attachment.html>

From ZmnSCPxj at protonmail.com  Tue May 10 16:45:19 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 10 May 2022 16:45:19 +0000
Subject: [bitcoin-dev] Conjectures on solving the high interactivity
	issue in payment pools and channel factories
In-Reply-To: <CAGpPWDa2wofye=KSq-vVNS0SOU34st9wm-hMhiYzGLTKMGuP5w@mail.gmail.com>
References: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
 <CAGpPWDa2wofye=KSq-vVNS0SOU34st9wm-hMhiYzGLTKMGuP5w@mail.gmail.com>
Message-ID: <mcikQmSFmiZw6Tq1GocybVcjGHNc-u9cP1aoZpJU-HEfgcqXXi1WhZSnEDMtEz3GfqAJGWpfZXjEBmsCXNSyLAgVNNcsSklERd-DJ8KeocE=@protonmail.com>

Good morning Billy,


> Very interesting exploration. I think you're right that there are issues with the kind of partitioning you're talking about. Lightning works because all participants sign all?offchain states (barring data loss). If a participant can be excluded from needing to agree to a new state, there must be an additional mechanism to ensure the relevant state for that participant isn't changed to their detriment.?
>
> To summarize my below email, the two techniques I can think for solving this problem are:
>
> A. Create sub-pools when the whole group is live that can be used by the sub- pool?participants later without the whole group's involvement. The whole group is needed to change the whole group's state (eg close or open sub-pools), but sub-pool?states don't need to involve the whole group.

Is this not just basically channel factories?

To reduce the disruption if any one pool participant is down, have each sub-pool have only 2 participants each.
More participants means that the probability that one of them is offline is higher, so you use the minimum number of participants in the sub-pool: 2.
This makes any arbitrary sub-pool more likely to be usable.

But a 2-participant pool is a channel.
So a large multiparticipant pool with sub-pools is just a channel factory for a bunch of channels.

I like this idea because it has good tradeoffs, so channel factories ho.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Tue May 10 16:54:31 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 10 May 2022 16:54:31 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
Message-ID: <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>

Good morning waxwing,

> ------- Original Message -------
> On Sunday, May 1st, 2022 at 11:01, Chris Belcher via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > Hello ZmnSCPxj,
> > This is an intended feature. I'm thinking that the same fidelity bond
> > can be used to running a JoinMarket maker as well as a Teleport
> > (Coinswap) maker.
> > I don't believe it's abusable. It would be a problem if the same
> > fidelity bond is used by two makers in the same application, but
> > JoinMarket takers are already coded to check for this, and Teleport
> > takers will soon as well. Using the same bond across different
> > applications is fine.
> > Best,
> > CB
>
> Hi Chris, Zmn, list,
> I've noodled about this a few times in the past (especially when trying to figure out an LSAG style ring sig based FB for privacy, but that does not seem workable), and I can't decide the right perspective on it.
>
> A user sacrifices X amount of time-value-of-money (henceforth TVOM) by committing in Joinmarket with FB1. He then uses the same FB1 in Teleport, let's say. If he gets benefit Y from using FB1 in Joinmarket, and benefit Z in Teleport, then presumably he'll only do it if (probabilistically) he thinks Y+Z > X.
>
> But as an assessor of FB1 in Joinmarket, I don't know if it's also being used for Teleport, and more importantly, if it's being used somewhere else I'm not even aware of. Now I'm not an economist I admit, so I might not be intuit-ing this situation right, but it fees to me like the right answer is "It's fine for a closed system, but not an open one." (i.e. if the set of possible usages is not something that all participants have fixed in advance, then there is an effective Sybilling problem, like I'm, as an assessor, thinking that sacrificed value 100 is there, whereas actually it's only 15, or whatever.)
>
> As I mentioned in https://github.com/JoinMarket-Org/joinmarket-clientserver/issues/993#issuecomment-1110784059 , I did wonder about domain separation tags because of this, and as I vaguely alluded to there, I'm really not sure about it.
>
> If it was me I'd want to include domain separation via part of the signed message, since I don't see how it hurts? For scenarios where reuse is fine, reuse can still happen.

Ah, yes, now I remember.
I discussed this with Tamas as well in the past and that is why we concluded that in defiads, each UTXO can host at most one advertisement at any one time.
In the case of defiads there would be a sequence counter where a higher-sequenced advertisement would replace lower-sequenced advertisement, so you could update, but at any one time, for a defiads node, only one advertisement per UTXO could be used.
This assumed that there would be a defiads network with good gossip propagation so our thinking at the time was that a higher-sequenced advertisement would quickly replace lower-sequenced ones on the network.
But it is simpler if such replacement would not be needed, and you could then commit to the advertisement directly on the UTXO via a tweak.

Each advertisement would also have a specific application ID that it applied to, and applications on top of defiads would ask the local defiads node to give it the ads that match a specific application ID, so a UTXO could only be used for one application at a time.
This would be equivalent to domain separation tags that waxwing mentions.

Regards,
ZmnSCPxj


From gsanders87 at gmail.com  Tue May 10 18:53:14 2022
From: gsanders87 at gmail.com (Greg Sanders)
Date: Tue, 10 May 2022 14:53:14 -0400
Subject: [bitcoin-dev] Bringing a nuke to a knife fight: Transaction
 introspection to stop RBF pinning
Message-ID: <CAB3F3Dtp7YQBhLJQbCLpSKau8Hj=5gN4yuGCFN=u=6e1o6o=dA@mail.gmail.com>

Hello devs,

I've had this thought rattling around and thought it was worth putting to a
wider audience since
I haven't really seen it in other contexts. I've been working on eltoo
designs for Elements and
eventual inclusion into Bitcoin. With that in mind there's been a
reasonable amount of discussion
on the remaining unknowns on how well eltoo could work. To me the biggest
issue is BIP125 rule#3.

To quote:"The replacement transaction pays an absolute fee of at least the
sum paid by the original
transactions."

In the ANYONECANPAY-like scenarios like eltoo that require "bring your own
fees", this essentially
means the counterparty(or anyone, if you don't include chaperone sigs[0])
can post a series of low
feerate update transactions, or the final update, with bloated
inputs/outputs(depending on flags),
and this results in illicit HTLC timeouts as the channel is unable to be
settled in time, unless you fork
over quite a few sats. This is a problem in both "vanilla" eltoo[1] from
the original paper, as well as the
"layered commitments" style of eltoo[2]. This problem is highly reminiscent
of the ANYONECANPAY
pinning that others have discussed for vaults and other usecases, in that
anyone can include new
inputs(and sometimes outputs) to make the overall feerate lower. To
promptly get the final transactions
settled, you are forced to over-pay, and essentially refund your griefing
counterparty by knocking their
inputs out of the mempool.

Fixing BIP125 rule#3 would be great. It's also a while out at a minimum.

There are thoughts on how to mitigate some cases[3] of this pinning using
policy, and could be extended
to cover this particular pinning case(restrict both transaction weight AND
the weight of the descendant
package, or maybe just include the txns weight in the original idea?). This
might be the simplest idea,
if it ends up being deemed incentive compatible and deployed.

In case the above is not incentive compatible, we can use more drastic
measures. Another tactic would
be to use transaction introspection opcodes to smooth around these policy
issues.

Elements has its own set of transaction introspection codes[4], but fairly
standard introspection codes
seem to be sufficient.

This example is using Rusty's quite recent OP_TX proposal[5] with a single
extension but as mentioned
before it's all fairly standard. The actual eltoo-enabling opcode
implementation is basically orthogonal
to this problem, so I'm simply focusing on restricting the size of the
transaction package being
submitted to mempools.

For simplicity of a working example, we'll assume a set of "state" outputs
that are continuously being spent
off-chain and sent to a committed set of outputs. In vanilla eltoo case
this corresponds to the first
input and output you typically see in diagrams. The state transitions
include no fees themselves,
sending inputs of sum value N to outputs that sum to the value of N.
Vanilla eltoo uses SIGHASH_SINGLE
to bind just the first input/ouput pair. To post on-chain, we will need to
include at least one input,
and likely an output for change.

We add OPTX_SELECT_WEIGHT(pushes tx weight to stack, my addition to the
proposal) to the "state" input's script.
This is used in the update transaction to set the upper bound on the final
transaction weight.
In this same input, for each contract participant, we also conditionally
commit to the change output's scriptpubkey
via OPTX_SELECT_OUTPUT_SCRIPTPUBKEY and OPTX_SELECT_OUTPUTCOUNT==2. This
means any participant can send change back
to themselves, but with a catch. Each change output script possibility in
that state input also includes a 1 block
CSV to avoid mempool spending to reintroduce pinning. This allows the
change value to be anything, contra to
what SIGHASH_ALL would give you instead.

With this setup, you can't CPFP-spend the fee change outputs you create,
but you can RBF as much as
you'd like by RBFing at higher feerates, using any number of inputs you'd
like provided the total tx
weight doesn't exceed the OPTX_SELECT_WEIGHT argument.

With more engineering we can re-enable CPFP of this change output as well.
Handwaves here, but we could
encumber change outputs to either the aformentioned 1 block CSV encumbered
outputs or one to another
OPTX_SELECT_WEIGHT, recursively. This would allow each counterparty to CPFP
N times, each transaction
a maximum weight, and use the 1 block CSV as an "escape hatch" to get their
fee output back out from
the covenant structure. We could mix and match strategies here as well
allowing bigger transactions at
each step, or more steps. I suspect you'd want a single weight-bound CPFP
that can later be RBF'd any
number of times under this same weight limit.

TL;DR: Mempool is hard, let's use transaction weight, output count, and
output scriptpubkey,
and ??? introspection to avoid solving life's hard problems.

0:
https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-May/001994.html
1: https://blockstream.com/eltoo.pdf
2:
https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html
3:
https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff?permalink_comment_id=4058140#gistcomment-4058140
4:
https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md
5:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020450.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220510/ab9b8fc8/attachment.html>

From AdamISZ at protonmail.com  Tue May 10 19:03:16 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Tue, 10 May 2022 19:03:16 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
 <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
Message-ID: <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>

------- Original Message -------
On Tuesday, May 10th, 2022 at 17:54, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Good morning waxwing,
<snip>
>
> Ah, yes, now I remember.
> I discussed this with Tamas as well in the past and that is why we concluded that in defiads, each UTXO can host at most one advertisement at any one time.
> In the case of defiads there would be a sequence counter where a higher-sequenced advertisement would replace lower-sequenced advertisement, so you could update, but at any one time, for a defiads node, only one advertisement per UTXO could be used.
> This assumed that there would be a defiads network with good gossip propagation so our thinking at the time was that a higher-sequenced advertisement would quickly replace lower-sequenced ones on the network.
> But it is simpler if such replacement would not be needed, and you could then commit to the advertisement directly on the UTXO via a tweak.
>
> Each advertisement would also have a specific application ID that it applied to, and applications on top of defiads would ask the local defiads node to give it the ads that match a specific application ID, so a UTXO could only be used for one application at a time.
> This would be equivalent to domain separation tags that waxwing mentions.
>
> Regards,
> ZmnSCPxj
>

I suppose ultimately this brings up the question of the scope of this BIP. The abstract points out that the BIP contains both a definition of address derivation, but also how to sign fidelity bond certificates.

My feeling is that the latter might be better not included? I note that the 'Motivation' section gives motivation for standardisation of derivation (this includes things like time schedule), but not the second area - certificate signing. I think the second area is much more tricky, but much more to the point is, isn't it the case that that second area, can be interpreted without consensus between wallet developers? So say you were a hardware wallet provider, or a "node in a box" provider - your customers want you to provide the ability move funds around, including e.g. moving funds out of an old Joinmarket wallet (in which say there is a now expired timelock address utxo) by just entering its BIP39 seed. If this BIP addresses that, it should be enough.

I don't doubt that there's gains to be had from a broader community discussing and agreeing the details of how to create a fidelity bond certificate, but it's a separate, and more difficult, task.

Cheers,
waxwing/AdamISZ

From AdamISZ at protonmail.com  Tue May 10 19:28:05 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Tue, 10 May 2022 19:28:05 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
 <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
 <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>
Message-ID: <PFBgbTn4_7JXQaRMlMjZDVrGBIr4OKfMK1ftW38cY-8Qu6tm_GllxDOWEj7K4zHkmQz9jA9NO_9rT_UzTSw9rr3RneEKTNhz826LmEIWF7w=@protonmail.com>

> I suppose ultimately this brings up the question of the scope of this BIP. The abstract points out that the BIP contains both a definition of address derivation, but also how to sign fidelity bond certificates.
>
> My feeling is that the latter might be better not included? I note that the 'Motivation' section gives motivation for standardisation of derivation (this includes things like time schedule), but not the second area - certificate signing. I think the second area is much more tricky, but much more to the point is, isn't it the case that that second area, can be interpreted without consensus between wallet developers? So say you were a hardware wallet provider, or a "node in a box" provider - your customers want you to provide the ability move funds around, including e.g. moving funds out of an old Joinmarket wallet (in which say there is a now expired timelock address utxo) by just entering its BIP39 seed. If this BIP addresses that, it should be enough.
>
> I don't doubt that there's gains to be had from a broader community discussing and agreeing the details of how to create a fidelity bond certificate, but it's a separate, and more difficult, task.
>
> Cheers,
> waxwing/AdamISZ

Further to that last point, as the BIP draft currently says:

" Almost all wallets implementing this standard can use their
already-existing "Sign Message" function to sign the certificate
message. As the certificate message itself is always an ascii string,
the wallet may not need to specially implement this section at all but
just rely on users copypasting their certificate message into the
already-existing "Sign Message" user interface. This works as long as
the wallet knows how to use the private key of the timelocked address
for signing messages."

So, isn't that an argument that we don't need to specify the certificate message format here?

On the other hand, I can hardly disagree that it's worth presenting a kind of 'default' way of doing it. But I fear it is not at all simple to decide what a secure, general format should be (as per the discussion we started having here about domain separation tags).

Cheers,
waxwing/AdamISZ

From vjudeu at gazeta.pl  Wed May 11 10:57:01 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Wed, 11 May 2022 12:57:01 +0200
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <6pDae6X_tAfMTldPPsad5CSHPF98NVbTf06JxRCs7RqJGyrOqLALsDHHa_3C5DbbfpAVnzLMWCn-7e0FwQO-TOk4XxWYIiaYomuA9NJjkEQ=@protonmail.com>
Message-ID: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>

> Looks like `OP_CAT` is not getting enabled until after we are reasonably sure that recursive covenants are not really unsafe.

Maybe we should use OP_SUBSTR instead of OP_CAT. Or even better: OP_SPLIT. Then, we could have OP_SPLIT <n> <pos1> <pos2> ... <posN> that would split a string N times (so there will be N+1 pieces). Or we could have just OP_SPLIT <pos> to split one string into two. Or maybe OP_2SPLIT and OP_3SPLIT, just to split into two or three pieces (as we have OP_2DUP and OP_3DUP). I think OP_SUBSTR or OP_SPLIT is better than OP_CAT, because then things always get smaller and we can be always sure that we will have one byte as the smallest unit in our Script.

On 2022-05-08 04:20:19 user ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Good morning shesek,

> On Sat, May 7, 2022 at 5:08 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > * Even ***with*** `OP_CAT`, the following will enable non-recursive covenants without enabling recursive covenants:
> >  * `OP_CTV`, ...
> > * With `OP_CAT`, the following would enable recursive covenants:
> >  * `OP_CHECKSIGFROMSTACK`, ...
>
> Why does CTV+CAT not enable recursive covenants while CSFS+CAT does?
>
> CTV+CAT lets you similarly assert against the outputs and verify that they match some dynamically constructed script.
>
> Is it because CTV does not let you have a verified copy of the input's prevout scriptPubKey on the stack [0], while with OP_CSFS you can because the signature hash covers it?
>
> But you don't actually need this for recursion. Instead of having the user supply the script in the witness stack and verifying it against the input to obtain the quine, the script can simply contain a copy of itself as an initial push (minus this push). You can then reconstruct the full script quine using OP_CAT, as a PUSH(<script>) followed by the literal <script>.

    <OP_PUSH_length-of-script> OP_SWAP OP_DUP OP_CAT OP_CAT <rest of script...>

Ha, yes, looks like you are correct here.

`OP_CAT` makes *all* covenant opcodes recursive, because you can always quine using `OP_CAT`.

By itself it does not make recursive covenants, but with probably any opcode it would.

Looks like `OP_CAT` is not getting enabled until after we are reasonably sure that recursive covenants are not really unsafe.

Regards,
ZmnSCPxj
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From ZmnSCPxj at protonmail.com  Wed May 11 11:42:10 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 11 May 2022 11:42:10 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
Message-ID: <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>

Good morning vjudeu,


> > Looks like `OP_CAT` is not getting enabled until after we are reasonably sure that recursive covenants are not really unsafe.
>
> Maybe we should use OP_SUBSTR instead of OP_CAT. Or even better: OP_SPLIT. Then, we could have OP_SPLIT <n> <pos1> <pos2> ... <posN> that would split a string N times (so there will be N+1 pieces). Or we could have just OP_SPLIT <pos> to split one string into two. Or maybe OP_2SPLIT and OP_3SPLIT, just to split into two or three pieces (as we have OP_2DUP and OP_3DUP). I think OP_SUBSTR or OP_SPLIT is better than OP_CAT, because then things always get smaller and we can be always sure that we will have one byte as the smallest unit in our Script.

Unfortunately `OP_SUBSTR` can be used to synthesize an effective `OP_CAT`.

Instead of passing in two items on the witness stack to be `OP_CAT`ted together, you instead pass in the two items to concatenate, and *then* the concatenation.
Then you can synthesize a SCRIPT which checks that the supposed concatenation is indeed the two items to be concatenated.

Recursive covenants DO NOT arise from the increasing amounts of memory the trivial `OP_DUP OP_CAT OP_DUP OP_CAT` repetition allocates.

REMEMBER: `OP_CAT` BY ITSELF DOES NOT ENABLE COVENANTS, WHETHER RECURSIVE OR NOT.

Instead, `OP_CAT` enable recursive covenants (which we are not certain are safe) because `OP_CAT` allows quining to be done.
Quining is a technique to pass a SCRIPT with a copy of its code, so that it can then enforce that the output is passed to the exact same input SCRIPT.

`OP_SUBSTR` allows a SCRIPT to validate that it is being passed a copy of itself and that the complete SCRIPT contains its copy as an `OP_PUSH` and the rest of the SCRIPT as actual code.
This is done by `OP_SUBSTR` the appropriate parts of the supposed complete SCRIPT and comparing them to a reference value we have access to (because our own SCRIPT was passed to us inside an `OP_PUSH`).

   # Assume that the witness stack top is the concatenation of
   #   `OP_PUSH`, the SCRIPT below, then the`SCRIPT below.
   # Assume this SCRIPT is prepended with an OP_PUSH of our own code.
   OP_TOALTSTACK # save our reference
   OP_DUP 1 <scriptlength> OP_SUBSTR # Get the OP_PUSH argument
   OP_FROMALTSTACK OP_DUP OP_TOALTSTACK # Get our reference
   OP_EQUALVERIFY # check they are the same
   OP_DUP <1 + scriptlength> <scriptlength> OP_SUBSTR # Get the SCRIPT body
   OP_FROMALTSTACK # Get our reference
   OP_EQUALVERIFY # check they are the same
   # At this point, we have validated that the top of the witness stack
   # is the quine of this SCRIPT.
   # TODO: validate the `OP_PUSH` instruction, left as an exercise for the
   # reader.

Thus, `OP_SUBSTR` is enough to enable quining and is enough to implement recursive covenants.

We cannot enable `OP_SUBSTR` either, unless we are reasonably sure that recursive covenants are safe.

(FWIW recursive covenants are probably safe, as they are not in fact Turing-complete, they are a hair less powerful, equivalent to the total functional programming with codata.)

Regards,
ZmnSCPxj

From alicexbt at protonmail.com  Wed May 11 15:15:15 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Wed, 11 May 2022 15:15:15 +0000
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
In-Reply-To: <CAGpPWDbHUqf5_APr3e_hr7npo=ObJvLuWooJc5azMDCDOVSfOA@mail.gmail.com>
References: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
 <CAGpPWDbHUqf5_APr3e_hr7npo=ObJvLuWooJc5azMDCDOVSfOA@mail.gmail.com>
Message-ID: <k_QSGEzNPna1m81VnNhvzXE1e6asLJwXOslQNRTOs6Sqv2BG9K3t0UznguMpoeB11V3I4by5QxbNpyWlRTjtGrO8Y_nlGOaO03Qj-2H9a7A=@protonmail.com>

Hi Billy,

Thanks for the feedback. I agree with everything and?bip-trinary-version-signaling looks interesting.

> A primary difference from both BIP8 and BIP9 is that this proposal uses tri-state version signaling (rather than binary version bits) that can encode both active support as well as active opposition to an active soft fork.


I think 'support' and 'opposition' can be replaced with readiness. Miners should not consider signaling as voting.

> The meaning for each ternary value is as follows:


0 - No signal
1 - Ready for new consensus rules
2 - Not ready for new consensus rules

The concept of a minimum and maximum threshold sounds intriguing, and I'm interested to read what other developers have to say about it.

Concept ACK on removing LOT, using tri-state version signaling,?min/max threshold and required threshold calculation.


/dev/fd0

Sent with ProtonMail secure email.
------- Original Message -------
On Tuesday, May 10th, 2022 at 9:01 PM, Billy Tetrud billy.tetrud at gmail.com wrote:



> I think this is a useful proposal. There are certainly things about BIP9 that BIP8 fixes. I believe taproot's speedy trial did kind of a hybrid, but a BIP spec was never produced for it afaik. A possibly unhelpful comment:
>
> > minimum_activation_height
> > I think a minor improvement would be to specify this as minimum_activation_blocks, ie a number of blocks passed the start_height. Slightly easier to reason about and change when necessary. I proposed semantics like that here.
> > In any case, I'll give this a concept ACK. I would very much like future soft forks to use a previously specified activation mechanism rather than rolling out a rushed unspeced thing as part of the (very orthogonal) soft fork implementation.
> > On Tue, May 10, 2022 at 9:02 AM alicexbt via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > Hi Bitcoin Developers,
> >
> > There were some disagreements with speedy trial activation method recently and BIP 8 became controversial because of LOT earlier. I have tried to solve these two problems after reading some arguments for/against different activation methods by removing LOT from BIP 8 and calculating MUST_SIGNAL state based on threshold reached.
> >
> > BIP draft with no code and some changes in BIP 8: https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1
> >
> > State transitions diagram: https://i.imgur.com/dj4bFVK.png
> >
> > This proposal removes lockinontimeout flag, activation never fails although MUST_SIGNAL can be longer if miners signaling does not reach the threshold. Longer period for MUST_SIGNAL state is useful for coordination if LOCKED_IN was not reached.
> >
> > MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached and blocks that fail to signal in MUST_SIGNAL phase are invalid.
> >
> > Example:
> >
> > - This activation method is used for a soft fork
> > - Only 60% miners signaled readiness and timeout height was reached
> > - MUST_SIGNAL phase starts and will last for 4*2016 blocks
> > - LOCKED_IN and ACTIVE states remain same as BIP 8
> > - Soft fork is activated with a delay of 2 months
> >
> > /dev/fd0
> >
> > Sent with ProtonMail secure email._______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From alicexbt at protonmail.com  Wed May 11 15:25:31 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Wed, 11 May 2022 15:25:31 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <629505ec-81ba-013d-43a0-009d61fada23@gazeta.pl>
References: <629505ec-81ba-013d-43a0-009d61fada23@gazeta.pl>
Message-ID: <b4X11F5edHpTf3LtKIQ53TOvUYP7l4AS689gAveWrDpfoeCC_5X8GzxoN8esnd0InoC4gAP46OX-YhxQoBp6nVfolMpNRkkk4DGqoLH2VDg=@protonmail.com>

Hi vjudeu,

> It can be changed by using different sighashes, for example, it is possible to create a "negative fee transaction", where all transaction costs are paid by receiver. Using SIGHASH_SINGLE | SIGHASH_ANYONECANPAY with a higher amount in outputs than inputs is enough to do that, see testnet3 transaction 495d2007ae8b741c70c3d278c02ce03702223b9675e954ecabbb634c6cd5bf40.

This transaction has 2 inputs: 0.00074 tBTC and 0.00073 tBTC (0.00074 + 0.00073 = 0.00147) which is more than output amount 0.001 tBTC

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.
------- Original Message -------
On Saturday, May 7th, 2022 at 9:22 AM, vjudeu via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:

>> Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.
>
> We have TapScript for that. OP_CAT is defined as OP_SUCCESS, it can be re-enabled in a soft-fork way. For now, OP_CAT in TapScript simply means "anyone can move those coins", so adding some restrictions is all we need to re-enable this opcode. Introducing OP_CAT2 is not needed at all, unless it will be totally different, but then it should not be named as OP_CAT2, but rather as OP_SOMETHING_ELSE, it depends how different it will be from OP_CAT.
>
>> OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...
>
> So we can use OP_SUBSTR instead. Maybe even OP_SPLIT will be enough, if data expansion is the only problem, then we can focus on getting it smaller. Or better, we could use OP_FIND that would return true/false answer if element A is a part of element B, when we do byte-to-byte comparison. In general, we can use many different string-based functions to do the same things, we can choose something that will not exponentially explode as OP_CAT.
>
>> It was considered unfair that the sender is paying for the security of the receiver.
>
> It can be changed by using different sighashes, for example, it is possible to create a "negative fee transaction", where all transaction costs are paid by receiver. Using SIGHASH_SINGLE | SIGHASH_ANYONECANPAY with a higher amount in outputs than inputs is enough to do that, see testnet3 transaction 495d2007ae8b741c70c3d278c02ce03702223b9675e954ecabbb634c6cd5bf40.
>
> On 2022-05-07 05:06:46 user ZmnSCPxj via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>
>> Good morning Jorge,
>
>> OP_CAT was removed. If I remember correctly, some speculated that perhaps it was removed because it could allow covenants.I don't remember any technical concern about the OP besides enabling covenants.Before it was a common opinion that covenants shouldn't be enabled in bitcoin because, despite having good use case, there are some nasty attacks that are enabled with them too. These days it seems the opinion of the benefits being worth the dangers is quite generalized. Which is quite understandable given that more use cases have been thought since then.
>
> I think the more accurate reason for why it was removed is because the following SCRIPT of N size would lead to 2^N memory usage:
>
> OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...
>
> In particular it was removed at about the same time as OP_MUL, which has similar behavior (consider that multiplying two 32-bit numbers results in a 64-bit number, similar to OP_CATting a vector to itself).
>
> OP_CAT was removed long before covenants were even expressed as a possibility.
>
> Covenants were first expressed as a possibility, I believe, during discussions around P2SH.
> Basically, at the time, the problem was this:
>
> * Some receivers wanted to use k-of-n multisignature for improved security.
> * The only way to implement this, pre-P2SH, was by putting in the scriptPubKey all the public keys.
> * The sender is the one paying for the size of the scriptPubKey.
> * It was considered unfair that the sender is paying for the security of the receiver.
>
> Thus, OP_EVAL and the P2SH concept was conceived.
> Instead of the scriptPubKey containing the k-of-n multisignature, you create a separate script containing the public keys, then hash it, and the scriptPubKey would contain the hash of the script.
> By symmetry with the P2PKH template:
>
> OP_DUP OP_HASH160 <hash160(pubkey)> OP_EQUALVERIFY OP_CHECKSIG
>
> The P2SH template would be:
>
> OP_DUP OP_HASH160 <hash160(redeemScript)> OP_EQUALVERIFY OP_EVAL
>
> OP_EVAL would take the stack top vector and treat it as a Bitcoin SCRIPT.
>
> It was then pointed out that OP_EVAL could be used to create recursive SCRIPTs by quining using OP_CAT.
> OP_CAT was already disabled by then, but people were talking about re-enabling it somehow by restricting the output size of OP_CAT to limit the O(2^N) behavior.
>
> Thus, since then, OP_CAT has been associated with recursive covenants (and people are now reluctant to re-enable it even with a limit on its output size, because recursive covenants).
> In particular, OP_CAT in combination with OP_CHECKSIGFROMSTACK and OP_CHECKSIG, you could get a deferred OP_EVAL and then use OP_CAT too to quine.
>
> Because of those concerns, the modern P2SH is now "just a template" with an implicit OP_EVAL of the redeemScript, but without any OP_EVAL being actually enabled.
>
> (OP_EVAL cannot replace an OP_NOP in a softfork, but it is helpful to remember that P2SH was pretty much what codified the difference between softfork and hardfork, and the community at the time was small enough (or so it seemed) that a hardfork might not have been disruptive.)
>
>> Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.
>
> If you are willing to work in Taproot the same OP-code can be enabled in a softfork by using a new Tapscript version.
>
> If you worry about quantum-computing-break, a new SegWit version (which is more limited than Tapscript versions, unfortunately) can also be used, creating a new P2WSHv2 (or whatever version) that enables these opcodes.
>
>> As far a I know, this is the covenants proposal that has been implemented for the longest time, if that's to be used as a selection criteria.And as always, this is not incompatible with deploying other convenant proposals later.
>
> No, it was OP_EVAL, not OP_CAT.
> In particular if OP_EVAL was allowed in the redeemScript then it would enable covenants as well.
> It was just pointed out that OP_CAT enables recursive covenenats in combination with OP_EVAL-in-redeemScript.
>
> In particular, in combination with OP_CAT, OP_EVAL not only allows recursive covenants, but also recursion within a SCRIPT i.e. unbounded SCRIPT execution.
> Thus, OP_EVAL is simply not going to fly, at all.
>
>> Personally I find the simplicity proposal the best one among all the covenant proposals by far, including this one.But I understand that despite the name, the proposal is harder to review and test than other proposals, for it wouldn't simply add covenants, but a complete new scripting language that is better in many senses.Speedy covenants, on the other hand, is much simpler and has been implemented for longer, so in principle, it should be easier to deploy in a speedy manner.
>>
>> What are the main arguments against speedy covenants (aka op_cat2) and against deploying simplicity in bitcoin respectively?
>> Sorry if this was discussed before.
>
> OP_CAT, by itself, does not implement any covenants --- instead, it creates recursive covenants when combined with almost all covenant opcodes.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220511/40c774ba/attachment-0001.html>

From vjudeu at gazeta.pl  Wed May 11 16:03:25 2022
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Wed, 11 May 2022 18:03:25 +0200
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <b4X11F5edHpTf3LtKIQ53TOvUYP7l4AS689gAveWrDpfoeCC_5X8GzxoN8esnd0InoC4gAP46OX-YhxQoBp6nVfolMpNRkkk4DGqoLH2VDg=@protonmail.com>
Message-ID: <161249063-43e0faa99d531e0f159a89feef8a592b@pmq5v.m5r2.onet>

> This transaction has 2 inputs: 0.00074 tBTC and 0.00073 tBTC (0.00074 + 0.00073 = 0.00147) which is more than output amount 0.001 tBTC

It was created without the second input, see: https://bitcointalk.org/index.php?topic=5390103.msg59616324#msg59616324
I didn't touch that later, the signatures are the same. Some user named coinlatte just completed it: https://bitcointalk.org/index.php?topic=5390103.msg60029953#msg60029953


On 2022-05-11 17:25:41 user alicexbt <alicexbt at protonmail.com> wrote:

Hi vjudeu,

It can be changed by using different sighashes, for example, it is possible to create a "negative fee transaction", where all transaction costs are paid by receiver. Using SIGHASH_SINGLE | SIGHASH_ANYONECANPAY with a higher amount in outputs than inputs is enough to do that, see testnet3 transaction 495d2007ae8b741c70c3d278c02ce03702223b9675e954ecabbb634c6cd5bf40.


This transaction has 2 inputs: 0.00074 tBTC and 0.00073 tBTC (0.00074 +?0.00073 = 0.00147)?which is more than output amount 0.001 tBTC


/dev/fd0





Sent with ProtonMail secure email.

------- Original Message -------
On Saturday, May 7th, 2022 at 9:22 AM, vjudeu via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:







Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.

We have TapScript for that. OP_CAT is defined as OP_SUCCESS, it can be re-enabled in a soft-fork way. For now, OP_CAT in TapScript simply means "anyone can move those coins", so adding some restrictions is all we need to re-enable this opcode. Introducing OP_CAT2 is not needed at all, unless it will be totally different, but then it should not be named as OP_CAT2, but rather as OP_SOMETHING_ELSE, it depends how different it will be from OP_CAT.

OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...

So we can use OP_SUBSTR instead. Maybe even OP_SPLIT will be enough, if data expansion is the only problem, then we can focus on getting it smaller. Or better, we could use OP_FIND that would return true/false answer if element A is a part of element B, when we do byte-to-byte comparison. In general, we can use many different string-based functions to do the same things, we can choose something that will not exponentially explode as OP_CAT.

It was considered unfair that the sender is paying for the security of the receiver.

It can be changed by using different sighashes, for example, it is possible to create a "negative fee transaction", where all transaction costs are paid by receiver. Using SIGHASH_SINGLE | SIGHASH_ANYONECANPAY with a higher amount in outputs than inputs is enough to do that, see testnet3 transaction 495d2007ae8b741c70c3d278c02ce03702223b9675e954ecabbb634c6cd5bf40.

On 2022-05-07 05:06:46 user ZmnSCPxj via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:

Good morning Jorge,

OP_CAT was removed. If I remember correctly, some speculated that perhaps it was removed because it could allow covenants.I don't remember any technical concern about the OP besides enabling covenants.Before it was a common opinion that covenants shouldn't be enabled in bitcoin because, despite having good use case, there are some nasty attacks that are enabled with them too. These days it seems the opinion of the benefits being worth the dangers is quite generalized. Which is quite understandable given that more use cases have been thought since then.

I think the more accurate reason for why it was removed is because the following SCRIPT of N size would lead to 2^N memory usage:

OP_1 OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT OP_DUP OP_CAT ...

In particular it was removed at about the same time as OP_MUL, which has similar behavior (consider that multiplying two 32-bit numbers results in a 64-bit number, similar to OP_CATting a vector to itself).

OP_CAT was removed long before covenants were even expressed as a possibility.

Covenants were first expressed as a possibility, I believe, during discussions around P2SH.
Basically, at the time, the problem was this:

* Some receivers wanted to use k-of-n multisignature for improved security.
* The only way to implement this, pre-P2SH, was by putting in the scriptPubKey all the public keys.
* The sender is the one paying for the size of the scriptPubKey.
* It was considered unfair that the sender is paying for the security of the receiver.

Thus, OP_EVAL and the P2SH concept was conceived.
Instead of the scriptPubKey containing the k-of-n multisignature, you create a separate script containing the public keys, then hash it, and the scriptPubKey would contain the hash of the script.
By symmetry with the P2PKH template:

OP_DUP OP_HASH160 <hash160(pubkey)> OP_EQUALVERIFY OP_CHECKSIG

The P2SH template would be:

OP_DUP OP_HASH160 <hash160(redeemScript)> OP_EQUALVERIFY OP_EVAL

OP_EVAL would take the stack top vector and treat it as a Bitcoin SCRIPT.

It was then pointed out that OP_EVAL could be used to create recursive SCRIPTs by quining using OP_CAT.
OP_CAT was already disabled by then, but people were talking about re-enabling it somehow by restricting the output size of OP_CAT to limit the O(2^N) behavior.

Thus, since then, OP_CAT has been associated with recursive covenants (and people are now reluctant to re-enable it even with a limit on its output size, because recursive covenants).
In particular, OP_CAT in combination with OP_CHECKSIGFROMSTACK and OP_CHECKSIG, you could get a deferred OP_EVAL and then use OP_CAT too to quine.

Because of those concerns, the modern P2SH is now "just a template" with an implicit OP_EVAL of the redeemScript, but without any OP_EVAL being actually enabled.

(OP_EVAL cannot replace an OP_NOP in a softfork, but it is helpful to remember that P2SH was pretty much what codified the difference between softfork and hardfork, and the community at the time was small enough (or so it seemed) that a hardfork might not have been disruptive.)

Re-enabling OP_CAT with the exact same OP would be a hardfork, but creating a new OP_CAT2 that does the same would be a softfork.

If you are willing to work in Taproot the same OP-code can be enabled in a softfork by using a new Tapscript version.

If you worry about quantum-computing-break, a new SegWit version (which is more limited than Tapscript versions, unfortunately) can also be used, creating a new P2WSHv2 (or whatever version) that enables these opcodes.

As far a I know, this is the covenants proposal that has been implemented for the longest time, if that's to be used as a selection criteria.And as always, this is not incompatible with deploying other convenant proposals later.

No, it was OP_EVAL, not OP_CAT.
In particular if OP_EVAL was allowed in the redeemScript then it would enable covenants as well.
It was just pointed out that OP_CAT enables recursive covenenats in combination with OP_EVAL-in-redeemScript.

In particular, in combination with OP_CAT, OP_EVAL not only allows recursive covenants, but also recursion within a SCRIPT i.e. unbounded SCRIPT execution.
Thus, OP_EVAL is simply not going to fly, at all.

Personally I find the simplicity proposal the best one among all the covenant proposals by far, including this one.But I understand that despite the name, the proposal is harder to review and test than other proposals, for it wouldn't simply add covenants, but a complete new scripting language that is better in many senses.Speedy covenants, on the other hand, is much simpler and has been implemented for longer, so in principle, it should be easier to deploy in a speedy manner.

What are the main arguments against speedy covenants (aka op_cat2) and against deploying simplicity in bitcoin respectively?
Sorry if this was discussed before.

OP_CAT, by itself, does not implement any covenants --- instead, it creates recursive covenants when combined with almost all covenant opcodes.

Regards,
ZmnSCPxj
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From roconnor at blockstream.com  Wed May 11 19:22:40 2022
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 11 May 2022 15:22:40 -0400
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
In-Reply-To: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
References: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
Message-ID: <CAMZUoKmXFxoSs5_5EM8ptAOpiiGP4ryqAibn5eghkbsaYz+oQA@mail.gmail.com>

Hi alicexbt,

As far as I understand things, I believe the whole notion of a MUST_SIGNAL
state is misguided today. Please correct me if I'm misunderstanding
something here.

Back when BIP8 was first proposed by Shaolin Fry, we were in a situation
where many existing clients waiting for segwit signalling had already been
deployed.  The purpose of mandatory signaling at that point in time was to
ensure all these existing clients would be activated together with any BIP8
clients.

However, if such other clients do not exist, the MUST_SIGNAL state no
longer accomplishes its purpose.  Going forward, I think there is little
reason to expect such other clients to exist alongside a BIP8 deployment.
If everyone uses a BIP8 deployment, then there are no other clients to
activate.  Alternatively, Speedy Trial was specifically designed to avoid
this parallel deployment for the reason that several people object to
allowing their client's non-BIP8 activation logic to be hijacked in this
manner.

Now I understand that some people would like *some* signal on the chain
that indicates a soft-fork activation in order to allow people who object
to the fork to make an "anti-fork" that rejects blocks containing the
soft-fork signal.  And while some sort of mandatory version bit signaling
*could* be used for this purpose, we do not *have* to use version bits.  We
also don't need such a signal span over multiple blocks.  Indeed, using
version bits and signaling over multiple blocks is quite bad because it
risks losing mining power if miners don't conform, or are unable to
conform, to the version bits signal.  (Recall at the time taproot's
signaling period started, the firmware needed for many miners to signal
version bits did not even exist yet!).

A soft-fork signal to enable an "anti-fork" only needs to be on a single
block and it can be almost anything.  For example we could have a signal
that at the block at lockin or perhaps the block at activation requires
that the coinbase must *not* contain the suffix "taproot sucks!".  This
suffices to prepare an "anti-fork" which would simply require that the
specified block must contain the suffix "taproot sucks!".

Anyway, I'm sure there are lots of design choices available better than a
MUST_SIGNAL state that does not risk potentially taking a large fraction of
mining hardware offline for a protracted period of time.

On Tue, May 10, 2022 at 10:02 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Bitcoin Developers,
>
> There were some disagreements with speedy trial activation method recently
> and BIP 8 became controversial because of LOT earlier. I have tried to
> solve these two problems after reading some arguments for/against different
> activation methods by removing LOT from BIP 8 and calculating MUST_SIGNAL
> state based on threshold reached.
>
> BIP draft with no code and some changes in BIP 8:
> https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1
>
> State transitions diagram: https://i.imgur.com/dj4bFVK.png
>
> This proposal removes lockinontimeout flag, activation never fails
> although MUST_SIGNAL can be longer if miners signaling does not reach the
> threshold. Longer period for MUST_SIGNAL state is useful for coordination
> if LOCKED_IN was not reached.
>
> MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached and
> blocks that fail to signal in MUST_SIGNAL phase are invalid.
>
> Example:
>
> - This activation method is used for a soft fork
> - Only 60% miners signaled readiness and timeout height was reached
> - MUST_SIGNAL phase starts and will last for 4*2016 blocks
> - LOCKED_IN and ACTIVE states remain same as BIP 8
> - Soft fork is activated with a delay of 2 months
>
>
> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220511/2cdd2915/attachment.html>

From roconnor at blockstream.com  Wed May 11 19:41:16 2022
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 11 May 2022 15:41:16 -0400
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
 <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
Message-ID: <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>

On Wed, May 11, 2022 at 7:42 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> REMEMBER: `OP_CAT` BY ITSELF DOES NOT ENABLE COVENANTS, WHETHER RECURSIVE
> OR NOT.
>

I think the state of the art has advanced to the point where we can say
"OP_CAT in tapscript enables non recursive covenants and it is unknown
whether OP_CAT can enable recursive covenants or not".

A. Poelstra in
https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html show
how to use CAT to use the schnorr verification opcode to get the sighash
value + 1 onto the stack, and then through some grinding and some more CAT,
get the actual sighash value on the stack.  From there we can use SHA256 to
get the signed transaction data onto the stack and apply introspect (using
CAT) to build functionality similar to OP_CTV.

The missing bits for enabling recursive covenants comes down to needing to
transform a scriptpubkey into an taproot address, which involves some
tweaking.  Poelstra has suggested that it might be possible to hijack the
ECDSA checksig operation from a parallel, legacy input, in order to perform
the calculations for this tweaking.  But as far as I know no one has yet
been able to achieve this feat.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220511/50e8333f/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Thu May 12 03:07:45 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 12 May 2022 03:07:45 +0000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
 <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
 <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>
Message-ID: <fkMEju1kNN5OJPoI1d2K99sV0bhr7qeAnhVbv-99K_UL48YQyHp-rbqEfQ81crx-thaA8JuUY4-eFlYUskvFC_8h6DIhdF0Wj-v-4DNnlcI=@protonmail.com>

Good morning Russell,

> On Wed, May 11, 2022 at 7:42 AM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > REMEMBER: `OP_CAT` BY ITSELF DOES NOT ENABLE COVENANTS, WHETHER RECURSIVE OR NOT.
>
>
> I think the state of the art has advanced to the point where we can say "OP_CAT in tapscript enables non recursive covenants and it is unknown whether OP_CAT can enable recursive covenants or not".
>
> A. Poelstra in https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html show how to use CAT to use the schnorr verification opcode to get the sighash value + 1 onto the stack, and then through some grinding and some more CAT, get the actual sighash value on the stack. From there we can use SHA256 to get the signed transaction data onto the stack and apply introspect (using CAT) to build functionality similar to OP_CTV.
>
> The missing bits for enabling recursive covenants comes down to needing to transform a scriptpubkey into an taproot address, which involves some tweaking. Poelstra has suggested that it might be possible to hijack the ECDSA checksig operation from a parallel, legacy input, in order to perform the calculations for this tweaking. But as far as I know no one has yet been able to achieve this feat.

Hmm, I do not suppose it would have worked in ECDSA?
Seems like this exploits linearity in the Schnorr.
For the ECDSA case it seems that the trick in that link leads to `s = e + G[x]` where `G[x]` is the x-coordinate of `G`.
(I am not a mathist, so I probably am not making sense; in particular, there may be an operation to add two SECP256K1 scalars that I am not aware of)

In that case, since Schnorr was added later, I get away by a technicality, since it is not *just* `OP_CAT` which enabled this style of covenant, it was `OP_CAT` + BIP340 v(^^);;;;;

Also holy shit math is scary.

Seems this also works with `OP_SUBSTR`, simply by inverting it into "validate that the concatenation is correct" rather than "concatenate it ourselves".




So really: are recursive covenants good or...?
Because if recursive covenants are good, what we should really work on is making them cheap (in CPU load/bandwidth load terms) and private, to avoid centralization and censoring.

Regards,
ZmnSCPxj

From dave at dtrt.org  Thu May 12 07:17:05 2022
From: dave at dtrt.org (David A. Harding)
Date: Wed, 11 May 2022 21:17:05 -1000
Subject: [bitcoin-dev] Bringing a nuke to a knife fight: Transaction
 introspection to stop RBF pinning
In-Reply-To: <CAB3F3Dtp7YQBhLJQbCLpSKau8Hj=5gN4yuGCFN=u=6e1o6o=dA@mail.gmail.com>
References: <CAB3F3Dtp7YQBhLJQbCLpSKau8Hj=5gN4yuGCFN=u=6e1o6o=dA@mail.gmail.com>
Message-ID: <6a73b36724e6134a1cd57ea9277f2779@dtrt.org>

On 2022-05-10 08:53, Greg Sanders via bitcoin-dev wrote:
> We add OPTX_SELECT_WEIGHT(pushes tx weight to stack, my addition to
> the proposal) to the "state" input's script.
> This is used in the update transaction to set the upper bound on the
> final transaction weight.
> In this same input, for each contract participant, we also
> conditionally commit to the change output's scriptpubkey
> via OPTX_SELECT_OUTPUT_SCRIPTPUBKEY and OPTX_SELECT_OUTPUTCOUNT==2.
> This means any participant can send change back
> to themselves, but with a catch. Each change output script possibility
> in that state input also includes a 1 block
> CSV to avoid mempool spending to reintroduce pinning.

I like the idea!   However, I'm not sure the `1 CSV` trick helps much.  
Can't an attacker just submit to the mempool their other eltoo state 
updates?  For example, let's assume Bob and Mallory have a channel with 
 >25 updates and Mallory wants to prevent update[-1] from being committed onchain before its (H|P)TLC timeout.  Mallory also has at least 25 unencumbered UTXOs, so she submits to the mempool update[0], update[1], update[...], update[24]---each of them with a different second input to pay fees.

If `OPTX_SELECT_WEIGHT OP_TX` limits each update's weight to 1,000 
vbytes[1] and the default node relay/mempool policy of allowing a 
transaction and up to 24 descendants remains, Mallory can pin the 
unsubmitted update[-1] under 25,000 vbytes of junk---which is 25% of 
what she can pin under current mempool policies.

Alice can't RBF update[0] without paying for update[1..24] (BIP125 rule 
#3), and an RBF of update[24] will have its additional fees divided by 
its size plus the 24,000 vbytes of update[1..24].

To me, that seems like your proposal makes escaping the pinning at most 
75% cheaper than today.  That's certainly an improvement---yay!---but 
I'm not sure it eliminates the underlying concern.  Also depending on 
the mempool ancestor/descendant limits makes it harder to raise those 
limits in the future, which is something I think we might want to do if 
we can ensure raising them won't increase node memory/CPU DoS risk.

I'd love to hear that my analysis is missing something though!

Thanks!,

-Dave

[1] 1,000 vbytes per update seems like a reasonable value to me.  
Obviously there's a tradeoff here: making it smaller limits the amount 
of pinning possible (assuming mempool ancestor/descendant limits remain) 
but also limits the number and complexity of inputs that may be added.  
I don't think we want to discourage people too much from holding 
bitcoins in deep taproot trees or sophisticated tapscripts.

From alex.schoof at gmail.com  Wed May 11 23:32:34 2022
From: alex.schoof at gmail.com (Alex Schoof)
Date: Wed, 11 May 2022 19:32:34 -0400
Subject: [bitcoin-dev] [PROPOSAL] OP_TX: generalized covenants reduced
	to OP_CHECKTEMPLATEVERIFY
In-Reply-To: <87h75xoet1.fsf@rustcorp.com.au>
References: <87h75xoet1.fsf@rustcorp.com.au>
Message-ID: <CA+2b5C0nJFThN_JV4usx2KQqTbAYwPq_u6RJn+1k5PuLwT1wPA@mail.gmail.com>

Hi Rusty,

One of the common sentiments thats been expressed over the last few months
is that more people want to see experimentation with different applications
using covenants. I really like this proposal because in addition to
offering a cleaner upgrade/extension path than adding ?CTV++? as a new
opcode in a few years, it also seems like it would make it very easy to
create prototype applications to game out new ideas:
If the ?only this combination of fields are valid, otherwise OP_SUCCESS?
check is just comparing with a list of bitmasks for permissible field
combinations (which right now is a list of length 1), it seems like it
would be *very* easy for people who want to play with other covenant field
sets to just add the relevant bitmasks and then go spin up a signet to
build applications.

Being able to make a very targeted change like that to enable
experimentation is super cool. Thanks for sharing!

Alex

On Tue, May 10, 2022 at 6:37 AM Rusty Russell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
>         TL;DR: a v1 tapscript opcode for generic covenants, but
> OP_SUCCESS unless it's used a-la OP_CHECKTEMPLATEVERIFY.  This gives an
> obvious use case, with clean future expansion.  OP_NOP4 can be
> repurposed in future as a shortcut, if experience shows that to be a
> useful optimization.
>
> (This proposal builds on Russell O'Connor's TXHASH[1], with Anthony
> Towns' modification via extending the opcode[2]; I also notice on
> re-reading that James Lu had a similar restriction idea[3]).
>
> Details
> -------
>
> OP_TX, when inside v1 tapscript, is followed by 4 bytes of flags.
> Unknown flag patterns are OP_SUCCESS, though for thoroughness some future
> potential uses are documented here.  Note that pushing more than 1000
> elements on the stack or an element more than 512 bytes will hit the
> BIP-342 resource limits and fail.
>
> Defined bits
> ------------
>
> (Only those marked with * have to be defined for this soft fork; the
>  others can have semantics later).
>
> OPTX_SEPARATELY: treat fields separately (vs concatenating)
> OPTX_UNHASHED: push on the stack without hashing (vs SHA256 before push)
>
> - The first nicely sidesteps the lack of OP_CAT, and the latter allows
>   OP_TXHASH semantics (and avoid stack element limits).
>
> OPTX_SELECT_VERSION*: version
> OPTX_SELECT_LOCKTIME*: nLocktime
> OPTX_SELECT_INPUTNUM*: current input number
> OPTX_SELECT_INPUTCOUNT*: number of inputs
> OPTX_SELECT_OUTPUTCOUNT*: number of outputs
>
> OPTX_INPUT_SINGLE: if set, pop input number off stack to apply to
>                 OPTX_SELECT_INPUT_*, otherwise iterate through all.
> OPTX_SELECT_INPUT_TXID: txid
> OPTX_SELECT_INPUT_OUTNUM: txout index
> OPTX_SELECT_INPUT_NSEQUENCE*: sequence number
> OPTX_SELECT_INPUT_AMOUNT32x2: sats in, as a high-low u31 pair
> OPTX_SELECT_INPUT_SCRIPT*: input scriptsig
> OPTX_SELECT_INPUT_TAPBRANCH: ?
> OPTX_SELECT_INPUT_TAPLEAF: ?
>
> OPTX_OUTPUT_SINGLE: if set, pop input number off stack to apply to
>                 OPTX_SELECT_OUTPUT_*, otherwise iterate through all.
> OPTX_SELECT_OUTPUT_AMOUNT32x2*: sats out, as a high-low u31 pair
> OPTX_SELECT_OUTPUT_SCRIPTPUBKEY*: output scriptpubkey
>
> OPTX_SELECT_19...OPTX_SELECT_31: future expansion.
>
> OP_CHECKTEMPLATEVERIFY is approximated by the following flags:
>         OPTX_SELECT_VERSION
>         OPTX_SELECT_LOCKTIME
>         OPTX_SELECT_INPUTCOUNT
>         OPTX_SELECT_INPUT_SCRIPT
>         OPTX_SELECT_INPUT_NSEQUENCE
>         OPTX_SELECT_OUTPUTCOUNT
>         OPTX_SELECT_OUTPUT_AMOUNT32x2
>         OPTX_SELECT_OUTPUT_SCRIPTPUBKEY
>         OPTX_SELECT_INPUTNUM
>
> All other flag combinations result in OP_SUCCESS.
>
> Discussion
> ----------
>
> By enumerating exactly what can be committed to, it's absolutely clear
> what is and isn't committed (and what you need to think about!).
>
> The bits which separate concatenation and hashing provide a simple
> mechanism for template-style (i.e. CTV-style) commitments, or for
> programatic treatment of individual elements (e.g. amounts, though the
> two s31 style is awkward: a 64-bit push flag could be added in future).
>
> The lack of double-hashing of scriptsigs and other fields means we
> cannot simply re-use hashing done for SIGHASH_ALL.
>
> The OP_SUCCESS semantic is only valid in tapscript v1, so this does not
> allow covenants for v0 segwit or pre-segwit inputs.  If covenants prove
> useful, dedicated opcodes can be provided for those cases (a-la
> OP_CHECKTEMPLATEVERIFY).
>
> Cheers,
> Rusty.
>
> [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019813.html
> [2]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019819.html
> [3]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019816.html
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-- 


Alex Schoof
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220511/03fcb3bf/attachment.html>

From roconnor at blockstream.com  Thu May 12 10:48:44 2022
From: roconnor at blockstream.com (Russell O'Connor)
Date: Thu, 12 May 2022 06:48:44 -0400
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <fkMEju1kNN5OJPoI1d2K99sV0bhr7qeAnhVbv-99K_UL48YQyHp-rbqEfQ81crx-thaA8JuUY4-eFlYUskvFC_8h6DIhdF0Wj-v-4DNnlcI=@protonmail.com>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
 <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
 <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>
 <fkMEju1kNN5OJPoI1d2K99sV0bhr7qeAnhVbv-99K_UL48YQyHp-rbqEfQ81crx-thaA8JuUY4-eFlYUskvFC_8h6DIhdF0Wj-v-4DNnlcI=@protonmail.com>
Message-ID: <CAMZUoKmhOpt2N+6YxxREMzmRca2hNnPHBMRMsT09efkEs0CJiQ@mail.gmail.com>

On Wed, May 11, 2022 at 11:07 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Russell,
>
> > On Wed, May 11, 2022 at 7:42 AM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > REMEMBER: `OP_CAT` BY ITSELF DOES NOT ENABLE COVENANTS, WHETHER
> RECURSIVE OR NOT.
> >
> >
> > I think the state of the art has advanced to the point where we can say
> "OP_CAT in tapscript enables non recursive covenants and it is unknown
> whether OP_CAT can enable recursive covenants or not".
> >
> > A. Poelstra in
> https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html show
> how to use CAT to use the schnorr verification opcode to get the sighash
> value + 1 onto the stack, and then through some grinding and some more CAT,
> get the actual sighash value on the stack. From there we can use SHA256 to
> get the signed transaction data onto the stack and apply introspect (using
> CAT) to build functionality similar to OP_CTV.
> >
> > The missing bits for enabling recursive covenants comes down to needing
> to transform a scriptpubkey into an taproot address, which involves some
> tweaking. Poelstra has suggested that it might be possible to hijack the
> ECDSA checksig operation from a parallel, legacy input, in order to perform
> the calculations for this tweaking. But as far as I know no one has yet
> been able to achieve this feat.
>
> Hmm, I do not suppose it would have worked in ECDSA?
> Seems like this exploits linearity in the Schnorr.
> For the ECDSA case it seems that the trick in that link leads to `s = e +
> G[x]` where `G[x]` is the x-coordinate of `G`.
> (I am not a mathist, so I probably am not making sense; in particular,
> there may be an operation to add two SECP256K1 scalars that I am not aware
> of)
>
> In that case, since Schnorr was added later, I get away by a technicality,
> since it is not *just* `OP_CAT` which enabled this style of covenant, it
> was `OP_CAT` + BIP340 v(^^);;;;;
>

Correct.


> Also holy shit math is scary.
>
> Seems this also works with `OP_SUBSTR`, simply by inverting it into
> "validate that the concatenation is correct" rather than "concatenate it
> ourselves".
>
>
>
>
> So really: are recursive covenants good or...?
> Because if recursive covenants are good, what we should really work on is
> making them cheap (in CPU load/bandwidth load terms) and private, to avoid
> centralization and censoring.
>

My view is that recursive covenants are inevitable.  It is nearly
impossible to have programmable money without it because it is so difficult
to avoid.

Given that we cannot have programmable money without recursive covenants
and given all the considerations already discussed regarding them, i.e. no
worse than being compelled to co-sign transactions, and that user generated
addresses won't be encumbered by a covenant unless they specifically
generate it to be, I do think it makes sense to embrace them.


> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/af1e5596/attachment-0001.html>

From jtimon at jtimon.cc  Thu May 12 11:46:45 2022
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Thu, 12 May 2022 13:46:45 +0200
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <CAGpPWDYUTCsSgirR7iNmbUw+cjEqHSymtzH4EtH=BQnZRjvgmQ@mail.gmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
 <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
 <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>
 <CALeFGL18ULkGW4UA_5Fod4PVoe_LeF5e97eZdJja-ctf2paLWQ@mail.gmail.com>
 <CAGpPWDYUTCsSgirR7iNmbUw+cjEqHSymtzH4EtH=BQnZRjvgmQ@mail.gmail.com>
Message-ID: <CABm2gDqVcAAz-Nqwt+SPBZrFyTUN3kizSTYkbuWSkoG0xJtoPQ@mail.gmail.com>

I think something like visacoin could be kind of feasible without recursive
covenants. But as billy points out, I guess they could kind of do it with
multisig too.

I fail to understand why non recursive covenants are called covenants at
all. Probably I'm missing something, but I guess that's another topic.


On Tue, May 10, 2022 at 5:11 PM Billy Tetrud via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> >  So if you don't want to receive restricted coins, just don't generate
> an address with those restrictions embedded.
>
> This is an interesting point that I for some reason haven't thought of
> before. However...
>
> > Unless governments can mandate that you generate these addresses AND
> force you to accept funds bound by them for your services**, I don't
> actually see how this is a real concern.
>
> Actually, I think only the second is necessary. For example, if there was
> a law that compelled giving a good or service if payment of a publicly
> advertised amount was paid, and someone pays to an address that can be
> shown is spendable by the merchant's keys in a way that the government
> accepts, it doesn't matter whether the recipient can or has generated the
> address.
>
> Regardless I do think its still important to note that a government could
> do that today using multisig.
>
> > This is a reason to oppose legal tender laws for Bitcoin imo.
>
> I agree.
>
> On Mon, May 9, 2022 at 10:23 AM Keagan McClelland <
> keagan.mcclelland at gmail.com> wrote:
>
>> > > > To me the most scary one is visacoin, specially seeing what
>> happened in canada and other places lately and the general censorship in
>> the west, the supposed war on "misinformation" going on (really a war
>> against truth imo, but whatever) it's getting really scary. But perhaps
>> someone else can be more scared about a covenant to add demurrage fees to
>> coins or something, I don't know.
>> > > > https://bitcointalk.org/index.php?topic=278122
>>
>> > > This requires *recursive* covenants.
>>
>> > Actually, for practical use, any walled-garden requires *dynamic*
>> covenants, not recursive covenants.
>>
>> There's actually also a very straight forward defense for those who do
>> not want to receive "tainted" coins. In every covenant design I've seen to
>> date (including recursive designs) it requires that the receiver generate a
>> script that is "compliant" with the covenant provisions to which the sender
>> is bound. The consequence of this is that you can't receive coins that are
>> bound by covenants you weren't aware of*. So if you don't want to receive
>> restricted coins, just don't generate an address with those restrictions
>> embedded. As long as you can specify the spend conditions upon the receipt
>> of your funds, it really doesn't matter how others are structuring their
>> own spend conditions. So long as the verification of those conditions can
>> be predictably verified by the rest of the network, all risk incurred is
>> quarantined to the receiver of the funds. Worst case scenario is that no
>> one wants to agree to those conditions and the funds are effectively burned.
>>
>> It's not hard to make the case that any time funds are being transferred
>> between organizations with incompatible interests (external to a firm),
>> that they will want to be completely free to choose their own spend
>> conditions and will not wish to inherit the conditions of the spender.
>> Correspondingly, any well implemented covenant contract will include
>> provisions for escaping the recursion loop if some sufficiently high bar is
>> met by the administrators of those funds. Unless governments can mandate
>> that you generate these addresses AND force you to accept funds bound by
>> them for your services**, I don't actually see how this is a real concern.
>>
>> *This requires good wallet tooling and standards but that isn't
>> materially different than wallets experimenting with non-standard recovery
>> policies.
>>
>> **This is a reason to oppose legal tender laws for Bitcoin imo.
>>
>> Keagan
>>
>> On Sun, May 8, 2022 at 11:32 AM Billy Tetrud via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> >  This requires *recursive* covenants.
>>>
>>> Actually, for practical use, any walled-garden requires *dynamic*
>>> covenants, not recursive covenants. CTV can get arbitrarily close to
>>> recursive covenants, because you can have an arbitrarily long string of
>>> covenants. But this doesn't help someone implement visacoin because CTV
>>> only allows a specific predefined iteration of transactions, meaning that
>>> while "locked" into the covenant sequence, the coins can't be used in any
>>> way like normal coins - you can't choose who you pay, the sequence is
>>> predetermined.
>>>
>>> Even covenants that allow infinite recursion (like OP_TLUV and OP_CD
>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md>)
>>> don't automatically allow for practical walled gardens. Recursion
>>> definitely allows creating walled gardens, but those gardens would be
>>> impractically static. You could add millions of potential addresses to send
>>> to, which would "only" quadruple the size of your transactions, but if
>>> anyone creates a new address you want to send to, you wouldn't be able to.
>>> Everyone would have to have a single address whitelisted into every
>>> government-bitcoin output. If someone lost their key and needs to create a
>>> new wallet, suddenly no one would be able to pay them.
>>>
>>> In order to really build a wallet garden, infinite recursion isn't
>>> really necessary nor sufficient. You need to be able to dynamically specify
>>> destination addresses. For example, if you were a government that wants to
>>> make a walled garden where you (the government) could confiscate the funds
>>> whenever you wanted, you'd have to have a covenant that allows the end-user
>>> to specify an arbitrary public key to send money to. The covenant might
>>> require that user to send to another covenant that has a government spend
>>> path, but also has a spend path for that user-defined public key. That way,
>>> you (the government) could allow people to send to each other arbitrarily,
>>> while still ensuring that you (the government) could spend the funds no
>>> matter where they may have been sent. Even without recursive covenants, you
>>> could have arbitrarily long chains of these, say 1 million long, where at
>>> the end of the chain the user must send your coins back to the government
>>> who can then send them back with another million-long chain of covenants to
>>> work with.
>>>
>>> OP_CHECKOUTPUTVERIFY <https://fc16.ifca.ai/bitcoin/papers/MES16.pdf> can
>>> do this kind of dynamicness, and OP_PUSHOUTPUTSTACK
>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/pos/bip-pushoutputstack.md> can
>>> enable it for things like OP_TLUV and OP_CD. I personally think dynamic
>>> covenants are a *good* thing, as it enables more secure wallet vaults,
>>> among other things. And I'm not worried about a government creating a
>>> in-bitcoin visa-coin. Why? Because they can already do it today. They have
>>> been able to do it for 9 years already. How?
>>>
>>> Replace the covenant above with a multisig wallet. The government has 2
>>> keys, you have 1 key. Every time you make a transaction, you request the
>>> government's signature on it. The government then only signs if you're
>>> sending to a wallet they approve of. They might only sign when you're
>>> sending to another multisig wallet that the government has 2 of 3 keys for.
>>> Its a very similar walled garden, where the only difference is that the
>>> government needs to actively sign, which I'm sure wouldn't be a huge
>>> challenge for the intrepid dictator of the land. You want to add
>>> demurage fees? Easy, the government just spends the fee out of everyone's
>>> wallets every so often.
>>>
>>> On the other hand, OP_CTV *cannot* be used for such a thing. No
>>> combination of future opcodes can enable either recursion or dynamicness to
>>> an OP_CTV call.
>>>
>>>
>>>
>>> On Sat, May 7, 2022 at 5:40 PM ZmnSCPxj via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Good morning Jorge,
>>>>
>>>> > I think people may be scared of potential attacks based on covenants.
>>>> For example, visacoin.
>>>> > But there was a thread with ideas of possible attacks based on
>>>> covenants.
>>>> > To me the most scary one is visacoin, specially seeing what happened
>>>> in canada and other places lately and the general censorship in the west,
>>>> the supposed war on "misinformation" going on (really a war against truth
>>>> imo, but whatever) it's getting really scary. But perhaps someone else can
>>>> be more scared about a covenant to add demurrage fees to coins or
>>>> something, I don't know.
>>>> > https://bitcointalk.org/index.php?topic=278122
>>>>
>>>> This requires *recursive* covenants.
>>>>
>>>> At the time the post was made, no distinction was seen between
>>>> recursive and non-recursive covenants, which is why the post points out
>>>> that covenants suck.
>>>> The idea then was that anything powerful enough to provide covenants
>>>> would also be powerful enough to provide *recursive* covenants, so there
>>>> was no distinction made between recursive and non-recursive covenants (the
>>>> latter was thought to be impossible).
>>>>
>>>> However, `OP_CTV` turns out to enable sort-of covenants, but by
>>>> construction *cannot* provide recursion.
>>>> It is just barely powerful enough to make a covenant, but not powerful
>>>> enough to make *recursive* covenants.
>>>>
>>>> That is why today we distinguish between recursive and non-recursive
>>>> covenant opcodes, because we now have opcode designs that provides
>>>> non-recursive covenants (when previously it was thought all covenant
>>>> opcodes would provide recursion).
>>>>
>>>> `visacoin` can only work as a recursive covenant, thus it is not
>>>> possible to use `OP_CTV` to implement `visacoin`, regardless of your
>>>> political views.
>>>>
>>>> (I was also misinformed in the past and ignored `OP_CTV` since I
>>>> thought that, like all the other covenant opcodes, it would enable
>>>> recursive covenants.)
>>>>
>>>>
>>>> Regards,
>>>> ZmnSCPxj
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/8e84e535/attachment.html>

From ZmnSCPxj at protonmail.com  Thu May 12 12:20:01 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 12 May 2022 12:20:01 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <CABm2gDqVcAAz-Nqwt+SPBZrFyTUN3kizSTYkbuWSkoG0xJtoPQ@mail.gmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
 <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
 <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>
 <CALeFGL18ULkGW4UA_5Fod4PVoe_LeF5e97eZdJja-ctf2paLWQ@mail.gmail.com>
 <CAGpPWDYUTCsSgirR7iNmbUw+cjEqHSymtzH4EtH=BQnZRjvgmQ@mail.gmail.com>
 <CABm2gDqVcAAz-Nqwt+SPBZrFyTUN3kizSTYkbuWSkoG0xJtoPQ@mail.gmail.com>
Message-ID: <YexjEuO_SQawFcFWRGWAoZ0aVZqw6_pem6IGvCrTUGW1Q6WoKFbQXMzf9ICkpxn1ffLGFnvCWv8205dv97pZo9CzfiUA7Q53-X2Sd7uCQEM=@protonmail.com>

Good morning Jorge,

> I fail to understand why non recursive covenants are called covenants at all. Probably I'm missing something, but I guess that's another topic.

A covenant simply promises that something will happen in the future.

A recursive covenant guarantees that the same thing will happen in the future.

Thus, non-recursive covenants can be useful.

Consider `OP_EVICT`, for example, which is designed for a very specific use-case, and avoids recursion.

Regards,
ZmnSCPxj

From gsanders87 at gmail.com  Thu May 12 13:31:02 2022
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 12 May 2022 09:31:02 -0400
Subject: [bitcoin-dev] Bringing a nuke to a knife fight: Transaction
 introspection to stop RBF pinning
In-Reply-To: <6a73b36724e6134a1cd57ea9277f2779@dtrt.org>
References: <CAB3F3Dtp7YQBhLJQbCLpSKau8Hj=5gN4yuGCFN=u=6e1o6o=dA@mail.gmail.com>
 <6a73b36724e6134a1cd57ea9277f2779@dtrt.org>
Message-ID: <CAB3F3DsGtqWo5ajc_iBGikFdTFqfMyA2y0-R1vcgFNht6Rb_Sw@mail.gmail.com>

Great point in this specific case I unfortunately didn't consider! So
basically the design degenerates to the last option I gave, where the
counterparty
can send off N(25) weight-bound packages.

A couple thoughts:

0) Couldn't we relative-time lock update transactions's state input by 1
block as well to close the vector off? People are allowed
one "update transaction package" at a time in mempool, so if detected
in-mempool it can be RBF'd, or in-block can be immediately responded to.
1) other usages of ANYONECANPAY like behavior may not have these issues,
like vault structures.


On Thu, May 12, 2022, 3:17 AM David A. Harding <dave at dtrt.org> wrote:

> On 2022-05-10 08:53, Greg Sanders via bitcoin-dev wrote:
> > We add OPTX_SELECT_WEIGHT(pushes tx weight to stack, my addition to
> > the proposal) to the "state" input's script.
> > This is used in the update transaction to set the upper bound on the
> > final transaction weight.
> > In this same input, for each contract participant, we also
> > conditionally commit to the change output's scriptpubkey
> > via OPTX_SELECT_OUTPUT_SCRIPTPUBKEY and OPTX_SELECT_OUTPUTCOUNT==2.
> > This means any participant can send change back
> > to themselves, but with a catch. Each change output script possibility
> > in that state input also includes a 1 block
> > CSV to avoid mempool spending to reintroduce pinning.
>
> I like the idea!   However, I'm not sure the `1 CSV` trick helps much.
> Can't an attacker just submit to the mempool their other eltoo state
> updates?  For example, let's assume Bob and Mallory have a channel with
>  >25 updates and Mallory wants to prevent update[-1] from being committed
> onchain before its (H|P)TLC timeout.  Mallory also has at least 25
> unencumbered UTXOs, so she submits to the mempool update[0], update[1],
> update[...], update[24]---each of them with a different second input to pay
> fees.
>
> If `OPTX_SELECT_WEIGHT OP_TX` limits each update's weight to 1,000
> vbytes[1] and the default node relay/mempool policy of allowing a
> transaction and up to 24 descendants remains, Mallory can pin the
> unsubmitted update[-1] under 25,000 vbytes of junk---which is 25% of
> what she can pin under current mempool policies.
>
> Alice can't RBF update[0] without paying for update[1..24] (BIP125 rule
> #3), and an RBF of update[24] will have its additional fees divided by
> its size plus the 24,000 vbytes of update[1..24].
>
> To me, that seems like your proposal makes escaping the pinning at most
> 75% cheaper than today.  That's certainly an improvement---yay!---but
> I'm not sure it eliminates the underlying concern.  Also depending on
> the mempool ancestor/descendant limits makes it harder to raise those
> limits in the future, which is something I think we might want to do if
> we can ensure raising them won't increase node memory/CPU DoS risk.
>
> I'd love to hear that my analysis is missing something though!
>
> Thanks!,
>
> -Dave
>
> [1] 1,000 vbytes per update seems like a reasonable value to me.
> Obviously there's a tradeoff here: making it smaller limits the amount
> of pinning possible (assuming mempool ancestor/descendant limits remain)
> but also limits the number and complexity of inputs that may be added.
> I don't think we want to discourage people too much from holding
> bitcoins in deep taproot trees or sophisticated tapscripts.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/6333a535/attachment.html>

From billy.tetrud at gmail.com  Thu May 12 17:28:39 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Thu, 12 May 2022 12:28:39 -0500
Subject: [bitcoin-dev] CTV BIP Meeting #8 Notes
In-Reply-To: <YexjEuO_SQawFcFWRGWAoZ0aVZqw6_pem6IGvCrTUGW1Q6WoKFbQXMzf9ICkpxn1ffLGFnvCWv8205dv97pZo9CzfiUA7Q53-X2Sd7uCQEM=@protonmail.com>
References: <kbrvpw3Y5y3ko3Wf2VtcywN462JjMW6YjqecduPOXwrek2sR9FkWfSv6G2Fph22UTAAbgII88MtOn1AFo223jjryNAz8YNbbQlFRVQo_HMY=@protonmail.com>
 <CABm2gDqxOtrMrTu2Ovx32USJT2T+6DRpexct1-k3zwEEnsDPMA@mail.gmail.com>
 <HfqjtQb_3TfhHaAZzYOcUoMic1iG40qUjqlKpzOZY6PSBW1bXVFtFW4zCHFRUdOoIhrard9ZPslzbrIYO0cM-Oi37mLzeEv6MZiQ7JtulE4=@protonmail.com>
 <CAGpPWDZVqas6v9nQtGtgk2mMOw9KQ+=dytBc+fBE6SNL=F3bqQ@mail.gmail.com>
 <CALeFGL18ULkGW4UA_5Fod4PVoe_LeF5e97eZdJja-ctf2paLWQ@mail.gmail.com>
 <CAGpPWDYUTCsSgirR7iNmbUw+cjEqHSymtzH4EtH=BQnZRjvgmQ@mail.gmail.com>
 <CABm2gDqVcAAz-Nqwt+SPBZrFyTUN3kizSTYkbuWSkoG0xJtoPQ@mail.gmail.com>
 <YexjEuO_SQawFcFWRGWAoZ0aVZqw6_pem6IGvCrTUGW1Q6WoKFbQXMzf9ICkpxn1ffLGFnvCWv8205dv97pZo9CzfiUA7Q53-X2Sd7uCQEM=@protonmail.com>
Message-ID: <CAGpPWDaDofscrK=k-Ej4Ze1u-VaoiJ1-Liy6DuuO3Wuss0aoyQ@mail.gmail.com>

@Jorge & Zmn
>  A recursive covenant guarantees that the same thing will happen in the
future.

Just a clarification: a recursive covenant does not necessarily guarantee
any particular thing will happen in the future. Both recursives and a
non-recursive covenant opcodes *can* be used to guarantee something will
happen. Neither *necessarily* guarantee anything (because of
the possibility of alternative spend paths). A covenant isn't just a
promise, its a restriction.

A "recursive covenant" opcode is one that allows loops in the progression
through covenant addresses. Here's an example of a set of transitions from
one address with a covenant in the spend path to another (or "exit" which
does not have a covenant restriction):

A -> B
A -> C
B -> C
C -> A
C -> exit

The possible combinations of changes are:

A -> B -> C -> exit
A -> C -> A -> ...
A -> B -> C -> A -> ...

This would be a recursive covenant with an exit. Remove the exit
transition, and you have a walled garden. Even with this walled garden, you
can avoid going through address B (since you can skip directly to C).

A covenant opcode that can allow for infinite recursion (often talked about
as a "recursive covenant") can be used to return to a previous state, which
allows for permanent walled gardens.

So I would instead characterize a bitcoin covenant as:

A covenant in an input script places a requirement/restriction on the
output script(s) that input sends to. Pretty much any covenant allows for a
chain or graph of covenant-laden addresses to be prescribed, while a
"recursive covenant" opcode allows previous nodes in that graph to be
returned to such that the states can be looped through forever (which may
or may not have some way to exit).

One potentially confusing thing about the way covenants are usually talked
about is that in technical discussions about the risks of covenants, what
is being talked about is not what a particular covenant opcode always does,
but rather what the boundaries are on what can be done with that opcode.
Pretty much any recursive covenant you could design would be able to be
used to create normal simple non-walled-garden situations. The question is,
since they do allow someone to create walled gardens, is that ok.

I suppose maybe an interesting possibility would be to have a covenant
limit placed into a covenant opcode. Eg, let's say that you have
OP_LIMITEDCOVENANT (OP_LC) and OP_LC specifies that the maximum covenant
chain is 100. The 100th consecutive output with an OP_LC use could simply
ignore it and be spent normally to anywhere (given that the rest of the
script allows it). This could effectively prevent the ability to create
walled gardens, without eliminating most interesting use cases. Among
people who care about covenants on this mailing list, the consensus seems
to be that infinitely recursive covenants are not something to be afraid
of. However, if maybe something like this could make more powerful
covenants acceptable to a larger group of people, it could be worth doing.

On Thu, May 12, 2022 at 7:20 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Jorge,
>
> > I fail to understand why non recursive covenants are called covenants at
> all. Probably I'm missing something, but I guess that's another topic.
>
> A covenant simply promises that something will happen in the future.
>
> A recursive covenant guarantees that the same thing will happen in the
> future.
>
> Thus, non-recursive covenants can be useful.
>
> Consider `OP_EVICT`, for example, which is designed for a very specific
> use-case, and avoids recursion.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/23bd0000/attachment-0001.html>

From billy.tetrud at gmail.com  Thu May 12 17:36:25 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Thu, 12 May 2022 12:36:25 -0500
Subject: [bitcoin-dev] Conjectures on solving the high interactivity
 issue in payment pools and channel factories
In-Reply-To: <mcikQmSFmiZw6Tq1GocybVcjGHNc-u9cP1aoZpJU-HEfgcqXXi1WhZSnEDMtEz3GfqAJGWpfZXjEBmsCXNSyLAgVNNcsSklERd-DJ8KeocE=@protonmail.com>
References: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
 <CAGpPWDa2wofye=KSq-vVNS0SOU34st9wm-hMhiYzGLTKMGuP5w@mail.gmail.com>
 <mcikQmSFmiZw6Tq1GocybVcjGHNc-u9cP1aoZpJU-HEfgcqXXi1WhZSnEDMtEz3GfqAJGWpfZXjEBmsCXNSyLAgVNNcsSklERd-DJ8KeocE=@protonmail.com>
Message-ID: <CAGpPWDb-P9ubvx1iMmYR8Gm2AOwg9cbu+fCKuXHMZk2JRwW=iw@mail.gmail.com>

@Antoine
>  it's also hard to predict in advance the liquidity needs of the
sub-pools.

Definitely. Better than not being able to use the pool at all when
someone's offline tho.

> this fan-out transaction could interfere with the confirmation of the
simple withdraw transactions
> So there is an open question about the "honest" usage of the sub-pool
states themselves.

I don't follow this one. How would it interfere? How would it call into
question the "honesty" of the sub-pools? Why would honesty matter? I would
assume they can all be structured trustlessly.

> one could envision an accumulator committing directly to balances too

Are you suggesting that there would be some kind of opcode that operates on
this accumulator to shift around balances of some participants without
disturbing others? Sounds reasonable.

> I think the challenge is to find a compact accumulator with those
properties.

The Merkle Sum Trees like are used in Taro sound like they could probably
be useful for that.

> It's more likely a lot of them will delegate this operation to
third-party providers, with the known reductions in terms of
trust-minimizations.

There is of course that limitation. But a third party empowered only to
keep the pool functioning is much better than one given the ability to
spend on your behalf without your confirmation. This would be a big
improvement despite there still being minor privacy downsides.

> Hmmm, how could you prevent the always-online service from using the
receiving-key in "spending" mode if the balance stacked there becomes
relevant ?

You mean if your balance in the pool is 1000 sats and the service
facilitates receiving 100 sats, that service could then steal those 100
sats? And you're asking how you could prevent that? Well first of all, if
you're in a channel, not only does your service need to want to steal your
funds, but your channel partner(s) must also sign for that as well - so
they both must be malicious for these funds to be stolen. I can't see a way
to prevent that, but at least this situation prevents them from stealing
your whole 1100 sats, and can only steal 100 sats.

>  see https://gitlab.com/lightning-signer/docs for wip in that direction.

Interesting. I'm glad someone's been working on this kind of thing

> A malicious pool participant could still commit her off-chain balance in
two partitions and send spends to the A&B hosting "receiving-keys" entities
without them being aware of the conflict, in the lack of a reconciliation
such as a publication space ?

Actually, I was envisioning that the always-online services holding a
receive-only key would *all* be online. So all participants of the pool
would have a representative, either one with a spending key or with just a
receiving-key (which could also be used to simply sign pool state changes
that don't negatively affect the balance of the user they represent). So
there still would be agreement among all participants on pool state
changes.

I kind of think if both techniques (sub-pools and limited-trust services)
are used, it might be able to substantially increase the ability for a pool
to operate effectively (ie substantially decrease the average downtime).

@ZmnSCPxj
> Is this not just basically channel factories?

It is.

> To reduce the disruption if any one pool participant is down, have each
sub-pool have only 2 participants each.

Yes. But the benefit of the pool over just having individual 2 person
channels is that you can change around the structure of the channels within
the pool without doing on-chain transactions. As Antoine mentioned, it may
often not be predictable which 2-person channels would be beneficial in the
future. So you want the pool to be as responsive as possible to the
changing needs of the pool.



On Tue, May 10, 2022 at 11:45 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Billy,
>
>
> > Very interesting exploration. I think you're right that there are issues
> with the kind of partitioning you're talking about. Lightning works because
> all participants sign all offchain states (barring data loss). If a
> participant can be excluded from needing to agree to a new state, there
> must be an additional mechanism to ensure the relevant state for that
> participant isn't changed to their detriment.
> >
> > To summarize my below email, the two techniques I can think for solving
> this problem are:
> >
> > A. Create sub-pools when the whole group is live that can be used by the
> sub- pool participants later without the whole group's involvement. The
> whole group is needed to change the whole group's state (eg close or open
> sub-pools), but sub-pool states don't need to involve the whole group.
>
> Is this not just basically channel factories?
>
> To reduce the disruption if any one pool participant is down, have each
> sub-pool have only 2 participants each.
> More participants means that the probability that one of them is offline
> is higher, so you use the minimum number of participants in the sub-pool: 2.
> This makes any arbitrary sub-pool more likely to be usable.
>
> But a 2-participant pool is a channel.
> So a large multiparticipant pool with sub-pools is just a channel factory
> for a bunch of channels.
>
> I like this idea because it has good tradeoffs, so channel factories ho.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/940da85e/attachment.html>

From alicexbt at protonmail.com  Thu May 12 19:59:38 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Thu, 12 May 2022 19:59:38 +0000
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
In-Reply-To: <CAMZUoKmXFxoSs5_5EM8ptAOpiiGP4ryqAibn5eghkbsaYz+oQA@mail.gmail.com>
References: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
 <CAMZUoKmXFxoSs5_5EM8ptAOpiiGP4ryqAibn5eghkbsaYz+oQA@mail.gmail.com>
Message-ID: <kQ7oSMJyxVmU6SPSgRfgGFb6rT0MtUEoZhaSaarnv1yalWc9aPD4tOQcVfanxWFFFDGSE3Nfiyg99BhQx8547obgRh3wCOlydMk6lNEInV4=@protonmail.com>

Hi Russell,

> As far as I understand things, I believe the whole notion of a MUST_SIGNAL state is misguided today. Please correct me if I'm misunderstanding something here.
> Back when BIP8 was first proposed by Shaolin Fry, we were in a situation where many existing clients waiting for segwit signalling had already been deployed. The purpose of mandatory signaling at that point in time was to ensure all these existing clients would be activated together with any BIP8 clients.

I won't consider it misguided. Not using MUST_SIGNAL gives opportunity for drama and politics during signaling. MUST_SIGNAL phase is initiated when height + 2016 >= timeoutheight and if a mining pool is still not sure about signaling at that point, maybe they are not interested in mining bitcoin anymore.

Rephrasing 'motivation' section in BIP 8:

BIP 9 activation is dependent on near unanimous hashrate signaling which may be impractical and result in veto by a small minority of non-signaling hashrate. All consensus rules are ultimately enforced by full nodes, eventually any new soft fork will be enforced by the economy. BIP 8 provides optional flag day activation after a reasonable time, as well as for accelerated activation by majority of hash rate before the flag date.

> We also don't need such a signal span over multiple blocks. Indeed, using version bits and signaling over multiple blocks is quite bad because it risks losing mining power if miners don't conform, or are unable to conform, to the version bits signal. (Recall at the time taproot's signaling period started, the firmware needed for many miners to signal version bits did not even exist yet!).

Solutions to these problems:

1)Developers plan and ship the binaries with activation code in time.
2)Mining pools pay attention, participate in soft fork discussions, hire competent developers and reach out to developers in community if require help.
3)Mining pools understand the loss involved in mining invalid blocks and upgrade during the first month of signaling.

If some mining pools still mine invalid blocks, Bitcoin should still work normally as it did during May-June 2021 when 50% hashrate went down due to some issues in China.

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.

------- Original Message -------
On Thursday, May 12th, 2022 at 12:52 AM, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi alicexbt,
>
> As far as I understand things, I believe the whole notion of a MUST_SIGNAL state is misguided today. Please correct me if I'm misunderstanding something here.
>
> Back when BIP8 was first proposed by Shaolin Fry, we were in a situation where many existing clients waiting for segwit signalling had already been deployed. The purpose of mandatory signaling at that point in time was to ensure all these existing clients would be activated together with any BIP8 clients.
>
> However, if such other clients do not exist, the MUST_SIGNAL state no longer accomplishes its purpose. Going forward, I think there is little reason to expect such other clients to exist alongside a BIP8 deployment. If everyone uses a BIP8 deployment, then there are no other clients to activate. Alternatively, Speedy Trial was specifically designed to avoid this parallel deployment for the reason that several people object to allowing their client's non-BIP8 activation logic to be hijacked in this manner.
>
> Now I understand that some people would like *some* signal on the chain that indicates a soft-fork activation in order to allow people who object to the fork to make an "anti-fork" that rejects blocks containing the soft-fork signal. And while some sort of mandatory version bit signaling *could* be used for this purpose, we do not *have* to use version bits. We also don't need such a signal span over multiple blocks. Indeed, using version bits and signaling over multiple blocks is quite bad because it risks losing mining power if miners don't conform, or are unable to conform, to the version bits signal. (Recall at the time taproot's signaling period started, the firmware needed for many miners to signal version bits did not even exist yet!).
>
> A soft-fork signal to enable an "anti-fork" only needs to be on a single block and it can be almost anything. For example we could have a signal that at the block at lockin or perhaps the block at activation requires that the coinbase must *not* contain the suffix "taproot sucks!". This suffices to prepare an "anti-fork" which would simply require that the specified block must contain the suffix "taproot sucks!".
>
> Anyway, I'm sure there are lots of design choices available better than a MUST_SIGNAL state that does not risk potentially taking a large fraction of mining hardware offline for a protracted period of time.
>
> On Tue, May 10, 2022 at 10:02 AM alicexbt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi Bitcoin Developers,
>>
>> There were some disagreements with speedy trial activation method recently and BIP 8 became controversial because of LOT earlier. I have tried to solve these two problems after reading some arguments for/against different activation methods by removing LOT from BIP 8 and calculating MUST_SIGNAL state based on threshold reached.
>>
>> BIP draft with no code and some changes in BIP 8: https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1
>>
>> State transitions diagram: https://i.imgur.com/dj4bFVK.png
>>
>> This proposal removes lockinontimeout flag, activation never fails although MUST_SIGNAL can be longer if miners signaling does not reach the threshold. Longer period for MUST_SIGNAL state is useful for coordination if LOCKED_IN was not reached.
>>
>> MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached and blocks that fail to signal in MUST_SIGNAL phase are invalid.
>>
>> Example:
>>
>> - This activation method is used for a soft fork
>> - Only 60% miners signaled readiness and timeout height was reached
>> - MUST_SIGNAL phase starts and will last for 4*2016 blocks
>> - LOCKED_IN and ACTIVE states remain same as BIP 8
>> - Soft fork is activated with a delay of 2 months
>>
>> /dev/fd0
>>
>> Sent with [ProtonMail](https://protonmail.com/) secure email.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/29942cf8/attachment-0001.html>

From gsanders87 at gmail.com  Thu May 12 22:56:22 2022
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 12 May 2022 18:56:22 -0400
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
In-Reply-To: <kQ7oSMJyxVmU6SPSgRfgGFb6rT0MtUEoZhaSaarnv1yalWc9aPD4tOQcVfanxWFFFDGSE3Nfiyg99BhQx8547obgRh3wCOlydMk6lNEInV4=@protonmail.com>
References: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
 <CAMZUoKmXFxoSs5_5EM8ptAOpiiGP4ryqAibn5eghkbsaYz+oQA@mail.gmail.com>
 <kQ7oSMJyxVmU6SPSgRfgGFb6rT0MtUEoZhaSaarnv1yalWc9aPD4tOQcVfanxWFFFDGSE3Nfiyg99BhQx8547obgRh3wCOlydMk6lNEInV4=@protonmail.com>
Message-ID: <CAB3F3DubWD-xV53dBTHU6agzhTz6mGV7DN5p=5OCZ=4-put6WQ@mail.gmail.com>

I think you may be confused. Mandatory signaling is not the same thing as
mandatory activation on timeout, aka Lock On Timeout aka LOT=true.

These are two related but separate things.

On Thu, May 12, 2022, 6:53 PM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Russell,
>
>
> As far as I understand things, I believe the whole notion of a MUST_SIGNAL
> state is misguided today. Please correct me if I'm misunderstanding
> something here.
>
> Back when BIP8 was first proposed by Shaolin Fry, we were in a situation
> where many existing clients waiting for segwit signalling had already been
> deployed. The purpose of mandatory signaling at that point in time was to
> ensure all these existing clients would be activated together with any BIP8
> clients.
>
>
> I won't consider it misguided. Not using MUST_SIGNAL gives opportunity for
> drama and politics during signaling. MUST_SIGNAL phase is initiated when
> height + 2016 >= timeoutheight and if a mining pool is still not sure about
> signaling at that point, maybe they are not interested in mining bitcoin
> anymore.
>
> Rephrasing 'motivation' section in BIP 8:
>
> BIP 9 activation is dependent on near unanimous hashrate signaling which
> may be impractical and result in veto by a small minority of
> non-signaling hashrate. All consensus rules are ultimately enforced by full
> nodes, eventually any new soft fork will be enforced by the economy. BIP 8
> provides optional flag day activation after a reasonable time, as well as
> for accelerated activation by majority of hash rate before the flag date.
>
> We also don't need such a signal span over multiple blocks. Indeed, using
> version bits and signaling over multiple blocks is quite bad because it
> risks losing mining power if miners don't conform, or are unable to
> conform, to the version bits signal. (Recall at the time taproot's
> signaling period started, the firmware needed for many miners to signal
> version bits did not even exist yet!).
>
>
> Solutions to these problems:
>
> 1)Developers plan and ship the binaries with activation code in time.
> 2)Mining pools pay attention, participate in soft fork discussions, hire
> competent developers and reach out to developers in community if require
> help.
> 3)Mining pools understand the loss involved in mining invalid blocks and
> upgrade during the first month of signaling.
>
> If some mining pools still mine invalid blocks, Bitcoin should still work
> normally as it did during May-June 2021 when 50% hashrate went down due to
> some issues in China.
>
>
> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
>
> ------- Original Message -------
> On Thursday, May 12th, 2022 at 12:52 AM, Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi alicexbt,
>
> As far as I understand things, I believe the whole notion of a MUST_SIGNAL
> state is misguided today. Please correct me if I'm misunderstanding
> something here.
>
> Back when BIP8 was first proposed by Shaolin Fry, we were in a situation
> where many existing clients waiting for segwit signalling had already been
> deployed. The purpose of mandatory signaling at that point in time was to
> ensure all these existing clients would be activated together with any BIP8
> clients.
>
> However, if such other clients do not exist, the MUST_SIGNAL state no
> longer accomplishes its purpose. Going forward, I think there is little
> reason to expect such other clients to exist alongside a BIP8 deployment.
> If everyone uses a BIP8 deployment, then there are no other clients to
> activate. Alternatively, Speedy Trial was specifically designed to avoid
> this parallel deployment for the reason that several people object to
> allowing their client's non-BIP8 activation logic to be hijacked in this
> manner.
>
> Now I understand that some people would like *some* signal on the chain
> that indicates a soft-fork activation in order to allow people who object
> to the fork to make an "anti-fork" that rejects blocks containing the
> soft-fork signal. And while some sort of mandatory version bit signaling
> *could* be used for this purpose, we do not *have* to use version bits. We
> also don't need such a signal span over multiple blocks. Indeed, using
> version bits and signaling over multiple blocks is quite bad because it
> risks losing mining power if miners don't conform, or are unable to
> conform, to the version bits signal. (Recall at the time taproot's
> signaling period started, the firmware needed for many miners to signal
> version bits did not even exist yet!).
>
> A soft-fork signal to enable an "anti-fork" only needs to be on a single
> block and it can be almost anything. For example we could have a signal
> that at the block at lockin or perhaps the block at activation requires
> that the coinbase must *not* contain the suffix "taproot sucks!". This
> suffices to prepare an "anti-fork" which would simply require that the
> specified block must contain the suffix "taproot sucks!".
>
> Anyway, I'm sure there are lots of design choices available better than a
> MUST_SIGNAL state that does not risk potentially taking a large fraction of
> mining hardware offline for a protracted period of time.
>
> On Tue, May 10, 2022 at 10:02 AM alicexbt via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi Bitcoin Developers,
>>
>> There were some disagreements with speedy trial activation method
>> recently and BIP 8 became controversial because of LOT earlier. I have
>> tried to solve these two problems after reading some arguments for/against
>> different activation methods by removing LOT from BIP 8 and calculating
>> MUST_SIGNAL state based on threshold reached.
>>
>> BIP draft with no code and some changes in BIP 8:
>> https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1
>>
>> State transitions diagram: https://i.imgur.com/dj4bFVK.png
>>
>> This proposal removes lockinontimeout flag, activation never fails
>> although MUST_SIGNAL can be longer if miners signaling does not reach the
>> threshold. Longer period for MUST_SIGNAL state is useful for coordination
>> if LOCKED_IN was not reached.
>>
>> MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached and
>> blocks that fail to signal in MUST_SIGNAL phase are invalid.
>>
>> Example:
>>
>> - This activation method is used for a soft fork
>> - Only 60% miners signaled readiness and timeout height was reached
>> - MUST_SIGNAL phase starts and will last for 4*2016 blocks
>> - LOCKED_IN and ACTIVE states remain same as BIP 8
>> - Soft fork is activated with a delay of 2 months
>>
>>
>> /dev/fd0
>>
>> Sent with ProtonMail <https://protonmail.com/> secure email.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220512/ee216a78/attachment.html>

From belcher at riseup.net  Fri May 13 10:02:20 2022
From: belcher at riseup.net (Chris Belcher)
Date: Fri, 13 May 2022 11:02:20 +0100
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
 for BIP39 seeds
In-Reply-To: <PFBgbTn4_7JXQaRMlMjZDVrGBIr4OKfMK1ftW38cY-8Qu6tm_GllxDOWEj7K4zHkmQz9jA9NO_9rT_UzTSw9rr3RneEKTNhz826LmEIWF7w=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
 <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
 <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>
 <PFBgbTn4_7JXQaRMlMjZDVrGBIr4OKfMK1ftW38cY-8Qu6tm_GllxDOWEj7K4zHkmQz9jA9NO_9rT_UzTSw9rr3RneEKTNhz826LmEIWF7w=@protonmail.com>
Message-ID: <05fdc268-1701-cd62-181d-906b6b5d4f9d@riseup.net>

Hello waxwing,

 > A user sacrifices X amount of time-value-of-money (henceforth TVOM) 
by committing in Joinmarket with FB1. He then uses the same FB1 in 
Teleport, let's say. If he gets benefit Y from using FB1 in Joinmarket, 
and benefit Z in Teleport, then presumably he'll only do it if 
(probabilistically) he thinks Y+Z > X.

 > But as an assessor of FB1 in Joinmarket, I don't know if it's also 
being used for Teleport, and more importantly, if it's being used 
somewhere else I'm not even aware of. Now I'm not an economist I admit, 
so I might not be intuit-ing this situation right, but it fees to me 
like the right answer is "It's fine for a closed system, but not an open 
one." (i.e. if the set of possible usages is not something that all 
participants have fixed in advance, then there is an effective Sybilling 
problem, like I'm, as an assessor, thinking that sacrificed value 100 is 
there, whereas actually it's only 15, or whatever.)


I don't entirely agree with this. The value of the sacrifice doesn't 
change if the fidelity bond owner starts using it for Teleport as well 
as Joinmarket. The sacrifice is still 100. Even if the owner doesn't run 
any maker at all the sacrifice would still be 100, because it only 
depends on the bitcoin value and locktime. In your equation Y+Z > X, 
using a fidelity bond for more applications increases the 
left-hand-side, while the right-hand-side X remains the same. As 
protection from a sybil attack is calculated using only X, it makes no 
difference what Y and Z are, the takers can still always calculate that 
"to sybil attack the coinjoin I'm about to make, it costs A btc locked 
up for B time".

Regarding fidelity bonds being used for both, I expect that most 
fidelity bond owners will use their bonds with both Joinmarket and 
Teleport, to not do that is just leaving money on the table.

If an attacker locks up the 100k btc or whatever the requirement is now, 
and actually does a successful sybil attack against Joinmarket, then 
they could at the same time do a successful sybil attack against 
teleport with little added cost. So both markets form a single fidelity 
bond ecosystem. This is a similar situation to merge-mining bitcoin with 
an altcoin that also uses SHA256^2 for proof of work. The two or more 
coins form one mining ecosystem. This results in the users of the small 
altcoin benefiting from having their transactions protected by bitcoin's 
massive hashrate. In this analogy the new small Teleport system can very 
quickly benefit from the large amount of fidelity bonds already used in 
Joinmarket.

Yes the hypothetical attacker can attack all systems at once, but the 
defenders can defend all systems at once (and we can say not just that 
they "can" do it, but that they "will" do it, or else they leave money 
on the table). The mathematics which gives a huge advantage to the 
defender still applies.

----

You've convinced me that specifying the exact form of the fidelity bond 
certificate is a bad idea. I'll leave it more general, saying just that 
wallets should be able to do SignMessage using the timelocked privkey. 
And I'll leave the example signature in the test vectors.

I've made edits to this effect on the gist:
https://gist.github.com/chris-belcher/7257763cedcc014de2cd4239857cd36e/revisions#diff-4f1f364f340b78bdfe9dca2ff50784bd312d49be220e5e5c2e4675447f79c6e8

It's worth noting that even if the certificate message is different 
across the two systems, a fidelity bond owner can still create two 
signatures over two different messages (e.g. 
"fidelity-bond-cert|<pubkey>|<expiry>" and 
"fidelity-bond-cert-teleport|<pubkey>|<expiry>").




From billy.tetrud at gmail.com  Fri May 13 12:23:39 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Fri, 13 May 2022 07:23:39 -0500
Subject: [bitcoin-dev] Improving BIP 8 soft fork activation
In-Reply-To: <k_QSGEzNPna1m81VnNhvzXE1e6asLJwXOslQNRTOs6Sqv2BG9K3t0UznguMpoeB11V3I4by5QxbNpyWlRTjtGrO8Y_nlGOaO03Qj-2H9a7A=@protonmail.com>
References: <8ZKbVUejj2P32rYfjnMaE6sLpiSUdQNHI-cNNpQ2KZiDT-TYrXrKUxJidZH0O5U1jMMllgpF2qiYuahUBeCBQ8ZAIKhIvIgZJ7PM9_b2t64=@protonmail.com>
 <CAGpPWDbHUqf5_APr3e_hr7npo=ObJvLuWooJc5azMDCDOVSfOA@mail.gmail.com>
 <k_QSGEzNPna1m81VnNhvzXE1e6asLJwXOslQNRTOs6Sqv2BG9K3t0UznguMpoeB11V3I4by5QxbNpyWlRTjtGrO8Y_nlGOaO03Qj-2H9a7A=@protonmail.com>
Message-ID: <CAGpPWDb=O1UxgbvZi2pwxA+4vnMbjcymwCjT2+hp5L=Kw6JGfQ@mail.gmail.com>

@alicexbt
>  I think 'support' and 'opposition' can be replaced with readiness.
Miners should not consider signaling as voting.

I agree that it isn't voting, its signaling. But whether or not you call it
'readiness' or 'support', some miners will use it to signal 'support' and
will refuse to become ready if they do not support the change. Regardless,
I'm open to calling it "readiness" instead.

@Russell
>  I'm sure there are lots of design choices available better than a
MUST_SIGNAL state that does not risk potentially taking a large fraction of
mining hardware offline for a protracted period of time.

I tend to agree. The case where the fork has not locked in, but some miners
are beginning to orphan other miners' blocks, seems like a rather chaotic
state to program into an activation mechanism. I do like the idea of using
orphaning to ensure that miners are alerted to the fact that a fork has
*already* locked in, but such a thing should be done at a low level (eg
orphan <10% of their blocks) - just high enough so the drop in revenue
makes them investigate, but as minimal as possible to avoid lots of orphans
and loss of hashpower.


On Wed, May 11, 2022 at 10:15 AM alicexbt <alicexbt at protonmail.com> wrote:

> Hi Billy,
>
> Thanks for the feedback. I agree with everything
> and bip-trinary-version-signaling looks interesting.
>
> > A primary difference from both BIP8 and BIP9 is that this proposal uses
> tri-state version signaling (rather than binary version bits) that can
> encode both active support as well as active opposition to an active soft
> fork.
>
>
> I think 'support' and 'opposition' can be replaced with readiness. Miners
> should not consider signaling as voting.
>
> > The meaning for each ternary value is as follows:
>
>
> 0 - No signal
> 1 - Ready for new consensus rules
> 2 - Not ready for new consensus rules
>
> The concept of a minimum and maximum threshold sounds intriguing, and I'm
> interested to read what other developers have to say about it.
>
> Concept ACK on removing LOT, using tri-state version signaling, min/max
> threshold and required threshold calculation.
>
>
> /dev/fd0
>
> Sent with ProtonMail secure email.
> ------- Original Message -------
> On Tuesday, May 10th, 2022 at 9:01 PM, Billy Tetrud billy.tetrud at gmail.com
> wrote:
>
>
>
> > I think this is a useful proposal. There are certainly things about BIP9
> that BIP8 fixes. I believe taproot's speedy trial did kind of a hybrid, but
> a BIP spec was never produced for it afaik. A possibly unhelpful comment:
> >
> > > minimum_activation_height
> > > I think a minor improvement would be to specify this as
> minimum_activation_blocks, ie a number of blocks passed the start_height.
> Slightly easier to reason about and change when necessary. I proposed
> semantics like that here.
> > > In any case, I'll give this a concept ACK. I would very much like
> future soft forks to use a previously specified activation mechanism rather
> than rolling out a rushed unspeced thing as part of the (very orthogonal)
> soft fork implementation.
> > > On Tue, May 10, 2022 at 9:02 AM alicexbt via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> > > Hi Bitcoin Developers,
> > >
> > > There were some disagreements with speedy trial activation method
> recently and BIP 8 became controversial because of LOT earlier. I have
> tried to solve these two problems after reading some arguments for/against
> different activation methods by removing LOT from BIP 8 and calculating
> MUST_SIGNAL state based on threshold reached.
> > >
> > > BIP draft with no code and some changes in BIP 8:
> https://gist.github.com/1440000bytes/5e58cad7ba9d9c1a7000d304920fe6f1
> > >
> > > State transitions diagram: https://i.imgur.com/dj4bFVK.png
> > >
> > > This proposal removes lockinontimeout flag, activation never fails
> although MUST_SIGNAL can be longer if miners signaling does not reach the
> threshold. Longer period for MUST_SIGNAL state is useful for coordination
> if LOCKED_IN was not reached.
> > >
> > > MUST_SIGNAL = ((100-t)/10)*2016 blocks, where t is threshold reached
> and blocks that fail to signal in MUST_SIGNAL phase are invalid.
> > >
> > > Example:
> > >
> > > - This activation method is used for a soft fork
> > > - Only 60% miners signaled readiness and timeout height was reached
> > > - MUST_SIGNAL phase starts and will last for 4*2016 blocks
> > > - LOCKED_IN and ACTIVE states remain same as BIP 8
> > > - Soft fork is activated with a delay of 2 months
> > >
> > > /dev/fd0
> > >
> > > Sent with ProtonMail secure
> email._______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220513/6fbdf8b8/attachment.html>

From ZmnSCPxj at protonmail.com  Fri May 13 12:44:14 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 13 May 2022 12:44:14 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <05fdc268-1701-cd62-181d-906b6b5d4f9d@riseup.net>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
 <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
 <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>
 <PFBgbTn4_7JXQaRMlMjZDVrGBIr4OKfMK1ftW38cY-8Qu6tm_GllxDOWEj7K4zHkmQz9jA9NO_9rT_UzTSw9rr3RneEKTNhz826LmEIWF7w=@protonmail.com>
 <05fdc268-1701-cd62-181d-906b6b5d4f9d@riseup.net>
Message-ID: <FiQ49v3gOISKrdhs08_rsoYj9pwwcLRvwXbXPgGV3ulDGW70Wsfk3AMAX1KpOByW3iTm_aQdi6tECdMmDcycl1qIM2KNlJz4DiHZ8omhT8U=@protonmail.com>

Good morning Chris,

> Hello waxwing,
>
> > A user sacrifices X amount of time-value-of-money (henceforth TVOM)
>
> by committing in Joinmarket with FB1. He then uses the same FB1 in
> Teleport, let's say. If he gets benefit Y from using FB1 in Joinmarket,
> and benefit Z in Teleport, then presumably he'll only do it if
> (probabilistically) he thinks Y+Z > X.
>
> > But as an assessor of FB1 in Joinmarket, I don't know if it's also
>
> being used for Teleport, and more importantly, if it's being used
> somewhere else I'm not even aware of. Now I'm not an economist I admit,
> so I might not be intuit-ing this situation right, but it fees to me
> like the right answer is "It's fine for a closed system, but not an open
> one." (i.e. if the set of possible usages is not something that all
> participants have fixed in advance, then there is an effective Sybilling
> problem, like I'm, as an assessor, thinking that sacrificed value 100 is
> there, whereas actually it's only 15, or whatever.)
>
>
> I don't entirely agree with this. The value of the sacrifice doesn't
> change if the fidelity bond owner starts using it for Teleport as well
> as Joinmarket. The sacrifice is still 100. Even if the owner doesn't run
> any maker at all the sacrifice would still be 100, because it only
> depends on the bitcoin value and locktime. In your equation Y+Z > X,
>
> using a fidelity bond for more applications increases the
> left-hand-side, while the right-hand-side X remains the same. As
> protection from a sybil attack is calculated using only X, it makes no
> difference what Y and Z are, the takers can still always calculate that
> "to sybil attack the coinjoin I'm about to make, it costs A btc locked
> up for B time".

I think another perspective here is that a maker with a single fidelity bond between both Teleport and Joinmarket has a single identity in both systems.

Recall that not only makers can be secretly surveillors, but takers can also be secretly surveillors.

Ideally, the maker should not tie its identity in one system to its identity in another system, as that degrades the privacy of the maker as well.

And the privacy of the maker is the basis of the privacy of its takers.
It is the privacy of the coins the maker offers, that is being purchased by the takers.


A taker can be a surveillor as well, and because the identity between JoinMarket and Teleport is tied via the single shared fidelity bond, a taker can perform partial-protocol attacks (i.e. aborting at the last step) to identify UTXOs of particular makers.
And it can perform attacks on both systems to identify the ownership of maker coins in both systems.

Since the coins in one system are tied to that system, this increases the information available to the surveillor: it is now able to associate coins in JoinMarket with coins in Teleport, via the shared fidelity bond identity.
It would be acceptable for both systems to share an identity if coins were shared between the JoinMarket and Teleport maker clients, but at that point they would arguably be a single system, not two separate systems, and that is what you should work towards.


Regards,
ZmnSCPxj

From billy.tetrud at gmail.com  Fri May 13 13:05:47 2022
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Fri, 13 May 2022 08:05:47 -0500
Subject: [bitcoin-dev] Soliciting more discussion for
	OP_CONSTRAINDESTINATION (a covenant opcode)
Message-ID: <CAGpPWDZskzjKeSOZ3G8Z+1kVtDiKHzzOwk=oNgvm+1MbqzNZLg@mail.gmail.com>

Hi all,

Since there's recently been a lot more interest in discussing covenants and
alternative covenant proposals because of CTV, I figured I'd bring up my
own proposed covenant opcode again while the urge is still fresh.

To be clear upfront, this opcode has a spec, but nothing else. No tests. No
implementation. No signet. No tooling. While this is a serious proposal
that I think has a lot of benefits over any other covenant opcode proposal,
I am not suggesting that this should supplant CTV. I also don't have any
plans to work on an implementation of OP_CONSTRAINDESTINATION, and I
certainly wouldn't without more interest and an equal partner on a project
like this.  I think CTV is a quite useful opcode that is simple and
incremental. OP_CD on the other hand is significantly more powerful, which
would be likely to lead to even more contention than what CTV has had.

To the opcode itself, there is already plenty of exposition about it in the
spec:

https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md

So I wanted to discuss it from the perspective of what it enables, pros and
cons, and key considerations:

*OP_CONSTRAINDESTINATION alone*

   - Like OP_CTV
      - Is fully enumerated (not open ended)
   - Unlike OP_CTV
      - Enables infinitely recursive covenants
      - Does not and cannot prevent malleability on its own

The wallet vaults that can be created
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
using this are more flexible than ones that can be created with OP_CTV:

   - Spends from a wallet vault can spend arbitrary amounts, and send the
   rest back to a change address, just like a normal transaction.
   - Arbitrary amounts of coins can be sent directly to any of the
   addresses involved in the wallet vault without any risk of loss of funds.
   - Anchor outputs are not (necessarily) necessary for fee bumping. A user
   can have the option of creating a transaction that includes other inputs
   that can contribute to the fee. Those inputs can also send to other
   outputs, allowing one to basically attach an anchor output at
   transaction-creation-time if they think they want it for CPFP fee bumping.

One less-than-ideal property shared with CTV wallet vaults:

   - If the hot wallet / intermediate wallet key is stolen, the attacker
   can steal funds after the owner initiates a normal spend.

The opcode requires some mechanism for fee limiting:

   - As currently specified, an attacker who gets access to the hot key can
   fee-grief the owner of the vault by spending all the coins as fees. The
   proposed solution to this is to add an addition opcode to limit the fees,
   called OP_LIMITFEECONTRIBUTION
   <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/lfc/bip-limit-fee-contribution.md>.
   Another solution would be to require 100% of the output values go to the
   destinations passed to OP_CONSTRAINDESTINATION, and rely on CPFP on an
   anchor output to pay the fees, which seems less than ideal. A third
   solution would be to include sponsor transactions alongside the opcode and
   rely on those instead of CPFP. While I think sponsor transactions would be
   very useful, always relying on an external wallet to pay the fees is IMO
   not super great since it allows for inconvenient scenarios if all your
   money is in this secure vault, in which case you simply wouldn't be able to
   get it out without either first acquiring more bitcoin in a hotter wallet,
   or doing a full recovery transaction with all your wallet vault keys.

The downsides compared to CTV:

   - Increased implementation complexity and complexity of the possibility
   space. The opcode's main purpose of ensuring that only certain addresses
   are sent to might be simpler than CTV, but the aspect of counting output
   values pushes it into more complex territory. And when you consider the
   solutions to fee-griefing, that adds additional implementation and
   possibility-space complexity (depending on how its done).
   - txid malleability


*OP_CONSTRAINDESTINATION + OP_PUSHOUTPUTSTACK*
OP_PUSHOUTPUTSTACK
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/pos/bip-pushoutputstack.md>
is
an opcode that allows a script to dynamically add local state to an output
being created.

   - Unlike OP_CTV
   - Also enables infinitely recursive covenants and does not prevent
      malleability.
      - Can be open ended (not fully enumerated)
      - Can produce dynamic state.

The wallet vaults that can be created with this combination of opcodes is a
bit better than ones with just OP_CD on its own:

   - Even if the hot wallet key is stolen, the attacker cannot steal funds
   without compromising all the seeds that make up the wallet vault.

However, the complexity is substantially higher:

   - Being able to push dynamic state onto transactions substantially
   increases the possibility space of covenant chains. There may be
   significant consequences of this that no one has thought of yet.

*Summary*

These opcodes would allow the creation of wallet vaults that could be
intuitively used in almost the same way that a standard wallet can be used,
including mixing in arbitrary inputs and outputs (including ones you don't
own). With one more opcode
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/bbv/bip-beforeblockverify.md>,
funds could be sent directly out of a wallet vault in a single transaction
(whereas most wallet vaults require two transactions to send money out to
an arbitrary destination).

The opcodes are significantly more complex and powerful than OP_CTV, and
also substantially less developed. However, I think they demonstrate a
number of important considerations for covenants in the context of wallet
vaults. Please feel free to respond or ask questions here or as a github
issue.

I think wallet vaults in particular are a very important mechanism to
enable much more secure self-custody setups without sacrificing so much
usability as normal multisig wallets require. Wallet vaults could enable
significantly faster growth in the rate of bitcoin holders who
self-custody. CTV is the only opcode that is ready, and no other opcode is
even being developed, let alone close to being ready. I don't see APO as a
good practical covenant mechanism as currently defined. Any "next" covenant
opcode would likely be 4-6 years out. I believe centralized custody is a
huge problem in the bitcoin ecosystem, so I think making it easier for
people to securely self-custody their bitcoins is an incredibly important
area of development. I believe even *if* some other covenant opcode makes
CTV completely obsolete (which it isn't at all clear to me is a likely
scenario), a 4-6 year head start on better self-custody mechanisms could go
a long way to saving a lot of people who need bitcoin a lot of pain (from
both custodial shenanigans and self-custody mishaps).

Cheers,
BT
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220513/3f91a9e9/attachment-0001.html>

From aj at erisian.com.au  Fri May 13 21:43:47 2022
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 14 May 2022 07:43:47 +1000
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CAMZUoKmhOpt2N+6YxxREMzmRca2hNnPHBMRMsT09efkEs0CJiQ@mail.gmail.com>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
 <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
 <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>
 <fkMEju1kNN5OJPoI1d2K99sV0bhr7qeAnhVbv-99K_UL48YQyHp-rbqEfQ81crx-thaA8JuUY4-eFlYUskvFC_8h6DIhdF0Wj-v-4DNnlcI=@protonmail.com>
 <CAMZUoKmhOpt2N+6YxxREMzmRca2hNnPHBMRMsT09efkEs0CJiQ@mail.gmail.com>
Message-ID: <20220513214347.GA2463@erisian.com.au>

On Thu, May 12, 2022 at 06:48:44AM -0400, Russell O'Connor via bitcoin-dev wrote:
> On Wed, May 11, 2022 at 11:07 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> > So really: are recursive covenants good or...?
> My view is that recursive covenants are inevitable.  It is nearly
> impossible to have programmable money without it because it is so difficult
> to avoid.

I think my answer is that yes they are good: they enable much more
powerful contracting.

Of course, like any cryptographic tool they can also be harmful to you if
you misuse them, and so before you use them yourself you should put in the
time to understand them well enough that you *don't* misuse them. Same as
using a kitchen knife, or riding a bicycle, or swimming. Can be natural
to be scared at first, too.

> Given that we cannot have programmable money without recursive covenants
> and given all the considerations already discussed regarding them, i.e. no
> worse than being compelled to co-sign transactions, and that user generated
> addresses won't be encumbered by a covenant unless they specifically
> generate it to be, I do think it makes sense to embrace them.

I think that's really the easy way to be sure *you* aren't at risk
from covenants: just follow the usual "not your keys, not your coins"
philosophy.

The way you currently generate an address from a private key already
guarantees that *your* funds won't be encumbered by any covenants; all
you need to do is to keep doing that. And generating the full address
yourself is already necessary with taproot: if you don't understand
all the tapscript MAST paths, then even though you can spend the coin,
one of those paths you don't know about might already allow someone to
steal your funds. But if you generated the address, you (or at least your
software) will understand everything and not include anything dangerous,
so your funds really are safu.

It may be that some people will refuse to send money to your address
because they have some rule that says "I'll only send money to people who
encumber all their funds with covenant X" and you didn't encumber your
address in that way -- but that just means they're refusing to pay you,
just as people who say "I'll only pay you off-chain via coinbase" or
"I'll only pay you via SWIFT" won't send funds to your bitcoin address.

Other examples might include "we only support segwit-v0 addresses not
taproot ones", or "you're on an OFAC sanctions list so I can't send
to you or the government will put me in prison" or "my funds are in a
multisig with the government who won't pay to anyone who isn't also in
a multisig with them".

It does mean you still need people with the moral fortitude to say "no,
if you can't pay me properly, we can't do business" though.

Even better: in so far as wallet software will just ignore any funds
sent to addresses that they didn't generate themselves according to the
rules you selected, you can already kind of outsource that policy to
your wallet. And covenants, recursive or otherwise, don't change that.


For any specific opcode proposal, I think you still want to consider

 1) how much you can do with it
 2) how efficient it is to validate (and thus how cheap it is to use)
 3) how easy it is to make it do what you want
 4) how helpful it is at preventing bugs
 5) how clean and maintainable the validation code is

I guess to me CTV and APO are weakest at (1); CAT/CSFS falls down on
(3) and (4); OP_TX is probably weakest at (5) and maybe not as good as
we'd like at (3) and (4)?

Cheers,
aj


From roconnor at blockstream.com  Fri May 13 23:33:36 2022
From: roconnor at blockstream.com (Russell O'Connor)
Date: Fri, 13 May 2022 19:33:36 -0400
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <20220513214347.GA2463@erisian.com.au>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
 <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
 <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>
 <fkMEju1kNN5OJPoI1d2K99sV0bhr7qeAnhVbv-99K_UL48YQyHp-rbqEfQ81crx-thaA8JuUY4-eFlYUskvFC_8h6DIhdF0Wj-v-4DNnlcI=@protonmail.com>
 <CAMZUoKmhOpt2N+6YxxREMzmRca2hNnPHBMRMsT09efkEs0CJiQ@mail.gmail.com>
 <20220513214347.GA2463@erisian.com.au>
Message-ID: <CAMZUoK=stZaPcTNfC_KdOxbQp=VyORwC3osSm3sTeQ0WZ4ejYQ@mail.gmail.com>

On Fri, May 13, 2022 at 5:43 PM Anthony Towns <aj at erisian.com.au> wrote:

> For any specific opcode proposal, I think you still want to consider
>
>  1) how much you can do with it
>  2) how efficient it is to validate (and thus how cheap it is to use)
>  3) how easy it is to make it do what you want
>  4) how helpful it is at preventing bugs
>  5) how clean and maintainable the validation code is
>
> I guess to me CTV and APO are weakest at (1); CAT/CSFS falls down on
> (3) and (4); OP_TX is probably weakest at (5) and maybe not as good as
> we'd like at (3) and (4)?
>

FWIW, I think the rmain reasons to do CAT+CSFS is to validate oracle
messages and pubkey delegation.  The ability to covenants would be
secondary and would mostly serve to get us some real user data about what
sort of covenants users find especially valuable.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220513/e19a4b5f/attachment.html>

From erik at q32.com  Sat May 14 13:32:18 2022
From: erik at q32.com (Erik Aronesty)
Date: Sat, 14 May 2022 09:32:18 -0400
Subject: [bitcoin-dev] Speedy covenants (OP_CAT2)
In-Reply-To: <CAMZUoK=stZaPcTNfC_KdOxbQp=VyORwC3osSm3sTeQ0WZ4ejYQ@mail.gmail.com>
References: <161946014-482cdec305e2bd7a2c3fc4774c70239d@pmq1v.m5r2.onet>
 <M80pb4TxcE1yCMCW4IboyTtx8MSvp8m9tphXe2EYvIvcrcf2Wzsn4ManJw8EP_ri-ohqtIOPrEaw7XkUcTO3lfVSLN4WMUwpromwzLm15Kc=@protonmail.com>
 <CAMZUoKnzjcYDM-mOhT00P7YO18YmjxRkYsfO6QFtYFn0mEtLQw@mail.gmail.com>
 <fkMEju1kNN5OJPoI1d2K99sV0bhr7qeAnhVbv-99K_UL48YQyHp-rbqEfQ81crx-thaA8JuUY4-eFlYUskvFC_8h6DIhdF0Wj-v-4DNnlcI=@protonmail.com>
 <CAMZUoKmhOpt2N+6YxxREMzmRca2hNnPHBMRMsT09efkEs0CJiQ@mail.gmail.com>
 <20220513214347.GA2463@erisian.com.au>
 <CAMZUoK=stZaPcTNfC_KdOxbQp=VyORwC3osSm3sTeQ0WZ4ejYQ@mail.gmail.com>
Message-ID: <CAJowKgKfy7-2UsBoypHmPkGnMb5V+m7Mt3ek5scsEHwj0YW9wA@mail.gmail.com>

>
>
>
> FWIW, I think the rmain reasons to do CAT+CSFS is to validate oracle
> messages and pubkey delegation.  The ability to covenants would be
> secondary and would mostly serve to get us some real user data about what
> sort of covenants users find especially valuable.
>

I don't think this should be discounted.   I think it's worthwhile to
willingly include possibly less-than-awesome, but proven perfectly-safe
opcodes, knowing we will have to validate them forever, even if new, cooler
and more widely-used ones replace them years from now.

I honestly don't think the development of the latter will happen without
some version of the former.

Personally I am satisfied:

  - the safety of covenants, in general, is covered by how addresses are
generated
  - fears of forced forward-encumbrance are not any worse than can be
easily done today
  - ctv+apo, cat+csfs are fine, but we should pick ones that everyone
thinks are "good enough for everyone who cares about them"
  - they are not an undue burden on nodes in terms of
validate-cpu-cycles-per-byte (have we proven this?)
  - the complexity is low, code is easy to validate
  - won't introduce DDOS attack vectors (also needs to be proven i think?)
  - the game theory underpinning selfish miner support of the chain won't
be altered by causing a widespread use of on-chain leveraging instruments
(shorting bitcoin on-chain would be dangerous, for example)




>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220514/4d21bc38/attachment.html>

From belcher at riseup.net  Sun May 15 09:13:39 2022
From: belcher at riseup.net (Chris Belcher)
Date: Sun, 15 May 2022 10:13:39 +0100
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
 for BIP39 seeds
In-Reply-To: <FiQ49v3gOISKrdhs08_rsoYj9pwwcLRvwXbXPgGV3ulDGW70Wsfk3AMAX1KpOByW3iTm_aQdi6tECdMmDcycl1qIM2KNlJz4DiHZ8omhT8U=@protonmail.com>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
 <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
 <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>
 <PFBgbTn4_7JXQaRMlMjZDVrGBIr4OKfMK1ftW38cY-8Qu6tm_GllxDOWEj7K4zHkmQz9jA9NO_9rT_UzTSw9rr3RneEKTNhz826LmEIWF7w=@protonmail.com>
 <05fdc268-1701-cd62-181d-906b6b5d4f9d@riseup.net>
 <FiQ49v3gOISKrdhs08_rsoYj9pwwcLRvwXbXPgGV3ulDGW70Wsfk3AMAX1KpOByW3iTm_aQdi6tECdMmDcycl1qIM2KNlJz4DiHZ8omhT8U=@protonmail.com>
Message-ID: <f4dc955f-4cae-bc4f-7d85-ec2ae1fcf546@riseup.net>

Hello ZmnSCPxj,

You say "A taker can be a surveillor as well", as though that's simple 
and easy to achieve. In reality there are many defenses against that.

Defending against the attack of a malicious taker aborting at the last 
step is the purpose of the podle commitments which joinmarket has 
implemented since 2016. This was in response to this attack actually 
taking place. Another important point is that this attack cant happen 
secretly, it is very obvious to everyone operating a maker that it 
happens. The podle defense means that an attacker doing this will 
constantly have to spend money on miner fees to create new UTXOs. Here's 
a writeup with links to other blog posts about the whole thing: 
https://gist.github.com/chris-belcher/00255ecfe1bc4984fcf7c65e25aa8b4b

As well as podle as mitigation, the multiple mixdepths in the joinmarket 
wallet also helps a lot because it's not trivial for an attacker to 
actually learn all the UTXOs in all 5 mixdepths, which is necessary for 
the attack to work.

Mitigation in Teleport works in a slightly different way: takers can 
only see UTXOs or transactions belonging to the maker once they have 
already gotten their own transaction confirmed. So if they were to abort 
the protocol early they would not only have spent miner fees but also 
waste their own time waiting for the OP_CSV timeout.

It's worth remembering that the fidelity bond UTXOs are not linked to 
any resulting coinjoin or coinswaps on-chain.

Yes linking the two identities (joinmarket maker and teleport maker) 
together slightly degrades privacy, but that has to be balanced against 
the privacy loss of leaving both systems open to sybil attacks. Without 
fidelity bonds the two systems can be sybil attacked just by using about 
five-figures USD, and the attack can get these coins back at any time 
when they're finished.

Regards
CB

On 13/05/2022 13:44, ZmnSCPxj wrote:
> Good morning Chris,
> 
>> Hello waxwing,
>>
>>> A user sacrifices X amount of time-value-of-money (henceforth TVOM)
>>
>> by committing in Joinmarket with FB1. He then uses the same FB1 in
>> Teleport, let's say. If he gets benefit Y from using FB1 in Joinmarket,
>> and benefit Z in Teleport, then presumably he'll only do it if
>> (probabilistically) he thinks Y+Z > X.
>>
>>> But as an assessor of FB1 in Joinmarket, I don't know if it's also
>>
>> being used for Teleport, and more importantly, if it's being used
>> somewhere else I'm not even aware of. Now I'm not an economist I admit,
>> so I might not be intuit-ing this situation right, but it fees to me
>> like the right answer is "It's fine for a closed system, but not an open
>> one." (i.e. if the set of possible usages is not something that all
>> participants have fixed in advance, then there is an effective Sybilling
>> problem, like I'm, as an assessor, thinking that sacrificed value 100 is
>> there, whereas actually it's only 15, or whatever.)
>>
>>
>> I don't entirely agree with this. The value of the sacrifice doesn't
>> change if the fidelity bond owner starts using it for Teleport as well
>> as Joinmarket. The sacrifice is still 100. Even if the owner doesn't run
>> any maker at all the sacrifice would still be 100, because it only
>> depends on the bitcoin value and locktime. In your equation Y+Z > X,
>>
>> using a fidelity bond for more applications increases the
>> left-hand-side, while the right-hand-side X remains the same. As
>> protection from a sybil attack is calculated using only X, it makes no
>> difference what Y and Z are, the takers can still always calculate that
>> "to sybil attack the coinjoin I'm about to make, it costs A btc locked
>> up for B time".
> 
> I think another perspective here is that a maker with a single fidelity bond between both Teleport and Joinmarket has a single identity in both systems.
> 
> Recall that not only makers can be secretly surveillors, but takers can also be secretly surveillors.
> 
> Ideally, the maker should not tie its identity in one system to its identity in another system, as that degrades the privacy of the maker as well.
> 
> And the privacy of the maker is the basis of the privacy of its takers.
> It is the privacy of the coins the maker offers, that is being purchased by the takers.
> 
> 
> A taker can be a surveillor as well, and because the identity between JoinMarket and Teleport is tied via the single shared fidelity bond, a taker can perform partial-protocol attacks (i.e. aborting at the last step) to identify UTXOs of particular makers.
> And it can perform attacks on both systems to identify the ownership of maker coins in both systems.
> 
> Since the coins in one system are tied to that system, this increases the information available to the surveillor: it is now able to associate coins in JoinMarket with coins in Teleport, via the shared fidelity bond identity.
> It would be acceptable for both systems to share an identity if coins were shared between the JoinMarket and Teleport maker clients, but at that point they would arguably be a single system, not two separate systems, and that is what you should work towards.
> 
> 
> Regards,
> ZmnSCPxj

From ZmnSCPxj at protonmail.com  Mon May 16 00:00:16 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 16 May 2022 00:00:16 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <f4dc955f-4cae-bc4f-7d85-ec2ae1fcf546@riseup.net>
References: <22c80504-e648-e021-866e-ca5a5db3b247@riseup.net>
 <bsOJ-OnnA4FutVmPqtg1xY-k0notwX4OqqIpdMsymXR9-KnS2iXGUE8o7kDVeYBMCqAX0v3oEAmiVMhUIB25gupx6l_bLff2_CNsLK_sk-U=@protonmail.com>
 <82948428-29a3-e50a-a54a-520a83f39bba@riseup.net>
 <dI-CkifjUyQssT-JzKmv09W6NggL89orF78qz1AOFlBL7Kmxo6z5BVBEr6aZha_nbnBQHFcN1hqC5EZM7lB0U0jiBtE3ZWCiIR_dGBJMsDA=@protonmail.com>
 <Xjq4gzy3me86tG6sYumDq16JE8EpRSnC90Ao-02Fyz3i55vRlLY7QKbW9TdaSJg8hiclxpBqhW93CtNgeCzVmbN3CDaW35P3BZwYp1o54H0=@protonmail.com>
 <6IPqvNW2vQcHQLhUgSmQQLqtnV0RGrsUfnoUMKgv0SDQpVvKh7PIqJOKNazzgEzGE2W5OHHrlEtmg9lapjbiSjTpUuxqPmsiFua2P_ZN_FY=@protonmail.com>
 <PFBgbTn4_7JXQaRMlMjZDVrGBIr4OKfMK1ftW38cY-8Qu6tm_GllxDOWEj7K4zHkmQz9jA9NO_9rT_UzTSw9rr3RneEKTNhz826LmEIWF7w=@protonmail.com>
 <05fdc268-1701-cd62-181d-906b6b5d4f9d@riseup.net>
 <FiQ49v3gOISKrdhs08_rsoYj9pwwcLRvwXbXPgGV3ulDGW70Wsfk3AMAX1KpOByW3iTm_aQdi6tECdMmDcycl1qIM2KNlJz4DiHZ8omhT8U=@protonmail.com>
 <f4dc955f-4cae-bc4f-7d85-ec2ae1fcf546@riseup.net>
Message-ID: <SWV1PDHijAF6FwWeobGDCqhvmd8Na8sZZ7Bdfq66g1UCBSNJCBWVFLG0NKfND01wd1gE7ZXjWirJZ3QBOm056o1iDkevl5GYz_sazwWIAGY=@protonmail.com>


Good morning Chris,


> Yes linking the two identities (joinmarket maker and teleport maker)
> together slightly degrades privacy, but that has to be balanced against
> the privacy loss of leaving both systems open to sybil attacks. Without
> fidelity bonds the two systems can be sybil attacked just by using about
> five-figures USD, and the attack can get these coins back at any time
> when they're finished.

I am not saying "do not use fidelity bonds at all", I am saying "maybe we should disallow a fidelity bond used in JoinMarket from being used in Teleport and vice versa".



Regards,
ZmnSCPxj

From antoine.riard at gmail.com  Mon May 16 00:01:29 2022
From: antoine.riard at gmail.com (Antoine Riard)
Date: Sun, 15 May 2022 20:01:29 -0400
Subject: [bitcoin-dev] A small tweak to TLUV to enable off-chain
 cancellation of payment pool transactions
Message-ID: <CALZpt+F+Hmwm_1F1j0-58cFjsHTqqxAMxwdLqu0vqtk0--ArFA@mail.gmail.com>

Hi,

Proposing a small tweak to TLUV to enable cancellation of an off-chain
transaction among a set of pool participants. Namely, to give the index of
the constrained output as an opcode item.

Using CoinPool terminology, the Withdraw phase happens by a participant
publishing an Update transaction and her own Withdraw transaction, freeing
her balance from the pool control. From then, any participant can
recursively and unilaterally publish a Withdraw transaction. Or the
consensus of the remaining participants can agree to stay in the pool by
cancelling the non-published Withdraw transactions with a Snapshot one
spending the pool output. This transaction implies a rotation of the
tapscripts, effectively cancelling the Withdraws.

The presence of this latest transaction is a bit artificial and could be
removed by cancelling the non-published Withdraw transactions. This
cancellation would be manifested by producing a group signature spending
any non-published Withdraw transaction `pool_output` and `balance_output`.

If the SIGHASH_ANYPREVOUTANYSCRIPT semantic is used, this re-lifting Update
transaction could be attached on any Withdraw transaction, even if the user
balances are not equal, as the amounts are not committed. To enable
rebinding on multiple cancelled Withdraw
transactions, I think SIGHASH_ANYONECANPAY could be used.

However, the group producing the signature to spend any cancelled output
should reflect the new set of pool participants after the withdrawals have
been played out. Any withdrawing user should have been removed, as there is
no interest anymore to
contribute to the signature. We would like to avoid a former participant
with nothing at stake in the pool to block the pool operations.

E,g let's say you have Alice, Bob, Caroll and Dave as pool participants.
Each of them owns a Withdraw transaction to exit their individual balances
at any time. Alice publishes her Withdraw transaction. Bob, Caroll and Dave
would like to cancel their non-published ones to pursue the pool
operations. To cancel the non-published transactions, only Bob, Caroll and
Dave should be part of the group of signers encumbering the non-published
Withdraw transactions outputs.

That said, the composition of this group of signers is a function of the
Withdraw transactions order, and as thus is unknown at pool state
generation. Therefore, it should be constrained leveraging some covenant
mechanism.

I believe this is achievable using TLUV semantics, at the condition to add
an output index to target the second output. Currently, a Withdraw
transaction `balance_output` is only the owner pubkey. The update internal
pubkey should also be inherited there to make the output cancellable. The
owner withdrawing capability could be moved as a timelock + a key inside a
tapscript.

A tapscript from a CoinPool Withdraw transaction currently looks like this
"0 A MERKLESUB P CHECKSIGVERIFY" [0]

The new tapscript would duplicate TLUV with an output index to constrain
the spending transactions both outputs, and therefore make them cancellable:

"<output_index=0> <control_integer> <path_step> <pubkey_tweak> TLUV
<output_index=1 <control_integer> <path_step> <pubkey_tweak> TLUV
<pubkey> CHECKSIGVERIFY"

I think it is a really slight modification of TLUV and it might serve other
use-cases, beyond the payment pool one ?

Thoughts ?

[0] While it could be argue to split TLUV in two smaller opcodes like
OP_MERKLESUB or a hypothesis OP_MERKLEADD to save few bytes when only the
subtraction or the addition feature is used, I'm not sure it's worthy the
complexity increased. In the context of payment pools, the usage of a TLUV
opcode should only happen in case of "pessimistic" non-cooperative
publication...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220515/5c5ac4ea/attachment.html>

From belcher at riseup.net  Mon May 16 10:26:45 2022
From: belcher at riseup.net (Chris Belcher)
Date: Mon, 16 May 2022 11:26:45 +0100
Subject: [bitcoin-dev] Improving chaumian ecash and sidechains with fidelity
 bond federations
Message-ID: <21c0cdea-f929-b9a8-baa6-e33eb2cee80f@riseup.net>

Hello list,

Fidelity bonds could be used to help create trust-minimized federations 
that are needed for things like chaumian ecash servers or sidechains.

 From what I've seen until now, people working on chaumian ecash or 
sidechains say that the federation controlling the multisig keys will be 
based on some kind of reputation. Perhaps it will be some pseudonymous 
nyms that have built up a good reputation over a long time. I suggest 
another option is to use fidelity bonds to decide who gets to control 
the multisig keys.

Fidelity bonds are a way to deliberately sacrifice bitcoin value in a 
way that can be proven to a third party. In practice this is done by 
sending bitcoins to an address which is time-locked using the 
OP_CHECKTIMELOCKVERIFY opcode. The redeemscript and UTXO, along with a 
signature, can be shown to anyone to prove that the sacrifice happened. 
This system has already been deployed in JoinMarket since August 2021, 
and at the time of writing about 600 btc have been locked up, some for 
several years. The whole scheme is similar in some ways to PoW that 
bitcoin itself uses to avoid sybil attacks when solving the double spend 
problem.

It's important to understand what is the value-add of fidelity bonds and 
what it isn't. Fidelity bonds don't solve the trust issue, as someone 
with a big fidelity bond could still steal funds from the ecash server 
or sidechain using multisig keys they control. Such systems will always 
be custodial.

Rather, fidelity bonds strongly incentivize that the different fidelity 
bond owners are actually different people. That might be exactly the 
kind of thing needed for distributing the keys of big multisigs, 
especially now that taproot allows us to create very big multisig 
schemes. This happens because the value of a fidelity bond is calculated 
as a greater-than-linear power of the bitcoin sacrifice. So for example 
if the power was 2, and someone sacrificed 5 bitcoins of value, their 
fidelity bond would be worth 5 x 5 = 25. If instead they sacrificed 6 
bitcoins their fidelity bond would be worth 6 x 6 = 36. This superlinear 
power is what creates a strong incentive for the different fidelity 
bonds to actually be controlled by different people, because anyone 
behaving rationally will put all their bitcoins into just one fidelity, 
not split them up over many bonds. As a sybil attacker needs to 
distribute their bitcoins over many different bonds, they are 
mathematically punished. The fidelity bond system achieves this without 
revealing anything much about those people's identities.

Another value-add of fidelity bonds is they are very much in keeping 
with the cypherpunk ethos, as anyone can create a fidelity bond and 
advertise it in the market. As the bitcoins can be mixed with coinjoin 
before and after sending to the timelocked address, the scheme doesn't 
have to be linked to any identity. Only money talks; not reputation, 
political power or geographical power.

I don't know yet exactly the details of how such a scheme would work, 
maybe something like each fidelity bond owner creates a key in the 
multisig scheme, and transaction fees from the sidechain or ecash server 
are divided amongst the fidelity bonds in proportion to their fidelity 
bond value.

Regards
CB

From ZmnSCPxj at protonmail.com  Mon May 16 11:26:38 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 16 May 2022 11:26:38 +0000
Subject: [bitcoin-dev] Improving chaumian ecash and sidechains with
	fidelity bond federations
In-Reply-To: <21c0cdea-f929-b9a8-baa6-e33eb2cee80f@riseup.net>
References: <21c0cdea-f929-b9a8-baa6-e33eb2cee80f@riseup.net>
Message-ID: <HDg-_x4k8XbHnF6QHAI9vbT_8Pcy8OZrRJ4LwM4DHBTg0XV7ZmZCLWDmPYihVOtc_9_6DMBwRYoaDsLai7mSaP8jDC8KI5ij1edYaIb1iOU=@protonmail.com>


Good morning Chris,

> I don't know yet exactly the details of how such a scheme would work,
> maybe something like each fidelity bond owner creates a key in the
> multisig scheme, and transaction fees from the sidechain or ecash server
> are divided amongst the fidelity bonds in proportion to their fidelity
> bond value.

Such a scheme would probably look a little like my old ideas about "mainstake", where you lock up funds on the mainchain and use that as your right to construct new sidechain blocks, with your share of the sideblocks proportional to the value of the mainstake you locked up.

Of note is that it need not operate as a sidechain or chaumian bank, anything that requires a federation can use this scheme as well.
For instance, statechains are effectively federation-guarded CoinPools, and could use a similar scheme for selecting federation members.
Smart contracts unchained can also have users be guided by fidelity bonds in order to select federation members.

Regards,
ZmnSCPxj

From jeremy.l.rubin at gmail.com  Tue May 17 04:27:46 2022
From: jeremy.l.rubin at gmail.com (Jeremy Rubin)
Date: Mon, 16 May 2022 21:27:46 -0700
Subject: [bitcoin-dev] CTV Meeting #9 Reminder + Agenda (Tuesday, May 17th,
	12:00 PT / 7PM UTC)
Message-ID: <CAD5xwhiGjZgke5JH8sK8ewQPP2LpChDdyK9Lr1kVQQiZZH69yw@mail.gmail.com>

Developers,

A reminder that the regularly scheduled CTV Meeting is tomorrow at 12:00
Pacific Time in ##ctv-bip-review in Libera.

In terms of agenda, we'll keep it as an open forum for discussion guided by
the participants. We'll try to go over, minimally:

- Rusty's OP_TX
- Adding OP_CAT / CSFS

Feel free to propose meeting topics in the IRC in advance of the meeting to
aid in allocating time to things that you would like to have discussed.

Best,

Jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220516/514650f5/attachment.html>

From salvatore.ingala at gmail.com  Tue May 17 08:44:53 2022
From: salvatore.ingala at gmail.com (Salvatore Ingala)
Date: Tue, 17 May 2022 10:44:53 +0200
Subject: [bitcoin-dev] Wallet policies for descriptor wallets
In-Reply-To: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
References: <CAMhCMoHfdsQMsVigFqPexTE_q-Cyg7pfRvORUoy2sZtvyzd1cg@mail.gmail.com>
Message-ID: <CAMhCMoF9P6gCqeCyfMGSHT95msDnjGVzkSfLQkRkABbu2jVz5A@mail.gmail.com>

Hi all,

TL;DR: It is easy to convert from wallet policy to descriptors and back;
imho aliases are better left out of descriptors in real world usage; some
more examples given.

I received some very useful feedback on the wallet policy proposal (in this
list and outside); that also led me to realize that my initial post lacked
some clarity and more practical examples.

This post wants to:
- clarify that extracting descriptors from the wallet policy is trivial;
- argue that figuring out the wallet policy (template and list of keys
information) from the descriptor is reasonably easy ? automatable for sane
descriptors currently in use, and much more general ones as well;
- give an idea of what the information shown on a hardware wallet screen
would look like (emphasizing compactness);
- explain my point of view on "descriptors with aliases".

This gist demoes conversions from wallet policies to descriptors, and back:
https://gist.github.com/bigspider/10df51401be3aa6120217c03c2836ffa

Note that I would expect/hope software wallets to prefer working directly
with wallet policies ? but it might help to have automated tools for the
conversion, for interoperability with tools that do not adopt wallet
policies.

(All the following examples use the `/**` notation as a shortcut for
`/<0,1>/*`; this notation might be dropped without consequences on the rest
of the proposal.)

All the keys in the example I'm proposing are followed by /**. It is
unclear to me if hardware wallets should allow *registration* of wallet
policies with static keys (that is, without any range operator), as that
would incentivize key reuse. The specs still support it as there might be
other use cases.

The policy for miniscript examples not using taproot was generated with the
online compiler: https://bitcoin.sipa.be/miniscript. Many examples are also
borrowed from there.
(To the best of my knowledge, there is no publicly released compiler for
miniscript on taproot, yet)

Note on aliases: it has been pointed out that many miniscript
implementations internally use aliases to refer to the keys. In my opinion,
aliases:
- should be external to the descriptor language, as they bear no
significance for the actual script(s) that the descriptor can produce
- fail to distinguish which part of the KEY expression is part of the
"wallet description", and which part is not

By clearly separating the key information in the vector (typically, an xpub
with key origin information) from the key placeholder expression (which
typically will have the `/**` or `/<0,1>/*` derivation step), wallet
policies semantically represent keys in a way that should be convenient to
both software wallets and hardware signers.

Associating recognizable names to the xpubs (and registering them on the
device) is a good idea for future developments and can greatly improve the
UX, both during wallet setup, or in recognizing outputs for repeated
payments; it should be easy to build this feature on top of wallet policies.

== Examples ==

All the examples show:
- Miniscript policy: semantic spending rules, and optimization hints (can
be compiled to miniscript automatically)
- Miniscript: the actual miniscript descriptor, compiles 1-to-1 to Bitcoin
Script
- Wallet template: the "wallet descriptor template"
- Vector of keys: the list of key information (with key origin information)

Together, the wallet template and the vector of keys are the complet
"wallet policy".

=== Example 1: Either of two keys (equally likely) ===

Miniscript policy: or(pk(key_0),pk(key_1))
Miniscript:
 wsh(or_b([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*),s:pk([12345678/44'/0'/0']xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB/<0;1>/*)))

Descriptor template:   wsh(or_b(pk(@0/**),s:pk(@1/**)))
Vector of keys: [

"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL",

"[12345678/44'/0'/0']xpub661MyMwAqRbcFW31YEwpkMuc5THy2PSt5bDMsktWQcFF8syAmRUapSCGu8ED9W6oDMSgv6Zz8idoc4a6mr8BDzTJY47LJhkJ8UB7WEGuduB"
]

In all the following examples, I will replace the xpubs with aliases in the
miniscript for brevity, and omit the corresponding vector of keys in the
wallet policy.

Of course, in comparing the "information density" (especially for UX
purposes), it is important to take the full descriptor into account.
It is always to be assumed that the keys are xpubs, complete with key
origin information if internal (that is, controlled by the software or
hardware signer that the wallet policy is being with).

=== Example 2: Either of two keys, but one is more likely ===

Miniscript policy: or(99 at pk(key_likely),pk(key_unlikely))
Miniscript:           wsh(or_d(pk(key_likely),pkh(key_unlikely)))

Descriptor template: wsh(or_d(pk(@0/**),pkh(@1/**)))
Vector of keys:         <omitted>

=== Example 3: A 3-of-3 that turns into a 2-of-3 after 90 days ===

Miniscript policy: thresh(3,pk(key_0),pk(key_1),pk(key_2),older(12960))
Miniscript:
 wsh(thresh(3,pk(key_0),s:pk(key_1),s:pk(key_2),sln:older(12960)))

Descriptor template:
wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))))
Vector of keys:         <omitted>

=== Example 4: The BOLT #3 received HTLC policy ===

Miniscript policy:
andor(pk(key_remote),or_i(and_v(v:pkh(key_local),hash160(395e368b267d64945f30e4b71de1054f364c9473)),older(1008)),pk(key_revocation))
Miniscript:
 wsh(andor(pk(key_remote),or_i(and_v(v:pkh(key_local),hash160(395e368b267d64945f30e4b71de1054f364c9473)),older(1008)),pk(key_revocation)))

Descriptor template:
wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(395e368b267d64945f30e4b71de1054f364c9473)),older(1008)),pk(@2/**)))
Vector of keys:          <omitted>

=== Example 5: Taproot complex script (2-of-2 with cold backup and
timelocked inheritance) ===

The likely path is a 2-of-2 of a hot_key and a cosigner_key (2FA-like
service). At any time, a cold_key can be used for signing, and after about
a year, a separate timelocked_key becomes active (for example, to a notary
for inheritance purposes).
The timelock is reset every time UTXOs are spent.

Miniscript policy: or(99 at thresh(2,pk(hot_key),pk(cosigner_key)),1 at or(99 at pk
(cold_key),1 at and(pk(timelocked_key),older(52596))))
Miniscript:
 tr(cold_key,{and_v(v:pk(timelocked_key),older(52596)),multi_a(2,hot_key,cosigner_key)})

Descriptor template:
tr(@0/**,{and_v(v:pk(@1/**),older(52596)),multi_a(2, at 2/**, at 3/**)})
Vector of keys:          <omitted>

=== Example 6: Taproot complex script with MuSig2 ===

The same policy as above, but we assume that the hot wallet and the
cosigner are able to engage in the MuSig2 protocol.
This greatly exemplifies the practical advantage of MuSig2 with taproot in
terms of both transaction cost and privacy.

Miniscript policy: or(99 at musig2(hot_key,cosigner_key),1 at or(99 at pk
(cold_key),1 at and(pk(timelocked_key),older(52596))))
Miniscript:
 tr(musig2(hot_key,cosigner_key),{and_v(v:pk(timelocked_key),older(52596)),pk(cold_key)})

Descriptor template:
tr(musig2(@0, at 1)/**,{and_v(v:pk(@2/**),older(52596)),pk(@3/**)})
Vector of keys:         <omitted>. Note: the order of keys differs from the
previous example.



Salvatore Ingala
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220517/94538dab/attachment.html>

From gloriajzhao at gmail.com  Tue May 17 16:01:04 2022
From: gloriajzhao at gmail.com (Gloria Zhao)
Date: Tue, 17 May 2022 12:01:04 -0400
Subject: [bitcoin-dev] Package Relay Proposal
Message-ID: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>

Hi everybody,

I?m writing to propose a set of p2p protocol changes to enable package
relay, soliciting feedback on the design and approach. Here is a link
to the most up-to-date proposal:

https://github.com/bitcoin/bips/pull/1324

If you have concept or approach feedback, *please respond on the
mailing list* to allow everybody to view and participate in the
discussion. If you find a typo or inaccurate wording, please feel free
to leave suggestions on the PR.

I?m also working on an implementation for Bitcoin Core.


The rest of this post will include the same contents as the proposal,
with a bit of reordering and additional context. If you are not 100%
up-to-date on package relay and find the proposal hard to follow, I
hope you find this format more informative and persuasive.


==Background and Motivation==

Users may create and broadcast transactions that depend upon, i.e.
spend outputs of, unconfirmed transactions. A ?package? is the
widely-used term for a group of transactions representable by a
connected Directed Acyclic Graph (where a directed edge exists between
a transaction that spends the output of another transaction).

Incentive-compatible mempool and miner policies help create a fair,
fee-based market for block space. While miners maximize transaction
fees in order to earn higher block rewards, non-mining users
participating in transaction relay reap many benefits from employing
policies that result in a mempool with the same contents, including
faster compact block relay and more accurate fee estimation.
Additionally, users may take advantage of mempool and miner policy to
bump the priority of their transactions by attaching high-fee
descendants (Child Pays for Parent or CPFP).  Only considering
transactions one at a time for submission to the mempool creates a
limitation in the node's ability to determine which transactions have
the highest feerates, since it cannot take into account descendants
until all the transactions are in the mempool. Similarly, it cannot
use a transaction's descendants when considering which of two
conflicting transactions to keep (Replace by Fee or RBF).

When a user's transaction does not meet a mempool's minimum feerate
and they cannot create a replacement transaction directly, their
transaction will simply be rejected by this mempool. They also cannot
attach a descendant to pay for replacing a conflicting transaction.
This limitation harms users' ability to fee-bump their transactions.
Further, it presents a security issue in contracting protocols which
rely on **presigned**, time-sensitive transactions to prevent cheating
(HTLC-Timeout in LN Penalty [1] [2] [3], Unvault Cancel in Revault
[4], Refund Transaction in Discreet Log Contracts [5], Updates in
eltoo [6]). In other words, a key security assumption of many
contracting protocols is that all parties can propagate and confirm
transactions in a timely manner.

In the past few years, increasing attention [0][1][2][3][6] has been
brought to **pinning attacks**, a type of censorship in which the
attacker uses mempool policy restrictions to prevent a transaction
from being relayed or getting mined.  TLDR: revocation transactions
must meet a certain confirmation target to be effective, but their
feerates are negotiated well ahead of broadcast time. If the
forecasted feerate was too low and no fee-bumping options are
available, attackers can steal money from their counterparties. I walk
through a concrete example for stealing Lightning HTLC outputs at
~23:58 in this talk [7][8].  Note that most attacks are only possible
when the market for blockspace at broadcast time  demands much higher
feerates than originally anticipated at signing time. Always
overestimating fees may sidestep this issue temporarily (while mempool
traffic is low and predictable), but this solution is not foolproof
and wastes users' money. The feerate market can change due to sudden
spikes in traffic (e.g. huge 12sat/vB dump a few days ago [9]) or
sustained, high volume of Bitcoin payments (e.g.  April 2021 and
December 2017).

The best solution is to enable nodes to consider packages of
transactions as a unit, e.g. one or more low-fee parent transactions
with a high-fee child, instead of separately. A package-aware mempool
policy can help determine if it would actually be economically
rational to accept a transaction to the mempool if it doesn't meet fee
requirements individually. Network-wide adoption of these policies
would create a more purely-feerate-based market for block space and
allow contracting protocols to adjust fees (and therefore mining
priority) at broadcast time.  Some support for packages has existed in
Bitcoin Core for years. Since v0.13, Bitcoin Core has used ancestor
packages instead of individual transactions to evaluate the incentive
compatibility of transactions in the mempool [10] and select them for
inclusion in blocks [11].

Package Relay, the concept of {announcing, requesting, downloading}
packages between nodes on the p2p network, has also been discussed for
many years. The earliest public mention I can find is from 2015 [12].
The two most common use cases for package relay are fee-bumping
otherwise-too-low-fee transactions and reducing the amount of orphans.
It seems uncontroversial to say that everybody desires package relay
conceptually, with varying degrees of urgency. Lots of work has been
done by others over the past few years, from which I've taken
inspiration from [13][14][15][16].

My approach has been to split the project into two components: (1) Package
Mempool Accept, which includes validation logic and mempool policy.
(3) Package Relay, which includes the p2p protocol changes.

Progress so far:
After discussions with various developers of contracting protocols
(with heavier emphasis towards LN), it was determined that a
package containing a child with all of its unconfirmed parents
(child-with-unconfirmed-parents or 1-child-multi-parent package) would
be sufficient for their use case, i.e. fee-bumping presigned
transactions. A child-with-unconfirmed-parents package has several
properties that make many things easier to reason about.

A few months ago, I proposed a set of policies for safe package
validation and fee assessment for packages of this restricted
topology [17]. A series of PRs implementing this proposal have
been merged into Bitcoin Core [18].

Theoretically, developing a safe and incentive-compatible package
mempool acceptance policy is sufficient to solve this issue. Nodes
could opportunistically accept packages (e.g. by trying combinations
of transactions rejected from their mempools), but this practice would
likely be inefficient at best and open new Denial of Service attacks
at worst. Additional p2p messages may enable nodes to request and
share package validation-related information with one another in a
more communication-efficient way.

Given that only package RBF remains for package mempool accept, and we
can make progress on p2p and mempool in parallel, I think it?s
appropriate to put forward a package relay proposal.

==Proposal==

This proposal contains 2 components: a ?generic? package relay
protocol and an extension of it, child-with-unconfirmed-parents
packages, as version 1 package relay. Another version of packages,
?tx-with-unconfirmed-ancestors? can be created to extend package relay
for eliminating orphans.

===Generic Package Relay===

Two main ideas are introduced:

Download and validate packages of transactions together.

Provide information to help peers decide whether to request and/or how
to validate transactions which are part of a package.

====Intended Protocol Flow====

Due to the asynchronous nature of a distributed transaction relay
network, nodes may not receive all of the information needed to
validate a transaction at once. For example, after a node completes
Initial Block Download (IBD) and first starts participating in
transaction relay with an empty mempool, it is common to receive
orphans. In such scenarios where a node is aware that it is missing
information, a ''receiver-initiated'' dialogue is appropriate:

1. Receiver requests package information.

2. The sender provides package information, including the wtxids of
   the transactions in the package and anything else that might be
relevant (e.g. total fees and size).

3. The reciever uses the package information to decide how to request
   and validate the transactions.

Sometimes, no matter what order transactions are received by a node,
validating them individually is insufficient. When the sender is aware
of additional information that the receiver needs to accept a package,
a proactive ''sender-initiated'' dialogue should be enabled:

1. Sender announces they have package information pertaining to a
   transaction that might otherwise be undesired on its own.

2. The receiver requests package information.

3. The sender provides package information, including the wtxids of
   the transactions in the package and anything else that might be
relevant (e.g. total fees and size).

4. The reciever uses the package information to decide how to request
   and validate the transactions.

Package relay is negotiated between two peers during the version
handshake. Package relay requires both peers to support wtxid-based
relay because package transactions are referenced by their wtxid.

====New Messages====

Three new protocol messages are added for use in any version of
package relay. Additionally, each version of package relay must define
its own inv type and "pckginfo" message version, referred to in this
document as "MSG_PCKG" and "pckginfo" respectively. See
BIP-v1-packages for a concrete example.

=====sendpackages=====

{|
|  Field Name  ||  Type  ||  Size  ||  Purpose
|-
|version || uint32_t || 4 || Denotes a package version supported by the
node.
|-
|max_count || uint32_t || 4 ||Specifies the maximum number of transactions
per package this node is
willing to accept.
|-
|max_weight || uint32_t || 4 ||Specifies the maximum total weight per
package this node is willing
to accept.
|-
|}

1. The "sendpackages" message has the structure defined above, with
   pchCommand == "sendpackages".

2. During version handshake, nodes should send a "sendpackages"
   message indicate they support package relay and may request
packages.

3. The message should contain a version supported by the node. Nodes
   should send a "sendpackages" message for each version they support.

4. The "sendpackages" message MUST be sent before sending a "verack"
   message. If a "sendpackages" message is received afer "verack", the
sender should be disconnected.

5. If 'fRelay==false' in a peer's version message, the node must not
   send "sendpackages" to them. If a "sendpackages" message is
received by a peer after sending `fRelay==false` in their version
message, the sender should be disconnected.

6.. Upon receipt of a "sendpackages" message with a version that is
not supported, a node must treat the peer as if it never received the
message.

7. If both peers send "wtxidrelay" and "sendpackages" with the same
   version, the peers should announce, request, and send package
information to each other.

=====getpckgtxns=====

{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions
requested.
|-
|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in
the package.
|}

1. The "getpckgtxns" message has the structure defined above, with
   pchCommand == "getpckgtxns".

2. A "getpckgtxns" message should be used to request all or some of
   the transactions previously announced in a "pckginfo" message,
specified by witness transactiosome id.

3. Upon receipt of a "getpckgtxns" message, a node must respond with
   either a "pckgtxns" containing the requested transactions or a
"notfound" message indicating one or more of the transactions is
unavailable. This allows the receiver to avoid downloading and storing
transactions that cannot be validated immediately.

4. A "getpckgtxns" message should only be sent if both peers agreed to
   send packages in the version handshake. If a "getpckgtxns" message
is received from a peer with which package relay was not negotiated,
the sender should be disconnected.

=====pckgtxns=====

{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions
provided.
|-
|txns||List of transactions||variable|| The transactions in the package.
|}

1. The "pckgtxns" message has the structure defined above, with
   pchCommand == "pckgtxns".

2. A "pckgtxns" message should contain the transaction data requested
   using "getpckgtxns".

3. A "pckgtxns" message should only be sent to a peer that requested
   the package using "getpckgtxns". If a node receives an unsolicited
package, the sender should be disconnected.

4. A "pckgtxns" message should only be sent if both peers agreed to
   send packages in the version handshake. If a "pckgtxns" message is
received from a peer with which package relay was not negotiated, the
sender should be disconnected.

===Version 1 Packages: child-with-unconfirmed-parents===

This extends package relay for packages consisting of one transaction
and all of its unconfirmed parents,by defining version 1 packages, a
pckginfo1 message, and a MSG_PCKG1 inv type. It enables the use case
in which a child pays for its otherwise-too-low-fee parents and their
mempool conflict(s).

====Intended Protocol Flow====

When relaying a package of low-fee parent(s) and high-fee child, the
sender and receiver do the following:

1. Sender announces they have a child-with-unconfirmed-parents package
   for a child that pays for otherwise-too-low-fee parent(s) using
"inv(MSG_PCKG1)".

2. The receiver requests package information using
   "getdata(MSG_PCKG1)".

3. The sender provides package information using "pckginfo1",
   including the blockhash of the sender's best block, the wtxids of
the transactions in the package, their total fees and total weight.

4. The reciever uses the package information to decide how to request
   the transactions. For example, if the receiver already has some of
the transactions in their mempool, they only request the missing ones.
They could also decide not to request the package at all based on the
fee information provided.

5. Upon receiving a "pckgtxns", the receiver submits the transactions
   together as a package.

====New Messages====

A new inv type, "MSG_PCKG1", and new protocol message, "PCKGINFO1",
are added.

=====pckginfo1=====

{|
|  Field Name  ||  Type  ||  Size  ||   Purpose
|-
|blockhash || uint256 || 32 || The chain tip at which this package is
defined.
|-
|pckg_fee||CAmount||4|| The sum total fees paid by all transactions in the
package.
|-
|pckg_weight||int64_t||8|| The sum total weight of all transactions in the
package.
|-
|txns_length||CompactSize||1 or 3 bytes|| The number of transactions
provided.
|-
|txns||List of wtxids||txns_length * 32|| The wtxids of each transaction in
the package.
|}


1. The "pckginfo1" message has the structure defined above, with
   pchCommand == "pckginfo1".

2. A "pckginfo1" message contains information about a version 1
   package (defined below), referenced by the wtxid of the transaction
it pertains to and the current blockhash.

3. Upon receipt of a "pckginfo1" message, the node should decide if it
   wants to validate the package, request transaction data if
necessary, etc.

4. Upon receipt of a malformed "pckginfo1" message or package that
   does not abide by the max_count, max_weight, or other rules
specified by the version agreed upon in the initial negotiation, the
sender should be disconnected.  If a node receives a "pckginfo1"
message for which the "pckg_fee" or "pckg_weight" do not reflect the
true total fees and weight, respectively, or the transactions in the
package, the message is malformed.

5. A node MUST NOT send a "pckginfo1" message that has not been
   requested by the recipient. Upon receipt of an unsolicited
"pckginfo1", a node should disconnect the sender.

6. A "pckginfo1" message should only be sent if both peers agreed to
   send version 1 packages in the version handshake. If a "pckginfo1"
message is received from a peer with which package relay was not
negotiated, the sender should be disconnected.

=====MSG_PCKG1=====

1. A new inv type (MSG_PCKG1 == 0x6) is added, for use in inv messages
   and getdata requests pertaining to version 1 packages.

2. As an inv type, it indicates that both transaction data and version
   1 package information are available for the transaction. The
transaction is referenced by its wtxid. As a getdata request type, it
indicates that the sender wants package information for the
transaction.

3. Upon receipt of a "getdata" request for "MSG_PCKG1", the node
   should respond with the version 1 package corresponding to the
requested transaction and its current chain tip, or with NOTFOUND.
The node should not assume that the sender is requesting the
transaction data as well.

====Child With Parent Packages Rules====

A child-with-unconfirmed-parents package sent between nodes must abide
by the rules below, otherwise the package is malformed and the sender
should be disconnected.

A version 1 or ''child-with-unconfirmed-parents'' package can be
defined for any transaction that spends unconfirmed inputs. The child
can be thought of as the "representative" of the package. This package
can be uniquely identified by the transaction's wtxid and the current
chain tip block hash.

A ''child-with-unconfirmed-parents'' package MUST be:

1. ''Sorted topologically.'' For every transaction t in the package,
   if any of t's parents are present in the package, the parent must
appear somewhere in the list before t. In other words, the
transactions must be sorted in ascending order of the number of
ancestors present in the package.

2. ''Only 1 child with unconfirmed parents.'' The package must consist
   of one transaction and its unconfirmed parents. There must not be
any other transactions in the package. Other dependency relationships
may exist within the package (e.g. one parent may spend the output of
another parent) provided that topological order is respected.

3. ''All unconfirmed parents.'' All of the child's unconfirmed parents
   must be present.

4. ''No conflicts.'' None of the transactions in the package may
   conflict with each other (i.e.  spend the same prevout).

5. ''Total fees and weight.'' The 'total_fee' and 'total_weight'
   fields must accurately represent the sum total of all transactions'
fees and weights as defined in BIP141, respectively.

Not all of the child's parents must be present; the child transaction
may also spend confirmed inputs. However, if the child has confirmed
parents, they must not be in the package.

While a child-with-unconfirmed-parents package is perhaps most
relevant when the child has a higher feerate than its parents, this
property is not required to construct a valid package.

====Clarifications====

''Q: Under what circumstances should a sender announce a
child-with-unconfirmed-parents package?''

A child-with-unconfirmed-parents package for a transaction should be
announced when it meets the peer's fee filter but one or more of its
parents don't; a "inv(MSG_PCKG1)" instead of "inv(WTX)" should be sent
for the child. Each of the parents which meet the peer's fee filter
should still be announced normally.

''Q: What if a new block arrives in between messages?''

A child-with-unconfirmed-parents package is defined for a transaction
based on the current chain state. As such, a new block extending the
tip may decrease the number of transactions in the package (i.e. if
any of the transaction's parents were included in the block). In a
reorg, the number of transactions in the package may decrease or
increase (i.e. if any of the transaction's parents were included in a
block in the previous chain but not the new one).

If the new block arrives before the "getdata" or "pckginfo1", nothing
needs to change.

If the new block arrives before "getpckgtxns" or before "pckgtxns",
the receiver may need to re-request package information if the block
contained a transaction in the package. If the block doesn't contain
any transactions in the package, whether it extends the previous tip
or causes a reorg, nothing needs to change.

''Q: Can "getpckgtxns" and "pckgtxns" messages contain only one
transaction?''

Yes.

===Further Protocol Extensions===

When introducing a new type of package, assign it a version number "n"
and use an additional "sendpackages" message during version handshake
to negotiate support for it. An additional package information message
"pckginfon" and inv type "MSG_PCKGn" should be defined for the type of
package.  However, "getpckgtxns" and "pckgtxns" do not need to be
changed.

Example proposal for tx-with-unconfirmed-ancestors package relay: [19]

===Compatibility===

Older clients remain fully compatible and interoperable after this
change. Clients implementing this protocol will only attempt to send
and request packages if agreed upon during the version handshake.

===Package Erlay===

Clients using BIP330 reconciliation-based transaction relay (Erlay)
are able to use package relay without interference. In fact, a package
of transactions may be announced using both Erlay and package relay.
After reconciliation, if the initiator would have announced a
transaction by wtxid but also has package information for it, they may
send "inv(MSG_PCKG)" instead of "inv(WTX)".

===Rationale===

====P2P Message Design====

These p2p messages are added for communication efficiency and, as
such, one should measure alternative solutions based on the resources
used to communicate (not necessarily trustworthy) information: We
would like to minimize network bandwidth, avoid downloading a
transaction more than once, avoid downloading transactions that are
eventually rejected, and minimize storage allocated for
not-yet-validated transactions.

Consider these (plausible) scenarios in transaction relay:

Alice (the "sender") is relaying transactions to Bob (the "receiver").
Alice's mempool has a minimum feerate of 1sat/vB and Bob's has a
minimum feerate of 3sat/vB. For simplicity, all transactions are
1600Wu in virtual size and 500 bytes in serialized size. Apart from
the spending relationships specified, all other inputs are from
confirmed UTXOs.

1. Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in
   fees.

2. Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in
   fees.

3. Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000
   satoshis in fees, respectively.

====Alternative Designs Considered====

''Package Information Only:'' Just having "pckginfo" gives enough
information for the receiver to accept the package. Omit the
"getpckgtxns" and "pckgtxns" messages. While this option is a good
fallback if batched transaction download fails for some reason, it
shouldn't be used as the default because it 'always' requires storage
of unvalidated transactions.

''No Package Information Round:'' Instead of having a package
information round, just use the child's wtxid to refer to the package
and always send the entire package together. This would cause nodes to
redownload duplicate transactions.

I have also created a slidedeck exploring various alternative designs
and some examples in which they fall flat [20]. Please feel free to
suggest other alternatives.

====Versioning System====

This protocol should be extensible to support multiple types of
packages based on future desired use cases. Two "flavors" of
versioning were considered:

1. When package mempool acceptance is upgraded to support more types
   of packages, increment the version number (similar to Erlay).
During version handshake, peers negotiate which version of package
relay they will use by each sending one "sendpackages" message.

2. When introducing another type of package, assign a version number
   to it and announce it as an additional supported version (similar
to Compact Block Relay). During version handshake, peers send one
"sendpackages" message for each version supported.

The second option was favored because it allows different parameters
for different versions.  For example, it should be possible to support
both "arbitrary topology but maximum 3-transaction" package as well as
"child-with-unconfirmed-parents with default mempool ancestor limits"
packages simultaneously.

==Acknowledgements==

I hope to have made it abundantly clear that this proposal isn?t
inventing the concept of package relay, and in fact builds upon years
of work by many others, including Suhas Daftuar and Antoine Riard.

Thank you to John Newbery and Martin Zumsande for input on the design.

Thank you to Matt Corallo, Christian Decker, David Harding, Antoine
Poinsot, Antoine Riard, Gregory Sanders, Chris Stewart, Bastien
Teinturier, and others for input on the desired interface for
contracting protocols.

Looking forward to hearing your thoughts!

Best,
Gloria

[0]:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html
[1]:
https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html
[2]:
https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html
[3]: https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md
[4]:
https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx
[5]:
https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction
[6]: https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1
[7]:
https://btctranscripts.com/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/#lightning-attacks
[8]: https://youtu.be/fbWSQvJjKFs?t=1438
[9]:
https://www.reddit.com/r/Bitcoin/comments/unew4e/looks_like_70_mvb_of_transactions_just_got_dumped/
[10]: https://github.com/bitcoin/bitcoin/pull/7594
[11]: https://github.com/bitcoin/bitcoin/pull/7600
[12]: https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716820
[13]: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a
[14]: https://github.com/bitcoin/bitcoin/issues/14895
[15]: https://github.com/bitcoin/bitcoin/pull/16401
[16]: https://github.com/bitcoin/bitcoin/pull/19621
[17]:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019464.html
[18]: https://github.com/users/glozow/projects/5/views/4?layout=board
[19]: https://gist.github.com/glozow/9b321cd3ef6505135c763112033ff2a7
[20]:
https://docs.google.com/presentation/d/1B__KlZO1VzxJGx-0DYChlWawaEmGJ9EGApEzrHqZpQc/edit?usp=sharing
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220517/f2e7c128/attachment-0001.html>

From gsanders87 at gmail.com  Tue May 17 17:56:40 2022
From: gsanders87 at gmail.com (Greg Sanders)
Date: Tue, 17 May 2022 13:56:40 -0400
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
Message-ID: <CAB3F3DsJPHQJiyRfBTAFfP2SSjOJbGREbGO0N5rXmxwkHLeHeg@mail.gmail.com>

Hi Gloria,

Thanks for working on this important proposal!

Still a lot to digest, but I just had on area of comment/question:

> A child-with-unconfirmed-parents package sent between nodes must abide by
the rules below, otherwise the package is malformed and the sender should
be disconnected.

> However, if the child has confirmed parents, they must not be in the
package.

If my naive understanding is correct, this means things like otherwise
common situations such as a new block will result in disconnects, say when
the sender doesn't hear about a new block which makes the relay package
superfluous/irrelevant. Similar would be disconnection
when confirmed gets turned into unconfirmed, but those situations are
extremely uncommon. The other rules are entirely under the control
of the sender, which leads me to wonder if it's appropriate.

Cheers,
Greg

On Tue, May 17, 2022 at 12:09 PM Gloria Zhao via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi everybody,
>
> I?m writing to propose a set of p2p protocol changes to enable package
> relay, soliciting feedback on the design and approach. Here is a link
> to the most up-to-date proposal:
>
> https://github.com/bitcoin/bips/pull/1324
>
> If you have concept or approach feedback, *please respond on the
> mailing list* to allow everybody to view and participate in the
> discussion. If you find a typo or inaccurate wording, please feel free
> to leave suggestions on the PR.
>
> I?m also working on an implementation for Bitcoin Core.
>
>
> The rest of this post will include the same contents as the proposal,
> with a bit of reordering and additional context. If you are not 100%
> up-to-date on package relay and find the proposal hard to follow, I
> hope you find this format more informative and persuasive.
>
>
> ==Background and Motivation==
>
> Users may create and broadcast transactions that depend upon, i.e.
> spend outputs of, unconfirmed transactions. A ?package? is the
> widely-used term for a group of transactions representable by a
> connected Directed Acyclic Graph (where a directed edge exists between
> a transaction that spends the output of another transaction).
>
> Incentive-compatible mempool and miner policies help create a fair,
> fee-based market for block space. While miners maximize transaction
> fees in order to earn higher block rewards, non-mining users
> participating in transaction relay reap many benefits from employing
> policies that result in a mempool with the same contents, including
> faster compact block relay and more accurate fee estimation.
> Additionally, users may take advantage of mempool and miner policy to
> bump the priority of their transactions by attaching high-fee
> descendants (Child Pays for Parent or CPFP).  Only considering
> transactions one at a time for submission to the mempool creates a
> limitation in the node's ability to determine which transactions have
> the highest feerates, since it cannot take into account descendants
> until all the transactions are in the mempool. Similarly, it cannot
> use a transaction's descendants when considering which of two
> conflicting transactions to keep (Replace by Fee or RBF).
>
> When a user's transaction does not meet a mempool's minimum feerate
> and they cannot create a replacement transaction directly, their
> transaction will simply be rejected by this mempool. They also cannot
> attach a descendant to pay for replacing a conflicting transaction.
> This limitation harms users' ability to fee-bump their transactions.
> Further, it presents a security issue in contracting protocols which
> rely on **presigned**, time-sensitive transactions to prevent cheating
> (HTLC-Timeout in LN Penalty [1] [2] [3], Unvault Cancel in Revault
> [4], Refund Transaction in Discreet Log Contracts [5], Updates in
> eltoo [6]). In other words, a key security assumption of many
> contracting protocols is that all parties can propagate and confirm
> transactions in a timely manner.
>
> In the past few years, increasing attention [0][1][2][3][6] has been
> brought to **pinning attacks**, a type of censorship in which the
> attacker uses mempool policy restrictions to prevent a transaction
> from being relayed or getting mined.  TLDR: revocation transactions
> must meet a certain confirmation target to be effective, but their
> feerates are negotiated well ahead of broadcast time. If the
> forecasted feerate was too low and no fee-bumping options are
> available, attackers can steal money from their counterparties. I walk
> through a concrete example for stealing Lightning HTLC outputs at
> ~23:58 in this talk [7][8].  Note that most attacks are only possible
> when the market for blockspace at broadcast time  demands much higher
> feerates than originally anticipated at signing time. Always
> overestimating fees may sidestep this issue temporarily (while mempool
> traffic is low and predictable), but this solution is not foolproof
> and wastes users' money. The feerate market can change due to sudden
> spikes in traffic (e.g. huge 12sat/vB dump a few days ago [9]) or
> sustained, high volume of Bitcoin payments (e.g.  April 2021 and
> December 2017).
>
> The best solution is to enable nodes to consider packages of
> transactions as a unit, e.g. one or more low-fee parent transactions
> with a high-fee child, instead of separately. A package-aware mempool
> policy can help determine if it would actually be economically
> rational to accept a transaction to the mempool if it doesn't meet fee
> requirements individually. Network-wide adoption of these policies
> would create a more purely-feerate-based market for block space and
> allow contracting protocols to adjust fees (and therefore mining
> priority) at broadcast time.  Some support for packages has existed in
> Bitcoin Core for years. Since v0.13, Bitcoin Core has used ancestor
> packages instead of individual transactions to evaluate the incentive
> compatibility of transactions in the mempool [10] and select them for
> inclusion in blocks [11].
>
> Package Relay, the concept of {announcing, requesting, downloading}
> packages between nodes on the p2p network, has also been discussed for
> many years. The earliest public mention I can find is from 2015 [12].
> The two most common use cases for package relay are fee-bumping
> otherwise-too-low-fee transactions and reducing the amount of orphans.
> It seems uncontroversial to say that everybody desires package relay
> conceptually, with varying degrees of urgency. Lots of work has been
> done by others over the past few years, from which I've taken
> inspiration from [13][14][15][16].
>
> My approach has been to split the project into two components: (1) Package
> Mempool Accept, which includes validation logic and mempool policy.
> (3) Package Relay, which includes the p2p protocol changes.
>
> Progress so far:
> After discussions with various developers of contracting protocols
> (with heavier emphasis towards LN), it was determined that a
> package containing a child with all of its unconfirmed parents
> (child-with-unconfirmed-parents or 1-child-multi-parent package) would
> be sufficient for their use case, i.e. fee-bumping presigned
> transactions. A child-with-unconfirmed-parents package has several
> properties that make many things easier to reason about.
>
> A few months ago, I proposed a set of policies for safe package
> validation and fee assessment for packages of this restricted
> topology [17]. A series of PRs implementing this proposal have
> been merged into Bitcoin Core [18].
>
> Theoretically, developing a safe and incentive-compatible package
> mempool acceptance policy is sufficient to solve this issue. Nodes
> could opportunistically accept packages (e.g. by trying combinations
> of transactions rejected from their mempools), but this practice would
> likely be inefficient at best and open new Denial of Service attacks
> at worst. Additional p2p messages may enable nodes to request and
> share package validation-related information with one another in a
> more communication-efficient way.
>
> Given that only package RBF remains for package mempool accept, and we
> can make progress on p2p and mempool in parallel, I think it?s
> appropriate to put forward a package relay proposal.
>
> ==Proposal==
>
> This proposal contains 2 components: a ?generic? package relay
> protocol and an extension of it, child-with-unconfirmed-parents
> packages, as version 1 package relay. Another version of packages,
> ?tx-with-unconfirmed-ancestors? can be created to extend package relay
> for eliminating orphans.
>
> ===Generic Package Relay===
>
> Two main ideas are introduced:
>
> Download and validate packages of transactions together.
>
> Provide information to help peers decide whether to request and/or how
> to validate transactions which are part of a package.
>
> ====Intended Protocol Flow====
>
> Due to the asynchronous nature of a distributed transaction relay
> network, nodes may not receive all of the information needed to
> validate a transaction at once. For example, after a node completes
> Initial Block Download (IBD) and first starts participating in
> transaction relay with an empty mempool, it is common to receive
> orphans. In such scenarios where a node is aware that it is missing
> information, a ''receiver-initiated'' dialogue is appropriate:
>
> 1. Receiver requests package information.
>
> 2. The sender provides package information, including the wtxids of
>    the transactions in the package and anything else that might be
> relevant (e.g. total fees and size).
>
> 3. The reciever uses the package information to decide how to request
>    and validate the transactions.
>
> Sometimes, no matter what order transactions are received by a node,
> validating them individually is insufficient. When the sender is aware
> of additional information that the receiver needs to accept a package,
> a proactive ''sender-initiated'' dialogue should be enabled:
>
> 1. Sender announces they have package information pertaining to a
>    transaction that might otherwise be undesired on its own.
>
> 2. The receiver requests package information.
>
> 3. The sender provides package information, including the wtxids of
>    the transactions in the package and anything else that might be
> relevant (e.g. total fees and size).
>
> 4. The reciever uses the package information to decide how to request
>    and validate the transactions.
>
> Package relay is negotiated between two peers during the version
> handshake. Package relay requires both peers to support wtxid-based
> relay because package transactions are referenced by their wtxid.
>
> ====New Messages====
>
> Three new protocol messages are added for use in any version of
> package relay. Additionally, each version of package relay must define
> its own inv type and "pckginfo" message version, referred to in this
> document as "MSG_PCKG" and "pckginfo" respectively. See
> BIP-v1-packages for a concrete example.
>
> =====sendpackages=====
>
> {|
> |  Field Name  ||  Type  ||  Size  ||  Purpose
> |-
> |version || uint32_t || 4 || Denotes a package version supported by the
> node.
> |-
> |max_count || uint32_t || 4 ||Specifies the maximum number of transactions
> per package this node is
> willing to accept.
> |-
> |max_weight || uint32_t || 4 ||Specifies the maximum total weight per
> package this node is willing
> to accept.
> |-
> |}
>
> 1. The "sendpackages" message has the structure defined above, with
>    pchCommand == "sendpackages".
>
> 2. During version handshake, nodes should send a "sendpackages"
>    message indicate they support package relay and may request
> packages.
>
> 3. The message should contain a version supported by the node. Nodes
>    should send a "sendpackages" message for each version they support.
>
> 4. The "sendpackages" message MUST be sent before sending a "verack"
>    message. If a "sendpackages" message is received afer "verack", the
> sender should be disconnected.
>
> 5. If 'fRelay==false' in a peer's version message, the node must not
>    send "sendpackages" to them. If a "sendpackages" message is
> received by a peer after sending `fRelay==false` in their version
> message, the sender should be disconnected.
>
> 6.. Upon receipt of a "sendpackages" message with a version that is
> not supported, a node must treat the peer as if it never received the
> message.
>
> 7. If both peers send "wtxidrelay" and "sendpackages" with the same
>    version, the peers should announce, request, and send package
> information to each other.
>
> =====getpckgtxns=====
>
> {|
> |  Field Name  ||  Type  ||  Size  ||   Purpose
> |-
> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions
> requested.
> |-
> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction
> in the package.
> |}
>
> 1. The "getpckgtxns" message has the structure defined above, with
>    pchCommand == "getpckgtxns".
>
> 2. A "getpckgtxns" message should be used to request all or some of
>    the transactions previously announced in a "pckginfo" message,
> specified by witness transactiosome id.
>
> 3. Upon receipt of a "getpckgtxns" message, a node must respond with
>    either a "pckgtxns" containing the requested transactions or a
> "notfound" message indicating one or more of the transactions is
> unavailable. This allows the receiver to avoid downloading and storing
> transactions that cannot be validated immediately.
>
> 4. A "getpckgtxns" message should only be sent if both peers agreed to
>    send packages in the version handshake. If a "getpckgtxns" message
> is received from a peer with which package relay was not negotiated,
> the sender should be disconnected.
>
> =====pckgtxns=====
>
> {|
> |  Field Name  ||  Type  ||  Size  ||   Purpose
> |-
> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions
> provided.
> |-
> |txns||List of transactions||variable|| The transactions in the package.
> |}
>
> 1. The "pckgtxns" message has the structure defined above, with
>    pchCommand == "pckgtxns".
>
> 2. A "pckgtxns" message should contain the transaction data requested
>    using "getpckgtxns".
>
> 3. A "pckgtxns" message should only be sent to a peer that requested
>    the package using "getpckgtxns". If a node receives an unsolicited
> package, the sender should be disconnected.
>
> 4. A "pckgtxns" message should only be sent if both peers agreed to
>    send packages in the version handshake. If a "pckgtxns" message is
> received from a peer with which package relay was not negotiated, the
> sender should be disconnected.
>
> ===Version 1 Packages: child-with-unconfirmed-parents===
>
> This extends package relay for packages consisting of one transaction
> and all of its unconfirmed parents,by defining version 1 packages, a
> pckginfo1 message, and a MSG_PCKG1 inv type. It enables the use case
> in which a child pays for its otherwise-too-low-fee parents and their
> mempool conflict(s).
>
> ====Intended Protocol Flow====
>
> When relaying a package of low-fee parent(s) and high-fee child, the
> sender and receiver do the following:
>
> 1. Sender announces they have a child-with-unconfirmed-parents package
>    for a child that pays for otherwise-too-low-fee parent(s) using
> "inv(MSG_PCKG1)".
>
> 2. The receiver requests package information using
>    "getdata(MSG_PCKG1)".
>
> 3. The sender provides package information using "pckginfo1",
>    including the blockhash of the sender's best block, the wtxids of
> the transactions in the package, their total fees and total weight.
>
> 4. The reciever uses the package information to decide how to request
>    the transactions. For example, if the receiver already has some of
> the transactions in their mempool, they only request the missing ones.
> They could also decide not to request the package at all based on the
> fee information provided.
>
> 5. Upon receiving a "pckgtxns", the receiver submits the transactions
>    together as a package.
>
> ====New Messages====
>
> A new inv type, "MSG_PCKG1", and new protocol message, "PCKGINFO1",
> are added.
>
> =====pckginfo1=====
>
> {|
> |  Field Name  ||  Type  ||  Size  ||   Purpose
> |-
> |blockhash || uint256 || 32 || The chain tip at which this package is
> defined.
> |-
> |pckg_fee||CAmount||4|| The sum total fees paid by all transactions in the
> package.
> |-
> |pckg_weight||int64_t||8|| The sum total weight of all transactions in the
> package.
> |-
> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions
> provided.
> |-
> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction
> in the package.
> |}
>
>
> 1. The "pckginfo1" message has the structure defined above, with
>    pchCommand == "pckginfo1".
>
> 2. A "pckginfo1" message contains information about a version 1
>    package (defined below), referenced by the wtxid of the transaction
> it pertains to and the current blockhash.
>
> 3. Upon receipt of a "pckginfo1" message, the node should decide if it
>    wants to validate the package, request transaction data if
> necessary, etc.
>
> 4. Upon receipt of a malformed "pckginfo1" message or package that
>    does not abide by the max_count, max_weight, or other rules
> specified by the version agreed upon in the initial negotiation, the
> sender should be disconnected.  If a node receives a "pckginfo1"
> message for which the "pckg_fee" or "pckg_weight" do not reflect the
> true total fees and weight, respectively, or the transactions in the
> package, the message is malformed.
>
> 5. A node MUST NOT send a "pckginfo1" message that has not been
>    requested by the recipient. Upon receipt of an unsolicited
> "pckginfo1", a node should disconnect the sender.
>
> 6. A "pckginfo1" message should only be sent if both peers agreed to
>    send version 1 packages in the version handshake. If a "pckginfo1"
> message is received from a peer with which package relay was not
> negotiated, the sender should be disconnected.
>
> =====MSG_PCKG1=====
>
> 1. A new inv type (MSG_PCKG1 == 0x6) is added, for use in inv messages
>    and getdata requests pertaining to version 1 packages.
>
> 2. As an inv type, it indicates that both transaction data and version
>    1 package information are available for the transaction. The
> transaction is referenced by its wtxid. As a getdata request type, it
> indicates that the sender wants package information for the
> transaction.
>
> 3. Upon receipt of a "getdata" request for "MSG_PCKG1", the node
>    should respond with the version 1 package corresponding to the
> requested transaction and its current chain tip, or with NOTFOUND.
> The node should not assume that the sender is requesting the
> transaction data as well.
>
> ====Child With Parent Packages Rules====
>
> A child-with-unconfirmed-parents package sent between nodes must abide
> by the rules below, otherwise the package is malformed and the sender
> should be disconnected.
>
> A version 1 or ''child-with-unconfirmed-parents'' package can be
> defined for any transaction that spends unconfirmed inputs. The child
> can be thought of as the "representative" of the package. This package
> can be uniquely identified by the transaction's wtxid and the current
> chain tip block hash.
>
> A ''child-with-unconfirmed-parents'' package MUST be:
>
> 1. ''Sorted topologically.'' For every transaction t in the package,
>    if any of t's parents are present in the package, the parent must
> appear somewhere in the list before t. In other words, the
> transactions must be sorted in ascending order of the number of
> ancestors present in the package.
>
> 2. ''Only 1 child with unconfirmed parents.'' The package must consist
>    of one transaction and its unconfirmed parents. There must not be
> any other transactions in the package. Other dependency relationships
> may exist within the package (e.g. one parent may spend the output of
> another parent) provided that topological order is respected.
>
> 3. ''All unconfirmed parents.'' All of the child's unconfirmed parents
>    must be present.
>
> 4. ''No conflicts.'' None of the transactions in the package may
>    conflict with each other (i.e.  spend the same prevout).
>
> 5. ''Total fees and weight.'' The 'total_fee' and 'total_weight'
>    fields must accurately represent the sum total of all transactions'
> fees and weights as defined in BIP141, respectively.
>
> Not all of the child's parents must be present; the child transaction
> may also spend confirmed inputs. However, if the child has confirmed
> parents, they must not be in the package.
>
> While a child-with-unconfirmed-parents package is perhaps most
> relevant when the child has a higher feerate than its parents, this
> property is not required to construct a valid package.
>
> ====Clarifications====
>
> ''Q: Under what circumstances should a sender announce a
> child-with-unconfirmed-parents package?''
>
> A child-with-unconfirmed-parents package for a transaction should be
> announced when it meets the peer's fee filter but one or more of its
> parents don't; a "inv(MSG_PCKG1)" instead of "inv(WTX)" should be sent
> for the child. Each of the parents which meet the peer's fee filter
> should still be announced normally.
>
> ''Q: What if a new block arrives in between messages?''
>
> A child-with-unconfirmed-parents package is defined for a transaction
> based on the current chain state. As such, a new block extending the
> tip may decrease the number of transactions in the package (i.e. if
> any of the transaction's parents were included in the block). In a
> reorg, the number of transactions in the package may decrease or
> increase (i.e. if any of the transaction's parents were included in a
> block in the previous chain but not the new one).
>
> If the new block arrives before the "getdata" or "pckginfo1", nothing
> needs to change.
>
> If the new block arrives before "getpckgtxns" or before "pckgtxns",
> the receiver may need to re-request package information if the block
> contained a transaction in the package. If the block doesn't contain
> any transactions in the package, whether it extends the previous tip
> or causes a reorg, nothing needs to change.
>
> ''Q: Can "getpckgtxns" and "pckgtxns" messages contain only one
> transaction?''
>
> Yes.
>
> ===Further Protocol Extensions===
>
> When introducing a new type of package, assign it a version number "n"
> and use an additional "sendpackages" message during version handshake
> to negotiate support for it. An additional package information message
> "pckginfon" and inv type "MSG_PCKGn" should be defined for the type of
> package.  However, "getpckgtxns" and "pckgtxns" do not need to be
> changed.
>
> Example proposal for tx-with-unconfirmed-ancestors package relay: [19]
>
> ===Compatibility===
>
> Older clients remain fully compatible and interoperable after this
> change. Clients implementing this protocol will only attempt to send
> and request packages if agreed upon during the version handshake.
>
> ===Package Erlay===
>
> Clients using BIP330 reconciliation-based transaction relay (Erlay)
> are able to use package relay without interference. In fact, a package
> of transactions may be announced using both Erlay and package relay.
> After reconciliation, if the initiator would have announced a
> transaction by wtxid but also has package information for it, they may
> send "inv(MSG_PCKG)" instead of "inv(WTX)".
>
> ===Rationale===
>
> ====P2P Message Design====
>
> These p2p messages are added for communication efficiency and, as
> such, one should measure alternative solutions based on the resources
> used to communicate (not necessarily trustworthy) information: We
> would like to minimize network bandwidth, avoid downloading a
> transaction more than once, avoid downloading transactions that are
> eventually rejected, and minimize storage allocated for
> not-yet-validated transactions.
>
> Consider these (plausible) scenarios in transaction relay:
>
> Alice (the "sender") is relaying transactions to Bob (the "receiver").
> Alice's mempool has a minimum feerate of 1sat/vB and Bob's has a
> minimum feerate of 3sat/vB. For simplicity, all transactions are
> 1600Wu in virtual size and 500 bytes in serialized size. Apart from
> the spending relationships specified, all other inputs are from
> confirmed UTXOs.
>
> 1. Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in
>    fees.
>
> 2. Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in
>    fees.
>
> 3. Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000
>    satoshis in fees, respectively.
>
> ====Alternative Designs Considered====
>
> ''Package Information Only:'' Just having "pckginfo" gives enough
> information for the receiver to accept the package. Omit the
> "getpckgtxns" and "pckgtxns" messages. While this option is a good
> fallback if batched transaction download fails for some reason, it
> shouldn't be used as the default because it 'always' requires storage
> of unvalidated transactions.
>
> ''No Package Information Round:'' Instead of having a package
> information round, just use the child's wtxid to refer to the package
> and always send the entire package together. This would cause nodes to
> redownload duplicate transactions.
>
> I have also created a slidedeck exploring various alternative designs
> and some examples in which they fall flat [20]. Please feel free to
> suggest other alternatives.
>
> ====Versioning System====
>
> This protocol should be extensible to support multiple types of
> packages based on future desired use cases. Two "flavors" of
> versioning were considered:
>
> 1. When package mempool acceptance is upgraded to support more types
>    of packages, increment the version number (similar to Erlay).
> During version handshake, peers negotiate which version of package
> relay they will use by each sending one "sendpackages" message.
>
> 2. When introducing another type of package, assign a version number
>    to it and announce it as an additional supported version (similar
> to Compact Block Relay). During version handshake, peers send one
> "sendpackages" message for each version supported.
>
> The second option was favored because it allows different parameters
> for different versions.  For example, it should be possible to support
> both "arbitrary topology but maximum 3-transaction" package as well as
> "child-with-unconfirmed-parents with default mempool ancestor limits"
> packages simultaneously.
>
> ==Acknowledgements==
>
> I hope to have made it abundantly clear that this proposal isn?t
> inventing the concept of package relay, and in fact builds upon years
> of work by many others, including Suhas Daftuar and Antoine Riard.
>
> Thank you to John Newbery and Martin Zumsande for input on the design.
>
> Thank you to Matt Corallo, Christian Decker, David Harding, Antoine
> Poinsot, Antoine Riard, Gregory Sanders, Chris Stewart, Bastien
> Teinturier, and others for input on the desired interface for
> contracting protocols.
>
> Looking forward to hearing your thoughts!
>
> Best,
> Gloria
>
> [0]:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html
> [1]:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html
> [2]:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html
> [3]:
> https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md
> [4]:
> https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx
> [5]:
> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction
> [6]: https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1
> [7]:
> https://btctranscripts.com/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/#lightning-attacks
> [8]: https://youtu.be/fbWSQvJjKFs?t=1438
> [9]:
> https://www.reddit.com/r/Bitcoin/comments/unew4e/looks_like_70_mvb_of_transactions_just_got_dumped/
> [10]: https://github.com/bitcoin/bitcoin/pull/7594
> [11]: https://github.com/bitcoin/bitcoin/pull/7600
> [12]: https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716820
> [13]: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a
> [14]: https://github.com/bitcoin/bitcoin/issues/14895
> [15]: https://github.com/bitcoin/bitcoin/pull/16401
> [16]: https://github.com/bitcoin/bitcoin/pull/19621
> [17]:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019464.html
> [18]: https://github.com/users/glozow/projects/5/views/4?layout=board
> [19]: https://gist.github.com/glozow/9b321cd3ef6505135c763112033ff2a7
> [20]:
> https://docs.google.com/presentation/d/1B__KlZO1VzxJGx-0DYChlWawaEmGJ9EGApEzrHqZpQc/edit?usp=sharing
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220517/06bd18af/attachment-0001.html>

From gloriajzhao at gmail.com  Tue May 17 20:45:42 2022
From: gloriajzhao at gmail.com (Gloria Zhao)
Date: Tue, 17 May 2022 16:45:42 -0400
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAB3F3DsJPHQJiyRfBTAFfP2SSjOJbGREbGO0N5rXmxwkHLeHeg@mail.gmail.com>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <CAB3F3DsJPHQJiyRfBTAFfP2SSjOJbGREbGO0N5rXmxwkHLeHeg@mail.gmail.com>
Message-ID: <CAFXO6=+_Xh_U+yJuu3f17zixvAOL+EHS6+XPDBzck4d0VOJupg@mail.gmail.com>

Hi Greg,

Thanks for reading!

>> A child-with-unconfirmed-parents package sent between nodes must abide by
the rules below, otherwise the package is malformed and the sender should
be disconnected.

>> However, if the child has confirmed parents, they must not be in the
package.

> If my naive understanding is correct, this means things like otherwise
common situations such as a new block will result in disconnects, say when
> the sender doesn't hear about a new block which makes the relay package
superfluous/irrelevant. Similar would be disconnection
> when confirmed gets turned into unconfirmed, but those situations are
extremely uncommon. The other rules are entirely under the control
> of the sender, which leads me to wonder if it's appropriate.

This is why the "pckginfo1" message includes the blockhash at which the
package was defined.
Also please see Clarifications - "Q: What if a new block arrives in between
messages?'' section in the v1-packages portion. It covers both cases, i.e.
a transaction going from unconfirmed->confirmed and confirmed->unconfirmed
in a reorg.

In case anybody is wondering "why don't we just allow confirmed parents?":
Since we validate based on the UTXO set, when we see a recently-confirmed
transaction, it just looks like it spends nonexistent inputs. In these
cases, we don't really know if the input was recently spent in a block or
just never existed, unless we plan on looking up transactions in past
blocks. We do some guesswork when we deal with new blocks in normal
transaction relay (e.g. we requested the tx before a block arrived):
https://github.com/bitcoin/bitcoin/blob/d5d40d59f8d12cf53c5ad1ce9710f3f108cec386/src/validation.cpp#L780-L784
I believe it's cleaner to just explicitly say which blockhash you're on to
avoid confusion.

Thanks,
Gloria

On Tue, May 17, 2022 at 1:56 PM Greg Sanders <gsanders87 at gmail.com> wrote:

> Hi Gloria,
>
> Thanks for working on this important proposal!
>
> Still a lot to digest, but I just had on area of comment/question:
>
> > A child-with-unconfirmed-parents package sent between nodes must abide by
> the rules below, otherwise the package is malformed and the sender should
> be disconnected.
>
> > However, if the child has confirmed parents, they must not be in the
> package.
>
> If my naive understanding is correct, this means things like otherwise
> common situations such as a new block will result in disconnects, say when
> the sender doesn't hear about a new block which makes the relay package
> superfluous/irrelevant. Similar would be disconnection
> when confirmed gets turned into unconfirmed, but those situations are
> extremely uncommon. The other rules are entirely under the control
> of the sender, which leads me to wonder if it's appropriate.
>
> Cheers,
> Greg
>
> On Tue, May 17, 2022 at 12:09 PM Gloria Zhao via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi everybody,
>>
>> I?m writing to propose a set of p2p protocol changes to enable package
>> relay, soliciting feedback on the design and approach. Here is a link
>> to the most up-to-date proposal:
>>
>> https://github.com/bitcoin/bips/pull/1324
>>
>> If you have concept or approach feedback, *please respond on the
>> mailing list* to allow everybody to view and participate in the
>> discussion. If you find a typo or inaccurate wording, please feel free
>> to leave suggestions on the PR.
>>
>> I?m also working on an implementation for Bitcoin Core.
>>
>>
>> The rest of this post will include the same contents as the proposal,
>> with a bit of reordering and additional context. If you are not 100%
>> up-to-date on package relay and find the proposal hard to follow, I
>> hope you find this format more informative and persuasive.
>>
>>
>> ==Background and Motivation==
>>
>> Users may create and broadcast transactions that depend upon, i.e.
>> spend outputs of, unconfirmed transactions. A ?package? is the
>> widely-used term for a group of transactions representable by a
>> connected Directed Acyclic Graph (where a directed edge exists between
>> a transaction that spends the output of another transaction).
>>
>> Incentive-compatible mempool and miner policies help create a fair,
>> fee-based market for block space. While miners maximize transaction
>> fees in order to earn higher block rewards, non-mining users
>> participating in transaction relay reap many benefits from employing
>> policies that result in a mempool with the same contents, including
>> faster compact block relay and more accurate fee estimation.
>> Additionally, users may take advantage of mempool and miner policy to
>> bump the priority of their transactions by attaching high-fee
>> descendants (Child Pays for Parent or CPFP).  Only considering
>> transactions one at a time for submission to the mempool creates a
>> limitation in the node's ability to determine which transactions have
>> the highest feerates, since it cannot take into account descendants
>> until all the transactions are in the mempool. Similarly, it cannot
>> use a transaction's descendants when considering which of two
>> conflicting transactions to keep (Replace by Fee or RBF).
>>
>> When a user's transaction does not meet a mempool's minimum feerate
>> and they cannot create a replacement transaction directly, their
>> transaction will simply be rejected by this mempool. They also cannot
>> attach a descendant to pay for replacing a conflicting transaction.
>> This limitation harms users' ability to fee-bump their transactions.
>> Further, it presents a security issue in contracting protocols which
>> rely on **presigned**, time-sensitive transactions to prevent cheating
>> (HTLC-Timeout in LN Penalty [1] [2] [3], Unvault Cancel in Revault
>> [4], Refund Transaction in Discreet Log Contracts [5], Updates in
>> eltoo [6]). In other words, a key security assumption of many
>> contracting protocols is that all parties can propagate and confirm
>> transactions in a timely manner.
>>
>> In the past few years, increasing attention [0][1][2][3][6] has been
>> brought to **pinning attacks**, a type of censorship in which the
>> attacker uses mempool policy restrictions to prevent a transaction
>> from being relayed or getting mined.  TLDR: revocation transactions
>> must meet a certain confirmation target to be effective, but their
>> feerates are negotiated well ahead of broadcast time. If the
>> forecasted feerate was too low and no fee-bumping options are
>> available, attackers can steal money from their counterparties. I walk
>> through a concrete example for stealing Lightning HTLC outputs at
>> ~23:58 in this talk [7][8].  Note that most attacks are only possible
>> when the market for blockspace at broadcast time  demands much higher
>> feerates than originally anticipated at signing time. Always
>> overestimating fees may sidestep this issue temporarily (while mempool
>> traffic is low and predictable), but this solution is not foolproof
>> and wastes users' money. The feerate market can change due to sudden
>> spikes in traffic (e.g. huge 12sat/vB dump a few days ago [9]) or
>> sustained, high volume of Bitcoin payments (e.g.  April 2021 and
>> December 2017).
>>
>> The best solution is to enable nodes to consider packages of
>> transactions as a unit, e.g. one or more low-fee parent transactions
>> with a high-fee child, instead of separately. A package-aware mempool
>> policy can help determine if it would actually be economically
>> rational to accept a transaction to the mempool if it doesn't meet fee
>> requirements individually. Network-wide adoption of these policies
>> would create a more purely-feerate-based market for block space and
>> allow contracting protocols to adjust fees (and therefore mining
>> priority) at broadcast time.  Some support for packages has existed in
>> Bitcoin Core for years. Since v0.13, Bitcoin Core has used ancestor
>> packages instead of individual transactions to evaluate the incentive
>> compatibility of transactions in the mempool [10] and select them for
>> inclusion in blocks [11].
>>
>> Package Relay, the concept of {announcing, requesting, downloading}
>> packages between nodes on the p2p network, has also been discussed for
>> many years. The earliest public mention I can find is from 2015 [12].
>> The two most common use cases for package relay are fee-bumping
>> otherwise-too-low-fee transactions and reducing the amount of orphans.
>> It seems uncontroversial to say that everybody desires package relay
>> conceptually, with varying degrees of urgency. Lots of work has been
>> done by others over the past few years, from which I've taken
>> inspiration from [13][14][15][16].
>>
>> My approach has been to split the project into two components: (1) Package
>> Mempool Accept, which includes validation logic and mempool policy.
>> (3) Package Relay, which includes the p2p protocol changes.
>>
>> Progress so far:
>> After discussions with various developers of contracting protocols
>> (with heavier emphasis towards LN), it was determined that a
>> package containing a child with all of its unconfirmed parents
>> (child-with-unconfirmed-parents or 1-child-multi-parent package) would
>> be sufficient for their use case, i.e. fee-bumping presigned
>> transactions. A child-with-unconfirmed-parents package has several
>> properties that make many things easier to reason about.
>>
>> A few months ago, I proposed a set of policies for safe package
>> validation and fee assessment for packages of this restricted
>> topology [17]. A series of PRs implementing this proposal have
>> been merged into Bitcoin Core [18].
>>
>> Theoretically, developing a safe and incentive-compatible package
>> mempool acceptance policy is sufficient to solve this issue. Nodes
>> could opportunistically accept packages (e.g. by trying combinations
>> of transactions rejected from their mempools), but this practice would
>> likely be inefficient at best and open new Denial of Service attacks
>> at worst. Additional p2p messages may enable nodes to request and
>> share package validation-related information with one another in a
>> more communication-efficient way.
>>
>> Given that only package RBF remains for package mempool accept, and we
>> can make progress on p2p and mempool in parallel, I think it?s
>> appropriate to put forward a package relay proposal.
>>
>> ==Proposal==
>>
>> This proposal contains 2 components: a ?generic? package relay
>> protocol and an extension of it, child-with-unconfirmed-parents
>> packages, as version 1 package relay. Another version of packages,
>> ?tx-with-unconfirmed-ancestors? can be created to extend package relay
>> for eliminating orphans.
>>
>> ===Generic Package Relay===
>>
>> Two main ideas are introduced:
>>
>> Download and validate packages of transactions together.
>>
>> Provide information to help peers decide whether to request and/or how
>> to validate transactions which are part of a package.
>>
>> ====Intended Protocol Flow====
>>
>> Due to the asynchronous nature of a distributed transaction relay
>> network, nodes may not receive all of the information needed to
>> validate a transaction at once. For example, after a node completes
>> Initial Block Download (IBD) and first starts participating in
>> transaction relay with an empty mempool, it is common to receive
>> orphans. In such scenarios where a node is aware that it is missing
>> information, a ''receiver-initiated'' dialogue is appropriate:
>>
>> 1. Receiver requests package information.
>>
>> 2. The sender provides package information, including the wtxids of
>>    the transactions in the package and anything else that might be
>> relevant (e.g. total fees and size).
>>
>> 3. The reciever uses the package information to decide how to request
>>    and validate the transactions.
>>
>> Sometimes, no matter what order transactions are received by a node,
>> validating them individually is insufficient. When the sender is aware
>> of additional information that the receiver needs to accept a package,
>> a proactive ''sender-initiated'' dialogue should be enabled:
>>
>> 1. Sender announces they have package information pertaining to a
>>    transaction that might otherwise be undesired on its own.
>>
>> 2. The receiver requests package information.
>>
>> 3. The sender provides package information, including the wtxids of
>>    the transactions in the package and anything else that might be
>> relevant (e.g. total fees and size).
>>
>> 4. The reciever uses the package information to decide how to request
>>    and validate the transactions.
>>
>> Package relay is negotiated between two peers during the version
>> handshake. Package relay requires both peers to support wtxid-based
>> relay because package transactions are referenced by their wtxid.
>>
>> ====New Messages====
>>
>> Three new protocol messages are added for use in any version of
>> package relay. Additionally, each version of package relay must define
>> its own inv type and "pckginfo" message version, referred to in this
>> document as "MSG_PCKG" and "pckginfo" respectively. See
>> BIP-v1-packages for a concrete example.
>>
>> =====sendpackages=====
>>
>> {|
>> |  Field Name  ||  Type  ||  Size  ||  Purpose
>> |-
>> |version || uint32_t || 4 || Denotes a package version supported by the
>> node.
>> |-
>> |max_count || uint32_t || 4 ||Specifies the maximum number of
>> transactions per package this node is
>> willing to accept.
>> |-
>> |max_weight || uint32_t || 4 ||Specifies the maximum total weight per
>> package this node is willing
>> to accept.
>> |-
>> |}
>>
>> 1. The "sendpackages" message has the structure defined above, with
>>    pchCommand == "sendpackages".
>>
>> 2. During version handshake, nodes should send a "sendpackages"
>>    message indicate they support package relay and may request
>> packages.
>>
>> 3. The message should contain a version supported by the node. Nodes
>>    should send a "sendpackages" message for each version they support.
>>
>> 4. The "sendpackages" message MUST be sent before sending a "verack"
>>    message. If a "sendpackages" message is received afer "verack", the
>> sender should be disconnected.
>>
>> 5. If 'fRelay==false' in a peer's version message, the node must not
>>    send "sendpackages" to them. If a "sendpackages" message is
>> received by a peer after sending `fRelay==false` in their version
>> message, the sender should be disconnected.
>>
>> 6.. Upon receipt of a "sendpackages" message with a version that is
>> not supported, a node must treat the peer as if it never received the
>> message.
>>
>> 7. If both peers send "wtxidrelay" and "sendpackages" with the same
>>    version, the peers should announce, request, and send package
>> information to each other.
>>
>> =====getpckgtxns=====
>>
>> {|
>> |  Field Name  ||  Type  ||  Size  ||   Purpose
>> |-
>> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions
>> requested.
>> |-
>> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction
>> in the package.
>> |}
>>
>> 1. The "getpckgtxns" message has the structure defined above, with
>>    pchCommand == "getpckgtxns".
>>
>> 2. A "getpckgtxns" message should be used to request all or some of
>>    the transactions previously announced in a "pckginfo" message,
>> specified by witness transactiosome id.
>>
>> 3. Upon receipt of a "getpckgtxns" message, a node must respond with
>>    either a "pckgtxns" containing the requested transactions or a
>> "notfound" message indicating one or more of the transactions is
>> unavailable. This allows the receiver to avoid downloading and storing
>> transactions that cannot be validated immediately.
>>
>> 4. A "getpckgtxns" message should only be sent if both peers agreed to
>>    send packages in the version handshake. If a "getpckgtxns" message
>> is received from a peer with which package relay was not negotiated,
>> the sender should be disconnected.
>>
>> =====pckgtxns=====
>>
>> {|
>> |  Field Name  ||  Type  ||  Size  ||   Purpose
>> |-
>> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions
>> provided.
>> |-
>> |txns||List of transactions||variable|| The transactions in the package.
>> |}
>>
>> 1. The "pckgtxns" message has the structure defined above, with
>>    pchCommand == "pckgtxns".
>>
>> 2. A "pckgtxns" message should contain the transaction data requested
>>    using "getpckgtxns".
>>
>> 3. A "pckgtxns" message should only be sent to a peer that requested
>>    the package using "getpckgtxns". If a node receives an unsolicited
>> package, the sender should be disconnected.
>>
>> 4. A "pckgtxns" message should only be sent if both peers agreed to
>>    send packages in the version handshake. If a "pckgtxns" message is
>> received from a peer with which package relay was not negotiated, the
>> sender should be disconnected.
>>
>> ===Version 1 Packages: child-with-unconfirmed-parents===
>>
>> This extends package relay for packages consisting of one transaction
>> and all of its unconfirmed parents,by defining version 1 packages, a
>> pckginfo1 message, and a MSG_PCKG1 inv type. It enables the use case
>> in which a child pays for its otherwise-too-low-fee parents and their
>> mempool conflict(s).
>>
>> ====Intended Protocol Flow====
>>
>> When relaying a package of low-fee parent(s) and high-fee child, the
>> sender and receiver do the following:
>>
>> 1. Sender announces they have a child-with-unconfirmed-parents package
>>    for a child that pays for otherwise-too-low-fee parent(s) using
>> "inv(MSG_PCKG1)".
>>
>> 2. The receiver requests package information using
>>    "getdata(MSG_PCKG1)".
>>
>> 3. The sender provides package information using "pckginfo1",
>>    including the blockhash of the sender's best block, the wtxids of
>> the transactions in the package, their total fees and total weight.
>>
>> 4. The reciever uses the package information to decide how to request
>>    the transactions. For example, if the receiver already has some of
>> the transactions in their mempool, they only request the missing ones.
>> They could also decide not to request the package at all based on the
>> fee information provided.
>>
>> 5. Upon receiving a "pckgtxns", the receiver submits the transactions
>>    together as a package.
>>
>> ====New Messages====
>>
>> A new inv type, "MSG_PCKG1", and new protocol message, "PCKGINFO1",
>> are added.
>>
>> =====pckginfo1=====
>>
>> {|
>> |  Field Name  ||  Type  ||  Size  ||   Purpose
>> |-
>> |blockhash || uint256 || 32 || The chain tip at which this package is
>> defined.
>> |-
>> |pckg_fee||CAmount||4|| The sum total fees paid by all transactions in
>> the package.
>> |-
>> |pckg_weight||int64_t||8|| The sum total weight of all transactions in
>> the package.
>> |-
>> |txns_length||CompactSize||1 or 3 bytes|| The number of transactions
>> provided.
>> |-
>> |txns||List of wtxids||txns_length * 32|| The wtxids of each transaction
>> in the package.
>> |}
>>
>>
>> 1. The "pckginfo1" message has the structure defined above, with
>>    pchCommand == "pckginfo1".
>>
>> 2. A "pckginfo1" message contains information about a version 1
>>    package (defined below), referenced by the wtxid of the transaction
>> it pertains to and the current blockhash.
>>
>> 3. Upon receipt of a "pckginfo1" message, the node should decide if it
>>    wants to validate the package, request transaction data if
>> necessary, etc.
>>
>> 4. Upon receipt of a malformed "pckginfo1" message or package that
>>    does not abide by the max_count, max_weight, or other rules
>> specified by the version agreed upon in the initial negotiation, the
>> sender should be disconnected.  If a node receives a "pckginfo1"
>> message for which the "pckg_fee" or "pckg_weight" do not reflect the
>> true total fees and weight, respectively, or the transactions in the
>> package, the message is malformed.
>>
>> 5. A node MUST NOT send a "pckginfo1" message that has not been
>>    requested by the recipient. Upon receipt of an unsolicited
>> "pckginfo1", a node should disconnect the sender.
>>
>> 6. A "pckginfo1" message should only be sent if both peers agreed to
>>    send version 1 packages in the version handshake. If a "pckginfo1"
>> message is received from a peer with which package relay was not
>> negotiated, the sender should be disconnected.
>>
>> =====MSG_PCKG1=====
>>
>> 1. A new inv type (MSG_PCKG1 == 0x6) is added, for use in inv messages
>>    and getdata requests pertaining to version 1 packages.
>>
>> 2. As an inv type, it indicates that both transaction data and version
>>    1 package information are available for the transaction. The
>> transaction is referenced by its wtxid. As a getdata request type, it
>> indicates that the sender wants package information for the
>> transaction.
>>
>> 3. Upon receipt of a "getdata" request for "MSG_PCKG1", the node
>>    should respond with the version 1 package corresponding to the
>> requested transaction and its current chain tip, or with NOTFOUND.
>> The node should not assume that the sender is requesting the
>> transaction data as well.
>>
>> ====Child With Parent Packages Rules====
>>
>> A child-with-unconfirmed-parents package sent between nodes must abide
>> by the rules below, otherwise the package is malformed and the sender
>> should be disconnected.
>>
>> A version 1 or ''child-with-unconfirmed-parents'' package can be
>> defined for any transaction that spends unconfirmed inputs. The child
>> can be thought of as the "representative" of the package. This package
>> can be uniquely identified by the transaction's wtxid and the current
>> chain tip block hash.
>>
>> A ''child-with-unconfirmed-parents'' package MUST be:
>>
>> 1. ''Sorted topologically.'' For every transaction t in the package,
>>    if any of t's parents are present in the package, the parent must
>> appear somewhere in the list before t. In other words, the
>> transactions must be sorted in ascending order of the number of
>> ancestors present in the package.
>>
>> 2. ''Only 1 child with unconfirmed parents.'' The package must consist
>>    of one transaction and its unconfirmed parents. There must not be
>> any other transactions in the package. Other dependency relationships
>> may exist within the package (e.g. one parent may spend the output of
>> another parent) provided that topological order is respected.
>>
>> 3. ''All unconfirmed parents.'' All of the child's unconfirmed parents
>>    must be present.
>>
>> 4. ''No conflicts.'' None of the transactions in the package may
>>    conflict with each other (i.e.  spend the same prevout).
>>
>> 5. ''Total fees and weight.'' The 'total_fee' and 'total_weight'
>>    fields must accurately represent the sum total of all transactions'
>> fees and weights as defined in BIP141, respectively.
>>
>> Not all of the child's parents must be present; the child transaction
>> may also spend confirmed inputs. However, if the child has confirmed
>> parents, they must not be in the package.
>>
>> While a child-with-unconfirmed-parents package is perhaps most
>> relevant when the child has a higher feerate than its parents, this
>> property is not required to construct a valid package.
>>
>> ====Clarifications====
>>
>> ''Q: Under what circumstances should a sender announce a
>> child-with-unconfirmed-parents package?''
>>
>> A child-with-unconfirmed-parents package for a transaction should be
>> announced when it meets the peer's fee filter but one or more of its
>> parents don't; a "inv(MSG_PCKG1)" instead of "inv(WTX)" should be sent
>> for the child. Each of the parents which meet the peer's fee filter
>> should still be announced normally.
>>
>> ''Q: What if a new block arrives in between messages?''
>>
>> A child-with-unconfirmed-parents package is defined for a transaction
>> based on the current chain state. As such, a new block extending the
>> tip may decrease the number of transactions in the package (i.e. if
>> any of the transaction's parents were included in the block). In a
>> reorg, the number of transactions in the package may decrease or
>> increase (i.e. if any of the transaction's parents were included in a
>> block in the previous chain but not the new one).
>>
>> If the new block arrives before the "getdata" or "pckginfo1", nothing
>> needs to change.
>>
>> If the new block arrives before "getpckgtxns" or before "pckgtxns",
>> the receiver may need to re-request package information if the block
>> contained a transaction in the package. If the block doesn't contain
>> any transactions in the package, whether it extends the previous tip
>> or causes a reorg, nothing needs to change.
>>
>> ''Q: Can "getpckgtxns" and "pckgtxns" messages contain only one
>> transaction?''
>>
>> Yes.
>>
>> ===Further Protocol Extensions===
>>
>> When introducing a new type of package, assign it a version number "n"
>> and use an additional "sendpackages" message during version handshake
>> to negotiate support for it. An additional package information message
>> "pckginfon" and inv type "MSG_PCKGn" should be defined for the type of
>> package.  However, "getpckgtxns" and "pckgtxns" do not need to be
>> changed.
>>
>> Example proposal for tx-with-unconfirmed-ancestors package relay: [19]
>>
>> ===Compatibility===
>>
>> Older clients remain fully compatible and interoperable after this
>> change. Clients implementing this protocol will only attempt to send
>> and request packages if agreed upon during the version handshake.
>>
>> ===Package Erlay===
>>
>> Clients using BIP330 reconciliation-based transaction relay (Erlay)
>> are able to use package relay without interference. In fact, a package
>> of transactions may be announced using both Erlay and package relay.
>> After reconciliation, if the initiator would have announced a
>> transaction by wtxid but also has package information for it, they may
>> send "inv(MSG_PCKG)" instead of "inv(WTX)".
>>
>> ===Rationale===
>>
>> ====P2P Message Design====
>>
>> These p2p messages are added for communication efficiency and, as
>> such, one should measure alternative solutions based on the resources
>> used to communicate (not necessarily trustworthy) information: We
>> would like to minimize network bandwidth, avoid downloading a
>> transaction more than once, avoid downloading transactions that are
>> eventually rejected, and minimize storage allocated for
>> not-yet-validated transactions.
>>
>> Consider these (plausible) scenarios in transaction relay:
>>
>> Alice (the "sender") is relaying transactions to Bob (the "receiver").
>> Alice's mempool has a minimum feerate of 1sat/vB and Bob's has a
>> minimum feerate of 3sat/vB. For simplicity, all transactions are
>> 1600Wu in virtual size and 500 bytes in serialized size. Apart from
>> the spending relationships specified, all other inputs are from
>> confirmed UTXOs.
>>
>> 1. Package {A, B} where A pays 0 satoshis and B pays 8000 satoshis in
>>    fees.
>>
>> 2. Package {C, D} where C pays 0 satoshis and D pays 1200 satoshis in
>>    fees.
>>
>> 3. Package {E, F, G, H, J} that pays 4000, 8000, 0, 2000, and 4000
>>    satoshis in fees, respectively.
>>
>> ====Alternative Designs Considered====
>>
>> ''Package Information Only:'' Just having "pckginfo" gives enough
>> information for the receiver to accept the package. Omit the
>> "getpckgtxns" and "pckgtxns" messages. While this option is a good
>> fallback if batched transaction download fails for some reason, it
>> shouldn't be used as the default because it 'always' requires storage
>> of unvalidated transactions.
>>
>> ''No Package Information Round:'' Instead of having a package
>> information round, just use the child's wtxid to refer to the package
>> and always send the entire package together. This would cause nodes to
>> redownload duplicate transactions.
>>
>> I have also created a slidedeck exploring various alternative designs
>> and some examples in which they fall flat [20]. Please feel free to
>> suggest other alternatives.
>>
>> ====Versioning System====
>>
>> This protocol should be extensible to support multiple types of
>> packages based on future desired use cases. Two "flavors" of
>> versioning were considered:
>>
>> 1. When package mempool acceptance is upgraded to support more types
>>    of packages, increment the version number (similar to Erlay).
>> During version handshake, peers negotiate which version of package
>> relay they will use by each sending one "sendpackages" message.
>>
>> 2. When introducing another type of package, assign a version number
>>    to it and announce it as an additional supported version (similar
>> to Compact Block Relay). During version handshake, peers send one
>> "sendpackages" message for each version supported.
>>
>> The second option was favored because it allows different parameters
>> for different versions.  For example, it should be possible to support
>> both "arbitrary topology but maximum 3-transaction" package as well as
>> "child-with-unconfirmed-parents with default mempool ancestor limits"
>> packages simultaneously.
>>
>> ==Acknowledgements==
>>
>> I hope to have made it abundantly clear that this proposal isn?t
>> inventing the concept of package relay, and in fact builds upon years
>> of work by many others, including Suhas Daftuar and Antoine Riard.
>>
>> Thank you to John Newbery and Martin Zumsande for input on the design.
>>
>> Thank you to Matt Corallo, Christian Decker, David Harding, Antoine
>> Poinsot, Antoine Riard, Gregory Sanders, Chris Stewart, Bastien
>> Teinturier, and others for input on the desired interface for
>> contracting protocols.
>>
>> Looking forward to hearing your thoughts!
>>
>> Best,
>> Gloria
>>
>> [0]:
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-January/019817.html
>> [1]:
>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-April/002639.html
>> [2]:
>> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-June/002758.html
>> [3]:
>> https://github.com/t-bast/lightning-docs/blob/master/pinning-attacks.md
>> [4]:
>> https://github.com/revault/practical-revault/blob/master/transactions.md#cancel_tx
>> [5]:
>> https://github.com/discreetlogcontracts/dlcspecs/blob/master/Transactions.md#refund-transaction
>> [6]: https://gist.github.com/instagibbs/60264606e181451e977e439a49f69fe1
>> [7]:
>> https://btctranscripts.com/adopting-bitcoin/2021/2021-11-16-gloria-zhao-transaction-relay-policy/#lightning-attacks
>> [8]: https://youtu.be/fbWSQvJjKFs?t=1438
>> [9]:
>> https://www.reddit.com/r/Bitcoin/comments/unew4e/looks_like_70_mvb_of_transactions_just_got_dumped/
>> [10]: https://github.com/bitcoin/bitcoin/pull/7594
>> [11]: https://github.com/bitcoin/bitcoin/pull/7600
>> [12]: https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716820
>> [13]: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a
>> [14]: https://github.com/bitcoin/bitcoin/issues/14895
>> [15]: https://github.com/bitcoin/bitcoin/pull/16401
>> [16]: https://github.com/bitcoin/bitcoin/pull/19621
>> [17]:
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019464.html
>> [18]: https://github.com/users/glozow/projects/5/views/4?layout=board
>> [19]: https://gist.github.com/glozow/9b321cd3ef6505135c763112033ff2a7
>> [20]:
>> https://docs.google.com/presentation/d/1B__KlZO1VzxJGx-0DYChlWawaEmGJ9EGApEzrHqZpQc/edit?usp=sharing
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220517/321c2029/attachment-0001.html>

From aj at erisian.com.au  Wed May 18 00:35:31 2022
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 18 May 2022 10:35:31 +1000
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
Message-ID: <20220518003531.GA4402@erisian.com.au>

On Tue, May 17, 2022 at 12:01:04PM -0400, Gloria Zhao via bitcoin-dev wrote:
> ====New Messages====
> Three new protocol messages are added for use in any version of
> package relay. Additionally, each version of package relay must define
> its own inv type and "pckginfo" message version, referred to in this
> document as "MSG_PCKG" and "pckginfo" respectively. See
> BIP-v1-packages for a concrete example.

The "PCKG" abbreviation threw me for a loop; isn't the usual
abbreviation "PKG" ?

> =====sendpackages=====
> |version || uint32_t || 4 || Denotes a package version supported by the
> node.
> |max_count || uint32_t || 4 ||Specifies the maximum number of transactions
> per package this node is
> willing to accept.
> |max_weight || uint32_t || 4 ||Specifies the maximum total weight per
> package this node is willing
> to accept.

Does it make sense for these to be configurable, rather than implied
by the version? 

I presume the idea is to cope with people specifying different values for
-limitancestorcount or -limitancestorsize, but if people are regularly
relaying packages around, it seems like it becomes hard to have those
values really be configurable while being compatible with that?

I guess I'm asking: would it be better to either just not do sendpackages
at all if you're limiting ancestors in the mempool incompatibly; or
alternatively, would it be better to do the package relay, then reject
the particular package if it turns out too big, and log that you've
dropped it so that the node operator has some way of realising "whoops,
I'm not relaying packages properly because of how I configured my node"?

> 5. If 'fRelay==false' in a peer's version message, the node must not
>    send "sendpackages" to them. If a "sendpackages" message is
> received by a peer after sending `fRelay==false` in their version
> message, the sender should be disconnected.

Seems better to just say "if you set fRelay=false in your version
message, you must not send sendpackages"? You already won't do packages
with the peer if they don't also announce sendpackages.

> 7. If both peers send "wtxidrelay" and "sendpackages" with the same
>    version, the peers should announce, request, and send package
> information to each other.

Maybe: "You must not send sendpackages unless you also send wtxidrelay" ?


As I understand it, the two cases for the protocol flow are "I received
an orphan, and I'd like its ancestors please" which seems simple enough,
and "here's a child you may be interested in, even though you possibly
weren't interested in the parents of that child". I think the logic for
the latter is:

 * if tx C's fee rate is less than the peer's feefilter, skip it
   (will maybe treat it as a parent in some package later though)
 * if tx C's ancestor fee rate is less than the peer's feefilter, skip
   it?
 * look at the lowest ancestor fee rate for any of C's in-mempool
   parents
 * if that is higher than the peer's fee filter, send a normal INV
 * if it's lower than the peer's fee filter, send a PCKG INV

Are "getpckgtxns" / "pcktxns" really limited to packages, or are they
just a general way to request a batch of transactions? Particularly in
the case of requesting the parents of an orphan tx you already have,
it seems hard for the node receiving getpckgtxns to validate that the
txs are related in some way; but also it doesn't seem very necessary?

Maybe call those messages "getbatchtxns" and "batchtxns" and allow them to
be used more generally, potentially in ways unrelated to packages/cpfp?
The "only be sent if both peers agreed to do package relay" rule could
simply be dropped, I think.

> 4. The reciever uses the package information to decide how to request
>    the transactions. For example, if the receiver already has some of
> the transactions in their mempool, they only request the missing ones.
> They could also decide not to request the package at all based on the
> fee information provided.

Shouldn't the sender only be sending package announcements when they know
the recipient will be interested in the package, based on their feefilter?

> =====pckginfo1=====
> {|
> |  Field Name  ||  Type  ||  Size  ||   Purpose
> |-
> |blockhash || uint256 || 32 || The chain tip at which this package is
> defined.
> |-
> |pckg_fee||CAmount||4|| The sum total fees paid by all transactions in the
> package.

CAmount in consensus/amount.h is a int64_t so shouldn't this be 8
bytes? If you limit a package to 101kvB, an int32_t is enough to cover
any package with a fee rate of about 212 BTC/block or lower, though.

> |pckg_weight||int64_t||8|| The sum total weight of all transactions in the
> package.

The maximum block weight is 4M, and the default -limitancestorsize
presumably implies a max package weight of 404k; seems odd to provide
a uint64_t rather than an int32_t here, which easily allows either of
those values?

> 2. ''Only 1 child with unconfirmed parents.'' The package must consist
>    of one transaction and its unconfirmed parents. There must not be
> any other transactions in the package. Other dependency relationships
> may exist within the package (e.g. one parent may spend the output of
> another parent) provided that topological order is respected.

I think this means that some of the parents could also have unconfirmed
parents, but they won't be included in the package, and must be requested
via the recipient-initiated approach?

> 5. ''Total fees and weight.'' The 'total_fee' and 'total_weight'
>    fields must accurately represent the sum total of all transactions'
>    fees and weights as defined in BIP141, respectively.

Presumably this excludes any unconfirmed grandparents and earlier
ancestors since they aren't part of the package, in this approach? Doesn't
that make this both harder to calculate (assuming we already have
ancestor summaries) and less useful, in the case where those ancestors
have a lower fee rate?

> ''Q: Can "getpckgtxns" and "pckgtxns" messages contain only one
> transaction?''
> Yes.

This would be normal if you're requesting a single missing parent for
an orphan you've received, I think?

I'm slightly surprised the process is:

 ->  INV PCKG1 C
  <- GETDATA PCKG1 C
 ->  PCKGINFO1 blockhash A B C fee weight

rather than announcing the package fee info in the first message.
But if the sender is already applying the feefilter to the package before
announcing it, it probably doesn't matter, and means you're only getting
a 32B INV from every peer, rather than a 32*(n+2) PCKGINFO1 message from
every peer.

I guess tx relay is low priority enough that it wouldn't be worth tagging
some peers as "high bandwidth" and having them immediately announce the
PCKGINFO1 message, and skip the INV/GETDATA step?

Cheers,
aj


From eric at voskuil.org  Wed May 18 03:06:29 2022
From: eric at voskuil.org (eric at voskuil.org)
Date: Tue, 17 May 2022 20:06:29 -0700
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <01c401d86a5c$956ddbd0$c0499370$@voskuil.org>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
 <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
 <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>
 <01c401d86a5c$956ddbd0$c0499370$@voskuil.org>
Message-ID: <01d901d86a64$452ef9d0$cf8ced70$@voskuil.org>

Good evening ZmnSCPxj,

Sorry for the long delay...

> Good morning e,
> 
> > Good evening ZmnSCPxj,
> >
> > For the sake of simplicity, I'll use the terms lender (Landlord), borrower
> > (Lessor), interest (X), principal (Y), period (N) and maturity (height after N).
> >
> > The lender in your scenario "provides use" of the principal, and is paid
> > interest in exchange. This is of course the nature of lending, as a period
> > without one's capital incurs an opportunity cost that must be offset (by
> > interest).
> >
> > The borrower's "use" of the principal is what is being overlooked. To
> > generate income from capital one must produce something and sell it.
> > Production requires both capital and time. Borrowing the principle for the
> > period allows the borrower to produce goods, sell them, and return the
> > "profit" as interest to the lender. Use implies that the borrower is spending
> > the principle - trading it with others. Eventually any number of others end up
> > holding the principle. At maturity, the coin is returned to the lender (by
> > covenant). At that point, all people the borrower traded with are bag holders.
> > Knowledge of this scam results in an imputed net present zero value for the
> > borrowed principal.
> 
> But in this scheme, the principal is not being used as money, but as a billboard
> for an advertisement.
>
> Thus, the bitcoins are not being used as money due to the use of the fidelity
> bond to back a "you can totally trust me I am not a bot!!" assertion.
> This is not the same as your scenario --- the funds are never transferred,
> instead, a different use of the locked funds is invented.
> 
> As a better analogy: I am borrowing a piece of gold, smelting it down to make
> a nice shiny advertisement "I am totally not a bot!!", then at the end of the
> lease period, re-smelting it back and returning to you the same gold piece
> (with the exact same atoms constituting it), plus an interest from my business,
> which gained customers because of the shiny gold advertisement claiming "I
> am totally not a bot!!".
> 
> That you use the same piece of gold for money does not preclude me using
> the gold for something else of economic value, like making a nice shiny
> advertisement, so I think your analysis fails there.
> Otherwise, your analysis is on point, but analyses something else entirely.

Ok, so you are suggesting the renting of someone else's proof of "burn" (opportunity cost) to prove your necessary expense - the financial equivalent of your own burn. Reading through the thread, it looks like you are suggesting this as a way the cost of the burn might be diluted across multiple uses, based on the obscuration of the identity. And therefore identity (or at least global uniqueness) enters the equation. Sounds like a reasonable concern to me.

It appears that the term "fidelity bond" is generally accepted, though I find this an unnecessarily misleading analogy. A bond is a loan (capital at risk), and a fidelity bond is also capital at risk (to provide assurance of some behavior). Proof of burn/work, such as Hash Cash (and Bitcoin), is merely demonstration of a prior expense. But in those cases, the expense is provably associated. As you have pointed out, if the burn is not associated with the specific use, it can be reused, diluting the demonstrated expense to an unprovable degree.

I can see how you come to refer to selling the PoB as "lending" it, because the covenant on the underlying coin is time constrained. But nothing is actually lent here. The "advertisement" created by the covenant (and its presumed exclusivity) is sold. This is also entirely consistent with the idea that a loan implies capital at risk. While this is nothing more than a terminology nit, the use of "fidelity bond" and the subsequent description of "renting" (the fidelity bond) both led me down another path (Tamas' proposal for risk free lending under covenant, which we discussed here years ago).

In any case, I tend to agree with your other posts on the subject. For the burn to be provably non-dilutable it must be a cost provably associated to the scenario which relies upon the cost. This provides the global uniqueness constraint (under cryptographic assumptions of difficulty).

Best,
e

> Regards,
> ZmnSCPxj



From ZmnSCPxj at protonmail.com  Wed May 18 06:29:23 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 18 May 2022 06:29:23 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <01d901d86a64$452ef9d0$cf8ced70$@voskuil.org>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
 <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
 <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>
 <01c401d86a5c$956ddbd0$c0499370$@voskuil.org>
 <01d901d86a64$452ef9d0$cf8ced70$@voskuil.org>
Message-ID: <tG19tbinpV6rx5WtwbP3fIilB3lvJvhoUSpj6eJIw5VKWykeG72TErCvF1ZzVotiLsat0iosK2xdomXMppDK2AzTUe864tQIg5hz4fSuJvw=@protonmail.com>


Good morning e,

> Good evening ZmnSCPxj,
>
> Sorry for the long delay...

Thank you very much for responding.

>
> > Good morning e,
> >
> > > Good evening ZmnSCPxj,
> > >
> > > For the sake of simplicity, I'll use the terms lender (Landlord), borrower
> > > (Lessor), interest (X), principal (Y), period (N) and maturity (height after N).
> > >
> > > The lender in your scenario "provides use" of the principal, and is paid
> > > interest in exchange. This is of course the nature of lending, as a period
> > > without one's capital incurs an opportunity cost that must be offset (by
> > > interest).
> > >
> > > The borrower's "use" of the principal is what is being overlooked. To
> > > generate income from capital one must produce something and sell it.
> > > Production requires both capital and time. Borrowing the principle for the
> > > period allows the borrower to produce goods, sell them, and return the
> > > "profit" as interest to the lender. Use implies that the borrower is spending
> > > the principle - trading it with others. Eventually any number of others end up
> > > holding the principle. At maturity, the coin is returned to the lender (by
> > > covenant). At that point, all people the borrower traded with are bag holders.
> > > Knowledge of this scam results in an imputed net present zero value for the
> > > borrowed principal.
> >
> > But in this scheme, the principal is not being used as money, but as a billboard
> > for an advertisement.
> >
> > Thus, the bitcoins are not being used as money due to the use of the fidelity
> > bond to back a "you can totally trust me I am not a bot!!" assertion.
> > This is not the same as your scenario --- the funds are never transferred,
> > instead, a different use of the locked funds is invented.
> >
> > As a better analogy: I am borrowing a piece of gold, smelting it down to make
> > a nice shiny advertisement "I am totally not a bot!!", then at the end of the
> > lease period, re-smelting it back and returning to you the same gold piece
> > (with the exact same atoms constituting it), plus an interest from my business,
> > which gained customers because of the shiny gold advertisement claiming "I
> > am totally not a bot!!".
> >
> > That you use the same piece of gold for money does not preclude me using
> > the gold for something else of economic value, like making a nice shiny
> > advertisement, so I think your analysis fails there.
> > Otherwise, your analysis is on point, but analyses something else entirely.
>
>
> Ok, so you are suggesting the renting of someone else's proof of "burn" (opportunity cost) to prove your necessary expense - the financial equivalent of your own burn. Reading through the thread, it looks like you are suggesting this as a way the cost of the burn might be diluted across multiple uses, based on the obscuration of the identity. And therefore identity (or at least global uniqueness) enters the equation. Sounds like a reasonable concern to me.
>
> It appears that the term "fidelity bond" is generally accepted, though I find this an unnecessarily misleading analogy. A bond is a loan (capital at risk), and a fidelity bond is also capital at risk (to provide assurance of some behavior). Proof of burn/work, such as Hash Cash (and Bitcoin), is merely demonstration of a prior expense. But in those cases, the expense is provably associated. As you have pointed out, if the burn is not associated with the specific use, it can be reused, diluting the demonstrated expense to an unprovable degree.

Indeed, that is why defiads used the term "advertisement" and not "fidelity bond".
One could say that defiads was a much-too-ambitious precursor of this proposed scheme.

> I can see how you come to refer to selling the PoB as "lending" it, because the covenant on the underlying coin is time constrained. But nothing is actually lent here. The "advertisement" created by the covenant (and its presumed exclusivity) is sold. This is also entirely consistent with the idea that a loan implies capital at risk. While this is nothing more than a terminology nit, the use of "fidelity bond" and the subsequent description of "renting" (the fidelity bond) both led me down another path (Tamas' proposal for risk free lending under covenant, which we discussed here years ago).

Yes, that is why Tamas switched to defiads, as I had convinced him that it would be similar enough without actually being a covenant scam like you described.

> In any case, I tend to agree with your other posts on the subject. For the burn to be provably non-dilutable it must be a cost provably associated to the scenario which relies upon the cost. This provides the global uniqueness constraint (under cryptographic assumptions of difficulty).

Indeed.
I suspect the only reason it is not *yet* a problem with existing JoinMarket and Teleport is simply that no convenient software currently exists which allows the same bond to be used by both, thus making it safe in practice but not in theory.
But the theory implies that if somebody does make such software, effectively both systems will become joined as effectively only a single identity exists in both systems.
This may not be a problem either since the intent is that Teleport will obsolete JoinMarket someday, but if other applications start using the same scheme without requiring a commitment to a specific application, this may also effectively render Teleport less useful as well.

Regards,
ZmnSCPxj

From keagan.mcclelland at gmail.com  Wed May 18 17:08:43 2022
From: keagan.mcclelland at gmail.com (Keagan McClelland)
Date: Wed, 18 May 2022 11:08:43 -0600
Subject: [bitcoin-dev] A Calculus of Covenants
In-Reply-To: <CAD5xwhggbrg0tvjs4Pc6p7LWuy4RDcSfTHaGZ0U-KV6Wyn+CXQ@mail.gmail.com>
References: <CAD5xwhjBkKVuiPaRJZrsq+GcvSeht+SHvmmiH2MjnU2k1m_4gw@mail.gmail.com>
 <CAD5xwhggbrg0tvjs4Pc6p7LWuy4RDcSfTHaGZ0U-KV6Wyn+CXQ@mail.gmail.com>
Message-ID: <CALeFGL2CTgqbOHHGtJhZc8DJ55GNoyfm_y9+a3_6rKktwZ5H-Q@mail.gmail.com>

> One must also analyze all the covenants that one *could* author using a
primitive

So as I've been contemplating this more, I'm realizing that a calculus of
covenants themselves may not make as much sense as a broader calculus of
Bitcoin transactions as a whole. I think this comment that you made in your
followup solidified that position. If you have to analyze it in the context
of all of the other opcodes that could potentially interact with it, you
don't really have a closed algebra that you can really try to understand
and evaluate. I'm still ruminating on what such a calculus would be, but it
also makes me more convinced that Simplicity gets a lot right here. That
said, there is probably an opportunity for a significantly more domain
specific set of primitives than what simplicity offers that would allow you
similar practical use cases but with a much more high level analysis.

The way I think about this now is that most of the primitives in the
Bitcoin script VM right now are constraints on the witness, you have a
couple of opcodes that are constraints on the chain state, and then
covenants are really a constraint on the body of the transaction that
spends an input. I think most of the time we imagine covenants of output
constraints but you can also imagine a hypothetical covenant that says,
"this input may not be spent alongside any other inputs". This is still a
constraint on the spending transaction despite the fact that it mentions
nothing of the outputs, and I would still broadly think of this as a
covenant. I think depending on how you define "family" and "state
transition" it would tolerate this distinction. However, it definitely
complicates the question of things like unrollability. Is a covenant that
permits any output(s) but the input must be spent alone unrollable? Does
the concept unrollable even make any sense when you aren't constraining the
outputs?

These thoughts aren't completely baked but I figured I'd jot them down
while I was thinking about it.

Keagan

On Tue, Apr 12, 2022 at 9:04 AM Jeremy Rubin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> note of clarification:
>
> this is from the perspective of a developer trying to build infrastructure
> for covenants. from the perspective of bitcoin consensus, a covenant
> enforcing primitve would be something like OP_TLUV and less so it's use in
> conjunction with other opcodes, e.g. OP_AMOUNT.
>
> One must also analyze all the covenants that one *could* author using a
> primitive, in some sense, to demonstrate that our understanding is
> sufficient. As a trivial example, you could use
> OP_DELETE_BITCOIN_ENTIRELY_IF_KNOWS_PREIMAGE_TO_X_OR_TLUV and just because
> you could use it safely for TLUV would not mean we should add that opcode
> if there's some way of using it negatively.
>
> Cheers,
>
> Jeremy
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
>
>
> On Tue, Apr 12, 2022 at 10:33 AM Jeremy Rubin <jeremy.l.rubin at gmail.com>
> wrote:
>
>> Sharing below a framework for thinking about covenants. It is most useful
>> for modeling local covenants, that is, covenants where only one coin must
>> be examined, and not multi-coin covenants whereby you could have issues
>> with protocol forking requiring a more powerful stateful prover. It's the
>> model I use in Sapio.
>>
>> I define a covenant primitive as follows:
>>
>> 1) A set of sets of transaction intents (a *family)*, potentially
>> recursive or co-recursive (e.g., the types of state transitions that can be
>> generated). These intents can also be represented by a language that
>> generates the transactions, rather than the literal transactions
>> themselves. We do the family rather than just sets at this level because to
>> instantiate a covenant we must pick a member of the family to use.
>> 2) A verifier generator function that generates a function that accepts
>> an intent that is any element of one member of the family of intents and a
>> proof for it and rejects others.
>> 3) A prover generator function that generates a function that takes an
>> intent that is any element of one member of the family and some extra data
>> and returns either a new prover function, a finished proof, or a rejection
>> (if not a valid intent).
>> 4) A set of proofs that the Prover, Verifier, and a set of intents are
>> "impedance matched", that is, all statements the prover can prove and all
>> statements the verifier can verify are one-to-one and onto (or something
>> similar), and that this also is one-to-one and onto with one element of the
>> intents (a set of transactions) and no other.
>> 5) A set of assumptions under which the covenant is verified (e.g., a
>> multi-sig covenant with at least 1-n honesty, a multisig covenant with any
>> 3-n honesty required, Sha256 collision resistance, DLog Hardness, a SGX
>> module being correct).
>>
>> To instantiate a covenant, the user would pick a particular element of
>> the set of sets of transaction intents. For example, in TLUV payment pool,
>> it would be the set of all balance adjusting transactions and redemptions. *Note,
>> we can 'cleave' covenants into separate bits -- e.g. one TLUV + some extra
>> CTV paths can be 'composed', but the composition is not guaranteed to be
>> well formed.*
>>
>> Once the user has a particular intent, they then must generate a verifier
>> which can receive any member of the set of intents and accept it, and
>> receive any transaction outside the intents and reject it.
>>
>> With the verifier in hand (or at the same time), the user must then
>> generate a prover function that can make a proof for any intent that the
>> verifier will accept. This could be modeled as a continuation system (e.g.,
>> multisig requires multiple calls into the prover), or it could be
>> considered to be wrapped as an all-at-once function. The prover could be
>> done via a multi-sig in which case the assumptions are stronger, but it
>> still should be well formed such that the signers can clearly and
>> unambiguously sign all intents and reject all non intents, otherwise the
>> covenant is not well formed.
>>
>> The proofs of validity of the first three parts and the assumptions for
>> them should be clear, but do not require generation for use. However,
>> covenants which do not easily permit proofs are less useful.
>>
>> We now can analyze three covenants under this, plain CTV, 2-3 online
>> multisig, 3-3 presigned + deleted.
>>
>> CTV:
>> 1) Intent sets: the set of specific next transactions, with unbound
>> inputs into it that can be mutated (but once the parent is known, can be
>> filled in for all children).
>> 2) Verifier: The transaction has the hash of the intent
>> 3) Prover: The transaction itself and no other work
>> 4) Proofs of impedance: trivial.
>> 5) Assumptions: sha256
>> 6) Composition: Any two CTVs can be OR'd together as separate leafs
>>
>> 2-3 Multisig:
>> 1) Intent: All possible sets of transactions, one set selected per
>> instance
>> 2) Verifier: At least 2 signed the transition
>> 3) Prover: Receive some 'state' in the form of business logic to enforce,
>> only sign if that is satisfied. Produce a signature.
>> 4) Impedance: The business logic must cover the instance's Intent set and
>> must not be able to reach any other non-intent
>> 5) Assumptions: at least 2 parties are 'honest' for both liveness and for
>> correctness, and the usual suspects (sha256, schnorr, etc)
>> 6) Composition: Any two groups can be OR'd together, if the groups have
>> different signers, then the assumptions expand
>>
>> 3-3 Presigned:
>> Same as CTV except:
>> 5) Assumptions: at least one party deletes their key after signing
>>
>>
>>  You can also think through other covenants like TLUV in this model.
>>
>> One useful question is the 'cardinality' of an intent set. The useful
>> notion of this is both in magnitude but also contains. Obviously, many of
>> these are infinite sets, but if one set 'contains' another then it is
>> definitionally more powerful. Also, if a set of transitions is 'bigger'
>> (work to do on what that means?) than another it is potentially more
>> powerful.
>>
>> Another question is around composition of different covenants inside of
>> an intent -- e.g., a TLUV that has a branch with a CTV or vice versa. We
>> consider this outside the model, analysis should be limited to "with only
>> these covenants what could you build". Obviously, one recursive primitive
>> makes all primitives recursive.
>>
>> Another question is 'unrollability'. Can the intents, and the intents of
>> the outputs of the intents, be unrolled into a representation for a
>> specific instantiation? Or is that set of possible transactions infinite?
>> How infinite? CTV is, e.g., unrollable.
>>
>>
>> Last note on statefulness: The above has baked into it a notion of
>> 'statelessness', but it's very possible and probably required that provers
>> maintain some external state in order to prove (whether multisig or not).
>> E.g., a multisig managing an account model covenant may need to track who
>> is owed what. This data can sometimes be put e.g. in an op return, an extra
>> tapleaf branch, or just considered exogenous to the covenant. But the idea
>> that a prover isn't just deciding on what to do based on purely local
>> information to an output descriptor is important.
>>
>>
>> For Sapio in particular, this framework is useful because if you can
>> answer the above questions on intents, and prover/verifier generators, then
>> you would be able to generate tooling that could integrate your covenant
>> into Sapio and have things work nicely. If you can't answer these questions
>> (in code?) then your covenant might not be 'well formed'. The efficiency of
>> a prover or verifier is out of scope of this framework, which focuses on
>> the engineering + design, but can also be analyzed.
>>
>>
>> Grateful for any and all feedback on this model and if there are examples
>> that cannot be described within it,
>>
>> Jeremy
>>
>>
>>
>>
>> --
>> @JeremyRubin <https://twitter.com/JeremyRubin>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220518/68ca4404/attachment-0001.html>

From gloriajzhao at gmail.com  Wed May 18 18:40:58 2022
From: gloriajzhao at gmail.com (Gloria Zhao)
Date: Wed, 18 May 2022 14:40:58 -0400
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <20220518003531.GA4402@erisian.com.au>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
Message-ID: <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>

(To everyone):
I should have made it much clearer that version 1 is only supposed to solve
1 of the 2 use cases. I was a lot more focused on the fee-bumping use case,
since it?s more important. Orphan-fetching was added to the motivation
section last-minute because John Newbery mentioned to me ?hey you could
deal with orphans really easily with this.? Of course,
child-with-unconfirmed-parents packages aren?t very useful for
orphan-fetching since non-parent ancestors are quite common.

Maybe a version 2 package for orphan-fetching could look like this:

?pckginfo2? message contains a tx with all of its ancestors

?MSG_PCKG2? inv type refers to a ?pckginfo2? for a tx. You don?t send
inv(MSG_PCKG2), but a node can request getdata(MSG_PCKG2) for a transaction
they want the ancestors for, provided they sent sendpackages(version=2)
ahead of time. It seems to me that orphan-fetching only ever needs to be
receiver-initiated.

Protocol flow would look like this:
https://user-images.githubusercontent.com/25183001/168891185-1630f583-de47-4937-86b1-2652cf8852f2.png

We don?t have a policy for dealing with anything more than a child with its
direct parents, but I also don?t think anybody is relying on fee-bumping
more than 2 generations, so the validation logic here could probably just
submit them all individually. Maybe they can request a pckginfo1 if they
see something that?s too-low-fee, and/or use the
child-with-unconfirmed-parents logic opportunistically.

Thanks aj for the feedback! Responding:

> The "PCKG" abbreviation threw me for a loop; isn't the usual
> abbreviation "PKG" ?

Oh I didn't know that. I could change it if people feel strongly.

> Does it make sense for these to be configurable, rather than implied
> by the version?
> ? would it be better to either just not do sendpackages
> at all if you're limiting ancestors in the mempool incompatibly

Effectively: if you?re setting your ancestor/descendant limits lower than
the default, you can?t do package relay. I wonder if this might be
controversial, since it adds pressure to adhere to Bitcoin Core?s current
mempool policy? I would be happy to do it this way, though - makes things
easier to implement.

> > 5. If 'fRelay==false' in a peer's version message, the node must not
> >    send "sendpackages" to them. If a "sendpackages" message is
> > received by a peer after sending `fRelay==false` in their version
> > message, the sender should be disconnected.

> Seems better to just say "if you set fRelay=false in your version
> message, you must not send sendpackages"? You already won't do packages
> with the peer if they don't also announce sendpackages.

I guess, theoretically, if you allow bloom filters with this peer, it?s
plausible they?re saying ?fRelay=false, I?ll send you a bloom filter later,
and I?ll also want to talk about packages.?
I don?t know if that?s a use case we want to support - my gut reaction is
no.

> Maybe: "You must not send sendpackages unless you also send wtxidrelay" ?

Do you mean if we get a verack, and the peer sent ?sendpackages? but not
?wtxidrelay,? we should disconnect them?

> As I understand it, the two cases for the protocol flow are "I received
> an orphan, and I'd like its ancestors please" which seems simple enough,
> and "here's a child you may be interested in, even though you possibly
> weren't interested in the parents of that child".

(Btw, please see my notes at the top of this email about separating those
two use cases. sorry for the confusion).

> I think the logic for the latter is: [?]

I have it as: we send a PCKG INV when this transaction?s feerate is above
the fee filter, but one or more of its parents don?t. I don?t think using
ancestor feerate is better.
See this counterexample:
https://raw.githubusercontent.com/glozow/bitcoin-notes/master/mempool_garden/abc_1parent_2kids.png
A (0fee) has 2 kids, B (3sat/vB) and C (20sat/vB), everything?s the same
vsize. Let?s say the fee filter is 3sat/vB.
If we do it based on ancestor feerate, we won?t send B. But B is actually
fine; C is paying for A.

> Are "getpckgtxns" / "pcktxns" really limited to packages, or are they
> just a general way to request a batch of transactions?

> Maybe call those messages "getbatchtxns" and "batchtxns" and allow them to
> be used more generally, potentially in ways unrelated to packages/cpfp?

Indeed, it?s a general way to request a batch of transactions. I?ll
highlight that it is ?all or nothing,? i.e. if the sender is missing any of
them, they?ll just send a notfound.
The idea here was to avoid downloading any transactions that can?t be
validated right away. With packages, this makes sense, because there are
dependency relationships. But if you?re requesting multiple unrelated
transactions, for example, it?s unnecessary. You might end up with even
more transaction data that?s just sitting around waiting to be validated.

> The "only be sent if both peers agreed to do package relay" rule could
> simply be dropped, I think.

Wouldn?t we need some way of saying ?hey I support batchtxns?? Otherwise
you would have to guess by sending a request and waiting to see if it?s
ignored?

> Shouldn't the sender only be sending package announcements when they know
> the recipient will be interested in the package, based on their feefilter?

I think there are cases where the sender doesn?t necessarily know.
Consider this example:
https://raw.githubusercontent.com/glozow/bitcoin-notes/master/mempool_garden/rich_parent_bad_cpfp.png
D (5sat/vB) has 2 parents, A (0sat/vB) and B (20sat/vB). All same size.
Feefilter is 3sat/vB.
If the receiver already has B, they?ll know they can just reject the
package already based on the pckginfo.
But the sender doesn?t really know that. The sender just knows A is below
feerate and D is above. D is above the fee filter, and its ancestor feerate
is above the fee filter.

> CAmount in consensus/amount.h is a int64_t
> The maximum block weight is 4M?

 Oops yes. I think we just usually use int64_t for vsizes afaik. Agree that
it should be 8 bytes for fee, and 4 bytes is enough for vsize.

> I guess tx relay is low priority enough that it wouldn't be worth tagging
> some peers as "high bandwidth" and having them immediately announce the
> PCKGINFO1 message, and skip the INV/GETDATA step?

I had the same idea as well, but seemed unnecessary. It would reduce the
number of round trips, but I don?t think an extra round trip is that big of
a deal for transaction relay. Block relay, yes of course, but I don?t think
we care that much if it takes an extra second to send a transaction?

Best,
Gloria

On Tue, May 17, 2022 at 8:35 PM Anthony Towns <aj at erisian.com.au> wrote:

> On Tue, May 17, 2022 at 12:01:04PM -0400, Gloria Zhao via bitcoin-dev
> wrote:
> > ====New Messages====
> > Three new protocol messages are added for use in any version of
> > package relay. Additionally, each version of package relay must define
> > its own inv type and "pckginfo" message version, referred to in this
> > document as "MSG_PCKG" and "pckginfo" respectively. See
> > BIP-v1-packages for a concrete example.
>
> The "PCKG" abbreviation threw me for a loop; isn't the usual
> abbreviation "PKG" ?
>
> > =====sendpackages=====
> > |version || uint32_t || 4 || Denotes a package version supported by the
> > node.
> > |max_count || uint32_t || 4 ||Specifies the maximum number of
> transactions
> > per package this node is
> > willing to accept.
> > |max_weight || uint32_t || 4 ||Specifies the maximum total weight per
> > package this node is willing
> > to accept.
>
> Does it make sense for these to be configurable, rather than implied
> by the version?
>
> I presume the idea is to cope with people specifying different values for
> -limitancestorcount or -limitancestorsize, but if people are regularly
> relaying packages around, it seems like it becomes hard to have those
> values really be configurable while being compatible with that?
>
> I guess I'm asking: would it be better to either just not do sendpackages
> at all if you're limiting ancestors in the mempool incompatibly; or
> alternatively, would it be better to do the package relay, then reject
> the particular package if it turns out too big, and log that you've
> dropped it so that the node operator has some way of realising "whoops,
> I'm not relaying packages properly because of how I configured my node"?
>
> > 5. If 'fRelay==false' in a peer's version message, the node must not
> >    send "sendpackages" to them. If a "sendpackages" message is
> > received by a peer after sending `fRelay==false` in their version
> > message, the sender should be disconnected.
>
> Seems better to just say "if you set fRelay=false in your version
> message, you must not send sendpackages"? You already won't do packages
> with the peer if they don't also announce sendpackages.
>
> > 7. If both peers send "wtxidrelay" and "sendpackages" with the same
> >    version, the peers should announce, request, and send package
> > information to each other.
>
> Maybe: "You must not send sendpackages unless you also send wtxidrelay" ?
>
>
> As I understand it, the two cases for the protocol flow are "I received
> an orphan, and I'd like its ancestors please" which seems simple enough,
> and "here's a child you may be interested in, even though you possibly
> weren't interested in the parents of that child". I think the logic for
> the latter is:
>
>  * if tx C's fee rate is less than the peer's feefilter, skip it
>    (will maybe treat it as a parent in some package later though)
>  * if tx C's ancestor fee rate is less than the peer's feefilter, skip
>    it?
>  * look at the lowest ancestor fee rate for any of C's in-mempool
>    parents
>  * if that is higher than the peer's fee filter, send a normal INV
>  * if it's lower than the peer's fee filter, send a PCKG INV
>
> Are "getpckgtxns" / "pcktxns" really limited to packages, or are they
> just a general way to request a batch of transactions? Particularly in
> the case of requesting the parents of an orphan tx you already have,
> it seems hard for the node receiving getpckgtxns to validate that the
> txs are related in some way; but also it doesn't seem very necessary?
>
> Maybe call those messages "getbatchtxns" and "batchtxns" and allow them to
> be used more generally, potentially in ways unrelated to packages/cpfp?
> The "only be sent if both peers agreed to do package relay" rule could
> simply be dropped, I think.
>
> > 4. The reciever uses the package information to decide how to request
> >    the transactions. For example, if the receiver already has some of
> > the transactions in their mempool, they only request the missing ones.
> > They could also decide not to request the package at all based on the
> > fee information provided.
>
> Shouldn't the sender only be sending package announcements when they know
> the recipient will be interested in the package, based on their feefilter?
>
> > =====pckginfo1=====
> > {|
> > |  Field Name  ||  Type  ||  Size  ||   Purpose
> > |-
> > |blockhash || uint256 || 32 || The chain tip at which this package is
> > defined.
> > |-
> > |pckg_fee||CAmount||4|| The sum total fees paid by all transactions in
> the
> > package.
>
> CAmount in consensus/amount.h is a int64_t so shouldn't this be 8
> bytes? If you limit a package to 101kvB, an int32_t is enough to cover
> any package with a fee rate of about 212 BTC/block or lower, though.
>
> > |pckg_weight||int64_t||8|| The sum total weight of all transactions in
> the
> > package.
>
> The maximum block weight is 4M, and the default -limitancestorsize
> presumably implies a max package weight of 404k; seems odd to provide
> a uint64_t rather than an int32_t here, which easily allows either of
> those values?
>
> > 2. ''Only 1 child with unconfirmed parents.'' The package must consist
> >    of one transaction and its unconfirmed parents. There must not be
> > any other transactions in the package. Other dependency relationships
> > may exist within the package (e.g. one parent may spend the output of
> > another parent) provided that topological order is respected.
>
> I think this means that some of the parents could also have unconfirmed
> parents, but they won't be included in the package, and must be requested
> via the recipient-initiated approach?
>
> > 5. ''Total fees and weight.'' The 'total_fee' and 'total_weight'
> >    fields must accurately represent the sum total of all transactions'
> >    fees and weights as defined in BIP141, respectively.
>
> Presumably this excludes any unconfirmed grandparents and earlier
> ancestors since they aren't part of the package, in this approach? Doesn't
> that make this both harder to calculate (assuming we already have
> ancestor summaries) and less useful, in the case where those ancestors
> have a lower fee rate?
>
> > ''Q: Can "getpckgtxns" and "pckgtxns" messages contain only one
> > transaction?''
> > Yes.
>
> This would be normal if you're requesting a single missing parent for
> an orphan you've received, I think?
>
> I'm slightly surprised the process is:
>
>  ->  INV PCKG1 C
>   <- GETDATA PCKG1 C
>  ->  PCKGINFO1 blockhash A B C fee weight
>
> rather than announcing the package fee info in the first message.
> But if the sender is already applying the feefilter to the package before
> announcing it, it probably doesn't matter, and means you're only getting
> a 32B INV from every peer, rather than a 32*(n+2) PCKGINFO1 message from
> every peer.
>
> I guess tx relay is low priority enough that it wouldn't be worth tagging
> some peers as "high bandwidth" and having them immediately announce the
> PCKGINFO1 message, and skip the INV/GETDATA step?
>
> Cheers,
> aj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220518/f022b65c/attachment-0001.html>

From alicexbt at protonmail.com  Thu May 19 15:57:55 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Thu, 19 May 2022 15:57:55 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #9 Notes
Message-ID: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>

Hi Bitcoin Developers,

Summary for the last CTV meeting:

Topics:

1)OP_TX
2)OP_CAT / CSFS / General Covenants
3)Script interpreter flags

===================================================
OP_TX
===================================================

Jeremy Rubin thinks that if folks believe OP_TX is a superior upgrading path, he would be delighted to shift focus. Although prefers more thorough evaluation of CTV / NOP upgradability vs the multibyte op-success.

Anthony Towns doesn't find OP_TX interesting if it just does CTV from start. He prefers adding SEPARATELY, UNHASHED and maybe things to do APO equivalent behavior.

Harding considers OP_TX==OP_CTV only somewhat more interesting than just OP_CTV because it provides a very clear upgrade path. He would be more interested if it came with a few more initial features.

===================================================
OP_CAT / CSFS / General Covenants
===================================================

Harding believes that concerns regarding general covenants are unfounded. He indicated an interest in learning more about one of ZmnSCPxj's criticisms, which is the only one about which he is personally concerned. It has to do with general covenants making scripts more difficult to evaluate.

Harding's thoughts on CAT+CSFS:

13:01 < harding> Without regard to the generalized covenants concern, I think CAT+CSFS add the smallest amount of consensus complexity to enable the greatest amount of experimentation with covenants and other features (like signature delegation), which can provide significant data about real-world usage for informing future soft fork designs. There'd still be lots of question marks, plus chances for abuse (e.g. the sort of tx spamming we saw during the block
13:01 < harding> size debates), but I think it's worth giving devs the tools to experiment onchain (with only their and their supporters' money) and allowing economic full node operators to evualuate actual use before agreeing to enforce future soft forks whose code will need to be maintained in perpetuitity.
13:02 < harding> Consensus stability is a reference to, for example, being able to implement something like drivechains on top of CAT+CSFS?

Jeremy Rubin shared some issues that are being discussed on mailing list and social media related to general bitcoin covenants:

- Scripts harder to analyze
- Fungibility
- MEV & consensus stability
- Whitelist/Blacklist

Anthony Towns and TechMiX added that some users think covenants can be imposed on their coins without consent or everyone will accept covenants so unable to pay them. Some bitcoin users in Iran are afraid that a generalized form of the covenants would enable some kind of censorship.

MEV could be one the issues associated with general covenants. There are some resources on https://mev.day if anyone interested to read more about it.

13:06 <@jeremyrubin> the covenants are "self executing" and can be e.g. sandwiched
13:07 <@jeremyrubin> so given that bitmatrix is sandwich attackable, you'd see similar types of MEV as Eth sees
13:07 <@jeremyrubin> v.s. the MEV of e.g. lightning channels

13:14 < _aj_> i guess i'd rather not have that sort of MEV available, because then it makes complicated MEV extraction profitable, which then makes "smart" miners more profitable than "Dumb" ones, which is maybe centralising

===================================================
Script interpreter flags
===================================================

Anthony Towns likes the idea of documenting exactly what rules the flags are meant to enforce (associated BIPs).

13:54 <@jeremyrubin> The test flags infrastructure relies on some particular features of validity/invalidity and flagging, which has previously been avoided surfacing because upgrades were at the output type level. The way the flagging works is a not quite the right thing for testability and simple consensus code, it's worth re-evaluating?
13:55 < _aj_> we changed how "things are done" with taproot, and need to re-evaluate how we do script enforcement in light of wanting to keep doing things that way?
13:56 < _aj_> we don't really have to do things the way we did for taproot, but i thought it was kind-of nice, i guess
13:56 <@jeremyrubin> Well taproot just sidestepped the issue because it was an outputtype
13:56 < _aj_> taproot had it easy because it was an outputtype
13:57 <@jeremyrubin> yes

IRC Logs: https://gnusha.org/ctv-bip-review/2022-05-17.log

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220519/c6a13a4e/attachment.html>

From ZmnSCPxj at protonmail.com  Fri May 20 01:03:11 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 20 May 2022 01:03:11 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #9 Notes
In-Reply-To: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>
References: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>
Message-ID: <4FE6Gygz1J6ehzVcTMyfSGbhSPvvkg06LjxqKy-lhPgGlYOGAbxgjYEkGBys8iE09FCOOU1rzq2GLqnMNjMhbstTTdtYNqzHWaLro1CA5FM=@protonmail.com>

Good morning fd0,


> MEV could be one the issues associated with general covenants. There are some resources on https://mev.day if anyone interested to read more about it.
> 13:06 <@jeremyrubin> the covenants are "self executing" and can be e.g. sandwiched13:07 <@jeremyrubin> so given that bitmatrix is sandwich attackable, you'd see similar types of MEV as Eth sees13:07 <@jeremyrubin> v.s. the MEV of e.g. lightning channels
> 13:14 < _aj_> i guess i'd rather not have that sort of MEV available, because then it makes complicated MEV extraction profitable, which then makes "smart" miners more profitable than "Dumb" ones, which is maybe centralising

Well that was interesting....

TLDR: MEV = Miner-extractable value, basically if your contracts are complex enough, miners can analyze which of the possible contract executions are most profitable for them, and order transactions on the block they are building in such a way that it is the most profitable path that gets executed.
(do correct me if that summary is inaccurate or incomplete)

As a concrete example: in a LN channel breach condition, the revocation transaction must be confirmed within the CSV timeout, or else the theft will be accepted and confirmed.
Now, some software will be aware of this timeout and will continually raise the fee of the revocation transaction per block.
A rational miner which sees a channel breach condition might prefer to not mine such a transaction, since if it is not confirmed, the software will bump up the fees and the miner could try again on the next block with the higher feerates.
Depending on the channel size and how the software behaves exactly, the miner may be able to make a decision on whether it should or should not work on the revocation transaction and instead hold out for a later higher fee.

Now, having thought of this problem for no more than 5 minutes, it seems to me, naively, that a mechanism with privacy would be helpful, i.e. the contract details should be as little-revealed as possible, to reduce the scope of miner-extractable value.
For instance, Taproot is good since only one branch at a time can be revealed, however, in case of a dispute, multiple competing branches of the Taproot may be revealed by the disputants, and the miners may now be able to make a choice.

Probably, it is best if our covenants systems take full advantage of the linearity of Schnorr signing, in that case, if there is at all some kind of branch involved; for example, a previous transaction may reveal, if you have the proper adaptor signature, some scalar, and that scalar is actually the `s` component for a signature of a different transaction.
Without knowledge of the adaptor signature, and without knowledge of the link between this previous transaction and some other one, a miner cannot extract additional value by messing with the ordering the transactions get confirmed on the blockchain, or whatever.

This may mean that mechanisms that inspect the block outside of the transaction being validated (e.g. `OP_BRIBE` for drivechains, or similar mechanisms that might be capable of looking beyond the transaction) should be verboten; such cross-transaction introspection should require an adaptor signature that is kept secret by the participants from the miner that might want to manipulate the transactions to make other alternate branches more favorable to the miner.

In addition, covenant mechanisms that require large witness data are probably more vulnerable to MEV.
For instance, if in a dispute case, one of the disputants needs to use a large witness data while the other requires a smaller one, then the disputant with the smaller witness data would have an advantage, and can match the fee offered by the disputant with the larger witness.
Then a fee-maximizing miner would prefer the smaller-witness branch of the contract, as they get more fees for less blockspace.
Of course, this mechanism itself can be used if we can arrange that the disputant that is inherently "wrong" (i.e. went against the expected behavior of the protocol) is the one that is burdened with the larger witness.

Or I could be entirely wrong and MEV is something even worse than that.

Hmmmmmm

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Fri May 20 23:47:54 2022
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 20 May 2022 23:47:54 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #9 Notes
In-Reply-To: <15z3VVTB7kcfg_qPey-bpkPtF551URlIDOq_qIvO9SdYWBW6duAfZjCOXT0o5hkQIdDznLsGSP9WqVw3ChXalEDyvttuUMyXT9x9SAqNfiE=@protonmail.com>
References: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>
 <4FE6Gygz1J6ehzVcTMyfSGbhSPvvkg06LjxqKy-lhPgGlYOGAbxgjYEkGBys8iE09FCOOU1rzq2GLqnMNjMhbstTTdtYNqzHWaLro1CA5FM=@protonmail.com>
 <15z3VVTB7kcfg_qPey-bpkPtF551URlIDOq_qIvO9SdYWBW6duAfZjCOXT0o5hkQIdDznLsGSP9WqVw3ChXalEDyvttuUMyXT9x9SAqNfiE=@protonmail.com>
Message-ID: <bLiy9L3lrXcUEjguWaAamJ07dQAe7frz2118VgwGu9ikIHsUSD1rwpcF22ko4LmnKCza60-_4YlU7kmsfOBztGQcHvj2xVMfrGLNWw-mYgE=@protonmail.com>

Good morning fd0,


> > In addition, covenant mechanisms that require large witness data are probably more vulnerable to MEV.
>
>
> Which covenant mechanisms require large witness data?

`OP_CSFS` + `OP_CAT`, which requires that you copy parts of the transaction into the witness data if you want to use it for covenants.
And the script itself is in the witness data, and AFAIK `OP_CSFS` needs large scripts if used for covenants.

Arguably though `OP_CSFS` is not designed for covenants, it just *happens to enable* covenants when you throw enough data at it.

If we are going to tolerate recursive covenants, we might want an opcode that explicitly supports recursion, instead of one that happens to enable recursive covenants, because the latter is likely to require more data to be pushed on the witness stack.
E.g. instead of the user having to quine the script (i.e. the script is really written twice, so it ends up doubling the witness size of the SCRIPT part), make an explicitly quining opcode.

Basically, Do not Repeat Yourself.

Regards,
ZmnSCPxj

From alicexbt at protonmail.com  Fri May 20 23:23:58 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Fri, 20 May 2022 23:23:58 +0000
Subject: [bitcoin-dev] CTV BIP Meeting #9 Notes
In-Reply-To: <4FE6Gygz1J6ehzVcTMyfSGbhSPvvkg06LjxqKy-lhPgGlYOGAbxgjYEkGBys8iE09FCOOU1rzq2GLqnMNjMhbstTTdtYNqzHWaLro1CA5FM=@protonmail.com>
References: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>
 <4FE6Gygz1J6ehzVcTMyfSGbhSPvvkg06LjxqKy-lhPgGlYOGAbxgjYEkGBys8iE09FCOOU1rzq2GLqnMNjMhbstTTdtYNqzHWaLro1CA5FM=@protonmail.com>
Message-ID: <15z3VVTB7kcfg_qPey-bpkPtF551URlIDOq_qIvO9SdYWBW6duAfZjCOXT0o5hkQIdDznLsGSP9WqVw3ChXalEDyvttuUMyXT9x9SAqNfiE=@protonmail.com>

Hi ZmnSCPxj,


> TLDR: MEV = Miner-extractable value, basically if your contracts are complex enough, miners can analyze which of the possible contract executions are most profitable for them, and order transactions on the block they are building in such a way that it is the most profitable path that gets executed.
> (do correct me if that summary is inaccurate or incomplete)

Yes its elaborated as Miner Extractable Value and also referred as Maximal Extractable Value sometimes because value could be extracted by validators, sequencers and others in some chains. MEV is basically frontrunning some transactions based on mempool activity for profit. Profit could be achieved by order or include/exclude some transactions in block. Normally such opportunities are only found in complex smart contracts that allow trades being settled on-chain.

In this (IRC logs) context, Jeremy mentioned sandwich attack. An attacker looks for buy orders in mempool, buy before others and profit from selling at higher price.

> Now, having thought of this problem for no more than 5 minutes, it seems to me, naively, that a mechanism with privacy would be helpful, i.e. the contract details should be as little-revealed as possible, to reduce the scope of miner-extractable value.

This makes sense and Tarun has shared similar ideas for AMMs in this pdf: https://drive.google.com/file/d/1W6PtJhGgqlNTCENE7I5pO5Brh2oqasVc/view?usp=sharing

> Probably, it is best if our covenants systems take full advantage of the linearity of Schnorr signing, in that case, if there is at all some kind of branch involved; for example, a previous transaction may reveal, if you have the proper adaptor signature, some scalar, and that scalar is actually the `s` component for a signature of a different transaction.
> Without knowledge of the adaptor signature, and without knowledge of the link between this previous transaction and some other one, a miner cannot extract additional value by messing with the ordering the transactions get confirmed on the blockchain, or whatever.

I am assuming this is possible using all the bitcoin covenant proposals including CTV.

> In addition, covenant mechanisms that require large witness data are probably more vulnerable to MEV.

Which covenant mechanisms require large witness data?


/dev/fd0

Sent with ProtonMail secure email.
------- Original Message -------
On Friday, May 20th, 2022 at 6:33 AM, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:


> Good morning fd0,
>
> > MEV could be one the issues associated with general covenants. There are some resources on https://mev.day if anyone interested to read more about it.
> > 13:06 <@jeremyrubin> the covenants are "self executing" and can be e.g. sandwiched13:07 <@jeremyrubin> so given that bitmatrix is sandwich attackable, you'd see similar types of MEV as Eth sees13:07 <@jeremyrubin> v.s. the MEV of e.g. lightning channels
> > 13:14 < aj> i guess i'd rather not have that sort of MEV available, because then it makes complicated MEV extraction profitable, which then makes "smart" miners more profitable than "Dumb" ones, which is maybe centralising
>
>
> Well that was interesting....
>
> TLDR: MEV = Miner-extractable value, basically if your contracts are complex enough, miners can analyze which of the possible contract executions are most profitable for them, and order transactions on the block they are building in such a way that it is the most profitable path that gets executed.
> (do correct me if that summary is inaccurate or incomplete)
>
> As a concrete example: in a LN channel breach condition, the revocation transaction must be confirmed within the CSV timeout, or else the theft will be accepted and confirmed.
> Now, some software will be aware of this timeout and will continually raise the fee of the revocation transaction per block.
> A rational miner which sees a channel breach condition might prefer to not mine such a transaction, since if it is not confirmed, the software will bump up the fees and the miner could try again on the next block with the higher feerates.
> Depending on the channel size and how the software behaves exactly, the miner may be able to make a decision on whether it should or should not work on the revocation transaction and instead hold out for a later higher fee.
>
> Now, having thought of this problem for no more than 5 minutes, it seems to me, naively, that a mechanism with privacy would be helpful, i.e. the contract details should be as little-revealed as possible, to reduce the scope of miner-extractable value.
> For instance, Taproot is good since only one branch at a time can be revealed, however, in case of a dispute, multiple competing branches of the Taproot may be revealed by the disputants, and the miners may now be able to make a choice.
>
> Probably, it is best if our covenants systems take full advantage of the linearity of Schnorr signing, in that case, if there is at all some kind of branch involved; for example, a previous transaction may reveal, if you have the proper adaptor signature, some scalar, and that scalar is actually the `s` component for a signature of a different transaction.
> Without knowledge of the adaptor signature, and without knowledge of the link between this previous transaction and some other one, a miner cannot extract additional value by messing with the ordering the transactions get confirmed on the blockchain, or whatever.
>
> This may mean that mechanisms that inspect the block outside of the transaction being validated (e.g. `OP_BRIBE` for drivechains, or similar mechanisms that might be capable of looking beyond the transaction) should be verboten; such cross-transaction introspection should require an adaptor signature that is kept secret by the participants from the miner that might want to manipulate the transactions to make other alternate branches more favorable to the miner.
>
> In addition, covenant mechanisms that require large witness data are probably more vulnerable to MEV.
> For instance, if in a dispute case, one of the disputants needs to use a large witness data while the other requires a smaller one, then the disputant with the smaller witness data would have an advantage, and can match the fee offered by the disputant with the larger witness.
> Then a fee-maximizing miner would prefer the smaller-witness branch of the contract, as they get more fees for less blockspace.
> Of course, this mechanism itself can be used if we can arrange that the disputant that is inherently "wrong" (i.e. went against the expected behavior of the protocol) is the one that is burdened with the larger witness.
>
> Or I could be entirely wrong and MEV is something even worse than that.
>
> Hmmmmmm
>
> Regards,
> ZmnSCPxj

From bram at chia.net  Sat May 21 15:37:51 2022
From: bram at chia.net (Bram Cohen)
Date: Sat, 21 May 2022 08:37:51 -0700
Subject: [bitcoin-dev] CTV BIP Meeting #9 Notes
In-Reply-To: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>
References: <Q26yJ8xABAnyKIAJ7nAt5er5Tok-tqvbQYhN7Wxh1xdlod-Kg5d7jefrxEgeini54ZIPup3jIGjmTx1gZBKEIjT7mYSQlXcTwG-Olo4pz8E=@protonmail.com>
Message-ID: <CAHUJnBCjYpVVsR2gVzsODwVgjmFCsTEmi7=KYAm4i32j5sK3RA@mail.gmail.com>

On Thu, May 19, 2022 at 9:17 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> MEV could be one the issues associated with general covenants. There are
> some resources on https://mev.day if anyone interested to read more about
> it.
>

One of the top things to do about MEV is to make all transactions in a
block simultaneous, so for example if you have a price oracle it can be
limited to only reporting one price per block so although it can be
manipulated to either report a high or low price it can't simultaneously do
both. In Bitcoin ordering is strictly enforced but there's a loophole that
things which happen in the same transaction do happen simultaneously, so
future extensions could be made to only sign things they care about and are
okay with transactions getting aggregated just by smushing them together.
That of course requires a new signature opcode, because current signatures
always sign the whole transaction.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220521/f44e89f7/attachment.html>

From AdamISZ at protonmail.com  Sat May 21 21:24:39 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Sat, 21 May 2022 21:24:39 +0000
Subject: [bitcoin-dev] Pay to signature hash as a covenant
In-Reply-To: <160600410-14147cd52da04b7e94af778dff5502bf@pmq7v.m5r2.onet>
References: <160600410-14147cd52da04b7e94af778dff5502bf@pmq7v.m5r2.onet>
Message-ID: <moWd-k5LwWHaGbUC5KWrv20R_c9__AwH41Azf1IuZiRYlhOtQv522ku8yHeEJFIEpCsl6vLgBrVK4MdrZsY37xdh_IobnQPdoxK-oj0piDY=@protonmail.com>






Sent with ProtonMail secure email.
------- Original Message -------
On Tuesday, May 3rd, 2022 at 02:37, vjudeu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Typical P2PK looks like that: "<signature> <pubkey> OP_CHECKSIG". In a typical scenario, we have "<signature>" in out input and "<pubkey> OP_CHECKSIG" in our output. I wonder if it is possible to use covenants right here and right now, with no consensus changes, just by requiring a specific signature. To start with, I am trying to play with P2PK and legacy signatures, but it may turn out, that doing such things with Schnorr signatures will be more flexible and will allow more use cases.
>
>
> The simplest "pay to signature" script I can think of is: "<signature> OP_SWAP OP_CHECKSIG". Then, any user can provide just a "<pubkey>" in some input, as a part of a public key recovery. The problem with such scheme is that it is insecure. Another problem is that we should handle it carefully, because signatures are removed from outputs. However, we could replace it with some signature hash, then it will be untouched, for example: "OP_TOALTSTACK OP_DUP OP_HASH160 <signatureHash> OP_EQUALVERIFY OP_FROMALTSTACK OP_CHECKSIG".
>

Doesn't this suffer from the standard "circular reference" problem for covenants? To pay to a utxo U1, whose scriptpubkey is a (p2wsh wrapped, say) script of: sig, op_checksig, I must create that sig, using my chosen public key, and a message which is a (signature style) hashing of a tx TX1, where an/the input to TX1 is U1, and the txid of U1 'hashes over' that script, which includes the sig we're trying to create. You can't make a hash of data which includes that hash (unless the hash fn is broken ofc).

I don't think that's affected by the later discussion here or in Zmn's response right?

Also a side detail which you might find useful in these ponderings: pubkey recovery is, as you know, possible in ECDSA but is not possible in BIP340 schnorr (which has key prefixing, i.e. the pubkey is included in the message hash binding, i.e. the e in s = k + ex), but is in the original Schnorr where only R(=kG), m are included in e. Easy to see why: from R, s and e(=H(R,m) .. easy to calculate) you can get P = (sG - R)* e^-1.
But in BIP340 Schnorr where (R, s) is published and e (=H(P, R, m)) is not, you cannot reconstruct e and so can only calculate e*P, which by DL assumption does not reveal P. Another way to put it is: if you made up a random R, s you wouldn't be able to find the right 'P' to put into e=H(P, R, m) so that the same P came out, and so that the sig actually verifies.

Cheers,
waxwing/AdamISZ

From AdamISZ at protonmail.com  Sat May 21 21:36:06 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Sat, 21 May 2022 21:36:06 +0000
Subject: [bitcoin-dev] BIP proposal: Timelocked address fidelity bond
	for BIP39 seeds
In-Reply-To: <tG19tbinpV6rx5WtwbP3fIilB3lvJvhoUSpj6eJIw5VKWykeG72TErCvF1ZzVotiLsat0iosK2xdomXMppDK2AzTUe864tQIg5hz4fSuJvw=@protonmail.com>
References: <f3892570-6c45-47ee-2804-9988ff18bdf5@riseup.net>
 <48D4B621-D862-4031-AE43-3F54D34FB0B5@voskuil.org>
 <ipHZZpEipF7oliIh-RlPP2e6rcWkIFW22jEOwaCPIfJUuoDh4JfmzvGC2i7tZK-kT0o0osyxFyWxZKDRZOWI_dqdSWNWOLR7KpN3CsN6BRE=@protonmail.com>
 <01c401d86a5c$956ddbd0$c0499370$@voskuil.org>
 <01d901d86a64$452ef9d0$cf8ced70$@voskuil.org>
 <tG19tbinpV6rx5WtwbP3fIilB3lvJvhoUSpj6eJIw5VKWykeG72TErCvF1ZzVotiLsat0iosK2xdomXMppDK2AzTUe864tQIg5hz4fSuJvw=@protonmail.com>
Message-ID: <olCBTQ6jYBZcIxtLRZP32QmJrLF4j9jfzR5SSXwwUJp-J85H3usIGmNaWT5DIQV9DnuDEl9Noo9nEJ593dpgqipSRAwGkggCB0eHZhuD6nI=@protonmail.com>


> > > As a better analogy: I am borrowing a piece of gold, smelting it down to make
> > > a nice shiny advertisement "I am totally not a bot!!", then at the end of the
> > > lease period, re-smelting it back and returning to you the same gold piece
> > > (with the exact same atoms constituting it), plus an interest from my business,
> > > which gained customers because of the shiny gold advertisement claiming "I
> > > am totally not a bot!!".
> > >
> > > That you use the same piece of gold for money does not preclude me using
> > > the gold for something else of economic value, like making a nice shiny
> > > advertisement, so I think your analysis fails there.
> > > Otherwise, your analysis is on point, but analyses something else entirely.

Back to this analogy, I think it's imprecise in a way that's important to not overlook: you cannot re-use the same gold atoms in two different advertisements. Use of a fidelity bond, being basically a signature, is completely 'non-rivalrous' as I think the economists say.

> Yes, that is why Tamas switched to defiads, as I had convinced him that it would be similar enough without actually being a covenant scam like you described.
>
> > In any case, I tend to agree with your other posts on the subject. For the burn to be provably non-dilutable it must be a cost provably associated to the scenario which relies upon the cost. This provides the global uniqueness constraint (under cryptographic assumptions of difficulty).
>
>
> Indeed.
> I suspect the only reason it is not yet a problem with existing JoinMarket and Teleport is simply that no convenient software currently exists which allows the same bond to be used by both, thus making it safe in practice but not in theory.
> But the theory implies that if somebody does make such software, effectively both systems will become joined as effectively only a single identity exists in both systems.
> This may not be a problem either since the intent is that Teleport will obsolete JoinMarket someday, but if other applications start using the same scheme without requiring a commitment to a specific application, this may also effectively render Teleport less useful as well.
>
> Regards,
> ZmnSCPxj
> _______________________________________________

So, general comment: it seems like both you and Eric agree with my uncertain intuition up-thread and therefore do we all agree that the correct solution (to whatever extent there is one) is something like domain separation tags, as we discussed earlier? It's still a matter of social consensus: if appending "JM" to the end of a certificate signature is intended to mean that this fidelity bond can only be used in Joinmarket and not anywhere else, well we can only as individual users demand that (i.e. *I* might not accept it in Teleport, but what if Fred down the street does? It's not enough for me to rely on my own criteria!), and more subtly, it makes sense only if we all have an unambiguous definition of what Joinmarket *is* - ironically it is precisely the thing brought most into question by the achievement of real decentralization in a system.

Cheers,
waxwing/AdamISZ

From AdamISZ at protonmail.com  Sun May 22 22:26:08 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Sun, 22 May 2022 22:26:08 +0000
Subject: [bitcoin-dev] MuSig2 BIP
In-Reply-To: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
References: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
Message-ID: <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>

Jonas,

Many thanks for getting the BIP draft out. Particularly appreciate the reference code!

I have a question about identical pubkeys (including how it relates to MuSig2* optimization):

What is the purpose of allowing this? Isn't it always the case that N equal keys combined with M non-equal keys is logically equivalent to 1+M keys? It non trivially complicates certain aspects of the algorithm to allow it and I guess I must be missing something in my previous statement because, otherwise, isn't it pointless (and pretty unwise, considering how likely it is to come from an error)? The whole 'second key' thing in MuSig2 is a sorty of icky side effect.

A valid point about this is already made in the BIP and enunciated clearly and in detail: that MuSig2 is designed to discover lying at the partial sig verify stage, so it's not really that I'm saying that what's in the BIP is logically or mathematically wrong; it just seems unwise and needlessly complex. The case of 2 keys being identical does not imply an attacker; it is far more likely to be a busted implementation by counterparties where they're accidentally using P1, P1 instead of their intended P1, P2.

I suppose the key word is 'needlessly' - is there a need for this that I'm overlooking?

Cheers,
waxwing/AdamISZ


Sent with ProtonMail secure email.
------- Original Message -------
On Tuesday, April 5th, 2022 at 17:57, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Tim Ruffing, Elliott Jin, and I are working on a MuSig2 BIP that we would like
> to propose to the community for discussion. The BIP is compatible with BIP340
> public keys and signatures. It supports tweaking, which allows deriving BIP32
> child keys from aggregate keys and creating BIP341 Taproot outputs with key and
> script paths. You can find the BIP draft at:
> https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki
>
> The draft is in a state where it should be possible to write an implementation
> based on the BIP that passes the basic test vectors (as, e.g., demonstrated by
> [0]). The draft BIP also contains a reference implementation in python. Please
> be aware that this is only a draft and that it may still be necessary to make
> small tweaks to the algorithms and test vectors.
>
> [0] https://github.com/btcsuite/btcd/pull/1820
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jonasdnick at gmail.com  Mon May 23 15:56:54 2022
From: jonasdnick at gmail.com (Jonas Nick)
Date: Mon, 23 May 2022 15:56:54 +0000
Subject: [bitcoin-dev] MuSig2 BIP
In-Reply-To: <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>
References: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
 <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>
Message-ID: <c2a9b488-8d29-d1c6-b2c3-bc17d12b7d65@gmail.com>

Thank you for taking the time to look at the BIP and reference code, waxwing. I
don't know if you're overlooking anything, so let me try to restate the
paragraph in the BIP draft that attempts to cover this topic [0].

Suppose signers would just abort in the presence of identical public keys. In
that case, a disruptive signer can permanently DoS-attack a session by simply
copying the public key of some other signer. Therefore, the BIP is much more
useful if it can deal with identical public keys.

The MuSig2 BIP draft requires some added complexity to handle identical public
keys (because of the MuSig2* optimization). But this solution naturally allows
identifying and removing disruptive signers, which ultimately reduces the
complexity for MuSig2 users.

[0] https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki#public-key-aggregation

From aj at erisian.com.au  Mon May 23 21:34:16 2022
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 24 May 2022 07:34:16 +1000
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
Message-ID: <20220523213416.GA6151@erisian.com.au>

On Wed, May 18, 2022 at 02:40:58PM -0400, Gloria Zhao via bitcoin-dev wrote:
> > Does it make sense for these to be configurable, rather than implied
> > by the version?
> > ? would it be better to either just not do sendpackages
> > at all if you're limiting ancestors in the mempool incompatibly
> Effectively: if you?re setting your ancestor/descendant limits lower than
> the default, you can?t do package relay. I wonder if this might be
> controversial, since it adds pressure to adhere to Bitcoin Core?s current
> mempool policy? I would be happy to do it this way, though - makes things
> easier to implement.

How about looking at it the other way: if you're writing a protocol that's
dependent on people seeing that a package as a whole pays a competitive
feerate, don't you want to know in advance what conditions the network
is going to impose on your transactions in order to consider them as a
package? In that case, aren't the "depth" and "size" constraints things
we should specify in a standard?

(The above's not a rhetorical question; I'm not sure what the answer is.
And even if it's "yes", maybe core's defaults should be reconsidered
rather than standardised as-is)

Worst case, you could presumably do a new package relay version with
different constraints, if needed.

> > > 5. If 'fRelay==false' in a peer's version message, the node must not
> > >    send "sendpackages" to them. If a "sendpackages" message is
> > > received by a peer after sending `fRelay==false` in their version
> > > message, the sender should be disconnected.
> > Seems better to just say "if you set fRelay=false in your version
> > message, you must not send sendpackages"? You already won't do packages
> > with the peer if they don't also announce sendpackages.
> I guess, theoretically, if you allow bloom filters with this peer, it?s
> plausible they?re saying ?fRelay=false, I?ll send you a bloom filter later,
> and I?ll also want to talk about packages.?

I was just meaning "it's okay to send VERSION fRelay=true then immediately
send WTXIDRELAY then immediately send SENDPACKAGES" without having to
first verify what the other guy's fRelay was set to. On the other hand,
you do already have to verify the other guy's version is high enough,
but it would be kind-of nice to move towards just announcing the features
you support, and not having to make it a multistep negotiation...

> > Maybe: "You must not send sendpackages unless you also send wtxidrelay" ?
> Do you mean if we get a verack, and the peer sent ?sendpackages? but not
> ?wtxidrelay,? we should disconnect them?

Yes.

> I have it as: we send a PCKG INV when this transaction?s feerate is above
> the fee filter, but one or more of its parents don?t. I don?t think using
> ancestor feerate is better.
> See this counterexample:
> https://raw.githubusercontent.com/glozow/bitcoin-notes/master/mempool_garden/abc_1parent_2kids.png
> A (0fee) has 2 kids, B (3sat/vB) and C (20sat/vB), everything?s the same
> vsize. Let?s say the fee filter is 3sat/vB.
> If we do it based on ancestor feerate, we won?t send B. But B is actually
> fine; C is paying for A.

But that only works if the receiver also has C, in which case they also
have A, and you don't need package relay to do anything with B? If they
didn't have C already, then relaying {A,B} would be a waste of time,
because {A,B} would be rejected as only paying 1.5sat/vB or whatever..

If you switch it to being:

  A (0 sats, 200vB)
  B (2000 sats, 200vB, spends A:0)
  C (200 sats, 200vB)
  D (1000 sats, 200vB, sepnds A:1, C:0)

then you get:

  A alone = 0s/vB
  B+A = 5s/vB

  C alone = 1s/vB
  D+C+A = 2s/vB
  D+C = 3s/vB      (B+A already at 5s/vB)

which I think recovers your point, while also having all the details
only be dealing with direct parents.

> > Are "getpckgtxns" / "pcktxns" really limited to packages, or are they
> > just a general way to request a batch of transactions?
> > Maybe call those messages "getbatchtxns" and "batchtxns" and allow them to
> > be used more generally, potentially in ways unrelated to packages/cpfp?
> Indeed, it?s a general way to request a batch of transactions. I?ll
> highlight that it is ?all or nothing,? i.e. if the sender is missing any of
> them, they?ll just send a notfound.
> The idea here was to avoid downloading any transactions that can?t be
> validated right away.

Right; maybe I should just be calling a "batch of packages to be validated
together" a "tx package" in the first place.

Maybe it would be worth emphasising that you should be expecting to
validate all the txs you receive as a response to getpckgtxns (getpkgtxs
:) all at the same time, and immediately upon receiving them?

> > The "only be sent if both peers agreed to do package relay" rule could
> > simply be dropped, I think.
> Wouldn?t we need some way of saying ?hey I support batchtxns?? Otherwise
> you would have to guess by sending a request and waiting to see if it?s
> ignored?

Sure, perhaps I should have said leave that rule, but drop the following
"should be disconnected" rule, so that other BIPs could add in other
ways of negotiating the connection in future? *shrug*

> > Shouldn't the sender only be sending package announcements when they know
> > the recipient will be interested in the package, based on their feefilter?
> I think there are cases where the sender doesn?t necessarily know.
> Consider this example:
> https://raw.githubusercontent.com/glozow/bitcoin-notes/master/mempool_garden/rich_parent_bad_cpfp.png
> D (5sat/vB) has 2 parents, A (0sat/vB) and B (20sat/vB). All same size.
> Feefilter is 3sat/vB.
> If the receiver already has B, they?ll know they can just reject the
> package already based on the pckginfo.
> But the sender doesn?t really know that. The sender just knows A is below
> feerate and D is above. D is above the fee filter, and its ancestor feerate
> is above the fee filter.

The sender would also need to know whether or not there's some other
child E that pays for A sufficiently?

If you're asking for the package for "D", would a response telling you:

  txid_D (500 sat, 100vB)
  txid_A (0 sat, 100vB)
  txid_B (2000 sat, 100 vB)

be better, in that case? Then the receiver can maybe do the logic
themselves to figure out that they already have A in their mempool
so it's fine, or not?

If you've got a package for X, and its direct parents P1..Pn, then
I think the logic would be:

  * is X alone above my fee rate? no, then forget it
  * otherwise, s := X.size, f := X.fees, R := [X]
  * for P = P1..Pn:
    * do I already have P? then skip to the next parent
    * s += P.size, f += P.fees, R += [P]
  * if f/s above my fee rate floor? if so, request all the txs in R

and you'd request txs if-and-only-if they're a match for you mempool rate?

If you have a tx with 20 in-mempool parents, then the pkginfo1 message
as proposed would be 737 bytes; including all the fee/size info would be
957 bytes, maybe a 30% increase. Might be worth it though?

Cheers,
aj


From AdamISZ at protonmail.com  Mon May 23 22:09:52 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Mon, 23 May 2022 22:09:52 +0000
Subject: [bitcoin-dev] MuSig2 BIP
In-Reply-To: <c2a9b488-8d29-d1c6-b2c3-bc17d12b7d65@gmail.com>
References: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
 <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>
 <c2a9b488-8d29-d1c6-b2c3-bc17d12b7d65@gmail.com>
Message-ID: <HPRdBVSvEmkPyHkS-175ZYEYyL-ULZAgmhSPh3uwVtfryFOKZUFKUM5QXnSXjwZy3b10sV55f9lhOkZ-ILShaWSWJ7GMN0JmKNweKY6kfLg=@protonmail.com>

Jonas, all,:

So I do want to ask a couple further clarifying questions on this point, but I got rather majorly sidetracked :)
I wonder can you (and other list readers!) take a look at my attempt here to summarize what is described in Footnote 2 of the draft BIP (as it's related to this discussion and also .. it's pretty interesting generally!):

https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b

(btw github gists have equation rendering now which is nice!)

Thanks,
waxwing/AdamISZ



Sent with ProtonMail secure email.
------- Original Message -------
On Monday, May 23rd, 2022 at 10:56, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Thank you for taking the time to look at the BIP and reference code, waxwing. I
> don't know if you're overlooking anything, so let me try to restate the
> paragraph in the BIP draft that attempts to cover this topic [0].
>
> Suppose signers would just abort in the presence of identical public keys. In
> that case, a disruptive signer can permanently DoS-attack a session by simply
> copying the public key of some other signer. Therefore, the BIP is much more
> useful if it can deal with identical public keys.
>
> The MuSig2 BIP draft requires some added complexity to handle identical public
> keys (because of the MuSig2* optimization). But this solution naturally allows
> identifying and removing disruptive signers, which ultimately reduces the
> complexity for MuSig2 users.
>
> [0] https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki#public-key-aggregation
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From gloriajzhao at gmail.com  Tue May 24 01:13:43 2022
From: gloriajzhao at gmail.com (Gloria Zhao)
Date: Mon, 23 May 2022 21:13:43 -0400
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <20220523213416.GA6151@erisian.com.au>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
Message-ID: <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>

Hi aj,

> if you're writing a protocol that's
> dependent on people seeing that a package as a whole pays a competitive
> feerate, don't you want to know in advance what conditions the network
> is going to impose on your transactions in order to consider them as a
> package?

I do think unifying the size/count constraints would result in a more
stable/easier to reason about interface for L2 devs. Then the requirement
for propagation is just a path of nodes that support v1 package relay, and
it?s implied their mempool policy supports it as well. Also seems like it
could be a fingerprinting problem for nodes to give very specific
count/size limits.

> (? maybe core's defaults should be reconsidered rather than standardised
as-is)

> Worst case, you could presumably do a new package relay version with
> different constraints, if needed.

Maybe this was my actual concern. I think the defaults are safe but it?s
not like they?ve been proven to be optimal. This creates an obstacle to
changing them, especially if we want to make them smaller. But I think it?s
unlikely we?ll do that, and adding another version for new constraints
doesn?t seem too bad.


(Agreed with everything here, thanks for the feedback and clarifications!)
TLDR, making these changes:
- Count and size are implied by the version. Version 1 is specifically
child-with-unconfirmed-parents, where the whole package is at most 25
transactions and 101KvB.
- Announce sendpackages based on our own state. It?s ok to send
?sendpackages? if they sent fRelay=false.
- At verack, require fRelay=true and wtxidrelay if they sent sendpackages,
otherwise disconnect.
- If we get ?getpckgtxns? or ?pckgtxns? without having negotiated
?sendpackages? ahead of time, ignore, don?t disconnect. Emphasize that the
intention is to validate all of the transactions received through
?pckgtxns? together.

> If you're asking for the package for "D", would a response telling you:
>   txid_D (500 sat, 100vB)
>   txid_A (0 sat, 100vB)
>   txid_B (2000 sat, 100 vB)
> be better, in that case? Then the receiver can maybe do the logic
> themselves to figure out that they already have A in their mempool
> so it's fine, or not?

Right, I also considered giving the fees and sizes of each transaction in
the package in ?pckginfo1?. But I don?t think that information provides
additional meaning unless you know the exact topology, i.e. also know if
the parents have dependency relationships between them. For instance, in
the {A, B, D} package there, even if you have the information listed, your
decision should be different depending on whether B spends from A. The only
thing you know for sure about a child with direct parents is: if the
aggregate feerate is too low, you won?t want the child since it depends on
everyone else. If there?s a good-feerate transaction in there that doesn?t
have a dependency, you?re fine as long as someone sends it to you
individually.

Best,
Gloria

On Mon, May 23, 2022 at 2:34 PM Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Wed, May 18, 2022 at 02:40:58PM -0400, Gloria Zhao via bitcoin-dev
> wrote:
> > > Does it make sense for these to be configurable, rather than implied
> > > by the version?
> > > ? would it be better to either just not do sendpackages
> > > at all if you're limiting ancestors in the mempool incompatibly
> > Effectively: if you?re setting your ancestor/descendant limits lower than
> > the default, you can?t do package relay. I wonder if this might be
> > controversial, since it adds pressure to adhere to Bitcoin Core?s current
> > mempool policy? I would be happy to do it this way, though - makes things
> > easier to implement.
>
> How about looking at it the other way: if you're writing a protocol that's
> dependent on people seeing that a package as a whole pays a competitive
> feerate, don't you want to know in advance what conditions the network
> is going to impose on your transactions in order to consider them as a
> package? In that case, aren't the "depth" and "size" constraints things
> we should specify in a standard?
>
> (The above's not a rhetorical question; I'm not sure what the answer is.
> And even if it's "yes", maybe core's defaults should be reconsidered
> rather than standardised as-is)
>
> Worst case, you could presumably do a new package relay version with
> different constraints, if needed.
>
> > > > 5. If 'fRelay==false' in a peer's version message, the node must not
> > > >    send "sendpackages" to them. If a "sendpackages" message is
> > > > received by a peer after sending `fRelay==false` in their version
> > > > message, the sender should be disconnected.
> > > Seems better to just say "if you set fRelay=false in your version
> > > message, you must not send sendpackages"? You already won't do packages
> > > with the peer if they don't also announce sendpackages.
> > I guess, theoretically, if you allow bloom filters with this peer, it?s
> > plausible they?re saying ?fRelay=false, I?ll send you a bloom filter
> later,
> > and I?ll also want to talk about packages.?
>
> I was just meaning "it's okay to send VERSION fRelay=true then immediately
> send WTXIDRELAY then immediately send SENDPACKAGES" without having to
> first verify what the other guy's fRelay was set to. On the other hand,
> you do already have to verify the other guy's version is high enough,
> but it would be kind-of nice to move towards just announcing the features
> you support, and not having to make it a multistep negotiation...
>
> > > Maybe: "You must not send sendpackages unless you also send
> wtxidrelay" ?
> > Do you mean if we get a verack, and the peer sent ?sendpackages? but not
> > ?wtxidrelay,? we should disconnect them?
>
> Yes.
>
> > I have it as: we send a PCKG INV when this transaction?s feerate is above
> > the fee filter, but one or more of its parents don?t. I don?t think using
> > ancestor feerate is better.
> > See this counterexample:
> >
> https://raw.githubusercontent.com/glozow/bitcoin-notes/master/mempool_garden/abc_1parent_2kids.png
> > A (0fee) has 2 kids, B (3sat/vB) and C (20sat/vB), everything?s the same
> > vsize. Let?s say the fee filter is 3sat/vB.
> > If we do it based on ancestor feerate, we won?t send B. But B is actually
> > fine; C is paying for A.
>
> But that only works if the receiver also has C, in which case they also
> have A, and you don't need package relay to do anything with B? If they
> didn't have C already, then relaying {A,B} would be a waste of time,
> because {A,B} would be rejected as only paying 1.5sat/vB or whatever..
>
> If you switch it to being:
>
>   A (0 sats, 200vB)
>   B (2000 sats, 200vB, spends A:0)
>   C (200 sats, 200vB)
>   D (1000 sats, 200vB, sepnds A:1, C:0)
>
> then you get:
>
>   A alone = 0s/vB
>   B+A = 5s/vB
>
>   C alone = 1s/vB
>   D+C+A = 2s/vB
>   D+C = 3s/vB      (B+A already at 5s/vB)
>
> which I think recovers your point, while also having all the details
> only be dealing with direct parents.
>
> > > Are "getpckgtxns" / "pcktxns" really limited to packages, or are they
> > > just a general way to request a batch of transactions?
> > > Maybe call those messages "getbatchtxns" and "batchtxns" and allow
> them to
> > > be used more generally, potentially in ways unrelated to packages/cpfp?
> > Indeed, it?s a general way to request a batch of transactions. I?ll
> > highlight that it is ?all or nothing,? i.e. if the sender is missing any
> of
> > them, they?ll just send a notfound.
> > The idea here was to avoid downloading any transactions that can?t be
> > validated right away.
>
> Right; maybe I should just be calling a "batch of packages to be validated
> together" a "tx package" in the first place.
>
> Maybe it would be worth emphasising that you should be expecting to
> validate all the txs you receive as a response to getpckgtxns (getpkgtxs
> :) all at the same time, and immediately upon receiving them?
>
> > > The "only be sent if both peers agreed to do package relay" rule could
> > > simply be dropped, I think.
> > Wouldn?t we need some way of saying ?hey I support batchtxns?? Otherwise
> > you would have to guess by sending a request and waiting to see if it?s
> > ignored?
>
> Sure, perhaps I should have said leave that rule, but drop the following
> "should be disconnected" rule, so that other BIPs could add in other
> ways of negotiating the connection in future? *shrug*
>
> > > Shouldn't the sender only be sending package announcements when they
> know
> > > the recipient will be interested in the package, based on their
> feefilter?
> > I think there are cases where the sender doesn?t necessarily know.
> > Consider this example:
> >
> https://raw.githubusercontent.com/glozow/bitcoin-notes/master/mempool_garden/rich_parent_bad_cpfp.png
> > D (5sat/vB) has 2 parents, A (0sat/vB) and B (20sat/vB). All same size.
> > Feefilter is 3sat/vB.
> > If the receiver already has B, they?ll know they can just reject the
> > package already based on the pckginfo.
> > But the sender doesn?t really know that. The sender just knows A is below
> > feerate and D is above. D is above the fee filter, and its ancestor
> feerate
> > is above the fee filter.
>
> The sender would also need to know whether or not there's some other
> child E that pays for A sufficiently?
>
> If you're asking for the package for "D", would a response telling you:
>
>   txid_D (500 sat, 100vB)
>   txid_A (0 sat, 100vB)
>   txid_B (2000 sat, 100 vB)
>
> be better, in that case? Then the receiver can maybe do the logic
> themselves to figure out that they already have A in their mempool
> so it's fine, or not?
>
> If you've got a package for X, and its direct parents P1..Pn, then
> I think the logic would be:
>
>   * is X alone above my fee rate? no, then forget it
>   * otherwise, s := X.size, f := X.fees, R := [X]
>   * for P = P1..Pn:
>     * do I already have P? then skip to the next parent
>     * s += P.size, f += P.fees, R += [P]
>   * if f/s above my fee rate floor? if so, request all the txs in R
>
> and you'd request txs if-and-only-if they're a match for you mempool rate?
>
> If you have a tx with 20 in-mempool parents, then the pkginfo1 message
> as proposed would be 737 bytes; including all the fee/size info would be
> 957 bytes, maybe a 30% increase. Might be worth it though?
>
> Cheers,
> aj
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220523/c502fd7c/attachment-0001.html>

From woltx at protonmail.com  Tue May 24 01:31:23 2022
From: woltx at protonmail.com (woltx)
Date: Tue, 24 May 2022 01:31:23 +0000
Subject: [bitcoin-dev] =?utf-8?q?_Silent_Payments_=E2=80=93_Non-interactiv?=
	=?utf-8?q?e_private_payments_with_no_on-chain_overhead?=
Message-ID: <yAzuw9BsMPNXQIeZG98n6d0-6C1ymv9ZCfKIV9ZZYc97wuVbsjkKF1pqS9Uc4ZTuGyh2nKNeRiDYPuklq64Y4UYQ4ITfnvvQo7vsSChvUMs=@protonmail.com>

I created a short and simple tutorial on how to make silent payments on signet.
https://gist.github.com/w0xlt/72390ded95dd797594f80baba5d2e6ee
In this tutorial, the user will generate an address, publish it, receive and spend coins from it and still no transactions are shown from this address in a blockchain explorer.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220524/45256620/attachment.html>

From alicexbt at protonmail.com  Tue May 24 13:49:34 2022
From: alicexbt at protonmail.com (alicexbt)
Date: Tue, 24 May 2022 13:49:34 +0000
Subject: [bitcoin-dev]
	=?utf-8?q?Silent_Payments_=E2=80=93_Non-interactive?=
	=?utf-8?q?_private_payments_with_no_on-chain_overhead?=
In-Reply-To: <yAzuw9BsMPNXQIeZG98n6d0-6C1ymv9ZCfKIV9ZZYc97wuVbsjkKF1pqS9Uc4ZTuGyh2nKNeRiDYPuklq64Y4UYQ4ITfnvvQo7vsSChvUMs=@protonmail.com>
References: <yAzuw9BsMPNXQIeZG98n6d0-6C1ymv9ZCfKIV9ZZYc97wuVbsjkKF1pqS9Uc4ZTuGyh2nKNeRiDYPuklq64Y4UYQ4ITfnvvQo7vsSChvUMs=@protonmail.com>
Message-ID: <p5vlwEtPHiiul4GbOK8j3x32FKrnNC9aba_5Q_MJnNVA9I6vvc3BrfQlbvUmBKJELMvORUk6JK68_rQMwsDpat4wHCkZZst79RJPIvyDPzI=@protonmail.com>

Hi woltx,

Thanks for implementing silent payments in Bitcoin Core. I tried the steps shared in tutorial and everything works as expected.

I have updated the silent payment address (signet) as TXT record for domain alice.silentbitco.in

$ dig -t txt alice.silentbitco.in +short
"tb1px3kma8e8y8z9l7e640v0x2chzrzww9cu06mqvwyrz805ffletu3s067sgh"

I have also added basic information about silent payments proposal, implementation and tutorial on https://silentbitco.in

I had no issues with performance of the UTXO Set and the blocks scan. I don't mind using flag but a new address/descriptor format should be a better approach. I could not review the code in detail or test edge cases however these suggestions by Pavol Rusnak make sense: https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8?permalink_comment_id=4177027#gistcomment-4177027

/dev/fd0

Sent with [ProtonMail](https://protonmail.com/) secure email.

------- Original Message -------
On Tuesday, May 24th, 2022 at 7:01 AM, woltx via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I created a short and simple tutorial on how to make silent payments on signet.
> https://gist.github.com/w0xlt/72390ded95dd797594f80baba5d2e6ee
> In this tutorial, the user will generate an address, publish it, receive and spend coins from it and still no transactions are shown from this address in a blockchain explorer.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220524/81d2b9ae/attachment.html>

From AdamISZ at protonmail.com  Tue May 24 19:06:41 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Tue, 24 May 2022 19:06:41 +0000
Subject: [bitcoin-dev] MuSig2 BIP
In-Reply-To: <HPRdBVSvEmkPyHkS-175ZYEYyL-ULZAgmhSPh3uwVtfryFOKZUFKUM5QXnSXjwZy3b10sV55f9lhOkZ-ILShaWSWJ7GMN0JmKNweKY6kfLg=@protonmail.com>
References: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
 <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>
 <c2a9b488-8d29-d1c6-b2c3-bc17d12b7d65@gmail.com>
 <HPRdBVSvEmkPyHkS-175ZYEYyL-ULZAgmhSPh3uwVtfryFOKZUFKUM5QXnSXjwZy3b10sV55f9lhOkZ-ILShaWSWJ7GMN0JmKNweKY6kfLg=@protonmail.com>
Message-ID: <XRFIZf_z1dKNoKvgFJmrgThHcIE_B0JW9mmJL7mE2B2afcgwZn7NuJaK_vXUAvVwWSZ2Nijwz9yhiwYpty6iI3mrJyivdLxL_CtWlEaAhMY=@protonmail.com>

------- Original Message -------
On Monday, May 23rd, 2022 at 17:09, AdamISZ via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Jonas, all,:
>
> So I do want to ask a couple further clarifying questions on this point, but I got rather majorly sidetracked :)
> I wonder can you (and other list readers!) take a look at my attempt here to summarize what is described in Footnote 2 of the draft BIP (as it's related to this discussion and also .. it's pretty interesting generally!):
>
> https://gist.github.com/AdamISZ/ca974ed67889cedc738c4a1f65ff620b
>
> (btw github gists have equation rendering now which is nice!)
>
> Thanks,
> waxwing/AdamISZ
>
Jonas, list,

So given that that's basically correct (see the comments), continuing on this point of how to handle duplicate keys:

In https://github.com/jonasnick/bips/blob/musig2/bip-musig2.mediawiki#identifiying-disruptive-signers we have:

"If partial signatures are received over authenticated channels, this method can be used to identify disruptive signers and hold them accountable. Note that partial signatures are not signatures. An adversary can forge a partial signature, i.e., create a partial signature without knowing the secret key for the claimed public key."

(the gist in the previous message was just fleshing out what's stated there and in Footnote 2: if you get a "valid" partial sig at index i, it doesn't mean that the signer at index i knows the key for index i, *if* they also control index j; it just means they won't be able to produce "valid" partial sigs for both indices i and j).

(scare quotes "valid" - there is no notion in MuSig2 of a partial signature as a signature, only the aggregate signature in toto is valid or invalid or forged).

So we see in the above quote, that the concept of 'authenticated channels' is rather important. Consider 2 scenarios:
1. "Persistent": Every signer has a persistent identity across many signing sessions, and their communications are authenticated against that identity.
2. "Spontaneous": Signers join the protocol in some ad hoc way, but authenticate specifically inasmuch as they set up temporary nyms and use e.g. diffie hellman to establish a confidential and authenticated channel for the period of this signing session.

An example of "Spontaneous" might be: a variant of a multiparty channel construction with anonymous participants on LN or LN* in which participants set up such constructions ad hoc e.g. via liquidity markets .. in contrast, e.g. a hardware wallet multisig setup with a known provider might be a "Persistent" case.

Not sure, but ... are we mainly talking about the "Spontaneous" case?

Because the "Persistent" case doesn't seem interesting: If I "know" the counterparty that I'm engaging in this protocol with, first, a Sybil at two indices is kinda weird, so the occurrence of a duplicated key from them tells me something is wrong and manual intervention is needed (or equivalently some sanity check in the meta-protocol). Often (e.g. cold storage, devices) there'd be a way to know in advance what the keys *should* be. It's very likely a bug. (I suppose you could argue waiting till the second signing round helps, because it helps us isolate the bug (except it might not, if in certain protocols, both signers have access to some shared keys, but, meh) ... but that doesn't seem convincing ... executing more of a protocol when you already know the implementation is broken seems unwise).

So, to the "Spontaneous" case: if we see two identical pubkeys from two pseud/anonymous counterparties, I can see the argument for waiting until partial sig sending occurs, before establishing misbehaviour. The main substance of the argument seems to be something like: we can't actually deduce adversarial behaviour at key exchange time, so we *have* to wait for the partial signature step. I'm objecting to this on two fronts:

* A general principle of security should be 'abort early'. It's to me just sensibly conservative to not continue given the substantial risk of bugs (esp. in systems exposed to nonce-fragility!)
* The claim that the protocol laid out in the BIP identifies misbehaviour seems to be at best partially correct, it cannot be true in the general case.

Jonas has already countered my first bullet point by stating that this abort-early (at key exchange) strategy opens up an unlimited DOS vector. My counter here is that that, because of the second bullet oint, the DOS vector remains, in the "Spontaneous" case, anyway; and that the only way to close it is to use either identities (switch to "Persistent": see e.g. Coinshuffle which registers identities via inputs), or cost.

(Why does the DOS vector remain? Because of the partial sig "validation" issue as per my gist and Footnote2: if key 3 and key 4 are identical in a set of 5, we can wait, and then find that partial sig 3 verifies, and partial sig 4 *also* verifies, and only at index 5 do we see an 'invalid' partial sig. If the adversary (as seems extremely likely.. I can't imagine it being otherwise) has used two *different* nyms for his two adversarial indices 4 and 5, then ejecting 5 doesn't really seem to close the DOS potential? If we then restart and 'grab another anonymous nym' for the 5th index, can't it be the adversary again? And haven't we let the adversary stay, at index 4? (though I'm not sure the implications)).

Another way to look at it, I'm saying that this claim:

"In contrast, MuSig2 is designed to identify disruptive signers at signing time: any signer who prevents a signing session from completing successfully by sending incorrect contributions in the session can be identified and held accountable (see below)."

isn't *fully* correct. That is, for sure the algorithm will identify a disruptive signer who simply operates one key, but it doesn't (as current) always identify every key owned by a disruptive signer. So it doesn't close the DOS vector.

(To be clear the whole 'fake partial sig' adversarial behaviour is *not* specific to having duplicate public keys; I'm just discussing whether the protocol should continue if duplicates are seen).

So overall I have the feeling that allowing duplicate keys at setup makes the implementation messier (and this protocol is complex, so that matters a bit more), and it strikes me as risky in the inevitable presence of implementation errors.

Cheers,
waxwing/AdamISZ

From aj at erisian.com.au  Tue May 24 19:48:02 2022
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 24 May 2022 15:48:02 -0400
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
 <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
Message-ID: <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>

On 23 May 2022 9:13:43 pm GMT-04:00, Gloria Zhao <gloriajzhao at gmail.com> wrote:
>> If you're asking for the package for "D", would a response telling you:
>>   txid_D (500 sat, 100vB)
>>   txid_A (0 sat, 100vB)
>>   txid_B (2000 sat, 100 vB)
>> be better, in that case? Then the receiver can maybe do the logic
>> themselves to figure out that they already have A in their mempool
>> so it's fine, or not?
>Right, I also considered giving the fees and sizes of each transaction in
>the package in ?pckginfo1?. But I don?t think that information provides
>additional meaning unless you know the exact topology, i.e. also know if
>the parents have dependency relationships between them. For instance, in
>the {A, B, D} package there, even if you have the information listed, your
>decision should be different depending on whether B spends from A.

I don't think that's true? We already know D is above our fee floor so if B with A is also above the floor, we want them all, but also if B isn't above the floor, but all of them combined are, then we also do?

If you've got (A,B,C,X) where B spends A and X spends A,B,C where X+C is below fee floor while A+B and A+B+C+X are above fee floor you have the problem though.

Is it plausible to add the graph in?

Cheers,
aj



-- 
Sent from my phone.

From gloriajzhao at gmail.com  Tue May 24 21:05:35 2022
From: gloriajzhao at gmail.com (Gloria Zhao)
Date: Tue, 24 May 2022 14:05:35 -0700
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
 <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
 <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>
Message-ID: <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>

Hi aj,

> If you've got (A,B,C,X) where B spends A and X spends A,B,C where X+C is
below fee floor while A+B and A+B+C+X are above fee floor you have the
problem though.

To clarify, in this situation, I'm imagining something like
A: 0 sat, 100vB
B: 1500 sat, 100vB
C: 0 sat, 100vB
X: 500 sat, 100vB
feerate floor is 3sat/vB

With the algo:
>  * is X alone above my fee rate? no, then forget it
>  * otherwise, s := X.size, f := X.fees, R := [X]
>  * for P = P1..Pn:
>   * do I already have P? then skip to the next parent
>   * s += P.size, f += P.fees, R += [P]
>  * if f/s above my fee rate floor? if so, request all the txs in R

We'd erroneously ask for A+B+C+X, but really we should only take A+B.
But wouldn't A+B also be a package that was announced for B?
Please lmk if you were imagining something different. I think I may be
missing something.

> Is it plausible to add the graph in?

Fun to think about. Most basic design would be to represent {spends,
doesn?t spend} for a previous transaction in the package as a bit. Can
think of it as a matrix where row i, column j tells you whether Tx j
(directly) spends Tx i.
But of course you can omit the last row, since the child spends all of
them. And since topological ordering is a requirement, you only need as
many bits as there are transactions preceding this one in the package.
If you have up to 24 parents, you need 1 + 2 + ... + 23 bits to codify
spending for the 2nd ... 24th parent. For a maximum 25 transactions,
23*24/2 = 276, seems like 36 bytes for a child-with-parents package. A few
more for tx-with-ancestors.
Then you can split it up into sub-packages and everything. Still not sure
if we really need to.

Also side note, since there are no size/count params, wondering if we
should just have "version" in "sendpackages" be a bit field instead of
sending a message for each version. 32 versions should be enough right?

Best,
Gloria

On Tue, 24 May 2022 at 12:48 Anthony Towns <aj at erisian.com.au> wrote:

> On 23 May 2022 9:13:43 pm GMT-04:00, Gloria Zhao <gloriajzhao at gmail.com>
> wrote:
> >> If you're asking for the package for "D", would a response telling you:
> >>   txid_D (500 sat, 100vB)
> >>   txid_A (0 sat, 100vB)
> >>   txid_B (2000 sat, 100 vB)
> >> be better, in that case? Then the receiver can maybe do the logic
> >> themselves to figure out that they already have A in their mempool
> >> so it's fine, or not?
> >Right, I also considered giving the fees and sizes of each transaction in
> >the package in ?pckginfo1?. But I don?t think that information provides
> >additional meaning unless you know the exact topology, i.e. also know if
> >the parents have dependency relationships between them. For instance, in
> >the {A, B, D} package there, even if you have the information listed, your
> >decision should be different depending on whether B spends from A.
>
> I don't think that's true? We already know D is above our fee floor so if
> B with A is also above the floor, we want them all, but also if B isn't
> above the floor, but all of them combined are, then we also do?
>
> If you've got (A,B,C,X) where B spends A and X spends A,B,C where X+C is
> below fee floor while A+B and A+B+C+X are above fee floor you have the
> problem though.
>
> Is it plausible to add the graph in?
>
> Cheers,
> aj
>
>
>
> --
> Sent from my phone.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220524/056c9996/attachment-0001.html>

From eric at voskuil.org  Tue May 24 23:43:57 2022
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 24 May 2022 16:43:57 -0700
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
References: <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
Message-ID: <42B47B8A-947C-4B61-928C-F9F0CA684FDA@voskuil.org>

The set of txs is the graph. Anything else would just reproduce the tx graph which must be traversed in any case.

Similarly the set of txs is the fee, the sigops, the size, and the weight. The only information required by packaging is the association of the txs with each other for the purpose of aggregate (vs. individual) net reward consideration.

Since a package can only be reasonably considered for a single block, there is a natural effective limit on acceptable package size. Since any number of individual txs may be transmitted, and the size/weight/sigops of one tx is bounded only by block validity, there is no reason to put any other constraints on packages. A package is just a set of txs that may fit into a block and may collectively be worth mining. A rational package is just a block or compact block without the header. Making it any more than that is unnecessary complexity.

If parts of a package satisfy profitability constraints, they will be accepted/mined and if other parts do not, they will be rejected. There?s no preventing this.

The only pertinent feature missing in the p2p protocol is the ability to associate a set of txs for consideration, where the set (or subset) may satisfy profitability constraints that would not be satisfied if the txs were considered individually.

e

> On May 24, 2022, at 16:21, Gloria Zhao via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?
> Hi aj,
> 
> > If you've got (A,B,C,X) where B spends A and X spends A,B,C where X+C is below fee floor while A+B and A+B+C+X are above fee floor you have the problem though.
> 
> To clarify, in this situation, I'm imagining something like
> A: 0 sat, 100vB
> B: 1500 sat, 100vB
> C: 0 sat, 100vB
> X: 500 sat, 100vB
> feerate floor is 3sat/vB
> 
> With the algo:
> >  * is X alone above my fee rate? no, then forget it
> >  * otherwise, s := X.size, f := X.fees, R := [X]
> >  * for P = P1..Pn:
> >   * do I already have P? then skip to the next parent
> >   * s += P.size, f += P.fees, R += [P]
> >  * if f/s above my fee rate floor? if so, request all the txs in R
> 
> We'd erroneously ask for A+B+C+X, but really we should only take A+B.
> But wouldn't A+B also be a package that was announced for B?
> Please lmk if you were imagining something different. I think I may be missing something.
> 
> > Is it plausible to add the graph in?
> 
> Fun to think about. Most basic design would be to represent {spends, doesn?t spend} for a previous transaction in the package as a bit. Can think of it as a matrix where row i, column j tells you whether Tx j (directly) spends Tx i.
> But of course you can omit the last row, since the child spends all of them. And since topological ordering is a requirement, you only need as many bits as there are transactions preceding this one in the package.
> If you have up to 24 parents, you need 1 + 2 + ... + 23 bits to codify spending for the 2nd ... 24th parent. For a maximum 25 transactions, 23*24/2 = 276, seems like 36 bytes for a child-with-parents package. A few more for tx-with-ancestors.
> Then you can split it up into sub-packages and everything. Still not sure if we really need to.
> 
> Also side note, since there are no size/count params, wondering if we should just have "version" in "sendpackages" be a bit field instead of sending a message for each version. 32 versions should be enough right?
> 
> Best,
> Gloria
> 
>> On Tue, 24 May 2022 at 12:48 Anthony Towns <aj at erisian.com.au> wrote:
>> On 23 May 2022 9:13:43 pm GMT-04:00, Gloria Zhao <gloriajzhao at gmail.com> wrote:
>> >> If you're asking for the package for "D", would a response telling you:
>> >>   txid_D (500 sat, 100vB)
>> >>   txid_A (0 sat, 100vB)
>> >>   txid_B (2000 sat, 100 vB)
>> >> be better, in that case? Then the receiver can maybe do the logic
>> >> themselves to figure out that they already have A in their mempool
>> >> so it's fine, or not?
>> >Right, I also considered giving the fees and sizes of each transaction in
>> >the package in ?pckginfo1?. But I don?t think that information provides
>> >additional meaning unless you know the exact topology, i.e. also know if
>> >the parents have dependency relationships between them. For instance, in
>> >the {A, B, D} package there, even if you have the information listed, your
>> >decision should be different depending on whether B spends from A.
>> 
>> I don't think that's true? We already know D is above our fee floor so if B with A is also above the floor, we want them all, but also if B isn't above the floor, but all of them combined are, then we also do?
>> 
>> If you've got (A,B,C,X) where B spends A and X spends A,B,C where X+C is below fee floor while A+B and A+B+C+X are above fee floor you have the problem though.
>> 
>> Is it plausible to add the graph in?
>> 
>> Cheers,
>> aj
>> 
>> 
>> 
>> -- 
>> Sent from my phone.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220524/0e92938d/attachment.html>

From erik at q32.com  Wed May 25 13:13:05 2022
From: erik at q32.com (Erik Aronesty)
Date: Wed, 25 May 2022 09:13:05 -0400
Subject: [bitcoin-dev]
	=?utf-8?q?Silent_Payments_=E2=80=93_Non-interactive?=
	=?utf-8?q?_private_payments_with_no_on-chain_overhead?=
In-Reply-To: <p5vlwEtPHiiul4GbOK8j3x32FKrnNC9aba_5Q_MJnNVA9I6vvc3BrfQlbvUmBKJELMvORUk6JK68_rQMwsDpat4wHCkZZst79RJPIvyDPzI=@protonmail.com>
References: <yAzuw9BsMPNXQIeZG98n6d0-6C1ymv9ZCfKIV9ZZYc97wuVbsjkKF1pqS9Uc4ZTuGyh2nKNeRiDYPuklq64Y4UYQ4ITfnvvQo7vsSChvUMs=@protonmail.com>
 <p5vlwEtPHiiul4GbOK8j3x32FKrnNC9aba_5Q_MJnNVA9I6vvc3BrfQlbvUmBKJELMvORUk6JK68_rQMwsDpat4wHCkZZst79RJPIvyDPzI=@protonmail.com>
Message-ID: <CAJowKgJmBfa9Vtq25rZKbf4jt_Rev80sakAMpxMKAiX_Q-Xfig@mail.gmail.com>

i like the  00 || X_spend || X_scan + mandate address reuse prevention.

might as well start with something strict

easy to loosen it later - if needed - harder to tighten it later because of
back-compatibility with addresses in-use


On Tue, May 24, 2022 at 11:02 AM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi woltx,
>
> Thanks for implementing silent payments in Bitcoin Core. I tried the steps
> shared in tutorial and everything works as expected.
>
> I have updated the silent payment address (signet) as TXT record for
> domain alice.silentbitco.in
>
> $ dig -t txt alice.silentbitco.in +short
> "tb1px3kma8e8y8z9l7e640v0x2chzrzww9cu06mqvwyrz805ffletu3s067sgh"
>
> I have also added basic information about silent payments proposal,
> implementation and tutorial on https://silentbitco.in
>
> I had no issues with performance of the UTXO Set and the blocks scan. I
> don't mind using flag but a new address/descriptor format should be a
> better approach. I could not review the code in detail or test edge cases
> however these suggestions by Pavol Rusnak make sense:
> https://gist.github.com/RubenSomsen/c43b79517e7cb701ebf77eec6dbb46b8?permalink_comment_id=4177027#gistcomment-4177027
>
>
> /dev/fd0
>
> Sent with ProtonMail <https://protonmail.com/> secure email.
>
> ------- Original Message -------
> On Tuesday, May 24th, 2022 at 7:01 AM, woltx via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> I created a short and simple tutorial on how to make silent payments on
> signet.
> https://gist.github.com/w0xlt/72390ded95dd797594f80baba5d2e6ee
>
> In this tutorial, the user will generate an address, publish it, receive
> and spend coins from it and still no transactions are shown from this
> address in a blockchain explorer.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220525/a6d14e05/attachment.html>

From aj at erisian.com.au  Wed May 25 18:55:35 2022
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 25 May 2022 14:55:35 -0400
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
 <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
 <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>
 <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
Message-ID: <8FFE048D-854F-4D34-85DA-CE523C16EEB0@erisian.com.au>

On 24 May 2022 5:05:35 pm GMT-04:00, Gloria Zhao via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>To clarify, in this situation, I'm imagining something like
>A: 0 sat, 100vB
>B: 1500 sat, 100vB
>C: 0 sat, 100vB
>X: 500 sat, 100vB
>feerate floor is 3sat/vB
>
>With the algo:
>>  * is X alone above my fee rate? no, then forget it
>>  * otherwise, s := X.size, f := X.fees, R := [X]
>>  * for P = P1..Pn:
>>   * do I already have P? then skip to the next parent
>>   * s += P.size, f += P.fees, R += [P]
>>  * if f/s above my fee rate floor? if so, request all the txs in R
>
>We'd erroneously ask for A+B+C+X, but really we should only take A+B.
>But wouldn't A+B also be a package that was announced for B?

In theory, yes, but maybe it was announced earlier (while our node was down?) or had dropped from our mempool or similar, either way we don't have those txs yet.

>Please lmk if you were imagining something different. I think I may be
>missing something.

That's what I was thinking, yes.

So the other thing is what happens if the peer announcing packages to us is dishonest?

They announce pkg X, say X has parents A B C and the fee rate is garbage. But actually X has parent D and the fee rate is excellent. Do we request the package from another peer, or every peer, to double check? Otherwise we're allowing the first peer we ask about a package to censor that tx from us?

I think the fix for that is just to provide the fee and weight when announcing the package rather than only being asked for its info? Then if one peer makes it sound like a good deal you ask for the parent txids from them, dedupe, request, and verify they were honest about the parents.

>> Is it plausible to add the graph in?

Likewise, I think you'd have to have the graph info from many nodes if you're going to make decisions based on it and don't want hostile peers to be able to trick you into ignoring txs.

Other idea: what if you encode the parent txs as a short hash of the wtxid (something like bip152 short ids? perhaps seeded per peer so collisions will be different per peer?) and include that in the inv announcement? Would that work to avoid a round trip almost all of the time, while still giving you enough info to save bw by deduping parents?


> For a maximum 25 transactions,
>23*24/2 = 276, seems like 36 bytes for a child-with-parents package.

If you're doing short ids that's maybe 25*4B=100B already, then the above is up to 36% overhead, I guess. Might be worth thinking more about, but maybe more interesting with ancestors than just parents.

>Also side note, since there are no size/count params, wondering if we
>should just have "version" in "sendpackages" be a bit field instead of
>sending a message for each version. 32 versions should be enough right?

Maybe but a couple of messages per connection doesn't really seem worth arguing about?

Cheers,
aj


-- 
Sent from my phone.

From eric at voskuil.org  Wed May 25 20:52:07 2022
From: eric at voskuil.org (eric at voskuil.org)
Date: Wed, 25 May 2022 13:52:07 -0700
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <8FFE048D-854F-4D34-85DA-CE523C16EEB0@erisian.com.au>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
 <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
 <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>
 <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
 <8FFE048D-854F-4D34-85DA-CE523C16EEB0@erisian.com.au>
Message-ID: <017501d87079$4c08f9c0$e41aed40$@voskuil.org>

> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On
Behalf
> Of Anthony Towns via bitcoin-dev
> Sent: Wednesday, May 25, 2022 11:56 AM

> So the other thing is what happens if the peer announcing packages to us
is
> dishonest?
> 
> They announce pkg X, say X has parents A B C and the fee rate is garbage.
But
> actually X has parent D and the fee rate is excellent. Do we request the
> package from another peer, or every peer, to double check? Otherwise we're
> allowing the first peer we ask about a package to censor that tx from us?
> 
> I think the fix for that is just to provide the fee and weight when
announcing
> the package rather than only being asked for its info? Then if one peer
makes
> it sound like a good deal you ask for the parent txids from them, dedupe,
> request, and verify they were honest about the parents.

Single tx broadcasts do not carry an advertised fee rate, however the'
feefilter' message (BIP133) provides this distinction. This should be
interpreted as applicable to packages. Given this message there is no reason
to send a (potentially bogus) fee rate with every package. It can only be
validated by obtaining the full set of txs, and the only recourse is
dropping (etc.) the peer, as is the case with single txs. Relying on the
existing message is simpler, more consistent, and more efficient.

> >> Is it plausible to add the graph in?
> 
> Likewise, I think you'd have to have the graph info from many nodes if
you're
> going to make decisions based on it and don't want hostile peers to be
able to
> trick you into ignoring txs.
> 
> Other idea: what if you encode the parent txs as a short hash of the wtxid
> (something like bip152 short ids? perhaps seeded per peer so collisions
will
> be different per peer?) and include that in the inv announcement? Would
> that work to avoid a round trip almost all of the time, while still giving
you
> enough info to save bw by deduping parents?

As I suggested earlier, a package is fundamentally a compact block (or
block) announcement without the header. Compact block (BIP152) announcement
is already well-defined and widely implemented. A node should never be
required to retain an orphan, and BIP152 ensures this is not required.

Once a validated set of txs within the package has been obtained with
sufficient fee, a fee-optimal node would accept the largest subgraph of the
package that conforms to fee constraints and drop any peer that provides a
package for which the full graph does not.

Let us not reinvent the wheel and/or introduce accidental complexity. I see
no reason why packaging is not simply BIP152 without the 'header' field, an
updated protocol version, and the following sort of changes to names:

sendpkg
MSG_CMPCT_PKG
cmpctpkg
getpkgtxn
pkgtxn

> > For a maximum 25 transactions,
> >23*24/2 = 276, seems like 36 bytes for a child-with-parents package.
> 
> If you're doing short ids that's maybe 25*4B=100B already, then the above
is
> up to 36% overhead, I guess. Might be worth thinking more about, but maybe
> more interesting with ancestors than just parents.
> 
> >Also side note, since there are no size/count params,

Size is restricted in the same manner as block and transaction broadcasts,
by consensus. If the fee rate is sufficient there would be no reason to
preclude any valid size up to what can be mined in one block (packaging
across blocks is not economically rational under the assumption that one
miner cannot expect to mine multiple blocks in a row). Count is incorporated
into BIP152 as 'shortids_length'.

> > wondering if we
> >should just have "version" in "sendpackages" be a bit field instead of
> >sending a message for each version. 32 versions should be enough right?

Adding versioning to individual protocols is just a reflection of the
insufficiency of the initial protocol versioning design, and that of the
various ad-hoc changes to it (including yet another approach in this
proposal) that have been introduced to compensate for it, though I'll
address this in an independent post at some point.

Best,
e

> Maybe but a couple of messages per connection doesn't really seem worth
> arguing about?
> 
> Cheers,
> aj
> 
> 
> --
> Sent from my phone.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From eric at voskuil.org  Thu May 26 02:59:01 2022
From: eric at voskuil.org (eric at voskuil.org)
Date: Wed, 25 May 2022 19:59:01 -0700
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <017501d87079$4c08f9c0$e41aed40$@voskuil.org>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
 <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
 <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>
 <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
 <8FFE048D-854F-4D34-85DA-CE523C16EEB0@erisian.com.au>
 <017501d87079$4c08f9c0$e41aed40$@voskuil.org>
Message-ID: <001201d870ac$8d7a06a0$a86e13e0$@voskuil.org>

Given that packages have no header, the package requires identity in a
BIP152 scheme. For example 'header' and 'blockhash' fields can be replaced
with a Merkle root (e.g. "identity" field) for the package, uniquely
identifying the partially-ordered set of txs. And use of 'getdata' (to
obtain a package by hash) can be eliminated (not a use case).

e

> -----Original Message-----
> From: eric at voskuil.org <eric at voskuil.org>
> Sent: Wednesday, May 25, 2022 1:52 PM
> To: 'Anthony Towns' <aj at erisian.com.au>; 'Bitcoin Protocol Discussion'
> <bitcoin-dev at lists.linuxfoundation.org>; 'Gloria Zhao'
> <gloriajzhao at gmail.com>
> Subject: RE: [bitcoin-dev] Package Relay Proposal
> 
> > From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On
> Behalf
> > Of Anthony Towns via bitcoin-dev
> > Sent: Wednesday, May 25, 2022 11:56 AM
> 
> > So the other thing is what happens if the peer announcing packages to us
> is
> > dishonest?
> >
> > They announce pkg X, say X has parents A B C and the fee rate is
garbage.
> But
> > actually X has parent D and the fee rate is excellent. Do we request the
> > package from another peer, or every peer, to double check? Otherwise
> we're
> > allowing the first peer we ask about a package to censor that tx from
us?
> >
> > I think the fix for that is just to provide the fee and weight when
> announcing
> > the package rather than only being asked for its info? Then if one peer
> makes
> > it sound like a good deal you ask for the parent txids from them,
dedupe,
> > request, and verify they were honest about the parents.
> 
> Single tx broadcasts do not carry an advertised fee rate, however the'
> feefilter' message (BIP133) provides this distinction. This should be
> interpreted as applicable to packages. Given this message there is no
reason
> to send a (potentially bogus) fee rate with every package. It can only be
> validated by obtaining the full set of txs, and the only recourse is
> dropping (etc.) the peer, as is the case with single txs. Relying on the
> existing message is simpler, more consistent, and more efficient.
> 
> > >> Is it plausible to add the graph in?
> >
> > Likewise, I think you'd have to have the graph info from many nodes if
> you're
> > going to make decisions based on it and don't want hostile peers to be
> able to
> > trick you into ignoring txs.
> >
> > Other idea: what if you encode the parent txs as a short hash of the
wtxid
> > (something like bip152 short ids? perhaps seeded per peer so collisions
> will
> > be different per peer?) and include that in the inv announcement? Would
> > that work to avoid a round trip almost all of the time, while still
giving
> you
> > enough info to save bw by deduping parents?
> 
> As I suggested earlier, a package is fundamentally a compact block (or
> block) announcement without the header. Compact block (BIP152)
> announcement
> is already well-defined and widely implemented. A node should never be
> required to retain an orphan, and BIP152 ensures this is not required.
> 
> Once a validated set of txs within the package has been obtained with
> sufficient fee, a fee-optimal node would accept the largest subgraph of
the
> package that conforms to fee constraints and drop any peer that provides a
> package for which the full graph does not.
> 
> Let us not reinvent the wheel and/or introduce accidental complexity. I
see
> no reason why packaging is not simply BIP152 without the 'header' field,
an
> updated protocol version, and the following sort of changes to names:
> 
> sendpkg
> MSG_CMPCT_PKG
> cmpctpkg
> getpkgtxn
> pkgtxn
> 
> > > For a maximum 25 transactions,
> > >23*24/2 = 276, seems like 36 bytes for a child-with-parents package.
> >
> > If you're doing short ids that's maybe 25*4B=100B already, then the
above
> is
> > up to 36% overhead, I guess. Might be worth thinking more about, but
> maybe
> > more interesting with ancestors than just parents.
> >
> > >Also side note, since there are no size/count params,
> 
> Size is restricted in the same manner as block and transaction broadcasts,
> by consensus. If the fee rate is sufficient there would be no reason to
> preclude any valid size up to what can be mined in one block (packaging
> across blocks is not economically rational under the assumption that one
> miner cannot expect to mine multiple blocks in a row). Count is
incorporated
> into BIP152 as 'shortids_length'.
> 
> > > wondering if we
> > >should just have "version" in "sendpackages" be a bit field instead of
> > >sending a message for each version. 32 versions should be enough right?
> 
> Adding versioning to individual protocols is just a reflection of the
> insufficiency of the initial protocol versioning design, and that of the
> various ad-hoc changes to it (including yet another approach in this
> proposal) that have been introduced to compensate for it, though I'll
> address this in an independent post at some point.
> 
> Best,
> e
> 
> > Maybe but a couple of messages per connection doesn't really seem worth
> > arguing about?
> >
> > Cheers,
> > aj
> >
> >
> > --
> > Sent from my phone.
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jonasdnick at gmail.com  Thu May 26 15:32:33 2022
From: jonasdnick at gmail.com (Jonas Nick)
Date: Thu, 26 May 2022 15:32:33 +0000
Subject: [bitcoin-dev] MuSig2 BIP
In-Reply-To: <XRFIZf_z1dKNoKvgFJmrgThHcIE_B0JW9mmJL7mE2B2afcgwZn7NuJaK_vXUAvVwWSZ2Nijwz9yhiwYpty6iI3mrJyivdLxL_CtWlEaAhMY=@protonmail.com>
References: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
 <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>
 <c2a9b488-8d29-d1c6-b2c3-bc17d12b7d65@gmail.com>
 <HPRdBVSvEmkPyHkS-175ZYEYyL-ULZAgmhSPh3uwVtfryFOKZUFKUM5QXnSXjwZy3b10sV55f9lhOkZ-ILShaWSWJ7GMN0JmKNweKY6kfLg=@protonmail.com>
 <XRFIZf_z1dKNoKvgFJmrgThHcIE_B0JW9mmJL7mE2B2afcgwZn7NuJaK_vXUAvVwWSZ2Nijwz9yhiwYpty6iI3mrJyivdLxL_CtWlEaAhMY=@protonmail.com>
Message-ID: <7c4395b0-9bc9-78e6-5a46-dc3eddb8e97f@gmail.com>

Thanks for the detailed feedback. Let me try to summarize your argument: Key
aggregation should fail if there are duplicate keys because this is likely a bug
and continuing might be dangerous. If it is not a bug but a dishonest signer
trying to disrupt, then resuming the protocol and trying to identify the
dishonest signer does not work because partial signatures are not real
signatures.

I disagree that identifying dishonest signers is useless. But if I try hard, I
can see your point that honest signers should not continue in order to protect
terribly broken implementations. Broken could mean that signers reuse nonces,
output their secret key instead of a partial signature, etc. However, terribly
broken implementations are terribly broken. It seems very unlikely that they're
nice enough to truthfully indicate their brokenness by copying someone elses
public key. Perhaps they use the sum of every other key, actually create a
proper public key, or do something entirely different. So I think in practice,
it is implausible to find a single instance of an implementation that doesn't
survive partial signature creation by looking at duplicate public keys.

However, your suggestion to abort in KeyAgg when encountering duplicate public
keys is compatible with the MuSig2 BIP draft. No one can force a signer to
accept an arbitrary set of public keys for the multi-signature, so signers are
always fine to abort at the key aggregation stage to try to protect terribly
broken co-signers. In that sense, the BIP draft takes a more general and
flexible approach. I doubt that identifying duplicate public keys is less
complex. The only consequence of allowing duplicate public keys is that the
`GetSecondKey` is required to loop over the public keys. Aborting when
encountering duplicate public keys also has the added complexity of giving users
the unspecific instruction to "debug signers X and Y" versus "there's something
definitely wrong with signer Z".

As mentioned above, I don't follow your argument that identifying signers
claiming the public key of other signers is useless. I do think the "persistent"
case is interesting. It's easy to imagine persistent identities not tied to
secp256k1 curve points. Only for creating BIP-340 multi-signatures do they use
secp256k1 public keys. These keys can be fresh, or if they are persistent, the
participants may want to rotate them from time to time. So there are plenty of
opportunities for an attacker to overtake a participant and try to disrupt the
protocol. You mention that duplicating keys would require "a Sybil at two
indices", but actually a single malicious signer that copies some public key is
sufficient.

Your analysis of the "spontaneous" case misses that partial signature
verification identifies at least one of the dishonest signers and therefore
allows to make progress. This closes the DoS vector as far as the MuSig protocol
is concerned. If there are multiple disruptive signers, they may not all be
identified in a single round but require multiple signing attempts. Of course,
applications that use MuSig and replace disruptive signers with just some other
arbitrary nym may be so unlucky that it always has disruptive signers. But
that's a problem of the application layer, and it's easy to conceive smarter
peer selection.

I agree that the claim "any signer who prevents a signing session from
completing successfully by sending incorrect contributions in the session can be
identified" is incorrect. We can identify at least one, and that means
applications can make progress. I opened a PR to fix the wording [0].

[0] https://github.com/jonasnick/bips/pull/25

From AdamISZ at protonmail.com  Thu May 26 17:34:47 2022
From: AdamISZ at protonmail.com (AdamISZ)
Date: Thu, 26 May 2022 17:34:47 +0000
Subject: [bitcoin-dev] MuSig2 BIP
In-Reply-To: <7c4395b0-9bc9-78e6-5a46-dc3eddb8e97f@gmail.com>
References: <46175970-d2ab-a58e-7010-f29820849604@gmail.com>
 <yitwgERAsaofLM5dheUZUYyFp0ncU8xyN98xTym3MkCxTch83DkweZN5JYyovVcfxA2Mo7DjTbv1Iku3wBApYiPG_cMwznTytKFpcjYa1O0=@protonmail.com>
 <c2a9b488-8d29-d1c6-b2c3-bc17d12b7d65@gmail.com>
 <HPRdBVSvEmkPyHkS-175ZYEYyL-ULZAgmhSPh3uwVtfryFOKZUFKUM5QXnSXjwZy3b10sV55f9lhOkZ-ILShaWSWJ7GMN0JmKNweKY6kfLg=@protonmail.com>
 <XRFIZf_z1dKNoKvgFJmrgThHcIE_B0JW9mmJL7mE2B2afcgwZn7NuJaK_vXUAvVwWSZ2Nijwz9yhiwYpty6iI3mrJyivdLxL_CtWlEaAhMY=@protonmail.com>
 <7c4395b0-9bc9-78e6-5a46-dc3eddb8e97f@gmail.com>
Message-ID: <VUoLgGbJszQbch6ZCnjWri-lV9sJ6PhsS8vUu9vVeaQ8XddMxp3b6HUP5hGDu8FfAAgsAb4xPXIoX4mZ-8pPuhXssrD2ysKtENbQ2fcIdMo=@protonmail.com>

Hi Jonas, list,
responses inline




Sent with Proton Mail secure email.
------- Original Message -------
On Thursday, May 26th, 2022 at 10:32, Jonas Nick via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> Thanks for the detailed feedback. Let me try to summarize your argument: Key
> aggregation should fail if there are duplicate keys because this is likely a bug
> and continuing might be dangerous. If it is not a bug but a dishonest signer
> trying to disrupt, then resuming the protocol and trying to identify the
> dishonest signer does not work because partial signatures are not real
> signatures.
>
> I disagree that identifying dishonest signers is useless.

Oh but that wasn't the claim - that it's useless. I'd characterize it more like: the benefit of identifying one disruptor index is less than claimed (but PR now to fix that), and in certain (see 'spontaneous' case) does not allow a guarantee of progress (but see below .. you have convinced me that this is kind of a false conclusion to draw). That combined with the risk potential from implementation errors weighted my opinion in favour of the abort early option.


> It seems very unlikely that they're
> nice enough to truthfully indicate their brokenness by copying someone elses
> public key.

I don't really buy that. My thinking was, there are of course an infinite number of ways an implementation can be broken, but this is not a vanishingly unlikely case, especially when you consider how often there might be ex-protocol cooperative interactions between signers. The obvious case that crops up is when one agent actually stands behind multiple different signing keys; in that scenario it's not that unlikely, and if that agent is co-signing with *other* agents something very bad might happen.


>
> However, your suggestion to abort in KeyAgg when encountering duplicate public
> keys is compatible with the MuSig2 BIP draft. No one can force a signer to
> accept an arbitrary set of public keys for the multi-signature, so signers are
> always fine to abort at the key aggregation stage to try to protect terribly
> broken co-signers. In that sense, the BIP draft takes a more general and
> flexible approach.

That's a very fair point, and good to mention. The BIP strongly justifies no abort early, though.

 I doubt that identifying duplicate public keys is less
> complex. The only consequence of allowing duplicate public keys is that the
> `GetSecondKey` is required to loop over the public keys. Aborting when
> encountering duplicate public keys also has the added complexity of giving users
> the unspecific instruction to "debug signers X and Y" versus "there's something
> definitely wrong with signer Z".

Yeah, this is the 'we can identify the disruptor' point which has been discussed in the previous mail and below, re: spontaneous. It's true except when it, partially, isn't :)

>
> As mentioned above, I don't follow your argument that identifying signers
> claiming the public key of other signers is useless. I do think the "persistent"
> case is interesting. It's easy to imagine persistent identities not tied to
> secp256k1 curve points. Only for creating BIP-340 multi-signatures do they use
> secp256k1 public keys. These keys can be fresh, or if they are persistent, the
> participants may want to rotate them from time to time. So there are plenty of
> opportunities for an attacker to overtake a participant and try to disrupt the
> protocol. You mention that duplicating keys would require "a Sybil at two
> indices", but actually a single malicious signer that copies some public key is
> sufficient.
>
> Your analysis of the "spontaneous" case misses that partial signature
> verification identifies at least one of the dishonest signers and therefore
> allows to make progress. This closes the DoS vector as far as the MuSig protocol
> is concerned.

Well but I didn't miss that point, I addressed it in the section "Why does the DOS vector remain?".
I see that where we've diverged here is only that you consider the case 'the same adversary keeps joining the group' to be out of scope as something that higher level protocols would have to address.

On reflection I guess I agree: such a protocol needs to address this point, regardless of the quirk of repeated keys, and regardless of forged partial sigs; if participant 5 is a disruptor and you replace him with another, you have to have a mechanism to handle that it might be the same guy, and it's outside the scope of this doc. The fact that the disruptor may still stay at another index modulates that argument a little bit, but doesn't invalidate it, I believe.

So from that perspective, my point here was more a 'quibble' than an actual critique: because the document kind of implies that you can do a bit more than you can, and didn't let the reader know that such an attacker, in this specific case, might 'still be around' in some sense, as you agree below:

>
> I agree that the claim "any signer who prevents a signing session from
> completing successfully by sending incorrect contributions in the session can be
> identified" is incorrect. We can identify at least one, and that means
> applications can make progress. I opened a PR to fix the wording [0].
>
> [0] https://github.com/jonasnick/bips/pull/25

Right, thanks, will follow up.

Honestly, as an implementor, I would still abort early *in most usage scenarios* ... So many more coins were lost to screw ups in implementations than super genius attackers.

Cheers,
waxwing/AdamISZ


From gloriajzhao at gmail.com  Sat May 28 01:54:13 2022
From: gloriajzhao at gmail.com (Gloria Zhao)
Date: Fri, 27 May 2022 18:54:13 -0700
Subject: [bitcoin-dev] Package Relay Proposal
In-Reply-To: <8FFE048D-854F-4D34-85DA-CE523C16EEB0@erisian.com.au>
References: <CAFXO6=JROe_9ih2h+_CCH-UbxehsM5RQ6YyNnPesEpveBEtdow@mail.gmail.com>
 <20220518003531.GA4402@erisian.com.au>
 <CAFXO6=LWM4eHM=zJhejw5981+8h7QHTbwpz0jEbWkrLOX0037Q@mail.gmail.com>
 <20220523213416.GA6151@erisian.com.au>
 <CAFXO6=KXToP2MFWQ1JVKX6jV++utw8E4Z13T4cH+mfgtyeUx_A@mail.gmail.com>
 <2B3D1901-901C-4000-A2B9-F6857FCE2847@erisian.com.au>
 <CAFXO6=K6FXNFwOZ3VyT6_RZY2F2BX+iTy+MyOshRBfNnn9Hqyg@mail.gmail.com>
 <8FFE048D-854F-4D34-85DA-CE523C16EEB0@erisian.com.au>
Message-ID: <CAFXO6=LJqbXCy_fWSf9OCKYRAOz_WwanLNbZR4+hs0yOE4Xpgg@mail.gmail.com>

Hi aj, answering slightly out of order:

> what happens if the peer announcing packages to us is dishonest?
> They announce pkg X, say X has parents A B C and the fee rate is garbage.
But actually X has parent D and the fee rate is excellent. Do we request
the package from another peer, or every peer, to double check? Otherwise
we're allowing the first peer we ask about a package to censor that tx from
us?

Yes, providing false information shouldn't be worse than not announcing the
package at all, otherwise we have a censorship vector. In general, the
request logic should not let one peer prevent us from requesting a similar
announcement from another peer.
Yes I was indeed expecting that we would ask for package info from everyone
who announces it until it accepts the package or has full information.
I can see that it's a fair bit of messages (request pckginfo, oh it's low
fee, request pckginfo from somebody else), but we also need to track
announcements / potentially go through the same circle to handle
"notfound"s, right?
In normal running, the fee filter should stop a bunch of honest nodes from
telling us packages that are low fee.

> I think the fix for that is just to provide the fee and weight when
announcing the package rather than only being asked for its info? Then if
one peer makes it sound like a good deal you ask for the parent txids from
them, dedupe, request, and verify they were honest about the parents.
> Likewise, I think you'd have to have the graph info from many nodes if
you're going to make decisions based on it and don't want hostile peers to
be able to trick you into ignoring txs.

I don't think providing more information up front can ever sufficiently
resolve the censorship issue. If we want to prevent any one peer from being
able to censor requests to other peers, we need to store all announcements
and be prepared to request from everybody.

Would it be better if we just took out the fee information and had
"pckginfo" only consist of transaction ids? Sender tries its best to apply
the fee filter? Presumably you have a txInventoryKnown of your peer based
on what they've announced to you... just take the ancestor set of a
transaction, subtract what they already have, and apply the fee filter to
that? Or some kind of algorithm that ensures we don't underestimate? If
it's imperfect, the worst case is the receiver downloads a few transactions
and rejects them. Given that our goal is just to avoid this case, perhaps
opting for simplicity is better than adding a topology graph
serialization/deserialization + feerate assessment algorithm on top of this
protocol...?

>>We'd erroneously ask for A+B+C+X, but really we should only take A+B.
>>But wouldn't A+B also be a package that was announced for B?

> In theory, yes, but maybe it was announced earlier (while our node was
down?) or had dropped from our mempool or similar, either way we don't have
those txs yet.

Hm. It's fine if they have Erlay, since a sender would know in advance that
B is missing and announce it as a package. A potential tack-on solution
would be to request package information whenever you have a "low fee" error
on a parent and "missing inputs" on a child. Or we solve it at the
validation level - instead of submitting each tx individually, we submit
each ancestor subset. Do you think any of these is sufficient? At least the
package properly propagates across nodes which are online when it is
broadcasted...

Best,
Gloria

On Wed, May 25, 2022 at 11:55 AM Anthony Towns <aj at erisian.com.au> wrote:

> On 24 May 2022 5:05:35 pm GMT-04:00, Gloria Zhao via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >To clarify, in this situation, I'm imagining something like
> >A: 0 sat, 100vB
> >B: 1500 sat, 100vB
> >C: 0 sat, 100vB
> >X: 500 sat, 100vB
> >feerate floor is 3sat/vB
> >
> >With the algo:
> >>  * is X alone above my fee rate? no, then forget it
> >>  * otherwise, s := X.size, f := X.fees, R := [X]
> >>  * for P = P1..Pn:
> >>   * do I already have P? then skip to the next parent
> >>   * s += P.size, f += P.fees, R += [P]
> >>  * if f/s above my fee rate floor? if so, request all the txs in R
> >
> >We'd erroneously ask for A+B+C+X, but really we should only take A+B.
> >But wouldn't A+B also be a package that was announced for B?
>
> In theory, yes, but maybe it was announced earlier (while our node was
> down?) or had dropped from our mempool or similar, either way we don't have
> those txs yet.
>
> >Please lmk if you were imagining something different. I think I may be
> >missing something.
>
> That's what I was thinking, yes.
>
> So the other thing is what happens if the peer announcing packages to us
> is dishonest?
>
> They announce pkg X, say X has parents A B C and the fee rate is garbage.
> But actually X has parent D and the fee rate is excellent. Do we request
> the package from another peer, or every peer, to double check? Otherwise
> we're allowing the first peer we ask about a package to censor that tx from
> us?
>
> I think the fix for that is just to provide the fee and weight when
> announcing the package rather than only being asked for its info? Then if
> one peer makes it sound like a good deal you ask for the parent txids from
> them, dedupe, request, and verify they were honest about the parents.
>
> >> Is it plausible to add the graph in?
>
> Likewise, I think you'd have to have the graph info from many nodes if
> you're going to make decisions based on it and don't want hostile peers to
> be able to trick you into ignoring txs.
>
> Other idea: what if you encode the parent txs as a short hash of the wtxid
> (something like bip152 short ids? perhaps seeded per peer so collisions
> will be different per peer?) and include that in the inv announcement?
> Would that work to avoid a round trip almost all of the time, while still
> giving you enough info to save bw by deduping parents?
>
>
> > For a maximum 25 transactions,
> >23*24/2 = 276, seems like 36 bytes for a child-with-parents package.
>
> If you're doing short ids that's maybe 25*4B=100B already, then the above
> is up to 36% overhead, I guess. Might be worth thinking more about, but
> maybe more interesting with ancestors than just parents.
>
> >Also side note, since there are no size/count params, wondering if we
> >should just have "version" in "sendpackages" be a bit field instead of
> >sending a message for each version. 32 versions should be enough right?
>
> Maybe but a couple of messages per connection doesn't really seem worth
> arguing about?
>
> Cheers,
> aj
>
>
> --
> Sent from my phone.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220527/262714e4/attachment.html>

From luke at dashjr.org  Mon May 30 13:40:18 2022
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 30 May 2022 13:40:18 +0000
Subject: [bitcoin-dev] Bitcoin Knots 23.0.knots20220529 released
Message-ID: <202205301340.20223.luke@dashjr.org>

Bitcoin Knots version 23.0.knots20220529 is now available from:

  https://bitcoinknots.org/files/23.x/23.0.knots20220529/

This release includes new features, various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  https://github.com/bitcoinknots/bitcoin/issues

To receive security and update notifications, please subscribe to:

  https://bitcoinknots.org/list/announcements/join/

For the full release notes and change log, see:

https://github.com/bitcoinknots/bitcoin/blob/v23.0.knots20220529-release-notes/doc/release-notes.md
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20220530/02496a9a/attachment.sig>

