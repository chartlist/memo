From roconnor at blockstream.io  Sun Dec  1 16:09:54 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sun, 1 Dec 2019 11:09:54 -0500
Subject: [bitcoin-dev] Signing CHECKSIG position in Tapscript
In-Reply-To: <20191128080659.msrpdpcjhhvbqtv2@erisian.com.au>
References: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>
 <20191128080659.msrpdpcjhhvbqtv2@erisian.com.au>
Message-ID: <CAMZUoKmYi6btmhN8NmePPZNpPtXwNp=EpyYrxo7P2Ug7fnPSwQ@mail.gmail.com>

On Thu, Nov 28, 2019 at 3:07 AM Anthony Towns <aj at erisian.com.au> wrote:

> FWIW, there's discussion of this at
> http://www.erisian.com.au/taproot-bip-review/log-2019-11-28.html#l-65
>

I think variants like signing the position of the enclosing
OP_IF/OP_NOTIF/OP_ELSE of the OP_IF/OP_NOTIF/OP_ELSE block that the
checksig is within, or signing the byte offset instead of the opcode number
offset are all fine.  In particular, signing the enclosing OP_IF... would
allow sharing of the hashed signed data in a normal multisig sequence of
operations.  Below I'll continue to refer to my proposal as signing the
CHECKSIG position, but please take it to mean any of these proposed,
semantically equivalent, realizations of this idea.

I also think that it is quite reasonable to have a sighash flag control
whether or not the signature covers the CHECKSIG position or not, with
SIGHASH_ALL including the CHECKSIG position.


> First, it seems like a bad idea for Alice to have put funds behind a
> script she doesn't understand in the first place. There's plenty of
> scripts that are analysable, so just not using ones that are too hard to
> analyse sure seems like an option.
>

I don't think this is true in general.  When constructing a script it seems
quite reasonable for one party to come to the table with their own custom
script that they want to use because they have some sort of 7-of-11 scheme
but in one of those cases is really a 2-of-3 and another is 5-of-6.  The
point is that you shouldn't need to decode their exact policy in order to
collaborate with them.  This notion is captured quite clearly in the MAST
aspect of taproot.  In many circumstances, it is sufficient for you to know
that there exists a branch that contains a particular script without need
to know what every branch contains.  Because we include the tapleaf in the
signature, we already prevent this signature copying attack against
attempts to transplant one's signature from one tapleaf to another.  My
proposal is to simply extend this same protection to branches within a
single tapscript.

Second, if there are many branches in the script, it's probably more
> efficient to do them via different branches in the merkle tree, which
> at least for this purpose would make them easier to analyse as well
> (since you can analyse them independently).
>

Of course this should be done when practical.  This point isn't under
dispute.


> Third, if you are doing something crazy complex where a particular key
> could appear in different CHECKSIG operators and they should have
> independent signatures, that seems like you're at the level of
> complexity where learning about CODESEPARATOR is a reasonable thing to
> do.
>

So while I agree that learning about CODESEPARATOR is a reasonable thing to
do, given that I haven't heard the CODESEPARATOR being proposed as
protection against this sort of signature-copying attack before and given
the subtle nature of the issue, I'm not sure people will know to use it to
protect themselves.  We should aim for a Script design that makes the
cheaper default Script programming choices the safer one.

On the other hand, in a previous thread a while ago I was also arguing that
sophisticated people are plausibly using CODESEPARATOR today, hidden away
in unredeemed P2SH UTXOs.  So perhaps I'm right about at least one of these
two points. :)

I think CODESEPARATOR is a better solution to this problem anyway. In
> particular, consider a "leaf path root OP_MERKLEPATHVERIFY" opcode,
> and a script that says "anyone in group A can spend if the preimage for
> X is revelaed, anyone in group B can spend unconditionally":
>
>  IF HASH160 x EQUALVERIFY groupa ELSE groupb ENDIF
>  MERKLEPATHVERIFY CHECKSIG
>
> spendable by
>
>  siga keya path preimagex 1
>
> or
>
>  sigb keyb path 0
>
> With your proposed semantics, if my pubkey is in both groups, my signature
> will sign for position 10, and still be valid on either path, even if
> the signature commits to the CHECKSIG position.
>
> I could fix my script either by having two CHECKSIG opcodes (one for
> each branch) and also duplicating the MERKLEPATHVERIFY; or I could
> add a CODESEPARATOR in either IF branch.
>

> (Or I could just not reuse the exact same pubkey across groups; or I could
> have two separate scripts: "HASH160 x EQUALVERIFY groupa MERKLEPATHVERIFY
> CHECKSIG" and "groupb MERKLEPATHVERIFY CHECKSIG")
>

I admit my proposal doesn't automatically prevent this signature-copying
attack against every Script template.  To be fully effective you need to be
aware of this signature-copying attack vector to ensure your scripts are
designed so that your CHECKSIG operations are protected by being within the
IF block that does the verification of the hash-preimage.  My thinking is
that my proposal is effective enough to save most people most of the time,
even if it doesn't save everyone all the time, all while having no
significant burden otherwise.  Therefore, I don't think your point that
there still exists a Script where a signature copying attack can be
performed is adequate by itself to dismiss my proposal.  However if you
believe that if we don't save everyone all the time then there is no point
in trying, or if you believe that signing the CHECKSIG position probably
will not protect most users most of the time, or if you believe the burden
on all the other cases is too great, then maybe it is better to rely on
people using CODESEPARATOR.

Given that MAST design of taproot greatly reduces this problem compared to
legacy script, I suppose you could argue that "the burden on all the other
cases is too great" simply because you believe the problematic situation is
now extremely rare.

I still think we ought to choose designs that are safer by default and
include as much user intention within the signed data as we can reasonably
get away, and use other sighash flags for those cases when we need to
exclude data from the signature.

In particular, imagine a world where CODESEPARATOR never existed.  We have
this signature copying attack to deal with, and we are designing a new
Segwit version in which we can now address the problem.  One proposal that
someone comes up with is to sign the CHECKSIG position (or sign the
enclosing OP_IF/OP_ELSE... position), maybe using a SIGHASH flag to
optionally disable it.  Someone else comes up with a proposal to add new
"CODESEPARATOR" opcode which requires adding a new piece of state to the
Script interpreter (the only non-stack based piece of state) to track the
last executed CODESEPARATOR position and include that in the signature.
Would you really prefer the CODESEPARATOR proposal?


> > I believe that it would be safer, and less surprising to users, to
> always sign
> > the CHECKSIG position by default.
>
> > As a side benefit, we get to eliminate CODESEPARATOR, removing a fairly
> awkward
> > opcode from this script version.
>
> As it stands, ANYPREVOUTANYSCRIPT proposes to not sign the script code
> (allowing the signature to be reused in different scripts) but does
> continue signing the CODESEPARATOR position, allowing you to optionally
> restrict how flexibly you can reuse signatures. That seems like a better
> tradeoff than having ANYPREVOUTANYSCRIPT signatures commit to the CHECKSIG
> position which would make it a fair bit harder to design scripts that
> can share signatures, or not having any way to restrict which scripts
> the signature could apply to other than changing the pubkey.
>

Um, I believe that signing the CODESEPERATOR position without signing the
script code is nonsensical.  You are talking about signing a piece of data
without an interpretation of its meaning.

Recall that originally CODESEPARTOR would let you sign a suffix of the
Script program.  In the context of signing the whole script (which is
always signed indirectly as part of the txid in legacy signatures) signing
the offset into that scripts contains just as much information as signing a
script suffix, while being constant sized.  When you remove the Script from
the data being signed, signing an offset is no longer equivalent to signing
a Script suffix, and an offset into an unknown data structure is a
meaningless value by itself.  There is no way that you should be signing
CODESEPARATOR position without also covering the Script with the signature.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191201/75cc9af7/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Dec  2 02:05:01 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 02 Dec 2019 02:05:01 +0000
Subject: [bitcoin-dev] Composable MuSig
In-Reply-To: <CAH5Bsr2rsiU9gV6VsGH3ZCWGRoTz=g5hXNq37P3P6HB+MmxUAA@mail.gmail.com>
References: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>
 <CAH5Bsr2rsiU9gV6VsGH3ZCWGRoTz=g5hXNq37P3P6HB+MmxUAA@mail.gmail.com>
Message-ID: <tvK5ZI4GmQzBkGfcYFOaUI4kgLBv7N615LV-yvyUOeYU49Ig2krXbyPOrTSwiiYNZpPYNv6GtLrSRTQf_MRwqmYeXY1VTLzinq93wNW9ex8=@protonmail.com>

Good morning Lloyd, and list,

> Just a quick note: I think there is a way to commit to a point properly with Pedersen commitments. Consider the following:
> COM(X) = (y*G + z*H, y*G?+ X)? where y and z are random and the opening is (y,z,X).? This seems to be a? unconditionally hiding and computationally binding homomorphic commitment scheme to a point based on the DL problem rather than DDH.

So the Pedersen commitment commits to a tweak on `X`, which is revealed later so we can un-tweak `X`.
Am I correct in assuming that you propose to use `X` for the contribution to `R` for a participant?
How is it different from using ElGamal commitments?


-------


Some number of people have noted, including at least one MuSig author, that in the ElGamal case it would be possible to prove your knowledge of the `q` behind `q * G`, and thus prevent the cancellation attack shown.
We already have a general proof-of-knowledge-of-secret-key, the Schnorr signature signing algorithm itself.

Thus, together with `q * G` in the ElGamal commitment, we could include a Schnorr signature using `q * G`, either of the target message itself, or any constant string.

This seems highly appropriate, yo dawg, I heard you like MuSig, so I put an aggregate in your aggregate, so you could sign (singly) while you sign (multiply).

In terms of a *composable* MuSig, e.g. MuSig(MuSig(A, B), C), both A and B will select `q[a]` and `q[b]` and will generate a shared `q[ab] * G` as the MuSig of `q[a] * G` and `q[b] * G`.
Since they know the corresponding `q[a]` and `q[b]` they will also known the contributions they each will need to generate `q[ab] * H`, but note that there is no proof of this until they reveal `q[a]` and `q[b]`, which may lead to further attacks, this time on `q[ab] * H` instead.
So at least for `q` it seems not to be a good idea, though I have not put much thought into this.

Indeed, it seems to me that signatures using the contributions `R[a]` and `R[b]` as public keys seems to be another way to commit to `R` while ensuring that your own `R` cannot have cancelled the other participant `R`.
You would have to exchange the (single) signatures of `R[a]` and `R[b]` first, however, otherwise a Wagner attack may be possible if you exchange `R[a]` and `R[b]` first (i.e. the signatures replace the `R` commitment phase of 3-phase MuSig).

The complexity of either sign-while-you-sign idea, however, is much greater.
Your signing algorithm now requires delegating to another signing algorithm, which while at least fair in that you are now signing while you sign because you aggregated while you aggregated, is more complicated to implement practically.



Regards,
ZmnSCPxj

From lloyd.fourn at gmail.com  Mon Dec  2 03:30:26 2019
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Mon, 2 Dec 2019 14:30:26 +1100
Subject: [bitcoin-dev] Composable MuSig
In-Reply-To: <tvK5ZI4GmQzBkGfcYFOaUI4kgLBv7N615LV-yvyUOeYU49Ig2krXbyPOrTSwiiYNZpPYNv6GtLrSRTQf_MRwqmYeXY1VTLzinq93wNW9ex8=@protonmail.com>
References: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>
 <CAH5Bsr2rsiU9gV6VsGH3ZCWGRoTz=g5hXNq37P3P6HB+MmxUAA@mail.gmail.com>
 <tvK5ZI4GmQzBkGfcYFOaUI4kgLBv7N615LV-yvyUOeYU49Ig2krXbyPOrTSwiiYNZpPYNv6GtLrSRTQf_MRwqmYeXY1VTLzinq93wNW9ex8=@protonmail.com>
Message-ID: <CAH5Bsr07ZxxneRngGO=C56qODxu7FQ3r1c7NmcXYY3BZ2VEokA@mail.gmail.com>

Hi ZmnSCPxj,

> > Just a quick note: I think there is a way to commit to a point properly with Pedersen commitments. Consider the following:
> > COM(X) = (y*G + z*H, y*G + X)  where y and z are random and the opening is (y,z,X).  This seems to be a  unconditionally hiding and computationally binding homomorphic commitment scheme to a point based on the DL problem rather than DDH.
>
> So the Pedersen commitment commits to a tweak on `X`, which is revealed later so we can un-tweak `X`.
> Am I correct in assuming that you propose to use `X` for the contribution to `R` for a participant?
> How is it different from using ElGamal commitments?

Yes. It's not significantly different. It is unconditionally hiding
rather than binding (ElGamal is unconditionally binding). I just
thought of it while reading your post so I mentioned it. The real
question is what properties does the commitment scheme need to be
appropriate for MuSig R coin tossing?
In the security proof, the commitment hash is modelled as a random
oracle rather than as an abstract commitment scheme. I wonder if any
MuSig author has an opinion on whether the H_com interaction can be
generalised to a commitment scheme with certain properties (e.g
equivocal, extractable). By the looks of it, the random oracle is
never explicitly programmed except with randomly generated values so
maybe there is hope that a non ROM commitment scheme can do the job. I
guess the reduction would then be to either breaking the discrete
logarithm problem OR some property of the commitment scheme.

Cheers,

LL

From jose.femenias at gmail.com  Mon Dec  2 14:00:57 2019
From: jose.femenias at gmail.com (Jose Femenias)
Date: Mon, 2 Dec 2019 15:00:57 +0100
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
	without addresses
In-Reply-To: <mailman.1377.1575015939.25512.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.1377.1575015939.25512.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <e300549d-4890-3cf2-e514-76bb778abef2@gmail.com>

An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191202/764f28cf/attachment.html>

From tim at timblokdijk.nl  Mon Dec  2 17:27:21 2019
From: tim at timblokdijk.nl (Tim Blokdijk)
Date: Mon, 2 Dec 2019 18:27:21 +0100
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
 without addresses
In-Reply-To: <e300549d-4890-3cf2-e514-76bb778abef2@gmail.com>
References: <mailman.1377.1575015939.25512.bitcoin-dev@lists.linuxfoundation.org>
 <e300549d-4890-3cf2-e514-76bb778abef2@gmail.com>
Message-ID: <55cb9731-e7fb-0bfa-0cba-391ff81d263a@timblokdijk.nl>

Hello Jos?,

Just a quick question, this is fully decentralized?

Greetings,

Tim Blokdijk

Op 02-12-19 om 15:00 schreef Jose Femenias via bitcoin-dev:
> Hi,
>
> I have just released an early preview of easypaysy, a protocol for 
> Bitcoin, that I have been working on for the past few months.
>
> (In case you are wondering, easypaysy stands for EASY - PAYment- 
> SYstem...)
>
> Long story short, easypaysy is a layer-two protocol that allows the 
> creation of non-custodial accounts directly on the blockchain, so that 
> bitcoin addresses can fully disappear from the user experience.
> In lieu of addresses, users send payments to permanent account IDs.
>
> Account IDs are implicitly assigned by the mining process, and come in 
> several flavors, like in these examples:
>
> Canonical ID: btc at 543847.636/577
> Mnemonic ID: btc at cancel-mind.exhibit/motion
> Domain ID: btc at example.com/motion-custom
>
> (Note: Domain IDs are optional and require extra configuration)
>
> The protocol allows both interactive and non interactive payments.
> All payments are non-repudiable, and it is possible to implement 
> pull-payments as well as chargebacks.
>
> Most of the protocol is quite advanced, but I have refrained from 
> specifying some of the details, until the interested parties can give 
> their feedback.
>
> For more information, you can see the white paper and a short 
> introductory video at:
>
> https://www.easypaysy.org
>
> or directly, by following these links:
>
> White paper at https://www.easypaysy.org/assets/easypaysy_white_paper.pdf
> Introductory video at https://www.youtube.com/watch?v=AOGBdyZbyoA
>
> You can also get in contact with me in at:
>
> jose.femenias at gmail.com
>
> or using the project's email at:
>
> easypaysy at gmail.com
>
> Best regards.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191202/dcda1fd1/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Dec  2 21:10:19 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 02 Dec 2019 21:10:19 +0000
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
	without addresses
In-Reply-To: <55cb9731-e7fb-0bfa-0cba-391ff81d263a@timblokdijk.nl>
References: <mailman.1377.1575015939.25512.bitcoin-dev@lists.linuxfoundation.org>
 <e300549d-4890-3cf2-e514-76bb778abef2@gmail.com>
 <55cb9731-e7fb-0bfa-0cba-391ff81d263a@timblokdijk.nl>
Message-ID: <S7L8Cy5mIxjdkhJ-iRPFVsXDWiabzgSGFonO_KreVL-O67tab79Zxm_h1bH6cp4qrZY3tqi6kODvjGdX4OHh_OYip19EWEglb5KmAuWIZ-Y=@protonmail.com>

Good morning Tim, and Jose,

> Just a quick question, this is fully decentralized?
>

It broadcasts information over `OP_RETURN` on the blockchain layer, thus decentralized as long as the blockchain layer is decentralized.
It also means that to register an account, you need to either own some Bitcoins, or rent some Bitcoins to serve as signalling (and then potentially have to change your account identifier later when the lease expires).
`OP_RETURN` does have size limits (imposed by `isStandard`), I do not remember exact numbers, and any data would need to fit.
Finally, use of the blockchain layer is costly; given that payees must be online at any time payers wish to pay, it may do better to just use Lightning instead, which has the same requirement, but moves payments to a separate layer as well, and requires only a single onchain transaction to construct a channel (easypaysy seems to require at least 2, one to anchor the account pubkeys, the other to give the basic "activation" information for the account).

It may be useful to consider defiads, which does *not* use `OP_RETURN`, but instead uses pay-to-contract, and sends the advertisement data over a separate overlay network.
The use-case is mildly different, but ultimately defiads is about connecting potential buyers to potential sellers, and sending data about how to get paid would have to be part and parcel of how defiads ultimately works.

Also, one of the contact-information protocols supported should probably be Tor hidden services, instead of `https`.
Tor hidden services have better useability (no need for port forwarding or registering DNS from some centralized service), with privacy as a bonus.

Further it seems insufficient to only encode block and tx index.
I think it should also encode output index, to also allow a single transaction to anchor multiple accounts.
Also consider using the Lightning encoding of identifying an output: 543847x636x2


Regards,
ZmnSCPxj


> Greetings,
>
> Tim Blokdijk
>
> Op 02-12-19 om 15:00 schreef Jose Femenias via bitcoin-dev:
>
> > Hi,
> >
> > I have just released an early preview of easypaysy, a protocol for Bitcoin, that I have been working on for the past few months.
> >
> > (In case you are wondering, easypaysy stands for EASY - PAYment- SYstem...)
> >
> > Long story short, easypaysy is a layer-two protocol that allows the creation of non-custodial accounts directly on the blockchain, so that bitcoin addresses can fully disappear from the user experience.
> > In lieu of addresses, users send payments to permanent account IDs.
> >
> > Account IDs are implicitly assigned by the mining process, and come in several flavors, like in these examples:
> >
> > Canonical ID:??? btc at 543847.636/577
> > Mnemonic ID:??? btc at cancel-mind.exhibit/motion
> > Domain ID:??? btc at example.com/motion-custom
> >
> > (Note: Domain IDs are optional and require extra configuration)
> >
> > The protocol allows both interactive and non interactive payments.
> > All payments are non-repudiable, and it is possible to implement pull-payments as well as chargebacks.
> >
> > Most of the protocol is quite advanced, but I have refrained from specifying some of the details, until the interested parties can give their feedback.
> >
> > For more information, you can see the white paper and a short introductory video at:
> >
> > https://www.easypaysy.org
> >
> > or directly, by following these links:
> >
> > White paper at https://www.easypaysy.org/assets/easypaysy_white_paper.pdf
> > Introductory video at https://www.youtube.com/watch?v=AOGBdyZbyoA
> >
> > You can also get in contact with me in at:
> >
> > jose.femenias at gmail.com
> >
> > or using the project's email at:
> >
> > easypaysy at gmail.com
> >
> > Best regards.
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From aj at erisian.com.au  Tue Dec  3 08:35:38 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 3 Dec 2019 18:35:38 +1000
Subject: [bitcoin-dev] Signing CHECKSIG position in Tapscript
In-Reply-To: <CAMZUoKmYi6btmhN8NmePPZNpPtXwNp=EpyYrxo7P2Ug7fnPSwQ@mail.gmail.com>
References: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>
 <20191128080659.msrpdpcjhhvbqtv2@erisian.com.au>
 <CAMZUoKmYi6btmhN8NmePPZNpPtXwNp=EpyYrxo7P2Ug7fnPSwQ@mail.gmail.com>
Message-ID: <20191203083538.ggiginwo5k6m4ywq@erisian.com.au>

On Sun, Dec 01, 2019 at 11:09:54AM -0500, Russell O'Connor wrote:
> On Thu, Nov 28, 2019 at 3:07 AM Anthony Towns <aj at erisian.com.au> wrote:
>     First, it seems like a bad idea for Alice to have put funds behind a
>     script she doesn't understand in the first place. There's plenty of
>     scripts that are analysable, so just not using ones that are too hard to
>     analyse sure seems like an option.
> I don't think this is true in general.? When constructing a script it seems
> quite reasonable for one party to come to the table with their own custom
> script that they want to use because they have some sort of 7-of-11 scheme but
> in one of those cases is really a 2-of-3 and another is 5-of-6.? The point is
> that you shouldn't need to decode their exact policy in order to collaborate
> with them.

Hmm, I take the opposite lesson from your scenario -- it's only fine for
people to bring their own 2-of-3 or 5-of-6 or whatever and replace a
simple key if you've got something like miniscript where you understand
the script completely enough that you can be sure those changes are
fine. 

For contrast, with ECDSA and pre-miniscript, the above scenario might
have gone like someone proposing to change:

  7 A B C1 C2 C3 C4 C5 C6 C7 C8 C9 11 CHECKMULTISIG

for something like

  7
  SWAP IF TOALT 2 A1 A2 A3 3 CHECKMULTISIGVERIFY FROMALT 1SUB ENDIF
  SWAP IF TOALT 5 B1 B2 B3 B4 B5 B6 6 CHECKMULTISIGVERIFY FROMALT 1SUB ENDIF
  C1 C2 C3 C4 C5 C6 C7 C8 C9 11 CHECKMULTISIG

but I think you'd want to be pretty sure you can decode those added
policies rather than just accepting it because your "C4" key is still
there. (In particular, any script fragment that uses an opcode that used
to be OP_SUCCESS could have arbitrary effects on the script)

[0]

> This notion is captured quite clearly in the MAST aspect of
> taproot. In many circumstances, it is sufficient for you to know that there
> exists a branch that contains a particular script without need to know what
> every branch contains.

(I'm trying to avoid using MAST in the context of taproot, despite the
backronym, so please excuse the rephrasing--)

I think if you're going to start using a taproot address with multiple
tapscripts, either as a participant in a multiparty smart contract,
or just to have different ways of spending your funds, then you do have
to analyse all the branches to make sure there's no hidden "all the
money goes to the Lizard People" script.

Once you've done that, you can then simplify things -- maybe some
scripts are only useful for other participants in the contract, or maybe
you've got a few different hardware wallets and one only needs to know
about one branch, while the other only needs to know about some other
branch, but you still need to have done the analysis in the first place.

Of course, probably most of the time that "analysis" is just making sure
the scripts match some well known, hardcoded template, as filled out
with various (tweaked) keys that you've checked elsewhere, but that
still ensures you know all the scripts do what you need them too.

>     Third, if you are doing something crazy complex where a particular key
>     could appear in different CHECKSIG operators and they should have
>     independent signatures, that seems like you're at the level of
>     complexity where learning about CODESEPARATOR is a reasonable thing to
>     do.
> So while I agree that learning about CODESEPARATOR is a reasonable thing to do,
> given that I haven't heard the CODESEPARATOR being proposed as protection
> against this sort of signature-copying attack before

Err? The current behaviour of CODESEP with taproot was first discussed in
[1], which summarised it as "CODESEP -- lets you require different sigs
for different parts of a single script" which seems to me like just a
different way of saying the same thing.

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016500.html

I don't think tapscript's CODESEP or the current CODESEP can be used
for anything other than preventing a signature from being reused for a
different CHECKSIG operation on the same pubkey within the same script.

> and given the subtle
> nature of the issue, I'm not sure people will know to use it to protect
> themselves.? We should aim for a Script design that makes the cheaper default
> Script programming choices the safer one.

I think techniques like miniscript and having fixed templates specified
in BIPs and BOLTs and the like are better approaches -- both let you
easily allow a limited set of changes that can be safely made to a policy
(maybe just substituting keys, hashes and times, maybe allowing more
general changes).

> On the other hand, in a previous thread a while ago I was also arguing that
> sophisticated people are plausibly using CODESEPARATOR today, hidden away in
> unredeemed P2SH UTXOs.? So perhaps I'm right about at least one of these two
> points. :)

Sounds like an economics argument :)

>     ?IF HASH160 x EQUALVERIFY groupa ELSE groupb ENDIF
>     ?MERKLEPATHVERIFY CHECKSIG
>     spendable by
>     ?siga keya path preimagex 1
>     or
>     ?sigb keyb path 0
> I admit my proposal doesn't automatically prevent this signature-copying attack
> against every Script template.

Right -- so if you're worried about this sort of attack, you need to
analyse your script to at least be sure that it's not one of these cases
that aren't covered. And if you've got to analyse the script anyway
(which I think you do no matter what), then there's no benefit -- you're
either doing something simple and you're using templates or miniscript
to make the analysis easy; or you're doing something novel and complex,
and you can probably cope with using CODESEP.

(Ultimately I think there's only really two cases where you're
contributing a signature for a tx: either you're a party to the contract,
and you should have fully analysed all the possible ways the utxo could
be spent to make sure the smart contract stuff is correctly implemented
and you can't be cheated; or you're acting as an oracle or similar and
don't really care how the contract goes because you're not a party to
it, in which case people reusing your signature as much as they like is
fine. Hardware wallets don't need to analyse scripts they sign for, eg,
but that's only because for those cases where their owners have done
that first)

> To be fully effective you need to be aware of
> this signature-copying attack vector to ensure your scripts are designed so
> that your CHECKSIG operations are protected by being within the IF block that
> does the verification of the hash-preimage.? My thinking is that my proposal is
> effective enough to save most people most of the time, even if it doesn't save
> everyone all the time, all while having no significant burden otherwise.

I agree the burden's pretty minor; but I think having a single value
for the tx digest for each input for SIGHASH_ALL is kind-of nice for
validation; and I think having to pass through a CHECKSIG position
everytime you do a signature is likely to be annoying for implementors
for pretty much zero actual benefit.

> Therefore, I don't think your point that there still exists a Script where a
> signature copying attack can be performed is adequate by itself to dismiss my
> proposal.

I'm making two points with that example: (1) it's a case where if
you don't analyse the scripts somehow, you can still be vulnerable to
the attack with your change -- so your change doesn't let you avoid
knowing what scripts do; but also (2) that CODESEP is a marginally more
efficient/general fix the problem. Maybe (1) isn't too important,
because even if it weren't true, I still think you need to know what all
the scripts do, but I think (2)'s still reelevant.

> Given that MAST design of taproot greatly reduces this problem compared to
> legacy script, I suppose you could argue that "the burden on all the other
> cases is too great" simply because you believe the problematic situation is now
> extremely rare.

As you aluded to in the previous mail; I think the problem's currently
extremely rare and trivially avoidable because we don't really have any
way of manipulating pubkeys -- there's no CAT, EC_ADD/EC_MUL/EC_TWEAK
or MERKLEPATHVERIFY opcode (or actual Merkle Abstract Syntax Trees or
OP_EXEC etc) to make it a dynamic concern rather than a static one.

> In particular, imagine a world where CODESEPARATOR never existed.? We have this
> signature copying attack to deal with, and we are designing a new Segwit
> version in which we can now address the problem.? One proposal that someone
> comes up with is to sign the CHECKSIG position (or sign the enclosing OP_IF/
> OP_ELSE... position), maybe using a SIGHASH flag to optionally disable it.?
> Someone else comes up with a proposal to add new "CODESEPARATOR" opcode which
> requires adding a new piece of state to the Script interpreter (the only
> non-stack based piece of state) to track the last executed CODESEPARATOR
> position and include that in the signature.? Would you really prefer the
> CODESEPARATOR proposal?

If CODESEP had never existed, I think my first response would be to say
"well, just make sure you don't reuse pubkeys, and because each
bip-schnorr sig commits to the pubkey, problem solved."

There's only two use cases I'm aware of, one is the ridiculous
reveal-a-secret-key-by-forced-nonce-reuse script that's never actually
been implemented [2] and ntumblebit's escrow script [3]. The first of
those requires pubkey recovery so doesn't work with bip-schnorr anyway;
and it's not clear to me whether the second is really reason enough to
justify a dedicated opcode/sighash/etc.

[2] https://lists.linuxfoundation.org/pipermail/lightning-dev/2015-November/000363.html
[3] https://github.com/NTumbleBit/NTumbleBit/blob/master/NTumbleBit/EscrowScriptBuilder.cs

An option would be to remove CODESEP and treat it as OP_SUCCESS -- that
way it could be introduced later with pretty much the exact semantics
that are currently proposed; or with some more useful semantics. That
way we could bring in whatever functionality was actually needed at the
same time as introducing CAT/EC_MUL/etc.

But my default position is to think that the way things currently work is
mostly fine, and we should default ot just keeping the same functionality
-- so SIGHASH_ALL doesn't do anything fancy, but CODESEP can be used to
prevent sig reuse.

>     > As a side benefit, we get to eliminate CODESEPARATOR, removing a fairly
>     awkward
>     > opcode from this script version.
> 
>     As it stands, ANYPREVOUTANYSCRIPT proposes to not sign the script code
>     (allowing the signature to be reused in different scripts) but does
>     continue signing the CODESEPARATOR position, allowing you to optionally
>     restrict how flexibly you can reuse signatures. That seems like a better
>     tradeoff than having ANYPREVOUTANYSCRIPT signatures commit to the CHECKSIG
>     position which would make it a fair bit harder to design scripts that
>     can share signatures, or not having any way to restrict which scripts
>     the signature could apply to other than changing the pubkey.

> Recall that originally CODESEPARTOR would let you sign a suffix of the Script
> program.? In the context of signing the whole script (which is always signed
> indirectly as part of the txid in legacy signatures) signing the offset into
> that scripts contains just as much information as signing a script suffix,
> while being constant sized.? When you remove the Script from the data being
> signed, signing an offset is no longer equivalent to signing a Script suffix,
> and an offset into an unknown data structure is a meaningless value by itself.?
The tapscript implementation isn't intended to be equivalent to signing
a script suffix; all it does is add an index to the digest being signed
so that signatures at different indexes are distinct. That it's
equivalent to the current behaviour is definitely a feature, but I think
that's a surprising coincidence than a useful way of thinking about the
actual usefulness of CODESEP in tapscript...

[4]

> Um, I believe that signing the CODESEPERATOR position without signing the
> script code is nonsensical.? You are talking about signing a piece of data
> without an interpretation of its meaning.

With ANYPREVOUTANYSCRIPT, you're still differentiating signatures by
index, you just no longer also commit to any of the other details of
the script. That means you can't prevent your signature being reused in
random other scripts someone else designs -- hence the "ANYSCRIPT" part --
but you can prevent any of your funds from going to those addresses, so
that's not really your problem anyway. What it does mean is that you can
prevent your signature from being reused in different scripts you do know
about; eg you might have a UTXO with four different tapscript branches:

     1) OP_1 CHECKSIG
     2) CODESEP OP_1 CHECKSIGVERIFY HASH160 x EQUAL
     3) n CLTV DROP CODESEP OP_1 CHECKSIGVERIFY
     4) k CSV DROP CODESEP OP_1 CHECKSIGVERIFY

(where OP_1 means using the taproot internal pubkey with support for
ANYPREVOUT*) -- that way a signature for either path (1) or (2) is only
valid for that path, but a signature for (3) can be reused for (4)
(or vice-versa), but not (1) or (2); and all those signatures could
be reused for other corresponding scripts, for instance with different
values for x,n,k if desired.

> There is no way that you should be signing CODESEPARATOR position without also
> covering the Script with the signature.

So I think it's more sensible than it seems; and still plausible enough
to leave in. If you don't want to separate your ANYPREVOUT scripts,
you can just not put a CODESEP in -- or at least only put CODESEP after
all your ANYPREVOUT CHECKSIGs; so it doesn't seem like it's creating
any added complexity.

Cheers,
aj

[0] For what it's worth, there's another reason not to allow replacing
    keys in a threshold sig with different policies: if you've got say
    30 people with a majority threshold of 16, then you could two groups
    of 9 people form parties and each agree to all vote along party lines;
    but if you let them replace their keys with multisig policies along
    those lines, you're now enforcing a 10-of-30 policy instead (as long
    as the 10 are 5 from the first party and 5 from the second party)
    and allowing minority control instead of majority rule.

[4] I wonder if it would be worth exploring whether we could do
    something more like the original (presumed) intent of CODESEP, given
    use of NOINPUT/ANYPREVOUT so as not to commit to the full script,
    you could potentially have a SIGHASH that committed to a hash of
    the script that's been executed so far, and also the witness data
    that's been consumed so far, but it would ensure the first part of
    the script behaved exactly as you expected, and allow the rest of
    the script to be arbitrarily weird, and (I think) be efficiently
    implementable. That doesn't give you delegation without the ability
    to also have executable witness data of some sort, but maybe something
    like it is interesting anyway?


From jose.femenias at gmail.com  Mon Dec  2 21:25:01 2019
From: jose.femenias at gmail.com (=?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?=)
Date: Mon, 2 Dec 2019 22:25:01 +0100
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
 without addresses
Message-ID: <D6F34614-37E6-4169-86B8-83EB47A6C3C3@gmail.com>

> Hello Jos?,
> 
> Just a quick question, this is fully decentralized?
> Greetings,
> 
> Tim Blokdijk


Tim,

it is fully decentralized indeed. 
Every user is in charge of creating and maintaining his own account.

Regards,

Jos? Femen?as
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191202/469e02ff/attachment.html>

From jose.femenias at gmail.com  Thu Dec  5 20:00:03 2019
From: jose.femenias at gmail.com (=?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?=)
Date: Thu, 5 Dec 2019 21:00:03 +0100
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
 without addresses
Message-ID: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>

Hi ZmnSCPxj

first of all, excuse me for my delayed answer. 

I think I posted to the wrong address the first time (I?m mainly a lurker in the list, so I make gotchas like that?)

Let me address your points.

> It also means that to register an account, you need to either own some Bitcoins, or rent some Bitcoins to serve as signalling (and then potentially have to change your account identifier later when the lease expires). 

I don?t understand what you mean by ?renting? Bitcoins. 
Once you commit the account transaction, the account ID never changes.
(Also, you don?t need to own Bitcoins if you use a Master Easypaysy Account. See my comments later on).



> Finally, use of the blockchain layer is costly; given that payees must be online at any time payers wish to pay, it may do better to just use Lightning instead,

That is not the case. 
When using non-interactive payments, the payee doesn?t need to be online at all.
Even for interactive payments, it depends on the protocol you use.

For Bitmessage, or email, or even MQTT you don?t need to be online simultaneously. (The interactive protocol(s) is still open, however, those are just some hypothetical examples):

Anyway, when using interactive payments, the payee has the option to specify an LN invoice and/or a bitcoin address.



> which has the same requirement, but moves payments to a separate layer as well, and requires only a single onchain transaction to construct a channel (easypaysy seems to require at least 2, one to anchor the account pubkeys, the other to give the basic "activation" information for the account). 

Easypaysy accounts don?t need 2 TXs. They need funding plus a TX for the account information itself.
So, you need an UTXO -to fund the account- and a TX. 
But the UTXO can be one of many in the same transaction. 
So, you could fund multiple accounts with a single TX.


> Also, one of the contact-information protocols supported should probably be Tor hidden services, instead of `https`. Tor hidden services have better useability (no need for port forwarding or registering DNS from some centralized service), with privacy as a bonus. 
Easypaysy is protocol agnostic (for now). So, Tor is definitely a possibility.


> Further it seems insufficient to only encode block and tx index. I think it should also encode output index, to also allow a single transaction to anchor multiple accounts. Also consider using the Lightning encoding of identifying an output: 543847x636x2 
There is really no need to specify an additional output.
If I am right, you can?t have more than one OP_RETURN per transaction.

On the other hand, as you can see in the white paper ?4.2 Master accounts?, these type of accounts allow for up to 2048 accounts per transaction.

The format of the ID in this case is: btc at master_idx.slave_id/checksum

The master_idx is an ordinal pointer (not positional) to the Master TX, while the slave_id points to one of the 2048 transactions within the account (whose information is stored elsewhere, protected by a Merkle root committed in the Master Tx)

There is a little bit more to it that seems appropriate to discuss here, please have a look at page 25 of the white paper.

Thanks for your input.


Best regards,

Jos? Femen?as

From roconnor at blockstream.io  Thu Dec  5 20:24:46 2019
From: roconnor at blockstream.io (Russell O'Connor)
Date: Thu, 5 Dec 2019 15:24:46 -0500
Subject: [bitcoin-dev] Signing CHECKSIG position in Tapscript
In-Reply-To: <20191203083538.ggiginwo5k6m4ywq@erisian.com.au>
References: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>
 <20191128080659.msrpdpcjhhvbqtv2@erisian.com.au>
 <CAMZUoKmYi6btmhN8NmePPZNpPtXwNp=EpyYrxo7P2Ug7fnPSwQ@mail.gmail.com>
 <20191203083538.ggiginwo5k6m4ywq@erisian.com.au>
Message-ID: <CAMZUoKkRVE-1hPvAZmo4QfLRBgeXzxk0bBncN9eZ110+Hb7T+A@mail.gmail.com>

After chatting with andytoshi and others, and some more thinking I've been
convinced that my specific concern about other users masquerading other
people pubkeys as their own in complex scripts is actually a non-issue.

No matter what you write in Script (today), you are limited to expressing
some policy that is logically equivalent to a set of conditions and
signatures on pubkeys that can be expressed in disjunctive normal form.  We
can write such a policy as

(C[1] && PK[1,1] && ... && PK[1,m[1]]) || ... || (C[n] && PK[n,1] && ... &&
PK[n,m[n]])

where C[i] is some conjunction of conditions such as timelock constraints,
or hash-lock constraints or any other kind of proof of publication, and
where PK[i,j] is a requirement of a signature against a specific public key.

>From Alice's point of view, she can divide set of clauses under the
disjunction into those that contain a pubkey that she considers (partially)
under her control and those clauses that she does not control (even though
as we shall see those other keys might actually be under Alice's control,
unbeknownst to her). To that end, let us consider a specific representative
policy.

    (C[1] && APK[1]) || (C[2] && APK[2] && BPK[2]) || (C[3] && BPK[3])

where Alice considers herself in control of APK[1] and APK[2], and where
she considers Bob in control of BPK[2] and BPK[3] and where C[1], C[2], and
C[3] are different conditions, let's say three different hash-locks.  We
will also say that Alice has ensured that her pubkeys in different clauses
are different (i.e. APK[1] != APK[2]), but she doesn't make any such
assumption for Bob's keys and neither will we.

When Alice funded this Script, or otherwise accepted it for consideration,
she agreed that she wouldn't control the redemption of the UTXO as long as
the preimage for C[3] is published.  In particular, Alice doesn't even need
to fully decode the Script semantics for that clause beyond determining
that it enforces the C[3] requirement that she cares about. Even if Bob was
masquerading Alice's pubkey as his own (as in BPK[3] = APK[1] or BPK[3] =
APK[2]), and he ends up copying her signature into that clause, Alice ends
up with C[3] published as she originally accepted as a possibility.  Bob
masquerading Alice's pubkey as his own only serves to hamper his own
ability to sign for his clauses (I mean, Bob might be trying to convince
some third party that Alice signed for something she didn't actually sign
for, but such misrepresentations of the meaning of digital signatures is
outside our scope and this just serves as a reminder not to be deceived by
Bob's tricks here).

And the same argument holds for BPK[2].  Even if BPK[2] = APK[1] and Bob
tries to copy Alice's signature into the C[2] condition, he still needs a
countersignature with her APK[2], so Alice remains in control of that
clause.  And if BPK[2] = APK[2] then Bob can only copy Alice's signature on
the C[2] condition, but in that case she has already authorised that
condition.  Again, Bob masquerading Alice's pubkey as his own only serves
to hamper his own ability to sign for his clauses.

So what makes our potential issue here safe, versus the dangers that would
happen in <https://bitcoin.stackexchange.com/a/85665/49364> where Bob
masqurades Alice's UTXO as his own?  The key problem in the UTXO case isn't
so much Bob masquerading Alice's pubkey as his own, as it is an issue with
Alice reusing her pubkeys and Bob taking advantage of that.  We do, in
fact, have exactly the same issue in Script.  If Alice were to reuse
pubkeys such that APK[1] = APK[2], then Bob could take her signature for
C[1] and transplant it to redeem under condition C[2].  We see that it is
imperative that Alice ensures that she doesn't reuse pubkeys that she
considers under her control for different conditions when she wants her
signature to distinguish between them.

For various reasons, some historical, it is much harder to avoid pubkey
reuse for different UTXOs than it is to avoid pubkey reuse within a single
script.  We often use Bitcoin addresses in non-interactive ways, such as
putting them on flyers or painting them on walls and such.  Without a
standard for tweaking such pubkeys in a per-transaction way, we end up with
a lot of pubkey reuse between various UTXOs.  However, within a Script,
avoiding pubkey reuse ought to be easier.  Alice must communicate different
pubkeys intended for different clauses, or if Bob is constructing a whole
complex script on Alice's behalf, he may need to add CODESEPARATORs if
tweaking Alice's pubkey isn't an option.

The conversion of a policy to disjunctive normal form can involve an
exponential blowup (see <
https://en.wikipedia.org/wiki/Disjunctive_normal_form#Conversion_to_DNF>).
For instance, if Alice's policy (not in disjunctive normal form) is of the
form

    (C[1] || D[1]) && ... && (C[n] || D[n]) && APK

where C[i] and D[i] are all distinct hashlocks, we require O(2^n) clauses
to put it in disjunctive normal form.  If Alice wants to create signatures
that are restricted to a specific combination of C[i]'s and D[i]'s, she
needs to use an exponential number of pubkeys, which isn't tractable to do
in Script.  But neither my original proposal nor CODESEPARATOR helps in
this case either because CODESEPARATOR can mark only the last executed
position.  Taproot's MAST (Merklized Alternative Script Tree per aj's
suggestion), can maybe provide a tractable solution to this in cases where
it is applicable.  The MAST is always a disjunction and because the tapleaf
is signed, it is safe to reuse pubkeys between alternative branches.

This analysis suggests that we should amend CODESEPARATORs behaviour to
update an accumulator (presumably a running hash value), so that all
executed CODESEPARATOR positions end up covered by the signature.  That
would provide a solution to the above problem for those cases where
taproot's MAST cannot be used.  I'm not sure if it is better to propose
such an amendment to CODESEPARATOR's behaviour now, or to propose to
soft-fork in such optional behaviour at a later time.

However, what I said above was even too simplified.  In general, a policy
of the form.

    (Exists w[1]. C[1](w[1]) && PK[1,1](w[1]) && ... && PK[1,m[1]](w[1]) ||
... || (Exists w[n]. C[n](w[n]) && PK[n,1](w[n]) && ... && PK[n,m[n]](w[n]))

where each term could possibly be parameterized by some witness value
(though at the moment there isn't enough functionality in Script to
parameterize the pubkeys in any reasonably way and it maybe isn't even
possible to parameterise the conditions in any reasonable way).  In
general, you might want your signature to cover (some function of) this
witness value.  This suggests that we would actually want a CODESEPARATOR
variant that pushes a stack item into the accumulator that gets covered by
the signature rather than pushing the CODESEPARATOR position.  Though at
this point the name CODESEPARATOR is probably not suitable, even if it
subsumes the functionality.  Again, I'm not sure if it is better to propose
such a replacement for CODESEPARATOR's behaviour now, or to propose to
soft-fork in such optional behaviour at a later time.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191205/5dc3e915/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Fri Dec  6 02:53:34 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 06 Dec 2019 02:53:34 +0000
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
	without addresses
In-Reply-To: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>
References: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>
Message-ID: <fBhj5XmKd7-1Bk13TuSLkwYGGgbvdVUbSr-dOjJk9pe0cb6CdLPhCUgbIDFyCv6ua2yJJc2lpn-IX42jN2MH8FGex7oqlxb2t-UKIUjPYrA=@protonmail.com>

Good morning Jose,


> > It also means that to register an account, you need to either own some Bitcoins, or rent some Bitcoins to serve as signalling (and then potentially have to change your account identifier later when the lease expires).
>
> I don?t understand what you mean by ?renting? Bitcoins.
> Once you commit the account transaction, the account ID never changes.
> (Also, you don?t need to own Bitcoins if you use a Master Easypaysy Account. See my comments later on).

If you have 0 Bitcoins, you need to have *some* Bitcoins from somewhere else (perhaps a service provider) in order to back the initial funding transaction output.
If you create Master Easypaysy account by paying fiat to some service provider that then uses its Bitcoins to fund your Easypaysy account, but requires some sort of shared control over the money in it, I simply call this "renting" the Bitcoin, as presumably the service provider would want to get its coins back from you.

If you are referring to the use of a service provider, then the service provider at least partially controls your account and if it ceases to exist or refuses to continue doing business with you, you need to transfer your account identifier somehow (i.e. end of lease).

>
> > Finally, use of the blockchain layer is costly; given that payees must be online at any time payers wish to pay, it may do better to just use Lightning instead,
>
> That is not the case.
> When using non-interactive payments, the payee doesn?t need to be online at all.
> Even for interactive payments, it depends on the protocol you use.
>
> For Bitmessage, or email, or even MQTT you don?t need to be online simultaneously. (The interactive protocol(s) is still open, however, those are just some hypothetical examples):

You could indicate use of some kind of pay-to-contract, then have the payer send the contract text to the payee so that the payee can claim the funds later.

> Anyway, when using interactive payments, the payee has the option to specify an LN invoice and/or a bitcoin address.
>
> > which has the same requirement, but moves payments to a separate layer as well, and requires only a single onchain transaction to construct a channel (easypaysy seems to require at least 2, one to anchor the account pubkeys, the other to give the basic "activation" information for the account).
>
> Easypaysy accounts don?t need 2 TXs. They need funding plus a TX for the account information itself.
> So, you need an UTXO -to fund the account- and a TX.

Yes, that is why I count it as 2 transactions: one transaction to host the funding UTXO that is referred to in the account identifier, and the other transaction is what broadcasts the account information (in particular, the funding UTXO is a P2SH and the transaction that spends it is the one that reveals the 2 pubkeys you require).

In contrast, Lightning Network requires only the funding UTXO (which requires that short channel IDs include the transaction output index, as a single funding transaction can fund multiple Lightning Network channels).

> But the UTXO can be one of many in the same transaction.
> So, you could fund multiple accounts with a single TX.

So can Lightning Network channels: multiple channels can be funded by a single funding transactions (C-Lightning supports this, but not as a single command yet, it requires some low-level fiddling).

> > Also, one of the contact-information protocols supported should probably be Tor hidden services, instead of `https`. Tor hidden services have better useability (no need for port forwarding or registering DNS from some centralized service), with privacy as a bonus.
>
> Easypaysy is protocol agnostic (for now). So, Tor is definitely a possibility.

I suggest being Tor-centric instead.

>
> > Further it seems insufficient to only encode block and tx index. I think it should also encode output index, to also allow a single transaction to anchor multiple accounts. Also consider using the Lightning encoding of identifying an output: 543847x636x2
>
> There is really no need to specify an additional output.
> If I am right, you can?t have more than one OP_RETURN per transaction.

This does not mesh with your earlier claim:

> But the UTXO can be one of many in the same transaction.

My understanding is that the account identifier refers to the funding TXO (and funding transactions do not have an `OP_RETURN`, so I fail to see the relevance of that restriction).
If the funding transaction can have many UTXOs that are individually funding TXOs of multiple Easypaysy accounts, then you need to refer to *which* TXO of that funding transaction is what you are using.

>
> On the other hand, as you can see in the white paper ?4.2 Master accounts?, these type of accounts allow for up to 2048 accounts per transaction.
>
> The format of the ID in this case is: btc at master_idx.slave_id/checksum
>
> The master_idx is an ordinal pointer (not positional) to the Master TX, while the slave_id points to one of the 2048 transactions within the account (whose information is stored elsewhere, protected by a Merkle root committed in the Master Tx)
>
> There is a little bit more to it that seems appropriate to discuss here, please have a look at page 25 of the white paper.

Why would it not be appropriate?

In case of such a "Master TX", would it be possible for each slave to be independently controlled by a different party?


Regards,
ZmnSCPxj

From aj at erisian.com.au  Fri Dec  6 04:51:53 2019
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 6 Dec 2019 14:51:53 +1000
Subject: [bitcoin-dev] Signing CHECKSIG position in Tapscript
In-Reply-To: <CAMZUoKkRVE-1hPvAZmo4QfLRBgeXzxk0bBncN9eZ110+Hb7T+A@mail.gmail.com>
References: <CAMZUoKm7Y8bRJ+hqmvyPwwTWHaMA7JJc5TZdx7Eufax9G0D=Gg@mail.gmail.com>
 <20191128080659.msrpdpcjhhvbqtv2@erisian.com.au>
 <CAMZUoKmYi6btmhN8NmePPZNpPtXwNp=EpyYrxo7P2Ug7fnPSwQ@mail.gmail.com>
 <20191203083538.ggiginwo5k6m4ywq@erisian.com.au>
 <CAMZUoKkRVE-1hPvAZmo4QfLRBgeXzxk0bBncN9eZ110+Hb7T+A@mail.gmail.com>
Message-ID: <20191206045153.dufkatmm6izcy4dw@erisian.com.au>

On Thu, Dec 05, 2019 at 03:24:46PM -0500, Russell O'Connor wrote:

Thanks for the careful write up! That matches what I was thinking.

> This analysis suggests that we should amend CODESEPARATORs behaviour to update
> an accumulator (presumably a running hash value), so that all executed
> CODESEPARATOR positions end up covered by the signature.

On IRC, gmaxwell suggests "OP_BREADCRUMB" as a name for (something like)
this functionality.

(I think it's a barely plausible stretch to use the name "CODESEPARATOR"
for marking a position in the script -- that separates what was before
and after, at least; anything more general seems like it warrants a
better name though)

> That would provide a
> solution to the above problem for those cases where taproot's MAST cannot be
> used.? I'm not sure if it is better to propose such an amendment to
> CODESEPARATOR's behaviour now, or to propose to soft-fork in such optional
> behaviour at a later time.
> However, what I said above was even too simplified.? 

FWIW, I think it's too soon to propose this because (a) it's not clear
there's a practical need for it, (b) it's not clear the functionality is
quite right (opcode vs more automatic sighash flag?), and (c) as you say,
it's not clear it's powerful enough.

> In general, a policy of the form.
> ??? (Exists w[1]. C[1](w[1]) && PK[1,1](w[1]) && ... && PK[1,m[1]](w[1]) || ...
> || (Exists w[n]. C[n](w[n]) && PK[n,1](w[n]) && ... && PK[n,m[n]](w[n]))
> where each term could possibly be parameterized by some witness value (though
> at the moment there isn't enough functionality in Script to parameterize the
> pubkeys in any reasonably way and it maybe isn't even possible to parameterise
> the conditions in any reasonable way).? In general, you might want your
> signature to cover (some function of) this witness value.? This suggests that
> we would actually want a CODESEPARATOR variant that pushes a stack item into
> the accumulator that gets covered by the signature rather than pushing the
> CODESEPARATOR position.? Though at this point the name CODESEPARATOR is
> probably not suitable, even if it subsumes the functionality.

> Again, I'm not
> sure if it is better to propose such a replacement for CODESEPARATOR's
> behaviour now, or to propose to soft-fork in such optional behaviour at a later
> time.

Last bit first, it seems pretty clear to me that this is too novel an
idea to propose it immediately -- we should explore the problem space
more first to see what's the best way of doing it before coding it into
consensus. And (guessing) I think the tapscript upgrade methods should
be fine for handling this later.

I think the annex is also not general enough for what you're thinking
here, in that it wouldn't allow for one signature to constrain the witness
data more than some other signature -- so you'd need to determine all
the constraints for all signatures to finish filling out the annex,
and could only then start signing.

I think you could conceivably do any/all of:

 * commit to a hash of all the witness data that hasn't been popped off
   the stack ("suffix" commitment -- the data will be used by later script
   opcodes)
 * commit to a hash of all the witness data that has been popped off the
   stack ("prefix" commitment -- this is the data that's been used by
   earlier script opcodes)
 * commit to the hash of the current stack

That would be expensive, but still doable as O(1) per opcode / stack
element. I think any other masking would mean you'd have potentially
O(size of witness data) or O(size of stack) runtime per signature which
I think would be unacceptable...

I guess a general implementation to at least think about the possibilities
might be an "OP_DATACOMMIT" opcode that pops an element from the stack,
does hash_"DataCommit"(element), and then any later signatures commit
to that value (maybe with OP_0 OP_DATACOMMIT allowing you to get back to
the default state). You'd either need to write your script carefully to
commit to witness data you're using elsewhere, or have some other new
opcodes to do that more conveniently...

CODESEP at position "x" in the script is equivalent to "<x> DATACOMMIT"
here, I think. "BREADCRUMB .. BREADCRUMB" could be something like:

   OP_0 TOALT [at start of script]
   ..
   FROMALT x CAT SHA256 DUP TOALT DATACOMMIT   
   ..
   FROMALT y CAT SHA256 DUP TOALT DATACOMMIT   

if the altstack was otherwise unused, I guess; so the accumulator
behaviour probably warrants something better.

It also more or less gives you CHECKSIGFROMSTACK behaviour by doing
"SWAP OP_DATACOMMIT OP_CHECKSIG" and a SIGHASH_NONE|ANYPREVOUTANYSCRIPT
signature.

But that seems like a plausible generalisation to think about?

Cheers,
aj


From jose.femenias at gmail.com  Fri Dec  6 07:56:52 2019
From: jose.femenias at gmail.com (=?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?=)
Date: Fri, 6 Dec 2019 08:56:52 +0100
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
 without addresses
In-Reply-To: <fBhj5XmKd7-1Bk13TuSLkwYGGgbvdVUbSr-dOjJk9pe0cb6CdLPhCUgbIDFyCv6ua2yJJc2lpn-IX42jN2MH8FGex7oqlxb2t-UKIUjPYrA=@protonmail.com>
References: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>
 <fBhj5XmKd7-1Bk13TuSLkwYGGgbvdVUbSr-dOjJk9pe0cb6CdLPhCUgbIDFyCv6ua2yJJc2lpn-IX42jN2MH8FGex7oqlxb2t-UKIUjPYrA=@protonmail.com>
Message-ID: <AF3AF268-8E5B-481E-A5C7-205D171E90A5@gmail.com>

Hi ZmnSCPxj,

first of all: do you ever sleep?    ;-)


A few points about your reply:

a) The easypaysy white paper isn?t a final set of specifications. 
Instead it is meant as a somewhat detailed draft of the ideas that can drive a working set of specifications.
As such, any qualified input -as in your case- is much welcome, since it can greatly help with the process.



b) Master accounts are included in the white paper as a feature for a future release. 
The roadmap is not set yet, but I?d like to include a first release of the protocol that only covers the most basic features, to make it simpler and safer for wallet developers. 
Master accounts aren?t a priority, since they are more oriented towards scaling the proposal, and that is far from being a problem yet. 
So, this feature is not well defined for now. However, as presented in the white paper, the ?service provider? has really no control over your money.

He would basically do a just a few things: 

- Aggregate the account info (up to 2048 individual accounts per master account).
- Hash every account info, sort them, and calculate the Merkle root of a tree containing them all.
- Create a JSON document containing the information of all the sub-accounts included in the pack.
- Make that JSON document publicly available, probably with a https: URL (That?s called an Authoritative server)
- Finally, create and publish a TX that contains a pointer to the Authoritative server, and the Merkle root of the set of accounts.

The service provider would have NO control whatsoever of your funds, nor can he block payments, etc.
There is some sort of delegation, but no trust involved here. The Merkle root protects agains any attempt of tampering with the account data.

The account?s TX won?t ever disappear from the blockchain, so your account info will always be there.
Worst case scenario, the service provider disappears and users can?t download the Json document containing your account information.

To mitigate this issue, the white paper suggests the creation of mirror servers.

Page 27
---------
'The risk that the authoritative server designated within the EASYPAYSY_MASTER_ACCOUNT_DESCRIPTOR could become unavailable can be mitigated with the use of mirror servers.?
...
'It is conceivable that the mirror could charge for this service, perhaps requiring a small LN payment per request, so there will be an economic incentive to preserve the information associated with every master account ever published into the blockchain.?



c) I am a BIG fan of the Lightning network (see the example before). I wouldn?t like to sound as easypaysy promotes on-chain payments vs LN payments.
I still think there is room for both. I guess and hope that LN payments will grow exponentially in the future. 
However, some large transactions and a few other uses cases will probably make more sense on-chain.



d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).
*** However ***, your idea is sound and I can see some use cases for both pointing to the input and output of a TX.
In fact, the seed for easypaysy is some work I did previously, called ?Bitcoin pointers? (you can search the dev list for the link).
In there, I proposed a fuller set of features for a TX-ID, including both pointing to the input and the output of a TX.

This is an excerpt from the document on canonical pointers:

'It is also possible to refer to an input: and/or  :output within a transaction. 
In our example, the canonical pointers that point to the first input and the second output of that  transaction are, respectively:

	btc at 0:170.1/028-588-872 and btc at 170.1:1/413-851-608'

Additionally, the specs allow for the use of attributes; quoting again:

'btc at 170.1:1/179_address should return 12cbQLTFMXRnSzktFkuoG3eHoMeFtpTu3S, which is the address of the second output of that transaction?.



e) The white paper barely touches the implications the easypaysy protocol could have for the Lightning Network, other than citing the possibility of receiving an LN invoice within the Payment reply document.
I didn?t really have neither the time, nor the expertise required to explore further applicability for LN, although I can imagine some use cases.
I know you are quite the expert on LN issues, so if you would like to contribute your suggestions on how to shape the protocol in this regard, I will very much welcome your contributions.

If you are interested, please contact me, preferably privately since I wouldn?t want to become much too off topic in this dev-list

Thanks again for your comments.

Regards,


Jose Femenias

jose.femenias at gmail.com
www.easypaysy.org



> On 6 Dec 2019, at 03:53, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Jose,
> 
> 
>>> It also means that to register an account, you need to either own some Bitcoins, or rent some Bitcoins to serve as signalling (and then potentially have to change your account identifier later when the lease expires).
>> 
>> I don?t understand what you mean by ?renting? Bitcoins.
>> Once you commit the account transaction, the account ID never changes.
>> (Also, you don?t need to own Bitcoins if you use a Master Easypaysy Account. See my comments later on).
> 
> If you have 0 Bitcoins, you need to have *some* Bitcoins from somewhere else (perhaps a service provider) in order to back the initial funding transaction output.
> If you create Master Easypaysy account by paying fiat to some service provider that then uses its Bitcoins to fund your Easypaysy account, but requires some sort of shared control over the money in it, I simply call this "renting" the Bitcoin, as presumably the service provider would want to get its coins back from you.
> 
> If you are referring to the use of a service provider, then the service provider at least partially controls your account and if it ceases to exist or refuses to continue doing business with you, you need to transfer your account identifier somehow (i.e. end of lease).
> 
>> 
>>> Finally, use of the blockchain layer is costly; given that payees must be online at any time payers wish to pay, it may do better to just use Lightning instead,
>> 
>> That is not the case.
>> When using non-interactive payments, the payee doesn?t need to be online at all.
>> Even for interactive payments, it depends on the protocol you use.
>> 
>> For Bitmessage, or email, or even MQTT you don?t need to be online simultaneously. (The interactive protocol(s) is still open, however, those are just some hypothetical examples):
> 
> You could indicate use of some kind of pay-to-contract, then have the payer send the contract text to the payee so that the payee can claim the funds later.
> 
>> Anyway, when using interactive payments, the payee has the option to specify an LN invoice and/or a bitcoin address.
>> 
>>> which has the same requirement, but moves payments to a separate layer as well, and requires only a single onchain transaction to construct a channel (easypaysy seems to require at least 2, one to anchor the account pubkeys, the other to give the basic "activation" information for the account).
>> 
>> Easypaysy accounts don?t need 2 TXs. They need funding plus a TX for the account information itself.
>> So, you need an UTXO -to fund the account- and a TX.
> 
> Yes, that is why I count it as 2 transactions: one transaction to host the funding UTXO that is referred to in the account identifier, and the other transaction is what broadcasts the account information (in particular, the funding UTXO is a P2SH and the transaction that spends it is the one that reveals the 2 pubkeys you require).
> 
> In contrast, Lightning Network requires only the funding UTXO (which requires that short channel IDs include the transaction output index, as a single funding transaction can fund multiple Lightning Network channels).
> 
>> But the UTXO can be one of many in the same transaction.
>> So, you could fund multiple accounts with a single TX.
> 
> So can Lightning Network channels: multiple channels can be funded by a single funding transactions (C-Lightning supports this, but not as a single command yet, it requires some low-level fiddling).
> 
>>> Also, one of the contact-information protocols supported should probably be Tor hidden services, instead of `https`. Tor hidden services have better useability (no need for port forwarding or registering DNS from some centralized service), with privacy as a bonus.
>> 
>> Easypaysy is protocol agnostic (for now). So, Tor is definitely a possibility.
> 
> I suggest being Tor-centric instead.
> 
>> 
>>> Further it seems insufficient to only encode block and tx index. I think it should also encode output index, to also allow a single transaction to anchor multiple accounts. Also consider using the Lightning encoding of identifying an output: 543847x636x2
>> 
>> There is really no need to specify an additional output.
>> If I am right, you can?t have more than one OP_RETURN per transaction.
> 
> This does not mesh with your earlier claim:
> 
>> But the UTXO can be one of many in the same transaction.
> 
> My understanding is that the account identifier refers to the funding TXO (and funding transactions do not have an `OP_RETURN`, so I fail to see the relevance of that restriction).
> If the funding transaction can have many UTXOs that are individually funding TXOs of multiple Easypaysy accounts, then you need to refer to *which* TXO of that funding transaction is what you are using.
> 
>> 
>> On the other hand, as you can see in the white paper ?4.2 Master accounts?, these type of accounts allow for up to 2048 accounts per transaction.
>> 
>> The format of the ID in this case is: btc at master_idx.slave_id/checksum
>> 
>> The master_idx is an ordinal pointer (not positional) to the Master TX, while the slave_id points to one of the 2048 transactions within the account (whose information is stored elsewhere, protected by a Merkle root committed in the Master Tx)
>> 
>> There is a little bit more to it that seems appropriate to discuss here, please have a look at page 25 of the white paper.
> 
> Why would it not be appropriate?
> 
> In case of such a "Master TX", would it be possible for each slave to be independently controlled by a different party?
> 
> 
> Regards,
> ZmnSCPxj


From ZmnSCPxj at protonmail.com  Fri Dec  6 17:16:44 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 06 Dec 2019 17:16:44 +0000
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
	without addresses
In-Reply-To: <AF3AF268-8E5B-481E-A5C7-205D171E90A5@gmail.com>
References: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>
 <fBhj5XmKd7-1Bk13TuSLkwYGGgbvdVUbSr-dOjJk9pe0cb6CdLPhCUgbIDFyCv6ua2yJJc2lpn-IX42jN2MH8FGex7oqlxb2t-UKIUjPYrA=@protonmail.com>
 <AF3AF268-8E5B-481E-A5C7-205D171E90A5@gmail.com>
Message-ID: <Qul4dCoKs2JEQgCYkvdn_QYjgQ5ucpwHZCHdU7qOZ5DGYOGB7p37-s7GN6Jg_NKDzsLlGv-WkOU_mY-a1A_tygRlnhOVnJBK9nvAJ3Gs-bE=@protonmail.com>

Good morning Jose,

> Hi ZmnSCPxj,
>
> first of all: do you ever sleep? ;-)

It seems possible, that, I do not.


> b) Master accounts are included in the white paper as a feature for a future release.
> The roadmap is not set yet, but I?d like to include a first release of the protocol that only covers the most basic features, to make it simpler and safer for wallet developers.
> Master accounts aren?t a priority, since they are more oriented towards scaling the proposal, and that is far from being a problem yet.
> So, this feature is not well defined for now. However, as presented in the white paper, the ?service provider? has really no control over your money.
>
> He would basically do a just a few things:
>
> -   Aggregate the account info (up to 2048 individual accounts per master account).
> -   Hash every account info, sort them, and calculate the Merkle root of a tree containing them all.
> -   Create a JSON document containing the information of all the sub-accounts included in the pack.
> -   Make that JSON document publicly available, probably with a https: URL (That?s called an Authoritative server)
> -   Finally, create and publish a TX that contains a pointer to the Authoritative server, and the Merkle root of the set of accounts.
>
>     The service provider would have NO control whatsoever of your funds, nor can he block payments, etc.
>     There is some sort of delegation, but no trust involved here. The Merkle root protects agains any attempt of tampering with the account data.

This does not seem to mesh well with the other non-Master parts of the protocol, where further updates on the single account backed by a funding TXO are performed by spending the funding TXO and creating a transaction with `OP_RETURN`.

In addition, I would like to suggest as well that instead of `OP_RETURN`, you could instead use "sign-to-contract".

Sign-to-contract is simply that, when signing, instead of selecting a random `r` and computing `R` as `R = r * G`, you select a random `r` and a contract or other message `c`, and compute `R` as `R = r * G + h((r * G) | c) * G`.
Then the user can provide the message `c` independently of the signature, via another mechanism, and reveal `r * G` and `c` and point to the signature as a commitment to the message `c`.
Although, it does have the drawback that using sign-to-contract require a different layer / overlay network to broadcast messages `c`, but it does reduce the cost on the blockchain layer, which is always a good thing.
Similar issues are faced by the RGB project, for instance, and defiads explicitly uses a separate overlay network when transmitting advertisements (both RGB and defiads use the opposite pay-to-contract, which tweaks the pubkey rather than the ephemeral `R`).

>
>     The account?s TX won?t ever disappear from the blockchain, so your account info will always be there.
>     Worst case scenario, the service provider disappears and users can?t download the Json document containing your account information.
>
>     To mitigate this issue, the white paper suggests the creation of mirror servers.

How about control transactions on top of the funding txo?
Who is able to make further control transactions?
If the service provider gives the user full control of the control transactions on top of the funding txo, then it outright loses the money it put in the funding txo and might as well operate as a full exchange.
If the service provider retains even partial control, then it can refuse to cooperate with the user and the user will be unable to update his or her account.

This is not fixable by the use of mirror servers.


> d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).

Do you mean, that if the user makes a control transaction to change the details of the account, then the user is forced to change the easypaysy identifier?

My initial reading of your whitepaper is that the easypaysy identifier refers to the funding txo that roots the further control transactions.
If so, the funding txo is not necessarily a one-input two-output transaction.
If not, then each time a control transaction changes the details of the easypaysy identifier, the identifier itself is changed.0


> If you are interested, please contact me, preferably privately since I wouldn?t want to become much too off topic in this dev-list

I still do not see why it would be off-topic to the devlist.

Regards,
ZmnSCPxj


From ZmnSCPxj at protonmail.com  Sat Dec  7 04:09:52 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 07 Dec 2019 04:09:52 +0000
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
	without addresses
In-Reply-To: <6CB7E73C-57C9-428B-83E6-36113B619BFB@gmail.com>
References: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>
 <fBhj5XmKd7-1Bk13TuSLkwYGGgbvdVUbSr-dOjJk9pe0cb6CdLPhCUgbIDFyCv6ua2yJJc2lpn-IX42jN2MH8FGex7oqlxb2t-UKIUjPYrA=@protonmail.com>
 <AF3AF268-8E5B-481E-A5C7-205D171E90A5@gmail.com>
 <Qul4dCoKs2JEQgCYkvdn_QYjgQ5ucpwHZCHdU7qOZ5DGYOGB7p37-s7GN6Jg_NKDzsLlGv-WkOU_mY-a1A_tygRlnhOVnJBK9nvAJ3Gs-bE=@protonmail.com>
 <6CB7E73C-57C9-428B-83E6-36113B619BFB@gmail.com>
Message-ID: <N9-zGG_2BG2WsjQrRXInpHcn53gxQwUb-P9K5P2DL_NoZwYsNAzfgYSvgT4hAyWbmZmshWM5peZKGRmKMfDECvDifwJNUXG7tULEQPLixCU=@protonmail.com>

Good morning Jose,




> > If the service provider retains even partial control, then it can refuse to cooperate with the user and the user will be unable to update his or her account.
> > This is not fixable by the use of mirror servers.
>
> You are right about that too? (I wonder if some kind of MAST smart contract could fix this, maybe you have a suggestion for this; I am thinking K of M users can override the service provider if he misbehaves)

Sybils are trivial, and a "quorum" of K users can always be manufactured for a targeted attack.
Far better to use an n-of-n, with the service provider as one of the n, and use pre-signed transactions like in Lightning Network to allow unilateral ending of the agreement.

> What I have in mind, but haven?t completely figured out, in case of an uncooperative service provider -or just because one user decides to fly solo- is the possibility for a sub-account to ?detach? itself from the master account.

A "graftroot transform" can be done, at the cost of moving data offchain and thus requiring easypaysy to have its own overlay network.
Basically, one commits onchain (via `OP_RETURN`, sign-to-contract, pay-to-contract, or even just using P2PKH) some public key and a series of `R` values.
Then, control messages are authorized by signatures validated with the public key, and use up individual `R`s in the series of `R` values.
(Alternately we commit just to the public key and a "next" `R` value, and each control message indicates a new public key and next `R` value that is signed with the current public key and "current" `R` value, to form a chain of off-blockchain control messages.)

Having a precommitted series of `R` values ensures that the signer can only safely use an `R` once and thus cannot otherwise attack the network by giving half of it one control message and the other half a conflicting control message: if someone does so, the `R` must be reused between both conflicting control messages and this allows trivial revelation of the private key (i.e. a form of single-use-seal).
Presumably the private key is valuable by itself somehow.

> But, based on the private feedback I am having from two prominent figures in the space, making sure the protocol is easy to implement for SPV wallets is essential to encourage wallet adoption.
> A separate transport layer doesn?t fit well with this.

Indeed.

>
> So, maybe your suggestion will become more applicable in future iterations of the protocol. I may request your help for further clarification about this issue, if you are so kind (as you always are).
>
> > > d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).
> >
> > Do you mean, that if the user makes a control transaction to change the details of the account, then the user is forced to change the easypaysy identifier?
> > My initial reading of your whitepaper is that the easypaysy identifier refers to the funding txo that roots the further control transactions.
> > If so, the funding txo is not necessarily a one-input two-output transaction.
>
> The easypaysy identifier doesn?t point to the funding TXO. Instead it points to the first transaction that spends the funding TXO (the TX with the OP_RETURN containing the ?Rendezvous descriptor?)

Ah, I see my misunderstanding now.

Regards,
ZmnSCPXj

From ZmnSCPxj at protonmail.com  Sun Dec  8 01:15:51 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 08 Dec 2019 01:15:51 +0000
Subject: [bitcoin-dev] Composable MuSig
In-Reply-To: <CAH5Bsr07ZxxneRngGO=C56qODxu7FQ3r1c7NmcXYY3BZ2VEokA@mail.gmail.com>
References: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>
 <CAH5Bsr2rsiU9gV6VsGH3ZCWGRoTz=g5hXNq37P3P6HB+MmxUAA@mail.gmail.com>
 <tvK5ZI4GmQzBkGfcYFOaUI4kgLBv7N615LV-yvyUOeYU49Ig2krXbyPOrTSwiiYNZpPYNv6GtLrSRTQf_MRwqmYeXY1VTLzinq93wNW9ex8=@protonmail.com>
 <CAH5Bsr07ZxxneRngGO=C56qODxu7FQ3r1c7NmcXYY3BZ2VEokA@mail.gmail.com>
Message-ID: <5JbfLKwbVsIev2M33s366qbyuAGqz-ydB4gZ2KTFR_nCWbgZ0vWMm5UOU19jNVeMfYD3A0GPTpbuuYINwOv_F6fJS3NdxuPgMm8hGUnjbB0=@protonmail.com>

Good morning Lloyd,

> The real
> question is what properties does the commitment scheme need to be
> appropriate for MuSig R coin tossing?

It seems to me that what is needed for a composable MuSig is to have a commitment scheme which is composable.

Let me define a composable commitment scheme:

Given:

* `A` and `B`, two points to be committed to.
* `c[A]` and `c[B]`, commitments to the above points respectively.
* `r[A]` and `r[B]`, openings of the above commitments respectively.

Then a composable commitment scheme must have these operations:

* `ComposeCommitments(c[A], c[B])`, which returns a commitment to the point `A + B`.
* `ComposeOpenings(r[A], r[B])`, which returns an opening of the above commitment to the point `A + B`.

My multi-`R` proposal is a composable commitment scheme:

* A commitment `c[A]` is the list `{h(A)}` where `h()` is some hash function.
* `ComposeCommitments(c[A], c[B])` is the concatenation on lists of hashes of points.
* An opening `r[A]` is the list `{A}`.
* `ComposeOpenings(r[A], r[B])` is the concatenation on lists of points.

The property we want to have, is that:

* There must not exist some operation `NegateCommitment(c[A])`, such that:
  * `ComposeCommitments(ComposeCommitments(c[B], NegateCommitment(c[A])), c[A]) == c[B]`.

My multi-`R` proposal works as a composable commitment scheme appropriate for composable MuSig because there is no way to create an input to a concatenation operation such that the concatenation operation becomes a "search and delete" operation.
Pedersen and ElGamal commitments, I think, cannot work here, because commitments in those schemes are negatable in such a way that composing the commitments allows a commitment to be cancelled.

-----

Let us now turn to signature schemes.
I conjecture that the Schnorr and ECDSA signature schemes are also commitment schemes on points.

To create a commitment `c[A]` on the point A, such that `A = a * G`, the committer:

* Generates random scalars `r` and `m`.
* Computes `R` as `r * G`.
* Computes `s` as `r + h(R | m) * a`.
* Gives `c[A]` as the tuple `(R, s)`.

The opening `r[A]` of the above is then the tuple `(m, A)`.
The verifier then validates that the commitment was indeed to the point `A` by doing the below:

* Computes `S[validator]` as `R + h(R | m) * A`.
* Validates that `S[validator] == s * G`.

Now, we know that signatures can be composed in such a way that points (public keys) cannot be cancelled, i.e. preventing the creation of a `NegateCommitment()` operation.
Thus, a signature can be used as a composable commitment in composable MuSig scheme.

In summary, I conjecture that:

* We need a composable commitment scheme that does not allow cancellation, and any such commitment scheme can be "slotted" into the 3-phase MuSig framework.

Regards,
ZmnSCPxj


From jose.femenias at gmail.com  Fri Dec  6 18:47:38 2019
From: jose.femenias at gmail.com (=?utf-8?Q?Jose_Femen=C3=ADas_Ca=C3=B1uelo?=)
Date: Fri, 6 Dec 2019 19:47:38 +0100
Subject: [bitcoin-dev] easypaysy - A layer-two protocol to send payments
 without addresses
In-Reply-To: <Qul4dCoKs2JEQgCYkvdn_QYjgQ5ucpwHZCHdU7qOZ5DGYOGB7p37-s7GN6Jg_NKDzsLlGv-WkOU_mY-a1A_tygRlnhOVnJBK9nvAJ3Gs-bE=@protonmail.com>
References: <E70934BE-E7BE-4035-BBFF-47005E25C441@gmail.com>
 <fBhj5XmKd7-1Bk13TuSLkwYGGgbvdVUbSr-dOjJk9pe0cb6CdLPhCUgbIDFyCv6ua2yJJc2lpn-IX42jN2MH8FGex7oqlxb2t-UKIUjPYrA=@protonmail.com>
 <AF3AF268-8E5B-481E-A5C7-205D171E90A5@gmail.com>
 <Qul4dCoKs2JEQgCYkvdn_QYjgQ5ucpwHZCHdU7qOZ5DGYOGB7p37-s7GN6Jg_NKDzsLlGv-WkOU_mY-a1A_tygRlnhOVnJBK9nvAJ3Gs-bE=@protonmail.com>
Message-ID: <6CB7E73C-57C9-428B-83E6-36113B619BFB@gmail.com>

Hi ZmnSCPxj,


>> It seems possible, that, I do not.

Haha, I?am starting to believe that?s not a joke ...


>> 
>> This does not seem to mesh well with the other non-Master parts of the protocol, where further updates on the single account backed by a funding TXO are performed by spending the funding TXO and creating a transaction with `OP_RETURN`.
>> 
>> 


You are right. The lifecycle of a regular easypaysy account states that you spend its TXO circularly as many times as you want, specifying changes in its OP_RETURN (you can?t change the Identity or Value key).
When you want to revoke an account, you simply spend its last update (if any) to a different address (not the one it was funded originally with).


> How about control transactions on top of the funding txo?
> Who is able to make further control transactions?
> If the service provider gives the user full control of the control transactions on top of the funding txo, then it outright loses the money it put in the funding txo and might as well operate as a full exchange.

Nope, he will keep control of the TXO keys.


> If the service provider retains even partial control, then it can refuse to cooperate with the user and the user will be unable to update his or her account.
> 
> This is not fixable by the use of mirror servers.

You are right about that too? (I wonder if some kind of MAST smart contract could fix this, maybe you have a suggestion for this; I am thinking K of M users can override the service provider if he misbehaves)

What I have in mind, but haven?t completely figured out, in case of an uncooperative service provider -or just because one user decides to fly solo- is the possibility for a sub-account to ?detach? itself from the master account.

The sub-account holder would do so by:

a) Funding the multisig 2-of-2 address composed of his Id_key + Value_key, included in the common JSON file, not the Master TX. (And yes, in this event he will need to buy some btc, because life is hard...)
b) Publishing his own update, much like a regular easypaysy account does.

In any case, the account ID never changes, it would always keep pointing to the original place where it appeared on the blockchain. 
User wallets would have to query for the multisig address of a particular account to check whether the account is detached or not.

As as side note, I expect most easypaysy accounts to choose only non-interactive payments, since they have fewer requirements than their interactive counterparts; so -in most cases- the majority of users won?t ever have to update their accounts.

So, even if the ?service provider? goes away or becomes uncooperative, it is just business as usual for the sub-account owners, and they can work just fine with the mirrors.

(Again, all of these is speculative for now. I hope scalability will become an issue for easypaysy one day, but I think we?ll have time to work out the best solution by then)



>> In addition, I would like to suggest as well that instead of `OP_RETURN`, you could instead use "sign-to-contract??.

I really need to study this further before I can express an informed opinion on your suggestion.

On the other hand, for Master accounts I don?t think cost or space should be a problem, since both can be shared among up to 2048 sub-accounts.
For regular accounts, it could be.

But, based on the private feedback I am having from two prominent figures in the space, making sure the protocol is easy to implement for SPV wallets is essential to encourage wallet adoption.
A separate transport layer doesn?t fit well with this. 

So, maybe your suggestion will become more applicable in future iterations of the protocol. I may request your help for further clarification about this issue, if you are so kind (as you always are).


>> d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).
> 
> Do you mean, that if the user makes a control transaction to change the details of the account, then the user is forced to change the easypaysy identifier?
> 
> My initial reading of your whitepaper is that the easypaysy identifier refers to the funding txo that roots the further control transactions.
> If so, the funding txo is not necessarily a one-input two-output transaction.
> 

The easypaysy identifier doesn?t point to the funding TXO. Instead it points to the first transaction that spends the funding TXO (the TX with the OP_RETURN containing the ?Rendezvous descriptor?)
So, you are right in that the funding TXO doesn?t need to be a one-input, two-output transaction.

> If not, then each time a control transaction changes the details of the easypaysy identifier, the identifier itself is changed.

Nope. The easypaysy identifier always points the placement in the blockchain of the first transaction that spends the funding TXO, not the TXO itself (please read page 3, ?2.3 Account ID?).
Further updates (performed by spending its single non-zero output to the same address) must be verified by wallets (by asking for the payment history of the funding address; but they never change the account ID, by convention).

So, for example, (I?m following the example in page 13 of the white paper):

a) TX #3b00367?4af, in block 859253, that has j outputs and k outputs, has an output (k) that sends funds to the 2-of-2 multisig address ?3NhgE9?bqs?. 
   This is the address that the Identity_key + Value_key can spend.

b) Several blocks later, TX #2a01fe?aab2, in its single input, spends the TXO with another TXO the same address ?3NhgE9?bqs?. 
   It sends all of the funds (minus the fee) in its first output (the 2nd is the OP_RETURN).
   This TX (called the ep_root_tx in the protocol) appears in block 859368 at, let?s say position 349. So its permanent ID will be (obviating the checksum): 
   
   btc at 859368.349

   This is the ID you share with your potential payers. Whenever they want to send funds to you, they will look up the 349th transaction at block 859368. 
   They don?t need to check the funding TX at all. They only have to check the signature of the ep_root_tx, because that?s the part of the TX where they can find both the Identity_key and the Value_key.
   Since this TX, by definition of the protocol, can only have a single input, there will be a single signature in it, so there is no need for its easypaysy ID to include a pointer to the input in the TX.


c) A few more blocks later, appears TX #72f1ed?bade8 a similar 1-input 2-output TX, that updates its OP_RETURN with a new ?Rendezvous descriptor? (in the example, it changes the email endpoint)
d) Finally, the user revokes the account by spending the output in c) to a different address (17He...A45n).


>> If you are interested, please contact me, preferably privately since I wouldn?t want to become much too off topic in this dev-list
> 
> I still do not see why it would be off-topic to the devlist.

Since the easypaysy proposal is about a layer-2 protocol, I am not sure the developers in this list want to see this much detail about something that maybe doesn?t affect them at all.
Hopefully I am wrong and this is relevant for many of the list subscribers.

Again, thanks for your time and contributions.

Best regards,

Jose


> On 6 Dec 2019, at 18:16, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Jose,
> 
>> Hi ZmnSCPxj,
>> 
>> first of all: do you ever sleep? ;-)
> 
> It seems possible, that, I do not.
> 
> 
>> b) Master accounts are included in the white paper as a feature for a future release.
>> The roadmap is not set yet, but I?d like to include a first release of the protocol that only covers the most basic features, to make it simpler and safer for wallet developers.
>> Master accounts aren?t a priority, since they are more oriented towards scaling the proposal, and that is far from being a problem yet.
>> So, this feature is not well defined for now. However, as presented in the white paper, the ?service provider? has really no control over your money.
>> 
>> He would basically do a just a few things:
>> 
>> -   Aggregate the account info (up to 2048 individual accounts per master account).
>> -   Hash every account info, sort them, and calculate the Merkle root of a tree containing them all.
>> -   Create a JSON document containing the information of all the sub-accounts included in the pack.
>> -   Make that JSON document publicly available, probably with a https: URL (That?s called an Authoritative server)
>> -   Finally, create and publish a TX that contains a pointer to the Authoritative server, and the Merkle root of the set of accounts.
>> 
>>    The service provider would have NO control whatsoever of your funds, nor can he block payments, etc.
>>    There is some sort of delegation, but no trust involved here. The Merkle root protects agains any attempt of tampering with the account data.
> 
> This does not seem to mesh well with the other non-Master parts of the protocol, where further updates on the single account backed by a funding TXO are performed by spending the funding TXO and creating a transaction with `OP_RETURN`.
> 
> In addition, I would like to suggest as well that instead of `OP_RETURN`, you could instead use "sign-to-contract".
> 
> Sign-to-contract is simply that, when signing, instead of selecting a random `r` and computing `R` as `R = r * G`, you select a random `r` and a contract or other message `c`, and compute `R` as `R = r * G + h((r * G) | c) * G`.
> Then the user can provide the message `c` independently of the signature, via another mechanism, and reveal `r * G` and `c` and point to the signature as a commitment to the message `c`.
> Although, it does have the drawback that using sign-to-contract require a different layer / overlay network to broadcast messages `c`, but it does reduce the cost on the blockchain layer, which is always a good thing.
> Similar issues are faced by the RGB project, for instance, and defiads explicitly uses a separate overlay network when transmitting advertisements (both RGB and defiads use the opposite pay-to-contract, which tweaks the pubkey rather than the ephemeral `R`).
> 
>> 
>>    The account?s TX won?t ever disappear from the blockchain, so your account info will always be there.
>>    Worst case scenario, the service provider disappears and users can?t download the Json document containing your account information.
>> 
>>    To mitigate this issue, the white paper suggests the creation of mirror servers.
> 
> How about control transactions on top of the funding txo?
> Who is able to make further control transactions?
> If the service provider gives the user full control of the control transactions on top of the funding txo, then it outright loses the money it put in the funding txo and might as well operate as a full exchange.
> If the service provider retains even partial control, then it can refuse to cooperate with the user and the user will be unable to update his or her account.
> 
> This is not fixable by the use of mirror servers.
> 
> 
>> d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).
> 
> Do you mean, that if the user makes a control transaction to change the details of the account, then the user is forced to change the easypaysy identifier?
> 
> My initial reading of your whitepaper is that the easypaysy identifier refers to the funding txo that roots the further control transactions.
> If so, the funding txo is not necessarily a one-input two-output transaction.
> If not, then each time a control transaction changes the details of the easypaysy identifier, the identifier itself is changed.0
> 
> 
>> If you are interested, please contact me, preferably privately since I wouldn?t want to become much too off topic in this dev-list
> 
> I still do not see why it would be off-topic to the devlist.
> 
> Regards,
> ZmnSCPxj



> On 6 Dec 2019, at 18:16, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> Good morning Jose,
> 
>> Hi ZmnSCPxj,
>> 
>> first of all: do you ever sleep? ;-)
> 
> It seems possible, that, I do not.
> 
> 
>> b) Master accounts are included in the white paper as a feature for a future release.
>> The roadmap is not set yet, but I?d like to include a first release of the protocol that only covers the most basic features, to make it simpler and safer for wallet developers.
>> Master accounts aren?t a priority, since they are more oriented towards scaling the proposal, and that is far from being a problem yet.
>> So, this feature is not well defined for now. However, as presented in the white paper, the ?service provider? has really no control over your money.
>> 
>> He would basically do a just a few things:
>> 
>> -   Aggregate the account info (up to 2048 individual accounts per master account).
>> -   Hash every account info, sort them, and calculate the Merkle root of a tree containing them all.
>> -   Create a JSON document containing the information of all the sub-accounts included in the pack.
>> -   Make that JSON document publicly available, probably with a https: URL (That?s called an Authoritative server)
>> -   Finally, create and publish a TX that contains a pointer to the Authoritative server, and the Merkle root of the set of accounts.
>> 
>>    The service provider would have NO control whatsoever of your funds, nor can he block payments, etc.
>>    There is some sort of delegation, but no trust involved here. The Merkle root protects agains any attempt of tampering with the account data.
> 
> This does not seem to mesh well with the other non-Master parts of the protocol, where further updates on the single account backed by a funding TXO are performed by spending the funding TXO and creating a transaction with `OP_RETURN`.
> 
> In addition, I would like to suggest as well that instead of `OP_RETURN`, you could instead use "sign-to-contract".
> 
> Sign-to-contract is simply that, when signing, instead of selecting a random `r` and computing `R` as `R = r * G`, you select a random `r` and a contract or other message `c`, and compute `R` as `R = r * G + h((r * G) | c) * G`.
> Then the user can provide the message `c` independently of the signature, via another mechanism, and reveal `r * G` and `c` and point to the signature as a commitment to the message `c`.
> Although, it does have the drawback that using sign-to-contract require a different layer / overlay network to broadcast messages `c`, but it does reduce the cost on the blockchain layer, which is always a good thing.
> Similar issues are faced by the RGB project, for instance, and defiads explicitly uses a separate overlay network when transmitting advertisements (both RGB and defiads use the opposite pay-to-contract, which tweaks the pubkey rather than the ephemeral `R`).
> 
>> 
>>    The account?s TX won?t ever disappear from the blockchain, so your account info will always be there.
>>    Worst case scenario, the service provider disappears and users can?t download the Json document containing your account information.
>> 
>>    To mitigate this issue, the white paper suggests the creation of mirror servers.
> 
> How about control transactions on top of the funding txo?
> Who is able to make further control transactions?
> If the service provider gives the user full control of the control transactions on top of the funding txo, then it outright loses the money it put in the funding txo and might as well operate as a full exchange.
> If the service provider retains even partial control, then it can refuse to cooperate with the user and the user will be unable to update his or her account.
> 
> This is not fixable by the use of mirror servers.
> 
> 
>> d) Regarding your comments on the possibility of adding the output index in the account ID, I still don?t see the need for the use case of easypaysy (since, by definition, easypaysy accounts must have exactly one input and two outputs).
> 
> Do you mean, that if the user makes a control transaction to change the details of the account, then the user is forced to change the easypaysy identifier?
> 
> My initial reading of your whitepaper is that the easypaysy identifier refers to the funding txo that roots the further control transactions.
> If so, the funding txo is not necessarily a one-input two-output transaction.
> If not, then each time a control transaction changes the details of the easypaysy identifier, the identifier itself is changed.0
> 
> 
>> If you are interested, please contact me, preferably privately since I wouldn?t want to become much too off topic in this dev-list
> 
> I still do not see why it would be off-topic to the devlist.
> 
> Regards,
> ZmnSCPxj
> 


From lloyd.fourn at gmail.com  Sun Dec  8 06:10:00 2019
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Sun, 8 Dec 2019 17:10:00 +1100
Subject: [bitcoin-dev] Composable MuSig
In-Reply-To: <5JbfLKwbVsIev2M33s366qbyuAGqz-ydB4gZ2KTFR_nCWbgZ0vWMm5UOU19jNVeMfYD3A0GPTpbuuYINwOv_F6fJS3NdxuPgMm8hGUnjbB0=@protonmail.com>
References: <u1IeyK5A7zyklXzl26UpCliJrFEsDp5SXUGbtXGBCrEWw6Wi7vNcoy4HNv2WXUTG_SBuMURDLhvh3YCwL2r53rL0Yj19TZpumYFD5WqmYL8=@protonmail.com>
 <CAH5Bsr2rsiU9gV6VsGH3ZCWGRoTz=g5hXNq37P3P6HB+MmxUAA@mail.gmail.com>
 <tvK5ZI4GmQzBkGfcYFOaUI4kgLBv7N615LV-yvyUOeYU49Ig2krXbyPOrTSwiiYNZpPYNv6GtLrSRTQf_MRwqmYeXY1VTLzinq93wNW9ex8=@protonmail.com>
 <CAH5Bsr07ZxxneRngGO=C56qODxu7FQ3r1c7NmcXYY3BZ2VEokA@mail.gmail.com>
 <5JbfLKwbVsIev2M33s366qbyuAGqz-ydB4gZ2KTFR_nCWbgZ0vWMm5UOU19jNVeMfYD3A0GPTpbuuYINwOv_F6fJS3NdxuPgMm8hGUnjbB0=@protonmail.com>
Message-ID: <CAH5Bsr1rdbTw16+FVo0NC0zqv3EDHmEd=ef7k3baLaQ+HMn2Cg@mail.gmail.com>

Hi ZmnSCPxj,

I think you're idea of allowing multiple Rs is a fine solution as it
would essentially mean that you were just doing a three party MuSig
with more specific communication structure. As you mentioned, this is
not quite ideal though.

> It seems to me that what is needed for a composable MuSig is to have a commitment scheme which is composable.

Maybe. Showing certain attacks don't work is a first step. It would
take some deeper analysis of the security model to figure out what
exactly the MuSig requires of the commitment scheme.

> To create a commitment `c[A]` on the point A, such that `A = a * G`, the committer:
>
> * Generates random scalars `r` and `m`.
> * Computes `R` as `r * G`.
> * Computes `s` as `r + h(R | m) * a`.
> * Gives `c[A]` as the tuple `(R, s)`.

This doesn't look binding. It's easy to find another ((A,a),m) which
would validate against (R,s). Just choose m and choose a = (s - r)
h(R||m)^-1.

Cheers,

LL

From cheng at alephium.org  Sun Dec  8 10:43:49 2019
From: cheng at alephium.org (Cheng Wang)
Date: Sun, 8 Dec 2019 11:43:49 +0100
Subject: [bitcoin-dev] Reducing energy consumption and increasing security
	at the same time
Message-ID: <CAJgZxF4G_BjJ=OhuzhjfZtkePnEc2hz8DMZzFzWKBNh17XhBeQ@mail.gmail.com>

Hi Everyone,

I would like to share my serious work on reducing the energy consumption of
PoW without sacrificing security. My new type of algorithm is called PoLW.
For a practical system where mining is profitable, PoLW could actually
improve the security of the system.

The idea is to shift part of the external cost of mining in the physical
world (mainly energy consumption) to the internal cost of the network. In
PoLW, the miners are able to give up part of the coinbase reward so as to
get weight (> 1) for the block hash they produce. The total cost of
generating a new block would still be equal to maximal coinbase reward in
equilibrium.

I analyzed two algorithms in the paper: linear PoLW and exponential PoLW.
Linear PoLW could reduce energy consumption by a factor close to 1/2 in
equilibrium, while exponential PoLW could reduce energy consumption by an
arbitrary factor in equilibrium.

In a practical system, mining is usually (if not always) profitable. If we
transition from PoW to PoLW, the external costs of mining would decrease
and the internal costs will increase. However, the decrease in external
costs would be less than the increase in internal costs since mining is
profitable. The total cost of block generation would get higher, therefore,
the security will increase.

Of course, we could not decrease the external costs of any existing system
by a factor close to zero immediately. There is a section in my paper
discussing this particularly. The principle of applying PoLW is that
keeping the absolute external cost increasing all the time, but the
percentage of external cost in the total cost gets lower eventually.

This work is based on solid math calculation, and I am looking forward to
feedback and discussions. My paper is available at:
https://github.com/alephium/research/raw/master/polw.pdf

It's inspired by the recent great paper of Itay, Alexander, and Ittay:
https://arxiv.org/abs/1911.04124

Best,
Cheng Wang
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191208/023a43f6/attachment-0001.html>

From runchao.han at monash.edu  Mon Dec  9 00:45:27 2019
From: runchao.han at monash.edu (Runchao Han)
Date: Mon, 9 Dec 2019 11:45:27 +1100
Subject: [bitcoin-dev] Reducing energy consumption and increasing
	security	at the same time
In-Reply-To: <mailman.3482.1575825776.25512.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.3482.1575825776.25512.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <29C07E1A-DC6B-49F0-893B-A59E7BD8DB1C@monash.edu>

Hi Cheng,

This is an interesting proposal!
While the incentive analysis is sound, I have two concerns:

## What if a guy keeps mining easy blocks to launch 51% attacks?

With PoLW, a miner can sacrifice the coinbase reward as much as possible to mine blocks faster.
If the blockchain follows the longest chain rule, PoLW may make 51% attacks much easier.
An easy way of fixing this is to choose the chain with most work rather than most blocks.

## What if the coinbase tx is no longer the majority of mining reward, but the fx fee?

This might happen in the future.
A possible solution is to limit the number of txs for easy blocks.
For example, if a miner chooses to mine blocks N times easier, he can only include txs of which the total size is <= (block_size - metadata_size) / N.

Best regards,
Runchao

> Date: Sun, 8 Dec 2019 11:43:49 +0100
> From: Cheng Wang <cheng at alephium.org>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] Reducing energy consumption and increasing
> 	security	at the same time
> Message-ID:
> 	<CAJgZxF4G_BjJ=OhuzhjfZtkePnEc2hz8DMZzFzWKBNh17XhBeQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
> 
> Hi Everyone,
> 
> I would like to share my serious work on reducing the energy consumption of
> PoW without sacrificing security. My new type of algorithm is called PoLW.
> For a practical system where mining is profitable, PoLW could actually
> improve the security of the system.
> 
> The idea is to shift part of the external cost of mining in the physical
> world (mainly energy consumption) to the internal cost of the network. In
> PoLW, the miners are able to give up part of the coinbase reward so as to
> get weight (> 1) for the block hash they produce. The total cost of
> generating a new block would still be equal to maximal coinbase reward in
> equilibrium.
> 
> I analyzed two algorithms in the paper: linear PoLW and exponential PoLW.
> Linear PoLW could reduce energy consumption by a factor close to 1/2 in
> equilibrium, while exponential PoLW could reduce energy consumption by an
> arbitrary factor in equilibrium.
> 
> In a practical system, mining is usually (if not always) profitable. If we
> transition from PoW to PoLW, the external costs of mining would decrease
> and the internal costs will increase. However, the decrease in external
> costs would be less than the increase in internal costs since mining is
> profitable. The total cost of block generation would get higher, therefore,
> the security will increase.
> 
> Of course, we could not decrease the external costs of any existing system
> by a factor close to zero immediately. There is a section in my paper
> discussing this particularly. The principle of applying PoLW is that
> keeping the absolute external cost increasing all the time, but the
> percentage of external cost in the total cost gets lower eventually.
> 
> This work is based on solid math calculation, and I am looking forward to
> feedback and discussions. My paper is available at:
> https://github.com/alephium/research/raw/master/polw.pdf
> 
> It's inspired by the recent great paper of Itay, Alexander, and Ittay:
> https://arxiv.org/abs/1911.04124
> 
> Best,
> Cheng Wang

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191209/b61d37f6/attachment.html>

From cheng at alephium.org  Mon Dec  9 09:47:49 2019
From: cheng at alephium.org (Cheng Wang)
Date: Mon, 9 Dec 2019 10:47:49 +0100
Subject: [bitcoin-dev] Reducing energy consumption and increasing
 security at the same time
In-Reply-To: <29C07E1A-DC6B-49F0-893B-A59E7BD8DB1C@monash.edu>
References: <mailman.3482.1575825776.25512.bitcoin-dev@lists.linuxfoundation.org>
 <29C07E1A-DC6B-49F0-893B-A59E7BD8DB1C@monash.edu>
Message-ID: <CAJgZxF4HMPf_Gmwd+KBZbsC7Yt+WdmcoF-Nfi9hF4oX8OBRKQA@mail.gmail.com>

Hi Runchao,

- 1st question regarding double spending:

We won't allow a miner to sacrifice coinbase reward as much as possible for
a practical system. This will be achieved by setting a dynamic upper bound
for the number of rewards the miner could sacrifice. The upper bound would
be related to the actual mining difficulty (not the weighted one) of the
recent mining epoch.

In Section 8 of the paper, I discussed quite a lot about how to select
system parameters and how to transition the current PoW systems to PoLW.
Just for an example, for Bitcoin, we might transition from giving up 0
coinbase reward to giving up maximal 10% coinbase reward. In the long term,
if the value of Bitcoin goes as comparable to gold, we could allow the
miners to give up more rewards. The network could adjust these bounds
solely based on the internal state (i.e. the actual mining difficulty).

In short, PoLW could reduce the energy consumption of Bitcoin in
equilibrium from coinbase reward to even sub-linear. Still, the absolute
energy consumption would be kept at a sufficiently high level.

- 2nd question regarding tx fees:

We could simply reduce this problem to purely coinbase reward by adding tx
fees into the maximal coinbase reward. When the tx fees dominant miner's
profits, we could simply allow negative coinbase reward (i.e. miners spend
coins for the coinbase transaction).

Note that, using PoLW, we could remove the halving mechanism, as PoLW is
adaptive already.

Best, Cheng!

On Mon, Dec 9, 2019 at 1:45 AM Runchao Han <runchao.han at monash.edu> wrote:

> Hi Cheng,
>
> This is an interesting proposal!
> While the incentive analysis is sound, I have two concerns:
>
> ## What if a guy keeps mining easy blocks to launch 51% attacks?
>
> With PoLW, a miner can sacrifice the coinbase reward as much as possible
> to mine blocks faster.
> If the blockchain follows the longest chain rule, PoLW may make
> 51% attacks much easier.
> An easy way of fixing this is to choose the chain with most work rather
> than most blocks.
>
> ## What if the coinbase tx is no longer the majority of mining reward, but
> the fx fee?
>
> This might happen in the future.
> A possible solution is to limit the number of txs for easy blocks.
> For example, if a miner chooses to mine blocks N times easier, he can only
> include txs of which the total size is <= (block_size - metadata_size) / N.
>
> Best regards,
> Runchao
>
> Date: Sun, 8 Dec 2019 11:43:49 +0100
> From: Cheng Wang <cheng at alephium.org>
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] Reducing energy consumption and increasing
> security at the same time
> Message-ID:
> <CAJgZxF4G_BjJ=OhuzhjfZtkePnEc2hz8DMZzFzWKBNh17XhBeQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> Hi Everyone,
>
> I would like to share my serious work on reducing the energy consumption of
> PoW without sacrificing security. My new type of algorithm is called PoLW.
> For a practical system where mining is profitable, PoLW could actually
> improve the security of the system.
>
> The idea is to shift part of the external cost of mining in the physical
> world (mainly energy consumption) to the internal cost of the network. In
> PoLW, the miners are able to give up part of the coinbase reward so as to
> get weight (> 1) for the block hash they produce. The total cost of
> generating a new block would still be equal to maximal coinbase reward in
> equilibrium.
>
> I analyzed two algorithms in the paper: linear PoLW and exponential PoLW.
> Linear PoLW could reduce energy consumption by a factor close to 1/2 in
> equilibrium, while exponential PoLW could reduce energy consumption by an
> arbitrary factor in equilibrium.
>
> In a practical system, mining is usually (if not always) profitable. If we
> transition from PoW to PoLW, the external costs of mining would decrease
> and the internal costs will increase. However, the decrease in external
> costs would be less than the increase in internal costs since mining is
> profitable. The total cost of block generation would get higher, therefore,
> the security will increase.
>
> Of course, we could not decrease the external costs of any existing system
> by a factor close to zero immediately. There is a section in my paper
> discussing this particularly. The principle of applying PoLW is that
> keeping the absolute external cost increasing all the time, but the
> percentage of external cost in the total cost gets lower eventually.
>
> This work is based on solid math calculation, and I am looking forward to
> feedback and discussions. My paper is available at:
> https://github.com/alephium/research/raw/master/polw.pdf
>
> It's inspired by the recent great paper of Itay, Alexander, and Ittay:
> https://arxiv.org/abs/1911.04124
>
> Best,
> Cheng Wang
>
>
>

-- 
Cheng Wang
# Love math and coding
# Founder of Alephium; Proposed BlockFlow algorithm
# Proposed the first linear-time asynchronous Byzantine consensus algorithm
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191209/b39d6158/attachment.html>

From pieter.wuille at gmail.com  Mon Dec  9 22:31:13 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 9 Dec 2019 14:31:13 -0800
Subject: [bitcoin-dev] Analysis of Bech32 swap/insert/delete detection and
	next steps
Message-ID: <CAPg+sBgdspmfK1qpG=9N9fAtVNkMDd+xym7yHdjq=zYnqeh5dA@mail.gmail.com>

Hi all,

I've made a writeup on Bech32's detection abilities, analysing how it
behaves in the presence of not just substitution errors, but also
swapping of characters, and insertions and deletions:
https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb

It shows that the "insert or delete a 'q' right before a final 'p'" is
in fact the only deviation from the expected at-most-1-in-a-billion
failure to detect chance, at least when restricted to the classes of
errors analyzed with various uniformity assumptions. There is some
future work left, such as analyzing combinations of insertions and
substitutions, but I would be surprising if additional weaknesses
exist there.

It also shows that changing one constant in Bech32 would resolve this
issue, while not affecting the error detection properties for other
classes of errors.

So my suggestion for the next steps are:
* Update BIP173 to include the insertion weakness as an erratum, and
the results of this analysis.
* Amend segwit addresses (either by amending BIP173, or by writing a
short updated BIP to modify it) to be restricted to only length 20 or
32 (as fixed-length strings are unaffected by the insertion issue, and
I don't think inserting 20 characters is an interesting error class).
* Define a variant of Bech32 with the modified constant, so that
non-BIP173 uses of Bech32 can choose a non-impacted version if they
worry about this class of errors.
* Later, if and when we expect a need for non-32-byte witness programs
in the medium term, define an updated segwit address scheme that uses
the modified Bech32 variant.

I believe that the impact on production systems will be minimal using
the above, as many wallets already do not accept unknown witness
versions in outputs, and it gives us probably years to adapt.

What do people think?

Cheers,

-- 
Pieter

From ZmnSCPxj at protonmail.com  Tue Dec 10 01:50:38 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 10 Dec 2019 01:50:38 +0000
Subject: [bitcoin-dev] Analysis of Bech32 swap/insert/delete detection
	and next steps
In-Reply-To: <CAPg+sBgdspmfK1qpG=9N9fAtVNkMDd+xym7yHdjq=zYnqeh5dA@mail.gmail.com>
References: <CAPg+sBgdspmfK1qpG=9N9fAtVNkMDd+xym7yHdjq=zYnqeh5dA@mail.gmail.com>
Message-ID: <2YyEOYXhcEvfGJLUX4zswzSpBA0vWOC_Jwl_MOcphySLZqjfBDqqDkBvZB6kX7nvVsGNPqwuh63lgBGO5BcURaig2r5tqxFoaEZTLDMTG7U=@protonmail.com>

Good morning Pieter,

> Hi all,
>
> I've made a writeup on Bech32's detection abilities, analysing how it
> behaves in the presence of not just substitution errors, but also
> swapping of characters, and insertions and deletions:
> https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb
>
> It shows that the "insert or delete a 'q' right before a final 'p'" is
> in fact the only deviation from the expected at-most-1-in-a-billion
> failure to detect chance, at least when restricted to the classes of
> errors analyzed with various uniformity assumptions. There is some
> future work left, such as analyzing combinations of insertions and
> substitutions, but I would be surprising if additional weaknesses
> exist there.
>
> It also shows that changing one constant in Bech32 would resolve this
> issue, while not affecting the error detection properties for other
> classes of errors.
>
> So my suggestion for the next steps are:
>
> -   Update BIP173 to include the insertion weakness as an erratum, and
>     the results of this analysis.
>

To clarify, this step does not modify anything about the implementation of BIP173, only adds this as an additional erratum section?

> -   Amend segwit addresses (either by amending BIP173, or by writing a
>     short updated BIP to modify it) to be restricted to only length 20 or
>     32 (as fixed-length strings are unaffected by the insertion issue, and
>     I don't think inserting 20 characters is an interesting error class).

To clarify, this refers to all SegWit address versions from 1 to 15, as this restriction exists for SegWit address v0?

>
> -   Define a variant of Bech32 with the modified constant, so that
>     non-BIP173 uses of Bech32 can choose a non-impacted version if they
>     worry about this class of errors.
>

Okay, this probably needs to be raised in lightning-dev as well, for invoice formats, as well as planned offers feature.

By my understanding, best practice for readers of Bech32-based formats would be something like the below:

1.  Define two variants of checksum, the current Bech32 checksum and the modified Bech32 checksum.
2.  Support both variants (software tries one first, then tries the other if it fails).
3.  Flag or signal some deprecation warning if current Bech32 checksum was detected.
4.  At some undefined point in the future, drop support for the current Bech32 checksum.

> -   Later, if and when we expect a need for non-32-byte witness programs
>     in the medium term, define an updated segwit address scheme that uses
>     the modified Bech32 variant.


Okay, so we will only use the modified Bech32 if and only if we expect to need a non-32-byte witness program for a particular non-0 SegWit version.


Regards,
ZmnSCPxj

From pieter.wuille at gmail.com  Tue Dec 10 06:36:20 2019
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Mon, 9 Dec 2019 22:36:20 -0800
Subject: [bitcoin-dev] Analysis of Bech32 swap/insert/delete detection
 and next steps
In-Reply-To: <2YyEOYXhcEvfGJLUX4zswzSpBA0vWOC_Jwl_MOcphySLZqjfBDqqDkBvZB6kX7nvVsGNPqwuh63lgBGO5BcURaig2r5tqxFoaEZTLDMTG7U=@protonmail.com>
References: <CAPg+sBgdspmfK1qpG=9N9fAtVNkMDd+xym7yHdjq=zYnqeh5dA@mail.gmail.com>
 <2YyEOYXhcEvfGJLUX4zswzSpBA0vWOC_Jwl_MOcphySLZqjfBDqqDkBvZB6kX7nvVsGNPqwuh63lgBGO5BcURaig2r5tqxFoaEZTLDMTG7U=@protonmail.com>
Message-ID: <CAPg+sBhXrJYYLFKRZJmKe+21p9zn7ah54e36A_EpXLWO8Q+XeA@mail.gmail.com>

> > So my suggestion for the next steps are:
> >
> > -   Update BIP173 to include the insertion weakness as an erratum, and
> >     the results of this analysis.
> >
>
> To clarify, this step does not modify anything about the implementation of BIP173, only adds this as an additional erratum section?

Correct - just documenting the issue.

> > -   Amend segwit addresses (either by amending BIP173, or by writing a
> >     short updated BIP to modify it) to be restricted to only length 20 or
> >     32 (as fixed-length strings are unaffected by the insertion issue, and
> >     I don't think inserting 20 characters is an interesting error class).
>
> To clarify, this refers to all SegWit address versions from 1 to 15, as this restriction exists for SegWit address v0?

Right, for v0 there is an inherent restriction to size 20 or 32
already, so this would only semantically change anything for version 1
through 16 (not 15).

> > -   Define a variant of Bech32 with the modified constant, so that
> >     non-BIP173 uses of Bech32 can choose a non-impacted version if they
> >     worry about this class of errors.
> >
>
> Okay, this probably needs to be raised in lightning-dev as well, for invoice formats, as well as planned offers feature.

It seems BOLT11 already doesn't care very much about the error
detection properties, as it's using Bech32 outside its design
parameters (max length 90 characters).

> By my understanding, best practice for readers of Bech32-based formats would be something like the below:
>
> 1.  Define two variants of checksum, the current Bech32 checksum and the modified Bech32 checksum.
> 2.  Support both variants (software tries one first, then tries the other if it fails).
> 3.  Flag or signal some deprecation warning if current Bech32 checksum was detected.
> 4.  At some undefined point in the future, drop support for the current Bech32 checksum.

I think it depends on the application and their tolerance to this sort
of errors. In some cases, these insertions may be detected already
with high probability (e.g. because of length restrictions, or the
fact that it adds random unstructured symbols at the end of the data
part).

> > -   Later, if and when we expect a need for non-32-byte witness programs
> >     in the medium term, define an updated segwit address scheme that uses
> >     the modified Bech32 variant.
>
> Okay, so we will only use the modified Bech32 if and only if we expect to need a non-32-byte witness program for a particular non-0 SegWit version.

Exactly.

-- 
Pieter

From jw at mathbot.com  Tue Dec 10 02:11:10 2019
From: jw at mathbot.com (JW Weatherman)
Date: Tue, 10 Dec 2019 02:11:10 +0000
Subject: [bitcoin-dev] Human readable format for private keys
In-Reply-To: <9QeoIpWbdIBmLIvDI1SnwIIUSu84IDb1DqCNIn60CrKbnwZkOk0aFZY8uNCv5hCC6QK2nChJ3lQdvGwftGwhBYTayzVqIgQ3L1UC4nw5Y2Y=@mathbot.com>
References: <9QeoIpWbdIBmLIvDI1SnwIIUSu84IDb1DqCNIn60CrKbnwZkOk0aFZY8uNCv5hCC6QK2nChJ3lQdvGwftGwhBYTayzVqIgQ3L1UC4nw5Y2Y=@mathbot.com>
Message-ID: <xannjm1wBI-vJPTaiNABDY6HPg-mhpigLQc3ENxKL6tBvYnYhap-YrBhBzbpiO8prtTJjryqEYbIHA8Jp1zVCXREZcFaXm6CJCADJXrhy98=@mathbot.com>

I now have a live demo of using the NATO alphabet and checksums every 4 words.

It does seem remove the stress of attempting to write unambiguous characters  and I think the demo shows it?s actually easier to type with autocomplete when the word dictionary is not involved.

https://youtu.be/kpZcXtww8Us

-JW

On Sat, Oct 5, 2019 at 6:51 PM, JW Weatherman via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hey Guys,
>
> I?d like to propose a feature to bitcoin to solve the following problems:
>
> - When people read or write private keys it is very easy to mistake a letter or number.
> - When entering a private key a mistake isn?t identified until the entire key is entered.
> - When an error is made in providing a private key the location of the error isn?t indicated within the private key.
> - Private keys stored on paper can be lost if a single character is damaged or poorly transcribed.
>
> The solution I?m proposing has two parts.
>
> First provide an option to use to the NATO phonetic alphabet when displaying or entertaining private keys. To indicate lower case the word should not be capitalized. Capital letters and numbers should be capitalized.
>
> The nato phonetic alphabet is a long-standing international standard (as international as the use of letters and numbers already used in base58) and has been designed to make each letter easily distinguishable when spoken and written.
>
> By using whole words, that are easily distinguishable and from a very short word database (58 well known words that are either the English numbers or words that begin with the letter indicated) the likelihood of errors in recovery are reduced.
>
> The second part of the solution is to insert checksum letters. If every 5th word is actually a checksum for the previous 4 words, you end up with 13 sentences such as:
>
> ALFA tango THREE SIX bravo
>
> In this case bravo is actually a checksum for the previous 4 words and can be calculated and verified as the private key is entered. If the user accidentally trumped BRAVO instead of bravo the checksum would immediately indicate an error within these 5 words (in most cases) making for a greatly improved user experience.
>
> An additional side effect of this is that even if an entire word is lost on multiple lines, the  checksum would probably make guessing the correct words relatively easy.
>
> I realize some of these issues have been discussed in relation to bip39, but I hope this is more likely to be adopted by bitcoin core as it uses existing private keys, has no impact on keygen, does not require a standardized and well known word list for every language, and is essential just a display format that hopefully wouldn?t require invasive code changes.
>
> Thanks in advance for your feedback.
>
> -JW
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191210/948917d1/attachment.html>

From jlrubin at mit.edu  Wed Dec 11 00:37:59 2019
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 10 Dec 2019 16:37:59 -0800
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAD5xwhi115pHK4J4=WDX=xbusxG_qP-oOWYNsD4z1Hh7JZ1yzQ@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <CAMZUoKkS77GwTW0B+cbh5BE5koB5oR4zbvEFmufAH7rN+CkR+w@mail.gmail.com>
 <CAD5xwhi115pHK4J4=WDX=xbusxG_qP-oOWYNsD4z1Hh7JZ1yzQ@mail.gmail.com>
Message-ID: <CAD5xwhiQiCZJ18fqJKsW8Z5g2x4TxSyQeNf0+qEkr-UcLat-1A@mail.gmail.com>

Three changes I would like to make to the OP_CTV draft. I think this should
put the draft in a very good place w.r.t. outstanding feedback.

The changes can all be considered/merged independently, though, they are
written below assuming all of them are reasonable.


1) *Make the hash commit to the INPUT_INDEX of the executing scriptPubKey.*

*Motivation:* As previously specified, a CTV template constructed
specifying a transaction with two or more inputs has a "half-spend" issue
whereby if the template script is paid to more than once (a form of
key-reuse), they can be joined in a single transaction leading to half of
the intended outputs being created.
*Example:*
Suppose I have a UTXO with a CTV requiring two inputs. The first is set to
be the CTV template, and the input has enough money to pay for all the
outputs. The second input is added to allow the adding of a fee-only utxo.
Now suppose someone creates an similar UTXO with this same CTV (even within
the same transaction).


TxA {vin: [/*elided...*/], vout: [TxOut{1 BTC, <TxB template hash> CTV},
TxOut {1 BTC, <TxB template hash> CTV}]}

*Intended Behavior:*
    TxB0 {vin: [Outpoint{TxA.hash(), 0}, /*arbitrary fee utxo*/], vout :
[TxOut {1 BTC, /* arbitrary scriptPubKey */}]
    TxB1 {vin: [Outpoint{TxA.hash(), 1}, /*arbitrary fee utxo*/], vout :
[TxOut {1 BTC, /* arbitrary scriptPubKey */}]
*Possible Unintended Behaviors:*
*    Half-Spend:*
        TxB {vin: [Outpoint{TxA.hash(), 1}, Outpoint{TxA.hash(), 0}], vout
: [TxOut {1 BTC, /* arbitrary scriptPubKey */}]
    *Order-malleation:*
        TxB0 {vin: [/*arbitrary fee utxo*/, Outpoint{TxA.hash(), 0}], vout
: [TxOut {1 BTC, /* arbitrary scriptPubKey */}]
        TxB1 {vin: [Outpoint{TxA.hash(), 1}, /*arbitrary fee utxo*/], vout
: [TxOut {1 BTC, /* arbitrary scriptPubKey */}]

With the new rule, the CTV commits to the index in the vin array that it
will appear. This prevents both the half-spend issue and the
order-malleation issue.

Thus, the only execution possible is:

*Intended Behavior:*
    TxB0 {vin: [Outpoint{TxA.hash(), 0}, /*arbitrary fee utxo*/], vout :
[TxOut {1 BTC, /* arbitrary scriptPubKey */}]
    TxB1 {vin: [Outpoint{TxA.hash(), 1}, /*arbitrary fee utxo*/], vout :
[TxOut {1 BTC, /* arbitrary scriptPubKey */}]

*Impact of Change:*
This behavior change is minor -- in most cases we are expecting templates
with a single input, so committing the input index has no effect.

Only when we do specify multiple inputs, committing the INPUT_INDEX has the
side effect of making reused-keys not susceptible to the "half-spend" issue.

This change doesn't limit the technical capabilities of OP_CTV by much
because cases where the half-spend construct is desired can be specified by
selecting the correct inputs for the constituent transactions for the
transaction-program. In the future, Taproot can make it easier to express
contracts where the input can appear at any index by committing to a tree
of positions.

This change also has the benefit of reducing the miner-caused TXID
malleability in certain applications (e.g., in a wallet vault you can
reduce malleability from your deposit flow, preventing an exponential
blow-up). However in such constructions the TXIDs are still malleable if
someone decides to pay you Bitcoin that wasn't previously yours through a
withdrawal path (a recoverable error, and on the bright side, someone paid
you Bitcoin to do it).

This change also has a minor impact on the cacheability of OP_CTV. In the
reference implementation we currently precompute and store single hash for
the StandardTemplateHash of the entire transaction. Making the hash vary
per-input means that we would need to precompute one hash per-input, which
is impractical. Given that we expect the 0-index to be the exceedingly
common case, and it's not horribly expensive if we aren't cached (a
constant sized SHA-256), the spec will be updated to precompute and cache
only the hash for the 0th index. (The hash is also changed slightly to make
it more efficient for un-cached values, as noted in change 3).


*2) Remove Constexpr restriction*
*Changes:*
Currently it is checked that the template hash argument was not 'computed',
but came from a preceding push. Remove all this logic and accept any
argument.
*Motivation:*
I've had numerous conversations with Bitcoin developers (see above, see
#bitcoin-wizards on Nov 28th 2019, in person at local meetups, and in
private chats with ecosystem developers) about the constexpr restriction in
OP_CTV. There have been a lot of folks asking to remove template constexpr
restriction, for a few reasons:

a) Parsing Simplification / no need for special-casing in optimizers like
miniscript
b) The types of script it disables aren't dangerous
c) There are exciting things you can do were it not there and other
features were enabled (OP_CAT)
d) Without other features (like OP_CAT), there's not really too much you
can do

No one has expressed any strong justification to keep it.

The main motivation for the constexpr restriction was to keep the CTV
proposal very conservative in scope, increasing the likelihood that it is
an acceptable change. It was also designed to be able to be easily lifted
in a future soft-fork. There isn't a *specific* behavior the constexpr
restriction is attempting to prevent, it's just a belt-and-suspenders
measure to limit how creatively CTV could be used now or in the future.

Future OpCodes + OP_CTV may introduce a broader set of functionality than
possible if OP_CTV were to retain the constexpr rule. But I think given
that these future op-codes will likely be introduced intentionally to
introduce broader functionalities, we shouldn't limit the functionality of
OP_CTV today.

*Impact of Changes:*

The only mildly interesting thing that could be done with this change (with
no additional changes; that I could think of) would be to write a script
like:

<serialization of transaction fields according to hash spec> SHA256 OP_CTV

which would be a "self-describing" covenant (for no space savings). This
could be useful in some protocols where "the public" should be able to
execute some step with only chain-data.

N.B. This cannot enable a case where the CTV is in the scriptSig like:

scriptPubKey: <key> CHECKSIG
scriptSig: <serialization of transaction details> OP_SHA256 CTV <sig>

because the serialization of the transaction contains a commitment to
non-null scriptSigs, a self-reference/hash cycle.


*3) Modify the template digest to be easier to cache and work with in
script.*
*Changes:*
The current hash is:

    uint256 GetStandardTemplateHash(const CTransaction& tx) {
        auto h =  TaggedHash("StandardTemplateHash")
            << tx.nVersion << tx.nLockTime
            << GetOutputsSHA256(tx) << GetSequenceSHA256(tx)
            << uint64_t(tx.vin.size());
        for (const auto& in : tx.vin) h << in.scriptSig;
        return h.GetSHA256();
    }

I propose changing it to:

    uint256 GetStandardTemplateHash(const CTransaction& tx, uint32_t
input_index) {

        uint256 scriptSig_hash{};

        bool hash_scriptSigs = std::count(tx.vin.begin(),
tx.vin.begin(), CScript()) != tx.vin().size();

        if (hash_scriptSigs) {
            auto h =  CHashWriter()
            for (const auto& in : tx.vin) h << in.scriptSig;

            scriptSig_hash = h.GetSHA256();

        }
        auto h =  CHashWriter()
            << tx.nVersion
            << tx.nLockTime;

            if (hash_scriptSigs) h << scriptSig_hash;

            h << uint64_t(tx.vin.size())

            << GetSequenceSHA256(tx)

            << uint32_t(tx.vout.size())

            << GetOutputsSHA256(tx)

            << input_index;

        return h.GetSHA256();
    }

This changes a few things:
1) Getting rid of the TaggedHash use

2) Re-ordering to put input_index last

3) Re-ordering to put Outputs SHA256 second-to-last

4) Only computing scriptSig_hash if any scriptSig is non-null

5) Making scriptSig data hashed in it's own hash-buffer

6) explicitly committing to the vout.size()
7) Casting vout.size() but not vin.size() to uint32_t (vout is capped
by COutpoint indicies to 32 bits, vin is not)

*Motivation:*
The current digest algorithm is relatively arbitrarily ordered and set up.
Modifying it makes it easier to cache (given the input index change) and
makes it easier to construct templates in script (once OP_CAT, or
OP_SUBSTR, or OP_STREAMSHA256 are added to core).

*Impact of Changes:*

*1) Getting rid of the TaggedHash use*

Low-impact. TaggedHash didn't add any security to the template hashes,
but did make it harder to "confuse" a StandardTemplateHash for a hash
of another type.

However, the tagged hash makes it slightly more difficult/costly to
construct (with OP_CAT enabled) a template hash within script, so it
is removed.

*2) Re-ordering to put input_index last*

The input index should be put last because this makes it easy to cache
the intermediate hash state *just before* hashing the index, which
makes recomputing for different indexes cheaper.

It also allows (with OP_CAT or STREAMSHA256) to easily allow setting
the accepted indexes from script.

*3) Re-ordering to put Outputs SHA256 second-to-last*

In the future, with OP_CAT/SHA256STREAM or similar, changing the
outputs in the covenant is the most likely change. Placing it near the
end simplifies this operation.


*4) Only computing scriptSig_hash if any scriptSig is non-null*

There is no need to hash the scriptSig data at all if they are all
null. This is in most cases true, so we avoid extra hashing.

But the bigger win is for scripted construction of templates, which
can just completely ignore the scriptSig hashing if it is known to be
using all bare CTV/non-p2sh segwit inputs (which should be the common
case).


*5) Making scriptSig data hashed in it's own hash-buffer, when hash is
included.*

This implies that there are two possible sizes for the hashed data,
+/- 1 hash (for scripSig_hash). This eliminates concerns that directly
hashing elements into the template hash buffer might expose some
length extension issue when constructing a template in script.


*6) explicitly committing to the vout.size()*

This makes it easier, when OP_CAT or similar is added, to write
restrictions that guarantee a limit on the number of inputs that may
be created.


*7) Casting vout.size() but not vin.size() to uint32_t (vout is capped
by COutpoint indicies to 32 bits, vin is not)*

This is just kind of annoying, but technically you can have more inputs in
a transaction than outputs because more than 32-bits of outputs breaks the
COutpoint class invariants.


--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Thu, Nov 28, 2019 at 11:59 AM Jeremy <jlrubin at mit.edu> wrote:

> Thanks for the feedback Russell, now and early. It deeply informed the
> version I'm proposing here.
>
> I weighed carefully when selecting this design that I thought it would be
> an acceptable tradeoff after our discussion, but I recognize this isn't
> exactly what you had argued for.
>
> First off, with respect to the 'global state' issue, I figured it was
> reasonable with this choice of constexpr rule given that a reasonable tail
> recursive parser might look something like:
>
> parse (code : rest) stack alt_stack just_pushed =
>     match code with
>         OP_PUSH => parse rest (x:stack) alt_stack True
>         OP_DUP => parse rest (x:stack) alt_stack False
>         // ...
>
> So we're only adding one parameter which is a bool, and we only need to
> ever set it to an exact value based on the current code path, no
> complicated rules. I'm sensitive to the complexity added when formally
> modeling script, but I think because it is only ever a literal, you could
> re-write it as co-recursive:
>
> parse_non_constexpr (code : rest) stack alt_stack =
>     match code with
>         OP_PUSH => parse_constexpr rest (x:stack) alt_stack
>         OP_DUP => parse_non_constexpr rest (x:stack) alt_stack
>         // ...
>
> parse_constexpr (code : rest) stack alt_stack  =
>     match code with
>         OP_CTV => ...
>         _ => parese_non_constexpr (code : rest) stack alt_stack
>
>
> If I recall, this should help a bit with the proof automatability as it's
> easier in the case by case breakdown to see the unconditional code paths.
>
>
> In terms of upgrade-ability, one of the other reasons I liked this design
> is that if we do enable OP_CTV for non-constexpr arguments, the issue
> basically goes away and the OP becomes "pure" without any state tracking.
> (I think the switching on argument size is much less a concern because we
> already use similar upgrade mechanisms elsewhere, and it doesn't add
> parsing context).
>
>
> It's also possible, as I think *should be done* for tooling to treat an
> unbalanced OP_CTV as a parsing error. This will always produce
> consensus-valid scripts! However by keeping the consensus rules more
> relaxed we keep our upgrade-ability paths open for OP_CTV, which as I
> understand from speaking with other users is quite desirable.
>
>
> Best (and happy thanksgiving to those celebrating),
>
> Jeremy
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
>
> On Thu, Nov 28, 2019 at 6:33 AM Russell O'Connor <roconnor at blockstream.io>
> wrote:
>
>> Thanks for this work Jeremy.
>>
>> I know we've discussed this before, but I'll restate my concerns with
>> adding a new "global" state variable to the Script interpreter for tracking
>> whether the previous opcode was a push-data operation or not.  While it
>> isn't so hard to implement this in Bitcoin Core's Script interpreter,
>> adding a new global state variable adds that much more complexity to anyone
>> trying to formally model Script semantics.  Perhaps one can argue that
>> there is already (non-stack) state in Script, e.g. to deal with
>> CODESEPARATOR, so why not add more?  But I'd argue that we should avoid
>> making bad problems worse.
>>
>> If we instead make the CHECKTEMPLATEVERIFY operation fail if it isn't
>> preceded by (or alternatively followed by) an appropriate sized
>> (canonical?) PUSHDATA constant, even in an unexecuted IF branch, then we
>> can model the Script semantics by considering the
>> PUSHDATA-CHECKTEMPLATEVERIFY pair as a single operation.  This allows
>> implementations to consider improper use of CHECKTEMPLATEVERIFY as a
>> parsing error (just as today unbalanced IF-ENDIF pairs can be modeled as a
>> parsing error, even though that isn't how it is implemented in Bitcoin
>> Core).
>>
>> I admit we would lose your soft-fork upgrade path to reading values off
>> the stack; however, in my opinion, this is a reasonable tradeoff.  When we
>> are ready to add programmable covenants to Script, we'll do so by adding
>> CAT and operations to push transaction data right onto the stack, rather
>> than posting a preimage to this template hash.
>>
>> Pleased to announce refinements to the BIP draft for
>>> OP_CHECKTEMPLATEVERIFY (replaces previous OP_SECURETHEBAG BIP). Primarily:
>>>
>>> 1) Changed the name to something more fitting and acceptable to the
>>> community
>>> 2) Changed the opcode specification to use the argument off of the stack
>>> with a primitive constexpr/literal tracker rather than script lookahead
>>> 3) Permits future soft-fork updates to loosen or remove "constexpr"
>>> restrictions
>>> 4) More detailed comparison to alternatives in the BIP, and why
>>> OP_CHECKTEMPLATEVERIFY should be favored even if a future technique may
>>> make it semi-redundant.
>>>
>>> Please see:
>>> BIP: https://github.com/JeremyRubin/bips/blob/ctv/bip-ctv.mediawiki
>>> Reference Implementation:
>>> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify
>>>
>>> I believe this addresses all outstanding feedback on the design of this
>>> opcode, unless there are any new concerns with these changes.
>>>
>>> I'm also planning to host a review workshop in Q1 2020, most likely in
>>> San Francisco. Please fill out the form here
>>> https://forms.gle/pkevHNj2pXH9MGee9 if you're interested in
>>> participating (even if you can't physically attend).
>>>
>>> And as a "but wait, there's more":
>>>
>>> 1) RPC functions are under preliminary development, to aid in testing
>>> and evaluation of OP_CHECKTEMPLATEVERIFY. The new command
>>> `sendmanycompacted` shows one way to use OP_CHECKTEMPLATEVERIFY. See:
>>> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-rpcs.
>>> `sendmanycompacted` is still under early design. Standard practices for
>>> using OP_CHECKTEMPLATEVERIFY & wallet behaviors may be codified into a
>>> separate BIP. This work generalizes even if an alternative strategy is used
>>> to achieve the scalability techniques of OP_CHECKTEMPLATEVERIFY.
>>> 2) Also under development are improvements to the mempool which will, in
>>> conjunction with improvements like package relay, help make it safe to lift
>>> some of the mempool's restrictions on longchains specifically for
>>> OP_CHECKTEMPLATEVERIFY output trees. See: https://github.com/bitcoin/bitcoin/pull/17268
>>> This work offers an improvement irrespective of OP_CHECKTEMPLATEVERIFY's
>>> fate.
>>>
>>>
>>> Neither of these are blockers for proceeding with the BIP, as they are
>>> ergonomics and usability improvements needed once/if the BIP is activated.
>>>
>>> See prior mailing list discussions here:
>>>
>>> *
>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016934.html
>>> *
>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/016997.html
>>>
>>> Thanks to the many developers who have provided feedback on iterations
>>> of this design.
>>>
>>> Best,
>>>
>>> Jeremy
>>>
>>> --
>>> @JeremyRubin <https://twitter.com/JeremyRubin>
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191210/f3b59f34/attachment-0001.html>

From jlrubin at mit.edu  Fri Dec 13 23:06:59 2019
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 13 Dec 2019 15:06:59 -0800
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAD5xwhiQiCZJ18fqJKsW8Z5g2x4TxSyQeNf0+qEkr-UcLat-1A@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <CAMZUoKkS77GwTW0B+cbh5BE5koB5oR4zbvEFmufAH7rN+CkR+w@mail.gmail.com>
 <CAD5xwhi115pHK4J4=WDX=xbusxG_qP-oOWYNsD4z1Hh7JZ1yzQ@mail.gmail.com>
 <CAD5xwhiQiCZJ18fqJKsW8Z5g2x4TxSyQeNf0+qEkr-UcLat-1A@mail.gmail.com>
Message-ID: <CAD5xwhj-WGBLGCi4nKE_5D+cYL134Xn4iux03co+s_iHtHhGZw@mail.gmail.com>

I've prepared a draft of the changes noted above (some small additional
modifications on the StandardTemplateHash described in the BIP), but have
not yet updated the main branches for the BIP to leave time for any further
feedback.

See below:

BIP: https://github.com/JeremyRubin/bips/blob/ctv-v2/bip-ctv.mediawiki
Implementation:
https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-v2

Thank you for your feedback,

Jeremy
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191213/be6af5e4/attachment.html>

From jlrubin at mit.edu  Thu Dec 19 20:08:03 2019
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 19 Dec 2019 12:08:03 -0800
Subject: [bitcoin-dev] BIP OP_CHECKTEMPLATEVERIFY
In-Reply-To: <CAD5xwhj-WGBLGCi4nKE_5D+cYL134Xn4iux03co+s_iHtHhGZw@mail.gmail.com>
References: <CAD5xwhjXidpeLLUr4TO30t7U3z_zUxTpU9GBpLxu3MWX3ZFeTA@mail.gmail.com>
 <CAMZUoKkS77GwTW0B+cbh5BE5koB5oR4zbvEFmufAH7rN+CkR+w@mail.gmail.com>
 <CAD5xwhi115pHK4J4=WDX=xbusxG_qP-oOWYNsD4z1Hh7JZ1yzQ@mail.gmail.com>
 <CAD5xwhiQiCZJ18fqJKsW8Z5g2x4TxSyQeNf0+qEkr-UcLat-1A@mail.gmail.com>
 <CAD5xwhj-WGBLGCi4nKE_5D+cYL134Xn4iux03co+s_iHtHhGZw@mail.gmail.com>
Message-ID: <CAD5xwhiDHC7-7GJmkjBo68=e+73A2rdGWniaV+ZbpP9ZdNAzrA@mail.gmail.com>

I've updated the main branch (ctv) to match ctv-v2, and pushed branches
ctv-v1 which points at the prior versions.

Thanks to Dmitry Petukhov for helping me fix several typos and errors.

I also wanted to share some some "non-technical" tax analysis covering the
use of OP_CTV for batched payments. See here:
https://utxos.org/analysis/taxes/

As an aside, the site https://utxos.org/ generally is a repository of
information & material on OP_CTV, it's design, applications, and analysis.
If you're interested in contributing any content please let me know!

Best,

Jeremy
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, Dec 13, 2019 at 3:06 PM Jeremy <jlrubin at mit.edu> wrote:

> I've prepared a draft of the changes noted above (some small additional
> modifications on the StandardTemplateHash described in the BIP), but have
> not yet updated the main branches for the BIP to leave time for any further
> feedback.
>
> See below:
>
> BIP: https://github.com/JeremyRubin/bips/blob/ctv-v2/bip-ctv.mediawiki
> Implementation:
> https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify-v2
>
> Thank you for your feedback,
>
> Jeremy
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191219/5500674a/attachment.html>

From ty at rubix.io  Tue Dec 24 03:20:15 2019
From: ty at rubix.io (Ty Everett)
Date: Mon, 23 Dec 2019 19:20:15 -0800
Subject: [bitcoin-dev] [New BIP]: Universal Addresses
Message-ID: <D538E88C-4F34-4456-9803-EF6A40CBD8AE@rubix.io>

I?d like to propose a new BIP for universal, multi-currency addresses. Until a BIP number is assigned, we can substitute it with ${BIPNUM} wherever it is used. In the examples, I?ll use 3301 as the value for ${BIPNUM} when required to demonstrate BIP32 derivation.

```
BIP: ${BIPNUM}
Layer: Applications
Title: Universal Addresses
Author: Ty Everett <ty at rubix.io>
Status: Draft
Type: Informational
Created: 2019-12-23
License: BSD-2-Clause
Requires: 32, 43, 44
```

Abstract

A universally recognized and accepted cryptocurrency address format would allow merchants, exchanges and users to more easily coordinate transactions and conduct business. I propose a new address format not specific to any cryptocurrency that provides strong cryptographic security while maintaining or improving the level of transactional privacy specific to each underlying currency. BIP32 derivation permits compatibility with existing HD wallets, reducing implementational friction across the ecosystem. BIP44 numberings at the coin-selection level allow new coins to be used with the same Universal Addresses, while URL-style query parameters dictate which currencies a user prefers to receive.

As the Bitcoin and wider cryptocurrency community has matured, numerous address formats have been devised. Some projects use their own format, while others use base-58 or hex-encoded strings. Some even have identical addresses, creating confusion for users and a potential for the loss of funds. While each format has its unique set of advantages and disadvantages, they all have one thing in common: they are specific to a single currency and not to the user, who may or may not use and accept a great many currencies. I propose the use of BIP32 extended public key nodes as a Universal Address format, because no cryptocurrency project exists in a vacuum.

Copyright

This BIP is licensed under the BSD 2-Clause License.

Specification

Pre-requisite Knowledge

This BIP draws on concepts from BIP32, BIP43 and BIP44. The reader is encouraged to familiarize themselves with those BIPs before attempting to read and understand this BIP.

A Note on Annotations and Rationale in this BIP

Design decisions have been made with regard to many respects of this BIP. Where appropriate, annotations[1] have been added. Justifications can be found in the ?Rationale? section, along with a few explanatory Q&A-style points about potential implementation concerns.

A Note on Terminology Used In This BIP

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", ?SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

Derivation Path Levels for Universal Addresses

Implementers of BIP${BIPNUM} MUST use the below BIP32 derivation path levels for Universal Addresses; apostrophe denotes hardened BIP32 derivation:

```
m / ${BIPNUM}? / entity / coin / shield
```

Level 1: Denotes Use with Universal Addresses

The top-level derivation simply denotes the use of this node with Universal Addresses. Primarily, it?s purpose is to isolate this use-case from other uses of the same BIP32 node (notably BIP44 wallets).

Level 2: Recipient Determines Index of Address to Share

This is the level at which the Universal Addresses allocated by a recipient's wallet are to be split off; one for each sender to whom the recipient has given an address. Starting at index 1 (0 is reserved for future use), each Universal Address SHOULD be generated canonically. The keys generated at this level are the ones to be shared from the sender to the recipient. The recipient may then derive a level 3 key based on this key and the currency they wish to send. There is no need for the sender to obtain a new Universal Address from the recipient for each of their subsequent transactions.

Level 3: Sender Selects and Derives Address for the Currency They Wish to Send

The sender receives the level 2 key from the recipient formatted as a Universal Address (see Serialization Format section below). Based on the BIP44 coin assignment number for the coin the sender would like to send (maintained by Satoshi Labs as SLIP44), the sender makes the appropriate derivation at this level.

Level 4: Sender Increments Shield Counter to Improve Privacy (?Enhanced Privacy Mode?)

The shield counter starts at child #1 (#0 is reserved for future use). If a higher level of privacy is desired, the sender MAY increment the shield counter once per transaction. In this way, individual addresses are not re-used. Additionally, the sender MAY split a payment into multiple separate transactions, each destined for a different blockchain-level address[2]. If the sender does not increment the shield counter for every transaction, the sender MUST always use child #1 as the public key component of the blockchain-level address.

Reservation of ${BIPNUM} as a BIP43 Purpose

I define that the first level of BIP32 derivation to be used in Universal Address allocation from the root BIP32 node SHALL be ${BIPNUM}, which conforms to the BIP43 recommendation that top-level derivations be based on the number assigned to a BIP. The BIP43 purpose for this BIP is ?Universal Addresses.?

Serialization Format

The serialized address format for BIP${BIPNUM} Universal Addresses SHALL be the same format described in the ?Serialization Format? subsection of the ?Specification: key derivation? section of BIP32, subject to the following considerations:

- Implementers of BIP${BIPNUM} Universal Addresses MUST encode Universal Addresses using the same base58 format as current extended public keys for interoperability with existing software.

- For additional privacy, implementers of BIP${BIPNUM} Universal Addresses SHOULD substitute the 32-bit ?parent key fingerprint? with 0x00000000 before disclosing the Universal Address to the sender. In these cases, the recipient has the sole responsibility of keeping track of the true parent key fingerprint if they find it useful.

- For additional privacy, implementers of BIP${BIPNUM} Universal Addresses SHOULD substitute the 32-bit ?child number? with 0x00000000 before disclosing the Universal Address to the sender. In these cases, the recipient has the sole responsibility of keeping track of the true child number if they find it useful.

URL-Style Query Parameters for Denotability of Recipient-Specified Currency Acceptance Preferences

When the recipient wishes to specify which currencies it prefers to receive, a URL-style query parameter MAY be appended to the end of the Universal Address. If provided, the query parameter MUST have the property of lowercase ?accept? and its value MUST be a comma-delimited list of one or more SLIP44 currency symbols. Future BIPs MAY propose new query parameters that can also be appended. All such parameters are strictly OPTIONAL in this specification. Universal addresses with no appended query parameters MUST be regarded as valid.

When a sender wallet encounters a Universal Address with an appended ?accept? URL-style query parameter, it SHOULD show a list of currencies in its user interface that correspond to the ones denoted by the value of the parameter. The sending wallet SHOULD also remove currencies from the list that it does not support.

The sender wallet MAY auto-select a currency for the sender if there is only one common currency between the ?accept? list and the ?supported currencies? list of the sender wallet. Auto-selection based on the sender?s balance or other factors MAY also be performed.

Future Possibilities for Backwards-Compatible Improvements to Universal Addresses

A future BIP MAY specify a URI-style format (e.g. ?pay:??) and, if a URI-style format for Universal Addresses is proposed, the proposing BIP SHOULD consider removing unnecessary fields (version bytes, depth, parent key fingerprint and child index) from the base58-encoded string. However, to reduce the friction for adoption of Universal Addresses by the community and to promote compatibility with existing software, those changes are not proposed as part of this BIP. BIP${BIPNUM} Universal Addresses can be converted to a new, shorter format in the future[6]. Libraries, wallets and BIPs building on top of and claiming support for BIP${BIPNUM} Universal Addresses MUST maintain seamless backwards-compatible support for the use of standard BIP32-serialized extended public keys as BIP${BIPNUM} Universal Addresses.

BIP${BIPNUM} Universal Address Validity Checks

A serialized BIP32 extended public key string that is encoded in base58 format with a valid 32-bit checksum SHALL be regarded as a valid BIP${BIPNUM} Universal Address if the following are true:
1). The string meets the BIP32 requirement that the specified point lies on the secp256k1 curve, and is otherwise representative of a valid BIP32 public node.
2). The version bytes are equal to 0x0488B21E for the key[3].
3). The depth byte is equal to 0x02.
4). Notwithstanding the above, validity assertions SHALL NOT take into account the contents of the 32-bit parent key fingerprint or the 32-bit child number, except that these fields MUST be present in some form and that the final double-sha256 checksum MUST be correct.

Implementation Notes

BIP44-compliant wallet Implementers SHOULD use the same BIP32 root node as is presently in use for each of their users. This generally reduces complexity and maintains compatibility with existing software.

This BIP mandates that it is absolutely REQUIRED that the community agree on SLIP44 designations for each coin. Project leaders MUST apply for SLIP44 allocations if they have yet to do so and want their projects to be compatible with this BIP[4].

Universal Address Sharing

Universal Addresses SHOULD be viewed as having two possible security models: they can be fully public or they can be kept secret between the recipient and exactly one sender. Fully public addresses are OK, because Universal Addresses do not claim to provide confidentiality about the amounts and currencies received by the recipient. Fully private addresses, where the recipient allocates a new address for every sender (such that each sender has their own designated Universal Address for the recipient, but no sender may learn the Universal Address of any other senders to the recipient) are also secure and have other benefits[2]. However, other security models have inherent weaknesses[5] and SHOULD definitely be avoided.

Balance Calculation Algorithm

Similar to current extended public key-based wallets, inquiring about the balance of a Universal Address involves querying for transactions related to the blockchain-level addresses derived from the root node. The only difference with Universal Addresses is that wallets SHOULD query all blockchains for which a known balance is desired. Higher zero-use gap toleration decreases the likelihood of missing coins. Wallets SHOULD keep track of the Universal Addresses they allocate.

Examples

Three situations that utilize Universal Addresses will be described; the first from the perspective of a recipient and the second two from the perspective of senders.

Example 1: Recipient Usage

A user generates a BIP32 private root node and wants to give out a Universal Address:

```
xprv9s21ZrQH143K2eR2vYd9i6YvrFUojaL3ecK2hY4zfabMgu6okTk2s6WxnQmPYA45apCKWiUnHrQsdvh6ER4Leaaa7ehDx5KZtDUbAcgfGBy
```

The user will perform a hardened level 1 derivation to find private child #${BIPNUM} of their root node:

```
xprv9umttUfc6MFTxANAkz8fWE4hHN99xra5GwiP9Er91M69mBso9hAhAgYu2tXfvXaAs5AHWAPwZCSUT4SzkgBqtuNYdHLcp1tSsPDGmAg9ugW
```

The user will perform a public derivation to arrive at the #1 child, as this is their first Universal Address:

```
xpub6A6MPF2tU1tML7JJa98pzmSgDr7V8JuaKCrYu4tjgq4ZLFKTvF4eW7y3c28ye3db9nk3XVvPBTwDA7VB7hch4aj1aQKrCj7FoW78vTJw8zj
```

This is the Universal Address. Assuming the user is OK with accepting any SLIP44 cryptocurrency, they can share the Universal Address with any sender or publish it online.

Optionally, they can append URL-style query parameters to denote one or more currencies they prefer to accept with this address. Other query string parameters may be proposed by future BIPs. This BIP only reserves the ?accept? parameter for use as a comma-delimited list of SLIP44 currency symbols, as defined in the ?URL-Style Query Parameters for Denotability of Recipient-Specified Currency Acceptance Preferences? subsection of the ?Specification? section above.

Example 2: Multi-currency Wallet

A user sees a BIP${BIPNUM} Universal Address on a website:

```
xpub6A6MPF2tU1tMQXuhyAAXLDWKMuw3GRwZEFUAXXwHuykZoUcyUn24gN7RPuy5xZXj6zSqWXFcVjTJEnnX5Qh4pjJMnGbjZkuXHFKFy4U22AX?accept=BTC,LTC
```

The user?s wallet notices that the address indicates a preference for either Bitcoin or Litecoin, so the UI presents a choice. The user selects Litecoin, so the wallet searches for LTC in the SLIP44 currency list and therefore derives the #2 child node of the Universal Address:

```
xpub6D76wrzT2eTJH5EaMdcK8Wkej36nBakXFwMr79HLJMxga4giaehK8RLFiCTiAkBt9W8saivsX4n2ot9reUt4ePbSUhEFHK1NGkKiPhWhQZH
```

This particular wallet does not support "Enhanced Privacy Mode", so it will simply derive the #1 child of the Litecoin node instead of calculating the correct shield value:

```
xpub6E9man3MPJXdrgjHDqhkJuSjG3j9TBfESbxppRA1fF5pq9KEDCQegPfa76e9BT3Nnhwpy9krXrLTRsYx8ccFXrMKTuz6hH2ZEanhG1tC59a
```

The Litecoin address corresponding to the derived node is:

```
LXDxiYDVosUg3hKwJ4yP24EfdkRuNumLs5
```

The user completes their transaction with Litecoin.

Example 3: "Enhanced Privacy Mode" and Universal Address Reuse

In a (semi)-private chat, a user receives a Universal Address:

```
xpub6AJUhNSZRaZS7d9eJ2jyyuNMbkMWQgHNEgDt9rC3WJfkXvQDAKu9LZLhMhVkeot66EtEtBJK48Ca3qNfrjBH1otkBc2CNPwaTMeHSh3TvL1
```

The user received this particular Universal Address some months ago[7], and has used to for 17 previous Bitcoin transactions and 2 Litecoin transactions to this recipient.

The user wants to send 2 BTC to the recipient. The user?s wallet has two unspent outputs in different places; the first for 1.5 BTC and the second for 1 BTC.

The wallet notices that the recipient?s Universal Address indicates no preference for which currency to receive. Thus, the UI presents a list of all supported currencies for which the sender has a balance. The sender selects Bitcoin, so the wallet searches for BTC in the SLIP44 currency list and therefore derives the #0 child node of the Universal Address:

```
xpub6CUu5jU1UVXsB3zstbr6MDZcmZy9SAEfsTtm81iR2foAtRZ34cb9jnr4D1jcQxKG9y9fMhVeqYy9kC3j4jidyhbrRuX6nXiYgSdQSwZmzVi
```

Since the sender?s wallet supports "Enhanced Privacy Mode", it will increment the Bitcoin shield counter starting at child #1 and querying the blockchain for each shielded address to see if it has ever been used[8]. The wallet sees that the shield counter is at #17[9]. Since the wallet uses ?Enhanced Privacy Mode?, it MUST NOT use shielded children less than child #18. For privacy, the wallet MAY also split the payment into two or more transactions[11]. The wallet will now derive the #18 and #19 children of the Bitcoin node:

```
xpub6EvkmcciNXPHVoiSP4sV21mgAWi3MAzJtvwRFXoNuUusADN1KU9eZ9REkuD7PgtRDR1ggKRSvci8L6uhegmcoNwSP8QDfSqRH66iC6oGYWs -> 1F2idiEsCTBN6ZrzkLE7JTddaJPubYet5m
```

and

```
xpub6EvkmcciNXPHWR7ZLh8XJz74CZh8NDszKBzEBMS7xFDgTB7aoLbJwtzwV1CdKM6JvwrGowU1FoMpf1uZuUfBqX4BpHqMGQocTPev98qZ3Wf -> 1PpcyFv46NvqJusLwfrv6dkw3K9z434hJV
```

The wallet will now spend the first of its outputs (1.5 BTC) entirely to child #18, and 0.5 BTC from the second output will be spent to child #19. The remaining 0.5 BTC from the second output will be sent back to a change address. In this way, it is impossible for an observer to correlate that the two outputs originally belonged to the same sender or were part of the same payment[10].

Motivation

Addresses are a tedious part of living in the cryptocurrency-enabled world. With hundreds of contacts and dozens of popular currencies, keeping track of which people provided which addresses for which coins makes life all the more difficult. Widespread adoption of a Universal Addressing format would allow users to share one address and accept many cryptocurrencies in the same wallet. As merchants and exchanges support and use new currencies, new addresses do not need to be exchanged among users. When sender wallets support ?Enhanced Privacy Mode?, a substantial gain in transactional privacy is also obtained by the use of Universal Addresses.

Rationale

References from the above text:

[1]: This is the example annotation appearing in the ?A Note on Annotations and Rationale in this BIP? subsection of the ?Specification? section.

[2]: For certain blockchains that do not implement transactional ?inputs and outputs?, this permits transactions to be made in a way that permits single-use addressing. For these coins, when the original recipient wishes to spend the received coins which are in multiple addresses, they may do so in one of two ways:
1). If the original recipient wishes to send all received coins out as one blockchain-level transaction and from one blockchain-level address, they may first create many blockchain-level transactions collecting the coins into a single ?change address? and then spend the coins all at once from that address to the next recipient.
2). If the original recipient wishes to spend using multiple addresses (i.e. the next recipient also uses Universal Addresses), the original recipient may simply empty each of the addresses they would like to spend from; the original recipient may either choose to forward all coins in a given address to the next recipient, or to forward some of the coins to the next recipient and the rest to a new ?change address.? This same model can apply to Bitcoin. In any case, the advantage is that it makes for better privacy because multi-transactional payments do not permit correlation of any of the outputs to any single user. It is also possible to send one transaction on blockchain A and another transaction on blockchain B as part of the same payment.

[3]: Private keys are never used, and since the Bitcoin Testnet (normally 0x043587CF) is covered by level 3 SLIP44 derivation, no other version prefixes are needed.

[4]: Not all cryptocurrency projects will be initially compatible with BIP${BIPNUM} Universal Addresses out of the box. Does that make these addresses non-universal? How non-universal is UPnP? This BIP defines a standard that works for most use-cases and most currencies most of the time. If enough people adopt it, non-compliant projects MAY find a way to join the standard.

[5]: In particular, situations where a group of entities know a single Universal Address for a member, and where the transactions of the members of the group which involve the known Universal Address are not intended to be public should be avoided. By publishing the known Universal Address, a single member of the group can compromise the privacy of the transactions of all group members involving the known Universal Address. Each recipient SHOULD take care to allocate new Universal Addresses for each entity with whom they intend to transact business; even if an allocated address never gets used by a sender, a completely new address SHOULD be allocated by the recipient for each potential sender when privacy is strictly required because the previously-designated sender can learn the transactional activity between the newly-designated sender and the recipient if addresses are reused.

[6]: Conversion can occur by simply deserializing the string, removing the unnecessary fields and re-serializing to the new format.

[7]: Since Universal Addresses can be reused, the user?s wallet could keep an associative list mapping names to Universal Addresses. Wallets MAY consider making this look like an address book, where the user can add their associates as contacts.

[8]: Wallets MAY use a binary search-style querying strategy to speed up this process as opposed to a linear search of the blockchain. The wallet MAY also cache the highest known-to-be-used shield counter for each previously-checked currency of each Universal Address it has seen in the past.

[9]: Wallets SHOULD always check shield counters even if cached data exists, because a publicly-known Universal Address could have been used by another sender. However, caching speeds up future checks because the wallet knows that the shield value is not less than the cached value.

[10]: In typical Bitcoin transactions, such correlations are possible and are widely used for ?blockchain forensics.? This new mode of wallet operation represents a substantial privacy improvement for Bitcoin and for all compliant[4] SLIP44 cryptocurrencies.

[11]: It is also possible for the sender to conduct a multi-blockchain payment. For example, the sender might send one Bitcoin transaction and two Litecoin transactions. The sender SHOULD only attempt this with communication and coordination with the recipient to avoid confusion. The sender always has an incentive to ensure the recipient properly receives the payment.

Other considerations:

The final set of design decisions made with regard to this BIP are documented below in a Q&A/interview-style format:

Q: Will it be easy to lose coins since an address is no longer associated with a single cryptocurrency?

A: This is a valid concern, but there are quite a large number of projects without unique address formats. Specifically, ERC20 coins use hex strings while Bitcoin SV and Bitcoin both use base58. Universal Addresses will be a net benefit because each project gets its own pool of address space. Additionally, the ?accept? parameter might only contain a single SLIP44 symbol, making Universal Addresses the de facto address format for many projects.

Wallets implementing Universal Addresses SHOULD append the ?accept? parameter, and senders SHOULD NOT send coins that are not listed by the ?accept? header when specified. Also, the money wouldn't actually be lost in these situations. Assuming the root private node is safe, derivation of the right path will make recovering coins fairly straightforward. Additionally, high quality multi-currency wallet implementations should consider scanning popular blockchains for transactions even if those chains are otherwise unsupported. This can alert the user in cases where unsupported coins were received.

Q: For split transaction payments, no single TXID exists. This makes accounting harder.

A: In the vast majority of cases, the sender should get the recipient to simply come up with an invoice number or ?payment ID? that can be communicated to the sender for their records. Listing all relevant TXIDs is another possible solution. Calculating the bitwise XOR of all relevant TXIDs to create a single ?MTXID? is also possible and could be the subject for a future BIP. In any case, it is a valid concern that ?Enhanced Privacy Mode? deviates from the standard transactional model. If a single TXID is strictly required, a multi-transactional payment should not be used.

Q: It is the sender?s choice whether to use a split payment or ?Enhanced Privacy Mode?. If they choose not to do so, can?t the recipient?s privacy be harmed?

A: In existing implementations, the sender can breach their own privacy in many ways by revealing participation in a transaction. The onus is always on the sender of a transaction to ensure that their privacy is protected since the recipient does not control whether the sender uses ?Enhanced Privacy Mode." With Universal Addresses, each sender makes their own choice about privacy and their decision does not effect the privacy of the recipient or any other senders. In any case, future BIPs might also propose recipient-controlled preferences for privacy modes using additional URL-like query parameters.

Q: Can?t a sender publish the recipient?s non-public Universal Address to compromise the recipient's privacy?

A: Recipients should only share the same non-public Universal Address with one sender. Thus, the impact of such a disclosure is limited to transactions strictly involving this particular sender. Refer to the ?Universal Address Sharing? subsection of the ?Specification? section and [5] for further details. It is also worth noting that by revealing the non-public Universal Address, the sender explicitly notifies the recipient that they have breached the recipient's implicit trust relationship. Since the recipient gave the non-public Universal Address solely to this sender and since the recipient knows that they were not the one to have published it, the recipient can be certain that the sender published the address. The sender will lose the implicit trust of the recipient to maintain privacy.

Q: Suppose a recipient publishes their own previously-undisclosed non-public Universal Address. Would this reveal that two or more spent outputs were from the same sender?

A: Even if the Universal Address is publicly revealed, it does not prove that any two transactions sent from different source addresses are part of the same payment or even that they came from the same sender. Notwithstanding the above, the sender should understand that their privacy is determined by their own actions, not the actions of the recipient. If the sender failed to re-use addresses and then the recipient published the Universal Address revealing a pattern of the sender?s single-address activity, the recipient is not liable for the sender?s negligence.

Q: Universal Addresses are long. What can be done to shorten them?

A: Elimination of version bytes, parent fingerprint, child number and node depth in combination with the creation of a URI prefix would decrease length and would also make for another great BIP.

Q: Is it likely that people will get Universal Addresses mixed up with normal BIP32 extended public keys?

A: As they are currently used, extended keys are generally distributed at the root level. People may attempt to differentiate them because the node depth will always be 2 for Universal Addresses. Additionally, an extended public key is probably a Universal Address if its parent fingerprint and child index have been zeroed, but Universal Addresses may also exist with these values populated. A future BIP proposing a URI-denoted identifier (?pay:??) would also solve this problem. Ideally such a BIP would also reduce the length of Universal Addresses. In any case, the likelihood for mistakes is small considering that BIP32 extended public keys are typically only used by advanced users.

Q: Should the version bytes defined in BIP32 be removed or changed for use with this BIP?

A: BIP43 recommends that version bytes do not change across use-cases. If a new URI scheme is proposed for Universal Addresses in a future BIP, the effective result would be that such an identifier could replace the version bytes, because it would serve to identify the resource as a Universal Address. Version bytes are maintained by this BIP to create full backwards-compatibility with BIP32 extended public keys.

Q: XYZCoin is incompatible with this BIP because BIP32 derivation will not work with Ed25519 or some other cryptography

A: BIP${BIPNUM} Universal Addresses were designed to work well for most people and most cryptocurrency projects most of the time. Since anyone is free to start a new project, it is entirely possible that existing or future projects are non-compliant with this BIP. Consideration should be given to past projects which existed before this BIP?s publication, since they could not have known about this BIP at the time of their inception. However, the benefits to users and the wider cryptocurrency ecosystem in implementing a standard address format MUST NOT be underestimated.

References

- BIP32
- BIP43
- BIP44
- SLIP44
- RFC-2119

From belcher at riseup.net  Tue Dec 24 17:06:01 2019
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 24 Dec 2019 17:06:01 +0000
Subject: [bitcoin-dev] Base64-encoded descriptors
Message-ID: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>

I've recently been playing around with descriptors, and they are very
nice to work with. They should become the standard for master public
keys IMO.

One downside is that users cant easily copypaste them to-and-fro to make
watch-only wallet. The descriptors contain parenthesis and commas which
stop highlighting by double-clicking. Also the syntax might look scary
to newbs.

An obvious solution is to base64 encode the descriptors. Then users
would get a text blog as the master public key without any extra details
to bother them, and developers can easily base64 decode for developing
with them.

A complication might be the descriptor checksum. If there's a typo in
the base64 text then that could decode into multiple character errors in
the descriptor, which might be problematic for the checksum. Maybe the
descriptor could be base64 encoded without the checksum, then attach the
checksum to the end of the base64 text.

Thoughts?

I didn't come up with these ideas, they came from discussions with achow101.

From stick at satoshilabs.com  Tue Dec 24 19:25:02 2019
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Tue, 24 Dec 2019 20:25:02 +0100
Subject: [bitcoin-dev] Base64-encoded descriptors
In-Reply-To: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
References: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
Message-ID: <CAF90AvkHKck8cd3hX6TbP0Bq1czoUv_N56bYf3ViVFncOOG8Sg@mail.gmail.com>

I'd rather see something using Base58 or even better Bech32. Base64 is not
URL/QR code friendly.

On Tue, Dec 24, 2019, 18:06 Chris Belcher via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I've recently been playing around with descriptors, and they are very
> nice to work with. They should become the standard for master public
> keys IMO.
>
> One downside is that users cant easily copypaste them to-and-fro to make
> watch-only wallet. The descriptors contain parenthesis and commas which
> stop highlighting by double-clicking. Also the syntax might look scary
> to newbs.
>
> An obvious solution is to base64 encode the descriptors. Then users
> would get a text blog as the master public key without any extra details
> to bother them, and developers can easily base64 decode for developing
> with them.
>
> A complication might be the descriptor checksum. If there's a typo in
> the base64 text then that could decode into multiple character errors in
> the descriptor, which might be problematic for the checksum. Maybe the
> descriptor could be base64 encoded without the checksum, then attach the
> checksum to the end of the base64 text.
>
> Thoughts?
>
> I didn't come up with these ideas, they came from discussions with
> achow101.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191224/8cbce0ca/attachment.html>

From spencer.dupre at gmail.com  Tue Dec 24 19:09:33 2019
From: spencer.dupre at gmail.com (Spencer Dupre`)
Date: Tue, 24 Dec 2019 14:09:33 -0500
Subject: [bitcoin-dev] Base64-encoded descriptors
In-Reply-To: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
References: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
Message-ID: <CAOB=H7qZ55XXncp9ovR8YpXwBwoVMO=WmbPS_aRxdqk0dFoEiQ@mail.gmail.com>

Sounds like a good UX improvement, but do we really need to introduce a new
encoding? Perhaps bech32 could be used instead.

On Tue, Dec 24, 2019, 12:07 PM Chris Belcher via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I've recently been playing around with descriptors, and they are very
> nice to work with. They should become the standard for master public
> keys IMO.
>
> One downside is that users cant easily copypaste them to-and-fro to make
> watch-only wallet. The descriptors contain parenthesis and commas which
> stop highlighting by double-clicking. Also the syntax might look scary
> to newbs.
>
> An obvious solution is to base64 encode the descriptors. Then users
> would get a text blog as the master public key without any extra details
> to bother them, and developers can easily base64 decode for developing
> with them.
>
> A complication might be the descriptor checksum. If there's a typo in
> the base64 text then that could decode into multiple character errors in
> the descriptor, which might be problematic for the checksum. Maybe the
> descriptor could be base64 encoded without the checksum, then attach the
> checksum to the end of the base64 text.
>
> Thoughts?
>
> I didn't come up with these ideas, they came from discussions with
> achow101.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191224/4255cd9f/attachment.html>

From j.delbonis.3 at gmail.com  Wed Dec 25 01:02:09 2019
From: j.delbonis.3 at gmail.com (Trey Del Bonis)
Date: Tue, 24 Dec 2019 20:02:09 -0500
Subject: [bitcoin-dev] Base64-encoded descriptors
In-Reply-To: <CAOB=H7qZ55XXncp9ovR8YpXwBwoVMO=WmbPS_aRxdqk0dFoEiQ@mail.gmail.com>
References: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
 <CAOB=H7qZ55XXncp9ovR8YpXwBwoVMO=WmbPS_aRxdqk0dFoEiQ@mail.gmail.com>
Message-ID: <CAFUsdzp5d=0ErFZPfyB4Lh84HiCpWB+CfuYWRTfsFOfXL0sz4Q@mail.gmail.com>

Part of the aversion to using bech32 may be that the BCH code used in
bech32 for error detection doesn't hold up for messages longer than some
length (that I can't remember off the top of my head).  It still encodes
and decodes perfectly well but a decoder won't be guaranteed to detect
potential errors, so that's somewhat wasted there.  Maybe someone should
define a derivatives of bech32 that retains error detection properties for
longer message lengths, such as those used in lightning invoices.

QR codes (as Pavol mentioned) have built-in error detection (using its own
BCH code scheme), somewhat mitigate this when used there.  Although
personally I'm skeptical of how useful payment descriptors are for the
kinds of quick transactions that QR codes work well for.

-Trey

On Tue, Dec 24, 2019, 6:55 PM Spencer Dupre` via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Sounds like a good UX improvement, but do we really need to introduce a
> new encoding? Perhaps bech32 could be used instead.
>
> On Tue, Dec 24, 2019, 12:07 PM Chris Belcher via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I've recently been playing around with descriptors, and they are very
>> nice to work with. They should become the standard for master public
>> keys IMO.
>>
>> One downside is that users cant easily copypaste them to-and-fro to make
>> watch-only wallet. The descriptors contain parenthesis and commas which
>> stop highlighting by double-clicking. Also the syntax might look scary
>> to newbs.
>>
>> An obvious solution is to base64 encode the descriptors. Then users
>> would get a text blog as the master public key without any extra details
>> to bother them, and developers can easily base64 decode for developing
>> with them.
>>
>> A complication might be the descriptor checksum. If there's a typo in
>> the base64 text then that could decode into multiple character errors in
>> the descriptor, which might be problematic for the checksum. Maybe the
>> descriptor could be base64 encoded without the checksum, then attach the
>> checksum to the end of the base64 text.
>>
>> Thoughts?
>>
>> I didn't come up with these ideas, they came from discussions with
>> achow101.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191224/ad21c428/attachment-0001.html>

From jb55 at jb55.com  Wed Dec 25 17:17:18 2019
From: jb55 at jb55.com (William Casarin)
Date: Wed, 25 Dec 2019 12:17:18 -0500
Subject: [bitcoin-dev] Base64-encoded descriptors
In-Reply-To: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
References: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
Message-ID: <87sgl8mijl.fsf@jb55.com>


Hey Chris,

Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> I've recently been playing around with descriptors, and they are very
> nice to work with. They should become the standard for master public
> keys IMO.
>
> One downside is that users cant easily copypaste them to-and-fro to make
> watch-only wallet. The descriptors contain parenthesis and commas which
> stop highlighting by double-clicking. Also the syntax might look scary
> to newbs.
>
> An obvious solution is to base64 encode the descriptors. Then users
> would get a text blog as the master public key without any extra details
> to bother them, and developers can easily base64 decode for developing
> with them.

I don't think encoding descriptors is a good idea. Encoding makes more
sense if it's non-human-readable binary data that you want transfer over
a plaintext channel.

Descriptors aren't binary data, and have a wealth of useful information
that you can view at a glance. Obfuscating this information just to gain
the ability to copy-paste doesn't seem like a good idea.

> I didn't come up with these ideas, they came from discussions with achow101.

I suggested base58 or base62 +hrp for PSBT in id:87zhzlbfq5.fsf at jb55.com
[1] for the reasons that you mentioned, so I'm a bit sad that base64 was
chosen. base64 isn't really good for double-click copy-pasting, it
contains characters such as +/= which aren't always included when
double-clicking. I prefer bech32, base58 or base62. In this case,
encoding of any kind doesn't make much sense IMO.

Cheers,
Will

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-June/016151.html


-- 
https://jb55.com

From rsomsen at gmail.com  Thu Dec 26 02:23:10 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Thu, 26 Dec 2019 03:23:10 +0100
Subject: [bitcoin-dev] Blind Merged Mining with covenants (
	sighash_anyprevout / op_ctv )
Message-ID: <CAPv7TjYb3u9wauHQ_U9tTRKotuJushnnoAGu-MLgA_djMkdNdw@mail.gmail.com>

Blind Merged Mining (BMM) is the idea of committing the hash of another
blockchain into a unique location on the Bitcoin blockchain, and paying a
Bitcoin fee to miners for the privilege of deciding this hash and capturing
the fees inside the other blockchain. Since miners don?t have to know what
the hash represents and are simply incentivized to choose the highest
bidder, it requires no extra validation on their part (?blind?). This idea
was originally conceived of by Paul Sztorc, but required a specific soft
fork. [0]

In essence, BMM is a mechanism that allows external blockchains (altcoins,
tokens) to outsource their mining to the Bitcoin blockchain. Instead of
burning electricity with ASICs, they pay bitcoins to miners, who in turn
will perform Proof-of-Work (PoW) for the privilege of obtaining this
payment. This increases the total PoW on the Bitcoin blockchain, which adds
to the security of the Bitcoin network. It's an easy consensus mechanism to
implement, and simple to mine, only requiring full node software for both
chains and some bitcoins.

While it may be hard to justify this as a soft fork, it turns out that the
inclusion of sighash_anyprevout (previously sighash_noinput) into Bitcoin
is sufficient to make BMM work, because, as noted by Anthony Towns [1],
sighash_anyprevout allows for the creation of op_checktemplateverify
(op_ctv, previously op_securethebag) style covenants [2]. With that, we can
generate the following without any trusted setup:

- A long string of sighash_anyprevout transactions, each only spendable by
the next (the spending signature is placed in the output script, making it
a covenant)
- RBF enabled and signed with sighash flags single, anyonecanpay, and
anyprevout, allowing the addition of inputs and outputs in order to pay
fees (similar to fees in eltoo [3])
- A relative locktime of one block, ensuring only one transaction gets
mined per block

A complete transaction flow diagram can be found here:
https://gist.github.com/RubenSomsen/5e4be6d18e5fa526b17d8b34906b16a5#file-bmm-svg

(Note that op_ctv instead of sighash_anyprevout would require the use of
CPFP, because all outputs need to be pre-defined.)

This setup generates a unique location for the hash, which can be freely
competed for by anyone with the help of RBF. The hash can be committed into
the fee paying output via taproot. If the block corresponding to the hash
is not revealed or invalid, then the BMM block simply gets orphaned, just
like in Sztorc?s proposal.

While the Bitcoin blockchain will be unaware of the BMM chain, the opposite
does not have to be true. This enables some interesting possibilities. For
instance, you could make a conditional BMM token transfer that only goes
through if a specific Bitcoin transaction occurs within a certain period of
time, thus enabling atomic swaps (especially useful when combined with
asset issuance/colored coins/pegged tokens). It would also be possible to
create contracts based on Bitcoin?s hashrate and such.

It seems inevitable that this chain will need some kind of native token in
order to pay for fees. This makes me uneasy. The fairest and least
speculation-inducing method I can think of is a perpetual one-way peg,
where at any time 1 BTC can be burned for 1 token, essentially preserving
the 21M coin limit. Coins that are burned will never return, benefiting all
BTC holders equally. Holding BTC will always be preferable, because the
option to move is always open to you. This should disincentivize
speculation -- it only makes sense to move coins if they serve an immediate
purpose.

Given the lack of a block subsidy, there may not be enough impetus to move
the chain forward instead of enacting a reorg. However, BMM reorgs are
somewhat unique in that they will have to compete for the same unique
location that the original chain is using. A 10-block reorg would take 100
minutes on average to catch up, during which the original chain won?t move
forward. If fee pressure of new transactions is targeted exclusively
towards the original chain during this time [4], there would be forward
pressure that makes reorgs more expensive. Whether this mitigation is
sufficient is an open question.

Finally, it is worth asking whether BMM interferes too much with the
existing incentive structure of Bitcoin. I don?t have a clear answer, but
it should be noted that a much more inefficient version of BMM is already
possible today. One could simply use up lots of block space instead of
specifying a unique location for the hash, as demonstrated by Veriblock
[5]. I therefore believe that the same argument as adding data via
op_return applies here -- if it?s not supported, more wasteful methods may
be utilized instead.

Some technical details (thanks to Anthony Towns for providing his insights):

- Since the exact signature is committed to ahead of time, private key
security is actually irrelevant. You can simply use G to replace both R and
P instead of the usual s = r + e*p. This means anyone can easily
pre-compute all the sighash_anyprevout signatures with s = 1 + e.

- Assuming taproot, the spending script will be inside a taproot leaf,
meaning there is a key spend path which should be made unusable in order to
enforce the covenant. This can be achieved with a NUMS such as
hashToCurve(G) =  H, which can then be used as the internal taproot key T =
H + hash(H||bmm_hash)*G.

-- Ruben Somsen


[0] https://github.com/bitcoin/bips/blob/master/bip-0301.mediawiki

[1]
https://www.mail-archive.com/bitcoin-dev at lists.linuxfoundation.org/msg08075.html

[2] https://github.com/JeremyRubin/bips/blob/ctv-v2/bip-ctv.mediawiki

[3] https://blockstream.com/eltoo.pdf

[4]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016352.html

[5] https://twitter.com/lopp/status/1081558829454802945
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191226/fdba0ee1/attachment.html>

From achow101-lists at achow101.com  Thu Dec 26 05:18:00 2019
From: achow101-lists at achow101.com (Andrew Chow)
Date: Thu, 26 Dec 2019 05:18:00 +0000
Subject: [bitcoin-dev] Base64-encoded descriptors
In-Reply-To: <87sgl8mijl.fsf@jb55.com>
References: <deb1cedd-ae7d-4ef2-6b89-104183b919b4@riseup.net>
 <87sgl8mijl.fsf@jb55.com>
Message-ID: <60e86243-8aa7-8b67-1547-9114d6f1f1cd@achow101.com>

Hi All,

Just a few comments about choosing an encoding and why this is even
being proposed.


On Wednesday, December 25, 2019 12:17 PM, William Casarin via
bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I don't think encoding descriptors is a good idea. Encoding makes more
> sense if it's non-human-readable binary data that you want transfer
> over
> a plaintext channel.
>
> Descriptors aren't binary data, and have a wealth of useful
> information
> that you can view at a glance. Obfuscating this information just to
> gain
> the ability to copy-paste doesn't seem like a good idea.

The main reasons this was proposed in the first place is because of
concerns that users will be unwilling to use or be confused by descriptors.
There is a concern that users will not understand the commas,
parentheses, brackets, etc. syntax of descriptors and thus only copy
part of it.
There is also the concern that users will see this code-like syntax and
be intimidated by it so they will not want to handle them.

So my (offhanded) suggestion was to encode it in some way to just make
it look like some magic string that they need to handle as one unit.


> so I'm a bit sad that base64 was
> chosen. base64 isn't really good for double-click copy-pasting, it
> contains characters such as +/= which aren't always included when
> double-clicking. I prefer bech32, base58 or base62.

On Tuesday, December 24, 2019 2:09 PM, Spencer Dupre` via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:

> Sounds like a good UX improvement, but do we really need to introduce
a new encoding? Perhaps bech32 could be used instead.

On Tuesday, December 24, 2019 2:25 PM, Pavol Rusnak via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'd rather see something using Base58 or even better Bech32. Base64 is
not URL/QR code friendly.

A different encoding scheme could certainly be used. Base64 was
suggested in my comments to Chris and others as it is a well known
encoding scheme that doesn't already define its own checksum as Base58
and Bech32 do. This is an important detail because descriptors *also*
have their own checksum scheme.

While other encoding methods could be used, I do want to point out that
it would be nice to stick to things that already exist. We could use a
bech32-like encoding, just with the different BCH code that descriptors
use instead of the bech32 code, but calling that bech32 would be a bit
confusing. And I don't think we should use Base58 at all.

On Tuesday, December 24, 2019 8:02 PM, Trey Del Bonis via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:

> Part of the aversion to using bech32 may be that the BCH code used in
> bech32 for error detection doesn't hold up for messages longer than
> some length (that I can't remember off the top of my head).  It still
> encodes and decodes perfectly well but a decoder won't be guaranteed
> to detect potential errors, so that's somewhat wasted there.  Maybe
> someone should define a derivatives of bech32 that retains error
> detection properties for longer message lengths, such as those used in
> lightning invoices.

Descriptors already have their own BCH code for descriptor checksums
optimized for their length and character rset. This can be repurposed to
be used with whatever encoding scheme is chosen so long as the
encoding's character set is covered by the descriptor checksum character
set. The checksum's character set is fairly large and covers all(?)
characters on a standard keyboard so that descriptors could be expanded
with other features in the future. Thus it should cover any encoding
scheme that is suggested.

More information about the descriptor checksum can be found at
https://github.com/bitcoin/bitcoin/blob/master/src/script/descriptor.cpp#L26


From nico.gregory at gmail.com  Thu Dec 26 12:32:26 2019
From: nico.gregory at gmail.com (Nick Gregory)
Date: Thu, 26 Dec 2019 12:32:26 +0000
Subject: [bitcoin-dev] Blind Merged Mining with covenants (
 sighash_anyprevout / op_ctv )
In-Reply-To: <CAPv7TjYb3u9wauHQ_U9tTRKotuJushnnoAGu-MLgA_djMkdNdw@mail.gmail.com>
References: <CAPv7TjYb3u9wauHQ_U9tTRKotuJushnnoAGu-MLgA_djMkdNdw@mail.gmail.com>
Message-ID: <CAEqdS56_LaRfGihpDy7U+F-2jSzFxCFwCnFztdo2Lze0Ot-Riw@mail.gmail.com>

This not similar to MainStay?

https://commerceblock.readthedocs.io/en/latest/mainstay/index.html

https://mainstay.xyz


On Thu, Dec 26, 2019 at 2:25 AM Ruben Somsen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Blind Merged Mining (BMM) is the idea of committing the hash of another
> blockchain into a unique location on the Bitcoin blockchain, and paying a
> Bitcoin fee to miners for the privilege of deciding this hash and capturing
> the fees inside the other blockchain. Since miners don?t have to know what
> the hash represents and are simply incentivized to choose the highest
> bidder, it requires no extra validation on their part (?blind?). This idea
> was originally conceived of by Paul Sztorc, but required a specific soft
> fork. [0]
>
> In essence, BMM is a mechanism that allows external blockchains (altcoins,
> tokens) to outsource their mining to the Bitcoin blockchain. Instead of
> burning electricity with ASICs, they pay bitcoins to miners, who in turn
> will perform Proof-of-Work (PoW) for the privilege of obtaining this
> payment. This increases the total PoW on the Bitcoin blockchain, which adds
> to the security of the Bitcoin network. It's an easy consensus mechanism to
> implement, and simple to mine, only requiring full node software for both
> chains and some bitcoins.
>
> While it may be hard to justify this as a soft fork, it turns out that the
> inclusion of sighash_anyprevout (previously sighash_noinput) into Bitcoin
> is sufficient to make BMM work, because, as noted by Anthony Towns [1],
> sighash_anyprevout allows for the creation of op_checktemplateverify
> (op_ctv, previously op_securethebag) style covenants [2]. With that, we can
> generate the following without any trusted setup:
>
> - A long string of sighash_anyprevout transactions, each only spendable by
> the next (the spending signature is placed in the output script, making it
> a covenant)
> - RBF enabled and signed with sighash flags single, anyonecanpay, and
> anyprevout, allowing the addition of inputs and outputs in order to pay
> fees (similar to fees in eltoo [3])
> - A relative locktime of one block, ensuring only one transaction gets
> mined per block
>
> A complete transaction flow diagram can be found here:
>
> https://gist.github.com/RubenSomsen/5e4be6d18e5fa526b17d8b34906b16a5#file-bmm-svg
>
> (Note that op_ctv instead of sighash_anyprevout would require the use of
> CPFP, because all outputs need to be pre-defined.)
>
> This setup generates a unique location for the hash, which can be freely
> competed for by anyone with the help of RBF. The hash can be committed into
> the fee paying output via taproot. If the block corresponding to the hash
> is not revealed or invalid, then the BMM block simply gets orphaned, just
> like in Sztorc?s proposal.
>
> While the Bitcoin blockchain will be unaware of the BMM chain, the
> opposite does not have to be true. This enables some interesting
> possibilities. For instance, you could make a conditional BMM token
> transfer that only goes through if a specific Bitcoin transaction occurs
> within a certain period of time, thus enabling atomic swaps (especially
> useful when combined with asset issuance/colored coins/pegged tokens). It
> would also be possible to create contracts based on Bitcoin?s hashrate and
> such.
>
> It seems inevitable that this chain will need some kind of native token in
> order to pay for fees. This makes me uneasy. The fairest and least
> speculation-inducing method I can think of is a perpetual one-way peg,
> where at any time 1 BTC can be burned for 1 token, essentially preserving
> the 21M coin limit. Coins that are burned will never return, benefiting all
> BTC holders equally. Holding BTC will always be preferable, because the
> option to move is always open to you. This should disincentivize
> speculation -- it only makes sense to move coins if they serve an immediate
> purpose.
>
> Given the lack of a block subsidy, there may not be enough impetus to move
> the chain forward instead of enacting a reorg. However, BMM reorgs are
> somewhat unique in that they will have to compete for the same unique
> location that the original chain is using. A 10-block reorg would take 100
> minutes on average to catch up, during which the original chain won?t move
> forward. If fee pressure of new transactions is targeted exclusively
> towards the original chain during this time [4], there would be forward
> pressure that makes reorgs more expensive. Whether this mitigation is
> sufficient is an open question.
>
> Finally, it is worth asking whether BMM interferes too much with the
> existing incentive structure of Bitcoin. I don?t have a clear answer, but
> it should be noted that a much more inefficient version of BMM is already
> possible today. One could simply use up lots of block space instead of
> specifying a unique location for the hash, as demonstrated by Veriblock
> [5]. I therefore believe that the same argument as adding data via
> op_return applies here -- if it?s not supported, more wasteful methods may
> be utilized instead.
>
> Some technical details (thanks to Anthony Towns for providing his
> insights):
>
> - Since the exact signature is committed to ahead of time, private key
> security is actually irrelevant. You can simply use G to replace both R and
> P instead of the usual s = r + e*p. This means anyone can easily
> pre-compute all the sighash_anyprevout signatures with s = 1 + e.
>
> - Assuming taproot, the spending script will be inside a taproot leaf,
> meaning there is a key spend path which should be made unusable in order to
> enforce the covenant. This can be achieved with a NUMS such as
> hashToCurve(G) =  H, which can then be used as the internal taproot key T =
> H + hash(H||bmm_hash)*G.
>
> -- Ruben Somsen
>
>
> [0] https://github.com/bitcoin/bips/blob/master/bip-0301.mediawiki
>
> [1]
> https://www.mail-archive.com/bitcoin-dev at lists.linuxfoundation.org/msg08075.html
>
> [2] https://github.com/JeremyRubin/bips/blob/ctv-v2/bip-ctv.mediawiki
>
> [3] https://blockstream.com/eltoo.pdf
>
> [4]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016352.html
>
> [5] https://twitter.com/lopp/status/1081558829454802945
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191226/8a3166d9/attachment.html>

From rsomsen at gmail.com  Thu Dec 26 16:52:43 2019
From: rsomsen at gmail.com (Ruben Somsen)
Date: Thu, 26 Dec 2019 17:52:43 +0100
Subject: [bitcoin-dev] Blind Merged Mining with covenants (
 sighash_anyprevout / op_ctv )
In-Reply-To: <CAEqdS56_LaRfGihpDy7U+F-2jSzFxCFwCnFztdo2Lze0Ot-Riw@mail.gmail.com>
References: <CAPv7TjYb3u9wauHQ_U9tTRKotuJushnnoAGu-MLgA_djMkdNdw@mail.gmail.com>
 <CAEqdS56_LaRfGihpDy7U+F-2jSzFxCFwCnFztdo2Lze0Ot-Riw@mail.gmail.com>
Message-ID: <CAPv7TjY4sM=MxBfdATgkKNHTM4xnP=dCBnRZj0Oqh7KSapPUCg@mail.gmail.com>

Hello Nick,

Thank you for your interest.

It is quite different. Unlike MainStay, BMM isn't federation controlled.
It's a decentralized consensus mechanism that can function entirely without
a federation. BMM blocks are chosen by the highest bidder, which can be
anyone.

Note that it would be entirely possible for federations to issue two-way
pegged tokens on this decentralized chain, but keep in mind you'll have two
chains to worry about in terms of reorg potential (i.e. slow peg-outs).

Cheers,
Ruben

On Thu, Dec 26, 2019 at 1:32 PM Nick Gregory <nico.gregory at gmail.com> wrote:

> This not similar to MainStay?
>
> https://commerceblock.readthedocs.io/en/latest/mainstay/index.html
>
> https://mainstay.xyz
>
>
> On Thu, Dec 26, 2019 at 2:25 AM Ruben Somsen via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Blind Merged Mining (BMM) is the idea of committing the hash of another
>> blockchain into a unique location on the Bitcoin blockchain, and paying a
>> Bitcoin fee to miners for the privilege of deciding this hash and capturing
>> the fees inside the other blockchain. Since miners don?t have to know what
>> the hash represents and are simply incentivized to choose the highest
>> bidder, it requires no extra validation on their part (?blind?). This idea
>> was originally conceived of by Paul Sztorc, but required a specific soft
>> fork. [0]
>>
>> In essence, BMM is a mechanism that allows external blockchains
>> (altcoins, tokens) to outsource their mining to the Bitcoin blockchain.
>> Instead of burning electricity with ASICs, they pay bitcoins to miners, who
>> in turn will perform Proof-of-Work (PoW) for the privilege of obtaining
>> this payment. This increases the total PoW on the Bitcoin blockchain, which
>> adds to the security of the Bitcoin network. It's an easy consensus
>> mechanism to implement, and simple to mine, only requiring full node
>> software for both chains and some bitcoins.
>>
>> While it may be hard to justify this as a soft fork, it turns out that
>> the inclusion of sighash_anyprevout (previously sighash_noinput) into
>> Bitcoin is sufficient to make BMM work, because, as noted by Anthony Towns
>> [1], sighash_anyprevout allows for the creation of op_checktemplateverify
>> (op_ctv, previously op_securethebag) style covenants [2]. With that, we can
>> generate the following without any trusted setup:
>>
>> - A long string of sighash_anyprevout transactions, each only spendable
>> by the next (the spending signature is placed in the output script, making
>> it a covenant)
>> - RBF enabled and signed with sighash flags single, anyonecanpay, and
>> anyprevout, allowing the addition of inputs and outputs in order to pay
>> fees (similar to fees in eltoo [3])
>> - A relative locktime of one block, ensuring only one transaction gets
>> mined per block
>>
>> A complete transaction flow diagram can be found here:
>>
>> https://gist.github.com/RubenSomsen/5e4be6d18e5fa526b17d8b34906b16a5#file-bmm-svg
>>
>> (Note that op_ctv instead of sighash_anyprevout would require the use of
>> CPFP, because all outputs need to be pre-defined.)
>>
>> This setup generates a unique location for the hash, which can be freely
>> competed for by anyone with the help of RBF. The hash can be committed into
>> the fee paying output via taproot. If the block corresponding to the hash
>> is not revealed or invalid, then the BMM block simply gets orphaned, just
>> like in Sztorc?s proposal.
>>
>> While the Bitcoin blockchain will be unaware of the BMM chain, the
>> opposite does not have to be true. This enables some interesting
>> possibilities. For instance, you could make a conditional BMM token
>> transfer that only goes through if a specific Bitcoin transaction occurs
>> within a certain period of time, thus enabling atomic swaps (especially
>> useful when combined with asset issuance/colored coins/pegged tokens). It
>> would also be possible to create contracts based on Bitcoin?s hashrate and
>> such.
>>
>> It seems inevitable that this chain will need some kind of native token
>> in order to pay for fees. This makes me uneasy. The fairest and least
>> speculation-inducing method I can think of is a perpetual one-way peg,
>> where at any time 1 BTC can be burned for 1 token, essentially preserving
>> the 21M coin limit. Coins that are burned will never return, benefiting all
>> BTC holders equally. Holding BTC will always be preferable, because the
>> option to move is always open to you. This should disincentivize
>> speculation -- it only makes sense to move coins if they serve an immediate
>> purpose.
>>
>> Given the lack of a block subsidy, there may not be enough impetus to
>> move the chain forward instead of enacting a reorg. However, BMM reorgs are
>> somewhat unique in that they will have to compete for the same unique
>> location that the original chain is using. A 10-block reorg would take 100
>> minutes on average to catch up, during which the original chain won?t move
>> forward. If fee pressure of new transactions is targeted exclusively
>> towards the original chain during this time [4], there would be forward
>> pressure that makes reorgs more expensive. Whether this mitigation is
>> sufficient is an open question.
>>
>> Finally, it is worth asking whether BMM interferes too much with the
>> existing incentive structure of Bitcoin. I don?t have a clear answer, but
>> it should be noted that a much more inefficient version of BMM is already
>> possible today. One could simply use up lots of block space instead of
>> specifying a unique location for the hash, as demonstrated by Veriblock
>> [5]. I therefore believe that the same argument as adding data via
>> op_return applies here -- if it?s not supported, more wasteful methods may
>> be utilized instead.
>>
>> Some technical details (thanks to Anthony Towns for providing his
>> insights):
>>
>> - Since the exact signature is committed to ahead of time, private key
>> security is actually irrelevant. You can simply use G to replace both R and
>> P instead of the usual s = r + e*p. This means anyone can easily
>> pre-compute all the sighash_anyprevout signatures with s = 1 + e.
>>
>> - Assuming taproot, the spending script will be inside a taproot leaf,
>> meaning there is a key spend path which should be made unusable in order to
>> enforce the covenant. This can be achieved with a NUMS such as
>> hashToCurve(G) =  H, which can then be used as the internal taproot key T =
>> H + hash(H||bmm_hash)*G.
>>
>> -- Ruben Somsen
>>
>>
>> [0] https://github.com/bitcoin/bips/blob/master/bip-0301.mediawiki
>>
>> [1]
>> https://www.mail-archive.com/bitcoin-dev at lists.linuxfoundation.org/msg08075.html
>>
>> [2] https://github.com/JeremyRubin/bips/blob/ctv-v2/bip-ctv.mediawiki
>>
>> [3] https://blockstream.com/eltoo.pdf
>>
>> [4]
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-September/016352.html
>>
>> [5] https://twitter.com/lopp/status/1081558829454802945
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191226/3e453af7/attachment-0001.html>

From adam.ficsor73 at gmail.com  Fri Dec 27 18:03:49 2019
From: adam.ficsor73 at gmail.com (nopara73)
Date: Fri, 27 Dec 2019 14:03:49 -0400
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
Message-ID: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>

The CashFusion research came out of the Bitcoin Cash camp, thus this
probably went under the radar of many of you. I would like to ask your
opinions on the research's claim that, if non-equal value coinjoins can be
really relied on for privacy or not.

(Btw, there were also similar ideas in the Knapsack paper in 2017:
https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf
 )

https://github.com/cashshuffle/spec/blob/master/CASHFUSION.md#avoiding-amount-linkages-through-combinatorics


I copy the most relevant paragraphs here:

  ---------BEGIN QUOTE ---------


Consider a transaction where 10 people have each brought 10 inputs of
arbitary amounts in the neighborhood of ~0.1 BCH. One input might be
0.03771049 BCH; the next might be 0.24881232 BCH, etc. All parties have
chosen to consolidate their coins, so the transaction has 10 outputs of
around 1 BCH. So the transaction has 100 inputs, and 10 outputs. The first
output might be 0.91128495, the next could be 1.79783710, etc.

Now, there are 100!/(10!)^10 ~= 10^92 ways to partition the inputs into a
list of 10 sets of 10 inputs, but only a tiny fraction of these partitions
will produce the precise output list. So, how many ways produce this exact
output list? We can estimate with some napkin math. First, recognize that
for each partitioning, each output will typically land in a range of ~10^8
discrete possibilities (around 1 BCH wide, with a 0.00000001 BCH
resolution). The first 9 outputs all have this range of possibilities, and
the last will be constrained by the others. So, the 10^92 possibilies will
land somewhere within a 9-dimensional grid that cointains (10^8)^9=10^72
possible distinct sites, one site which is our actual output list. Since we
are stuffing 10^92 possibilties into a grid that contains only 10^72 sites,
then this means on average, each site will have 10^20 possibilities.

Based on the example above, we can see that not only are there a huge
number of partitions, but that even with a fast algorithm that could find
matching partitions, it would produce around 10^20 possible valid
configurations. With 10^20 possibilities, there is essentially no linkage.
The Cash Fusion scheme actually extends this obfuscation even further. Not
only can players bring many inputs, they can also have multiple outputs.
---------END QUOTE ---------
-- 
Best,
?d?m
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191227/6b744205/attachment.html>

From eth3rs at gmail.com  Sat Dec 28 17:38:11 2019
From: eth3rs at gmail.com (Ethan Heilman)
Date: Sat, 28 Dec 2019 12:38:11 -0500
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
Message-ID: <CAEM=y+XdaLLW+EBt8TnceHmpBhFDJnX3jYY=zs_PW6fy-QFRBA@mail.gmail.com>

I'm only going to talk about cashfusion and not the knapsack paper.

The language they use to describe the cashfusion protocol is very
broad and could describe many things. Because it is hard so vague I
don't want to dismiss the cashfusion approach out of hand. For
instance they say: "inputs of arbitary amounts in the neighborhood of
~0.1 BCH" what exactly does this mean?

Attack 1:
If we assume arbitrary means any precision then a trivial attack is
possible. Consider the case where one of the inputs has more precision
than any other input. This allows an attacker to trivially break the
privacy of that input:

Lets look at a toy example that takes 12 inputs and creates 3 outputs
inputs:
0.1525
0.1225
0.1145
0.1443
0.1144111
0.1001
0.1124
0.1093
0.1113
0.1134
0.1029
0.1206

Outputs:
0.4648111
0.5185
0.4349

Clearly output output 0.4648111 contains input 0.1144111.

Attack 2:
Let's say you attempt to address this problem this by limiting the
precision of inputs to two decimal places i.e. 0.1X where 0<=X<=9.
Consider the case of 10 users where each user is always joining sets
of 10 inputs to create 1 output. Thus in total you would have 100
inputs and 10 outputs in the coinjoin. If one of those outputs is 2
then you know its inputs must all be 0.2. Using this method you can
start eliminate input output pairs far faster brute force. How much
faster is hard to say without adding additional assumptions for
instance are these inputs amounts drawn from a uniform distribution?

I want to be clear. I'm not saying cashfusion is broken or that this
more inputs than outputs technique is a dead end. However the
description given is vague and could be interpreted to describe a
broken protocol. Is this actively being used?

On Fri, Dec 27, 2019 at 8:29 PM nopara73 via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> The CashFusion research came out of the Bitcoin Cash camp, thus this probably went under the radar of many of you. I would like to ask your opinions on the research's claim that, if non-equal value coinjoins can be really relied on for privacy or not.
>
> (Btw, there were also similar ideas in the Knapsack paper in 2017: https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf )
>
> https://github.com/cashshuffle/spec/blob/master/CASHFUSION.md#avoiding-amount-linkages-through-combinatorics
>
> I copy the most relevant paragraphs here:
>
>   ---------BEGIN QUOTE ---------
>
>
> Consider a transaction where 10 people have each brought 10 inputs of arbitary amounts in the neighborhood of ~0.1 BCH. One input might be 0.03771049 BCH; the next might be 0.24881232 BCH, etc. All parties have chosen to consolidate their coins, so the transaction has 10 outputs of around 1 BCH. So the transaction has 100 inputs, and 10 outputs. The first output might be 0.91128495, the next could be 1.79783710, etc.
>
> Now, there are 100!/(10!)^10 ~= 10^92 ways to partition the inputs into a list of 10 sets of 10 inputs, but only a tiny fraction of these partitions will produce the precise output list. So, how many ways produce this exact output list? We can estimate with some napkin math. First, recognize that for each partitioning, each output will typically land in a range of ~10^8 discrete possibilities (around 1 BCH wide, with a 0.00000001 BCH resolution). The first 9 outputs all have this range of possibilities, and the last will be constrained by the others. So, the 10^92 possibilies will land somewhere within a 9-dimensional grid that cointains (10^8)^9=10^72 possible distinct sites, one site which is our actual output list. Since we are stuffing 10^92 possibilties into a grid that contains only 10^72 sites, then this means on average, each site will have 10^20 possibilities.
>
> Based on the example above, we can see that not only are there a huge number of partitions, but that even with a fast algorithm that could find matching partitions, it would produce around 10^20 possible valid configurations. With 10^20 possibilities, there is essentially no linkage. The Cash Fusion scheme actually extends this obfuscation even further. Not only can players bring many inputs, they can also have multiple outputs.
>
> ---------END QUOTE ---------
> --
> Best,
> ?d?m
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Sat Dec 28 23:25:07 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 28 Dec 2019 23:25:07 +0000
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
Message-ID: <zlmDLPI5ns68UtpmU4KnIQff7O1V7sqI3-nzQ2i1axQXiyUsX0IhW5F7TAjoRAfIak1vw7LYaxhSCAHoi0r--DI6RFz7FhYGVQ_lBXi5L9M=@protonmail.com>

Good morning Adam,

> The CashFusion research came out of the Bitcoin Cash camp, thus this probably went under the radar of many of you. I would like to ask your opinions on the research's claim that, if non-equal value coinjoins can be really relied on for privacy or not.
>
> (Btw, there were also similar ideas in the Knapsack paper in 2017:?https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf?)?
>
> https://github.com/cashshuffle/spec/blob/master/CASHFUSION.md#avoiding-amount-linkages-through-combinatorics??
>
> I copy the most relevant paragraphs here:
>
> ? ---------BEGIN QUOTE ---------?
> ?
>
> Consider a transaction where 10 people have each brought 10 inputs of arbitary amounts in the neighborhood of ~0.1 BCH. One input might be 0.03771049 BCH; the next might be 0.24881232 BCH, etc. All parties have chosen to consolidate their coins, so the transaction has 10 outputs of around 1 BCH. So the transaction has 100 inputs, and 10 outputs. The first output might be 0.91128495, the next could be 1.79783710, etc.
>
> Now, there are 100!/(10!)^10 ~= 10^92 ways to partition the inputs into a list of 10 sets of 10 inputs, but only a tiny fraction of these partitions will produce the precise output list. So, how many ways produce this exact output list? We can estimate with some napkin math. First, recognize that for each partitioning, each output will typically land in a range of ~10^8 discrete possibilities (around 1 BCH wide, with a 0.00000001 BCH resolution). The first 9 outputs all have this range of possibilities, and the last will be constrained by the others. So, the 10^92 possibilies will land somewhere within a 9-dimensional grid that cointains (10^8)^9=10^72 possible distinct sites, one site which is our actual output list. Since we are stuffing 10^92 possibilties into a grid that contains only 10^72 sites, then this means on average, each site will have 10^20 possibilities.
>
> Based on the example above, we can see that not only are there a huge number of partitions, but that even with a fast algorithm that could find matching partitions, it would produce around 10^20 possible valid configurations. With 10^20 possibilities, there is essentially no linkage. The Cash Fusion scheme actually extends this obfuscation even further. Not only can players bring many inputs, they can also have multiple outputs.
>
> ---------END QUOTE ---------
> --


It seems to me that most users will not have nearly the same output of "around 1 BTC" anyway if you deploy this on a real live mainnet, and if your math requires that you have "around 1 BTC" outputs per user. you might as well just use equal-valued CoinJoins, where the equal-valued outputs at least are completely unlinked from the inputs.

Indeed, the change outputs of an equal-valued CoinJoin would have similar analyses to CashFusion, since the same analysis "around 1 BTC" can be performed with the CoinJoin change outputs "around 0 BTC".

* You can always transform a CashFusion transaction whose outputs are "around 1 BTC" to a CoinJoin transaction with equal-valued outputs and some change outputs, with the equal-valued outputs having equal value to the smallest CashFusion output.
 * e.g. if you have a CashFusion transaction with outputs 1.0, 1.1, 0.99, you could transform that to a CoinJoin with 0.99, 0.99, 0.99, 0.01, 0.11 outputs.
* Conversely, you can transform an equal-valued CoinJoin transaction to a CashFusion transaction using the same technique.
* That implies that the change outputs of an equal-valued CoinJoin have the same linkability as the outputs of the equivalent CashFusion transaction.
* At least with equal-valued CoinJoin, the equal-valued outputs have 0 linkability with inputs (at least with only that transaction in isolation).
  The same cannot be said of CashFusion, because the value involved is just in a single UTXO.

Regards,
ZmnSCPxj

From nothingmuch at woobling.org  Sun Dec 29 03:31:48 2019
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Sun, 29 Dec 2019 03:31:48 +0000
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
Message-ID: <CAAQdECBqFKxAoZXCkWynN4wj5g8C9vzdhuEWk9b-BYqDW=us6g@mail.gmail.com>

Hi,

On Sat, 28 Dec 2019 at 01:29, nopara73 via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

I haven't read the whole thing in detail (and fwiw, I don't think I will by
this point), but I do want to respond to section about the combinatorics as
well as the proof, since both the premises and the implications don't seem
very solid to me, especially in light of the other replies in this thread.

It appears to be a step up from the Knapsack paper in terms of the
specificity of a concrete mixing protocol (which again, I did not
scrutinize, but see below), but a regression in terms of privacy (see other
replies), which even in the Knapsack paper's approach raises some concerns:

Now, there are 100!/(10!)^10 ~= 10^92 ways to partition the inputs into a
> list of 10 sets of 10 inputs, but only a tiny fraction of these partitions
> will produce the precise output list.
>
In the equal amount case, the search space of possible interpretations with
n = # inputs + # indistinguishable outputs is proportional to the nth Bell
number, i.e. it's exponential in the size of the transaction, which is an
inviting intuition. But this is an *upper* bound on the difficulty of
deanonymization, given no additional information.

This quantitative framing is potentially misleading because:

1. attributing inputs/outputs (sub-transactions in the Knapsack paper's
terminology) is arguably not a search problem, but an optimization problem,
since approximate results are still partly useful to the adversary
2. there are many computational strategies, heuristics, etc that in
practice can make this more efficient than brute force[1], so framing it
that as a security parameter doesn't sit right with me
3. as individual sub-transactions are identified (for example using out of
band information), the computational challenge also *drops* exponentially
fast

Additionally (though is a broader criticism of CoinJoin based privacy and
not specific to unequal amounts, and in particular refers to ZmnSCPxj's
assertion of 0 linkability) I am very worried that perspectives that focus
on linkability information revealed by a single coinjoin transaction in
isolation. This problem was alluded in the document, to but I don't see
that it was addressed. Naively the post/pre mix transaction graph would
seem to present a computationally much harder problem when looking at the
combinatorics through the same lens, but reality it can also be used to
place many constraints on valid partitions/sub-transaction assignments for
a single transaction with equal amounts. The trivial example is post mix
linking of outputs, but there are many other ways to draw inferences or
eliminate possible interpretations of a single transaction based on its
wider context, which in turn may be used to attack other transactions.


> Based on the example above, we can see that not only are there a huge
> number of partitions, but that even with a fast algorithm that could find
> matching partitions, it would produce around 10^20 possible valid
> configurations. With 10^20 possibilities, there is essentially no linkage.
>
This is a better framing, but still doesn't address my third bullet, since
"Attacks always get better; they never get worse." In other words
"essentially no linkage" due to multiple possible interpretation is still
strictly more meaningful if you can add constraints out of band.

To be fair in equal amount CoinJoins this is also the case, but it's a much
simpler model to consider in the context of other privacy leak vectors
(e.g. transaction graph connectivity beyond a single coinjoin, wallet
fingerprinting, temporal patterns, network privacy leaks, etc etc), since
analyzing your level of exposure is *also* complicated by unequal amounts,
in other words higher chance of privacy leaks due to misuse, or ignorance
of some of the implications under intended use. Thinking through these
implications is much easier when the information content in the amounts is
minimized.

The Cash Fusion scheme actually extends this obfuscation even further. Not
> only can players bring many inputs, they can also have multiple outputs
>
And, quoting another section:

Unfortunately, the production of equal-amount coins is impractical for
> various reasons. Foremost, it has a "toxic waste"
>

I'm still cautiously optimistic about the potential of multiple
inputs/outputs per user (c.f. 3-phase chaumian CoinJoin ideas we've
previously discussed in the context of Wasabi, though I don't recall any
public discussion I can link to, sorry list), but with the additional
assumption of amounts with small popcounts/Hamming weights (e.g. only
amounts that are 2^n sat in size, or based on 1-2-5 series, and for a
rationale see Ethan's reply).

Unfortunately this trades off that "toxic waste" problem for a very large
on chain footprint (e.g. if the popcount of the amount of a wallet is
limited to 1, the number of inputs and change outputs required in the worst
case is proportional to log of the payment amount) and significant UTXO
bloat (several mixed outputs per magnitude for transaction size to scale as
the popcount(payment amount) instead of the log(payment amount))

However, with OP_CHECKTEMPLATEVERIFY and Taproot, this overhead could
potentially be mitigated (something more like TumbleBit's privacy model,
but with an on chain footprint similar to multiparty payment channels as
described in the OP_CTV BIP draft) since the safety guaranteed by
CoinJoins' atomicity can be preserved without requiring atomicity of the
mixing itself, which can extend over multiple transactions and long time
intervals, while still providing the liquidity and finality and unilateral
exit option of payment channels. By moving such low hamming weight amount
outputs off chain, and allowing them to be mixed (with equal amounts),
split and merged off chain. The simpler analysis of equal amount outputs
could still be assumed which makes analysis easier and assumptions about
adversary weaker, and furthermore this approach would better align the
incentives for batching and privacy, which is why I think it's very
promising.

Finally, the proof as well as its applicability seems suspect to me, since
seems to involve trusting the server:
"Since the distinct list [...] [is] kept on the server and not shared with
the players"
"The server knows the linkages of the commitments but does not participate
as a verifier "
"If there is a problem [...] each component is assigned to another player
at random for verification"
these 3 statements together seems to suggest the server is trusted to not
use sybils in order the compromise privacy by participating in the
verification process?

(also, and although this is nitpicking, also does not seem to be
demonstrating "soundness" in any sense that I am familiar with - wouldn't
break in soundness only imply DoS vector?)

[1] btw, although I still owe you (nopara73) some consistently working
linear programming code to attribute change outputs in Wasabi (sorry! i
suck...), but anecdotally, in the special cases I did manage to solve even
transactions with tens of inputs do not present a challenge even to
supposedly slow/inefficient solvers compared to the state of the art. Even
though it's just anecdotal and in the context of the easier problem of
attributing change, which can still be ambiguous in Wasabi transactions, i
still think this puts into question the privacy of mixing based on a
dubious hardness assumption and a computationally bounded adversary, as
opposed to something which (in the scope of a single mixing transaction) is
perfectly hiding.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191229/9b2cd993/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sun Dec 29 10:23:39 2019
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 29 Dec 2019 10:23:39 +0000
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <CAAQdECBqFKxAoZXCkWynN4wj5g8C9vzdhuEWk9b-BYqDW=us6g@mail.gmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
 <CAAQdECBqFKxAoZXCkWynN4wj5g8C9vzdhuEWk9b-BYqDW=us6g@mail.gmail.com>
Message-ID: <Ucl9pe26g2ECz-SRmXPV3WLxVR8PBOf0dnMR_aD8NwTqBNmq6e3a9hKJtwkYPJz7v_QUCxT_Y5X0w1VkvbiQZ6H3QJVcOtpUhNYTQ29rwFA=@protonmail.com>

Good morning Yuval,


> Additionally (though is a broader criticism of CoinJoin based privacy and not specific to unequal amounts, and in particular refers to ZmnSCPxj's assertion of 0 linkability) I am very worried that perspectives that focus on linkability information revealed by a single coinjoin transaction in isolation. This problem was alluded in the document, to but I don't see that it was addressed. Naively the post/pre mix transaction graph would seem to present a computationally much harder problem when looking at the combinatorics through the same lens, but reality it can also be used to place many constraints on valid partitions/sub-transaction assignments for a single transaction with equal amounts. The trivial example is post mix linking of outputs, but there are many other ways to draw inferences or eliminate possible interpretations of a single transaction based on its wider context, which in turn may be used to attack other transactions.

Indeed, this is a problem still of equal-valued CoinJoin.
In theory the ZeroLink protocol fixes this by strongly constraining user behavior, but ZeroLink is not "purely" implemented in e.g. Wasabi: Wasabi still allows spending pre- and post-mix coins in the same tx (ZeroLink disallows this) and any mix change should be considered as still linked to the inputs (though could be unlinked from the equal-valued output), i.e. returned to pre-mix wallet.

> Finally, the proof as well as its applicability seems suspect to me, since seems to involve trusting the server:
> "Since the distinct list [...] [is] kept on the server and not shared with the players"
> "The server knows the linkages of the commitments but does not participate as a verifier "
> "If there is a problem [...] each component is assigned to another player at random for verification"
> these 3 statements together seems to suggest the server is trusted to not use sybils in order the compromise privacy by participating in the verification process?

Equal-valued CoinJoins fix this by using a Chaumian bank, which constrains value transfers to specific fixed amounts.
Since an equal-valued CoinJoin uses a single fixed amount anyway, it is not an additional restriction.
CashFusion cannot use the same technique without dropping into something very much like an equal-valued CoinJoin.

Regards,
ZmnSCPxj

From nothingmuch at woobling.org  Sun Dec 29 09:57:48 2019
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Sun, 29 Dec 2019 11:57:48 +0200
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <CAAQdECBqFKxAoZXCkWynN4wj5g8C9vzdhuEWk9b-BYqDW=us6g@mail.gmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
 <CAAQdECBqFKxAoZXCkWynN4wj5g8C9vzdhuEWk9b-BYqDW=us6g@mail.gmail.com>
Message-ID: <CAAQdECA7BHR2A5xPnuLsriY1DaLwrvfHg3B+-MCbRUcxxM-GOg@mail.gmail.com>

On Sun, 29 Dec 2019, 05:31 Yuval Kogman, <nothingmuch at woobling.org> wrote:

> n = # inputs + # indistinguishable outputs
>

sorry, this is really wrong (although of no consequence to my arguments) -
n is the smaller of these two numbers, not their sum.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191229/190287fb/attachment.html>

From lucasontivero at gmail.com  Mon Dec 30 01:14:19 2019
From: lucasontivero at gmail.com (Lucas Ontivero)
Date: Sun, 29 Dec 2019 22:14:19 -0300
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
Message-ID: <CALHvQn06DSPnxWYDEoi_28s9ukaC0Be1sCf0cvv44f2cz0f5hA@mail.gmail.com>

This idea is not similar to the one in the knapsack paper because this one
is based only in the computational complexity of finding partitions that
match the outputs. However, and except in rare cases, there is only one
valid partition (solution) for each output, it doesn't introduce any
ambiguity. Knapsack, on the other hand, splits the original outputs in such
a way that there are many partitions (solutions) that match the a selected
group of outputs. For example, imagine 7 people decide to participate in a
coinjoin transaction with an arbitrary number of inputs (no more than 7
inputs each), imagine this is not a pay to yourself cj tx but a pay to
someone else cjtx instead such that there are at most 2 outputs for
participants (payment output and change output) in this case, configuring
the partitions search algorithm to restrict the search space to sets of 7
inputs maximum and 4 outputs maximum it found 14,599 valid transactions in
42mins 18secs
https://raw.githubusercontent.com/lontivero/Knapsack/master/data/knapsack-7-participants.txt

The same simulation with 8 participants under the same conditions found
35,781 valid transactions in about 4 hours. Finally, with 9 participants I
let it running all the day and it didn't finished. The point is that the
number of valid transactions grows so incredible fast that with 100
participants even if you find a way to find all the partitions that matches
a set of outputs (something near to impossible), there are no way to know
which of those are the real ones.

Also, the attacks on this mechanism look so simple that generate doubts.
Finally, I think the numbers in this proposal look weird because the
example is using 10 inputs and the amounts are in the "neighborhood of
~0.1btc" (what the heck does that mean?) and the sum of those are around
1btc. That means that it could work in a very specific scenario. Knapsack
is a general solution with good math behind and backtested against
historical data extracted from the bitcoin's blockchain.

In summary, in unequal inputs/outputs coinjoins knapsack is the best we
have at the moment (btw, it is not as effective as equal-outputs
transactions). This proposal is imo inferior and it is not supported by
good math.


El vie., 27 dic. 2019 a las 22:29, nopara73 via bitcoin-dev (<
bitcoin-dev at lists.linuxfoundation.org>) escribi?:

> The CashFusion research came out of the Bitcoin Cash camp, thus this
> probably went under the radar of many of you. I would like to ask your
> opinions on the research's claim that, if non-equal value coinjoins can be
> really relied on for privacy or not.
>
> (Btw, there were also similar ideas in the Knapsack paper in 2017:
> https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf
>  )
>
>
> https://github.com/cashshuffle/spec/blob/master/CASHFUSION.md#avoiding-amount-linkages-through-combinatorics
>
>
> I copy the most relevant paragraphs here:
>
>   ---------BEGIN QUOTE ---------
>
>
> Consider a transaction where 10 people have each brought 10 inputs of
> arbitary amounts in the neighborhood of ~0.1 BCH. One input might be
> 0.03771049 BCH; the next might be 0.24881232 BCH, etc. All parties have
> chosen to consolidate their coins, so the transaction has 10 outputs of
> around 1 BCH. So the transaction has 100 inputs, and 10 outputs. The first
> output might be 0.91128495, the next could be 1.79783710, etc.
>
> Now, there are 100!/(10!)^10 ~= 10^92 ways to partition the inputs into a
> list of 10 sets of 10 inputs, but only a tiny fraction of these partitions
> will produce the precise output list. So, how many ways produce this exact
> output list? We can estimate with some napkin math. First, recognize that
> for each partitioning, each output will typically land in a range of ~10^8
> discrete possibilities (around 1 BCH wide, with a 0.00000001 BCH
> resolution). The first 9 outputs all have this range of possibilities, and
> the last will be constrained by the others. So, the 10^92 possibilies will
> land somewhere within a 9-dimensional grid that cointains (10^8)^9=10^72
> possible distinct sites, one site which is our actual output list. Since we
> are stuffing 10^92 possibilties into a grid that contains only 10^72 sites,
> then this means on average, each site will have 10^20 possibilities.
>
> Based on the example above, we can see that not only are there a huge
> number of partitions, but that even with a fast algorithm that could find
> matching partitions, it would produce around 10^20 possible valid
> configurations. With 10^20 possibilities, there is essentially no linkage.
> The Cash Fusion scheme actually extends this obfuscation even further. Not
> only can players bring many inputs, they can also have multiple outputs.
> ---------END QUOTE ---------
> --
> Best,
> ?d?m
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191229/87d4973c/attachment.html>

From nothingmuch at woobling.org  Sun Dec 29 17:48:38 2019
From: nothingmuch at woobling.org (Yuval Kogman)
Date: Sun, 29 Dec 2019 17:48:38 +0000
Subject: [bitcoin-dev] Non-equal value CoinJoins. Opinions.
In-Reply-To: <Ucl9pe26g2ECz-SRmXPV3WLxVR8PBOf0dnMR_aD8NwTqBNmq6e3a9hKJtwkYPJz7v_QUCxT_Y5X0w1VkvbiQZ6H3QJVcOtpUhNYTQ29rwFA=@protonmail.com>
References: <CAEPKjgdtgDbyLoj6FV+cjY1Djca_FBtd9Kt_eB4zWU+at=wfYQ@mail.gmail.com>
 <CAAQdECBqFKxAoZXCkWynN4wj5g8C9vzdhuEWk9b-BYqDW=us6g@mail.gmail.com>
 <Ucl9pe26g2ECz-SRmXPV3WLxVR8PBOf0dnMR_aD8NwTqBNmq6e3a9hKJtwkYPJz7v_QUCxT_Y5X0w1VkvbiQZ6H3QJVcOtpUhNYTQ29rwFA=@protonmail.com>
Message-ID: <CAAQdECCCPL1jezCpFEbj=9r5=ho33dfvd=AQCzGpczKKrD8omw@mail.gmail.com>

Hi,

On Sun, 29 Dec 2019 at 10:23, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

>
> Indeed, this is a problem still of equal-valued CoinJoin.
> In theory the ZeroLink protocol fixes this by strongly constraining user
> behavior, but ZeroLink is not "purely" implemented in e.g. Wasabi: Wasabi
> still allows spending pre- and post-mix coins in the same tx (ZeroLink
> disallows this) and any mix change should be considered as still linked to
> the inputs (though could be unlinked from the equal-valued output), i.e.
> returned to pre-mix wallet.
>

Yes, although since the base denomination size is pretty large this can be
very limiting, possibly forcing these change outputs to be linked to each
other or, worse, with unmixed inputs which is still a serious linkage
concern. This is further complicated due to variability of the denomination
(which makes remixing possible due to the fee structure, but see below)
also leaks some information or requires linking of mixed outputs in
addition (although this resets its notion of anonymity set size, so I don't
consider this unsafe or misleading, just wasteful) or in change being
donated to the coordinator due to not meeting the threshold, depending on
the "phase angle" between a user's past mixes and the coordinator's current
denomination.

>
> Equal-valued CoinJoins fix this by using a Chaumian bank, which constrains
> value transfers to specific fixed amounts.
> Since an equal-valued CoinJoin uses a single fixed amount anyway, it is
> not an additional restriction.
> CashFusion cannot use the same technique without dropping into something
> very much like an equal-valued CoinJoin.
>

I concur.

I need to write a proper account of what I alluded to in my last email, but
here's a summary (allowing myself to keep it in this thread as the subject
was unequal amounts and opinions ;-)

1. introduce another stage between the input/output phases - at input
registration you would receive chaumian reissuable/redenominatable tokens
after deduction of per input fees, which you can then "spend" to create
outputs (instead of the chaumian token itself being an output script)

2. replace the current notion of a mixing round into several sub-types:
  - "decompose" - take an arbitrary amount and produce
popcount(amount-fees) outputs with popcount = 1 (anon set size assumed to
be 1)
  - "mix" - mix popcount == 1 amounts with equal sized outputs - this is
the only round type that can increase anon set size
  - "optimize" - convert mixed, popcount == 1 (e.g. { 2^n} <-> { 2^(n-1),
2^(n-1) } ) - it's not clear to me to what anon set size should be
considered after this, probably reset to somewhere between 1 and the
minimum size of the inputs, depending on degree of linkage
  - "combine" - spend popcount == 1 outputs to produce arbitrary amounts

Note that simultaneous rounds can be merged by the server during the
signing phase, such so that for example a "decompose" output may benefit
from inhabiting the same CoinJoin transaction as a mixing round with the
same denomination, but the coordinator would still be able to categorically
distinguish between these, so this should not be thought of as a robust
privacy improvement (but it does make some other adversary's job harder
given only public data).

In order to preserve the exact denomination size for mixing transactions,
such rounds would need to have their mining fees subsidized - this can be
accomplished by such merging, with the coordinator discounting or
subsidizing input/output registration fees depending on the degree of
mixing (a la Samourai/Whirlpool's mechanism design), or using some sort of
prepaid mechanism (e.g. as part of a mixing round instead of a registered
output you might elect to receive long lived - as in not per round -
chaumian tokens that can be redeemed for fee-less, round denomination
mixing, which can be reissued if the signing phase fails). In both cases
I'm assuming the coordinator includes an input to cover the mining fees.

I find the privacy aspects much easier to think about in this model, and it
addresses many things of zerolink's weaknesses:

1. allows unequal amounts but retains many of the advantages of fixed
denomination - the number of separate mixing pools would be at most
log(2.1e13), with their sizes corresponding to actual amount distribution
being used (for mining & coordination fees too, but more generally any
amounts used for any Bitcoin payment)

2. it can potentially eliminate post mix change (if I want to spend some
amount x = \sum{i=1..~40} a_i*2^i, and i have exactly the combination
specified by the a_i's) which the server can also enforce by restricting
"combine" rounds to require "optimize" rounds before them

3. increases privacy benefit of remixing while still removing Wasabi's
round denomination decreases, especially over long time intervals

The main issue, which I stress is significant, is the bloat - many such
rounds are required, with many inputs and outputs per user per round, and
many UTXOs per user on average. This can be alleviated to a certain degree
by batching. Although this leaks information about payment linkage post mix
which can be attacked by partitioning, the risk is still mitigated since
the amounts themselves are low hamming weight and since consolidations
still happen in mixing rounds. Since the intra-round tokens are reissuable,
they are transferable as well, so this effectively makes everything into a
payment hub protocol (e.g. if Alice wants to pay Bob and Carol, registers
an input receiving tokens, splits those as necessary to accommodate the
payment & change amounts, and transfers some subsets to Bob and Carol, who
are free to register their own output(s). Payment is finalized if the
mixing succeeds and the transaction is mined). That in turn led to thinking
of how payment channels or multiparty payment might be used in a Chaumian
CoinJoin protocol (see also our private correspondence of some months ago),
but naively this approach makes many tradeoffs like a slight departure from
CoinJoin's notion of trustless mixing or requiring interaction between
participants post-mix (which introduces new privacy concerns, or at least
significant complexity). Since covenants were re-raised, and specifically
OP_STB/CTV's approach to congestion control and multiparty payment channels
in the context of Taproot & SIGHASH_NOINPUT/ANYPREVOUT etc. I believe that
this approach can actually made to be size efficient by just keeping the
low hamming weight outputs virtual, but I still haven't worked this out in
detail (still overwhelmed by the size of this design space).
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20191229/d2ab40f3/attachment-0001.html>

