From jtimon at jtimon.cc  Sat Jan  2 16:37:54 2016
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Sat, 2 Jan 2016 17:37:54 +0100
Subject: [bitcoin-dev] Segregated witnesses and validationless mining
In-Reply-To: <20151231234847.GB5112@muck>
References: <20151223013119.GA31113@muck>
	<20151231234847.GB5112@muck>
Message-ID: <CABm2gDpSnX=_jXdHMyoTd-ktXT_U-6NAVDgGMj_R2kHGYykYyA@mail.gmail.com>

Is there a link to the IRC discussion?
On Jan 1, 2016 12:49 AM, "Peter Todd via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Tue, Dec 22, 2015 at 05:31:19PM -0800, Peter Todd via bitcoin-dev
wrote:
> > # Summary
>
> Updates from IRC discussion:

Is there a link to the IRC discussion?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160102/209a13ac/attachment.html>

From kanzure at gmail.com  Sat Jan  2 16:54:43 2016
From: kanzure at gmail.com (Bryan Bishop)
Date: Sat, 2 Jan 2016 10:54:43 -0600
Subject: [bitcoin-dev] Segregated witnesses and validationless mining
In-Reply-To: <CABm2gDpSnX=_jXdHMyoTd-ktXT_U-6NAVDgGMj_R2kHGYykYyA@mail.gmail.com>
References: <20151223013119.GA31113@muck> <20151231234847.GB5112@muck>
	<CABm2gDpSnX=_jXdHMyoTd-ktXT_U-6NAVDgGMj_R2kHGYykYyA@mail.gmail.com>
Message-ID: <CABaSBawAgCZ5C0Ft+NaOshQgBms7EsnFEnE4=bZcyktqwUtiTw@mail.gmail.com>

On Sat, Jan 2, 2016 at 10:37 AM, Jorge Tim?n
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Updates from IRC discussion:
>
> Is there a link to the IRC discussion?

prior-block possession proofs, fraud proofs, non-fraud correctness
proofs, commitments and segwit:
https://botbot.me/freenode/bitcoin-core-dev/2015-12-28/?msg=56907496&page=2

- Bryan
http://heybryan.org/
1 512 203 0507

From joe2015 at openmailbox.org  Sun Jan  3 03:51:26 2016
From: joe2015 at openmailbox.org (joe2015 at openmailbox.org)
Date: Sun, 03 Jan 2016 11:51:26 +0800
Subject: [bitcoin-dev] An implementation of BIP102 as a softfork.
In-Reply-To: <CAKJqnrE7W8aRgracL1cy_hBLWpVsTAQL4qg4ViSP9aCHvM1yvA@mail.gmail.com>
References: <6fc10e581a81abb76be5cd49275ebf48@openmailbox.org>
	<CAKJqnrGUKeUb7g4SrjnWNAcPZOuLDKB-kjP2+Jy8Rdk_MfWLyQ@mail.gmail.com>
	<814e1ba765445a4c3b7364c471299393@openmailbox.org>
	<CAKJqnrE7W8aRgracL1cy_hBLWpVsTAQL4qg4ViSP9aCHvM1yvA@mail.gmail.com>
Message-ID: <3b3d9102043577785d1b1679704eabfd@openmailbox.org>

On 2016-01-03 02:46, Marco Falke wrote:
> 2015-12-30 17:27 GMT+01:00  <joe2015 at openmailbox.org>:
>> On 2015-12-30 18:33, Marco Falke wrote:
>>> 
>>> This is an interesting approach but I don't see how this is a soft
>>> fork. (Just because something is not a hard fork, doesn't make it a
>>> soft fork by definition)
>>> Softforks don't require any nodes to upgrade. [1]
>>> Nonetheless, as I understand your approach, it requires nodes to
>>> upgrade. Otherwise they are missing all transactions but the coinbase
>>> transactions. Thus, they cannot update their utxoset and are easily
>>> susceptible to double spends...
>>> 
>>> Am I missing something obvious?
>>> 
>>> -- Marco
>>> 
>>> 
>>> [1] https://en.bitcoin.it/wiki/Softfork#Implications
>> 
>> 
>> It just depends how you define "softfork".  In my original write-up I 
>> called
>> it a "generalized" softfork, Peter suggested a "firm" fork, and there 
>> are
>> some suggestions for other names.  Ultimately what you call it is not 
>> very
>> important.
>> 
>> --joe.
> 
> joe, indeed it is not important how you call it, but please, let's not
> call it "soft fork".

This kind of fork (whatever it is called) has all the traditional 
properties of a softfork except meaningful backwards compatibility for 
non-upgraded clients.  So I think it is reasonable to call it a softfork 
with some qualification.

> Besides my initial question about the coinbase
> tx, I was also wondering how non-updated nodes would verify the
> collected fees without the actual txs at hand. (They only have the
> coinbase tx, don't they?)

Yes this appears to be an oversight in my proof-of-concept 
implementation.  The unintended consequence being that all transactions 
would have to be zero-fee...

The simplest fix would be make the new rules add the fees implicitly.  
There are other solutions.

> Moreover, I can't see the benefits over a hard fork. A hard fork is
> much cleaner in regard to code changes. As one of the intends of
> "generalized soft forks" is to force user to update, at least a hard
> fork doesn't lie about the fact. Am I missing any obvious advantages
> of a "generalized soft fork" over a "clean" hard fork?

A "firm soft fork" also does not lie about that fact -- you must 
upgrade.  I don't see it dishonest if it was never claimed otherwise.

I agree that hardforks can be "cleaner".

However the obvious disadvantage of a hardfork is the risk of the 
network splitting between upgraded and non-upgraded clients.  This is 
not a problem if there is 100% consensus behind the hardfork, but I am 
not sure if 100% is realistically achievable for contentious issues such 
as the blocksize limit.

If 100% consensus is never achieved, then the options are:
1. Never upgrade and keep the blocksize limit unchanged forever.
2. Use a firm softfork to resolve the deadlock.
3. Hardfork anyway and split the network.

My argument is simply that 2 is better than 3 and possibly 1.

--joe


From rusty at rustcorp.com.au  Sun Jan  3 23:31:26 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 04 Jan 2016 10:01:26 +1030
Subject: [bitcoin-dev] [BIP Draft] Decentralized Improvement Proposals
In-Reply-To: <201512302347.17609.luke@dashjr.org>
References: <1451493317.3215816.479282618.4F666D71@webmail.messagingengine.com>
	<201512301710.27154.luke@dashjr.org>
	<1451499779.3919416.479357794.2C21BFA1@webmail.messagingengine.com>
	<201512302347.17609.luke@dashjr.org>
Message-ID: <878u46s0j5.fsf@rustcorp.com.au>

Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> On Wednesday, December 30, 2015 6:22:59 PM Tomas wrote:
>> > The specification itself looks like an inefficient and bloaty reinvention
>> > of version bits.
>> 
>> The actual assignment of version bits isn't clear from the
>> specification. Are you saying that any implementation that wants to
>> propose a change is encouraged to pick a free version bit and use it?
>
> That should probably be clarified in the BIP, I agree. Perhaps it ought to be 
> assigned the same as BIP numbers themselves, by the BIP editor? (Although as a 
> limited resource, maybe that's not the best solution.)

I thought about it, but it's subject to change.  Frankly, the number of
deployed forks is low enough that they can sort it out themselves.  If
we need something more robust, I'm happy to fill that role.

Cheers,
Rusty.


From nickodell at gmail.com  Mon Jan  4 18:04:29 2016
From: nickodell at gmail.com (Nick ODell)
Date: Mon, 4 Jan 2016 11:04:29 -0700
Subject: [bitcoin-dev] An implementation of BIP102 as a softfork.
In-Reply-To: <3b3d9102043577785d1b1679704eabfd@openmailbox.org>
References: <6fc10e581a81abb76be5cd49275ebf48@openmailbox.org>
	<CAKJqnrGUKeUb7g4SrjnWNAcPZOuLDKB-kjP2+Jy8Rdk_MfWLyQ@mail.gmail.com>
	<814e1ba765445a4c3b7364c471299393@openmailbox.org>
	<CAKJqnrE7W8aRgracL1cy_hBLWpVsTAQL4qg4ViSP9aCHvM1yvA@mail.gmail.com>
	<3b3d9102043577785d1b1679704eabfd@openmailbox.org>
Message-ID: <CANN4kme78DzknfOY_kOG0Bo+v16O1McxznCi4VPq5p9HxgzuKw@mail.gmail.com>

How are you collecting fees from the transactions in the block?

On Sat, Jan 2, 2016 at 8:51 PM, joe2015--- via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On 2016-01-03 02:46, Marco Falke wrote:
>>
>> 2015-12-30 17:27 GMT+01:00  <joe2015 at openmailbox.org>:
>>>
>>> On 2015-12-30 18:33, Marco Falke wrote:
>>>>
>>>>
>>>> This is an interesting approach but I don't see how this is a soft
>>>> fork. (Just because something is not a hard fork, doesn't make it a
>>>> soft fork by definition)
>>>> Softforks don't require any nodes to upgrade. [1]
>>>> Nonetheless, as I understand your approach, it requires nodes to
>>>> upgrade. Otherwise they are missing all transactions but the coinbase
>>>> transactions. Thus, they cannot update their utxoset and are easily
>>>> susceptible to double spends...
>>>>
>>>> Am I missing something obvious?
>>>>
>>>> -- Marco
>>>>
>>>>
>>>> [1] https://en.bitcoin.it/wiki/Softfork#Implications
>>>
>>>
>>>
>>> It just depends how you define "softfork".  In my original write-up I
>>> called
>>> it a "generalized" softfork, Peter suggested a "firm" fork, and there are
>>> some suggestions for other names.  Ultimately what you call it is not
>>> very
>>> important.
>>>
>>> --joe.
>>
>>
>> joe, indeed it is not important how you call it, but please, let's not
>> call it "soft fork".
>
>
> This kind of fork (whatever it is called) has all the traditional properties
> of a softfork except meaningful backwards compatibility for non-upgraded
> clients.  So I think it is reasonable to call it a softfork with some
> qualification.
>
>> Besides my initial question about the coinbase
>> tx, I was also wondering how non-updated nodes would verify the
>> collected fees without the actual txs at hand. (They only have the
>> coinbase tx, don't they?)
>
>
> Yes this appears to be an oversight in my proof-of-concept implementation.
> The unintended consequence being that all transactions would have to be
> zero-fee...
>
> The simplest fix would be make the new rules add the fees implicitly.  There
> are other solutions.
>
>> Moreover, I can't see the benefits over a hard fork. A hard fork is
>> much cleaner in regard to code changes. As one of the intends of
>> "generalized soft forks" is to force user to update, at least a hard
>> fork doesn't lie about the fact. Am I missing any obvious advantages
>> of a "generalized soft fork" over a "clean" hard fork?
>
>
> A "firm soft fork" also does not lie about that fact -- you must upgrade.  I
> don't see it dishonest if it was never claimed otherwise.
>
> I agree that hardforks can be "cleaner".
>
> However the obvious disadvantage of a hardfork is the risk of the network
> splitting between upgraded and non-upgraded clients.  This is not a problem
> if there is 100% consensus behind the hardfork, but I am not sure if 100% is
> realistically achievable for contentious issues such as the blocksize limit.
>
> If 100% consensus is never achieved, then the options are:
> 1. Never upgrade and keep the blocksize limit unchanged forever.
> 2. Use a firm softfork to resolve the deadlock.
> 3. Hardfork anyway and split the network.
>
> My argument is simply that 2 is better than 3 and possibly 1.
>
> --joe
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From luke at dashjr.org  Mon Jan  4 21:53:36 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 4 Jan 2016 21:53:36 +0000
Subject: [bitcoin-dev] Increasing the blocksize as a (generalized)
	softfork.
In-Reply-To: <1bf64a5b514d57ca37744ae5f5238149@openmailbox.org>
References: <1bf64a5b514d57ca37744ae5f5238149@openmailbox.org>
Message-ID: <201601042153.37771.luke@dashjr.org>

On Sunday, December 20, 2015 10:56:33 AM joe2015--- via bitcoin-dev wrote:
> "generalized" softfork.

FWIW, this is something I've been planning to proposed (in a nicer form) for a 
while, tentatively called a "soft hardfork" (or less-seriously a "softserve 
hardfork"). The big piece missing that I've been holding off on publishing it 
as a BIP until complete, is a planned-out defensive reaction for a community 
which wishes to reject the hardfork. I guess I should probably prioritise this 
a bit more now...

Luke

From joe2015 at openmailbox.org  Tue Jan  5 01:26:59 2016
From: joe2015 at openmailbox.org (joe2015 at openmailbox.org)
Date: Tue, 05 Jan 2016 09:26:59 +0800
Subject: [bitcoin-dev] An implementation of BIP102 as a softfork.
In-Reply-To: <CANN4kme78DzknfOY_kOG0Bo+v16O1McxznCi4VPq5p9HxgzuKw@mail.gmail.com>
References: <6fc10e581a81abb76be5cd49275ebf48@openmailbox.org>
	<CAKJqnrGUKeUb7g4SrjnWNAcPZOuLDKB-kjP2+Jy8Rdk_MfWLyQ@mail.gmail.com>
	<814e1ba765445a4c3b7364c471299393@openmailbox.org>
	<CAKJqnrE7W8aRgracL1cy_hBLWpVsTAQL4qg4ViSP9aCHvM1yvA@mail.gmail.com>
	<3b3d9102043577785d1b1679704eabfd@openmailbox.org>
	<CANN4kme78DzknfOY_kOG0Bo+v16O1McxznCi4VPq5p9HxgzuKw@mail.gmail.com>
Message-ID: <640324f3e4cafd1fecfef809a8cb017d@openmailbox.org>

On 2016-01-05 02:04, Nick ODell wrote:
> How are you collecting fees from the transactions in the block?

Probably the simplest way to do this is to map the new-rules coinbase tx 
(which collects the block reward and fees) into an old-rules legacy 
coinbase tx (which collects the block reward only).  Care must be taken 
to ensure the mapping is not reversible.  I will update my 
implementation in due course.

--joe.

From jl2012 at xbt.hk  Tue Jan  5 05:43:41 2016
From: jl2012 at xbt.hk (jl2012)
Date: Tue, 05 Jan 2016 00:43:41 -0500
Subject: [bitcoin-dev] Segregated Witness BIPs
In-Reply-To: <77ba13602b2d9e3c0f56a41a9799021a@xbt.hk>
References: <em3b62e758-afbe-4aed-a08d-eb85b252efc4@platinum>
	<77ba13602b2d9e3c0f56a41a9799021a@xbt.hk>
Message-ID: <18f27064f026b117d6dc6fc95b57891f@xbt.hk>

A new BIP, as part of the SW softfork, is pending BIP number assignment:

https://github.com/bitcoin/bips/pull/270

This proposal defines a new transaction digest algorithm for signature 
verification in version 0 and version 1 witness program, in order to 
minimize redundant data hashing in verification (solving the O(n^2) 
issue), and to cover the input value by the signature (a frequently 
requested feature for cold wallet).

jl2012 via bitcoin-dev ? 2015-12-24 09:22 ??:
> The SW payment address format BIP draft is ready and is pending BIP
> number assignment:
> https://github.com/bitcoin/bips/pull/267
> 
> This is the 3rd BIP for segwit. The 2nd one for Peer Services is being
> prepared by Eric Lombrozo
> 
> Eric Lombrozo via bitcoin-dev ? 2015-12-23 10:22 ??:
>> I've been working with jl2012 on some SEGWIT BIPs based on earlier
>> discussions Pieter Wuille's implementation. We're considering
>> submitting three separate BIPs:
>> 
>> CONSENSUS BIP: witness structures and how they're committed to blocks,
>> cost metrics and limits, the scripting system (witness programs), and
>> the soft fork mechanism.
>> 
>> PEER SERVICES BIP: relay message structures, witnesstx serialization,
>> and other issues pertaining to the p2p protocol such as IBD,
>> synchronization, tx and block propagation, etc...
>> 
>> APPLICATIONS BIP: scriptPubKey encoding formats and other wallet
>> interoperability concerns.
>> 
>> The Consensus BIP is submitted as a draft and is pending BIP number
>> assignment: https://github.com/bitcoin/bips/pull/265 [1]
>> The other two BIPS will be drafted soon.
>> 
>> ---
>> Eric
>> 
>> Links:
>> ------
>> [1] https://github.com/bitcoin/bips/pull/265
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From mail at felixweis.com  Wed Jan  6 15:18:56 2016
From: mail at felixweis.com (Felix Weis)
Date: Wed, 06 Jan 2016 15:18:56 +0000
Subject: [bitcoin-dev] Confidential Transactions as a soft fork (using
	segwit)
Message-ID: <CAMnWzuVi2qK6FhML=R5M1r95i1346J5YpUuOd1=StSdAZXfG3g@mail.gmail.com>

Since the release of sidechains alpha, confidential transactions[1] by Greg
Maxwell have show how they could greatly improve transaction privacy and
fungibility of bitcoin. Unfortunately without a hardfork or pegged
sidechain it was not easy to enable them in bitcoin.

The segregated witness[2] proposal by Pieter Wuille allows to reduce the
blockchain to a mere utxo changeset while putting all cryptographic proofs
(redeemscript/pubkeys/signatures) for the inputs into a witness part.
Segwit also allows upgradable scripting language. All can be done with a
soft fork.

We propose an upgrade to segwit to allow transactions to have both
witnessIns and witnessOuts.

We also propose 3 new transactions types: blinding, unblinding and
confidential. Valid blocks containing any of these new transactions MUST
also include a mandatory special output in their coinbase transaction and a
new special confidential base transaction.

The basic idea for confidential transaction is to use 0 value inputs and
outputs while having the encrypted amounts (petersen-commitment +
range-proof) in the witnessOut part. These transactions are valid under old
rules (but currently non-standard). For blinding, unblinding and miner fees
we use a single anyone-can-spend output (GCTXO) which will be updated in
every block containing confidential transactions.

Blinding transaction:
  Ins:
    All non-confidential inputs are valid
  Outs:
  - 0..N: (new confidential outputs)
    amount: 0
    scriptPubkey: OP_2 <0x{32-byte-hash-value}>
    witnessOut: <0x{petersen-commitment}> <0x{range-proof}>
  - last:
    amount: 0
    scriptPubkey: OP_RETURN OP_2 {blinding-fee-amount}
  Fee: Sum of the all inputs value
The last output's script is also a marker of the transaction being a
blinding tx. After the soft fork, a block is invalid if the miner claims
the fees for himself instead of putting it into a special coinbase output.


Coinbase transaction:
If the block contains blinding transactions, it MUST send the sum of all
their fees to a new output: GCTXO[coinbase]
The scriptPubkey does not really matter since it will be only spendable
under strict rules in the same block's confidential base transaction. Maybe
OP_TRUE.


Unblinding transaction:
  Ins:
    prev: CTXO[n]
    scriptSig: (empty)
    witnessIn: <signature> <0x{redeemscript}>
  Outs:
  - 0..N:
    amount: 0
  scriptPubkey: OP_RETURN OP_2 {amount-to-be-unblinded} {p2sh-destination}
    witnessOut: (empty)
  - last:
    amount: 0
    scriptPubkey: OP_RETURN OP_2 {unblinding-fee-amount}
  Fee: 0

This transaction remove removes the confidential outputs from the utxo set.
This outpoint itself is not spendable (it's OP_RETURN), but the same block
will contain a confidential base transaction created by the miner that will
satisfy the amount and p2sh-destination (refunded using GCTXO).
Confidential transaction:
  Ins:
  - 0..N:
    prev: CTXO[n]
    scriptSig: (empty)
    witnessIn: <signature> <0x{redeemscript}>
  Outs:
  - 0..N:
    amount: 0
    scriptPubkey: OP_2 <0x{32-byte-hash-value}>
    witnessOut: <0x{petersen-commitment}> <0x{range-proof}>
  - last:
    amount: 0
    scriptPubkey: OP_RETURN OP_2 {confidential-fee-amount}
  Fee: 0

All inputs and outputs and have amount 0 and are everyone can spend V2
segwit, thus valid under old rules. Transaction valid under new rules
obviously only if petersen commitment and range-proof in witnessOut valid.
Minerfee for this transaction is expressed as one extra output:


Confidential base transaction:
  Ins:
    GCTXO[last_block],
    GCTXO[coinbase]
  Outs:
    0: GCTXO[current_block]
    amount: {last_block + coinbase - unblindings}
    scriptPubkey: OP_TRUE
    1..N:
    amount/scriptPubkey: as requested by unblinding transactions in this
block
  Fee:
    Sum of all the explicit OP_RETURN OP_2 {...} expressed fees from
    confidential transactions in this block

This special transaction in last position in every block that contains at
least one of the new transaction types. Created by the miner of the block
and used to do the actual unblinding and redeeming transaction fees for all
confidential transactions.

There will always be only 1 GCTXO in the utxo set. This allows for full
accountability for 21 million bitcoin. Should a vulnerability in CT be
discovered all unconfidential bitcoins remain safe. Under these new rules,
a block is only valid if all amounts/commitments/range-proofs match. A a
miner trying use GCTXO other than allowed in the single confidential base
transaction
will be orphaned.

[1] https://people.xiph.org/~greg/confidential_values.txt
[2]
https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki


Sorry for the form, this is just a quick draft of a thought I had today.
Please comment.

Felix Weis
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160106/94ee558a/attachment.html>

From elombrozo at gmail.com  Thu Jan  7 13:28:18 2016
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Thu, 07 Jan 2016 05:28:18 -0800
Subject: [bitcoin-dev] SegWit testnet is live
Message-ID: <059B0A23-1423-4167-B86E-FD7C804E7F49@gmail.com>

I am pleased to report that as of December 31, 2015 we have been successfully running a segregated witness testnet, called segnet, and have already implemented rudimentary wallets with support.

For source code, please look at sipa's github repo:
https://github.com/sipa/bitcoin/tree/segwit

And some example signing code at my repo:
https://github.com/CodeShark/BitcoinScriptExperiments/blob/master/src/signwitnesstx.cpp

Several wallets have already committed to supporting it including mSIGNA, GreenAddress, GreenBits, Blocktrail, and NBitcoin. More wallets are expected to be added to this list soon. If you're a wallet dev and are interested in developing and testing on segnet please contact me.

We're right on schedule and are very excited about the fundamental improvements to bitcoin that segwit will enable.

---
Eric

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/b6f64fe3/attachment.html>

From elombrozo at gmail.com  Thu Jan  7 13:56:57 2016
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Thu, 07 Jan 2016 05:56:57 -0800
Subject: [bitcoin-dev] SegWit testnet is live
In-Reply-To: <059B0A23-1423-4167-B86E-FD7C804E7F49@gmail.com>
References: <059B0A23-1423-4167-B86E-FD7C804E7F49@gmail.com>
Message-ID: <9080AE86-C75D-497B-B03E-30C9986E621A@gmail.com>

I have been informed that Breadwallet has also committed to supporting segwit.

The list now includes Blocktrail, Breadwallet, GreenAddress, GreenBits, mSIGNA, and NBitcoin.

---
Eric

On January 7, 2016 5:28:18 AM PST, Eric Lombrozo <elombrozo at gmail.com> wrote:
>I am pleased to report that as of December 31, 2015 we have been
>successfully running a segregated witness testnet, called segnet, and
>have already implemented rudimentary wallets with support.
>
>For source code, please look at sipa's github repo:
>https://github.com/sipa/bitcoin/tree/segwit
>
>And some example signing code at my repo:
>https://github.com/CodeShark/BitcoinScriptExperiments/blob/master/src/signwitnesstx.cpp
>
>Several wallets have already committed to supporting it including
>mSIGNA, GreenAddress, GreenBits, Blocktrail, and NBitcoin. More wallets
>are expected to be added to this list soon. If you're a wallet dev and
>are interested in developing and testing on segnet please contact me.
>
>We're right on schedule and are very excited about the fundamental
>improvements to bitcoin that segwit will enable.
>
>---
>Eric
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/300c0445/attachment.html>

From luke at dashjr.org  Thu Jan  7 17:10:55 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 7 Jan 2016 17:10:55 +0000
Subject: [bitcoin-dev] New BIP editor, and request for information
Message-ID: <201601071710.57868.luke@dashjr.org>

Greg has requested that I take over as the BIP editor responsible for 
assigning BIP numbers. Before I begin, I would like to ensure I have a correct 
record of what has already been assigned or soft-assigned so I don't overlap 
them, as the BIPs repository appears that it may possibly be incomplete.

If you have been assigned (or soft-assigned) a BIP number - or any other 
information that may be relevant to my performing this role, please reply and 
let me know, preferably within the next 24 hours if possible (as there are 
many BIP drafts awaiting assignments).

Getting into some specifics...

- BIP 46 is missing from the repository, but apparently self-soft-assigned by 
Tier Nolan in https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-April/005545.html ; if this was later assigned official, or if he is still 
interested in pursuing this, it seems logical to just keep it at BIP 46.

- BIPs 80 and 81 are currently part of an open pull request 
https://github.com/bitcoin/bips/pull/170, but it is unclear if they were 
formally assigned or not.

- BIP 82 is currently officially assigned and pending in 
https://github.com/bitcoin/bips/pull/171 ; I personally think this is outside 
the scope of BIPs since it does not deal with Bitcoin, and encourage Justus to 
move it to the SLIP standard, but will honour this assignment unless he tells 
me he is moving it. (But understand this will not set a precedent for strictly 
non-Bitcoin things being assigned BIPs...)

- BIP 100 is missing from the repository, and I am uncertain if it was ever 
properly assigned. Considering that the 10x block has mostly been used for 
similar proposals, and BIP 100 is fairly well-established as "BIP 100", it 
seems logical to just make this its official assignment.

- BIP 104 is missing from the repository, but was apparently used unofficially 
by https://drive.google.com/file/d/0BwEbhrQ4ELzBX3hCekFRSUVySWs/view at one 
time. But I do not see an actual specification in this PDF, so as far as I 
know BIP 104 appears to be available?

- BIP 109 was soft-assigned for 
https://gist.github.com/erasmospunk/23040383b7620b525df0, but as this doesn't 
fit with the rest of 10x, I am inclined to give it a new number outside that 
range unless there are objections.

- BIP 122 is missing from the repository, and was self-soft-assigned by Chris 
Priest for "ScaleNet" in https://github.com/bitcoin/bips/pull/222 ; there are 
concerns whether testnets are appropriate for standardisation at all, but 
since it has received sufficient discussion on the mailing list and others 
appear to agree with the effort, it seems reasonable to err in favour of 
assigning it a BIP number (not necessarily 122) if Chris wishes to further 
pursue the idea and add an actual specification to the draft.

To be clear: except for BIPs 82 and 109, and those appearing in the 
https://github.com/bitcoin/bips repository at present, anyone (preferably the 
author, but not necessarily if they are away) aware of any other BIP 
assignments should reply to this message indicating the status of such BIPs 
and their assigned numbers.

Thanks,

Luke

From gavinandresen at gmail.com  Thu Jan  7 19:02:05 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 7 Jan 2016 14:02:05 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or not?
Message-ID: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>

I'm hoisting this from some private feedback I sent on the segregated
witness BIP:

I said:

"I'd also use RIPEMD160(SHA256()) as the hash function and save the 12
bytes-- a successful preimage attack against that ain't gonna happen before
we're all dead. I'm probably being dense, but I just don't see how a
collision attack is relevant here."

Pieter responded:

"The problem case is where someone in a contract setup shows you a script,
which you accept as being a payment to yourself. An attacker could use a
collision attack to construct scripts with identical hashes, only one of
which does have the property you want, and steal coins.

So you really want collision security, and I don't think 80 bits is
something we should encourage for that. Normal pubkey hashes don't have
that problem, as they can't be constructed to pay to you."
... but I'm unconvinced:

"But it is trivial for contract wallets to protect against collision
attacks-- if you give me a script that is "gavin_pubkey CHECKSIG
arbitrary_data OP_DROP" with "I promise I'm not trying to rip you off, just
ignore that arbitrary data" a wallet can just refuse. Even more likely, a
contract wallet won't even recognize that as a pay-to-gavin transaction.

I suppose it could be looking for some form of "gavin_pubkey
somebody_else_pubkey CHECKMULTISIG ... with the attacker using
somebody_else_pubkey to force the collision, but, again, trivial contract
protocol tweaks ("send along a proof you have the private key corresponding
to the public key" or "everybody pre-commits pubkeys they'll use at
protocol start") would protect against that.

Adding an extra 12 bytes to every segwit to prevent an attack that takes
2^80 computation and 2^80 storage, is unlikely to be a problem in practice,
and is trivial to protect against is the wrong tradeoff to make."

20 bytes instead of 32 bytes is a savings of almost 40%, which is
significant.

The general question I'd like to raise on this list is:

Should we be worried, today, about collision attacks against RIPEMD160 (our
160-bit hash)?

Mounting a successful brute-force collision attack would require at least
O(2^80) CPU, which is kinda-sorta feasible (Pieter pointed out that Bitcoin
POW has computed more SHA256 hashes than that). But it also requires
O(2^80) storage, which is utterly infeasible (there is something on the
order of 2^35 bytes of storage in the entire world).  Even assuming
doubling every single year (faster than Moore's Law), we're four decades
away from an attacker with THE ENTIRE WORLD's storage capacity being able
to mount a collision attack.


References:

https://en.wikipedia.org/wiki/Collision_attack

https://vsatglobalseriesblog.wordpress.com/2013/06/21/in-2013-the-amount-of-data-generated-worldwide-will-reach-four-zettabytes/


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/09860830/attachment.html>

From lf-lists at mattcorallo.com  Thu Jan  7 19:13:22 2016
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 7 Jan 2016 19:13:22 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
 not?
In-Reply-To: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
Message-ID: <568EB8D2.20104@mattcorallo.com>

We absolutely should be worried about 80-bit collision resistance.
Collisions only take 2**80 work if the hash is theoretically perfect,
which is never the case, not to mention that collision resistance is
almost always the first thing to go for hash functions, and often starts
to get easier slowly long, long before anyone is truly worried about the
security of the hash function.

I would never assume RIPEMD160's collision resistance is 2**80, and
would definitely never wager a significant amount of money that this
remains true for, say, five years.

Matt

On 01/07/16 19:02, Gavin Andresen via bitcoin-dev wrote:
> I'm hoisting this from some private feedback I sent on the segregated
> witness BIP:
> 
> I said:
> 
> "I'd also use RIPEMD160(SHA256()) as the hash function and save the 12
> bytes-- a successful preimage attack against that ain't gonna happen
> before we're all dead. I'm probably being dense, but I just don't see
> how a collision attack is relevant here."
> 
> Pieter responded:
> 
> "The problem case is where someone in a contract setup shows you a
> script, which you accept as being a payment to yourself. An attacker
> could use a collision attack to construct scripts with identical hashes,
> only one of which does have the property you want, and steal coins.
> 
> So you really want collision security, and I don't think 80 bits is
> something we should encourage for that. Normal pubkey hashes don't have
> that problem, as they can't be constructed to pay to you."
> 
> ... but I'm unconvinced:
> 
> "But it is trivial for contract wallets to protect against collision
> attacks-- if you give me a script that is "gavin_pubkey CHECKSIG
> arbitrary_data OP_DROP" with "I promise I'm not trying to rip you off,
> just ignore that arbitrary data" a wallet can just refuse. Even more
> likely, a contract wallet won't even recognize that as a pay-to-gavin
> transaction.
> 
> I suppose it could be looking for some form of "gavin_pubkey
> somebody_else_pubkey CHECKMULTISIG ... with the attacker using
> somebody_else_pubkey to force the collision, but, again, trivial
> contract protocol tweaks ("send along a proof you have the private key
> corresponding to the public key" or "everybody pre-commits pubkeys
> they'll use at protocol start") would protect against that.
> 
> Adding an extra 12 bytes to every segwit to prevent an attack that takes
> 2^80 computation and 2^80 storage, is unlikely to be a problem in
> practice, and is trivial to protect against is the wrong tradeoff to make."
> 
> 20 bytes instead of 32 bytes is a savings of almost 40%, which is
> significant.
> 
> The general question I'd like to raise on this list is:
> 
> Should we be worried, today, about collision attacks against RIPEMD160
> (our 160-bit hash)?
> 
> Mounting a successful brute-force collision attack would require at
> least O(2^80) CPU, which is kinda-sorta feasible (Pieter pointed out
> that Bitcoin POW has computed more SHA256 hashes than that). But it also
> requires O(2^80) storage, which is utterly infeasible (there is
> something on the order of 2^35 bytes of storage in the entire world). 
> Even assuming doubling every single year (faster than Moore's Law),
> we're four decades away from an attacker with THE ENTIRE WORLD's storage
> capacity being able to mount a collision attack.
> 
> 
> References: 
> 
> https://en.wikipedia.org/wiki/Collision_attack
> 
> https://vsatglobalseriesblog.wordpress.com/2013/06/21/in-2013-the-amount-of-data-generated-worldwide-will-reach-four-zettabytes/
> 
> 
> -- 
> --
> Gavin Andresen
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From adam at cypherspace.org  Thu Jan  7 19:19:42 2016
From: adam at cypherspace.org (Adam Back)
Date: Thu, 7 Jan 2016 20:19:42 +0100
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
Message-ID: <CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>

You could say 256 bit ECDSA is overkill lets go to 160 equivalently.
Saves even more bytes.

The problem with arguing down is where to stop.

As Matt said these things dont degrade gracefully so a best practice
is to aim for a bit of extra margin.

256-bit is quite common at this point since AES, SHA256 etc even in
things with much less at stake than Bitcoin.

You could send the compressed (unhashed) pubkey then there's no hash
(and omit it from the sig).  Greg had mentioned that in the past.

I think it might be possible to do both (reclaim the hash bits in the
serialisation of the pub key).

Adam

On 7 January 2016 at 20:02, Gavin Andresen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I'm hoisting this from some private feedback I sent on the segregated
> witness BIP:
>
> I said:
>
> "I'd also use RIPEMD160(SHA256()) as the hash function and save the 12
> bytes-- a successful preimage attack against that ain't gonna happen before
> we're all dead. I'm probably being dense, but I just don't see how a
> collision attack is relevant here."
>
> Pieter responded:
>
> "The problem case is where someone in a contract setup shows you a script,
> which you accept as being a payment to yourself. An attacker could use a
> collision attack to construct scripts with identical hashes, only one of
> which does have the property you want, and steal coins.
>
> So you really want collision security, and I don't think 80 bits is
> something we should encourage for that. Normal pubkey hashes don't have that
> problem, as they can't be constructed to pay to you."
>
> ... but I'm unconvinced:
>
> "But it is trivial for contract wallets to protect against collision
> attacks-- if you give me a script that is "gavin_pubkey CHECKSIG
> arbitrary_data OP_DROP" with "I promise I'm not trying to rip you off, just
> ignore that arbitrary data" a wallet can just refuse. Even more likely, a
> contract wallet won't even recognize that as a pay-to-gavin transaction.
>
> I suppose it could be looking for some form of "gavin_pubkey
> somebody_else_pubkey CHECKMULTISIG ... with the attacker using
> somebody_else_pubkey to force the collision, but, again, trivial contract
> protocol tweaks ("send along a proof you have the private key corresponding
> to the public key" or "everybody pre-commits pubkeys they'll use at protocol
> start") would protect against that.
>
> Adding an extra 12 bytes to every segwit to prevent an attack that takes
> 2^80 computation and 2^80 storage, is unlikely to be a problem in practice,
> and is trivial to protect against is the wrong tradeoff to make."
>
> 20 bytes instead of 32 bytes is a savings of almost 40%, which is
> significant.
>
> The general question I'd like to raise on this list is:
>
> Should we be worried, today, about collision attacks against RIPEMD160 (our
> 160-bit hash)?
>
> Mounting a successful brute-force collision attack would require at least
> O(2^80) CPU, which is kinda-sorta feasible (Pieter pointed out that Bitcoin
> POW has computed more SHA256 hashes than that). But it also requires O(2^80)
> storage, which is utterly infeasible (there is something on the order of
> 2^35 bytes of storage in the entire world).  Even assuming doubling every
> single year (faster than Moore's Law), we're four decades away from an
> attacker with THE ENTIRE WORLD's storage capacity being able to mount a
> collision attack.
>
>
> References:
>
> https://en.wikipedia.org/wiki/Collision_attack
>
> https://vsatglobalseriesblog.wordpress.com/2013/06/21/in-2013-the-amount-of-data-generated-worldwide-will-reach-four-zettabytes/
>
>
> --
> --
> Gavin Andresen
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From dscotese at litmocracy.com  Thu Jan  7 20:56:33 2016
From: dscotese at litmocracy.com (Dave Scotese)
Date: Thu, 7 Jan 2016 12:56:33 -0800
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
Message-ID: <CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>

Maybe I'm being dense, but I don't see why 2**80 storage is required for
this attack.  Also, I don't see why the attacker ever needs to get the
victim to accept "arbitrary_data".  Perhaps I'm wrong about how the
collision attack works:

   1. Create a script which is perfectly acceptable and would pass the
   sniff test Gavin proposed (no arbitrary_data).
   2. Set off CPU power to construct a second script that lets attacker
   keep his coins and has the same hash. (This is where you get
   "arbitrary_data").
   3. Send a transaction with the first script to the seller as payment.
   4. Wait for the transaction to be included in a block.
   5. Redeem the transaction with the second script, thus stealing the
   coins back.

So the seller would never see the I'd appreciate any correction to my
understanding here.  Where do you need 2**80 storage?  And when does the
seller have to accept "arbitrary_data"?
Thanks!

On Thu, Jan 7, 2016 at 11:19 AM, Adam Back via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> You could say 256 bit ECDSA is overkill lets go to 160 equivalently.
> Saves even more bytes.
>
> The problem with arguing down is where to stop.
>
> As Matt said these things dont degrade gracefully so a best practice
> is to aim for a bit of extra margin.
>
> 256-bit is quite common at this point since AES, SHA256 etc even in
> things with much less at stake than Bitcoin.
>
> You could send the compressed (unhashed) pubkey then there's no hash
> (and omit it from the sig).  Greg had mentioned that in the past.
>
> I think it might be possible to do both (reclaim the hash bits in the
> serialisation of the pub key).
>
> Adam
>
> On 7 January 2016 at 20:02, Gavin Andresen via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > I'm hoisting this from some private feedback I sent on the segregated
> > witness BIP:
> >
> > I said:
> >
> > "I'd also use RIPEMD160(SHA256()) as the hash function and save the 12
> > bytes-- a successful preimage attack against that ain't gonna happen
> before
> > we're all dead. I'm probably being dense, but I just don't see how a
> > collision attack is relevant here."
> >
> > Pieter responded:
> >
> > "The problem case is where someone in a contract setup shows you a
> script,
> > which you accept as being a payment to yourself. An attacker could use a
> > collision attack to construct scripts with identical hashes, only one of
> > which does have the property you want, and steal coins.
> >
> > So you really want collision security, and I don't think 80 bits is
> > something we should encourage for that. Normal pubkey hashes don't have
> that
> > problem, as they can't be constructed to pay to you."
> >
> > ... but I'm unconvinced:
> >
> > "But it is trivial for contract wallets to protect against collision
> > attacks-- if you give me a script that is "gavin_pubkey CHECKSIG
> > arbitrary_data OP_DROP" with "I promise I'm not trying to rip you off,
> just
> > ignore that arbitrary data" a wallet can just refuse. Even more likely, a
> > contract wallet won't even recognize that as a pay-to-gavin transaction.
> >
> > I suppose it could be looking for some form of "gavin_pubkey
> > somebody_else_pubkey CHECKMULTISIG ... with the attacker using
> > somebody_else_pubkey to force the collision, but, again, trivial contract
> > protocol tweaks ("send along a proof you have the private key
> corresponding
> > to the public key" or "everybody pre-commits pubkeys they'll use at
> protocol
> > start") would protect against that.
> >
> > Adding an extra 12 bytes to every segwit to prevent an attack that takes
> > 2^80 computation and 2^80 storage, is unlikely to be a problem in
> practice,
> > and is trivial to protect against is the wrong tradeoff to make."
> >
> > 20 bytes instead of 32 bytes is a savings of almost 40%, which is
> > significant.
> >
> > The general question I'd like to raise on this list is:
> >
> > Should we be worried, today, about collision attacks against RIPEMD160
> (our
> > 160-bit hash)?
> >
> > Mounting a successful brute-force collision attack would require at least
> > O(2^80) CPU, which is kinda-sorta feasible (Pieter pointed out that
> Bitcoin
> > POW has computed more SHA256 hashes than that). But it also requires
> O(2^80)
> > storage, which is utterly infeasible (there is something on the order of
> > 2^35 bytes of storage in the entire world).  Even assuming doubling every
> > single year (faster than Moore's Law), we're four decades away from an
> > attacker with THE ENTIRE WORLD's storage capacity being able to mount a
> > collision attack.
> >
> >
> > References:
> >
> > https://en.wikipedia.org/wiki/Collision_attack
> >
> >
> https://vsatglobalseriesblog.wordpress.com/2013/06/21/in-2013-the-amount-of-data-generated-worldwide-will-reach-four-zettabytes/
> >
> >
> > --
> > --
> > Gavin Andresen
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/b5c2e636/attachment.html>

From eth3rs at gmail.com  Thu Jan  7 20:40:03 2016
From: eth3rs at gmail.com (Ethan Heilman)
Date: Thu, 7 Jan 2016 15:40:03 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
Message-ID: <CAEM=y+VNGDjS3gQRXh4qCDXccMLMTG8F30OFi-XrM=gJbJQs7A@mail.gmail.com>

Based on current GH/s count of 775,464,121 Bitcoin tests 2^80 every 19 days.
log2(775464121*(1000*1000*1000*60*60*24*19)) = ~80.07

I don't fully understand the security model of segwit, so my analysis
will assume that any collision is bad.

>But it also requires O(2^80) storage, which is utterly infeasible

You don't store all 2^80 previous hashes, instead you just hash a seed
value 2^80 times, then look for a cycle.

seed = {0,1}^160
x = hash(seed)

for i in 2^80:
....x = hash(x)
x_final = x

y = hash(x_final)

for j in 2^80:
....if y == x_final:
........print "cycle len: "+j
........break
....y = hash(y)

If at any point x collides with a prior value of x it will form a
cycle. Thus y will also cycle and collide with x_final. j gives you
the cycle length, which allows you find the collision:
hash^(2^80-j)(seed) == hash^(j)(hash^(2^80-j)(seed)).

Worst case:
First loop costs 2**80, second loop costs 2**80=j, finding the
colliding value is 2**80. Total cost 2**80+2**80+2**80 = 2**81.5 and
requires storing less than a kilobyte.

This is a toy example, does not exploit parallelism, time memory trade
offs, can be easily made better, etc...

On Thu, Jan 7, 2016 at 2:02 PM, Gavin Andresen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I'm hoisting this from some private feedback I sent on the segregated
> witness BIP:
>
> I said:
>
> "I'd also use RIPEMD160(SHA256()) as the hash function and save the 12
> bytes-- a successful preimage attack against that ain't gonna happen before
> we're all dead. I'm probably being dense, but I just don't see how a
> collision attack is relevant here."
>
> Pieter responded:
>
> "The problem case is where someone in a contract setup shows you a script,
> which you accept as being a payment to yourself. An attacker could use a
> collision attack to construct scripts with identical hashes, only one of
> which does have the property you want, and steal coins.
>
> So you really want collision security, and I don't think 80 bits is
> something we should encourage for that. Normal pubkey hashes don't have that
> problem, as they can't be constructed to pay to you."
>
> ... but I'm unconvinced:
>
> "But it is trivial for contract wallets to protect against collision
> attacks-- if you give me a script that is "gavin_pubkey CHECKSIG
> arbitrary_data OP_DROP" with "I promise I'm not trying to rip you off, just
> ignore that arbitrary data" a wallet can just refuse. Even more likely, a
> contract wallet won't even recognize that as a pay-to-gavin transaction.
>
> I suppose it could be looking for some form of "gavin_pubkey
> somebody_else_pubkey CHECKMULTISIG ... with the attacker using
> somebody_else_pubkey to force the collision, but, again, trivial contract
> protocol tweaks ("send along a proof you have the private key corresponding
> to the public key" or "everybody pre-commits pubkeys they'll use at protocol
> start") would protect against that.
>
> Adding an extra 12 bytes to every segwit to prevent an attack that takes
> 2^80 computation and 2^80 storage, is unlikely to be a problem in practice,
> and is trivial to protect against is the wrong tradeoff to make."
>
> 20 bytes instead of 32 bytes is a savings of almost 40%, which is
> significant.
>
> The general question I'd like to raise on this list is:
>
> Should we be worried, today, about collision attacks against RIPEMD160 (our
> 160-bit hash)?
>
> Mounting a successful brute-force collision attack would require at least
> O(2^80) CPU, which is kinda-sorta feasible (Pieter pointed out that Bitcoin
> POW has computed more SHA256 hashes than that). But it also requires O(2^80)
> storage, which is utterly infeasible (there is something on the order of
> 2^35 bytes of storage in the entire world).  Even assuming doubling every
> single year (faster than Moore's Law), we're four decades away from an
> attacker with THE ENTIRE WORLD's storage capacity being able to mount a
> collision attack.
>
>
> References:
>
> https://en.wikipedia.org/wiki/Collision_attack
>
> https://vsatglobalseriesblog.wordpress.com/2013/06/21/in-2013-the-amount-of-data-generated-worldwide-will-reach-four-zettabytes/
>
>
> --
> --
> Gavin Andresen
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From gavinandresen at gmail.com  Thu Jan  7 21:06:30 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 7 Jan 2016 16:06:30 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
Message-ID: <CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>

Maybe I'm asking this question on the wrong mailing list:

Matt/Adam: do you have some reason to think that RIPEMD160 will be broken
before SHA256?
And do you have some reason to think that they will be so broken that the
nested hash construction RIPEMD160(SHA256()) will be vulnerable?

Adam: re: "where to stop"  :  I'm suggesting we stop exactly at the current
status quo, where we use RIPEMD160 for P2SH and P2PKH.

Ethan:  your algorithm will find two arbitrary values that collide. That
isn't useful as an attack in the context we're talking about here (both of
those values will be useless as coin destinations with overwhelming
probability).

Dave: you described a first preimage attack, which is 2**160 cpu time and
no storage.


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/a777b3e1/attachment.html>

From eth3rs at gmail.com  Thu Jan  7 22:56:38 2016
From: eth3rs at gmail.com (Ethan Heilman)
Date: Thu, 7 Jan 2016 17:56:38 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
	<CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
Message-ID: <CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>

>Ethan:  your algorithm will find two arbitrary values that collide. That isn't useful as an attack in the context we're talking about here (both of those values will be useless as coin destinations with overwhelming probability).

I'm not sure exactly the properties you want here and determining
these properties is not an easy task, but the case is far worse than
just two random values. For instance: (a). with a small modification
my algorithm can also find collisions containing targeted substrings,
(b). length extension attacks are possible with RIPEMD160.

(a). targeted cycles:

target1 = "str to prepend"
target2 = "str to end with"

seed = {0,1}^160
x = hash(seed)

for i in 2^80:
....x = hash(target1||x||target2)
x_final = x

y = hash(tartget1||x_final||target2)

for j in 2^80:
....if y == x_final:
........print "cycle len: "+j
........break
....y = hash(target1||y||target2)

If a collision is found, the two colliding inputs must both start with
"str to prepend" and end with the phrase "str to end with". As before
this only requires 2^81.5 computations and no real memory. For an
additional 2**80 an adversary has an good change of finding two
different targeted substrings which collide. Consider the case where
the attacker mixes the targeted strings with the hash output:

hash("my name is=0x329482039483204324423"+x[1]+", my favorite number
is="+x) where x[1] is the first bit of x.

(b). length extension attacks

Even if all the adversary can do is create two random values that
collide, you can append substrings to the input and get collisions.
Once you find two random values hash(x) = hash(y), you could use a
length extension attack on RIPEMD-160 to find hash(x||z) = hash(y||z).

Now the bitcoin wiki says:
"The padding scheme is identical to MD4 using Merkle?Damg?rd
strengthening to prevent length extension attacks."[1]

Which is confusing to me because:

1. MD4 is vulnerable to length extension attacks
2. Merkle?Damg?rd strengthening does not protect against length
extension: "Indeed, we already pointed out that none of the 64
variants above can withstand the 'extension' attack on the MAC
application, even with the Merkle-Damgard strengthening" [2]
3. RIPEMD-160 is vulnerable to length extension attacks, is Bitcoin
using a non-standard version of RIPEMD-160.

RIPEMD160(SHA256()) does not protect against length extension attacks
on SHA256, but should protect RIPEMD-160 against length extension
attacks as RIPEMD-160 uses 512-bit message blocks. That being said we
should be very careful here. Research has been done that shows that
cascading the same hash function twice is weaker than using HMAC[3]. I
can't find results on cascading RIPEMD160(SHA256()).

RIPEMD160(SHA256()) seems better than RIPEMD160() though, but security
should not rest on the notion that an attacker requires 2**80 memory,
many targeted collision attacks can work without much memory.

[1]: https://en.bitcoin.it/wiki/RIPEMD-160
[2]: "Merkle-Damgard Revisited: How to Construct a Hash Function"
https://www.cs.nyu.edu/~puniya/papers/merkle.pdf
[3]: https://www.cs.nyu.edu/~dodis/ps/h-of-h.pdf

On Thu, Jan 7, 2016 at 4:06 PM, Gavin Andresen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Maybe I'm asking this question on the wrong mailing list:
>
> Matt/Adam: do you have some reason to think that RIPEMD160 will be broken
> before SHA256?
> And do you have some reason to think that they will be so broken that the
> nested hash construction RIPEMD160(SHA256()) will be vulnerable?
>
> Adam: re: "where to stop"  :  I'm suggesting we stop exactly at the current
> status quo, where we use RIPEMD160 for P2SH and P2PKH.
>
> Ethan:  your algorithm will find two arbitrary values that collide. That
> isn't useful as an attack in the context we're talking about here (both of
> those values will be useless as coin destinations with overwhelming
> probability).
>
> Dave: you described a first preimage attack, which is 2**160 cpu time and no
> storage.
>
>
> --
> --
> Gavin Andresen
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From pieter.wuille at gmail.com  Thu Jan  7 23:52:27 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Fri, 8 Jan 2016 00:52:27 +0100
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
Message-ID: <CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>

> "The problem case is where someone in a contract setup shows you a
script, which you accept as being a payment to yourself. An attacker could
use a collision attack to construct scripts with identical hashes, only one
of which does have the property you want, and steal coins.
>
> So you really want collision security, and I don't think 80 bits is
something we should encourage for that. Normal pubkey hashes don't have
that problem, as they can't be constructed to pay to you."
>
> ... but I'm unconvinced:
>
> "But it is trivial for contract wallets to protect against collision
attacks-- if you give me a script that is "gavin_pubkey CHECKSIG
arbitrary_data OP_DROP" with "I promise I'm not trying to rip you off, just
ignore that arbitrary data" a wallet can just refuse. Even more likely, a
contract wallet won't even recognize that as a pay-to-gavin transaction.
>
> I suppose it could be looking for some form of "gavin_pubkey
somebody_else_pubkey CHECKMULTISIG ... with the attacker using
somebody_else_pubkey to force the collision, but, again, trivial contract
protocol tweaks ("send along a proof you have the private key corresponding
to the public key" or "everybody pre-commits pubkeys they'll use at
protocol start") would protect against that.

Yes, this is what I worry about. We're constructing a 2-of-2 multisig
escrow in a contract. I reveal my public key A, you do a 80-bit search for
B and C such that H(A and B) = H(B and C). You tell me your keys B, and I
happily send to H(A and B), which you steal with H(B and C).

Sending along a proof does not help, you can't prove that you do not know
of a collision. Pre-committing does help, but is a very non-obvious
security requirement, something I strongly believe is far riskier in
practice.

Bitcoin does have parts that rely on economic arguments for security or
privacy, but can we please stick to using cryptography that is up to par
for parts where we can? It's a small constant factor of data, and it
categorically removes the worry about security levels.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/e2e921fb/attachment.html>

From gavinandresen at gmail.com  Thu Jan  7 23:39:58 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 7 Jan 2016 18:39:58 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
	<CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
	<CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>
Message-ID: <CABsx9T2+Q9+4mNUH3OnbnfFSn6NJ3LRCObTtU8WQqupEvhi_hA@mail.gmail.com>

Thanks, Ethan, that's helpful and I'll stop thinking that collision attacks
require 2^(n/2) memory...

So can we quantify the incremental increase in security of SHA256(SHA256)
over RIPEMD160(SHA256) versus the incremental increase in security of
having a simpler implementation of segwitness?

I'm going to claim that the difference in the first case is very, very,
very small-- the risk of an implementation error caused by having multiple
ways of interpreting the segwitness hash in the scriptPubKey is much, much
greater.

And even if there IS some risk of collision attack now or at some point in
the future, I claim that it is easy for wallets to mitigate that risk. In
fact, the principle of security in depth means wallets that don't
completely control the scriptPubKeys they're creating on behalf of users
SHOULD be coded to mitigate that risk (e.g. not allowing arbitrary data
around a user's public key in a Script so targeted substring attacks are
eliminated entirely).

Purely from a security point of view, I think a single 20-byte segwitness
in the scriptPubKey is the best design.
"Keep the design as simple and small as possible"
https://www.securecoding.cert.org/confluence/plugins/servlet/mobile#content/view/2426

Add in the implied capacity increase of smaller scriptPubKeys and I still
think it is a no-brainer.


On Thu, Jan 7, 2016 at 5:56 PM, Ethan Heilman <eth3rs at gmail.com> wrote:

> >Ethan:  your algorithm will find two arbitrary values that collide. That
> isn't useful as an attack in the context we're talking about here (both of
> those values will be useless as coin destinations with overwhelming
> probability).
>
> I'm not sure exactly the properties you want here and determining
> these properties is not an easy task, but the case is far worse than
> just two random values. For instance: (a). with a small modification
> my algorithm can also find collisions containing targeted substrings,
> (b). length extension attacks are possible with RIPEMD160.
>
> (a). targeted cycles:
>
> target1 = "str to prepend"
> target2 = "str to end with"
>
> seed = {0,1}^160
> x = hash(seed)
>
> for i in 2^80:
> ....x = hash(target1||x||target2)
> x_final = x
>
> y = hash(tartget1||x_final||target2)
>
> for j in 2^80:
> ....if y == x_final:
> ........print "cycle len: "+j
> ........break
> ....y = hash(target1||y||target2)
>
> If a collision is found, the two colliding inputs must both start with
> "str to prepend" and end with the phrase "str to end with". As before
> this only requires 2^81.5 computations and no real memory. For an
> additional 2**80 an adversary has an good change of finding two
> different targeted substrings which collide. Consider the case where
> the attacker mixes the targeted strings with the hash output:
>
> hash("my name is=0x329482039483204324423"+x[1]+", my favorite number
> is="+x) where x[1] is the first bit of x.
>
> (b). length extension attacks
>
> Even if all the adversary can do is create two random values that
> collide, you can append substrings to the input and get collisions.
> Once you find two random values hash(x) = hash(y), you could use a
> length extension attack on RIPEMD-160 to find hash(x||z) = hash(y||z).
>
> Now the bitcoin wiki says:
> "The padding scheme is identical to MD4 using Merkle?Damg?rd
> strengthening to prevent length extension attacks."[1]
>
> Which is confusing to me because:
>
> 1. MD4 is vulnerable to length extension attacks
> 2. Merkle?Damg?rd strengthening does not protect against length
> extension: "Indeed, we already pointed out that none of the 64
> variants above can withstand the 'extension' attack on the MAC
> application, even with the Merkle-Damgard strengthening" [2]
> 3. RIPEMD-160 is vulnerable to length extension attacks, is Bitcoin
> using a non-standard version of RIPEMD-160.
>
> RIPEMD160(SHA256()) does not protect against length extension attacks
> on SHA256, but should protect RIPEMD-160 against length extension
> attacks as RIPEMD-160 uses 512-bit message blocks. That being said we
> should be very careful here. Research has been done that shows that
> cascading the same hash function twice is weaker than using HMAC[3]. I
> can't find results on cascading RIPEMD160(SHA256()).
>
> RIPEMD160(SHA256()) seems better than RIPEMD160() though, but security
> should not rest on the notion that an attacker requires 2**80 memory,
> many targeted collision attacks can work without much memory.
>
> [1]: https://en.bitcoin.it/wiki/RIPEMD-160
> [2]: "Merkle-Damgard Revisited: How to Construct a Hash Function"
> https://www.cs.nyu.edu/~puniya/papers/merkle.pdf
> [3]: https://www.cs.nyu.edu/~dodis/ps/h-of-h.pdf
>
> On Thu, Jan 7, 2016 at 4:06 PM, Gavin Andresen via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Maybe I'm asking this question on the wrong mailing list:
> >
> > Matt/Adam: do you have some reason to think that RIPEMD160 will be broken
> > before SHA256?
> > And do you have some reason to think that they will be so broken that the
> > nested hash construction RIPEMD160(SHA256()) will be vulnerable?
> >
> > Adam: re: "where to stop"  :  I'm suggesting we stop exactly at the
> current
> > status quo, where we use RIPEMD160 for P2SH and P2PKH.
> >
> > Ethan:  your algorithm will find two arbitrary values that collide. That
> > isn't useful as an attack in the context we're talking about here (both
> of
> > those values will be useless as coin destinations with overwhelming
> > probability).
> >
> > Dave: you described a first preimage attack, which is 2**160 cpu time
> and no
> > storage.
> >
> >
> > --
> > --
> > Gavin Andresen
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>



-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/39e4d3d6/attachment-0001.html>

From gavinandresen at gmail.com  Fri Jan  8 01:00:42 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 7 Jan 2016 20:00:42 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
Message-ID: <CABsx9T1cPYorAo=u5YjA1tOoN5GNQpb_hT-ZTG9G9Hp88GgAMA@mail.gmail.com>

On Thu, Jan 7, 2016 at 6:52 PM, Pieter Wuille <pieter.wuille at gmail.com>
wrote:

> Bitcoin does have parts that rely on economic arguments for security or
> privacy, but can we please stick to using cryptography that is up to par
> for parts where we can? It's a small constant factor of data, and it
> categorically removes the worry about security levels.
>
Our message may have crossed in the mod queue:

"So can we quantify the incremental increase in security of SHA256(SHA256)
over RIPEMD160(SHA256) versus the incremental increase in security of
having a simpler implementation of segwitness?"

I believe the history of computer security is that implementation errors
and sidechannel attacks are much, much more common than brute-force breaks.
KEEP IT SIMPLE.

(and a quibble:  "do a 80-bit search for B and C such that H(A and B) = H(B
and C)"  isn't enough, you have to end up with a C public key for which you
know the corresponding private key or the attacker just succeeds in burning
the funds)


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/f73f2f2c/attachment.html>

From lf-lists at mattcorallo.com  Fri Jan  8 01:26:22 2016
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 8 Jan 2016 01:26:22 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
 not?
In-Reply-To: <CABsx9T2+Q9+4mNUH3OnbnfFSn6NJ3LRCObTtU8WQqupEvhi_hA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
	<CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
	<CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>
	<CABsx9T2+Q9+4mNUH3OnbnfFSn6NJ3LRCObTtU8WQqupEvhi_hA@mail.gmail.com>
Message-ID: <568F103E.1050909@mattcorallo.com>

So just because other attacks are possible we should weaken the crypto
we use? You may feel comfortable weakening crypto used to protect a few
billion dollars of other peoples' money, but I dont.

On 01/07/16 23:39, Gavin Andresen via bitcoin-dev wrote:
> Thanks, Ethan, that's helpful and I'll stop thinking that collision
> attacks require 2^(n/2) memory...
> 
> So can we quantify the incremental increase in security of
> SHA256(SHA256) over RIPEMD160(SHA256) versus the incremental increase in
> security of having a simpler implementation of segwitness?
> 
> I'm going to claim that the difference in the first case is very, very,
> very small-- the risk of an implementation error caused by having
> multiple ways of interpreting the segwitness hash in the scriptPubKey is
> much, much greater.
> 
> And even if there IS some risk of collision attack now or at some point
> in the future, I claim that it is easy for wallets to mitigate that
> risk. In fact, the principle of security in depth means wallets that
> don't completely control the scriptPubKeys they're creating on behalf of
> users SHOULD be coded to mitigate that risk (e.g. not allowing arbitrary
> data around a user's public key in a Script so targeted substring
> attacks are eliminated entirely).
> 
> Purely from a security point of view, I think a single 20-byte
> segwitness in the scriptPubKey is the best design.
> "Keep the design as simple and small as possible"
> https://www.securecoding.cert.org/confluence/plugins/servlet/mobile#content/view/2426
> 
> Add in the implied capacity increase of smaller scriptPubKeys and I
> still think it is a no-brainer.
> 
> 
> On Thu, Jan 7, 2016 at 5:56 PM, Ethan Heilman <eth3rs at gmail.com
> <mailto:eth3rs at gmail.com>> wrote:
> 
>     >Ethan:  your algorithm will find two arbitrary values that collide. That isn't useful as an attack in the context we're talking about here (both of those values will be useless as coin destinations with overwhelming probability).
> 
>     I'm not sure exactly the properties you want here and determining
>     these properties is not an easy task, but the case is far worse than
>     just two random values. For instance: (a). with a small modification
>     my algorithm can also find collisions containing targeted substrings,
>     (b). length extension attacks are possible with RIPEMD160.
> 
>     (a). targeted cycles:
> 
>     target1 = "str to prepend"
>     target2 = "str to end with"
> 
>     seed = {0,1}^160
>     x = hash(seed)
> 
>     for i in 2^80:
>     ....x = hash(target1||x||target2)
>     x_final = x
> 
>     y = hash(tartget1||x_final||target2)
> 
>     for j in 2^80:
>     ....if y == x_final:
>     ........print "cycle len: "+j
>     ........break
>     ....y = hash(target1||y||target2)
> 
>     If a collision is found, the two colliding inputs must both start with
>     "str to prepend" and end with the phrase "str to end with". As before
>     this only requires 2^81.5 computations and no real memory. For an
>     additional 2**80 an adversary has an good change of finding two
>     different targeted substrings which collide. Consider the case where
>     the attacker mixes the targeted strings with the hash output:
> 
>     hash("my name is=0x329482039483204324423"+x[1]+", my favorite number
>     is="+x) where x[1] is the first bit of x.
> 
>     (b). length extension attacks
> 
>     Even if all the adversary can do is create two random values that
>     collide, you can append substrings to the input and get collisions.
>     Once you find two random values hash(x) = hash(y), you could use a
>     length extension attack on RIPEMD-160 to find hash(x||z) = hash(y||z).
> 
>     Now the bitcoin wiki says:
>     "The padding scheme is identical to MD4 using Merkle?Damg?rd
>     strengthening to prevent length extension attacks."[1]
> 
>     Which is confusing to me because:
> 
>     1. MD4 is vulnerable to length extension attacks
>     2. Merkle?Damg?rd strengthening does not protect against length
>     extension: "Indeed, we already pointed out that none of the 64
>     variants above can withstand the 'extension' attack on the MAC
>     application, even with the Merkle-Damgard strengthening" [2]
>     3. RIPEMD-160 is vulnerable to length extension attacks, is Bitcoin
>     using a non-standard version of RIPEMD-160.
> 
>     RIPEMD160(SHA256()) does not protect against length extension attacks
>     on SHA256, but should protect RIPEMD-160 against length extension
>     attacks as RIPEMD-160 uses 512-bit message blocks. That being said we
>     should be very careful here. Research has been done that shows that
>     cascading the same hash function twice is weaker than using HMAC[3]. I
>     can't find results on cascading RIPEMD160(SHA256()).
> 
>     RIPEMD160(SHA256()) seems better than RIPEMD160() though, but security
>     should not rest on the notion that an attacker requires 2**80 memory,
>     many targeted collision attacks can work without much memory.
> 
>     [1]: https://en.bitcoin.it/wiki/RIPEMD-160
>     [2]: "Merkle-Damgard Revisited: How to Construct a Hash Function"
>     https://www.cs.nyu.edu/~puniya/papers/merkle.pdf
>     [3]: https://www.cs.nyu.edu/~dodis/ps/h-of-h.pdf
> 
>     On Thu, Jan 7, 2016 at 4:06 PM, Gavin Andresen via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>     > Maybe I'm asking this question on the wrong mailing list:
>     >
>     > Matt/Adam: do you have some reason to think that RIPEMD160 will be
>     broken
>     > before SHA256?
>     > And do you have some reason to think that they will be so broken
>     that the
>     > nested hash construction RIPEMD160(SHA256()) will be vulnerable?
>     >
>     > Adam: re: "where to stop"  :  I'm suggesting we stop exactly at
>     the current
>     > status quo, where we use RIPEMD160 for P2SH and P2PKH.
>     >
>     > Ethan:  your algorithm will find two arbitrary values that
>     collide. That
>     > isn't useful as an attack in the context we're talking about here
>     (both of
>     > those values will be useless as coin destinations with overwhelming
>     > probability).
>     >
>     > Dave: you described a first preimage attack, which is 2**160 cpu
>     time and no
>     > storage.
>     >
>     >
>     > --
>     > --
>     > Gavin Andresen
>     >
>     > _______________________________________________
>     > bitcoin-dev mailing list
>     > bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     >
> 
> 
> 
> 
> -- 
> --
> Gavin Andresen
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From gavinandresen at gmail.com  Fri Jan  8 01:54:00 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Thu, 7 Jan 2016 20:54:00 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <568F103E.1050909@mattcorallo.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
	<CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
	<CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>
	<CABsx9T2+Q9+4mNUH3OnbnfFSn6NJ3LRCObTtU8WQqupEvhi_hA@mail.gmail.com>
	<568F103E.1050909@mattcorallo.com>
Message-ID: <CABsx9T2CM2iVBbzBs-jQA6S-sHCdtEEWNwn=DgN_D+biKVErkA@mail.gmail.com>

On Thu, Jan 7, 2016 at 8:26 PM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> So just because other attacks are possible we should weaken the crypto
> we use? You may feel comfortable weakening crypto used to protect a few
> billion dollars of other peoples' money, but I dont.
>

No...

I'm saying we can eliminate one somewhat unlikely attack (that there is a
bug in the code or test cases, today or some future version, that has to
decide what to do with "version 0" versus "version 1" witness programs) by
accepting the risk of another insanely, extremely unlikely attack.

Reference for those who are lost:

https://github.com/CodeShark/bips/blob/segwit/bip-codeshark-jl2012-segwit.mediawiki#witness-program

My proposal would be to just do a version 0 witness program now, that is
RIPEMD160(SHA256(script)).

And ten or twenty years from now, if there is a plausible attack on
RIPEMD160 and/or SHA256, revisit and do a version 11 (or whatever).

It will simplify the BIP, means half as many test cases have to be written,
means a little more scalability, and is as secure as the P2SH and P2PKH
everybody is using to secure their bitcoin today.

Tell you what:  I'll change my mind if anybody can describe a plausible
attack if we were using MD5(SHA256), given what we know about how MD5 is
broken.


---

I'm really disappointed with the "Here's the spec, take it or leave it"
attitude. What's the point of having a BIP process if the discussion just
comes down to "We think more is better. We don't care what you think."

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/ba55bae0/attachment.html>

From watsonbladd at gmail.com  Fri Jan  8 01:27:02 2016
From: watsonbladd at gmail.com (Watson Ladd)
Date: Thu, 7 Jan 2016 17:27:02 -0800
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T1cPYorAo=u5YjA1tOoN5GNQpb_hT-ZTG9G9Hp88GgAMA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<CABsx9T1cPYorAo=u5YjA1tOoN5GNQpb_hT-ZTG9G9Hp88GgAMA@mail.gmail.com>
Message-ID: <CACsn0cn9ijwc+SzLqVgd+2RvL1xAdu9XdwVqU-zjy=2Qt9J0bg@mail.gmail.com>

On Jan 7, 2016 5:22 PM, "Gavin Andresen via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Thu, Jan 7, 2016 at 6:52 PM, Pieter Wuille <pieter.wuille at gmail.com>
wrote:
>>
>> Bitcoin does have parts that rely on economic arguments for security or
privacy, but can we please stick to using cryptography that is up to par
for parts where we can? It's a small constant factor of data, and it
categorically removes the worry about security levels.
>
> Our message may have crossed in the mod queue:
>
> "So can we quantify the incremental increase in security of
SHA256(SHA256) over RIPEMD160(SHA256) versus the incremental increase in
security of having a simpler implementation of segwitness?"

There are several clever ways to exploit even chosen prefix collisions
using the scripting language. One could search for collisions where one
message is some data and the other is a jump over a critical check.

>
> I believe the history of computer security is that implementation errors
and sidechannel attacks are much, much more common than brute-force breaks.
KEEP IT SIMPLE.

Ask the Iranian nuclear program. Or those brainwallet users.
>
> (and a quibble:  "do a 80-bit search for B and C such that H(A and B) =
H(B and C)"  isn't enough, you have to end up with a C public key for which
you know the corresponding private key or the attacker just succeeds in
burning the funds)
>
>
> --
> --
> Gavin Andresen
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/9bdcb94f/attachment-0001.html>

From rusty at rustcorp.com.au  Fri Jan  8 03:30:11 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Fri, 08 Jan 2016 14:00:11 +1030
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks
	or	not?
In-Reply-To: <CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
Message-ID: <8760z4rbng.fsf@rustcorp.com.au>

Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:
> Yes, this is what I worry about. We're constructing a 2-of-2 multisig
> escrow in a contract. I reveal my public key A, you do a 80-bit search for
> B and C such that H(A and B) = H(B and C). You tell me your keys B, and I
> happily send to H(A and B), which you steal with H(B and C).

FWIW, this attack would effect the current lightning-network "deployable
lightning" design at channel establishment; we reveal our pubkey in the
opening packet (which is used to redeem a P2SH using normal 2of2).

At least you need to grind before replying (which will presumably time
out), rather than being able to do it once the channel is open.

We could pre-commit by exchanging hashes of pubkeys first, but contracts
on bitcoin are hard enough to get right that I'm reluctant to add more
hoops.

Cheers,
Rusty.

From lf-lists at mattcorallo.com  Fri Jan  8 03:41:34 2016
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Fri, 08 Jan 2016 03:41:34 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision
	attacks	or	not?
In-Reply-To: <8760z4rbng.fsf@rustcorp.com.au>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
Message-ID: <C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>

Indeed, anything which uses P2SH is obviously vulnerable if there is an attack on RIPEMD160 which reduces it's security only marginally. While no one thought hard about these attacks when P2SH was designed, we realized later this was not such a good idea to reuse the structure from P2PKH. Hence why this discussion came up.

On January 7, 2016 7:30:11 PM PST, Rusty Russell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>writes:
>> Yes, this is what I worry about. We're constructing a 2-of-2 multisig
>> escrow in a contract. I reveal my public key A, you do a 80-bit
>search for
>> B and C such that H(A and B) = H(B and C). You tell me your keys B,
>and I
>> happily send to H(A and B), which you steal with H(B and C).
>
>FWIW, this attack would effect the current lightning-network
>"deployable
>lightning" design at channel establishment; we reveal our pubkey in the
>opening packet (which is used to redeem a P2SH using normal 2of2).
>
>At least you need to grind before replying (which will presumably time
>out), rather than being able to do it once the channel is open.
>
>We could pre-commit by exchanging hashes of pubkeys first, but
>contracts
>on bitcoin are hard enough to get right that I'm reluctant to add more
>hoops.
>
>Cheers,
>Rusty.
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From matthieu at blockcypher.com  Fri Jan  8 02:17:03 2016
From: matthieu at blockcypher.com (Matthieu Riou)
Date: Thu, 7 Jan 2016 18:17:03 -0800
Subject: [bitcoin-dev] SegWit testnet is live
In-Reply-To: <9080AE86-C75D-497B-B03E-30C9986E621A@gmail.com>
References: <059B0A23-1423-4167-B86E-FD7C804E7F49@gmail.com>
	<9080AE86-C75D-497B-B03E-30C9986E621A@gmail.com>
Message-ID: <CAHUNwMr2LMR8QWR8Rnj-iNG4Bb8HDSQ-dNOLL00EtnhOJivuFA@mail.gmail.com>

Not strictly speaking a wallet but we (BlockCypher) will also go down the
segwit path as soon as the BIP and branch are mature enough.  All
transactions built from our APIs should eventually be segwitted (just made
up a verb).

Thanks,
Matthieu
*CTO and Founder, Blockcypher*
I have been informed that Breadwallet has also committed to supporting
segwit.

The list now includes Blocktrail, Breadwallet, GreenAddress, GreenBits,
mSIGNA, and NBitcoin.

---
Eric

On January 7, 2016 5:28:18 AM PST, Eric Lombrozo <elombrozo at gmail.com>
wrote:
>
> I am pleased to report that as of December 31, 2015 we have been
> successfully running a segregated witness testnet, called segnet, and have
> already implemented rudimentary wallets with support.
>
> For source code, please look at sipa's github repo:
> https://github.com/sipa/bitcoin/tree/segwit
>
> And some example signing code at my repo:
>
> https://github.com/CodeShark/BitcoinScriptExperiments/blob/master/src/signwitnesstx.cpp
>
> Several wallets have already committed to supporting it including mSIGNA,
> GreenAddress, GreenBits, Blocktrail, and NBitcoin. More wallets are
> expected to be added to this list soon. If you're a wallet dev and are
> interested in developing and testing on segnet please contact me.
>
> We're right on schedule and are very excited about the fundamental
> improvements to bitcoin that segwit will enable.
>
> ---
> Eric
>
>
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160107/5c49eacf/attachment.html>

From rusty at rustcorp.com.au  Fri Jan  8 12:02:01 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Fri, 08 Jan 2016 22:32:01 +1030
Subject: [bitcoin-dev] Time to worry about 80-bit collision
	attacks	or	not?
In-Reply-To: <C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
Message-ID: <8737u8qnye.fsf@rustcorp.com.au>

Matt Corallo <lf-lists at mattcorallo.com> writes:
> Indeed, anything which uses P2SH is obviously vulnerable if there is
> an attack on RIPEMD160 which reduces it's security only marginally.

I don't think this is true?  Even if you can generate a collision in
RIPEMD160, that doesn't help you since you need to create a specific
SHA256 hash for the RIPEMD160 preimage.

Even a preimage attack only helps if it leads to more than one preimage
fairly cheaply; that would make grinding out the SHA256 preimage easier.
AFAICT even MD4 isn't this broken.

But just with Moore's law (doubling every 18 months), we'll worry about
economically viable attacks in 20 years.[1]

That's far enough away that I would choose simplicity, and have all SW
scriptPubKeys simply be "<0> RIPEMD(SHA256(WP))" for now, but it's
not a no-brainer.

Cheers,
Rusty.

[1] Assume bitcoin-network-level compute (collision in 19 days) costs
    $1B to build today.  Assume there will be 100 million dollars a day
    in vulnerable txs, and you're on one end of all of them (or can MITM
    if you find a collision), *and* can delay them all by 10 seconds,
    and none are in parallel so you can attack all of them.  IOW, just
    like a single $100M opportunity for 3650 seconds each year.

    Our machine has a 0.11% chance of finding a collision in 1 hour, so
    it's worth about $110,000.  We can build it for that in about 20
    years.

From gavinandresen at gmail.com  Fri Jan  8 12:38:50 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 8 Jan 2016 07:38:50 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <8737u8qnye.fsf@rustcorp.com.au>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
Message-ID: <CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>

On Fri, Jan 8, 2016 at 7:02 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:

> Matt Corallo <lf-lists at mattcorallo.com> writes:
> > Indeed, anything which uses P2SH is obviously vulnerable if there is
> > an attack on RIPEMD160 which reduces it's security only marginally.
>
> I don't think this is true?  Even if you can generate a collision in
> RIPEMD160, that doesn't help you since you need to create a specific
> SHA256 hash for the RIPEMD160 preimage.
>
> Even a preimage attack only helps if it leads to more than one preimage
> fairly cheaply; that would make grinding out the SHA256 preimage easier.
> AFAICT even MD4 isn't this broken.
>

It feels like we've gone over that before, but I can never remember where
or when. I believe consensus was that if we were using the broken MD5 in
all the places we use RIPEMD160 we'd still be secure today because of
Satoshi's use of nested hash functions everywhere.


> But just with Moore's law (doubling every 18 months), we'll worry about
> economically viable attacks in 20 years.[1]


> That's far enough away that I would choose simplicity, and have all SW
> scriptPubKeys simply be "<0> RIPEMD(SHA256(WP))" for now, but it's
> not a no-brainer.


Lets see if I've followed the specifics of the collision attack correctly,
Ethan (or somebody) please let me know if I'm missing something:

So attacker is in the middle of establishing a payment channel with
somebody. Victim gives their public key, attacker creates the innocent
fund-locking script  '2 V A 2 CHECKMULTISIG' (V is victim's public key, A
is attacker's) but doesn't give it to the victim yet.

Instead they then generate about 2^81scripts that are some form of
pay-to-attacker ....
... wait, no that doesn't work, because SHA256 is used as the inner hash
function.  They'd have to generate 2^129 to find a cycle in SHA256.

Instead, they .. what? I don't see a viable attack unless RIPEMD160 and
SHA256 (or the combination) suffers a cryptographic break.


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/aec650d3/attachment.html>

From watsonbladd at gmail.com  Fri Jan  8 14:34:09 2016
From: watsonbladd at gmail.com (Watson Ladd)
Date: Fri, 8 Jan 2016 06:34:09 -0800
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
Message-ID: <CACsn0cmE-c3MCAegH6QaFfDg6NDgNy7tKbczsxtQvkWBnLYJgw@mail.gmail.com>

On Fri, Jan 8, 2016 at 4:38 AM, Gavin Andresen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Fri, Jan 8, 2016 at 7:02 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:
>>
>> Matt Corallo <lf-lists at mattcorallo.com> writes:
>> > Indeed, anything which uses P2SH is obviously vulnerable if there is
>> > an attack on RIPEMD160 which reduces it's security only marginally.
>>
>> I don't think this is true?  Even if you can generate a collision in
>> RIPEMD160, that doesn't help you since you need to create a specific
>> SHA256 hash for the RIPEMD160 preimage.
>>
>> Even a preimage attack only helps if it leads to more than one preimage
>> fairly cheaply; that would make grinding out the SHA256 preimage easier.
>> AFAICT even MD4 isn't this broken.
>
>
> It feels like we've gone over that before, but I can never remember where or
> when. I believe consensus was that if we were using the broken MD5 in all
> the places we use RIPEMD160 we'd still be secure today because of Satoshi's
> use of nested hash functions everywhere.
>
>>
>> But just with Moore's law (doubling every 18 months), we'll worry about
>> economically viable attacks in 20 years.[1]
>>
>>
>> That's far enough away that I would choose simplicity, and have all SW
>> scriptPubKeys simply be "<0> RIPEMD(SHA256(WP))" for now, but it's
>> not a no-brainer.
>
>
> Lets see if I've followed the specifics of the collision attack correctly,
> Ethan (or somebody) please let me know if I'm missing something:
>
> So attacker is in the middle of establishing a payment channel with
> somebody. Victim gives their public key, attacker creates the innocent
> fund-locking script  '2 V A 2 CHECKMULTISIG' (V is victim's public key, A is
> attacker's) but doesn't give it to the victim yet.
>
> Instead they then generate about 2^81scripts that are some form of
> pay-to-attacker ....
> ... wait, no that doesn't work, because SHA256 is used as the inner hash
> function.  They'd have to generate 2^129 to find a cycle in SHA256.

For 2^80 they simply generate 2^80 scripts that look innocent, and
2^80 that are not. With high probability there is a collision. I agree
that most cryptanalysis won't work because of the nesting, but 2^80 is
not good.
>
> Instead, they .. what? I don't see a viable attack unless RIPEMD160 and
> SHA256 (or the combination) suffers a cryptographic break.
>
>
> --
> --
> Gavin Andresen
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
"Man is born free, but everywhere he is in chains".
--Rousseau.

From adam at cypherspace.org  Fri Jan  8 15:26:50 2016
From: adam at cypherspace.org (Adam Back)
Date: Fri, 8 Jan 2016 16:26:50 +0100
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CACsn0cmE-c3MCAegH6QaFfDg6NDgNy7tKbczsxtQvkWBnLYJgw@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<CACsn0cmE-c3MCAegH6QaFfDg6NDgNy7tKbczsxtQvkWBnLYJgw@mail.gmail.com>
Message-ID: <CALqxMTHHh81Rkd274_XepXuZY-r_6Us+0FYrg9_Uupi0R9yVUw@mail.gmail.com>

Tricky choice. On the one hand I had spotted this too before and maybe
one or two more exceptions to bitcoin's 128-bit security target and
been vaguely tut-tutting about them in the background.  It's kind of a
violation of crypto rule of thumb that you want to balance things and
not have odd weak points as Watson was implying, it puts you closer to
the margin if there is a slip or other problem so you have an
imbalanced crypto format.

On the other hand it's not currently a problem as such and it's less
change and slightly more compact.

RIPEMD probably is less well reviewed than SHA2.  However SHA1 has
problems, and SHA2 is a bigger SHA1 basically so, hence the NIST
motivation for SHA3 designed to fix the design flaw in SHA1 (and SHA2
in principle).

So then if we agree with this rule of thumb (and not doing so would
fly against best practices which we probably shouldnt look to do in
such a security focussed domain) then what this discussion is more
about is when is a good time to write down tech debt.

I think that comes to segregated-witness itself which writes down a
tidily organised by lines of code robust fix to a bunch of long
standing problems.

Doing a 2MB hard-fork in comparison fixes nothing really.  Leaving
known issues to bake in for another N years eventually builds up on
you (not even in security just in software engineering) as another
rule of thumb.  I mean if we dont fix it now that we are making a
change that connects, when will we?

In software projects I ran we always disguised the cost of tech-debt
as non-negotiable baked into our estimates without a line item to
escape the PHB syndrome of haggling for features instead of tech debt
(which is _never_ a good idea:)

Pragmatism vs refactoring as you go.

But for scale I think segregated-witness does offer the intriguing
next step of being able to do 2 of 2, 3 of 3 and N of N which give
size of one sig multisig (indistinguishable even for privacy) as well
as K of N key tree sigs, which are also significantly more compact.

There was also the other thing I mentioned further up the thread that
if we want to take an approach of living with little bit of bloat from
getting back to a universal 128-bit target, there are still some
fixable bloat things going on:
a) sending pubKey in the signature vs recovery (modulo interference
with Schnorr batch verify compatibility*);
b) using the PubKey instead of PKH in the ScriptPubKey, though that
loses the nice property of of not having the key to do DL attacks on
until the signed transaction is broadcast;
c) I think there might be a way to combine hash & PubKey to keep the
delayed PubKey publication property and yet still save the bloat of
having both.

* I did suggest to Pieter that you could let the miner decide to forgo
Schnorr batch verifiability to get compaction from recovery - the pub
key could be optionally elided from the scriptSig serialisation by the
miner.

The other thing we could consider is variable sized hashes (& a few
pubkey size choices) that is software complexity however.  We might be
better of focussing on the bigger picture like IBLT/weak-blocks and
bigger wins like MAST, multiSig Schnorr & key tree sigs.

Didnt get time to muse on c) but a nice crypto question for someone :)

Another thing to note is combining has been known to be fragile to bad
interactions or unexpected behaviours.  This paper talks about things
tradeoffs and weaknesses in hash combiners.
http://tuprints.ulb.tu-darmstadt.de/2094/1/thesis.lehmann.pdf

Weak concept NACK I think for losing a cleanup opportunity to store it
up for the future when there is a reasonable opportunity to fix it?

Adam


On 8 January 2016 at 15:34, Watson Ladd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Fri, Jan 8, 2016 at 4:38 AM, Gavin Andresen via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> On Fri, Jan 8, 2016 at 7:02 AM, Rusty Russell <rusty at rustcorp.com.au> wrote:
>>>
>>> Matt Corallo <lf-lists at mattcorallo.com> writes:
>>> > Indeed, anything which uses P2SH is obviously vulnerable if there is
>>> > an attack on RIPEMD160 which reduces it's security only marginally.
>>>
>>> I don't think this is true?  Even if you can generate a collision in
>>> RIPEMD160, that doesn't help you since you need to create a specific
>>> SHA256 hash for the RIPEMD160 preimage.
>>>
>>> Even a preimage attack only helps if it leads to more than one preimage
>>> fairly cheaply; that would make grinding out the SHA256 preimage easier.
>>> AFAICT even MD4 isn't this broken.
>>
>>
>> It feels like we've gone over that before, but I can never remember where or
>> when. I believe consensus was that if we were using the broken MD5 in all
>> the places we use RIPEMD160 we'd still be secure today because of Satoshi's
>> use of nested hash functions everywhere.
>>
>>>
>>> But just with Moore's law (doubling every 18 months), we'll worry about
>>> economically viable attacks in 20 years.[1]
>>>
>>>
>>> That's far enough away that I would choose simplicity, and have all SW
>>> scriptPubKeys simply be "<0> RIPEMD(SHA256(WP))" for now, but it's
>>> not a no-brainer.
>>
>>
>> Lets see if I've followed the specifics of the collision attack correctly,
>> Ethan (or somebody) please let me know if I'm missing something:
>>
>> So attacker is in the middle of establishing a payment channel with
>> somebody. Victim gives their public key, attacker creates the innocent
>> fund-locking script  '2 V A 2 CHECKMULTISIG' (V is victim's public key, A is
>> attacker's) but doesn't give it to the victim yet.
>>
>> Instead they then generate about 2^81scripts that are some form of
>> pay-to-attacker ....
>> ... wait, no that doesn't work, because SHA256 is used as the inner hash
>> function.  They'd have to generate 2^129 to find a cycle in SHA256.
>
> For 2^80 they simply generate 2^80 scripts that look innocent, and
> 2^80 that are not. With high probability there is a collision. I agree
> that most cryptanalysis won't work because of the nesting, but 2^80 is
> not good.
>>
>> Instead, they .. what? I don't see a viable attack unless RIPEMD160 and
>> SHA256 (or the combination) suffers a cryptographic break.
>>
>>
>> --
>> --
>> Gavin Andresen
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
>
> --
> "Man is born free, but everywhere he is in chains".
> --Rousseau.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From aj at erisian.com.au  Fri Jan  8 15:33:29 2016
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 9 Jan 2016 01:33:29 +1000
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
 not?
In-Reply-To: <CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
Message-ID: <20160108153329.GA15731@sapphire.erisian.com.au>

On Fri, Jan 08, 2016 at 07:38:50AM -0500, Gavin Andresen via bitcoin-dev wrote:
> Lets see if I've followed the specifics of the collision attack correctly,
> Ethan (or somebody) please let me know if I'm missing something:
> 
> So attacker is in the middle of establishing a payment channel with
> somebody. Victim gives their public key, attacker creates the innocent
> fund-locking script  '2 V A 2 CHECKMULTISIG' (V is victim's public key, A
> is attacker's) but doesn't give it to the victim yet.

Using Ethan Heilman's procedure, the attacker can create two scripts:

  2 V __A1__ 2 CHECKMULTISIG

  2 V __A2__ 2 CHECKMULTISIG

and find values A1 and A2 which hash the scripts to the same result
with under 3*2**80 work. I think you can do that by setting the next
private key as the result of RIPEMD(SHA256(script with pubkey)), so you
could still spend either. But it doesn't change the script, so it's not
*that* helpful -- you've just got two different keys you can use.

Ah, but you can make the form of the script be a function of your key, so:

  if privkey % 2 == 0:
    script = "2 V %s 2 CHECKMULTISIG" % (pubkey)
  else:
    script = "%s CHECKSIG" % (pubkey)
  hash = ripemd160(sha256(script))

  nextprivkey = hash

Then you have a 50% chance of your cycle giving you a matching hash for
one script with A1 and the other script with A2, and you can find the
cycle with under 3*2**80 work. Doing five attempts should give you ~96%
chance of hitting a usable pair, and should take under 15*2**80 work ~=
2**84 work, with trivial memory use.

Trying that in python with a vastly weakened hash function (namely,
the first five bytes of ripemd160(sha256()), with 40 bits of security
and 3*2**20 work) works as expected -- I got a "useful" collision on my
second try in about 7 seconds, seeding with "grumpycat3" ("grumpycat2"
didn't work) with the result being:

 hexlify(ripemd160(sha256("foo%sbar"%unhexlify("86f9fbac1a")))[:5])
 'ae94d9f908'

 hexlify(ripemd160(sha256("baz%squux"%unhexlify("104fc5093f")))[:5])
 'ae94d9f908'

Cheers,
aj


From pieter.wuille at gmail.com  Fri Jan  8 17:38:34 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Fri, 8 Jan 2016 18:38:34 +0100
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T2CM2iVBbzBs-jQA6S-sHCdtEEWNwn=DgN_D+biKVErkA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
	<CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
	<CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>
	<CABsx9T2+Q9+4mNUH3OnbnfFSn6NJ3LRCObTtU8WQqupEvhi_hA@mail.gmail.com>
	<568F103E.1050909@mattcorallo.com>
	<CABsx9T2CM2iVBbzBs-jQA6S-sHCdtEEWNwn=DgN_D+biKVErkA@mail.gmail.com>
Message-ID: <CAPg+sBiOPpJb8kPYqMSZdGvN7Tb96sgyw_h4yPdhbsLWNcVFRQ@mail.gmail.com>

On Fri, Jan 8, 2016 at 2:54 AM, Gavin Andresen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:
> I'm saying we can eliminate one somewhat unlikely attack (that there is a
> bug in the code or test cases, today or some future version, that has to
> decide what to do with "version 0" versus "version 1" witness programs) by
> accepting the risk of another insanely, extremely unlikely attack.

Ok, just having one witness program version now is a somewhat different
proposal. It would be simpler for sure. The reasoning was that you'd need
this to not add significant overhead to small scripts, but that may not be
the case anymore. I wouldn't mind seeing numbers.

> My proposal would be to just do a version 0 witness program now, that is
> RIPEMD160(SHA256(script)).

I don't think that is wise. Bitcoin has a 128-bit security target for
everything else. We did not know that P2SH and similar constructs were
vulnerable to a collision attack at the time, but now we do, so the obvious
choice is to pick a size that is sufficiently large to maintain the 128-bit
security target. This is a no brainer to me; we're not proposing switching
to a 160-bit EC curve either, right?

> I'm really disappointed with the "Here's the spec, take it or leave it"
> attitude. What's the point of having a BIP process if the discussion just
> comes down to "We think more is better. We don't care what you think."

It is a proposal and we are discussing it. You first brought up some
criticisms in private, and I agreed with several things you said.

But it remains the proposal of a few people including me, and I do not
agree with the specific suggestion of reducing the security target for
witness scripts to 80 bits.

We are not deciding what the system will be. We're making a proposal, and
hope that due to its technical merit, the ecosystem will adopt it. You're
free to participate in that discussion.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/2420393c/attachment.html>

From gavinandresen at gmail.com  Fri Jan  8 15:46:53 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 8 Jan 2016 10:46:53 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <20160108153329.GA15731@sapphire.erisian.com.au>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
Message-ID: <CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>

Thanks, Anthony, that works!

So...

How many years until we think a 2^84 attack where the work is an ECDSA
private->public key derivation will take a reasonable amount of time?

And Ethan or Anthony:  can you think of a similar attack scheme if you
assume we had switched to Schnorr 2-of-2 signatures by then?


And to everybody who might not be reading this closely:  All of the above
is discussing collision attacks; none of it is relevant in the normal case
where your wallet generates the scriptPubKey.



-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/8f69988f/attachment.html>

From gavinandresen at gmail.com  Fri Jan  8 15:50:06 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 8 Jan 2016 10:50:06 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
Message-ID: <CABsx9T0WRXz54LZnyU7Fr=_ZgwF5armj0Z8uwYcFy2x+BWooxg@mail.gmail.com>

And to fend off the messag that I bet somebody is composing right now:

Yes, I know about a "security first" mindset.  But as I said earlier in the
thread, there is a tradeoff here between crypto strength and code
complexity, and "the strength of the crypto is all that matters" is NOT
security first.

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/b0d965ec/attachment.html>

From gavinandresen at gmail.com  Fri Jan  8 15:59:21 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 8 Jan 2016 10:59:21 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T0WRXz54LZnyU7Fr=_ZgwF5armj0Z8uwYcFy2x+BWooxg@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
	<CABsx9T0WRXz54LZnyU7Fr=_ZgwF5armj0Z8uwYcFy2x+BWooxg@mail.gmail.com>
Message-ID: <CABsx9T34htMaC-uoE0Tk3tb1KEct7hk=s=eyY-94+CLCcN2_EQ@mail.gmail.com>

On Fri, Jan 8, 2016 at 10:50 AM, Gavin Andresen <gavinandresen at gmail.com>
wrote:

> But as I said earlier in the thread, there is a tradeoff here between
> crypto strength and code complexity, and "the strength of the crypto is all
> that matters" is NOT security first.


I should be more explicit about code complexity:

The big picture is "segwitness will help scale in the very short term."

So the spec gives two ways of stuffing the segwitness hash into the
scriptPubKey -- one way that uses a 32-bit hash, but if used would actually
make scalability a bit worse as coins moved into segwitness-locked
transactions (DUP HASH160 EQUALVERIFY pay-to-script-hash scriptpubkeys are
just 24 bytes).

And another way that add just one byte to the scriptpubkey.

THAT is the code complexity I'm talking about.  Better to always move the
script into the witness data, in my opinion, on the keep the design as
simple as possible principle.

It could be a 32-byte hash... but then the short-term scalability goal is
compromised.

Maybe I'm being dense, but I still think it is a no-brainer....

-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/49bd0b02/attachment.html>

From gavinandresen at gmail.com  Fri Jan  8 16:06:34 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 8 Jan 2016 11:06:34 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
Message-ID: <CABsx9T18zaQEG3ZvKG_=q7duF-+npvG=Y3DSDw8HV3JaZNNSWg@mail.gmail.com>

On Fri, Jan 8, 2016 at 10:46 AM, Gavin Andresen <gavinandresen at gmail.com>
wrote:

> And Ethan or Anthony:  can you think of a similar attack scheme if you
> assume we had switched to Schnorr 2-of-2 signatures by then?


Don't answer that, I was being dense again, Anthony's scheme works with
Schnorr...


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/f1c01274/attachment.html>

From jameson.lopp at gmail.com  Fri Jan  8 15:35:27 2016
From: jameson.lopp at gmail.com (Jameson Lopp)
Date: Fri, 8 Jan 2016 10:35:27 -0500
Subject: [bitcoin-dev] SegWit testnet is live
In-Reply-To: <CAHUNwMr2LMR8QWR8Rnj-iNG4Bb8HDSQ-dNOLL00EtnhOJivuFA@mail.gmail.com>
References: <059B0A23-1423-4167-B86E-FD7C804E7F49@gmail.com>
	<9080AE86-C75D-497B-B03E-30C9986E621A@gmail.com>
	<CAHUNwMr2LMR8QWR8Rnj-iNG4Bb8HDSQ-dNOLL00EtnhOJivuFA@mail.gmail.com>
Message-ID: <CADL_X_cgR=pbkpg-+w=TWUtEqWZB0FHPfu9+qzivfyF0=3w0UQ@mail.gmail.com>

BitGo also intends to support SegWit transactions as soon as possible.

- Jameson

On Thu, Jan 7, 2016 at 9:17 PM, Matthieu Riou via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Not strictly speaking a wallet but we (BlockCypher) will also go down the
> segwit path as soon as the BIP and branch are mature enough.  All
> transactions built from our APIs should eventually be segwitted (just made
> up a verb).
>
> Thanks,
> Matthieu
> *CTO and Founder, Blockcypher*
> I have been informed that Breadwallet has also committed to supporting
> segwit.
>
> The list now includes Blocktrail, Breadwallet, GreenAddress, GreenBits,
> mSIGNA, and NBitcoin.
>
> ---
> Eric
>
> On January 7, 2016 5:28:18 AM PST, Eric Lombrozo <elombrozo at gmail.com>
> wrote:
>>
>> I am pleased to report that as of December 31, 2015 we have been
>> successfully running a segregated witness testnet, called segnet, and have
>> already implemented rudimentary wallets with support.
>>
>> For source code, please look at sipa's github repo:
>> https://github.com/sipa/bitcoin/tree/segwit
>>
>> And some example signing code at my repo:
>>
>> https://github.com/CodeShark/BitcoinScriptExperiments/blob/master/src/signwitnesstx.cpp
>>
>> Several wallets have already committed to supporting it including mSIGNA,
>> GreenAddress, GreenBits, Blocktrail, and NBitcoin. More wallets are
>> expected to be added to this list soon. If you're a wallet dev and are
>> interested in developing and testing on segnet please contact me.
>>
>> We're right on schedule and are very excited about the fundamental
>> improvements to bitcoin that segwit will enable.
>>
>> ---
>> Eric
>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/708ab045/attachment-0001.html>

From pete at petertodd.org  Fri Jan  8 18:41:15 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 8 Jan 2016 10:41:15 -0800
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
 not?
In-Reply-To: <CABsx9T2CM2iVBbzBs-jQA6S-sHCdtEEWNwn=DgN_D+biKVErkA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CALqxMTHjvFT2aCBYDEiG-6F5qvsXK57_LR6ttpPb3xUG2i443w@mail.gmail.com>
	<CAGLBAhczEceqDp6XPSVLJ0FuTcmZgYkVnUE4rspb3JdeHnZJUg@mail.gmail.com>
	<CABsx9T0JX41bOQxjPg7QFUKGEwgFaCGFzR3ySbaqFwy4i28Hbg@mail.gmail.com>
	<CAEM=y+VAmT5wRsDhUufPCDPB=U+h-MQ1+xY5uJqAAO8Xt6SaxA@mail.gmail.com>
	<CABsx9T2+Q9+4mNUH3OnbnfFSn6NJ3LRCObTtU8WQqupEvhi_hA@mail.gmail.com>
	<568F103E.1050909@mattcorallo.com>
	<CABsx9T2CM2iVBbzBs-jQA6S-sHCdtEEWNwn=DgN_D+biKVErkA@mail.gmail.com>
Message-ID: <20160108184115.GA8489@muck>

On Thu, Jan 07, 2016 at 08:54:00PM -0500, Gavin Andresen via bitcoin-dev wrote:
> ---
> 
> I'm really disappointed with the "Here's the spec, take it or leave it"
> attitude. What's the point of having a BIP process if the discussion just
> comes down to "We think more is better. We don't care what you think."

I'll point out that I personally raised an issue with segpregated
witnesses quite recently - my concern that it could make validationless
mining easier and more profitable(1). Neither Pieter Wuille nor Gregory
Maxwell believed my concern to be important at first in private
communication. However, it was still discussed on IRC, with Pieter,
Greg, and others contributing valuable input on the problem and my
proposed fix. Right now I think the next step for me is to write the
code to implement my fix and submit a pull-req against the segwit
branch.

I certainly wouldn't describe that experience as "Here's the spec, take
it or leave it; We don't what what you think."

1) "Segregated witnesses and validationless mining",
    Peter Todd, Dec 23 2015, Bitcoin-dev mailing list,
    http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/012103.html

-- 
'peter'[:-1]@petertodd.org
000000000000000004aea2cfdb89c4816b7a42208dca1f3cfd66a1c9b5df4506
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/d491f65e/attachment.sig>

From pete at petertodd.org  Fri Jan  8 18:52:54 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 8 Jan 2016 10:52:54 -0800
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks
	or	not?
In-Reply-To: <8760z4rbng.fsf@rustcorp.com.au>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
Message-ID: <20160108185254.GA18199@muck>

On Fri, Jan 08, 2016 at 02:00:11PM +1030, Rusty Russell via bitcoin-dev wrote:
> Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> writes:
> > Yes, this is what I worry about. We're constructing a 2-of-2 multisig
> > escrow in a contract. I reveal my public key A, you do a 80-bit search for
> > B and C such that H(A and B) = H(B and C). You tell me your keys B, and I
> > happily send to H(A and B), which you steal with H(B and C).
> 
> FWIW, this attack would effect the current lightning-network "deployable
> lightning" design at channel establishment; we reveal our pubkey in the
> opening packet (which is used to redeem a P2SH using normal 2of2).
> 
> At least you need to grind before replying (which will presumably time
> out), rather than being able to do it once the channel is open.
> 
> We could pre-commit by exchanging hashes of pubkeys first, but contracts
> on bitcoin are hard enough to get right that I'm reluctant to add more
> hoops.

Note how this is a good example where trying to avoid the relatively
small amount of complexity of having two different segregated witness
schemes to allow for 128bit security could lead to a significant amount
of upper level complexity trying to regain security. I wouldn't be
surprised at all if this upper level complexity leads to exploits; at
the very least it'll lead to a lot of wasted mental effort from
cryptographers concerned about the potential weakness, both within and
external to the Bitcoin development community.

-- 
'peter'[:-1]@petertodd.org
000000000000000004aea2cfdb89c4816b7a42208dca1f3cfd66a1c9b5df4506
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160108/070f712d/attachment.sig>

From rusty at rustcorp.com.au  Mon Jan 11 03:57:15 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 11 Jan 2016 14:27:15 +1030
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks
	or	not?
In-Reply-To: <CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
Message-ID: <87fuy4hip0.fsf@rustcorp.com.au>

Gavin Andresen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> How many years until we think a 2^84 attack where the work is an ECDSA
> private->public key derivation will take a reasonable amount of time?

vanitygen can generate keypairs pretty fast (on my CPU it's comparable
with hashing time), and there are ways to make it faster.  Since you can
generate multiple script variations, too, I think hashing is the
bottleneck.

Antminer S7 can do 4.73 Terahash per second for $1.2k.  (Double SHA, but
let's assume RIPEMD160(SHA256()) is the same speed).

766,760,562,123 seconds to do 3*2^80, so you'd need over 200 million
S7s to do it in an hour.[1] If you want to do that for $1M, wait 27
years and hope Moore's Law holds?

Also, a colleague points out you could use this attack against a site
like bitrated.com which publishes one side's pubkey, giving you a much
longer attack window.
     
Cheers,
Rusty.
[1] Weirdly, the bitcoin network is doing this much work every 57
    days, for about $92M.  If that's all the attack costs, it's under
    1M in 10 years.

From pete at petertodd.org  Mon Jan 11 06:57:42 2016
From: pete at petertodd.org (Peter Todd)
Date: Mon, 11 Jan 2016 06:57:42 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision
	attacks	or	not?
In-Reply-To: <87fuy4hip0.fsf@rustcorp.com.au>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
	<87fuy4hip0.fsf@rustcorp.com.au>
Message-ID: <60A90647-86FC-49F5-9FB0-0CAA6A040A4B@petertodd.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512



On 10 January 2016 22:57:15 GMT-05:00, Rusty
>Cheers,
>Rusty.
>[1] Weirdly, the bitcoin network is doing this much work every 57
>    days, for about $92M.  If that's all the attack costs, it's under
>    1M in 10 years.

Don't get too caught up in Moore's law here - more likely the attack will become feasible because SHA2 is partially weakened, as happened with SHA1. Having industry standard safety margins would make such a weakening be an academic problem rather than an emergency.
-----BEGIN PGP SIGNATURE-----

iQE9BAEBCgAnIBxQZXRlciBUb2RkIDxwZXRlQHBldGVydG9kZC5vcmc+BQJWk1Jc
AAoJEMCF8hzn9Lncz4MH/RYReh4+oPkt8D4uW2FhiB/BlzY5Q1FP94nyi/jQAAh9
er3cUA47RhSLLd2ukC2XDgbw8CZzhnzECs7vBVsXacc3dGpzV59n8L/pnX47IRJh
i1BPWHzEl/UeE/uBYUVgmy+kCVkJ80gnL2GGgZ3IXL5P+CHYY9dvhBrr53Q3HSpi
aEXVivBvBnX0GeATMVY5TAiailUfsUbUmPdEHu0x5hqqTh0sUpi+R+wXWJfPESB2
hzMVZd8ALz1SJhDqbkmBNHy2CX0fhGlnMSapm6EkQksfshkcwJ7tj8s2CEOYD68T
4mR7Xh+FsOA2bbZP8M/lMd3rrXbwFzXi0rWPa70mxqI=
=2W58
-----END PGP SIGNATURE-----


From jtimon at jtimon.cc  Mon Jan 11 20:32:15 2016
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Mon, 11 Jan 2016 21:32:15 +0100
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T0WRXz54LZnyU7Fr=_ZgwF5armj0Z8uwYcFy2x+BWooxg@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
	<CABsx9T0WRXz54LZnyU7Fr=_ZgwF5armj0Z8uwYcFy2x+BWooxg@mail.gmail.com>
Message-ID: <CABm2gDrQx-ETyCk1XOCGKwsLeTQU_gPG_Gpjx=bbf2qHpE1u=w@mail.gmail.com>

On Fri, Jan 8, 2016 at 4:50 PM, Gavin Andresen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> And to fend off the messag that I bet somebody is composing right now:
>
> Yes, I know about a "security first" mindset.  But as I said earlier in the
> thread, there is a tradeoff here between crypto strength and code
> complexity, and "the strength of the crypto is all that matters" is NOT
> security first.

If the crypto code is properly encapsulated, the code complexity costs
of choosing one hashing function over another should be non-existent.
You made the space argument which is valid, but in my opinion code
complexity shouldn't be a valid concern in this discussion.

As a maybe uninteresting anecdote, I proposed the asset IDs in
https://github.com/ElementsProject/elements/tree/alpha-0.10-multi-asset
to do the same ```ripemd160 . sha256``` choice that Mark Friedenbach
had proposed and I had approved for
https://github.com/jtimon/freimarkets/blob/master/doc/freimarkets_specs.org#asset-tags
. More humble than me, he admitted he had made a design mistake much
earlier than me, who (maybe paradoxically) probably had less knowledge
for making crypto choices at the low level. In the end I was convinced
with examples I failed to write down for documentation and can't
remember.

That's not to say I have anything to say in this debate other than
code complexity (which I do feel qualified to talk about) shouldn't be
a concern in this debate. Just want to focus the discussion on what it
should be: security vs space tradeoff.
Since I am admittedly in doubt, I tend to prefer to play safe, but
neither my feelings nor my anecdote are logical arguments and should,
therefore, be ignored for any conclusions in the ```ripemd160 .
sha256``` vs sha256d debate. Just like you non-sequitor "sha256d will
lead to more code complexity", if anything, sha256d should be simpler
than ```ripemd160 . sha256``` (but not simpler enough that it matters
much).

From tier.nolan at gmail.com  Mon Jan 11 23:57:59 2016
From: tier.nolan at gmail.com (Tier Nolan)
Date: Mon, 11 Jan 2016 23:57:59 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
Message-ID: <CAE-z3OUMRivWPVA+3BgC_95MGYBHN34+hoo6xfCu_gNeLFVknA@mail.gmail.com>

On Fri, Jan 8, 2016 at 3:46 PM, Gavin Andresen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> How many years until we think a 2^84 attack where the work is an ECDSA
> private->public key derivation will take a reasonable amount of time?
>

I think the EC multiply is not actually required.  With compressed public
keys, the script selection rule can just be a sha256 call instead.

V is the public key of the victim, and const_pub_key is the attacker's
public key.

     if prev_hash % 2 == 0:
        script = "2 V 0x02%s 2 CHECKMULTISIG" % (sha256(prev_hash)))
    else:
        script = "CHECKSIG %s OP_DROP" % (prev_hash, const_pub_key)

    next_hash = ripemd160(sha256(script))

If a collision is found, there is a 50% chance that the two scripts have
different parity and there is a 50% chance that a compressed key is a valid
key.

This means that you need to run the algorithm 4 times instead of 2.

The advantage is that each step is 2 sha256 calls and a ripemd160 call.  No
EC multiply is required.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160111/be7bd486/attachment.html>

From tier.nolan at gmail.com  Tue Jan 12 00:00:08 2016
From: tier.nolan at gmail.com (Tier Nolan)
Date: Tue, 12 Jan 2016 00:00:08 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CAE-z3OUMRivWPVA+3BgC_95MGYBHN34+hoo6xfCu_gNeLFVknA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
	<CAE-z3OUMRivWPVA+3BgC_95MGYBHN34+hoo6xfCu_gNeLFVknA@mail.gmail.com>
Message-ID: <CAE-z3OVuAMdpZb+-C4JS_6FEreFohOMAsWpepgE1L5YoBOw4iA@mail.gmail.com>

On Mon, Jan 11, 2016 at 11:57 PM, Tier Nolan <tier.nolan at gmail.com> wrote:
>
>     else:
>         script = "CHECKSIG %s OP_DROP" % (prev_hash, const_pub_key)
>

That should be

script = "%s CHECKSIG %s OP_DROP" % (const_pub_key, prev_hash)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160112/f404e9db/attachment.html>

From tier.nolan at gmail.com  Tue Jan 12 00:09:46 2016
From: tier.nolan at gmail.com (Tier Nolan)
Date: Tue, 12 Jan 2016 00:09:46 +0000
Subject: [bitcoin-dev] New BIP editor, and request for information
In-Reply-To: <201601071710.57868.luke@dashjr.org>
References: <201601071710.57868.luke@dashjr.org>
Message-ID: <CAE-z3OVZHLef76cUENwu+v2W9Lp8PZFZJwnaFMPc0x=_x48JHQ@mail.gmail.com>

On Thu, Jan 7, 2016 at 5:10 PM, Luke Dashjr <luke at dashjr.org> wrote:

> - BIP 46 is missing from the repository, but apparently self-soft-assigned
> by
> Tier Nolan in
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-April/005545.html
> ; if this was later assigned official, or if he is still
> interested in pursuing this, it seems logical to just keep it at BIP 46.
>

I was never officially assigned any number for this.

Subsequent P2SH changes give the required functionality in an alternative
way.  This renders the BIP obsolete.

I suggest marking the number as nonassignable, in order to prevent
confusion with archive searches.  I assume that new BIP numbers will be
greater than 100 anyway.

As was pointed out at the time, I shouldn't have used a number in the
original git branch before being assigned it officially.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160112/4632ff10/attachment.html>

From joe2015 at openmailbox.org  Tue Jan 12 03:58:13 2016
From: joe2015 at openmailbox.org (joe2015 at openmailbox.org)
Date: Tue, 12 Jan 2016 11:58:13 +0800
Subject: [bitcoin-dev] An implementation of BIP102 as a softfork.
In-Reply-To: <640324f3e4cafd1fecfef809a8cb017d@openmailbox.org>
References: <6fc10e581a81abb76be5cd49275ebf48@openmailbox.org>
	<CAKJqnrGUKeUb7g4SrjnWNAcPZOuLDKB-kjP2+Jy8Rdk_MfWLyQ@mail.gmail.com>
	<814e1ba765445a4c3b7364c471299393@openmailbox.org>
	<CAKJqnrE7W8aRgracL1cy_hBLWpVsTAQL4qg4ViSP9aCHvM1yvA@mail.gmail.com>
	<3b3d9102043577785d1b1679704eabfd@openmailbox.org>
	<CANN4kme78DzknfOY_kOG0Bo+v16O1McxznCi4VPq5p9HxgzuKw@mail.gmail.com>
	<640324f3e4cafd1fecfef809a8cb017d@openmailbox.org>
Message-ID: <16fe2f0a56e7257b9465bcdd9e34e49c@openmailbox.org>

On 2016-01-05 09:26, joe2015--- via bitcoin-dev wrote:
> On 2016-01-05 02:04, Nick ODell wrote:
>> How are you collecting fees from the transactions in the block?
> 
> Probably the simplest way to do this is to map the new-rules coinbase
> tx (which collects the block reward and fees) into an old-rules legacy
> coinbase tx (which collects the block reward only).  Care must be
> taken to ensure the mapping is not reversible.  I will update my
> implementation in due course.

The redesigned implementation is here:

https://github.com/ZoomT/bitcoin/tree/2015_2mb_blocksize
https://github.com/jgarzik/bitcoin/compare/2015_2mb_blocksize...ZoomT:2015_2mb_blocksize

The new version maps the Merkle root onto a 'legacy' coinbase 
transaction, solving the problem with fees.

--joe.

From gavinandresen at gmail.com  Tue Jan 12 12:08:18 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Tue, 12 Jan 2016 07:08:18 -0500
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CAE-z3OVuAMdpZb+-C4JS_6FEreFohOMAsWpepgE1L5YoBOw4iA@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
	<CAE-z3OUMRivWPVA+3BgC_95MGYBHN34+hoo6xfCu_gNeLFVknA@mail.gmail.com>
	<CAE-z3OVuAMdpZb+-C4JS_6FEreFohOMAsWpepgE1L5YoBOw4iA@mail.gmail.com>
Message-ID: <CABsx9T3UTSnLx_BGfMTrQB1=vR9Bdd8OJvSXy=++-_=wfv7+uw@mail.gmail.com>

I'm convinced-- it is a good idea to worry about 80-bit collision attacks
now.

Thanks to all the people smarter than me who contributed to this
discussion, I learned a lot about collision attacks that I didn't know
before.

Would this be a reasonable "executive summary" :

If you are agreeing to lock up funds with somebody else, and they control
what public key to use, you are susceptible to collision attacks.

It is very likely an 80-bit-collision-in-ten-minutes attack will cost less
than $1million in 10 to twenty years (possibly sooner if there are crypto
breaks in that time).

If you don't trust the person with whom you're locking up funds and you're
locking up a significant amount of money (tens of millions of dollars
today, tens of thousands of dollars in a few years):

Then you should avoid using pay-to-script-hash addresses and instead use
the payment protocol and "raw" multisig outputs.

AND/OR

Have them give you a hierarchical deterministic (BIP32) seed, and derive a
public key for them to use.


----------

Following the security in depth and validate all input secure coding
principles would mean doing both-- avoid p2sh AND have all parties to a
transaction exchange HD seeds, add randomness, and use the resulting public
keys in the transaction.


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160112/866bc47e/attachment.html>

From jtimon at jtimon.cc  Tue Jan 12 17:53:24 2016
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Tue, 12 Jan 2016 18:53:24 +0100
Subject: [bitcoin-dev] Libconsensus phase 2
Message-ID: <CABm2gDqPrsuHH4L+dQE-6e162Zj6jbyyB1-6htjB_+2EY2qTXg@mail.gmail.com>

After talking to some people about libconsensus in the last Hong Kong
conference I realized that my initial plan of exposing one more thing
at a time would actually probably slow things down.

There's still a promised pdf with pictures that will be released, and
actually drafting the UML pictures helped realize that the whole
explanation could be much simpler if #7091 was merged first as the
last step in phase 1 (that phase has so many contributors that I will
probably never get finished documenting it). Matt Corallo's idea of
exposing VerifyScript() through a C API certainly helped a lot in
cementing the more-minimal-than-earlier dependencies (thanks to Cory
Fields among many other people before him) that are not part of the
incomplete but existing libbitcoinconsensus library.

Given this success in protecting encapsulation by exposing things in a
new library, my instinct was to expose more things: VerifyHeader(),
VerifyTx() and VerifyBlock() [in that order].
But all those three new functions depend on storage in one way or
another. That was part of my reasoning to expose VerifyHeader() first,
because I believe there will be less discussion on a common interface
for the stored longest chain than for the utxo view (which may depend
on other transactions spent within the same block).
In any case, I realized we should finish putting all the consensus
critical code in the libconsensus lib and then worry about its "final"
API.

Therefore I changed the goal of the phase 2 in my libconsensus
encapsulation planning from "expose VerifyHeader() in the existing
libconsensus library" to "build all the consensus critical code within
the existing libconsensus library, even if we don't expose anything
else". I believe this is much feasible for a single Bitcoin Core
release cycle and also more of a priority. Other implementations
experimenting with libconsensus like
https://github.com/libbitcoin/libbitcoin-consensus will have the
chance to compare their reimplementations with the future complete
libbitcoinconsensus without having to worry about the C API, which
ideally they will help to define.

I repeat, the goal of phase 2 in my upcoming libconsensus
encapsulation plan is to fully decouple libconsensus from Bitcoin
Core.
In phase 3, we can refine the storage interfaces and focus on a
quasi-final C API.
In phase 4, we can refine and take out code that doesn't belong in
libconsensus like CTxOut::GetDustThreshold() in
primitives/transaction.h and move all those consensus files to the
consensus folder before creating a separate sub-repository like for
libsecp256k1. Note that most of the file-moving work can be in
parallel to phases 2 and 3 and, in fact, by any new developer that is
willing to exchange rebase-patience for meaningless github stats (I'll
do it if nobody else wants, but I'm more than happy to delegate there:
I have more than enough github meaningless stats already).

As said, the document with pictures and the update to #6714 are still
promised, but until they're ready, merging/reviewing #7091, #7287,
#7310 and #7311 could do a great deal to make later steps in
libconsensus phase 2 more readable.
Most reviewers probably don't need to see any "big picture" to tell
whether certain functions on Bitcoin Core are consensus-critical or
not, or whether consensus critical code needs to depend on util.o or
not.
But I wouldn't be writing to the mailing list without a plan with
further words nor pictures if I didn't had what I believe is a
complete implementation of what I just defined as "libconsensus phase
2".

Phase 3 should finish long pending discussions like "should
libconsensus be C++14 or plain C" which should NOT delay phase 2.
Phase 4 should be mostly trivial: rename files to the target dir and
move the remaining unused code out of libconsensus.
Phase 5 should make Bitcoin Core eat its own dog food and use
libbitcoinconsensus oonly by its generic C API (I'm sorry if this
looks too far away for me to even think about detailing it).

The work in progress branch (but hopefully being finished, nit and
merged within the 0.12.99 cycle) can be found in:
https://github.com/jtimon/bitcoin/commits/libconsensus-f2

Before sipa asks, signing code may make it into a new library but
SHOULDN'T BE PART OF LIBBITCOINCONSENSUS. Ideally, all exposed
functions will return true or false and an error string. It is based
on last-0.12.99 3cd836c1 but by popular demand I can open it as a
"DEPENDENT-tagged" PR linking to smaller steps and keeping track of
steps done. Analogous to the about to be replaced (for a simpler and
more maintainable example of testchain) #6382. If people like
Wladimir, Cory and Pieter cannot see that I've been able to reduce my
overall cry-for-review noise thanks to github adoption of emacs'
org-mode's [ ] vs [X] I can alwways leave those "big picture" branches
as "private" branches out of the pull request count.

I expect to publish a phase 3 branch very shortly. But as said I
expect a lot of discussion on the API part, so I don't expect big
movements in phase 3 until phase 2 is done (as said phase 4 is
orthogonal to anything, this time git will say "verified MOVEONLY" for
us).

To finish this long mail, if you are new to free software and would
like to get familiarized with Bitcoin Core development in particular,
moving one file is a simple task that you can always besure you can do
right.
The way I plan to hand this to you, you won't need to convince anyone
to publicly confirm that your "MOVEONLY" commit being legit, because
all your remaining work will be to build on one platform (ideally you
should do a gitian build, but embarrassingly enough for someone
touching consensus code I just trust travis ) and trust travis (as
said, that's what I do from my laptop, but I plan to buy my own
building machine [and maybe outsource it for free in some protocol
that hasn't been invented, sorry again for the distraction]) and fix
the includes that have stopped working.

I intend to create an issue to move all the files in this list one by one:

https://github.com/bitcoin/bitcoin/pull/7091/files#diff-480477e89f9b6ddafb30c4383dcdd705R250

But don't hesitate to contact me if are eager for moving some files,
because I believe we can save a few lines of total diff if we chose
the order of the movements properly.

Sorry, I forgot many people read this list again.
Happy to answer any question.

Specially about https://github.com/jtimon/bitcoin/commits/libconsensus-f2

From eric at voskuil.org  Tue Jan 12 19:17:20 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 12 Jan 2016 11:17:20 -0800
Subject: [bitcoin-dev] Libconsensus phase 2
In-Reply-To: <CABm2gDqPrsuHH4L+dQE-6e162Zj6jbyyB1-6htjB_+2EY2qTXg@mail.gmail.com>
References: <CABm2gDqPrsuHH4L+dQE-6e162Zj6jbyyB1-6htjB_+2EY2qTXg@mail.gmail.com>
Message-ID: <56955140.7050301@voskuil.org>

Jorge, first, thanks again for your work on this.

Without creating and using a public blockchain interface in phase 2, how
will you isolate the database dependency from consensus critical code?
Is it that the interface will exist but you will recommend against its use?

This work presumes that the users of the library reject the argument
that the database implementation is consensus critical code. Faithful
reproduction of stored data is a prerequisite for a validity. But a
common store implementation is only slightly more reasonable for this
library than a common RAM implementation.

e

On 01/12/2016 09:53 AM, Jorge Tim?n wrote:
> After talking to some people about libconsensus in the last Hong Kong
> conference I realized that my initial plan of exposing one more thing
> at a time would actually probably slow things down.
> 
> There's still a promised pdf with pictures that will be released, and
> actually drafting the UML pictures helped realize that the whole
> explanation could be much simpler if #7091 was merged first as the
> last step in phase 1 (that phase has so many contributors that I will
> probably never get finished documenting it). Matt Corallo's idea of
> exposing VerifyScript() through a C API certainly helped a lot in
> cementing the more-minimal-than-earlier dependencies (thanks to Cory
> Fields among many other people before him) that are not part of the
> incomplete but existing libbitcoinconsensus library.
> 
> Given this success in protecting encapsulation by exposing things in a
> new library, my instinct was to expose more things: VerifyHeader(),
> VerifyTx() and VerifyBlock() [in that order].
> But all those three new functions depend on storage in one way or
> another. That was part of my reasoning to expose VerifyHeader() first,
> because I believe there will be less discussion on a common interface
> for the stored longest chain than for the utxo view (which may depend
> on other transactions spent within the same block).
> In any case, I realized we should finish putting all the consensus
> critical code in the libconsensus lib and then worry about its "final"
> API.
> 
> Therefore I changed the goal of the phase 2 in my libconsensus
> encapsulation planning from "expose VerifyHeader() in the existing
> libconsensus library" to "build all the consensus critical code within
> the existing libconsensus library, even if we don't expose anything
> else". I believe this is much feasible for a single Bitcoin Core
> release cycle and also more of a priority. Other implementations
> experimenting with libconsensus like
> https://github.com/libbitcoin/libbitcoin-consensus will have the
> chance to compare their reimplementations with the future complete
> libbitcoinconsensus without having to worry about the C API, which
> ideally they will help to define.
> 
> I repeat, the goal of phase 2 in my upcoming libconsensus
> encapsulation plan is to fully decouple libconsensus from Bitcoin
> Core.
> In phase 3, we can refine the storage interfaces and focus on a
> quasi-final C API.
> In phase 4, we can refine and take out code that doesn't belong in
> libconsensus like CTxOut::GetDustThreshold() in
> primitives/transaction.h and move all those consensus files to the
> consensus folder before creating a separate sub-repository like for
> libsecp256k1. Note that most of the file-moving work can be in
> parallel to phases 2 and 3 and, in fact, by any new developer that is
> willing to exchange rebase-patience for meaningless github stats (I'll
> do it if nobody else wants, but I'm more than happy to delegate there:
> I have more than enough github meaningless stats already).
> 
> As said, the document with pictures and the update to #6714 are still
> promised, but until they're ready, merging/reviewing #7091, #7287,
> #7310 and #7311 could do a great deal to make later steps in
> libconsensus phase 2 more readable.
> Most reviewers probably don't need to see any "big picture" to tell
> whether certain functions on Bitcoin Core are consensus-critical or
> not, or whether consensus critical code needs to depend on util.o or
> not.
> But I wouldn't be writing to the mailing list without a plan with
> further words nor pictures if I didn't had what I believe is a
> complete implementation of what I just defined as "libconsensus phase
> 2".
> 
> Phase 3 should finish long pending discussions like "should
> libconsensus be C++14 or plain C" which should NOT delay phase 2.
> Phase 4 should be mostly trivial: rename files to the target dir and
> move the remaining unused code out of libconsensus.
> Phase 5 should make Bitcoin Core eat its own dog food and use
> libbitcoinconsensus oonly by its generic C API (I'm sorry if this
> looks too far away for me to even think about detailing it).
> 
> The work in progress branch (but hopefully being finished, nit and
> merged within the 0.12.99 cycle) can be found in:
> https://github.com/jtimon/bitcoin/commits/libconsensus-f2
> 
> Before sipa asks, signing code may make it into a new library but
> SHOULDN'T BE PART OF LIBBITCOINCONSENSUS. Ideally, all exposed
> functions will return true or false and an error string. It is based
> on last-0.12.99 3cd836c1 but by popular demand I can open it as a
> "DEPENDENT-tagged" PR linking to smaller steps and keeping track of
> steps done. Analogous to the about to be replaced (for a simpler and
> more maintainable example of testchain) #6382. If people like
> Wladimir, Cory and Pieter cannot see that I've been able to reduce my
> overall cry-for-review noise thanks to github adoption of emacs'
> org-mode's [ ] vs [X] I can alwways leave those "big picture" branches
> as "private" branches out of the pull request count.
> 
> I expect to publish a phase 3 branch very shortly. But as said I
> expect a lot of discussion on the API part, so I don't expect big
> movements in phase 3 until phase 2 is done (as said phase 4 is
> orthogonal to anything, this time git will say "verified MOVEONLY" for
> us).
> 
> To finish this long mail, if you are new to free software and would
> like to get familiarized with Bitcoin Core development in particular,
> moving one file is a simple task that you can always besure you can do
> right.
> The way I plan to hand this to you, you won't need to convince anyone
> to publicly confirm that your "MOVEONLY" commit being legit, because
> all your remaining work will be to build on one platform (ideally you
> should do a gitian build, but embarrassingly enough for someone
> touching consensus code I just trust travis ) and trust travis (as
> said, that's what I do from my laptop, but I plan to buy my own
> building machine [and maybe outsource it for free in some protocol
> that hasn't been invented, sorry again for the distraction]) and fix
> the includes that have stopped working.
> 
> I intend to create an issue to move all the files in this list one by one:
> 
> https://github.com/bitcoin/bitcoin/pull/7091/files#diff-480477e89f9b6ddafb30c4383dcdd705R250
> 
> But don't hesitate to contact me if are eager for moving some files,
> because I believe we can save a few lines of total diff if we chose
> the order of the movements properly.
> 
> Sorry, I forgot many people read this list again.
> Happy to answer any question.
> 
> Specially about https://github.com/jtimon/bitcoin/commits/libconsensus-f2
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160112/8976d566/attachment.sig>

From zooko at z.cash  Tue Jan 12 23:22:17 2016
From: zooko at z.cash (Zooko Wilcox-O'Hearn)
Date: Tue, 12 Jan 2016 23:22:17 +0000
Subject: [bitcoin-dev] Time to worry about 80-bit collision attacks or
	not?
In-Reply-To: <CABsx9T3UTSnLx_BGfMTrQB1=vR9Bdd8OJvSXy=++-_=wfv7+uw@mail.gmail.com>
References: <CABsx9T3aTme2EQATamGGzeqNqJkUcPGa=0LVidJSRYNznM-myQ@mail.gmail.com>
	<CAPg+sBhH0MODjjp8Avx+Fy_UGqzMjUq_jn3vT3oH=u3711tsSA@mail.gmail.com>
	<8760z4rbng.fsf@rustcorp.com.au>
	<C4B5B9F1-9C53-45BC-9B30-F572C78096E3@mattcorallo.com>
	<8737u8qnye.fsf@rustcorp.com.au>
	<CABsx9T1gmz=sr_sEEuy8BQU6SXdmi58O30rzRWNW=0Ej98fi4A@mail.gmail.com>
	<20160108153329.GA15731@sapphire.erisian.com.au>
	<CABsx9T3MfndREm9icE-TUF58zsRZ5YsBMvUAMy4E-MmYWxWV=A@mail.gmail.com>
	<CAE-z3OUMRivWPVA+3BgC_95MGYBHN34+hoo6xfCu_gNeLFVknA@mail.gmail.com>
	<CAE-z3OVuAMdpZb+-C4JS_6FEreFohOMAsWpepgE1L5YoBOw4iA@mail.gmail.com>
	<CABsx9T3UTSnLx_BGfMTrQB1=vR9Bdd8OJvSXy=++-_=wfv7+uw@mail.gmail.com>
Message-ID: <CADorodh9s4T3YMVb=bKHkMMbbtuNQ1iimPN=55j0Ws161e3A1g@mail.gmail.com>

Folks:

I don't fully understand this thread, but it sounds like to me it
might be omitting consideration of multi-target attacks. For example,
Tier Nolan's attack
(http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012230.html),
which seems to be the best attack on this thread, seems to start with
one specific public key of an intended victim, but if the attacker is
happy to find a collision with *any* one out of a large number of
potential victims, he gets an advantage proportional to the number of
potential victims.

So it would be wise, in addition to the kind of analysis already done
on this thread (which appears to have already settled at "Yes, we need
> 80-bit security."), to make a nice optimistic estimate of how many
public keys we could eventually have in use. 2??? 2??? Or maybe be
*very* optimistic, with some added IoT [*] goodness, and budget for
2???

Then we need to budget that many more bits of security to keep the
future attacker's chances of success low enough that the attacker will
never succeed. (Assuming that's our requirement.)

You might enjoy this recent blog post by DJB, legendary cryptographer
who works in this niche of cryptography as well as several other
niches:

http://blog.cr.yp.to/20151120-batchattacks.html

It has some interesting philosophical musings about the "Attacker
Economist" approach. (N.B. My respect for DJB's accomplishments is
tremendous, but that doesn't mean I automatically agree with
everything he says. I haven't made up my mind what I think about this
particular philosophical argument.)

Sincerely,

Zooko

[*] The Internet of Targets

From jtimon at jtimon.cc  Wed Jan 13 08:37:46 2016
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Wed, 13 Jan 2016 09:37:46 +0100
Subject: [bitcoin-dev] Libconsensus phase 2
In-Reply-To: <56955140.7050301@voskuil.org>
References: <CABm2gDqPrsuHH4L+dQE-6e162Zj6jbyyB1-6htjB_+2EY2qTXg@mail.gmail.com>
	<56955140.7050301@voskuil.org>
Message-ID: <CABm2gDqz8NyZE_juwfqb23Hg5kZUU5oJuXHH098aU+_W8dPhBA@mail.gmail.com>

On Tue, Jan 12, 2016 at 8:17 PM, Eric Voskuil <eric at voskuil.org> wrote:
> Jorge, first, thanks again for your work on this.
>
> Without creating and using a public blockchain interface in phase 2, how
> will you isolate the database dependency from consensus critical code?
> Is it that the interface will exist but you will recommend against its use?

The interface will exist but it will be a C++ interface that fits
better with Bitcoin Core internals.
See an initial draft of what could be the storage interface:
https://github.com/jtimon/bitcoin/blob/1717db89c6db17ea65ddbd5eb19034315db0b059/src/consensus/storage_interfaces_cpp.h

Phase 3 will consist on discussing and refining that interface to also
define the C interfaces using structs of function pointers instead of
classes (see https://github.com/jtimon/bitcoin/blob/2bcc07c014e5dd000030e666be047dfa11f54c10/src/consensus/interfaces.h
for an early draft) that is needed for the "final" C API.
But since I think there will be more discussion and work defining
those interfaces, I would rather start with ANY interface that allows
us to decouple the consensus code from chain.o and coins.o, which we
don't want to be built as part of the consensus building package
(which is used for building both libbitcoinconsensus and Bitcoin
Core).
Future potential users are more than welcomed to draft their own C
APIs and that experience should be useful for phase 3.
I was expecting you, for example, to include the whole consensus code
(even if it lacks a C API) in
https://github.com/libbitcoin/libbitcoin-consensus for better testing
of the equivalent code in libbitcoin. You are kind of taking the C API
part out already, so this time you will just have less things to
delete/ignore.

> This work presumes that the users of the library reject the argument
> that the database implementation is consensus critical code. Faithful
> reproduction of stored data is a prerequisite for a validity. But a
> common store implementation is only slightly more reasonable for this
> library than a common RAM implementation.

This is a concern that has been risen repeatedly.
I am aware that faithful reproduction of the stored data is a
prerequisite for consensus validity. On the other hand, my presumption
is that a libbitcoinconsensus that forces its users to a given unifrom
storage will likely had much less users and any alternative
implementation that wants to implement its own custom storage would
have to necessarily reimplement the consensus validation code.
Doing it this way is more flexible. We can relatively easily implement
another library (if I remember correctly, last time we talked about it
we reffered to it as "libconsensus plus", but there's probably better
names) also takes care of storage for the users that don't want to
take the risks of reimplementing the storage (probably just using
Bitcoin Core's structures).

Unlike me, Luke Dashjr, for example, advocated for the
storage-dependent version, but I believe that implementing both
versions was an acceptable solution to him.
It is certainly an acceptable solution for me. I don't want to force
anyone that doesn't want or need to take the risks reimplementing the
consensus storage part to do so. But at the same time I really believe
that it would be a mistake to not allow it optionally.

Does that make sense?

From eric at voskuil.org  Wed Jan 13 22:47:44 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 13 Jan 2016 14:47:44 -0800
Subject: [bitcoin-dev] Libconsensus phase 2
In-Reply-To: <CABm2gDqz8NyZE_juwfqb23Hg5kZUU5oJuXHH098aU+_W8dPhBA@mail.gmail.com>
References: <CABm2gDqPrsuHH4L+dQE-6e162Zj6jbyyB1-6htjB_+2EY2qTXg@mail.gmail.com>	<56955140.7050301@voskuil.org>
	<CABm2gDqz8NyZE_juwfqb23Hg5kZUU5oJuXHH098aU+_W8dPhBA@mail.gmail.com>
Message-ID: <5696D410.7080609@voskuil.org>

On 01/13/2016 12:37 AM, Jorge Tim?n wrote:
> On Tue, Jan 12, 2016 at 8:17 PM, Eric Voskuil <eric at voskuil.org> wrote:
>> Jorge, first, thanks again for your work on this.
>>
>> Without creating and using a public blockchain interface in phase 2, how
>> will you isolate the database dependency from consensus critical code?
>> Is it that the interface will exist but you will recommend against its use?
> 
> The interface will exist but it will be a C++ interface that fits
> better with Bitcoin Core internals.
> See an initial draft of what could be the storage interface:
> https://github.com/jtimon/bitcoin/blob/1717db89c6db17ea65ddbd5eb19034315db0b059/src/consensus/storage_interfaces_cpp.h
> 
> Phase 3 will consist on discussing and refining that interface to also
> define the C interfaces using structs of function pointers instead of
> classes (see https://github.com/jtimon/bitcoin/blob/2bcc07c014e5dd000030e666be047dfa11f54c10/src/consensus/interfaces.h
> for an early draft) that is needed for the "final" C API.
> But since I think there will be more discussion and work defining
> those interfaces, I would rather start with ANY interface that allows
> us to decouple the consensus code from chain.o and coins.o, which we
> don't want to be built as part of the consensus building package
> (which is used for building both libbitcoinconsensus and Bitcoin
> Core).

Okay.

> Future potential users are more than welcomed to draft their own C
> APIs and that experience should be useful for phase 3.
> I was expecting you, for example, to include the whole consensus code
> (even if it lacks a C API) in
> https://github.com/libbitcoin/libbitcoin-consensus for better testing
> of the equivalent code in libbitcoin. You are kind of taking the C API
> part out already, so this time you will just have less things to
> delete/ignore.

Generalization of the store interface may be more challenging than you
anticipate, but the objective makes sense.

>> This work presumes that the users of the library reject the argument
>> that the database implementation is consensus critical code. Faithful
>> reproduction of stored data is a prerequisite for a validity. But a
>> common store implementation is only slightly more reasonable for this
>> library than a common RAM implementation.
> 
> This is a concern that has been risen repeatedly.
> I am aware that faithful reproduction of the stored data is a
> prerequisite for consensus validity. On the other hand, my presumption
> is that a libbitcoinconsensus that forces its users to a given unifrom
> storage will likely had much less users and any alternative
> implementation that wants to implement its own custom storage would
> have to necessarily reimplement the consensus validation code.
> Doing it this way is more flexible. We can relatively easily implement
> another library (if I remember correctly, last time we talked about it
> we reffered to it as "libconsensus plus", but there's probably better
> names) also takes care of storage for the users that don't want to
> take the risks of reimplementing the storage (probably just using
> Bitcoin Core's structures).
> 
> Unlike me, Luke Dashjr, for example, advocated for the
> storage-dependent version, but I believe that implementing both
> versions was an acceptable solution to him.
> It is certainly an acceptable solution for me. I don't want to force
> anyone that doesn't want or need to take the risks reimplementing the
> consensus storage part to do so. But at the same time I really believe
> that it would be a mistake to not allow it optionally.
> 
> Does that make sense?

We would not offer libbitcoinconsensus integration if it required us to
incorporate the store. These are distinct logical components, as are p2p
networking and client-server networking (e.g. RPC), for example. I would
not think of these as multiple versions of libbitcoinconsensus but
instead as distinct components of a bitcoin node. It doesn't make sense
to me that you would ship this as two consensus variants. I would work
toward shipping independent component libraries (i.e. consensus and store).

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160113/6383f5b8/attachment.sig>

From scott at adligo.com  Wed Jan 13 23:47:50 2016
From: scott at adligo.com (Scott Morgan)
Date: Wed, 13 Jan 2016 17:47:50 -0600
Subject: [bitcoin-dev] Fwd: Wallet Lock, Unlock BIP idea
In-Reply-To: <CANEdHmjczpys1RMaZAahE-L==xMDzuVT=eyVApCxU_AHswtEYQ@mail.gmail.com>
References: <CANEdHmjczpys1RMaZAahE-L==xMDzuVT=eyVApCxU_AHswtEYQ@mail.gmail.com>
Message-ID: <CANEdHmgBkwLxJNqEwoWCVL7Vrsiv8WZReJp2so+UvMG1A38Gmg@mail.gmail.com>

Hi All,

   Here is a suggestion which is similar to bip-0065, but slightly
different.
In a nutshell I under stand bip-0065 to do this;
Create a transaction adding a lock time, that the recipient user must wait
before they can spend the coins.

My proposal is to do this;
Create an entry in the blocks to lock entire wallet addresses indefinitely,
with a specified unlock period.
Later on create / modify an entry in the blocks to acknowledge the wallet
is being unlocked.
Remove the lock on the wallet after the unlock period has transpired.

  I think it is technically feasible since many wallet addresses are in
each block at the transaction level.  However, it would have huge
implications to the entire Bitcion ecosystem, so it would probably need a
start date at least a year in the future after it was developed.

bip-0065 would not allow the following;
  This would allow users holding coins for long periods to monitor the
blockchain to see if someone else is unlocking their wallets (which may
have been stolen/copied etc), giving them some time to react to a
intrusion.  Perhaps there should also be a re-lock (during unlock) feature.

My original message is attached.

Cheers,
Scott

---------- Forwarded message ----------
From: Scott Morgan <scott at adligo.com>
Date: Tue, Jan 12, 2016 at 3:35 PM
Subject: Wallet Lock, Unlock BIP idea
To: bitcoin-dev at lists.linuxfoundation.org


Hi All,

   It seems to me that one of the large issues with bitcoin is that they
can be stolen like cash.   This issue also culminates with the fact that
most miners probably need to hold their coins for some time to be
profitable due to the large interest in mining.
   I think it may be possible to reduce some of this theft by adding a BIP
to lock and unlock wallets.  Here is the basic idea (probably with some
holes);

   1) Users could 'lock' their wallet specifying a unlock period (i.e. 15
days)
       The information that a particular wallet is locked would get added
to the blocks and confirmed like other transactions.
    2) During transaction creation and mining (to be sure a locked wallet
isn't drained) the top blocks would be checked to see if the wallet is
locked.  Locked wallet transactions would not be confirmed.
    3)  Users would eventually 'unlock' their wallet.
        This would put a unlocking as of date time in the blocks to specify
a wallet is unlocking.  Eventually the wallet would not have any lock or
unlocking entries in the blocks.
    4) The users would wait the unlock period (i.e. 15 days)
    5) The Users could then spend their coins.


   This would also have some other consequences on the bitcoin system,
since anyone could check the transactions to locked wallets to see how many
BTC are being held, or are being unlocked soon.   This could effect the
price of BTC in fiat as supply would change similar to the way mining
changes it.  Also it will slow transaction creation a little and mining a
fair amount.
   Also locking a wallet might incur a fee.

  What are your thoughts, does this idea qualify for a BIP?
  If so, I would appreciate it if someone takes it and runs with it.

Cheers,
Scott

PS A bit about me, I am a Privacy and Java evangelist, so I will not be
doing any work on the main bitcoin core.  I have been doing a little mining
to attempt to help fund my companies (Adligo Inc) open source Java projects
Tests4j and Fabricate and hopefully in the future Taxi, Sanctum and
Intelligence4j.

Donations are always welcome;

http://www.plumfund.com/crowdfunding/adligoorg
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160113/08c2eb43/attachment.html>

From buzz at spacedout.nl  Thu Jan 14 08:38:29 2016
From: buzz at spacedout.nl (Bastiaan van den Berg)
Date: Thu, 14 Jan 2016 09:38:29 +0100
Subject: [bitcoin-dev] Fwd: Wallet Lock, Unlock BIP idea
In-Reply-To: <CANEdHmgBkwLxJNqEwoWCVL7Vrsiv8WZReJp2so+UvMG1A38Gmg@mail.gmail.com>
References: <CANEdHmjczpys1RMaZAahE-L==xMDzuVT=eyVApCxU_AHswtEYQ@mail.gmail.com>
	<CANEdHmgBkwLxJNqEwoWCVL7Vrsiv8WZReJp2so+UvMG1A38Gmg@mail.gmail.com>
Message-ID: <CACLj26+DkRkUT2B4=jscs2YWTx6iq+zOS2o33AOLnvuhznFdvw@mail.gmail.com>

You might not be aware, but the wallet supports encrypting. Which then
means that when Mr Badguy steals your wallet.dat, he cannot do anything
with it without the passphrase. See RPC calls 'encryptwallet'
'walletpassphrase' and 'walletlock'.

Also i'd like to say, that adding a big waving flag in the blockchain to
say you are locking/unlocking your wallet might not match good privacy
ethics ;)
?
--
buZz
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160114/1d659519/attachment.html>

From scott at adligo.com  Thu Jan 14 18:26:57 2016
From: scott at adligo.com (Scott Morgan)
Date: Thu, 14 Jan 2016 12:26:57 -0600
Subject: [bitcoin-dev] Fwd: Wallet Lock, Unlock BIP idea
Message-ID: <CANEdHmhM+j=xrK8Lv+5hmVTC6VojGTF0dCiKDxcjYY51S4zPkg@mail.gmail.com>

Hi Again (buZz),

   I am aware of wallet encryption, even if encryptwallet was NOT there you
could always copy wallet.dat and use a third party encryption /decryption
tool.   Also any encryption can be broken, although this may not be
profitable.   I know a few people who still have problems with intruders
taking copper pipe out of buildings in Chicago, which is also unprofitable
since commodity prices have crashed.
   Your right that a big waving flag in the block chain may be a bad idea,
I figured there would be a good way to obsfucate the information through
some one way encryption.  Then anyone could check if wallet '1ABC...' is
locked by encrypting the wallet address and comparing it to a list of
encrypted wallet addresses, but couldn't easily obtain a list of locked or
unlocking wallets.   I haven't done any detailed work on implementation
though, as I mentioned.

Cheers,
Scott
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160114/750ce265/attachment.html>

From laanwj at gmail.com  Sun Jan 17 10:08:08 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Sun, 17 Jan 2016 11:08:08 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
Message-ID: <20160117100808.GA4299@amethyst.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Binaries for bitcoin Core version 0.12.0rc1 are available from:

    https://bitcoin.org/bin/bitcoin-core-0.12.0/test/

Source code can be found on github under the signed tag

    https://github.com/bitcoin/bitcoin/tree/v0.12.0rc1

This is a release candidate for a new major version release, bringing new
features, bug fixes, as well as other improvements.

Preliminary release notes for the release can be found here:

    https://github.com/bitcoin/bitcoin/blob/0.12/doc/release-notes.md

Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.12.0.

Please report bugs using the issue tracker at github:

    https://github.com/bitcoin/bitcoin/issues

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBCgAGBQJWm2fGAAoJEHSBCwEjRsmm274H/2BH3QD4AlJ87mQ8g6bzzv7h
S8m/EEDmpOuMgM6uF5PzWQ84yNfSyMItq7Y3cU8p9Fv+JD6ic1ZQPPQ0MQc3KtDx
EeF3wQ2iJe/ggBFcwrz0eIxfEOEo1mi5ooWMVSsnCKQU0IpMtq7ToMvhi/39ACnj
GsVRBJYlFoRCBh1LKkcyID7Fh7JstMgMrLEcrCy46T9h2EQEevlLydkwY26ENYUO
BasWXMaysdeKieO5S6tM6MD/50Bd19jHvjzvkeRY5+nZIdrNR1b5n7diCLEUa7b4
79oIqjdKF+4ns5Qgc+iVhIktthRyrHLrWxX7N8Ky+hSVj1OAKFZfdp4skgAzQUE=
=oVOV
-----END PGP SIGNATURE-----

From kanzure at gmail.com  Sun Jan 17 08:02:29 2016
From: kanzure at gmail.com (Bryan Bishop)
Date: Sun, 17 Jan 2016 02:02:29 -0600
Subject: [bitcoin-dev] Some more lightning-related git repos
Message-ID: <CABaSBaxA-Vcz92Eq8ogpDDdKJZ6MX9W+grdyUthzN9hkxmdSHw@mail.gmail.com>

I saw these two repositories through the -wizards IRC channel earlier
today. I have not reviewed any of the source code for quality, security or
functionality, so I don't have word to offer regarding status of these.

https://github.com/LightningNetwork/lnd
https://github.com/LightningNetwork/lightning-onion

Also other git repositories with related work:
https://github.com/ElementsProject/lightning
https://github.com/matsjj/thundernetwork

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160117/62dee7f2/attachment.html>

From xor at freenetproject.org  Sun Jan 17 22:57:28 2016
From: xor at freenetproject.org (xor at freenetproject.org)
Date: Sun, 17 Jan 2016 23:57:28 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <20160117100808.GA4299@amethyst.visucore.com>
References: <20160117100808.GA4299@amethyst.visucore.com>
Message-ID: <2974102.cQI6F9PQvI@1337h4x0r>

On Sunday, January 17, 2016 11:08:08 AM Wladimir J. van der Laan via bitcoin-
dev wrote:
> Preliminary release notes for the release can be found here:
> 
>     https://github.com/bitcoin/bitcoin/blob/0.12/doc/release-notes.md


The part which lists raw Git pull requests says:
> #6057 ac5476e re-enable wallet in autoprune

But the main, handwritten part does not mention this.
Is pruning really finished, i.e. could I safely use it as a wallet "end-user"?

IMHO it would be one of the most interesting feature for users, as it could 
fix the issue of taking >60 GB of disk space.

So if it is finished, please mention that
- it's finished
- how to enable it.


Thanks for your hard work! :)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160117/8190b24a/attachment.sig>

From n210241048576 at gmail.com  Sat Jan 16 18:20:13 2016
From: n210241048576 at gmail.com (Robert Grosse)
Date: Sat, 16 Jan 2016 10:20:13 -0800
Subject: [bitcoin-dev] [BIP Draft] A modest proposal to increase maximum
 transactions per block without requiring a hardfork
Message-ID: <CALJjGitKqSPOCC32-HiVG+s159Gn4dLm+7v=60zoqr2_my21Pg@mail.gmail.com>

Summary: This describes a new transaction format which allows most
transactions to take up less space (and thus fit more per block) and a
method to implement it requiring only a (non generalized) softfork.

= Compressed transactions =
This format is designed to allow the majority of transactions to take up
less space, by removing flexibility and unnecessary data. The requirements
to use a compressed transaction are

* Non-coinbase
* 1-8 inputs and 1-8 outputs
* Pay to pubkey hash only

Transactions which want to use arbitrary scripts or a larger number of
inputs and outputs can still use the existing transaction format.

A compressed transaction consists of
header byte, compressed inputs, compressed outputs, optional lock_time

header byte has the following format
* bit 7: Always 1, to make it easy to distinguish compressed and
uncompressed transactions
* bit 6: 1 if lock_time is used, otherwise 0
* bit 5-3: Number of inputs - 1
* bit 2-0: Number of outputs - 1

This saves 5+ bytes from omitting the version number and the input and
output count fields. Additionally, most transactions will not have
lock_time, saving another 4 bytes.

Compressed input:
previous transaction hash, index byte, signature, pubkey, optional
sequence_no

This has the following differences from a normal input: Index is only 1
byte, since it is at most 8 anyway. The top bit of the index byte indicates
whether the input has a sequence number. ScriptSig length is completely
omitted, and signature and public key are included directly, saving space
from the data push and check opcodes. And as before, sequence_no is
optional and usually omitted.

Compressed output:
compressed value (1-7 bytes), pubkeyhash

compressed value format: The high 3 bits of the first byte give the number
of following bytes. The lower 5 bits and the n following bytes comprise the
output value. The maximum possible value is 2099999997690000 satoshis,
which requires 7 bytes to encode, but most values will be far shorter. For
example, a value of 0.01 BTC could be encoded in just 3 bytes, saving 5.

As before the script length field is completely omitted, and the pubkeyhash
is included directly, without extra opcodes.


= Consensus =

Like all softforks, adoption by a minority of miners would cause problems.
Therefore, these changes would only take effect after a consensus. Miners
can advertise support for the new format by increment the version code.
Once X% of Y consecutive blocks have this version, the new changes take
effect. Users who do not upgrade will still work but will not always see
accurate balances in other addresses and miners who do not upgrade risk
mining an invalid block, encouraging them to upgrade.

= The Shadow Chain =

Now for the interesting part: Implementing the new format with only a
softfork. In order to qualify as a softfork, every valid block under the
new rules also has to be valid under the old rules.

Among other things this means that compressed transactions can't just be
included in place of an ordinary transaction in a block, since the legacy
(non-upgraded) clients will consider that invalid. Instead, they will be
hidden as extra data inside the coinbase transaction, which is allowed to
contain arbitrary data.

Additionally, in order to support interoperability between compressed and
uncompressed transactions, uncompressed transactions can hide compressed
inputs and ouputs inside of the normal inputs and outputs using a currently
unused opcode (OP_NOP1, hereafter referred to as OP_SHADOW). OP_SHADOW
isn't a script operation per se; instead it marked scripts that should be
interpreted differently under the new rules.


In the following, shadow input/output refers to a compressed input/output,
which is hidden as metadata and hence not visible to legacy clients.

The blockchain must also still be valid when all the hidden data is
ignored. When moving money from the visible to the shadow chain, there is
no problem, but when moving money back, things get trickier, since the
legacy client won't know about any of the shadow transactions. Therefore,
when sending money to the shadow chain, the transaction includes a
specially marked anyone-can-spend output. When moving money back from the
shadow chain, the transaction "spends" any available such outputs.

Since an arbitrary amount of splitting and combining can occur inside the
shadow chain, these will not be 1:1. Instead a pool of available ouputs is
maintained with a total balance equal to the total balance inside the
shadow chain. The validation rules of upgraded clients ensure that this is
always maintained. A legacy client may try to spend these outputs, but it
would fail validation under the new rules and quickly become orphaned.

= Sending money from the visible to the shadow chain =
An uncompressed transaction is created with a specially formatted output.

OP_SHADOW OP_PUSHDATA1 <shadow output>

Where <shadow output> is a compressed output using the format described in
the previous section.

A legacy client will interpret this as an anyone-can-spend output. An
upgraded client will see the OP_SHADOW and interpret this specially, rather
than as a normal script. Instead it will interpret the data as a compressed
output, and add it as a shadow UTXO, which can be spent by compressed
transactions. Additionally, it will note that the visible output can be
used later when withdrawing from the shadow chain.

= Sending money from the shadow chain to the visible chain =
An uncompressed transaction is created with a specially formatted input.

OP_SHADOW OP_PUSHDATA1 <shadow input>

Where <shadow input> is a compressed input using the format described in
the previous section.

The legacy client will interpret this as spending one of the
anyone-can-spend outputs from earlier. The upgraded client will see the
leading OP_SHADOW and recognize that it should be interpreted specially. It
will perform all the normal verification that <shadow input> is a valid
input and not already spent in the shadow chain, etc. Thus the blockchain
is seen as valid by both legacy and upgraded clients.

Note: These scripts are currently considered nonstandard and will not be
relayed by legacy clients. As part of implementing the new protocol,
upgraded clients will obviously be modified to relay these transactions.
Since the consensus step earlier ensures that these are a majority of the
network before the changes take effect, this shouldn't be much of a problem.

= Combining and splitting inputs =

The above illustrates the simplest case. In practice, it will often by the
case that the available pool of OP_SHADOW marked anyone-can-spend UTXOs
doesn't match up exactly with the amount being withdrawn.

If the amounts available are too small, the uncompressed transaction can
include multiple inputs. The first one will contain the shadow input data
as above, and the subsequent inputs will just say

OP_SHADOW OP_TRUE

Likewise, the left over change will be included as an extra output with the
script
OP_SHADOW

Each uncompressed transaction can include up to 8 shadow inputs and up to 8
shadow outputs. The validation rules require that the total amount of
marked anyone-can-spend outputs being spent and created matches up with the
total balance leaving and entering the shadow chain.

What if you want to create an actual anyone-can-spend output under the new
rules? Just include an empty script as before. Only scripts that begin with
OP_SHADOW take part in the shadow deposit/withdrawal process.

I hope I explained my idea well enough. It's fairly complex, but I think it
works. Unlike the "generalized softfork" proposals, this is a true
softfork, as the new blockchain is still valid under the old rules, just
interpreted a bit differently.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160116/136367b7/attachment.html>

From laanwj at gmail.com  Mon Jan 18 11:14:16 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 18 Jan 2016 12:14:16 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <2974102.cQI6F9PQvI@1337h4x0r>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<2974102.cQI6F9PQvI@1337h4x0r>
Message-ID: <20160118111416.GA23240@amethyst.visucore.com>

On Sun, Jan 17, 2016 at 11:57:28PM +0100, xor--- via bitcoin-dev wrote:
> On Sunday, January 17, 2016 11:08:08 AM Wladimir J. van der Laan via bitcoin-
> dev wrote:
> > Preliminary release notes for the release can be found here:
> > 
> >     https://github.com/bitcoin/bitcoin/blob/0.12/doc/release-notes.md
> 
> 
> The part which lists raw Git pull requests says:
> > #6057 ac5476e re-enable wallet in autoprune
> 
> But the main, handwritten part does not mention this.
> Is pruning really finished, i.e. could I safely use it as a wallet "end-user"?

It has been tested in git for almost half a year. This RC is the first binary
release that contains the functionality.

It is extremely unlikely that the wallet will eat your coins (always backup
nevertheless), but I can't guarantee there won't be some issue where the wallet
and chain get out of sync and you're forced to redownload the blockchain.

> IMHO it would be one of the most interesting feature for users, as it could 
> fix the issue of taking >60 GB of disk space.
> 
> So if it is finished, please mention that
> - it's finished
> - how to enable it.

How to enable it is still the same as mentioned in the 0.11 release notes:
https://github.com/bitcoin/bitcoin/blob/v0.11.0/doc/release-notes.md#block-file-pruning

Wladimir

From aj at erisian.com.au  Mon Jan 18 12:02:51 2016
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 18 Jan 2016 22:02:51 +1000
Subject: [bitcoin-dev] Capacity increases for the Bitcoin system.
In-Reply-To: <20151208045803.GA1042@sapphire.erisian.com.au>
References: <CAAS2fgQyVs1fAEj+vqp8E2=FRnqsgs7VUKqALNBHNxRMDsHdVg@mail.gmail.com>
	<20151208024224.GA32631@sapphire.erisian.com.au>
	<20151208045803.GA1042@sapphire.erisian.com.au>
Message-ID: <20160118120251.GA14507@sapphire.erisian.com.au>

TLDR:

  1.7MB effective block size is a better estimate than 1.6MB for p2pkh
  with segwit. 2MB for 2/2 multisig still seems accurate.

  Additional post-segwit soft forked script improvements can improve
  the effective block size for p2pkh txns from 1.7MB to 1.9MB, and for
  2/2 multisig from 2MB to 2.5MB/3MB.

  (To the best of my knowledge, anyway; if I've made a mistake in my
  maths or assumptions, corrections appreciated)

On Tue, Dec 08, 2015 at 02:58:03PM +1000, Anthony Towns via bitcoin-dev wrote:
> So from IRC, this doesn't seem quite right -- capacity is constrained as
>   base_size + witness_size/4 <= 1MB
..
> That would be 1.6MB and 2MB of total actual data if you hit the limits
> with real transactions, so it's more like a 1.8x increase for real
> transactions afaics, even with substantial use of multisig addresses.

I think these numbers are slightly mistaken -- I was only aware of version
1 segwit scripts at the time, and assumed 256 bit hashes would be used
for all segwit transaction, however version 0 segwit txns would be more
efficient for p2pkh, with the same security as bitcoin currently has
(which seems fine).

Also, segwit will make two additional soft-fork improvements possible that
would have a positive effect on transactions per block without requiring
more data per block: ecdsa public key recovery (more space efficient for
*both* multisig and p2pkh) and schnorr signatures (more space efficient
multisig) which might also improve things. I don't know how soon they're
planned to be worked on post segwit's roll out; basic Schnorr signatures
are in the Elements sidechain, but I don't think key recovery has been
implemented anywhere? (Actually, I guess they could both be done already
via softforking OP_NOP opcodes, though segwit makes them slightly
cleaner)

Anyhoo here's some revised figures, working explained in the footnotes.
If I've made mistakes, corrections appreciated, of course.

p2pkh:

  now: 10+146i+34o [0]
  segwit: 10+41i+36o + 0.25*105*i [1]
  ecdsa recovery: 10+41i+33o + 0.25*71*i [2]
  80-bit schnorr: 10+41i+33o + 0.25*71*i (same as ecdsa recovery imo [3])
  128-bit schnorr: 10+41i+43o + 0.25*106*i [4]

(128-bit schnorr provides a not very useful increase in security here)

2-of-2 multisig:

  now: 10+254i+32o [5]
  segwit: 10+43i+43o + 0.25*213*i [6]
  ecdsa recovery: 10+43i+43o + 0.25+187*i [7]
  80-bit schnorr: 10+41i+33o + 0.25*71*i (same as p2pkh)
  128-bit schnorr: 10+41i+43o + 0.25*106*i (same as p2pkh)

(segwit, ecdsa recovery and 128-bit schnorr all provide a beneficial
security increase here, as per the "Time to worry about 80-bit collision
attacks" thread; 80-bit schnorr provides the same security as current
p2sh multisig)

Using the same assumptions in the previous mail, ie that over the long
term number inputs is about the same as number of outputs, these
simplify to:

        p2pkh           2-of-2 msig
now     10+180i         10+286i
segwit  10+104i         10+140i
recov   10+92i          10+133i
sch80   10+92i          10+92i
sch128  10+111i         10+111i

Translating "now" to 100%, the scaling factors work out to be:

i=1, i->inf

        p2pkh           2-of-2 msig
now     100%            100%
segwit  166%-173%       197%-204%
recov   186%-195%       207%-215%
sch80   186%-195%       290%-310%
sch128  157%-162%       244%-257%

So 170% for p2pkh (rather my original estimate of 160%) and 200% for
multisig (same as my original estimate), which can rise via further
soft-forks up to 190% for p2pkh and 250% or 300% for 2-of-2 multisig
(depending on whether you want additional security for 2/2 multisig
beyond what's currently available).

(I'm assuming people are mostly interested in the number of transactions
per block (or tx/second or tx/day); if miners are worried about the
actual data per block (which effects orphan rates) implied by the above,
but don't want to work it out themselves, I could do the maths for that
too pretty easily. Let me know)


If a 2MB hard fork is done first, then the 1/4 discount for segwit could
mean up to 8MB of total data per block -- from what I understand this
is currently infeasible; so I presume that segwit on top of a hardfork
and prior to IBLT/weak blocks would need to have a smaller discount or
no discount applied so as to ensure total data per block remains at 4MB
or less. With no discount for witness data (ie, no "accounting tricks")
those figures look like:

        p2pkh           2-of-2 msig
now     100%            100%
segwit  99%             95%
recov   122%-124%       104%
sch80   122%-124%       191%-198%
sch128  94%-95%         148%-150%

That is, without discounting, segwit comes at a slight cost in
transactions per block, and additional soft forks will only result in
25% gain for p2pkh (via key recovery) and 50%-100% for 2-of-2 multisig
(through the use of schnorr sigs and key recovery, and depending on
whether you want 128 bits of security rather than 80 bits).

(So without the discounting factor, with a 2MB block size, 2MB per block
with segwit and key recovery gives you 25% more p2pkh transactions than
just 2MB per block now; while segwit and schnorr signatures gives you
50%-100% more 2/2 multisig transactions in the same 2MB. Likewise with
1MB or 4MB and no discounting. Discounting has the indirect benefit of
providing a monetary incentive to limit UTXO sizes however)


(2 of 3 multisig for escrow payments would probably be interesting to
work out too; I think ecdsa key recovery combined with 1/4 discounting
would provide a substantial improvement there. I don't think Schnorr
helps at all for that case, unfortunately; and it's probably too small
scale for merkle-ised abstract syntax trees to do any good either)


A caveat: I'm only counting the script data from witnesses here; but it's
possible that additional metadata (such as a length for each witness
signature, or the value of the input, or even some/all of the merkle
hashes) should also be accounted for. I don't think any of them need to
be accounted for segwit as proposed, but I'm not sure. And it might well
be different for a hardforked segwit; there I have no idea at all. I
don't think a byte or two for length would make much difference, at least.

Cheers,
aj

[0] 10 bytes for version (4), input count (1), output count (1) and
    locktime (4); 146 bytes per input consisting of tx hash (32), txout
    index (4), script length (1), scriptsig (signature and pubkey =
    105), CHECKSIG = 25), and sequence number (4); 34 bytes per output
    consisting of value (8), script length (1) and scriptpubkey (DUP
    HASH160 PUSH20 EQVERIFY CHECKSIG = 25).

[1] Same as now, except two extra bytes per output script (segwit push and
    segwit version byte), and moving the 105 bytes of signature script
    directly into the segregated witness

[2] Allowing ECDSA recovery requires an additional soft-fork post segwit
    to change the CHECKSIG operation; this requires bumping the
    segwit script version to 2 or higher and possibly using a different
    opcode, but allows the scriptsig to just be the 70 byte signature,
    without also including the 33 byte pubkey. The 33 byte pubkey is
    automatically calculated from the signature, and verified against
    the hash provided in the scriptpubkey to maintain security, with a
    scriptpubkey like: [PUSH (20 byte pubkey hash) CHECKSIG_RECOVER] (22
    bytes versus 25 bytes), and a scriptsig like [PUSH (70 byte sig)]
    (71 bytes versus 105 bytes).

[3] libsecp256k1 has a function to recover a pubkey from a schnorr
    signature, so I'm assuming that means pubkey recovery with schnorr
    is possible :) -- I haven't actually verified the maths
    https://github.com/bitcoin/secp256k1/blob/master/include/secp256k1_schnorr.h

[4] The witness scriptpubkey is limited to 32 bytes (plus push op and
    version byte for a total of 34 bytes, so 128 bit security requires
    version 1 segwit, and p2sh-style constuction. Hence: 10 bytes
    (version, input and output counts and locktime); 41 base bytes per
    input (tx hash, tx index, script length, and sequence number); 106
    witness bytes per input (sig (70 bytes) plus witness script (PUSH
    schnorr merged pubkey (32 bytes) plus CHECKSCHNORR), plus PUSH ops);
    and 43 bytes per output (value, script length, and 34 bytes for the
    v1-style witness script).

[5] Per input is (32 bytes tx hash, 4 bytes tx index, 4 bytes nsequence,
    1 byte scriptsig length, 143 bytes for actual signature (2x70
    for the sigs, 3 bytes for OP_0 and two OP_PUSH), and 70 bytes for
    the redeemscript (2 pub pub 2 OP_CHECKMULTISIG)) for 254 bytes;
    per output is (8 bytes value, 1 byte length, 23 bytes for HASH160
    [20 byte hash] OP_EQUAL) for 32 bytes.

[6] Per input is (34 bytes tx hash, 4 bytes tx index, 4 bytes nsequence,
    1 byte scriptsig length) for 43 bytes in the base block and (143
    bytes for the actual signature, plus 70 bytes for the redeemscript)
    for 213 bytes of witness data; per output is (8 bytes value, 1 byte
    length, and 34 bytes for version 1 segwit scriptpubkey) for 43
    bytes.

[7] Same as [6], but with key recovery on a MULTISIG op, rather than 33
    bytes per pubkey, this could be reduced to a 20 byte pubkey hash
    per pubkey, for a saving of 26 bytes of witness data.


From luke at dashjr.org  Tue Jan 19 02:12:29 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 19 Jan 2016 02:12:29 +0000
Subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process
In-Reply-To: <CAAxp-m8JW-WOCem6a4RmBk7HOV3cCc02r5r=BkEDyUBu84u4=A@mail.gmail.com>
References: <64B72DF6-BE37-4624-ADAA-CE28C14A4227@gmail.com>
	<201509042145.34410.luke@dashjr.org>
	<CAAxp-m8JW-WOCem6a4RmBk7HOV3cCc02r5r=BkEDyUBu84u4=A@mail.gmail.com>
Message-ID: <201601190212.30685.luke@dashjr.org>

On Saturday, September 05, 2015 9:19:51 PM Andy Chase wrote:
> Okay for sure yeah writing another proposal that reflects the current state
> of affairs as people see it might provide some interesting perspective on
> this proposal. I would welcome that.

Are you saying your proposal is intentionally not intended to reflect the 
reality? I wasn't talking about a "current state of affairs" for BIPs as much 
as that that the acceptance of BIPs is *defined by* the state of affairs.

Overall, I think something *similar to* this proposal is a good idea, but I 
disagree with how this proposal currently approaches the problem. Instead, 
what I would recommend is a specification based on BIP 123 that specifies the 
conditions under which a proposal is *known to be* accepted by the community 
(ie, discerning, not deciding), and establishes a way for a committee to 
review the BIP and *determine* if these conditions have been met. This would 
avoid a "disconnect" between the "official status" and reality, making the BIP 
process more useful to everyone.

Reviewing your current proposal:

> * It sets up '''committees''' for reviewing comments and indicating
> acceptance under precise conditions.

As mentioned, IMO a committee shouldn't be indicating acceptance, as much as 
it should be *determining* acceptance.

> ** Committees are authorized groups that represent client authors, miners,
> merchants, and users (each as a segment). Each one must represent at least
> 1% stake in the Bitcoin ecosystem.

1% seems like an awful lot to dedicate to BIP status changes.

> A committee system is used to organize the essential concerns of each
> segment of the Bitcoin ecosystem. Although each segment may have many
> different viewpoints on each BIP, in order to seek a decisive yes/no on a
> BIP, a representational authoritative structure is sought. This structure
> should be fluid, allowing people to move away from committees that do not
> reflect their views and should be re-validated on each BIP evaluation.

That sounds very time consuming. And what happens if these committees don't 
represent the community? What about when only part of the community - let's 
say 10% - decides to adopt a BIP that doesn't require consensus? Logically 
that BIP should still proceed...

> ** Proof of claim and minimum 1% stake via:
> *** Software: proof of ownership and user base (Min 1% of Bitcoin userbase)

But the Bitcoin user base is completely unknown, and tracking software user 
base is a privacy violation.

> ** Merchant: proof of economic activity (Min 1% of Bitcoin economic
> activity)

Bitcoin economic activity is also unknown, and it seems likely that merchants 
consider their own activity confidential.

> Mining: proof of work (Min 1% of Hashpower)

This needs a proper specification. How do miners express their positions?

> A BIP Process Manager should be chosen who is in charge of:

Chosen how, and by whom?

> == Conditions for activation ==
>
> In order for this process BIP to become active, it must succeed by its own
> rules. At least a 4% sample of the Bitcoin community must be represented,
> with at least one committee in each segment included. Once at least one
> committee has submitted a declaration, a request for comments will be called
> and the process should be completed from there.

Until this BIP is active, its rules do not apply, so this would be a form of 
circular reasoning. I like the idea of putting conditions for activation in 
the BIP text, but I don't think we can just let the author set any conditions 
they like either...

Luke

From achow101 at gmail.com  Tue Jan 19 01:39:19 2016
From: achow101 at gmail.com (Andrew C)
Date: Tue, 19 Jan 2016 01:39:19 +0000
Subject: [bitcoin-dev] What is OpenSSL still used for?
Message-ID: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>

In the release notes for 0.12, it says that we have moved from using
OpenSSL to libsecp256k1 for signature validation. So what else is it being
used for that we need to keep it as a dependency?

Thanks,
Andrew
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160119/2cc15d41/attachment.html>

From eth3rs at gmail.com  Tue Jan 19 03:58:22 2016
From: eth3rs at gmail.com (Ethan Heilman)
Date: Mon, 18 Jan 2016 22:58:22 -0500
Subject: [bitcoin-dev] What is OpenSSL still used for?
In-Reply-To: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>
References: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>
Message-ID: <CAEM=y+XUj00YZ=O98nn_NChBZ0=KiX7nPFegnyrDyOQiPgeGmA@mail.gmail.com>

I believe libsecp256k1 just performs Elliptic Curve operations
required by Bitcoin. OpenSSL is used for all other crypto.

For instance the PRNG appears to be OpenSSL:
https://github.com/bitcoin/bitcoin/blob/master/src/random.h


On Mon, Jan 18, 2016 at 8:39 PM, Andrew C via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> In the release notes for 0.12, it says that we have moved from using OpenSSL
> to libsecp256k1 for signature validation. So what else is it being used for
> that we need to keep it as a dependency?
>
> Thanks,
> Andrew
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From xor at freenetproject.org  Tue Jan 19 06:06:50 2016
From: xor at freenetproject.org (xor at freenetproject.org)
Date: Tue, 19 Jan 2016 07:06:50 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <20160118111416.GA23240@amethyst.visucore.com>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<2974102.cQI6F9PQvI@1337h4x0r>
	<20160118111416.GA23240@amethyst.visucore.com>
Message-ID: <1591452.8UA7xN1qih@1337h4x0r>

On Monday, January 18, 2016 12:14:16 PM Wladimir J. van der Laan wrote:
> It has been tested in git for almost half a year. This RC is the first
> binary release that contains the functionality.
> 
> It is extremely unlikely that the wallet will eat your coins (always backup
> nevertheless), but I can't guarantee there won't be some issue where the
> wallet and chain get out of sync and you're forced to redownload the
> blockchain.

I think I asked the wrong way, sorry: My question was not really meant at 
whether it is bug-free (testing that is the purpose of a release candidate, so 
we of course don't know yet), but rather whether it is at least feature 
complete now.

Remember, the previous v0.11.0 release notes said:
> Block pruning is currently incompatible with running a wallet due to the
> fact that block data is used for rescanning the wallet and importing keys
> or addresses (which require a rescan.) However, running the wallet with
> block pruning will be supported in the near future, subject to those
> limitations.

So I'm interested whether this limitation has been lifted, and the whole 
feature is considered as finished.

If yes, I would highly recommend advertising it in the new release notes - as 
said, the disk space reduction is a big deal.


Thank you!
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160119/54b4bd69/attachment-0001.sig>

From elombrozo at gmail.com  Tue Jan 19 11:54:15 2016
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Tue, 19 Jan 2016 03:54:15 -0800
Subject: [bitcoin-dev] Segregated Witness App Development
Message-ID: <46426D6D-E4DB-4CB6-A63A-4388A9286B2F@gmail.com>

Hello, folks.

I wanted to let all of you know a new IRC channel has been created called #segwit-dev where we welcome all discussion pertaining to integrating and supporting segregated witness transactions in wallets as well as comments or suggestions for improvement to the spec. Please come join us. :)


??
Eric

From dscotese at litmocracy.com  Tue Jan 19 06:07:52 2016
From: dscotese at litmocracy.com (Dave Scotese)
Date: Mon, 18 Jan 2016 22:07:52 -0800
Subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process
In-Reply-To: <201601190212.30685.luke@dashjr.org>
References: <64B72DF6-BE37-4624-ADAA-CE28C14A4227@gmail.com>
	<201509042145.34410.luke@dashjr.org>
	<CAAxp-m8JW-WOCem6a4RmBk7HOV3cCc02r5r=BkEDyUBu84u4=A@mail.gmail.com>
	<201601190212.30685.luke@dashjr.org>
Message-ID: <CAGLBAhdanrqDDA2keA8gLLD-0w1YcEnysA3Cz+1nTOLDAd4Wkg@mail.gmail.com>

This seems like a good place to point out that attempts to identify
individuals (either by name or simply as an individual human being) are
futile as well as destructive.  "1%" usually means "one out of every 100
people" but this requires identification of individuals as individuals.
One person can look like many in Bitcoin, which is why such an effort is
futile.  Additionally, one person may be far more affected by a decision
than others, which is why it's destructive.

I like the idea of measuring consensus, and there are proto-ideas in my
head about how that can be done, based not on individual people, but on
amounts of bitcoin.  Many will argue that we don't want the system to be
controlled by those who hold the most bitcoin.  I understand that
sentiment, but A) I simply disagree, and B) Finding something better seems
impossible to me.

A simple method is the following:
A message can be constructed saying: "As of block X, the holder(s) of Y BTC
controlled by [public key] agrees that Z," where X, Y, Z, and the [public
key] are the only things that change.  This message can be signed by the
private key matching the [public key] in the message.  Anyone interested in
measuring consensus on anything relative to bitcoin holders can advertise
for such signed messages to be sent to a repository of their choice which
would validate each message (that [public key] (still) holds Y BTC and that
the signature is valid) and provide a measure of agreement about Z.  Change
your mind?  Just move your BTC to a different address.

On Mon, Jan 18, 2016 at 6:12 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Saturday, September 05, 2015 9:19:51 PM Andy Chase wrote:
> > Okay for sure yeah writing another proposal that reflects the current
> state
> > of affairs as people see it might provide some interesting perspective on
> > this proposal. I would welcome that.
>
> Are you saying your proposal is intentionally not intended to reflect the
> reality? I wasn't talking about a "current state of affairs" for BIPs as
> much
> as that that the acceptance of BIPs is *defined by* the state of affairs.
>
> Overall, I think something *similar to* this proposal is a good idea, but I
> disagree with how this proposal currently approaches the problem. Instead,
> what I would recommend is a specification based on BIP 123 that specifies
> the
> conditions under which a proposal is *known to be* accepted by the
> community
> (ie, discerning, not deciding), and establishes a way for a committee to
> review the BIP and *determine* if these conditions have been met. This
> would
> avoid a "disconnect" between the "official status" and reality, making the
> BIP
> process more useful to everyone.
>
> Reviewing your current proposal:
>
> > * It sets up '''committees''' for reviewing comments and indicating
> > acceptance under precise conditions.
>
> As mentioned, IMO a committee shouldn't be indicating acceptance, as much
> as
> it should be *determining* acceptance.
>
> > ** Committees are authorized groups that represent client authors,
> miners,
> > merchants, and users (each as a segment). Each one must represent at
> least
> > 1% stake in the Bitcoin ecosystem.
>
> 1% seems like an awful lot to dedicate to BIP status changes.
>
> > A committee system is used to organize the essential concerns of each
> > segment of the Bitcoin ecosystem. Although each segment may have many
> > different viewpoints on each BIP, in order to seek a decisive yes/no on a
> > BIP, a representational authoritative structure is sought. This structure
> > should be fluid, allowing people to move away from committees that do not
> > reflect their views and should be re-validated on each BIP evaluation.
>
> That sounds very time consuming. And what happens if these committees don't
> represent the community? What about when only part of the community - let's
> say 10% - decides to adopt a BIP that doesn't require consensus? Logically
> that BIP should still proceed...
>
> > ** Proof of claim and minimum 1% stake via:
> > *** Software: proof of ownership and user base (Min 1% of Bitcoin
> userbase)
>
> But the Bitcoin user base is completely unknown, and tracking software user
> base is a privacy violation.
>
> > ** Merchant: proof of economic activity (Min 1% of Bitcoin economic
> > activity)
>
> Bitcoin economic activity is also unknown, and it seems likely that
> merchants
> consider their own activity confidential.
>
> > Mining: proof of work (Min 1% of Hashpower)
>
> This needs a proper specification. How do miners express their positions?
>
> > A BIP Process Manager should be chosen who is in charge of:
>
> Chosen how, and by whom?
>
> > == Conditions for activation ==
> >
> > In order for this process BIP to become active, it must succeed by its
> own
> > rules. At least a 4% sample of the Bitcoin community must be represented,
> > with at least one committee in each segment included. Once at least one
> > committee has submitted a declaration, a request for comments will be
> called
> > and the process should be completed from there.
>
> Until this BIP is active, its rules do not apply, so this would be a form
> of
> circular reasoning. I like the idea of putting conditions for activation in
> the BIP text, but I don't think we can just let the author set any
> conditions
> they like either...
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160118/da355e45/attachment.html>

From theandychase at gmail.com  Tue Jan 19 04:23:31 2016
From: theandychase at gmail.com (Andy Chase)
Date: Mon, 18 Jan 2016 20:23:31 -0800
Subject: [bitcoin-dev] [BIP/Draft] BIP Acceptance Process
In-Reply-To: <201601190212.30685.luke@dashjr.org>
References: <64B72DF6-BE37-4624-ADAA-CE28C14A4227@gmail.com>
	<201509042145.34410.luke@dashjr.org>
	<CAAxp-m8JW-WOCem6a4RmBk7HOV3cCc02r5r=BkEDyUBu84u4=A@mail.gmail.com>
	<201601190212.30685.luke@dashjr.org>
Message-ID: <CAAxp-m_AFAB7BgHpXvorMeUovxK+TmUD9j7Hwv9bVBXysYfmnw@mail.gmail.com>

Thanks for your comments Luke.

> Are you saying your proposal is intentionally not intended to reflect the
reality?

That's right. I want to be able to include more voices and be able to get a
clearer idea of acceptance then the process currently has available.

This process should work alongside the current one; not replace it.

> conditions under which a proposal is *known to be* accepted by the
community

*known to be* Is what I'm working towards; yes; but I think we need
additional tools/processes to determine that then what we currently have
available.

> As mentioned, IMO a committee shouldn't be indicating acceptance, as much
as
it should be *determining* acceptance.

The committee determine acceptance when taking their opinions in aggregate.
The source of their indication might be similar to what we currently have
(esp for Core Devs, etc.)

> That sounds very time consuming

Ok

> And what happens if these committees don't represent the community?

The committee structures are fluid-- that is users are able to re-organize
at any time.

> What about when only part of the community - let's say 10% - decides to
adopt a BIP that doesn't require consensus

This might happen, but is not a flaw in my process. My process makes it
clear they are going against the acceptance of the rest of the community. I
don't intend to "force" anyone to implement or use an accepted BIP. If that
is desired that's outside the scope of this BIP.

> But the Bitcoin user base is completely unknown, and tracking software
user base is a privacy violation.

I made a suggestion for this here:
https://gist.github.com/andychase/dddb83c294295879308b

If there are other ways for honest but anonymous voting mechanisms (that
aren't proof-of-stake since that's proof-of-most-money) I'd be all ears.

> Bitcoin economic activity is also unknown
> This needs a proper specification. How do miners express their positions?

I agree these are flaws in the proposal. I'm not sure that one way of
indicating should be considered valid forever, but may have to change over
time.

> Chosen how, and by whom?

I think the process could be used to determine this.

> but I don't think we can just let the author set any conditions they like
either

I'm not sure what you mean here but would love more information.

On Mon, Jan 18, 2016 at 6:12 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Saturday, September 05, 2015 9:19:51 PM Andy Chase wrote:
> > Okay for sure yeah writing another proposal that reflects the current
> state
> > of affairs as people see it might provide some interesting perspective on
> > this proposal. I would welcome that.
>
> Are you saying your proposal is intentionally not intended to reflect the
> reality? I wasn't talking about a "current state of affairs" for BIPs as
> much
> as that that the acceptance of BIPs is *defined by* the state of affairs.
>
> Overall, I think something *similar to* this proposal is a good idea, but I
> disagree with how this proposal currently approaches the problem. Instead,
> what I would recommend is a specification based on BIP 123 that specifies
> the
> conditions under which a proposal is *known to be* accepted by the
> community
> (ie, discerning, not deciding), and establishes a way for a committee to
> review the BIP and *determine* if these conditions have been met. This
> would
> avoid a "disconnect" between the "official status" and reality, making the
> BIP
> process more useful to everyone.
>
> Reviewing your current proposal:
>
> > * It sets up '''committees''' for reviewing comments and indicating
> > acceptance under precise conditions.
>
> As mentioned, IMO a committee shouldn't be indicating acceptance, as much
> as
> it should be *determining* acceptance.
>
> > ** Committees are authorized groups that represent client authors,
> miners,
> > merchants, and users (each as a segment). Each one must represent at
> least
> > 1% stake in the Bitcoin ecosystem.
>
> 1% seems like an awful lot to dedicate to BIP status changes.
>
> > A committee system is used to organize the essential concerns of each
> > segment of the Bitcoin ecosystem. Although each segment may have many
> > different viewpoints on each BIP, in order to seek a decisive yes/no on a
> > BIP, a representational authoritative structure is sought. This structure
> > should be fluid, allowing people to move away from committees that do not
> > reflect their views and should be re-validated on each BIP evaluation.
>
> That sounds very time consuming. And what happens if these committees don't
> represent the community? What about when only part of the community - let's
> say 10% - decides to adopt a BIP that doesn't require consensus? Logically
> that BIP should still proceed...
>
> > ** Proof of claim and minimum 1% stake via:
> > *** Software: proof of ownership and user base (Min 1% of Bitcoin
> userbase)
>
> But the Bitcoin user base is completely unknown, and tracking software user
> base is a privacy violation.
>
> > ** Merchant: proof of economic activity (Min 1% of Bitcoin economic
> > activity)
>
> Bitcoin economic activity is also unknown, and it seems likely that
> merchants
> consider their own activity confidential.
>
> > Mining: proof of work (Min 1% of Hashpower)
>
> This needs a proper specification. How do miners express their positions?
>
> > A BIP Process Manager should be chosen who is in charge of:
>
> Chosen how, and by whom?
>
> > == Conditions for activation ==
> >
> > In order for this process BIP to become active, it must succeed by its
> own
> > rules. At least a 4% sample of the Bitcoin community must be represented,
> > with at least one committee in each segment included. Once at least one
> > committee has submitted a declaration, a request for comments will be
> called
> > and the process should be completed from there.
>
> Until this BIP is active, its rules do not apply, so this would be a form
> of
> circular reasoning. I like the idea of putting conditions for activation in
> the BIP text, but I don't think we can just let the author set any
> conditions
> they like either...
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160118/7b057fc4/attachment-0001.html>

From mark at friedenbach.org  Tue Jan 19 16:27:09 2016
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 19 Jan 2016 08:27:09 -0800
Subject: [bitcoin-dev] Segregated Witness App Development
In-Reply-To: <46426D6D-E4DB-4CB6-A63A-4388A9286B2F@gmail.com>
References: <46426D6D-E4DB-4CB6-A63A-4388A9286B2F@gmail.com>
Message-ID: <CAOG=w-tPUHKYaBVjhVAwr_AMhAd3FYQAN5xmb1phT4eRMG5J2w@mail.gmail.com>

Wouldn't this be entirely on topic for #bitcoin-dev? It's probably better
not to fragment the communication channels and associated infrastructure
(logs, bots, etc.)

On Tue, Jan 19, 2016 at 3:54 AM, Eric Lombrozo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello, folks.
>
> I wanted to let all of you know a new IRC channel has been created called
> #segwit-dev where we welcome all discussion pertaining to integrating and
> supporting segregated witness transactions in wallets as well as comments
> or suggestions for improvement to the spec. Please come join us. :)
>
>
> ??
> Eric
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160119/8e206798/attachment.html>

From kanzure at gmail.com  Tue Jan 19 16:31:17 2016
From: kanzure at gmail.com (Bryan Bishop)
Date: Tue, 19 Jan 2016 10:31:17 -0600
Subject: [bitcoin-dev] Segregated Witness App Development
In-Reply-To: <CAOG=w-tPUHKYaBVjhVAwr_AMhAd3FYQAN5xmb1phT4eRMG5J2w@mail.gmail.com>
References: <46426D6D-E4DB-4CB6-A63A-4388A9286B2F@gmail.com>
	<CAOG=w-tPUHKYaBVjhVAwr_AMhAd3FYQAN5xmb1phT4eRMG5J2w@mail.gmail.com>
Message-ID: <CABaSBaxhhQCG6b7=s814CPXKmg1JOgfVYzZrNiC4-+8QhMAw=g@mail.gmail.com>

On Tue, Jan 19, 2016 at 10:27 AM, Mark Friedenbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Wouldn't this be entirely on topic for #bitcoin-dev? It's probably better
> not to fragment the communication channels and associated infrastructure
> (logs, bots, etc.)


Yeah, I agree that this is on topic for #bitcoin-dev. I think that if
segwit discussion got to the point of clouding out all other development
discussions, then perhaps it would be time for a new channel. I would
definitely like to see segwit discussion not fragmented into a separate
venue.

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160119/79cd5c1d/attachment.html>

From rusty at rustcorp.com.au  Thu Jan 21 00:50:46 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 21 Jan 2016 11:20:46 +1030
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
Message-ID: <87si1rycux.fsf@rustcorp.com.au>

Hi all!

        As planned, this is the three month review[1]: discussion of how
moderation should change is encouraged in this thread.

        First, thanks to everyone for the restraint shown in sending
(and responding to!) inflammatory or sand-in-the-gears mails, and being
tolerant with our mistakes and variances in moderation.

The only changes we made to the plan so far:
1) We've stopped clearing the "needs mod" bit after first posts, and
2) Trivially answerable emails or proposals have been answered in the
   reject message itself.

You can see almost all (there was some lossage) rejects at:
        https://lists.ozlabs.org/pipermail/bitcoin-dev-moderation/

So, what should moderation look like from now on?
- Stop moderating altogether?
- Moderate <topic> more/less harshly?
- Use a different method/criteria for moderation?
- Add/remove moderators?
- Other improvements?

Thanks,
Rusty.
[1] http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-October/011591.html

From joroark at vt.edu  Thu Jan 21 02:57:23 2016
From: joroark at vt.edu (Douglas Roark)
Date: Wed, 20 Jan 2016 18:57:23 -0800
Subject: [bitcoin-dev] What is OpenSSL still used for?
In-Reply-To: <CAEM=y+XUj00YZ=O98nn_NChBZ0=KiX7nPFegnyrDyOQiPgeGmA@mail.gmail.com>
References: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>
	<CAEM=y+XUj00YZ=O98nn_NChBZ0=KiX7nPFegnyrDyOQiPgeGmA@mail.gmail.com>
Message-ID: <56A04913.90906@vt.edu>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

On 2016/1/18 19:58, Ethan Heilman via bitcoin-dev wrote:
> I believe libsecp256k1 just performs Elliptic Curve operations 
> required by Bitcoin. OpenSSL is used for all other crypto.

The exact answer, as I understand it, is a bit more nuanced. In
particular, you referenced the PRNG. I believe libsecp256k1, as
currently written, relies on an implementation of RFC 6979 instead of
using a PRNG. I'm guessing this is done for portability reasons (no
need to hook into the OS's RNG).

Otherwise, yes, I believe this answer is basically correct. There are
still some crypto functions not covered by libsecp256k1, at least at
the API level. But, for consensus-critical functionality, I think 0.12
will be rid of OpenSSL.

- -- 
- ---
Douglas Roark
Cryptocurrency, network security, travel, and art.
https://onename.com/droark
joroark at vt.edu
PGP key ID: 26623924
-----BEGIN PGP SIGNATURE-----
Comment: GPGTools - https://gpgtools.org

iQIcBAEBCgAGBQJWoEkTAAoJEEOBHRomYjkkoR0QAKmvgmoOdCw7SLP9cFURltXw
Ro8mOfikjp04C6tsshtiKQ1+jq80wBhioVYIL7XiyNU7ZUNdAWSc/wGBCG+YkMeQ
6h02WJZQtTe0PvGVHIgUw6SiV4ZzXBuapXQX0BgEl0pInvQkRRqWtgrqDlWbqJVg
NKzm8Kh+c8JUHEKbhnC45Jgh2JYHpyXcByLHSyGYsPOprjHmsupCPC6qydrRnuaO
r7YHtObK2myOglJ1h6BXir//+XNbk6RiRNf5voONNAR9L+69BBV7hMVVO3eiDZ12
vrNaOIKhDjhDs1kmkFYi7ML/zKBQRXlb7iM8AEpfCUKl/zK9bSNeblP4ZBGPqjCm
9TGCqGjmKEbg7AYXjyMvmw+jZReediJMNYpCdxaSJi+XJZO6EC28pcKsb6pu/9gX
NCLf1T/f2NoyXxc57aTuHNo0SnVaee1z0+IlGSh+5foxhZGbFmPhxOy3WNIubuou
tm0guAXloCCERwVg0OhhQ3YyrlOWz7VnUrT8cteQC+yP353zdnxay7ZmQh9swcyR
VX7yu4xLcxgbQmBIhMyKs9iQnycOrdNhZEfGx4vQ2ZKAj1CPVqrgKxbtY3KuPfvb
YAzfs/iXaqBHH7FN9juLMRGqkzyVzJ9mIsFyLldADvSoc8RSa1IQiZtfPsIU1w1i
UKEl9Qasje80EojNZNz0
=glL2
-----END PGP SIGNATURE-----

From xor at freenetproject.org  Thu Jan 21 02:25:50 2016
From: xor at freenetproject.org (xor at freenetproject.org)
Date: Thu, 21 Jan 2016 03:25:50 +0100
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <87si1rycux.fsf@rustcorp.com.au>
References: <87si1rycux.fsf@rustcorp.com.au>
Message-ID: <2998879.R5sQRbxZRv@1337h4x0r>

On Thursday, January 21, 2016 11:20:46 AM Rusty Russell via bitcoin-dev wrote:
> So, what should moderation look like from now on?

The original mail which announced moderation contains this rule:
> - Generally discouraged: [...], +1s, [...]

I assume "+1s" means statements such as "I agree with doing X".

Any sane procedure of deciding something includes asking the involved people 
whether they're for or against it.
If there are dozens of proposals on how to solve a particular technical 
problem, how else do you want to decide it than having a vote?
It's very strange that this is not allowed - especially if we consider that 
the Bitcoin community is in a state of constant dissent currently.
The effect is likely that you push the actual decision-making to IRC, which 
less people have access to (since it's difficult to bear the high traffic), 
and thus form some kind of "inner circle" - which makes decisions seem even 
more as if they're being dictated.

So please consider allowing people to say whether they agree with something 
something or don't.


Other than that, thanks for the good latency of moderation, I guess you're 
doing hard work there :)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160121/aee4edba/attachment.sig>

From dscotese at litmocracy.com  Thu Jan 21 04:35:39 2016
From: dscotese at litmocracy.com (Dave Scotese)
Date: Wed, 20 Jan 2016 20:35:39 -0800
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <2998879.R5sQRbxZRv@1337h4x0r>
References: <87si1rycux.fsf@rustcorp.com.au>
	<2998879.R5sQRbxZRv@1337h4x0r>
Message-ID: <CAGLBAhd7DCcRiJ6SZvJ9hEBWvBnmgRWKLL00yxaeiGSEbNKNwQ@mail.gmail.com>

I agree with the prohibition of +1s.  The core competency of those who
provide this list are moderation and technology, not managing a process
through which "involved people [indicate] whether they're for or against
it."

That is certainly an excellent function, but it can be offered by anyone
who wants to run a system for collecting and displaying those indications.
The email list itself is intended to be information rich, and such
"approval voting" is not information-rich enough in my view.

It is a shame that the moderated messages require so many steps to
retrieve.  Is it possible to have the "downloadable version" from
https://lists.ozlabs.org/pipermail/bitcoin-dev-moderation/ for each month
contain the text of the moderated emails?  They do contain the subjects, so
that helps.

On Wed, Jan 20, 2016 at 6:25 PM, xor--- via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thursday, January 21, 2016 11:20:46 AM Rusty Russell via bitcoin-dev
> wrote:
> > So, what should moderation look like from now on?
>
> The original mail which announced moderation contains this rule:
> > - Generally discouraged: [...], +1s, [...]
>
> I assume "+1s" means statements such as "I agree with doing X".
>
> Any sane procedure of deciding something includes asking the involved
> people
> whether they're for or against it.
> If there are dozens of proposals on how to solve a particular technical
> problem, how else do you want to decide it than having a vote?
> It's very strange that this is not allowed - especially if we consider that
> the Bitcoin community is in a state of constant dissent currently.
> The effect is likely that you push the actual decision-making to IRC, which
> less people have access to (since it's difficult to bear the high traffic),
> and thus form some kind of "inner circle" - which makes decisions seem even
> more as if they're being dictated.
>
> So please consider allowing people to say whether they agree with something
> something or don't.
>
>
> Other than that, thanks for the good latency of moderation, I guess you're
> doing hard work there :)
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160120/89ab35ee/attachment.html>

From rusty at rustcorp.com.au  Thu Jan 21 04:44:47 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 21 Jan 2016 15:14:47 +1030
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <2998879.R5sQRbxZRv@1337h4x0r>
References: <87si1rycux.fsf@rustcorp.com.au> <2998879.R5sQRbxZRv@1337h4x0r>
Message-ID: <87powvy20w.fsf@rustcorp.com.au>

xor--- via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> On Thursday, January 21, 2016 11:20:46 AM Rusty Russell via bitcoin-dev wrote:
>> So, what should moderation look like from now on?
>
> The original mail which announced moderation contains this rule:
>> - Generally discouraged: [...], +1s, [...]
>
> I assume "+1s" means statements such as "I agree with doing X".
>
> Any sane procedure of deciding something includes asking the involved people 
> whether they're for or against it.
> If there are dozens of proposals on how to solve a particular technical 
> problem, how else do you want to decide it than having a vote?

+1s here means simpling say "+1" or "me too" that carries no additional
information.  ie. if you like an idea, that's great, but it's not worth
interruping the entire list for.

If you say "I prefer proposal X over Y because <reasons>" that's
different.  As is "I dislike X because <reasons>" or "I need X because
<reasons>".

Hope that clarifies!
Rusty.

From rusty at rustcorp.com.au  Thu Jan 21 05:00:20 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 21 Jan 2016 15:30:20 +1030
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <CAGLBAhd7DCcRiJ6SZvJ9hEBWvBnmgRWKLL00yxaeiGSEbNKNwQ@mail.gmail.com>
References: <87si1rycux.fsf@rustcorp.com.au> <2998879.R5sQRbxZRv@1337h4x0r>
	<CAGLBAhd7DCcRiJ6SZvJ9hEBWvBnmgRWKLL00yxaeiGSEbNKNwQ@mail.gmail.com>
Message-ID: <87bn8fy1az.fsf@rustcorp.com.au>

Dave Scotese via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> writes:
> It is a shame that the moderated messages require so many steps to
> retrieve.  Is it possible to have the "downloadable version" from
> https://lists.ozlabs.org/pipermail/bitcoin-dev-moderation/ for each month
> contain the text of the moderated emails?  They do contain the subjects, so
> that helps.

Yes, it's because we simply forward them to the bitcoin-dev-moderation
mailing list, and it strips them out as attachments.

I'd really love a filter which I could run them through (on ozlabs.org)
to fix this.  Volunteers welcome :)

Cheers,
Rusty.

From dev at jonasschnelli.ch  Thu Jan 21 07:42:56 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 21 Jan 2016 08:42:56 +0100
Subject: [bitcoin-dev] What is OpenSSL still used for?
In-Reply-To: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>
References: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>
Message-ID: <56A08C00.8020403@jonasschnelli.ch>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Hi Andrew

> In the release notes for 0.12, it says that we have moved from
> using OpenSSL to libsecp256k1 for signature validation. So what
> else is it being used for that we need to keep it as a dependency?

Openssl was dropped from the consensus layer (ECC) in 0.12, though, it
still used for...

1) ... getting random numbers (randomize the ECC signing context)
2) [wallet only] ... AES256 encryption of private keys
3) [GUI only] ... SSL/X.509 for BIP70 (payment protocol)

Openssl dependency for 1) and 2) could be removed. There are some ?
outdated ? relevant PRs:

Entropy: https://github.com/bitcoin/bitcoin/pull/5885
AES: https://github.com/bitcoin/bitcoin/pull/5949

I guess for point 3) [BIP70] it makes sense to keep openssl.

/jonas
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBCAAGBQJWoIwAAAoJECnUvLZBb1PsWSMP/2VyURcUUmnFodX1UUkkTQSu
KmEMqRe3Ak1v4B5S+7raodYE+7ePONedHrciUgNfj0GBDu7/5Wl3LD0GnFb0//Nl
JEHPzNQB8xhRjhXux17rq+Kf60qjc+uybJQDDs9KfQQYS+hFTUKXX61s7wwY/QAy
6Vi5FxZRThzFUFWFZvG9KbRLWEbBVONnXLaA4pB0o7UnU2wAHkmPP5wyeCJLy3cW
uggeLYh3X6GBF/+IQ0ndO4yFJ09ROXBS7N1VisJy2Z4zTJr0y6rAVVG9XcPtlkMc
SvMULeiB34odvlZMRMFdCYLHCuff30jN2+aEJST/d+lr4IB2ai8veXwt69yya4p2
4UUL5ueOzKWfgcxVT/qDDcVkZJFqrhdHmMaEggelRakQCSdLly+4X7Mdo/Dx/RC2
PYUDQVGGFephTpzBTQ3fpRGtZu2JX45T2RKyF2qcVlzXrRW7SjqzwGWWuutwbbrS
V9cSMMVS7NU90mgCE4e3G2oqi40H8dOzg+opf5ynChEccgJwUlxrfjj4kJbQZRH1
X00tGeVs93MxQes+vacYq7VYX4pzM1kiU3EMNStyAvCzd8FbGxmiv3C1VKhRj3xK
Oo98Yg18OBL2jQCWHza3nOU5jN8AnjlkXNvrqsaGedjVNirlnR6a+qmklNIiY1lE
kBxMbfAhTLPY3ukqtaSh
=4GfM
-----END PGP SIGNATURE-----

From aj at erisian.com.au  Fri Jan 22 09:46:18 2016
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 22 Jan 2016 19:46:18 +1000
Subject: [bitcoin-dev] Capacity increases for the Bitcoin system.
In-Reply-To: <20160118120251.GA14507@sapphire.erisian.com.au>
References: <CAAS2fgQyVs1fAEj+vqp8E2=FRnqsgs7VUKqALNBHNxRMDsHdVg@mail.gmail.com>
	<20151208024224.GA32631@sapphire.erisian.com.au>
	<20151208045803.GA1042@sapphire.erisian.com.au>
	<20160118120251.GA14507@sapphire.erisian.com.au>
Message-ID: <20160122094618.GA18567@sapphire.erisian.com.au>

On Mon, Jan 18, 2016 at 10:02:51PM +1000, Anthony Towns via bitcoin-dev wrote:
> I think these numbers are slightly mistaken -- I was only aware of version
> 1 segwit scripts at the time, and assumed 256 bit hashes would be used
> for all segwit transaction, however version 0 segwit txns would be more
> efficient for p2pkh, with the same security as bitcoin currently has
> (which seems fine).

Latest segwit code just has version 0 witness format, and treats a 32
byte push as the sha256 of a script, and a 20 byte push as the hash of
the pub key. Also, the witness scriptPubKey format uses "OP_0 [hash]" to
push the version and hash to the script separately, rather than "[0x00
script]" or "[0x01 hash]" (this changes allows segwit transactions to
be encoded backwards compatibly as a p2sh payment).

> p2pkh:
>   segwit: 10+41i+36o + 0.25*105*i [1]

> [0] 10 bytes for version (4), input count (1), output count (1) and
>     locktime (4); 146 bytes per input consisting of tx hash (32), txout
>     index (4), script length (1), scriptsig (signature and pubkey =
>     105), CHECKSIG = 25), and sequence number (4); 34 bytes per output
>     consisting of value (8), script length (1) and scriptpubkey (DUP
>     HASH160 PUSH20 EQVERIFY CHECKSIG = 25).

> [1] Same as [0], except two extra bytes per output script (segwit push
>     and segwit version byte), and moving the 105 bytes of signature
>     script directly into the segregated witness

So this change means segwit p2pkh needs 31 bytes per output not 36 bytes (value,
length stay the same, scriptpubkey becomes "OP_0 PUSH20" for 22 bytes
instead of 25+2 bytes). This gives another couple of percent gain, so:

    segwit: 10+41i+31o + 0.25*105*i [1]

Setting i=o makes:

>         p2pkh           2-of-2 msig
> now     10+180i         10+286i
> segwit  10+104i         10+140i

become:

segwit    10+99i          10+140i

and therefore,

>         p2pkh           2-of-2 msig
> now     100%            100%
> segwit  166%-173%       197%-204%

becomes:

segwit    174%-181%       197%-204%

Constantly creeping up! Pretty nice.

Also, p2pkh with segwit-via-p2sh is probably interesting, those numbers
work out as:

segwit:   10+41i+31o + 0.25*105*i (for comparison)
segp2sh:  10+60i+32o + 0.25*105*i [0]
  ->      10+119i
  ->      147%-151%

So that still looks like a reasonable improvement even if (eg) in the
short term merchants are the only ones that upgrade, and customers just
use non-segwit-aware wallets with a p2sh address that's only redeemable
by a segwit-aware wallet.

Cheers,
aj

[0] 10 bytes standard. For each input, tx hash (32) plus index (4),
    script length (1) and scriptsig which is a push of the standard segwit
    pubscript (22+1) totaling to 60, and witness data is the same as for
    normal segwit (105). Each output is standard p2sh, which is value
    (8), length (1) and script (23) for a total of 32.

Cheers,
aj


From achow101 at gmail.com  Fri Jan 22 16:36:58 2016
From: achow101 at gmail.com (Andrew C)
Date: Fri, 22 Jan 2016 16:36:58 +0000
Subject: [bitcoin-dev] nSequence multiple uses
Message-ID: <CADToNK-O-KWZjLzKAcUz9CZB65to=bCgTfRLTVFhLVKcCjO5bA@mail.gmail.com>

With 0.12 and opt-in RBF, nSequence will have multiple uses. It can be used
for locktime and now signaling for opting in to RBF. However, there is
nothing that I could find that distinguishes the uses for nSequence.
Spending a time locked output requires setting nSequence to less than
MAX_INT but opting into RBF also requires setting nSequence to less than
MAX_INT. By spending a time locked output, you would also be opting into
RBF, which may not be desired behavior. Since using nSequence to signal a
certain behavior will probably be used in the future, is there any plan to
change nSequence so that the features the transaction is using can be
distinguished? Perhaps something like version bits?

Thanks,
Andrew
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160122/790e817d/attachment.html>

From dave at dtrt.org  Sat Jan 23 04:10:42 2016
From: dave at dtrt.org (David A. Harding)
Date: Fri, 22 Jan 2016 23:10:42 -0500
Subject: [bitcoin-dev] nSequence multiple uses
In-Reply-To: <CADToNK-O-KWZjLzKAcUz9CZB65to=bCgTfRLTVFhLVKcCjO5bA@mail.gmail.com>
References: <CADToNK-O-KWZjLzKAcUz9CZB65to=bCgTfRLTVFhLVKcCjO5bA@mail.gmail.com>
Message-ID: <20160123041042.GA5956@localhost.localdomain>

On Fri, Jan 22, 2016 at 04:36:58PM +0000, Andrew C via bitcoin-dev wrote:
> Spending a time locked output requires setting nSequence to less than
> MAX_INT but opting into RBF also requires setting nSequence to less than
> MAX_INT. 

Hi Andrew,

Opt-in RBF requires setting nSequence to less than MAX-1 (not merely
less than MAX), so an nSequence of exactly MAX-1 (which appears in
hex-encoded serialized transactions as feffffff) enables locktime
enforcement but doesn't opt in to RBF.

For more information, please see BIP125:

    https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki

-Dave

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 473 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160122/151c0b39/attachment.sig>

From achow101 at gmail.com  Sat Jan 23 04:41:55 2016
From: achow101 at gmail.com (Andrew C)
Date: Sat, 23 Jan 2016 04:41:55 +0000
Subject: [bitcoin-dev] nSequence multiple uses
In-Reply-To: <20160123041042.GA5956@localhost.localdomain>
References: <CADToNK-O-KWZjLzKAcUz9CZB65to=bCgTfRLTVFhLVKcCjO5bA@mail.gmail.com>
	<20160123041042.GA5956@localhost.localdomain>
Message-ID: <CADToNK96HTcz+pjdQgo7XO2wNhaTkCsAHWbO=WZNPKM0_L4MwQ@mail.gmail.com>

Ahh. I see. Thanks, I must have missed that when going through the BIP.
Guess I need to read more carefully next time.

Thanks,
Andrew

On Fri, Jan 22, 2016 at 11:11 PM David A. Harding <dave at dtrt.org> wrote:

> On Fri, Jan 22, 2016 at 04:36:58PM +0000, Andrew C via bitcoin-dev wrote:
> > Spending a time locked output requires setting nSequence to less than
> > MAX_INT but opting into RBF also requires setting nSequence to less than
> > MAX_INT.
>
> Hi Andrew,
>
> Opt-in RBF requires setting nSequence to less than MAX-1 (not merely
> less than MAX), so an nSequence of exactly MAX-1 (which appears in
> hex-encoded serialized transactions as feffffff) enables locktime
> enforcement but doesn't opt in to RBF.
>
> For more information, please see BIP125:
>
>     https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki
>
> -Dave
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160123/1fa99b48/attachment.html>

From xor at freenetproject.org  Sat Jan 23 05:33:56 2016
From: xor at freenetproject.org (xor at freenetproject.org)
Date: Sat, 23 Jan 2016 06:33:56 +0100
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <87powvy20w.fsf@rustcorp.com.au>
References: <87si1rycux.fsf@rustcorp.com.au> <2998879.R5sQRbxZRv@1337h4x0r>
	<87powvy20w.fsf@rustcorp.com.au>
Message-ID: <1736759.DT0dcscznj@1337h4x0r>

On Thursday, January 21, 2016 03:14:47 PM Rusty Russell wrote:
> +1s here means simpling say "+1" or "me too" that carries no additional
> information.  ie. if you like an idea, that's great, but it's not worth
> interruping the entire list for.
> 
> If you say "I prefer proposal X over Y because <reasons>" that's
> different.  As is "I dislike X because <reasons>" or "I need X because
> <reasons>".

So "+1"ing is OK as long as I provide a technical explanation of why I agree?
While I still think that this is too much of a restriction because it prevents 
peer-review, I would say that I could live with it as a last resort if you 
don't plan to abolish this rule altogether.

So in that case, to foster peer review, I would recommend you amend the rules 
to clarify this.
Example: "+1s are not allowed unless you provide an explanation of why you 
agree with something".
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160123/710d3845/attachment.sig>

From pete at petertodd.org  Sat Jan 23 20:59:53 2016
From: pete at petertodd.org (Peter Todd)
Date: Sat, 23 Jan 2016 15:59:53 -0500
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <1736759.DT0dcscznj@1337h4x0r>
References: <87si1rycux.fsf@rustcorp.com.au> <2998879.R5sQRbxZRv@1337h4x0r>
	<87powvy20w.fsf@rustcorp.com.au> <1736759.DT0dcscznj@1337h4x0r>
Message-ID: <20160123205953.GA22494@muck>

On Sat, Jan 23, 2016 at 06:33:56AM +0100, xor--- via bitcoin-dev wrote:
> So "+1"ing is OK as long as I provide a technical explanation of why I agree?
> While I still think that this is too much of a restriction because it prevents 
> peer-review, I would say that I could live with it as a last resort if you 
> don't plan to abolish this rule altogether.
> 
> So in that case, to foster peer review, I would recommend you amend the rules 
> to clarify this.
> Example: "+1s are not allowed unless you provide an explanation of why you 
> agree with something".

I would extend this to say that the technical explanation also should
contribute uniquely to the conversation; a +1 with an explanation
the last +1 gave isn't useful.

-- 
'peter'[:-1]@petertodd.org
000000000000000007e2005be0ce25b3f3de67b2dc35fd810b0ccd77b33eb7be
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160123/7aa2753d/attachment.sig>

From gavinandresen at gmail.com  Sat Jan 23 21:38:44 2016
From: gavinandresen at gmail.com (Gavin)
Date: Sat, 23 Jan 2016 16:38:44 -0500
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <20160123205953.GA22494@muck>
References: <87si1rycux.fsf@rustcorp.com.au> <2998879.R5sQRbxZRv@1337h4x0r>
	<87powvy20w.fsf@rustcorp.com.au> <1736759.DT0dcscznj@1337h4x0r>
	<20160123205953.GA22494@muck>
Message-ID: <3B18134A-3E3A-4A98-ADD3-9F5E8600047E@gmail.com>


> On Jan 23, 2016, at 3:59 PM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I would extend this to say that the technical explanation also should
> contribute uniquely to the conversation; a +1 with an explanation
> the last +1 gave isn't useful.

Yes, comments should contribute to the discussion, with either technical discussion or additional relevant data. I think a +1 like the following should be encouraged:

"+1: we had eleven customer support tickets in just the last week that would have been prevented if XYZ.

Jane Doe, CTO CoinBitChainBasely.com"


From dscotese at litmocracy.com  Sun Jan 24 01:06:23 2016
From: dscotese at litmocracy.com (Dave Scotese)
Date: Sat, 23 Jan 2016 17:06:23 -0800
Subject: [bitcoin-dev] Three Month bitcoin-dev Moderation Review
In-Reply-To: <3B18134A-3E3A-4A98-ADD3-9F5E8600047E@gmail.com>
References: <87si1rycux.fsf@rustcorp.com.au> <2998879.R5sQRbxZRv@1337h4x0r>
	<87powvy20w.fsf@rustcorp.com.au> <1736759.DT0dcscznj@1337h4x0r>
	<20160123205953.GA22494@muck>
	<3B18134A-3E3A-4A98-ADD3-9F5E8600047E@gmail.com>
Message-ID: <CAGLBAhfBwxnYyN=8EmpaZrfZSDWTL1StZOpqUO3scdzTu+Qxdw@mail.gmail.com>

+1
The distinction we are making importantly requires that contributors
provide readers with another thing to say in favor of something - another
thing which is different than "X people support this instead of only X-1
people."  Evidence trumps votes.

On Sat, Jan 23, 2016 at 1:38 PM, Gavin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> > On Jan 23, 2016, at 3:59 PM, Peter Todd via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > I would extend this to say that the technical explanation also should
> > contribute uniquely to the conversation; a +1 with an explanation
> > the last +1 gave isn't useful.
>
> Yes, comments should contribute to the discussion, with either technical
> discussion or additional relevant data. I think a +1 like the following
> should be encouraged:
>
> "+1: we had eleven customer support tickets in just the last week that
> would have been prevented if XYZ.
>
> Jane Doe, CTO CoinBitChainBasely.com"
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160123/573d40da/attachment.html>

From laanwj at gmail.com  Mon Jan 25 11:58:29 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 25 Jan 2016 12:58:29 +0100
Subject: [bitcoin-dev] What is OpenSSL still used for?
In-Reply-To: <56A08C00.8020403@jonasschnelli.ch>
References: <CADToNK--p5FBxCKXGbab4sa_uOkWL=GxcNKA8f6Dgcz+NE0BMg@mail.gmail.com>
	<56A08C00.8020403@jonasschnelli.ch>
Message-ID: <20160125115829.GA17769@amethyst.visucore.com>

> > In the release notes for 0.12, it says that we have moved from
> > using OpenSSL to libsecp256k1 for signature validation. So what
> > else is it being used for that we need to keep it as a dependency?
> 
> Openssl was dropped from the consensus layer (ECC) in 0.12, though, it
> still used for...
> 
> 1) ... getting random numbers (randomize the ECC signing context)
> 2) [wallet only] ... AES256 encryption of private keys
> 3) [GUI only] ... SSL/X.509 for BIP70 (payment protocol)
> 
> Openssl dependency for 1) and 2) could be removed. There are some ?
> outdated ? relevant PRs:
> 
> Entropy: https://github.com/bitcoin/bitcoin/pull/5885
> AES: https://github.com/bitcoin/bitcoin/pull/5949
> 
> I guess for point 3) [BIP70] it makes sense to keep openssl.

Exactly - the plan is that OpenSSL will, in due time, be a dependency only if the
GUI is enabled. Most of the work for that is already done but it has to be made
up to date and carefully tested and integrated.

Wladimir

From laanwj at gmail.com  Mon Jan 25 12:03:17 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 25 Jan 2016 13:03:17 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <1591452.8UA7xN1qih@1337h4x0r>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<2974102.cQI6F9PQvI@1337h4x0r>
	<20160118111416.GA23240@amethyst.visucore.com>
	<1591452.8UA7xN1qih@1337h4x0r>
Message-ID: <20160125120317.GB17769@amethyst.visucore.com>

> 
> So I'm interested whether this limitation has been lifted, and the whole 
> feature is considered as finished.

Yes, it's exactly that limitation that has been lifted!

> If yes, I would highly recommend advertising it in the new release notes - as 
> said, the disk space reduction is a big deal.

Good idea, has been added by Marco Falke in commit fa31133,

Wladimir

From laanwj at gmail.com  Mon Jan 25 12:09:38 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 25 Jan 2016 13:09:38 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 2 available
Message-ID: <20160125120938.GC17769@amethyst.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Binaries for bitcoin Core version 0.12.0rc2 are available from:

    https://bitcoin.org/bin/bitcoin-core-0.12.0/test/

Source code can be found on github under the signed tag

    https://github.com/bitcoin/bitcoin/tree/v0.12.0rc2

This is a release candidate for a new major version release, bringing new
features, bug fixes, as well as other improvements.

Preliminary release notes for the release can be found here:

    https://github.com/bitcoin/bitcoin/blob/0.12/doc/release-notes.md

Release candidates are test versions for releases. When no critical problems
are found, this release candidate will be tagged as 0.12.0.

Diff since rc1:
- - #7222 `e25b158` RPC: indicate which transactions are replaceable
- - #7386 `da83ecd` Add option `-permitrbf` to set transaction replacement policy
- - #7290 `b16b5bc` Add missing options help
- - #7387 `f4b2ce8` Get rid of inaccurate ScriptSigArgsExpected
- - #7381 `621bbd8` [walletdb] Fix syntax error in key parser
- - #7327 `b16b5bc` [Wallet] Transaction View: LastMonth calculation fixed
- - #7364 `7726c48` [qt] Windows: Make rpcconsole monospace font larger

Please report bugs using the issue tracker at github:

    https://github.com/bitcoin/bitcoin/issues

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAEBCgAGBQJWphBHAAoJEHSBCwEjRsmmh0EIALopACCwaCYRt9vl6fadDLxL
JMTyEPsGUaEX82iwuXeAhdReyvZDlC00ACZy6agp7oOuS1ryqOeYAsc33N+WtHE0
iETNyvRZVD1ASopHkdJrRW1a9X63Yvcvk/d6nVbO5auUAG5gPUFLrSTrqpSzR2D4
QtY1ofifXrYdqdQmPFJ5hnWg/Z1rko99sD8Pu3ebD6Dof5zuvJKHkLmXunGGXn/n
GOn8roS5LXEFHwCcL0zgNzfDywt/dhKiUHMKSNPsnz5qEDRg7WPzsNiQA/HVDlcp
v6akQ4ykZ56Lik8cVLi0NRW2dozSDti/XKBfWQHqWjGUJGUOS+lPJaWLv81oMwc=
=WlQm
-----END PGP SIGNATURE-----

From xor at freenetproject.org  Mon Jan 25 12:27:18 2016
From: xor at freenetproject.org (xor at freenetproject.org)
Date: Mon, 25 Jan 2016 13:27:18 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <20160125120317.GB17769@amethyst.visucore.com>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<1591452.8UA7xN1qih@1337h4x0r>
	<20160125120317.GB17769@amethyst.visucore.com>
Message-ID: <2815165.aykQg88K5r@1337h4x0r>

On Monday, January 25, 2016 01:03:17 PM Wladimir J. van der Laan wrote:
> > If yes, I would highly recommend advertising it in the new release notes -
> > as said, the disk space reduction is a big deal.
> 
> Good idea, has been added by Marco Falke in commit fa31133,

Thanks. The RC2 changelog now says:

> To enable block pruning set prune=<N> on the command line or in
> bitcoin.conf, where N is the number of MiB to allot for raw block & undo
> data.

From having read the Bitcoin whitepaper quite a few months ago ago, I have the 
very very basic understanding that pruning is meant to:
- delete old transaction data which merely "moves coins around"
- instead only store the "origin" (= block where coins were mined) and 
"current location" of the coins, i.e. the unspent transactions. Notably, I 
understood it as "this is as secure as storing everything, since we know where 
the coins were created, and where they are".

So from that point of view, I would assume that there is a "natural" amount of 
megabytes which a fully pruned blockchain consists of: It would be defined by 
the final amount of unspent coins.
I thereby am confused why it is possible to configure a number of megabytes 
"to allot for raw block & undo data". I would rather expect pruning just to be 
a boolean on/off flag, and the number of megabytes to be an automatically 
computed result from the natural size of the dataset.
And especially, I fear that I could set N too low, and as a result, it would 
delete "too much". I mean could this result in even security relevant 
transaction data being deleted?

Thus, it would be nice if you could yet once more edit the release notes to:
- explain why a N must be given
- what a "safe" value of N is. I.e. how large must N be at least to not delete 
security-relevant stuff?
- maybe mention if there is a "auto" setting for N to ensure that it choses a 
safe value on its own?

Sorry if my descriptions are from a layman's point of view. I intentionally 
did *not* re-read the Bitcoin whitepaper to have a better understanding:
I think having a layman's understanding is a good usability test for such 
stuff.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/87785117/attachment.sig>

From laanwj at gmail.com  Mon Jan 25 15:05:59 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 25 Jan 2016 16:05:59 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <2815165.aykQg88K5r@1337h4x0r>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<1591452.8UA7xN1qih@1337h4x0r>
	<20160125120317.GB17769@amethyst.visucore.com>
	<2815165.aykQg88K5r@1337h4x0r>
Message-ID: <20160125150559.GA28847@amethyst.visucore.com>

> > To enable block pruning set prune=<N> on the command line or in
> > bitcoin.conf, where N is the number of MiB to allot for raw block & undo
> > data.
> 

> From having read the Bitcoin whitepaper quite a few months ago ago, I have the 
> very very basic understanding that pruning is meant to:
> - delete old transaction data which merely "moves coins around"
> - instead only store the "origin" (= block where coins were mined) and 
> "current location" of the coins, i.e. the unspent transactions. Notably, I 
> understood it as "this is as secure as storing everything, since we know where 
> the coins were created, and where they are".
> 
> So from that point of view, I would assume that there is a "natural" amount of 
> megabytes which a fully pruned blockchain consists of: It would be defined by 
> the final amount of unspent coins.
> I thereby am confused why it is possible to configure a number of megabytes 
> "to allot for raw block & undo data". I would rather expect pruning just to be 
> a boolean on/off flag, and the number of megabytes to be an automatically 
> computed result from the natural size of the dataset.
> And especially, I fear that I could set N too low, and as a result, it would 
> delete "too much". I mean could this result in even security relevant 
> transaction data being deleted?

The term 'pruning', unfortunately is very much overused and overloaded in the
bitcoin ecosystem. Satoshi's paper refers to UTXO pruning. This is Pieter Wuille's "ultraprune",
which has been part of Bitcoin Core for more than three years.

Block pruning is not mentioned in that paper because it is just administrative,
the only reason that nodes store historical blocks at all is to serve it to other nodes,
as well as to catch up the wallet status and for -reindexes.

> Thus, it would be nice if you could yet once more edit the release notes to:

I don't have time to work on the release notes right now, but if someone else
wants to contribute that'd be awesome.

> - explain why a N must be given

To give a quotum. The point is that the user can choose how much harddisk space they want to
dedicate to block storage.

Block data that is stored can be used by other software, or potentially be
served to other nodes. The latter is not implemented at the moment - it would require
a change to the P2P protocol, thus right now pruning nodes don't serve block
data at all.

> - what a "safe" value of N is. I.e. how large must N be at least to not delete 
> security-relevant stuff?

There is no security compromise with pruning. Any value of N is intended to be safe.

Very low values would delete undo data that may be necessary in a reorganization,
but this is prohibited by argument checks.

Release notes are not meant as a replacement or supplement for documentation.
The documentation for -prune is this:

  -prune=<n>
       Reduce storage requirements by pruning (deleting) old blocks. This mode
       is incompatible with -txindex and -rescan. Warning: Reverting this
       setting requires re-downloading the entire blockchain. (default: 0 =
       disable pruning blocks, >550 = target size in MiB to use for block
       files)

> - maybe mention if there is a "auto" setting for N to ensure that it choses a 
> safe value on its own?

As said, there is no safe or unsafe value. The lowest acceptable value is just as safe
as storing everything.

Wladimir


From falke.marco at gmail.com  Mon Jan 25 14:44:08 2016
From: falke.marco at gmail.com (Marco Falke)
Date: Mon, 25 Jan 2016 15:44:08 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <2815165.aykQg88K5r@1337h4x0r>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<1591452.8UA7xN1qih@1337h4x0r>
	<20160125120317.GB17769@amethyst.visucore.com>
	<2815165.aykQg88K5r@1337h4x0r>
Message-ID: <CAKJqnrGq41ZvGByfH53n1=wJtPZghk+zyNOwZX8RXbJWcr=Xog@mail.gmail.com>

All of this is already implemented in the bitcoind and bitcoin gui.

The theoretic minimum for the prune target would be 0 (just the header
of the current best block) as Bitcoin Core already stores the
chainstate (about 2 GiB) regardless of what you set for -prune=<N>.

In practice, the minimum is 510, so reorgs and small rescans (may not
be implemented in 0.12) are still possible.

The clients won't let you set it below that target:
"Prune configured below the minimum of 550 MiB. Please use a higher number."

Also, keep in mind Bitcoin Core comes with a help message explaining
-prune and other command line options

--Marco

2016-01-25 13:27 GMT+01:00 xor--- via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org>:
> On Monday, January 25, 2016 01:03:17 PM Wladimir J. van der Laan wrote:
>> > If yes, I would highly recommend advertising it in the new release notes -
>> > as said, the disk space reduction is a big deal.
>>
>> Good idea, has been added by Marco Falke in commit fa31133,
>
> Thanks. The RC2 changelog now says:
>
>> To enable block pruning set prune=<N> on the command line or in
>> bitcoin.conf, where N is the number of MiB to allot for raw block & undo
>> data.
>
> From having read the Bitcoin whitepaper quite a few months ago ago, I have the
> very very basic understanding that pruning is meant to:
> - delete old transaction data which merely "moves coins around"
> - instead only store the "origin" (= block where coins were mined) and
> "current location" of the coins, i.e. the unspent transactions. Notably, I
> understood it as "this is as secure as storing everything, since we know where
> the coins were created, and where they are".
>
> So from that point of view, I would assume that there is a "natural" amount of
> megabytes which a fully pruned blockchain consists of: It would be defined by
> the final amount of unspent coins.
> I thereby am confused why it is possible to configure a number of megabytes
> "to allot for raw block & undo data". I would rather expect pruning just to be
> a boolean on/off flag, and the number of megabytes to be an automatically
> computed result from the natural size of the dataset.
> And especially, I fear that I could set N too low, and as a result, it would
> delete "too much". I mean could this result in even security relevant
> transaction data being deleted?
>
> Thus, it would be nice if you could yet once more edit the release notes to:
> - explain why a N must be given
> - what a "safe" value of N is. I.e. how large must N be at least to not delete
> security-relevant stuff?
> - maybe mention if there is a "auto" setting for N to ensure that it choses a
> safe value on its own?
>
> Sorry if my descriptions are from a layman's point of view. I intentionally
> did *not* re-read the Bitcoin whitepaper to have a better understanding:
> I think having a layman's understanding is a good usability test for such
> stuff.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From simon at coingyft.com  Mon Jan 25 15:57:53 2016
From: simon at coingyft.com (Simon Selitsky)
Date: Mon, 25 Jan 2016 10:57:53 -0500
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <20160125150559.GA28847@amethyst.visucore.com>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<1591452.8UA7xN1qih@1337h4x0r>
	<20160125120317.GB17769@amethyst.visucore.com>
	<2815165.aykQg88K5r@1337h4x0r>
	<20160125150559.GA28847@amethyst.visucore.com>
Message-ID: <2A118822-6550-4042-9229-1D213B6FE615@coingyft.com>

>> Block data that is stored can be used by other software, or potentially be
>> served to other nodes. The latter is not implemented at the moment - it would require a change to the P2P protocol, thus right now pruning nodes don't serve block data at all.

Why is the minimum storage quota of 550 MiB necessary for pruning nodes
if the block data is not served to other nodes ? Could the client just do transaction verification and transaction relaying and only keep the block(s) 
being verified on disk ?


On Jan 25, 2016, at 10:05 AM, Wladimir J. van der Laan via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

>>> To enable block pruning set prune=<N> on the command line or in
>>> bitcoin.conf, where N is the number of MiB to allot for raw block & undo
>>> data.
> 
>> From having read the Bitcoin whitepaper quite a few months ago ago, I have the 
>> very very basic understanding that pruning is meant to:
>> - delete old transaction data which merely "moves coins around"
>> - instead only store the "origin" (= block where coins were mined) and 
>> "current location" of the coins, i.e. the unspent transactions. Notably, I 
>> understood it as "this is as secure as storing everything, since we know where 
>> the coins were created, and where they are".
>> 
>> So from that point of view, I would assume that there is a "natural" amount of 
>> megabytes which a fully pruned blockchain consists of: It would be defined by 
>> the final amount of unspent coins.
>> I thereby am confused why it is possible to configure a number of megabytes 
>> "to allot for raw block & undo data". I would rather expect pruning just to be 
>> a boolean on/off flag, and the number of megabytes to be an automatically 
>> computed result from the natural size of the dataset.
>> And especially, I fear that I could set N too low, and as a result, it would 
>> delete "too much". I mean could this result in even security relevant 
>> transaction data being deleted?
> 
> The term 'pruning', unfortunately is very much overused and overloaded in the
> bitcoin ecosystem. Satoshi's paper refers to UTXO pruning. This is Pieter Wuille's "ultraprune",
> which has been part of Bitcoin Core for more than three years.
> 
> Block pruning is not mentioned in that paper because it is just administrative,
> the only reason that nodes store historical blocks at all is to serve it to other nodes,
> as well as to catch up the wallet status and for -reindexes.
> 
>> Thus, it would be nice if you could yet once more edit the release notes to:
> 
> I don't have time to work on the release notes right now, but if someone else
> wants to contribute that'd be awesome.
> 
>> - explain why a N must be given
> 
> To give a quotum. The point is that the user can choose how much harddisk space they want to
> dedicate to block storage.
> 
> Block data that is stored can be used by other software, or potentially be
> served to other nodes. The latter is not implemented at the moment - it would require
> a change to the P2P protocol, thus right now pruning nodes don't serve block
> data at all.
> 
>> - what a "safe" value of N is. I.e. how large must N be at least to not delete 
>> security-relevant stuff?
> 
> There is no security compromise with pruning. Any value of N is intended to be safe.
> 
> Very low values would delete undo data that may be necessary in a reorganization,
> but this is prohibited by argument checks.
> 
> Release notes are not meant as a replacement or supplement for documentation.
> The documentation for -prune is this:
> 
>  -prune=<n>
>       Reduce storage requirements by pruning (deleting) old blocks. This mode
>       is incompatible with -txindex and -rescan. Warning: Reverting this
>       setting requires re-downloading the entire blockchain. (default: 0 =
>       disable pruning blocks, >550 = target size in MiB to use for block
>       files)
> 
>> - maybe mention if there is a "auto" setting for N to ensure that it choses a 
>> safe value on its own?
> 
> As said, there is no safe or unsafe value. The lowest acceptable value is just as safe
> as storing everything.
> 
> Wladimir
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From dev at jonasschnelli.ch  Mon Jan 25 16:12:01 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Mon, 25 Jan 2016 17:12:01 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <2A118822-6550-4042-9229-1D213B6FE615@coingyft.com>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<1591452.8UA7xN1qih@1337h4x0r>
	<20160125120317.GB17769@amethyst.visucore.com>
	<2815165.aykQg88K5r@1337h4x0r>
	<20160125150559.GA28847@amethyst.visucore.com>
	<2A118822-6550-4042-9229-1D213B6FE615@coingyft.com>
Message-ID: <56A64951.7040405@jonasschnelli.ch>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256


> Why is the minimum storage quota of 550 MiB necessary for pruning
> nodes if the block data is not served to other nodes ? Could the
> client just do transaction verification and transaction relaying
> and only keep the block(s) being verified on disk ?
> 

We try to allow reorgs ~288 blocks deep also in pruning:

- From code comments:
Require that user allocate at least 550MB for block & undo files
(blk???.dat and rev???.dat)
At 1MB per block, 288 blocks = 288MB.
Add 15% for Undo data = 331MB
Add 20% for Orphan block rate = 397MB
We want the low water mark after pruning to be at least 397 MB and
since we prune in
full block file chunks, we need the high water mark which triggers the
prune to be
one 128MB block file + added 15% undo data = 147MB greater for a total
of 545MB
Setting the target to > than 550MB will make it likely we can respect
the target.


</jonas>
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2

iQIcBAEBCAAGBQJWpklQAAoJECnUvLZBb1Ps464P+gNqN+Rs5MnAFg5Hukxcj9BU
f+Zm5B99VMT3qWjJUjk05NTPLoa6vS6I6pkanWNlzmquZSardW0rW/7JS8wu8BiA
ILP3gMWMiF2w//0o+4uEhQt5FhUKQGUVgtXDprc/6WeOfpEBunk+/YTmFPpSMQym
w9roH+vrMBHNogSXjdIsn3qPGdVWWuc1PeeluMthN/f7Y5Y5kcyUJvvJmhNbNspG
UaGqh7vCDBvaHmxKuPRvqPlSqvwXjA3kxDP1s+VBtLGKnJzVoBqBEsody0UscQQO
RRvxbEdaRL1iTVgA0orsDCOMsBaUcKiZ4tlJUd+Z+ifHCVJ5Szl5fsqIIElF8vOk
hy8++T4XqPEZqlDnAIpOxE0eGnByvdkUrFew60nA+A+ivY7GkCFhMz8AP4VHrhFS
UOU2wDuBOsA6ssqkxMmc5Vizyb6CmL2Ho0csPqabvfRYk5VZACc63FbJ2xcdjDZz
CufvfJZ3O5dgSy29fn9XQHsU8qSn0DteSU/9OiHAJmvkqrvB0yT21kIQXUWiqYGk
xDvc/SVpttYqaW2hAgjFG9NGJ/D2dpliYNUjgwmijUVZuI9bkJ68l5CfpOzXYnNJ
e1AFzBeHVCKSn0advmTVdyybslU32g7ytzJQcQP2b8a4GQYEI6DNhTA5HTxWaj//
O+Cm0CkAbW1vNJqSolnU
=lDcA
-----END PGP SIGNATURE-----

From xor at freenetproject.org  Mon Jan 25 17:33:09 2016
From: xor at freenetproject.org (xor at freenetproject.org)
Date: Mon, 25 Jan 2016 18:33:09 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.12.0 release candidate 1 available
In-Reply-To: <20160125150559.GA28847@amethyst.visucore.com>
References: <20160117100808.GA4299@amethyst.visucore.com>
	<2815165.aykQg88K5r@1337h4x0r>
	<20160125150559.GA28847@amethyst.visucore.com>
Message-ID: <20782747.nfdyibNE2U@1337h4x0r>

On Monday, January 25, 2016 04:05:59 PM Wladimir J. van der Laan wrote:
> I don't have time to work on the release notes right now, but if someone
> else wants to contribute that'd be awesome.

I cooked my first pull request to resolve this:
https://github.com/bitcoin/bitcoin/pull/7416

Thanks for all the explanations you folks provided! :)
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 836 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/603d7652/attachment.sig>

From luke at dashjr.org  Tue Jan 26 02:24:16 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 26 Jan 2016 02:24:16 +0000
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
Message-ID: <201601260224.16917.luke@dashjr.org>

This is a bad idea. OP_RETURN attachments are tolerated (not encouraged!) for 
the sake of the network, since the spam cannot be outright stopped. If it 
could be outright stopped, it would not be reasonable to allow OP_RETURN. When 
it comes to the payment protocol, however, changing the current behaviour has 
literally no benefit to the network at all, and the changes proposed herein 
are clearly detrimental since it would both encourage spam, and potentially 
make users unwilling (maybe even unaware) participants in it. For these 
reasons, *I highly advise against publishing or implementing this BIP, even if 
the later mentioned issues are fixed.*

On Tuesday, January 26, 2016 1:02:44 AM Toby Padilla wrote:
> An example might be a merchant that adds the hash of a plain text invoice
> to the checkout transaction. The merchant could construct the
> PaymentRequest with the invoice hash in an OP_RETURN and pass it to the
> customer's wallet. The wallet could then submit the transaction, including
> the invoice hash from the PaymentRequest. The wallet will have encoded a
> proof of purchase to the blockchain without the wallet developer having to
> coordinate with the merchant software or add features beyond this BIP.

Such a "proof" is useless without wallet support. Even if you argue it could 
be implemented later on, it stands to reason that a scammer will simply encode 
garbage if the wallet is not checking the proof-of-purchase upfront. To check 
it, you would also need further protocol extensions which are not included in 
this draft.

> Merchants and Bitcoin application developers benefit from this BIP because
> they can now construct transactions that include OP_RETURN data in a
> keyless environment. Again, prior to this BIP, transactions that used
> OP_RETURN (with zero value) needed to be constructed and executed in the
> same software. By separating the two concerns, this BIP allows merchant
> software to create transactions with OP_RETURN metadata on a server without
> storing public or private Bitcoin keys. This greatly enhances security
> where OP_RETURN applications currently need access to a private key to sign
> transactions.

I don't see how this has any relevance to keys at all...

> ## Specification
> 
> The specification for this BIP is straightforward. BIP70 should be fully
> implemented with two changes:
> 
> 1. Outputs where the script is an OP_RETURN and the value is zero should be
> accepted by the wallet.
> 2. Outputs where the script is an OP_RETURN and the value is greater than
> zero should be rejected.
> 
> This is a change from the BIP70 requirement that all zero value outputs be
> ignored.

This does not appear to be backward nor even forward compatible. Old clients 
will continue to use the previous behaviour and transparently omit any 
commitments. New clients on the other hand will fail to include commitments 
produced by old servers. In other words, it is impossible to produce software 
compatible with both BIP 70 and this draft, and implementing either would 
result in severe consequences.

> As it exists today, BIP70 allows for OP_RETURN data storage at the expense
> of permanently destroyed Bitcoin.

It is better for the spammers to lose burned bitcoins, than have a way to 
avoid them.

Luke

From tobypadilla at gmail.com  Tue Jan 26 01:02:44 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Mon, 25 Jan 2016 17:02:44 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
Message-ID: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>

Hi all,

I'm submitting a new BIP draft for consideration and discussion. I've put a
pull request up on Github that implements this BIP (with discussion from
the Core team):

https://github.com/bitcoin/bitcoin/pull/7376

My original discussion of this issue:

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/011874.html

BIP draft as follows...

--

```
Title: Allow zero value OP_RETURN in Payment Protocol
Author: Toby Padilla <tobypadilla at gmail.com>
```

## Abstract

This BIP alters the Payment Protocol to allow for zero value OP_RETURN
outputs in serialized PaymentRequests.

## Motivation

The Payment Protocol (defined in BIP70) gives merchants a way to build
sophisticated transactions by serializing one or more outputs in the form
of a PaymentRequest. The PaymentRequest is then served over http/https to a
customer's wallet where the serialized transaction can be executed.

While the Payment Protocol allows for any valid script in its outputs, it
also ignores outputs with zero value. This means BIP70 implementations can
encode an OP_RETURN script but must provide a greater than dust value for
that output. The end result is a successful PaymentRequest transaction with
an OP_RETURN but the value assigned to that output is lost forever.

This BIP allows for zero value OP_RETURN outputs in serialized
PaymentRequests. The change means that OP_RETURN scripts will work as they
were originally intended from within PaymentRequests without permanently
destroying Bitcoin value. Zero value non-OP_RETURN scripts should continue
to be ignored and positive value OP_RETURN outputs should now be rejected.

In addition to fixing the issue of destroyed value, this change opens up
new use cases that were previously impossible.

While storing data on the blockchain is controversial, when used
responsibly OP_RETURN provides a powerful mechanism for attaching metadata
to a transaction. This BIP effectively decouples the creation of
transactions containing OP_RETURN data from the execution of those
transactions. The result are positive benefits for both merchants and
wallets/customers.

By supporting this BIP, wallets can participate in current and future,
unforeseen use cases that benefit from metadata stored in OP_RETURN. Until
now OP_RETURN transactions have typically been created and submitted by
custom software. If a wallet can process a PaymentRequest with OP_RETURN
data as proposed by this BIP, it will support potentially sophisticated
Bitcoin applications without the wallet developer having to have prior
knowledge of that application.

An example might be a merchant that adds the hash of a plain text invoice
to the checkout transaction. The merchant could construct the
PaymentRequest with the invoice hash in an OP_RETURN and pass it to the
customer's wallet. The wallet could then submit the transaction, including
the invoice hash from the PaymentRequest. The wallet will have encoded a
proof of purchase to the blockchain without the wallet developer having to
coordinate with the merchant software or add features beyond this BIP.

Merchants and Bitcoin application developers benefit from this BIP because
they can now construct transactions that include OP_RETURN data in a
keyless environment. Again, prior to this BIP, transactions that used
OP_RETURN (with zero value) needed to be constructed and executed in the
same software. By separating the two concerns, this BIP allows merchant
software to create transactions with OP_RETURN metadata on a server without
storing public or private Bitcoin keys. This greatly enhances security
where OP_RETURN applications currently need access to a private key to sign
transactions.

## Specification

The specification for this BIP is straightforward. BIP70 should be fully
implemented with two changes:

1. Outputs where the script is an OP_RETURN and the value is zero should be
accepted by the wallet.
2. Outputs where the script is an OP_RETURN and the value is greater than
zero should be rejected.

This is a change from the BIP70 requirement that all zero value outputs be
ignored.

## Rationale

As with the discussion around vanilla OP_RETURN, the practice of storing
data on the blockchain is controversial. While blockchain and network bloat
is an undeniable issue, the benefits that come from attaching metadata to
transactions has proven to be too powerful to dismiss entirely. In the
absence of OP_RETURN support the Bitcoin ecosystem has seen alternative,
less elegant and more wasteful methods employed for Blockchain data storage.

As it exists today, BIP70 allows for OP_RETURN data storage at the expense
of permanently destroyed Bitcoin. Even fully removing support for OP_RETURN
values in the Payment Protocol would still leave the door open to
suboptimal data encoding via burning a larger than dust value to an output
with a false address designed to encode data.

This BIP offers all of the same benefits that come from the OP_RETURN
compromise. Mainly that OP_RETURN scripts are provably unspendable and thus
can be pruned from the UTXO pool. Without supporting this BIP, wallets that
support BIP70 will allow for wasteful data storage.

## Compatibility

While not in widespread use, existing BIP70 PaymentRequest outputs that
have a greater than zero value with an OP_RETURN script (burning Bitcoin)
will need to have their values changed to zero or they will be rejected by
wallets implementing this BIP.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/e25484bd/attachment.html>

From tobypadilla at gmail.com  Tue Jan 26 02:54:16 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Mon, 25 Jan 2016 18:54:16 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <201601260224.16917.luke@dashjr.org>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260224.16917.luke@dashjr.org>
Message-ID: <CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>

It looks like my draft hasn't been approved by the mailing list so if
anyone would like to read it it's also on Gist:

https://gist.github.com/toby/9e71811d387923a71a53

Luke - As stated in the Github thread, I totally understand where you're
coming from but the fact is people *will* encode data on the blockchain
using worse methods. For all of the reasons that OP_RETURN was a good idea
in the first place, it's a good idea to support it in PaymentRequests.

As for keyless - there's no way (that I know of) to construct a transaction
with a zero value OP_RETURN in an environment without keys since the
Payment Protocol is what defines the method for getting a transaction from
a server to a wallet. You can make a custom transaction and execute it in
the same application but without Payments there's no way to move
transactions between two applications. You need to build the transaction
where you execute it and thus need a key.



On Mon, Jan 25, 2016 at 6:24 PM, Luke Dashjr <luke at dashjr.org> wrote:

> This is a bad idea. OP_RETURN attachments are tolerated (not encouraged!)
> for
> the sake of the network, since the spam cannot be outright stopped. If it
> could be outright stopped, it would not be reasonable to allow OP_RETURN.
> When
> it comes to the payment protocol, however, changing the current behaviour
> has
> literally no benefit to the network at all, and the changes proposed herein
> are clearly detrimental since it would both encourage spam, and potentially
> make users unwilling (maybe even unaware) participants in it. For these
> reasons, *I highly advise against publishing or implementing this BIP,
> even if
> the later mentioned issues are fixed.*
>
> On Tuesday, January 26, 2016 1:02:44 AM Toby Padilla wrote:
> > An example might be a merchant that adds the hash of a plain text invoice
> > to the checkout transaction. The merchant could construct the
> > PaymentRequest with the invoice hash in an OP_RETURN and pass it to the
> > customer's wallet. The wallet could then submit the transaction,
> including
> > the invoice hash from the PaymentRequest. The wallet will have encoded a
> > proof of purchase to the blockchain without the wallet developer having
> to
> > coordinate with the merchant software or add features beyond this BIP.
>
> Such a "proof" is useless without wallet support. Even if you argue it
> could
> be implemented later on, it stands to reason that a scammer will simply
> encode
> garbage if the wallet is not checking the proof-of-purchase upfront. To
> check
> it, you would also need further protocol extensions which are not included
> in
> this draft.
>
> > Merchants and Bitcoin application developers benefit from this BIP
> because
> > they can now construct transactions that include OP_RETURN data in a
> > keyless environment. Again, prior to this BIP, transactions that used
> > OP_RETURN (with zero value) needed to be constructed and executed in the
> > same software. By separating the two concerns, this BIP allows merchant
> > software to create transactions with OP_RETURN metadata on a server
> without
> > storing public or private Bitcoin keys. This greatly enhances security
> > where OP_RETURN applications currently need access to a private key to
> sign
> > transactions.
>
> I don't see how this has any relevance to keys at all...
>
> > ## Specification
> >
> > The specification for this BIP is straightforward. BIP70 should be fully
> > implemented with two changes:
> >
> > 1. Outputs where the script is an OP_RETURN and the value is zero should
> be
> > accepted by the wallet.
> > 2. Outputs where the script is an OP_RETURN and the value is greater than
> > zero should be rejected.
> >
> > This is a change from the BIP70 requirement that all zero value outputs
> be
> > ignored.
>
> This does not appear to be backward nor even forward compatible. Old
> clients
> will continue to use the previous behaviour and transparently omit any
> commitments. New clients on the other hand will fail to include commitments
> produced by old servers. In other words, it is impossible to produce
> software
> compatible with both BIP 70 and this draft, and implementing either would
> result in severe consequences.
>
> > As it exists today, BIP70 allows for OP_RETURN data storage at the
> expense
> > of permanently destroyed Bitcoin.
>
> It is better for the spammers to lose burned bitcoins, than have a way to
> avoid them.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/3d421af4/attachment-0001.html>

From luke at dashjr.org  Tue Jan 26 02:56:54 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 26 Jan 2016 02:56:54 +0000
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260224.16917.luke@dashjr.org>
	<CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>
Message-ID: <201601260256.55378.luke@dashjr.org>

On Tuesday, January 26, 2016 2:54:16 AM Toby Padilla wrote:
> Luke - As stated in the Github thread, I totally understand where you're
> coming from but the fact is people *will* encode data on the blockchain
> using worse methods. For all of the reasons that OP_RETURN was a good idea
> in the first place, it's a good idea to support it in PaymentRequests.

As I explained, none of those reasons apply to PaymentRequests.

> As for keyless - there's no way (that I know of) to construct a transaction
> with a zero value OP_RETURN in an environment without keys since the
> Payment Protocol is what defines the method for getting a transaction from
> a server to a wallet. You can make a custom transaction and execute it in
> the same application but without Payments there's no way to move
> transactions between two applications. You need to build the transaction
> where you execute it and thus need a key.

I have no idea what you are trying to say here.

Luke

From luke at dashjr.org  Tue Jan 26 03:04:33 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 26 Jan 2016 03:04:33 +0000
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <CAGcHOzwpcCdgJ1VcBrnZ+D8dfZFBJYLs_A9Z4Nz-FJokdkcuyQ@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260256.55378.luke@dashjr.org>
	<CAGcHOzwpcCdgJ1VcBrnZ+D8dfZFBJYLs_A9Z4Nz-FJokdkcuyQ@mail.gmail.com>
Message-ID: <201601260304.34013.luke@dashjr.org>

On Tuesday, January 26, 2016 3:01:13 AM Toby Padilla wrote:
> > As I explained, none of those reasons apply to PaymentRequests.
> 
> As they exist today PaymentRequests allow for essentially the same types of
> transactions as non-PaymentRequest based transactions with the limitation
> that OP_RETURN values must be greater. In that sense they're basically a
> pre-OP_RETURN environment. OP_RETURN serves a purpose and it can't be used
> with PaymentRequest transactions.

OP_RETURN can be used, but you need to burn coins. I don't see any benefit to 
changing that. It is better that coins are burned.

> > I have no idea what you are trying to say here.
> 
> I think if you think through how you would create an OP_RETURN transaction
> today without this BIP you'll see you need a key at some point if you want
> a zero value.

You *always* need a key, to redeem inputs... regardless of values.

Luke

From luke at dashjr.org  Tue Jan 26 03:12:24 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 26 Jan 2016 03:12:24 +0000
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <CAGcHOzy9nSTLKjgiV3mDcawJaL-MiTAscSO4Ok0Lz9ysWBoKNg@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260304.34013.luke@dashjr.org>
	<CAGcHOzy9nSTLKjgiV3mDcawJaL-MiTAscSO4Ok0Lz9ysWBoKNg@mail.gmail.com>
Message-ID: <201601260312.25248.luke@dashjr.org>

On Tuesday, January 26, 2016 3:07:40 AM Toby Padilla wrote:
> > I don't see any benefit to changing that. It is better that coins are
> > burned.
> 
> I think this is our fundamental disagreement. People will burn coins to
> encode data, why allow this when there's a better alternative?

My point is that there isn't a better alternative. The coins being burned, is 
strictly better than it being gratis.

> > You *always* need a key, to redeem inputs... regardless of values.
> 
> Correct, but with BIP70 that key is in the user's wallet and you can
> construct transactions on another machine (thus not needing a key during
> construction). Right now there's no way to do the transaction construction
> on another machine with zero value OP_RETURNs.

This is also a good thing. Spam should not be made easier or cheaper.

Luke

From tobypadilla at gmail.com  Tue Jan 26 03:01:13 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Mon, 25 Jan 2016 19:01:13 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <201601260256.55378.luke@dashjr.org>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260224.16917.luke@dashjr.org>
	<CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>
	<201601260256.55378.luke@dashjr.org>
Message-ID: <CAGcHOzwpcCdgJ1VcBrnZ+D8dfZFBJYLs_A9Z4Nz-FJokdkcuyQ@mail.gmail.com>

> As I explained, none of those reasons apply to PaymentRequests.

As they exist today PaymentRequests allow for essentially the same types of
transactions as non-PaymentRequest based transactions with the limitation
that OP_RETURN values must be greater. In that sense they're basically a
pre-OP_RETURN environment. OP_RETURN serves a purpose and it can't be used
with PaymentRequest transactions.

> I have no idea what you are trying to say here.

I think if you think through how you would create an OP_RETURN transaction
today without this BIP you'll see you need a key at some point if you want
a zero value.

On Mon, Jan 25, 2016 at 6:56 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Tuesday, January 26, 2016 2:54:16 AM Toby Padilla wrote:
> > Luke - As stated in the Github thread, I totally understand where you're
> > coming from but the fact is people *will* encode data on the blockchain
> > using worse methods. For all of the reasons that OP_RETURN was a good
> idea
> > in the first place, it's a good idea to support it in PaymentRequests.
>
> As I explained, none of those reasons apply to PaymentRequests.
>
> > As for keyless - there's no way (that I know of) to construct a
> transaction
> > with a zero value OP_RETURN in an environment without keys since the
> > Payment Protocol is what defines the method for getting a transaction
> from
> > a server to a wallet. You can make a custom transaction and execute it in
> > the same application but without Payments there's no way to move
> > transactions between two applications. You need to build the transaction
> > where you execute it and thus need a key.
>
> I have no idea what you are trying to say here.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/cd6c0b93/attachment.html>

From tobypadilla at gmail.com  Tue Jan 26 03:07:40 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Mon, 25 Jan 2016 19:07:40 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <201601260304.34013.luke@dashjr.org>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260256.55378.luke@dashjr.org>
	<CAGcHOzwpcCdgJ1VcBrnZ+D8dfZFBJYLs_A9Z4Nz-FJokdkcuyQ@mail.gmail.com>
	<201601260304.34013.luke@dashjr.org>
Message-ID: <CAGcHOzy9nSTLKjgiV3mDcawJaL-MiTAscSO4Ok0Lz9ysWBoKNg@mail.gmail.com>

> I don't see any benefit to
changing that. It is better that coins are burned.

I think this is our fundamental disagreement. People will burn coins to
encode data, why allow this when there's a better alternative?

> You *always* need a key, to redeem inputs... regardless of values.

Correct, but with BIP70 that key is in the user's wallet and you can
construct transactions on another machine (thus not needing a key during
construction). Right now there's no way to do the transaction construction
on another machine with zero value OP_RETURNs.

On Mon, Jan 25, 2016 at 7:04 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Tuesday, January 26, 2016 3:01:13 AM Toby Padilla wrote:
> > > As I explained, none of those reasons apply to PaymentRequests.
> >
> > As they exist today PaymentRequests allow for essentially the same types
> of
> > transactions as non-PaymentRequest based transactions with the limitation
> > that OP_RETURN values must be greater. In that sense they're basically a
> > pre-OP_RETURN environment. OP_RETURN serves a purpose and it can't be
> used
> > with PaymentRequest transactions.
>
> OP_RETURN can be used, but you need to burn coins. I don't see any benefit
> to
> changing that. It is better that coins are burned.
>
> > > I have no idea what you are trying to say here.
> >
> > I think if you think through how you would create an OP_RETURN
> transaction
> > today without this BIP you'll see you need a key at some point if you
> want
> > a zero value.
>
> You *always* need a key, to redeem inputs... regardless of values.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/b17c123c/attachment.html>

From luke at dashjr.org  Tue Jan 26 03:23:13 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 26 Jan 2016 03:23:13 +0000
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <CAGcHOzw88za1m6uJY9MBO2X=3psNk667FyBOHz2XCPO3ABbcRw@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260312.25248.luke@dashjr.org>
	<CAGcHOzw88za1m6uJY9MBO2X=3psNk667FyBOHz2XCPO3ABbcRw@mail.gmail.com>
Message-ID: <201601260323.14993.luke@dashjr.org>

On Tuesday, January 26, 2016 3:17:12 AM Toby Padilla wrote:
> I don't think every application of OP_RETURN could be classified as "spam".

Perhaps not, but in this context I cannot think of any non-spam use cases.
Use cases should come before changes to support them.

> I also don't think burning the value is going to dissuade anyone from going
> down that route. I don't think lost value is better for anyone.

Lost value is better because it has a cost to the spammer, and deflates the 
rest of the bitcoins.

Luke

From tobypadilla at gmail.com  Tue Jan 26 03:30:38 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Mon, 25 Jan 2016 19:30:38 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <201601260323.14993.luke@dashjr.org>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260312.25248.luke@dashjr.org>
	<CAGcHOzw88za1m6uJY9MBO2X=3psNk667FyBOHz2XCPO3ABbcRw@mail.gmail.com>
	<201601260323.14993.luke@dashjr.org>
Message-ID: <CAGcHOzwec-eoG-uZzXY2pb=VzQ98EvnijvxrcsrFYgKi2HQ_uw@mail.gmail.com>

There are already valid use cases for OP_RETURN, it only makes sense to
fully support the feature. The only reason it's not supported now is
because the Payments protocol came before OP_RETURN.

I give one example use case in the BIP. I agree that special wallet support
would make the feature even better, but if someone tried to use Core the
transaction would at least not be rejected.

I've also been exploring this area with key.run (
https://git.playgrub.com/toby/keyrun) and want the functionality for voting
based on aggregate OP_RETURN value. *Not* to store data on the blockchain,
but to associate content pointers with transactions.

I think that since OP_RETURN has already been approved and supported it
doesn't make much sense for me to have to re-defend it from scratch here.

On Mon, Jan 25, 2016 at 7:23 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Tuesday, January 26, 2016 3:17:12 AM Toby Padilla wrote:
> > I don't think every application of OP_RETURN could be classified as
> "spam".
>
> Perhaps not, but in this context I cannot think of any non-spam use cases.
> Use cases should come before changes to support them.
>
> > I also don't think burning the value is going to dissuade anyone from
> going
> > down that route. I don't think lost value is better for anyone.
>
> Lost value is better because it has a cost to the spammer, and deflates the
> rest of the bitcoins.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/a1a5ce6c/attachment.html>

From andreas at schildbach.de  Tue Jan 26 14:37:15 2016
From: andreas at schildbach.de (Andreas Schildbach)
Date: Tue, 26 Jan 2016 15:37:15 +0100
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260224.16917.luke@dashjr.org>
	<CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>
Message-ID: <n880a6$i5v$1@ger.gmane.org>

Discussion about reasoning of OP_RETURN aside, I think your
specification needs to be more precise/less ambiguous.

Here is what BIP70 currently says about PaymentDetails.outputs:

"one or more outputs where Bitcoins are to be sent. If the sum of
outputs.amount is zero, the customer will be asked how much to pay, and
the bitcoin client may choose any or all of the Outputs (if there are
more than one) for payment. If the sum of outputs.amount is non-zero,
then the customer will be asked to pay the sum, and the payment shall be
split among the Outputs with non-zero amounts (if there are more than
one; Outputs with zero amounts shall be ignored)."

As you can see, zero outputs are not ignored at all. They are used as an
indication to allow the user to set an amount. So if you'd come up with
one zero-amount OP_RETURN output, it would pop up an amount dialog.
Certainly not what you want, right?


On 01/26/2016 03:54 AM, Toby Padilla via bitcoin-dev wrote:
> It looks like my draft hasn't been approved by the mailing list so if
> anyone would like to read it it's also on Gist:
> 
> https://gist.github.com/toby/9e71811d387923a71a53
> 
> Luke - As stated in the Github thread, I totally understand where you're
> coming from but the fact is people *will* encode data on the blockchain
> using worse methods. For all of the reasons that OP_RETURN was a good
> idea in the first place, it's a good idea to support it in PaymentRequests.
> 
> As for keyless - there's no way (that I know of) to construct a
> transaction with a zero value OP_RETURN in an environment without keys
> since the Payment Protocol is what defines the method for getting a
> transaction from a server to a wallet. You can make a custom transaction
> and execute it in the same application but without Payments there's no
> way to move transactions between two applications. You need to build the
> transaction where you execute it and thus need a key.
> 
> 
> 
> On Mon, Jan 25, 2016 at 6:24 PM, Luke Dashjr <luke at dashjr.org
> <mailto:luke at dashjr.org>> wrote:
> 
>     This is a bad idea. OP_RETURN attachments are tolerated (not
>     encouraged!) for
>     the sake of the network, since the spam cannot be outright stopped.
>     If it
>     could be outright stopped, it would not be reasonable to allow
>     OP_RETURN. When
>     it comes to the payment protocol, however, changing the current
>     behaviour has
>     literally no benefit to the network at all, and the changes proposed
>     herein
>     are clearly detrimental since it would both encourage spam, and
>     potentially
>     make users unwilling (maybe even unaware) participants in it. For these
>     reasons, *I highly advise against publishing or implementing this
>     BIP, even if
>     the later mentioned issues are fixed.*
> 
>     On Tuesday, January 26, 2016 1:02:44 AM Toby Padilla wrote:
>     > An example might be a merchant that adds the hash of a plain text invoice
>     > to the checkout transaction. The merchant could construct the
>     > PaymentRequest with the invoice hash in an OP_RETURN and pass it to the
>     > customer's wallet. The wallet could then submit the transaction, including
>     > the invoice hash from the PaymentRequest. The wallet will have encoded a
>     > proof of purchase to the blockchain without the wallet developer having to
>     > coordinate with the merchant software or add features beyond this BIP.
> 
>     Such a "proof" is useless without wallet support. Even if you argue
>     it could
>     be implemented later on, it stands to reason that a scammer will
>     simply encode
>     garbage if the wallet is not checking the proof-of-purchase upfront.
>     To check
>     it, you would also need further protocol extensions which are not
>     included in
>     this draft.
> 
>     > Merchants and Bitcoin application developers benefit from this BIP because
>     > they can now construct transactions that include OP_RETURN data in a
>     > keyless environment. Again, prior to this BIP, transactions that used
>     > OP_RETURN (with zero value) needed to be constructed and executed in the
>     > same software. By separating the two concerns, this BIP allows merchant
>     > software to create transactions with OP_RETURN metadata on a server without
>     > storing public or private Bitcoin keys. This greatly enhances security
>     > where OP_RETURN applications currently need access to a private key to sign
>     > transactions.
> 
>     I don't see how this has any relevance to keys at all...
> 
>     > ## Specification
>     >
>     > The specification for this BIP is straightforward. BIP70 should be fully
>     > implemented with two changes:
>     >
>     > 1. Outputs where the script is an OP_RETURN and the value is zero should be
>     > accepted by the wallet.
>     > 2. Outputs where the script is an OP_RETURN and the value is greater than
>     > zero should be rejected.
>     >
>     > This is a change from the BIP70 requirement that all zero value outputs be
>     > ignored.
> 
>     This does not appear to be backward nor even forward compatible. Old
>     clients
>     will continue to use the previous behaviour and transparently omit any
>     commitments. New clients on the other hand will fail to include
>     commitments
>     produced by old servers. In other words, it is impossible to produce
>     software
>     compatible with both BIP 70 and this draft, and implementing either
>     would
>     result in severe consequences.
> 
>     > As it exists today, BIP70 allows for OP_RETURN data storage at the expense
>     > of permanently destroyed Bitcoin.
> 
>     It is better for the spammers to lose burned bitcoins, than have a
>     way to
>     avoid them.
> 
>     Luke
> 
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 



From thomas.kerin at gmail.com  Tue Jan 26 16:19:18 2016
From: thomas.kerin at gmail.com (Thomas Kerin)
Date: Tue, 26 Jan 2016 16:19:18 +0000
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
 Protocol
In-Reply-To: <CAGcHOzwec-eoG-uZzXY2pb=VzQ98EvnijvxrcsrFYgKi2HQ_uw@mail.gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260312.25248.luke@dashjr.org>
	<CAGcHOzw88za1m6uJY9MBO2X=3psNk667FyBOHz2XCPO3ABbcRw@mail.gmail.com>
	<201601260323.14993.luke@dashjr.org>
	<CAGcHOzwec-eoG-uZzXY2pb=VzQ98EvnijvxrcsrFYgKi2HQ_uw@mail.gmail.com>
Message-ID: <56A79C86.1030902@gmail.com>


On 26/01/16 03:30, Toby Padilla via bitcoin-dev wrote:
> There are already valid use cases for OP_RETURN, it only makes sense
> to fully support the feature. The only reason it's not supported now
> is because the Payments protocol came before OP_RETURN.
>
You keep saying OP_RETURN is new, but it has been there from day one.
It's purpose is causing script execution to end if encountered.

Since then, we have tolerated putting pushdata's after it, and even
raised the limit for the size of this data. It still doesn't mean every
proposal has to be rewritten to cater for a new allowance we give
OP_RETURN.


> I've also been exploring this area with key.run
> (https://git.playgrub.com/toby/keyrun) and want the functionality for
> voting based on aggregate OP_RETURN value. *Not* to store data on the
> blockchain, but to associate content pointers with transactions.
>
> I think that since OP_RETURN has already been approved and supported
> it doesn't make much sense for me to have to re-defend it from scratch
> here.

I'd generally agree with Luke. Removing the cost of this hurts bitcoin,
and ironically, your application to a certain degree. Just because you
can do a thing one way, it doesn't mean you should. Especially if your
applications success depends on people spamming OP_RETURN hashes of
every torrent they like.

From tobypadilla at gmail.com  Tue Jan 26 17:41:01 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Tue, 26 Jan 2016 09:41:01 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <n880a6$i5v$1@ger.gmane.org>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260224.16917.luke@dashjr.org>
	<CAGcHOzziBsF6DhX=TrgDJdYiOLHT-zwwX3FAUUkvfi1_4OmPKw@mail.gmail.com>
	<n880a6$i5v$1@ger.gmane.org>
Message-ID: <CAGcHOzyQ4d_oPey=7bMcm8mA4QWAcBrkCu3CY=_BVjrbbd03Sw@mail.gmail.com>

The wording is a little strange and I think it *should* work as you state,
but Bitcoin Core will actually reject any output that has zero value (even
a single OP_RETURN output -- I just tested again to make sure).

Here's the blocking code:

https://github.com/bitcoin/bitcoin/blob/master/src/qt/paymentserver.cpp#L584

I agree that this should be made more clear in my BIP though, I'll clean up
the language.

On Tue, Jan 26, 2016 at 6:37 AM, Andreas Schildbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Discussion about reasoning of OP_RETURN aside, I think your
> specification needs to be more precise/less ambiguous.
>
> Here is what BIP70 currently says about PaymentDetails.outputs:
>
> "one or more outputs where Bitcoins are to be sent. If the sum of
> outputs.amount is zero, the customer will be asked how much to pay, and
> the bitcoin client may choose any or all of the Outputs (if there are
> more than one) for payment. If the sum of outputs.amount is non-zero,
> then the customer will be asked to pay the sum, and the payment shall be
> split among the Outputs with non-zero amounts (if there are more than
> one; Outputs with zero amounts shall be ignored)."
>
> As you can see, zero outputs are not ignored at all. They are used as an
> indication to allow the user to set an amount. So if you'd come up with
> one zero-amount OP_RETURN output, it would pop up an amount dialog.
> Certainly not what you want, right?
>
>
> On 01/26/2016 03:54 AM, Toby Padilla via bitcoin-dev wrote:
> > It looks like my draft hasn't been approved by the mailing list so if
> > anyone would like to read it it's also on Gist:
> >
> > https://gist.github.com/toby/9e71811d387923a71a53
> >
> > Luke - As stated in the Github thread, I totally understand where you're
> > coming from but the fact is people *will* encode data on the blockchain
> > using worse methods. For all of the reasons that OP_RETURN was a good
> > idea in the first place, it's a good idea to support it in
> PaymentRequests.
> >
> > As for keyless - there's no way (that I know of) to construct a
> > transaction with a zero value OP_RETURN in an environment without keys
> > since the Payment Protocol is what defines the method for getting a
> > transaction from a server to a wallet. You can make a custom transaction
> > and execute it in the same application but without Payments there's no
> > way to move transactions between two applications. You need to build the
> > transaction where you execute it and thus need a key.
> >
> >
> >
> > On Mon, Jan 25, 2016 at 6:24 PM, Luke Dashjr <luke at dashjr.org
> > <mailto:luke at dashjr.org>> wrote:
> >
> >     This is a bad idea. OP_RETURN attachments are tolerated (not
> >     encouraged!) for
> >     the sake of the network, since the spam cannot be outright stopped.
> >     If it
> >     could be outright stopped, it would not be reasonable to allow
> >     OP_RETURN. When
> >     it comes to the payment protocol, however, changing the current
> >     behaviour has
> >     literally no benefit to the network at all, and the changes proposed
> >     herein
> >     are clearly detrimental since it would both encourage spam, and
> >     potentially
> >     make users unwilling (maybe even unaware) participants in it. For
> these
> >     reasons, *I highly advise against publishing or implementing this
> >     BIP, even if
> >     the later mentioned issues are fixed.*
> >
> >     On Tuesday, January 26, 2016 1:02:44 AM Toby Padilla wrote:
> >     > An example might be a merchant that adds the hash of a plain text
> invoice
> >     > to the checkout transaction. The merchant could construct the
> >     > PaymentRequest with the invoice hash in an OP_RETURN and pass it
> to the
> >     > customer's wallet. The wallet could then submit the transaction,
> including
> >     > the invoice hash from the PaymentRequest. The wallet will have
> encoded a
> >     > proof of purchase to the blockchain without the wallet developer
> having to
> >     > coordinate with the merchant software or add features beyond this
> BIP.
> >
> >     Such a "proof" is useless without wallet support. Even if you argue
> >     it could
> >     be implemented later on, it stands to reason that a scammer will
> >     simply encode
> >     garbage if the wallet is not checking the proof-of-purchase upfront.
> >     To check
> >     it, you would also need further protocol extensions which are not
> >     included in
> >     this draft.
> >
> >     > Merchants and Bitcoin application developers benefit from this BIP
> because
> >     > they can now construct transactions that include OP_RETURN data in
> a
> >     > keyless environment. Again, prior to this BIP, transactions that
> used
> >     > OP_RETURN (with zero value) needed to be constructed and executed
> in the
> >     > same software. By separating the two concerns, this BIP allows
> merchant
> >     > software to create transactions with OP_RETURN metadata on a
> server without
> >     > storing public or private Bitcoin keys. This greatly enhances
> security
> >     > where OP_RETURN applications currently need access to a private
> key to sign
> >     > transactions.
> >
> >     I don't see how this has any relevance to keys at all...
> >
> >     > ## Specification
> >     >
> >     > The specification for this BIP is straightforward. BIP70 should be
> fully
> >     > implemented with two changes:
> >     >
> >     > 1. Outputs where the script is an OP_RETURN and the value is zero
> should be
> >     > accepted by the wallet.
> >     > 2. Outputs where the script is an OP_RETURN and the value is
> greater than
> >     > zero should be rejected.
> >     >
> >     > This is a change from the BIP70 requirement that all zero value
> outputs be
> >     > ignored.
> >
> >     This does not appear to be backward nor even forward compatible. Old
> >     clients
> >     will continue to use the previous behaviour and transparently omit
> any
> >     commitments. New clients on the other hand will fail to include
> >     commitments
> >     produced by old servers. In other words, it is impossible to produce
> >     software
> >     compatible with both BIP 70 and this draft, and implementing either
> >     would
> >     result in severe consequences.
> >
> >     > As it exists today, BIP70 allows for OP_RETURN data storage at the
> expense
> >     > of permanently destroyed Bitcoin.
> >
> >     It is better for the spammers to lose burned bitcoins, than have a
> >     way to
> >     avoid them.
> >
> >     Luke
> >
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160126/ccf44462/attachment-0001.html>

From tobypadilla at gmail.com  Tue Jan 26 03:17:12 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Mon, 25 Jan 2016 19:17:12 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <201601260312.25248.luke@dashjr.org>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260304.34013.luke@dashjr.org>
	<CAGcHOzy9nSTLKjgiV3mDcawJaL-MiTAscSO4Ok0Lz9ysWBoKNg@mail.gmail.com>
	<201601260312.25248.luke@dashjr.org>
Message-ID: <CAGcHOzw88za1m6uJY9MBO2X=3psNk667FyBOHz2XCPO3ABbcRw@mail.gmail.com>

I don't think every application of OP_RETURN could be classified as "spam".
I also don't think burning the value is going to dissuade anyone from going
down that route. I don't think lost value is better for anyone.

On Mon, Jan 25, 2016 at 7:12 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Tuesday, January 26, 2016 3:07:40 AM Toby Padilla wrote:
> > > I don't see any benefit to changing that. It is better that coins are
> > > burned.
> >
> > I think this is our fundamental disagreement. People will burn coins to
> > encode data, why allow this when there's a better alternative?
>
> My point is that there isn't a better alternative. The coins being burned,
> is
> strictly better than it being gratis.
>
> > > You *always* need a key, to redeem inputs... regardless of values.
> >
> > Correct, but with BIP70 that key is in the user's wallet and you can
> > construct transactions on another machine (thus not needing a key during
> > construction). Right now there's no way to do the transaction
> construction
> > on another machine with zero value OP_RETURNs.
>
> This is also a good thing. Spam should not be made easier or cheaper.
>
> Luke
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160125/69e50f07/attachment.html>

From tobypadilla at gmail.com  Tue Jan 26 17:44:48 2016
From: tobypadilla at gmail.com (Toby Padilla)
Date: Tue, 26 Jan 2016 09:44:48 -0800
Subject: [bitcoin-dev] [BIP Draft] Allow zero value OP_RETURN in Payment
	Protocol
In-Reply-To: <56A79C86.1030902@gmail.com>
References: <CAGcHOzzde_T3xJwJL2Ehyw7U1FgxEEBJR30VBLdSZMj=W49hSg@mail.gmail.com>
	<201601260312.25248.luke@dashjr.org>
	<CAGcHOzw88za1m6uJY9MBO2X=3psNk667FyBOHz2XCPO3ABbcRw@mail.gmail.com>
	<201601260323.14993.luke@dashjr.org>
	<CAGcHOzwec-eoG-uZzXY2pb=VzQ98EvnijvxrcsrFYgKi2HQ_uw@mail.gmail.com>
	<56A79C86.1030902@gmail.com>
Message-ID: <CAGcHOzybd3fgmdZwdMjq36O4-dXUMcdpdV0+jovTSiAtzFdGUg@mail.gmail.com>

OP_RETURN was not part of isStandard? from day one. Once it was supported
by Core it became necessary to actually support it, not try to support it
in one part of the software and not in others. The whole reason it was
supported is because without it people will use more heinous methods to
encode data on the blockchain. There's no way to stop people from doing
that, so this compromise seemed best for everyone.

I think we should actually define "spam". To me a valid transaction someone
willing pays for is never spam. Also PaymentRequests would be a very
inefficient way to spam. It would be much easier to write a script to
automatically create and submit transactions yourself. With PaymentRequests
 customers have to initiate the transaction and submit/pay for it one by
one.

What is actually the worst case scenario that those opposed to this are
concerned about? That this takes off like wild fire and all of the sudden
millions of people are using PaymentRequests and creating small
transactions? That seems like a win for Bitcoin. It will help spread
support for the Payment protocol and IF it becomes a problem it's because
so many people are using it. In which case there's a very valid use case
for Bitcoin that people are obviously excited about.

I really don't like the idea of policing other people's use of the
protocol. If a transaction pays its fee and has a greater than dust value,
it makes no sense to object to it.

On Tue, Jan 26, 2016 at 8:19 AM, Thomas Kerin via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> On 26/01/16 03:30, Toby Padilla via bitcoin-dev wrote:
> > There are already valid use cases for OP_RETURN, it only makes sense
> > to fully support the feature. The only reason it's not supported now
> > is because the Payments protocol came before OP_RETURN.
> >
> You keep saying OP_RETURN is new, but it has been there from day one.
> It's purpose is causing script execution to end if encountered.
>
> Since then, we have tolerated putting pushdata's after it, and even
> raised the limit for the size of this data. It still doesn't mean every
> proposal has to be rewritten to cater for a new allowance we give
> OP_RETURN.
>
>
> > I've also been exploring this area with key.run
> > (https://git.playgrub.com/toby/keyrun) and want the functionality for
> > voting based on aggregate OP_RETURN value. *Not* to store data on the
> > blockchain, but to associate content pointers with transactions.
> >
> > I think that since OP_RETURN has already been approved and supported
> > it doesn't make much sense for me to have to re-defend it from scratch
> > here.
>
> I'd generally agree with Luke. Removing the cost of this hurts bitcoin,
> and ironically, your application to a certain degree. Just because you
> can do a thing one way, it doesn't mean you should. Especially if your
> applications success depends on people spamming OP_RETURN hashes of
> every torrent they like.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160126/4a59a363/attachment.html>

From luzius.meisser at gmail.com  Tue Jan 26 17:42:25 2016
From: luzius.meisser at gmail.com (Luzius Meisser)
Date: Tue, 26 Jan 2016 18:42:25 +0100
Subject: [bitcoin-dev] Fee smoothing
Message-ID: <CAMuv0Z2gjNKc52UFV2n3H1ckt30chS7=fEUwO8OpfU1Vg7Ayzw@mail.gmail.com>

This post serves to convince you of the economic benefits of smoothing
the payout of fees across blocks. It incentivizes decentralization and
supports the establishment of a fee market.

Idea: currently, the total amount of fees collected in a block is paid
out in full to whoever mined that block. I propose to only pay out,
say, 10% of the collected fees, and to add the remaining 90% to the
collected fees of the next block. Thus, the payout to the miner
constitutes a rolling average of collected fees from the current and
past blocks. This reduces the marginal benefit of including an
additional transaction into a block by an order of magnitude and thus
aligns the incentives of individual miners better with those of the
whole network. As a side-effect, the disadvantage of mining with a
slow connection is reduced.

Example: currently, given a transaction with a fee of 1000 Satoshis
and global processing cost per transaction of 5000 Satoshis, an
individual miner would still include the transaction if it costs him
500 Satoshis to do so, as the remaining burden of 4500 Satoshis is
carried by others (a classic externality). However, with fee
smoothing, the immediate benefit of including that particular
transaction is reduced to 100 Satoshis, aligning the economic
incentives of the miner better with the whole network and leading the
miner to skip it. Generally, the fraction that is paid out immediately
(here 10%) can be used to adjust the incentive, but not arbitrarily.

Benefits:
1. The disadvantage of mining with a slow connection is reduced by an
order of magnitude. If it takes 30 seconds to download the latest
block, a miner loses 5% of the potential income from fees as he does
not know yet which transactions to include in the next block. With fee
smoothing, that loss is reduced to 0.5% as he would still earn 90% of
the average fees per block by mining an empty one based on the latest
header.
2. This is a step towards a free fee market. In an ideal market,
prices form where supply and demand meet, with the fees asymptotically
approaching the marginal costs of a transaction. Currently, supply is
capped and only demand can adjust. Should we ever consider to let
miners decide about supply, it is essential that their marginal
benefit of including an additional transaction is aligned with the
global marginal cost incurred by that additional transaction. Fee
smoothing is a step in this direction.
3. The incentive to form mining pools is reduced. Currently,
solo-mining yields a very volatile income stream due to the random
nature of mining, leading to the formation of pools. This volatility
will increase to even higher levels once the amount of Bitcoins earned
per block is dominated by (volatile) collected fees and not by
(constant) freshly minted coins, thus increasing the economic pressure
to join a large pool. Fee smoothing reduces that volatility and
pressure.

Problems: touching anything related to fee distribution is a political
minefield. This proposal probably requires a hard fork. Its technical
feasibility was only superficially verified.

This is my first post to this list and I am looking forward to your
comments. In case this proposal is received well, I plan to
specify/implement the idea more formally in order to kick off the
usual process for improvements.

-- 
Luzius Meisser
President of Bitcoin Association Switzerland
MSc in Computer Science and MA in Economics

From wtogami at gmail.com  Wed Jan 27 02:45:51 2016
From: wtogami at gmail.com (Warren Togami Jr.)
Date: Tue, 26 Jan 2016 18:45:51 -0800
Subject: [bitcoin-dev] Fee smoothing
In-Reply-To: <CAMuv0Z2gjNKc52UFV2n3H1ckt30chS7=fEUwO8OpfU1Vg7Ayzw@mail.gmail.com>
References: <CAMuv0Z2gjNKc52UFV2n3H1ckt30chS7=fEUwO8OpfU1Vg7Ayzw@mail.gmail.com>
Message-ID: <CAEz79PrVfdy5g=XcajMvKtCMUCtG44A8N_UAM8NrzZL00cvjiA@mail.gmail.com>

On Tue, Jan 26, 2016 at 9:42 AM, Luzius Meisser via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This post serves to convince you of the economic benefits of smoothing
> the payout of fees across blocks. It incentivizes decentralization and
> supports the establishment of a fee market.
>
> Idea: currently, the total amount of fees collected in a block is paid
> out in full to whoever mined that block. I propose to only pay out,
> say, 10% of the collected fees, and to add the remaining 90% to the
> collected fees of the next block. Thus, the payout to the miner
> constitutes a rolling average of collected fees from the current and
> past blocks. This
> *reduces the marginal benefit of including an additional transaction into
> a block* by an order of magnitude and thus
> aligns the incentives of individual miners better with those of the
> whole network. As a side-effect,
>
> *the disadvantage of mining with a slow connection is reduced.*


I do not believe your logic is correct.  Reducing the marginal benefit of
including an additional transaction is problematic because it
simultaneously increases the orphan risk while it reduces the reward.  90%
of the fee going to the next block would also create new incentive problems
like mining an empty block to minimize the chance of losing 90% of the fees
from the previous block to an orphan.  Another major issue with mandatory
sharing is if the miner doesn't want to share, nothing stops them from
taking payment out-of-band and confirming the transaction with little or no
fees visible in the block.

I had been thinking recently about fee deferral for a different reason.  In
the future when the subsidy is much smaller in proportion to the fees,
there may be little incentive to confirm on top of someone else's block in
cases when the expected value of replacing the current tip is higher.  I
think smoothing fees between the current and subsequent 5 blocks (for
example) might reduce the incentive of this type of behavior.  The main
risk here might be in weakening too far the incentive of adding more
transactions to the current block, as I believe your 10% current and 90%
subsequent reward split would do.  I think my idea of a mandatory split
between six blocks might also be a failure because of the high incentive to
conduct out-of-band payments.


> Benefits:
>
2. This is a step towards a free fee market. In an ideal market,
> prices form where supply and demand meet, with the fees asymptotically
> approaching the marginal costs of a transaction. Currently, supply is
> capped and only demand can adjust. Should we ever consider to let
> miners decide about supply, it is
>
> *essential that their marginal benefit of including an additional
> transaction is aligned with the global marginal cost incurred by that
> additional transaction.* Fee
> smoothing is a step in this direction.
>

While I don't agree with the rest of your logic, it is agreeable that you
care about aligning the miner's supply incentives with the global marginal
cost.  If you believe that is an important goal, you might like the Flex
Cap approach as presented by Mark Friedenbach at Scaling Bitcoin Hong Kong.

Under the general idea of the Flex Cap approach block size is no longer
fixed, it can be bursted higher on a per-block basis if the miner is
willing to defer a tiny portion of the current block subsidy to pay out to
the miner of later blocks.  If conditions are such that there is genuine
demand then some are willing to pay higher fees for time preference.  Some
formula would balance the cost and reward in some manner like: add the
value of newly included fees, subtract the expected marginal cost of orphan
risk, then subtract the portion of subsidy deferred.  Flex cap has periodic
block size retargets to allow for a temporary limit to rise or fall to
something resembling actual market demand.  This temporary limit is never a
"wall" that can be hit as miners can choose to burst past it if the cost is
worth the reward.

Flex Cap is an area of ongoing research that I strongly believe would
benefit Bitcoin in the long-term.  For this reason it requires careful
study and simulations to figure out specifics.

3. The incentive to form mining pools is reduced. Currently,
> solo-mining yields a very volatile income stream due to the random
> nature of mining, leading to the formation of pools. This volatility
> will increase to even higher levels once the amount of Bitcoins earned
> per block is dominated by (volatile) collected fees and not by
> (constant) freshly minted coins, thus increasing the economic pressure
> to join a large pool. Fee smoothing reduces that volatility and
> pressure.
>

You seem to not recognize that orphan cost is a major reason why pools are
attractive.

Warren Togami
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160126/c2d01aac/attachment-0001.html>

From luzius.meisser at gmail.com  Wed Jan 27 10:12:02 2016
From: luzius.meisser at gmail.com (Luzius Meisser)
Date: Wed, 27 Jan 2016 11:12:02 +0100
Subject: [bitcoin-dev] Fee smoothing
In-Reply-To: <CAEz79PrVfdy5g=XcajMvKtCMUCtG44A8N_UAM8NrzZL00cvjiA@mail.gmail.com>
References: <CAMuv0Z2gjNKc52UFV2n3H1ckt30chS7=fEUwO8OpfU1Vg7Ayzw@mail.gmail.com>
	<CAEz79PrVfdy5g=XcajMvKtCMUCtG44A8N_UAM8NrzZL00cvjiA@mail.gmail.com>
Message-ID: <CAMuv0Z1yo7-zzj75nXFf9kJNJfmxOoxqHMpDmmNM9uQzFKZ_xQ@mail.gmail.com>

2016-01-27 3:45 GMT+01:00 Warren Togami Jr. <wtogami at gmail.com>:
> On Tue, Jan 26, 2016 at 9:42 AM, Luzius Meisser via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Idea: currently, the total amount of fees collected in a block is paid
>> out in full to whoever mined that block. I propose to only pay out,
>> say, 10% of the collected fees, and to add the remaining 90% to the
>> collected fees of the next block. Thus, the payout to the miner
>> constitutes a rolling average of collected fees from the current and
>> past blocks.
>
> [...] Another major issue with mandatory sharing is
> if the miner doesn't want to share, nothing stops them from taking payment
> out-of-band and confirming the transaction with little or no fees visible in
> the block.

While I find the other points you raised debatable, the out-of-band
argument looks strong enough to kill the idea. To work around it, one
would need to create rules about the transactions that can be included
in a block, for example by mandating that all included transactions
must have a fee at least as high as 0.9 times the 5th percentile of
the transactions in the previous 10 blocks. However, having to tell
the miners what fees they are allowed to accept destroys some of the
elegance of the idea. Maybe I should put it to rest for now and see if
a more elegant solution comes to mind later.

> While I don't agree with the rest of your logic, it is agreeable that you
> care about aligning the miner's supply incentives with the global marginal
> cost.  If you believe that is an important goal, you might like the Flex Cap
> approach as presented by Mark Friedenbach at Scaling Bitcoin Hong Kong.
> Under the general idea of the Flex Cap approach block size is no longer
> fixed, it can be bursted higher on a per-block basis if the miner is willing
> to defer a tiny portion of the current block subsidy to pay out to the miner
> of later blocks.
> [...]
> Flex Cap is an area of ongoing research that I strongly believe would
> benefit Bitcoin in the long-term.  For this reason it requires careful study
> and simulations to figure out specifics.

I agree that flex cap is promising. However, for it to be a viable
long-term solution, it must not depend on significant block subsidies
to work as the block subsidy will become less and less relevant over
time.

Picking up your thoughts, I guess this is how flex cap should be done:
1. There is a flexible block cap (e.g. 1 MB). This first MB is free to fill.
2. Miners can buy additional space for an exponentially increasing
fee. For example, the first KiB might cost 200 Satoshis, the second
KiB 400 Satoshis, the tenth KiB 102400 Satoshis etc.
3. The price of the purchased space is subtracted from the collected
fees and added to the reward of the next block.
4. The amount miners are willing to spend on additional space allows
to calculate the marginal costs of a transaction of a miner. For
example, if a miner pays 6000 Satoshis to include a 1 KB transaction
with a fee of 6100 Satoshis, the marginal costs must be below 100
Satoshis, assuming a rational miner. This cost is multiplied by say 50
to account for the costs of decentralization to get a global cost
estimate of 5000 Satoshis per KB.
5. Every 1000 blocks or so, the basic cap is adjusted upwards or
downwards (e.g. by 10%) depending on whether the average fees per KB
were above or below the global cost estimate.

Under such a scheme, prices should get very close to free market
prices. However, ruthless competition can get ugly in markets where
fixed costs dominate. We can currently witness this in the oil
industry. Thus, from an economic point of view, it might be more
advisable to simply let miners vote on block size, as has been
proposed by others. The drawback of voting is that it allows miners to
enforce a cartel among themselves and to charge monopoly prices
instead of competitive prices. However, monopoly prices would already
be much better than having an artificial cap.

Warren, thank you for your thoughts! I appreciate the opportunity to
discuss ideas at such a high level.

--
Luzius Meisser
President of Bitcoin Association Switzerland
MSc in Computer Science and MA in Economics

From wtogami at gmail.com  Wed Jan 27 23:11:04 2016
From: wtogami at gmail.com (Warren Togami Jr.)
Date: Wed, 27 Jan 2016 15:11:04 -0800
Subject: [bitcoin-dev] Fee smoothing
In-Reply-To: <CAMuv0Z1yo7-zzj75nXFf9kJNJfmxOoxqHMpDmmNM9uQzFKZ_xQ@mail.gmail.com>
References: <CAMuv0Z2gjNKc52UFV2n3H1ckt30chS7=fEUwO8OpfU1Vg7Ayzw@mail.gmail.com>
	<CAEz79PrVfdy5g=XcajMvKtCMUCtG44A8N_UAM8NrzZL00cvjiA@mail.gmail.com>
	<CAMuv0Z1yo7-zzj75nXFf9kJNJfmxOoxqHMpDmmNM9uQzFKZ_xQ@mail.gmail.com>
Message-ID: <CAEz79Pq7AEmSfDZr0jc0JjdeH9asyGXXhJGMXc43OHJcj8Vrsw@mail.gmail.com>

On Wed, Jan 27, 2016 at 2:12 AM, Luzius Meisser <luzius.meisser at gmail.com>
wrote:

> I agree that flex cap is promising. However, for it to be a viable
> long-term solution, it must not depend on significant block subsidies
> to work as the block subsidy will become less and less relevant over
> time


There is another variant of the Flex Cap approach that allows miners to pay
with a slightly higher difficulty target instead of deferring a portion of
subsidy to later blocks.  I think the HK presentation was about the subsidy
deferral variant because of miner feedback that they preferred that
approach.

Myself and a few other developers think proposals like BIP100 where the
block size is subject to a vote by the miners is suboptimal because this
type of vote is costless.  You were astute in recognizing in your post it's
a good thing to somehow align the global marginal cost with the miner's
incentive.  I feel a costless vote is not great because it aligns only to
the miner's marginal cost, and not the marginal cost to the entire flood
network.  Flex Cap is superior as "vote" mechanism as there is an actual
cost associated, allowing block size to grow with actual demand.

Warren
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160127/dfc770d0/attachment.html>

From pete at petertodd.org  Thu Jan 28 18:51:24 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 28 Jan 2016 13:51:24 -0500
Subject: [bitcoin-dev] Segwit Upgrade Procedures & Block Extension Data
Message-ID: <20160128185124.GA5140@savin.petertodd.org>

A few notes on upgrade procedures associated with segregated witnesses:


Initial Deployment
==================

While segregated witnesses is a soft-fork, because it adds new data
blocks that old nodes don't relay segwit nodes can't sync from
non-segwit nodes and still be fully validating; once the segwit softfork
has activated full nodes need witness data to function. This poses a
major problem during deployment: if full node adoption lags miner
adoption, the segwit-supporting P2P network can partition and lose
consensus.

While Pieter Wuille's segwit branch(1) doesn't yet implement a fix for
the above problem, the obvious thing to do is to add a new service bit
such as NODE_SEGWIT, and/or bump the protocol version, and for outgoing
peers only connect to peers with segwit support. Interestingly, a
closely related problem already exists in Bitcoin Core: neither addrman
nor the outgoing connection thread takes what service bits a peer
advertises into account. So if a large number of non-block-relaying
nodes joined the network and advertised their addresses the network
could, in theory, partition even without an explicit attack. (My own
full-RBF fork of Bitcoin Core does fix(2) this issue, though by
accident!)

Note how because of this the segwit soft-fork has properties not unlike
hard-forks in terms of the need for nodes to upgrade with regard to the
P2P layer. Even with the above fix, the worst case would be for segwit
to not be adopted widely by full node operators, resulting in a network
much more vulnerable to attacks such as DoSing nodes. This is one of the
(many) reasons why hard-forks are generally significantly more dangerous
than soft-forks.


Future Upgrades
===============

Segwit isn't going to be the last thing that adds new block data. For
example, my own prev-block-proof proposal(3) requires that blocks commit
to another tree, which itself is calculated using a nonce that must be
passed along with the block data. (U)TXO commitments are another
possible future example.

BIP141 (currently) suggests an Extensible Commitment Structure(4)
consisting of a hashed linked list of consensus-critical commitments,
with a redefinable nonce at the end of the list for future soft-forks.
Currently this nonce is put into the otherwise useless, and non-hashed,
witness for the coinbase transaction(6) and a block is invalid if its
witness contains more than that single nonce.(7)

Unfortunately, this means that the next soft-fork upgrade to add
additional data will have the above relaying problem all over again!
Even a minimal upgrade adding a new commitment - like my
prev-block-proof proposal - needs to at least add another nonce for
future upgrades. In addition to having to upgrade full nodes, this also
requires systems like the relay network to upgrade, even though they may
not themselves otherwise need to care about the contents of blocks.

A more subtle implication of this problem is how do you handle parallel
upgrades, as proposed by BIP9? Splitting the P2P network into
non-upgraded nodes, and a much smaller group of upgraded nodes, is bad
enough when done every once in a awhile. How does this look with more
frequent upgrades, not necessarily done by teams that are working
closely with each other?


Proposal: Unvalidated Block Extension Data
==========================================

1) Remove the restriction that the coinbase witness contain exactly one
   32byte value.

2) Hash the contents of the coinbase witness (e.g. as a merkle tree) and
   commit them in place of the current nonce commitment.

3) Include that data in the blocksize limit (to prevent abuse).

Now future soft-forks can simply add additional data, which non-upgraded
nodes simply see as extension data that they don't know how to fully
validate. All nodes can however validate that data came from the miner,
and thus they can freely propagate that data without risk of attack
(Bitcoin Core used to allow additional data to be included with
transactions, which was used in a DoS attack (CVE-2013-4627)).

This is more efficient than it may appear at first glace. As most future
upgrades are expected to be additional commitments where full nodes can
deterministically recalculate the commitment, the additional data for
each new commitment is just 32 bytes.

A significant design consideration is that if arbitrary data can be
added, it is very likely that miners will make use of that ability for
non-Bitcoin purposes; we've already run into problems deploying segwit
itself because of pools using the coinbase space for advertising and
merge-mining. Avoiding this problem is easiest with a merkelized
key:value mapping, with the ability to use collision-resistant ID's as
keys (e.g. UUID).

Secondly, does using the coinbase witness for this really make sense?
Logically it'd make more sense to change the way blocks are serialized,
much the same way transaction serialization was changed to accomodate
segwit; stuffing this in the coinbase witness smells like a hack. (along
those lines, note how witnesses themselves could have been implemented
this way - probably too late to change now)


References
==========

1) https://github.com/sipa/bitcoin/tree/segwit

2) https://github.com/petertodd/bitcoin/blob/replace-by-fee-v0.12.0rc2/src/net.cpp#L1616

3) http://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-December/012103.html

5) https://github.com/bitcoin/bips/blob/6a315c023f13d83c58aab98cf8668d74cf7566c7/bip-0141.mediawiki#Extensible_commitment_structure

6) https://github.com/sipa/bitcoin/blob/37973bf2efd7a558c86bf35455a1355e5b0d5d64/src/main.cpp#L3212

7) https://github.com/sipa/bitcoin/blob/37973bf2efd7a558c86bf35455a1355e5b0d5d64/src/main.cpp#L3209

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
0000000000000000003b293f5507f7787f1ba64ba58a21c46ba4454c21a88710
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160128/961968b0/attachment.sig>

From luzius.meisser at gmail.com  Thu Jan 28 20:16:41 2016
From: luzius.meisser at gmail.com (Luzius Meisser)
Date: Thu, 28 Jan 2016 21:16:41 +0100
Subject: [bitcoin-dev] Fee smoothing
In-Reply-To: <CAMuv0Z1yo7-zzj75nXFf9kJNJfmxOoxqHMpDmmNM9uQzFKZ_xQ@mail.gmail.com>
References: <CAMuv0Z2gjNKc52UFV2n3H1ckt30chS7=fEUwO8OpfU1Vg7Ayzw@mail.gmail.com>
	<CAEz79PrVfdy5g=XcajMvKtCMUCtG44A8N_UAM8NrzZL00cvjiA@mail.gmail.com>
	<CAMuv0Z1yo7-zzj75nXFf9kJNJfmxOoxqHMpDmmNM9uQzFKZ_xQ@mail.gmail.com>
Message-ID: <CAMuv0Z1r9u9_ru8ouLuxh1M7O2k_6RqmGe6Tf2XKsqi+mOvY7g@mail.gmail.com>

2016-01-28 13:00 GMT+01:00  Warren Togami Jr. <wtogami at gmail.com>:
> Myself and a few other developers think proposals like BIP100 where the
> block size is subject to a vote by the miners is suboptimal because this
> type of vote is costless.

The cost of the vote is completely irrelevant. What matters are the
resulting block sizes and transaction fees. Assuming rational,
profit-maximizing miners, BIP100 would allow them to effectively
enforce a cartel and to set block sizes (and thereby indirectly also
fees) at monopoly price levels. Charging something for a vote would
not affect that equilibrium and thus also neither affect block sizes
nor fees. Also note that monopoly prices are always at least as high
as competitive market prices. In other words: the transaction fees
that emerge under BIP100 will be higher than those that would emerge
with a flex cap mechanism that is based on the total marginal costs of
the miners. If you do not believe that, I'll happily go into the gory
details.

> You were astute in recognizing in your post it's
> a good thing to somehow align the global marginal cost with the miner's
> incentive.  I feel a costless vote is not great because it aligns only to
> the miner's marginal cost, and not the marginal cost to the entire flood
> network.  Flex Cap is superior as "vote" mechanism as there is an actual
> cost associated, allowing block size to grow with actual demand.

There are two types of flex cap mechanisms: First, there mechanisms
like the one I described previously which ensures that supply is based
on the actual costs of the miners. If done right, they can lead to a
competitive equilibrium with free market prices. Second, there are
flex cap mechanisms that simply replace todays centrally planned
constant cap with a centrally planned supply curve. If you believe in
central planning, that's ok. I for one prefer to avoid it. Also, it is
not much better than the constant cap, maybe even worse.

Note that neither type of flex cap adjusts to the marginal cost of the
entire network, simply because none of them can measure the cost of
running a full node, yet alone reliably detect the number of running
full nodes. Any attempt to do so would be futile anyway because it
would too easy to pretend-run full nodes in order to manipulate the
mechanism. When reasoning about full nodes, completely different
forces are at play. The only connection between full nodes and the fee
market is that larger blocks make it more expensive to run a full
node.

However, a holistic analysis must also reason about the benefits of
running a full node. I often see one-sided arguments saying that
increasing block sizes will make running one more expensive and thus
there will be fewer nodes. This logic is flawed because the economic
reasons for running a full node are not understood and taken into
account. An example reason could be the ability to monitor the network
and to verify transactions, which is very valuable to exchanges,
merchants and wallet services. To them, this value of running a full
node even grows with the number of customers. Thus, depending on the
circumstances, increase block sizes can counter-intuitively make it
more attractive to run a full node. The big picture from a systemic
perspective can look completely different than the conventional
micro-view that only sees first-order effects. Unfortunately, most
people are not great systems-thinkers.



2016-01-27 11:12 GMT+01:00 Luzius Meisser <luzius.meisser at gmail.com>:
> 2016-01-27 3:45 GMT+01:00 Warren Togami Jr. <wtogami at gmail.com>:
>> On Tue, Jan 26, 2016 at 9:42 AM, Luzius Meisser via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> Idea: currently, the total amount of fees collected in a block is paid
>>> out in full to whoever mined that block. I propose to only pay out,
>>> say, 10% of the collected fees, and to add the remaining 90% to the
>>> collected fees of the next block. Thus, the payout to the miner
>>> constitutes a rolling average of collected fees from the current and
>>> past blocks.
>>
>> [...] Another major issue with mandatory sharing is
>> if the miner doesn't want to share, nothing stops them from taking payment
>> out-of-band and confirming the transaction with little or no fees visible in
>> the block.
>
> While I find the other points you raised debatable, the out-of-band
> argument looks strong enough to kill the idea. To work around it, one
> would need to create rules about the transactions that can be included
> in a block, for example by mandating that all included transactions
> must have a fee at least as high as 0.9 times the 5th percentile of
> the transactions in the previous 10 blocks. However, having to tell
> the miners what fees they are allowed to accept destroys some of the
> elegance of the idea. Maybe I should put it to rest for now and see if
> a more elegant solution comes to mind later.
>
>> While I don't agree with the rest of your logic, it is agreeable that you
>> care about aligning the miner's supply incentives with the global marginal
>> cost.  If you believe that is an important goal, you might like the Flex Cap
>> approach as presented by Mark Friedenbach at Scaling Bitcoin Hong Kong.
>> Under the general idea of the Flex Cap approach block size is no longer
>> fixed, it can be bursted higher on a per-block basis if the miner is willing
>> to defer a tiny portion of the current block subsidy to pay out to the miner
>> of later blocks.
>> [...]
>> Flex Cap is an area of ongoing research that I strongly believe would
>> benefit Bitcoin in the long-term.  For this reason it requires careful study
>> and simulations to figure out specifics.
>
> I agree that flex cap is promising. However, for it to be a viable
> long-term solution, it must not depend on significant block subsidies
> to work as the block subsidy will become less and less relevant over
> time.
>
> Picking up your thoughts, I guess this is how flex cap should be done:
> 1. There is a flexible block cap (e.g. 1 MB). This first MB is free to fill.
> 2. Miners can buy additional space for an exponentially increasing
> fee. For example, the first KiB might cost 200 Satoshis, the second
> KiB 400 Satoshis, the tenth KiB 102400 Satoshis etc.
> 3. The price of the purchased space is subtracted from the collected
> fees and added to the reward of the next block.
> 4. The amount miners are willing to spend on additional space allows
> to calculate the marginal costs of a transaction of a miner. For
> example, if a miner pays 6000 Satoshis to include a 1 KB transaction
> with a fee of 6100 Satoshis, the marginal costs must be below 100
> Satoshis, assuming a rational miner. This cost is multiplied by say 50
> to account for the costs of decentralization to get a global cost
> estimate of 5000 Satoshis per KB.
> 5. Every 1000 blocks or so, the basic cap is adjusted upwards or
> downwards (e.g. by 10%) depending on whether the average fees per KB
> were above or below the global cost estimate.
>
> Under such a scheme, prices should get very close to free market
> prices. However, ruthless competition can get ugly in markets where
> fixed costs dominate. We can currently witness this in the oil
> industry. Thus, from an economic point of view, it might be more
> advisable to simply let miners vote on block size, as has been
> proposed by others. The drawback of voting is that it allows miners to
> enforce a cartel among themselves and to charge monopoly prices
> instead of competitive prices. However, monopoly prices would already
> be much better than having an artificial cap.
>
> Warren, thank you for your thoughts! I appreciate the opportunity to
> discuss ideas at such a high level.
>
> --
> Luzius Meisser
> President of Bitcoin Association Switzerland
> MSc in Computer Science and MA in Economics



-- 
Luzius Meisser
luzius.meisser at gmail.com

From elombrozo at gmail.com  Fri Jan 29 00:52:53 2016
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Thu, 28 Jan 2016 16:52:53 -0800
Subject: [bitcoin-dev] BIP Classification Process
Message-ID: <42F57F58-7C67-43DD-81DE-2C77E03733F2@gmail.com>

Folks,

I think the current situation with forks could have been avoided with a better process that can distinguish between different layers for bitcoin modification proposals.

For instance, BIP64 was proposed by Mike Hearn, which does not affect the consensus layer at all. Many Core devs disliked the proposal and Mike had lots of pushback. Regardless of whether or not you agree with the merits of Mike?s ideas here, fact is having nodes that support BIP64 would not fundamentally break the Bitcoin network.

This issue prompted Mike to break off from Core and create XT as the applications he was developing required BIP64 to work. With this split, Gavin found a new home for his big block ideas?and the two teamed up.

We need to have a process that clearly distinguishes these different layers and allows much more freedom in the upper layers while requiring agreement at the consensus layer. Many of these fork proposals are actually conflating different features, only some of which would actually be consensus layer changes. When people proposing nonconsensus features get pushback from Core developers they feel rejected and are likely to team up with others trying to push for hard forks and the like.

A while back I had submitted a BIP -  BIP123 - that addresses this issue. I have updated it to include all the currently proposed and accepted BIPs and have submitted a PR: https://github.com/bitcoin/bips/pull/311 <https://github.com/bitcoin/bips/pull/311>

I urge everyone to seriously consider getting this BIP accepted as a top priority before we get more projects all trying their hand at stuff and not understanding these critical distinctions.


- Eric
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160128/2e877491/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160128/2e877491/attachment-0001.sig>

From jannes.faber at gmail.com  Fri Jan 29 02:31:05 2016
From: jannes.faber at gmail.com (Jannes Faber)
Date: Fri, 29 Jan 2016 03:31:05 +0100
Subject: [bitcoin-dev] Best (block nr % 2016) for hard fork activation?
Message-ID: <CABeL=0hLCt5OTj0KCg7Ci-gMbL7=MGvm9NhBCquWMObYkbgEuw@mail.gmail.com>

Hi,

Question if you'll allow me. This is not about Gavin's latest hard fork
proposal but in general about any hard (or soft) fork.

I was surprised to see a period expressed in human time instead of in block
time:

> Blocks with timestamps greater than or equal to the triggering block's
timestamp plus 28 days (60*60*24*28 seconds) shall have the new limits.

But even more so I would expect there to be significant differences in
effects on non-updated clients depending on the moment (expressed as block
number) of applying the new rules. I see a few options, all relating to the
2016 blocks recalibration window.

1) the first block after difficulty adjustment.
2) the last block before the difficulty adjustment.
3) in the middle
4) n blocks before the adjustment with n the smallest number of blocks
calculated such that the adjustment can just manage to do the maximum
possible drop in difficulty.

One of the effects I'm thinking of would be in case of an evil contentious
75-25 hard fork. If that activates at 1) or 2) it will take an awful long
time for the 25% chain to get to 2016 for the next adjustment all the while
having 40 minutes block times. Option 4) sounds a lot better for the
conservative chain. The attacking fork clearly has a choice to make it as
hard as possible for them.

On the other hand when a non-contentious hard fork is rolled out, one could
argue that it's actually best for everyone if the remaining 1% chain
doesn't stand a chance of ever reaching 2016 blocks anymore (not even by a
decent sized attacker trying to double spend on stragglers). Also causing
all alarm bells to go off in the non-updated clients.

Have people thought through all the different scenarios yet?

And would it not make sense to define whatever the best choice is as
mandatory for any hard fork proposal? BIP9? (Realising attackers won't
necessarily follow BIPs anyway.)

Does something like this also play a role for soft forks?

I do realise that it's quite possible for the first few blocks, mined after
the new rules become valid, to still be old style blocks. Thus maybe
defeating the whole planning.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160129/09171b31/attachment.html>

From btcdrak at gmail.com  Fri Jan 29 07:21:10 2016
From: btcdrak at gmail.com (Btc Drak)
Date: Fri, 29 Jan 2016 07:21:10 +0000
Subject: [bitcoin-dev] BIP Classification Process
In-Reply-To: <42F57F58-7C67-43DD-81DE-2C77E03733F2@gmail.com>
References: <42F57F58-7C67-43DD-81DE-2C77E03733F2@gmail.com>
Message-ID: <CADJgMzv8o8fewFa7nsFf6-2N=Qo8S2bLsTpYd7F6jcsO1oYrXA@mail.gmail.com>

Your proposal does not solve the issue related to Mike creating his own
fork. He created his own for because he had a non-consensus feature set
that Bitcoin Core disagreed with and he wanted. That is to be _encouraged_.
I also maintain my own Bitcoin fork with a specific (non-consensus) feature
for the same reason and I am perfectly happy with the arrangement, as are
my userbase.

Classification of BIPs is fine, I have no problem with that and I support
your BIP, but your proposition it would have stopped Mike from creating his
own distribution is false (nor desirable): it was down to a strong
differing of technical opinions between Mike and a dozen other developers
as well as node security concerns (which were proved correct).


On Fri, Jan 29, 2016 at 12:52 AM, Eric Lombrozo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Folks,
>
> I think the current situation with forks could have been avoided with a
> better process that can distinguish between different layers for bitcoin
> modification proposals.
>
> For instance, BIP64 was proposed by Mike Hearn, which does not affect the
> consensus layer at all. Many Core devs disliked the proposal and Mike had
> lots of pushback. Regardless of whether or not you agree with the merits of
> Mike?s ideas here, fact is having nodes that support BIP64 would not
> fundamentally break the Bitcoin network.
>
> This issue prompted Mike to break off from Core and create XT as the
> applications he was developing required BIP64 to work. With this split,
> Gavin found a new home for his big block ideas?and the two teamed up.
>
> We need to have a process that clearly distinguishes these different
> layers and allows much more freedom in the upper layers while requiring
> agreement at the consensus layer. Many of these fork proposals are actually
> conflating different features, only some of which would actually be
> consensus layer changes. When people proposing nonconsensus features get
> pushback from Core developers they feel rejected and are likely to team up
> with others trying to push for hard forks and the like.
>
> A while back I had submitted a BIP -  BIP123 - that addresses this issue.
> I have updated it to include all the currently proposed and accepted BIPs
> and have submitted a PR: https://github.com/bitcoin/bips/pull/311
>
> I urge everyone to seriously consider getting this BIP accepted as a top
> priority before we get more projects all trying their hand at stuff and not
> understanding these critical distinctions.
>
>
> - Eric
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160129/cbfbca9f/attachment.html>

From elombrozo at gmail.com  Fri Jan 29 07:57:00 2016
From: elombrozo at gmail.com (Eric Lombrozo)
Date: Thu, 28 Jan 2016 23:57:00 -0800
Subject: [bitcoin-dev] BIP Classification Process
In-Reply-To: <CADJgMzv8o8fewFa7nsFf6-2N=Qo8S2bLsTpYd7F6jcsO1oYrXA@mail.gmail.com>
References: <42F57F58-7C67-43DD-81DE-2C77E03733F2@gmail.com>
	<CADJgMzv8o8fewFa7nsFf6-2N=Qo8S2bLsTpYd7F6jcsO1oYrXA@mail.gmail.com>
Message-ID: <7DA5E08C-DABB-48F8-A47F-0852F059EB74@gmail.com>

Codebase forks with nonconsensus features are totally fine! It?s the bitterness and resentment that arose out of the need to get everyone to agree on something that not everyone really needs to agree on that?s the problem.

> On Jan 28, 2016, at 11:21 PM, Btc Drak <btcdrak at gmail.com> wrote:
> 
> Your proposal does not solve the issue related to Mike creating his own fork. He created his own for because he had a non-consensus feature set that Bitcoin Core disagreed with and he wanted. That is to be _encouraged_. I also maintain my own Bitcoin fork with a specific (non-consensus) feature for the same reason and I am perfectly happy with the arrangement, as are my userbase.
> 
> Classification of BIPs is fine, I have no problem with that and I support your BIP, but your proposition it would have stopped Mike from creating his own distribution is false (nor desirable): it was down to a strong differing of technical opinions between Mike and a dozen other developers as well as node security concerns (which were proved correct).
> 
> 
> On Fri, Jan 29, 2016 at 12:52 AM, Eric Lombrozo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> Folks,
> 
> I think the current situation with forks could have been avoided with a better process that can distinguish between different layers for bitcoin modification proposals.
> 
> For instance, BIP64 was proposed by Mike Hearn, which does not affect the consensus layer at all. Many Core devs disliked the proposal and Mike had lots of pushback. Regardless of whether or not you agree with the merits of Mike?s ideas here, fact is having nodes that support BIP64 would not fundamentally break the Bitcoin network.
> 
> This issue prompted Mike to break off from Core and create XT as the applications he was developing required BIP64 to work. With this split, Gavin found a new home for his big block ideas?and the two teamed up.
> 
> We need to have a process that clearly distinguishes these different layers and allows much more freedom in the upper layers while requiring agreement at the consensus layer. Many of these fork proposals are actually conflating different features, only some of which would actually be consensus layer changes. When people proposing nonconsensus features get pushback from Core developers they feel rejected and are likely to team up with others trying to push for hard forks and the like.
> 
> A while back I had submitted a BIP -  BIP123 - that addresses this issue. I have updated it to include all the currently proposed and accepted BIPs and have submitted a PR: https://github.com/bitcoin/bips/pull/311 <https://github.com/bitcoin/bips/pull/311>
> 
> I urge everyone to seriously consider getting this BIP accepted as a top priority before we get more projects all trying their hand at stuff and not understanding these critical distinctions.
> 
> 
> - Eric
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160128/a8c4af1d/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 842 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160128/a8c4af1d/attachment-0001.sig>

From gavinandresen at gmail.com  Fri Jan 29 16:39:14 2016
From: gavinandresen at gmail.com (Gavin Andresen)
Date: Fri, 29 Jan 2016 11:39:14 -0500
Subject: [bitcoin-dev] Best (block nr % 2016) for hard fork activation?
In-Reply-To: <CABeL=0hLCt5OTj0KCg7Ci-gMbL7=MGvm9NhBCquWMObYkbgEuw@mail.gmail.com>
References: <CABeL=0hLCt5OTj0KCg7Ci-gMbL7=MGvm9NhBCquWMObYkbgEuw@mail.gmail.com>
Message-ID: <CABsx9T0oY2OuPCRgnQmqbLOBSQVd-yuQ8mMXjfzYpJTjXn8woQ@mail.gmail.com>

On Thu, Jan 28, 2016 at 9:31 PM, Jannes Faber via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> Question if you'll allow me. This is not about Gavin's latest hard fork
> proposal but in general about any hard (or soft) fork.
>
> I was surprised to see a period expressed in human time instead of in
> block time:
>
> > Blocks with timestamps greater than or equal to the triggering block's
> timestamp plus 28 days (60*60*24*28 seconds) shall have the new limits.
>
>
Block timestamps are in the 80-byte block header, so activation is
completely deterministic and can be determined from just the sequence of
block headers. There are no edge cases to worry about.

But even more so I would expect there to be significant differences in
> effects on non-updated clients depending on the moment (expressed as block
> number) of applying the new rules. I see a few options, all relating to the
> 2016 blocks recalibration window.
>

It doesn't matter much where in the difficulty period the fork happens; if
it happens in the middle, the lower-power fork's difficulty will adjust a
little quicker.

Example:  (check my math, I'm really good at screwing up at basic
arithmetic):

Fork at block%2016:  25% hashpower will take 8 weeks to produce 2016
blocks, difficulty drops by 4.

Fork one-week (halfway) into difficulty period:  25% hashpower will take 4
weeks to adjust, difficulty drops by 5/2 = 2.5
It will then take another 3.2 weeks to get to the next difficult adjustment
period and normal 10-minute blocks.

That's an unrealisitic scenario, though-- there will not be 25% of hash
power on a minority fork. I wrote about why in a blog post today:

http://gavinandresen.ninja/minority-branches

If you assume a more realistic single-digit-percentage of hash power on the
minority fork, then the numbers get silly (e.g. two or three months of an
hour or three between blocks before a difficulty adjustment).


-- 
--
Gavin Andresen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160129/9d042bb9/attachment.html>

From jtimon at jtimon.cc  Fri Jan 29 18:50:14 2016
From: jtimon at jtimon.cc (=?UTF-8?B?Sm9yZ2UgVGltw7Nu?=)
Date: Fri, 29 Jan 2016 19:50:14 +0100
Subject: [bitcoin-dev] Best (block nr % 2016) for hard fork activation?
In-Reply-To: <CABsx9T0oY2OuPCRgnQmqbLOBSQVd-yuQ8mMXjfzYpJTjXn8woQ@mail.gmail.com>
References: <CABeL=0hLCt5OTj0KCg7Ci-gMbL7=MGvm9NhBCquWMObYkbgEuw@mail.gmail.com>
	<CABsx9T0oY2OuPCRgnQmqbLOBSQVd-yuQ8mMXjfzYpJTjXn8woQ@mail.gmail.com>
Message-ID: <CABm2gDrQxUUfQA07309LSMZMb-j4Kxutc41F+fUK+E8yHNNj6Q@mail.gmail.com>

On Fri, Jan 29, 2016 at 5:39 PM, Gavin Andresen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On Thu, Jan 28, 2016 at 9:31 PM, Jannes Faber via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> It doesn't matter much where in the difficulty period the fork happens; if
> it happens in the middle, the lower-power fork's difficulty will adjust a
> little quicker.

The reason why BIP9 (versionbits) only checks for new activations
during difficulty retargettings is a simple optimization to only check
1/2016 of the blocks.
I suspect the check itself is not that costly for Bitcoin Core, which
has all the block headers in memory anyway, but I don't think we
should assume that will be the case for all implementations.

<BIP99 aside comment>
As an aside, BIP99 never recommends a 75% mining signaling activation
threshold: it recommends 95% for uncontroversial rule changes and no
miner signaling at all for controversial hardforks.
I still have to update BIP99 with some later changes I commented at
Scaling Bitcoin HK like signaling hardfork activation with the
"negative int32_t bit" so that old clients are forced to
upgrade/decide. We could start deploying better ways to inform users
about a hardfork event, but of course those changes cannot be applied
to older software that is already deployed (but hopefully they will
still notice something is weird is happening if the longest chain that
keeps growing is invalid because it contained a block with a negative
version in it).
But I'm yet to see a single hardfork proposal that follows BIP99's
recommendations besides the hardfork proposed in BIP99 itself, which
should consist on a manageable list of very simple to deploy fixes
like the timewarp fix forward-ported from Freicoin 0.8 for the BIP. I
haven't seen much interest in growing that little list of "a few fixes
nobody disagrees are bugs or sub-optimal design decisions, plus the
changes are easy to implement both separately and as a whole" either.
I cannot say I have seen any opposition at all to BIP99 as a hardfork
either, but I naively expected people would ask me to implement more
things for BIP99 besides
https://github.com/bitcoin/bitcoin/compare/0.11...jtimon:hardfork-timewarp-0.11
or even contribute the patches themselves. For all that, I don't
consider BIP99 a priority to work on and I plan to complete it at some
point later, unless there's a time limit for a BIP to be in the
"draft" state or something.
If someone else considers completing BIP99 a priority, I'm happy to
review and integrate things, though. Thanks again to all the reviewers
and contributors to the BIP at this time and I'm sorry that it has
been stuck for some time. Maybe the classification/recommendations
should have been a BIP without code and the hardfork proposal itself
should have been another one and that would have been clearer. I just
wanted to have some code on my first BIP (and as said the plan is
still to put more code at some point).
</BIP99 aside comment>

From pete at petertodd.org  Fri Jan 29 19:11:52 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 29 Jan 2016 14:11:52 -0500
Subject: [bitcoin-dev] Best (block nr % 2016) for hard fork activation?
In-Reply-To: <CABeL=0hLCt5OTj0KCg7Ci-gMbL7=MGvm9NhBCquWMObYkbgEuw@mail.gmail.com>
References: <CABeL=0hLCt5OTj0KCg7Ci-gMbL7=MGvm9NhBCquWMObYkbgEuw@mail.gmail.com>
Message-ID: <20160129191152.GA18253@savin.petertodd.org>

On Fri, Jan 29, 2016 at 03:31:05AM +0100, Jannes Faber via bitcoin-dev wrote:
> On the other hand when a non-contentious hard fork is rolled out, one could
> argue that it's actually best for everyone if the remaining 1% chain
> doesn't stand a chance of ever reaching 2016 blocks anymore (not even by a
> decent sized attacker trying to double spend on stragglers). Also causing
> all alarm bells to go off in the non-updated clients.
> 
> Have people thought through all the different scenarios yet?

I wrote up some of those risks in my "Soft Forks Are Safer Than Hard
Forks" post the other week:

https://petertodd.org/2016/soft-forks-are-safer-than-hard-forks

I was writing mainly in terms of technical risks for deployment
non-controversial forks; for controversial forks there's many more
failure scenarios. In any case, on technical grounds alone it's obvious
that hard-forks without very high - 95% or so - activation thresholds
are quite dangerous.

In general, it should be remembered that high activation thresholds for
hard-forks can always be soft-forked down after the fact. For instance,
suppose we initially used 100% support over the past one month of blocks
as a hard-fork threshold, but can't get more than 96% support. A
soft-fork with the following rule can be implemented:

    If 95% of the past blocks vote yes, voting against the hard-fork is
    not allowed.

As soft-forks can be rolled out quite quickly, implementing this in the
event that a hard-fork isn't getting sufficient support won't add much
delay to the overall process; as it is a soft-fork, only miners need to
adopt it for it to take effect.

For this reason I'd suggest any hard fork use 99%+ activation
thresholds, measured over multi-week timespan. Hard-forks should not be
controversial for good social/political reasons anyway, so there's
little harm in most cases to at worst delaying the fork by two or three
months if stragglers won't upgrade (in very rare cases like security
issues there may be exceptions; blocksize is certainly not one of those
cases).

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
000000000000000005822b77a904129795a3ff4167c57ed1044f5a93512c830f
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 650 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160129/14717ba2/attachment.sig>

From aj at erisian.com.au  Sat Jan 30 15:32:26 2016
From: aj at erisian.com.au (Anthony Towns)
Date: Sun, 31 Jan 2016 01:32:26 +1000
Subject: [bitcoin-dev] Segwit Upgrade Procedures & Block Extension Data
In-Reply-To: <20160128185124.GA5140@savin.petertodd.org>
References: <20160128185124.GA5140@savin.petertodd.org>
Message-ID: <20160130153226.GA9757@sapphire.erisian.com.au>

On Thu, Jan 28, 2016 at 01:51:24PM -0500, Peter Todd via bitcoin-dev wrote:
> While Pieter Wuille's segwit branch(1) doesn't yet implement a fix for
> the above problem, the obvious thing to do is to add a new service bit
> such as NODE_SEGWIT, and/or bump the protocol version, and for outgoing
> peers only connect to peers with segwit support.

If I'm following the code right, the segwit branch has a fHaveWitness
flag for each connection, which is set when a HAVEWITNESS message comes
from the peer, and HAVEWITNESS is sent as part of handshaking. BIP144
suggests maybe this should be changed to a service bit though:

https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki

If you've got a limit of 8 outgoing connections and >4 of them don't
support witnesses, would it be enough to just drop a non-witness
connection and try a new one? Or is anything less than 8 of 8 outgoing
witness supporting connections likely to be bad for the network?

> Future Upgrades
> ===============
> Segwit isn't going to be the last thing that adds new block data. For
> example, my own prev-block-proof proposal(3) requires that blocks commit
> to another tree, which itself is calculated using a nonce that must be
> passed along with the block data. (U)TXO commitments are another
> possible future example.

Commitments to a merkle sum tree of transaction bytes, sigops, sighash
bytes, fees, priority, etc for small fraud proofs also fit here,
don't they?

> Unfortunately, this means that the next soft-fork upgrade to add
> additional data will have the above relaying problem all over again!

This isn't necessarily true -- you could just make the coinbase witness
nonce become HASH(newinformation | newnonce), and put newnonce back into
the coinbase as an additional OP_RETURN, so that it can be verified.

If you want to have layered soft-forks adding new commitments, I think
you have to keep adding 32 byte hashed nonces; dropping them would be
a hard fork as far as I can see. So if there might eventually be three
or four of them, putting them in the witness block rather than the base
block seems sensible to me.

> Proposal: Unvalidated Block Extension Data
> ==========================================
> 1) Remove the restriction that the coinbase witness contain exactly one
>    32byte value.

+1.

If the linked list approach in BIP141 is used, then I think the logic
could be something like this:

 * suppose there have been a few soft-forks and the coinbase witness
   now handles three commitments: segwit, prevblockproof, fraudproofs

 * then the coinbase witness stack should have at least 3 32-byte
   values pushed on it, which should evaluate to:

     s[1] = HASH( fraudproof-info ; s[2] )
     s[0] = HASH( prevblockproof-info ; s[1] )

   and the coinbase should include

     OP_RETURN SHA256d( segwit-info ; s[0] )

 * old segwit code works fine (assuming the stack.size() != 1 check is
   changed to == 0), just treating s[0] as a meaningless nonce

 * old prevblockproof supporting nodes check s[0], treating s[1] as a
   meaningless nonce, but still validating the prevblock proofs

 * nodes running the latest code validate all three checks, and will
   continue to work if new checks are soft-forked in later

> 2) Hash the contents of the coinbase witness (e.g. as a merkle tree) and
>    commit them in place of the current nonce commitment.

But I think this seems just as good, and a fair bit simpler. ie with the
same three commitments, the coinbase witness contains:

     s[2] = nonce
     s[1] = fraudproof-info-hash
     s[0] = prevblockproof-info-hash

and coinbase includes:

     OP_RETURN SHA256d( HASH(segwit-info) ; s[0] ; s[1] ; s[2] ; ... )

I'm not sure if the use of a nonce has any value if done this way.

With this apporach, the commitments could be ordered arbitrarily --
you only have to check that "fraudproof-info-hash" is somewhere on the
stack of the coinbase witness, not that it's s[1] in particular.

I think it makes sense to plan on cleaning these up with infrequent
hard forks, eg one that combines the transactions hashMerkleRoot
and the witnessMerkleRoot and the fraudProofMerkleSumRoot and the
prevBLockProofHash into a single entry in the block header, but being
able to add features with soft-forks in the meantime seems like a win.

> 3) Include that data in the blocksize limit (to prevent abuse).

Including it in the coinbase witness already includes it in the blocksize
limit, albeit discounted, no? If someone wants to propose a soft-fork
adding 500kB of extra consensus-critical data to each block for some
reason, sticking it in the coinbase witness seems about the least
offensive way to do it?

> Secondly, does using the coinbase witness for this really make sense?

If you look at the witness as a proof of "this is why it's okay to
accept this transaction" in general, and the coinbase witness is "this
is why it's okay to accept this block", then including prevblock proofs
and fraud proof info in the coinbase witness seems pretty logical... Or
at least, it does to me.

This topic seems to be being discussed in a PR on the segwit branch:

  https://github.com/sipa/bitcoin/pull/48

where there's a proposal to have the coinbase witness include the merkle
path to the segwit data, so, if I understand it right, the coinbase
commitment might be:

  OP_RETURN Hash( s[0] || Hash( Hash( s[2] || segwit-data ) || s[1] ) )

if the path to the segwit data happened to be right-left-right. That
would still make it hard to work out the path to some proof that happened
to be in position right-right-left, though, so it seems inferior to the
approaches described above to me...

Cheers,
aj

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160131/7cb0c5c1/attachment.sig>

From aj at erisian.com.au  Sat Jan 30 15:48:57 2016
From: aj at erisian.com.au (Anthony Towns)
Date: Sun, 31 Jan 2016 01:48:57 +1000
Subject: [bitcoin-dev] Segwit Upgrade Procedures & Block Extension Data
In-Reply-To: <20160130153226.GA9757@sapphire.erisian.com.au>
References: <20160128185124.GA5140@savin.petertodd.org>
	<20160130153226.GA9757@sapphire.erisian.com.au>
Message-ID: <20160130154857.GA13217@sapphire.erisian.com.au>

On Sun, Jan 31, 2016 at 01:32:26AM +1000, Anthony Towns via bitcoin-dev wrote:
> On Thu, Jan 28, 2016 at 01:51:24PM -0500, Peter Todd via bitcoin-dev wrote:
> > While Pieter Wuille's segwit branch(1) doesn't yet implement a fix for
> > the above problem, the obvious thing to do is to add a new service bit
> > such as NODE_SEGWIT, and/or bump the protocol version, and for outgoing
> > peers only connect to peers with segwit support.
> If I'm following the code right, the segwit branch has a fHaveWitness
> flag for each connection, which is set when a HAVEWITNESS message comes
> from the peer, and HAVEWITNESS is sent as part of handshaking. BIP144
> suggests maybe this should be changed to a service bit though:

Oh, there's a PR to change this to a NODE_WITNESS service bit:

https://github.com/sipa/bitcoin/pull/55

Cheers,
aj

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160131/ef5edc4f/attachment.sig>

From luke at dashjr.org  Sat Jan 30 18:50:02 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 30 Jan 2016 18:50:02 +0000
Subject: [bitcoin-dev] SegWit GBT updates
Message-ID: <201601301850.03469.luke@dashjr.org>

I've completed an initial draft of a BIP for updating getblocktemplate for 
segregated witness here:
    https://github.com/luke-jr/bips/blob/segwit_gbt/bip-segwit-gbt.mediawiki

Please review and comment (especially with regard to the changes in the 
sigoplimits handling).

(Note: libblkmaker's reference implementation is at this time incompatible 
with the "last output" rule in this BIP.)

Thanks,

Luke

