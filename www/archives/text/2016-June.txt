From cp368202 at ohiou.edu  Thu Jun  2 00:21:54 2016
From: cp368202 at ohiou.edu (Chris Priest)
Date: Wed, 1 Jun 2016 17:21:54 -0700
Subject: [bitcoin-dev] BIP draft: Memo server
Message-ID: <CAAcC9ysPMmTiEX3TS+=2t6FtNSYMXdz+h+qi=KQyTjS7CsbsxQ@mail.gmail.com>

I'm currently working on a wallet called multiexplorer. You can check
it at https://multiexplorer.com/wallet

It supports all the BIPs, including the ones that lets you export and
import based on a 12 word mnemonic. This lets you easily import
addresses from one wallet to the next. For instance, you can
copy+paste your 12 word mnemonic from Coinbase CoPay into
Multiexplorer wallet and all of your address and transaction history
is imported (except CoPay doesn't support altcoins, so it will just be
your BTC balance that shows up). Its actually pretty cool, but not
everything is transferred over.

For instance, some people like to add little notes such as "paid sally
for lunch at Taco Bell", or "Paid rent" to each transaction they make
through their wallet's UI. When you export and import into another
wallet these memos are lost, as there is no way for this data to be
encoded into the mnemonic.

For my next project, I want to make a stand alone system for archiving
and serving these memos. After it's been built and every wallet
supports the system, you should be able to move from one wallet by
just copy+pasting the mnemonic into the next wallet without losing
your memos. This will make it easier for people to move off of old
wallets that may not be safe anymore, to more modern wallets with
better security features. Some people may want to switch wallets, but
since its much harder to backup memos, people may feel stuck using a
certain wallet. This is bad because it creates lock in.

I wrote up some details of how the system will work:

https://github.com/priestc/bips/blob/master/memo-server.mediawiki

Basically the memos are encrypted and then sent to a server where the
memo is stored. An API exists that allows wallets to get the memos
through an HTTPS interface. There isn't one single memo server, but
multiple memo servers all ran by different people. These memo servers
share data amongst each other through a sync process.

The specifics of how the memos will be encrypted have not been set in
stone yet. The memos will be publicly propagated, so it is important
that they are encrypted strongly. I'm not a cryptography expert, so
someone else has to decide on the scheme that is appropriate.

From luke at dashjr.org  Thu Jun  2 00:41:27 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 2 Jun 2016 00:41:27 +0000
Subject: [bitcoin-dev] BIP draft: Memo server
In-Reply-To: <CAAcC9ysPMmTiEX3TS+=2t6FtNSYMXdz+h+qi=KQyTjS7CsbsxQ@mail.gmail.com>
References: <CAAcC9ysPMmTiEX3TS+=2t6FtNSYMXdz+h+qi=KQyTjS7CsbsxQ@mail.gmail.com>
Message-ID: <201606020041.30139.luke@dashjr.org>

First of all, and most importantly, I like the idea/concept.

The first issue I see is that this scheme exposes private information in the 
form of which inputs/outputs are related to the user. But IMO this information 
should also be private and kept encrypted, so memo servers don't have anything 
at all to leak. 

Note this necessarily means you can't reuse the keys for the blockchain UTXOs 
for memos. But such key reuse is also a risk that should be avoided anyway. 
Instead, I suggest encrypting all the memos to an arbitrary key which is 
derived from the HD seed and shouldn't ever be used for UTXOs.

Ideally, the memo server shouldn't be tied to a specific wallet schema. So the 
next step is to not tell the memo server anything except your memo-specific 
identifier (which can be a hash of a pubkey, or really anything at all - 
there's no reason the memo server needs to know ANYTHING about the user's 
wallet). Using an arbitrary identifier of sufficient length allows for future 
wallet schemas to continue to use the same memo servers. (The specifics on how 
to derive the identifier can be specified in a separate BIP to ensure wallets 
can be compatible with each other.)

I don't think there is a real need for memo servers to sync data. It should be 
sufficient for users to decide on two or more memo servers they wish to 
entrust their memos with, or possibly trust only their own memo server(s).

There should probably also be a way for memos of different types. Some wallets 
might only support simple memos, but others might associate more data for (eg) 
proof-of-existence schemas. What types are used *might* be desirable to 
encrypt as well, so this should probably be in the second "how wallets use it" 
BIP.

IIRC, Electrum already has some kind of "memo server" interface in a plugin. 
Have you looked at how it works, and considered its features (and/or flaws) 
for your proposal?

Finally, using "?data&data&data" doesn't follow the standard 
"?key=value&key=value" scheme; simple to fix.

Luke

On Thursday, June 02, 2016 12:21:54 AM Chris Priest via bitcoin-dev wrote:
> I'm currently working on a wallet called multiexplorer. You can check
> it at https://multiexplorer.com/wallet
> 
> It supports all the BIPs, including the ones that lets you export and
> import based on a 12 word mnemonic. This lets you easily import
> addresses from one wallet to the next. For instance, you can
> copy+paste your 12 word mnemonic from Coinbase CoPay into
> Multiexplorer wallet and all of your address and transaction history
> is imported (except CoPay doesn't support altcoins, so it will just be
> your BTC balance that shows up). Its actually pretty cool, but not
> everything is transferred over.
> 
> For instance, some people like to add little notes such as "paid sally
> for lunch at Taco Bell", or "Paid rent" to each transaction they make
> through their wallet's UI. When you export and import into another
> wallet these memos are lost, as there is no way for this data to be
> encoded into the mnemonic.
> 
> For my next project, I want to make a stand alone system for archiving
> and serving these memos. After it's been built and every wallet
> supports the system, you should be able to move from one wallet by
> just copy+pasting the mnemonic into the next wallet without losing
> your memos. This will make it easier for people to move off of old
> wallets that may not be safe anymore, to more modern wallets with
> better security features. Some people may want to switch wallets, but
> since its much harder to backup memos, people may feel stuck using a
> certain wallet. This is bad because it creates lock in.
> 
> I wrote up some details of how the system will work:
> 
> https://github.com/priestc/bips/blob/master/memo-server.mediawiki
> 
> Basically the memos are encrypted and then sent to a server where the
> memo is stored. An API exists that allows wallets to get the memos
> through an HTTPS interface. There isn't one single memo server, but
> multiple memo servers all ran by different people. These memo servers
> share data amongst each other through a sync process.
> 
> The specifics of how the memos will be encrypted have not been set in
> stone yet. The memos will be publicly propagated, so it is important
> that they are encrypted strongly. I'm not a cryptography expert, so
> someone else has to decide on the scheme that is appropriate.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jl2012 at xbt.hk  Wed Jun  8 05:57:36 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Wed, 8 Jun 2016 13:57:36 +0800
Subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of
	witness program definition
Message-ID: <A7E9BC23-6860-4B31-9D4E-11F771A5E581@xbt.hk>

Please note that the segregated witness (BIP141) consensus rule is updated. Originally, a witness program is a scriptPubKey or redeemScript that consists of a 1-byte push opcode (OP_0 to OP_16) followed by a data push between 2 and 32 bytes. The definition is now extended to 2 to 40 bytes:
https://github.com/bitcoin/bips/commit/d1b52cb198066d4e515e8a50fc3928c5397c3d9b https://github.com/bitcoin/bitcoin/pull/7910/commits/14d4d1d23a3cbaa8a3051d0da10ff7a536517ed0


Why?
----------
BIP141 defines only version 0 witness program: 20 bytes program for P2WPKH and 32 bytes program for P2WSH. Versions 1 to 16 are not defined, and are considered as anyone-can-spend scripts, reserved for future extension (e.g. the proposed BIP114). BIP141 also requires that only a witness program input may have witness data. Therefore, before this update, an 1-byte push opcode followed by a 33 bytes data push was not considered to be a witness program, and no witness data is allowed for that.

This may be over-restrictive for a future witness program softfork. When 32-byte program is used, this leaves only 16 versions for upgrade, and any ?sub-version? metadata must be recorded in the witness field. This may not be compatible with some novel hashing functions we are exploring.

By extending the maximum length by 8 bytes, it allows up to 16 * 2 ^ 64 versions for future upgrades, which is enough for any foreseeable use.


Why not make it even bigger, e.g. 75 bytes?
----------
A 40 bytes witness program allows a 32-byte hash with 8-byte metadata. For any scripts that are larger than 32 bytes, they should be recorded in the witness field, like P2WSH in BIP141, to reduce the transaction cost and impact on UTXO set. Since SHA256 is already used everywhere, it is very unlikely that we would require a larger witness program (e.g. SHA512) without also a major revamp of the bitcoin protocol.

In any case, since scripts with a 1-byte push followed by a push of >40 bytes remain anyone-can-spend, we always have the option to redefine them with a softfork.


What are affected?
----------
As defined in BIP141, a version 0 witness program is valid only with 20 bytes (P2WPKH) or 32 bytes (P2WSH). Before this update, an OP_0 followed by a data push of 33-40 bytes was not a witness program and considered as anyone-can-spend. Now, such a script will fail due to incorrect witness program length.

Before this update, no witness data was allowed for a script with a 1-byte push followed by a data push of 33-40 bytes. This is now allowed.



Actions to take:
----------
If you are running a segnet node, or a testnet node with segwit code, please upgrade to the latest version at https://github.com/bitcoin/bitcoin/pull/7910

If you have an alternative implementation, please make sure your consensus code is updated accordingly, or your node may fork off the network.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 671 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160608/cbf69a4f/attachment.sig>

From luke at dashjr.org  Wed Jun  8 07:29:22 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 8 Jun 2016 07:29:22 +0000
Subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of
	witness program definition
In-Reply-To: <A7E9BC23-6860-4B31-9D4E-11F771A5E581@xbt.hk>
References: <A7E9BC23-6860-4B31-9D4E-11F771A5E581@xbt.hk>
Message-ID: <201606080729.24789.luke@dashjr.org>

On Wednesday, June 08, 2016 5:57:36 AM Johnson Lau via bitcoin-dev wrote:
> Why not make it even bigger, e.g. 75 bytes?

I don't see a sufficient answer to this question. Pieter explained why >75 
would be annoying, but 75 seems like it should be fine.

> In any case, since scripts with a 1-byte push followed by a push of >40
> bytes remain anyone-can-spend, we always have the option to redefine them
> with a softfork.

It's not that simple, since this is preventing use of the witness field for 
such scripts. With this limit in place, any such a softfork would suddenly 
require either two different witness commitments, or disabling the previous 
witness transaction format.

Luke

From jl2012 at xbt.hk  Wed Jun  8 08:23:51 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Wed, 8 Jun 2016 16:23:51 +0800
Subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of
	witness program definition
In-Reply-To: <201606080729.24789.luke@dashjr.org>
References: <A7E9BC23-6860-4B31-9D4E-11F771A5E581@xbt.hk>
	<201606080729.24789.luke@dashjr.org>
Message-ID: <D192E876-1A4F-4B06-86F6-54F1BDEC857D@xbt.hk>


> On 8 Jun 2016, at 15:29, Luke Dashjr <luke at dashjr.org> wrote:
> 
> On Wednesday, June 08, 2016 5:57:36 AM Johnson Lau via bitcoin-dev wrote:
>> Why not make it even bigger, e.g. 75 bytes?
> 
> I don't see a sufficient answer to this question. Pieter explained why >75
> would be annoying, but 75 seems like it should be fine.
> 
>> In any case, since scripts with a 1-byte push followed by a push of >40
>> bytes remain anyone-can-spend, we always have the option to redefine them
>> with a softfork.
> 
> It's not that simple, since this is preventing use of the witness field for
> such scripts. With this limit in place, any such a softfork would suddenly
> require either two different witness commitments, or disabling the previous
> witness transaction format.
> 
> Luke

This is exactly why I proposed to extend the definition. My initial proposal was extending it to 33 bytes to effectively allow 16*256 new script versions, assuming we will keep using 32 bytes program hash.

If someday 32 bytes hash is deemed to be unsafe, the txid would also be unsafe and a hard fork might be needed. Therefore, I don?t see how a witness program larger than 40 bytes would be useful in any case (as it is more expensive and takes more UTXO space). I think Pieter doesn?t want to make it unnecessarily lenient.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 671 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160608/b00c1e10/attachment.sig>

From luke at dashjr.org  Wed Jun  8 16:45:10 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 8 Jun 2016 16:45:10 +0000
Subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of
	witness program definition
In-Reply-To: <D192E876-1A4F-4B06-86F6-54F1BDEC857D@xbt.hk>
References: <A7E9BC23-6860-4B31-9D4E-11F771A5E581@xbt.hk>
	<201606080729.24789.luke@dashjr.org>
	<D192E876-1A4F-4B06-86F6-54F1BDEC857D@xbt.hk>
Message-ID: <201606081645.12598.luke@dashjr.org>

On Wednesday, June 08, 2016 8:23:51 AM Johnson Lau wrote:
> If someday 32 bytes hash is deemed to be unsafe, the txid would also be
> unsafe and a hard fork might be needed. Therefore, I don?t see how a
> witness program larger than 40 bytes would be useful in any case (as it is
> more expensive and takes more UTXO space). I think Pieter doesn?t want to
> make it unnecessarily lenient.

There is no harm in being lenient, but it limits the ability to do softfork 
upgrades in the future. I appreciate Pieter's concern that we'd need to do 
more development and testing to go to this extreme, which is why I am only 
asking the limit raised to 75 bytes.

Luke

From alfie at alfie.wtf  Wed Jun  8 23:47:28 2016
From: alfie at alfie.wtf (Alfie John)
Date: Wed, 8 Jun 2016 23:47:28 +0000
Subject: [bitcoin-dev] BIP 151 MITM
Message-ID: <20160608234728.GQ32334@dosf1.alfie.wtf>

Hi folks,

Overall I think BIP 151 is a good idea. However unless I'm mistaken, what's to
prevent someone between peers to suppress the initial 'encinit' message during
negotiation, causing both to fallback to plaintext?

Peers should negotiate a secure channel from the outset or backout entirely
with no option of falling back. This can be indicated loudly by the daemon
listening on an entirely new port.

Alfie

-- 
Alfie John
https://www.alfie.wtf

From greg at xiph.org  Thu Jun  9 01:24:09 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 9 Jun 2016 01:24:09 +0000
Subject: [bitcoin-dev] BIP 151 MITM
In-Reply-To: <20160608234728.GQ32334@dosf1.alfie.wtf>
References: <20160608234728.GQ32334@dosf1.alfie.wtf>
Message-ID: <CAAS2fgTtu8nqwgrO1u8SRuga6ozcYt7NEDR_tv+cuA3uqgtKvA@mail.gmail.com>

On Wed, Jun 8, 2016 at 11:47 PM, Alfie John via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi folks,
>
> Overall I think BIP 151 is a good idea. However unless I'm mistaken, what's to
> prevent someone between peers to suppress the initial 'encinit' message during
> negotiation, causing both to fallback to plaintext?
>
> Peers should negotiate a secure channel from the outset or backout entirely
> with no option of falling back. This can be indicated loudly by the daemon
> listening on an entirely new port.

Reduction to plaintext isn't an interesting attack vector for an
active attacker: they can simply impersonate the remote side.

This is addressed via authentication, where available, which is done
by a separate specification that builds on this one.

Without authentication this only provides protection against passive attackers.

From alfie at alfie.wtf  Thu Jun  9 01:42:59 2016
From: alfie at alfie.wtf (Alfie John)
Date: Thu, 9 Jun 2016 01:42:59 +0000
Subject: [bitcoin-dev] BIP 151 MITM
In-Reply-To: <CAAS2fgTtu8nqwgrO1u8SRuga6ozcYt7NEDR_tv+cuA3uqgtKvA@mail.gmail.com>
References: <20160608234728.GQ32334@dosf1.alfie.wtf>
	<CAAS2fgTtu8nqwgrO1u8SRuga6ozcYt7NEDR_tv+cuA3uqgtKvA@mail.gmail.com>
Message-ID: <20160609014259.GT32334@dosf1.alfie.wtf>

On Thu, Jun 09, 2016 at 01:24:09AM +0000, Gregory Maxwell wrote:
> Reduction to plaintext isn't an interesting attack vector for an active
> attacker: they can simply impersonate the remote side.
>
> This is addressed via authentication, where available, which is done by a
> separate specification that builds on this one.

Are there any links to discussions on how authentication may be done?

Thanks,

Alfie

-- 
Alfie John
https://www.alfie.wtf

From dev at jonasschnelli.ch  Thu Jun  9 06:57:29 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 9 Jun 2016 08:57:29 +0200
Subject: [bitcoin-dev] BIP 151 MITM
In-Reply-To: <20160609014259.GT32334@dosf1.alfie.wtf>
References: <20160608234728.GQ32334@dosf1.alfie.wtf>
	<CAAS2fgTtu8nqwgrO1u8SRuga6ozcYt7NEDR_tv+cuA3uqgtKvA@mail.gmail.com>
	<20160609014259.GT32334@dosf1.alfie.wtf>
Message-ID: <57591359.4050607@jonasschnelli.ch>

Hi

> On Thu, Jun 09, 2016 at 01:24:09AM +0000, Gregory Maxwell wrote:
>> Reduction to plaintext isn't an interesting attack vector for an active
>> attacker: they can simply impersonate the remote side.
>>
>> This is addressed via authentication, where available, which is done by a
>> separate specification that builds on this one.
> 
> Are there any links to discussions on how authentication may be done?

I'm currently working on the Auth-BIP which is not worth reviewing it
right now (I will post it to the mailing list once it has been reached a
stable level where it can be discusses).

If you can't wait, here is the current work:
https://github.com/jonasschnelli/bips/blob/35d7e382cdd6955ff42726c3d06c44e33f61ae52/bip-undef-0.mediawiki


Most recent MITM/auth discussion (there where plenty of discussions on
IRC about this topic):
https://botbot.me/freenode/bitcoin-core-dev/2016-04-04/?msg=63463826&page=3


</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160609/8f75bb8c/attachment.sig>

From alfie at alfie.wtf  Thu Jun  9 07:00:51 2016
From: alfie at alfie.wtf (Alfie John)
Date: Thu, 9 Jun 2016 07:00:51 +0000
Subject: [bitcoin-dev] BIP 151 MITM
In-Reply-To: <57591359.4050607@jonasschnelli.ch>
References: <20160608234728.GQ32334@dosf1.alfie.wtf>
	<CAAS2fgTtu8nqwgrO1u8SRuga6ozcYt7NEDR_tv+cuA3uqgtKvA@mail.gmail.com>
	<20160609014259.GT32334@dosf1.alfie.wtf>
	<57591359.4050607@jonasschnelli.ch>
Message-ID: <20160609070051.GV32334@dosf1.alfie.wtf>

On Thu, Jun 09, 2016 at 08:57:29AM +0200, Jonas Schnelli via bitcoin-dev wrote:
> > Are there any links to discussions on how authentication may be done?
> 
> I'm currently working on the Auth-BIP which is not worth reviewing it
> right now (I will post it to the mailing list once it has been reached a
> stable level where it can be discusses).
> 
> If you can't wait, here is the current work:
> https://github.com/jonasschnelli/bips/blob/35d7e382cdd6955ff42726c3d06c44e33f61ae52/bip-undef-0.mediawiki
> 
> Most recent MITM/auth discussion (there where plenty of discussions on
> IRC about this topic):
> https://botbot.me/freenode/bitcoin-core-dev/2016-04-04/?msg=63463826&page=3

Awesome, thanks for the link Jonas.

Alfie

-- 
Alfie John
https://www.alfie.wtf

From pieter.wuille at gmail.com  Sun Jun 12 14:40:17 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Sun, 12 Jun 2016 16:40:17 +0200
Subject: [bitcoin-dev] BIP141 segwit consensus rule update: extension of
 witness program definition
In-Reply-To: <201606081645.12598.luke@dashjr.org>
References: <A7E9BC23-6860-4B31-9D4E-11F771A5E581@xbt.hk>
	<201606080729.24789.luke@dashjr.org>
	<D192E876-1A4F-4B06-86F6-54F1BDEC857D@xbt.hk>
	<201606081645.12598.luke@dashjr.org>
Message-ID: <CAPg+sBjXctdezfSbi1y7KVpNS4BwD6HESCgZLNaQGqDotVtwGQ@mail.gmail.com>

On Jun 8, 2016 18:46, "Luke Dashjr via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Wednesday, June 08, 2016 8:23:51 AM Johnson Lau wrote:
> > If someday 32 bytes hash is deemed to be unsafe, the txid would also be
> > unsafe and a hard fork might be needed. Therefore, I don?t see how a
> > witness program larger than 40 bytes would be useful in any case (as it
is
> > more expensive and takes more UTXO space). I think Pieter doesn?t want
to
> > make it unnecessarily lenient.
>
> There is no harm in being lenient, but it limits the ability to do
softfork
> upgrades in the future. I appreciate Pieter's concern that we'd need to do
> more development and testing to go to this extreme, which is why I am only
> asking the limit raised to 75 bytes.

No strong opinion, but I'd rather not change it anymore, as I don't see the
point. Any data you would want to encode there can be moved to the witness
at 1/4 the cost and replaced by a 256-bit hash. If the data is 43 bytes or
higher, that is even cheaper. The only thing that cannot be in the hash is
metadata to indicate what hashing/rule scheme itself is used. I think 68
bits (OP_n + 8 bytes) for that is plenty.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160612/ff54a257/attachment.html>

From Daniel.Weigl at mycelium.com  Tue Jun 14 15:41:15 2016
From: Daniel.Weigl at mycelium.com (Daniel Weigl)
Date: Tue, 14 Jun 2016 17:41:15 +0200
Subject: [bitcoin-dev] RFC for BIP: Derivation scheme for
 P2WPKH-nested-in-P2SH based accounts
Message-ID: <5760259B.7040409@mycelium.com>

Hi List,

Following up to the discussion last month ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012695.html ), ive prepared a proposal for a BIP here:
	
	https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki


Any comments on it? Does anyone working on a BIP44 compliant wallet implement something different?
If there are no objection, id also like to request a number for it.

Thx,
Daniel

From bram at bittorrent.com  Wed Jun 15 00:14:23 2016
From: bram at bittorrent.com (Bram Cohen)
Date: Tue, 14 Jun 2016 17:14:23 -0700
Subject: [bitcoin-dev] Merkle trees and mountain ranges
Message-ID: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>

This is in response to Peter Todd's proposal for Merkle Mountain Range
commitments in blocks:

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html

I'm in strong agreement that there's a compelling need to put UTXO
commitments in blocks, and that the big barrier to getting it done is
performance, particularly latency. But I have strong disagreements (or
perhaps the right word is skepticism) about the details.

Peter proposes that there should be both UTXO and STXO commitments, and
they should be based on Merkle Mountain Ranges based on Patricia Tries. My
first big disagreement is about the need for STXO commitments. I think
they're unnecessary and a performance problem. The STXO set is much larger
than the utxo set and requires much more memory and horespower to maintain.
Most if not all of its functionality can in practice be done using the utxo
set. Almost anything accepting proofs of inclusion and exclusion will have
a complete history of block headers, so to prove inclusion in the stxo set
you can use a utxo proof of inclusion in the past and a proof of exclusion
for the most recent block. In the case of a txo which has never been
included at all, it's generally possible to show that an ancestor of the
txo in question was at one point included but that an incompatible
descendant of it (or the ancestor itself) is part of the current utxo set.
Generating these sorts of proofs efficiently can for some applications
require a complete STXO set, but that can done with a non-merkle set,
getting the vastly better performance of an ordinary non-cryptographic
hashtable.

The fundamental approach to handling the latency problem is to have the
utxo commitments trail a bit. Computing utxo commitments takes a certain
amount of time, too much to hold up block propagation but still hopefully
vastly less than the average amount of time between blocks. Trailing by a
single block is probably a bad idea because you sometimes get blocks back
to back, but you never get blocks back to back to back to back. Having the
utxo set be trailing by a fixed amount - five blocks is probably excessive
- would do a perfectly good job of keeping latency from every becoming an
issue. Smaller commitments for the utxos added and removed in each block
alone could be added without any significant performance penalty. That way
all blocks would have sufficient commitments for a completely up to date
proofs of inclusion and exclusion. This is not a controversial approach.

Now I'm going to go out on a limb. My thesis is that usage of a mountain
range is unnecessary, and that a merkle tree in the raw can be made
serviceable by sprinkling magic pixie dust on the performance problem.

There are two causes of performance problems for merkle trees: hashing
operations and memory cache misses. For hashing functions, the difference
between a mountain range and a straight merkle tree is roughly that in a
mountain range there's one operation for each new update times the number
of times that thing will get merged into larger hills. If there are fewer
levels of hills the number of operations is less but the expense of proof
of inclusion will be larger. For raw merkle trees the number of operations
per thing added is the log base 2 of the number of levels in the tree,
minus the log base 2 of the number of things added at once since you can do
lazy evaluation. For practical Bitcoin there are (very roughly) a million
things stored, or 20 levels, and there are (even more roughly) about a
thousand things stored per block, so each thing forces about 20 - 10 = 10
operations. If you follow the fairly reasonable guideline of mountain range
hills go up by factors of four, you instead have 20/2 = 10 operations per
thing added amortized. Depending on details this comparison can go either
way but it's roughly a wash and the complexity of a mountain range is
clearly not worth it at least from the point of view of CPU costs.

But CPU costs aren't the main performance problem in merkle trees. The
biggest issues is cache misses, specifically l1 and l2 cache misses. These
tend to take a long time to do, resulting in the CPU spending most of its
time sitting around doing nothing. A naive tree implementation is pretty
much the worst thing you can possibly build from a cache miss standpoint,
and its performance will be completely unacceptable. Mountain ranges do a
fabulous job of fixing this problem, because all their updates are merges
so the metrics are more like cache misses per block instead of cache misses
per transaction.

The magic pixie dust I mentioned earlier involves a bunch of subtle
implementation details to keep cache coherence down which should get the
number of cache misses per transaction down under one, at which point it
probably isn't a bottleneck any more. There is an implementation in the
works here:

https://github.com/bramcohen/MerkleSet

This implementation isn't finished yet! I'm almost there, and I'm
definitely feeling time pressure now. I've spent quite a lot of time on
this, mostly because of a bunch of technical reworkings which proved
necessary. This is the last time I ever write a database for kicks. But
this implementation is good on all important dimensions, including:

Lazy root calculation
Few l1 and l2 cache misses
Small proofs of inclusion/exclusion
Reasonably simple implementation
Reasonably efficient in memory
Reasonable defense against malicious insertion attacks

There is a bit of a false dichotomy with the mountain range approach.
Mountain ranges need underlying merkle trees, and mine are semantically
nearly identically to Peter's. This is not a coincidence - I adopted
patricia tries at his suggestion. There are a bunch of small changes which
allow a more efficient implementation. I believe that my underlying merkle
tree is unambiguously superior in every way, but the question of whether a
mountain range is worth it is one which can only be answered empirically,
and that requires a bunch of implementation work to be done, starting with
me finishing my merkle tree implementation and then somebody porting it to
C and optimizing it. The Python version has details which are ridiculous
and only make sense once it gets ported, and even under the best of
conditions Python performance is not strongly indicative of C performance.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160614/a1bc30c1/attachment.html>

From hoenicke at gmail.com  Wed Jun 15 10:26:47 2016
From: hoenicke at gmail.com (Jochen Hoenicke)
Date: Wed, 15 Jun 2016 12:26:47 +0200
Subject: [bitcoin-dev] RFC for BIP: Derivation scheme for
 P2WPKH-nested-in-P2SH based accounts
In-Reply-To: <5760259B.7040409@mycelium.com>
References: <5760259B.7040409@mycelium.com>
Message-ID: <57612D67.9080007@gmail.com>

Hello Daniel,

Am 14.06.2016 um 17:41 schrieb Daniel Weigl via bitcoin-dev:
> Hi List,
> 
> Following up to the discussion last month ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012695.html ), ive prepared a proposal for a BIP here:
> 	
> 	https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki
> 
> 
> Any comments on it? Does anyone working on a BIP44 compliant wallet implement something different?
> If there are no objection, id also like to request a number for it.

thank you for going forward with this.  Should we keep the discussion on
the list, or should we make it on github?

I think we should already consider not only P2WPKH over P2SH addresses
but also "native" P2WPKH addresses.  Instead of having one BIP for these
two kinds of segwit addresses and forcing the user to have several
different accounts for each BIP, the idea would be that every fully
BIP?? compatible wallet must support both of them.  Since P2WPKH is
simpler than P2WPKH over P2SH, this is IMHO reasonable to require.

I would go with the suggestion from Aaron Voisine to use different chain
id's to distinguish between different address types.   E.g., 0,1 for
P2WPKH over P2SH and 2,3 for native P2WPKH.  I see no reason why a
wallet would want to use P2WPKH over P2SH for change addresses instead
of native P2WPKH, though.

  Jochen


From Daniel.Weigl at mycelium.com  Wed Jun 15 10:53:27 2016
From: Daniel.Weigl at mycelium.com (Daniel Weigl)
Date: Wed, 15 Jun 2016 12:53:27 +0200
Subject: [bitcoin-dev] RFC for BIP: Derivation scheme for
 P2WPKH-nested-in-P2SH based accounts
In-Reply-To: <57612D67.9080007@gmail.com>
References: <5760259B.7040409@mycelium.com> <57612D67.9080007@gmail.com>
Message-ID: <576133A7.6070004@mycelium.com>

Hello Jochen,

> I think we should already consider not only P2WPKH over P2SH addresses
> but also "native" P2WPKH addresses.  Instead of having one BIP for these
[...]
> BIP?? compatible wallet must support both of them.  Since P2WPKH is
> simpler than P2WPKH over P2SH, this is IMHO reasonable to require.
[...]
> E.g., 0,1 for
> P2WPKH over P2SH and 2,3 for native P2WPKH.  I see no reason why a

Thats a good point and should be simple to maintain. Yes, ill extend on that part.

The problem is, we dont have a final decision how the address encoding for P2WPKH 
public keys should look like. Or do we? Bip141 is "Status: Deferred"

But for now, I can at least include the public key derivation path.

> I see no reason why a
> wallet would want to use P2WPKH over P2SH for change addresses instead
> of native P2WPKH, though.

That would be a big privacy leak, imo. As soon as both outputs are spent, its visible 
which one was the P2WPKH-in-P2SH and which one the pure P2WPKH and as a consequence
you leak which output was the change and which one the actual sent output

So, i'd suggest to even make it a requirement for "normal" send-to-single-address transactions
to always use the same output type for the change output (if the wallet is able to recognize it)

Daniel

On 2016-06-15 12:26, Jochen Hoenicke wrote:
> Hello Daniel,
> 
> Am 14.06.2016 um 17:41 schrieb Daniel Weigl via bitcoin-dev:
>> Hi List,
>>
>> Following up to the discussion last month ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012695.html ), ive prepared a proposal for a BIP here:
>> 	
>> 	https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki
>>
>>
>> Any comments on it? Does anyone working on a BIP44 compliant wallet implement something different?
>> If there are no objection, id also like to request a number for it.
> 
> thank you for going forward with this.  Should we keep the discussion on
> the list, or should we make it on github?
> 
> I think we should already consider not only P2WPKH over P2SH addresses
> but also "native" P2WPKH addresses.  Instead of having one BIP for these
> two kinds of segwit addresses and forcing the user to have several
> different accounts for each BIP, the idea would be that every fully
> BIP?? compatible wallet must support both of them.  Since P2WPKH is
> simpler than P2WPKH over P2SH, this is IMHO reasonable to require.
> 
> I would go with the suggestion from Aaron Voisine to use different chain
> id's to distinguish between different address types.   E.g., 0,1 for
> P2WPKH over P2SH and 2,3 for native P2WPKH.  I see no reason why a
> wallet would want to use P2WPKH over P2SH for change addresses instead
> of native P2WPKH, though.
> 
>   Jochen
> 

From pieter.wuille at gmail.com  Wed Jun 15 11:00:42 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 15 Jun 2016 13:00:42 +0200
Subject: [bitcoin-dev] RFC for BIP: Derivation scheme for
 P2WPKH-nested-in-P2SH based accounts
In-Reply-To: <576133A7.6070004@mycelium.com>
References: <5760259B.7040409@mycelium.com> <57612D67.9080007@gmail.com>
	<576133A7.6070004@mycelium.com>
Message-ID: <CAPg+sBj_9A8gmqRhs3Yg1+rVubdPLMxUhbcrGovF22RgCfVbrw@mail.gmail.com>

On Jun 15, 2016 12:53, "Daniel Weigl via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> That would be a big privacy leak, imo. As soon as both outputs are spent,
its visible
> which one was the P2WPKH-in-P2SH and which one the pure P2WPKH and as a
consequence
> you leak which output was the change and which one the actual sent output
>
> So, i'd suggest to even make it a requirement for "normal"
send-to-single-address transactions
> to always use the same output type for the change output (if the wallet
is able to recognize it)

Indeed, and you can go even further. When there are multiple "sending"
outputs, pick one at random, and mimic it for the change output. This means
that if you have a P2PKH and 3 P2SH sends, you'll have 25% chance for a
P2PKH change output, and 75% chance for a P2SH output.

You can go even further of course, if you want privacy that remains after
those sends get spent. In that case, you also need to match the template of
the redeemscript/witnessscript. For example, if the send you are mimicking
is a 2-of-3, the change output should also use 2-of-3.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160615/35a22171/attachment.html>

From roconnor at blockstream.io  Wed Jun 15 17:08:13 2016
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 15 Jun 2016 13:08:13 -0400
Subject: [bitcoin-dev] RFC for BIP: Derivation scheme for
 P2WPKH-nested-in-P2SH based accounts
In-Reply-To: <CAPg+sBj_9A8gmqRhs3Yg1+rVubdPLMxUhbcrGovF22RgCfVbrw@mail.gmail.com>
References: <5760259B.7040409@mycelium.com> <57612D67.9080007@gmail.com>
	<576133A7.6070004@mycelium.com>
	<CAPg+sBj_9A8gmqRhs3Yg1+rVubdPLMxUhbcrGovF22RgCfVbrw@mail.gmail.com>
Message-ID: <CAMZUoKkaJWAo0MUxObJXRwBXzTKL-jGnNZg9d7aTjshP3Au_Ag@mail.gmail.com>

On Wed, Jun 15, 2016 at 7:00 AM, Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

Indeed, and you can go even further. When there are multiple "sending"
> outputs, pick one at random, and mimic it for the change output. This means
> that if you have a P2PKH and 3 P2SH sends, you'll have 25% chance for a
> P2PKH change output, and 75% chance for a P2SH output.
>

This isn't quite perfect because if there is only 1 P2PKH output and you
know the person is using the above algorithm then you know the P2PKH output
isn't the change.

I don't know what the perfect method is.  My guess is that it is to let p
be the probability that a P2PKH output is produced over the entire network
and to pick P2PKH for your change output with probability p (and similarly
for other output types).

On Wed, Jun 15, 2016 at 7:00 AM, Pieter Wuille via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> On Jun 15, 2016 12:53, "Daniel Weigl via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > That would be a big privacy leak, imo. As soon as both outputs are
> spent, its visible
> > which one was the P2WPKH-in-P2SH and which one the pure P2WPKH and as a
> consequence
> > you leak which output was the change and which one the actual sent output
> >
> > So, i'd suggest to even make it a requirement for "normal"
> send-to-single-address transactions
> > to always use the same output type for the change output (if the wallet
> is able to recognize it)
>
> Indeed, and you can go even further. When there are multiple "sending"
> outputs, pick one at random, and mimic it for the change output. This means
> that if you have a P2PKH and 3 P2SH sends, you'll have 25% chance for a
> P2PKH change output, and 75% chance for a P2SH output.
>
> You can go even further of course, if you want privacy that remains after
> those sends get spent. In that case, you also need to match the template of
> the redeemscript/witnessscript. For example, if the send you are mimicking
> is a 2-of-3, the change output should also use 2-of-3.
>
> --
> Pieter
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160615/a1642a0d/attachment.html>

From pete at petertodd.org  Thu Jun 16 00:10:40 2016
From: pete at petertodd.org (Peter Todd)
Date: Wed, 15 Jun 2016 20:10:40 -0400
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
Message-ID: <20160616001040.GA5026@fedora-21-dvm>

On Tue, Jun 14, 2016 at 05:14:23PM -0700, Bram Cohen via bitcoin-dev wrote:
> This is in response to Peter Todd's proposal for Merkle Mountain Range
> commitments in blocks:
> 
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html
> 
> I'm in strong agreement that there's a compelling need to put UTXO
> commitments in blocks, and that the big barrier to getting it done is
> performance, particularly latency. But I have strong disagreements (or
> perhaps the right word is skepticism) about the details.
> 
> Peter proposes that there should be both UTXO and STXO commitments, and

No, that's incorrect - I'm only proposing TXO commitments, not UTXO nor STXO
commitments.

> they should be based on Merkle Mountain Ranges based on Patricia Tries. My
> first big disagreement is about the need for STXO commitments. I think
> they're unnecessary and a performance problem. The STXO set is much larger
> than the utxo set and requires much more memory and horespower to maintain.

Again, I'm not proposing STXO commitments precisely because the set of _spent_
transactions grows without bound. TXO commitments with committed sums of
remaining unspent TXO's and with pruning of old history are special in this
regard, because once spent the data associated with spent transactions can be
discarded completely, and at the same time, data associated with old history
can be pruned with responsibility for keeping it resting on the shoulders of
those owning those coins.

> Most if not all of its functionality can in practice be done using the utxo
> set. Almost anything accepting proofs of inclusion and exclusion will have
> a complete history of block headers, so to prove inclusion in the stxo set
> you can use a utxo proof of inclusion in the past and a proof of exclusion
> for the most recent block. In the case of a txo which has never been
> included at all, it's generally possible to show that an ancestor of the
> txo in question was at one point included but that an incompatible
> descendant of it (or the ancestor itself) is part of the current utxo set.
> Generating these sorts of proofs efficiently can for some applications
> require a complete STXO set, but that can done with a non-merkle set,
> getting the vastly better performance of an ordinary non-cryptographic
> hashtable.

TXO commitments allows you to do all of this without requiring miners to have
unbounded storage to create new blocks.

> The fundamental approach to handling the latency problem is to have the
> utxo commitments trail a bit. Computing utxo commitments takes a certain
> amount of time, too much to hold up block propagation but still hopefully
> vastly less than the average amount of time between blocks. Trailing by a
> single block is probably a bad idea because you sometimes get blocks back
> to back, but you never get blocks back to back to back to back. Having the
> utxo set be trailing by a fixed amount - five blocks is probably excessive
> - would do a perfectly good job of keeping latency from every becoming an
> issue. Smaller commitments for the utxos added and removed in each block
> alone could be added without any significant performance penalty. That way
> all blocks would have sufficient commitments for a completely up to date
> proofs of inclusion and exclusion. This is not a controversial approach.

Agreed - regardless of approach adding latency to commitment calculations of
all kinds is something I think we all agree can work in principle, although
obviously it should be a last resort technique when optimization fails.

> Now I'm going to go out on a limb. My thesis is that usage of a mountain
> range is unnecessary, and that a merkle tree in the raw can be made
> serviceable by sprinkling magic pixie dust on the performance problem.

It'd help if you specified exactly what type of merkle tree you're talking
about here; remember that the certificate transparency RFC appears to have
reinvented merkle mountain ranges, and they call them "merkle trees".  Bitcoin
meanwhile uses a so-called "merkle tree" that's broken, and Zcash uses a
partially filled fixed-sized perfect tree.

> There are two causes of performance problems for merkle trees: hashing
> operations and memory cache misses. For hashing functions, the difference
> between a mountain range and a straight merkle tree is roughly that in a
> mountain range there's one operation for each new update times the number
> of times that thing will get merged into larger hills. If there are fewer
> levels of hills the number of operations is less but the expense of proof
> of inclusion will be larger. For raw merkle trees the number of operations
> per thing added is the log base 2 of the number of levels in the tree,
> minus the log base 2 of the number of things added at once since you can do
> lazy evaluation. For practical Bitcoin there are (very roughly) a million
> things stored, or 20 levels, and there are (even more roughly) about a
> thousand things stored per block, so each thing forces about 20 - 10 = 10
> operations. If you follow the fairly reasonable guideline of mountain range
> hills go up by factors of four, you instead have 20/2 = 10 operations per
> thing added amortized. Depending on details this comparison can go either
> way but it's roughly a wash and the complexity of a mountain range is
> clearly not worth it at least from the point of view of CPU costs.

I'm having a hard time understanding this paragraph; could you explain what you
think is happening when things are "merged into larger hills"?

> But CPU costs aren't the main performance problem in merkle trees. The
> biggest issues is cache misses, specifically l1 and l2 cache misses. These
> tend to take a long time to do, resulting in the CPU spending most of its
> time sitting around doing nothing. A naive tree implementation is pretty
> much the worst thing you can possibly build from a cache miss standpoint,
> and its performance will be completely unacceptable. Mountain ranges do a
> fabulous job of fixing this problem, because all their updates are merges
> so the metrics are more like cache misses per block instead of cache misses
> per transaction.
>
> The magic pixie dust I mentioned earlier involves a bunch of subtle
> implementation details to keep cache coherence down which should get the
> number of cache misses per transaction down under one, at which point it
> probably isn't a bottleneck any more. There is an implementation in the
> works here:

As UTXO/STXO/TXO sets are all enormously larger than L1/L2 cache, it's
impossible to get CPU cache misses below one for update operations. The closest
thing to an exception is MMR's, which due to their insertion-ordering could
have good cache locality for appends, in the sense that the mountain tips
required to recalculate the MMR tip digest will already be in cache from the
previous append. But that's not sufficient, as you also need to modify old
TXO's further back in the tree to mark them as spent - that data is going to be
far larger than L1/L2 cache.

> https://github.com/bramcohen/MerkleSet
> 
> This implementation isn't finished yet! I'm almost there, and I'm
> definitely feeling time pressure now. I've spent quite a lot of time on
> this, mostly because of a bunch of technical reworkings which proved
> necessary. This is the last time I ever write a database for kicks. But
> this implementation is good on all important dimensions, including:
> 
> Lazy root calculation
> Few l1 and l2 cache misses
> Small proofs of inclusion/exclusion

Have you looked at the pruning system that my proofchains work implements?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160615/9afd4c09/attachment.sig>

From bram at bittorrent.com  Thu Jun 16 01:16:26 2016
From: bram at bittorrent.com (Bram Cohen)
Date: Wed, 15 Jun 2016 18:16:26 -0700
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <20160616001040.GA5026@fedora-21-dvm>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
Message-ID: <CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>

On Wed, Jun 15, 2016 at 5:10 PM, Peter Todd <pete at petertodd.org> wrote:

> On Tue, Jun 14, 2016 at 05:14:23PM -0700, Bram Cohen via bitcoin-dev wrote:
> >
> > Peter proposes that there should be both UTXO and STXO commitments, and
>
> No, that's incorrect - I'm only proposing TXO commitments, not UTXO nor
> STXO
> commitments.
>

What do you mean by TXO commitments? If you mean that it only records
insertions rather than deletions, then that can do many of the same proofs
but has no way of proving that something is currently in the UTXO set,
which is functionality I'd like to provide.

When I say 'merkle tree' what I mean is a patricia trie. What I assume is
meant by a merkle mountain range is a series of patricia tries of
decreasing size each of which is an addition to the previous one, and
they're periodically consolidated into larger tries so the old ones can go
away. This data structure has the nice property that it's both in sorted
order and has less than one cache miss per operation because the
consolidation operations can be batched and done linearly. There are a
number of different things you could be describing if I misunderstood.


> I'm not proposing STXO commitments precisely because the set of _spent_
> transactions grows without bound.


I'm worried that once there's real transaction fees everyone might stop
consolidating dust and the set of unspent transactions might grow without
bound as well, but that's a topic for another day.


> > Now I'm going to go out on a limb. My thesis is that usage of a mountain
> > range is unnecessary, and that a merkle tree in the raw can be made
> > serviceable by sprinkling magic pixie dust on the performance problem.
>
> It'd help if you specified exactly what type of merkle tree you're talking
> about here; remember that the certificate transparency RFC appears to have
> reinvented merkle mountain ranges, and they call them "merkle trees".
> Bitcoin
> meanwhile uses a so-called "merkle tree" that's broken, and Zcash uses a
> partially filled fixed-sized perfect tree.
>

What I'm making is a patricia trie. Its byte level definition is very
similar to the one in your MMR codebase.

Each level of the tree has a single metadata byte and followed by two
hashes. The hashes are truncated by one byte and the hash function is a
non-padding variant of sha256 (right now it's just using regular sha256,
but that's a nice optimization which allows everything to fit in a single
block).

The possible metadata values are: TERM0, TERM1, TERMBOTH, ONLY0, ONLY1,
MIDDLE. They mean:

TERM0, TERM1: There is a single thing in the tree on the specified side.
The thing hashed on that side is that thing verbatim. The other side has
more than one thing and the hash of it is the root of everything below.

TERMBOTH: There are exactly two things below and they're included inline.
Note that two things is a special case, if there are more you sometimes
have ONLY0 or ONLY1.

ONLY0, ONLY1: There are more than two things below and they're all on the
same side. This makes proofs of inclusion and exclusion simpler, and makes
some implementation details easier, for example there's always something at
every level with perfect memory positioning. It doesn't cause much extra
memory usage because of the TERMBOTH exception for exactly two things.

MIDDLE: There two or more things on both sides.

There's also a SINGLETON special case for a tree which contains only one
thing, and an EMPTY special value for tree which doesn't contain anything.

The main differences to your patricia trie are the non-padding sha256 and
that each level doesn't hash in a record of its depth and the usage of
ONLY0 and ONLY1.


>
> > There are two causes of performance problems for merkle trees: hashing
> > operations and memory cache misses. For hashing functions, the difference
> > between a mountain range and a straight merkle tree is roughly that in a
> > mountain range there's one operation for each new update times the number
> > of times that thing will get merged into larger hills. If there are fewer
> > levels of hills the number of operations is less but the expense of proof
> > of inclusion will be larger. For raw merkle trees the number of
> operations
> > per thing added is the log base 2 of the number of levels in the tree,
> > minus the log base 2 of the number of things added at once since you can
> do
> > lazy evaluation. For practical Bitcoin there are (very roughly) a million
> > things stored, or 20 levels, and there are (even more roughly) about a
> > thousand things stored per block, so each thing forces about 20 - 10 = 10
> > operations. If you follow the fairly reasonable guideline of mountain
> range
> > hills go up by factors of four, you instead have 20/2 = 10 operations per
> > thing added amortized. Depending on details this comparison can go either
> > way but it's roughly a wash and the complexity of a mountain range is
> > clearly not worth it at least from the point of view of CPU costs.
>
> I'm having a hard time understanding this paragraph; could you explain
> what you
> think is happening when things are "merged into larger hills"?
>

I'm talking about the recalculation of mountain tips, assuming we're on the
same page about what 'MMR' means.


> As UTXO/STXO/TXO sets are all enormously larger than L1/L2 cache, it's
> impossible to get CPU cache misses below one for update operations. The
> closest
> thing to an exception is MMR's, which due to their insertion-ordering could
> have good cache locality for appends, in the sense that the mountain tips
> required to recalculate the MMR tip digest will already be in cache from
> the
> previous append. But that's not sufficient, as you also need to modify old
> TXO's further back in the tree to mark them as spent - that data is going
> to be
> far larger than L1/L2 cache.
>

This makes me think we're talking about subtly different things for MMRs.
The ones I described above have sub-1 cache miss per update due to the
amortized merging together of old mountains.

Technically even a patricia trie utxo commitment can have sub-1 cache
misses per update if some of the updates in a single block are close to
each other in memory. I think I can get practical Bitcoin updates down to a
little bit less than one l2 cache miss per update, but not a lot less.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160615/62646c88/attachment-0001.html>

From pete at petertodd.org  Thu Jun 16 03:26:12 2016
From: pete at petertodd.org (Peter Todd)
Date: Wed, 15 Jun 2016 23:26:12 -0400
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
	<CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>
Message-ID: <20160616032612.GA7792@fedora-21-dvm>

On Wed, Jun 15, 2016 at 06:16:26PM -0700, Bram Cohen wrote:
> On Wed, Jun 15, 2016 at 5:10 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > On Tue, Jun 14, 2016 at 05:14:23PM -0700, Bram Cohen via bitcoin-dev wrote:
> > >
> > > Peter proposes that there should be both UTXO and STXO commitments, and
> >
> > No, that's incorrect - I'm only proposing TXO commitments, not UTXO nor
> > STXO
> > commitments.
> >
> 
> What do you mean by TXO commitments? If you mean that it only records
> insertions rather than deletions, then that can do many of the same proofs
> but has no way of proving that something is currently in the UTXO set,
> which is functionality I'd like to provide.

I think you need to re-read my original post on TXO commitments, specifically
where I say:

    # TXO Commitments

    A merkle tree committing to the state of __all transaction outputs, both spent
    and unspent__, we can provide a method of compactly proving the current state of
    an output.

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html

> When I say 'merkle tree' what I mean is a patricia trie. What I assume is
> meant by a merkle mountain range is a series of patricia tries of
> decreasing size each of which is an addition to the previous one, and
> they're periodically consolidated into larger tries so the old ones can go
> away. This data structure has the nice property that it's both in sorted
> order and has less than one cache miss per operation because the
> consolidation operations can be batched and done linearly. There are a
> number of different things you could be describing if I misunderstood.

Nope, MMR's are completely unlike what you just described.

> > I'm not proposing STXO commitments precisely because the set of _spent_
> > transactions grows without bound.
> 
> 
> I'm worried that once there's real transaction fees everyone might stop
> consolidating dust and the set of unspent transactions might grow without
> bound as well, but that's a topic for another day.

Ok, but then if you're concerned about that risk, why introduce a data
structure - the STXO set - that's _guaranteed_ to grow without bound?

> > > Now I'm going to go out on a limb. My thesis is that usage of a mountain
> > > range is unnecessary, and that a merkle tree in the raw can be made
> > > serviceable by sprinkling magic pixie dust on the performance problem.
> >
> > It'd help if you specified exactly what type of merkle tree you're talking
> > about here; remember that the certificate transparency RFC appears to have
> > reinvented merkle mountain ranges, and they call them "merkle trees".
> > Bitcoin
> > meanwhile uses a so-called "merkle tree" that's broken, and Zcash uses a
> > partially filled fixed-sized perfect tree.
> >
> 
> What I'm making is a patricia trie. Its byte level definition is very
> similar to the one in your MMR codebase.

Which codebase exactly? I have both a insertion-ordered list (MMR) and a
key:value mapping (referred to as a "merbinner tree" in the codebase) in the
proofchains codebase. They're very different data structures.

> Each level of the tree has a single metadata byte and followed by two
> hashes. The hashes are truncated by one byte and the hash function is a
> non-padding variant of sha256 (right now it's just using regular sha256,
> but that's a nice optimization which allows everything to fit in a single
> block).
> 
> The possible metadata values are: TERM0, TERM1, TERMBOTH, ONLY0, ONLY1,
> MIDDLE. They mean:
> 
> TERM0, TERM1: There is a single thing in the tree on the specified side.
> The thing hashed on that side is that thing verbatim. The other side has
> more than one thing and the hash of it is the root of everything below.
> 
> TERMBOTH: There are exactly two things below and they're included inline.
> Note that two things is a special case, if there are more you sometimes
> have ONLY0 or ONLY1.
> 
> ONLY0, ONLY1: There are more than two things below and they're all on the
> same side. This makes proofs of inclusion and exclusion simpler, and makes
> some implementation details easier, for example there's always something at
> every level with perfect memory positioning. It doesn't cause much extra
> memory usage because of the TERMBOTH exception for exactly two things.
> 
> MIDDLE: There two or more things on both sides.
> 
> There's also a SINGLETON special case for a tree which contains only one
> thing, and an EMPTY special value for tree which doesn't contain anything.
> 
> The main differences to your patricia trie are the non-padding sha256 and
> that each level doesn't hash in a record of its depth and the usage of
> ONLY0 and ONLY1.

I'm rather confused, as the above sounds nothing like what I've implemented,
which only has leaf nodes, inner nodes, and the special empty node singleton,
for both the MMR and merbinner trees.

> > I'm having a hard time understanding this paragraph; could you explain
> > what you
> > think is happening when things are "merged into larger hills"?
> >
> 
> I'm talking about the recalculation of mountain tips, assuming we're on the
> same page about what 'MMR' means.

Yeah, we're definitely not...

In MMR's append operations never need to modify mountain contents.

> > As UTXO/STXO/TXO sets are all enormously larger than L1/L2 cache, it's
> > impossible to get CPU cache misses below one for update operations. The
> > closest
> > thing to an exception is MMR's, which due to their insertion-ordering could
> > have good cache locality for appends, in the sense that the mountain tips
> > required to recalculate the MMR tip digest will already be in cache from
> > the
> > previous append. But that's not sufficient, as you also need to modify old
> > TXO's further back in the tree to mark them as spent - that data is going
> > to be
> > far larger than L1/L2 cache.
> >
> 
> This makes me think we're talking about subtly different things for MMRs.
> The ones I described above have sub-1 cache miss per update due to the
> amortized merging together of old mountains.

Again, see above.

> Technically even a patricia trie utxo commitment can have sub-1 cache
> misses per update if some of the updates in a single block are close to
> each other in memory. I think I can get practical Bitcoin updates down to a
> little bit less than one l2 cache miss per update, but not a lot less.

I'm very confused as to why you think that's possible. When you say "practical
Bitcoin updates", what exactly is the data structure you're proposing to
update? How is it indexed?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160615/8500d863/attachment.sig>

From bram at bittorrent.com  Thu Jun 16 09:07:26 2016
From: bram at bittorrent.com (Bram Cohen)
Date: Thu, 16 Jun 2016 02:07:26 -0700
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <20160616032612.GA7792@fedora-21-dvm>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
	<CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>
	<20160616032612.GA7792@fedora-21-dvm>
Message-ID: <CA+KqGkqA2WnvBEck3kv6p2no-9wzNVCTNA-MGw=Jg=gMGfrxUQ@mail.gmail.com>

On Wed, Jun 15, 2016 at 8:26 PM, Peter Todd <pete at petertodd.org> wrote:

> >
> > What do you mean by TXO commitments? If you mean that it only records
> > insertions rather than deletions, then that can do many of the same
> proofs
> > but has no way of proving that something is currently in the UTXO set,
> > which is functionality I'd like to provide.
>
> I think you need to re-read my original post on TXO commitments,
> specifically
> where I say:
>
>     # TXO Commitments
>
>     A merkle tree committing to the state of __all transaction outputs,
> both spent
>     and unspent__, we can provide a method of compactly proving the
> current state of
>     an output.
>
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012715.html


Okay, clearly my assumptions about the parts of that post I didn't read
carefully were way off. I'll have to look through it carefully to be able
to make coherent apples to apples comparisons.

> I'm worried that once there's real transaction fees everyone might stop
> > consolidating dust and the set of unspent transactions might grow without
> > bound as well, but that's a topic for another day.
>
> Ok, but then if you're concerned about that risk, why introduce a data
> structure - the STXO set - that's _guaranteed_ to grow without bound?
>

I'm not proposing STXO set commitments either. My point was that there
should be incentives for collecting dust. That has nothing to do with this
thread though and should be discussed separately (also I don't feel like
discussing it because I don't have a good proposal).


> > What I'm making is a patricia trie. Its byte level definition is very
> > similar to the one in your MMR codebase.
>
> Which codebase exactly? I have both a insertion-ordered list (MMR) and a
> key:value mapping (referred to as a "merbinner tree" in the codebase) in
> the
> proofchains codebase. They're very different data structures.
>

I'm talking about your merbinner trees. I read through that part of your
codebase carefully and got the impression that the MMR tree section used it
as a building block.


> > The main differences to your patricia trie are the non-padding sha256 and
> > that each level doesn't hash in a record of its depth and the usage of
> > ONLY0 and ONLY1.
>
> I'm rather confused, as the above sounds nothing like what I've
> implemented,
> which only has leaf nodes, inner nodes, and the special empty node
> singleton,
> for both the MMR and merbinner trees.
>

It's quite a bit like merbinner trees. I've basically taken the leaf nodes
and smushed them into the inner nodes above them, thus saving a hashing
operation and some memory. They're both binary radix trees.

> Technically even a patricia trie utxo commitment can have sub-1 cache
> > misses per update if some of the updates in a single block are close to
> > each other in memory. I think I can get practical Bitcoin updates down
> to a
> > little bit less than one l2 cache miss per update, but not a lot less.
>
> I'm very confused as to why you think that's possible. When you say
> "practical
> Bitcoin updates", what exactly is the data structure you're proposing to
> update? How is it indexed?


My calculations are: a Bitcoin block contains about 2000 updates. The l2
cache is about 256 kilobytes, and if an update is about 32 bytes times two
for the parents, grandparents, etc. then an l2 cache can contain about 4000
values. If the current utxo size is about 2000 * 4000 = 8,000,000 in size
then about half the pages which contain a transaction will contain a second
one. I think the utxo set is currently about an order of magnitude greater
than that, so the number of such collisions will be fairly mall, hence my
'less than one but not a lot less' comment.

As for how it's indexed, at a crypto definition level it's just a binary
radix tree. In terms of how it's indexed in memory, that involves some
optimizations to avoid cache misses. Memory is allocated into blocks of
about the size of an 12 cache (or maybe an l1 cache, it will require some
testing and optimization). Blocks are either branch blocks, which keep
everything in fixed positions, or leaf blocks, which contain fixed size
entries for nodes plus indexes within the same leaf block of their
children. Branch blocks can have many children which can be either branch
blocks or leaf blocks, but typically are either all branch blocks or all
leaf blocks. Branch blocks always have exactly one parent. Leaf blocks
always have all their inputs come from a single branch block, but there can
be multiple ones of those. When a branch block overflows it first tries to
put stuff into the last leaf block it used, and if there's no more room it
allocates a new one. It's fairly common for branches to have just a few
leaf children, but they also could have a lot, depending on whether the
base 2 log of the number of things currently in the set modulo the number
levels in a branch is a small number.

Usually when an update is done it consists of first checking the
appropriate output of the root block (it's jumped to directly to avoid
unnecessary memory lookups. If there's nothing there the algorithm will
walk back until it finds something.) That leads directly to (usually)
another branch whose output is jumped to directly again. At Bitcoin utxo
set sizes that will usually lead to a leaf block, which is then walked down
manually to find the actual terminal node, which is then updated, and the
parent, grandparent, etc. is then marked invalid until something which was
already marked invalid is hit, and it exits. Calculation of hash values is
done lazily.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160616/e266893c/attachment.html>

From pete at petertodd.org  Fri Jun 17 04:34:35 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 17 Jun 2016 00:34:35 -0400
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <CA+KqGkqA2WnvBEck3kv6p2no-9wzNVCTNA-MGw=Jg=gMGfrxUQ@mail.gmail.com>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
	<CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>
	<20160616032612.GA7792@fedora-21-dvm>
	<CA+KqGkqA2WnvBEck3kv6p2no-9wzNVCTNA-MGw=Jg=gMGfrxUQ@mail.gmail.com>
Message-ID: <20160617043435.GA12800@fedora-21-dvm>

On Thu, Jun 16, 2016 at 02:07:26AM -0700, Bram Cohen wrote:
> On Wed, Jun 15, 2016 at 8:26 PM, Peter Todd <pete at petertodd.org> wrote:
> Okay, clearly my assumptions about the parts of that post I didn't read
> carefully were way off. I'll have to look through it carefully to be able
> to make coherent apples to apples comparisons.

Thanks!

> > I'm worried that once there's real transaction fees everyone might stop
> > > consolidating dust and the set of unspent transactions might grow without
> > > bound as well, but that's a topic for another day.
> >
> > Ok, but then if you're concerned about that risk, why introduce a data
> > structure - the STXO set - that's _guaranteed_ to grow without bound?
> >
> 
> I'm not proposing STXO set commitments either. My point was that there
> should be incentives for collecting dust. That has nothing to do with this
> thread though and should be discussed separately (also I don't feel like
> discussing it because I don't have a good proposal).

Ah, yeah, I misunderstood you there; as expected absolutely no-one is proposing
STXO set commitments. :)

> > > The main differences to your patricia trie are the non-padding sha256 and
> > > that each level doesn't hash in a record of its depth and the usage of
> > > ONLY0 and ONLY1.
> >
> > I'm rather confused, as the above sounds nothing like what I've
> > implemented,
> > which only has leaf nodes, inner nodes, and the special empty node
> > singleton,
> > for both the MMR and merbinner trees.
> >
> 
> It's quite a bit like merbinner trees. I've basically taken the leaf nodes
> and smushed them into the inner nodes above them, thus saving a hashing
> operation and some memory. They're both binary radix trees.

Ah, I see what you mean now.

So above you said that in merbinner trees each node "hash[es] in a record of
its depth" That's actually incorrect: each node commits to the prefix that all
keys below that level start with, not just the depth.

This means that in merbinner trees, cases where multiple keys share parts of
the same prefix are handled efficiently, without introducing extra levels
unnecessarily; there's no need for the ONLY0/1 nodes as the children of an
inner node will always be on different sides.

When keys are randomly distributed, this isn't a big deal; OTOH against
attackers who are choosing keys, e.g. by grinding hashes, merbinner trees
always have maximum depths in proportion to log2(n) of the actual number of
items in the tree. Grinding is particularly annoying to deal with due to the
birthday attack: creating a ground prefix 64 bits long only takes 32 bits worth
of work.


In my deterministic expressions work one of the ideas I've been tossing around
is rather than always using hash digests directly for when you need to commit
to some data, we could instead extend the idea of a digest to that of a
"commitment", where a commitment is simply some short, but variable-sized,
string that uniquely maps to a given set of data. Secondly, commitments do
*not* always guarantee that the original data can't be recovered from the
commitment itself.

By allowing commitments to be variable sized - say 0 to ~64 bytes - we get a
number of advantages:

1) Data shorter than the length of a digest (32 bytes) can be included in the
commitment itself, improving efficiency.

2) Data a little longer than a digest can have hashing delayed, to better fill
up blocks.

In particular, case #2 handles your leaf node optimizations generically,
without special cases and additional complexity. It'd also be a better way to
do the ONLY0/1 cases, as if the "nothing on this side" symbol is a single byte,
each additional colliding level would simply extend the commitment without
hashing. In short, you'd have nearly the same level of optimization even if at
the cryptography level your tree consists of only leaves, inner nodes, and nil.

Another advantage of variable sized commitments is that it can help make clear
to users when it's possible to brute force the message behind the commitment.
For instance, digest from a hashed four byte integer can be trivially reversed
by just trying all combinations. Equally, if that integer is concatenated with
a 32 byte digest that the attacker knows, the value of the integer can be brute
forced.

> > Technically even a patricia trie utxo commitment can have sub-1 cache
> > > misses per update if some of the updates in a single block are close to
> > > each other in memory. I think I can get practical Bitcoin updates down
> > to a
> > > little bit less than one l2 cache miss per update, but not a lot less.
> >
> > I'm very confused as to why you think that's possible. When you say
> > "practical
> > Bitcoin updates", what exactly is the data structure you're proposing to
> > update? How is it indexed?
> 
> 
> My calculations are: a Bitcoin block contains about 2000 updates. The l2
> cache is about 256 kilobytes, and if an update is about 32 bytes times two
> for the parents, grandparents, etc. then an l2 cache can contain about 4000
> values. If the current utxo size is about 2000 * 4000 = 8,000,000 in size
> then about half the pages which contain a transaction will contain a second
> one. I think the utxo set is currently about an order of magnitude greater
> than that, so the number of such collisions will be fairly mall, hence my
> 'less than one but not a lot less' comment.

Your estimate of updates requiring 32 bytes of data is *way* off.

Each inner node updated on the path to a leaf node will itself require 32 bytes
of data to be fetched - the digest of the sibling. As of block 416,628, there
are 39,167,128 unspent txouts, giving us a tree about 25 levels deep.

So if I want to update a single leaf, I need to read:

    25 nodes * 32 bytes/node = 800 bytes

of data. Naively, that'd mean our 2,000 updates needs to read 1.6MB from RAM,
which is 6.4x bigger than the L2 cache - it's just not going to fit.

Taking into account the fact that this is a batched update improves things a
little bit. For a node at level i with random access patterns and N accesses
total our amortised cost is 1/(1 + N/2^i) Summing that over 2,000 leaf updates
and 25 levels gives us ~29,000 total updates, 0.9MB, which is still a lot
larger than L2 cache.

While this might fit in L3 cache - usually on the order of megabytes - this is
a rather optimistic scenario anyway: we're assuming no other cache pressure and
100% hit rate.

Anyway hashing is pretty slow. The very fast BLAKE2 is about 3 cycles/byte
(SHA256 is about 15 cycles/byte) so hashing that same data would take around
200 cycles, and probably quite a bit more in practice due to overheads from our
short message lengths; fetching a cache line from DRAM only takes about 1,000
cycles. I'd guess that once other overheads are taken into account, even if you
could eliminate L2/L3 cache-misses it wouldn't be much of an improvement.

> As for how it's indexed, at a crypto definition level it's just a binary
> radix tree. In terms of how it's indexed in memory, that involves some
> optimizations to avoid cache misses. Memory is allocated into blocks of
> about the size of an 12 cache (or maybe an l1 cache, it will require some
> testing and optimization). Blocks are either branch blocks, which keep
> everything in fixed positions, or leaf blocks, which contain fixed size
> entries for nodes plus indexes within the same leaf block of their
> children. Branch blocks can have many children which can be either branch
> blocks or leaf blocks, but typically are either all branch blocks or all
> leaf blocks. Branch blocks always have exactly one parent. Leaf blocks
> always have all their inputs come from a single branch block, but there can
> be multiple ones of those. When a branch block overflows it first tries to
> put stuff into the last leaf block it used, and if there's no more room it
> allocates a new one. It's fairly common for branches to have just a few
> leaf children, but they also could have a lot, depending on whether the
> base 2 log of the number of things currently in the set modulo the number
> levels in a branch is a small number.
> 
> Usually when an update is done it consists of first checking the
> appropriate output of the root block (it's jumped to directly to avoid
> unnecessary memory lookups. If there's nothing there the algorithm will
> walk back until it finds something.) That leads directly to (usually)
> another branch whose output is jumped to directly again. At Bitcoin utxo
> set sizes that will usually lead to a leaf block, which is then walked down
> manually to find the actual terminal node, which is then updated, and the
> parent, grandparent, etc. is then marked invalid until something which was
> already marked invalid is hit, and it exits. Calculation of hash values is
> done lazily.

I think it's safe to say that given our working set is significantly larger
than the L2/L3 cache available, none of the above optimizations are likely to
help much. Better to just keep the codebase simple and use standard techniques.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160617/3c2a9dc6/attachment.sig>

From bram at bittorrent.com  Sat Jun 18 02:43:47 2016
From: bram at bittorrent.com (Bram Cohen)
Date: Fri, 17 Jun 2016 19:43:47 -0700
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <20160617043435.GA12800@fedora-21-dvm>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
	<CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>
	<20160616032612.GA7792@fedora-21-dvm>
	<CA+KqGkqA2WnvBEck3kv6p2no-9wzNVCTNA-MGw=Jg=gMGfrxUQ@mail.gmail.com>
	<20160617043435.GA12800@fedora-21-dvm>
Message-ID: <CA+KqGkpRmeKyo6TFpe+uUCdJSina+ARraNd0dkHSb2Hpx5dYuw@mail.gmail.com>

On Thu, Jun 16, 2016 at 9:34 PM, Peter Todd <pete at petertodd.org> wrote:

> So above you said that in merbinner trees each node "hash[es] in a record
> of
> its depth" That's actually incorrect: each node commits to the prefix that
> all
> keys below that level start with, not just the depth.


I considered a similar trick at the implementation rather than the
definition level: A node doesn't have to store the prefix which is implicit
in its position. That would create a fair number of headaches though,
because I'm using fixed size stuff in important ways, and it could at most
save about 10% of memory, so it goes into the 'maybe later' bucket.


>
> This means that in merbinner trees, cases where multiple keys share parts
> of
> the same prefix are handled efficiently, without introducing extra levels
> unnecessarily; there's no need for the ONLY0/1 nodes as the children of an
> inner node will always be on different sides.
>
> When keys are randomly distributed, this isn't a big deal; OTOH against
> attackers who are choosing keys, e.g. by grinding hashes, merbinner trees
> always have maximum depths in proportion to log2(n) of the actual number of
> items in the tree. Grinding is particularly annoying to deal with due to
> the
> birthday attack: creating a ground prefix 64 bits long only takes 32 bits
> worth
> of work.
>

Yes an attacker can force the tree to be deeper in places, but it's
mitigated in several ways: (1) The way I'm using memory it won't cause a
whole new block to be allocated, it will just force log(attack strength) -
log(n) nodes to be used (2) logarithmic growth being what it is that isn't
such a big amount (3) With the special casing of TERMBOTH an attacker needs
three things with the same prefix to pull off an attack rather than two,
which is quite a bit harder to pull off.

That said, it wouldn't be all that hard to change how the hashing function
works to do a single hash for a whole series of ONLY in a row instead of a
new one at every level, which would make the attacker only able to force
extra memory usage instead of extra CPU, but this is a slightly annoying
thing to write to stop a fairly lame attack, so I'm at least not doing it
for my initial implementation. I could likely be convinced that it's worth
doing before an actual release though. There's another implementation trick
to do the same thing for memory usage, which is much more in the 'do later'
category because it doesn't involve changing the format and hence it can be
put off.


> In particular, case #2 handles your leaf node optimizations generically,
> without special cases and additional complexity. It'd also be a better way
> to
> do the ONLY0/1 cases, as if the "nothing on this side" symbol is a single
> byte,
> each additional colliding level would simply extend the commitment without
> hashing. In short, you'd have nearly the same level of optimization even
> if at
> the cryptography level your tree consists of only leaves, inner nodes, and
> nil.
>

I'm taking pains to make all the hashing be of fixed-size things, so that a
non-padding variant of a secure hashing algorithm can be used. The chains
of ONLY thing above would force a special exception to that, which can be
done but is annoying. Making things smaller than a single block (64 bytes)
won't speed up hashing time, and making things a single byte longer than
that doubles it.


> Another advantage of variable sized commitments is that it can help make
> clear
> to users when it's possible to brute force the message behind the
> commitment.
> For instance, digest from a hashed four byte integer can be trivially
> reversed
> by just trying all combinations. Equally, if that integer is concatenated
> with
> a 32 byte digest that the attacker knows, the value of the integer can be
> brute
> forced.
>

I'm hashing all strings before inserting to get them to be a fixed size and
avoid a few different attacks. In Bitcoin most of the strings added are
longer than that so it's a form of compression. A custom hash function
could be used which 'hashes' very short strings by repeating them verbatim
could be used, but seems like not such a hot idea. I'm making extensive use
of things being fixed size everywhere, which improves performance in a lot
of ways.


> > > Technically even a patricia trie utxo commitment can have sub-1 cache
> > > > misses per update if some of the updates in a single block are close
> to
> > > > each other in memory. I think I can get practical Bitcoin updates
> down
> > > to a
> > > > little bit less than one l2 cache miss per update, but not a lot
> less.
> > >
> > > I'm very confused as to why you think that's possible. When you say
> > > "practical
> > > Bitcoin updates", what exactly is the data structure you're proposing
> to
> > > update? How is it indexed?
>

I'll re-answer this because I did a terrible job before. The entire data
structure consists of nodes which contain a metadata byte (TERM0, ONLY1,
etc.) followed by fixes size secure hashes, and (in some cases) pointers to
where the children are. The secure hashes in parent nodes are found by
hashing their children verbatim (or the stored string in the case of a
TERM). This is very conventional. All of the cleverness is in where in
memory these nodes are stored so that tracing down the tree causes very few
cache misses.

(The alternate approach is to have each node store its own hash rather than
that be stored by the parent. That approach means that when you're
recalculating you have to look up siblings which doubles the number of
cache misses. Not such a hot idea.)

At the root there's a branch block. It consists of all nodes up to some
fixed depth - let's say 12 - with that depth set so that it roughly fits
within a single memory page. Branch blocks are arranged with the nodes in
fixed position defined by the prefix they correspond to, and the terminals
have outpointers to other blocks. Because they're all clustered together, a
lookup or update will only require a single

Below the root block are other branch blocks. Each of them has a fixed 12
bit prefix it is responsible for. When doing a lookup a second cache miss
will be hit for levels 13-24, because those are all clustered in the same
branch block.

Below the second level of root block (at Bitcoin utxo set scale - this
varies based on how much is stored) there are leaf blocks. A leaf block
consists of nodes with outpointers to its own children which must be within
the same leaf block. All entry points into a leaf block are from the same
branch block, and the leaf block has no out pointers to other blocks. When
a leaf block overflows the entry point into it which overflowed is moved
into the active leaf for that branch, and if that's full a new one is
allocated. There's some subtlety to exactly how this is done, but I've
gotten everything down to simple expedient tricks with straightforward
implementations. The thing which matters for now is that there's only a
single cache miss for each leaf node, because they also fit in a page.

So at Bitcoin scale there will probably only be 3 cache misses for a
lookup, and that's a worst case scenario. The first one is probably always
warm, bringing it down to 2, and if you do a bunch in sorted order they'll
probably hit the same second level branches repeatedly bringing it down to
1, and might even average less than that if there are enough that the leaf
block has multiple things being accessed.

(These same tricks can be applied to merbinner tree implementation as well,
although that would be a bit less parsimonious with memory, by a small
constant factor.)


> Anyway hashing is pretty slow. The very fast BLAKE2 is about 3 cycles/byte
> (SHA256 is about 15 cycles/byte) so hashing that same data would take
> around
> 200 cycles, and probably quite a bit more in practice due to overheads
> from our
> short message lengths; fetching a cache line from DRAM only takes about
> 1,000
> cycles. I'd guess that once other overheads are taken into account, even
> if you
> could eliminate L2/L3 cache-misses it wouldn't be much of an improvement.
>

Those numbers actually back up my claims about performance. If you're doing
a single update and recalculating the root afterwards, then the amount of
rehashing to be done is about 30 levels deep times 64 bytes per thing
hashed times 15 cycles per byte then it's about 28,800 cycles of hashing.
If you have a naive radix tree implementation which hits a cache miss at
every level then that's 30,000 cycles, which is about half the performance
time, certainly worth optimizing. If instead of sha256 you use blake2
(Which sounds like a very good idea!) then hashing for an update will be
about 5760 cycles and performance will be completely dominated by cache
misses. If a more cache coherent implementation is used, then the cost of
cache misses will be 3000 cycles, which will be a non-factor with sha256
and a significant but not dominating one with blake2.

It's reasonable to interpret those numbers as saying that blake2 and cache
coherent implementation are both clearly worth it (probably necessary for
real adoption) and that an amortized binary radix tree is tempting but not
worth it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160617/88e3169a/attachment.html>

From bram at bittorrent.com  Sat Jun 18 03:22:04 2016
From: bram at bittorrent.com (Bram Cohen)
Date: Fri, 17 Jun 2016 20:22:04 -0700
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <20160616001040.GA5026@fedora-21-dvm>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
Message-ID: <CA+KqGko2jW9999A9vkkBrM3EPb5OXYe4OPu0_Ot=fGnc7Cge-Q@mail.gmail.com>

On Wed, Jun 15, 2016 at 5:10 PM, Peter Todd <pete at petertodd.org> wrote:

> On Tue, Jun 14, 2016 at 05:14:23PM -0700, Bram Cohen via bitcoin-dev wrote:
>
> > The fundamental approach to handling the latency problem is to have the
> > utxo commitments trail a bit. Computing utxo commitments takes a certain
> > amount of time, too much to hold up block propagation but still hopefully
> > vastly less than the average amount of time between blocks. Trailing by a
> > single block is probably a bad idea because you sometimes get blocks back
> > to back, but you never get blocks back to back to back to back. Having
> the
> > utxo set be trailing by a fixed amount - five blocks is probably
> excessive
> > - would do a perfectly good job of keeping latency from every becoming an
> > issue. Smaller commitments for the utxos added and removed in each block
> > alone could be added without any significant performance penalty. That
> way
> > all blocks would have sufficient commitments for a completely up to date
> > proofs of inclusion and exclusion. This is not a controversial approach.
>
> Agreed - regardless of approach adding latency to commitment calculations
> of
> all kinds is something I think we all agree can work in principle, although
> obviously it should be a last resort technique when optimization fails.
>

An important point: Adding latency to utxo commitments does not imply
latency to proofs of inclusion and exclusion! If roots of what's added and
deleted in each block are added as well, then a proof of inclusion can be
done by having a proof of inclusion of the trailing utxo set followed by a
proof of exclusion from all the following deletion sets, or a proof of
inclusion in one of the single block addition sets followed by proofs of
exclusion from all the more recent deletion sets. Likewise a proof of
exclusion can be a proof of exclusion from the utxo set followed by proofs
of exclusion from all the more recent addition sets or a single proof of
inclusion in a recent deletion set.

This does make proofs larger (except in the case of recent deletions and
maybe recent additions) and adds complexity, so it shouldn't be done unless
necessary. But validation before block propagation needs to be extremely
fast, so for utxo roots this trick is probably both necessary and
sufficient.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160617/1843b319/attachment-0001.html>

From voisine at gmail.com  Sat Jun 18 06:07:48 2016
From: voisine at gmail.com (Aaron Voisine)
Date: Fri, 17 Jun 2016 23:07:48 -0700
Subject: [bitcoin-dev] RFC for BIP: Derivation scheme for
 P2WPKH-nested-in-P2SH based accounts
In-Reply-To: <5760259B.7040409@mycelium.com>
References: <5760259B.7040409@mycelium.com>
Message-ID: <CACq0ZD4EWNxmsbz4pUv30ZPS9O+paMNzqvaHpL6uZ5tF-up4iQ@mail.gmail.com>

This works for segwit version 1 with the addition of also using a different
chain id.

I presume that segwit version 2 will be implementing schnorr signatures.
What do we know about the likely implementation details? Is there any way
to avoid using a third derivation path to support it?


Aaron Voisine
co-founder and CEO
breadwallet <http://breadwallet.com>

On Tue, Jun 14, 2016 at 8:41 AM, Daniel Weigl via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi List,
>
> Following up to the discussion last month (
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012695.html
> ), ive prepared a proposal for a BIP here:
>
>
> https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki
>
>
> Any comments on it? Does anyone working on a BIP44 compliant wallet
> implement something different?
> If there are no objection, id also like to request a number for it.
>
> Thx,
> Daniel
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160617/e8e17b28/attachment.html>

From pete at petertodd.org  Sat Jun 18 22:09:29 2016
From: pete at petertodd.org (Peter Todd)
Date: Sat, 18 Jun 2016 18:09:29 -0400
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <CA+KqGko2jW9999A9vkkBrM3EPb5OXYe4OPu0_Ot=fGnc7Cge-Q@mail.gmail.com>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
	<CA+KqGko2jW9999A9vkkBrM3EPb5OXYe4OPu0_Ot=fGnc7Cge-Q@mail.gmail.com>
Message-ID: <20160618220929.GA24713@fedora-21-dvm>

On Fri, Jun 17, 2016 at 08:22:04PM -0700, Bram Cohen wrote:
> On Wed, Jun 15, 2016 at 5:10 PM, Peter Todd <pete at petertodd.org> wrote:
> > Agreed - regardless of approach adding latency to commitment calculations
> > of
> > all kinds is something I think we all agree can work in principle, although
> > obviously it should be a last resort technique when optimization fails.
> >
> 
> An important point: Adding latency to utxo commitments does not imply
> latency to proofs of inclusion and exclusion! If roots of what's added and
> deleted in each block are added as well, then a proof of inclusion can be
> done by having a proof of inclusion of the trailing utxo set followed by a
> proof of exclusion from all the following deletion sets, or a proof of
> inclusion in one of the single block addition sets followed by proofs of
> exclusion from all the more recent deletion sets. Likewise a proof of
> exclusion can be a proof of exclusion from the utxo set followed by proofs
> of exclusion from all the more recent addition sets or a single proof of
> inclusion in a recent deletion set.
> 
> This does make proofs larger (except in the case of recent deletions and
> maybe recent additions) and adds complexity, so it shouldn't be done unless
> necessary.

So, to be clear you're assuming that blocks commit to key:value maps of the
block contents, specifically a pre-block "UTXO deletion/things that this block
spent" set? First of all, it's interesting how the much smaller dataset of a
pre-block key:value map would make L2/L3 caching optimizations much more likely
to be relevant. :)


That type of solution would be very similar to the solutions treechains would
need to prove coins haven't been doublespent. Basically, in treechains the
system as a whole is a datastructure indexed by time and prefix. So, if you
want to prove a valid spend you need to convince me of three things:

1. The coin existed as of time t1 at prefix p

2. At t2, p, a valid spend was published.

3. Between t1 and t2 at prefix p no other valid spend was published.

Paths to any prefix p as of time t, will have about log2(len(p)) size (beyond
the top-level chain), similar to your above suggestion. Of course, unlike your
above suggestion, in treechains it's not clear if step #1 can be done without
another n*log(N)-ish sized proof in a truly trustless environment!

> But validation before block propagation needs to be extremely
> fast, so for utxo roots this trick is probably both necessary and
> sufficient.

I'm _not_ of the optinion that validation before propagation needs to be done
at all - I think it's perfectly reasonable to propgate blocks that you have not
validated at all (beyond checking PoW as an anti-DoS measure).  The time it
takes miners to start mining the next block - and collecting fees - is however
very important.

In practice, I think we're mostly in agreement here, but because I'm happy to
propagate prior to validating I'd be ok with protocol designs that required
miners to have relatively large amounts of RAM - say 32GB - dedicated to UTXO
lookup because that wouldn't require relay nodes to also have those kinds of
resources available to them once validationless propagation was implemented.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160618/0ca1a55b/attachment.sig>

From pete at petertodd.org  Sat Jun 18 23:01:43 2016
From: pete at petertodd.org (Peter Todd)
Date: Sat, 18 Jun 2016 19:01:43 -0400
Subject: [bitcoin-dev] Merkle trees and mountain ranges
In-Reply-To: <CA+KqGkpRmeKyo6TFpe+uUCdJSina+ARraNd0dkHSb2Hpx5dYuw@mail.gmail.com>
References: <CA+KqGkosGrWQ2Lpg3Ptc+UyidK7H4_HLQ_QWx2DOAFRmLkv4zQ@mail.gmail.com>
	<20160616001040.GA5026@fedora-21-dvm>
	<CA+KqGkqAHcU2PzEX6OmorXRBQ22eF_QBYYqUDS1v_ZvevhLCuQ@mail.gmail.com>
	<20160616032612.GA7792@fedora-21-dvm>
	<CA+KqGkqA2WnvBEck3kv6p2no-9wzNVCTNA-MGw=Jg=gMGfrxUQ@mail.gmail.com>
	<20160617043435.GA12800@fedora-21-dvm>
	<CA+KqGkpRmeKyo6TFpe+uUCdJSina+ARraNd0dkHSb2Hpx5dYuw@mail.gmail.com>
Message-ID: <20160618230143.GA25017@fedora-21-dvm>

On Fri, Jun 17, 2016 at 07:43:47PM -0700, Bram Cohen wrote:
> On Thu, Jun 16, 2016 at 9:34 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> > So above you said that in merbinner trees each node "hash[es] in a record
> > of
> > its depth" That's actually incorrect: each node commits to the prefix that
> > all
> > keys below that level start with, not just the depth.
> 
> 
> I considered a similar trick at the implementation rather than the
> definition level: A node doesn't have to store the prefix which is implicit
> in its position. That would create a fair number of headaches though,
> because I'm using fixed size stuff in important ways, and it could at most
> save about 10% of memory, so it goes into the 'maybe later' bucket.

Wait, are you saying you think committing to the prefix is a "trick"? It's just
a very simple - and possibly not-optimal - way of committing to what data
should be accessible under a given node. An alternative would have been ensure
that in terms of _cryptographic_ tree position.

By "position", are you talking about position within RAM? That may or may not
be a viable optimization, but it's quite separate from the question of the
cryptographic structure of the data.

> > This means that in merbinner trees, cases where multiple keys share parts
> > of
> > the same prefix are handled efficiently, without introducing extra levels
> > unnecessarily; there's no need for the ONLY0/1 nodes as the children of an
> > inner node will always be on different sides.
> >
> > When keys are randomly distributed, this isn't a big deal; OTOH against
> > attackers who are choosing keys, e.g. by grinding hashes, merbinner trees
> > always have maximum depths in proportion to log2(n) of the actual number of
> > items in the tree. Grinding is particularly annoying to deal with due to
> > the
> > birthday attack: creating a ground prefix 64 bits long only takes 32 bits
> > worth
> > of work.
> >
> 
> Yes an attacker can force the tree to be deeper in places, but it's
> mitigated in several ways: (1) The way I'm using memory it won't cause a
> whole new block to be allocated, it will just force log(attack strength) -
> log(n) nodes to be used (2) logarithmic growth being what it is that isn't
> such a big amount (3) With the special casing of TERMBOTH an attacker needs
> three things with the same prefix to pull off an attack rather than two,
> which is quite a bit harder to pull off.



> That said, it wouldn't be all that hard to change how the hashing function
> works to do a single hash for a whole series of ONLY in a row instead of a
> new one at every level, which would make the attacker only able to force
> extra memory usage instead of extra CPU, but this is a slightly annoying
> thing to write to stop a fairly lame attack, so I'm at least not doing it
> for my initial implementation. I could likely be convinced that it's worth
> doing before an actual release though. There's another implementation trick
> to do the same thing for memory usage, which is much more in the 'do later'
> category because it doesn't involve changing the format and hence it can be
> put off.
> 
> 
> > In particular, case #2 handles your leaf node optimizations generically,
> > without special cases and additional complexity. It'd also be a better way
> > to
> > do the ONLY0/1 cases, as if the "nothing on this side" symbol is a single
> > byte,
> > each additional colliding level would simply extend the commitment without
> > hashing. In short, you'd have nearly the same level of optimization even
> > if at
> > the cryptography level your tree consists of only leaves, inner nodes, and
> > nil.
> >
> 
> I'm taking pains to make all the hashing be of fixed-size things, so that a
> non-padding variant of a secure hashing algorithm can be used. The chains
> of ONLY thing above would force a special exception to that, which can be
> done but is annoying. Making things smaller than a single block (64 bytes)
> won't speed up hashing time, and making things a single byte longer than
> that doubles it.

Have you seen how BLAKE2 omits padding when the data to be hashed happens to be
exactly one block in size? It's significantly faster than SHA256, and that's a
standard part of the algorithm already.

> > > > Technically even a patricia trie utxo commitment can have sub-1 cache
> > > > > misses per update if some of the updates in a single block are close
> > to
> > > > > each other in memory. I think I can get practical Bitcoin updates
> > down
> > > > to a
> > > > > little bit less than one l2 cache miss per update, but not a lot
> > less.
> > > >
> > > > I'm very confused as to why you think that's possible. When you say
> > > > "practical
> > > > Bitcoin updates", what exactly is the data structure you're proposing
> > to
> > > > update? How is it indexed?
> >
> 
> I'll re-answer this because I did a terrible job before. The entire data
> structure consists of nodes which contain a metadata byte (TERM0, ONLY1,
> etc.) followed by fixes size secure hashes, and (in some cases) pointers to
> where the children are. The secure hashes in parent nodes are found by
> hashing their children verbatim (or the stored string in the case of a
> TERM). This is very conventional. All of the cleverness is in where in
> memory these nodes are stored so that tracing down the tree causes very few
> cache misses.
> 
> (The alternate approach is to have each node store its own hash rather than
> that be stored by the parent. That approach means that when you're
> recalculating you have to look up siblings which doubles the number of
> cache misses. Not such a hot idea.)

Have you benchmarked the cost of a hash operation vs. the cost of a cache miss?
What are the actual numbers?

> At the root there's a branch block. It consists of all nodes up to some
> fixed depth - let's say 12 - with that depth set so that it roughly fits
> within a single memory page. Branch blocks are arranged with the nodes in
> fixed position defined by the prefix they correspond to, and the terminals
> have outpointers to other blocks. Because they're all clustered together, a
> lookup or update will only require a single

A single....?

> Below the root block are other branch blocks. Each of them has a fixed 12
> bit prefix it is responsible for. When doing a lookup a second cache miss
> will be hit for levels 13-24, because those are all clustered in the same
> branch block.

So, is this also how the data structure looks cryptographically, or is the way
it's hashed separate from the above description?

> Below the second level of root block (at Bitcoin utxo set scale - this
> varies based on how much is stored) there are leaf blocks. A leaf block
> consists of nodes with outpointers to its own children which must be within
> the same leaf block. All entry points into a leaf block are from the same
> branch block, and the leaf block has no out pointers to other blocks. When
> a leaf block overflows the entry point into it which overflowed is moved
> into the active leaf for that branch, and if that's full a new one is
> allocated. There's some subtlety to exactly how this is done, but I've
> gotten everything down to simple expedient tricks with straightforward
> implementations. The thing which matters for now is that there's only a
> single cache miss for each leaf node, because they also fit in a page.

Page as in 4096 bytes? But L1/L2/L3 cache is arranged in terms of 64 byte cache
lines - where do pages come in here?

At Bitcoin UTXO set scale, how large do you think these data structures are?

> So at Bitcoin scale there will probably only be 3 cache misses for a
> lookup, and that's a worst case scenario. The first one is probably always
> warm, bringing it down to 2, and if you do a bunch in sorted order they'll
> probably hit the same second level branches repeatedly bringing it down to
> 1, and might even average less than that if there are enough that the leaf
> block has multiple things being accessed.

"Sorted order" - what exact type of sorting do you mean here?

> > Anyway hashing is pretty slow. The very fast BLAKE2 is about 3 cycles/byte
> > (SHA256 is about 15 cycles/byte) so hashing that same data would take
> > around
> > 200 cycles, and probably quite a bit more in practice due to overheads
> > from our
> > short message lengths; fetching a cache line from DRAM only takes about
> > 1,000
> > cycles. I'd guess that once other overheads are taken into account, even
> > if you
> > could eliminate L2/L3 cache-misses it wouldn't be much of an improvement.
> >
> 
> Those numbers actually back up my claims about performance. If you're doing
> a single update and recalculating the root afterwards, then the amount of
> rehashing to be done is about 30 levels deep times 64 bytes per thing
> hashed times 15 cycles per byte then it's about 28,800 cycles of hashing.
> If you have a naive radix tree implementation which hits a cache miss at
> every level then that's 30,000 cycles, which is about half the performance
> time, certainly worth optimizing. If instead of sha256 you use blake2
> (Which sounds like a very good idea!) then hashing for an update will be
> about 5760 cycles and performance will be completely dominated by cache
> misses. If a more cache coherent implementation is used, then the cost of
> cache misses will be 3000 cycles, which will be a non-factor with sha256
> and a significant but not dominating one with blake2.

But that's assuming the dataset in question fits in cache; I don't see how it
does. Since it doesn't, I'm argung the total % improvement by _any_ cache
optimization on the subset that does fit in cache will be relatively small.

Again, how large a dataset do you think you're working with here?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160618/e7c404fd/attachment.sig>

From pete at petertodd.org  Mon Jun 20 08:56:49 2016
From: pete at petertodd.org (Peter Todd)
Date: Mon, 20 Jun 2016 04:56:49 -0400
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
	Consensus
Message-ID: <20160620085649.GA29964@fedora-21-dvm>

In light of Ethereum's recent problems with its imperative, account-based,
programming model, I thought I'd do a quick writeup outlining the building
blocks of the state-machine approach to so-called "smart contract" systems, an
extension of Bitcoin's own design that I personally have been developing for a
number of years now as my Proofchains/Dex research work.


# Deterministic Code / Deterministic Expressions

We need to be able to run code on different computers and get identical
results; without this consensus is impossible and we might as well just use a
central authoritative database. Traditional languages and surrounding
frameworks make determinism difficult to achieve, as they tend to be filled
with undefined and underspecified behavior, ranging from signed integer
overflow in C/C++ to non-deterministic behavior in databases. While some
successful systems like Bitcoin are based on such languages, their success is
attributable to heroic efforts by their developers.

Deterministic expression systems such as Bitcoin's scripting system and the
author's Dex project improve on this by allowing expressions to be precisely
specified by hash digest, and executed against an environment with
deterministic results. In the case of Bitcoin's script, the expression is a
Forth-like stack-based program; in Dex the expression takes the form of a
lambda calculus expression.


## Proofs

So far the most common use for deterministic expressions is to specify
conditions upon which funds can be spent, as seen in Bitcoin (particularly
P2SH, and the upcoming Segwit). But we can generalize their use to precisely
defining consensus protocols in terms of state machines, with each state
defined in terms of a deterministic expression that must return true for the
state to have been reached. The data that causes a given expression to return
true is then a "proof", and that proof can be passed from one party to another
to prove desired states in the system have been reached.

An important implication of this model is that we need deterministic, and
efficient, serialization of proof data.


## Pruning

Often the evaluation of an expression against a proof doesn't require all all
data in the proof. For example, to prove to a lite client that a given block
contains a transaction, we only need the merkle path from the transaction to
the block header. Systems like Proofchains and Dex generalize this process -
called "pruning" - with built-in support to both keep track of what data is
accessed by what operations, as well as support in their underlying
serialization schemes for unneeded data to be elided and replaced by the hash
digest of the pruned data.


# Transactions

A common type of state machine is the transaction. A transaction history is a
directed acyclic graph of transactions, with one or more genesis transactions
having no inputs (ancestors), and one or more outputs, and zero or more
non-genesis transactions with one or more inputs, and zero or more outputs. The
edges of the graph connect inputs to outputs, with every input connected to
exactly one output. Outputs with an associated input are known as spent
outputs; outputs with out an associated input are unspent.

Outputs have conditions attached to them (e.g. a pubkey for which a valid
signature must be produced), and may also be associated with other values such
as "# of coins". We consider a transaction valid if we have a set of proofs,
one per input, that satisfy the conditions associated with each output.
Secondly, validity may also require additional constraints to be true, such as
requiring the coins spent to be >= the coins created on the outputs. Input
proofs also must uniquely commit to the transaction itself to be secure - if
they don't the proofs can be reused in a replay attack.

A non-genesis transaction is valid if:

1. Any protocol-specific rules such as coins spent >= coins output are
   followed.

2. For every input a valid proof exists.

3. Every input transaction is itself valid.

A practical implementation of the above for value-transfer systems like Bitcoin
could use two merkle-sum trees, one for the inputs, and one for the outputs,
with inputs simply committing to the previous transaction's txid and output #
(outpoint), and outputs committing to a scriptPubKey and output amount.
Witnesses can be provided separately, and would sign a signature committing to
the transaction or optionally, a subset of of inputs and/or outputs (with
merkle trees we can easily avoid the exponential signature validation problems
bitcoin currently has).

As so long as all genesis transactions are unique, and our hash function is
secure, all transaction outputs can be uniquely identified (prior to BIP34 the
Bitcoin protocol actually failed at this!).


## Proof Distribution

How does Alice convince Bob that she has done a transaction that puts the
system into the state that Bob wanted? The obvious answer is she gives Bob data
proving that the system is now in the desired state; in a transactional system
that proof is some or all of the transaction history. Systems like Bitcoin
provide a generic flood-fill messaging layer where all participants have the
opportunity to get a copy of all proofs in the system, however we can also
implement more fine grained solutions based on peer-to-peer message passing -
one could imagine Alice proving to Bob that she transferred title to her house
to him by giving him a series of proofs, not unlike the same way that property
title transfer can be demonstrated by providing the buyer with a series of deed
documents (though note the double-spend problem!).


# Uniqueness and Single-Use Seals

In addition to knowing that a given transaction history is valid, we also want
to know if it's unique. By that we mean that every spent output in the
transaction history is associated with exactly one input, and no other valid
spends exist; we want to ensure no output has been double-spent.

Bitcoin (and pretty much every other cryptocurrency like it) achieves this goal
by defining a method of achieving consensus over the set of all (valid)
transactions, and then defining that consensus as valid if and only if no
output is spent more than once.

A more general approach is to introduce the idea of a cryptographic Single-Use
Seal, analogous to the tamper-evidence single-use seals commonly used for
protecting goods during shipment and storage. Each individual seals is
associated with a globally unique identifier, and has two states, open and
closed. A secure seal can be closed exactly once, producing a proof that the
seal was closed.

All practical single-use seals will be associated with some kind of condition,
such as a pubkey, or deterministic expression, that needs to be satisfied for
the seal to be closed. Secondly, the contents of the proof will be able to
commit to new data, such as the transaction spending the output associated with
the seal.

Additionally some implementations of single-use seals may be able to also
generate a proof that a seal was _not_ closed as of a certain
time/block-height/etc.


## Implementations

### Transactional Blockchains

A transaction output on a system like Bitcoin can be used as a single-use seal.
In this implementation, the outpoint (txid:vout #) is the seal's identifier,
the authorization mechanism is the scriptPubKey of the output, and the proof
is the transaction spending the output. The proof can commit to additional
data as needed in a variety of ways, such as an OP_RETURN output, or
unspendable output.

This implementation approach is resistant to miner censorship if the seal's
identifier isn't made public, and the protocol (optionally) allows for the
proof transaction to commit to the sealed contents with unspendable outputs;
unspendable outputs can't be distinguished from transactions that move funds.


### Unbounded Oracles

A trusted oracle P can maintain a set of closed seals, and produce signed
messages attesting to the fact that a seal was closed. Specifically, the seal
is identified by the tuple (P, q), with q being the per-seal authorization
expression that must be satisfied for the seal to be closed. The first time the
oracle is given a valid signature for the seal, it adds that signature and seal
ID to its closed seal set, and makes available a signed message attesting to
the fact that the seal has been closed. The proof is that message (and
possibly the signature, or a second message signed by it).

The oracle can publish the set of all closed seals for transparency/auditing
purposes. A good way to do this is to make a merkelized key:value set, with the
seal identifiers as keys, and the value being the proofs, and in turn create a
signed certificate transparency log of that set over time. Merkle-paths from
this log can also serve as the closed seal proof, and for that matter, as
proof of the fact that a seal has not been closed.


### Bounded Oracles

The above has the problem of unbounded storage requirements as the closed seal
set grows without bound. We can fix that problem by requiring users of the
oracle to allocate seals in advance, analogous to the UTXO set in Bitcoin.

To allocate a seal the user provides the oracle P with the authorization
expression q. The oracle then generates a nonce n and adds (q,n) to the set of
unclosed seals, and tells the user that nonce. The seal is then uniquely
identified by (P, q, n)

To close a seal, the user provides the oracle with a valid signature over (P,
q, n). If the open seal set contains that seal, the seal is removed from the
set and the oracle provides the user with a signed message attesting to the
valid close.

A practical implementation would be to have the oracle publish a transparency
log, with each entry in the log committing to the set of all open seals with a
merkle set, as well as any seals closed during that entry. Again, merkle paths
for this log can serve as proofs to the open or closed state of a seal.

Note how with (U)TXO commitments, Bitcoin itself is a bounded oracle
implementation that can produce compact proofs.


### Group Seals

Multiple seals can be combined into one, by having the open seal commit to a
set of sub-seals, and then closing the seal over a second set of closed seal
proofs. Seals that didn't need to be closed can be closed over a special
re-delegation message, re-delegating the seal to a new open seal.

Since the closed sub-seal proof can additionally include a proof of
authorization, we have a protcol where the entity with authorization to close
the master seal has the ability to DoS attack sub-seals owners, but not the
ability to fraudulently close the seals over contents of their choosing. This
may be useful in cases where actions on the master seal is expensive - such as
seals implemented on top of decentralized blockchains - by amortising the cost
over all sub-seals.


## Atomicity

Often protocols will require multiple seals to be closed for a transaction to
be valid. If a single entity controls all seals, this is no problem: the
transaction simply isn't valid until the last seal is closed.

However if multiple parties control the seals, a party could attack another
party by failing to go through with the transaction, after another party has
closed their seal, leaving the victim with an invalid transaction that they
can't reverse.

We have a few options to resolve this problem:

### Use a single oracle

The oracle can additionally guarantee that a seal will be closed iff some other
set of seals are also closed; seals implemented with Bitcoin can provide this
guarantee. If the parties to a transaction aren't already all on the same
oracle, they can add an additional transaction reassigning their outputs to a
common oracle.

Equally, a temporary consensus between multiple mutually trusting oracles can
be created with a consensus protocol they share; this option doesn't need to
change the proof verification implementation.


### Two-phase Timeouts

If a proof to the fact that a seal is open can be generated, even under
adversarial conditions, we can make the seal protocol allow a close to be
undone after a timeout if evidence can be provided that the other seal(s) were
not also closed (in the specified way).

Depending on the implementation - especially in decentralized systems - the
next time the seal is closed, the proof it has been closed may in turn provide
proof that a previous close was in fact invalid.


# Proof-of-Publication and Proof-of-Non-Publication

Often we need to be able to prove that a specified audience was able to receive
a specific message. For example, the author's PayPub protocol[^paypub],
Todd/Taaki's timelock encryption protocol[^timelock], Zero-Knowledge Contingent
Payments[^zkcp], and Lightning, among others work by requiring a secret key to
be published publicly in the Bitcoin blockchain as a condition of collecting a
payment. At a much smaller scale - in terms of audience - in certain FinTech
applications for regulated environments a transaction may be considered invalid
unless it was provably published to a regulatory agency.  Another example is
Certificate Transparency, where we consider a SSL certificate to be invalid
unless it has been provably published to a transparency log maintained by a
third-party.

Secondly, many proof-of-publication schemes also can prove that a message was
_not_ published to a specific audience. With this type of proof single-use
seals can be implemented, by having the proof consist of proof that a specified
message was not published between the time the seal was created, and the time
it was closed (a proof-of-publication of the message).

## Implementations

### Decentralized Blockchains

Here the audience is all participants in the system. However miner censorship
can be a problem, and compact proofs of non-publication aren't yet available
(requires (U)TXO commitments).

The authors treechains proposal is a particularly generic and scalable
implementation, with the ability to make trade offs between the size of
audience (security) and publication cost.

### Centralized Public Logs

Certificate Transparency works this way, with trusted (but auditable) logs run
by well known parties acting as the publication medium, who promise to allow
anyone to obtain copies of the logs.

The logs themselves may be indexed in a variety of ways; CT simply indexes logs
by time, however more efficient schemes are possible by having the operator
commit to a key:value mapping of "topics", to allow publication (and
non-publication) proofs to be created for specified topics or topic prefixes.

Auditing the logs is done by verifying that queries to the state of the log
return the same state at the same time for different requesters.

### Receipt Oracles

Finally publication can be proven by a receipt proof by the oracle, attesting
to the fact that the oracle has successfully received the message. This is
particularly appropriate in cases where the required audience is the oracle
itself, as in the FinTech regulator case.


# Validity Oracles

As transaction histories grow longer, they may become impractical to move from
one party to another. Validity oracles can solve this problem by attesting to
the validity of transactions, allowing history prior to the attested
transactions to be discarded.

A particularly generic validity oracle can be created using deterministic
expressions systems. The user gives the oracle an expression, and the oracle
returns a signed message attesting to the validity of the expression.
Optionally, the expression may be incomplete, with parts of the expression
replaced by previously generated attestations. For example, an expression that
returns true if a transaction is valid could in turn depend on the previous
transaction also being valid - a recursive call of itself - and that recursive
call can be proven with a prior attestation.

## Implementations

### Proof-of-Work Decentralized Consensus

Miners in decentralized consensus systems act as a type of validity oracle, in
that the economic incentives in the system are (supposed to be) designed to
encourage only the mining of valid blocks; a user who trusts the majority of
hashing power can trust that any transaction with a valid merkle path to a
block header in the most-work chain is valid. Existing decentralized consensus
systems like Bitcoin and Ethereum conflate the roles of validity oracle and
single-use seal/anti-replay oracle, however in principle that need not be true.


### Trusted Oracles

As the name suggests. Remote-attestation-capable trusted hardware is a
particularly powerful implementation - a conspiracy theory is that the reason
why essentially zero secure true remote attestation implementations exist is
because they'd immediately make untraceable digital currency systems easy to
implement (Finney's RPOW[^rpow] is a rare counter-example).

Note how a single-use seal oracle that supports a generic deterministic
expressions scheme for seal authorization can be easily extended to provide a
validity oracle service as well. The auditing mechanisms for a single-use seal
oracle can also be applied to validity oracles.


# Fraud Proofs

Protocols specified with deterministic expressions can easily generate "fraud
proofs", showing that claimed states/proof in the system are actually invalid.
Additionally many protocols can be specified with expressions of k*log2(n)
depth, allowing these fraud proofs to be compact.

A simple example is proving fraud in merkle-sum tree, where the validity
expression would be something like:

    (defun valid? (node)
        (or (== node.type leaf)
            (and (== node.sum (+ node.left.sum node.right.sum))
                 (and (valid? node.left)
                      (valid? node.right)))))

To prove the above expression evaluates to true, we'll need the entire contents
of the tree. However, to prove that it evaluates to false, we only need a
subset of the tree as proving an and expression evaluates to false only
requires one side, and requires log2(n) data. Secondly, with pruning, the
deterministic expressions evaluator can automatically keep track of exactly
what data was needed to prove that result, and prune all other data when
serializing the proof.


## Validity Challenges

However how do you guarantee it will be possible to prove fraud in the first
place? If pruning is allowed, you may simply not have access to the data
proving fraud - an especially severe problem in transactional systems where a
single fraudulent transaction can counterfeit arbitrary amounts of value out of
thin air.

A possible approach is the validity challenge: a subset of proof data, with
part of the data marked as "potentially fraudulent". The challenge can be
satisfied by providing the marked data and showing that the proof in question
is in fact valid; if the challenge is unmet participants in the system can
choose to take action, such as refusing to accept additional transactions.

Of course, this raises a whole host of so-far unsolved issues, such as DoS
attacks and lost data.


# Probabilistic Validation

Protocols that can tolerate some fraud can make use of probabilistic
verification techniques to prove that the percentage of undetected fraud within
the system is less than a certain amount, with a specified probability.

A common way to do this is the Fiat-Shamir transform, which repeatedly samples
a data structure deterministically, using the data's own hash digest as a seed
for a PRNG. Let's apply this technique to our merkle-sum tree example. We'll
first need a recursive function to check a sample, weighted by value:

    (defun prefix-valid? (node nonce)
        (or (== node.type leaf)
            (and (and (== node.sum (+ node.left.sum node.right.sum))
                      (> 0 node.sum)) ; mod by 0 is invalid, just like division by zero
                                      ; also could guarantee this with a type system
                 (and (if (< node.left.sum (mod nonce node.sum))
                          (prefix-valid? node.right (hash nonce))
                          (prefix-valid? node.left (hash nonce)))))))

Now we can combine multiple invocations of the above, in this case 256
invocations:

    (defun prob-valid? (node)
        (and (and (and .... (prefix-valid? node (digest (cons (digest node) 0)))
             (and (and ....
                            (prefix-valid? node (digest (cons (digest node) 255)))

As an exercise for a reader: generalize the above with a macro, or a suitable
types/generics system.

If we assume our attacker can grind up to 128 bits, that leaves us with 128
random samples that they can't control. If the (value weighted) probability of
a given node is fraudulent q, then the chance of the attacker getting away with
fraud is (1-q)^128 - for q=5% that works out to 0.1%

(Note that the above analysis isn't particularly well done - do a better
analysis before implementing this in production!)


## Random Beacons and Transaction History Linearization

The Fiat-Shamir transform requires a significant number of samples to defeat
grinding attacks; if we have a random beacon available we can significantly
reduce the size of our probabilistic proofs. PoW blockchains can themselves act
as random beacons, as it is provably expensive for miners to manipulate the
hash digests of blocks they produce - to do so requires discarding otherwise
valid blocks.

An example where this capability is essential is the author's transaction
history linearization technique. In value transfer systems such as Bitcoin, the
history of any given coin grows quasi-exponentially as coins are mixed across
the entire economy. We can linearize the growth of history proofs by redefining
coin validity to be probabilistic.

Suppose we have a transaction with n inputs. Of those inputs, the total value
of real inputs is p, and the total claimed value of fake inputs is q. The
transaction commits to all inputs in a merkle sum tree, and we define the
transaction as valid if a randomly chosen input - weighted by value - can
itself be proven valid. Finally, we assume that creating a genuine input is a
irrevocable action which irrevocable commits to the set of all inputs, real and
fake.

If all inputs are real, 100% of the time the transaction will be valid; if all
inputs are fake, 100% of the time the transaction will be invalid. In the case
where some inputs are real and some are fake the probability that the fraud
will be detected is:

    q / (q + p)

The expected value of the fake inputs is then the sum of the potential upside -
the fraud goes detected - and the potential downside - the fraud is detected
and the real inputs are destroyed:

    E = q(1 - q/(q + p)) - p(q/(q + p)
      = q(p/(q + p)) - p(q/(q + p)
      = (q - q)(p/(q + p))
      = 0

Thus so long as the random beacon is truly unpredictable, there's no economic
advantage to creating fake inputs, and it is sufficient for validity to only
require one input to be proven, giving us O(n) scaling for transaction history
proofs.


### Inflationary O(1) History Proofs

We can further improve our transaction history proof scalability by taking
advantage of inflation. We do this by occasionally allowing a transaction proof
to be considered valid without validating _any_ of the inputs; every time a
transaction is allowed without proving any inputs the size of the transaction
history proof is reset. Of course, this can be a source of inflation, but
provided the probability of this happening can be limited we can limit the
maximum rate of inflation to the chosen value.

For example, in Bitcoin as of writing every block inflates the currency supply
by 25BTC, and contains a maximum of 1MB of transaction data, 0.025BTC/KB. If we
check the prior input proof with probability p, then the expected value of a
transaction claiming to spend x BTC is:

    E = x(1-p)

We can rewrite that in terms of the block reward per-byte R, and the transaction size l:

    lR = x(1-p)

And solving for p:

    p = 1 - lR/x

For example, for a 1KB transaction proof claiming to spending 10BTC we can omit
checking the input 0.25% of the time without allowing more monetary inflation
than the block reward already does. Secondly, this means that after n
transactions, the probability that proof shortening will _not_ happen is p^n,
which reaches 1% after 1840 transactions.

In a system like Bitcoin where miners are expected to validate, a transaction
proof could consist of just a single merkle path showing that a single-use seal
was closed in some kind of TXO commitment - probably under 10KB of data. That
gives us a history proof less than 18.4MB in size, 99% of the time, and less
than 9.2MB in size 90% of the time.

An interesting outcome of thing kind of design is that we can institutionalize
inflation fraud: the entire block reward can be replaced by miners rolling the
dice, attempting to create valid "fake" transactions. However, such a pure
implementation would put a floor on the lowest transaction fee possible, so
better to allow both transaction fee and subsidy collection at the same time.


# References

[^paypub] https://github.com/unsystem/paypub
[^timelock] https://github.com/petertodd/timelock
[^zkcp] https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/
[^rpow] https://cryptome.org/rpow.htm

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160620/73f11845/attachment.sig>

From PoliceTerror at dyne.org  Mon Jun 20 13:26:22 2016
From: PoliceTerror at dyne.org (Police Terror)
Date: Mon, 20 Jun 2016 13:26:22 +0000
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
 Consensus
In-Reply-To: <20160620085649.GA29964@fedora-21-dvm>
References: <20160620085649.GA29964@fedora-21-dvm>
Message-ID: <5767EEFE.7060103@dyne.org>

Bitcoin could embed a lisp interpreter such as Scheme, reverse engineer
the current protocol into lisp (inside C++), run this alternative engine
alongside the current one as an option for some years (only for fine
tuning) then eventually fade this lisp written validation code instead
of the current one.

Scheme is small and minimal, and embeds easily in C++. This could be a
better option than the libconsensus library - validation in a functional
scripting language.

That doesn't mean people can't program the validation code in other
languages (maybe they'd want to optimize), but this code would be the
standard.

It's really good how you are thinking deeply how Bitcoin can be used,
and the implications of everything. Also there's a lot of magical utopic
thinking in Ethereum, which is transhumanist nonsense that is life
denying. Bitcoin really speaks to me because it is real and a great tool
following the UNIX principle.

I wouldn't be so quick to deride good engineering over systematic
provable systems for all domains. Bitcoin being written in C++ is not a
defect. It's actually a strong language for what it does. Especially
when used correctly (which is not often and takes years to master).

With the seals idea- am I understand this correctly?: Every transaction
has a number (essentially the index starting from 0 upwards) depending
on where it is in the blockchain.

Then there is an array (probably an on disk array mapping transaction
indexes to hashes). Each hash entry in the array must be unique (the
hashes) otherwise the transaction will be denied. This is a great idea
to solve transaction hash collisions and simple to implement.

Probabilistic validation is a good idea, although the real difficulty
now seems to be writing and indexing all the blockchain data for
lookups. And validation is disabled for most of the blocks. Pruning is
only a stop gap measure (which loses data) that doesn't solve the issue
of continually growing resource consumption. Hardware and implementation
can only mitigate this so much. If only there was a way to simplify the
underlying protocol to make it more resource efficient...

Peter Todd via bitcoin-dev:
> In light of Ethereum's recent problems with its imperative, account-based,
> programming model, I thought I'd do a quick writeup outlining the building
> blocks of the state-machine approach to so-called "smart contract" systems, an
> extension of Bitcoin's own design that I personally have been developing for a
> number of years now as my Proofchains/Dex research work.
> 
> 
> # Deterministic Code / Deterministic Expressions
> 
> We need to be able to run code on different computers and get identical
> results; without this consensus is impossible and we might as well just use a
> central authoritative database. Traditional languages and surrounding
> frameworks make determinism difficult to achieve, as they tend to be filled
> with undefined and underspecified behavior, ranging from signed integer
> overflow in C/C++ to non-deterministic behavior in databases. While some
> successful systems like Bitcoin are based on such languages, their success is
> attributable to heroic efforts by their developers.
> 
> Deterministic expression systems such as Bitcoin's scripting system and the
> author's Dex project improve on this by allowing expressions to be precisely
> specified by hash digest, and executed against an environment with
> deterministic results. In the case of Bitcoin's script, the expression is a
> Forth-like stack-based program; in Dex the expression takes the form of a
> lambda calculus expression.
> 
> 
> ## Proofs
> 
> So far the most common use for deterministic expressions is to specify
> conditions upon which funds can be spent, as seen in Bitcoin (particularly
> P2SH, and the upcoming Segwit). But we can generalize their use to precisely
> defining consensus protocols in terms of state machines, with each state
> defined in terms of a deterministic expression that must return true for the
> state to have been reached. The data that causes a given expression to return
> true is then a "proof", and that proof can be passed from one party to another
> to prove desired states in the system have been reached.
> 
> An important implication of this model is that we need deterministic, and
> efficient, serialization of proof data.
> 
> 
> ## Pruning
> 
> Often the evaluation of an expression against a proof doesn't require all all
> data in the proof. For example, to prove to a lite client that a given block
> contains a transaction, we only need the merkle path from the transaction to
> the block header. Systems like Proofchains and Dex generalize this process -
> called "pruning" - with built-in support to both keep track of what data is
> accessed by what operations, as well as support in their underlying
> serialization schemes for unneeded data to be elided and replaced by the hash
> digest of the pruned data.
> 
> 
> # Transactions
> 
> A common type of state machine is the transaction. A transaction history is a
> directed acyclic graph of transactions, with one or more genesis transactions
> having no inputs (ancestors), and one or more outputs, and zero or more
> non-genesis transactions with one or more inputs, and zero or more outputs. The
> edges of the graph connect inputs to outputs, with every input connected to
> exactly one output. Outputs with an associated input are known as spent
> outputs; outputs with out an associated input are unspent.
> 
> Outputs have conditions attached to them (e.g. a pubkey for which a valid
> signature must be produced), and may also be associated with other values such
> as "# of coins". We consider a transaction valid if we have a set of proofs,
> one per input, that satisfy the conditions associated with each output.
> Secondly, validity may also require additional constraints to be true, such as
> requiring the coins spent to be >= the coins created on the outputs. Input
> proofs also must uniquely commit to the transaction itself to be secure - if
> they don't the proofs can be reused in a replay attack.
> 
> A non-genesis transaction is valid if:
> 
> 1. Any protocol-specific rules such as coins spent >= coins output are
>    followed.
> 
> 2. For every input a valid proof exists.
> 
> 3. Every input transaction is itself valid.
> 
> A practical implementation of the above for value-transfer systems like Bitcoin
> could use two merkle-sum trees, one for the inputs, and one for the outputs,
> with inputs simply committing to the previous transaction's txid and output #
> (outpoint), and outputs committing to a scriptPubKey and output amount.
> Witnesses can be provided separately, and would sign a signature committing to
> the transaction or optionally, a subset of of inputs and/or outputs (with
> merkle trees we can easily avoid the exponential signature validation problems
> bitcoin currently has).
> 
> As so long as all genesis transactions are unique, and our hash function is
> secure, all transaction outputs can be uniquely identified (prior to BIP34 the
> Bitcoin protocol actually failed at this!).
> 
> 
> ## Proof Distribution
> 
> How does Alice convince Bob that she has done a transaction that puts the
> system into the state that Bob wanted? The obvious answer is she gives Bob data
> proving that the system is now in the desired state; in a transactional system
> that proof is some or all of the transaction history. Systems like Bitcoin
> provide a generic flood-fill messaging layer where all participants have the
> opportunity to get a copy of all proofs in the system, however we can also
> implement more fine grained solutions based on peer-to-peer message passing -
> one could imagine Alice proving to Bob that she transferred title to her house
> to him by giving him a series of proofs, not unlike the same way that property
> title transfer can be demonstrated by providing the buyer with a series of deed
> documents (though note the double-spend problem!).
> 
> 
> # Uniqueness and Single-Use Seals
> 
> In addition to knowing that a given transaction history is valid, we also want
> to know if it's unique. By that we mean that every spent output in the
> transaction history is associated with exactly one input, and no other valid
> spends exist; we want to ensure no output has been double-spent.
> 
> Bitcoin (and pretty much every other cryptocurrency like it) achieves this goal
> by defining a method of achieving consensus over the set of all (valid)
> transactions, and then defining that consensus as valid if and only if no
> output is spent more than once.
> 
> A more general approach is to introduce the idea of a cryptographic Single-Use
> Seal, analogous to the tamper-evidence single-use seals commonly used for
> protecting goods during shipment and storage. Each individual seals is
> associated with a globally unique identifier, and has two states, open and
> closed. A secure seal can be closed exactly once, producing a proof that the
> seal was closed.
> 
> All practical single-use seals will be associated with some kind of condition,
> such as a pubkey, or deterministic expression, that needs to be satisfied for
> the seal to be closed. Secondly, the contents of the proof will be able to
> commit to new data, such as the transaction spending the output associated with
> the seal.
> 
> Additionally some implementations of single-use seals may be able to also
> generate a proof that a seal was _not_ closed as of a certain
> time/block-height/etc.
> 
> 
> ## Implementations
> 
> ### Transactional Blockchains
> 
> A transaction output on a system like Bitcoin can be used as a single-use seal.
> In this implementation, the outpoint (txid:vout #) is the seal's identifier,
> the authorization mechanism is the scriptPubKey of the output, and the proof
> is the transaction spending the output. The proof can commit to additional
> data as needed in a variety of ways, such as an OP_RETURN output, or
> unspendable output.
> 
> This implementation approach is resistant to miner censorship if the seal's
> identifier isn't made public, and the protocol (optionally) allows for the
> proof transaction to commit to the sealed contents with unspendable outputs;
> unspendable outputs can't be distinguished from transactions that move funds.
> 
> 
> ### Unbounded Oracles
> 
> A trusted oracle P can maintain a set of closed seals, and produce signed
> messages attesting to the fact that a seal was closed. Specifically, the seal
> is identified by the tuple (P, q), with q being the per-seal authorization
> expression that must be satisfied for the seal to be closed. The first time the
> oracle is given a valid signature for the seal, it adds that signature and seal
> ID to its closed seal set, and makes available a signed message attesting to
> the fact that the seal has been closed. The proof is that message (and
> possibly the signature, or a second message signed by it).
> 
> The oracle can publish the set of all closed seals for transparency/auditing
> purposes. A good way to do this is to make a merkelized key:value set, with the
> seal identifiers as keys, and the value being the proofs, and in turn create a
> signed certificate transparency log of that set over time. Merkle-paths from
> this log can also serve as the closed seal proof, and for that matter, as
> proof of the fact that a seal has not been closed.
> 
> 
> ### Bounded Oracles
> 
> The above has the problem of unbounded storage requirements as the closed seal
> set grows without bound. We can fix that problem by requiring users of the
> oracle to allocate seals in advance, analogous to the UTXO set in Bitcoin.
> 
> To allocate a seal the user provides the oracle P with the authorization
> expression q. The oracle then generates a nonce n and adds (q,n) to the set of
> unclosed seals, and tells the user that nonce. The seal is then uniquely
> identified by (P, q, n)
> 
> To close a seal, the user provides the oracle with a valid signature over (P,
> q, n). If the open seal set contains that seal, the seal is removed from the
> set and the oracle provides the user with a signed message attesting to the
> valid close.
> 
> A practical implementation would be to have the oracle publish a transparency
> log, with each entry in the log committing to the set of all open seals with a
> merkle set, as well as any seals closed during that entry. Again, merkle paths
> for this log can serve as proofs to the open or closed state of a seal.
> 
> Note how with (U)TXO commitments, Bitcoin itself is a bounded oracle
> implementation that can produce compact proofs.
> 
> 
> ### Group Seals
> 
> Multiple seals can be combined into one, by having the open seal commit to a
> set of sub-seals, and then closing the seal over a second set of closed seal
> proofs. Seals that didn't need to be closed can be closed over a special
> re-delegation message, re-delegating the seal to a new open seal.
> 
> Since the closed sub-seal proof can additionally include a proof of
> authorization, we have a protcol where the entity with authorization to close
> the master seal has the ability to DoS attack sub-seals owners, but not the
> ability to fraudulently close the seals over contents of their choosing. This
> may be useful in cases where actions on the master seal is expensive - such as
> seals implemented on top of decentralized blockchains - by amortising the cost
> over all sub-seals.
> 
> 
> ## Atomicity
> 
> Often protocols will require multiple seals to be closed for a transaction to
> be valid. If a single entity controls all seals, this is no problem: the
> transaction simply isn't valid until the last seal is closed.
> 
> However if multiple parties control the seals, a party could attack another
> party by failing to go through with the transaction, after another party has
> closed their seal, leaving the victim with an invalid transaction that they
> can't reverse.
> 
> We have a few options to resolve this problem:
> 
> ### Use a single oracle
> 
> The oracle can additionally guarantee that a seal will be closed iff some other
> set of seals are also closed; seals implemented with Bitcoin can provide this
> guarantee. If the parties to a transaction aren't already all on the same
> oracle, they can add an additional transaction reassigning their outputs to a
> common oracle.
> 
> Equally, a temporary consensus between multiple mutually trusting oracles can
> be created with a consensus protocol they share; this option doesn't need to
> change the proof verification implementation.
> 
> 
> ### Two-phase Timeouts
> 
> If a proof to the fact that a seal is open can be generated, even under
> adversarial conditions, we can make the seal protocol allow a close to be
> undone after a timeout if evidence can be provided that the other seal(s) were
> not also closed (in the specified way).
> 
> Depending on the implementation - especially in decentralized systems - the
> next time the seal is closed, the proof it has been closed may in turn provide
> proof that a previous close was in fact invalid.
> 
> 
> # Proof-of-Publication and Proof-of-Non-Publication
> 
> Often we need to be able to prove that a specified audience was able to receive
> a specific message. For example, the author's PayPub protocol[^paypub],
> Todd/Taaki's timelock encryption protocol[^timelock], Zero-Knowledge Contingent
> Payments[^zkcp], and Lightning, among others work by requiring a secret key to
> be published publicly in the Bitcoin blockchain as a condition of collecting a
> payment. At a much smaller scale - in terms of audience - in certain FinTech
> applications for regulated environments a transaction may be considered invalid
> unless it was provably published to a regulatory agency.  Another example is
> Certificate Transparency, where we consider a SSL certificate to be invalid
> unless it has been provably published to a transparency log maintained by a
> third-party.
> 
> Secondly, many proof-of-publication schemes also can prove that a message was
> _not_ published to a specific audience. With this type of proof single-use
> seals can be implemented, by having the proof consist of proof that a specified
> message was not published between the time the seal was created, and the time
> it was closed (a proof-of-publication of the message).
> 
> ## Implementations
> 
> ### Decentralized Blockchains
> 
> Here the audience is all participants in the system. However miner censorship
> can be a problem, and compact proofs of non-publication aren't yet available
> (requires (U)TXO commitments).
> 
> The authors treechains proposal is a particularly generic and scalable
> implementation, with the ability to make trade offs between the size of
> audience (security) and publication cost.
> 
> ### Centralized Public Logs
> 
> Certificate Transparency works this way, with trusted (but auditable) logs run
> by well known parties acting as the publication medium, who promise to allow
> anyone to obtain copies of the logs.
> 
> The logs themselves may be indexed in a variety of ways; CT simply indexes logs
> by time, however more efficient schemes are possible by having the operator
> commit to a key:value mapping of "topics", to allow publication (and
> non-publication) proofs to be created for specified topics or topic prefixes.
> 
> Auditing the logs is done by verifying that queries to the state of the log
> return the same state at the same time for different requesters.
> 
> ### Receipt Oracles
> 
> Finally publication can be proven by a receipt proof by the oracle, attesting
> to the fact that the oracle has successfully received the message. This is
> particularly appropriate in cases where the required audience is the oracle
> itself, as in the FinTech regulator case.
> 
> 
> # Validity Oracles
> 
> As transaction histories grow longer, they may become impractical to move from
> one party to another. Validity oracles can solve this problem by attesting to
> the validity of transactions, allowing history prior to the attested
> transactions to be discarded.
> 
> A particularly generic validity oracle can be created using deterministic
> expressions systems. The user gives the oracle an expression, and the oracle
> returns a signed message attesting to the validity of the expression.
> Optionally, the expression may be incomplete, with parts of the expression
> replaced by previously generated attestations. For example, an expression that
> returns true if a transaction is valid could in turn depend on the previous
> transaction also being valid - a recursive call of itself - and that recursive
> call can be proven with a prior attestation.
> 
> ## Implementations
> 
> ### Proof-of-Work Decentralized Consensus
> 
> Miners in decentralized consensus systems act as a type of validity oracle, in
> that the economic incentives in the system are (supposed to be) designed to
> encourage only the mining of valid blocks; a user who trusts the majority of
> hashing power can trust that any transaction with a valid merkle path to a
> block header in the most-work chain is valid. Existing decentralized consensus
> systems like Bitcoin and Ethereum conflate the roles of validity oracle and
> single-use seal/anti-replay oracle, however in principle that need not be true.
> 
> 
> ### Trusted Oracles
> 
> As the name suggests. Remote-attestation-capable trusted hardware is a
> particularly powerful implementation - a conspiracy theory is that the reason
> why essentially zero secure true remote attestation implementations exist is
> because they'd immediately make untraceable digital currency systems easy to
> implement (Finney's RPOW[^rpow] is a rare counter-example).
> 
> Note how a single-use seal oracle that supports a generic deterministic
> expressions scheme for seal authorization can be easily extended to provide a
> validity oracle service as well. The auditing mechanisms for a single-use seal
> oracle can also be applied to validity oracles.
> 
> 
> # Fraud Proofs
> 
> Protocols specified with deterministic expressions can easily generate "fraud
> proofs", showing that claimed states/proof in the system are actually invalid.
> Additionally many protocols can be specified with expressions of k*log2(n)
> depth, allowing these fraud proofs to be compact.
> 
> A simple example is proving fraud in merkle-sum tree, where the validity
> expression would be something like:
> 
>     (defun valid? (node)
>         (or (== node.type leaf)
>             (and (== node.sum (+ node.left.sum node.right.sum))
>                  (and (valid? node.left)
>                       (valid? node.right)))))
> 
> To prove the above expression evaluates to true, we'll need the entire contents
> of the tree. However, to prove that it evaluates to false, we only need a
> subset of the tree as proving an and expression evaluates to false only
> requires one side, and requires log2(n) data. Secondly, with pruning, the
> deterministic expressions evaluator can automatically keep track of exactly
> what data was needed to prove that result, and prune all other data when
> serializing the proof.
> 
> 
> ## Validity Challenges
> 
> However how do you guarantee it will be possible to prove fraud in the first
> place? If pruning is allowed, you may simply not have access to the data
> proving fraud - an especially severe problem in transactional systems where a
> single fraudulent transaction can counterfeit arbitrary amounts of value out of
> thin air.
> 
> A possible approach is the validity challenge: a subset of proof data, with
> part of the data marked as "potentially fraudulent". The challenge can be
> satisfied by providing the marked data and showing that the proof in question
> is in fact valid; if the challenge is unmet participants in the system can
> choose to take action, such as refusing to accept additional transactions.
> 
> Of course, this raises a whole host of so-far unsolved issues, such as DoS
> attacks and lost data.
> 
> 
> # Probabilistic Validation
> 
> Protocols that can tolerate some fraud can make use of probabilistic
> verification techniques to prove that the percentage of undetected fraud within
> the system is less than a certain amount, with a specified probability.
> 
> A common way to do this is the Fiat-Shamir transform, which repeatedly samples
> a data structure deterministically, using the data's own hash digest as a seed
> for a PRNG. Let's apply this technique to our merkle-sum tree example. We'll
> first need a recursive function to check a sample, weighted by value:
> 
>     (defun prefix-valid? (node nonce)
>         (or (== node.type leaf)
>             (and (and (== node.sum (+ node.left.sum node.right.sum))
>                       (> 0 node.sum)) ; mod by 0 is invalid, just like division by zero
>                                       ; also could guarantee this with a type system
>                  (and (if (< node.left.sum (mod nonce node.sum))
>                           (prefix-valid? node.right (hash nonce))
>                           (prefix-valid? node.left (hash nonce)))))))
> 
> Now we can combine multiple invocations of the above, in this case 256
> invocations:
> 
>     (defun prob-valid? (node)
>         (and (and (and .... (prefix-valid? node (digest (cons (digest node) 0)))
>              (and (and ....
>                             (prefix-valid? node (digest (cons (digest node) 255)))
> 
> As an exercise for a reader: generalize the above with a macro, or a suitable
> types/generics system.
> 
> If we assume our attacker can grind up to 128 bits, that leaves us with 128
> random samples that they can't control. If the (value weighted) probability of
> a given node is fraudulent q, then the chance of the attacker getting away with
> fraud is (1-q)^128 - for q=5% that works out to 0.1%
> 
> (Note that the above analysis isn't particularly well done - do a better
> analysis before implementing this in production!)
> 
> 
> ## Random Beacons and Transaction History Linearization
> 
> The Fiat-Shamir transform requires a significant number of samples to defeat
> grinding attacks; if we have a random beacon available we can significantly
> reduce the size of our probabilistic proofs. PoW blockchains can themselves act
> as random beacons, as it is provably expensive for miners to manipulate the
> hash digests of blocks they produce - to do so requires discarding otherwise
> valid blocks.
> 
> An example where this capability is essential is the author's transaction
> history linearization technique. In value transfer systems such as Bitcoin, the
> history of any given coin grows quasi-exponentially as coins are mixed across
> the entire economy. We can linearize the growth of history proofs by redefining
> coin validity to be probabilistic.
> 
> Suppose we have a transaction with n inputs. Of those inputs, the total value
> of real inputs is p, and the total claimed value of fake inputs is q. The
> transaction commits to all inputs in a merkle sum tree, and we define the
> transaction as valid if a randomly chosen input - weighted by value - can
> itself be proven valid. Finally, we assume that creating a genuine input is a
> irrevocable action which irrevocable commits to the set of all inputs, real and
> fake.
> 
> If all inputs are real, 100% of the time the transaction will be valid; if all
> inputs are fake, 100% of the time the transaction will be invalid. In the case
> where some inputs are real and some are fake the probability that the fraud
> will be detected is:
> 
>     q / (q + p)
> 
> The expected value of the fake inputs is then the sum of the potential upside -
> the fraud goes detected - and the potential downside - the fraud is detected
> and the real inputs are destroyed:
> 
>     E = q(1 - q/(q + p)) - p(q/(q + p)
>       = q(p/(q + p)) - p(q/(q + p)
>       = (q - q)(p/(q + p))
>       = 0
> 
> Thus so long as the random beacon is truly unpredictable, there's no economic
> advantage to creating fake inputs, and it is sufficient for validity to only
> require one input to be proven, giving us O(n) scaling for transaction history
> proofs.
> 
> 
> ### Inflationary O(1) History Proofs
> 
> We can further improve our transaction history proof scalability by taking
> advantage of inflation. We do this by occasionally allowing a transaction proof
> to be considered valid without validating _any_ of the inputs; every time a
> transaction is allowed without proving any inputs the size of the transaction
> history proof is reset. Of course, this can be a source of inflation, but
> provided the probability of this happening can be limited we can limit the
> maximum rate of inflation to the chosen value.
> 
> For example, in Bitcoin as of writing every block inflates the currency supply
> by 25BTC, and contains a maximum of 1MB of transaction data, 0.025BTC/KB. If we
> check the prior input proof with probability p, then the expected value of a
> transaction claiming to spend x BTC is:
> 
>     E = x(1-p)
> 
> We can rewrite that in terms of the block reward per-byte R, and the transaction size l:
> 
>     lR = x(1-p)
> 
> And solving for p:
> 
>     p = 1 - lR/x
> 
> For example, for a 1KB transaction proof claiming to spending 10BTC we can omit
> checking the input 0.25% of the time without allowing more monetary inflation
> than the block reward already does. Secondly, this means that after n
> transactions, the probability that proof shortening will _not_ happen is p^n,
> which reaches 1% after 1840 transactions.
> 
> In a system like Bitcoin where miners are expected to validate, a transaction
> proof could consist of just a single merkle path showing that a single-use seal
> was closed in some kind of TXO commitment - probably under 10KB of data. That
> gives us a history proof less than 18.4MB in size, 99% of the time, and less
> than 9.2MB in size 90% of the time.
> 
> An interesting outcome of thing kind of design is that we can institutionalize
> inflation fraud: the entire block reward can be replaced by miners rolling the
> dice, attempting to create valid "fake" transactions. However, such a pure
> implementation would put a floor on the lowest transaction fee possible, so
> better to allow both transaction fee and subsidy collection at the same time.
> 
> 
> # References
> 
> [^paypub] https://github.com/unsystem/paypub
> [^timelock] https://github.com/petertodd/timelock
> [^zkcp] https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/
> [^rpow] https://cryptome.org/rpow.htm
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From zaki at manian.org  Mon Jun 20 16:21:39 2016
From: zaki at manian.org (zaki at manian.org)
Date: Mon, 20 Jun 2016 16:21:39 +0000
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
	Consensus
In-Reply-To: <5767EEFE.7060103@dyne.org>
References: <20160620085649.GA29964@fedora-21-dvm> <5767EEFE.7060103@dyne.org>
Message-ID: <CAJQ8TmBw3PdCYv=fsyiXMTNO_sHZEj__n0Rsra6id+ORxQworA@mail.gmail.com>

Hi Peter,

I didn't entirely understand the process of transaction linearization.

What I see is a potential process where when the miner assembles the block,
he strips all but one sigscript per tx. The selection of which  sigscript
is retained is determined by the random oracle.  Is this is primary benefit
you are suggesting?

It appears to me that blocks still need to contain a list of full TX Input
and Tx Outputs with your approach. Some of the description seems to
indicate that there are opportunities to elide further data but it's
unclear to me how.

On Mon, Jun 20, 2016 at 7:14 AM Police Terror via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Bitcoin could embed a lisp interpreter such as Scheme, reverse engineer
> the current protocol into lisp (inside C++), run this alternative engine
> alongside the current one as an option for some years (only for fine
> tuning) then eventually fade this lisp written validation code instead
> of the current one.
>
> Scheme is small and minimal, and embeds easily in C++. This could be a
> better option than the libconsensus library - validation in a functional
> scripting language.
>
> That doesn't mean people can't program the validation code in other
> languages (maybe they'd want to optimize), but this code would be the
> standard.
>
> It's really good how you are thinking deeply how Bitcoin can be used,
> and the implications of everything. Also there's a lot of magical utopic
> thinking in Ethereum, which is transhumanist nonsense that is life
> denying. Bitcoin really speaks to me because it is real and a great tool
> following the UNIX principle.
>
> I wouldn't be so quick to deride good engineering over systematic
> provable systems for all domains. Bitcoin being written in C++ is not a
> defect. It's actually a strong language for what it does. Especially
> when used correctly (which is not often and takes years to master).
>
> With the seals idea- am I understand this correctly?: Every transaction
> has a number (essentially the index starting from 0 upwards) depending
> on where it is in the blockchain.
>
> Then there is an array (probably an on disk array mapping transaction
> indexes to hashes). Each hash entry in the array must be unique (the
> hashes) otherwise the transaction will be denied. This is a great idea
> to solve transaction hash collisions and simple to implement.
>
> Probabilistic validation is a good idea, although the real difficulty
> now seems to be writing and indexing all the blockchain data for
> lookups. And validation is disabled for most of the blocks. Pruning is
> only a stop gap measure (which loses data) that doesn't solve the issue
> of continually growing resource consumption. Hardware and implementation
> can only mitigate this so much. If only there was a way to simplify the
> underlying protocol to make it more resource efficient...
>
> Peter Todd via bitcoin-dev:
> > In light of Ethereum's recent problems with its imperative,
> account-based,
> > programming model, I thought I'd do a quick writeup outlining the
> building
> > blocks of the state-machine approach to so-called "smart contract"
> systems, an
> > extension of Bitcoin's own design that I personally have been developing
> for a
> > number of years now as my Proofchains/Dex research work.
> >
> >
> > # Deterministic Code / Deterministic Expressions
> >
> > We need to be able to run code on different computers and get identical
> > results; without this consensus is impossible and we might as well just
> use a
> > central authoritative database. Traditional languages and surrounding
> > frameworks make determinism difficult to achieve, as they tend to be
> filled
> > with undefined and underspecified behavior, ranging from signed integer
> > overflow in C/C++ to non-deterministic behavior in databases. While some
> > successful systems like Bitcoin are based on such languages, their
> success is
> > attributable to heroic efforts by their developers.
> >
> > Deterministic expression systems such as Bitcoin's scripting system and
> the
> > author's Dex project improve on this by allowing expressions to be
> precisely
> > specified by hash digest, and executed against an environment with
> > deterministic results. In the case of Bitcoin's script, the expression
> is a
> > Forth-like stack-based program; in Dex the expression takes the form of a
> > lambda calculus expression.
> >
> >
> > ## Proofs
> >
> > So far the most common use for deterministic expressions is to specify
> > conditions upon which funds can be spent, as seen in Bitcoin
> (particularly
> > P2SH, and the upcoming Segwit). But we can generalize their use to
> precisely
> > defining consensus protocols in terms of state machines, with each state
> > defined in terms of a deterministic expression that must return true for
> the
> > state to have been reached. The data that causes a given expression to
> return
> > true is then a "proof", and that proof can be passed from one party to
> another
> > to prove desired states in the system have been reached.
> >
> > An important implication of this model is that we need deterministic, and
> > efficient, serialization of proof data.
> >
> >
> > ## Pruning
> >
> > Often the evaluation of an expression against a proof doesn't require
> all all
> > data in the proof. For example, to prove to a lite client that a given
> block
> > contains a transaction, we only need the merkle path from the
> transaction to
> > the block header. Systems like Proofchains and Dex generalize this
> process -
> > called "pruning" - with built-in support to both keep track of what data
> is
> > accessed by what operations, as well as support in their underlying
> > serialization schemes for unneeded data to be elided and replaced by the
> hash
> > digest of the pruned data.
> >
> >
> > # Transactions
> >
> > A common type of state machine is the transaction. A transaction history
> is a
> > directed acyclic graph of transactions, with one or more genesis
> transactions
> > having no inputs (ancestors), and one or more outputs, and zero or more
> > non-genesis transactions with one or more inputs, and zero or more
> outputs. The
> > edges of the graph connect inputs to outputs, with every input connected
> to
> > exactly one output. Outputs with an associated input are known as spent
> > outputs; outputs with out an associated input are unspent.
> >
> > Outputs have conditions attached to them (e.g. a pubkey for which a valid
> > signature must be produced), and may also be associated with other
> values such
> > as "# of coins". We consider a transaction valid if we have a set of
> proofs,
> > one per input, that satisfy the conditions associated with each output.
> > Secondly, validity may also require additional constraints to be true,
> such as
> > requiring the coins spent to be >= the coins created on the outputs.
> Input
> > proofs also must uniquely commit to the transaction itself to be secure
> - if
> > they don't the proofs can be reused in a replay attack.
> >
> > A non-genesis transaction is valid if:
> >
> > 1. Any protocol-specific rules such as coins spent >= coins output are
> >    followed.
> >
> > 2. For every input a valid proof exists.
> >
> > 3. Every input transaction is itself valid.
> >
> > A practical implementation of the above for value-transfer systems like
> Bitcoin
> > could use two merkle-sum trees, one for the inputs, and one for the
> outputs,
> > with inputs simply committing to the previous transaction's txid and
> output #
> > (outpoint), and outputs committing to a scriptPubKey and output amount.
> > Witnesses can be provided separately, and would sign a signature
> committing to
> > the transaction or optionally, a subset of of inputs and/or outputs (with
> > merkle trees we can easily avoid the exponential signature validation
> problems
> > bitcoin currently has).
> >
> > As so long as all genesis transactions are unique, and our hash function
> is
> > secure, all transaction outputs can be uniquely identified (prior to
> BIP34 the
> > Bitcoin protocol actually failed at this!).
> >
> >
> > ## Proof Distribution
> >
> > How does Alice convince Bob that she has done a transaction that puts the
> > system into the state that Bob wanted? The obvious answer is she gives
> Bob data
> > proving that the system is now in the desired state; in a transactional
> system
> > that proof is some or all of the transaction history. Systems like
> Bitcoin
> > provide a generic flood-fill messaging layer where all participants have
> the
> > opportunity to get a copy of all proofs in the system, however we can
> also
> > implement more fine grained solutions based on peer-to-peer message
> passing -
> > one could imagine Alice proving to Bob that she transferred title to her
> house
> > to him by giving him a series of proofs, not unlike the same way that
> property
> > title transfer can be demonstrated by providing the buyer with a series
> of deed
> > documents (though note the double-spend problem!).
> >
> >
> > # Uniqueness and Single-Use Seals
> >
> > In addition to knowing that a given transaction history is valid, we
> also want
> > to know if it's unique. By that we mean that every spent output in the
> > transaction history is associated with exactly one input, and no other
> valid
> > spends exist; we want to ensure no output has been double-spent.
> >
> > Bitcoin (and pretty much every other cryptocurrency like it) achieves
> this goal
> > by defining a method of achieving consensus over the set of all (valid)
> > transactions, and then defining that consensus as valid if and only if no
> > output is spent more than once.
> >
> > A more general approach is to introduce the idea of a cryptographic
> Single-Use
> > Seal, analogous to the tamper-evidence single-use seals commonly used for
> > protecting goods during shipment and storage. Each individual seals is
> > associated with a globally unique identifier, and has two states, open
> and
> > closed. A secure seal can be closed exactly once, producing a proof that
> the
> > seal was closed.
> >
> > All practical single-use seals will be associated with some kind of
> condition,
> > such as a pubkey, or deterministic expression, that needs to be
> satisfied for
> > the seal to be closed. Secondly, the contents of the proof will be able
> to
> > commit to new data, such as the transaction spending the output
> associated with
> > the seal.
> >
> > Additionally some implementations of single-use seals may be able to also
> > generate a proof that a seal was _not_ closed as of a certain
> > time/block-height/etc.
> >
> >
> > ## Implementations
> >
> > ### Transactional Blockchains
> >
> > A transaction output on a system like Bitcoin can be used as a
> single-use seal.
> > In this implementation, the outpoint (txid:vout #) is the seal's
> identifier,
> > the authorization mechanism is the scriptPubKey of the output, and the
> proof
> > is the transaction spending the output. The proof can commit to
> additional
> > data as needed in a variety of ways, such as an OP_RETURN output, or
> > unspendable output.
> >
> > This implementation approach is resistant to miner censorship if the
> seal's
> > identifier isn't made public, and the protocol (optionally) allows for
> the
> > proof transaction to commit to the sealed contents with unspendable
> outputs;
> > unspendable outputs can't be distinguished from transactions that move
> funds.
> >
> >
> > ### Unbounded Oracles
> >
> > A trusted oracle P can maintain a set of closed seals, and produce signed
> > messages attesting to the fact that a seal was closed. Specifically, the
> seal
> > is identified by the tuple (P, q), with q being the per-seal
> authorization
> > expression that must be satisfied for the seal to be closed. The first
> time the
> > oracle is given a valid signature for the seal, it adds that signature
> and seal
> > ID to its closed seal set, and makes available a signed message
> attesting to
> > the fact that the seal has been closed. The proof is that message (and
> > possibly the signature, or a second message signed by it).
> >
> > The oracle can publish the set of all closed seals for
> transparency/auditing
> > purposes. A good way to do this is to make a merkelized key:value set,
> with the
> > seal identifiers as keys, and the value being the proofs, and in turn
> create a
> > signed certificate transparency log of that set over time. Merkle-paths
> from
> > this log can also serve as the closed seal proof, and for that matter, as
> > proof of the fact that a seal has not been closed.
> >
> >
> > ### Bounded Oracles
> >
> > The above has the problem of unbounded storage requirements as the
> closed seal
> > set grows without bound. We can fix that problem by requiring users of
> the
> > oracle to allocate seals in advance, analogous to the UTXO set in
> Bitcoin.
> >
> > To allocate a seal the user provides the oracle P with the authorization
> > expression q. The oracle then generates a nonce n and adds (q,n) to the
> set of
> > unclosed seals, and tells the user that nonce. The seal is then uniquely
> > identified by (P, q, n)
> >
> > To close a seal, the user provides the oracle with a valid signature
> over (P,
> > q, n). If the open seal set contains that seal, the seal is removed from
> the
> > set and the oracle provides the user with a signed message attesting to
> the
> > valid close.
> >
> > A practical implementation would be to have the oracle publish a
> transparency
> > log, with each entry in the log committing to the set of all open seals
> with a
> > merkle set, as well as any seals closed during that entry. Again, merkle
> paths
> > for this log can serve as proofs to the open or closed state of a seal.
> >
> > Note how with (U)TXO commitments, Bitcoin itself is a bounded oracle
> > implementation that can produce compact proofs.
> >
> >
> > ### Group Seals
> >
> > Multiple seals can be combined into one, by having the open seal commit
> to a
> > set of sub-seals, and then closing the seal over a second set of closed
> seal
> > proofs. Seals that didn't need to be closed can be closed over a special
> > re-delegation message, re-delegating the seal to a new open seal.
> >
> > Since the closed sub-seal proof can additionally include a proof of
> > authorization, we have a protcol where the entity with authorization to
> close
> > the master seal has the ability to DoS attack sub-seals owners, but not
> the
> > ability to fraudulently close the seals over contents of their choosing.
> This
> > may be useful in cases where actions on the master seal is expensive -
> such as
> > seals implemented on top of decentralized blockchains - by amortising
> the cost
> > over all sub-seals.
> >
> >
> > ## Atomicity
> >
> > Often protocols will require multiple seals to be closed for a
> transaction to
> > be valid. If a single entity controls all seals, this is no problem: the
> > transaction simply isn't valid until the last seal is closed.
> >
> > However if multiple parties control the seals, a party could attack
> another
> > party by failing to go through with the transaction, after another party
> has
> > closed their seal, leaving the victim with an invalid transaction that
> they
> > can't reverse.
> >
> > We have a few options to resolve this problem:
> >
> > ### Use a single oracle
> >
> > The oracle can additionally guarantee that a seal will be closed iff
> some other
> > set of seals are also closed; seals implemented with Bitcoin can provide
> this
> > guarantee. If the parties to a transaction aren't already all on the same
> > oracle, they can add an additional transaction reassigning their outputs
> to a
> > common oracle.
> >
> > Equally, a temporary consensus between multiple mutually trusting
> oracles can
> > be created with a consensus protocol they share; this option doesn't
> need to
> > change the proof verification implementation.
> >
> >
> > ### Two-phase Timeouts
> >
> > If a proof to the fact that a seal is open can be generated, even under
> > adversarial conditions, we can make the seal protocol allow a close to be
> > undone after a timeout if evidence can be provided that the other
> seal(s) were
> > not also closed (in the specified way).
> >
> > Depending on the implementation - especially in decentralized systems -
> the
> > next time the seal is closed, the proof it has been closed may in turn
> provide
> > proof that a previous close was in fact invalid.
> >
> >
> > # Proof-of-Publication and Proof-of-Non-Publication
> >
> > Often we need to be able to prove that a specified audience was able to
> receive
> > a specific message. For example, the author's PayPub protocol[^paypub],
> > Todd/Taaki's timelock encryption protocol[^timelock], Zero-Knowledge
> Contingent
> > Payments[^zkcp], and Lightning, among others work by requiring a secret
> key to
> > be published publicly in the Bitcoin blockchain as a condition of
> collecting a
> > payment. At a much smaller scale - in terms of audience - in certain
> FinTech
> > applications for regulated environments a transaction may be considered
> invalid
> > unless it was provably published to a regulatory agency.  Another
> example is
> > Certificate Transparency, where we consider a SSL certificate to be
> invalid
> > unless it has been provably published to a transparency log maintained
> by a
> > third-party.
> >
> > Secondly, many proof-of-publication schemes also can prove that a
> message was
> > _not_ published to a specific audience. With this type of proof
> single-use
> > seals can be implemented, by having the proof consist of proof that a
> specified
> > message was not published between the time the seal was created, and the
> time
> > it was closed (a proof-of-publication of the message).
> >
> > ## Implementations
> >
> > ### Decentralized Blockchains
> >
> > Here the audience is all participants in the system. However miner
> censorship
> > can be a problem, and compact proofs of non-publication aren't yet
> available
> > (requires (U)TXO commitments).
> >
> > The authors treechains proposal is a particularly generic and scalable
> > implementation, with the ability to make trade offs between the size of
> > audience (security) and publication cost.
> >
> > ### Centralized Public Logs
> >
> > Certificate Transparency works this way, with trusted (but auditable)
> logs run
> > by well known parties acting as the publication medium, who promise to
> allow
> > anyone to obtain copies of the logs.
> >
> > The logs themselves may be indexed in a variety of ways; CT simply
> indexes logs
> > by time, however more efficient schemes are possible by having the
> operator
> > commit to a key:value mapping of "topics", to allow publication (and
> > non-publication) proofs to be created for specified topics or topic
> prefixes.
> >
> > Auditing the logs is done by verifying that queries to the state of the
> log
> > return the same state at the same time for different requesters.
> >
> > ### Receipt Oracles
> >
> > Finally publication can be proven by a receipt proof by the oracle,
> attesting
> > to the fact that the oracle has successfully received the message. This
> is
> > particularly appropriate in cases where the required audience is the
> oracle
> > itself, as in the FinTech regulator case.
> >
> >
> > # Validity Oracles
> >
> > As transaction histories grow longer, they may become impractical to
> move from
> > one party to another. Validity oracles can solve this problem by
> attesting to
> > the validity of transactions, allowing history prior to the attested
> > transactions to be discarded.
> >
> > A particularly generic validity oracle can be created using deterministic
> > expressions systems. The user gives the oracle an expression, and the
> oracle
> > returns a signed message attesting to the validity of the expression.
> > Optionally, the expression may be incomplete, with parts of the
> expression
> > replaced by previously generated attestations. For example, an
> expression that
> > returns true if a transaction is valid could in turn depend on the
> previous
> > transaction also being valid - a recursive call of itself - and that
> recursive
> > call can be proven with a prior attestation.
> >
> > ## Implementations
> >
> > ### Proof-of-Work Decentralized Consensus
> >
> > Miners in decentralized consensus systems act as a type of validity
> oracle, in
> > that the economic incentives in the system are (supposed to be) designed
> to
> > encourage only the mining of valid blocks; a user who trusts the
> majority of
> > hashing power can trust that any transaction with a valid merkle path to
> a
> > block header in the most-work chain is valid. Existing decentralized
> consensus
> > systems like Bitcoin and Ethereum conflate the roles of validity oracle
> and
> > single-use seal/anti-replay oracle, however in principle that need not
> be true.
> >
> >
> > ### Trusted Oracles
> >
> > As the name suggests. Remote-attestation-capable trusted hardware is a
> > particularly powerful implementation - a conspiracy theory is that the
> reason
> > why essentially zero secure true remote attestation implementations
> exist is
> > because they'd immediately make untraceable digital currency systems
> easy to
> > implement (Finney's RPOW[^rpow] is a rare counter-example).
> >
> > Note how a single-use seal oracle that supports a generic deterministic
> > expressions scheme for seal authorization can be easily extended to
> provide a
> > validity oracle service as well. The auditing mechanisms for a
> single-use seal
> > oracle can also be applied to validity oracles.
> >
> >
> > # Fraud Proofs
> >
> > Protocols specified with deterministic expressions can easily generate
> "fraud
> > proofs", showing that claimed states/proof in the system are actually
> invalid.
> > Additionally many protocols can be specified with expressions of
> k*log2(n)
> > depth, allowing these fraud proofs to be compact.
> >
> > A simple example is proving fraud in merkle-sum tree, where the validity
> > expression would be something like:
> >
> >     (defun valid? (node)
> >         (or (== node.type leaf)
> >             (and (== node.sum (+ node.left.sum node.right.sum))
> >                  (and (valid? node.left)
> >                       (valid? node.right)))))
> >
> > To prove the above expression evaluates to true, we'll need the entire
> contents
> > of the tree. However, to prove that it evaluates to false, we only need a
> > subset of the tree as proving an and expression evaluates to false only
> > requires one side, and requires log2(n) data. Secondly, with pruning, the
> > deterministic expressions evaluator can automatically keep track of
> exactly
> > what data was needed to prove that result, and prune all other data when
> > serializing the proof.
> >
> >
> > ## Validity Challenges
> >
> > However how do you guarantee it will be possible to prove fraud in the
> first
> > place? If pruning is allowed, you may simply not have access to the data
> > proving fraud - an especially severe problem in transactional systems
> where a
> > single fraudulent transaction can counterfeit arbitrary amounts of value
> out of
> > thin air.
> >
> > A possible approach is the validity challenge: a subset of proof data,
> with
> > part of the data marked as "potentially fraudulent". The challenge can be
> > satisfied by providing the marked data and showing that the proof in
> question
> > is in fact valid; if the challenge is unmet participants in the system
> can
> > choose to take action, such as refusing to accept additional
> transactions.
> >
> > Of course, this raises a whole host of so-far unsolved issues, such as
> DoS
> > attacks and lost data.
> >
> >
> > # Probabilistic Validation
> >
> > Protocols that can tolerate some fraud can make use of probabilistic
> > verification techniques to prove that the percentage of undetected fraud
> within
> > the system is less than a certain amount, with a specified probability.
> >
> > A common way to do this is the Fiat-Shamir transform, which repeatedly
> samples
> > a data structure deterministically, using the data's own hash digest as
> a seed
> > for a PRNG. Let's apply this technique to our merkle-sum tree example.
> We'll
> > first need a recursive function to check a sample, weighted by value:
> >
> >     (defun prefix-valid? (node nonce)
> >         (or (== node.type leaf)
> >             (and (and (== node.sum (+ node.left.sum node.right.sum))
> >                       (> 0 node.sum)) ; mod by 0 is invalid, just like
> division by zero
> >                                       ; also could guarantee this with a
> type system
> >                  (and (if (< node.left.sum (mod nonce node.sum))
> >                           (prefix-valid? node.right (hash nonce))
> >                           (prefix-valid? node.left (hash nonce)))))))
> >
> > Now we can combine multiple invocations of the above, in this case 256
> > invocations:
> >
> >     (defun prob-valid? (node)
> >         (and (and (and .... (prefix-valid? node (digest (cons (digest
> node) 0)))
> >              (and (and ....
> >                             (prefix-valid? node (digest (cons (digest
> node) 255)))
> >
> > As an exercise for a reader: generalize the above with a macro, or a
> suitable
> > types/generics system.
> >
> > If we assume our attacker can grind up to 128 bits, that leaves us with
> 128
> > random samples that they can't control. If the (value weighted)
> probability of
> > a given node is fraudulent q, then the chance of the attacker getting
> away with
> > fraud is (1-q)^128 - for q=5% that works out to 0.1%
> >
> > (Note that the above analysis isn't particularly well done - do a better
> > analysis before implementing this in production!)
> >
> >
> > ## Random Beacons and Transaction History Linearization
> >
> > The Fiat-Shamir transform requires a significant number of samples to
> defeat
> > grinding attacks; if we have a random beacon available we can
> significantly
> > reduce the size of our probabilistic proofs. PoW blockchains can
> themselves act
> > as random beacons, as it is provably expensive for miners to manipulate
> the
> > hash digests of blocks they produce - to do so requires discarding
> otherwise
> > valid blocks.
> >
> > An example where this capability is essential is the author's transaction
> > history linearization technique. In value transfer systems such as
> Bitcoin, the
> > history of any given coin grows quasi-exponentially as coins are mixed
> across
> > the entire economy. We can linearize the growth of history proofs by
> redefining
> > coin validity to be probabilistic.
> >
> > Suppose we have a transaction with n inputs. Of those inputs, the total
> value
> > of real inputs is p, and the total claimed value of fake inputs is q. The
> > transaction commits to all inputs in a merkle sum tree, and we define the
> > transaction as valid if a randomly chosen input - weighted by value - can
> > itself be proven valid. Finally, we assume that creating a genuine input
> is a
> > irrevocable action which irrevocable commits to the set of all inputs,
> real and
> > fake.
> >
> > If all inputs are real, 100% of the time the transaction will be valid;
> if all
> > inputs are fake, 100% of the time the transaction will be invalid. In
> the case
> > where some inputs are real and some are fake the probability that the
> fraud
> > will be detected is:
> >
> >     q / (q + p)
> >
> > The expected value of the fake inputs is then the sum of the potential
> upside -
> > the fraud goes detected - and the potential downside - the fraud is
> detected
> > and the real inputs are destroyed:
> >
> >     E = q(1 - q/(q + p)) - p(q/(q + p)
> >       = q(p/(q + p)) - p(q/(q + p)
> >       = (q - q)(p/(q + p))
> >       = 0
> >
> > Thus so long as the random beacon is truly unpredictable, there's no
> economic
> > advantage to creating fake inputs, and it is sufficient for validity to
> only
> > require one input to be proven, giving us O(n) scaling for transaction
> history
> > proofs.
> >
> >
> > ### Inflationary O(1) History Proofs
> >
> > We can further improve our transaction history proof scalability by
> taking
> > advantage of inflation. We do this by occasionally allowing a
> transaction proof
> > to be considered valid without validating _any_ of the inputs; every
> time a
> > transaction is allowed without proving any inputs the size of the
> transaction
> > history proof is reset. Of course, this can be a source of inflation, but
> > provided the probability of this happening can be limited we can limit
> the
> > maximum rate of inflation to the chosen value.
> >
> > For example, in Bitcoin as of writing every block inflates the currency
> supply
> > by 25BTC, and contains a maximum of 1MB of transaction data,
> 0.025BTC/KB. If we
> > check the prior input proof with probability p, then the expected value
> of a
> > transaction claiming to spend x BTC is:
> >
> >     E = x(1-p)
> >
> > We can rewrite that in terms of the block reward per-byte R, and the
> transaction size l:
> >
> >     lR = x(1-p)
> >
> > And solving for p:
> >
> >     p = 1 - lR/x
> >
> > For example, for a 1KB transaction proof claiming to spending 10BTC we
> can omit
> > checking the input 0.25% of the time without allowing more monetary
> inflation
> > than the block reward already does. Secondly, this means that after n
> > transactions, the probability that proof shortening will _not_ happen is
> p^n,
> > which reaches 1% after 1840 transactions.
> >
> > In a system like Bitcoin where miners are expected to validate, a
> transaction
> > proof could consist of just a single merkle path showing that a
> single-use seal
> > was closed in some kind of TXO commitment - probably under 10KB of data.
> That
> > gives us a history proof less than 18.4MB in size, 99% of the time, and
> less
> > than 9.2MB in size 90% of the time.
> >
> > An interesting outcome of thing kind of design is that we can
> institutionalize
> > inflation fraud: the entire block reward can be replaced by miners
> rolling the
> > dice, attempting to create valid "fake" transactions. However, such a
> pure
> > implementation would put a floor on the lowest transaction fee possible,
> so
> > better to allow both transaction fee and subsidy collection at the same
> time.
> >
> >
> > # References
> >
> > [^paypub] https://github.com/unsystem/paypub
> > [^timelock] https://github.com/petertodd/timelock
> > [^zkcp]
> https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/
> > [^rpow] https://cryptome.org/rpow.htm
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160620/f6abdd58/attachment-0001.html>

From erik at q32.com  Mon Jun 20 17:33:32 2016
From: erik at q32.com (Erik Aronesty)
Date: Mon, 20 Jun 2016 17:33:32 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
Message-ID: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>

BIP 0070 has been a a moderate success, however, IMO:

- protocol buffers are inappropriate since ease of use and extensibility is
desired over the minor gains of efficiency in this protocol.  Not too late
to support JSON messages as the standard going forward

- problematic reliance on merchant-supplied https (X509) as the sole form
of mechant identification.   alternate schemes (dnssec/netki), pgp and
possibly keybase seem like good ideas.   personally, i like keybase, since
there is no reliance on the existing domain-name system (you can sell with
a github id, for example)

- missing an optional client supplied identification

- lack of basic subscription support

*Proposed for subscriptions:*

- BIP0047 payment codes are recommended instead of wallet addresses when
establishing subscriptions.  Or, merchants can specify replacement
addresses in ACK/NACK responses.   UI confirms are *required *when there
are no replacement addresses or payment codes used.

- Wallets must confirm and store subscriptions, and are responsible for
initiating them at the specified interval.

- Intervals can *only *be from a preset list: weekly, biweekly, or 1,
2,3,4,6 or 12 months.   Intervals missed by more than 3 days cause
suspension until the user re-verifies.

- Wallets *may *optionally ask the user whether they want to be notified
and confirm every interval - or not.   Wallets that do not ask *must *notify
before initiating each payment.   Interval confirmations should begin at *least
*1 day in advance of the next payment.


*Proposed in general:*
- JSON should be used instead of protocol buffers going forward.  Easier to
use, explain extend.

- "Extendible" URI-like scheme to support multi-mode identity mechanisms on
both payment and subscription requests.   Support for keybase://, netki://
and others as alternates to https://.

- Support for client as well as merchant multi-mode verification

- Ideally, the identity verification URI scheme is somewhat
orthogonal/independent of the payment request itself

Question:

Should this be a new BIP?  I know netki's BIP75 is out there - but I think
it's too specific and too reliant on the domain name system.

Maybe an identity-protocol-agnostic BIP + solid implementation of a couple
major protocols without any mention of payment URI's ... just a way of
sending and receiving identity verified messages in general?

I would be happy to implement plugins for identity protocols, if anyone
thinks this is a good idea.

Does anyone think https:// or keybase, or PGP or netki all by themselves,
is enough - or is it always better to have an extensible protocol?

- Erik Aronesty
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160620/947bebda/attachment.html>

From alex.mizrahi at gmail.com  Mon Jun 20 22:28:48 2016
From: alex.mizrahi at gmail.com (Alex Mizrahi)
Date: Tue, 21 Jun 2016 01:28:48 +0300
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
	Consensus
In-Reply-To: <20160620085649.GA29964@fedora-21-dvm>
References: <20160620085649.GA29964@fedora-21-dvm>
Message-ID: <CAE28kUTkBmhLm-7rNVtX7Dm2yYABQiepZX0RCYpBn60Uo9=ehA@mail.gmail.com>

> All practical single-use seals will be associated with some kind of
> condition,
> such as a pubkey, or deterministic expression, that needs to be satisfied
> for
> the seal to be closed.


I think it would be useful to classify systems w.r.t. what data is
available to condition.
I imagine it might be useful if status of other seals is available.


> Secondly, the contents of the proof will be able to
> commit to new data, such as the transaction spending the output associated
> with
> the seal.
>

So basically a "condition" returns that "new data", right?
If it commits to a data in a recognizable way, then it's practically a
function which yields a tuple (valid, new_data).
If an oracle doesn't care about data then you can convert it to a predicate
using a simple projection.
But from point of view of a client, it is a function which returns a tuple.

It might help if you describe a type of the condition function.

Some related work on UTXO-based smart contracts:

1. Typecoin described in the paper
"Peer-to-peer Affine Commitment using Bitcoin" Karl Crary and Michael J.
Sullivan Carnegie Mellon University PLDI ?15, Portland June 17, 2015

I don't see the paper in open access and I've lost my copy, but there are
slides: https://www.msully.net/stuff/typecoin-slides.pdf

The paper is written by programming language researchers, and thus use
fairly complex constructs.
The idea is to use the language of linear logic, but it's actually
implemented using type-oriented programming.
So, basically, they associate logical propositions with transaction
outputs. Transactions proof that output-propositions logically follow from
input-propositions.
The paper first describes as a colored coin kind of a system, where color
values are propositions/types.
But in the implementation part it became more like a metacoin, as it uses a
complete transaction history.
A setup with a trusted server is also mentioned.

The interesting thing about Typecoin is that a contract language is based
on logic, which makes it powerful and -- I guess -- analyzable. However,
the paper doesn't mention any performance details, and I guess it's not
good.
Another problem is that it looks very unusual to people who aren't used to
type-oriented programming.

2. Generic coins
Seeing how much Typecoin people had to struggle to describe a Bitcoin-style
system I decided to describe a generalized Bitcoin-style system, so it can
be easily referenced in research. Sadly all I got so far is a draft of an
introduction/definition sections:
https://github.com/chromaway/ngcccbase/wiki/gc

In the first section I described a transaction graph model which is
supposed to be general enough to describe any kind of a transaction graph
system with explicit dependencies and no "spooky action at distance". As it
turns out, any such system can be defined in terms of few predicate
functions, however, using these functions directly might be very
inefficient.

The next section introduces a coin-based model. A coin-based system can be
described using a single function called coin kernel which is applied to a
transaction and a list of input coinstates.
It is then described how to go from a coin-based model to a
transaction-graph model.
The reverse should also be possible if we add additional restrictions on a
transaction-graph model, it's probably enough to define that coin can be
spent only once. (Partial coin spends were described in Freimarkets.)

There is a fairly shitty prototype in Haskell:
https://github.com/baldmaster/ColorCoin

3. flexichains
This is a prototype done by me more recently, the interesting thing about
it is that it unifies account-based and UTXO-based models in a single model.

We first introduce a notion of record. A record can be of an arbitrary
type, the only restriction is that it must have a key which must be unique
within a system.
Then transaction model can be introduced using two function:
  txDependencies returns a list of keys of records transaction depends on
  applyTx takes a transaction and a list of records it depends on and
returns either a list of records or an error.

A list of records includes
 * new records which are created by a transaction
 * updated records will have the same key but different content

A simple account-based system can be implement using tuples (pubkey,
balance, last_update) as records.
In an UTXO-based system records are transaction output, and they should
include a spent flag. (Obviously, records with spent flag can be pruned.)
A system with custom smart contracts can be implemented by adding some sort
of a function or bytecode to records.

A Haskell prototype is here:
https://bitbucket.org/chromawallet/flexichains/src/21059080bed6?at=develop
(It's kinda broken and incomplete, though.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/a4d13078/attachment.html>

From andreas at schildbach.de  Tue Jun 21 09:43:15 2016
From: andreas at schildbach.de (Andreas Schildbach)
Date: Tue, 21 Jun 2016 11:43:15 +0200
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
Message-ID: <nkb27k$5bi$1@ger.gmane.org>

Protobuf vs. JSON was a deliberate decision. Afaik Protobuf was chosen
because of its strong types, less vulnerability to malleability and very
good platform support. Having coded both, I can say Protobuf is not more
difficult than JSON. (Actually the entire Bitcoin P2P protocol should be
based on Protobuf, but that's another story.)

Yes, all extensions to BIP70 should go into new BIPs. Note the plural
here: if you have orthogonal ideas I strongly suggest one BIP per idea
so they can be discussed and implemented (or rejected) separately.


On 06/20/2016 07:33 PM, Erik Aronesty via bitcoin-dev wrote:
> BIP 0070 has been a a moderate success, however, IMO:
> 
> - protocol buffers are inappropriate since ease of use and extensibility
> is desired over the minor gains of efficiency in this protocol.  Not too
> late to support JSON messages as the standard going forward
> 
> - problematic reliance on merchant-supplied https (X509) as the sole
> form of mechant identification.   alternate schemes (dnssec/netki), pgp
> and possibly keybase seem like good ideas.   personally, i like keybase,
> since there is no reliance on the existing domain-name system (you can
> sell with a github id, for example)
> 
> - missing an optional client supplied identification
> 
> - lack of basic subscription support
> 
> /Proposed for subscriptions:/
> 
> - BIP0047 payment codes are recommended instead of wallet addresses when
> establishing subscriptions.  Or, merchants can specify replacement
> addresses in ACK/NACK responses.   UI confirms are /required /when there
> are no replacement addresses or payment codes used.
> 
> - Wallets must confirm and store subscriptions, and are responsible for
> initiating them at the specified interval.  
> 
> - Intervals can /only /be from a preset list: weekly, biweekly, or 1,
> 2,3,4,6 or 12 months.   Intervals missed by more than 3 days cause
> suspension until the user re-verifies.
> 
> - Wallets /may /optionally ask the user whether they want to be notified
> and confirm every interval - or not.   Wallets that do not ask /must
> /notify before initiating each payment.   Interval confirmations should
> begin at /least /1 day in advance of the next payment.
> 
> /Proposed in general:
> /
> - JSON should be used instead of protocol buffers going forward.  Easier
> to use, explain extend.
> 
> - "Extendible" URI-like scheme to support multi-mode identity mechanisms
> on both payment and subscription requests.   Support for keybase://,
> netki:// and others as alternates to https://. 
> 
> - Support for client as well as merchant multi-mode verification
> 
> - Ideally, the identity verification URI scheme is somewhat
> orthogonal/independent of the payment request itself
> 
> Question:
> 
> Should this be a new BIP?  I know netki's BIP75 is out there - but I
> think it's too specific and too reliant on the domain name system.
> 
> Maybe an identity-protocol-agnostic BIP + solid implementation of a
> couple major protocols without any mention of payment URI's ... just a
> way of sending and receiving identity verified messages in general?
> 
> I would be happy to implement plugins for identity protocols, if anyone
> thinks this is a good idea.
> 
> Does anyone think https:// or keybase, or PGP or netki all by
> themselves, is enough - or is it always better to have an extensible
> protocol?
> 
> - Erik Aronesty
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 



From erik at q32.com  Tue Jun 21 17:09:41 2016
From: erik at q32.com (Erik Aronesty)
Date: Tue, 21 Jun 2016 13:09:41 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <nkb27k$5bi$1@ger.gmane.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<nkb27k$5bi$1@ger.gmane.org>
Message-ID: <CAJowKgKA4UphM7O7i53WtLGV7_b-ve+o=nuWv6K7nw6LOcQFkQ@mail.gmail.com>

On Tue, Jun 21, 2016 at 5:43 AM, Andreas Schildbach via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Protobuf vs. JSON was a deliberate decision. Afaik Protobuf was chosen
> because of its strong types, less vulnerability to malleability and very
> good platform support. Having coded both, I can say Protobuf is not more
> difficult than JSON. (Actually the entire Bitcoin P2P protocol should be
> based on Protobuf, but that's another story.)
>

I like protobuf, personally, for C++ stuff.  I just imagined it would be
harder on mobile, or in some languages, to implement.   I'll focus on the
scheduling issue.  Really, that's the only thing I want hashed out.


>
> Yes, all extensions to BIP70 should go into new BIPs. Note the plural
> here: if you have orthogonal ideas I strongly suggest one BIP per idea
> so they can be discussed and implemented (or rejected) separately.
>
>
I think the intervals should *not* be flexible, even at the protocol level,
to prevent attacks designed to confuse users  - plus for shorter intervals,
you need payment channels anyway.  Also, I think the spec should be rigid
with respect to response times, retry periods, etc.... to encourage
consistency among wallet vendors.   Not sure how anyone else feels about
that.  I suspect the netki guys should have opinions, since they are
working on similar UI-stuff.

Should UI standards go somewhere else - not in a BIP?  I do think there
need to be UI standards.  Something with RFC-style should/must/will/wont
language, like "Wallet software *must* show unconfirmed transactions as
distinct from confirmed", and "Wallet software *should *show some visual
indication of other levels of confirmation" ....  stuff like that.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/3d77b01a/attachment.html>

From info at AndySchroder.com  Tue Jun 21 19:50:59 2016
From: info at AndySchroder.com (Andy Schroder)
Date: Tue, 21 Jun 2016 15:50:59 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <nkb27k$5bi$1@ger.gmane.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<nkb27k$5bi$1@ger.gmane.org>
Message-ID: <57699AA3.2010601@AndySchroder.com>

Bluetooth exchange of payment requests already has a noticeable lag with 
protocol buffers, so that would be another reason to argue against JSON, 
because JSON is less efficient size wise, correct? I will say that 
although protocol buffers have good platform support, I don't know that 
the documentation for each platform is very good. This is the main 
drawback I see with them. One additional advantage of protocol buffers 
is that the .proto file is a specification, whereas with JSON, you'd 
just have an example file, right?

Isn't keybase a centralized infrastructure? Are you against a blockchain 
based identification? There are a few out there. There is some confusion 
because onename's efforts are breaking away from namecoin though.

I like the idea of PGP signatures of payment requests. This allows for 
manual verification (in my mind, the highest quality) of key 
authenticity (or, with PGP you also have the option to opt into some 
centralized service for key verification). This can be useful when 
dealing with semi-manually issued invoices for goods and services. The 
local bitcoin wallet could just interact with the local PGP keyring. 
Although, one can already just send the payment request in a PGP signed 
e-mail, so I'm not sure if PGP signing is really needed if you're using 
PGP email. The main benefit may just be consolidating/itemizing into 
your bitcoin wallet's transaction history whether the payment 
destination/request was securely received or not. It may also be useful 
for someone to be able to extract a signed payment request from a signed 
PGP e-mail and send it to someone else to make a payment for you (maybe 
you don't want your accounting person to need your entire e-mail 
correspondence with a supplier to be able to just verify the payment 
request and make a payment for your company).

I'm concerned about extending the URI scheme too much. Isn't this going 
to reach the practical size limit of NFC and QR codes pretty quickly?




Andy Schroder

On 06/21/2016 05:43 AM, Andreas Schildbach via bitcoin-dev wrote:
> Protobuf vs. JSON was a deliberate decision. Afaik Protobuf was chosen
> because of its strong types, less vulnerability to malleability and very
> good platform support. Having coded both, I can say Protobuf is not more
> difficult than JSON. (Actually the entire Bitcoin P2P protocol should be
> based on Protobuf, but that's another story.)
>
> Yes, all extensions to BIP70 should go into new BIPs. Note the plural
> here: if you have orthogonal ideas I strongly suggest one BIP per idea
> so they can be discussed and implemented (or rejected) separately.
>
>
> On 06/20/2016 07:33 PM, Erik Aronesty via bitcoin-dev wrote:
>> BIP 0070 has been a a moderate success, however, IMO:
>>
>> - protocol buffers are inappropriate since ease of use and extensibility
>> is desired over the minor gains of efficiency in this protocol.  Not too
>> late to support JSON messages as the standard going forward
>>
>> - problematic reliance on merchant-supplied https (X509) as the sole
>> form of mechant identification.   alternate schemes (dnssec/netki), pgp
>> and possibly keybase seem like good ideas.   personally, i like keybase,
>> since there is no reliance on the existing domain-name system (you can
>> sell with a github id, for example)
>>
>> - missing an optional client supplied identification
>>
>> - lack of basic subscription support
>>
>> /Proposed for subscriptions:/
>>
>> - BIP0047 payment codes are recommended instead of wallet addresses when
>> establishing subscriptions.  Or, merchants can specify replacement
>> addresses in ACK/NACK responses.   UI confirms are /required /when there
>> are no replacement addresses or payment codes used.
>>
>> - Wallets must confirm and store subscriptions, and are responsible for
>> initiating them at the specified interval.
>>
>> - Intervals can /only /be from a preset list: weekly, biweekly, or 1,
>> 2,3,4,6 or 12 months.   Intervals missed by more than 3 days cause
>> suspension until the user re-verifies.
>>
>> - Wallets /may /optionally ask the user whether they want to be notified
>> and confirm every interval - or not.   Wallets that do not ask /must
>> /notify before initiating each payment.   Interval confirmations should
>> begin at /least /1 day in advance of the next payment.
>>
>> /Proposed in general:
>> /
>> - JSON should be used instead of protocol buffers going forward.  Easier
>> to use, explain extend.
>>
>> - "Extendible" URI-like scheme to support multi-mode identity mechanisms
>> on both payment and subscription requests.   Support for keybase://,
>> netki:// and others as alternates to https://.
>>
>> - Support for client as well as merchant multi-mode verification
>>
>> - Ideally, the identity verification URI scheme is somewhat
>> orthogonal/independent of the payment request itself
>>
>> Question:
>>
>> Should this be a new BIP?  I know netki's BIP75 is out there - but I
>> think it's too specific and too reliant on the domain name system.
>>
>> Maybe an identity-protocol-agnostic BIP + solid implementation of a
>> couple major protocols without any mention of payment URI's ... just a
>> way of sending and receiving identity verified messages in general?
>>
>> I would be happy to implement plugins for identity protocols, if anyone
>> thinks this is a good idea.
>>
>> Does anyone think https:// or keybase, or PGP or netki all by
>> themselves, is enough - or is it always better to have an extensible
>> protocol?
>>
>> - Erik Aronesty
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/6970aa58/attachment.sig>

From akiva.lichtner at gmail.com  Tue Jun 21 15:31:01 2016
From: akiva.lichtner at gmail.com (Akiva Lichtner)
Date: Tue, 21 Jun 2016 11:31:01 -0400
Subject: [bitcoin-dev] Geographic Partitioning
Message-ID: <CABCnA7XRxcABN2R2yQymGi3XYvG_CiiOZfa9+x=B0F51yr36uw@mail.gmail.com>

I am a long-time developer and I have some experience in process groups. I
am going to try to keep this short. If you are interested in pursuing this
idea please reply to me privately so we don't put a burden on the list.

As per Satoshi's paper, the blockchain implements a distributed timestamp
service. It defeats double-spending by establishing a "total order" on
transactions. The "domain" on which the ordering takes place is the entire
coin, the money supply. It's obvious to me that total ordering does not
scale well as a use case, it's not a matter of implementation details or
design. It's the requirement which is a problem. Therefore when I see
mention of the many clever schemes proposed to make Bitcoin scalable I
already know that by using that proposal we are going to give up something.
And in some cases I see lengthy and complex proposals, and just what the
user is giving up is not easy to see.

I think that the user has to give up something in order for electronic cash
to really scale, and that something has to be non-locality. At the moment
Bitcoin doesn't know whether I am buying a laptop from 3,000 miles away or
300. This is a wonderful property, but this property makes it impossible to
partition the users geographically. I think that a simple and effective way
to do this is to partition the address using a hash. A convention could be
adopted whereby there is a well-known partition number for each geographic
location. Most users would use third-party clients and the client could
generate Bitcoin addresses until it hits one in the user's geographical
area.

The partitioning scheme could be hierarchical. For example there could be
partitions at the city, state, and country level. A good way to see how
this works in real life is shopping at Walmart, which is something like
4,000 stores. Walmart could have users pay local addresses, and then move
the money "up" to a regional or country level.

The problem is what to do when an address in partition A wants to pay an
address in partition B. This should be done by processing the transaction
in partition A first, and once the block is made a hash of that block
should be included in some block in partition B. After A has made the block
the coin has left A, it cannot be spent. Once B has made its block the coin
has "arrived" in B and can be spent. It can be seen that some transactions
span a longer distance than others, in that they require two or more
blocks. These transactions take longer to execute, and I think that that is
entirely okay.

Transaction verification benefits because a small merchant can accept
payments from local addresses only. Larger merchants can verify
transactions across two or more partitions.

Some will be concerned about 51% attacks on partitions. I would point
out that nodes could process transactions at random, so that the majority
of the computing power is well-balanced across all partitions.

Regards,
Akiva
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/a5aebe68/attachment.html>

From luke at dashjr.org  Tue Jun 21 20:44:37 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 21 Jun 2016 20:44:37 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
Message-ID: <201606212044.38931.luke@dashjr.org>

On Monday, June 20, 2016 5:33:32 PM Erik Aronesty via bitcoin-dev wrote:
> BIP 0070 has been a a moderate success, however, IMO:
> 
> - protocol buffers are inappropriate since ease of use and extensibility is
> desired over the minor gains of efficiency in this protocol.  Not too late
> to support JSON messages as the standard going forward

IMO JSON is too prone to gratuitous inefficiency (both at network and CPU 
level), parser bugs, etc. Even the best C implementation (jansson) has serious 
issues with Number handling.

A few years ago, I looked into binary alternatives to JSON and concluded they 
all had problems, while it seems more than reasonable to do even dynamic 
parsing of protobuf messages. So to conclude, I prefer to stick to protobuf 
unless a clearly superior protocol turns up.

> - problematic reliance on merchant-supplied https (X509) as the sole form
> of mechant identification.   alternate schemes (dnssec/netki), pgp and
> possibly keybase seem like good ideas.   personally, i like keybase, since
> there is no reliance on the existing domain-name system (you can sell with
> a github id, for example)

X509 is entrenched, so it should remain supported. PGP might make sense for 
people already using it (it provides no real security for un-WoT-networked 
users), but unforunately, few people use it. Correct me if I'm wrong, but IIRC 
Keybase uses blockchain spam, so definitely not something to be encouraged if 
so. Namecoin seems like a more than reasonable decentralised solution, but 
will probably take some real work to implement (not that this is avoidable for 
a general-usage decentralised solution).

> - missing an optional client supplied identification

What do you mean by this? There's the memo field at least.

> - lack of basic subscription support
> 
> *Proposed for subscriptions:*
> 
> - BIP0047 payment codes are recommended instead of wallet addresses when
> establishing subscriptions.  Or, merchants can specify replacement
> addresses in ACK/NACK responses.   UI confirms are *required *when there
> are no replacement addresses or payment codes used.

I'd discourage anything using BIP 47 due to its serious design flaws.
No reason a regular BIP 32 pub seed can't be used instead.

What do you mean by "replacement addresses" and "UI confirms" here?

> - Wallets must confirm and store subscriptions, and are responsible for
> initiating them at the specified interval.
> 
> - Intervals can *only *be from a preset list: weekly, biweekly, or 1,
> 2,3,4,6 or 12 months.   Intervals missed by more than 3 days cause
> suspension until the user re-verifies.

Disagree with hard-coding intervals, or mandating specific policies from the 
service providers.

> - Wallets *may *optionally ask the user whether they want to be notified
> and confirm every interval - or not.   Wallets that do not ask *must
> *notify before initiating each payment.   Interval confirmations should
> begin at *least *1 day in advance of the next payment.

This is wallet policy, but maybe makes sense as a "best practices" BIP.

> *Proposed in general:*
> - JSON should be used instead of protocol buffers going forward.  Easier to
> use, explain extend.
> 
> - "Extendible" URI-like scheme to support multi-mode identity mechanisms on
> both payment and subscription requests.   Support for keybase://, netki://
> and others as alternates to https://.
> 
> - Support for client as well as merchant multi-mode verification
> 
> - Ideally, the identity verification URI scheme is somewhat
> orthogonal/independent of the payment request itself
> 
> Question:
> 
> Should this be a new BIP?  I know netki's BIP75 is out there - but I think
> it's too specific and too reliant on the domain name system.
>
> Maybe an identity-protocol-agnostic BIP + solid implementation of a couple
> major protocols without any mention of payment URI's ... just a way of
> sending and receiving identity verified messages in general?
> 
> I would be happy to implement plugins for identity protocols, if anyone
> thinks this is a good idea.
> 
> Does anyone think https:// or keybase, or PGP or netki all by themselves,
> is enough - or is it always better to have an extensible protocol?
> 
> - Erik Aronesty

From macwhyte at gmail.com  Tue Jun 21 20:56:40 2016
From: macwhyte at gmail.com (James MacWhyte)
Date: Tue, 21 Jun 2016 20:56:40 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
Message-ID: <CAH+Axy7OtGgbtmz+grfuob419PwQJiYfZsQnMEs=_McZFBqu2A@mail.gmail.com>

Thanks for starting this discussion, Erik.


> Should this be a new BIP?  I know netki's BIP75 is out there - but I think
> it's too specific and too reliant on the domain name system.
>

This is not quite accurate. BIP75 is designed to be independent of any name
resolution system. You could use it with a static URL that you share, for
example, or even use it to implement a mesh-network payment system over
bluetooth. Netki's wallet names do use DNS, but that isn't related to this
discussion.

What BIP75 *does* do is provide a way for a client to get a new payment
address for every payment. I personally think it is better than BIP47 for
the uses you mentioned (subscriptions, etc).

I'm glad you brought up identity methods other than x509. At breadwallet we
are thinking about how to establish the most universal system, and letting
users identify themselves with any of a selection of identity systems is
ideal. I think the pki_data slot should be constantly expanded to allow new
identity types, but they should be explained/standardized in the BIPs that
add them and use universal names. "netki://" wouldn't be appropriate, for
example, if their method is open sourced and possibly used by others--it
should instead be given a product name like "dnswallet://" or something
more clever.

James
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/316a6995/attachment.html>

From matt at netki.com  Tue Jun 21 21:17:12 2016
From: matt at netki.com (Matt David)
Date: Tue, 21 Jun 2016 14:17:12 -0700
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAH+Axy7OtGgbtmz+grfuob419PwQJiYfZsQnMEs=_McZFBqu2A@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<CAH+Axy7OtGgbtmz+grfuob419PwQJiYfZsQnMEs=_McZFBqu2A@mail.gmail.com>
Message-ID: <66AA3F7D-05BF-4435-A3B3-4DF136B212DF@netki.com>

Hey all,

Interestingly enough, the original BIP75 idea started by trying to move the Payment Protocol to use JSON, but because of all of the reasons mentioned by Andreas, we ended up with protobuf. There is quite a bit of language support on both desktop and mobile platforms so that's become mostly a non-issue.

Regarding the lack of optional client-supplied identification, BIP75 was designed to solve this issue. It allows both parties in a transaction to share identity information in an out-of-band fashion in order to keep specific identity information off-chain.

With regards to extensibility of PKI usage, both BIP70 and BIP75 provide plenty of flexibility. Both the InvoiceRequest and PaymentRequest contain the pki_type and pki_data fields to allow for the use of non X.509 certificates. Currently, the only pki_types specified in both BIPs are none or x509_sha256, but there isn't any specific limit on what can be used as long as you can define a PKI type to be used, include a public key and a signature that proves control of the keypair. Perhaps a new BIP allowing for additional PKI types can be submitted, similar to how RFCs extend usage of ciphers for TLS (ie., RFC 5932).

Regarding subscriptions, and as proposed in the address book example use case in BIP75, a wallet can be setup to automatically create BIP75 transactions in order to retrieve a wallet address to pay for a subscription on whatever frequency you would like to use. The service provider can approve the first BIP75 transaction and then store the public key for that client for future use. For subsequent subscription payments, the service provider may automatically return wallet addresses for each BIP75 transaction, understanding that the subsequent BIP75 transactions are linked to the public key that was used for the first transaction and therefore the subscription has been paid for. Additionally, the BIP75 InvoiceRequest message contains a memo field that can be used to include any additional subscription information required by the subscription provider (and can be different for both first and subsequent BIP75 transactions).

This is a very interesting idea and I'd love to see how the community can work together to make Bitcoin more user and mainstream friendly while increasing security for all parties involved. All movement toward this is really the goal at Netki.

Best,

Matt David
Sr. Software Engineer
Netki, Inc.

matt at netki.com



> On Jun 21, 2016, at 1:56 PM, James MacWhyte via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Thanks for starting this discussion, Erik.
> 
> 
> Should this be a new BIP?  I know netki's BIP75 is out there - but I think it's too specific and too reliant on the domain name system.
> 
> This is not quite accurate. BIP75 is designed to be independent of any name resolution system. You could use it with a static URL that you share, for example, or even use it to implement a mesh-network payment system over bluetooth. Netki's wallet names do use DNS, but that isn't related to this discussion.
> 
> What BIP75 *does* do is provide a way for a client to get a new payment address for every payment. I personally think it is better than BIP47 for the uses you mentioned (subscriptions, etc).
> 
> I'm glad you brought up identity methods other than x509. At breadwallet we are thinking about how to establish the most universal system, and letting users identify themselves with any of a selection of identity systems is ideal. I think the pki_data slot should be constantly expanded to allow new identity types, but they should be explained/standardized in the BIPs that add them and use universal names. "netki://" wouldn't be appropriate, for example, if their method is open sourced and possibly used by others--it should instead be given a product name like "dnswallet://" or something more clever.
> 
> James
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/ab05606d/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PastedGraphic-2.tiff
Type: image/tiff
Size: 10972 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/ab05606d/attachment-0001.tiff>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 801 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/ab05606d/attachment-0001.sig>

From erik at q32.com  Tue Jun 21 21:42:39 2016
From: erik at q32.com (Erik Aronesty)
Date: Tue, 21 Jun 2016 17:42:39 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <201606212044.38931.luke@dashjr.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<201606212044.38931.luke@dashjr.org>
Message-ID: <CAJowKg+9kfOwvSH3GENr-=RYnctGHEw_7o-UmFqjAMJaaZ8AtA@mail.gmail.com>

> keybase spam

good point about keybase spam, but i think it's limited to once hash per
hour (?), not really too bad... the tx's are just root signatures, so you
can verify a whole keybase tree (up to the last hour) with very minimal
bitcoin blockchain impact.

> What do you mean by "replacement addresses" and "UI confirms" here?

"Replacement addresses" would take the place of BIP 32/47 support, if
someone thought maybe that was too difficult to deal with.   So each time i
paid Alice, Alice could generate a new payment address for the next monthly
payment.   If you support BIP 32 pub seed, then there's no need for this.
I don't know any wallets that support a BIP 32 pub seed (and then what,
some random number generator?) as a destination address yet.

> Disagree with hard-coding intervals, or mandating specific policies from
the
service providers.

I think mandating is a harsh word here, but i I'm a strong believer in
providing strict guidelines that if people break, others can call them
on.   Giving someone a 12.3 +/- 5 day interval for payments using this
protocol would suck.   You should use payment channels for that stuff.
The idea is a lightweight protocol for getting monthly subscriptions
working.




On Tue, Jun 21, 2016 at 4:44 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Monday, June 20, 2016 5:33:32 PM Erik Aronesty via bitcoin-dev wrote:
> > BIP 0070 has been a a moderate success, however, IMO:
> >
> > - protocol buffers are inappropriate since ease of use and extensibility
> is
> > desired over the minor gains of efficiency in this protocol.  Not too
> late
> > to support JSON messages as the standard going forward
>
> IMO JSON is too prone to gratuitous inefficiency (both at network and CPU
> level), parser bugs, etc. Even the best C implementation (jansson) has
> serious
> issues with Number handling.
>
> A few years ago, I looked into binary alternatives to JSON and concluded
> they
> all had problems, while it seems more than reasonable to do even dynamic
> parsing of protobuf messages. So to conclude, I prefer to stick to protobuf
> unless a clearly superior protocol turns up.
>
> > - problematic reliance on merchant-supplied https (X509) as the sole form
> > of mechant identification.   alternate schemes (dnssec/netki), pgp and
> > possibly keybase seem like good ideas.   personally, i like keybase,
> since
> > there is no reliance on the existing domain-name system (you can sell
> with
> > a github id, for example)
>
> X509 is entrenched, so it should remain supported. PGP might make sense for
> people already using it (it provides no real security for un-WoT-networked
> users), but unforunately, few people use it. Correct me if I'm wrong, but
> IIRC
> Keybase uses blockchain spam, so definitely not something to be encouraged
> if
> so. Namecoin seems like a more than reasonable decentralised solution, but
> will probably take some real work to implement (not that this is avoidable
> for
> a general-usage decentralised solution).
>
> > - missing an optional client supplied identification
>
> What do you mean by this? There's the memo field at least.
>
> > - lack of basic subscription support
> >
> > *Proposed for subscriptions:*
> >
> > - BIP0047 payment codes are recommended instead of wallet addresses when
> > establishing subscriptions.  Or, merchants can specify replacement
> > addresses in ACK/NACK responses.   UI confirms are *required *when there
> > are no replacement addresses or payment codes used.
>
> I'd discourage anything using BIP 47 due to its serious design flaws.
> No reason a regular BIP 32 pub seed can't be used instead.
>
> What do you mean by "replacement addresses" and "UI confirms" here?
>
> > - Wallets must confirm and store subscriptions, and are responsible for
> > initiating them at the specified interval.
> >
> > - Intervals can *only *be from a preset list: weekly, biweekly, or 1,
> > 2,3,4,6 or 12 months.   Intervals missed by more than 3 days cause
> > suspension until the user re-verifies.
>
> Disagree with hard-coding intervals, or mandating specific policies from
> the
> service providers.
>
> > - Wallets *may *optionally ask the user whether they want to be notified
> > and confirm every interval - or not.   Wallets that do not ask *must
> > *notify before initiating each payment.   Interval confirmations should
> > begin at *least *1 day in advance of the next payment.
>
> This is wallet policy, but maybe makes sense as a "best practices" BIP.
>
> > *Proposed in general:*
> > - JSON should be used instead of protocol buffers going forward.  Easier
> to
> > use, explain extend.
> >
> > - "Extendible" URI-like scheme to support multi-mode identity mechanisms
> on
> > both payment and subscription requests.   Support for keybase://,
> netki://
> > and others as alternates to https://.
> >
> > - Support for client as well as merchant multi-mode verification
> >
> > - Ideally, the identity verification URI scheme is somewhat
> > orthogonal/independent of the payment request itself
> >
> > Question:
> >
> > Should this be a new BIP?  I know netki's BIP75 is out there - but I
> think
> > it's too specific and too reliant on the domain name system.
> >
> > Maybe an identity-protocol-agnostic BIP + solid implementation of a
> couple
> > major protocols without any mention of payment URI's ... just a way of
> > sending and receiving identity verified messages in general?
> >
> > I would be happy to implement plugins for identity protocols, if anyone
> > thinks this is a good idea.
> >
> > Does anyone think https:// or keybase, or PGP or netki all by
> themselves,
> > is enough - or is it always better to have an extensible protocol?
> >
> > - Erik Aronesty
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/9920f0c4/attachment.html>

From pete at petertodd.org  Tue Jun 21 22:10:08 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Jun 2016 18:10:08 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <201606212044.38931.luke@dashjr.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<201606212044.38931.luke@dashjr.org>
Message-ID: <20160621221008.GB10196@fedora-21-dvm>

On Tue, Jun 21, 2016 at 08:44:37PM +0000, Luke Dashjr via bitcoin-dev wrote:
> On Monday, June 20, 2016 5:33:32 PM Erik Aronesty via bitcoin-dev wrote:
> > BIP 0070 has been a a moderate success, however, IMO:
> > 
> > - protocol buffers are inappropriate since ease of use and extensibility is
> > desired over the minor gains of efficiency in this protocol.  Not too late
> > to support JSON messages as the standard going forward
> 
> IMO JSON is too prone to gratuitous inefficiency (both at network and CPU 
> level), parser bugs, etc. Even the best C implementation (jansson) has serious 
> issues with Number handling.
> 
> A few years ago, I looked into binary alternatives to JSON and concluded they 
> all had problems, while it seems more than reasonable to do even dynamic 
> parsing of protobuf messages. So to conclude, I prefer to stick to protobuf 
> unless a clearly superior protocol turns up.

I'll second that statement.

Ease of use isn't a very good criteria for security-critical software handling
money, and the JSON standard has a very large amount of degrees of freedom in
how people have implemented it historically. Even protobuf I'd personally avoid
using on that basis, as protobuf encoding isn't deterministic: you can encode
the same data in multiple ways.

Unfortunately there isn't a viable alternative, so we're probably stuck with
protobuf right now for standards that want to see wide adoption in the near
future; I've got a few projects that need an alternative, which I'm working on,
but that's a ways off.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/ab86e67e/attachment.sig>

From pete at petertodd.org  Tue Jun 21 22:13:47 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Jun 2016 18:13:47 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
Message-ID: <20160621221347.GC10196@fedora-21-dvm>

On Mon, Jun 20, 2016 at 05:33:32PM +0000, Erik Aronesty via bitcoin-dev wrote:
> BIP 0070 has been a a moderate success, however, IMO:
> 
> - protocol buffers are inappropriate since ease of use and extensibility is
> desired over the minor gains of efficiency in this protocol.  Not too late
> to support JSON messages as the standard going forward
> 
> - problematic reliance on merchant-supplied https (X509) as the sole form
> of mechant identification.   alternate schemes (dnssec/netki), pgp and
> possibly keybase seem like good ideas.   personally, i like keybase, since
> there is no reliance on the existing domain-name system (you can sell with
> a github id, for example)
> 
> - missing an optional client supplied identification

Note that "client supplied identification" is being pushed for AML/KYC
compliance, e.g. Netki's AML/KYC compliance product:

http://www.coindesk.com/blockchain-identity-company-netki-launch-ssl-certificate-blockchain/

This is an extremely undesirable feature to be baking into standards given it's
negative impact on fungibility and privacy; we should not be adopting standards
with AML/KYC support, for much the same reasons that the W3C should not be
standardizing DRM.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/5e89e377/attachment.sig>

From pete at petertodd.org  Tue Jun 21 22:19:40 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Jun 2016 18:19:40 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <201606212044.38931.luke@dashjr.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<201606212044.38931.luke@dashjr.org>
Message-ID: <20160621221940.GA10368@fedora-21-dvm>

On Tue, Jun 21, 2016 at 08:44:37PM +0000, Luke Dashjr via bitcoin-dev wrote:
> X509 is entrenched, so it should remain supported. PGP might make sense for 
> people already using it (it provides no real security for un-WoT-networked 
> users), but unforunately, few people use it. Correct me if I'm wrong, but IIRC 
> Keybase uses blockchain spam, so definitely not something to be encouraged if 

How else would you have keybase accomplish what they're accomplishing, with the
same security model?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/ec2235c8/attachment-0001.sig>

From pete at petertodd.org  Tue Jun 21 22:42:25 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Jun 2016 18:42:25 -0400
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
 Consensus
In-Reply-To: <CAJQ8TmBw3PdCYv=fsyiXMTNO_sHZEj__n0Rsra6id+ORxQworA@mail.gmail.com>
References: <20160620085649.GA29964@fedora-21-dvm> <5767EEFE.7060103@dyne.org>
	<CAJQ8TmBw3PdCYv=fsyiXMTNO_sHZEj__n0Rsra6id+ORxQworA@mail.gmail.com>
Message-ID: <20160621224225.GA10422@fedora-21-dvm>

On Mon, Jun 20, 2016 at 04:21:39PM +0000, zaki--- via bitcoin-dev wrote:
> Hi Peter,
> 
> I didn't entirely understand the process of transaction linearization.
> 
> What I see is a potential process where when the miner assembles the block,
> he strips all but one sigscript per tx. The selection of which  sigscript
> is retained is determined by the random oracle.  Is this is primary benefit
> you are suggesting?
> 
> It appears to me that blocks still need to contain a list of full TX Input
> and Tx Outputs with your approach. Some of the description seems to
> indicate that there are opportunities to elide further data but it's
> unclear to me how.

I think you've misunderstood what I'm proposing. The state machine approach I
described doesn't necessarily require blocks or even miners to exist at all.
Rather, it assumes that a single-use seal primitive is available, and a random
beacon primitive for tx linearization, and then builds a system on top of those
primitives. Transaction data - the proofs that certain states have been reached
in the system - does not need to be broadcast publicly; if Alice wants to
convince Bob that she has given him money, the only person who needs that
transaction (and transactions prior to it in the tx history) is Bob.

So as to your question about miners assembling blocks, and what blocks contain:
there doesn't need to be blocks at all! Transaction history linearization is
something your wallet would do for you.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/6a758129/attachment.sig>

From macwhyte at gmail.com  Tue Jun 21 22:50:36 2016
From: macwhyte at gmail.com (James MacWhyte)
Date: Tue, 21 Jun 2016 22:50:36 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160621221347.GC10196@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
Message-ID: <CAH+Axy59VfuiY7jp7CVrg0umt_AZydvYV8TP_RPUtEyGME9aCw@mail.gmail.com>

> Note that "client supplied identification" is being pushed for AML/KYC
> compliance, e.g. Netki's AML/KYC compliance product:
>
>
> http://www.coindesk.com/blockchain-identity-company-netki-launch-ssl-certificate-blockchain/
>
> This is an extremely undesirable feature to be baking into standards given
> it's
> negative impact on fungibility and privacy; we should not be adopting
> standards
> with AML/KYC support, for much the same reasons that the W3C should not be
> standardizing DRM.
>
>
KYC isn't the only use case. There are other situations in which you would
want to confirm who is sending you money. Making it *required* would of
course be a horrible idea, but allowing people to identify themselves, in
many cases with an online-only identity that isn't tied to their real world
identity, will be very useful to newly-developing use cases.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/6984221f/attachment.html>

From pete at petertodd.org  Tue Jun 21 23:02:33 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 21 Jun 2016 19:02:33 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAH+Axy59VfuiY7jp7CVrg0umt_AZydvYV8TP_RPUtEyGME9aCw@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CAH+Axy59VfuiY7jp7CVrg0umt_AZydvYV8TP_RPUtEyGME9aCw@mail.gmail.com>
Message-ID: <20160621230233.GA10705@fedora-21-dvm>

On Tue, Jun 21, 2016 at 10:50:36PM +0000, James MacWhyte wrote:
> > Note that "client supplied identification" is being pushed for AML/KYC
> > compliance, e.g. Netki's AML/KYC compliance product:
> >
> >
> > http://www.coindesk.com/blockchain-identity-company-netki-launch-ssl-certificate-blockchain/
> >
> > This is an extremely undesirable feature to be baking into standards given
> > it's
> > negative impact on fungibility and privacy; we should not be adopting
> > standards
> > with AML/KYC support, for much the same reasons that the W3C should not be
> > standardizing DRM.
> >
> >
> KYC isn't the only use case. There are other situations in which you would
> want to confirm who is sending you money. Making it *required* would of
> course be a horrible idea, but allowing people to identify themselves, in
> many cases with an online-only identity that isn't tied to their real world
> identity, will be very useful to newly-developing use cases.

It's easy to confirm who is sending you money: give out different addresses to
different people, and keep those addresses private.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/0cbe3456/attachment.sig>

From justin at netki.com  Wed Jun 22 00:14:31 2016
From: justin at netki.com (Justin Newton)
Date: Tue, 21 Jun 2016 17:14:31 -0700
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160621221347.GC10196@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
Message-ID: <CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>

On Tue, Jun 21, 2016 at 3:13 PM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Jun 20, 2016 at 05:33:32PM +0000, Erik Aronesty via bitcoin-dev
> wrote:
>
> > - missing an optional client supplied identification
>
> Note that "client supplied identification" is being pushed for AML/KYC
> compliance, e.g. Netki's AML/KYC compliance product:
>
>
> http://www.coindesk.com/blockchain-identity-company-netki-launch-ssl-certificate-blockchain/
>
> This is an extremely undesirable feature to be baking into standards given
> it's
> negative impact on fungibility and privacy; we should not be adopting
> standards
> with AML/KYC support, for much the same reasons that the W3C should not be
> standardizing DRM.
>

Hi Peter,
   Certainly AML/KYC compliance is one of the use cases that BIP 75 and our
certificates can support.  As a quick summary,

There are individuals and entities that would like to buy, sell, and use
bitcoin, and other public blockchains, but that have compliance
requirements that they need to meet before they can do so.  Similarly,
companies and entrepreneurs in the space suffer under the potential threat
of fines, or in extreme cases, jail time, also for not meeting AML or
sanctions list compliance.  We wanted to build tools that allowed
entrepreneurs to breathe easy, while at the same time allow more people and
companies to enter the ecosystem.  We also believe that the solution we are
using has the characteristics that you want in such a solution, for example:

1> Only the counterparties (and possibly their service providers in the
case of hosted services) in a transaction can see the identity data,
protecting user privacy.

2> The counterparties themselves (and possibly their service providers in
the case of hosted services) decide whether identity information is
required for any given transaction.

3> No trace is left on the blockchain or anywhere else (other than with the
counterparties) that identity information was even exchanged, protecting
fungibility

4> The solution is based on open source and open standards, allowing open
permissionless innovation, versus parties building closed networks based on
closed standards.  The very fact that this solution went through the BIP
process and was adapted based on feedback is an example of how this is
better for users than the inevitable closed solution that would arise if
the open source, community vetted version didn?t already exist.

I don?t know if you are opposed to organizations that have AML requirements
from using the bitcoin blockchain, but if you aren?t, why wouldn?t you
prefer an open source, open standards based solution to exclusionary,
proprietary ones?

BIP 70 and BIP 75 are standards for voluntary information exchange between
counterparties in a transaction.  This is exactly the kind of thing we want
standards for, in my experience.


-- 

Justin W. Newton
Founder/CEO
Netki, Inc.

justin at netki.com
+1.818.261.4248
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/e821a4e8/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PastedGraphic-1.tiff
Type: image/tiff
Size: 10972 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/e821a4e8/attachment-0001.tiff>

From scott at adligo.com  Tue Jun 21 22:12:32 2016
From: scott at adligo.com (Scott Morgan)
Date: Tue, 21 Jun 2016 17:12:32 -0500
Subject: [bitcoin-dev] Merkel Forrest Partitioning
Message-ID: <CANEdHmj92DirMaavmFpHPOmCgBobdsy=czSbY2pLOEGKjgTPBw@mail.gmail.com>

Hi Akiva,

   I have also given a little thought to partitioning, in a totally
different way a Merkel Tree Forrest. Generally the idea here would have be
to create new Merkel Trees every so often as currency supply was added. It
would partition the mining process and therefore improve the distribution
of the verification.

It would work as follows, and NO I haven't really thought this through it's
just an idea!


Imagine it was 2009 and there was a small number of 250 BTC in 'Batch 1',
once the number of BTC needed to go above 250 BTC two new Batches would be
created each one with it's own Merkel Tree until 750 BTC and so on.
Eventually there would be a large number of trees, allowing small scale
pool miners to dominate a single or small number of the trees and their
block chains.

This would also create a potential partial payment problem, where you send
3 BTC but only receive 2 BTC since 1 BTC ends up on a bad block and needs
to be resent.


Since most of the BTC currency supply is already available it's a bit late
for BitCoin, but could be used for new crypto currencies.


Any thoughts on this idea?


Cheers,

Scott
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160621/b9c50054/attachment.html>

From luke at dashjr.org  Wed Jun 22 00:36:53 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 22 Jun 2016 00:36:53 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKg+9kfOwvSH3GENr-=RYnctGHEw_7o-UmFqjAMJaaZ8AtA@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<201606212044.38931.luke@dashjr.org>
	<CAJowKg+9kfOwvSH3GENr-=RYnctGHEw_7o-UmFqjAMJaaZ8AtA@mail.gmail.com>
Message-ID: <201606220036.54258.luke@dashjr.org>

On Tuesday, June 21, 2016 9:42:39 PM Erik Aronesty wrote:
> > What do you mean by "replacement addresses" and "UI confirms" here?
> 
> "Replacement addresses" would take the place of BIP 32/47 support, if
> someone thought maybe that was too difficult to deal with.   So each time i
> paid Alice, Alice could generate a new payment address for the next monthly
> payment.   If you support BIP 32 pub seed, then there's no need for this.

I suppose it makes sense that since every payment requires communication with 
the recipient, that the recipient could give you a new scriptPubKey each time. 
No need to save [potentially compromised] payment info in advance?

> I don't know any wallets that support a BIP 32 pub seed (and then what,
> some random number generator?) as a destination address yet.

The point, as I see it, of payment protocol(s) is to deprecate addresses.
ie, this new protocol *could be* the BIP 32 pub seed destination address. ;)

> > Disagree with hard-coding intervals, or mandating specific policies from
> > the service providers.
> 
> I think mandating is a harsh word here, but i I'm a strong believer in
> providing strict guidelines that if people break, others can call them
> on.   Giving someone a 12.3 +/- 5 day interval for payments using this
> protocol would suck.   You should use payment channels for that stuff.
> The idea is a lightweight protocol for getting monthly subscriptions
> working.

Maybe just a field specifying how far in advance payments should be sent, 
then?

Luke

From thomasv at electrum.org  Wed Jun 22 07:57:37 2016
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Wed, 22 Jun 2016 09:57:37 +0200
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
Message-ID: <576A44F1.9050108@electrum.org>

IMO the moderate success of BIP70 is caused by its complexity. Since the
amount of data in a BIP70 payment request does not fit in a bitcoin:
URI, an https server is required to serve the requests.

Only large merchants are able to maintain such an infrastructure; (even
Coinbase recently failed at it, they forgot to update their
certificate). For end users that is completely unpractical.

The main benefit of BIP70 is that the payment request is signed by the
requestor; this gives the sender a proof that they are sending to the
right person, and that the person actually requested the payment.

The same benefit can be achieved without the complexity of BIP70, by
extending the Bitcoin URI scheme. The requestor is authenticated using
DNSSEC, and the payment request is signed using an EC private key. A
domain name and an EC signature are short enough to fit in a Bitcoin URI
and to be shared by QR code or SMS text.

 bitcoin:address?amount=xx&message=yyy&name=john.example.com&sig=zzz

The URI scheme is extended with two fields:
 name: DNS name containing a public key or bitcoin address
 sig: signature

That extension is sufficient to provide authenticated requests, without
requiring a https server. The signed data can be serialized from the
URI, and DNSSEC verification succeeds without requesting extra data from
the requestor. The only assumption is that the verifier is able to make
DNS requests.

I am willing to write a BIP if other wallet developers are interested.




Le 20/06/2016 19:33, Erik Aronesty via bitcoin-dev a ?crit :
> BIP 0070 has been a a moderate success, however, IMO:
> 
> - protocol buffers are inappropriate since ease of use and extensibility is
> desired over the minor gains of efficiency in this protocol.  Not too late
> to support JSON messages as the standard going forward
> 
> - problematic reliance on merchant-supplied https (X509) as the sole form
> of mechant identification.   alternate schemes (dnssec/netki), pgp and
> possibly keybase seem like good ideas.   personally, i like keybase, since
> there is no reliance on the existing domain-name system (you can sell with
> a github id, for example)
> 
> - missing an optional client supplied identification
> 
> - lack of basic subscription support
> 
> *Proposed for subscriptions:*
> 
> - BIP0047 payment codes are recommended instead of wallet addresses when
> establishing subscriptions.  Or, merchants can specify replacement
> addresses in ACK/NACK responses.   UI confirms are *required *when there
> are no replacement addresses or payment codes used.
> 
> - Wallets must confirm and store subscriptions, and are responsible for
> initiating them at the specified interval.
> 
> - Intervals can *only *be from a preset list: weekly, biweekly, or 1,
> 2,3,4,6 or 12 months.   Intervals missed by more than 3 days cause
> suspension until the user re-verifies.
> 
> - Wallets *may *optionally ask the user whether they want to be notified
> and confirm every interval - or not.   Wallets that do not ask *must *notify
> before initiating each payment.   Interval confirmations should begin at *least
> *1 day in advance of the next payment.
> 
> 
> *Proposed in general:*
> - JSON should be used instead of protocol buffers going forward.  Easier to
> use, explain extend.
> 
> - "Extendible" URI-like scheme to support multi-mode identity mechanisms on
> both payment and subscription requests.   Support for keybase://, netki://
> and others as alternates to https://.
> 
> - Support for client as well as merchant multi-mode verification
> 
> - Ideally, the identity verification URI scheme is somewhat
> orthogonal/independent of the payment request itself
> 
> Question:
> 
> Should this be a new BIP?  I know netki's BIP75 is out there - but I think
> it's too specific and too reliant on the domain name system.
> 
> Maybe an identity-protocol-agnostic BIP + solid implementation of a couple
> major protocols without any mention of payment URI's ... just a way of
> sending and receiving identity verified messages in general?
> 
> I would be happy to implement plugins for identity protocols, if anyone
> thinks this is a good idea.
> 
> Does anyone think https:// or keybase, or PGP or netki all by themselves,
> is enough - or is it always better to have an extensible protocol?
> 
> - Erik Aronesty
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From pete at petertodd.org  Wed Jun 22 11:10:09 2016
From: pete at petertodd.org (Peter Todd)
Date: Wed, 22 Jun 2016 07:10:09 -0400
Subject: [bitcoin-dev] Closed Seal Sets and Truth Lists for Better Privacy
 and Censorship Resistance
Message-ID: <20160622111009.GA10956@fedora-21-dvm>

At the recent coredev.tech meetup in Zurich I spent much of my time discussing
anti-censorship improvements with Adam Back, building on his idea of blind
symmetric commitments[^bsc], and my own ideas of client-side verification. Our
goal here is to combat censorship by ensuring that miners do not have the
information needed to selectively censor (blacklist) transactions, forcing them
to adopt a whitelist approach of allowed transactions if they choose to censor.

Back's work achieves that by changing the protocol such that users commit to
their transaction in advance, in such a way that the commitment doesn't contain
the information necessary to censor the transaction, although after commitment
all transactional information becomes available. Here we propose a similar
scheme with using "smart contract" state machine tooling, with the potential
for an even better Zerocash-like guarantee that only a subset of data ever
becomes public, without requiring "moon math" of uncertain security.


# The Closed Seal Maps

To implement Single-Use Seals we propose that miners attest to the contents of
a series of key:value maps of true expressions, with the keys being the
expressions, and the values being commitments, which along with (discardable)
witnesses make up the argument to the expression. Once an expression is added
to the closed seal map, the value associated with it can't be changed.

Periodically - perhaps once a year - the most recent map is archived, and the
map is started fresh again. Once archived a closed seal map is never changed.
Miners are expected to keep the contents of the current map, as well as the
most recent closed seal map - the contents of older maps are proven on demand
using techniques similar to TXO commitments.

A single-use seal[^sma] implemented with the closed seal maps is then
identified by the expression and a block height. The seal is open if the
expression does not exist in any closed seal maps between the creation block
height and the most recent block height. A witness to the fact that the seal
has been closed is then a proof that the seal was recorded as closed in one of
the closed seal maps, and (if needed) proof that the seal was still open in any
prior maps between its creation and closing.

Similar to the logic in Bitcoin's segregated witnesses proposal, separating the
commitment and witness arguments to the seal expression ensures that the
witness attesting to the fact that a given seal was closed does not depend on
the exact signature used to actually close it.

Here's a very simple example of such a seal expression, in the author's
Dex[^dex] expression language, for an application that can avoid reusing
pubkeys:

     (checksig <pubkey> <sig> (hash <committed-value>))

This desugars to the following after all named arguments were replaced by
explicit destructuring of the expression argument, denoted by the arg symbol:

    (and <nonce>
         (checksig <pubkey> (cdr arg) (digest (car arg))))

The arguments to the expression are the closed seal map's commitment and
witness, which are our committed value and signature respectively:

    (<committed-value> . <sig>)


## The Truth List

We implement an expression validity oracle by having miners attest to the
validity of a perpetually growing list of true predicate expressions, whose
evaluation can in turn depend on depend on previously attested expressions in
the truth list. SPV clients who trust miners can use the truth list to skip
validation of old history.

Similar to TXO commitments, we expect miners to have a copy of recent entries
in the truth list, perhaps the previous year. Older history can be proven on an
as-needed basis. Unlike TXO commitments, since this is a pure list of valid
expressions, once an item is added to the list it is never modified.

As the truth list can include expressions that reference previously
evaluated expressions, expressions of arbitrary depth can be evaluated. For
example, suppose we have an extremely long linked list of numbers, represented
as the following sexpr:

    (i_n i_n-1 i_n-2 ... i_1 i_0)

We want to check that every number in the list is even:

    (defun all-even? (l)
        (match l
            (nil true)
            ((n . rest) (if (mod n 2)
                            false
                            (all-even? rest)))))

In any real system this will fail for a sufficiently long list, either due to
stack overflow, or (if tail recursion is supported) due to exceeding the
anti-DoS limits on cycles executed in one expression; expressing the above may
even be impossible in expression systems that don't allow unbounded recursion.

A more subtle issue is that in a merkelized expression language, an expression
that calls itself is impossible to directly represent: doing so creates a cycle
in the call graph, which isn't possible without breaking the hash function. So
instead we'll define the special symbol self, which triggers a lookup in the
truth map instead of actually evaluating directly. Now our expression is:

    (defun all-even? (l)
        (match l
            (nil true)
            ((n . rest) (if (mod n 2)
                            false
                            (self rest)))))

We evaluate it in parts, starting with the end of the list. The truth list only
attests to valid expressions - not arguments - so we curry the argument to form
the following expression:

    (all-even? nil)

The second thing that is appended to the truth list is:

    (all-even? (0 . #<digest of "nil">))

Note how we haven't actually provided the cdr of the cons cell - it's been
pruned and replaced by the digest of nil. With an additional bit of metadata -
the index of that expression within the trust list, and possibly a merkle path
to the tip if the expression has been archived - we can show that the
expression has been previously evaluated and is true.

Subsequent expressions follow the same pattern:

    (all-even? (1 . #<digest of "(0)">))

Until finally we reach the last item:

    (all-even? (n_i . #<digest of "(n_i-1 n_i-2 ... 1 0)">))

Now we can show anyone who trusts that the truth list is valid - like a SPV
client - that evaluating all-even? on that list returns true by extracting a
merkle path from that item to the tip of the list's MMR commitment.


# Transactions

When we spend an output our goal is to direct the funds spent to a set of
outputs by irrovocably committing single-use seals to that distribution of
outputs. Equally, to validate an output we must show that sufficient funds have
been directed assigned to it. However, our anti-censorship goals make this
difficult, as we'll often want to reveal some information about where funds
being spend are going immediately - say to pay fees - while delaying when other
information is revealed as long as possible.

To achieve this we generalize the idea of a transaction slightly. Rather than
simply having a set of inputs spent and outputs created, we have a set of
_input splits_ spent, and outputs created. An input split is then a merkle-sum
map of nonces:values that the particular input has been split into; the
transaction commits to a specific nonce within that split, and is only valid if
the seal for that input is closed over a split actually committing to the
transaction.

Secondly, in a transaction with multiple outputs, we don't want it to be
immediately possible to link outputs together as seals associated with them are
closed, even if the transaction ID is known publicly. So we associate each
output with a unique nonce.

Thus we can uniquely identify a specific transaction output - an outpoint - by
the following data (remember that the tx would usually be pruned, leaving just
the digest):

    (struct outpoint
        (tx     :transaction)
        (nonce  :digest))

An transaction output is defined as:

    (struct txout
        (value     :int)    ; value of output
        (nonce     :digest)
        (authexpr  :func))  ; authorization expression

An input:

    (struct txin
        (prevout :outpoint) ; authorization expression
        (split   :digest)   ; split nonce
        (value   :int))     ; claimed value of output spent

And a transaction:

    (struct transaction
        ; fixme: need to define functions to extract sums and keys
        (inputs   :(merkle-sum-map  (:digest :txin))
        (outputs  :(merkle-sum-map  (:digest :txout))
        ; and probably more metadata here)


## Spending Outputs

Our single-use seal associated with a specific output is the expression:

    (<auth expr> <outpoint> . arg)

When the seal is closed it commits to the merkle-sum split map, which is
indexed by split nonces, one per (tx, value) pair committed to.  This means
that in the general case of an spend authorization expression that just checks
a signature, the actual outpoint can be pruned and what actually gets published
in the closed seal set is just:

    (<auth expr> #<digest of <outpoint>> . arg)

Along with the commitment:

    #<digest of split map>

With the relevant data hidden behind opaque digests, protected from
brute-forcing by nonces, external observers have no information about what
transaction output was spent, or anything about the transaction spending that
output. The nonce in the seal commitment prevents that multiple spends for the
same transaction from being linked together.  Yet at the same time, we're still
able to write a special-purpose spend auth expressions that do inspect the
contents of the transaction if needed.


## Validating Transactions

When validating a transaction, we want to validate the least amount of data
possible, allowing the maximum amount of data to be omitted for a given
recipient. Thus when we validate a transaction we _don't_ validate the outputs;
we only validate that the inputs spent by the transaction are valid, and the
sum of (split) inputs spent is correct. We only need to validate outputs when
they're spent - until then an invalid output is of no relevance. We also don't
need to validate any outputs other than the ones we're trying to spend - the
merkle sum tree guarantees that regardless of what's going on with other
outputs, the funds we're spending are uniquely allocated to us.

This means our function to check that a transaction is valid won't check the
outputs of the transaction itself, but will check outputs of previous
transactions:

    (defun valid-tx? (tx)
        (map-reduce tx.inputs
            (lambda (txin)
                (and <input is valid>
                     <witness is valid>
                     <split is valid>
                     (valid-output? txin.prevout)))))


# Censorship Resistant Usage

To make use of the separation between seal closure and validation we need to
pass transaction information from peer to peer. Let's look at what happens when
Alice pays Bob:

1. Alice picks one or more inputs to spend.

2. For each input she constructs a split, paying part of the funds to a
per-input fee transaction with no outputs, and committing part of the funds to
the transaction paying Bob. If she has change left over she'll construct a
third transaction with just that change as an input.

3. She signs each input, creating valid signatures for the corresponding
output's seal's authorization expression.

4. She broadcasts the subset of data corresponding to just the fee paying
transactions and related signatures individually, with a time delay between
each one. All other data is pruned, leaving just opaque digests.

5. Once all inputs are confirmed, she gives Bob the data corresponding to his
transaction, including the relevant parts of the merkle trees, and relevant
closed seal witnesses.

At this point, a whole bunch of seals have been closed, but there's absolutely
nothing on chain that links them together. Now let's suppose Bob pays Charlie,
using the funds Alice gave him, and a different input to pay mining fees:

1. Bob constructs a fee paying transaction, splitting some funds from a
previously revealed output, and depending on the seal for the output Alice gave
him, but without spending any of that output's funds.

2. Bob broadcasts the above publicly. Miners have to add both seals to the
closed seal set to collect the fees.

3. Once confirmed, Bob gives Charlie the corresponding transaction information
for his output, as well as the still-private information it depends on to prove
that the output Alice created for Bob is itself valid.

Again, nearly none of the information related to the transaction is public, yet
the funds have moved twice.


## Pruning Old History

Over time the proofs that a coin is valid will grow as each additional
transaction adds more data. We shorten these proofs by publishing some of the
data in the form of additions to the truth list of valid expressions,
specifically the is-valid-tx? expressions that determine whether or not a
transaction (and prior transactions) are valid. This allows SPV clients who
trust miners to stop validating once they reach that old history.

Secondly, with transaction history linearization[^sma] we can avoid ever
revealing most of the transaction data, greatly improving privacy. Only one
input per transaction needs to be proven, so all data related to other inputs
can be discarded permanently; in practice this will lead to either one or two
public inputs, including the input made public to pay mining fees.


# "Smart Contracts"

Privacy aside, the combination of single-use seal and true expressions list
enables all known "smart contract" applications, such as the ones Ethereum
currently targets. After all, the accounts-based Ethereum architecture can
always be simulated with a series of single-use seal's that explicitly keeps
track of of an account balance based on actions taken.


# Open Questions

1. How does the above architecture interact with scaling proposals, like
sharding? Fraud proofs?

2. How does the statistical inflation protection of transaction history
linearization work in a real economy, e.g. if people use it gamble with their
funds?

3. PoW isn't a perfect random beacon; how do we take that into account when
designing linearization?

4. How do wallets pass proof data between each other, e.g. offline?

5. How do wallets backup proof data? (similar problem that Lightning has)


# References

[^bsc]: "blind symmetric commitment for stronger byzantine voting resilience",
        Adam Back, May 15th 2013, bitcoin-dev mailing list,
        https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-May/002600.html

[^sma]: "Building Blocks of the State Machine Approach to Consensus",
        Peter Todd, Jun 20th 2016,
        https://petertodd.org/2016/state-machine-consensus-building-blocks
        https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012773.html

[^dex]: "Dex: Deterministic Predicate Expressions for Smarter Signatures",
        Peter Todd, May 25th 2016,
        https://github.com/WebOfTrustInfo/ID2020DesignWorkshop/blob/master/topics-and-advance-readings/DexPredicatesForSmarterSigs.md

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/bab63bb0/attachment-0001.sig>

From erik at q32.com  Wed Jun 22 14:25:03 2016
From: erik at q32.com (Erik Aronesty)
Date: Wed, 22 Jun 2016 10:25:03 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <576A44F1.9050108@electrum.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
Message-ID: <CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>

> Only large merchants are able to maintain such an infrastructure; (even
> Coinbase recently failed at it, they forgot to update their
> certificate). For end users that is completely unpractical.
>

Payment protocol is for when you buy stuff from purse.io, not really needed
for face-to face transfers, end users, IMO.


> The same benefit can be achieved without the complexity of BIP70, by
> extending the Bitcoin URI scheme. The requestor is authenticated using
> DNSSEC, and the payment request is signed using an EC private key. A
> domain name and an EC signature are short enough to fit in a Bitcoin URI
> and to be shared by QR code or SMS text.
>
>  bitcoin:address?amount=xx&message=yyy&name=john.example.com&sig=zzz
>

I agree.  A TXT record at that name could contain the pubkey.


> That extension is sufficient to provide authenticated requests, without
> requiring a https server. The signed data can be serialized from the
> URI, and DNSSEC verification succeeds without requesting extra data from
> the requestor. The only assumption is that the verifier is able to make
> DNS requests.
>

The problem is that there's no way for a merchant to *refuse *a payment
without a direct communication with the merchant's server.    Verify first
/ clear later is the rule.   Check stock, ensure you can deliver, and clear
the payment on the way out the door.

Also, as a merchant processing monthly subscriptions, you don't want the
first time you hear about a user's payment to be *after *it hits the
blockchain.  You could add a refund address to deal with it after the
fact... stuff a refund address int OP_RETURN somehow?

bitcoin:address?amount=xx&currency=ccc&message=yyy&name=john.example.com
&offset=3d&interval=1m&sig=zzz

... But what if the merchant simply goes out of business.  No OP_RETURN
will help you here.   You'll be posting transactions into a dead wallet.
You could have some way of posting a "ping" transaction, and then
monitoring for a valid response.   But this is "spamming the blockchain for
communications".

No, I think BIP075 is fine.   You just need to extend the *PaymentAck *with
a single field, instead of just having a memo.

next_payment_days : integer

The wallet, when it sees this field, re-initiates an invoice request after
the selected number of days, after presenting the user with the content of
the memo field which will presumably explain the subscription.   Wallet
vendors can let users "auto approve" vendors as needed.

This is, I think, the absolute minimum needed to update BIP0070/0075 for
subscriptions.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/69c8ccf9/attachment.html>

From info at AndySchroder.com  Wed Jun 22 15:12:04 2016
From: info at AndySchroder.com (Andy Schroder)
Date: Wed, 22 Jun 2016 11:12:04 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
Message-ID: <576AAAC4.1020304@AndySchroder.com>




>
>     Only large merchants are able to maintain such an infrastructure;
>     (even
>     Coinbase recently failed at it, they forgot to update their
>     certificate). For end users that is completely unpractical.
>
>
> Payment protocol is for when you buy stuff from purse.io 
> <http://purse.io>, not really needed for face-to face transfers, end 
> users, IMO.



I disagree with your statements. There are many face to face use cases 
where the payment protocol is essential. Pretty much anything where the 
payee's hardware device that the payer interacts with is automated in 
public and/or operated or accessible by untrusted employees. In any of 
those cases the software on the payee's hardware device can be modified. 
Providing a signed payment request gives the payer additional confidence 
that they are paying the correct person.

See some examples here: http://andyschroder.com/BitcoinFluidDispenser/2.3/


There was a secure bluetooth protocol that Andreas Schildbach and Eric 
Voskuil and I were working on, but we never pulled it all the way 
together. This would also need a two way exchange for a face to face 
payment. This could be used without using some sort of key/certificate 
verification service if being done between two humans who are the direct 
senders and receivers of the payment and are using hardware that they 
personally own (not necessarily the case of untrusted employees or 
public vulnerable machines).




>     The same benefit can be achieved without the complexity of BIP70, by
>     extending the Bitcoin URI scheme. The requestor is authenticated using
>     DNSSEC, and the payment request is signed using an EC private key. A
>     domain name and an EC signature are short enough to fit in a
>     Bitcoin URI
>     and to be shared by QR code or SMS text.
>
>      bitcoin:address?amount=xx&message=yyy&name=john.example.com
>     <http://john.example.com>&sig=zzz
>
>
> I agree.  A TXT record at that name could contain the pubkey.


Did you not see my previous message about the size of the bitcoin: URI 
getting too big for NFC and QR codes? Do you not care about giving the 
payer the option of using multiple destination payment addresses? This 
is important for many reasons.


>     That extension is sufficient to provide authenticated requests,
>     without
>     requiring a https server. The signed data can be serialized from the
>     URI, and DNSSEC verification succeeds without requesting extra
>     data from
>     the requestor. The only assumption is that the verifier is able to
>     make
>     DNS requests.
>
>
> The problem is that there's no way for a merchant to /refuse /a 
> payment without a direct communication with the merchant's server.    
> Verify first / clear later is the rule.   Check stock, ensure you can 
> deliver, and clear the payment on the way out the door.

So, are you saying first the payer should send an unsigned transaction 
for review, and then once the payee has agreed it's good, they can send 
an ACK message back and then wait for the signed version? I don't think 
this is a bad option to have. Many wallets simultaneously broadcast a 
signed transaction to their peers and and also back to the payee via 
https or bluetooth. So, you'd have to add another step to do the 
unsigned transaction review in order to avoid a transaction being 
accidentally broadcast that both parties don't like.


>
> Also, as a merchant processing monthly subscriptions, you don't want 
> the first time you hear about a user's payment to be /after /it hits 
> the blockchain.  You could add a refund address to deal with it after 
> the fact... stuff a refund address int OP_RETURN somehow?
>
> bitcoin:address?amount=xx&currency=ccc&message=yyy&name=john.example.com 
> <http://john.example.com>&offset=3d&interval=1m&sig=zzz

Again, my comments above about issues with using bitcoin: URI for 
everything. Also, why do you want to bloat the blockchain with 
unnecessary refund transaction data?


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/9ae17eed/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/9ae17eed/attachment.sig>

From erik at q32.com  Wed Jun 22 15:30:55 2016
From: erik at q32.com (Erik Aronesty)
Date: Wed, 22 Jun 2016 11:30:55 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <576AAAC4.1020304@AndySchroder.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
	<576AAAC4.1020304@AndySchroder.com>
Message-ID: <CAJowKgLK=AbsXcfsRKWNRQ=N=0QC3EVsALWxw6UOMCUXPo70fA@mail.gmail.com>

> Again, my comments above about issues with using bitcoin: URI for
everything. Also, why do you want to bloat the blockchain with unnecessary
refund transaction data?

I don't, sorry -  I was just kind of thinking out loud and explaining what
happens when you stuff that into a URL.

My conclusion at the bottom of that post was to keep BIP 75 the same, don't
change a bit, and stick any subscription information (future payment
schedule) in the PaymentACK.   Then the wallet then re-initiates an invoice
(unattended or attended.. up to the user), after the subscription interval
is passed.  Subscriptions are pretty important for Bitcoin to be used as a
real payment system.


?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/890f2b72/attachment-0001.html>

From info at AndySchroder.com  Wed Jun 22 16:20:38 2016
From: info at AndySchroder.com (Andy Schroder)
Date: Wed, 22 Jun 2016 12:20:38 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKgLK=AbsXcfsRKWNRQ=N=0QC3EVsALWxw6UOMCUXPo70fA@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
	<576AAAC4.1020304@AndySchroder.com>
	<CAJowKgLK=AbsXcfsRKWNRQ=N=0QC3EVsALWxw6UOMCUXPo70fA@mail.gmail.com>
Message-ID: <576ABAD6.7080308@AndySchroder.com>

I understand the need for people to make repeated payments to 
individuals in real life that they know, without the payee every even 
taking the effort to make a formal payment request (say you're just 
paying a family member of friend back for picking something up for you 
at the store, and you've already payed them many times before).

For a subscription, wouldn't it be better to promote payment channels or 
just send another payment request? I've been brainstorming recently 
about a model where service providers could deliver invoices, receipts, 
and payment requests in a standardized and secure way. In addition to 
having a send, receive, and transaction history tab in your bitcoin 
wallet, you'd also have an open payment channels tab (which would 
include all applications on your computer that have an open real time 
payment channel, such as a wifi access point, web browser, voip 
provider, etc.), as well as a "bills to pay" tab. Since everything would 
be automated and consolidated locally, you wouldn't have to deal with 
logging into a million different websites to get the bills and then pay 
them. If it were this easy, why would you ever want to do a recurring 
payment from a single payment request? I understand why you may think 
you want to given current work flows, but I'm wondering if it may be 
better to just skip over to a completely better way of doing things.


Andy Schroder

On 06/22/2016 11:30 AM, Erik Aronesty wrote:
> My conclusion at the bottom of that post was to keep BIP 75 the same, 
> don't change a bit, and stick any subscription information (future 
> payment schedule) in the PaymentACK.   Then the wallet then 
> re-initiates an invoice (unattended or attended.. up to the user), 
> after the subscription interval is passed. Subscriptions are pretty 
> important for Bitcoin to be used as a real payment system. 


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/a494da7d/attachment.sig>

From erik at q32.com  Wed Jun 22 17:07:21 2016
From: erik at q32.com (Erik Aronesty)
Date: Wed, 22 Jun 2016 13:07:21 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <576ABAD6.7080308@AndySchroder.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
	<576AAAC4.1020304@AndySchroder.com>
	<CAJowKgLK=AbsXcfsRKWNRQ=N=0QC3EVsALWxw6UOMCUXPo70fA@mail.gmail.com>
	<576ABAD6.7080308@AndySchroder.com>
Message-ID: <CAJowKgJMn5BDUUyQAU56XV-spUmy3GWHAieVEA9Nm9Y6ct7TNw@mail.gmail.com>

- Payment channels seem clearly inappropriate for things like monthly
subscriptions, the use of nlocktime, etc.

- Merchants cannot send requests to users for future payments, because
users don't run servers that they can connect to.  That's why BIP0070 works
the way it does.

- Need to have an interval for subscriptions, at a minimum, and stored in
the wallet so next months payment can go out on time

- Support for varying currency conversion needs to be baked in to
wallets.   Fortunately, by adding advisory subscription info to the
paymentrequest, this is left up to the wallet to
secure/validate/repeat/convert/etc. as needed for each subscription.

- The UI you describe is nice - but not unique to the solution.




On Wed, Jun 22, 2016 at 12:20 PM, Andy Schroder <info at andyschroder.com>
wrote:

> I understand the need for people to make repeated payments to individuals
> in real life that they know, without the payee every even taking the effort
> to make a formal payment request (say you're just paying a family member of
> friend back for picking something up for you at the store, and you've
> already payed them many times before).
>
> For a subscription, wouldn't it be better to promote payment channels or
> just send another payment request? I've been brainstorming recently about a
> model where service providers could deliver invoices, receipts, and payment
> requests in a standardized and secure way. In addition to having a send,
> receive, and transaction history tab in your bitcoin wallet, you'd also
> have an open payment channels tab (which would include all applications on
> your computer that have an open real time payment channel, such as a wifi
> access point, web browser, voip provider, etc.), as well as a "bills to
> pay" tab. Since everything would be automated and consolidated locally, you
> wouldn't have to deal with logging into a million different websites to get
> the bills and then pay them. If it were this easy, why would you ever want
> to do a recurring payment from a single payment request? I understand why
> you may think you want to given current work flows, but I'm wondering if it
> may be better to just skip over to a completely better way of doing things.
>
>
> Andy Schroder
>
>
> On 06/22/2016 11:30 AM, Erik Aronesty wrote:
>
>> My conclusion at the bottom of that post was to keep BIP 75 the same,
>> don't change a bit, and stick any subscription information (future payment
>> schedule) in the PaymentACK.   Then the wallet then re-initiates an invoice
>> (unattended or attended.. up to the user), after the subscription interval
>> is passed. Subscriptions are pretty important for Bitcoin to be used as a
>> real payment system.
>>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/d383acf0/attachment.html>

From macwhyte at gmail.com  Wed Jun 22 20:11:36 2016
From: macwhyte at gmail.com (James MacWhyte)
Date: Wed, 22 Jun 2016 20:11:36 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKgJMn5BDUUyQAU56XV-spUmy3GWHAieVEA9Nm9Y6ct7TNw@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
	<576AAAC4.1020304@AndySchroder.com>
	<CAJowKgLK=AbsXcfsRKWNRQ=N=0QC3EVsALWxw6UOMCUXPo70fA@mail.gmail.com>
	<576ABAD6.7080308@AndySchroder.com>
	<CAJowKgJMn5BDUUyQAU56XV-spUmy3GWHAieVEA9Nm9Y6ct7TNw@mail.gmail.com>
Message-ID: <CAH+Axy7WqFRrfi4HbtovDAa9pKfpPrvUWUSn4vZORqLjz_0YaQ@mail.gmail.com>

Thomas,

I like your idea about expanding Bitcoin URI's to include signatures. For
BIP75 store and forward servers we are already thinking the DNS record
would have the user's public key as well as the URL of their store and
forward endpoint, so as soon as that becomes a standard you could use it
just for the public key part. Expanding the Bitcoin URI should be done as
well, for people who want to go the simpler route and not rely on servers.

Erik, Andy, everyone else,

I don't understand why subscriptions would need to be built into the
protocol. With BIP75 the merchant could automatically issue a
PaymentRequest message every X amount of time, and the customer's wallet
would either display the request like normal or be set to pre-authorize
requests from the merchant. If the merchant goes out of business, the
requests would stop coming. This sounds like a UI issue and not a
protocol-level requirement.

If you think I'm wrong, please explain why :)

On Wed, Jun 22, 2016 at 12:35 PM Erik Aronesty via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> - Payment channels seem clearly inappropriate for things like monthly
> subscriptions, the use of nlocktime, etc.
>
> - Merchants cannot send requests to users for future payments, because
> users don't run servers that they can connect to.  That's why BIP0070 works
> the way it does.
>
> - Need to have an interval for subscriptions, at a minimum, and stored in
> the wallet so next months payment can go out on time
>
> - Support for varying currency conversion needs to be baked in to
> wallets.   Fortunately, by adding advisory subscription info to the
> paymentrequest, this is left up to the wallet to
> secure/validate/repeat/convert/etc. as needed for each subscription.
>
> - The UI you describe is nice - but not unique to the solution.
>
>
>
>
> On Wed, Jun 22, 2016 at 12:20 PM, Andy Schroder <info at andyschroder.com>
> wrote:
>
>> I understand the need for people to make repeated payments to individuals
>> in real life that they know, without the payee every even taking the effort
>> to make a formal payment request (say you're just paying a family member of
>> friend back for picking something up for you at the store, and you've
>> already payed them many times before).
>>
>> For a subscription, wouldn't it be better to promote payment channels or
>> just send another payment request? I've been brainstorming recently about a
>> model where service providers could deliver invoices, receipts, and payment
>> requests in a standardized and secure way. In addition to having a send,
>> receive, and transaction history tab in your bitcoin wallet, you'd also
>> have an open payment channels tab (which would include all applications on
>> your computer that have an open real time payment channel, such as a wifi
>> access point, web browser, voip provider, etc.), as well as a "bills to
>> pay" tab. Since everything would be automated and consolidated locally, you
>> wouldn't have to deal with logging into a million different websites to get
>> the bills and then pay them. If it were this easy, why would you ever want
>> to do a recurring payment from a single payment request? I understand why
>> you may think you want to given current work flows, but I'm wondering if it
>> may be better to just skip over to a completely better way of doing things.
>>
>>
>> Andy Schroder
>>
>>
>> On 06/22/2016 11:30 AM, Erik Aronesty wrote:
>>
>>> My conclusion at the bottom of that post was to keep BIP 75 the same,
>>> don't change a bit, and stick any subscription information (future payment
>>> schedule) in the PaymentACK.   Then the wallet then re-initiates an invoice
>>> (unattended or attended.. up to the user), after the subscription interval
>>> is passed. Subscriptions are pretty important for Bitcoin to be used as a
>>> real payment system.
>>>
>>
>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/ebc7af2e/attachment-0001.html>

From erik at q32.com  Wed Jun 22 20:37:06 2016
From: erik at q32.com (Erik Aronesty)
Date: Wed, 22 Jun 2016 16:37:06 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAH+Axy7WqFRrfi4HbtovDAa9pKfpPrvUWUSn4vZORqLjz_0YaQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
	<576AAAC4.1020304@AndySchroder.com>
	<CAJowKgLK=AbsXcfsRKWNRQ=N=0QC3EVsALWxw6UOMCUXPo70fA@mail.gmail.com>
	<576ABAD6.7080308@AndySchroder.com>
	<CAJowKgJMn5BDUUyQAU56XV-spUmy3GWHAieVEA9Nm9Y6ct7TNw@mail.gmail.com>
	<CAH+Axy7WqFRrfi4HbtovDAa9pKfpPrvUWUSn4vZORqLjz_0YaQ@mail.gmail.com>
Message-ID: <CAJowKgL2O44=UUg3h_-MqEEy3cHc+EhQPE3ivpxyyMN3VCLNDA@mail.gmail.com>

> I don't understand why subscriptions would need to be built into the
protocol.

Simple: Because the PaymentRequest is somewhat counter-intuitively a
/response/ to a customer initiated action.   It's not something the
merchant can initiate (of course, logically this makes sense... how can a
merchant know how to connect to some random android app).

Customers initiate all InvoiceRequests  BIP0075 clarifies this.   BIP0070
merely says that the customer "somehow indicates they are ready to pay".
BIP0075 formalizes a standard way to do this.

In no way do merchants initiate anything (of course).   Subscription
information must reside in the customers wallet, in response to a
merchant's advice to set up subscription.   Tacking parameters on to a
PaymentRequest or PaymentAck is the only good way to do this within BIP
70/75.

The only thing to hash out is exactly what fields to tack on and what they
mean.  ( subscription amount / currency / interval / interval_type ...
can't think of anything else )

Wallets are responsible for initiating the subscriptions on behalf of the
user.  Recommendations on how to do this should go into the spec.

Of course any wallet can, with BIP0075 add support for subscriptions
without any spec - just let the user set them up manually.   But it would
be nice if a user didn't have to enter the main parameters for
subscriptions... too easy to get times amounts, etc wrong.


On Wed, Jun 22, 2016 at 4:11 PM, James MacWhyte <macwhyte at gmail.com> wrote:

> Thomas,
>
> I like your idea about expanding Bitcoin URI's to include signatures. For
> BIP75 store and forward servers we are already thinking the DNS record
> would have the user's public key as well as the URL of their store and
> forward endpoint, so as soon as that becomes a standard you could use it
> just for the public key part. Expanding the Bitcoin URI should be done as
> well, for people who want to go the simpler route and not rely on servers.
>
> Erik, Andy, everyone else,
>
> I don't understand why subscriptions would need to be built into the
> protocol. With BIP75 the merchant could automatically issue a
> PaymentRequest message every X amount of time, and the customer's wallet
> would either display the request like normal or be set to pre-authorize
> requests from the merchant. If the merchant goes out of business, the
> requests would stop coming. This sounds like a UI issue and not a
> protocol-level requirement.
>
> If you think I'm wrong, please explain why :)
>
> On Wed, Jun 22, 2016 at 12:35 PM Erik Aronesty via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> - Payment channels seem clearly inappropriate for things like monthly
>> subscriptions, the use of nlocktime, etc.
>>
>> - Merchants cannot send requests to users for future payments, because
>> users don't run servers that they can connect to.  That's why BIP0070 works
>> the way it does.
>>
>> - Need to have an interval for subscriptions, at a minimum, and stored in
>> the wallet so next months payment can go out on time
>>
>> - Support for varying currency conversion needs to be baked in to
>> wallets.   Fortunately, by adding advisory subscription info to the
>> paymentrequest, this is left up to the wallet to
>> secure/validate/repeat/convert/etc. as needed for each subscription.
>>
>> - The UI you describe is nice - but not unique to the solution.
>>
>>
>>
>>
>> On Wed, Jun 22, 2016 at 12:20 PM, Andy Schroder <info at andyschroder.com>
>> wrote:
>>
>>> I understand the need for people to make repeated payments to
>>> individuals in real life that they know, without the payee every even
>>> taking the effort to make a formal payment request (say you're just paying
>>> a family member of friend back for picking something up for you at the
>>> store, and you've already payed them many times before).
>>>
>>> For a subscription, wouldn't it be better to promote payment channels or
>>> just send another payment request? I've been brainstorming recently about a
>>> model where service providers could deliver invoices, receipts, and payment
>>> requests in a standardized and secure way. In addition to having a send,
>>> receive, and transaction history tab in your bitcoin wallet, you'd also
>>> have an open payment channels tab (which would include all applications on
>>> your computer that have an open real time payment channel, such as a wifi
>>> access point, web browser, voip provider, etc.), as well as a "bills to
>>> pay" tab. Since everything would be automated and consolidated locally, you
>>> wouldn't have to deal with logging into a million different websites to get
>>> the bills and then pay them. If it were this easy, why would you ever want
>>> to do a recurring payment from a single payment request? I understand why
>>> you may think you want to given current work flows, but I'm wondering if it
>>> may be better to just skip over to a completely better way of doing things.
>>>
>>>
>>> Andy Schroder
>>>
>>>
>>> On 06/22/2016 11:30 AM, Erik Aronesty wrote:
>>>
>>>> My conclusion at the bottom of that post was to keep BIP 75 the same,
>>>> don't change a bit, and stick any subscription information (future payment
>>>> schedule) in the PaymentACK.   Then the wallet then re-initiates an invoice
>>>> (unattended or attended.. up to the user), after the subscription interval
>>>> is passed. Subscriptions are pretty important for Bitcoin to be used as a
>>>> real payment system.
>>>>
>>>
>>>
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160622/00d7edc0/attachment.html>

From pete at petertodd.org  Thu Jun 23 10:56:32 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Jun 2016 06:56:32 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
Message-ID: <20160623105632.GB19241@fedora-21-dvm>

On Tue, Jun 21, 2016 at 05:14:31PM -0700, Justin Newton wrote:
> On Tue, Jun 21, 2016 at 3:13 PM, Peter Todd via bitcoin-dev <
> Hi Peter,
>    Certainly AML/KYC compliance is one of the use cases that BIP 75 and our
> certificates can support.  As a quick summary,
> 
> There are individuals and entities that would like to buy, sell, and use
> bitcoin, and other public blockchains, but that have compliance
> requirements that they need to meet before they can do so.  Similarly,
> companies and entrepreneurs in the space suffer under the potential threat
> of fines, or in extreme cases, jail time, also for not meeting AML or
> sanctions list compliance.  We wanted to build tools that allowed
> entrepreneurs to breathe easy, while at the same time allow more people and
> companies to enter the ecosystem.  We also believe that the solution we are
> using has the characteristics that you want in such a solution, for example:
> 
> 1> Only the counterparties (and possibly their service providers in the
> case of hosted services) in a transaction can see the identity data,
> protecting user privacy.
> 
> 2> The counterparties themselves (and possibly their service providers in
> the case of hosted services) decide whether identity information is
> required for any given transaction.
> 
> 3> No trace is left on the blockchain or anywhere else (other than with the
> counterparties) that identity information was even exchanged, protecting
> fungibility
> 
> 4> The solution is based on open source and open standards, allowing open
> permissionless innovation, versus parties building closed networks based on
> closed standards.  The very fact that this solution went through the BIP
> process and was adapted based on feedback is an example of how this is
> better for users than the inevitable closed solution that would arise if
> the open source, community vetted version didn?t already exist.
> 
> I don?t know if you are opposed to organizations that have AML requirements
> from using the bitcoin blockchain, but if you aren?t, why wouldn?t you
> prefer an open source, open standards based solution to exclusionary,
> proprietary ones?

In some (most?) countries, it is illegal to offer telecoms services without
wiretap facilities. Does that mean Tor builds into its software "open source"
"open standards" wiretapping functionality? No. And interestingly, people
trying to add support for that stuff is actually a thing that keeps happening
in the Tor community...

In any case, I'd strongly argue that we remove BIP75 from the bips repository,
and boycott wallets that implement it. It's bad strategy for Bitcoin developers
to willingly participate in AML/KYC, just the same way as it's bad for Tor to
add wiretapping functionality, and W3C to support DRM tech. The minor tactical
wins you'll get our of this aren't worth it.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/594d6918/attachment.sig>

From pete at petertodd.org  Thu Jun 23 11:11:52 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Jun 2016 07:11:52 -0400
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
 Consensus
In-Reply-To: <CAE28kUTkBmhLm-7rNVtX7Dm2yYABQiepZX0RCYpBn60Uo9=ehA@mail.gmail.com>
References: <20160620085649.GA29964@fedora-21-dvm>
	<CAE28kUTkBmhLm-7rNVtX7Dm2yYABQiepZX0RCYpBn60Uo9=ehA@mail.gmail.com>
Message-ID: <20160623111152.GB19360@fedora-21-dvm>

On Tue, Jun 21, 2016 at 01:28:48AM +0300, Alex Mizrahi wrote:
> > All practical single-use seals will be associated with some kind of
> > condition,
> > such as a pubkey, or deterministic expression, that needs to be satisfied
> > for
> > the seal to be closed.
> 
> 
> I think it would be useful to classify systems w.r.t. what data is
> available to condition.
> I imagine it might be useful if status of other seals is available.

Useful yes, but actually implementing that often results in systems that are
too tightly coupled to scale well.

> > Secondly, the contents of the proof will be able to
> > commit to new data, such as the transaction spending the output associated
> > with
> > the seal.
> >
> 
> So basically a "condition" returns that "new data", right?
> If it commits to a data in a recognizable way, then it's practically a
> function which yields a tuple (valid, new_data).
> If an oracle doesn't care about data then you can convert it to a predicate
> using a simple projection.
> But from point of view of a client, it is a function which returns a tuple.

What do you mean by "new data"?

The point I'm making is simply that to be useful, when you close a seal you
have to be able to close it over some data, in particular, another seal. That's
the key thing that makes the idea a useful construct for smart contacts, value
transfer/currency systems, etc.

> It might help if you describe a type of the condition function.

I did describe some seal authorization condition functions in my more recent
post; the key thing is you'd have some kind of "checksig" operator that checks
a cryptographic signature.

> Some related work on UTXO-based smart contracts:

<snip>

Thanks for the links! Not at all surprising to me that there's a whole bunch of
projects working along those same lines; it's the obvious way to build this
kind of stuff once you realise that the imperative, stateful, model isn't
viable.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/17812b8c/attachment-0001.sig>

From pete at petertodd.org  Thu Jun 23 11:21:16 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Jun 2016 07:21:16 -0400
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
 Consensus
In-Reply-To: <5767EEFE.7060103@dyne.org>
References: <20160620085649.GA29964@fedora-21-dvm> <5767EEFE.7060103@dyne.org>
Message-ID: <20160623112116.GA19556@fedora-21-dvm>

On Mon, Jun 20, 2016 at 01:26:22PM +0000, Police Terror via bitcoin-dev wrote:
> Bitcoin could embed a lisp interpreter such as Scheme, reverse engineer
> the current protocol into lisp (inside C++), run this alternative engine
> alongside the current one as an option for some years (only for fine
> tuning) then eventually fade this lisp written validation code instead
> of the current one.

You know, I'm kinda regretting not making it sufficiently clear that Dex isn't
Lisp... It may look like it with all the braces, but expressions in it are
evaluated without any global state (they can be evaluated in parallel) and I've
got a lot of work ahead of me in type safety.

> Scheme is small and minimal, and embeds easily in C++. This could be a
> better option than the libconsensus library - validation in a functional
> scripting language.

I'd be surprised if you could find a scheme interpreter that's sufficiently
well defined to be suitable for that; starting with an existing one and
whipping it into shape would very likely be more work than starting from
scratch.
 
> That doesn't mean people can't program the validation code in other
> languages (maybe they'd want to optimize), but this code would be the
> standard.

Yeah, in general I'd expect most of these systems to be layered to a degree;
after all even in something like MAST you need tooling to manage the fact that
the opcodes that end up public, on-chain, are only a subset of the script.

> I wouldn't be so quick to deride good engineering over systematic
> provable systems for all domains. Bitcoin being written in C++ is not a
> defect. It's actually a strong language for what it does. Especially
> when used correctly (which is not often and takes years to master).

It's probably the best of a lot of bad alternatives... We use C++ not because
it's good, but because there's no other option.

In particular, we have enormous cost and risk in moving to other things due to
consensus, so making use of other languages is very difficult; my work with
dex/proofchains does not have that constraint.

> With the seals idea- am I understand this correctly?: Every transaction
> has a number (essentially the index starting from 0 upwards) depending
> on where it is in the blockchain.
> 
> Then there is an array (probably an on disk array mapping transaction
> indexes to hashes). Each hash entry in the array must be unique (the
> hashes) otherwise the transaction will be denied. This is a great idea
> to solve transaction hash collisions and simple to implement.

No, I think you've very much misunderstood things. The abstract notion of a
single-use seal doesn't even need global consensus on anything to implement; it
does not require transactions to have "indexes"

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/afb2886e/attachment.sig>

From pieter.wuille at gmail.com  Thu Jun 23 11:30:45 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 23 Jun 2016 13:30:45 +0200
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160623105632.GB19241@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
Message-ID: <CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>

On Jun 23, 2016 12:56, "Peter Todd via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> In any case, I'd strongly argue that we remove BIP75 from the bips
repository,
> and boycott wallets that implement it. It's bad strategy for Bitcoin
developers
> to willingly participate in AML/KYC, just the same way as it's bad for
Tor to
> add wiretapping functionality, and W3C to support DRM tech. The minor
tactical
> wins you'll get our of this aren't worth it.

I hope you're not seriously suggesting to censor a BIP because you feel it
is a bad idea.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/b6c34061/attachment.html>

From pete at petertodd.org  Thu Jun 23 11:39:04 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Jun 2016 07:39:04 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>
Message-ID: <20160623113904.GA19686@fedora-21-dvm>

On Thu, Jun 23, 2016 at 01:30:45PM +0200, Pieter Wuille wrote:
> On Jun 23, 2016 12:56, "Peter Todd via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > In any case, I'd strongly argue that we remove BIP75 from the bips
> repository,
> > and boycott wallets that implement it. It's bad strategy for Bitcoin
> developers
> > to willingly participate in AML/KYC, just the same way as it's bad for
> Tor to
> > add wiretapping functionality, and W3C to support DRM tech. The minor
> tactical
> > wins you'll get our of this aren't worth it.
> 
> I hope you're not seriously suggesting to censor a BIP because you feel it
> is a bad idea.

For the record, I think the idea of the bips repo being a pure publication
platform isn't a good one and doesn't match reality; like it or not by
accepting bips we're putting a stamp of some kind of approval on them.

For example, I suspect I wouldn't be able to get a BIP for a decentralized
assassination market protocol standard into the repository, regardless of
whether or not it was used - it's simply too distastful and controversial for
us to want to merge that. Would you call that rejection censorship?

I have zero issues with us exercising editorial control over what's in the bips
repo; us doing so doesn't in any way prevent other's from publishing elsewhere.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/6fce728d/attachment.sig>

From andreas at schildbach.de  Thu Jun 23 11:50:16 2016
From: andreas at schildbach.de (Andreas Schildbach)
Date: Thu, 23 Jun 2016 13:50:16 +0200
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<576A44F1.9050108@electrum.org>
	<CAJowKgLTtPKCV_6YWdTU2DiF0CAAiouggfGYVA+cax0Fyzc9Mg@mail.gmail.com>
Message-ID: <nkgidp$427$2@ger.gmane.org>

On 06/22/2016 04:25 PM, Erik Aronesty via bitcoin-dev wrote:
> 
>     Only large merchants are able to maintain such an infrastructure; (even
>     Coinbase recently failed at it, they forgot to update their
>     certificate). For end users that is completely unpractical.
> 
> 
> Payment protocol is for when you buy stuff from purse.io
> <http://purse.io>, not really needed for face-to face transfers, end
> users, IMO.

What Andy said, plus there is an (unencrypted) version of BIP70 via
Bluetooth already in place. And its used in several thousand
face-to-face trades per day.



From pieter.wuille at gmail.com  Thu Jun 23 12:01:10 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 23 Jun 2016 14:01:10 +0200
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160623113904.GA19686@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>
	<20160623113904.GA19686@fedora-21-dvm>
Message-ID: <CAPg+sBiqh80Q4Dfm0y6aEX+gHrcHZMq3tckejx8KDCPb-ikkOg@mail.gmail.com>

On Thu, Jun 23, 2016 at 1:39 PM, Peter Todd <pete at petertodd.org> wrote:
> On Thu, Jun 23, 2016 at 01:30:45PM +0200, Pieter Wuille wrote:
>> On Jun 23, 2016 12:56, "Peter Todd via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> > In any case, I'd strongly argue that we remove BIP75 from the bips
>> repository,
>> > and boycott wallets that implement it. It's bad strategy for Bitcoin
>> developers
>> > to willingly participate in AML/KYC, just the same way as it's bad for
>> Tor to
>> > add wiretapping functionality, and W3C to support DRM tech. The minor
>> tactical
>> > wins you'll get our of this aren't worth it.
>>
>> I hope you're not seriously suggesting to censor a BIP because you feel it
>> is a bad idea.
>
> For the record, I think the idea of the bips repo being a pure publication
> platform isn't a good one and doesn't match reality; like it or not by
> accepting bips we're putting a stamp of some kind of approval on them.

We? I don't feel like I have any authority to say what goes into that
repository, and neither do you. We just give technical opinion on
proposals. The fact that it's under the bitcoin organization on github
is a historical artifact.

> I have zero issues with us exercising editorial control over what's in the bips
> repo; us doing so doesn't in any way prevent other's from publishing elsewhere.

Editorial control is inevitable to some extent, but I think that's
more a matter of process than of opinion. Things like "Was there
community discussion?", "Is it relevant?", "Is there a reference
implementation?". I don't think that you objecting for moral reasons
to an otherwise technically sound idea is a reason for removal of a
BIP. You are of course free to propose alternatives, or recommend
against its usage.

-- 
Pieter

From pete at petertodd.org  Thu Jun 23 12:10:00 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Jun 2016 08:10:00 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAPg+sBiqh80Q4Dfm0y6aEX+gHrcHZMq3tckejx8KDCPb-ikkOg@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>
	<20160623113904.GA19686@fedora-21-dvm>
	<CAPg+sBiqh80Q4Dfm0y6aEX+gHrcHZMq3tckejx8KDCPb-ikkOg@mail.gmail.com>
Message-ID: <20160623121000.GA20073@fedora-21-dvm>

On Thu, Jun 23, 2016 at 02:01:10PM +0200, Pieter Wuille wrote:
> On Thu, Jun 23, 2016 at 1:39 PM, Peter Todd <pete at petertodd.org> wrote:
> > On Thu, Jun 23, 2016 at 01:30:45PM +0200, Pieter Wuille wrote:
> > For the record, I think the idea of the bips repo being a pure publication
> > platform isn't a good one and doesn't match reality; like it or not by
> > accepting bips we're putting a stamp of some kind of approval on them.
> 
> We? I don't feel like I have any authority to say what goes into that
> repository, and neither do you. We just give technical opinion on
> proposals. The fact that it's under the bitcoin organization on github
> is a historical artifact.

That's simply not how the rest of the community perceives bips, and until we
move them elsewhere that's not going to change.

No matter how much we scream that we don't have authority, the fact of the
matter is the bips are located under the github.com/bitcoin namespace, and we
do have editorial control over them.

> > I have zero issues with us exercising editorial control over what's in the bips
> > repo; us doing so doesn't in any way prevent other's from publishing elsewhere.
> 
> Editorial control is inevitable to some extent, but I think that's
> more a matter of process than of opinion. Things like "Was there
> community discussion?", "Is it relevant?", "Is there a reference
> implementation?". I don't think that you objecting for moral reasons
> to an otherwise technically sound idea is a reason for removal of a
> BIP. You are of course free to propose alternatives, or recommend
> against its usage.

Right, so you accept that we'll exert some degree of editorial control; the
question now is what editorial policies should we exert?

My argument is that rejecting BIP75 is something we should do on
ethical/strategic grounds. You may disagree with that, but please don't troll
and call that "advocating censorship"

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/406e462b/attachment.sig>

From pieter.wuille at gmail.com  Thu Jun 23 12:16:48 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 23 Jun 2016 14:16:48 +0200
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160623121000.GA20073@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>
	<20160623113904.GA19686@fedora-21-dvm>
	<CAPg+sBiqh80Q4Dfm0y6aEX+gHrcHZMq3tckejx8KDCPb-ikkOg@mail.gmail.com>
	<20160623121000.GA20073@fedora-21-dvm>
Message-ID: <CAPg+sBgCkD_54p10NgfDozFo+dNnm-mL1B=NyGYpkdrXgTtxUg@mail.gmail.com>

On Jun 23, 2016 14:10, "Peter Todd" <pete at petertodd.org> wrote:

> Right, so you accept that we'll exert some degree of editorial control;
the
> question now is what editorial policies should we exert?

No, I do not. I am saying that some degree of editorial control will
inevitably exist, simply because there is some human making the choice of
assigning a BIP number and merging. My opinion is that we should try to
restrict that editorial control to only be subject to objective process,
and not be dependent on personal opinions.

> My argument is that rejecting BIP75 is something we should do on
> ethical/strategic grounds. You may disagree with that, but please don't
troll
> and call that "advocating censorship"

I think that you are free to express dislike of BIP75. Suggesting to remove
it for that reason is utterly ridiculous to me, whatever you want to call
it.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/ba7a229f/attachment.html>

From pete at petertodd.org  Thu Jun 23 12:43:04 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 23 Jun 2016 08:43:04 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAPg+sBgCkD_54p10NgfDozFo+dNnm-mL1B=NyGYpkdrXgTtxUg@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<CAPg+sBg90FxbEy1smp9mn+djF-N6PdUprtQ7r_kgvKCGbTHndQ@mail.gmail.com>
	<20160623113904.GA19686@fedora-21-dvm>
	<CAPg+sBiqh80Q4Dfm0y6aEX+gHrcHZMq3tckejx8KDCPb-ikkOg@mail.gmail.com>
	<20160623121000.GA20073@fedora-21-dvm>
	<CAPg+sBgCkD_54p10NgfDozFo+dNnm-mL1B=NyGYpkdrXgTtxUg@mail.gmail.com>
Message-ID: <20160623124304.GA20280@fedora-21-dvm>

On Thu, Jun 23, 2016 at 02:16:48PM +0200, Pieter Wuille wrote:
> On Jun 23, 2016 14:10, "Peter Todd" <pete at petertodd.org> wrote:
> 
> > Right, so you accept that we'll exert some degree of editorial control;
> the
> > question now is what editorial policies should we exert?
> 
> No, I do not. I am saying that some degree of editorial control will
> inevitably exist, simply because there is some human making the choice of
> assigning a BIP number and merging. My opinion is that we should try to
> restrict that editorial control to only be subject to objective process,
> and not be dependent on personal opinions.
>
> > My argument is that rejecting BIP75 is something we should do on
> > ethical/strategic grounds. You may disagree with that, but please don't
> troll
> > and call that "advocating censorship"
> 
> I think that you are free to express dislike of BIP75. Suggesting to remove
> it for that reason is utterly ridiculous to me, whatever you want to call
> it.

In the future we're likely to see a lot of BIPs around AML/KYC support, e.g.
adding personal identity information to transactions, blacklist standards, etc.
Should we accept those BIPs into the bips repo?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/363edf91/attachment.sig>

From alex.mizrahi at gmail.com  Thu Jun 23 12:58:29 2016
From: alex.mizrahi at gmail.com (Alex Mizrahi)
Date: Thu, 23 Jun 2016 15:58:29 +0300
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
	Consensus
In-Reply-To: <20160623111152.GB19360@fedora-21-dvm>
References: <20160620085649.GA29964@fedora-21-dvm>
	<CAE28kUTkBmhLm-7rNVtX7Dm2yYABQiepZX0RCYpBn60Uo9=ehA@mail.gmail.com>
	<20160623111152.GB19360@fedora-21-dvm>
Message-ID: <CAE28kUQXLc=-8SoEsWNXz99hezMBmM0ws+Xx3+nrp4YPZkMaPQ@mail.gmail.com>

>
> The point I'm making is simply that to be useful, when you close a seal you
> have to be able to close it over some data, in particular, another seal.
> That's
> the key thing that makes the idea a useful construct for smart contacts,
> value
> transfer/currency systems, etc.
>

OK, your second post ("Closed Seal Sets and Truth Lists for Better Privacy
and Censorship Resistance") seems to clarify that this data is one of
arguments to the condition function.
Frankly this stuff is rather hard to follow. (Or maybe I'm dumb.)

Now I don't get scability properties. Let's consider a simplest scenario
where Alice creates some token, sends it to Bob, who sends it to Claire. So
now Claire needs to get both a proof that Alice sent it to Bob and that Bob
sent it to Claire, right? So Claire needs to verify 2 proofs, and for a
chain of N transfers one would need to verify N proofs, right?

And how it works in general:

1. Alice creates a token. To do that she constructs an unique expression
which checks her signature and signs a message "This token has such and
such meaning and its ownership originally associated with seal <hash of the
expression>" with her PGP key.
2. To transfer this token to Bob, she asks Bob for his auth expression and
sends a seal oracle a message (Alice_expression (Bob_expression .
signature)) where signatures is constructed in such a way that it evaluates
as true. Oracle stores this in a map: Alice_expression -> (Bob_expression .
signatures)
3. Bob sends token to Claire in a same way: (Bob_expression
(Claire_expression . signature))
4. Now Claire asks if Alice_expression->(Bob_expression . _) and
Bob_expression->(Claire_expression . _) are in oracle's map. She might
trust the oracle to verify signatures, but oracle doesn't understand token
semantics. Thus she needs to check if these entries were added.
If I understand correctly, Alice_expression->(Bob_expression . _) record
can be communicated in just 3 * size_of_hash_digest bytes.

So this seems to have rather bad scalability even with trusted oracles, am
I missing something?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/2ebbc3c3/attachment-0001.html>

From erik at q32.com  Thu Jun 23 13:03:36 2016
From: erik at q32.com (Erik Aronesty)
Date: Thu, 23 Jun 2016 09:03:36 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160623105632.GB19241@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
Message-ID: <CAJowKgJ8YQ9V891phx1qzJvFD3iWyPVU5iZ1w2LryALWAK5aHQ@mail.gmail.com>

AML/KYC is a *side-effect *of a some very important features of BIP0075.

Features that have nothing to do with public names for wallet seeds,
and moniker *consistency *should be scrapped.

BIP 75 formalises what someone could do today with a bunch of PGP emails
back and forth.

I create a public key, and I exchange it via QR code with you.   From then
on, You can initiate invoice requests with me, knowing my moniker is the
same as it was the last time.   I publish this key to a server (via DNSSEC)
so anyone can obtain it.   Sounds exactly like PGP.

Identity in BIP 75 is merely "moniker consistency".  Nothing says that
identity has to be "real"... only publicly verifiably consistent and
accessible.  This consistency and the ability to have public names for both
merchants and users are the important features of BIP 075.

Other features linking monikers to real-world identity should be surgically
removed from the standard.

- Users need to be able to send Bitcoin to an address without MITM attacks
during the address exchange.

- Merchants need to be able to supply memorable names linked to internet
services, like web servers and email addresses.

- Merchants and users both need to be able to initiate transaction
off-chain, with a workflow that allows things like rejection, subscription,
etc.



On Thu, Jun 23, 2016 at 6:56 AM, Peter Todd <pete at petertodd.org> wrote:

> On Tue, Jun 21, 2016 at 05:14:31PM -0700, Justin Newton wrote:
> > On Tue, Jun 21, 2016 at 3:13 PM, Peter Todd via bitcoin-dev <
> > Hi Peter,
> >    Certainly AML/KYC compliance is one of the use cases that BIP 75 and
> our
> > certificates can support.  As a quick summary,
> >
> > There are individuals and entities that would like to buy, sell, and use
> > bitcoin, and other public blockchains, but that have compliance
> > requirements that they need to meet before they can do so.  Similarly,
> > companies and entrepreneurs in the space suffer under the potential
> threat
> > of fines, or in extreme cases, jail time, also for not meeting AML or
> > sanctions list compliance.  We wanted to build tools that allowed
> > entrepreneurs to breathe easy, while at the same time allow more people
> and
> > companies to enter the ecosystem.  We also believe that the solution we
> are
> > using has the characteristics that you want in such a solution, for
> example:
> >
> > 1> Only the counterparties (and possibly their service providers in the
> > case of hosted services) in a transaction can see the identity data,
> > protecting user privacy.
> >
> > 2> The counterparties themselves (and possibly their service providers in
> > the case of hosted services) decide whether identity information is
> > required for any given transaction.
> >
> > 3> No trace is left on the blockchain or anywhere else (other than with
> the
> > counterparties) that identity information was even exchanged, protecting
> > fungibility
> >
> > 4> The solution is based on open source and open standards, allowing open
> > permissionless innovation, versus parties building closed networks based
> on
> > closed standards.  The very fact that this solution went through the BIP
> > process and was adapted based on feedback is an example of how this is
> > better for users than the inevitable closed solution that would arise if
> > the open source, community vetted version didn?t already exist.
> >
> > I don?t know if you are opposed to organizations that have AML
> requirements
> > from using the bitcoin blockchain, but if you aren?t, why wouldn?t you
> > prefer an open source, open standards based solution to exclusionary,
> > proprietary ones?
>
> In some (most?) countries, it is illegal to offer telecoms services without
> wiretap facilities. Does that mean Tor builds into its software "open
> source"
> "open standards" wiretapping functionality? No. And interestingly, people
> trying to add support for that stuff is actually a thing that keeps
> happening
> in the Tor community...
>
> In any case, I'd strongly argue that we remove BIP75 from the bips
> repository,
> and boycott wallets that implement it. It's bad strategy for Bitcoin
> developers
> to willingly participate in AML/KYC, just the same way as it's bad for Tor
> to
> add wiretapping functionality, and W3C to support DRM tech. The minor
> tactical
> wins you'll get our of this aren't worth it.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/07cec89c/attachment.html>

From voisine at gmail.com  Thu Jun 23 16:58:58 2016
From: voisine at gmail.com (Aaron Voisine)
Date: Thu, 23 Jun 2016 09:58:58 -0700
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160623105632.GB19241@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
Message-ID: <CACq0ZD6-gjjahdrpqk4UVHn+oOZw3dgFnV5opKLSimwpw7Mxtg@mail.gmail.com>

On Thu, Jun 23, 2016 at 3:56 AM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> In any case, I'd strongly argue that we remove BIP75 from the bips
> repository,
> and boycott wallets that implement it. It's bad strategy for Bitcoin
> developers
> to willingly participate in AML/KYC, just the same way as it's bad for Tor
> to
> add wiretapping functionality, and W3C to support DRM tech. The minor
> tactical
> wins you'll get our of this aren't worth it.
>
>
Peter, BIP75 gives the parties transacting complete control over who they
choose to share their identity information with. This was the entire point
of the proposal. You authorize who you choose to give your payment address
to, and the sender can verify who they are sending payment to. All
communication and payment info are encrypted against third party snooping,
while still allowing asynchronous communication to accommodate ephemeral
mobile connections.

The fact that some people will choose to use this identity information for
AML/KYC purposes doesn't detract at all from the fact that it gives bitcoin
users the tools they need to keep their payment information private, and
only communicate it with the parties they choose.

Aaron Voisine
co-founder and CEO
breadwallet <http://breadwallet.com/>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/a4f599d1/attachment.html>

From s7r at sky-ip.org  Thu Jun 23 20:46:46 2016
From: s7r at sky-ip.org (s7r)
Date: Thu, 23 Jun 2016 23:46:46 +0300
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <20160623105632.GB19241@fedora-21-dvm>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
Message-ID: <ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>


On 6/23/2016 1:56 PM, Peter Todd via bitcoin-dev wrote:
>>
>> I don?t know if you are opposed to organizations that have AML requirements
>> from using the bitcoin blockchain, but if you aren?t, why wouldn?t you
>> prefer an open source, open standards based solution to exclusionary,
>> proprietary ones?
> 
> In some (most?) countries, it is illegal to offer telecoms services without
> wiretap facilities. Does that mean Tor builds into its software "open source"
> "open standards" wiretapping functionality? No. And interestingly, people
> trying to add support for that stuff is actually a thing that keeps happening
> in the Tor community...
> 
> In any case, I'd strongly argue that we remove BIP75 from the bips repository,
> and boycott wallets that implement it. It's bad strategy for Bitcoin developers
> to willingly participate in AML/KYC, just the same way as it's bad for Tor to
> add wiretapping functionality, and W3C to support DRM tech. The minor tactical
> wins you'll get our of this aren't worth it.
> 
Exactly!
Totally agree with Peter Todd. There's absolutely no gain for Bitcoin to
willingly participate in AML/KYC. Plus this might come with strings
attached: for example when running a Tor relay in some countries if you
interfere with the traffic (censor, limit, filter, etc.) you become
responsible for it, while when you only relay anonymous traffic without
interfering or having the possibility to do so (installing certain
tools, using a modified Tor which allows you to do so, etc.) you cannot
be held responsible for the traffic.

Any kind of built-in AML/KYC tools in Bitcoin is bad, and might draw
expectations from _all_ users from authorities. Companies or individuals
who want and/or need AML/KYC can find ways and do it at their side
isolated from the entire network, and the solutions shouldn't come from
upstream. AML/KYC/<insert other regulation here> differ from country to
country and will be hard to implement in a global consensus network even
if it would be worth it.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/3541af5b/attachment.sig>

From justin at netki.com  Thu Jun 23 21:07:06 2016
From: justin at netki.com (Justin Newton)
Date: Thu, 23 Jun 2016 14:07:06 -0700
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>
Message-ID: <CABqynx+KGxD3ZwAAcD9VBcO8U13LKC=5kfOhsX32MxdM_hnHxA@mail.gmail.com>

On Thu, Jun 23, 2016 at 1:46 PM, s7r via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
>
>
> Any kind of built-in AML/KYC tools in Bitcoin is bad, and might draw
> expectations from _all_ users from authorities. Companies or individuals
> who want and/or need AML/KYC can find ways and do it at their side
> isolated from the entire network, and the solutions shouldn't come from
> upstream. AML/KYC/<insert other regulation here> differ from country to
> country and will be hard to implement in a global consensus network even
> if it would be worth it.
>
>
This was precisely our thinking as well.

This is actually exactly why BIP 75 was designed the way that it was.  Any
(voluntary) identity exchange is done at the application level, on an
encrypted https (or other) connection between the sender and receiver.
Identity data is not passed through or stored on the blockchain, and there
is actually no mark left on the blockchain that identity was even exchanged
on that transaction.

The only people who know identity info was exchanged, or what the identity
was is the counterparties in the transaction, and depending on
implementation, their service provider.  (At a high level, many software
based wallet providers wouldn?t have any visibility into identity info,
where many hosted services would, for example)

We did this to protect user privacy as well as fungibility.

We are allowing the people who want or need to exchange identtity info
(either self signed or 3rd party validated) the option to exchange it, in a
standards based way, directly between peers, without touching the
blockchain or network itself.

Is this more clear?

-- 

Justin W. Newton
Founder/CEO
Netki, Inc.

justin at netki.com
+1.818.261.4248
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/30ac6899/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PastedGraphic-1.tiff
Type: image/tiff
Size: 10972 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/30ac6899/attachment-0001.tiff>

From PoliceTerror at dyne.org  Thu Jun 23 21:31:29 2016
From: PoliceTerror at dyne.org (Police Terror)
Date: Thu, 23 Jun 2016 21:31:29 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CABqynx+KGxD3ZwAAcD9VBcO8U13LKC=5kfOhsX32MxdM_hnHxA@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>
	<CABqynx+KGxD3ZwAAcD9VBcO8U13LKC=5kfOhsX32MxdM_hnHxA@mail.gmail.com>
Message-ID: <576C5531.90608@dyne.org>

In England under RIPA 2000 legislation, it's irrelevant whether you have
the data or not. If the authorities compel you to hand over that
information, and it is within your means to obtain it then you are
obliged to do so under threat of criminal offense.

So any mechanism whereby data could be collected from Bitcoin users,
whether it's stored ephemerally or not, if the police have reasonable
suspicion to think it exists then they can compel all parties to work to
get them the data they require.

If the mechanism flat out does not exist, that is miles better than
could exist. Deniability is not a defense when served with a police
notice for disclosing data.

You have to think not only about the end result, but also about how
these mechanisms can be used for intimidating users or leveraging
technologies.

Justin Newton via bitcoin-dev:
> On Thu, Jun 23, 2016 at 1:46 PM, s7r via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>>
>>
>>
>> Any kind of built-in AML/KYC tools in Bitcoin is bad, and might draw
>> expectations from _all_ users from authorities. Companies or individuals
>> who want and/or need AML/KYC can find ways and do it at their side
>> isolated from the entire network, and the solutions shouldn't come from
>> upstream. AML/KYC/<insert other regulation here> differ from country to
>> country and will be hard to implement in a global consensus network even
>> if it would be worth it.
>>
>>
> This was precisely our thinking as well.
> 
> This is actually exactly why BIP 75 was designed the way that it was.  Any
> (voluntary) identity exchange is done at the application level, on an
> encrypted https (or other) connection between the sender and receiver.
> Identity data is not passed through or stored on the blockchain, and there
> is actually no mark left on the blockchain that identity was even exchanged
> on that transaction.
> 
> The only people who know identity info was exchanged, or what the identity
> was is the counterparties in the transaction, and depending on
> implementation, their service provider.  (At a high level, many software
> based wallet providers wouldn?t have any visibility into identity info,
> where many hosted services would, for example)
> 
> We did this to protect user privacy as well as fungibility.
> 
> We are allowing the people who want or need to exchange identtity info
> (either self signed or 3rd party validated) the option to exchange it, in a
> standards based way, directly between peers, without touching the
> blockchain or network itself.
> 
> Is this more clear?
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From justin at netki.com  Thu Jun 23 22:44:34 2016
From: justin at netki.com (Justin Newton)
Date: Thu, 23 Jun 2016 15:44:34 -0700
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <576C5531.90608@dyne.org>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>
	<CABqynx+KGxD3ZwAAcD9VBcO8U13LKC=5kfOhsX32MxdM_hnHxA@mail.gmail.com>
	<576C5531.90608@dyne.org>
Message-ID: <CABqynxKmqrUhFsGFp0N6yGpHcbE5NgxdKCPWvTAXTkXhHs6z_w@mail.gmail.com>

Hi there,
   For users who don?t wish a service provider to be able to see their
information, even ephemerally, and they would like to exchange information
via BIP75, they can use a software wallet, such as a breadwallet or others,
and that data will only exist on their phone, and the phone of their
counterparty (assuming the counterparty also chose to exchange info, and
was running on a software wallet).

In this way, we allow users to exchange data as they choose, without having
the risk that a service provider be asked for that data.

If a user chooses to use a hosted platform, and also to store their
identity data there, I do agree it could be subject to a subpoena, the same
as when they host their email, and other services.

Finally, they could choose not to use BIP75 at all, and no one would know
whether they did or didn?t (other than their counterparts) as we don?t
leave any residue on the blockchain, or anywhere else in the public eye.

We believe that this solution, due in part to its narrow data aperture, is
the best solution available to the problem we are solving.  We are eager to
engage in any discussions about how to improve the proposed solution, with
an eye to fungibility, privacy, and usability.

That said, there is a real need for people to know who they are transacting
with for usability reasons, for fraud reduction, and also of regulatory
reasons for some players.  To NOT solve it with a carefully crafted
standard means that it is more likely to be solved with back room, quick
and dirty solutions that are not available for community review and
feedback.

Thanks!

Justin






On Thu, Jun 23, 2016 at 2:31 PM, Police Terror via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> In England under RIPA 2000 legislation, it's irrelevant whether you have
> the data or not. If the authorities compel you to hand over that
> information, and it is within your means to obtain it then you are
> obliged to do so under threat of criminal offense.
>
> So any mechanism whereby data could be collected from Bitcoin users,
> whether it's stored ephemerally or not, if the police have reasonable
> suspicion to think it exists then they can compel all parties to work to
> get them the data they require.
>
> If the mechanism flat out does not exist, that is miles better than
> could exist. Deniability is not a defense when served with a police
> notice for disclosing data.
>
> You have to think not only about the end result, but also about how
> these mechanisms can be used for intimidating users or leveraging
> technologies.
>
> Justin Newton via bitcoin-dev:
> > On Thu, Jun 23, 2016 at 1:46 PM, s7r via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >>
> >>
> >>
> >> Any kind of built-in AML/KYC tools in Bitcoin is bad, and might draw
> >> expectations from _all_ users from authorities. Companies or individuals
> >> who want and/or need AML/KYC can find ways and do it at their side
> >> isolated from the entire network, and the solutions shouldn't come from
> >> upstream. AML/KYC/<insert other regulation here> differ from country to
> >> country and will be hard to implement in a global consensus network even
> >> if it would be worth it.
> >>
> >>
> > This was precisely our thinking as well.
> >
> > This is actually exactly why BIP 75 was designed the way that it was.
> Any
> > (voluntary) identity exchange is done at the application level, on an
> > encrypted https (or other) connection between the sender and receiver.
> > Identity data is not passed through or stored on the blockchain, and
> there
> > is actually no mark left on the blockchain that identity was even
> exchanged
> > on that transaction.
> >
> > The only people who know identity info was exchanged, or what the
> identity
> > was is the counterparties in the transaction, and depending on
> > implementation, their service provider.  (At a high level, many software
> > based wallet providers wouldn?t have any visibility into identity info,
> > where many hosted services would, for example)
> >
> > We did this to protect user privacy as well as fungibility.
> >
> > We are allowing the people who want or need to exchange identtity info
> > (either self signed or 3rd party validated) the option to exchange it,
> in a
> > standards based way, directly between peers, without touching the
> > blockchain or network itself.
> >
> > Is this more clear?
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 

Justin W. Newton
Founder/CEO
Netki, Inc.

justin at netki.com
+1.818.261.4248
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/cc872bf8/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PastedGraphic-1.tiff
Type: image/tiff
Size: 10972 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/cc872bf8/attachment-0001.tiff>

From erik at q32.com  Fri Jun 24 02:26:52 2016
From: erik at q32.com (Erik Aronesty)
Date: Thu, 23 Jun 2016 22:26:52 -0400
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CABqynxKmqrUhFsGFp0N6yGpHcbE5NgxdKCPWvTAXTkXhHs6z_w@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>
	<CABqynx+KGxD3ZwAAcD9VBcO8U13LKC=5kfOhsX32MxdM_hnHxA@mail.gmail.com>
	<576C5531.90608@dyne.org>
	<CABqynxKmqrUhFsGFp0N6yGpHcbE5NgxdKCPWvTAXTkXhHs6z_w@mail.gmail.com>
Message-ID: <CAJowKgLj=_dK0tcORJk=a-0zwswSF5Cnkgdj--s4Uze-x1m=bA@mail.gmail.com>

Sometimes I think there's concerted resistance to making Bitcoin usable for
the average person.   Clearly the primary purpose of BIP0075 is to enshrine
a DNSSEC protocol for giving wallet addresses memorable names.


On Thu, Jun 23, 2016 at 6:44 PM, Justin Newton via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi there,
>    For users who don?t wish a service provider to be able to see their
> information, even ephemerally, and they would like to exchange information
> via BIP75, they can use a software wallet, such as a breadwallet or others,
> and that data will only exist on their phone, and the phone of their
> counterparty (assuming the counterparty also chose to exchange info, and
> was running on a software wallet).
>
> In this way, we allow users to exchange data as they choose, without
> having the risk that a service provider be asked for that data.
>
> If a user chooses to use a hosted platform, and also to store their
> identity data there, I do agree it could be subject to a subpoena, the same
> as when they host their email, and other services.
>
> Finally, they could choose not to use BIP75 at all, and no one would know
> whether they did or didn?t (other than their counterparts) as we don?t
> leave any residue on the blockchain, or anywhere else in the public eye.
>
> We believe that this solution, due in part to its narrow data aperture, is
> the best solution available to the problem we are solving.  We are eager to
> engage in any discussions about how to improve the proposed solution, with
> an eye to fungibility, privacy, and usability.
>
> That said, there is a real need for people to know who they are
> transacting with for usability reasons, for fraud reduction, and also of
> regulatory reasons for some players.  To NOT solve it with a carefully
> crafted standard means that it is more likely to be solved with back room,
> quick and dirty solutions that are not available for community review and
> feedback.
>
> Thanks!
>
> Justin
>
>
>
>
>
>
> On Thu, Jun 23, 2016 at 2:31 PM, Police Terror via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> In England under RIPA 2000 legislation, it's irrelevant whether you have
>> the data or not. If the authorities compel you to hand over that
>> information, and it is within your means to obtain it then you are
>> obliged to do so under threat of criminal offense.
>>
>> So any mechanism whereby data could be collected from Bitcoin users,
>> whether it's stored ephemerally or not, if the police have reasonable
>> suspicion to think it exists then they can compel all parties to work to
>> get them the data they require.
>>
>> If the mechanism flat out does not exist, that is miles better than
>> could exist. Deniability is not a defense when served with a police
>> notice for disclosing data.
>>
>> You have to think not only about the end result, but also about how
>> these mechanisms can be used for intimidating users or leveraging
>> technologies.
>>
>> Justin Newton via bitcoin-dev:
>> > On Thu, Jun 23, 2016 at 1:46 PM, s7r via bitcoin-dev <
>> > bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >
>> >>
>> >>
>> >>
>> >> Any kind of built-in AML/KYC tools in Bitcoin is bad, and might draw
>> >> expectations from _all_ users from authorities. Companies or
>> individuals
>> >> who want and/or need AML/KYC can find ways and do it at their side
>> >> isolated from the entire network, and the solutions shouldn't come from
>> >> upstream. AML/KYC/<insert other regulation here> differ from country to
>> >> country and will be hard to implement in a global consensus network
>> even
>> >> if it would be worth it.
>> >>
>> >>
>> > This was precisely our thinking as well.
>> >
>> > This is actually exactly why BIP 75 was designed the way that it was.
>> Any
>> > (voluntary) identity exchange is done at the application level, on an
>> > encrypted https (or other) connection between the sender and receiver.
>> > Identity data is not passed through or stored on the blockchain, and
>> there
>> > is actually no mark left on the blockchain that identity was even
>> exchanged
>> > on that transaction.
>> >
>> > The only people who know identity info was exchanged, or what the
>> identity
>> > was is the counterparties in the transaction, and depending on
>> > implementation, their service provider.  (At a high level, many software
>> > based wallet providers wouldn?t have any visibility into identity info,
>> > where many hosted services would, for example)
>> >
>> > We did this to protect user privacy as well as fungibility.
>> >
>> > We are allowing the people who want or need to exchange identtity info
>> > (either self signed or 3rd party validated) the option to exchange it,
>> in a
>> > standards based way, directly between peers, without touching the
>> > blockchain or network itself.
>> >
>> > Is this more clear?
>> >
>> >
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
>
>
> --
>
> Justin W. Newton
> Founder/CEO
> Netki, Inc.
>
> justin at netki.com
> +1.818.261.4248
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/f11d74c6/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PastedGraphic-1.tiff
Type: image/tiff
Size: 10972 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160623/f11d74c6/attachment-0001.tiff>

From macwhyte at gmail.com  Fri Jun 24 05:27:36 2016
From: macwhyte at gmail.com (James MacWhyte)
Date: Fri, 24 Jun 2016 05:27:36 +0000
Subject: [bitcoin-dev] Even more proposed BIP extensions to BIP 0070
In-Reply-To: <CAJowKgLj=_dK0tcORJk=a-0zwswSF5Cnkgdj--s4Uze-x1m=bA@mail.gmail.com>
References: <CAJowKg+zYtUnHv+ea--srehVa5K46sjpWbHVcVGRY5x0w5XRTQ@mail.gmail.com>
	<20160621221347.GC10196@fedora-21-dvm>
	<CABqynxJCiXL0djx+xt9i=HJqC=0=5sZ9ecL7k1_a_XHiJ8qibw@mail.gmail.com>
	<20160623105632.GB19241@fedora-21-dvm>
	<ebfa5034-827d-00a6-c285-dab30aa3e9c8@sky-ip.org>
	<CABqynx+KGxD3ZwAAcD9VBcO8U13LKC=5kfOhsX32MxdM_hnHxA@mail.gmail.com>
	<576C5531.90608@dyne.org>
	<CABqynxKmqrUhFsGFp0N6yGpHcbE5NgxdKCPWvTAXTkXhHs6z_w@mail.gmail.com>
	<CAJowKgLj=_dK0tcORJk=a-0zwswSF5Cnkgdj--s4Uze-x1m=bA@mail.gmail.com>
Message-ID: <CAH+Axy7dCS_fEqQ9xAOD6WFUpnxS=mC5QQmaTgs3kAS8bw9sTA@mail.gmail.com>

> Clearly the primary purpose of BIP0075 is to enshrine a DNSSEC protocol
> for giving wallet addresses memorable names.
>
>
I can't tell if you're being sarcastic or not, but if you aren't, I don't
think this is an accurate description at all. BIP75 is, at its most
simplest, nothing more than an encrypted/encapsulated version of BIP70. All
we did was make it safe for people to exchange BIP70 messages through an
intermediary.

The only identity information included in BIP75 is the pki_data field,
which wasn't even introduced in BIP75--it was already in BIP70. I'm
guessing Peter would also have us remove BIP70 altogether?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160624/4fda853a/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: PastedGraphic-1.tiff
Type: image/tiff
Size: 10972 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160624/4fda853a/attachment.tiff>

From pete at petertodd.org  Fri Jun 24 22:23:16 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 24 Jun 2016 18:23:16 -0400
Subject: [bitcoin-dev] Building Blocks of the State Machine Approach to
 Consensus
In-Reply-To: <CAE28kUQXLc=-8SoEsWNXz99hezMBmM0ws+Xx3+nrp4YPZkMaPQ@mail.gmail.com>
References: <20160620085649.GA29964@fedora-21-dvm>
	<CAE28kUTkBmhLm-7rNVtX7Dm2yYABQiepZX0RCYpBn60Uo9=ehA@mail.gmail.com>
	<20160623111152.GB19360@fedora-21-dvm>
	<CAE28kUQXLc=-8SoEsWNXz99hezMBmM0ws+Xx3+nrp4YPZkMaPQ@mail.gmail.com>
Message-ID: <20160624222316.GA28767@fedora-21-dvm>

On Thu, Jun 23, 2016 at 03:58:29PM +0300, Alex Mizrahi wrote:
> >
> > The point I'm making is simply that to be useful, when you close a seal you
> > have to be able to close it over some data, in particular, another seal.
> > That's
> > the key thing that makes the idea a useful construct for smart contacts,
> > value
> > transfer/currency systems, etc.
> >
> 
> OK, your second post ("Closed Seal Sets and Truth Lists for Better Privacy
> and Censorship Resistance") seems to clarify that this data is one of
> arguments to the condition function.
> Frankly this stuff is rather hard to follow. (Or maybe I'm dumb.)
> 
> Now I don't get scability properties. Let's consider a simplest scenario
> where Alice creates some token, sends it to Bob, who sends it to Claire. So
> now Claire needs to get both a proof that Alice sent it to Bob and that Bob
> sent it to Claire, right? So Claire needs to verify 2 proofs, and for a
> chain of N transfers one would need to verify N proofs, right?

Not necessarily. In my writeup I outlined two ways that those chains can be
shortened: trusted validity oracles and the probabalistic, inflationary,
history proof concept.

Equally, even if history grows over time, that's no worse than Bitcoin.

> And how it works in general:
> 
> 1. Alice creates a token. To do that she constructs an unique expression
> which checks her signature and signs a message "This token has such and
> such meaning and its ownership originally associated with seal <hash of the
> expression>" with her PGP key.

Alice isn't _creating_ a tokne, she's _defining_ a token.

> 2. To transfer this token to Bob, she asks Bob for his auth expression and
> sends a seal oracle a message (Alice_expression (Bob_expression .
> signature)) where signatures is constructed in such a way that it evaluates
> as true. Oracle stores this in a map: Alice_expression -> (Bob_expression .
> signatures)

Nope.

In Alice's token definition, the genesis state of the token is defined to be
associated with a specific single-use seal. To transfer the token to Bob, she
asks Bob for the seal he wishes to use, and then closes the genesis seal over a
new state committing to Bob's seal.

Now Alice could construct the seal for Bob, in which case she'd just need to
know the auth expression Bob wants to use, but that's not the most fundamental
way of implementing this.

Regardless, the seal oracle doesn't need to know that any of the above is
happening; all it needs to do is spit out seal closed witnesses when the
authorization expressions are satisfied appropriately; the oracle does not and
should not know what the seals have been closed over. Whether or not the oracle
stores anything when seals are closed is an implementation decision - see my
original writeup on the unbounded vs. bounded oracle case. And of course, seals
implemented with decentralized blockchains are a different matter entirely.

> 3. Bob sends token to Claire in a same way: (Bob_expression
> (Claire_expression . signature))
> 4. Now Claire asks if Alice_expression->(Bob_expression . _) and
> Bob_expression->(Claire_expression . _) are in oracle's map. She might
> trust the oracle to verify signatures, but oracle doesn't understand token
> semantics. Thus she needs to check if these entries were added.
> If I understand correctly, Alice_expression->(Bob_expression . _) record
> can be communicated in just 3 * size_of_hash_digest bytes.
> 
> So this seems to have rather bad scalability even with trusted oracles, am
> I missing something?

Yes, as I mentioned above, there exists multiple techniques that can shorten
history proofs in a variety of ways, depending on what kinds of tradeoffs your
application needs.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160624/f1a28cc1/attachment.sig>

From erik at q32.com  Sun Jun 26 12:12:11 2016
From: erik at q32.com (Erik Aronesty)
Date: Sun, 26 Jun 2016 08:12:11 -0400
Subject: [bitcoin-dev] parallel token idea & question
Message-ID: <CAJowKgJKQ+4MU1pUE6s7kJL2+r2rLfJC0V1X96CK=Z5FvV8p9A@mail.gmail.com>

token miners who will work to the a new token signal readiness to secure
that token by posting a public key to the bitcoin blockchain along with a
collateral and possibly a block mined from a side chain, or some other
signal proving sufficient participation (allows for non-blockchain tokens).

coin moved to the new token set is sent to a multisig wallet consisting of
miners who have signaled readiness, with nlocktime set to some time in the
future

coin sits in that wallet - the new token doesn't even have to be a chain,
it could be a DAG, or some other mechanism - following whatever rules it
pleases

any time, miner of the new system can move coin back to the main chain...
trivially and following whatever rules are need.  also, any time a miner
fails to follow the rules of the new system, they lose their collateral

any sufficient consortium of miners/participants in the side chain can, of
course, steal that coin...but that is true for all sidechains - and to some
extent bitcoin - anyway

does this seem too simplistic or weak in some way?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160626/bf2a17d5/attachment.html>

From rusty at rustcorp.com.au  Tue Jun 28 02:31:34 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 28 Jun 2016 12:01:34 +0930
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
Message-ID: <87h9cecad5.fsf@rustcorp.com.au>


To quote:

> HMAC_SHA512(key=ecdh_secret|cipher-type,msg="encryption key").
> 
>  K_1 must be the left 32bytes of the HMAC_SHA512 hash.
>  K_2 must be the right 32bytes of the HMAC_SHA512 hash.

This seems a weak reason to introduce SHA512 to the mix.  Can we just
make:

K_1 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="header encryption key")
K_2 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="body encryption key")

Thanks,
Rusty.

From eric at voskuil.org  Tue Jun 28 07:17:31 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 09:17:31 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <87h9cecad5.fsf@rustcorp.com.au>
References: <87h9cecad5.fsf@rustcorp.com.au>
Message-ID: <1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

I haven't seen much discussion here on the rationale behind BIP 151. Apologies if I missed it. I'm trying to understand why libbitcoin (or any node) would want to support it.

I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features are client-server in nature. Libbitcoin (for example) supports client-server features on an independent port (and implements a variant of CurveCP for encryption and identity). My concern arises with application of identity to the P2P protocol (excluding Bloom filter features).

It seems to me that the desire to secure against the weaknesses of BF is being casually generalized to the P2P network. That generalization may actually weaken the security of the P2P protocol. One might consider the proper resolution is to move the BF features to a client-server protocol.

The BIP does not make a case for other scenarios, or contemplate the significant problems associated with key distribution in any identity system. Given that the BIP relies on identity, these considerations should be fully vetted before heading down another blind alley.

e
-----BEGIN PGP SIGNATURE-----
Version: oPenGP 6.0 on iOS

iQEVAwUBV3IkYjzYwH8LXOFOAQg+iggAkFShi/ibZXiVv3A3z1a1SMd+4ar0kiZk
mCkBBZaatoW8tXVZmuv5xzLnj3ali9Y4jp/3h2nUJ1B4ov2kcB0kZIKE/a1DTFwb
4X3uSzgu0lEAqSZormOvt7Op46NPn6KJ+/wTtP4lUFU72lSd7qrVKMlCVc88VE7/
pMloKSc69nAeFIkyWbOUi/zDzefu/5tarfif85jumooYjPmAwJnkgiPCqpqBbuga
5lBdS1r47KK+SaDFl6Cbn4i/c6tBPLTnu+TR7TEKOW5vwVA7eUqb6SOK7pETWJGK
0Ii4ZWYt7MOPSEda381CMjWEwtsCNp0eI4GPZAAz+jNLo4G1+PAbaw==
=Balw
-----END PGP SIGNATURE-----


From dev at jonasschnelli.ch  Tue Jun 28 07:19:04 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 28 Jun 2016 09:19:04 +0200
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <87h9cecad5.fsf@rustcorp.com.au>
References: <87h9cecad5.fsf@rustcorp.com.au>
Message-ID: <577224E8.6070307@jonasschnelli.ch>

> To quote:
> 
>> HMAC_SHA512(key=ecdh_secret|cipher-type,msg="encryption key").
>>
>>  K_1 must be the left 32bytes of the HMAC_SHA512 hash.
>>  K_2 must be the right 32bytes of the HMAC_SHA512 hash.
> 
> This seems a weak reason to introduce SHA512 to the mix.  Can we just
> make:
> 
> K_1 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="header encryption key")
> K_2 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="body encryption key")

SHA512_HMAC is used by BIP32 [1] and I guess most clients will somehow
make use of bip32 features. I though a single SHA512_HMAC operation is
cheaper and simpler then two SHA256_HMAC.

AFAIK, sha256_hmac is also not used by the current p2p & consensus layer.
Bitcoin-Core uses it for HTTP RPC auth and Tor control.

I don't see big pros/cons for SHA512_HMAC over SHA256_HMAC.

</jonas>

[1]
https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/bbe12795/attachment.sig>

From dev at jonasschnelli.ch  Tue Jun 28 08:26:12 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 28 Jun 2016 10:26:12 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
Message-ID: <577234A4.3030808@jonasschnelli.ch>

Hi Eric

> I haven't seen much discussion here on the rationale behind BIP 151. Apologies if I missed it. I'm trying to understand why libbitcoin (or any node) would want to support it.
> 
> I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features are client-server in nature. Libbitcoin (for example) supports client-server features on an independent port (and implements a variant of CurveCP for encryption and identity). My concern arises with application of identity to the P2P protocol (excluding Bloom filter features).
> 
> It seems to me that the desire to secure against the weaknesses of BF is being casually generalized to the P2P network. That generalization may actually weaken the security of the P2P protocol. One might consider the proper resolution is to move the BF features to a client-server protocol.
> 
> The BIP does not make a case for other scenarios, or contemplate the significant problems associated with key distribution in any identity system. Given that the BIP relies on identity, these considerations should be fully vetted before heading down another blind alley.


In my opinion, the question should be "why would you _not_ encrypt".


1) Transaction censorship
ISPs, WIFI provider or any other MITM, can holdback/censor unconfirmed
transactions. Regardless if you are a miner or a validation/wallet node.

2) Peer censorship
MITM can remove or add entries from a "addr" message.

3) Fingerprinting
ISPs or any other MITM can intercept/inject fingerprinting relevant
messages like "mempool" to analyze the bitcoin network.

4) SPV
For obvious reasons regarding BF (see BIP or above).

5) Goundwork for a "client-server" model over the P2P channel
Fee estimation, bloom-filters, or any other message type that requires
authentication.

I would not reduce BIP151 to only solve the BF privacy/censorship problem.

If we agree that censorship-resistance is one of the main properties of
Bitcoin, then we should definitively use a form of end-to-end encryption
between nodes. Built into the network layer.

There are plenty of other options to solve this problem. stunnel,
Bernsteins CurveCP, VPN, etc. which are available since years.
But the reality has shown that most bitcoin traffic is still unencrypted.
Example: IIRC non of the available SPV wallets can "speak" on of the
possible encryption techniques. Encrypting traffic below the application
layer is extremely hard to set up for non-experienced users.

On top of that, encryption allows us to drop the SHA256 checksum per p2p
message which should result in a better performance on the network layer
once BIP151 is deployed.

I agree that BIP151 _must_ be deployed together with an authentication
scheme (I'm working on that) to protect again MITM during encryption
initialization.

---
</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/4b67008b/attachment.sig>

From arthur.chen at btcc.com  Tue Jun 28 08:31:51 2016
From: arthur.chen at btcc.com (Arthur Chen)
Date: Tue, 28 Jun 2016 16:31:51 +0800
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <577224E8.6070307@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
Message-ID: <CAP+0UNKqDknS-w6QyCJ0_ra71YfsDDtSdSBYoguUicW2oNMLvQ@mail.gmail.com>

Based on previous crypto analysis result, the actual security of SHA512 is
not significantly higher than SHA256.
maybe we should consider SHA3?


On Tue, Jun 28, 2016 at 3:19 PM, Jonas Schnelli via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> > To quote:
> >
> >> HMAC_SHA512(key=ecdh_secret|cipher-type,msg="encryption key").
> >>
> >>  K_1 must be the left 32bytes of the HMAC_SHA512 hash.
> >>  K_2 must be the right 32bytes of the HMAC_SHA512 hash.
> >
> > This seems a weak reason to introduce SHA512 to the mix.  Can we just
> > make:
> >
> > K_1 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="header encryption
> key")
> > K_2 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="body encryption key")
>
> SHA512_HMAC is used by BIP32 [1] and I guess most clients will somehow
> make use of bip32 features. I though a single SHA512_HMAC operation is
> cheaper and simpler then two SHA256_HMAC.
>
> AFAIK, sha256_hmac is also not used by the current p2p & consensus layer.
> Bitcoin-Core uses it for HTTP RPC auth and Tor control.
>
> I don't see big pros/cons for SHA512_HMAC over SHA256_HMAC.
>
> </jonas>
>
> [1]
>
> https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Xuesong (Arthur) Chen
Senior Principle Engineer
BlockChain Technologist
BTCC
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/01c60739/attachment.html>

From dev at jonasschnelli.ch  Tue Jun 28 12:13:27 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 28 Jun 2016 14:13:27 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
Message-ID: <577269E7.6020008@jonasschnelli.ch>

Hi Eric

Sorry for not directly addressing your points.
I try to be more precise in this follow up email:

> I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features are client-server in nature. Libbitcoin (for example) supports client-server features on an independent port (and implements a variant of CurveCP for encryption and identity). My concern arises with application of identity to the P2P protocol (excluding Bloom filter features).

I think the bloom filter SPV usecase is not "pure client-server". SPV
clients could request from/broadcast to multiple "trusted nodes".
Trusted nodes could be nodes where the operators have shared
identities/keys in advance over a different channel.

Further private p2p extensions (lets say a p2p form of the estimatefee
command) are something which needs to be discussed first and not
something that is encouraged or outlined in BIP151.

> It seems to me that the desire to secure against the weaknesses of BF is being casually generalized to the P2P network. That generalization may actually weaken the security of the P2P protocol. One might consider the proper resolution is to move the BF features to a client-server protocol.

I don't see reasons why BIP151 could weaken the security of the P2P
network. Can you point out some specific concerns?


> The BIP does not make a case for other scenarios, or contemplate the significant problems associated with key distribution in any identity system. Given that the BIP relies on identity, these considerations should be fully vetted before heading down another blind alley.

BIP151 does not rely on identities. BIP151 does not use persisted keys
(only ephemeral keys). The authentication/identity system needs to be
described in a another BIP.
But correct, BIP151 without a form of authentication/identity management
is vulnerable to all sorts of MITM attacks and that's why I think BIP151
must be deployed together with an p2p authentication scheme.

Scope creeping and the risks of overspecifying is the main reason to
focus on the "pure encryption part" in BIP151.

Thanks
---
</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/404f4808/attachment.sig>

From jl2012 at xbt.hk  Tue Jun 28 16:22:45 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Wed, 29 Jun 2016 00:22:45 +0800
Subject: [bitcoin-dev] Code Review: The Consensus Critical Parts of
	Segwit by Peter Todd
Message-ID: <8AE6D76F-7808-4897-9F44-A83790545EE4@xbt.hk>

Thanks for Peter Todd?s detailed report:
https://petertodd.org/2016/segwit-consensus-critical-code-review

I have the following response.

>Since the reserve value is only a single, 32-byte value, we?re setting ourselves up for the same problem again7.

Please note that unlimited space has been reserved after the witness commitment:

  block.vtx[0].vout[o].scriptPubKey.size() >= 38

 Which means anything after 38 bytes has no consensus meaning. Any new consensus critical commitments/metadata could be put there. Anyway, there is no efficient way to add a new commitment with softfork.


> the fact that we do this has a rather odd result: a transaction spending a witness output with an unknown version is valid even if the transaction doesn?t have any witnesses!

I don?t see any reason to have such check. We simply leave unknown witness program as any-one-can-spend without looking at the witness, as described in BIP141.


> Bizzarely segwit has an additonal pay-to-witness-pubkey-hashP2WPKH that lets you use a 160-bit (20 byte) commitment??

Since ~90% of current transactions are P2PKH, we expect many people will keep using this type of transaction in the future. P2WPKH gives the same level of security as P2PKH, and smaller scriptPubKey.

>give users the option instead to choose to accept the less secure 160-bit commitment if their use-case doesn?t need the full 256-bit security level

This is actually discussed on the mailing list. P2WSH with multi-sig is subject to birthday attack, and therefore 256-bit is used to provide 128-bit security. P2WPKH is used as single sig and therefore 160-bit is enough.


>Secondly, if you are going to give a 160-bit commitment option, you don?t need the extra level of indirection in the P2SH case: just make the segwit redeemScript be: <version> <serialized witness script>

Something wrong here? In P2WPKH, the witness is <sig> <pubkey>


>The only downside is the serialized witness script is constrained to 520 bytes max

520 is the original limit. BIP141 tries to mimic the existing behaviour as much as possible. Anyway, normally nothing in the current scripts should use a push with more than 75 bytes


>we haven?t explicitly ensured that signatures for the new signature hash can?t be reused for the old signature hash

How could that be? That?d be a hash collision.





-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 671 bytes
Desc: Message signed with OpenPGP using GPGMail
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/cefe2cd2/attachment.sig>

From eric at voskuil.org  Tue Jun 28 16:45:58 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 18:45:58 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <577234A4.3030808@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
Message-ID: <360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>

Hi Jonas, I'll follow up in your second reply as well. Responses inline:

> On Jun 28, 2016, at 10:26 AM, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hi Eric
> 
>> I haven't seen much discussion here on the rationale behind BIP 151. Apologies if I missed it. I'm trying to understand why libbitcoin (or any node) would want to support it.
>> 
>> I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features are client-server in nature. Libbitcoin (for example) supports client-server features on an independent port (and implements a variant of CurveCP for encryption and identity). My concern arises with application of identity to the P2P protocol (excluding Bloom filter features).
>> 
>> It seems to me that the desire to secure against the weaknesses of BF is being casually generalized to the P2P network. That generalization may actually weaken the security of the P2P protocol. One might consider the proper resolution is to move the BF features to a client-server protocol.
>> 
>> The BIP does not make a case for other scenarios, or contemplate the significant problems associated with key distribution in any identity system. Given that the BIP relies on identity, these considerations should be fully vetted before heading down another blind alley.

> In my opinion, the question should be "why would you _not_ encrypt".

1) creation of a false sense of security
2) as a tradeoff against anonymity
3) benefit does not justify cost

> 1) Transaction censorship
> ISPs, WIFI provider or any other MITM, can holdback/censor unconfirmed
> transactions. Regardless if you are a miner or a validation/wallet node.
> 
> 2) Peer censorship
> MITM can remove or add entries from a "addr" message.
> 
> 3) Fingerprinting
> ISPs or any other MITM can intercept/inject fingerprinting relevant
> messages like "mempool" to analyze the bitcoin network.

Encryption alone cannot protect against a MITM attack in an anonymous and permissionless network. This is accepted in the BIP (and your follow-up reply).

> 4) SPV
> For obvious reasons regarding BF (see BIP or above).
> 
> 5) Goundwork for a "client-server" model over the P2P channel
> Fee estimation, bloom-filters, or any other message type that requires
> authentication.

I do not challenge the usefulness and appropriateness of encryption with authentication in a client-server blockchain protocol.

> I would not reduce BIP151 to only solve the BF privacy/censorship problem.
> 
> If we agree that censorship-resistance is one of the main properties of Bitcoin,

We do.

> then we should definitively use a form of end-to-end encryption between nodes. Built into the network layer.

This is the assumption that I'm questioning.

> There are plenty of other options to solve this problem. stunnel,
> Bernsteins CurveCP, VPN, etc. which are available since years.
> But the reality has shown that most bitcoin traffic is still unencrypted.

The question arises from concern over the security of the network in the case where encryption (and therefore authentication) is pervasive.

As you point out, anyone can set up a private network of nodes today. These nodes must also connect to the permissionless network to maintain the chain. These nodes constitute a trust zone within Bitcoin. This zone of exclusion operates as a single logical node from the perspective of the Bitcoin security model (one entity controls the validation rules for all nodes).

Widespread application of this model is potentially problematic. It is a non-trivial problem to design a distributed system that requires authentication but without identity and without central control. In fact this may be more challenging than Bitcoin itself. Trust on first use (TOFU) does not solve this problem.

In my opinion this question has not received sufficient consideration to warrant proceeding with a network encryption scheme (which concerns me as well, but as I consider it premature I won't comment).

> Example: IIRC non of the available SPV wallets can "speak" on of the
> possible encryption techniques. Encrypting traffic below the application
> layer is extremely hard to set up for non-experienced users.

Bloom filters can (and IMO should) be isolated from the P2P protocol. Also, if the proposal creates an insecurity its ease of deployment is moot.

> On top of that, encryption allows us to drop the SHA256 checksum per p2p
> message which should result in a better performance on the network layer
> once BIP151 is deployed.

I would not consider this a performance enhancing proposal. Simply dropping the checksum seems like a better option. But again, it is moot if it creates an insecurity.

> I agree that BIP151 _must_ be deployed together with an authentication
> scheme (I'm working on that) to protect again MITM during encryption
> initialization.

At a minimum I would propose that you modify BIP151 to declare a dependency on a future BIP, making BIP151 incomplete without it. I think we can agree that it would be unadvisable to deploy (and therefore to implement) encryption alone.

I'll respond to the question of authentication in your follow-up post.

e

> ---
> </jonas>
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From eric at voskuil.org  Tue Jun 28 17:39:41 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 19:39:41 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <577269E7.6020008@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577269E7.6020008@jonasschnelli.ch>
Message-ID: <2E638F35-D212-43B7-A9AB-7D7C33CFF781@voskuil.org>

continued from previous post...

> On Jun 28, 2016, at 2:13 PM, Jonas Schnelli via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Hi Eric
> 
> Sorry for not directly addressing your points.

No problem. Thanks for the detailed replies.

> I try to be more precise in this follow up email:
> 
>> I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features are client-server in nature. Libbitcoin (for example) supports client-server features on an independent port (and implements a variant of CurveCP for encryption and identity). My concern arises with application of identity to the P2P protocol (excluding Bloom filter features).
> 
> I think the bloom filter SPV usecase is not "pure client-server". SPV
> clients could request from/broadcast to multiple "trusted nodes".

I have referred to the Bloom filters messages. These are clearly asymmetric in nature. Despite being possible it is not a valid use case for a full node to make BF requests to another node.

One client to multiple servers is still client-server for the sake of this discussion. The nature of the P2P protocol is synchronization of content between all nodes/peers. If the protocol is asymmetric the semantics, and therefore use cases, are different.

FWIW posting a transaction to the network can be done using the P2P protocol, connecting for a short period of time. But this is also a client-server scenario and is a hack when done (full disclosure, bx provides both P2P and client-server commands for tx posting). Broadcasting is naturally the behavior of a full node.

> Trusted nodes could be nodes where the operators have shared identities/keys in advance over a different channel.

Yes, this is necessarily the case in order to prevent a MITM attack. This is the basis of my concern.

> Further private p2p extensions (lets say a p2p form of the estimatefee
> command) are something which needs to be discussed first and not
> something that is encouraged or outlined in BIP151.

Sure, but then let us not make assumptions about it in the context of this discussion. Libbitcoin provides fee estimation by monitoring broadcast penetration using a client-server protocol with an optional subscription mechanism.

>> It seems to me that the desire to secure against the weaknesses of BF is being casually generalized to the P2P network. That generalization may actually weaken the security of the P2P protocol. One might consider the proper resolution is to move the BF features to a client-server protocol.
> 
> I don't see reasons why BIP151 could weaken the security of the P2P network. Can you point out some specific concerns?

TOFU cannot prevent MITM attacks (the goal of the encryption). Authentication requires a secure (trusted) side channel by which to distribute public keys. This presents what I consider a significant problem. If widespread, control over this distribution network would constitute control over who can use Bitcoin.

The effort to prevent censorship could actually enable it. I don't think it would get that far. Someone would point this out in the process of vetting the authentication BIP, and the result would be the scrapping of BIP151.

>> The BIP does not make a case for other scenarios, or contemplate the significant problems associated with key distribution in any identity system. Given that the BIP relies on identity, these considerations should be fully vetted before heading down another blind alley.
> 
> BIP151 does not rely on identities. BIP151 does not use persisted keys
> (only ephemeral keys).

BIP 151 is incomplete without authentication.

> The authentication/identity system needs to be described in a another BIP.
> But correct, BIP151 without a form of authentication/identity management
> is vulnerable to all sorts of MITM attacks and that's why I think BIP151
> must be deployed together with an p2p authentication scheme.

Agree, but my problem is that I do not believe we can assume this is a solvable problem.

> Scope creeping and the risks of overspecifying is the main reason to
> focus on the "pure encryption part" in BIP151.

Understood, yet this is the basis of my blind alley comment.

e

> Thanks
> ---
> </jonas>

From pete at petertodd.org  Tue Jun 28 18:22:02 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 28 Jun 2016 14:22:02 -0400
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
Message-ID: <20160628182202.GA5519@fedora-21-dvm>

On Tue, Jun 28, 2016 at 06:45:58PM +0200, Eric Voskuil via bitcoin-dev wrote:
> > 1) Transaction censorship
> > ISPs, WIFI provider or any other MITM, can holdback/censor unconfirmed
> > transactions. Regardless if you are a miner or a validation/wallet node.
> > 
> > 2) Peer censorship
> > MITM can remove or add entries from a "addr" message.
> > 
> > 3) Fingerprinting
> > ISPs or any other MITM can intercept/inject fingerprinting relevant
> > messages like "mempool" to analyze the bitcoin network.
> 
> Encryption alone cannot protect against a MITM attack in an anonymous and permissionless network. This is accepted in the BIP (and your follow-up reply).

Being able to easily detect MITM attacks is a _huge_ step forward that
shouldn't be underestimated; even if 99% of users aren't in a position to
detect the MITM you only need a small subset of users that do the necessary
checks to alert the wider community, who can then respond with stronger
security measures. Those measures are likely to be more costly - authenticated
systems are significantly harder than not - so better to save your efforts
until the need for them is more obvious.

Also the fact that an attack has a reasonable probability of detection is a big
disincentive for many types of attackers - note how one of the things revealed
in the Snowden leaks was the fact that the NSA generally tries quite hard to
avoid tipping off targets to the fact that they're being surveilled, with a
myriad of carefully scripted policies to control when and how exploits are used
against targets.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/5edcd321/attachment.sig>

From eric at voskuil.org  Tue Jun 28 18:35:26 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 20:35:26 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <20160628182202.GA5519@fedora-21-dvm>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
Message-ID: <D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>

Hi Peter,

What in this BIP makes a MITM attack easier (or easy) to detect, or increases the probability of one being detected?

e

> On Jun 28, 2016, at 8:22 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> On Tue, Jun 28, 2016 at 06:45:58PM +0200, Eric Voskuil via bitcoin-dev wrote:
>>> 1) Transaction censorship
>>> ISPs, WIFI provider or any other MITM, can holdback/censor unconfirmed
>>> transactions. Regardless if you are a miner or a validation/wallet node.
>>> 
>>> 2) Peer censorship
>>> MITM can remove or add entries from a "addr" message.
>>> 
>>> 3) Fingerprinting
>>> ISPs or any other MITM can intercept/inject fingerprinting relevant
>>> messages like "mempool" to analyze the bitcoin network.
>> 
>> Encryption alone cannot protect against a MITM attack in an anonymous and permissionless network. This is accepted in the BIP (and your follow-up reply).
> 
> Being able to easily detect MITM attacks is a _huge_ step forward that
> shouldn't be underestimated; even if 99% of users aren't in a position to
> detect the MITM you only need a small subset of users that do the necessary
> checks to alert the wider community, who can then respond with stronger
> security measures. Those measures are likely to be more costly - authenticated
> systems are significantly harder than not - so better to save your efforts
> until the need for them is more obvious.
> 
> Also the fact that an attack has a reasonable probability of detection is a big
> disincentive for many types of attackers - note how one of the things revealed
> in the Snowden leaks was the fact that the NSA generally tries quite hard to
> avoid tipping off targets to the fact that they're being surveilled, with a
> myriad of carefully scripted policies to control when and how exploits are used
> against targets.
> 
> -- 
> https://petertodd.org 'peter'[:-1]@petertodd.org

From greg at xiph.org  Tue Jun 28 19:55:37 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 28 Jun 2016 19:55:37 +0000
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <577234A4.3030808@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
Message-ID: <CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>

> I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features

This is a bit of a strawman, you've selected a single narrow usecase
which isn't proposed by the BIP and then argue it is worthless. I
agree that example doesn't have much value (and I believe that
eventually the BIP37 bloom filters should be removed from the
protocol).

Without something like BIP151 network participants cannot have privacy
for the transactions they originate within the protocol against
network observers. Even if, through some extraordinary effort, their
own first hop is encrypted, unencrypted later hops would rapidly
expose significant information about transaction origins in the
network.

Without something like BIP151 authenticated links are not possible, so
manually curated links (addnode/connect) cannot be counted on to
provide protection against partitioning sybils.

Along the way BIP151 appears that it will actually make the protocol faster.

> Given that the BIP relies on identity

This is untrue. The proposal is an ephemerally keyed opportunistic
encryption system. The privacy against a network observer does not
depend on authentication, much less "identity".  And when used with
authentication at all it makes interception strongly detectable after
the fact.

> The BIP does not [...] contemplate the significant problems associated with key distribution in any identity system

Because it does not propose any "identity system" or authorization
(also, I object to your apparent characterization of authentication as
as an 'identity system'-- do you also call Bitcoin addresses an
identity system?).

That said, manually maintaining adds nodes to your own and somewhat
trusted nodes is a recommend best practice for miners and other high
value systems which is rendered much less effective due to a lack of
authentication, there is no significant key distribution problem in
that case, and I expect the future auth BIP (Jonas had one before, but
it was put aside for now to first focus on the link layer encryption)
to address that case quite well.

From dev at jonasschnelli.ch  Tue Jun 28 20:06:58 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Tue, 28 Jun 2016 22:06:58 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
Message-ID: <5772D8E2.6020007@jonasschnelli.ch>

>> In my opinion, the question should be "why would you _not_ encrypt".
> 
> 1) creation of a false sense of security

False sense of security is mostly a communication issue.
BIP151 does focus on encryption (not trust).

Are users aware of the fact that ISP/WiFi-Providers can track their
bitcoin spending (if they use SPV+BF) and link it with other internet
traffic or sell the data to anyone who is interested to do correlation?

Are node operators aware of the possibilities that ISPs/Data-Centers,
etc. can hold back peers, etc.?

If there is a false sense of security/anonymity, then we are already
deep into this territory.
BIP151 was designed as a puzzle-pice towards better security and better
censorship resistance. You shouldn't project all sorts of "false sense
of security" into BIP151. Is a stepping stone towards greater security.

> 2) as a tradeoff against anonymity

Can you point out the tradeoffs?
BIP151 does not introduce fingerprinting possibilities.

> 3) benefit does not justify cost

Can you elaborate the costs?
[Extremely simplified]: we need 300 lines of code from openssh
(ChaCha20-Poly1305 at openssl) and some ECDH magic (already in
Bitcoin-Cores codebase) together with two or three (maybe payed)
cryptoanalysis once the implementation is done.


>> There are plenty of other options to solve this problem. stunnel,
>> Bernsteins CurveCP, VPN, etc. which are available since years.
>> But the reality has shown that most bitcoin traffic is still unencrypted.
> 
> The question arises from concern over the security of the network in the case where encryption (and therefore authentication) is pervasive.
> 
> As you point out, anyone can set up a private network of nodes today. These nodes must also connect to the permissionless network to maintain the chain. These nodes constitute a trust zone within Bitcoin. This zone of exclusion operates as a single logical node from the perspective of the Bitcoin security model (one entity controls the validation rules for all nodes).
> 
> Widespread application of this model is potentially problematic. It is a non-trivial problem to design a distributed system that requires authentication but without identity and without central control. In fact this may be more challenging than Bitcoin itself. Trust on first use (TOFU) does not solve this problem.

Yes. There is no plan to adopt a TUFO scheme. Bip151 does not use TUFO
it does not cover "trust" (It just encrypt all traffic).

Imaging Bip151 together with a simple form of preshared EC key
authentication (nonce signing or similar). You could drastically
increase the security/censor-resistance-properties between nodes where
owners have preshared identity keys (with nodes I also mean SPV/wallet
nodes).

And I guess there are plenty of awesome identity management system ideas
tied or not tied to the Bitcoin blockchain out there.
This is also a reason to not cover trust/authentication/identity in BIP151.
It is  possible to have multiple authentication schemes.

> In my opinion this question has not received sufficient consideration to warrant proceeding with a network encryption scheme (which concerns me as well, but as I consider it premature I won't comment).

Yes. I think nobody have started implementing BIP151. It's a draft BIP
and I think it's still okay and great that we have this discussion.

BIP151 hopefully has started some brainwork in how encryption and
authentication could work in Bitcoin and I'm happy to deprecate BIP151
if we have found a better solution or if we come to a point where we
agree that BIP151 does make the network security worse.

>> Example: IIRC non of the available SPV wallets can "speak" on of the
>> possible encryption techniques. Encrypting traffic below the application
>> layer is extremely hard to set up for non-experienced users.
> 
> Bloom filters can (and IMO should) be isolated from the P2P protocol. Also, if the proposal creates an insecurity its ease of deployment is moot.

If we assume increasing amount of novice users starting with Bitcoin
every day, how should these users run wallets without increasing
centralization by using webwallets or client/central-server wallets?
(which is OT, but an interesting question)

>> On top of that, encryption allows us to drop the SHA256 checksum per p2p
>> message which should result in a better performance on the network layer
>> once BIP151 is deployed.
> 
> I would not consider this a performance enhancing proposal. Simply dropping the checksum seems like a better option. But again, it is moot if it creates an insecurity.
> 
>> I agree that BIP151 _must_ be deployed together with an authentication
>> scheme (I'm working on that) to protect again MITM during encryption
>> initialization.
> 
> At a minimum I would propose that you modify BIP151 to declare a dependency on a future BIP, making BIP151 incomplete without it. I think we can agree that it would be unadvisable to deploy (and therefore to implement) encryption alone.

I think BIP151 does what it says: encryption and laying groundwork for
authentication.
You wouldn't probably say BIP32 is incomplete because it does not cover
a scheme how to recover funds (or BIP141 [SW consensus] is incomplete
because it does not cover p2p [BIP144]).

The missing MITM protection (solvable over auth) is prominent mentioned
in the BIP [1].


(from your other mail):
>> I don't see reasons why BIP151 could weaken the security of the P2P network. Can you point out some specific concerns?
> 
> TOFU cannot prevent MITM attacks (the goal of the encryption). Authentication requires a secure (trusted) side channel by which to distribute public keys. This presents what I consider a significant problem. If widespread, control over this distribution network would constitute control over who can use Bitcoin.
> The effort to prevent censorship could actually enable it. I don't think it would get that far. Someone would point this out in the process of vetting the authentication BIP, and the result would be the scrapping of BIP151.

I agree that the secure trusted 2nd channel key-sharing problem can be
significant for large networks and/or connecting to unknown identities.

But as said, there could be multiple ways of sharing identity keys.
If you want to connect your node to serval other trusted nodes, you can
simply physically preshare keys or do it over GPG / Signal App, etc..

And if I have followed the news correctly, there are some clever guys
working on various internet of trust 2.0 proposals...

>>
>> BIP151 does not rely on identities. BIP151 does not use persisted keys
>> (only ephemeral keys).
> 
> BIP 151 is incomplete without authentication.

I would agree if you would say, _trusted encryption_ is incomplete with
authentication. But IMO BIP151 is complete and should be deployed
together with one or multiple authentication schemes.


[1] https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki#risks

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/3748c989/attachment.sig>

From pete at petertodd.org  Tue Jun 28 20:14:47 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 28 Jun 2016 16:14:47 -0400
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
Message-ID: <20160628201447.GA1148@fedora-21-dvm>

On Tue, Jun 28, 2016 at 08:35:26PM +0200, Eric Voskuil wrote:
> Hi Peter,
> 
> What in this BIP makes a MITM attack easier (or easy) to detect, or increases the probability of one being detected?

BIP151 gives users the tools to detect a MITM attack.

It's kinda like PGP in that way: lots of PGP users don't properly check keys,
so an attacker won't have a hard time MITM attacking those users. But some
users do check keys, a labor intensive manual process, but not a process that
requires any real cryptographic sophistication, let alone writing any code.
It's very difficult for widescale attackers to distinguish the users who do
check keys from the ones that don't, so if you MITM attack _any_ user you run
the risk of running into one of the few that does check, and those users can
alert everyone else.

The key thing, is we need to get everyones communications encrypted first: if
we don't the MITM attacker can intercept 99% of the communications with 0% risk
of detection, because the non-sophisticated users are trivially distinguishable
from the sophisticated users: just find the users with unencrypted
communications!

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/a26f4f33/attachment-0001.sig>

From eric at voskuil.org  Tue Jun 28 20:29:54 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 22:29:54 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <20160628201447.GA1148@fedora-21-dvm>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
Message-ID: <4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>



> On Jun 28, 2016, at 10:14 PM, Peter Todd <pete at petertodd.org> wrote:
> 
>> On Tue, Jun 28, 2016 at 08:35:26PM +0200, Eric Voskuil wrote:
>> Hi Peter,
>> 
>> What in this BIP makes a MITM attack easier (or easy) to detect, or increases the probability of one being detected?
> 
> BIP151 gives users the tools to detect a MITM attack.
> 
> It's kinda like PGP in that way: lots of PGP users don't properly check keys,

PGP requires a secure side channel for transmission of public keys. How does one "check" a key of an anonymous peer? I know you well enough to know you wouldn't trust a PGP key received over an insecure channel.

All you can prove is that you are talking to a peer and that communications in the session remain with that peer. The peer can be the attacker. As Jonas has acknowledged, authentication is required to actually guard against MITM attacks.

> so an attacker won't have a hard time MITM attacking those users. But some
> users do check keys, a labor intensive manual process, but not a process that
> requires any real cryptographic sophistication, let alone writing any code.
> It's very difficult for widescale attackers to distinguish the users who do
> check keys from the ones that don't, so if you MITM attack _any_ user you run
> the risk of running into one of the few that does check, and those users can
> alert everyone else.
> 
> The key thing, is we need to get everyones communications encrypted first: if
> we don't the MITM attacker can intercept 99% of the communications with 0% risk
> of detection, because the non-sophisticated users are trivially distinguishable from the sophisticated users: just find the users with unencrypted
> communications!
> 
> -- 
> https://petertodd.org 'peter'[:-1]@petertodd.org

From pete at petertodd.org  Tue Jun 28 20:36:05 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 28 Jun 2016 16:36:05 -0400
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
Message-ID: <20160628203605.GA1328@fedora-21-dvm>

On Tue, Jun 28, 2016 at 10:29:54PM +0200, Eric Voskuil wrote:
> 
> 
> > On Jun 28, 2016, at 10:14 PM, Peter Todd <pete at petertodd.org> wrote:
> > 
> >> On Tue, Jun 28, 2016 at 08:35:26PM +0200, Eric Voskuil wrote:
> >> Hi Peter,
> >> 
> >> What in this BIP makes a MITM attack easier (or easy) to detect, or increases the probability of one being detected?
> > 
> > BIP151 gives users the tools to detect a MITM attack.
> > 
> > It's kinda like PGP in that way: lots of PGP users don't properly check keys,
> 
> PGP requires a secure side channel for transmission of public keys. How does one "check" a key of an anonymous peer? I know you well enough to know you wouldn't trust a PGP key received over an insecure channel.
> 
> All you can prove is that you are talking to a peer and that communications in the session remain with that peer. The peer can be the attacker. As Jonas has acknowledged, authentication is required to actually guard against MITM attacks.

Easy: anonymous peers aren't always actually anonymous.

A MITM attacker can't easily distinguish communications between two nodes that
randomly picked their peers, and nodes that are connected because their
operators manually used -addnode to peer; in the latter case the operators can
check whether or not they're being attacked with an out-of-band key check.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160628/cbd12c6b/attachment.sig>

From eric at voskuil.org  Tue Jun 28 21:22:23 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 23:22:23 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <20160628203605.GA1328@fedora-21-dvm>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
Message-ID: <E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>


> On Jun 28, 2016, at 10:36 PM, Peter Todd <pete at petertodd.org> wrote:
> 
>> On Tue, Jun 28, 2016 at 10:29:54PM +0200, Eric Voskuil wrote:
>> 
>> 
>>>> On Jun 28, 2016, at 10:14 PM, Peter Todd <pete at petertodd.org> wrote:
>>>> 
>>>> On Tue, Jun 28, 2016 at 08:35:26PM +0200, Eric Voskuil wrote:
>>>> Hi Peter,
>>>> 
>>>> What in this BIP makes a MITM attack easier (or easy) to detect, or increases the probability of one being detected?
>>> 
>>> BIP151 gives users the tools to detect a MITM attack.
>>> 
>>> It's kinda like PGP in that way: lots of PGP users don't properly check keys,
>> 
>> PGP requires a secure side channel for transmission of public keys. How does one "check" a key of an anonymous peer? I know you well enough to know you wouldn't trust a PGP key received over an insecure channel.
>> 
>> All you can prove is that you are talking to a peer and that communications in the session remain with that peer. The peer can be the attacker. As Jonas has acknowledged, authentication is required to actually guard against MITM attacks.
> 
> Easy: anonymous peers aren't always actually anonymous.
> 
> A MITM attacker can't easily distinguish communications between two nodes that
> randomly picked their peers, and nodes that are connected because their operators manually used -addnode to peer; in the latter case the operators can
> check whether or not they're being attacked with an out-of-band key check.

An "out of band key check" is not part of BIP151. It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.

e

From greg at xiph.org  Tue Jun 28 21:36:00 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 28 Jun 2016 21:36:00 +0000
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
Message-ID: <CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>

On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> An "out of band key check" is not part of BIP151.

It has a session ID for this purpose.

> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.

One might wonder how you ever use a Bitcoin address, or even why we
might guess these emails from "you" aren't actually coming from the
NSA.

From da2ce7 at gmail.com  Tue Jun 28 21:40:23 2016
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Wed, 29 Jun 2016 00:40:23 +0300
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
Message-ID: <B1AF0E38-522E-4EC7-8595-92972D658430@gmail.com>

Unauthenticated link level encryption is wonderful! MITM attacks are overrated; as they require an active attacker.

Stopping passive attacks is the low hanging fruit. This should be taken first.

Automated and secure peer authentication in a mesh network is a huge topic. One of the unsolved problems in computer science.

A simple 'who is that' by asking for the fingerprint of your peers from your other peers is a very simple way to get 'some' authentication.  Semi-trusted index nodes also is a low hanging fruit for authentication.

However, let's first get unauthenticated encryption. Force the attackers to use active attacks. (That are thousands times more costly to couduct).

Sent from my iPhone

> On 29 Jun 2016, at 00:36, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> An "out of band key check" is not part of BIP151.
> 
> It has a session ID for this purpose.
> 
>> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.
> 
> One might wonder how you ever use a Bitcoin address, or even why we
> might guess these emails from "you" aren't actually coming from the
> NSA.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/436fe397/attachment-0001.html>

From eric at voskuil.org  Tue Jun 28 21:59:54 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 28 Jun 2016 23:59:54 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
Message-ID: <7F95A7F5-848C-4EA6-9503-C48F45AC1C34@voskuil.org>



> On Jun 28, 2016, at 11:36 PM, Gregory Maxwell <greg at xiph.org> wrote:
> 
> On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> An "out of band key check" is not part of BIP151.
> 
> It has a session ID for this purpose.

Passing the session ID out of band is authentication. As this is explicitly not part of BIP151 it cannot be that BIP151 provides the tools to detect a attack (the point at issue).

>> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.
> 
> One might wonder how you ever use a Bitcoin address, or even why we might guess these emails from "you" aren't actually coming from the NSA.

The sarcasm is counterproductive Greg. By the same token I could ask how you ever use Bitcoin given that the P2P protocol is not encrypted or authenticated.

It doesn't matter who I am, maybe I am the NSA. I don't argue from a position of authority. Signing my emails while traveling on holiday with only my phone gets a little tedious.

The blockchain and mempool are a cache of public data. Transmission of a payment address to a payer is not a comparable scenario.

The possibility that authentication may become required to participate in this trustless network is a legitimate concern, and one that has not been addressed.

e

From eric at voskuil.org  Tue Jun 28 22:07:45 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Jun 2016 00:07:45 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <B1AF0E38-522E-4EC7-8595-92972D658430@gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
	<B1AF0E38-522E-4EC7-8595-92972D658430@gmail.com>
Message-ID: <A74C9C1E-07CE-4769-85BA-AA97F55167EC@voskuil.org>

Hi Cameron, good to hear from you!

> On Jun 28, 2016, at 11:40 PM, Cameron Garnham <da2ce7 at gmail.com> wrote:
> 
> Unauthenticated link level encryption is wonderful! MITM attacks are overrated; as they require an active attacker.

This is not really the case with Bitcoin. A MITM attack does not require that the attacker find a way to inject traffic into the communication between nodes. Peers will connect to the attacker directly, or accept connections directly from it. Such attacks can be easier than even passive attacks.

> Stopping passive attacks is the low hanging fruit. This should be taken first.
> 
> Automated and secure peer authentication in a mesh network is a huge topic. One of the unsolved problems in computer science.
> 
> A simple 'who is that' by asking for the fingerprint of your peers from your other peers is a very simple way to get 'some' authentication.  Semi-trusted index nodes also is a low hanging fruit for authentication.

It is the implication of widespread authentication that is at issue. Clearly there are ways to implement it using a secure side channels.

> However, let's first get unauthenticated encryption. Force the attackers to use active attacks. (That are thousands times more costly to couduct).
> 
> Sent from my iPhone
> 
>> On 29 Jun 2016, at 00:36, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> An "out of band key check" is not part of BIP151.
>> 
>> It has a session ID for this purpose.
>> 
>>> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.
>> 
>> One might wonder how you ever use a Bitcoin address, or even why we
>> might guess these emails from "you" aren't actually coming from the
>> NSA.
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/5fb01d58/attachment.html>

From da2ce7 at gmail.com  Tue Jun 28 22:33:35 2016
From: da2ce7 at gmail.com (Cameron Garnham)
Date: Wed, 29 Jun 2016 01:33:35 +0300
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <A74C9C1E-07CE-4769-85BA-AA97F55167EC@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
	<B1AF0E38-522E-4EC7-8595-92972D658430@gmail.com>
	<A74C9C1E-07CE-4769-85BA-AA97F55167EC@voskuil.org>
Message-ID: <E1CB43A4-F13D-4109-AB05-DDD650FEC0C9@gmail.com>


There are two different topics mixed up here.

1. Link-level security (secure connection to the node we intended to connect to).

2. Node-level security (aka; don't connect to a 'evil node').

The fist requires link-level encryption and authentication.

The second requires identity authentication.

You described the 'evil node' attack; that indeed needs an identity system to stop. However BIP151 doesn't intend to protect against connecting to evil Bitcoin Nodes.

It is important not to mixup link-level authentication and node-level authentication.

When your client picks random nodes to connect to, you are not considered whom in particular runs them. (Rather that you have a good random sample of the network).

If you manually add a friends node; at this point you wish to have node-level authentication.  However, this may (and probably should) happen out-of-band.


Sent from my iPhone

> On 29 Jun 2016, at 01:07, Eric Voskuil <eric at voskuil.org> wrote:
> 
> Hi Cameron, good to hear from you!
> 
>> On Jun 28, 2016, at 11:40 PM, Cameron Garnham <da2ce7 at gmail.com> wrote:
>> 
>> Unauthenticated link level encryption is wonderful! MITM attacks are overrated; as they require an active attacker.
> 
> This is not really the case with Bitcoin. A MITM attack does not require that the attacker find a way to inject traffic into the communication between nodes. Peers will connect to the attacker directly, or accept connections directly from it. Such attacks can be easier than even passive attacks.
> 
>> Stopping passive attacks is the low hanging fruit. This should be taken first.
>> 
>> Automated and secure peer authentication in a mesh network is a huge topic. One of the unsolved problems in computer science.
>> 
>> A simple 'who is that' by asking for the fingerprint of your peers from your other peers is a very simple way to get 'some' authentication.  Semi-trusted index nodes also is a low hanging fruit for authentication.
> 
> It is the implication of widespread authentication that is at issue. Clearly there are ways to implement it using a secure side channels.
> 
>> However, let's first get unauthenticated encryption. Force the attackers to use active attacks. (That are thousands times more costly to couduct).
>> 
>> Sent from my iPhone
>> 
>>> On 29 Jun 2016, at 00:36, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> 
>>> On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> An "out of band key check" is not part of BIP151.
>>> 
>>> It has a session ID for this purpose.
>>> 
>>>> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.
>>> 
>>> One might wonder how you ever use a Bitcoin address, or even why we
>>> might guess these emails from "you" aren't actually coming from the
>>> NSA.
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/49c7f475/attachment-0001.html>

From eric at voskuil.org  Tue Jun 28 23:29:10 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Jun 2016 01:29:10 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <E1CB43A4-F13D-4109-AB05-DDD650FEC0C9@gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
	<B1AF0E38-522E-4EC7-8595-92972D658430@gmail.com>
	<A74C9C1E-07CE-4769-85BA-AA97F55167EC@voskuil.org>
	<E1CB43A4-F13D-4109-AB05-DDD650FEC0C9@gmail.com>
Message-ID: <2DC6C84C-5FE1-4908-B50B-47C6BF928A1C@voskuil.org>

Your description of the two scenarios reduces to one. They both require authentication, and if you intend to connect to potentially evil nodes you aren't securing anything with link level security except the knowledge that your potentially evil node connection remains so.

e

> On Jun 29, 2016, at 12:33 AM, Cameron Garnham <da2ce7 at gmail.com> wrote:
> 
> 
> There are two different topics mixed up here.
> 
> 1. Link-level security (secure connection to the node we intended to connect to).
> 
> 2. Node-level security (aka; don't connect to a 'evil node').
> 
> The fist requires link-level encryption and authentication.
> 
> The second requires identity authentication.
> 
> You described the 'evil node' attack; that indeed needs an identity system to stop. However BIP151 doesn't intend to protect against connecting to evil Bitcoin Nodes.
> 
> It is important not to mixup link-level authentication and node-level authentication.
> 
> When your client picks random nodes to connect to, you are not considered whom in particular runs them. (Rather that you have a good random sample of the network).
> 
> If you manually add a friends node; at this point you wish to have node-level authentication.  However, this may (and probably should) happen out-of-band.
> 
> 
> Sent from my iPhone
> 
>> On 29 Jun 2016, at 01:07, Eric Voskuil <eric at voskuil.org> wrote:
>> 
>> Hi Cameron, good to hear from you!
>> 
>>> On Jun 28, 2016, at 11:40 PM, Cameron Garnham <da2ce7 at gmail.com> wrote:
>>> 
>>> Unauthenticated link level encryption is wonderful! MITM attacks are overrated; as they require an active attacker.
>> 
>> This is not really the case with Bitcoin. A MITM attack does not require that the attacker find a way to inject traffic into the communication between nodes. Peers will connect to the attacker directly, or accept connections directly from it. Such attacks can be easier than even passive attacks.
>> 
>>> Stopping passive attacks is the low hanging fruit. This should be taken first.
>>> 
>>> Automated and secure peer authentication in a mesh network is a huge topic. One of the unsolved problems in computer science.
>>> 
>>> A simple 'who is that' by asking for the fingerprint of your peers from your other peers is a very simple way to get 'some' authentication.  Semi-trusted index nodes also is a low hanging fruit for authentication.
>> 
>> It is the implication of widespread authentication that is at issue. Clearly there are ways to implement it using a secure side channels.
>> 
>>> However, let's first get unauthenticated encryption. Force the attackers to use active attacks. (That are thousands times more costly to couduct).
>>> 
>>> Sent from my iPhone
>>> 
>>>> On 29 Jun 2016, at 00:36, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> 
>>>> On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>> An "out of band key check" is not part of BIP151.
>>>> 
>>>> It has a session ID for this purpose.
>>>> 
>>>>> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.
>>>> 
>>>> One might wonder how you ever use a Bitcoin address, or even why we
>>>> might guess these emails from "you" aren't actually coming from the
>>>> NSA.
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/5343f305/attachment.html>

From eric at voskuil.org  Tue Jun 28 23:31:19 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Jun 2016 01:31:19 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <5772D8E2.6020007@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<5772D8E2.6020007@jonasschnelli.ch>
Message-ID: <A32C431E-A639-40D4-BA2C-BF912D9FEE9D@voskuil.org>

On Jun 28, 2016, at 10:06 PM, Jonas Schnelli <dev at jonasschnelli.ch> wrote:

>>> In my opinion, the question should be "why would you _not_ encrypt".
>> 
>> 1) creation of a false sense of security
> 
> False sense of security is mostly a communication issue.
> BIP151 does focus on encryption (not trust).
> 
> Are users aware of the fact that ISP/WiFi-Providers can track their
> bitcoin spending (if they use SPV+BF) and link it with other internet
> traffic or sell the data to anyone who is interested to do correlation?

The relevant question would be to ask whether encryption would prevent an ISP from doing so (which it would not). This is a good example of false sense of security.

> Are node operators aware of the possibilities that ISPs/Data-Centers,
> etc. can hold back peers, etc.?
> 
> If there is a false sense of security/anonymity, then we are already
> deep into this territory.
> BIP151 was designed as a puzzle-pice towards better security and better
> censorship resistance. You shouldn't project all sorts of "false sense
> of security" into BIP151. Is a stepping stone towards greater security.

FWIW I was just answering your question comprehensively. Relationship to BIP151 is incidental (though apparently applicable).

Keep in mind my specific concern is not with the design of BIP151, it is with the implication of its dependency on an unspecified authentication proposal.

>> 2) as a tradeoff against anonymity
> 
> Can you point out the tradeoffs?
> BIP151 does not introduce fingerprinting possibilities.

The security tradeoff would arise from widespread deployment of authentication - which is necessary to make encryption useful against envisioned MITM attacks. See my previous discussion of trust zones below.

>> 3) benefit does not justify cost
> 
> Can you elaborate the costs?
> [Extremely simplified]: we need 300 lines of code from openssh
> (ChaCha20-Poly1305 at openssl) and some ECDH magic (already in
> Bitcoin-Cores codebase) together with two or three (maybe payed)
> cryptoanalysis once the implementation is done.

Simply put, any code that is unnecessary does not justify its cost.

>>> There are plenty of other options to solve this problem. stunnel,
>>> Bernsteins CurveCP, VPN, etc. which are available since years.
>>> But the reality has shown that most bitcoin traffic is still unencrypted.
>> 
>> The question arises from concern over the security of the network in the case where encryption (and therefore authentication) is pervasive.
>> 
>> As you point out, anyone can set up a private network of nodes today. These nodes must also connect to the permissionless network to maintain the chain. These nodes constitute a trust zone within Bitcoin. This zone of exclusion operates as a single logical node from the perspective of the Bitcoin security model (one entity controls the validation rules for all nodes).
>> 
>> Widespread application of this model is potentially problematic. It is a non-trivial problem to design a distributed system that requires authentication but without identity and without central control. In fact this may be more challenging than Bitcoin itself. Trust on first use (TOFU) does not solve this problem.
> 
> Yes. There is no plan to adopt a TUFO scheme. Bip151 does not use TUFO
> it does not cover "trust" (It just encrypt all traffic).

TOFU (trust on first use) was a reference to what was discussed on IRC as a potential solution to the (deferred) authentication problem. I didn't mean to imply that it was part of BIP151.

> Imaging Bip151 together with a simple form of preshared EC key
> authentication (nonce signing or similar). You could drastically
> increase the security/censor-resistance-properties between nodes where
> owners have preshared identity keys (with nodes I also mean SPV/wallet
> nodes).

This is a restatement of what I have accepted as a premise - that authentication, and as such, key distribution, will be a necessary part of making any encryption scheme effective. "Preshared" implies a secure side channel for key distribution.

> And I guess there are plenty of awesome identity management system ideas
> tied or not tied to the Bitcoin blockchain out there.
> This is also a reason to not cover trust/authentication/identity in BIP151.
> It is  possible to have multiple authentication schemes.

Whether or not there are multiple schemes is not relevant to the point I have raised. The issue is that authentication is necessary.

>> In my opinion this question has not received sufficient consideration to warrant proceeding with a network encryption scheme (which concerns me as well, but as I consider it premature I won't comment).
> 
> Yes. I think nobody have started implementing BIP151. It's a draft BIP
> and I think it's still okay and great that we have this discussion.
> 
> BIP151 hopefully has started some brainwork in how encryption and
> authentication could work in Bitcoin and I'm happy to deprecate BIP151 if we have found a better solution or if we come to a point where we agree that BIP151 does make the network security worse.

We should contemplate what the distributed permissionless network of anonymous peers looks like once every node authenticates every one of its peers using one or more key distribution side channels.

>>> Example: IIRC non of the available SPV wallets can "speak" on of the
>>> possible encryption techniques. Encrypting traffic below the application
>>> layer is extremely hard to set up for non-experienced users.
>> 
>> Bloom filters can (and IMO should) be isolated from the P2P protocol. Also, if the proposal creates an insecurity its ease of deployment is moot.
> 
> If we assume increasing amount of novice users starting with Bitcoin every day, how should these users run wallets without increasing centralization by using webwallets or client/central-server wallets?
> (which is OT, but an interesting question)

I fully appreciate the significant security risk arising from the proliferation of web wallets. This can only be resolved by people validating using code under their own control.

Encryption/authentication are orthogonal to this question, assuming people have wallets directly attached to full nodes. Remoting a wallet from a full node does not require use of the P2P protocol, and can use encryption/authentication without the concerns I've raised. It properly places the trust boundary around a wallet and its trusted node(s), as opposed to spanning (independent) nodes.

>>> On top of that, encryption allows us to drop the SHA256 checksum per p2p
>>> message which should result in a better performance on the network layer
>>> once BIP151 is deployed.
>> 
>> I would not consider this a performance enhancing proposal. Simply dropping the checksum seems like a better option. But again, it is moot if it creates an insecurity.
>> 
>>> I agree that BIP151 _must_ be deployed together with an authentication
>>> scheme (I'm working on that) to protect again MITM during encryption
>>> initialization.
>> 
>> At a minimum I would propose that you modify BIP151 to declare a dependency on a future BIP, making BIP151 incomplete without it. I think we can agree that it would be unadvisable to deploy (and therefore to implement) encryption alone.
> 
> I think BIP151 does what it says: encryption and laying groundwork for authentication.
> You wouldn't probably say BIP32 is incomplete because it does not cover
> a scheme how to recover funds (or BIP141 [SW consensus] is incomplete
> because it does not cover p2p [BIP144]).

This is an unfair statement. You have acknowledged that BIP151 requires authentication to accomplish its sole objective.

> The missing MITM protection (solvable over auth) is prominent mentioned in the BIP [1].

As I pointed out.

> (from your other mail):
>>> I don't see reasons why BIP151 could weaken the security of the P2P network. Can you point out some specific concerns?
>> 
>> TOFU cannot prevent MITM attacks (the goal of the encryption). Authentication requires a secure (trusted) side channel by which to distribute public keys. This presents what I consider a significant problem. If widespread, control over this distribution network would constitute control over who can use Bitcoin.
>> The effort to prevent censorship could actually enable it. I don't think it would get that far. Someone would point this out in the process of vetting the authentication BIP, and the result would be the scrapping of BIP151.
> 
> I agree that the secure trusted 2nd channel key-sharing problem can be significant for large networks and/or connecting to unknown identities.
> 
> But as said, there could be multiple ways of sharing identity keys.
> If you want to connect your node to serval other trusted nodes, you can simply physically preshare keys or do it over GPG / Signal App, etc..

Again, it's the fact that authentication is required that produces the issue, not that there are multiple ways to implement it.

> And if I have followed the news correctly, there are some clever guys
> working on various internet of trust 2.0 proposals...

I don't see how this is relevant.

>>> BIP151 does not rely on identities. BIP151 does not use persisted keys
>>> (only ephemeral keys).
>> 
>> BIP 151 is incomplete without authentication.
> 
> I would agree if you would say, _trusted encryption_ is incomplete with
> authentication. But IMO BIP151 is complete and should be deployed together with one or multiple authentication schemes.

It seems that we are talking past each other. You haven't yet addressed the issue that I have raised.

It is the requirement for authentication of any node that any other node may wish to connect to that is the issue. We end up with something that looks like WoT or PKI. And if not fully controlled by PKI (so using WoT) we will have hybrid nodes that accept untrusted connections and propagate information between trusted and untrusted nodes.

> [1] https://github.com/bitcoin/bips/blob/master/bip-0151.mediawiki#risks
> 

From eric at voskuil.org  Tue Jun 28 23:33:53 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Jun 2016 01:33:53 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
Message-ID: <AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>

On Jun 28, 2016, at 9:55 PM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

>> I understand the use, when coupled with a yet-to-be-devised identity system, with Bloom filter features. Yet these features
> 
> This is a bit of a strawman, you've selected a single narrow usecase which isn't proposed by the BIP and then argue it is worthless. I agree that example doesn't have much value (and I believe that
> eventually the BIP37 bloom filters should be removed from the protocol).

I don't follow this comment. The BIP aims quite clearly at "SPV" wallets as its justifying scenario.

> Without something like BIP151 network participants cannot have privacy for the transactions they originate within the protocol against network observers.

And they won't get it with BIP151 either. Being a peer is easier than observing the network. If one can observe the encrypted traffic one can certainly use a timing attack to determine what the node has sent.

> Even if, through some extraordinary effort, their own first hop is encrypted, unencrypted later hops would rapidly
> expose significant information about transaction origins in the network.

As will remain the case until all connections are encrypted and authenticated, and all participants are known to be good guys. Starting to sound like PKI?

> Without something like BIP151 authenticated links are not possible, so
> manually curated links (addnode/connect) cannot be counted on to provide protection against partitioning sybils.

If we trust the manual links we don't need/want the other links. In fact retaining the other links enables the attack you described above. Of course there is no need to worry about Sybil attacks when all of your peers are authenticated. But again, let us not ignore the problems of requiring all peers on the network be authenticated.

> Along the way BIP151 appears that it will actually make the protocol faster.
> 
>> Given that the BIP relies on identity
> 
> This is untrue. The proposal is an ephemerally keyed opportunistic
> encryption system. The privacy against a network observer does not depend on authentication, much less "identity".  And when used with authentication at all it makes interception strongly detectable after the fact.

Maybe I was insufficiently explicit. By "relies on identity" I meant that the BIP is not effective without it. I did not mean to imply that the BIP itself implements an identity scheme. I thought this was clear from the context.

>> The BIP does not [...] contemplate the significant problems associated with key distribution in any identity system
> 
> Because it does not propose any "identity system" or authorization (also, I object to your apparent characterization of authentication as as an 'identity system'-- do you also call Bitcoin addresses an identity system?).

Please read more carefully what I wrote. I did not characterize authentication as an identity system. I proposed that key distribution has significant problems, and used identity systems as an example of systems with such problems. I could just have easily written "authentication systems", (and probably should have).

> That said, manually maintaining adds nodes to your own and somewhat trusted nodes is a recommend best practice for miners and other high value systems which is rendered much less effective due to a lack of
> authentication, there is no significant key distribution problem in that case

This is the only legitimate scenario that I am aware of. Doing this by IP address (as we do) is weak if there is no VPN.

Yet this scenario is very different than general authentication. This scenario is a set of nodes that is essentially a single logical node from the perspective of the Bitcoin security model. One entity controls the validation rules, or is collaborating with another entity to do so.

My concern is that a general authentication requirement expands this single logical node and gives control over if to the entity that controls key distribution - the hard problem that hasn't been addressed.

If there is no such entity restricting access to the network (which hopefully we can assume) then there is no reason to expect any effective improvement, since nodes will necessarily have to connect with anonymous peers. Anyone with a node and the ability to monitor traffic should remain very effective.

> and I expect the future auth BIP (Jonas had one before, but it was put aside for now to first focus on the link layer encryption)
> to address that case quite well.

Defining an auth implementation is not a hard problem, nor is it the concern I have raised.

e

From eric at voskuil.org  Tue Jun 28 23:34:33 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Wed, 29 Jun 2016 01:34:33 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAAS2fgQ0Ocs8hF+pf+fWfkKKhQwxNKpY=JHpb_bwua7neVO8tg@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
	<7F95A7F5-848C-4EA6-9503-C48F45AC1C34@voskuil.org>
	<CAAS2fgQ0Ocs8hF+pf+fWfkKKhQwxNKpY=JHpb_bwua7neVO8tg@mail.gmail.com>
Message-ID: <D317F7C9-C645-455F-8BA6-EB9F6D09F39F@voskuil.org>



>> On Jun 29, 2016, at 12:22 AM, Gregory Maxwell <gmaxwell at gmail.com> wrote:
>> 
>> On Tue, Jun 28, 2016 at 9:59 PM, Eric Voskuil <eric at voskuil.org> wrote:
>> Passing the session ID out of band is authentication. As this is explicitly not part of BIP151 it cannot be that BIP151 provides the tools to detect a attack (the point at issue).
> 
> It provides the ID, the rest is meat.

The rest is "authentication".

> Users can compare session IDs
> via whatever communications channels they already use after the fact
> and discover if they were or are being MITMed.
> 
>>>> It requires a secure channel and is authentication. So BIP151 doesn't provide the tools to detect an attack, that requires authentication. A general requirement for authentication is the issue I have raised.
>>> 
>>> One might wonder how you ever use a Bitcoin address, or even why we might guess these emails from "you" aren't actually coming from the NSA.
>> 
>> The sarcasm is counterproductive Greg. By the same token I could ask how you ever use Bitcoin given that the P2P protocol is not encrypted or authenticated.
> 
> I think I was unclear. A bitcoin address needs to be sent over a secure channel, which we do not provide. Yet sending funds to addresses instead of anyone_can_spend is pretty useful.
> 
> Similarly, I can guess that messages claiming to you are probably from you when many people can independently check, even if they don't usually. The fact tampered messages might be detected is a big disincentive from trying.

You were perfectly clear. Did I give some indication that I did not understand what you meant?

>> The blockchain and mempool are a cache of public data. Transmission of a payment address to a payer is not a comparable scenario.
> 
> The precise timing and ordering of transactions being relayed is _not_
> public data.

Posting txs to the network is a client-server scenario. The set of txs arriving at an arbitrary node, including the order of arrival, is by definition public information. The only possible way it could be considered private is if the entire network was private.

So where does the private timing become public? First hop, second, third?

Encryption and authentication cannot prevent timing attacks against a person posting txs to the network unless the entire network is "secured". That is not possible without centralized access control.

Encrypting the P2P network doesn't resolve this problem, nor does authentication, nor does Tor. I would prefer we advance an actual solution to this significant problem than advance a false sense of security while creating both complexity and the likely evolution of node identity.

e

From nickodell at gmail.com  Wed Jun 29 00:06:41 2016
From: nickodell at gmail.com (Nick ODell)
Date: Tue, 28 Jun 2016 18:06:41 -0600
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <2DC6C84C-5FE1-4908-B50B-47C6BF928A1C@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160628182202.GA5519@fedora-21-dvm>
	<D40F9E9D-DB6C-4083-A9E8-C5EBC363DB30@voskuil.org>
	<20160628201447.GA1148@fedora-21-dvm>
	<4DCF7DD2-6533-4F79-8CA1-871B67C01BDA@voskuil.org>
	<20160628203605.GA1328@fedora-21-dvm>
	<E8335291-7142-4E21-A1E2-76F387426741@voskuil.org>
	<CAAS2fgRGbnH-NtPRdLe0yhFSoqJ7b6O25LfyGv_ULHhy8bBSpg@mail.gmail.com>
	<B1AF0E38-522E-4EC7-8595-92972D658430@gmail.com>
	<A74C9C1E-07CE-4769-85BA-AA97F55167EC@voskuil.org>
	<E1CB43A4-F13D-4109-AB05-DDD650FEC0C9@gmail.com>
	<2DC6C84C-5FE1-4908-B50B-47C6BF928A1C@voskuil.org>
Message-ID: <CANN4kmfqbWwPhD1kyWMsrRhDJaniu3f3Ca_-LSuNawDwY1_uvw@mail.gmail.com>

>They both require authentication,

Yeah, but not the same *sort* of authentication. As a trivial example,
you could have ten servers that sign long-term keys for nodes. All
that they need to check is that the node requesting a signature owns
the corresponding IP address. On the other hand, 'evil nodes' is a
subjective quality that is hard to assess automatically.

>and if you intend to connect to potentially evil nodes you aren't securing anything

Bitcoin is designed with the assumption that some of the nodes you
connect to might be evil. Sure, if 100% of the nodes you're connected
to are evil, you're screwed. However, we shouldn't avoid protecting
people from someone on the same coffee-shop network, just because the
same mitigation won't work against a nation-state.

On Tue, Jun 28, 2016 at 5:29 PM, Eric Voskuil via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Your description of the two scenarios reduces to one. They both require
> authentication, and if you intend to connect to potentially evil nodes you
> aren't securing anything with link level security except the knowledge that
> your potentially evil node connection remains so.
>
> e
>
> On Jun 29, 2016, at 12:33 AM, Cameron Garnham <da2ce7 at gmail.com> wrote:
>
>
> There are two different topics mixed up here.
>
> 1. Link-level security (secure connection to the node we intended to connect
> to).
>
> 2. Node-level security (aka; don't connect to a 'evil node').
>
> The fist requires link-level encryption and authentication.
>
> The second requires identity authentication.
>
> You described the 'evil node' attack; that indeed needs an identity system
> to stop. However BIP151 doesn't intend to protect against connecting to evil
> Bitcoin Nodes.
>
> It is important not to mixup link-level authentication and node-level
> authentication.
>
> When your client picks random nodes to connect to, you are not considered
> whom in particular runs them. (Rather that you have a good random sample of
> the network).
>
> If you manually add a friends node; at this point you wish to have
> node-level authentication.  However, this may (and probably should) happen
> out-of-band.
>
>
> Sent from my iPhone
>
> On 29 Jun 2016, at 01:07, Eric Voskuil <eric at voskuil.org> wrote:
>
> Hi Cameron, good to hear from you!
>
> On Jun 28, 2016, at 11:40 PM, Cameron Garnham <da2ce7 at gmail.com> wrote:
>
> Unauthenticated link level encryption is wonderful! MITM attacks are
> overrated; as they require an active attacker.
>
>
> This is not really the case with Bitcoin. A MITM attack does not require
> that the attacker find a way to inject traffic into the communication
> between nodes. Peers will connect to the attacker directly, or accept
> connections directly from it. Such attacks can be easier than even passive
> attacks.
>
> Stopping passive attacks is the low hanging fruit. This should be taken
> first.
>
> Automated and secure peer authentication in a mesh network is a huge topic.
> One of the unsolved problems in computer science.
>
> A simple 'who is that' by asking for the fingerprint of your peers from your
> other peers is a very simple way to get 'some' authentication.  Semi-trusted
> index nodes also is a low hanging fruit for authentication.
>
>
> It is the implication of widespread authentication that is at issue. Clearly
> there are ways to implement it using a secure side channels.
>
> However, let's first get unauthenticated encryption. Force the attackers to
> use active attacks. (That are thousands times more costly to couduct).
>
> Sent from my iPhone
>
> On 29 Jun 2016, at 00:36, Gregory Maxwell via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Tue, Jun 28, 2016 at 9:22 PM, Eric Voskuil via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> An "out of band key check" is not part of BIP151.
>
>
> It has a session ID for this purpose.
>
> It requires a secure channel and is authentication. So BIP151 doesn't
> provide the tools to detect an attack, that requires authentication. A
> general requirement for authentication is the issue I have raised.
>
>
> One might wonder how you ever use a Bitcoin address, or even why we
> might guess these emails from "you" aren't actually coming from the
> NSA.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From greg at xiph.org  Wed Jun 29 01:01:50 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 29 Jun 2016 01:01:50 +0000
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
	<AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
Message-ID: <CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>

On Tue, Jun 28, 2016 at 11:33 PM, Eric Voskuil <eric at voskuil.org> wrote:
> I don't follow this comment. The BIP aims quite clearly at "SPV" wallets as its justifying scenario.

It cites SPV as an example, doesn't mention bloom filters.. and sure--
sounds like the bip text should make the

>> Without something like BIP151 network participants cannot have privacy for the transactions they originate within the protocol against network observers.
>
> And they won't get it with BIP151 either. Being a peer is easier than observing the network.

Not passively, undetectable, and against thousands of users at once at low cost.

> If one can observe the encrypted traffic one can certainly use a timing attack to determine what the node has sent.

Not against Bitcoin Core, transactions are batched and relayed in
sorted order.  (obviously there are limits at what this provides;
ironically, the lack of link encryption has been used to argue against
privacy preserving relay behavior)

>> Even if, through some extraordinary effort, their own first hop is encrypted, unencrypted later hops would rapidly
>> expose significant information about transaction origins in the network.
>
> As will remain the case until all connections are encrypted and authenticated, and all participants are known to be good guys. Starting to sound like PKI?

Huh? The first and subsequent hops obscures the origin and timing.

>> Without something like BIP151 authenticated links are not possible, so
>> manually curated links (addnode/connect) cannot be counted on to provide protection against partitioning sybils.
>
> If we trust the manual links we don't need/want the other links. In fact retaining the other links enables the attack you described above. Of course there is no need to worry about Sybil attacks when all of your peers are authenticated. But again, let us not ignore the problems of requiring all peers on the network be authenticated.

Don't need and want them for what?  For _partitioning_ resistance,
you are not partitioned if you have one honest connection to the
functional network. Additional peers purely reduce your partition
vulnerability-- so long as an active network attacker isn't
itercepting all your connections out.

For privacy, you have improve transaction privacy so long as your
transaction isn't initially relayed to a malicious peer-- but
malicious peers can lie further out because transit nodes obscure the
order of message creation.  Bitcoin Core currently relays transactions
first and more frequently to outbound and whitelisted peers.

> Maybe I was insufficiently explicit. By "relies on identity" I meant that the BIP is not effective without it. I did not mean to imply that the BIP itself implements an identity scheme. I thought this was clear from the context.

I understood that, but my point was that Bitcoin cannot be used at
all_unless users have secure communication channels to share
addresses.

> then there is no reason to expect any effective improvement, since nodes will necessarily have to connect with anonymous peers.

They're not required to _only_ connect with anonymous peers. And
partition resistance requires that you have any one good link.

> Anyone with a node and the ability to monitor traffic should remain very effective.

Not via passive observation.

> Defining an auth implementation is not a hard problem, nor is it the concern I have raised.

Glad you agree.

We seem to be looping now. Feel free to not implement this proposal,
no one suggests making it mandatory.

From rusty at rustcorp.com.au  Wed Jun 29 01:00:29 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Wed, 29 Jun 2016 10:30:29 +0930
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <577224E8.6070307@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
Message-ID: <8760ssdd1u.fsf@rustcorp.com.au>

Jonas Schnelli <dev at jonasschnelli.ch> writes:
>> To quote:
>> 
>>> HMAC_SHA512(key=ecdh_secret|cipher-type,msg="encryption key").
>>>
>>>  K_1 must be the left 32bytes of the HMAC_SHA512 hash.
>>>  K_2 must be the right 32bytes of the HMAC_SHA512 hash.
>> 
>> This seems a weak reason to introduce SHA512 to the mix.  Can we just
>> make:
>> 
>> K_1 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="header encryption key")
>> K_2 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="body encryption key")
>
> SHA512_HMAC is used by BIP32 [1] and I guess most clients will somehow
> make use of bip32 features. I though a single SHA512_HMAC operation is
> cheaper and simpler then two SHA256_HMAC.

Good point; I would argue that mistake has already been made.  But I was
looking at appropriating your work for lightning inter-node comms, and
adding another hash algo seemed unnecessarily painful.

> AFAIK, sha256_hmac is also not used by the current p2p & consensus layer.
> Bitcoin-Core uses it for HTTP RPC auth and Tor control.

It's also not clear to me why the HMAC, vs just
SHA256(key|cipher-type|mesg).  But that's probably just my crypto
ignorance...

Thanks!
Rusty.

From arthur.chen at btcc.com  Wed Jun 29 01:38:44 2016
From: arthur.chen at btcc.com (Arthur Chen)
Date: Wed, 29 Jun 2016 09:38:44 +0800
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <8760ssdd1u.fsf@rustcorp.com.au>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<8760ssdd1u.fsf@rustcorp.com.au>
Message-ID: <CAP+0UNJ0hVK3FxST0PzaqDx+T7A0rOtCpcnZRPt+8Bn4TmUHNw@mail.gmail.com>

HMAC has proven security property.
It is still secure even when underlying crypto hashing function has
collision resistant weakness.
For example, MD5 is considered completely insecure now, but HMAC-MD5 is
still considered secure.
When in doubt, we should always use HMAC for MAC(Message Authentication
Code) rather than custom construction

On Wed, Jun 29, 2016 at 9:00 AM, Rusty Russell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Jonas Schnelli <dev at jonasschnelli.ch> writes:
> >> To quote:
> >>
> >>> HMAC_SHA512(key=ecdh_secret|cipher-type,msg="encryption key").
> >>>
> >>>  K_1 must be the left 32bytes of the HMAC_SHA512 hash.
> >>>  K_2 must be the right 32bytes of the HMAC_SHA512 hash.
> >>
> >> This seems a weak reason to introduce SHA512 to the mix.  Can we just
> >> make:
> >>
> >> K_1 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="header encryption
> key")
> >> K_2 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="body encryption key")
> >
> > SHA512_HMAC is used by BIP32 [1] and I guess most clients will somehow
> > make use of bip32 features. I though a single SHA512_HMAC operation is
> > cheaper and simpler then two SHA256_HMAC.
>
> Good point; I would argue that mistake has already been made.  But I was
> looking at appropriating your work for lightning inter-node comms, and
> adding another hash algo seemed unnecessarily painful.
>
> > AFAIK, sha256_hmac is also not used by the current p2p & consensus layer.
> > Bitcoin-Core uses it for HTTP RPC auth and Tor control.
>
> It's also not clear to me why the HMAC, vs just
> SHA256(key|cipher-type|mesg).  But that's probably just my crypto
> ignorance...
>
> Thanks!
> Rusty.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
Xuesong (Arthur) Chen
Senior Principle Engineer
BlockChain Technologist
BTCC
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/3e68c72a/attachment-0001.html>

From eth3rs at gmail.com  Wed Jun 29 01:56:55 2016
From: eth3rs at gmail.com (Ethan Heilman)
Date: Tue, 28 Jun 2016 21:56:55 -0400
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <8760ssdd1u.fsf@rustcorp.com.au>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<8760ssdd1u.fsf@rustcorp.com.au>
Message-ID: <CAEM=y+XKQZVz6UieB-nDy_C9xTmXiBB3-atuuZkxzmPoSVPOJw@mail.gmail.com>

>It's also not clear to me why the HMAC, vs just SHA256(key|cipher-type|mesg).  But that's probably just my crypto ignorance...

SHA256(key|cipher-type|mesg) is an extremely insecure MAC because of
the length extension property of SHA256.

If I have a tag y = SHA256(key|cipher-type|mesg), I can without
knowing key or msg compute a value y' such that
y' = SHA256(key|cipher-type|mesg|any values I want).

Thus, an attacker can trivially forge a tag protected by
SHA256(key|cipher-type|mesg).

For more details see:
https://web.archive.org/web/20141029080820/http://vudang.com/2012/03/md5-length-extension-attack/

On Tue, Jun 28, 2016 at 9:00 PM, Rusty Russell via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Jonas Schnelli <dev at jonasschnelli.ch> writes:
>>> To quote:
>>>
>>>> HMAC_SHA512(key=ecdh_secret|cipher-type,msg="encryption key").
>>>>
>>>>  K_1 must be the left 32bytes of the HMAC_SHA512 hash.
>>>>  K_2 must be the right 32bytes of the HMAC_SHA512 hash.
>>>
>>> This seems a weak reason to introduce SHA512 to the mix.  Can we just
>>> make:
>>>
>>> K_1 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="header encryption key")
>>> K_2 = HMAC_SHA256(key=ecdh_secret|cipher-type,msg="body encryption key")
>>
>> SHA512_HMAC is used by BIP32 [1] and I guess most clients will somehow
>> make use of bip32 features. I though a single SHA512_HMAC operation is
>> cheaper and simpler then two SHA256_HMAC.
>
> Good point; I would argue that mistake has already been made.  But I was
> looking at appropriating your work for lightning inter-node comms, and
> adding another hash algo seemed unnecessarily painful.
>
>> AFAIK, sha256_hmac is also not used by the current p2p & consensus layer.
>> Bitcoin-Core uses it for HTTP RPC auth and Tor control.
>
> It's also not clear to me why the HMAC, vs just
> SHA256(key|cipher-type|mesg).  But that's probably just my crypto
> ignorance...
>
> Thanks!
> Rusty.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From pieter.wuille at gmail.com  Wed Jun 29 06:58:21 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Wed, 29 Jun 2016 08:58:21 +0200
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <CAEM=y+XKQZVz6UieB-nDy_C9xTmXiBB3-atuuZkxzmPoSVPOJw@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<8760ssdd1u.fsf@rustcorp.com.au>
	<CAEM=y+XKQZVz6UieB-nDy_C9xTmXiBB3-atuuZkxzmPoSVPOJw@mail.gmail.com>
Message-ID: <CAPg+sBj3QRGYUzJn96ZS4bf1ZEH9KTwF+OxPXE-O_YJA66grBg@mail.gmail.com>

On Jun 29, 2016 07:05, "Ethan Heilman via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> >It's also not clear to me why the HMAC, vs just
SHA256(key|cipher-type|mesg).  But that's probably just my crypto
ignorance...
>
> SHA256(key|cipher-type|mesg) is an extremely insecure MAC because of
> the length extension property of SHA256.

This property does technically not apply here, as the output of the hash is
kept secret, and the possible messages are constants (which are presumably
chosen in such a way that one is never an extension of another).

However, this is a good example of why you can't generically use a hash
function in places where you want a MAC (aka "a hash with a shared
secret"). Furthermore, if you already have a hash function anyway, HMAC is
very easy construct on top of it.

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/72f9c103/attachment.html>

From alfie at alfie.wtf  Wed Jun 29 11:17:28 2016
From: alfie at alfie.wtf (Alfie John)
Date: Wed, 29 Jun 2016 11:17:28 +0000
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
Message-ID: <20160629111728.GO13338@dosf1.alfie.wtf>

On Tue, Jun 28, 2016 at 06:45:58PM +0200, Eric Voskuil via bitcoin-dev wrote:
> > then we should definitively use a form of end-to-end encryption between
> > nodes. Built into the network layer.
> 
> Widespread application of this model is potentially problematic. It is a
> non-trivial problem to design a distributed system that requires authentication
> but without identity and without central control. In fact this may be more
> challenging than Bitcoin itself. Trust on first use (TOFU) does not solve this
> problem.

Maybe the following paper can feed into this discussion:

  "Decentralized Anonymous Credentials" by Christina Garman, Matthew Green, Ian Miers
	https://eprint.iacr.org/2013/622.pdf

Alfie

-- 
Alfie John
https://www.alfie.wtf

From eth3rs at gmail.com  Wed Jun 29 14:38:43 2016
From: eth3rs at gmail.com (Ethan Heilman)
Date: Wed, 29 Jun 2016 10:38:43 -0400
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <CAPg+sBj3QRGYUzJn96ZS4bf1ZEH9KTwF+OxPXE-O_YJA66grBg@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<8760ssdd1u.fsf@rustcorp.com.au>
	<CAEM=y+XKQZVz6UieB-nDy_C9xTmXiBB3-atuuZkxzmPoSVPOJw@mail.gmail.com>
	<CAPg+sBj3QRGYUzJn96ZS4bf1ZEH9KTwF+OxPXE-O_YJA66grBg@mail.gmail.com>
Message-ID: <CAEM=y+X5uT+UbB1f6+ynsWW4ZsxEE4X0-PbHqWXEWz_mUj8Y2w@mail.gmail.com>

Just to clarify in BIP-0151 when it says:

>It is important to include the cipher-type into the symmetric cipher key to avoid weak-cipher-attacks.

the cipher-type here refers to the ECDH negotiation parameters?

On Wed, Jun 29, 2016 at 2:58 AM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> On Jun 29, 2016 07:05, "Ethan Heilman via bitcoin-dev"
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> >It's also not clear to me why the HMAC, vs just
>> > SHA256(key|cipher-type|mesg).  But that's probably just my crypto
>> > ignorance...
>>
>> SHA256(key|cipher-type|mesg) is an extremely insecure MAC because of
>> the length extension property of SHA256.
>
> This property does technically not apply here, as the output of the hash is
> kept secret, and the possible messages are constants (which are presumably
> chosen in such a way that one is never an extension of another).
>
> However, this is a good example of why you can't generically use a hash
> function in places where you want a MAC (aka "a hash with a shared secret").
> Furthermore, if you already have a hash function anyway, HMAC is very easy
> construct on top of it.
>
> --
> Pieter

From dev at jonasschnelli.ch  Wed Jun 29 18:34:06 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Wed, 29 Jun 2016 20:34:06 +0200
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <CAP+0UNKqDknS-w6QyCJ0_ra71YfsDDtSdSBYoguUicW2oNMLvQ@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<CAP+0UNKqDknS-w6QyCJ0_ra71YfsDDtSdSBYoguUicW2oNMLvQ@mail.gmail.com>
Message-ID: <5774149E.1010105@jonasschnelli.ch>

> Based on previous crypto analysis result, the actual security of SHA512
> is not significantly higher than SHA256.
> maybe we should consider SHA3?

As far as I know the security of the symmetric cipher key mainly depends
on the PRNG and the ECDH scheme.

The HMAC_SHA512 will be used to "drive" keys from the ECDH shared secret.
HMAC_SHA256 would be sufficient but I have specified SHA512 to allow to
directly derive 512bits which allows to have two 256bit keys with one
HMAC operation (same pattern is used in BIP for the key/chaincode
derivation).

Keccak would be an alternative but we probably don't want to introduce
another new hash type just for the encryption.

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/3c5c25c5/attachment.sig>

From dev at jonasschnelli.ch  Wed Jun 29 18:46:01 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Wed, 29 Jun 2016 20:46:01 +0200
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <CAEM=y+X5uT+UbB1f6+ynsWW4ZsxEE4X0-PbHqWXEWz_mUj8Y2w@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch> <8760ssdd1u.fsf@rustcorp.com.au>
	<CAEM=y+XKQZVz6UieB-nDy_C9xTmXiBB3-atuuZkxzmPoSVPOJw@mail.gmail.com>
	<CAPg+sBj3QRGYUzJn96ZS4bf1ZEH9KTwF+OxPXE-O_YJA66grBg@mail.gmail.com>
	<CAEM=y+X5uT+UbB1f6+ynsWW4ZsxEE4X0-PbHqWXEWz_mUj8Y2w@mail.gmail.com>
Message-ID: <57741769.7040300@jonasschnelli.ch>

Hi Ethan


>> It is important to include the cipher-type into the symmetric cipher key to avoid weak-cipher-attacks.
> 
> the cipher-type here refers to the ECDH negotiation parameters?

No. Not to the ECDH negotiation.
BIP151 specifies a flexible symmetric key cipher type negotiation,
although, BIP151 only specifies chacha20-poly1305 at openssh.com.

Lets assume someone adds another symmetric cipher type after BIP151 has
been deployed which has less strong security properties then
chacha20-poly1305.

If we don't include the ciphersuite-type in the key derivation HMAC, an
attacker/MITM could in theory force both nodes to use the weaker
symmetric cipher type.

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/47d92fd6/attachment.sig>

From pete at petertodd.org  Wed Jun 29 20:13:17 2016
From: pete at petertodd.org (Peter Todd)
Date: Wed, 29 Jun 2016 16:13:17 -0400
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <5774149E.1010105@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<CAP+0UNKqDknS-w6QyCJ0_ra71YfsDDtSdSBYoguUicW2oNMLvQ@mail.gmail.com>
	<5774149E.1010105@jonasschnelli.ch>
Message-ID: <20160629201317.GA4855@fedora-21-dvm>

On Wed, Jun 29, 2016 at 08:34:06PM +0200, Jonas Schnelli via bitcoin-dev wrote:
> > Based on previous crypto analysis result, the actual security of SHA512
> > is not significantly higher than SHA256.
> > maybe we should consider SHA3?
> 
> As far as I know the security of the symmetric cipher key mainly depends
> on the PRNG and the ECDH scheme.
> 
> The HMAC_SHA512 will be used to "drive" keys from the ECDH shared secret.
> HMAC_SHA256 would be sufficient but I have specified SHA512 to allow to
> directly derive 512bits which allows to have two 256bit keys with one
> HMAC operation (same pattern is used in BIP for the key/chaincode
> derivation).

What's the rational for doing that "directly" rather than with two SHA256
operations? (specifcially SHA256(0 . thing), SHA256(1 + thing) for the two
parts we need to derive)

Reducing the # of basic cryptographic primitives you need to implement a
standard needs is a good thing.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/12948cd4/attachment.sig>

From dev at jonasschnelli.ch  Wed Jun 29 20:31:50 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Wed, 29 Jun 2016 22:31:50 +0200
Subject: [bitcoin-dev] BIP 151 use of HMAC_SHA512
In-Reply-To: <20160629201317.GA4855@fedora-21-dvm>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<577224E8.6070307@jonasschnelli.ch>
	<CAP+0UNKqDknS-w6QyCJ0_ra71YfsDDtSdSBYoguUicW2oNMLvQ@mail.gmail.com>
	<5774149E.1010105@jonasschnelli.ch>
	<20160629201317.GA4855@fedora-21-dvm>
Message-ID: <57743036.5040304@jonasschnelli.ch>

> On Wed, Jun 29, 2016 at 08:34:06PM +0200, Jonas Schnelli via bitcoin-dev wrote:
>>> Based on previous crypto analysis result, the actual security of SHA512
>>> is not significantly higher than SHA256.
>>> maybe we should consider SHA3?
>>
>> As far as I know the security of the symmetric cipher key mainly depends
>> on the PRNG and the ECDH scheme.
>>
>> The HMAC_SHA512 will be used to "drive" keys from the ECDH shared secret.
>> HMAC_SHA256 would be sufficient but I have specified SHA512 to allow to
>> directly derive 512bits which allows to have two 256bit keys with one
>> HMAC operation (same pattern is used in BIP for the key/chaincode
>> derivation).
> 
> What's the rational for doing that "directly" rather than with two SHA256
> operations? (specifcially SHA256(0 . thing), SHA256(1 + thing) for the two
> parts we need to derive)

SHA256 and SHA512 are both from the SHA-2 family.

I have specified SHA512 to (slightly) increase the brute-force security
of the ecdh shared secret when knowing K_1 and K_2.

And I assumed (haven't measured the required cpu cycles) that a single
SHA512_HMAC is less expensive then two SHA256_HMAC.

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160629/8661e056/attachment.sig>

From eric at voskuil.org  Thu Jun 30 09:57:02 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 11:57:02 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
	<AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
	<CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>
Message-ID: <CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>


On Jun 29, 2016, at 3:01 AM, Gregory Maxwell <greg at xiph.org> wrote:
> 
>> On Tue, Jun 28, 2016 at 11:33 PM, Eric Voskuil <eric at voskuil.org> wrote:
>> I don't follow this comment. The BIP aims quite clearly at "SPV" wallets as its justifying scenario.
> 
> It cites SPV as an example, doesn't mention bloom filters.. and sure-- sounds like the bip text should make the

"MOTIVATION:
The Bitcoin network does not encrypt communication between peers today. This opens up security issues (eg: traffic manipulation by others) and allows for mass surveillance / analysis of bitcoin users. Mostly this is negligible because of the nature of Bitcoins trust model, however for SPV nodes this can have significant privacy impacts [1] and could reduce the censorship-resistance of a peer."

This is not an example, this is the exception that is described as "significant" in comparison to the other issues, which are described as "negligible".

The Bloom filters messages are of course the unique aspects of the protocol as it pertains to "SPV".

The RISKS section declares that the BIP cannot prevent MITM attacks and that "identity authentication" will  be defined in a forthcoming BIP.

The obvious implication (accepted by the author) is that authentication is required to prevent a MITM attack, and furthermore establishment of identity will be required to ensure that the authenticated party is not a bad actor.

>>> Without something like BIP151 network participants cannot have privacy for the transactions they originate within the protocol against network observers.
>> 
>> And they won't get it with BIP151 either. Being a peer is easier than observing the network.
> 
> Not passively, undetectable, and against thousands of users at once at low cost.

This is a straw man, as the BIP does not state that its objective is to moderately raise the cost of passive attack against large numbers of users.

It is also a red herring, as passivity is not itself a benefit. It implies that the attack is easier and therefore less costly. But a trivial active attack may be a larger security problem than a complex passive attack. Attacks against privacy under this BIP (and with authentication) can be carried out by passively monitoring traffic and operating one or more nodes. Operating a node may be considered "active" because the node communicates, but technically it is not. In either case the activeness itself hardly raises the difficulty, especially for a global (thousands of users) passive attacker.

Depending on the attacker, cost may not be an issue at all, so raising it can have zero effect. Certainly we are not talking about prohibitive (cryptographically hard) cost. Raising the cost *any* amount is not likely a reasonable cost-benefit tradeoff.

Privacy attacks would remain entirely undetectable under this proposal, and under any additional proposal that required authentication in the absence of identity. Only with all users of the network identified as "good" would such proposals be effective. Until that point any bad actors can become an integral part of the network. I will investigate the question of identity in a follow-up to an independent post.

>> If one can observe the encrypted traffic one can certainly use a timing attack to determine what the node has sent.
> 
> Not against Bitcoin Core, transactions are batched and relayed in
> sorted order.  (obviously there are limits at what this provides;
> ironically, the lack of link encryption has been used to argue against
> privacy preserving relay behavior)

It cannot be both impossible ("not against Bitcoin Core") and limited in effectiveness ("obviously there are limits").

We should be clear at this point that the transaction-posting security provided against a privacy attack, based on the assumption of "good" (identified) peers in the first few hops, derives entirely from the ability of the good peers to break the timing attack, which is itself "limited".

This is a compound pair of weak assumptions, that to be made stronger will require widespread use of identity (not just authentication).

The proliferation of node identity is my primary concern - this relates to privacy and the security of the network. Secondarily I am concerned about users operating under a false assumption about the strength of privacy. Thirdly I am concerned about the risk of vulnerability introduced by the integration into the P2P network layer of an totally new network security scheme. Fourthly I'm concerned about the cost of the above based on the belief that the benefit may not be material and that it may lead to increased centralization.

>>> Even if, through some extraordinary effort, their own first hop is encrypted, unencrypted later hops would rapidly
>>> expose significant information about transaction origins in the network.
>> 
>> As will remain the case until all connections are encrypted and authenticated, and all participants are known to be good guys. Starting to sound like PKI?
> 
> Huh? The first and subsequent hops obscures the origin and timing.

Described as "limited" in effectiveness, and clearly useful only if these hops are not attacker nodes.

So back to my comment on how we maintain a pool of "good" nodes for people to connect to, and raising the question of how effective is this strategy (which is itself unspecified and so cannot be assumed to even exist in the context of the BIP).

>>> Without something like BIP151 authenticated links are not possible, so
>>> manually curated links (addnode/connect) cannot be counted on to provide protection against partitioning sybils.
>> 
>> If we trust the manual links we don't need/want the other links. In fact retaining the other links enables the attack you described above. Of course there is no need to worry about Sybil attacks when all of your peers are authenticated. But again, let us not ignore the problems of requiring all peers on the network be authenticated.
> 
> Don't need and want them for what?  For _partitioning_ resistance,
> you are not partitioned if you have one honest connection to the
> functional network. Additional peers purely reduce your partition vulnerability-- so long as an active network attacker isn't
> intercepting all your connections out.

Don't want them as peers for the purpose of tx relay. As I said this, "enables the attack you described above."

> For privacy, you have improve transaction privacy so long as your
> transaction isn't initially relayed to a malicious peer-- but
> malicious peers can lie further out because transit nodes obscure the
> order of message creation.  Bitcoin Core currently relays transactions
> first and more frequently to outbound and whitelisted peers.

This whitelisting is simply a stand-in for a more formal identity system. One doesn't whitelist anonymous peers, one whitelists peers controlled by trusted parties. Preferring trusted peers is another aspect of trying to break the timing attack. So I would lump this under the same analysis as above (batching).

>> Maybe I was insufficiently explicit. By "relies on identity" I meant that the BIP is not effective without it. I did not mean to imply that the BIP itself implements an identity scheme. I thought this was clear from the context.
> 
> I understood that, but my point was that Bitcoin cannot be used at all_unless users have secure communication channels to share addresses.

This is true but not relevant. The parties with whom we transact are not in the same space as the nodes with which we connect. The fact that I am face-to-face with a counterparty does not help me find a "good" node, nor does my ability to PGP email a payment address or to send a stealth address in the clear.

But the fact that you raise this point is itself instructive. The solution that was devised to resolve the problem of verifying that a counterparty is who one thinks it is ended up being based on the use of certificate authorities - despite the fact the the BIP did not require this. Some people consider this extremely dangerous for Bitcoin, enough so that Peter Todd recently proposed scrapping the BIP.

It's not clear to me how the Bitcoin community intends to establish what nodes are good nodes. But one thing is certain, any anonymous node may be an undetectable attacker.

>> then there is no reason to expect any effective improvement, since nodes will necessarily have to connect with anonymous peers.
> 
> They're not required to _only_ connect with anonymous peers. And partition resistance requires that you have any one good link.

As a minimum requirement, it implies that only need only to connect to one or more "good" peers. Anonymous peers are gravy for partition resistance, yet they are potential attackers for tx tainting. In other words the logical topology is to only connect to good peers. That is a problem.

>> Anyone with a node and the ability to monitor traffic should remain very effective.
> 
> Not via passive observation.

See above commentary on the irrelevance of this distinction.

>> Defining an auth implementation is not a hard problem, nor is it the concern I have raised.
> 
> Glad you agree.

I don't get your point here. It seems like you are just trying to antagonize.

> We seem to be looping now. Feel free to not implement this proposal,

At this point I think it's fair for me to say that nobody needs your permission.

> no one suggests making it mandatory.

Have you ever debated an optional feature proposal?

e

From eric at voskuil.org  Thu Jun 30 11:56:42 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 13:56:42 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <20160629111728.GO13338@dosf1.alfie.wtf>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
Message-ID: <2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>

Hi Alfie,

Yes, this is exactly what I meant. The complexity of the proposed construction is comparable to that of Bitcoin itself. This is not itself prohibitive, but it is clearly worthy of consideration.

A question we should ask is whether decentralized anonymous credentials is applicable to the authentication problem posed by BIP151. I propose that it is not.

The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker. 

Authentication of an anonymous peer cannot achieve this objective, since the peer may be anyone and an attack on privacy can be undetectable. The identity of a peer must be known to the relying peer, either directly or transitively.

DAC is applicable in cases where identity is never required.  The prime example in the paper is that of first-come-first-served name registration. No identity is required in that scenario, just proof that a party in question is the original registrant. All participants are presumed to be "good".

I believe that a distributed anonymous system is fundamentally at odds with isolation of "good" vs. "bad" participants who comply with protocol rules (DoS considerations aside), and that any attempt to resolve this conflict will result in the system no longer allowing anonymous participation.

I may be mistaken, but I haven't found a way out of this realization.

e

> On Jun 29, 2016, at 1:17 PM, Alfie John <alfie at alfie.wtf> wrote:
> 
> On Tue, Jun 28, 2016 at 06:45:58PM +0200, Eric Voskuil via bitcoin-dev wrote:
>>> then we should definitively use a form of end-to-end encryption between
>>> nodes. Built into the network layer.
>> 
>> Widespread application of this model is potentially problematic. It is a
>> non-trivial problem to design a distributed system that requires authentication
>> but without identity and without central control. In fact this may be more
>> challenging than Bitcoin itself. Trust on first use (TOFU) does not solve this
>> problem.
> 
> Maybe the following paper can feed into this discussion:
> 
> "Decentralized Anonymous Credentials" by Christina Garman, Matthew Green, Ian Miers
>   https://eprint.iacr.org/2013/622.pdf
> 
> Alfie
> 
> -- 
> Alfie John
> https://www.alfie.wtf

From dev at jonasschnelli.ch  Thu Jun 30 12:20:59 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 30 Jun 2016 14:20:59 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
Message-ID: <57750EAB.3020105@jonasschnelli.ch>


> Yes, this is exactly what I meant. The complexity of the proposed construction is comparable to that of Bitcoin itself. This is not itself prohibitive, but it is clearly worthy of consideration.
> 
> A question we should ask is whether decentralized anonymous credentials is applicable to the authentication problem posed by BIP151. I propose that it is not.
> 
> The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker. 

BIP151 would increase the risks for MITM attackers.
What are the benefits for Mallory of he can't be sure Alice and Bob may
know that he is intercepting the channel?

MITM is possible today, it would still be possible (though under higher
costs) with BIP151.

With BIP151 we would have the basic tool-set to effectively reduce the
risks of being MITMled.

IMO we should focus on the risks and benefits of BIP151 and not drag
this discussion into the realm of authentication. This can and should be
done once we have proposals for authentication (and I'm sure this will
be a heated debate).

The only valid risk I have on my list from you, Eric, is the false sense
of security.

My countermeasure for that would be...
- deploy BIP151 together with the simplest form of authentication
(know_hosts / authorized_keys file, no TOFU only editable "by hand")
- make it more clear (in the BIP151 MOTIVATION text) that it won't solve
the privacy/MITM problem without additional authentication.

Or could you elaborate again ? without stepping into the realm of
authentication/MITM (which is not part of the BIP or possible already
today) ? why BIP151 would make things worse?

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160630/ddefb09d/attachment.sig>

From eric at voskuil.org  Thu Jun 30 12:27:30 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 14:27:30 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <57750EAB.3020105@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
Message-ID: <426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>


> On Jun 30, 2016, at 2:20 PM, Jonas Schnelli <dev at jonasschnelli.ch> wrote:
> 
> 
>> Yes, this is exactly what I meant. The complexity of the proposed construction is comparable to that of Bitcoin itself. This is not itself prohibitive, but it is clearly worthy of consideration.
>> 
>> A question we should ask is whether decentralized anonymous credentials is applicable to the authentication problem posed by BIP151. I propose that it is not.
>> 
>> The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker.
> 
> BIP151 would increase the risks for MITM attackers.
> What are the benefits for Mallory of he can't be sure Alice and Bob may
> know that he is intercepting the channel?

It is not clear to me why you believe an attack on privacy by an anonymous peer is detectable.

> MITM is possible today, it would still be possible (though under higher
> costs) with BIP151.
> 
> With BIP151 we would have the basic tool-set to effectively reduce the
> risks of being MITMled.
> 
> IMO we should focus on the risks and benefits of BIP151 and not drag
> this discussion into the realm of authentication. This can and should be
> done once we have proposals for authentication (and I'm sure this will
> be a heated debate).
> 
> The only valid risk I have on my list from you, Eric, is the false sense
> of security.
> 
> My countermeasure for that would be...
> - deploy BIP151 together with the simplest form of authentication
> (know_hosts / authorized_keys file, no TOFU only editable "by hand")
> - make it more clear (in the BIP151 MOTIVATION text) that it won't solve
> the privacy/MITM problem without additional authentication.
> 
> Or could you elaborate again ? without stepping into the realm of
> authentication/MITM (which is not part of the BIP or possible already
> today) ? why BIP151 would make things worse?
> 
> </jonas>
> 

From dev at jonasschnelli.ch  Thu Jun 30 12:43:07 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 30 Jun 2016 14:43:07 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
	<426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
Message-ID: <577513DB.60101@jonasschnelli.ch>



>>> The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker.
>>
>> BIP151 would increase the risks for MITM attackers.
>> What are the benefits for Mallory of he can't be sure Alice and Bob may
>> know that he is intercepting the channel?
> 
> It is not clear to me why you believe an attack on privacy by an anonymous peer is detectable.

If Mallory has substituted the ephemeral keys in both directions, at the
point where Alice and Bob will do an authentication, they can be sure
Mallory is listening.

Simple dummy example:
1.) Encryption setup with ECDH with ephemeral keys after BIP151
2.) Mallory is MITMling the connection. He is substituting both
direction with its own keys
3.) Connection is successfully MITMled
4.) Alice tells Bob "prove me that you are Bob, please sign the
session-ID with your identity key"
5.) Bob signs the sessionID (ECDH secret) with his identity key which
will be unusable for Mallory who has a substituted sessionID in both
directions.
6.) Alice has successfully detected the Mallory

Disclaimer: 4) and 5) are _not_ authentication proposals :-)

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160630/0920253c/attachment.sig>

From pieter.wuille at gmail.com  Thu Jun 30 13:03:18 2016
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Thu, 30 Jun 2016 15:03:18 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
	<AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
	<CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>
	<CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>
Message-ID: <CAPg+sBigr0BZBiuW9DYpxJ3ytZ4g30k_9B+Eb8QhQv2dC9qQUA@mail.gmail.com>

On Thu, Jun 30, 2016 at 11:57 AM, Eric Voskuil via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The proliferation of node identity is my primary concern - this relates to privacy and the security of the network.

I think this is a reasonable concern.

However, node identity is already being used widely, and in a very
inadvisable way:
* Since forever there have been lists of 'good nodes' to pass in
addnode= configuration options.
* Various people run multiple nodes in different geographic locations,
peering with each other.
* Various pieces of infrastructure exist that relies on connecting to
well-behaving nodes (miner relay networks, large players peering
directly with each other, ...)
* Several lightweight clients support configuring a trusted host to connect to.

Perhaps you deplore that fact, but I believe it is inevitable that
different pieces of the network will make different choices here. You
can'tg prevent people from create connections along preexisting trust
lines. That does not mean that the network as a whole relies on first
establishing trust everywhere.

And I do think there are advantages.

BIP 151 on its own gives you opportunistic encryption. You're very
right to point out that this does not give you protection from active
attackers, and that active attacking is relatively easy through sybil
attacks. I still prefer my attacker to actually do that over just
listening in on my connection. And yes, we should also work on
improving the privacy nodes and wallets have orthogonal to encryption,
but nothing will make everything perfectly private.

BIP 151 plus a simple optional pre-shared-secret authentication
extension can improve upon pure IP-based authentication, as well as
simplify things like SSL tunnels, and onion addresses purely used as
identity. This will still require explicit configuration, but not more
than now.

BIP 151 plus a non-leaking public key authentication scheme (where
peers can query "are you the peer with pubkey X?" but don't learn
anything if the answer is no) with keys specific to the IP addresses
can give a TOFU-like security. Nodes already remember IP addresses
they've succesfully interacted with in the past, and ban IP addresses
that misbehave. Being able to tell whether a node you connect to is
the same as one you've connected to before is a natural extension of
this, and does not require establishing any real-world identity beyond
what we're already implicitly relying on.

Perhaps these use cases and their security assumptions should be
spelled out more clearly in the BIP. If there is a misunderstanding,
it should be clearly stated that BIP 151 is only a building block for
further improvements

> Secondarily I am concerned about users operating under a false assumption about the strength of privacy.

This is a widespread problem, but it exists far outside the scope of
this proposal. The privacy properties of Bitcoin are often
misrepresented and even used as advertizements. The solution is
education, not avoiding improvements because they may be
misunderstood.

> The complexity of the proposed construction is comparable to that of Bitcoin itself.

I really think this is an exaggeration. It's a diffie-hellman
handshake and a stream cipher (both very common constructions), that
apply to individual connections. There are no consensus risks nor a
requirement for coordinated change through the network. The
cryptographic code can be directly reused from a well-known project
(OpenSSH), and is very small in size.

-- 
Pieter

From erik at q32.com  Thu Jun 30 13:36:57 2016
From: erik at q32.com (Erik Aronesty)
Date: Thu, 30 Jun 2016 09:36:57 -0400
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
	<AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
	<CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>
	<CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>
Message-ID: <CAJowKg+tOoEEeVh2sh3oZbnJ3dO_h4n9eBaUeZ+ys2RPD+s2vQ@mail.gmail.com>

I agree.

Encrypting links in a network without identity doesn't really seem to help
enough for the costs to be justified.

I would like to see a PGP-like "web of trust" proposal for both the
security of the bitcoin network itself /and/ (eventually) of things like
transmission of bitcoin addresses.

Something where nodes of any kind (full, spv, mobile wallets) can
/optionally/ accumulate trust over time and are capable of verifying the
identity of other nodes in that web.

*Then* you can slap an encryption layer on top of it.   Once you have
identity & P2P verified pub keys for nodes, encryption becomes easy.


On Thu, Jun 30, 2016 at 5:57 AM, Eric Voskuil via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Jun 29, 2016, at 3:01 AM, Gregory Maxwell <greg at xiph.org> wrote:
> >
> >> On Tue, Jun 28, 2016 at 11:33 PM, Eric Voskuil <eric at voskuil.org>
> wrote:
> >> I don't follow this comment. The BIP aims quite clearly at "SPV"
> wallets as its justifying scenario.
> >
> > It cites SPV as an example, doesn't mention bloom filters.. and sure--
> sounds like the bip text should make the
>
> "MOTIVATION:
> The Bitcoin network does not encrypt communication between peers today.
> This opens up security issues (eg: traffic manipulation by others) and
> allows for mass surveillance / analysis of bitcoin users. Mostly this is
> negligible because of the nature of Bitcoins trust model, however for SPV
> nodes this can have significant privacy impacts [1] and could reduce the
> censorship-resistance of a peer."
>
> This is not an example, this is the exception that is described as
> "significant" in comparison to the other issues, which are described as
> "negligible".
>
> The Bloom filters messages are of course the unique aspects of the
> protocol as it pertains to "SPV".
>
> The RISKS section declares that the BIP cannot prevent MITM attacks and
> that "identity authentication" will  be defined in a forthcoming BIP.
>
> The obvious implication (accepted by the author) is that authentication is
> required to prevent a MITM attack, and furthermore establishment of
> identity will be required to ensure that the authenticated party is not a
> bad actor.
>
> >>> Without something like BIP151 network participants cannot have privacy
> for the transactions they originate within the protocol against network
> observers.
> >>
> >> And they won't get it with BIP151 either. Being a peer is easier than
> observing the network.
> >
> > Not passively, undetectable, and against thousands of users at once at
> low cost.
>
> This is a straw man, as the BIP does not state that its objective is to
> moderately raise the cost of passive attack against large numbers of users.
>
> It is also a red herring, as passivity is not itself a benefit. It implies
> that the attack is easier and therefore less costly. But a trivial active
> attack may be a larger security problem than a complex passive attack.
> Attacks against privacy under this BIP (and with authentication) can be
> carried out by passively monitoring traffic and operating one or more
> nodes. Operating a node may be considered "active" because the node
> communicates, but technically it is not. In either case the activeness
> itself hardly raises the difficulty, especially for a global (thousands of
> users) passive attacker.
>
> Depending on the attacker, cost may not be an issue at all, so raising it
> can have zero effect. Certainly we are not talking about prohibitive
> (cryptographically hard) cost. Raising the cost *any* amount is not likely
> a reasonable cost-benefit tradeoff.
>
> Privacy attacks would remain entirely undetectable under this proposal,
> and under any additional proposal that required authentication in the
> absence of identity. Only with all users of the network identified as
> "good" would such proposals be effective. Until that point any bad actors
> can become an integral part of the network. I will investigate the question
> of identity in a follow-up to an independent post.
>
> >> If one can observe the encrypted traffic one can certainly use a timing
> attack to determine what the node has sent.
> >
> > Not against Bitcoin Core, transactions are batched and relayed in
> > sorted order.  (obviously there are limits at what this provides;
> > ironically, the lack of link encryption has been used to argue against
> > privacy preserving relay behavior)
>
> It cannot be both impossible ("not against Bitcoin Core") and limited in
> effectiveness ("obviously there are limits").
>
> We should be clear at this point that the transaction-posting security
> provided against a privacy attack, based on the assumption of "good"
> (identified) peers in the first few hops, derives entirely from the ability
> of the good peers to break the timing attack, which is itself "limited".
>
> This is a compound pair of weak assumptions, that to be made stronger will
> require widespread use of identity (not just authentication).
>
> The proliferation of node identity is my primary concern - this relates to
> privacy and the security of the network. Secondarily I am concerned about
> users operating under a false assumption about the strength of privacy.
> Thirdly I am concerned about the risk of vulnerability introduced by the
> integration into the P2P network layer of an totally new network security
> scheme. Fourthly I'm concerned about the cost of the above based on the
> belief that the benefit may not be material and that it may lead to
> increased centralization.
>
> >>> Even if, through some extraordinary effort, their own first hop is
> encrypted, unencrypted later hops would rapidly
> >>> expose significant information about transaction origins in the
> network.
> >>
> >> As will remain the case until all connections are encrypted and
> authenticated, and all participants are known to be good guys. Starting to
> sound like PKI?
> >
> > Huh? The first and subsequent hops obscures the origin and timing.
>
> Described as "limited" in effectiveness, and clearly useful only if these
> hops are not attacker nodes.
>
> So back to my comment on how we maintain a pool of "good" nodes for people
> to connect to, and raising the question of how effective is this strategy
> (which is itself unspecified and so cannot be assumed to even exist in the
> context of the BIP).
>
> >>> Without something like BIP151 authenticated links are not possible, so
> >>> manually curated links (addnode/connect) cannot be counted on to
> provide protection against partitioning sybils.
> >>
> >> If we trust the manual links we don't need/want the other links. In
> fact retaining the other links enables the attack you described above. Of
> course there is no need to worry about Sybil attacks when all of your peers
> are authenticated. But again, let us not ignore the problems of requiring
> all peers on the network be authenticated.
> >
> > Don't need and want them for what?  For _partitioning_ resistance,
> > you are not partitioned if you have one honest connection to the
> > functional network. Additional peers purely reduce your partition
> vulnerability-- so long as an active network attacker isn't
> > intercepting all your connections out.
>
> Don't want them as peers for the purpose of tx relay. As I said this,
> "enables the attack you described above."
>
> > For privacy, you have improve transaction privacy so long as your
> > transaction isn't initially relayed to a malicious peer-- but
> > malicious peers can lie further out because transit nodes obscure the
> > order of message creation.  Bitcoin Core currently relays transactions
> > first and more frequently to outbound and whitelisted peers.
>
> This whitelisting is simply a stand-in for a more formal identity system.
> One doesn't whitelist anonymous peers, one whitelists peers controlled by
> trusted parties. Preferring trusted peers is another aspect of trying to
> break the timing attack. So I would lump this under the same analysis as
> above (batching).
>
> >> Maybe I was insufficiently explicit. By "relies on identity" I meant
> that the BIP is not effective without it. I did not mean to imply that the
> BIP itself implements an identity scheme. I thought this was clear from the
> context.
> >
> > I understood that, but my point was that Bitcoin cannot be used at
> all_unless users have secure communication channels to share addresses.
>
> This is true but not relevant. The parties with whom we transact are not
> in the same space as the nodes with which we connect. The fact that I am
> face-to-face with a counterparty does not help me find a "good" node, nor
> does my ability to PGP email a payment address or to send a stealth address
> in the clear.
>
> But the fact that you raise this point is itself instructive. The solution
> that was devised to resolve the problem of verifying that a counterparty is
> who one thinks it is ended up being based on the use of certificate
> authorities - despite the fact the the BIP did not require this. Some
> people consider this extremely dangerous for Bitcoin, enough so that Peter
> Todd recently proposed scrapping the BIP.
>
> It's not clear to me how the Bitcoin community intends to establish what
> nodes are good nodes. But one thing is certain, any anonymous node may be
> an undetectable attacker.
>
> >> then there is no reason to expect any effective improvement, since
> nodes will necessarily have to connect with anonymous peers.
> >
> > They're not required to _only_ connect with anonymous peers. And
> partition resistance requires that you have any one good link.
>
> As a minimum requirement, it implies that only need only to connect to one
> or more "good" peers. Anonymous peers are gravy for partition resistance,
> yet they are potential attackers for tx tainting. In other words the
> logical topology is to only connect to good peers. That is a problem.
>
> >> Anyone with a node and the ability to monitor traffic should remain
> very effective.
> >
> > Not via passive observation.
>
> See above commentary on the irrelevance of this distinction.
>
> >> Defining an auth implementation is not a hard problem, nor is it the
> concern I have raised.
> >
> > Glad you agree.
>
> I don't get your point here. It seems like you are just trying to
> antagonize.
>
> > We seem to be looping now. Feel free to not implement this proposal,
>
> At this point I think it's fair for me to say that nobody needs your
> permission.
>
> > no one suggests making it mandatory.
>
> Have you ever debated an optional feature proposal?
>
> e
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160630/c7b1a867/attachment-0001.html>

From alfie at alfie.wtf  Thu Jun 30 14:47:34 2016
From: alfie at alfie.wtf (Alfie John)
Date: Thu, 30 Jun 2016 14:47:34 +0000
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAJowKg+tOoEEeVh2sh3oZbnJ3dO_h4n9eBaUeZ+ys2RPD+s2vQ@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
	<AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
	<CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>
	<CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>
	<CAJowKg+tOoEEeVh2sh3oZbnJ3dO_h4n9eBaUeZ+ys2RPD+s2vQ@mail.gmail.com>
Message-ID: <20160630144734.GR13338@dosf1.alfie.wtf>

On Thu, Jun 30, 2016 at 09:36:57AM -0400, Erik Aronesty via bitcoin-dev wrote:
> Encrypting links in a network without identity doesn't really seem to help
> enough for the costs to be justified.

Passive is still better than none.

> I would like to see a PGP-like "web of trust" proposal for both the
> security of the bitcoin network itself /and/ (eventually) of things like
> transmission of bitcoin addresses.

There already exists an unutilised WoT of "good" actors within the network -
miners via the coinbase transaction. Bootstrapping their own "trusted" pool of
IP addresses would be possible via the 100 bytes coinbase script.

> *Then* you can slap an encryption layer on top of it.   Once you have
> identity & P2P verified pub keys for nodes, encryption becomes easy.

A miner's WoT will give you this.

Alfie

-- 
Alfie John
https://www.alfie.wtf

From eric at voskuil.org  Thu Jun 30 15:10:52 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 17:10:52 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <CAPg+sBigr0BZBiuW9DYpxJ3ytZ4g30k_9B+Eb8QhQv2dC9qQUA@mail.gmail.com>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<CAAS2fgQFqHBdbym4GMAV-mdcEWR1SdGc3av0mDu65keKP9Ak6g@mail.gmail.com>
	<AB9C1C8F-7369-42CC-8551-7E03B16D5229@voskuil.org>
	<CAAS2fgT4V72vj17qTLu7pz5EQ60bqnggeDnTP5ASdwYxpuNpWw@mail.gmail.com>
	<CB6D8DF2-3EB7-4A12-8861-494D1DBC3D93@voskuil.org>
	<CAPg+sBigr0BZBiuW9DYpxJ3ytZ4g30k_9B+Eb8QhQv2dC9qQUA@mail.gmail.com>
Message-ID: <0932A659-6BE0-441F-AD05-ED846BBE7C80@voskuil.org>

Pieter, these are in my opinion very reasonable positions. I've made some observations inline.

> On Jun 30, 2016, at 3:03 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> 
> On Thu, Jun 30, 2016 at 11:57 AM, Eric Voskuil via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> The proliferation of node identity is my primary concern - this relates to privacy and the security of the network.
> 
> I think this is a reasonable concern.
> 
> However, node identity is already being used widely, and in a very
> inadvisable way:
> * Since forever there have been lists of 'good nodes' to pass in
> addnode= configuration options.
> * Various people run multiple nodes in different geographic locations,
> peering with each other.
> * Various pieces of infrastructure exist that relies on connecting to
> well-behaving nodes (miner relay networks, large players peering
> directly with each other, ...)

Yes, libbitcoin also provides these options on an IP basis.

> * Several lightweight clients support configuring a trusted host to connect to.

I explicitly exclude client-server behavior as I believe the proper resolution is to isolate clients from the P2P protocol. Libbitcoin does this already.

> Perhaps you deplore that fact, but I believe it is inevitable that different pieces of the network will make different choices here. You can't prevent people from create connections along preexisting trust lines. That does not mean that the network as a whole relies on first establishing trust everywhere.

Of course, the network operates just fine without universal trust. My concern is not that it is required, but that it may grow significantly and will have a tendency to gravitate towards more effective registration mechanisms for what is a "good" peer. Even an informal but pervasive web of trust may make it difficult for untrusted parties to connect.

> And I do think there are advantages.
> 
> BIP 151 on its own gives you opportunistic encryption. You're very right to point out that this does not give you protection from active attackers, and that active attacking is relatively easy through sybil attacks. I still prefer my attacker to actually do that over just listening in on my connection.

We agree, and the ease of this attack must be acknowledged. And given that the protection is weak it is not unreasonable to consider the potential downside of creeping node identity.

> And yes, we should also work on improving the privacy nodes and wallets have orthogonal to encryption, but nothing will make everything perfectly private.

I agree, and I doubt this proposal will have much impact on an advanced persistent threat, or even lesser threats. People should understand that there is both a risk and a limited benefit to this proposal.

> BIP 151 plus a simple optional pre-shared-secret authentication extension can improve upon pure IP-based authentication, as well as simplify things like SSL tunnels, and onion addresses purely used as identity. This will still require explicit configuration, but not more than now.

I agree - I consider tunneling the legitimate use case for this proposal. Yet when nodes become closely coupled they are not fully independent. I have a concern with these practices being promoted for general use while at the same time being strongly implemented.

> BIP 151 plus a non-leaking public key authentication scheme (where peers can query "are you the peer with pubkey X?" but don't learn anything if the answer is no) with keys specific to the IP addresses can give a TOFU-like security. Nodes already remember IP addresses they've succesfully interacted with in the past, and ban IP addresses that misbehave. Being able to tell whether a node you connect to is the same as one you've connected to before is a natural extension of this,

With this I disagree. There is no way to know that a node is one you have connected to previously unless that node wants you to know (apart from relying on the IP address). This is of no value in detecting misbehaving nodes that do not want to be detected. Ones that don't care (eg broken nodes) can be sufficiently managed by IP address.

> and does not require establishing any real-world identity beyond what we're already implicitly relying on.
> 
> Perhaps these use cases and their security assumptions should be spelled out more clearly in the BIP.

Absolutely.

> If there is a misunderstanding, it should be clearly stated that BIP 151 is only a building block for further improvements
> 
>> Secondarily I am concerned about users operating under a false assumption about the strength of privacy.
> 
> This is a widespread problem, but it exists far outside the scope of this proposal. The privacy properties of Bitcoin are often
> misrepresented and even used as advertizements. The solution is education, not avoiding improvements because they may be misunderstood.

Yes, let's not make it worse. This is a secondary concern. I remain primarily concerned about growth of node identity in a vain attempt to make transaction submission private in the P2P protocol (and to patch the other client-server features, specifically Bloom filters). As you imply, we cannot stop people from turning Bitcoin into a private network - but let's not facilitate it either.

>> The complexity of the proposed construction is comparable to that of Bitcoin itself.
> 
> I really think this is an exaggeration. It's a diffie-hellman handshake and a stream cipher (both very common constructions), that apply to individual connections. There are no consensus risks nor a
> requirement for coordinated change through the network. The
> cryptographic code can be directly reused from a well-known project
> (OpenSSH), and is very small in size.

I believe you have misinterpreted my comments on distributed anonymous credentials (and the like) as commentary on the construction of BIP151 (and a subsequent auth proposal). As such your observation that it is exaggerated would make sense, but it is not what I intended. Encryption and auth are straightforward. Preventing bad nodes from participating in an anonymous distributed system is not.

e

From eric at voskuil.org  Thu Jun 30 15:22:08 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 17:22:08 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <577513DB.60101@jonasschnelli.ch>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
	<426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
	<577513DB.60101@jonasschnelli.ch>
Message-ID: <F4BDD091-FD80-4EE9-93EF-735B6BBE253C@voskuil.org>


> On Jun 30, 2016, at 2:43 PM, Jonas Schnelli <dev at jonasschnelli.ch> wrote:
> 
>>>> The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker.
>>> 
>>> BIP151 would increase the risks for MITM attackers.
>>> What are the benefits for Mallory of he can't be sure Alice and Bob may
>>> know that he is intercepting the channel?
>> 
>> It is not clear to me why you believe an attack on privacy by an anonymous peer is detectable.
> 
> If Mallory has substituted the ephemeral keys in both directions, at the
> point where Alice and Bob will do an authentication, they can be sure
> Mallory is listening.

I understand the mechanics of a tunnel between trusting parties that have a secure side channel. But this assumes that no other peer can connect to these two nodes. How then do they maintain the chain?

The "middle" in this sense does not have to be the wire directly between these two peers. It can be between either of them and any anonymous connection they (must) allow.

Of course this creates pressure to expand their tunnel. Hence the problem of expanding node identity in an effort to preserve privacy. The protection will remain weak until the entire network is "secure". At that point it would necessarily be a private network.

As Pieter rightly observes, there are and always will be tunnels between trusting nodes. Often these are groups of nodes that are in collaboration, so logically they are one node from a system security standpoint. But if people become generally reliant on good node registration, it will become the registrar who controls access to the network. So my concern rests I this proposal becoming widely adopted.

> Simple dummy example:
> 1.) Encryption setup with ECDH with ephemeral keys after BIP151
> 2.) Mallory is MITMling the connection. He is substituting both direction with its own keys
> 3.) Connection is successfully MITMled
> 4.) Alice tells Bob "prove me that you are Bob, please sign the session-ID with your identity key"
> 5.) Bob signs the sessionID (ECDH secret) with his identity key which
> will be unusable for Mallory who has a substituted sessionID in both directions.
> 6.) Alice has successfully detected the Mallory
> 
> Disclaimer: 4) and 5) are _not_ authentication proposals :-)
> 
> </jonas>
> 

From pete at petertodd.org  Thu Jun 30 16:52:27 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 30 Jun 2016 12:52:27 -0400
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <F4BDD091-FD80-4EE9-93EF-735B6BBE253C@voskuil.org>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
	<426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
	<577513DB.60101@jonasschnelli.ch>
	<F4BDD091-FD80-4EE9-93EF-735B6BBE253C@voskuil.org>
Message-ID: <20160630165227.GA5816@fedora-21-dvm>

On Thu, Jun 30, 2016 at 05:22:08PM +0200, Eric Voskuil via bitcoin-dev wrote:
> 
> > On Jun 30, 2016, at 2:43 PM, Jonas Schnelli <dev at jonasschnelli.ch> wrote:
> > 
> >>>> The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker.
> >>> 
> >>> BIP151 would increase the risks for MITM attackers.
> >>> What are the benefits for Mallory of he can't be sure Alice and Bob may
> >>> know that he is intercepting the channel?
> >> 
> >> It is not clear to me why you believe an attack on privacy by an anonymous peer is detectable.
> > 
> > If Mallory has substituted the ephemeral keys in both directions, at the
> > point where Alice and Bob will do an authentication, they can be sure
> > Mallory is listening.
> 
> I understand the mechanics of a tunnel between trusting parties that have a secure side channel. But this assumes that no other peer can connect to these two nodes. How then do they maintain the chain?
> 
> The "middle" in this sense does not have to be the wire directly between these two peers. It can be between either of them and any anonymous connection they (must) allow.
> 
> Of course this creates pressure to expand their tunnel. Hence the problem of expanding node identity in an effort to preserve privacy. The protection will remain weak until the entire network is "secure". At that point it would necessarily be a private network.
> 
> As Pieter rightly observes, there are and always will be tunnels between trusting nodes. Often these are groups of nodes that are in collaboration, so logically they are one node from a system security standpoint. But if people become generally reliant on good node registration, it will become the registrar who controls access to the network. So my concern rests I this proposal becoming widely adopted.

To be clear, are you against Bitcoin Core's tor support?

Because node-to-node connections over tor are encrypted, and make use of onion
addresses, which are self-authenticated in the exact same way as BIP151
proposes. And we're shipping that in production as of 0.12.0, and by default
Tor onion support is enabled and will be automatically setup if you have a
recent version of Tor installed.

Does that "create pressure to expand node identity"?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160630/8a16ac69/attachment.sig>

From eric at voskuil.org  Thu Jun 30 18:25:45 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 20:25:45 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <20160630165227.GA5816@fedora-21-dvm>
References: <87h9cecad5.fsf@rustcorp.com.au>
	<1E86A00F-0609-4DBC-9543-94AE04CC13C9@voskuil.org>
	<577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
	<426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
	<577513DB.60101@jonasschnelli.ch>
	<F4BDD091-FD80-4EE9-93EF-735B6BBE253C@voskuil.org>
	<20160630165227.GA5816@fedora-21-dvm>
Message-ID: <663B51FE-D8D5-4570-ACA6-D1405D98C773@voskuil.org>



> On Jun 30, 2016, at 6:52 PM, Peter Todd <pete at petertodd.org> wrote:
> 
>> On Thu, Jun 30, 2016 at 05:22:08PM +0200, Eric Voskuil via bitcoin-dev wrote:
>> 
>>> On Jun 30, 2016, at 2:43 PM, Jonas Schnelli <dev at jonasschnelli.ch> wrote:
>>> 
>>>>>> The core problem posed by BIP151 is a MITM attack. The implied solution (BIP151 + authentication) requires that a peer trusts that another is not an attacker.
>>>>> 
>>>>> BIP151 would increase the risks for MITM attackers.
>>>>> What are the benefits for Mallory of he can't be sure Alice and Bob may
>>>>> know that he is intercepting the channel?
>>>> 
>>>> It is not clear to me why you believe an attack on privacy by an anonymous peer is detectable.
>>> 
>>> If Mallory has substituted the ephemeral keys in both directions, at the
>>> point where Alice and Bob will do an authentication, they can be sure
>>> Mallory is listening.
>> 
>> I understand the mechanics of a tunnel between trusting parties that have a secure side channel. But this assumes that no other peer can connect to these two nodes. How then do they maintain the chain?
>> 
>> The "middle" in this sense does not have to be the wire directly between these two peers. It can be between either of them and any anonymous connection they (must) allow.
>> 
>> Of course this creates pressure to expand their tunnel. Hence the problem of expanding node identity in an effort to preserve privacy. The protection will remain weak until the entire network is "secure". At that point it would necessarily be a private network.
>> 
>> As Pieter rightly observes, there are and always will be tunnels between trusting nodes. Often these are groups of nodes that are in collaboration, so logically they are one node from a system security standpoint. But if people become generally reliant on good node registration, it will become the registrar who controls access to the network. So my concern rests I this proposal becoming widely adopted.
> 
> To be clear, are you against Bitcoin Core's tor support?
> 
> Because node-to-node connections over tor are encrypted, and make use of onion
> addresses, which are self-authenticated in the exact same way as BIP151 proposes.

BIP151 is self-admittedly insufficient to protect against a MITM attack. It proposes node identity to close this hole (future BIP required). The yet-to-be-specified requirement for node identity is the basis of my primary concern. This is not self-authentication.

> And we're shipping that in production as of 0.12.0, and by default Tor onion support is enabled and will be automatically setup if you have a recent version of Tor installed.
> 
> Does that "create pressure to expand node identity"?

The orthogonal question of whether Tor is safe for use with the Bitcoin P2P protocol is a matter of existing research.

e

From pete at petertodd.org  Thu Jun 30 19:06:13 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 30 Jun 2016 15:06:13 -0400
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <663B51FE-D8D5-4570-ACA6-D1405D98C773@voskuil.org>
References: <577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
	<426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
	<577513DB.60101@jonasschnelli.ch>
	<F4BDD091-FD80-4EE9-93EF-735B6BBE253C@voskuil.org>
	<20160630165227.GA5816@fedora-21-dvm>
	<663B51FE-D8D5-4570-ACA6-D1405D98C773@voskuil.org>
Message-ID: <20160630190613.GA6758@fedora-21-dvm>

On Thu, Jun 30, 2016 at 08:25:45PM +0200, Eric Voskuil wrote:
> > To be clear, are you against Bitcoin Core's tor support?
> > 
> > Because node-to-node connections over tor are encrypted, and make use of onion
> > addresses, which are self-authenticated in the exact same way as BIP151 proposes.
> 
> BIP151 is self-admittedly insufficient to protect against a MITM attack. It proposes node identity to close this hole (future BIP required). The yet-to-be-specified requirement for node identity is the basis of my primary concern. This is not self-authentication.
> 
> > And we're shipping that in production as of 0.12.0, and by default Tor onion support is enabled and will be automatically setup if you have a recent version of Tor installed.
> > 
> > Does that "create pressure to expand node identity"?
> 
> The orthogonal question of whether Tor is safe for use with the Bitcoin P2P protocol is a matter of existing research.

I don't think you answered my question.

Again, we _already have_ the equivalent of BIP151 functionality in Bitcoin
Core, shipping in production, but implemented with a Tor dependency.

BIP151 removes that dependency on Tor, enabling encrypted connections
regardless of whether or not you have Tor installed.

So any arguments against BIP151 being implemented, are equally arguments
against our existing Tor onion support. Are you against that support? Because
if you aren't, you can't have any objections to BIP151 being implemented
either.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160630/6e23ac54/attachment.sig>

From eric at voskuil.org  Thu Jun 30 20:26:48 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 30 Jun 2016 22:26:48 +0200
Subject: [bitcoin-dev] BIP 151
In-Reply-To: <20160630190613.GA6758@fedora-21-dvm>
References: <577234A4.3030808@jonasschnelli.ch>
	<360EF9B8-A174-41CA-AFDD-2BC2C0B4DECB@voskuil.org>
	<20160629111728.GO13338@dosf1.alfie.wtf>
	<2981A919-4550-4807-8ED9-F8C51B2DC061@voskuil.org>
	<57750EAB.3020105@jonasschnelli.ch>
	<426C2AA3-BFB8-4C41-B4DF-4D6CC11988B2@voskuil.org>
	<577513DB.60101@jonasschnelli.ch>
	<F4BDD091-FD80-4EE9-93EF-735B6BBE253C@voskuil.org>
	<20160630165227.GA5816@fedora-21-dvm>
	<663B51FE-D8D5-4570-ACA6-D1405D98C773@voskuil.org>
	<20160630190613.GA6758@fedora-21-dvm>
Message-ID: <85F9E196-7D56-40DE-83A2-15255A56B115@voskuil.org>



> On Jun 30, 2016, at 9:06 PM, Peter Todd <pete at petertodd.org> wrote:
> 
> On Thu, Jun 30, 2016 at 08:25:45PM +0200, Eric Voskuil wrote:
>>> To be clear, are you against Bitcoin Core's tor support?
>>> 
>>> Because node-to-node connections over tor are encrypted, and make use of onion
>>> addresses, which are self-authenticated in the exact same way as BIP151 proposes.
>> 
>> BIP151 is self-admittedly insufficient to protect against a MITM attack. It proposes node identity to close this hole (future BIP required). The yet-to-be-specified requirement for node identity is the basis of my primary concern. This is not self-authentication.
>> 
>>> And we're shipping that in production as of 0.12.0, and by default Tor onion support is enabled and will be automatically setup if you have a recent version of Tor installed.
>>> 
>>> Does that "create pressure to expand node identity"?
>> 
>> The orthogonal question of whether Tor is safe for use with the Bitcoin P2P protocol is a matter of existing research.
> 
> I don't think you answered my question.
> 
> Again, we _already have_ the equivalent of BIP151 functionality in Bitcoin
> Core, shipping in production, but implemented with a Tor dependency.
> 
> BIP151 removes that dependency on Tor, enabling encrypted connections
> regardless of whether or not you have Tor installed.
> 
> So any arguments against BIP151 being implemented, are equally arguments
> against our existing Tor onion support. Are you against that support? Because
> if you aren't, you can't have any objections to BIP151 being implemented

Neither Tor nor Bitcoin Core are part of this BIP (or its proposed dependency on node identity).

But again, given that node identity is not part of the Bitcoin Core Tor integration, my objection to the presumption of node identity by BIP151 is unrelated to Bitcoin Core's Tor integration.

e

