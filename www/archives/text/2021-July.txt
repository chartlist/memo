From luke at dashjr.org  Thu Jul  1 05:44:17 2021
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 1 Jul 2021 05:44:17 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.21.1.knots20210629 released
Message-ID: <202107010544.27409.luke@dashjr.org>

Bitcoin Knots version 0.21.1.knots20210629 is now available from:

  https://bitcoinknots.org/files/0.21.x/0.21.1.knots20210629/

This release includes new features, various bug fixes and performance 
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  https://github.com/bitcoinknots/bitcoin/issues

To receive security and update notifications, please subscribe to:

  https://bitcoinknots.org/list/announcements/join/

For the full release notes and change log, see:

https://github.com/bitcoinknots/bitcoin/blob/v0.21.1.knots20210629/doc/release-notes.md
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210701/19d621fb/attachment.sig>

From raymo at riseup.net  Thu Jul  1 20:11:10 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Thu, 01 Jul 2021 13:11:10 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
Message-ID: <f46159f0286fe48720bc3f3fead1b575@riseup.net>

Hi Billy,
Sorry for late reply. Let?s jump in proposal.

> Some more information about the benefits of this approach vs alternatives (mainly lightning)
The most important different is unlike the lightning, in Sabu no one
have to open a channel and pay Bitcoin transaction fee, subsequently no
one has to close channel and pay another Bitcoin transaction fee. It is
the huge improvement since it drops the overhead cost of transactions.
So, it will be more convenience to trade under Sabu protocol. 
In Sabu none of parties of a transaction are obliged to block money in
any kind of smart contract or any other m of n signature accounts
on-chain, so it provides more privacy. 
Since Sabu protocol is designed to motivate people to circulate
transactions (AKA debt documents) in Sabu network, if every actor act
rationally no one will aware how much money transferred from who to
whom. 
In case of fraudulent activity by issuer, the creditor will send
Guarantee Transaction (GT) to Bitcoin network in order to recapture the
part of his credit. So, in this case the transaction is literally
recorded on bitcoin blockchain.
There is only one another reason to recording transaction on Bitcoin
blockchain. Where one creditor eager to pay Bitcoin transaction fee in
order to aggregate thousands or even millions different small amount
debt-documents in a single transaction on Bitcoin blockchain.
despite these two cases, the rest of transactions all occur in the Sabu
network (supposed to be over 99%). Thus, no footprint no bottleneck and
no over process.

Another important power point of Sabu is its pure-peer-to-peer network
architecture. In Sabu the mobile wallets communicating to each other
directly without any central server. There is no centralization at all.
As a result, there will be no routing as well. 
Since only issuer and creditors are aware of the content of transaction
(who pay how much to whom) it is a huge privacy improvement, which
doesn?t exist in other layer 2 solutions. 

About the usability of Sabu, although the protocol based on the
collaborating 2 different peer-to-peer network and 3 classic
server/client networks, but the end user (mobile wallet user) doesn?t
see any of these complexities. 
The end user simply installs the mobile/desktop wallet and add her/his
friends to his phonebook by adding their email address or scanning their
email (and/or PGP public key). After that s/he can immediately start to
send/receive Bitcoin through Sabu network. Entire communications between
wallets are PGP encrypted. 
Another good point in Sabu design is, the 12 seed words are using for
both Bitcoin wallet private key and the PGP private key. So, it is the
key of user wealth and its identity as well. For more details, please
read my previous answer to Alex Schoof. 
The issuer, by using his UTXOs and selling them to creditors earn money.
the issuer creates the debt document (transaction) by which promises to
creditor an amount of satoshi. These debt documents are valid Bitcoin
transaction. The only difference is these transactions are intended to
circulate in Sabu protocol instead of sending to Bitcoin blockchain.  
Each transaction is a small money transfer. 40,000 Satoshi as input and
maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as Bitcoin
transaction fee.
The creditors will use these received transactions as money and will pay
it in exchange of goods or services. For each transaction the creditor
pays 10 Satoshi as Sabu-transaction-fee to issuer. 
Sabu is not custodial service and the UXTOs are always under issuer
control, unless issuer or creditor send the signed transaction to
Bitcoin network. When the transaction was recorded in Bitcoin
blockchain, the creditor can spend proper UTXO in Bitcoin network.
Imagine million people use their UTXOs in Sabu, they are issuer and
issue/update/cancel million transactions per second. All they need is a
mobile wallet. On the other hand, every one by knowing an issuer can buy
some Satoshi (whit absolutely no KYC), even 1 Dollar or less, and spend
it, this time Alice really can buy caffe by Bitcoin ;)
The Bar can install the mobile wallet and every day receives thousands
of debt documents (transactions), each worth maximum 20,000 Satoshi in
exchange of coffee. And every evening aggregates those small
transactions to one single transaction and send it to Bitcoin network. 


The security model of Sabu is pretty straight forward. 
Issuer is the owner of UTXO(s) which will be used in transactions. The
issuer is and will the only person who creates transactions and sign
them. The transactions are valid transaction which either issuer or
creditor can send them to Bitcoin network, but they will never send
these transactions to Bitcoin network, because of the high Bitcoin
transaction fee for each single transaction. 
Since issuer is the only one who can sign transaction (spend UTXOs),
there is a risk of issuer cheating. And no one can stop issuer from
cheating, because these are his UTXOs and he has the proper private
keys. 
The Sabu solution is Guarantee transaction. It is a valid transaction
that issuer has to sign it alongside the Main transaction. In GT both
issuer and creditor cut a part of their output in favor of Bitcoin
transaction fee. 
We suppose miners always seeking for more profit, thus in a case there
are 2 or more transaction are spending same UTXO as input, miner will
choose transaction with highest feeRate. There is no economically
benefit for issuer to cheat creditors and pay less transaction fee
simultaneously. So rationally the issuer won?t cheat creditor.
It was the simplest explanation of Sabu security model.

> I agree with others that using email is probably not appropriate for a protocol like this. I would highly recommend making your protocol transport-agnostic, allowing users of your protocol to use any transport they want.
Indeed, the protocol is transparent-agnostic, if I insist of email as a
user identifier and communicating tool is because of the idea of
reforming part of internet architecture and make it more decentralized.
The wallet users can choose classic architecture. In this case mobile
wallets will connect to a central server and communicate through that
server (pretty much like all existed mobile wallets). While some users
decide to use a pure peer-to-peer communication. I knew email has some
privacy issues but as always it is a tradeoff. Users can decide between
an unstoppable, permission less, self-sovereignty and decentralized pure
peer-to-peer communication network (with some resolvable privacy issues)
or some efficient central limited network. 
Let me know the critics about email. Hopefully this would lead us to
improve email instead of letting it die. I strongly suggest email
because it is the ONLY neutral, free ?nonproprietary? and open
protocol/technology for communication in the world that its
infrastructure is well-established and is accessible all over the glob.

I tried to explain it more, hope was useful. By the way the complete
explanation is here
https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180



Regards
Raymo 



On 2021-06-22 18:20, Billy Tetrud wrote:
> I would be interested in seeing some more information about the
> benefits of this approach vs alternatives up front in this write up.
> Eg how does the security, cost, usability, and privacy compare to the
> lightning network, which would be the most likely competitor to this
> idea. It seems clear that there is more counterparty risk here, so it
> would probably also be very helpful to compare against traditional
> custodial solutions as well. If you have specific claims on how this
> system is better than eg lightning in certain contexts, it would be
> far easier to evaluate the protocol against those claims, and would
> also be a lot easier for readers to be motivated to read the whole
> protocol and do a more full analysis. 
> 
> I agree with others that using email is probably not appropriate for a
> protocol like this. I would highly recommend making your protocol
> transport-agnostic, allowing users of your protocol to use any
> transport they want. 
> 
> On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> I think you're making a number of assumptions about mining that are
>> not accurate.
>>
>>> First of all, how much chance in finding next block the corrupted
>> miners have? One percent of all Bitcoin hash powers? Or maximum 5
>> percent or 10? The cheaters must come up in dividing that 1.2
>> Bitcoin between. After all the risk/reward must fit them. They can
>> not be a big mining pool since there is no benefit, so they will be
>> small miners with low hash rate. If they solve the puzzle and
>> broadcast the block, no one in the entire Bitcoin network has block
>> transactions or seen it before in their mempool!
>>
>> You're making the assumption that miners won't build on top of a
>> block
>> with transactions they have not seen before or transactions that may
>> contain double spends of unconfirmed inputs, this is not how mining
>> works, as long as the block passes the consensus rules effectively
>> all
>> miners will mine on top of it by default, this behavior is
>> fundamental
>> to how mining currently works and is fairly deeply baked into the
>> current mining infrastructure.
>>
>>> Will they accept this block? In theory it is possible and have
>> 0.01 percent chance but we can eliminate this small possibilities by
>> a simple BIP for miners.
>>
>> What would this BIP look like? I don't see how this could work in a
>> decentralized way as you would need another way of reaching
>> consensus
>> on what defines a valid block. Right now the chance is nearly 100
>> percent that a miner will mine on top of the latest valid block,
>> many
>> pools(most last I checked) will even mine on the next block before
>> they validate the latest block fully(ie validationless mining) to
>> reduce their orphan rates.
>>
>>> We suppose the miners always control transactions with
>> doc-watchers and avoid accepting transaction with same UTXO but
>> different output.
>>
>> Miners have different mempool policy/rules for what transactions
>> they
>> themselves mine but all miners must mine on the most work chain of
>> valid blocks otherwise they risk their own blocks being orphaned,
>> any
>> miner that does not do this is effectively guaranteed to have their
>> block orphaned right now.
>>
>>> Because of high Bitcoin transaction fee, this guarantee
>> transaction will take place in next block, even if other transaction
>> which are using the same UTXO as input existed in mempool.
>>
>> When a new transaction is broadcast miners do not immediately start
>> mining on a block template that includes that transaction, the
>> template won't even be generated immediately when it enters a miners
>> mempool in practice, for bandwidth/network efficiency reasons mining
>> pools batch update the stratum templates/jobs they mine against so
>> there can be significant latency between the time a transaction is
>> actually broadcast and hits the miners mempool and the time the
>> miners
>> actually switch to mining on top it, these batched updates are
>> essentially like point in time snapshots of the mempool and
>> typically
>> remain valid(as in the pool will accept shares submitted against
>> that
>> job as valid) until the bitcoin network finds the next block. I
>> don't
>> think these batch updates are done more often than every 30 seconds
>> typically, while often it is on the order of multiple minutes
>> depending on the pool.
>>
>> Regards,
>> James
>>
>> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> Hi,
>>> I have a proposal for improve Bitcoin TPS and privacy, here is the
>> post.
>>>
>>
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>>> https://bitcointalk.org/index.php?topic=5344020.0
>>> Can you please read it and share your idea about it.
>>>
>>> Cheers
>>> Raymo
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From erik at q32.com  Thu Jul  1 20:49:16 2021
From: erik at q32.com (Erik Aronesty)
Date: Thu, 1 Jul 2021 16:49:16 -0400
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <f46159f0286fe48720bc3f3fead1b575@riseup.net>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
Message-ID: <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>

your protocol should always assume the email system is fully
compromised, and only send public information over email:

- public keys / addresses are sent
- other routing data encrypted with public keys (not sure how data is
routed in sabu)

your end user should be able to verify public keys  / addresses

 - use QR-codes
 - phone calls with users reading BIP words out loud
 - other in-person information exchange

separate the Sabu protocol from the app... allow others to implement
desktop version, or other versions that use other routing systems

-  you can allow direct-entry of a BIP-word-representation of a public
key/address to avoid privacy/central system concerns

On Thu, Jul 1, 2021 at 4:20 PM raymo via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi Billy,
> Sorry for late reply. Let?s jump in proposal.
>
> > Some more information about the benefits of this approach vs alternatives (mainly lightning)
> The most important different is unlike the lightning, in Sabu no one
> have to open a channel and pay Bitcoin transaction fee, subsequently no
> one has to close channel and pay another Bitcoin transaction fee. It is
> the huge improvement since it drops the overhead cost of transactions.
> So, it will be more convenience to trade under Sabu protocol.
> In Sabu none of parties of a transaction are obliged to block money in
> any kind of smart contract or any other m of n signature accounts
> on-chain, so it provides more privacy.
> Since Sabu protocol is designed to motivate people to circulate
> transactions (AKA debt documents) in Sabu network, if every actor act
> rationally no one will aware how much money transferred from who to
> whom.
> In case of fraudulent activity by issuer, the creditor will send
> Guarantee Transaction (GT) to Bitcoin network in order to recapture the
> part of his credit. So, in this case the transaction is literally
> recorded on bitcoin blockchain.
> There is only one another reason to recording transaction on Bitcoin
> blockchain. Where one creditor eager to pay Bitcoin transaction fee in
> order to aggregate thousands or even millions different small amount
> debt-documents in a single transaction on Bitcoin blockchain.
> despite these two cases, the rest of transactions all occur in the Sabu
> network (supposed to be over 99%). Thus, no footprint no bottleneck and
> no over process.
>
> Another important power point of Sabu is its pure-peer-to-peer network
> architecture. In Sabu the mobile wallets communicating to each other
> directly without any central server. There is no centralization at all.
> As a result, there will be no routing as well.
> Since only issuer and creditors are aware of the content of transaction
> (who pay how much to whom) it is a huge privacy improvement, which
> doesn?t exist in other layer 2 solutions.
>
> About the usability of Sabu, although the protocol based on the
> collaborating 2 different peer-to-peer network and 3 classic
> server/client networks, but the end user (mobile wallet user) doesn?t
> see any of these complexities.
> The end user simply installs the mobile/desktop wallet and add her/his
> friends to his phonebook by adding their email address or scanning their
> email (and/or PGP public key). After that s/he can immediately start to
> send/receive Bitcoin through Sabu network. Entire communications between
> wallets are PGP encrypted.
> Another good point in Sabu design is, the 12 seed words are using for
> both Bitcoin wallet private key and the PGP private key. So, it is the
> key of user wealth and its identity as well. For more details, please
> read my previous answer to Alex Schoof.
> The issuer, by using his UTXOs and selling them to creditors earn money.
> the issuer creates the debt document (transaction) by which promises to
> creditor an amount of satoshi. These debt documents are valid Bitcoin
> transaction. The only difference is these transactions are intended to
> circulate in Sabu protocol instead of sending to Bitcoin blockchain.
> Each transaction is a small money transfer. 40,000 Satoshi as input and
> maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as Bitcoin
> transaction fee.
> The creditors will use these received transactions as money and will pay
> it in exchange of goods or services. For each transaction the creditor
> pays 10 Satoshi as Sabu-transaction-fee to issuer.
> Sabu is not custodial service and the UXTOs are always under issuer
> control, unless issuer or creditor send the signed transaction to
> Bitcoin network. When the transaction was recorded in Bitcoin
> blockchain, the creditor can spend proper UTXO in Bitcoin network.
> Imagine million people use their UTXOs in Sabu, they are issuer and
> issue/update/cancel million transactions per second. All they need is a
> mobile wallet. On the other hand, every one by knowing an issuer can buy
> some Satoshi (whit absolutely no KYC), even 1 Dollar or less, and spend
> it, this time Alice really can buy caffe by Bitcoin ;)
> The Bar can install the mobile wallet and every day receives thousands
> of debt documents (transactions), each worth maximum 20,000 Satoshi in
> exchange of coffee. And every evening aggregates those small
> transactions to one single transaction and send it to Bitcoin network.
>
>
> The security model of Sabu is pretty straight forward.
> Issuer is the owner of UTXO(s) which will be used in transactions. The
> issuer is and will the only person who creates transactions and sign
> them. The transactions are valid transaction which either issuer or
> creditor can send them to Bitcoin network, but they will never send
> these transactions to Bitcoin network, because of the high Bitcoin
> transaction fee for each single transaction.
> Since issuer is the only one who can sign transaction (spend UTXOs),
> there is a risk of issuer cheating. And no one can stop issuer from
> cheating, because these are his UTXOs and he has the proper private
> keys.
> The Sabu solution is Guarantee transaction. It is a valid transaction
> that issuer has to sign it alongside the Main transaction. In GT both
> issuer and creditor cut a part of their output in favor of Bitcoin
> transaction fee.
> We suppose miners always seeking for more profit, thus in a case there
> are 2 or more transaction are spending same UTXO as input, miner will
> choose transaction with highest feeRate. There is no economically
> benefit for issuer to cheat creditors and pay less transaction fee
> simultaneously. So rationally the issuer won?t cheat creditor.
> It was the simplest explanation of Sabu security model.
>
> > I agree with others that using email is probably not appropriate for a protocol like this. I would highly recommend making your protocol transport-agnostic, allowing users of your protocol to use any transport they want.
> Indeed, the protocol is transparent-agnostic, if I insist of email as a
> user identifier and communicating tool is because of the idea of
> reforming part of internet architecture and make it more decentralized.
> The wallet users can choose classic architecture. In this case mobile
> wallets will connect to a central server and communicate through that
> server (pretty much like all existed mobile wallets). While some users
> decide to use a pure peer-to-peer communication. I knew email has some
> privacy issues but as always it is a tradeoff. Users can decide between
> an unstoppable, permission less, self-sovereignty and decentralized pure
> peer-to-peer communication network (with some resolvable privacy issues)
> or some efficient central limited network.
> Let me know the critics about email. Hopefully this would lead us to
> improve email instead of letting it die. I strongly suggest email
> because it is the ONLY neutral, free ?nonproprietary? and open
> protocol/technology for communication in the world that its
> infrastructure is well-established and is accessible all over the glob.
>
> I tried to explain it more, hope was useful. By the way the complete
> explanation is here
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>
>
>
> Regards
> Raymo
>
>
>
> On 2021-06-22 18:20, Billy Tetrud wrote:
> > I would be interested in seeing some more information about the
> > benefits of this approach vs alternatives up front in this write up.
> > Eg how does the security, cost, usability, and privacy compare to the
> > lightning network, which would be the most likely competitor to this
> > idea. It seems clear that there is more counterparty risk here, so it
> > would probably also be very helpful to compare against traditional
> > custodial solutions as well. If you have specific claims on how this
> > system is better than eg lightning in certain contexts, it would be
> > far easier to evaluate the protocol against those claims, and would
> > also be a lot easier for readers to be motivated to read the whole
> > protocol and do a more full analysis.
> >
> > I agree with others that using email is probably not appropriate for a
> > protocol like this. I would highly recommend making your protocol
> > transport-agnostic, allowing users of your protocol to use any
> > transport they want.
> >
> > On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >> I think you're making a number of assumptions about mining that are
> >> not accurate.
> >>
> >>> First of all, how much chance in finding next block the corrupted
> >> miners have? One percent of all Bitcoin hash powers? Or maximum 5
> >> percent or 10? The cheaters must come up in dividing that 1.2
> >> Bitcoin between. After all the risk/reward must fit them. They can
> >> not be a big mining pool since there is no benefit, so they will be
> >> small miners with low hash rate. If they solve the puzzle and
> >> broadcast the block, no one in the entire Bitcoin network has block
> >> transactions or seen it before in their mempool!
> >>
> >> You're making the assumption that miners won't build on top of a
> >> block
> >> with transactions they have not seen before or transactions that may
> >> contain double spends of unconfirmed inputs, this is not how mining
> >> works, as long as the block passes the consensus rules effectively
> >> all
> >> miners will mine on top of it by default, this behavior is
> >> fundamental
> >> to how mining currently works and is fairly deeply baked into the
> >> current mining infrastructure.
> >>
> >>> Will they accept this block? In theory it is possible and have
> >> 0.01 percent chance but we can eliminate this small possibilities by
> >> a simple BIP for miners.
> >>
> >> What would this BIP look like? I don't see how this could work in a
> >> decentralized way as you would need another way of reaching
> >> consensus
> >> on what defines a valid block. Right now the chance is nearly 100
> >> percent that a miner will mine on top of the latest valid block,
> >> many
> >> pools(most last I checked) will even mine on the next block before
> >> they validate the latest block fully(ie validationless mining) to
> >> reduce their orphan rates.
> >>
> >>> We suppose the miners always control transactions with
> >> doc-watchers and avoid accepting transaction with same UTXO but
> >> different output.
> >>
> >> Miners have different mempool policy/rules for what transactions
> >> they
> >> themselves mine but all miners must mine on the most work chain of
> >> valid blocks otherwise they risk their own blocks being orphaned,
> >> any
> >> miner that does not do this is effectively guaranteed to have their
> >> block orphaned right now.
> >>
> >>> Because of high Bitcoin transaction fee, this guarantee
> >> transaction will take place in next block, even if other transaction
> >> which are using the same UTXO as input existed in mempool.
> >>
> >> When a new transaction is broadcast miners do not immediately start
> >> mining on a block template that includes that transaction, the
> >> template won't even be generated immediately when it enters a miners
> >> mempool in practice, for bandwidth/network efficiency reasons mining
> >> pools batch update the stratum templates/jobs they mine against so
> >> there can be significant latency between the time a transaction is
> >> actually broadcast and hits the miners mempool and the time the
> >> miners
> >> actually switch to mining on top it, these batched updates are
> >> essentially like point in time snapshots of the mempool and
> >> typically
> >> remain valid(as in the pool will accept shares submitted against
> >> that
> >> job as valid) until the bitcoin network finds the next block. I
> >> don't
> >> think these batch updates are done more often than every 30 seconds
> >> typically, while often it is on the order of multiple minutes
> >> depending on the pool.
> >>
> >> Regards,
> >> James
> >>
> >> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>
> >>> Hi,
> >>> I have a proposal for improve Bitcoin TPS and privacy, here is the
> >> post.
> >>>
> >>
> > https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
> >>> https://bitcointalk.org/index.php?topic=5344020.0
> >>> Can you please read it and share your idea about it.
> >>>
> >>> Cheers
> >>> Raymo
> >>> _______________________________________________
> >>> bitcoin-dev mailing list
> >>> bitcoin-dev at lists.linuxfoundation.org
> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From raymo at riseup.net  Thu Jul  1 22:15:13 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Thu, 01 Jul 2021 15:15:13 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
Message-ID: <d8b3ba5b940473165ad72d689a01602a@riseup.net>


Hi Erik

Please correct me if I misunderstood.

> email is fully compromised. 

What I got is:
Email is not good because the sender and receiver are compromised.
Email is not good because the message content is revealed.
I can claim same argue about any other client/server model. Since the
server (website) service provider will ask some sort of KYC. And even if
the server uses end-to-end encryption, the provider company still can
read the packets content.
In my model the passive listener only can discover who is communicate to
whom and make a graph of connections. Although it is a threat for
privacy but the server/client model has this flaw inherently, since
provider already knew everything about everyone. In my model at least
users can make some fake connections and send some fake emails in order
to inject noise to communications.
Please note the fact that entire communication between mobile wallets
(via emails) are asymmetric PGP encrypted. The PGP keys are controlled
by end users unlike ALL pretending secure messengers (e.g whatsApp,
signal, zoom,?).
If you are worried about the way of exchanging PGP public key, you are
right. The most secure way is in-person PGP key exchanging.
After that for payments the wallets communicate in pgp encrypted
messages and they can transfer Bitcoin address through an PGP encrypted
cipher, thus no revealing Bitcoin address to public would occur. Neither
the amounts of transactions will be reviled. 
There for it would be a good practice for shops to put their email and
PGP public key on shop website and/or PGP public key servers, instead of
putting Bitcoin address on website or using 3rd parties services to hide
their Bitcoin payment addresses.

If I missed some points about ?fully compromised? please write it to me.


> public keys / addresses are sent
As I told before ALL communication in Sabu are PGP encrypted.

> other routing data encrypted with public keys 
>(not sure how data is routed in sabu)

Sabu is not responsible for routing at all. It simply sends emails.
Indeed the wallets peer-to-peer network in Sabu is pretty straight
forward. Each mobile wallet has one email address as its handler and
identifier in mobile-wallets-network. Each mobile can send message to
another mobile by knowing its email address and the PGP public key. 
This information can be prepared in first face-to-face contact of mobile
owners, or later (something like signing the other?s public key in web
of trust) when a creditor wants to spend his money and transfer it to
another creditor. The creditor1 send the signed money transfer request
alongside the email and public key of creditor2 all in a PGP encrypted
message to issuer.



> separate the Sabu protocol from the app... allow others to implement 
> desktop version, or other versions that use other routing systems

Indeed, it is my approach too. As I told before users will decide
between an unstoppable, permission less, self-sovereignty and
decentralized pure peer-to-peer communication network (with some
resolvable privacy issues) or some efficient, privacy-mimic central
limited network. 


> you can allow direct-entry of a BIP-word-representation 
> of a public key/address to avoid privacy/central system concerns
Agree. Actually, I was thinking about an easy mechanism to share your
public key like what you suggested here. 
But what I consider for a ?central system concerns? is the ability of
communication without dependency to any company. 
As an example, what can you do if the twitter bans your account?
Nothing! Your content and entire connections will be lost. 
But if you form your friends list in your mobile (or computer) and have
their PGP public keys and they have yours, and use email as a dual
purpose tool. First as a handler (the tool for finding and to be found
in internet) and second as a communication tool.
Thus, no one can stop you, ban you or limit you to send/receive
transaction to/from anyone. 
What I am trying to say is using email is far better than account
(username) in a limited central service like twitter, Facebook,
telegram... or even in future Sabu servers!
You have your connections under your control in your phone. You can
easily change your email and use a new email or even a new service
provider without losing your connections and your control over it. 
You just sign your new email address and send it to your friends circle
and notify them about changes. 
Of course, email is not good for millions of followers but it is
obviously good for managing your payment network of hundreds of people
(either issuers or creditors).

Best
Raymo

On 2021-07-01 20:49, Erik Aronesty wrote:
> your protocol should always assume the email system is fully
> compromised, and only send public information over email:
> 
> - public keys / addresses are sent
> - other routing data encrypted with public keys (not sure how data is
> routed in sabu)
> 
> your end user should be able to verify public keys  / addresses
> 
>  - use QR-codes
>  - phone calls with users reading BIP words out loud
>  - other in-person information exchange
> 
> separate the Sabu protocol from the app... allow others to implement
> desktop version, or other versions that use other routing systems
> 
> -  you can allow direct-entry of a BIP-word-representation of a public
> key/address to avoid privacy/central system concerns
> 
> On Thu, Jul 1, 2021 at 4:20 PM raymo via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Hi Billy,
>> Sorry for late reply. Let?s jump in proposal.
>>
>> > Some more information about the benefits of this approach vs alternatives (mainly lightning)
>> The most important different is unlike the lightning, in Sabu no one
>> have to open a channel and pay Bitcoin transaction fee, subsequently no
>> one has to close channel and pay another Bitcoin transaction fee. It is
>> the huge improvement since it drops the overhead cost of transactions.
>> So, it will be more convenience to trade under Sabu protocol.
>> In Sabu none of parties of a transaction are obliged to block money in
>> any kind of smart contract or any other m of n signature accounts
>> on-chain, so it provides more privacy.
>> Since Sabu protocol is designed to motivate people to circulate
>> transactions (AKA debt documents) in Sabu network, if every actor act
>> rationally no one will aware how much money transferred from who to
>> whom.
>> In case of fraudulent activity by issuer, the creditor will send
>> Guarantee Transaction (GT) to Bitcoin network in order to recapture the
>> part of his credit. So, in this case the transaction is literally
>> recorded on bitcoin blockchain.
>> There is only one another reason to recording transaction on Bitcoin
>> blockchain. Where one creditor eager to pay Bitcoin transaction fee in
>> order to aggregate thousands or even millions different small amount
>> debt-documents in a single transaction on Bitcoin blockchain.
>> despite these two cases, the rest of transactions all occur in the Sabu
>> network (supposed to be over 99%). Thus, no footprint no bottleneck and
>> no over process.
>>
>> Another important power point of Sabu is its pure-peer-to-peer network
>> architecture. In Sabu the mobile wallets communicating to each other
>> directly without any central server. There is no centralization at all.
>> As a result, there will be no routing as well.
>> Since only issuer and creditors are aware of the content of transaction
>> (who pay how much to whom) it is a huge privacy improvement, which
>> doesn?t exist in other layer 2 solutions.
>>
>> About the usability of Sabu, although the protocol based on the
>> collaborating 2 different peer-to-peer network and 3 classic
>> server/client networks, but the end user (mobile wallet user) doesn?t
>> see any of these complexities.
>> The end user simply installs the mobile/desktop wallet and add her/his
>> friends to his phonebook by adding their email address or scanning their
>> email (and/or PGP public key). After that s/he can immediately start to
>> send/receive Bitcoin through Sabu network. Entire communications between
>> wallets are PGP encrypted.
>> Another good point in Sabu design is, the 12 seed words are using for
>> both Bitcoin wallet private key and the PGP private key. So, it is the
>> key of user wealth and its identity as well. For more details, please
>> read my previous answer to Alex Schoof.
>> The issuer, by using his UTXOs and selling them to creditors earn money.
>> the issuer creates the debt document (transaction) by which promises to
>> creditor an amount of satoshi. These debt documents are valid Bitcoin
>> transaction. The only difference is these transactions are intended to
>> circulate in Sabu protocol instead of sending to Bitcoin blockchain.
>> Each transaction is a small money transfer. 40,000 Satoshi as input and
>> maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as Bitcoin
>> transaction fee.
>> The creditors will use these received transactions as money and will pay
>> it in exchange of goods or services. For each transaction the creditor
>> pays 10 Satoshi as Sabu-transaction-fee to issuer.
>> Sabu is not custodial service and the UXTOs are always under issuer
>> control, unless issuer or creditor send the signed transaction to
>> Bitcoin network. When the transaction was recorded in Bitcoin
>> blockchain, the creditor can spend proper UTXO in Bitcoin network.
>> Imagine million people use their UTXOs in Sabu, they are issuer and
>> issue/update/cancel million transactions per second. All they need is a
>> mobile wallet. On the other hand, every one by knowing an issuer can buy
>> some Satoshi (whit absolutely no KYC), even 1 Dollar or less, and spend
>> it, this time Alice really can buy caffe by Bitcoin ;)
>> The Bar can install the mobile wallet and every day receives thousands
>> of debt documents (transactions), each worth maximum 20,000 Satoshi in
>> exchange of coffee. And every evening aggregates those small
>> transactions to one single transaction and send it to Bitcoin network.
>>
>>
>> The security model of Sabu is pretty straight forward.
>> Issuer is the owner of UTXO(s) which will be used in transactions. The
>> issuer is and will the only person who creates transactions and sign
>> them. The transactions are valid transaction which either issuer or
>> creditor can send them to Bitcoin network, but they will never send
>> these transactions to Bitcoin network, because of the high Bitcoin
>> transaction fee for each single transaction.
>> Since issuer is the only one who can sign transaction (spend UTXOs),
>> there is a risk of issuer cheating. And no one can stop issuer from
>> cheating, because these are his UTXOs and he has the proper private
>> keys.
>> The Sabu solution is Guarantee transaction. It is a valid transaction
>> that issuer has to sign it alongside the Main transaction. In GT both
>> issuer and creditor cut a part of their output in favor of Bitcoin
>> transaction fee.
>> We suppose miners always seeking for more profit, thus in a case there
>> are 2 or more transaction are spending same UTXO as input, miner will
>> choose transaction with highest feeRate. There is no economically
>> benefit for issuer to cheat creditors and pay less transaction fee
>> simultaneously. So rationally the issuer won?t cheat creditor.
>> It was the simplest explanation of Sabu security model.
>>
>> > I agree with others that using email is probably not appropriate for a protocol like this. I would highly recommend making your protocol transport-agnostic, allowing users of your protocol to use any transport they want.
>> Indeed, the protocol is transparent-agnostic, if I insist of email as a
>> user identifier and communicating tool is because of the idea of
>> reforming part of internet architecture and make it more decentralized.
>> The wallet users can choose classic architecture. In this case mobile
>> wallets will connect to a central server and communicate through that
>> server (pretty much like all existed mobile wallets). While some users
>> decide to use a pure peer-to-peer communication. I knew email has some
>> privacy issues but as always it is a tradeoff. Users can decide between
>> an unstoppable, permission less, self-sovereignty and decentralized pure
>> peer-to-peer communication network (with some resolvable privacy issues)
>> or some efficient central limited network.
>> Let me know the critics about email. Hopefully this would lead us to
>> improve email instead of letting it die. I strongly suggest email
>> because it is the ONLY neutral, free ?nonproprietary? and open
>> protocol/technology for communication in the world that its
>> infrastructure is well-established and is accessible all over the glob.
>>
>> I tried to explain it more, hope was useful. By the way the complete
>> explanation is here
>> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>>
>>
>>
>> Regards
>> Raymo
>>
>>
>>
>> On 2021-06-22 18:20, Billy Tetrud wrote:
>> > I would be interested in seeing some more information about the
>> > benefits of this approach vs alternatives up front in this write up.
>> > Eg how does the security, cost, usability, and privacy compare to the
>> > lightning network, which would be the most likely competitor to this
>> > idea. It seems clear that there is more counterparty risk here, so it
>> > would probably also be very helpful to compare against traditional
>> > custodial solutions as well. If you have specific claims on how this
>> > system is better than eg lightning in certain contexts, it would be
>> > far easier to evaluate the protocol against those claims, and would
>> > also be a lot easier for readers to be motivated to read the whole
>> > protocol and do a more full analysis.
>> >
>> > I agree with others that using email is probably not appropriate for a
>> > protocol like this. I would highly recommend making your protocol
>> > transport-agnostic, allowing users of your protocol to use any
>> > transport they want.
>> >
>> > On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
>> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >
>> >> I think you're making a number of assumptions about mining that are
>> >> not accurate.
>> >>
>> >>> First of all, how much chance in finding next block the corrupted
>> >> miners have? One percent of all Bitcoin hash powers? Or maximum 5
>> >> percent or 10? The cheaters must come up in dividing that 1.2
>> >> Bitcoin between. After all the risk/reward must fit them. They can
>> >> not be a big mining pool since there is no benefit, so they will be
>> >> small miners with low hash rate. If they solve the puzzle and
>> >> broadcast the block, no one in the entire Bitcoin network has block
>> >> transactions or seen it before in their mempool!
>> >>
>> >> You're making the assumption that miners won't build on top of a
>> >> block
>> >> with transactions they have not seen before or transactions that may
>> >> contain double spends of unconfirmed inputs, this is not how mining
>> >> works, as long as the block passes the consensus rules effectively
>> >> all
>> >> miners will mine on top of it by default, this behavior is
>> >> fundamental
>> >> to how mining currently works and is fairly deeply baked into the
>> >> current mining infrastructure.
>> >>
>> >>> Will they accept this block? In theory it is possible and have
>> >> 0.01 percent chance but we can eliminate this small possibilities by
>> >> a simple BIP for miners.
>> >>
>> >> What would this BIP look like? I don't see how this could work in a
>> >> decentralized way as you would need another way of reaching
>> >> consensus
>> >> on what defines a valid block. Right now the chance is nearly 100
>> >> percent that a miner will mine on top of the latest valid block,
>> >> many
>> >> pools(most last I checked) will even mine on the next block before
>> >> they validate the latest block fully(ie validationless mining) to
>> >> reduce their orphan rates.
>> >>
>> >>> We suppose the miners always control transactions with
>> >> doc-watchers and avoid accepting transaction with same UTXO but
>> >> different output.
>> >>
>> >> Miners have different mempool policy/rules for what transactions
>> >> they
>> >> themselves mine but all miners must mine on the most work chain of
>> >> valid blocks otherwise they risk their own blocks being orphaned,
>> >> any
>> >> miner that does not do this is effectively guaranteed to have their
>> >> block orphaned right now.
>> >>
>> >>> Because of high Bitcoin transaction fee, this guarantee
>> >> transaction will take place in next block, even if other transaction
>> >> which are using the same UTXO as input existed in mempool.
>> >>
>> >> When a new transaction is broadcast miners do not immediately start
>> >> mining on a block template that includes that transaction, the
>> >> template won't even be generated immediately when it enters a miners
>> >> mempool in practice, for bandwidth/network efficiency reasons mining
>> >> pools batch update the stratum templates/jobs they mine against so
>> >> there can be significant latency between the time a transaction is
>> >> actually broadcast and hits the miners mempool and the time the
>> >> miners
>> >> actually switch to mining on top it, these batched updates are
>> >> essentially like point in time snapshots of the mempool and
>> >> typically
>> >> remain valid(as in the pool will accept shares submitted against
>> >> that
>> >> job as valid) until the bitcoin network finds the next block. I
>> >> don't
>> >> think these batch updates are done more often than every 30 seconds
>> >> typically, while often it is on the order of multiple minutes
>> >> depending on the pool.
>> >>
>> >> Regards,
>> >> James
>> >>
>> >> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
>> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> >>>
>> >>> Hi,
>> >>> I have a proposal for improve Bitcoin TPS and privacy, here is the
>> >> post.
>> >>>
>> >>
>> > https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>> >>> https://bitcointalk.org/index.php?topic=5344020.0
>> >>> Can you please read it and share your idea about it.
>> >>>
>> >>> Cheers
>> >>> Raymo
>> >>> _______________________________________________
>> >>> bitcoin-dev mailing list
>> >>> bitcoin-dev at lists.linuxfoundation.org
>> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> >> _______________________________________________
>> >> bitcoin-dev mailing list
>> >> bitcoin-dev at lists.linuxfoundation.org
>> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From billy.tetrud at gmail.com  Fri Jul  2 17:57:54 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Fri, 2 Jul 2021 10:57:54 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <d8b3ba5b940473165ad72d689a01602a@riseup.net>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
Message-ID: <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>

Thanks for the details Raymo. A thought occurred to me. Given the fact that
miners can abuse this system without penalty, it would be useful to be able
to fix this. What if it was possible for the creditor to claw back the
funds even if the cheating transaction was mined instead of the guarantee
transaction? Let's say there was a way to sign a transaction that gives the
receiver of that transaction the ability to override any other transaction
that uses the UTXO? If this were possible, the issuer could give the
creditor this kind of transaction as the guarantee transaction, and in the
case a cheat was done, the creditor could still use the GT to reallocate
that UTXO to themselves.

Now there are issues with this. First of all, it could give anyone the
ability to double spend. So it would be prudent to limit this in some way.
The revocation probably should only be valid for up to 6 blocks, such that
if the transaction has 6 confirmations, it can no longer be reallocated
(thus preserving the 6 block finality rule). It could also be required that
the UTXO be marked as opting into this behavior (so receivers would know
about the possibility it could get revoked). This second requirement would
require Sabu issuers to make an on-chain transaction to set themselves
up as an issuer.

Another issue is that this would make it possible for transactions to
expire. Any claw-back transaction would expire 6 blocks after the initial
transaction happened. This has been generally avoided in bitcoin, but I
think the relevant issues are solvable. You can find additional discussion
of that in this thread
<https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019050.html>
.

I would imagine this kind of ability would be pretty controversial, but
since it can close out the possibility for miners to escape punishment, it
could make this protocol viable.

On Thu, Jul 1, 2021 at 3:15 PM <raymo at riseup.net> wrote:

>
> Hi Erik
>
> Please correct me if I misunderstood.
>
> > email is fully compromised.
>
> What I got is:
> Email is not good because the sender and receiver are compromised.
> Email is not good because the message content is revealed.
> I can claim same argue about any other client/server model. Since the
> server (website) service provider will ask some sort of KYC. And even if
> the server uses end-to-end encryption, the provider company still can
> read the packets content.
> In my model the passive listener only can discover who is communicate to
> whom and make a graph of connections. Although it is a threat for
> privacy but the server/client model has this flaw inherently, since
> provider already knew everything about everyone. In my model at least
> users can make some fake connections and send some fake emails in order
> to inject noise to communications.
> Please note the fact that entire communication between mobile wallets
> (via emails) are asymmetric PGP encrypted. The PGP keys are controlled
> by end users unlike ALL pretending secure messengers (e.g whatsApp,
> signal, zoom,?).
> If you are worried about the way of exchanging PGP public key, you are
> right. The most secure way is in-person PGP key exchanging.
> After that for payments the wallets communicate in pgp encrypted
> messages and they can transfer Bitcoin address through an PGP encrypted
> cipher, thus no revealing Bitcoin address to public would occur. Neither
> the amounts of transactions will be reviled.
> There for it would be a good practice for shops to put their email and
> PGP public key on shop website and/or PGP public key servers, instead of
> putting Bitcoin address on website or using 3rd parties services to hide
> their Bitcoin payment addresses.
>
> If I missed some points about ?fully compromised? please write it to me.
>
>
> > public keys / addresses are sent
> As I told before ALL communication in Sabu are PGP encrypted.
>
> > other routing data encrypted with public keys
> >(not sure how data is routed in sabu)
>
> Sabu is not responsible for routing at all. It simply sends emails.
> Indeed the wallets peer-to-peer network in Sabu is pretty straight
> forward. Each mobile wallet has one email address as its handler and
> identifier in mobile-wallets-network. Each mobile can send message to
> another mobile by knowing its email address and the PGP public key.
> This information can be prepared in first face-to-face contact of mobile
> owners, or later (something like signing the other?s public key in web
> of trust) when a creditor wants to spend his money and transfer it to
> another creditor. The creditor1 send the signed money transfer request
> alongside the email and public key of creditor2 all in a PGP encrypted
> message to issuer.
>
>
>
> > separate the Sabu protocol from the app... allow others to implement
> > desktop version, or other versions that use other routing systems
>
> Indeed, it is my approach too. As I told before users will decide
> between an unstoppable, permission less, self-sovereignty and
> decentralized pure peer-to-peer communication network (with some
> resolvable privacy issues) or some efficient, privacy-mimic central
> limited network.
>
>
> > you can allow direct-entry of a BIP-word-representation
> > of a public key/address to avoid privacy/central system concerns
> Agree. Actually, I was thinking about an easy mechanism to share your
> public key like what you suggested here.
> But what I consider for a ?central system concerns? is the ability of
> communication without dependency to any company.
> As an example, what can you do if the twitter bans your account?
> Nothing! Your content and entire connections will be lost.
> But if you form your friends list in your mobile (or computer) and have
> their PGP public keys and they have yours, and use email as a dual
> purpose tool. First as a handler (the tool for finding and to be found
> in internet) and second as a communication tool.
> Thus, no one can stop you, ban you or limit you to send/receive
> transaction to/from anyone.
> What I am trying to say is using email is far better than account
> (username) in a limited central service like twitter, Facebook,
> telegram... or even in future Sabu servers!
> You have your connections under your control in your phone. You can
> easily change your email and use a new email or even a new service
> provider without losing your connections and your control over it.
> You just sign your new email address and send it to your friends circle
> and notify them about changes.
> Of course, email is not good for millions of followers but it is
> obviously good for managing your payment network of hundreds of people
> (either issuers or creditors).
>
> Best
> Raymo
>
> On 2021-07-01 20:49, Erik Aronesty wrote:
> > your protocol should always assume the email system is fully
> > compromised, and only send public information over email:
> >
> > - public keys / addresses are sent
> > - other routing data encrypted with public keys (not sure how data is
> > routed in sabu)
> >
> > your end user should be able to verify public keys  / addresses
> >
> >  - use QR-codes
> >  - phone calls with users reading BIP words out loud
> >  - other in-person information exchange
> >
> > separate the Sabu protocol from the app... allow others to implement
> > desktop version, or other versions that use other routing systems
> >
> > -  you can allow direct-entry of a BIP-word-representation of a public
> > key/address to avoid privacy/central system concerns
> >
> > On Thu, Jul 1, 2021 at 4:20 PM raymo via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>
> >> Hi Billy,
> >> Sorry for late reply. Let?s jump in proposal.
> >>
> >> > Some more information about the benefits of this approach vs
> alternatives (mainly lightning)
> >> The most important different is unlike the lightning, in Sabu no one
> >> have to open a channel and pay Bitcoin transaction fee, subsequently no
> >> one has to close channel and pay another Bitcoin transaction fee. It is
> >> the huge improvement since it drops the overhead cost of transactions.
> >> So, it will be more convenience to trade under Sabu protocol.
> >> In Sabu none of parties of a transaction are obliged to block money in
> >> any kind of smart contract or any other m of n signature accounts
> >> on-chain, so it provides more privacy.
> >> Since Sabu protocol is designed to motivate people to circulate
> >> transactions (AKA debt documents) in Sabu network, if every actor act
> >> rationally no one will aware how much money transferred from who to
> >> whom.
> >> In case of fraudulent activity by issuer, the creditor will send
> >> Guarantee Transaction (GT) to Bitcoin network in order to recapture the
> >> part of his credit. So, in this case the transaction is literally
> >> recorded on bitcoin blockchain.
> >> There is only one another reason to recording transaction on Bitcoin
> >> blockchain. Where one creditor eager to pay Bitcoin transaction fee in
> >> order to aggregate thousands or even millions different small amount
> >> debt-documents in a single transaction on Bitcoin blockchain.
> >> despite these two cases, the rest of transactions all occur in the Sabu
> >> network (supposed to be over 99%). Thus, no footprint no bottleneck and
> >> no over process.
> >>
> >> Another important power point of Sabu is its pure-peer-to-peer network
> >> architecture. In Sabu the mobile wallets communicating to each other
> >> directly without any central server. There is no centralization at all.
> >> As a result, there will be no routing as well.
> >> Since only issuer and creditors are aware of the content of transaction
> >> (who pay how much to whom) it is a huge privacy improvement, which
> >> doesn?t exist in other layer 2 solutions.
> >>
> >> About the usability of Sabu, although the protocol based on the
> >> collaborating 2 different peer-to-peer network and 3 classic
> >> server/client networks, but the end user (mobile wallet user) doesn?t
> >> see any of these complexities.
> >> The end user simply installs the mobile/desktop wallet and add her/his
> >> friends to his phonebook by adding their email address or scanning their
> >> email (and/or PGP public key). After that s/he can immediately start to
> >> send/receive Bitcoin through Sabu network. Entire communications between
> >> wallets are PGP encrypted.
> >> Another good point in Sabu design is, the 12 seed words are using for
> >> both Bitcoin wallet private key and the PGP private key. So, it is the
> >> key of user wealth and its identity as well. For more details, please
> >> read my previous answer to Alex Schoof.
> >> The issuer, by using his UTXOs and selling them to creditors earn money.
> >> the issuer creates the debt document (transaction) by which promises to
> >> creditor an amount of satoshi. These debt documents are valid Bitcoin
> >> transaction. The only difference is these transactions are intended to
> >> circulate in Sabu protocol instead of sending to Bitcoin blockchain.
> >> Each transaction is a small money transfer. 40,000 Satoshi as input and
> >> maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as Bitcoin
> >> transaction fee.
> >> The creditors will use these received transactions as money and will pay
> >> it in exchange of goods or services. For each transaction the creditor
> >> pays 10 Satoshi as Sabu-transaction-fee to issuer.
> >> Sabu is not custodial service and the UXTOs are always under issuer
> >> control, unless issuer or creditor send the signed transaction to
> >> Bitcoin network. When the transaction was recorded in Bitcoin
> >> blockchain, the creditor can spend proper UTXO in Bitcoin network.
> >> Imagine million people use their UTXOs in Sabu, they are issuer and
> >> issue/update/cancel million transactions per second. All they need is a
> >> mobile wallet. On the other hand, every one by knowing an issuer can buy
> >> some Satoshi (whit absolutely no KYC), even 1 Dollar or less, and spend
> >> it, this time Alice really can buy caffe by Bitcoin ;)
> >> The Bar can install the mobile wallet and every day receives thousands
> >> of debt documents (transactions), each worth maximum 20,000 Satoshi in
> >> exchange of coffee. And every evening aggregates those small
> >> transactions to one single transaction and send it to Bitcoin network.
> >>
> >>
> >> The security model of Sabu is pretty straight forward.
> >> Issuer is the owner of UTXO(s) which will be used in transactions. The
> >> issuer is and will the only person who creates transactions and sign
> >> them. The transactions are valid transaction which either issuer or
> >> creditor can send them to Bitcoin network, but they will never send
> >> these transactions to Bitcoin network, because of the high Bitcoin
> >> transaction fee for each single transaction.
> >> Since issuer is the only one who can sign transaction (spend UTXOs),
> >> there is a risk of issuer cheating. And no one can stop issuer from
> >> cheating, because these are his UTXOs and he has the proper private
> >> keys.
> >> The Sabu solution is Guarantee transaction. It is a valid transaction
> >> that issuer has to sign it alongside the Main transaction. In GT both
> >> issuer and creditor cut a part of their output in favor of Bitcoin
> >> transaction fee.
> >> We suppose miners always seeking for more profit, thus in a case there
> >> are 2 or more transaction are spending same UTXO as input, miner will
> >> choose transaction with highest feeRate. There is no economically
> >> benefit for issuer to cheat creditors and pay less transaction fee
> >> simultaneously. So rationally the issuer won?t cheat creditor.
> >> It was the simplest explanation of Sabu security model.
> >>
> >> > I agree with others that using email is probably not appropriate for
> a protocol like this. I would highly recommend making your protocol
> transport-agnostic, allowing users of your protocol to use any transport
> they want.
> >> Indeed, the protocol is transparent-agnostic, if I insist of email as a
> >> user identifier and communicating tool is because of the idea of
> >> reforming part of internet architecture and make it more decentralized.
> >> The wallet users can choose classic architecture. In this case mobile
> >> wallets will connect to a central server and communicate through that
> >> server (pretty much like all existed mobile wallets). While some users
> >> decide to use a pure peer-to-peer communication. I knew email has some
> >> privacy issues but as always it is a tradeoff. Users can decide between
> >> an unstoppable, permission less, self-sovereignty and decentralized pure
> >> peer-to-peer communication network (with some resolvable privacy issues)
> >> or some efficient central limited network.
> >> Let me know the critics about email. Hopefully this would lead us to
> >> improve email instead of letting it die. I strongly suggest email
> >> because it is the ONLY neutral, free ?nonproprietary? and open
> >> protocol/technology for communication in the world that its
> >> infrastructure is well-established and is accessible all over the glob.
> >>
> >> I tried to explain it more, hope was useful. By the way the complete
> >> explanation is here
> >>
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
> >>
> >>
> >>
> >> Regards
> >> Raymo
> >>
> >>
> >>
> >> On 2021-06-22 18:20, Billy Tetrud wrote:
> >> > I would be interested in seeing some more information about the
> >> > benefits of this approach vs alternatives up front in this write up.
> >> > Eg how does the security, cost, usability, and privacy compare to the
> >> > lightning network, which would be the most likely competitor to this
> >> > idea. It seems clear that there is more counterparty risk here, so it
> >> > would probably also be very helpful to compare against traditional
> >> > custodial solutions as well. If you have specific claims on how this
> >> > system is better than eg lightning in certain contexts, it would be
> >> > far easier to evaluate the protocol against those claims, and would
> >> > also be a lot easier for readers to be motivated to read the whole
> >> > protocol and do a more full analysis.
> >> >
> >> > I agree with others that using email is probably not appropriate for a
> >> > protocol like this. I would highly recommend making your protocol
> >> > transport-agnostic, allowing users of your protocol to use any
> >> > transport they want.
> >> >
> >> > On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
> >> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> >
> >> >> I think you're making a number of assumptions about mining that are
> >> >> not accurate.
> >> >>
> >> >>> First of all, how much chance in finding next block the corrupted
> >> >> miners have? One percent of all Bitcoin hash powers? Or maximum 5
> >> >> percent or 10? The cheaters must come up in dividing that 1.2
> >> >> Bitcoin between. After all the risk/reward must fit them. They can
> >> >> not be a big mining pool since there is no benefit, so they will be
> >> >> small miners with low hash rate. If they solve the puzzle and
> >> >> broadcast the block, no one in the entire Bitcoin network has block
> >> >> transactions or seen it before in their mempool!
> >> >>
> >> >> You're making the assumption that miners won't build on top of a
> >> >> block
> >> >> with transactions they have not seen before or transactions that may
> >> >> contain double spends of unconfirmed inputs, this is not how mining
> >> >> works, as long as the block passes the consensus rules effectively
> >> >> all
> >> >> miners will mine on top of it by default, this behavior is
> >> >> fundamental
> >> >> to how mining currently works and is fairly deeply baked into the
> >> >> current mining infrastructure.
> >> >>
> >> >>> Will they accept this block? In theory it is possible and have
> >> >> 0.01 percent chance but we can eliminate this small possibilities by
> >> >> a simple BIP for miners.
> >> >>
> >> >> What would this BIP look like? I don't see how this could work in a
> >> >> decentralized way as you would need another way of reaching
> >> >> consensus
> >> >> on what defines a valid block. Right now the chance is nearly 100
> >> >> percent that a miner will mine on top of the latest valid block,
> >> >> many
> >> >> pools(most last I checked) will even mine on the next block before
> >> >> they validate the latest block fully(ie validationless mining) to
> >> >> reduce their orphan rates.
> >> >>
> >> >>> We suppose the miners always control transactions with
> >> >> doc-watchers and avoid accepting transaction with same UTXO but
> >> >> different output.
> >> >>
> >> >> Miners have different mempool policy/rules for what transactions
> >> >> they
> >> >> themselves mine but all miners must mine on the most work chain of
> >> >> valid blocks otherwise they risk their own blocks being orphaned,
> >> >> any
> >> >> miner that does not do this is effectively guaranteed to have their
> >> >> block orphaned right now.
> >> >>
> >> >>> Because of high Bitcoin transaction fee, this guarantee
> >> >> transaction will take place in next block, even if other transaction
> >> >> which are using the same UTXO as input existed in mempool.
> >> >>
> >> >> When a new transaction is broadcast miners do not immediately start
> >> >> mining on a block template that includes that transaction, the
> >> >> template won't even be generated immediately when it enters a miners
> >> >> mempool in practice, for bandwidth/network efficiency reasons mining
> >> >> pools batch update the stratum templates/jobs they mine against so
> >> >> there can be significant latency between the time a transaction is
> >> >> actually broadcast and hits the miners mempool and the time the
> >> >> miners
> >> >> actually switch to mining on top it, these batched updates are
> >> >> essentially like point in time snapshots of the mempool and
> >> >> typically
> >> >> remain valid(as in the pool will accept shares submitted against
> >> >> that
> >> >> job as valid) until the bitcoin network finds the next block. I
> >> >> don't
> >> >> think these batch updates are done more often than every 30 seconds
> >> >> typically, while often it is on the order of multiple minutes
> >> >> depending on the pool.
> >> >>
> >> >> Regards,
> >> >> James
> >> >>
> >> >> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
> >> >> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >> >>>
> >> >>> Hi,
> >> >>> I have a proposal for improve Bitcoin TPS and privacy, here is the
> >> >> post.
> >> >>>
> >> >>
> >> >
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
> >> >>> https://bitcointalk.org/index.php?topic=5344020.0
> >> >>> Can you please read it and share your idea about it.
> >> >>>
> >> >>> Cheers
> >> >>> Raymo
> >> >>> _______________________________________________
> >> >>> bitcoin-dev mailing list
> >> >>> bitcoin-dev at lists.linuxfoundation.org
> >> >>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >> >> _______________________________________________
> >> >> bitcoin-dev mailing list
> >> >> bitcoin-dev at lists.linuxfoundation.org
> >> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >> _______________________________________________
> >> bitcoin-dev mailing list
> >> bitcoin-dev at lists.linuxfoundation.org
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210702/ba3a3221/attachment-0001.html>

From achow101-lists at achow101.com  Fri Jul  2 20:03:20 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Fri, 02 Jul 2021 20:03:20 +0000
Subject: [bitcoin-dev] Derivation Paths for Single Key Taproot Scripts
In-Reply-To: <6bb9110e-b726-0470-96f0-2d68eadf23a3@achow101.com>
References: <6bb9110e-b726-0470-96f0-2d68eadf23a3@achow101.com>
Message-ID: <ad7b84a7-7666-7cde-6ba9-84a5ffbc04be@achow101.com>

This was assigned BIP number 86, so the purpose level path will be m/86'

Andrew

On 6/22/21 9:17 PM, Andrew Chow wrote:
> Hi All,
>
> I would like to propose a simple derivation path scheme for keys to be
> used in single key Taproot scripts. This is based on BIP 44 so it is
> basically identical to BIPs 49 and 84. Like with those BIPs, the actual
> value to be used in the purpose level will be set to the BIP number,
> once assigned.
>
> Note that the keys derived in this method should be for the Taproot
> internal key, which should then be tweaked with the hash of itself as
> recommended by BIP 341. The keys derived at this path should not be used
> directly as the Taproot output pubkey. Additionally, this BIP does not
> specify new version bytes for extended key serialization because, with
> the advent of descriptors, I think that is unnecessary. In fact, this
> BIP feels somewhat unnecessary to me, but it seems like it will be
> needed for now in order to drive adoption and implementation of Taproot
> into software and hardware wallets.
>
> The text can be viewed below, with the rendered text available at
> https://github.com/achow101/bips/blob/taproot-bip44/bip-taproot-bip44.mediawiki
>
> Andrew Chow
>
> ---
>
> <pre>
>   ? BIP: bip-taproot-bip44
>   ? Layer: Applications
>   ? Title: Derivation scheme for P2TR based accounts
>   ? Author: Andrew Chow <andrew at achow101.com>
>   ? Comments-Summary: No comments yet.
>   ? Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-taproot-bip44
>   ? Status: Draft
>   ? Type: Informational
>   ? Created: 2021-06-22
>   ? License: BSD-2-Clause
> </pre>
>
> ==Abstract==
>
> This document suggests a derivation scheme for HD wallets whose keys are
> involved in single key
> P2TR ([[bip-0341.mediawiki|BIP 341]]) outputs as the Taproot internal key.
>
> ===Copyright===
>
> This BIP is licensed under the 2-clause BSD license.
>
> ==Motivation==
>
> With the usage of single key P2TR transactions, it is useful to have a
> common derivation scheme so
> that HD wallets that only have a backup of the HD seed can be likely to
> recover single key Taproot
> outputs. Although there are now solutions which obviate the need for
> fixed derivation paths for
> specific script types, many software wallets and hardware signers still
> use seed backups which
> lack derivation path and script information. Thus we largely use the
> same approach used in BIPs
> [[bip-0049.mediawiki|49]] and [[bip-0084.mediawiki|84]] for ease of
> implementation.
>
> ==Specifications==
>
> This BIP defines the two needed steps to derive multiple deterministic
> addresses based on a
> [[bip-0032.mediawiki|BIP 32]] master private key.
>
> ===Public key derivation===
>
> To derive a public key from the root account, this BIP uses the same
> account-structure as
> defined in BIPs [[bip-0044.mediawiki|44]], [[bip-0049.mediawiki|49]],
> and [[bip-0084.mediawiki|84]],
> but with a different purpose value for the script type.
>
> <pre>
> m / purpose' / coin_type' / account' / change / address_index
> </pre>
>
> For the <tt>purpose</tt>-path level it uses <tt><BIPNUMBER>'</tt>.
> The rest of the levels are used as defined in BIPs 44, 49, and 84.
>
> ===Address derivation===
>
> To derive the output key used in the P2TR script from the derived public
> key, we use the method
> recommended in
> [[bip-0341.mediawiki#constructing-and-spending-taproot-outputs|BIP 341]]:
>
> <pre>
> internal_key:?????? lift_x(derived_key)
> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)))G
> </pre>
>
> In a transaction, the scripts and witnesses are as defined in
> [[bip-0341.mediawiki#specification|BIP 341]]:
>
> <pre>
> witness:????? <signature>
> scriptSig:??? (empty)
> scriptPubKey: 1 <32_byte_output_key>
>   ????????????? (0x5120{32_byte_output_key})
> </pre>
>
> ==Backwards Compatibility==
>
> This BIP is not backwards compatible by design.
> An incompatible wallet will not discover these accounts at all and the
> user will notice that
> something is wrong.
>
> However this BIP uses the same method used in BIPs 44, 49, and 84, so it
> should not be difficult
> to implement.
>
> ==Test vectors==
>
> TBD
>
> ==Reference==
>
> * [[bip-0032.mediawiki|BIP32 - Hierarchical Deterministic Wallets]]
> * [[bip-0043.mediawiki|BIP43 - Purpose Field for Deterministic Wallets]]
> * [[bip-0044.mediawiki|BIP44 - Multi-Account Hierarchy for Deterministic
> Wallets]]
> * [[bip-0049.mediawiki|BIP49 - Derivation scheme for
> P2WPKH-nested-in-P2SH based accounts]]
> * [[bip-0084.mediawiki|BIP84 - Derivation scheme for P2WPKH based accounts]]
> * [[bip-0341.mediawiki|BIP341 - Taproot: SegWit version 1 spending rules]]
>



From achow101-lists at achow101.com  Fri Jul  2 20:05:45 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Fri, 02 Jul 2021 20:05:45 +0000
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <CAD5xwhg9sno+aABgUtiwhBo8mLrmj5m9WowGjnUfv-f1pSbshw@mail.gmail.com>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <CAD5xwhg9sno+aABgUtiwhBo8mLrmj5m9WowGjnUfv-f1pSbshw@mail.gmail.com>
Message-ID: <08950fa0-36ba-5411-fee4-cf0d5c229ca6@achow101.com>

I've opened a PR against my own BIPs fork for review: https://github.com/achow101/bips/pull/3

Andrew

On 6/29/21 11:41 PM, Jeremy wrote:

> Kudos, this is fantastic!
>
> It might be easier, since there is a ton of content here, for you to open up some WIP PRs to collect feedback?
> --
> [@JeremyRubin](https://twitter.com/JeremyRubin)
>
> On Tue, Jun 29, 2021 at 2:15 PM Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi All,
>>
>> I've been working on formalizing the Output Script Descriptors that have
>> been available in Bitcoin Core for a while into BIPs. Since descriptors
>> are modular and have optional components, I've decided to split it into
>> 7 BIPs, rather than a single one. The first describes descriptors in
>> general and does not specify any particular descriptor. However it does
>> describe the general operation, key expressions (including derivation
>> paths and key origin info), and the descriptor checksum. The following 6
>> BIPs specify the actual descriptors themselves. These are non-segwit
>> descriptor (pk, pkh, sh), segwit descriptors (wpkh, wsh), multisig
>> descriptors (multi, sortedmulti), the taproot descriptor (tr), the combo
>> descriptor, and opaque descriptors (raw, addr). This separation is so
>> that implementors can choose to not implement some descriptors and still
>> say which descriptors they support without being too difficult to
>> understand.
>>
>> The text of all of the documents are below, and they can also be found
>> on github:https://github.com/achow101/bips/tree/descriptors/
>>
>> Thanks,
>> Andrew Chow
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-general
>> Layer: Applications
>> Title: Output Script Descriptors General Operation
>> Author: Pieter Wuille <pieter at wuille.net>
>> Andrew Chow <andrew at achow101.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-general
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> Output Script Descriptors are a simple language which can be used to
>> describe collections ofoutput scripts.
>> There can be many different descriptor fragments and functions.
>> This document describes the general syntax for descriptors, descriptor
>> checksums, and common expressions.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> Bitcoin wallets traditionally have stored a set of keys which are later
>> serialized and mutated to produce the output scripts that the wallet
>> watches and the addresses it provides to users.
>> Typically backups have consisted of solely the private keys, nowadays
>> primarily in the form of BIP 39 mnemonics.
>> However this backup solution is insuffient, especially since the
>> introduction of Segregated Witness which added new output types.
>> Given just the private keys, it is not possible for restored wallets to
>> know which kinds of output scripts and addresses to produce.
>> This has lead to incompatibilities between wallets when restoring a
>> backup or exporting data for a watch only wallet.
>>
>> Further complicating matters are BIP 32 derivation paths.
>> Although BIPs 44, 49, and 84 have specified standard BIP 32 derivation
>> paths for different output scripts and addresses, not all wallets
>> support them nor use those derivation paths.
>> The lack of derivation path information in these backups and exports
>> leads to further incompatibilities between wallets.
>>
>> Current solutions to these issues have not been generic and can be
>> viewed as being layer violations.
>> Solutions such as introducing different version bytes for extended key
>> serialization both are a layer violation (key derivation should be
>> separate from script type meaning) and specific only to a particular
>> derivation path and script type.
>>
>> Output Script Descriptors introduces a generic solution to these issues.
>> Script types are specified explicitly through the use of Script Expressions.
>> Key derivation paths are specified explicitly in Key Expressions.
>> These allow for creating wallet backups and exports which specify the
>> exact scripts, subscripts (redeemScript, witnessScript, etc.), and keys
>> to produce.
>> With the general structure specified in this BIP, new Script Expressions
>> can be introduced as new script types are added.
>> Lastly, the use of common terminology and existing standards allow for
>> Output Script Descriptors to be engineer readable so that the results
>> can be understood at a glance.
>>
>> ==Specification==
>>
>> Descriptors consist of several types of expressions.
>> The top level expression is a <tt>SCRIPT</tt>.
>> This expression may be followed by <tt>#CHECKSUM</tt>, where
>> <tt>CHECKSUM</tt> is an 8 character alphanumeric descriptor checksum.
>>
>> ===Script Expressions===
>>
>> Script Expressions (denoted <tt>SCRIPT</tt>) are expressions which
>> correspond directly with a Bitcoin script.
>> These expressions are written as functions and take arguments.
>> Such expressions have a script template which is filled with the
>> arguments correspondingly.
>> Expressions are written with a human readable identifier string with the
>> arguments enclosed with parentheses.
>> The identifier string should be alphanumeric and may include underscores.
>>
>> The arguments to a script expression are defined by that expression itself.
>> They could be a script expression, a key expression, or some other
>> expression entirely.
>>
>> ===Key Expressions===
>>
>> A common expression used as an argument to script expressions are key
>> expressions (denoted <tt>KEY</tt>).
>> These represent a public or private key and, optionally, information
>> about the origin of that key.
>> Key expressions can only be used as arguments to script expressions.
>>
>> Key expressions consist of:
>> * Optionally, key origin information, consisting of:
>> ** An open bracket <tt>[</tt>
>> ** Exactly 8 hex characters for the fingerprint of the key where the
>> derivation starts (see BIP 32 for details)
>> ** Followed by zero or more <tt>/NUM</tt> or <tt>/NUM'</tt> path
>> elements to indicate the unhardened or hardened derivation steps between
>> the fingerprint and the key that follows.
>> ** A closing bracket <tt>]</tt>
>> * Followed by the actual key, which is either:
>> ** A hex encoded public key, which depending the script expression, may
>> be either:
>> *** 66 hex character string beginning with <tt>02</tt> or <tt>03</tt>
>> representing a compressed public key
>> *** 130 hex character string beginning with <tt>04</tt> representing an
>> uncompressed public key
>> *** 64 hex character string representing an x-only public key
>> ** A [[[https://en.bitcoin.it/wiki/Wallet_import_format|WIF](https://en.bitcoin.it/wiki/Wallet_import_format%7CWIF)]] encoded
>> private key
>> ** <tt>xpub</tt> encoded extended public key or <tt>xprv</tt> encoded
>> extended private key (as defined in BIP 32)
>> *** Followed by zero or more <tt>/NUM</tt> or <tt>/NUM'</tt> path
>> elements indicating BIP 32 derivation steps to be taken after the given
>> extended key.
>> *** Optionally followed by a single <tt>/*</tt> or <tt>/*'</tt> final
>> step to denote all direct unhardened or hardened children.
>>
>> If the <tt>KEY</tt> is a BIP 32 extended key, before output scripts can
>> be created, child keys must be derived using the derivation information
>> that follows the extended key.
>> When the final step is <tt>/*</tt> or <tt>/*'</tt>, an output script
>> will be produced for every child key index.
>> The derived key must be serialized as a compressed public key.
>>
>> In the above specification, the hardened indicator <tt>'</tt> may be
>> replaced with alternative hardnened indicators of <tt>h</tt> or <tt>H</tt>.
>>
>> ===Character Set===
>>
>> The expressions used in descriptors must only contain characters within
>> this character set so that the descriptor checksum will work.
>>
>> The allowed characters are:
>> <pre>
>> 0123456789()[],'/*abcdefgh@:$%{}
>> IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~
>> ijklmnopqrstuvwxyzABCDEFGH`#"\<space>
>> </pre>
>> Note that <tt><space></tt> on the last line is a space character.
>>
>> This character set is written as 3 groups of 32 characters in this
>> specific order so that the checksum below can identify more errors.
>> The first group are the most common "unprotected" characters (i.e.
>> things such as hex and keypaths that do not already have their own
>> checksums).
>> Case errors cause an offset that is a multiple of 32 while as many
>> alphabetic characters are in the same group while following the previous
>> restrictions.
>>
>> ===Checksum===
>>
>> Follwing the top level script expression is a single octothorpe
>> (<tt>#</tt>) followed by the 8 character checksum.
>> The checksum is an error correcting checksum similar to bech32.
>>
>> The checksum has the following properties:
>> * Mistakes in a descriptor string are measured in "symbol errors". The
>> higher the number of symbol errors, the harder it is to detect:
>> ** An error substituting a character from
>> <tt>0123456789()[],'/*abcdefgh@:$%{}</tt> for another in that set always
>> counts as 1 symbol error.
>> *** Note that hex encoded keys are covered by these characters. Extended
>> keys (<tt>xpub</tt> and <tt>xprv</tt>) use other characters too, but
>> also have their own checksum mechansim.
>> *** <tt>SCRIPT</tt> expression function names use other characters, but
>> mistakes in these would generally result in an unparsable descriptor.
>> ** A case error always counts as 1 symbol error.
>> ** Any other 1 character substitution error counts as 1 or 2 symbol errors.
>> * Any 1 symbol error is always detected.
>> * Any 2 or 3 symbol error in a descriptor of up to 49154 characters is
>> always detected.
>> * Any 4 symbol error in a descriptor of up to 507 characters is always
>> detected.
>> * Any 5 symbol error in a descriptor of up to 77 characters is always
>> detected.
>> * Is optimized to minimize the chance of a 5 symbol error in a
>> descriptor up to 387 characters is undetected
>> * Random errors have a chance of 1 in 2<super>40</super> of being
>> undetected.
>>
>> The checksum itself uses the same character set as bech32:
>> <tt>qpzry9x8gf2tvdw0s3jn54khce6mua7l</tt>
>>
>> Valid descriptor strings with a checksum must pass the criteria for
>> validity specified by the Python3 code snippet below.
>> The function <tt>descsum_check</tt> must return true when its argument
>> <tt>s</tt> is a descriptor consisting in the form <tt>SCRIPT#CHECKSUM</tt>.
>>
>> <pre>
>> INPUT_CHARSET =
>> "0123456789()[],'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#\"\\
>> "
>> CHECKSUM_CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
>> GENERATOR = [0xf5dee51989, 0xa9fdca3312, 0x1bab10e32d, 0x3706b1677a,
>> 0x644d626ffd]
>>
>> def descsum_polymod(symbols):
>> """Internal function that computes the descriptor checksum."""
>> chk = 1
>> for value in symbols:
>> top = chk >> 35
>> chk = (chk & 0x7ffffffff) << 5 ^ value
>> for i in range(5):
>> chk ^= GENERATOR[i] if ((top >> i) & 1) else 0
>> return chk
>>
>> def descsum_expand(s):
>> """Internal function that does the character to symbol expansion"""
>> groups = []
>> symbols = []
>> for c in s:
>> if not c in INPUT_CHARSET:
>> return None
>> v = INPUT_CHARSET.find(c)
>> symbols.append(v & 31)
>> groups.append(v >> 5)
>> if len(groups) == 3:
>> symbols.append(groups[0] * 9 + groups[1] * 3 + groups[2])
>> groups = []
>> if len(groups) == 1:
>> symbols.append(groups[0])
>> elif len(groups) == 2:
>> symbols.append(groups[0] * 3 + groups[1])
>> return symbols
>>
>> def descsum_check(s):
>> """Verify that the checksum is correct in a descriptor"""
>> if s[-9] != '#':
>> return False
>> if not all(x in CHECKSUM_CHARSET for x in s[-8:]):
>> return False
>> symbols = descsum_expand(s[:-9]) + [CHECKSUM_CHARSET.find(x) for x
>> in s[-8:]]
>> return descsum_polymod(symbols) == 1
>> </pre>
>>
>> This implements a BCH code that has the properties described above.
>> The entire descriptor string is first processed into an array of symbols.
>> The symbol for each character is its position within its group.
>> After every 3rd symbol, a 4th symbol is inserted which represents the
>> group numbers combined together.
>> This means that a change that only affects the position within a group,
>> or only a group number change, will only affect a single symbol.
>>
>> To construct a valid checksum given a script expression, the code below
>> can be used:
>>
>> <pre>
>> def descsum_create(s):
>> """Add a checksum to a descriptor without"""
>> symbols = descsum_expand(s) + [0, 0, 0, 0, 0, 0, 0, 0]
>> checksum = descsum_polymod(symbols) ^ 1
>> return s + '#' + ''.join(CHECKSUM_CHARSET[(checksum >> (5 * (7 -
>> i))) & 31] for i in range(8))
>>
>> </pre>
>>
>> ==Backwards Compatibility==
>>
>> Output script descriptors are an entirely new language which is not
>> compatible with any existing software.
>> However many components of the expressions reuse encodings and
>> serializations defined by previous BIPs.
>>
>> Output script descriptors are designed for future extension with further
>> fragment types and new script expressions.
>> These will be specified in additional BIPs.
>>
>> ==Reference Implemntation==
>>
>> Descriptors have been implemented in Bitcoin Core since version 0.17.
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-segwit
>> Layer: Applications
>> Title: segwit Output Script Descriptors
>> Author: Pieter Wuille <pieter at wuille.net>
>> Andrew Chow <andrew at achow101.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-segwit
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies <tt>wpkh()</tt>, and <tt>wsh()</tt> output
>> script descriptors.
>> <tt>wpkh()</tt> descriptors take a key and produces a P2WPKH output script.
>> <tt>wsh()</tt> descriptors take a script and produces a P2WSH output script.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> Segregated Witness added 2 additional standard output script formats:
>> P2WPKH and P2WSH.
>> These expressions allow specifying those formats as a descriptor.
>>
>> ==Specification==
>>
>> Two new script expressions are defined: <tt>wpkh()</tt>, and <tt>wsh()</tt>.
>>
>> ===<tt>wpkh()</tt>===
>>
>> The <tt>wpkh(KEY)</tt> expression can be used as a top level expression,
>> or inside of a <tt>sh()</tt> descriptor.
>> It takes a single key expression as an argument and produces a P2WPKH
>> output script.
>> Only keys which are/has compressed public keys can be contained in a
>> <tt>wpkh()</tt> expression.
>>
>> The output script produced is:
>> <pre>
>> OP_0 <KEY_hash160>
>> </pre>
>>
>> ===<tt>wsh()</tt>===
>>
>> The <tt>wsh(SCRIPT)</tt> expression can be used as a top level
>> expression, or inside of a <tt>sh()</tt> descriptor.
>> It takes a single script expression as an argument and produces a P2WSH
>> output script.
>> <tt>wsh()</tt> expressions also create a witnessScript which is required
>> in order to spend outputs which use its output script.
>> This redeemScript is the output script produced by the <tt>SCRIPT</tt>
>> argument to <tt>wsh()</tt>.
>> Any key expression found in any script expression contained by a
>> <tt>wsh()</tt> expression must only produce compresed public keys.
>>
>> The output script produced is:
>> <pre>
>> OP_0 <SCRIPT_sha256>
>> </pre>
>>
>> ==Test Vectors==
>>
>> TBD
>>
>> ==Backwards Compatibility==
>>
>> <tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors use the format and
>> general operation specified in
>> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
>> As these are a wholly new descriptors, they are not compatible with any
>> implementation.
>> However the scripts produced are standard scripts so existing software
>> are likely to be familiar with them.
>>
>> ==Reference Implemntation==
>>
>> <tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors have been implemented in
>> Bitcoin Core since version 0.17.
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-non-segwit
>> Layer: Applications
>> Title: Non-segwit Output Script Descriptors
>> Author: Pieter Wuille <pieter at wuille.net>
>> Andrew Chow <andrew at achow101.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-non-segwit
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt>
>> output script descriptors.
>> <tt>pk()</tt> descriptors take a key and produces a P2PK output script.
>> <tt>pkh()</tt> descriptors take a key and produces a P2PKH output script.
>> <tt>sh()</tt> descriptors take a script and produces a P2SH output script.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> Prior to the activation of Segregated Witness, there were 3 main
>> standard output script formats: P2PK, P2PKH, and P2SH.
>> These expressions allow specifying those formats as a descriptor.
>>
>> ==Specification==
>>
>> Three new script expressions are defined: <tt>pk()</tt>, <tt>pkh()</tt>,
>> and <tt>sh()</tt>.
>>
>> ===<tt>pk()</tt>===
>>
>> The <tt>pk(KEY)</tt> expression can be used in any context or level of a
>> descriptor.
>> It takes a single key expression as an argument and produces a P2PK
>> output script.
>> Depending on the higher level descriptors, there may be restrictions on
>> the type of public keys that can be included.
>> Such restrictions will be specified by those descriptors.
>>
>> The output script produced is:
>> <pre>
>> <KEY> OP_CHECKSIG
>> </pre>
>>
>> ===<tt>pkh()</tt>===
>>
>> The <tt>pkh(KEY)</tt> expression can be used as a top level expression,
>> or inside of either a <tt>sh()</tt> or <tt>wsh()</tt> descriptor.
>> It takes a single key expression as an argument and produces a P2PKH
>> output script.
>> Depending on the higher level descriptors, there may be restrictions on
>> the type of public keys that can be included.
>> Such restrictions will be specified by those descriptors.
>>
>> The output script produced is:
>> <pre>
>> OP_DUP OP_HASH160 <KEY_hash160> OP_EQUALVERIFY OP_CHECKSIG
>> </pre>
>>
>> ===<tt>sh()</tt>===
>>
>> The <tt>sh(SCRIPT)</tt> expression can only be used as a top level
>> expression.
>> It takes a single script expression as an argument and produces a P2SH
>> output script.
>> <tt>sh()</tt> expressions also create a redeemScript which is required
>> in order to spend outputs which use its output script.
>> This redeemScript is the output script produced by the <tt>SCRIPT</tt>
>> argument to <tt>sh()</tt>.
>>
>> The output script produced is:
>> <pre>
>> OP_HASH160 <SCRIPT_hash160> OP_EQUAL
>> </pre>
>>
>> ==Test Vectors==
>>
>> TBD
>>
>> ==Backwards Compatibility==
>>
>> <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors use the
>> format and general operation specified in
>> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
>> As these are a wholly new descriptors, they are not compatible with any
>> implementation.
>> However the scripts produced are standard scripts so existing software
>> are likely to be familiar with them.
>>
>> ==Reference Implemntation==
>>
>> <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors have been
>> implemented in Bitcoin Core since version 0.17.
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-tr
>> Layer: Applications
>> Title: tr() Output Script Descriptors
>> Author: Pieter Wuille <pieter at wuille.net>
>> Andrew Chow <andrew at achow101.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-tr
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies <tt>tr()</tt> output script descriptors.
>> <tt>tr()</tt> descriptors take a key and optionally a tree of scripts
>> and produces a P2TR output script.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> Taproot added one additional standard output script format: P2TR.
>> These expressions allow specifying those formats as a descriptor.
>>
>> ==Specification==
>>
>> A new script expressions are defined: <tt>tr()</tt>.
>> A new expression is defined: Tree Expressions
>>
>> ===Tree Expression===
>>
>> A Tree Expression (denoted <tt>TREE</tt>) is an expression which
>> represents a tree of scripts.
>> The way the tree is represented in an output script is dependent on the
>> higher level expressions.
>>
>> A Tree Expression is:
>> * Any Script Expression that is allowed at the level this Tree
>> Expression is in.
>> * A pair of Tree Expressions consisting of:
>> ** An open brace <tt>{</tt>
>> ** A Tree Expression
>> ** A comma <tt>,</tt>
>> ** A Tree Expression
>> ** A closing brance <tt>}</tt>
>>
>> ===<tt>tr()</tt>===
>>
>> The <tt>tr(KEY)</tt> or <tt>tr(KEY, TREE)</tt> expression can only be
>> used as a top level expression.
>> All key expressions under any <tt>tr()</tt> expression must create
>> x-only public keys.
>>
>> <tt>tr(KEY</tt> takes a single key expression as an argument and
>> produces a P2TR output script which does not have a script path.
>> The keys produced by the key expression are used as the internal key as
>> specified by [[bip-0341.mediawiki#cite_ref-22-0|BIP 341]].
>> Specifically, "If the spending conditions do not require a script path,
>> the output key should commit to an unspendable script path instead of
>> having no script path.
>> This can be achieved by computing the output key point as ''Q = P +
>> int(hash<sub>TapTweak</sub>(bytes(P)))G''."
>>
>> <pre>
>> internal_key: lift_x(KEY)
>> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)))G
>> scriptPubKey: OP_1 <32_byte_output_key>
>> </pre>
>>
>> <tt>tr(KEY, TREE)</tt> takes a key expression as the first argument, and
>> a tree expression as the second argument and produces a P2TR output
>> script which has a script path.
>> The keys produced by the first key expression are used as the internal
>> key as specified by
>> [[bip-0341.mediawiki#Constructing_and_spending_Taproot_outputs|BIP 341]].
>> The Tree expression becomes the Taproot script tree as described in BIP 341.
>> A merkle root is computed from this tree and combined with the internal
>> key to create the Taproot output key.
>>
>> <pre>
>> internal_key: lift_x(KEY)
>> merkle_root: HashTapBranch(TREE)
>> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)
>> || merkle_root))G
>> scriptPubKey: OP_1 <32_byte_output_key>
>> </pre>
>>
>> ==Test Vectors==
>>
>> TBD
>>
>> ==Backwards Compatibility==
>>
>> <tt>tr()</tt> descriptors use the format and general operation specified
>> in [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
>> As these are a wholly new descriptors, they are not compatible with any
>> implementation.
>> However the scripts produced are standard scripts so existing software
>> are likely to be familiar with them.
>>
>> Tree Expressions are largely incompatible with existing script
>> expressions due to the restrictions in those expressions.
>> As of 2021-06-27, the only allowed script expression that can be used in
>> a tree expression is <tt>pk()</tt>.
>> However there will be future BIPs that specify script expressions that
>> can be used in tree expressions.
>>
>> ==Reference Implemntation==
>>
>> <tt>tr()</tt> descriptors have been implemented in Bitcoin Core since
>> version 22.0.
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-multi
>> Layer: Applications
>> Title: Multisig Output Script Descriptors
>> Author: Pieter Wuille <pieter at wuille.net>
>> Andrew Chow <andrew at achow101.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-multi
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies <tt>multi()</tt>, and <tt>sortedmulti()</tt>
>> output script descriptors.
>> Both functions take a threshold and one or more public keys and produce
>> a multisig output script.
>> <tt>multi()</tt> specifies the public keys in the output script in the
>> order given in the descriptor while <tt>sortedmulti()</tt> sorts the
>> public keys lexicographically when the output script is produced.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> The most common complex script used in Bitcoin is a threshold multisig.
>> These expressions allow specifying multisig scripts as a descriptor.
>>
>> ==Specification==
>>
>> Two new script expressions are defined: <tt>multi()</tt>, and
>> <tt>sortedmulti()</tt>.
>> Both expressions produce the scripts of the same template and take the
>> same arguments.
>> They are written as <tt>multi(k,KEY_1,KEY_2,...,KEY_n)</tt>.
>> <tt>k</tt> is the threshold - the number of keys that must sign the
>> input for the script to be valid.
>> <tt>KEY_1,KEY_2,...,KEY_n</tt> are the key expressions for the multisig.
>> <tt>k</tt> must be less than or equal to <tt>n<tt>.
>>
>> <tt>multi()</tt> and <tt>sortedmulti()</tt> expressions can be used as a
>> top level expression, or inside of either a <tt>sh()</tt> or
>> <tt>wsh()</tt> descriptor.
>> Depending on the higher level descriptors, there may be restrictions on
>> the type of public keys that can be included.
>>
>> Depending on the higher level descriptors, there are also restrictions
>> on the number of keys that can be present, i.e. the maximum value of
>> <tt>n</tt>.
>> When used at the top level, there can only be at most 3 keys.
>> When used inside of a <tt>sh()</tt> expression, there can only be most
>> 15 compressed public keys (this is limited by the P2SH script limit).
>> Otherwise the maximum number of keys is 20.
>>
>> The output script produced also depends on the value of <tt>k</tt>. If
>> <tt>k</tt> is less than or equal to 16:
>> <pre>
>> OP_k KEY_1 KEY_2 ... KEY_n OP_CHECKMULTISIG
>> </pre>
>>
>> if <tt>k</tt> is greater than 16:
>> <pre>
>> k KEY_1 KEY_2 ... KEY_n OP_CHECKMULTISIG
>> </pre>
>>
>> ===<tt>sortedmulti()</tt>===
>>
>> The only change for <tt>sortedmulti()</tt> is that the keys are sorted
>> lexicographically prior to the creation of the output script.
>> This sorting is on the keys that are to be put into the output script,
>> i.e. after all extended keys are derived.
>>
>> ===Multiple Extended Keys</tt>===
>>
>> When one or more the key expressions in a <tt>multi()</tt> or
>> <tt>sortedmulti()</tt> expression are extended keys, the derived keys
>> use the same child index.
>> This changes the keys in lockstep and allows for output scripts to be
>> indexed in the same way that the derived keys are indexed.
>>
>> ==Test Vectors==
>>
>> TBD
>>
>> ==Backwards Compatibility==
>>
>> <tt>multi()</tt>, and <tt>sortedmulti()</tt> descriptors use the format
>> and general operation specified in
>> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
>> As these are a wholly new descriptors, they are not compatible with any
>> implementation.
>> However the scripts produced are standard scripts so existing software
>> are likely to be familiar with them.
>>
>> ==Reference Implemntation==
>>
>> <tt>multi()</tt>, and <tt>multi()</tt> descriptors have been implemented
>> in Bitcoin Core since version 0.17.
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-combo
>> Layer: Applications
>> Title: combo() Output Script Descriptors
>> Author: Pieter Wuille <pieter at wuille.net>
>> Andrew Chow <andrew at achow101.com>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-combo
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies <tt>combo()</tt> output script descriptors.
>> These take a key and produce P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH output
>> scripts if applicable to the key.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> In order to make the transition from traditional key based wallets to
>> descriptor based wallets easier, it is useful to be able to take a key
>> and produce the scripts which have traditionally been produced by wallet
>> software.
>>
>> ==Specification==
>>
>> A new top level script expression is defined: <tt>combo(KEY)</tt>.
>> This expression can only be used as a top level expression.
>> It takes a single key expression as an argument and produces either 2 or
>> 4 output scripts, depending on the key.
>> A <tt>combo()</tt> expression always produces a P2PK and P2PKH script,
>> the same as putting the key in both a <tt>pk()</tt> and a <tt>pkh()</tt>
>> expression.
>> If the key is/has a compressed public key, then P2WPKH and P2SH-P2WPKH
>> scripts are also produced, the same as putting the key in both a
>> <tt>wpkh()</tt> and <tt>sh(wpkh())</tt> expression.
>>
>> ==Test Vectors==
>>
>> TBD
>>
>> ==Backwards Compatibility==
>>
>> <tt>combo()</tt> descriptors use the format and general operation
>> specified in [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
>> As this is a wholly new descriptor, it is not compatible with any
>> implementation.
>> However the scripts produced are standard scripts so existing software
>> are likely to be familiar with them.
>>
>> ==Reference Implemntation==
>>
>> <tt>combo</tt> descriptors have been implemented in Bitcoin Core since
>> version 0.17.
>>
>> ---
>>
>> <pre>
>> BIP: bip-descriptors-encap
>> Layer: Applications
>> Title: raw() and addr() Output Script Descriptors
>> Author: Andrew Chow <andrew at achow101.com>
>> Pieter Wuille <pieter at wuille.net>
>> Comments-Summary: No comments yet.
>> Comments-URI:
>> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-raw
>> Status: Draft
>> Type: Informational
>> Created: 2021-06-27
>> License: BSD-2-Clause
>> </pre>
>>
>> ==Abstract==
>>
>> This document specifies <tt>raw()</tt> and <tt>addr()</tt> output script
>> descriptors.
>> <tt>raw()</tt> encapsulates a raw script as a descriptor.
>> <tt>addr()</tt> encapsulates an address as a descriptor.
>>
>> ==Copyright==
>>
>> This BIP is licensed under the BSD 2-clause license.
>>
>> ==Motivation==
>>
>> In order to make descriptors maximally compatible with scripts in use
>> today, it is useful to be able to wrap any arbitrary output script or an
>> address into a descriptor.
>>
>> ==Specification==
>>
>> Two new script expressions are defined: <tt>raw()</tt> and <tt>addr()</tt>.
>>
>> ===<tt>raw()</tt>===
>>
>> The <tt>raw(HEX)</tt> expression can only be used as a top level descriptor.
>> As the argument, it takes a hex string representing a Bitcoin script.
>> The output script produced by this descriptor is the script represented
>> by <tt>HEX</tt>.
>>
>> ===<tt>addr()</tt>===
>>
>> The <tt>addr(ADDR)</tt> expression can only be used as a top level
>> descriptor.
>> It takes an address as its single argument.
>> The output script produced by this descriptor is the output script
>> produced by the address <tt>ADDR</tt>.
>>
>> ==Test Vectors==
>>
>> TBD
>>
>> ==Backwards Compatibility==
>>
>> <tt>raw()</tt> and <tt>addr()</tt> descriptors use the format and
>> general operation specified in
>> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
>> As this is a wholly new descriptor, it is not compatible with any
>> implementation.
>> The reuse of existing Bitcoin addresses allows for this to be more
>> easily implemented.
>>
>> ==Reference Implemntation==
>>
>> <tt>raw()</tt> and <tt>addr</tt> descriptors have been implemented in
>> Bitcoin Core since version 0.17.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210702/12a7e13b/attachment-0001.html>

From jlrubin at mit.edu  Fri Jul  2 22:20:16 2021
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 2 Jul 2021 15:20:16 -0700
Subject: [bitcoin-dev] CheckSigFromStack for Arithmetic Values
Message-ID: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>

Dear Bitcoin Devs,

It recently occurred to me that it's possible to do a lamport signature in
script for arithmetic values by using a binary expanded representation.
There are some applications that might benefit from this and I don't recall
seeing it discussed elsewhere, but would be happy for a citation/reference
to the technique.

blog post here, https://rubin.io/blog/2021/07/02/signing-5-bytes/, text
reproduced below

There are two insights in this post:

1. to use a bitwise expansion of the number
2. to use a lamport signature

Let's look at the code in python and then translate to bitcoin script:

```python
def add_bit(idx, preimage, image_0, image_1):
    s = sha256(preimage)
    if s == image_1:
        return (1 << idx)
    if s == image_0:
        return 0
    else:
        assert False

def get_signed_number(witnesses : List[Hash], keys : List[Tuple[Hash,
Hash]]):
    acc = 0
    for (idx, preimage) in enumerate(witnesses):
        acc += add_bit(idx, preimage, keys[idx][0], keys[idx][1])
    return x
```

So what's going on here? The signer generates a key which is a list of
pairs of
hash images to create the script.

To sign, the signer provides a witness of a list of preimages that match
one or the other.

During validation, the network adds up a weighted value per preimage and
checks
that there are no left out values.

Let's imagine a concrete use case: I want a third party to post-hoc sign a
sequence lock. This is 16 bits.
I can form the following script:


```
<pk> checksigverify
0
SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <1<<1> ADD ELSE <H(K_1_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <1<<2> ADD ELSE <H(K_2_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <1<<3> ADD ELSE <H(K_3_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <1<<4> ADD ELSE <H(K_4_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <1<<5> ADD ELSE <H(K_5_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <1<<6> ADD ELSE <H(K_6_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <1<<7> ADD ELSE <H(K_7_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <1<<8> ADD ELSE <H(K_8_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <1<<9> ADD ELSE <H(K_9_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1<<10> ADD ELSE <H(K_10_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <1<<11> ADD ELSE <H(K_11_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <1<<12> ADD ELSE <H(K_12_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <1<<13> ADD ELSE <H(K_13_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <1<<14> ADD ELSE <H(K_14_0)>
EQUALVERIFY ENDIF
SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <1<<15> ADD ELSE <H(K_15_0)>
EQUALVERIFY ENDIF
CHECKSEQUENCEVERIFY
```

In order to sign a 16 bit value V, the owner of K simply puts on the stack
the
binary representation of V indexed into the K. E.g., to sign `53593`, first
expand to binary `0b1101000101011001`, then put the appropriate K values on
the
stack.

```
K_15_1
K_14_1
K_13_0
K_12_1
K_11_0
K_10_0
K_9_0
K_8_1
K_7_0
K_6_1
K_5_0
K_4_1
K_3_1
K_2_0
K_1_0
K_0_1
<sig>
```


This technique is kind of bulky! It's around 80x16 = 1280 length for the
gadget, and 528 bytes for the witnesses. So it is _doable_, if not a bit
expensive. There might be some more efficient scripts for this -- would a
trinary representation be more efficient?

The values that can be signed can be range limited either post-hoc (using
OP\_WITHIN) or internally as was done with the 16 bit value circuit where
it's
impossible to do more than 16 bits.

Keys *can* be reused across scripts, but signatures may only be constructed
one
time because a third party could take two signed messages and construct an
unintended value (e.g., if you sign both 4 and 2 then a third party could
construct 6).

There are certain applications where this could be used for an effect -- for
example, an oracle might have a bonding contract whereby possessing any
K\_i\_0
and K\_i\_1 allows the burning of funds.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210702/35d44430/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Jul  2 23:58:14 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 02 Jul 2021 23:58:14 +0000
Subject: [bitcoin-dev] CheckSigFromStack for Arithmetic Values
In-Reply-To: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>
References: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>
Message-ID: <YEsEkExygpn5zEqfCXSt8duo9C0tgyx9YBTRejVn8ccwX2SQCPQVP5r2Nav6isQIbK8ED2Z-fYNwcN0VhXpxAIhCd3TWeU1et85cZFIVWdA=@protonmail.com>

Good morning Jeremy,

> Dear Bitcoin Devs,
>
> It recently occurred to me that it's possible to do a lamport signature in script for arithmetic values by using a binary expanded representation. There are some applications that might benefit from this and I don't recall seeing it discussed elsewhere, but would be happy for a citation/reference to the technique.
>
> blog post here, https://rubin.io/blog/2021/07/02/signing-5-bytes/, text reproduced below
>
> There are two insights in this post:
> 1. to use a bitwise expansion of the number
> 2. to use a lamport signature
> Let's look at the code in python and then translate to bitcoin script:
> ```python
> def add_bit(idx, preimage, image_0, image_1):
> ? ? s = sha256(preimage)
> ? ? if s == image_1:
> ? ? ? ? return (1 << idx)
> ? ? if s == image_0:
> ? ? ? ? return 0
> ? ? else:
> ? ? ? ? assert False
> def get_signed_number(witnesses : List[Hash], keys : List[Tuple[Hash, Hash]]):
> ? ? acc = 0
> ? ? for (idx, preimage) in enumerate(witnesses):
> ? ? ? ? acc += add_bit(idx, preimage, keys[idx][0], keys[idx][1])
> ? ? return x
> ```
> So what's going on here? The signer generates a key which is a list of pairs of
> hash images to create the script.
> To sign, the signer provides a witness of a list of preimages that match one or the other.
> During validation, the network adds up a weighted value per preimage and checks
> that there are no left out values.
> Let's imagine a concrete use case: I want a third party to post-hoc sign a sequence lock. This is 16 bits.
> I can form the following script:
> ```
> <pk> checksigverify
> 0
> SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <1<<1> ADD ELSE <H(K_1_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <1<<2> ADD ELSE <H(K_2_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <1<<3> ADD ELSE <H(K_3_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <1<<4> ADD ELSE <H(K_4_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <1<<5> ADD ELSE <H(K_5_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <1<<6> ADD ELSE <H(K_6_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <1<<7> ADD ELSE <H(K_7_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <1<<8> ADD ELSE <H(K_8_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <1<<9> ADD ELSE <H(K_9_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1<<10> ADD ELSE <H(K_10_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <1<<11> ADD ELSE <H(K_11_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <1<<12> ADD ELSE <H(K_12_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <1<<13> ADD ELSE <H(K_13_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <1<<14> ADD ELSE <H(K_14_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <1<<15> ADD ELSE <H(K_15_0)> EQUALVERIFY ENDIF
> CHECKSEQUENCEVERIFY
> ```

This took a bit of thinking to understand, mostly because you use the `<<` operator in a syntax that uses `< >` as delimiters, which was mildly confusing --- at first I thought you were pushing some kind of nested SCRIPT representation, but in any case, replacing it with the actual numbers is a little less confusing on the syntax front, and I think (hope?) most people who can understand `1<<1` have also memorized the first few powers of 2....

> ```
> <pk> checksigverify
> 0
> SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <2> ADD ELSE <H(K_1_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <4> ADD ELSE <H(K_2_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <8> ADD ELSE <H(K_3_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <16> ADD ELSE <H(K_4_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <32> ADD ELSE <H(K_5_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <64> ADD ELSE <H(K_6_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <128> ADD ELSE <H(K_7_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <256> ADD ELSE <H(K_8_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <512> ADD ELSE <H(K_9_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1024> ADD ELSE <H(K_10_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <2048> ADD ELSE <H(K_11_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <4096> ADD ELSE <H(K_12_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <8192> ADD ELSE <H(K_13_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <16384> ADD ELSE <H(K_14_0)> EQUALVERIFY ENDIF
> SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <32768> ADD ELSE <H(K_15_0)> EQUALVERIFY ENDIF
> CHECKSEQUENCEVERIFY
> ```

On the other hand LOL WTF, this is cool.

Basically you are showing that if we enable something as innocuous as `OP_ADD`, we can implement Lamport signatures for **arbitrary** values representable in small binary numbers (16 bits in the above example).

I was thinking "why not Merkle signatures" since the pubkey would be much smaller but the signature would be much larger, but (a) the SCRIPT would be much more complicated and (b) in modern Bitcoin, the above SCRIPT would be in the witness stack anyway so there is no advantage to pushing the size towards the signature rather than the pubkey, they all have the same weight, and since both Lamport and Merkle are single-use-only and we do not want to encourage pubkey reuse even if they were not, the Merkle has much larger signature size, so Merkle sigs end up more expensive.

Regards,
ZmnSCPxj

From dave at dtrt.org  Sat Jul  3 03:24:05 2021
From: dave at dtrt.org (David A. Harding)
Date: Fri, 2 Jul 2021 17:24:05 -1000
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
Message-ID: <20210703032405.j3mru5rbag5sbfil@ganymede>

On Tue, Jun 29, 2021 at 09:14:39PM +0000, Andrew Chow via bitcoin-dev wrote:
> *** Optionally followed by a single <tt>/*</tt> or <tt>/*'</tt> final
> step to denote all direct unhardened or hardened children.
> 
> [...]
> 
> In the above specification, the hardened indicator <tt>'</tt> may be
> replaced with alternative hardnened indicators of <tt>h</tt> or <tt>H</tt>.

Is there any chance we can take this opportunity to make "h"/"H" the
preferred aliases?  Using "'" in bourne-style shells is very
annoying[1], and I suspect it's also creating unnecessary complications
elsewhere.

Alternatives:

- Completely kill "'" (I'd prefer this, but I realize it's complicated
  with descriptors already being used widely).  If "h"/"H" are made the
  preferred aliases, maybe it'd be enough to make implementing "'" a
  SHOULD rather than a MUST; this would push implementations towards
  displaying descriptors using the h versions for maximum compatibility.

- Calculate the checksum over s/(h|H)/'/ (again, I know that's
  complicated with descriptors already widely used)

Thanks,

-Dave

[1] https://github.com/bitcoin/bitcoin/issues/15740#issuecomment-695815432

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210702/ea8e1323/attachment.sig>

From jlrubin at mit.edu  Sat Jul  3 04:01:01 2021
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 2 Jul 2021 21:01:01 -0700
Subject: [bitcoin-dev] CheckSigFromStack for Arithmetic Values
In-Reply-To: <YEsEkExygpn5zEqfCXSt8duo9C0tgyx9YBTRejVn8ccwX2SQCPQVP5r2Nav6isQIbK8ED2Z-fYNwcN0VhXpxAIhCd3TWeU1et85cZFIVWdA=@protonmail.com>
References: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>
 <YEsEkExygpn5zEqfCXSt8duo9C0tgyx9YBTRejVn8ccwX2SQCPQVP5r2Nav6isQIbK8ED2Z-fYNwcN0VhXpxAIhCd3TWeU1et85cZFIVWdA=@protonmail.com>
Message-ID: <CAD5xwhggR_uC-Dx9S8kXj-j8L2EdXhmXdGmht05wC6nB3Xn_+w@mail.gmail.com>

Yep -- sorry for the confusing notation but seems like you got it. C++
templates have this issue too btw :)

One cool thing is that if you have op_add for arbitrary width integers or
op_cat you can also make a quantum proof signature by signing the signature
made with checksig with the lamport.

There are a couple gotchas wrt crypto assumptions on that but I'll write it
up soon ? it also works better in segwit V0 because there's no keypath
spend -- that breaks the quantum proofness of this scheme.

On Fri, Jul 2, 2021, 4:58 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Jeremy,
>
> > Dear Bitcoin Devs,
> >
> > It recently occurred to me that it's possible to do a lamport signature
> in script for arithmetic values by using a binary expanded representation.
> There are some applications that might benefit from this and I don't recall
> seeing it discussed elsewhere, but would be happy for a citation/reference
> to the technique.
> >
> > blog post here, https://rubin.io/blog/2021/07/02/signing-5-bytes/, text
> reproduced below
> >
> > There are two insights in this post:
> > 1. to use a bitwise expansion of the number
> > 2. to use a lamport signature
> > Let's look at the code in python and then translate to bitcoin script:
> > ```python
> > def add_bit(idx, preimage, image_0, image_1):
> >     s = sha256(preimage)
> >     if s == image_1:
> >         return (1 << idx)
> >     if s == image_0:
> >         return 0
> >     else:
> >         assert False
> > def get_signed_number(witnesses : List[Hash], keys : List[Tuple[Hash,
> Hash]]):
> >     acc = 0
> >     for (idx, preimage) in enumerate(witnesses):
> >         acc += add_bit(idx, preimage, keys[idx][0], keys[idx][1])
> >     return x
> > ```
> > So what's going on here? The signer generates a key which is a list of
> pairs of
> > hash images to create the script.
> > To sign, the signer provides a witness of a list of preimages that match
> one or the other.
> > During validation, the network adds up a weighted value per preimage and
> checks
> > that there are no left out values.
> > Let's imagine a concrete use case: I want a third party to post-hoc sign
> a sequence lock. This is 16 bits.
> > I can form the following script:
> > ```
> > <pk> checksigverify
> > 0
> > SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <1<<1> ADD ELSE <H(K_1_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <1<<2> ADD ELSE <H(K_2_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <1<<3> ADD ELSE <H(K_3_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <1<<4> ADD ELSE <H(K_4_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <1<<5> ADD ELSE <H(K_5_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <1<<6> ADD ELSE <H(K_6_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <1<<7> ADD ELSE <H(K_7_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <1<<8> ADD ELSE <H(K_8_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <1<<9> ADD ELSE <H(K_9_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1<<10> ADD ELSE <H(K_10_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <1<<11> ADD ELSE <H(K_11_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <1<<12> ADD ELSE <H(K_12_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <1<<13> ADD ELSE <H(K_13_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <1<<14> ADD ELSE <H(K_14_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <1<<15> ADD ELSE <H(K_15_0)>
> EQUALVERIFY ENDIF
> > CHECKSEQUENCEVERIFY
> > ```
>
> This took a bit of thinking to understand, mostly because you use the `<<`
> operator in a syntax that uses `< >` as delimiters, which was mildly
> confusing --- at first I thought you were pushing some kind of nested
> SCRIPT representation, but in any case, replacing it with the actual
> numbers is a little less confusing on the syntax front, and I think (hope?)
> most people who can understand `1<<1` have also memorized the first few
> powers of 2....
>
> > ```
> > <pk> checksigverify
> > 0
> > SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <2> ADD ELSE <H(K_1_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <4> ADD ELSE <H(K_2_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <8> ADD ELSE <H(K_3_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <16> ADD ELSE <H(K_4_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <32> ADD ELSE <H(K_5_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <64> ADD ELSE <H(K_6_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <128> ADD ELSE <H(K_7_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <256> ADD ELSE <H(K_8_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <512> ADD ELSE <H(K_9_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1024> ADD ELSE <H(K_10_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <2048> ADD ELSE <H(K_11_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <4096> ADD ELSE <H(K_12_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <8192> ADD ELSE <H(K_13_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <16384> ADD ELSE <H(K_14_0)>
> EQUALVERIFY ENDIF
> > SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <32768> ADD ELSE <H(K_15_0)>
> EQUALVERIFY ENDIF
> > CHECKSEQUENCEVERIFY
> > ```
>
> On the other hand LOL WTF, this is cool.
>
> Basically you are showing that if we enable something as innocuous as
> `OP_ADD`, we can implement Lamport signatures for **arbitrary** values
> representable in small binary numbers (16 bits in the above example).
>
> I was thinking "why not Merkle signatures" since the pubkey would be much
> smaller but the signature would be much larger, but (a) the SCRIPT would be
> much more complicated and (b) in modern Bitcoin, the above SCRIPT would be
> in the witness stack anyway so there is no advantage to pushing the size
> towards the signature rather than the pubkey, they all have the same
> weight, and since both Lamport and Merkle are single-use-only and we do not
> want to encourage pubkey reuse even if they were not, the Merkle has much
> larger signature size, so Merkle sigs end up more expensive.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210702/e507efdd/attachment-0001.html>

From achow101-lists at achow101.com  Sat Jul  3 05:12:35 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Sat, 03 Jul 2021 05:12:35 +0000
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <20210703032405.j3mru5rbag5sbfil@ganymede>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <20210703032405.j3mru5rbag5sbfil@ganymede>
Message-ID: <ad7657ea-0c35-f065-1788-cc8663bf94b5@achow101.com>

On 7/2/21 11:24 PM, David A. Harding wrote:
> Is there any chance we can take this opportunity to make "h"/"H" the
> preferred aliases?  Using "'" in bourne-style shells is very
> annoying[1], and I suspect it's also creating unnecessary complications
> elsewhere.
I've updated the text to use "h".
> Alternatives:
>
> - Completely kill "'" (I'd prefer this, but I realize it's complicated
>    with descriptors already being used widely).  If "h"/"H" are made the
>    preferred aliases, maybe it'd be enough to make implementing "'" a
>    SHOULD rather than a MUST; this would push implementations towards
>    displaying descriptors using the h versions for maximum compatibility.
Since there already are software implementing descriptors, I don't think
we can do this. I'm not sure about making "'" a SHOULD either.
> - Calculate the checksum over s/(h|H)/'/ (again, I know that's
>    complicated with descriptors already widely used)
This has been discussed in the past and the conclusion was that the
checksum should be strictly over the string itself. This would allow for
dumb checksum checkers which don't have to be able to parse descriptors
in order to check the checksum.

Thanks,
Andrew

>
> Thanks,
>
> -Dave
>
> [1] https://github.com/bitcoin/bitcoin/issues/15740#issuecomment-695815432



From jlrubin at mit.edu  Fri Jul  2 22:32:24 2021
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 2 Jul 2021 15:32:24 -0700
Subject: [bitcoin-dev] Templates, Eltoo, and Covenants, Oh My!
Message-ID: <CAD5xwhg7ksET7YjsJ4BnQW-pdmVSbuueEKzdJvTYH8KoHgQLZA@mail.gmail.com>

Dear Bitcoin Devs,

I recently put a blog post up which is of interest for this list. Post
available here: https://rubin.io/blog/2021/07/02/covenants/ (text
reproduced below for archives).

The main technical points of interest for this list are:

1) There's a similar protocol to Eltoo built with CSFS + CTV
2) There may be a similar protocol to Eltoo with exclusively CSFS

I'm curious if there's any sentiment around if a soft fork enabling CSFS is
controversial? Or if there are any thoughts on the design questions posed
below (e.g., splitting r and s value).

Best,

Jeremy

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

If you've been following The Discourse, you probably know that Taproot is
merged, locked in, and will activate later this November. What you might not
know is what's coming next... and you wouldn't be alone in that. There are a
number of fantastic proposals floating around to further improve Bitcoin,
but
there's no clear picture on what is ready to be added next and on what
timeline. No one -- core developer, technically enlightened individuals,
power
users, or plebs -- can claim to know otherwise.


In this post I'm going to describe 4 loosely related possible upgrades to
Bitcoin -- SH_APO (BIP-118), OP_CAT, OP_CSFS, and OP_CTV (BIP-119). These
four
upgrades all relate to how the next generation of stateful smart contracts
can
be built on top of bitcoin. As such, there's natural overlap -- and
competition
-- for mindshare for review and deployment. This post is my attempt to
stitch
together a path we might take to roll them out and why that ordering makes
sense. This post is for developers and engineers building in the Bitcoin
space,
but is intended to be followable by anyone technical or not who has a keen
interest in Bitcoin.


## Bitcoin Eschews Roadmaps and Agendas.


I provide this maxim to make clear that this document is by no means an
official roadmap, narrative, or prioritization. However, it is my own
assessment of what the current most pragmatic approach to upgrading Bitcoin
is,
based on my understanding of the state of outstanding proposals and their
interactions.


My priorities in producing this are to open a discussion on potential new
features, risk minimization, and pragmatic design for Bitcoin.


### Upgrade Summaries


Below follows summaries of what each upgrade would enable and how it works.
You
might be tempted to skip it if you're already familiar with the upgrades,
but I
recommend reading in any case as there are a few non obvious insights.


#### APO: SIGHASH_ANYPREVOUT, SIGHASH_ANYPREVOUTANYSCRIPT


Currently proposed as
[BIP-118](
https://github.com/bitcoin/bips/blob/d616d5492bc6e6566af1b9f9e43b660bcd48ca29/bip-0118.mediawiki).



APO provides two new signature digest algorithms that do not commit to the
coin
being spent, or the current script additionally. Essentially allowing
scripts
to use outputs that didn?t exist at the time the script was made. This
would be
a new promise enforced by Bitcoin (ex. ?You can close this Lightning channel
and receive these coins if you give me the right proof. If a newer proof
comes
in later I?ll trust that one instead.?).


APO?s primary purpose is to enable off chain protocols like
[Eltoo](https://blockstream.com/2018/04/30/en-eltoo-next-lightning/), an
improved non-punitive payment channel protocol.


APO can also
[emulate](
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-June/017038.html
)
some of the main features of CTV and could be made to work with Sapio,
partially. See the complimentary upgrades section for more detail.


#### CAT (+ variants)


Currently no BIP. However, CAT exists in
[Elements](
https://github.com/ElementsProject/elements/blob/bd2e2d5c64d38286b2ca0519f1215bed228e4dcf/src/script/interpreter.cpp#L914-L933
)
and [Bitcoin
Cash](
https://github.com/bitcoincashorg/bitcoincash.org/blob/3e2e6da8c38dab7ba12149d327bc4b259aaad684/spec/may-2018-reenabled-opcodes.md
)
as a 520 byte limited form, so a proposal for Bitcoin can crib heavily from
either.


Cat enables appending data onto other pieces of data. Diabolically simple
functionality that has many advanced use cases by itself and in concert with
other opcodes. There are many "straightforward" use cases of cat like
requiring
sighash types, requiring specific R values, etc, but there are too many
devious
use cases to list here.  Andrew Poelstra has a decent blogpost series ([part
1](https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html) and
[part
ii](https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-ii.html))
if
you're interested to read more. In particular, with much cleverness, it
seems
possible one could implement full covenants with just CAT, which covers
(inefficiently) most of the other techniques discussed in this post.


#### CSFS: CHECKSIGFROMSTACK


Currently no BIP. However, CSFS exists in
[Elements](
https://github.com/ElementsProject/elements/blob/bd2e2d5c64d38286b2ca0519f1215bed228e4dcf/src/script/interpreter.cpp#L1580-L1618
)
and in [Bitcoin
Cash](
https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/op_checkdatasig.md
),
so a proposal for Bitcoin can crib heavily from either.


CSFS enables checking of a signature against a message and key from the
stack
without including any transaction data.


Use cases include oracle protocols, key delegations, a [channel update
invalidation
variant](
https://stanford2017.scalingbitcoin.org/files/Day1/SB2017_script_2_0.pdf)
(Laolu claims this can be tweaked to be fully non punitive like eltoo, but
you'll need to bug him to write it up), and (+CAT) full covenants.




#### CTV: OP_CHECKTEMPLATEVERIFY


Currently proposed as
[BIP-119](https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki).


CTV enables committing to a specific "next" transaction from script. This is
the ability to make an unbreakable promise on chain which Bitcoin can
enforce
(e.g. ?This coin can only be spent to my multisig, or my backup after a
timelock?). This is a departure from normal script which is traditionally
only
concerned with restrictions on the sender, CTV imposes restrictions on the
recipient. More technically, CTV is essentially the ability to embed a
signature of a specific transaction inside of a script without needing any
elliptic curve operations. The validation costs are low. For more advanced
logic, you can nest multiple different CTV Hashes either using taproot or
up to
the script length limits in regular script.


CTV can be used for vaults, channels, and [many other
uses](https://utxos.org/uses/). There?s also
[Sapio](https://learn.sapio-lang.org) which is a language and toolkit for
creating many kinds of programs with CTV.


CTV compliments CSFS to be able to emulate APO-like functionality
sufficient to build Eltoo, potentially making APO feature-wise redundant.


## Comparative Analysis


Now that we've got the basics covered, let's explore these upgrades
comparatively across several dimensions.


### Design Specificity


"Design Specificity" is a subjective measure of how substantially an upgrade
could change from its current design while still meeting the features
goals. It
is not to be confused with security or safety. Ranked in order from most to
least design specific, with non-exhaustive lists of design questions based
on
ongoing community discourse as well as my own personal understanding of what
might be desirable.


1. CSFS
2. CTV
3. CAT
4. APO


#### Explanations & Open Questions:
1. CSFS is very simple and there is essentially a single way to implement
it. Three open questions are:
   1. Should CSFS require some sort of tagged hash? Very likely answer is
no --
      tags interfere with certain use cases)
   2. Should CSFS split the signature's R & S value stack items for some
      applications that otherwise may require OP_CAT? E.g. using a pinned R
    value allows you to extract a private key if ever double signed, using
2 R
    values allows pay-to-reveal-key contracts. Most likely answer is no, if
that is
    desired then OP_CAT can be introduced
   3. Should CSFS support a cheap way to reference the taproot internal or
      external key? Perhaps, can be handled with undefined upgradeable
    keytypes. One might want to use the internal key, if the signed data
should be
    valid independent of the tapscript tree.  One might want to use the
external
    key, if the data should only be valid for a single tapscript key + tree.
2. CTV is a commitment to all data that can malleate TXID besides the inputs
   being spent, therefore CTV does not have much space for variation on
design.
   1. Should the digest be reordered or formatted differently? If there were
      more data on what types of covenants might be built in the future, a
    better order could be picked. Some thought has already gone into an
order and
    commitments that make covenants easier, see the BIP for more. It's also
    possible the serialization format for the variable length fields
(scriptsigs,
    outputs) could be changed to make it easier to work with from script.
(Maybe,
    minor change)
   2. Should CTV include more template types? Possibly, CTV includes an
upgrade
      mechanism baked in for new template types, so it is extensible for
future
    purposes.
   3. Should CTV commit to the amounts? CTV does not commit to the amount
that
      a coin has. Input-inspecting functionality should be handled by
separate
    opcodes, as CTV would be overly restrictive otherwise. E.g. dynamic fees
    through new inputs would be harder: given CTV's design it is not
possible to
    detect which field did not match therefore it is not possible to script
against
    unexpected amount sent errors without some compromise (e.g. timeouts).
3. CAT is simplistic, and there are really few ways to implement it.
However,
   because it requires some restrictions for security, there are difficult
to
    answer open design questions:
   1. What is the appropriate maximum stack size CAT should permit?
Currently
      the design in Elements is 520 bytes, the max general stack size
permitted
    in script.
   2. Should CAT be introduced or
      [SHASTREAM](https://github.com/ElementsProject/elements/pull/817),
    SUBSTRING, or another variant? There is a strong argument for SHASTREAM
because
    when constructing covenants (e.g. for use with CTV) based on TX data
it's
    possible for size of a data field (e.g., serialization of all outputs)
to
    exceed 520 bytes.
4. There are many tough questions that the community has grappled with
during
   APO's design and engineering process, generally asking how APO-like
    techniques can be made 'Generally Safe' given iit breaks current
assumptions
    around address reuse.
   1. Should APO require chaperone signatures (in order to ensure that
replay
      is not done by 3rd parties)? Current Answer: No, anyone is free to
burn
    their keys by revealing them to similar effect.
   2. Should APO use key tagging to mark keys that can use APO: Current
Answer:
      yes, APO should be "double opt-in" (both requiring a tag and a signer
to
    produce such a signature)
   3. Should APO allow signing with the external taproot key: Current
Answer:
      no, because it makes APO not "double opt-in".
   4. Should APO optimize signing with the internal taproot key? Answer:
      default key 0x01 refers to taproot internal key, so it can be made
    cheaper if you're going to need it without having to repeat the entire
key.
   5. Should APO commit to the signing script? Answer: let's do two
variants.
   6. Should APO instead be a larger refactoring of sighash logic that
      encapsulates APO (e.g. sighash bitmasks)? Current Answer: No, APO is
good
    enough to ship as is and doesn't preclude future work.


### Safety


This category covers how "safe" each change is ranked from safest to least
safe. What makes a change more or less safe is how limited and foreseeable
the
uses are of a specific opcode, in other words, how well we understand what
it
can do or where it might interact poorly with deployed infrastructure.

1. CTV
2. CSFS
3. APO
4. CAT


CTV is the safest new feature since fundamentally what it introduces is very
similar to what can be done with pre-signed transactions, so it is only a
pivot
on trust and interactivity. Where there is some risk from CTV is that
addresses
(or rather, invoices) that are reused might have the same program behind
them
which could cause unintended behavior. This differs from the reuse problem
in
APO because the problem is stateless, that is, if you verify what is behind
an
address you will know what exists and does not exist. E.g., two payment
channel
addresses will create distinct payment channels that updates cannot be
replayed
across. In contrast with APO, paying one APO using address twice creates two
instances of the same channel, state updates from one channel can be used on
the other.


CSFS is the next safest, it is just a small piece of authenticated data.
CSFS
and CTV are relatively close in terms of safety, but CSFS is slightly less
safe
given a remote possibility of surprising  uses of it to perform unforeseen
elliptic curve operations. This functionality already exists for up to
5-byte
messages. A hash preimage revelation can emulate a signer compactly. Using
binary expansions and addition could be used to allow signing of values more
compactly (e.g., 2x16x32 byte hashes could be used to construct a signature
of
a post-hoc selected Sequence lock). [Read more
here](/blog/2021/07/02/signing-5-bytes/). Therefore it is appropriate to
think of
CSFS as an expansion of the efficiency of this technique, reusability of
keys,
and the types of data that can be signed over. Although CSFS is famously
used
to build covenants by comparing a CSFS signature to a CHECKSIG signature and
getting transaction data onto the stack, CSFS cannot do that without CAT.


APO. This is the next safest because APO has some questions around key reuse
safety and statefulness of information. See the above description in CTV for
why this is tangibly worse for APO than CTV. [See more discussion of APO's
safety & design trade offs
here](
https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-September/002176.html).



CAT is the least 'safe' in terms of extant Bitcoin concepts as it is highly
likely CAT introduces at least advanced covenants if added, especially in
conjunction with the above opcodes, but may also enable other unintended
functionality. CAT is a source of continual surprise with regards to what it
enables in composition with existing opcodes, therefore a systematic review
of
composability and known uses should be done before considering it. That CAT
was
forked out by Satoshi is of limited relevance as the variant proposed for
reintroduction would not have the vulnerability present initially.


### Complimentary Upgrades


Pairings of upgrades can work together to deliver functionality that neither
could alone:


1. CAT + CSFS: full blown arbitrary covenants
   1. With arbitrary covenants you can deploy many different kinds of smart
      contracts which are out of scope for this article.
2. CAT + CTV: Expanded covenants
   1. slightly simpler to use interface but fewer features than CSFS + CAT
which can
      covenant over witness data and inputs.
3. CTV + CSFS: Eltoo
    1. This can add very similar functionality to eltoo with the script
fragment:
    `CTV <musig(pka, pkb)> CSFS <S+1> CLTV`
    The protocol is essentially identical to the Eltoo paper, however there
are
    a couple subtle differences required for dynamic fee rates.
4. CTV + APO: Slightly Different
   1. It's commonly claimed that APO is a perfect substitute for CTV. This
is
      false. Their digests are slightly different, as such there are some
niche
    smart contracts that could use the differences in commitment structure
for
    interesting effects (CTV commits to all scriptsigs and sequences, APO
cannot
    cover that data but can cover a few variants of less data covered).


By all means not an exhaustive list -- feel free to message me with
additions.


### Recommendation


My recommendation is to deliver the upgrades described in this document in
the
following order:


1. CTV
2. CSFS
3. APO
4. CAT/SHASTREAM/SUBSTRING/etc


This recommendation comes as a synthesis of the thoughts above on the
composability, safety, and open design considerations of the various
proposals
currently in flight.


With CTV in place, we can begin experimenting with a wide variety of
contracts
using the Sapio toolchain, as well as improve and invest in maturing the
toolchain. Mature toolchains will make it easier to safely engineer and
deploy
applications making use of CTV and future upgrades.


CSFS is an independent change that can be deployed/developed in parallel to
or
before CTV, the implementation from Elements could be easily ported to
Bitcoin.
With CSFS and CTV, Eltoo-like constructions will be possible as well.


APO can then be deployed as an optimization to existing use patterns driven
by
market adoption of CTV+CSFS based use. This also gives us time to kick the
can
down the road on the design questions that APO prompts around
generalization of
signature digests and key reuse safety.  A similar approach was [discussed
on
the mailing
list](
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016996.html
),
but without the insight that CSFS + CTV was sufficient for Eltoo like
constructions, requiring CAT instead.


Lastly, OP_CAT can be delivered as part of an effort towards generalized
arbitrary covenants and perhaps in conjunction with some special purpose
opcodes (such as OP_CHECKINPUT) that can more easily handle common cases.
CAT,
although it has safe implementations used in Elements, deserves very strict
scrutiny given it's documented surprising uses.


This approach represents a gradual relaxation of Bitcoin's restrictions
around
smart contract programming that introduces useful, safe primitives and gives
the community time to build and deploy useful infrastructure. The path
described in this post is an opportunity to upgrade bitcoin with simple
primitives that compose nicely for permissionless innovation.


_Thanks to those who reviewed drafts of this post and provided valuable
feedback improving the clarity and accuracy of this post, including
[pyskell](https://github.com/pyskell), [Keagan
McClelland](https://twitter.com/ProofOfKeags), [Ryan
Gentry](https://twitter.com/RyanTheGentry), and [Olaoluwa
Osuntokun](https://twitter.com/roasbeef). Edit + Feedback &#8800;
Endorsement._

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210702/cd70c3e7/attachment-0001.html>

From raymo at riseup.net  Sat Jul  3 08:02:09 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Sat, 03 Jul 2021 01:02:09 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
Message-ID: <e843b5c28690557402b72fcd158dc1c2@riseup.net>

Hi Billy,

> What if it was possible for the creditor to claw back the funds
As far as I know the ?claw back? mechanism doesn?t exist in Bitcoin
system, and probably most Bitcoiners won?t be agree on it. 
Even if we want to add claw back to Bitcoin in general, and Sabu in
particular, it would add too complexities and uncertainty to Bitcoin. 
So, it would be better to not touch that part, instead focusing on
reduce the cheating risk by putting some penalty for both issuers,
creditors and miners. 
We already have the penalties for both issuers and creditors. 
It looks the miners still can abuse Sabu, but as I told before the miner
or better say the mining pool must be issuer (to be able to sign the
promised UTXO in cheating way) or must be creditor (in order to have a
copy of GT and not lose his money in favor of a stranger miner. Remember
the fact that creditor will lose 70% of their money in favor of Bitcoin
transaction fee in a typical GT) or collaborate one of them in a
conspiracy. Otherwise, there will be no economic benefit in this attack.
 
All these 3 cases of the attacks, theoretically could be happened, but
the risk to reward ratio is enough high to hinder potential malevolent
from a practical act.
Even this very small risk of miner attacks (which don?t care the attack
costs, since he is not interested in economic benefit, but he wants to
ruin Sabu), would be resolved by a slightly upgrade in Bitcoin protocol
by applying the BIPxxx ?for flagging/unflagging promised UTXOs?. 
I am not in rush to apply this upgrade on Bitcoin protocol, instead I am
actively working in order to realize the Sabu protocol and Gazin wallet.
Later the Sabu community will carry the BIPxxx.

Best

On 2021-07-02 17:57, Billy Tetrud wrote:
> Thanks for the details Raymo. A thought occurred to me. Given the fact
> that miners can abuse this system without penalty, it would be useful
> to be able to fix this. What if it was possible for the creditor to
> claw back the funds even if the cheating transaction was mined instead
> of the guarantee transaction? Let's say there was a way to sign a
> transaction that gives the receiver of that transaction the ability to
> override any other transaction that uses the UTXO? If this were
> possible, the issuer could give the creditor this kind of transaction
> as the guarantee transaction, and in the case a cheat was done, the
> creditor could still use the GT to reallocate that UTXO to themselves.
> 
> Now there are issues with this. First of all, it could give anyone the
> ability to double spend. So it would be prudent to limit this in some
> way. The revocation probably should only be valid for up to 6 blocks,
> such that if the transaction has 6 confirmations, it can no longer be
> reallocated (thus preserving the 6 block finality rule). It could also
> be required that the UTXO be marked as opting into this behavior (so
> receivers would know about the possibility it could get revoked). This
> second requirement would require Sabu issuers to make an on-chain
> transaction to set themselves up as an issuer. 
> 
> Another issue is that this would make it possible for transactions to
> expire. Any claw-back transaction would expire 6 blocks after the
> initial transaction happened. This has been generally avoided in
> bitcoin, but I think the relevant issues are solvable. You can find
> additional discussion of that in this thread [1].
> 
> I would imagine this kind of ability would be pretty controversial,
> but since it can close out the possibility for miners to escape
> punishment, it could make this protocol viable. 
> 
> On Thu, Jul 1, 2021 at 3:15 PM <raymo at riseup.net> wrote:
> 
>> Hi Erik
>>
>> Please correct me if I misunderstood.
>>
>>> email is fully compromised.
>>
>> What I got is:
>> Email is not good because the sender and receiver are compromised.
>> Email is not good because the message content is revealed.
>> I can claim same argue about any other client/server model. Since
>> the
>> server (website) service provider will ask some sort of KYC. And
>> even if
>> the server uses end-to-end encryption, the provider company still
>> can
>> read the packets content.
>> In my model the passive listener only can discover who is
>> communicate to
>> whom and make a graph of connections. Although it is a threat for
>> privacy but the server/client model has this flaw inherently, since
>> provider already knew everything about everyone. In my model at
>> least
>> users can make some fake connections and send some fake emails in
>> order
>> to inject noise to communications.
>> Please note the fact that entire communication between mobile
>> wallets
>> (via emails) are asymmetric PGP encrypted. The PGP keys are
>> controlled
>> by end users unlike ALL pretending secure messengers (e.g whatsApp,
>> signal, zoom,?).
>> If you are worried about the way of exchanging PGP public key, you
>> are
>> right. The most secure way is in-person PGP key exchanging.
>> After that for payments the wallets communicate in pgp encrypted
>> messages and they can transfer Bitcoin address through an PGP
>> encrypted
>> cipher, thus no revealing Bitcoin address to public would occur.
>> Neither
>> the amounts of transactions will be reviled.
>> There for it would be a good practice for shops to put their email
>> and
>> PGP public key on shop website and/or PGP public key servers,
>> instead of
>> putting Bitcoin address on website or using 3rd parties services to
>> hide
>> their Bitcoin payment addresses.
>>
>> If I missed some points about ?fully compromised? please write
>> it to me.
>>
>>> public keys / addresses are sent
>> As I told before ALL communication in Sabu are PGP encrypted.
>>
>>> other routing data encrypted with public keys
>>> (not sure how data is routed in sabu)
>>
>> Sabu is not responsible for routing at all. It simply sends emails.
>> Indeed the wallets peer-to-peer network in Sabu is pretty straight
>> forward. Each mobile wallet has one email address as its handler and
>> identifier in mobile-wallets-network. Each mobile can send message
>> to
>> another mobile by knowing its email address and the PGP public key.
>> This information can be prepared in first face-to-face contact of
>> mobile
>> owners, or later (something like signing the other?s public key in
>> web
>> of trust) when a creditor wants to spend his money and transfer it
>> to
>> another creditor. The creditor1 send the signed money transfer
>> request
>> alongside the email and public key of creditor2 all in a PGP
>> encrypted
>> message to issuer.
>>
>>> separate the Sabu protocol from the app... allow others to
>> implement
>>> desktop version, or other versions that use other routing systems
>>
>> Indeed, it is my approach too. As I told before users will decide
>> between an unstoppable, permission less, self-sovereignty and
>> decentralized pure peer-to-peer communication network (with some
>> resolvable privacy issues) or some efficient, privacy-mimic central
>> limited network.
>>
>>> you can allow direct-entry of a BIP-word-representation
>>> of a public key/address to avoid privacy/central system concerns
>> Agree. Actually, I was thinking about an easy mechanism to share
>> your
>> public key like what you suggested here.
>> But what I consider for a ?central system concerns? is the
>> ability of
>> communication without dependency to any company.
>> As an example, what can you do if the twitter bans your account?
>> Nothing! Your content and entire connections will be lost.
>> But if you form your friends list in your mobile (or computer) and
>> have
>> their PGP public keys and they have yours, and use email as a dual
>> purpose tool. First as a handler (the tool for finding and to be
>> found
>> in internet) and second as a communication tool.
>> Thus, no one can stop you, ban you or limit you to send/receive
>> transaction to/from anyone.
>> What I am trying to say is using email is far better than account
>> (username) in a limited central service like twitter, Facebook,
>> telegram... or even in future Sabu servers!
>> You have your connections under your control in your phone. You can
>> easily change your email and use a new email or even a new service
>> provider without losing your connections and your control over it.
>> You just sign your new email address and send it to your friends
>> circle
>> and notify them about changes.
>> Of course, email is not good for millions of followers but it is
>> obviously good for managing your payment network of hundreds of
>> people
>> (either issuers or creditors).
>>
>> Best
>> Raymo
>>
>> On 2021-07-01 20:49, Erik Aronesty wrote:
>>> your protocol should always assume the email system is fully
>>> compromised, and only send public information over email:
>>>
>>> - public keys / addresses are sent
>>> - other routing data encrypted with public keys (not sure how data
>> is
>>> routed in sabu)
>>>
>>> your end user should be able to verify public keys  / addresses
>>>
>>> - use QR-codes
>>> - phone calls with users reading BIP words out loud
>>> - other in-person information exchange
>>>
>>> separate the Sabu protocol from the app... allow others to
>> implement
>>> desktop version, or other versions that use other routing systems
>>>
>>> -  you can allow direct-entry of a BIP-word-representation of a
>> public
>>> key/address to avoid privacy/central system concerns
>>>
>>> On Thu, Jul 1, 2021 at 4:20 PM raymo via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>> Hi Billy,
>>>> Sorry for late reply. Let?s jump in proposal.
>>>>
>>>>> Some more information about the benefits of this approach vs
>> alternatives (mainly lightning)
>>>> The most important different is unlike the lightning, in Sabu no
>> one
>>>> have to open a channel and pay Bitcoin transaction fee,
>> subsequently no
>>>> one has to close channel and pay another Bitcoin transaction fee.
>> It is
>>>> the huge improvement since it drops the overhead cost of
>> transactions.
>>>> So, it will be more convenience to trade under Sabu protocol.
>>>> In Sabu none of parties of a transaction are obliged to block
>> money in
>>>> any kind of smart contract or any other m of n signature accounts
>>>> on-chain, so it provides more privacy.
>>>> Since Sabu protocol is designed to motivate people to circulate
>>>> transactions (AKA debt documents) in Sabu network, if every actor
>> act
>>>> rationally no one will aware how much money transferred from who
>> to
>>>> whom.
>>>> In case of fraudulent activity by issuer, the creditor will send
>>>> Guarantee Transaction (GT) to Bitcoin network in order to
>> recapture the
>>>> part of his credit. So, in this case the transaction is literally
>>>> recorded on bitcoin blockchain.
>>>> There is only one another reason to recording transaction on
>> Bitcoin
>>>> blockchain. Where one creditor eager to pay Bitcoin transaction
>> fee in
>>>> order to aggregate thousands or even millions different small
>> amount
>>>> debt-documents in a single transaction on Bitcoin blockchain.
>>>> despite these two cases, the rest of transactions all occur in
>> the Sabu
>>>> network (supposed to be over 99%). Thus, no footprint no
>> bottleneck and
>>>> no over process.
>>>>
>>>> Another important power point of Sabu is its pure-peer-to-peer
>> network
>>>> architecture. In Sabu the mobile wallets communicating to each
>> other
>>>> directly without any central server. There is no centralization
>> at all.
>>>> As a result, there will be no routing as well.
>>>> Since only issuer and creditors are aware of the content of
>> transaction
>>>> (who pay how much to whom) it is a huge privacy improvement,
>> which
>>>> doesn?t exist in other layer 2 solutions.
>>>>
>>>> About the usability of Sabu, although the protocol based on the
>>>> collaborating 2 different peer-to-peer network and 3 classic
>>>> server/client networks, but the end user (mobile wallet user)
>> doesn?t
>>>> see any of these complexities.
>>>> The end user simply installs the mobile/desktop wallet and add
>> her/his
>>>> friends to his phonebook by adding their email address or
>> scanning their
>>>> email (and/or PGP public key). After that s/he can immediately
>> start to
>>>> send/receive Bitcoin through Sabu network. Entire communications
>> between
>>>> wallets are PGP encrypted.
>>>> Another good point in Sabu design is, the 12 seed words are using
>> for
>>>> both Bitcoin wallet private key and the PGP private key. So, it
>> is the
>>>> key of user wealth and its identity as well. For more details,
>> please
>>>> read my previous answer to Alex Schoof.
>>>> The issuer, by using his UTXOs and selling them to creditors earn
>> money.
>>>> the issuer creates the debt document (transaction) by which
>> promises to
>>>> creditor an amount of satoshi. These debt documents are valid
>> Bitcoin
>>>> transaction. The only difference is these transactions are
>> intended to
>>>> circulate in Sabu protocol instead of sending to Bitcoin
>> blockchain.
>>>> Each transaction is a small money transfer. 40,000 Satoshi as
>> input and
>>>> maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as
>> Bitcoin
>>>> transaction fee.
>>>> The creditors will use these received transactions as money and
>> will pay
>>>> it in exchange of goods or services. For each transaction the
>> creditor
>>>> pays 10 Satoshi as Sabu-transaction-fee to issuer.
>>>> Sabu is not custodial service and the UXTOs are always under
>> issuer
>>>> control, unless issuer or creditor send the signed transaction to
>>>> Bitcoin network. When the transaction was recorded in Bitcoin
>>>> blockchain, the creditor can spend proper UTXO in Bitcoin
>> network.
>>>> Imagine million people use their UTXOs in Sabu, they are issuer
>> and
>>>> issue/update/cancel million transactions per second. All they
>> need is a
>>>> mobile wallet. On the other hand, every one by knowing an issuer
>> can buy
>>>> some Satoshi (whit absolutely no KYC), even 1 Dollar or less, and
>> spend
>>>> it, this time Alice really can buy caffe by Bitcoin ;)
>>>> The Bar can install the mobile wallet and every day receives
>> thousands
>>>> of debt documents (transactions), each worth maximum 20,000
>> Satoshi in
>>>> exchange of coffee. And every evening aggregates those small
>>>> transactions to one single transaction and send it to Bitcoin
>> network.
>>>>
>>>>
>>>> The security model of Sabu is pretty straight forward.
>>>> Issuer is the owner of UTXO(s) which will be used in
>> transactions. The
>>>> issuer is and will the only person who creates transactions and
>> sign
>>>> them. The transactions are valid transaction which either issuer
>> or
>>>> creditor can send them to Bitcoin network, but they will never
>> send
>>>> these transactions to Bitcoin network, because of the high
>> Bitcoin
>>>> transaction fee for each single transaction.
>>>> Since issuer is the only one who can sign transaction (spend
>> UTXOs),
>>>> there is a risk of issuer cheating. And no one can stop issuer
>> from
>>>> cheating, because these are his UTXOs and he has the proper
>> private
>>>> keys.
>>>> The Sabu solution is Guarantee transaction. It is a valid
>> transaction
>>>> that issuer has to sign it alongside the Main transaction. In GT
>> both
>>>> issuer and creditor cut a part of their output in favor of
>> Bitcoin
>>>> transaction fee.
>>>> We suppose miners always seeking for more profit, thus in a case
>> there
>>>> are 2 or more transaction are spending same UTXO as input, miner
>> will
>>>> choose transaction with highest feeRate. There is no economically
>>>> benefit for issuer to cheat creditors and pay less transaction
>> fee
>>>> simultaneously. So rationally the issuer won?t cheat creditor.
>>>> It was the simplest explanation of Sabu security model.
>>>>
>>>>> I agree with others that using email is probably not
>> appropriate for a protocol like this. I would highly recommend
>> making your protocol transport-agnostic, allowing users of your
>> protocol to use any transport they want.
>>>> Indeed, the protocol is transparent-agnostic, if I insist of
>> email as a
>>>> user identifier and communicating tool is because of the idea of
>>>> reforming part of internet architecture and make it more
>> decentralized.
>>>> The wallet users can choose classic architecture. In this case
>> mobile
>>>> wallets will connect to a central server and communicate through
>> that
>>>> server (pretty much like all existed mobile wallets). While some
>> users
>>>> decide to use a pure peer-to-peer communication. I knew email has
>> some
>>>> privacy issues but as always it is a tradeoff. Users can decide
>> between
>>>> an unstoppable, permission less, self-sovereignty and
>> decentralized pure
>>>> peer-to-peer communication network (with some resolvable privacy
>> issues)
>>>> or some efficient central limited network.
>>>> Let me know the critics about email. Hopefully this would lead us
>> to
>>>> improve email instead of letting it die. I strongly suggest email
>>>> because it is the ONLY neutral, free ?nonproprietary? and
>> open
>>>> protocol/technology for communication in the world that its
>>>> infrastructure is well-established and is accessible all over the
>> glob.
>>>>
>>>> I tried to explain it more, hope was useful. By the way the
>> complete
>>>> explanation is here
>>>>
>>
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>>>>
>>>>
>>>>
>>>> Regards
>>>> Raymo
>>>>
>>>>
>>>>
>>>> On 2021-06-22 18:20, Billy Tetrud wrote:
>>>>> I would be interested in seeing some more information about the
>>>>> benefits of this approach vs alternatives up front in this
>> write up.
>>>>> Eg how does the security, cost, usability, and privacy compare
>> to the
>>>>> lightning network, which would be the most likely competitor to
>> this
>>>>> idea. It seems clear that there is more counterparty risk here,
>> so it
>>>>> would probably also be very helpful to compare against
>> traditional
>>>>> custodial solutions as well. If you have specific claims on how
>> this
>>>>> system is better than eg lightning in certain contexts, it
>> would be
>>>>> far easier to evaluate the protocol against those claims, and
>> would
>>>>> also be a lot easier for readers to be motivated to read the
>> whole
>>>>> protocol and do a more full analysis.
>>>>>
>>>>> I agree with others that using email is probably not
>> appropriate for a
>>>>> protocol like this. I would highly recommend making your
>> protocol
>>>>> transport-agnostic, allowing users of your protocol to use any
>>>>> transport they want.
>>>>>
>>>>> On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
>>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>
>>>>>> I think you're making a number of assumptions about mining
>> that are
>>>>>> not accurate.
>>>>>>
>>>>>>> First of all, how much chance in finding next block the
>> corrupted
>>>>>> miners have? One percent of all Bitcoin hash powers? Or
>> maximum 5
>>>>>> percent or 10? The cheaters must come up in dividing that 1.2
>>>>>> Bitcoin between. After all the risk/reward must fit them. They
>> can
>>>>>> not be a big mining pool since there is no benefit, so they
>> will be
>>>>>> small miners with low hash rate. If they solve the puzzle and
>>>>>> broadcast the block, no one in the entire Bitcoin network has
>> block
>>>>>> transactions or seen it before in their mempool!
>>>>>>
>>>>>> You're making the assumption that miners won't build on top of
>> a
>>>>>> block
>>>>>> with transactions they have not seen before or transactions
>> that may
>>>>>> contain double spends of unconfirmed inputs, this is not how
>> mining
>>>>>> works, as long as the block passes the consensus rules
>> effectively
>>>>>> all
>>>>>> miners will mine on top of it by default, this behavior is
>>>>>> fundamental
>>>>>> to how mining currently works and is fairly deeply baked into
>> the
>>>>>> current mining infrastructure.
>>>>>>
>>>>>>> Will they accept this block? In theory it is possible and
>> have
>>>>>> 0.01 percent chance but we can eliminate this small
>> possibilities by
>>>>>> a simple BIP for miners.
>>>>>>
>>>>>> What would this BIP look like? I don't see how this could work
>> in a
>>>>>> decentralized way as you would need another way of reaching
>>>>>> consensus
>>>>>> on what defines a valid block. Right now the chance is nearly
>> 100
>>>>>> percent that a miner will mine on top of the latest valid
>> block,
>>>>>> many
>>>>>> pools(most last I checked) will even mine on the next block
>> before
>>>>>> they validate the latest block fully(ie validationless mining)
>> to
>>>>>> reduce their orphan rates.
>>>>>>
>>>>>>> We suppose the miners always control transactions with
>>>>>> doc-watchers and avoid accepting transaction with same UTXO
>> but
>>>>>> different output.
>>>>>>
>>>>>> Miners have different mempool policy/rules for what
>> transactions
>>>>>> they
>>>>>> themselves mine but all miners must mine on the most work
>> chain of
>>>>>> valid blocks otherwise they risk their own blocks being
>> orphaned,
>>>>>> any
>>>>>> miner that does not do this is effectively guaranteed to have
>> their
>>>>>> block orphaned right now.
>>>>>>
>>>>>>> Because of high Bitcoin transaction fee, this guarantee
>>>>>> transaction will take place in next block, even if other
>> transaction
>>>>>> which are using the same UTXO as input existed in mempool.
>>>>>>
>>>>>> When a new transaction is broadcast miners do not immediately
>> start
>>>>>> mining on a block template that includes that transaction, the
>>>>>> template won't even be generated immediately when it enters a
>> miners
>>>>>> mempool in practice, for bandwidth/network efficiency reasons
>> mining
>>>>>> pools batch update the stratum templates/jobs they mine
>> against so
>>>>>> there can be significant latency between the time a
>> transaction is
>>>>>> actually broadcast and hits the miners mempool and the time
>> the
>>>>>> miners
>>>>>> actually switch to mining on top it, these batched updates are
>>>>>> essentially like point in time snapshots of the mempool and
>>>>>> typically
>>>>>> remain valid(as in the pool will accept shares submitted
>> against
>>>>>> that
>>>>>> job as valid) until the bitcoin network finds the next block.
>> I
>>>>>> don't
>>>>>> think these batch updates are done more often than every 30
>> seconds
>>>>>> typically, while often it is on the order of multiple minutes
>>>>>> depending on the pool.
>>>>>>
>>>>>> Regards,
>>>>>> James
>>>>>>
>>>>>> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
>>>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>>>
>>>>>>> Hi,
>>>>>>> I have a proposal for improve Bitcoin TPS and privacy, here
>> is the
>>>>>> post.
>>>>>>>
>>>>>>
>>>>>
>>
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>>>>>>> https://bitcointalk.org/index.php?topic=5344020.0
>>>>>>> Can you please read it and share your idea about it.
>>>>>>>
>>>>>>> Cheers
>>>>>>> Raymo
>>>>>>> _______________________________________________
>>>>>>> bitcoin-dev mailing list
>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>>
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>> _______________________________________________
>>>>>> bitcoin-dev mailing list
>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>  
> 
> Links:
> ------
> [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019050.html

From dave at dtrt.org  Sat Jul  3 10:05:40 2021
From: dave at dtrt.org (David A. Harding)
Date: Sat, 3 Jul 2021 00:05:40 -1000
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <CAPR5oBP+5r8WLOew6zOdp3BzOLNr0vf2SVK028zfgoCSyu2wnA@mail.gmail.com>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <20210703032405.j3mru5rbag5sbfil@ganymede>
 <ad7657ea-0c35-f065-1788-cc8663bf94b5@achow101.com>
 <CAPR5oBP+5r8WLOew6zOdp3BzOLNr0vf2SVK028zfgoCSyu2wnA@mail.gmail.com>
Message-ID: <20210703100540.pr3nsgjhox26hhic@ganymede>

On Sat, Jul 03, 2021 at 10:35:48AM +0200, Craig Raw wrote:
> There is a downside to using "h"/"H" from a UX perspective - taking up more
> space 

Is this a serious concern of yours?  An apostrophe is 1/2 en; an "h" is
1 en; the following descriptor contains three hardened derivations in 149
characters; assuming the average non-'/h character width is 1.5 en, the
difference between 207 en and 208.5 en is barely more than half a
percent.

    pkh([d34db33f/44h/0h/0h]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*)#ml40v0wf

Here's a direct visual comparison: https://gist.github.com/harding/2fbbf2bfdce04c3e4110082f03ae3c80

> appearing as alphanumeric characters similar to the path numbers

First, I think you'd have to be using an awful font to confuse "h" with
any arabic numeral.  Second, avoiding transcription errors is exactly
why descriptors now have checksums.

> they make derivation paths and descriptors more difficult to read.

The example descriptor pasted above looks equally (un)readable to me
whether it uses ' or h.

> Also, although not as important, less efficient when making metal
> backups.

I think many metal backup schemes are using stamps or punch grids that
are fixed-width in nature, so there's no difference either way.  (And
you can argue that h is better since it's part of both the base58check
and bech32 character sets, so you already need a stamp or a grid row for
it---but ' is otherwise unused, so a stamp or grid row for it would be
special).

But even if people are manually etching descriptors into metal, we're
back to the original point where we're looking at something like a 0.7%
difference in "efficiency".

By comparison, the Bitcoin Core issue I cited in my earlier post
contains several examples of actual users needing technical support
because they tried to use '-containing descriptors in a bourne-style
shell.  (And I've personally lost time to that class of problems.)  In
the worst case, a shell-quoting accident can cause loss of money by
sending bitcoins to the descriptor for a key your hardware signing
device won't sign for.  I think these problems are much more serious
than using a tiny bit of extra space in a GUI or on a physical backup
medium.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/ac399f1f/attachment-0001.sig>

From craigraw at gmail.com  Sat Jul  3 08:35:48 2021
From: craigraw at gmail.com (Craig Raw)
Date: Sat, 3 Jul 2021 10:35:48 +0200
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <ad7657ea-0c35-f065-1788-cc8663bf94b5@achow101.com>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <20210703032405.j3mru5rbag5sbfil@ganymede>
 <ad7657ea-0c35-f065-1788-cc8663bf94b5@achow101.com>
Message-ID: <CAPR5oBP+5r8WLOew6zOdp3BzOLNr0vf2SVK028zfgoCSyu2wnA@mail.gmail.com>

There is a downside to using "h"/"H" from a UX perspective - taking up more
space and appearing as alphanumeric characters similar to the path numbers,
they make derivation paths and descriptors more difficult to read. Also,
although not as important, less efficient when making metal backups.

On Sat, Jul 3, 2021 at 7:13 AM Andrew Chow via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 7/2/21 11:24 PM, David A. Harding wrote:
> > Is there any chance we can take this opportunity to make "h"/"H" the
> > preferred aliases?  Using "'" in bourne-style shells is very
> > annoying[1], and I suspect it's also creating unnecessary complications
> > elsewhere.
> I've updated the text to use "h".
> > Alternatives:
> >
> > - Completely kill "'" (I'd prefer this, but I realize it's complicated
> >    with descriptors already being used widely).  If "h"/"H" are made the
> >    preferred aliases, maybe it'd be enough to make implementing "'" a
> >    SHOULD rather than a MUST; this would push implementations towards
> >    displaying descriptors using the h versions for maximum compatibility.
> Since there already are software implementing descriptors, I don't think
> we can do this. I'm not sure about making "'" a SHOULD either.
> > - Calculate the checksum over s/(h|H)/'/ (again, I know that's
> >    complicated with descriptors already widely used)
> This has been discussed in the past and the conclusion was that the
> checksum should be strictly over the string itself. This would allow for
> dumb checksum checkers which don't have to be able to parse descriptors
> in order to check the checksum.
>
> Thanks,
> Andrew
>
> >
> > Thanks,
> >
> > -Dave
> >
> > [1]
> https://github.com/bitcoin/bitcoin/issues/15740#issuecomment-695815432
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/204d7572/attachment-0001.html>

From erik at q32.com  Sat Jul  3 11:31:04 2021
From: erik at q32.com (Erik Aronesty)
Date: Sat, 3 Jul 2021 07:31:04 -0400
Subject: [bitcoin-dev] CheckSigFromStack for Arithmetic Values
In-Reply-To: <CAD5xwhggR_uC-Dx9S8kXj-j8L2EdXhmXdGmht05wC6nB3Xn_+w@mail.gmail.com>
References: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>
 <YEsEkExygpn5zEqfCXSt8duo9C0tgyx9YBTRejVn8ccwX2SQCPQVP5r2Nav6isQIbK8ED2Z-fYNwcN0VhXpxAIhCd3TWeU1et85cZFIVWdA=@protonmail.com>
 <CAD5xwhggR_uC-Dx9S8kXj-j8L2EdXhmXdGmht05wC6nB3Xn_+w@mail.gmail.com>
Message-ID: <CAJowKgJxsknJ_TnQU1bvz3VyBHFaykXjDQAfsnxSzoeE1KJhbw@mail.gmail.com>

i may be ignorant here but i have a question:

Given that schnorr signatures now allow signers to perform complex
arithmetic signing operations out-of-band using their own communications
techniques, couldn't you just perform the publishing and accumulation of
these signature components without using a bitcoin script?

In other words, push the effort of combination and computation off of the
bitcoin network and nodes.


On Sat, Jul 3, 2021 at 12:01 AM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Yep -- sorry for the confusing notation but seems like you got it. C++
> templates have this issue too btw :)
>
> One cool thing is that if you have op_add for arbitrary width integers or
> op_cat you can also make a quantum proof signature by signing the signature
> made with checksig with the lamport.
>
> There are a couple gotchas wrt crypto assumptions on that but I'll write
> it up soon ? it also works better in segwit V0 because there's no keypath
> spend -- that breaks the quantum proofness of this scheme.
>
> On Fri, Jul 2, 2021, 4:58 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Jeremy,
>>
>> > Dear Bitcoin Devs,
>> >
>> > It recently occurred to me that it's possible to do a lamport signature
>> in script for arithmetic values by using a binary expanded representation.
>> There are some applications that might benefit from this and I don't recall
>> seeing it discussed elsewhere, but would be happy for a citation/reference
>> to the technique.
>> >
>> > blog post here, https://rubin.io/blog/2021/07/02/signing-5-bytes/,
>> text reproduced below
>> >
>> > There are two insights in this post:
>> > 1. to use a bitwise expansion of the number
>> > 2. to use a lamport signature
>> > Let's look at the code in python and then translate to bitcoin script:
>> > ```python
>> > def add_bit(idx, preimage, image_0, image_1):
>> >     s = sha256(preimage)
>> >     if s == image_1:
>> >         return (1 << idx)
>> >     if s == image_0:
>> >         return 0
>> >     else:
>> >         assert False
>> > def get_signed_number(witnesses : List[Hash], keys : List[Tuple[Hash,
>> Hash]]):
>> >     acc = 0
>> >     for (idx, preimage) in enumerate(witnesses):
>> >         acc += add_bit(idx, preimage, keys[idx][0], keys[idx][1])
>> >     return x
>> > ```
>> > So what's going on here? The signer generates a key which is a list of
>> pairs of
>> > hash images to create the script.
>> > To sign, the signer provides a witness of a list of preimages that
>> match one or the other.
>> > During validation, the network adds up a weighted value per preimage
>> and checks
>> > that there are no left out values.
>> > Let's imagine a concrete use case: I want a third party to post-hoc
>> sign a sequence lock. This is 16 bits.
>> > I can form the following script:
>> > ```
>> > <pk> checksigverify
>> > 0
>> > SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <1<<1> ADD ELSE <H(K_1_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <1<<2> ADD ELSE <H(K_2_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <1<<3> ADD ELSE <H(K_3_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <1<<4> ADD ELSE <H(K_4_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <1<<5> ADD ELSE <H(K_5_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <1<<6> ADD ELSE <H(K_6_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <1<<7> ADD ELSE <H(K_7_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <1<<8> ADD ELSE <H(K_8_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <1<<9> ADD ELSE <H(K_9_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1<<10> ADD ELSE <H(K_10_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <1<<11> ADD ELSE <H(K_11_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <1<<12> ADD ELSE <H(K_12_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <1<<13> ADD ELSE <H(K_13_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <1<<14> ADD ELSE <H(K_14_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <1<<15> ADD ELSE <H(K_15_0)>
>> EQUALVERIFY ENDIF
>> > CHECKSEQUENCEVERIFY
>> > ```
>>
>> This took a bit of thinking to understand, mostly because you use the
>> `<<` operator in a syntax that uses `< >` as delimiters, which was mildly
>> confusing --- at first I thought you were pushing some kind of nested
>> SCRIPT representation, but in any case, replacing it with the actual
>> numbers is a little less confusing on the syntax front, and I think (hope?)
>> most people who can understand `1<<1` have also memorized the first few
>> powers of 2....
>>
>> > ```
>> > <pk> checksigverify
>> > 0
>> > SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <2> ADD ELSE <H(K_1_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <4> ADD ELSE <H(K_2_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <8> ADD ELSE <H(K_3_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <16> ADD ELSE <H(K_4_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <32> ADD ELSE <H(K_5_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <64> ADD ELSE <H(K_6_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <128> ADD ELSE <H(K_7_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <256> ADD ELSE <H(K_8_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <512> ADD ELSE <H(K_9_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1024> ADD ELSE <H(K_10_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <2048> ADD ELSE <H(K_11_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <4096> ADD ELSE <H(K_12_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <8192> ADD ELSE <H(K_13_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <16384> ADD ELSE <H(K_14_0)>
>> EQUALVERIFY ENDIF
>> > SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <32768> ADD ELSE <H(K_15_0)>
>> EQUALVERIFY ENDIF
>> > CHECKSEQUENCEVERIFY
>> > ```
>>
>> On the other hand LOL WTF, this is cool.
>>
>> Basically you are showing that if we enable something as innocuous as
>> `OP_ADD`, we can implement Lamport signatures for **arbitrary** values
>> representable in small binary numbers (16 bits in the above example).
>>
>> I was thinking "why not Merkle signatures" since the pubkey would be much
>> smaller but the signature would be much larger, but (a) the SCRIPT would be
>> much more complicated and (b) in modern Bitcoin, the above SCRIPT would be
>> in the witness stack anyway so there is no advantage to pushing the size
>> towards the signature rather than the pubkey, they all have the same
>> weight, and since both Lamport and Merkle are single-use-only and we do not
>> want to encourage pubkey reuse even if they were not, the Merkle has much
>> larger signature size, so Merkle sigs end up more expensive.
>>
>> Regards,
>> ZmnSCPxj
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/265a6217/attachment-0001.html>

From craigraw at gmail.com  Sat Jul  3 14:00:51 2021
From: craigraw at gmail.com (Craig Raw)
Date: Sat, 3 Jul 2021 16:00:51 +0200
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <20210703100540.pr3nsgjhox26hhic@ganymede>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <20210703032405.j3mru5rbag5sbfil@ganymede>
 <ad7657ea-0c35-f065-1788-cc8663bf94b5@achow101.com>
 <CAPR5oBP+5r8WLOew6zOdp3BzOLNr0vf2SVK028zfgoCSyu2wnA@mail.gmail.com>
 <20210703100540.pr3nsgjhox26hhic@ganymede>
Message-ID: <CAPR5oBMnzzNxL1j5YRgJNLnC9aPTX0m=As23KB2Wf-UDahL40A@mail.gmail.com>

It's a consideration, not a serious concern.

When I made the point around alphanumeric characters being similar to the
path numbers, I was actually thinking of the output descriptor appearing in
a fixed character width font, which I prefer as more appropriate for
displaying hexidecimal values. In this case, the apostrophe provides more
whitespace which makes the path easier to parse visually. It's difficult to
reduce this to a mathematical argument, as is true for many UX
considerations. Your example in fixed width here:
https://gist.github.com/craigraw/fc98b9031a7e01e1bc5d75a77bdb72e5

That said you make good arguments around the shell quoting and stamps for
metal backups, and therefore I agree it is preferable to use the lowercase
"h". Thanks for the detailed reply.

Craig

On Sat, Jul 3, 2021 at 12:11 PM David A. Harding <dave at dtrt.org> wrote:

> On Sat, Jul 03, 2021 at 10:35:48AM +0200, Craig Raw wrote:
> > There is a downside to using "h"/"H" from a UX perspective - taking up
> more
> > space
>
> Is this a serious concern of yours?  An apostrophe is 1/2 en; an "h" is
> 1 en; the following descriptor contains three hardened derivations in 149
> characters; assuming the average non-'/h character width is 1.5 en, the
> difference between 207 en and 208.5 en is barely more than half a
> percent.
>
>
> pkh([d34db33f/44h/0h/0h]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*)#ml40v0wf
>
> Here's a direct visual comparison:
> https://gist.github.com/harding/2fbbf2bfdce04c3e4110082f03ae3c80
>
> > appearing as alphanumeric characters similar to the path numbers
>
> First, I think you'd have to be using an awful font to confuse "h" with
> any arabic numeral.  Second, avoiding transcription errors is exactly
> why descriptors now have checksums.
>
> > they make derivation paths and descriptors more difficult to read.
>
> The example descriptor pasted above looks equally (un)readable to me
> whether it uses ' or h.
>
> > Also, although not as important, less efficient when making metal
> > backups.
>
> I think many metal backup schemes are using stamps or punch grids that
> are fixed-width in nature, so there's no difference either way.  (And
> you can argue that h is better since it's part of both the base58check
> and bech32 character sets, so you already need a stamp or a grid row for
> it---but ' is otherwise unused, so a stamp or grid row for it would be
> special).
>
> But even if people are manually etching descriptors into metal, we're
> back to the original point where we're looking at something like a 0.7%
> difference in "efficiency".
>
> By comparison, the Bitcoin Core issue I cited in my earlier post
> contains several examples of actual users needing technical support
> because they tried to use '-containing descriptors in a bourne-style
> shell.  (And I've personally lost time to that class of problems.)  In
> the worst case, a shell-quoting accident can cause loss of money by
> sending bitcoins to the descriptor for a key your hardware signing
> device won't sign for.  I think these problems are much more serious
> than using a tiny bit of extra space in a GUI or on a physical backup
> medium.
>
> -Dave
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/3a46f38d/attachment.html>

From jlrubin at mit.edu  Sat Jul  3 16:31:57 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sat, 3 Jul 2021 09:31:57 -0700
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
Message-ID: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>

Reproduced below is the BIP text from Bitcoin Cash's (MIT-Licensed)
specification for "CheckDataSig", more or less the same thing as
CHECKSIGFROMSTACK
https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/op_checkdatasig.md.
In contrast to Element's implementation, it does not have Element's bugs
around verify semantics and uses the nullfail rule, and there is a
specification document so it seemed like the easiest starting point for
discussion v.s. drafting something from scratch.

Does anyone have any issue with adapting this exact text and implementation
to a BIP for Bitcoin using 2 OP_SUCCESSX opcodes?

Note that with *just* CheckSigFromStack, while you can do some very
valuable use cases, but without OP_CAT it does not enable sophisticated
covenants (and as per
https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html just
CAT alone enables such uses).

Design questions worth considering as modifications:

1. Should CSFS require some sort of tagged hash? Very likely answer is no ?
tags interfere with certain use cases
2. Should CSFS split the signature?s R & S value stack items for some
applications that otherwise may require OP_CAT? E.g. using a pinned R value
allows you to extract a private key if ever double signed, using 2 R values
allows pay-to-reveal-key contracts. Most likely answer is no, if that is
desired then OP_CAT can be introduced
3. Should CSFS support a cheap way to reference the taproot internal or
external key? Perhaps, can be handled with undefined upgradeable keytypes.
One might want to use the internal key, if the signed data should be valid
independent of the tapscript tree. One might want to use the external key,
if the data should only be valid for a single tapscript key + tree.
4. Should invalid public keys types be a NOP to support future extended
pubkey types?



Best,


Jeremy


---
layout: specification
title: OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY Specification
category: spec
date: 2018-08-20
activation: 1542300000
version: 0.6
---

OP_CHECKDATASIG
===============

OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY check whether a signature is
valid with respect to a message and a public key.

OP_CHECKDATASIG permits data to be imported into a script, and have
its validity checked against some signing authority such as an
"Oracle".

OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY are designed to be
implemented similarly to OP_CHECKSIG [1]. Conceptually, one could
imagine OP_CHECKSIG functionality being replaced by OP_CHECKDATASIG,
along with a separate Op Code to create a hash from the transaction
based on the SigHash algorithm.

OP_CHECKDATASIG Specification
-----------------------------

### Semantics

OP_CHECKDATASIG fails immediately if the stack is not well formed. To
be well formed, the stack must contain at least three elements
[`<sig>`, `<msg>`, `<pubKey>`] in this order where `<pubKey>` is the
top element and
  * `<pubKey>` must be a validly encoded public key
  * `<msg>` can be any string
  * `<sig>` must follow the strict DER encoding as described in [2]
and the S-value of `<sig>` must be at most the curve order divided by
2 as described in [3]

If the stack is well formed, then OP_CHECKDATASIG pops the top three
elements [`<sig>`, `<msg>`, `<pubKey>`] from the stack and pushes true
onto the stack if `<sig>` is valid with respect to the raw
single-SHA256 hash of `<msg>` and `<pubKey>` using the secp256k1
elliptic curve. Otherwise, it pops three elements and pushes false
onto the stack in the case that `<sig>` is the empty string and fails
in all other cases.

Nullfail is enforced the same as for OP_CHECKSIG [3]. If the signature
does not match the supplied public key and message hash, and the
signature is not an empty byte array, the entire script fails.

### Opcode Number

OP_CHECKDATASIG uses the previously unused opcode number 186 (0xba in
hex encoding)

### SigOps

Signature operations accounting for OP_CHECKDATASIG shall be
calculated the same as OP_CHECKSIG. This means that each
OP_CHECKDATASIG shall be counted as one (1) SigOp.

### Activation

Use of OP_CHECKDATASIG, unless occuring in an unexecuted OP_IF branch,
will make the transaction invalid if it is included in a block where
the median timestamp of the prior 11 blocks is less than 1542300000.

### Unit Tests

 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if 15 November 2018
protocol upgrade is not yet activated.
 - `<sig> <msg> OP_CHECKDATASIG` fails if there are fewer than 3 items on stack.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<pubKey>` is not a
validly encoded public key.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<sig>` is not a
validly encoded signature with strict DER encoding.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>`
is not empty and does not pass the Low S check.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>`
is not empty and does not pass signature validation of `<msg>` and
`<pubKey>`.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and
pushes false onto the stack if `<sig>` is an empty byte array.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and
pushes true onto the stack if `<sig>` is a valid signature of `<msg>`
with respect to `<pubKey>`.

OP_CHECKDATASIGVERIFY Specification
-----------------------------------

### Semantics

OP_CHECKDATASIGVERIFY is equivalent to OP_CHECKDATASIG followed by
OP_VERIFY. It leaves nothing on the stack, and will cause the script
to fail immediately if the signature check does not pass.

### Opcode Number

OP_CHECKDATASIGVERIFY uses the previously unused opcode number 187
(0xbb in hex encoding)

### SigOps

Signature operations accounting for OP_CHECKDATASIGVERIFY shall be
calculated the same as OP_CHECKSIGVERIFY. This means that each
OP_CHECKDATASIGVERIFY shall be counted as one (1) SigOp.

### Activation

Use of OP_CHECKDATASIGVERIFY, unless occuring in an unexecuted OP_IF
branch, will make the transaction invalid if it is included in a block
where the median timestamp of the prior 11 blocks is less than
1542300000.

### Unit Tests

 - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if 15 November
2018 protocol upgrade is not yet activated.
 - `<sig> <msg> OP_CHECKDATASIGVERIFY` fails if there are fewer than 3
item on stack.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY`fails if `<pubKey>` is
not a validly encoded public key.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is
not a validly encoded signature with strict DER encoding.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if signature
`<sig>` is not empty and does not pass the Low S check.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is
not a valid signature of `<msg>` with respect to `<pubKey>`.
 - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` pops the top three
stack elements if `<sig>` is a valid signature of `<msg>` with respect
to `<pubKey>`.

Sample Implementation [4, 5]
----------------------------

```c++
                    case OP_CHECKDATASIG:
                    case OP_CHECKDATASIGVERIFY: {
                        // Make sure this remains an error before activation.
                        if ((flags & SCRIPT_ENABLE_CHECKDATASIG) == 0) {
                            return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
                        }

                        // (sig message pubkey -- bool)
                        if (stack.size() < 3) {
                            return set_error(
                                serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
                        }

                        valtype &vchSig = stacktop(-3);
                        valtype &vchMessage = stacktop(-2);
                        valtype &vchPubKey = stacktop(-1);

                        if (!CheckDataSignatureEncoding(vchSig, flags,
                                                        serror) ||
                            !CheckPubKeyEncoding(vchPubKey, flags, serror)) {
                            // serror is set
                            return false;
                        }

                        bool fSuccess = false;
                        if (vchSig.size()) {
                            valtype vchHash(32);
                            CSHA256()
                                .Write(vchMessage.data(), vchMessage.size())
                                .Finalize(vchHash.data());
                            uint256 message(vchHash);
                            CPubKey pubkey(vchPubKey);
                            fSuccess = pubkey.Verify(message, vchSig);
                        }

                        if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) &&
                            vchSig.size()) {
                            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
                        }

                        popstack(stack);
                        popstack(stack);
                        popstack(stack);
                        stack.push_back(fSuccess ? vchTrue : vchFalse);
                        if (opcode == OP_CHECKDATASIGVERIFY) {
                            if (fSuccess) {
                                popstack(stack);
                            } else {
                                return set_error(serror,
                                                 SCRIPT_ERR_CHECKDATASIGVERIFY);
                            }
                        }
                    } break;
```

Sample Usage
------------

The following example shows a spend and redeem script for a basic use
of CHECKDATASIG.  This example validates the signature of some data,
provides a placeholder where you would then process that data, and
finally allows one of 2 signatures to spend based on the outcome of
the data processing.

### spend script:
```
push txsignature
push txpubkey
push msg
push sig
```
### redeem script:
```
                                (txsig, txpubkey msg, sig)
OP_OVER                         (txsig, txpubkey, msg, sig, msg)
push data pubkey                (txsig, txpubkey, msg, sig, msg, pubkey)
OP_CHECKDATASIGVERIFY           (txsig, txpubkey, msg)
```
Now that msg is on the stack top, the script can write predicates on it,
resulting in the message being consumed and a true/false condition
left on the stack: (txpubkey, txsig, boolean)
```
OP_IF                           (txsig, txpubkey)
  OP_DUP                        (txsig, txpubkey, txpubkey)
  OP_HASH160                    (txsig, txpubkey, address)
  push <p2pkh spend address>    (txsig, txpubkey, address, p2pkh spend address)
  OP_EQUALVERIFY                (txsig, txpubkey)
  OP_CHECKSIG
OP_ELSE
  (same as if clause but a different <p2pkh spend address>)
OP_ENDIF
```

History
-------

This specification is based on Andrew Stone?s OP_DATASIGVERIFY
proposal [6, 7]. It is modified from Stone's original proposal based
on a synthesis of all the peer-review and feedback received [8].

References
----------

[1] [OP_CHECKSIG](https://en.bitcoin.it/wiki/OP_CHECKSIG)

[2] [Strict DER
Encoding](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)

[3] [Low-S and Nullfail
Specification](https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki)

[4] [Bitcoin ABC implementation](https://reviews.bitcoinabc.org/D1621)

[5] [Bitcoin ABC implementation update](https://reviews.bitcoinabc.org/D1646)

[6] [Andrew Stone?s
OP_DATASIGVERIFY](https://github.com/BitcoinUnlimited/BitcoinUnlimited/blob/bucash1.3.0.0/doc/opdatasigverify.md)

[7] [Andrew Stone's article on
Scripting](https://medium.com/@g.andrew.stone/bitcoin-scripting-applications-decision-based-spending-8e7b93d7bdb9)

[8] [Peer Review of Andrew Stone's
Proposal](https://github.com/bitcoincashorg/bitcoincash.org/pull/10)


--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/f38c654f/attachment-0001.html>

From roconnor at blockstream.com  Sat Jul  3 17:50:21 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sat, 3 Jul 2021 13:50:21 -0400
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
Message-ID: <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>

Hi Jermy,

As you are aware, we, and by we I mean mostly Sanket, are developing an
updated OP_CHECKSIGFROMSTACK implementation for tapscript on elements.  The
plan here would be to effectively support the an interface to the
variable-length extension of BIP-0340 schnorr signatures.

BIP-0340 would dispense with DER encoding (good riddance).
BIP-0340 signatures are batch verifiable along with other BIP-0340
transaction signatures and taproot tweak verification.
Support for variable length messages in BIP-0340 has been discussed in <
https://github.com/sipa/bips/issues/207> and an implementation has recently
been merged in <https://github.com/bitcoin-core/secp256k1/pull/844>.  The
BIP has not yet been updated but the difference is that the message m does
not have to be 32-bytes (it is recommended that the message be a 32-bit
tagged hash or a message with a 64-bit application specific prefix). The
CHECKSIGFROMSTACK operation (in tapscript) would use a stack item for this
m value to BIP-0340 signature verification and would not necessarily have
to be 32 bytes.

I think this design we are aiming for would be perfectly suited for Bitcoin
as well.

On Sat, Jul 3, 2021 at 12:32 PM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Reproduced below is the BIP text from Bitcoin Cash's (MIT-Licensed)
> specification for "CheckDataSig", more or less the same thing as
> CHECKSIGFROMSTACK
> https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/op_checkdatasig.md.
> In contrast to Element's implementation, it does not have Element's bugs
> around verify semantics and uses the nullfail rule, and there is a
> specification document so it seemed like the easiest starting point for
> discussion v.s. drafting something from scratch.
>
> Does anyone have any issue with adapting this exact text and
> implementation to a BIP for Bitcoin using 2 OP_SUCCESSX opcodes?
>
> Note that with *just* CheckSigFromStack, while you can do some very
> valuable use cases, but without OP_CAT it does not enable sophisticated
> covenants (and as per
> https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html just
> CAT alone enables such uses).
>
> Design questions worth considering as modifications:
>
> 1. Should CSFS require some sort of tagged hash? Very likely answer is no
> ? tags interfere with certain use cases
> 2. Should CSFS split the signature?s R & S value stack items for some
> applications that otherwise may require OP_CAT? E.g. using a pinned R value
> allows you to extract a private key if ever double signed, using 2 R values
> allows pay-to-reveal-key contracts. Most likely answer is no, if that is
> desired then OP_CAT can be introduced
> 3. Should CSFS support a cheap way to reference the taproot internal or
> external key? Perhaps, can be handled with undefined upgradeable keytypes.
> One might want to use the internal key, if the signed data should be valid
> independent of the tapscript tree. One might want to use the external key,
> if the data should only be valid for a single tapscript key + tree.
> 4. Should invalid public keys types be a NOP to support future extended
> pubkey types?
>
>
>
> Best,
>
>
> Jeremy
>
>
> ---
> layout: specification
> title: OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY Specification
> category: spec
> date: 2018-08-20
> activation: 1542300000
> version: 0.6
> ---
>
> OP_CHECKDATASIG
> ===============
>
> OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY check whether a signature is valid with respect to a message and a public key.
>
> OP_CHECKDATASIG permits data to be imported into a script, and have its validity checked against some signing authority such as an "Oracle".
>
> OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY are designed to be implemented similarly to OP_CHECKSIG [1]. Conceptually, one could imagine OP_CHECKSIG functionality being replaced by OP_CHECKDATASIG, along with a separate Op Code to create a hash from the transaction based on the SigHash algorithm.
>
> OP_CHECKDATASIG Specification
> -----------------------------
>
> ### Semantics
>
> OP_CHECKDATASIG fails immediately if the stack is not well formed. To be well formed, the stack must contain at least three elements [`<sig>`, `<msg>`, `<pubKey>`] in this order where `<pubKey>` is the top element and
>   * `<pubKey>` must be a validly encoded public key
>   * `<msg>` can be any string
>   * `<sig>` must follow the strict DER encoding as described in [2] and the S-value of `<sig>` must be at most the curve order divided by 2 as described in [3]
>
> If the stack is well formed, then OP_CHECKDATASIG pops the top three elements [`<sig>`, `<msg>`, `<pubKey>`] from the stack and pushes true onto the stack if `<sig>` is valid with respect to the raw single-SHA256 hash of `<msg>` and `<pubKey>` using the secp256k1 elliptic curve. Otherwise, it pops three elements and pushes false onto the stack in the case that `<sig>` is the empty string and fails in all other cases.
>
> Nullfail is enforced the same as for OP_CHECKSIG [3]. If the signature does not match the supplied public key and message hash, and the signature is not an empty byte array, the entire script fails.
>
> ### Opcode Number
>
> OP_CHECKDATASIG uses the previously unused opcode number 186 (0xba in hex encoding)
>
> ### SigOps
>
> Signature operations accounting for OP_CHECKDATASIG shall be calculated the same as OP_CHECKSIG. This means that each OP_CHECKDATASIG shall be counted as one (1) SigOp.
>
> ### Activation
>
> Use of OP_CHECKDATASIG, unless occuring in an unexecuted OP_IF branch, will make the transaction invalid if it is included in a block where the median timestamp of the prior 11 blocks is less than 1542300000.
>
> ### Unit Tests
>
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if 15 November 2018 protocol upgrade is not yet activated.
>  - `<sig> <msg> OP_CHECKDATASIG` fails if there are fewer than 3 items on stack.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<pubKey>` is not a validly encoded public key.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<sig>` is not a validly encoded signature with strict DER encoding.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>` is not empty and does not pass the Low S check.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>` is not empty and does not pass signature validation of `<msg>` and `<pubKey>`.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and pushes false onto the stack if `<sig>` is an empty byte array.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and pushes true onto the stack if `<sig>` is a valid signature of `<msg>` with respect to `<pubKey>`.
>
> OP_CHECKDATASIGVERIFY Specification
> -----------------------------------
>
> ### Semantics
>
> OP_CHECKDATASIGVERIFY is equivalent to OP_CHECKDATASIG followed by OP_VERIFY. It leaves nothing on the stack, and will cause the script to fail immediately if the signature check does not pass.
>
> ### Opcode Number
>
> OP_CHECKDATASIGVERIFY uses the previously unused opcode number 187 (0xbb in hex encoding)
>
> ### SigOps
>
> Signature operations accounting for OP_CHECKDATASIGVERIFY shall be calculated the same as OP_CHECKSIGVERIFY. This means that each OP_CHECKDATASIGVERIFY shall be counted as one (1) SigOp.
>
> ### Activation
>
> Use of OP_CHECKDATASIGVERIFY, unless occuring in an unexecuted OP_IF branch, will make the transaction invalid if it is included in a block where the median timestamp of the prior 11 blocks is less than 1542300000.
>
> ### Unit Tests
>
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if 15 November 2018 protocol upgrade is not yet activated.
>  - `<sig> <msg> OP_CHECKDATASIGVERIFY` fails if there are fewer than 3 item on stack.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY`fails if `<pubKey>` is not a validly encoded public key.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is not a validly encoded signature with strict DER encoding.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if signature `<sig>` is not empty and does not pass the Low S check.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is not a valid signature of `<msg>` with respect to `<pubKey>`.
>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` pops the top three stack elements if `<sig>` is a valid signature of `<msg>` with respect to `<pubKey>`.
>
> Sample Implementation [4, 5]
> ----------------------------
>
> ```c++
>                     case OP_CHECKDATASIG:
>                     case OP_CHECKDATASIGVERIFY: {
>                         // Make sure this remains an error before activation.
>                         if ((flags & SCRIPT_ENABLE_CHECKDATASIG) == 0) {
>                             return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
>                         }
>
>                         // (sig message pubkey -- bool)
>                         if (stack.size() < 3) {
>                             return set_error(
>                                 serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
>                         }
>
>                         valtype &vchSig = stacktop(-3);
>                         valtype &vchMessage = stacktop(-2);
>                         valtype &vchPubKey = stacktop(-1);
>
>                         if (!CheckDataSignatureEncoding(vchSig, flags,
>                                                         serror) ||
>                             !CheckPubKeyEncoding(vchPubKey, flags, serror)) {
>                             // serror is set
>                             return false;
>                         }
>
>                         bool fSuccess = false;
>                         if (vchSig.size()) {
>                             valtype vchHash(32);
>                             CSHA256()
>                                 .Write(vchMessage.data(), vchMessage.size())
>                                 .Finalize(vchHash.data());
>                             uint256 message(vchHash);
>                             CPubKey pubkey(vchPubKey);
>                             fSuccess = pubkey.Verify(message, vchSig);
>                         }
>
>                         if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) &&
>                             vchSig.size()) {
>                             return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
>                         }
>
>                         popstack(stack);
>                         popstack(stack);
>                         popstack(stack);
>                         stack.push_back(fSuccess ? vchTrue : vchFalse);
>                         if (opcode == OP_CHECKDATASIGVERIFY) {
>                             if (fSuccess) {
>                                 popstack(stack);
>                             } else {
>                                 return set_error(serror,
>                                                  SCRIPT_ERR_CHECKDATASIGVERIFY);
>                             }
>                         }
>                     } break;
> ```
>
> Sample Usage
> ------------
>
> The following example shows a spend and redeem script for a basic use of CHECKDATASIG.  This example validates the signature of some data, provides a placeholder where you would then process that data, and finally allows one of 2 signatures to spend based on the outcome of the data processing.
>
> ### spend script:
> ```
> push txsignature
> push txpubkey
> push msg
> push sig
> ```
> ### redeem script:
> ```
>                                 (txsig, txpubkey msg, sig)
> OP_OVER                         (txsig, txpubkey, msg, sig, msg)
> push data pubkey                (txsig, txpubkey, msg, sig, msg, pubkey)
> OP_CHECKDATASIGVERIFY           (txsig, txpubkey, msg)
> ```
> Now that msg is on the stack top, the script can write predicates on it,
> resulting in the message being consumed and a true/false condition left on the stack: (txpubkey, txsig, boolean)
> ```
> OP_IF                           (txsig, txpubkey)
>   OP_DUP                        (txsig, txpubkey, txpubkey)
>   OP_HASH160                    (txsig, txpubkey, address)
>   push <p2pkh spend address>    (txsig, txpubkey, address, p2pkh spend address)
>   OP_EQUALVERIFY                (txsig, txpubkey)
>   OP_CHECKSIG
> OP_ELSE
>   (same as if clause but a different <p2pkh spend address>)
> OP_ENDIF
> ```
>
> History
> -------
>
> This specification is based on Andrew Stone?s OP_DATASIGVERIFY proposal [6, 7]. It is modified from Stone's original proposal based on a synthesis of all the peer-review and feedback received [8].
>
> References
> ----------
>
> [1] [OP_CHECKSIG](https://en.bitcoin.it/wiki/OP_CHECKSIG)
>
> [2] [Strict DER Encoding](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)
>
> [3] [Low-S and Nullfail Specification](https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki)
>
> [4] [Bitcoin ABC implementation](https://reviews.bitcoinabc.org/D1621)
>
> [5] [Bitcoin ABC implementation update](https://reviews.bitcoinabc.org/D1646)
>
> [6] [Andrew Stone?s OP_DATASIGVERIFY](https://github.com/BitcoinUnlimited/BitcoinUnlimited/blob/bucash1.3.0.0/doc/opdatasigverify.md)
>
> [7] [Andrew Stone's article on Scripting](https://medium.com/@g.andrew.stone/bitcoin-scripting-applications-decision-based-spending-8e7b93d7bdb9)
>
> [8] [Peer Review of Andrew Stone's Proposal](https://github.com/bitcoincashorg/bitcoincash.org/pull/10)
>
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/ce1d831d/attachment-0001.html>

From jlrubin at mit.edu  Sat Jul  3 18:30:45 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sat, 3 Jul 2021 11:30:45 -0700
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
Message-ID: <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>

Awesome to hear that!

Actually I don't think I did know (or I forgot/didn't catch it) that there
was an updated spec for elements, I searched around for what I could find
and came up empty handed. Do you have any links for that? That sounds
perfect to me.


On Sat, Jul 3, 2021, 10:50 AM Russell O'Connor <roconnor at blockstream.com>
wrote:

> Hi Jermy,
>
> As you are aware, we, and by we I mean mostly Sanket, are developing an
> updated OP_CHECKSIGFROMSTACK implementation for tapscript on elements.  The
> plan here would be to effectively support the an interface to the
> variable-length extension of BIP-0340 schnorr signatures.
>
> BIP-0340 would dispense with DER encoding (good riddance).
> BIP-0340 signatures are batch verifiable along with other BIP-0340
> transaction signatures and taproot tweak verification.
> Support for variable length messages in BIP-0340 has been discussed in <
> https://github.com/sipa/bips/issues/207> and an implementation has
> recently been merged in <
> https://github.com/bitcoin-core/secp256k1/pull/844>.  The BIP has not yet
> been updated but the difference is that the message m does not have to be
> 32-bytes (it is recommended that the message be a 32-bit tagged hash or a
> message with a 64-bit application specific prefix). The CHECKSIGFROMSTACK
> operation (in tapscript) would use a stack item for this m value to
> BIP-0340 signature verification and would not necessarily have to be 32
> bytes.
>
> I think this design we are aiming for would be perfectly suited for
> Bitcoin as well.
>
> On Sat, Jul 3, 2021 at 12:32 PM Jeremy via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Reproduced below is the BIP text from Bitcoin Cash's (MIT-Licensed)
>> specification for "CheckDataSig", more or less the same thing as
>> CHECKSIGFROMSTACK
>> https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/op_checkdatasig.md.
>> In contrast to Element's implementation, it does not have Element's bugs
>> around verify semantics and uses the nullfail rule, and there is a
>> specification document so it seemed like the easiest starting point for
>> discussion v.s. drafting something from scratch.
>>
>> Does anyone have any issue with adapting this exact text and
>> implementation to a BIP for Bitcoin using 2 OP_SUCCESSX opcodes?
>>
>> Note that with *just* CheckSigFromStack, while you can do some very
>> valuable use cases, but without OP_CAT it does not enable sophisticated
>> covenants (and as per
>> https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html
>> just CAT alone enables such uses).
>>
>> Design questions worth considering as modifications:
>>
>> 1. Should CSFS require some sort of tagged hash? Very likely answer is no
>> ? tags interfere with certain use cases
>> 2. Should CSFS split the signature?s R & S value stack items for some
>> applications that otherwise may require OP_CAT? E.g. using a pinned R value
>> allows you to extract a private key if ever double signed, using 2 R values
>> allows pay-to-reveal-key contracts. Most likely answer is no, if that is
>> desired then OP_CAT can be introduced
>> 3. Should CSFS support a cheap way to reference the taproot internal or
>> external key? Perhaps, can be handled with undefined upgradeable keytypes.
>> One might want to use the internal key, if the signed data should be valid
>> independent of the tapscript tree. One might want to use the external key,
>> if the data should only be valid for a single tapscript key + tree.
>> 4. Should invalid public keys types be a NOP to support future extended
>> pubkey types?
>>
>>
>>
>> Best,
>>
>>
>> Jeremy
>>
>>
>> ---
>> layout: specification
>> title: OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY Specification
>> category: spec
>> date: 2018-08-20
>> activation: 1542300000
>> version: 0.6
>> ---
>>
>> OP_CHECKDATASIG
>> ===============
>>
>> OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY check whether a signature is valid with respect to a message and a public key.
>>
>> OP_CHECKDATASIG permits data to be imported into a script, and have its validity checked against some signing authority such as an "Oracle".
>>
>> OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY are designed to be implemented similarly to OP_CHECKSIG [1]. Conceptually, one could imagine OP_CHECKSIG functionality being replaced by OP_CHECKDATASIG, along with a separate Op Code to create a hash from the transaction based on the SigHash algorithm.
>>
>> OP_CHECKDATASIG Specification
>> -----------------------------
>>
>> ### Semantics
>>
>> OP_CHECKDATASIG fails immediately if the stack is not well formed. To be well formed, the stack must contain at least three elements [`<sig>`, `<msg>`, `<pubKey>`] in this order where `<pubKey>` is the top element and
>>   * `<pubKey>` must be a validly encoded public key
>>   * `<msg>` can be any string
>>   * `<sig>` must follow the strict DER encoding as described in [2] and the S-value of `<sig>` must be at most the curve order divided by 2 as described in [3]
>>
>> If the stack is well formed, then OP_CHECKDATASIG pops the top three elements [`<sig>`, `<msg>`, `<pubKey>`] from the stack and pushes true onto the stack if `<sig>` is valid with respect to the raw single-SHA256 hash of `<msg>` and `<pubKey>` using the secp256k1 elliptic curve. Otherwise, it pops three elements and pushes false onto the stack in the case that `<sig>` is the empty string and fails in all other cases.
>>
>> Nullfail is enforced the same as for OP_CHECKSIG [3]. If the signature does not match the supplied public key and message hash, and the signature is not an empty byte array, the entire script fails.
>>
>> ### Opcode Number
>>
>> OP_CHECKDATASIG uses the previously unused opcode number 186 (0xba in hex encoding)
>>
>> ### SigOps
>>
>> Signature operations accounting for OP_CHECKDATASIG shall be calculated the same as OP_CHECKSIG. This means that each OP_CHECKDATASIG shall be counted as one (1) SigOp.
>>
>> ### Activation
>>
>> Use of OP_CHECKDATASIG, unless occuring in an unexecuted OP_IF branch, will make the transaction invalid if it is included in a block where the median timestamp of the prior 11 blocks is less than 1542300000.
>>
>> ### Unit Tests
>>
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if 15 November 2018 protocol upgrade is not yet activated.
>>  - `<sig> <msg> OP_CHECKDATASIG` fails if there are fewer than 3 items on stack.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<pubKey>` is not a validly encoded public key.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<sig>` is not a validly encoded signature with strict DER encoding.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>` is not empty and does not pass the Low S check.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>` is not empty and does not pass signature validation of `<msg>` and `<pubKey>`.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and pushes false onto the stack if `<sig>` is an empty byte array.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and pushes true onto the stack if `<sig>` is a valid signature of `<msg>` with respect to `<pubKey>`.
>>
>> OP_CHECKDATASIGVERIFY Specification
>> -----------------------------------
>>
>> ### Semantics
>>
>> OP_CHECKDATASIGVERIFY is equivalent to OP_CHECKDATASIG followed by OP_VERIFY. It leaves nothing on the stack, and will cause the script to fail immediately if the signature check does not pass.
>>
>> ### Opcode Number
>>
>> OP_CHECKDATASIGVERIFY uses the previously unused opcode number 187 (0xbb in hex encoding)
>>
>> ### SigOps
>>
>> Signature operations accounting for OP_CHECKDATASIGVERIFY shall be calculated the same as OP_CHECKSIGVERIFY. This means that each OP_CHECKDATASIGVERIFY shall be counted as one (1) SigOp.
>>
>> ### Activation
>>
>> Use of OP_CHECKDATASIGVERIFY, unless occuring in an unexecuted OP_IF branch, will make the transaction invalid if it is included in a block where the median timestamp of the prior 11 blocks is less than 1542300000.
>>
>> ### Unit Tests
>>
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if 15 November 2018 protocol upgrade is not yet activated.
>>  - `<sig> <msg> OP_CHECKDATASIGVERIFY` fails if there are fewer than 3 item on stack.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY`fails if `<pubKey>` is not a validly encoded public key.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is not a validly encoded signature with strict DER encoding.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if signature `<sig>` is not empty and does not pass the Low S check.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is not a valid signature of `<msg>` with respect to `<pubKey>`.
>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` pops the top three stack elements if `<sig>` is a valid signature of `<msg>` with respect to `<pubKey>`.
>>
>> Sample Implementation [4, 5]
>> ----------------------------
>>
>> ```c++
>>                     case OP_CHECKDATASIG:
>>                     case OP_CHECKDATASIGVERIFY: {
>>                         // Make sure this remains an error before activation.
>>                         if ((flags & SCRIPT_ENABLE_CHECKDATASIG) == 0) {
>>                             return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
>>                         }
>>
>>                         // (sig message pubkey -- bool)
>>                         if (stack.size() < 3) {
>>                             return set_error(
>>                                 serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
>>                         }
>>
>>                         valtype &vchSig = stacktop(-3);
>>                         valtype &vchMessage = stacktop(-2);
>>                         valtype &vchPubKey = stacktop(-1);
>>
>>                         if (!CheckDataSignatureEncoding(vchSig, flags,
>>                                                         serror) ||
>>                             !CheckPubKeyEncoding(vchPubKey, flags, serror)) {
>>                             // serror is set
>>                             return false;
>>                         }
>>
>>                         bool fSuccess = false;
>>                         if (vchSig.size()) {
>>                             valtype vchHash(32);
>>                             CSHA256()
>>                                 .Write(vchMessage.data(), vchMessage.size())
>>                                 .Finalize(vchHash.data());
>>                             uint256 message(vchHash);
>>                             CPubKey pubkey(vchPubKey);
>>                             fSuccess = pubkey.Verify(message, vchSig);
>>                         }
>>
>>                         if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) &&
>>                             vchSig.size()) {
>>                             return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
>>                         }
>>
>>                         popstack(stack);
>>                         popstack(stack);
>>                         popstack(stack);
>>                         stack.push_back(fSuccess ? vchTrue : vchFalse);
>>                         if (opcode == OP_CHECKDATASIGVERIFY) {
>>                             if (fSuccess) {
>>                                 popstack(stack);
>>                             } else {
>>                                 return set_error(serror,
>>                                                  SCRIPT_ERR_CHECKDATASIGVERIFY);
>>                             }
>>                         }
>>                     } break;
>> ```
>>
>> Sample Usage
>> ------------
>>
>> The following example shows a spend and redeem script for a basic use of CHECKDATASIG.  This example validates the signature of some data, provides a placeholder where you would then process that data, and finally allows one of 2 signatures to spend based on the outcome of the data processing.
>>
>> ### spend script:
>> ```
>> push txsignature
>> push txpubkey
>> push msg
>> push sig
>> ```
>> ### redeem script:
>> ```
>>                                 (txsig, txpubkey msg, sig)
>> OP_OVER                         (txsig, txpubkey, msg, sig, msg)
>> push data pubkey                (txsig, txpubkey, msg, sig, msg, pubkey)
>> OP_CHECKDATASIGVERIFY           (txsig, txpubkey, msg)
>> ```
>> Now that msg is on the stack top, the script can write predicates on it,
>> resulting in the message being consumed and a true/false condition left on the stack: (txpubkey, txsig, boolean)
>> ```
>> OP_IF                           (txsig, txpubkey)
>>   OP_DUP                        (txsig, txpubkey, txpubkey)
>>   OP_HASH160                    (txsig, txpubkey, address)
>>   push <p2pkh spend address>    (txsig, txpubkey, address, p2pkh spend address)
>>   OP_EQUALVERIFY                (txsig, txpubkey)
>>   OP_CHECKSIG
>> OP_ELSE
>>   (same as if clause but a different <p2pkh spend address>)
>> OP_ENDIF
>> ```
>>
>> History
>> -------
>>
>> This specification is based on Andrew Stone?s OP_DATASIGVERIFY proposal [6, 7]. It is modified from Stone's original proposal based on a synthesis of all the peer-review and feedback received [8].
>>
>> References
>> ----------
>>
>> [1] [OP_CHECKSIG](https://en.bitcoin.it/wiki/OP_CHECKSIG)
>>
>> [2] [Strict DER Encoding](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)
>>
>> [3] [Low-S and Nullfail Specification](https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki)
>>
>> [4] [Bitcoin ABC implementation](https://reviews.bitcoinabc.org/D1621)
>>
>> [5] [Bitcoin ABC implementation update](https://reviews.bitcoinabc.org/D1646)
>>
>> [6] [Andrew Stone?s OP_DATASIGVERIFY](https://github.com/BitcoinUnlimited/BitcoinUnlimited/blob/bucash1.3.0.0/doc/opdatasigverify.md)
>>
>> [7] [Andrew Stone's article on Scripting](https://medium.com/@g.andrew.stone/bitcoin-scripting-applications-decision-based-spending-8e7b93d7bdb9)
>>
>> [8] [Peer Review of Andrew Stone's Proposal](https://github.com/bitcoincashorg/bitcoincash.org/pull/10)
>>
>>
>> --
>> @JeremyRubin <https://twitter.com/JeremyRubin>
>> <https://twitter.com/JeremyRubin>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/ba67ab0b/attachment-0001.html>

From roconnor at blockstream.com  Sat Jul  3 20:12:51 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sat, 3 Jul 2021 16:12:51 -0400
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
 <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
Message-ID: <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>

There is one line written at
https://github.com/ElementsProject/elements/pull/949/files#r660130155. I
suppose we need to decide on which variants of *VERIFY and *ADD we want to
include (presumably all of them) and choose which opcodes they will be
assigned to.  And I guess for CHECKSIGFROMSTACKADD will want to place the n
value between the signature and the message on the stack.  ... So I suppose
we will need more than one sentence.

The semantics would be basically to call secp256k1_schnorrsig_verify <
https://github.com/bitcoin-core/secp256k1/blob/0440945fb5ce69d335fed32827b5166e84b02e05/include/secp256k1_schnorrsig.h#L158>,
treating pubkeys and signatures the same way the other CHECKSIG operations
do, and in passing the (variable length) message from the stack.
CHECKSIGFROMSTACK would also be subject to the same sigops budget that
CHECKSIG has in tapscript.

On Sat, Jul 3, 2021 at 2:30 PM Jeremy <jlrubin at mit.edu> wrote:

> Awesome to hear that!
>
> Actually I don't think I did know (or I forgot/didn't catch it) that there
> was an updated spec for elements, I searched around for what I could find
> and came up empty handed. Do you have any links for that? That sounds
> perfect to me.
>
>
> On Sat, Jul 3, 2021, 10:50 AM Russell O'Connor <roconnor at blockstream.com>
> wrote:
>
>> Hi Jermy,
>>
>> As you are aware, we, and by we I mean mostly Sanket, are developing an
>> updated OP_CHECKSIGFROMSTACK implementation for tapscript on elements.  The
>> plan here would be to effectively support the an interface to the
>> variable-length extension of BIP-0340 schnorr signatures.
>>
>> BIP-0340 would dispense with DER encoding (good riddance).
>> BIP-0340 signatures are batch verifiable along with other BIP-0340
>> transaction signatures and taproot tweak verification.
>> Support for variable length messages in BIP-0340 has been discussed in <
>> https://github.com/sipa/bips/issues/207> and an implementation has
>> recently been merged in <
>> https://github.com/bitcoin-core/secp256k1/pull/844>.  The BIP has not
>> yet been updated but the difference is that the message m does not have to
>> be 32-bytes (it is recommended that the message be a 32-bit tagged hash or
>> a message with a 64-bit application specific prefix). The CHECKSIGFROMSTACK
>> operation (in tapscript) would use a stack item for this m value to
>> BIP-0340 signature verification and would not necessarily have to be 32
>> bytes.
>>
>> I think this design we are aiming for would be perfectly suited for
>> Bitcoin as well.
>>
>> On Sat, Jul 3, 2021 at 12:32 PM Jeremy via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Reproduced below is the BIP text from Bitcoin Cash's (MIT-Licensed)
>>> specification for "CheckDataSig", more or less the same thing as
>>> CHECKSIGFROMSTACK
>>> https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/op_checkdatasig.md.
>>> In contrast to Element's implementation, it does not have Element's bugs
>>> around verify semantics and uses the nullfail rule, and there is a
>>> specification document so it seemed like the easiest starting point for
>>> discussion v.s. drafting something from scratch.
>>>
>>> Does anyone have any issue with adapting this exact text and
>>> implementation to a BIP for Bitcoin using 2 OP_SUCCESSX opcodes?
>>>
>>> Note that with *just* CheckSigFromStack, while you can do some very
>>> valuable use cases, but without OP_CAT it does not enable sophisticated
>>> covenants (and as per
>>> https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html
>>> just CAT alone enables such uses).
>>>
>>> Design questions worth considering as modifications:
>>>
>>> 1. Should CSFS require some sort of tagged hash? Very likely answer is
>>> no ? tags interfere with certain use cases
>>> 2. Should CSFS split the signature?s R & S value stack items for some
>>> applications that otherwise may require OP_CAT? E.g. using a pinned R value
>>> allows you to extract a private key if ever double signed, using 2 R values
>>> allows pay-to-reveal-key contracts. Most likely answer is no, if that is
>>> desired then OP_CAT can be introduced
>>> 3. Should CSFS support a cheap way to reference the taproot internal or
>>> external key? Perhaps, can be handled with undefined upgradeable keytypes.
>>> One might want to use the internal key, if the signed data should be valid
>>> independent of the tapscript tree. One might want to use the external key,
>>> if the data should only be valid for a single tapscript key + tree.
>>> 4. Should invalid public keys types be a NOP to support future extended
>>> pubkey types?
>>>
>>>
>>>
>>> Best,
>>>
>>>
>>> Jeremy
>>>
>>>
>>> ---
>>> layout: specification
>>> title: OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY Specification
>>> category: spec
>>> date: 2018-08-20
>>> activation: 1542300000
>>> version: 0.6
>>> ---
>>>
>>> OP_CHECKDATASIG
>>> ===============
>>>
>>> OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY check whether a signature is valid with respect to a message and a public key.
>>>
>>> OP_CHECKDATASIG permits data to be imported into a script, and have its validity checked against some signing authority such as an "Oracle".
>>>
>>> OP_CHECKDATASIG and OP_CHECKDATASIGVERIFY are designed to be implemented similarly to OP_CHECKSIG [1]. Conceptually, one could imagine OP_CHECKSIG functionality being replaced by OP_CHECKDATASIG, along with a separate Op Code to create a hash from the transaction based on the SigHash algorithm.
>>>
>>> OP_CHECKDATASIG Specification
>>> -----------------------------
>>>
>>> ### Semantics
>>>
>>> OP_CHECKDATASIG fails immediately if the stack is not well formed. To be well formed, the stack must contain at least three elements [`<sig>`, `<msg>`, `<pubKey>`] in this order where `<pubKey>` is the top element and
>>>   * `<pubKey>` must be a validly encoded public key
>>>   * `<msg>` can be any string
>>>   * `<sig>` must follow the strict DER encoding as described in [2] and the S-value of `<sig>` must be at most the curve order divided by 2 as described in [3]
>>>
>>> If the stack is well formed, then OP_CHECKDATASIG pops the top three elements [`<sig>`, `<msg>`, `<pubKey>`] from the stack and pushes true onto the stack if `<sig>` is valid with respect to the raw single-SHA256 hash of `<msg>` and `<pubKey>` using the secp256k1 elliptic curve. Otherwise, it pops three elements and pushes false onto the stack in the case that `<sig>` is the empty string and fails in all other cases.
>>>
>>> Nullfail is enforced the same as for OP_CHECKSIG [3]. If the signature does not match the supplied public key and message hash, and the signature is not an empty byte array, the entire script fails.
>>>
>>> ### Opcode Number
>>>
>>> OP_CHECKDATASIG uses the previously unused opcode number 186 (0xba in hex encoding)
>>>
>>> ### SigOps
>>>
>>> Signature operations accounting for OP_CHECKDATASIG shall be calculated the same as OP_CHECKSIG. This means that each OP_CHECKDATASIG shall be counted as one (1) SigOp.
>>>
>>> ### Activation
>>>
>>> Use of OP_CHECKDATASIG, unless occuring in an unexecuted OP_IF branch, will make the transaction invalid if it is included in a block where the median timestamp of the prior 11 blocks is less than 1542300000.
>>>
>>> ### Unit Tests
>>>
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if 15 November 2018 protocol upgrade is not yet activated.
>>>  - `<sig> <msg> OP_CHECKDATASIG` fails if there are fewer than 3 items on stack.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<pubKey>` is not a validly encoded public key.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if `<sig>` is not a validly encoded signature with strict DER encoding.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>` is not empty and does not pass the Low S check.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` fails if signature `<sig>` is not empty and does not pass signature validation of `<msg>` and `<pubKey>`.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and pushes false onto the stack if `<sig>` is an empty byte array.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIG` pops three elements and pushes true onto the stack if `<sig>` is a valid signature of `<msg>` with respect to `<pubKey>`.
>>>
>>> OP_CHECKDATASIGVERIFY Specification
>>> -----------------------------------
>>>
>>> ### Semantics
>>>
>>> OP_CHECKDATASIGVERIFY is equivalent to OP_CHECKDATASIG followed by OP_VERIFY. It leaves nothing on the stack, and will cause the script to fail immediately if the signature check does not pass.
>>>
>>> ### Opcode Number
>>>
>>> OP_CHECKDATASIGVERIFY uses the previously unused opcode number 187 (0xbb in hex encoding)
>>>
>>> ### SigOps
>>>
>>> Signature operations accounting for OP_CHECKDATASIGVERIFY shall be calculated the same as OP_CHECKSIGVERIFY. This means that each OP_CHECKDATASIGVERIFY shall be counted as one (1) SigOp.
>>>
>>> ### Activation
>>>
>>> Use of OP_CHECKDATASIGVERIFY, unless occuring in an unexecuted OP_IF branch, will make the transaction invalid if it is included in a block where the median timestamp of the prior 11 blocks is less than 1542300000.
>>>
>>> ### Unit Tests
>>>
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if 15 November 2018 protocol upgrade is not yet activated.
>>>  - `<sig> <msg> OP_CHECKDATASIGVERIFY` fails if there are fewer than 3 item on stack.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY`fails if `<pubKey>` is not a validly encoded public key.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is not a validly encoded signature with strict DER encoding.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if signature `<sig>` is not empty and does not pass the Low S check.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` fails if `<sig>` is not a valid signature of `<msg>` with respect to `<pubKey>`.
>>>  - `<sig> <msg> <pubKey> OP_CHECKDATASIGVERIFY` pops the top three stack elements if `<sig>` is a valid signature of `<msg>` with respect to `<pubKey>`.
>>>
>>> Sample Implementation [4, 5]
>>> ----------------------------
>>>
>>> ```c++
>>>                     case OP_CHECKDATASIG:
>>>                     case OP_CHECKDATASIGVERIFY: {
>>>                         // Make sure this remains an error before activation.
>>>                         if ((flags & SCRIPT_ENABLE_CHECKDATASIG) == 0) {
>>>                             return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
>>>                         }
>>>
>>>                         // (sig message pubkey -- bool)
>>>                         if (stack.size() < 3) {
>>>                             return set_error(
>>>                                 serror, SCRIPT_ERR_INVALID_STACK_OPERATION);
>>>                         }
>>>
>>>                         valtype &vchSig = stacktop(-3);
>>>                         valtype &vchMessage = stacktop(-2);
>>>                         valtype &vchPubKey = stacktop(-1);
>>>
>>>                         if (!CheckDataSignatureEncoding(vchSig, flags,
>>>                                                         serror) ||
>>>                             !CheckPubKeyEncoding(vchPubKey, flags, serror)) {
>>>                             // serror is set
>>>                             return false;
>>>                         }
>>>
>>>                         bool fSuccess = false;
>>>                         if (vchSig.size()) {
>>>                             valtype vchHash(32);
>>>                             CSHA256()
>>>                                 .Write(vchMessage.data(), vchMessage.size())
>>>                                 .Finalize(vchHash.data());
>>>                             uint256 message(vchHash);
>>>                             CPubKey pubkey(vchPubKey);
>>>                             fSuccess = pubkey.Verify(message, vchSig);
>>>                         }
>>>
>>>                         if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) &&
>>>                             vchSig.size()) {
>>>                             return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);
>>>                         }
>>>
>>>                         popstack(stack);
>>>                         popstack(stack);
>>>                         popstack(stack);
>>>                         stack.push_back(fSuccess ? vchTrue : vchFalse);
>>>                         if (opcode == OP_CHECKDATASIGVERIFY) {
>>>                             if (fSuccess) {
>>>                                 popstack(stack);
>>>                             } else {
>>>                                 return set_error(serror,
>>>                                                  SCRIPT_ERR_CHECKDATASIGVERIFY);
>>>                             }
>>>                         }
>>>                     } break;
>>> ```
>>>
>>> Sample Usage
>>> ------------
>>>
>>> The following example shows a spend and redeem script for a basic use of CHECKDATASIG.  This example validates the signature of some data, provides a placeholder where you would then process that data, and finally allows one of 2 signatures to spend based on the outcome of the data processing.
>>>
>>> ### spend script:
>>> ```
>>> push txsignature
>>> push txpubkey
>>> push msg
>>> push sig
>>> ```
>>> ### redeem script:
>>> ```
>>>                                 (txsig, txpubkey msg, sig)
>>> OP_OVER                         (txsig, txpubkey, msg, sig, msg)
>>> push data pubkey                (txsig, txpubkey, msg, sig, msg, pubkey)
>>> OP_CHECKDATASIGVERIFY           (txsig, txpubkey, msg)
>>> ```
>>> Now that msg is on the stack top, the script can write predicates on it,
>>> resulting in the message being consumed and a true/false condition left on the stack: (txpubkey, txsig, boolean)
>>> ```
>>> OP_IF                           (txsig, txpubkey)
>>>   OP_DUP                        (txsig, txpubkey, txpubkey)
>>>   OP_HASH160                    (txsig, txpubkey, address)
>>>   push <p2pkh spend address>    (txsig, txpubkey, address, p2pkh spend address)
>>>   OP_EQUALVERIFY                (txsig, txpubkey)
>>>   OP_CHECKSIG
>>> OP_ELSE
>>>   (same as if clause but a different <p2pkh spend address>)
>>> OP_ENDIF
>>> ```
>>>
>>> History
>>> -------
>>>
>>> This specification is based on Andrew Stone?s OP_DATASIGVERIFY proposal [6, 7]. It is modified from Stone's original proposal based on a synthesis of all the peer-review and feedback received [8].
>>>
>>> References
>>> ----------
>>>
>>> [1] [OP_CHECKSIG](https://en.bitcoin.it/wiki/OP_CHECKSIG)
>>>
>>> [2] [Strict DER Encoding](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)
>>>
>>> [3] [Low-S and Nullfail Specification](https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki)
>>>
>>> [4] [Bitcoin ABC implementation](https://reviews.bitcoinabc.org/D1621)
>>>
>>> [5] [Bitcoin ABC implementation update](https://reviews.bitcoinabc.org/D1646)
>>>
>>> [6] [Andrew Stone?s OP_DATASIGVERIFY](https://github.com/BitcoinUnlimited/BitcoinUnlimited/blob/bucash1.3.0.0/doc/opdatasigverify.md)
>>>
>>> [7] [Andrew Stone's article on Scripting](https://medium.com/@g.andrew.stone/bitcoin-scripting-applications-decision-based-spending-8e7b93d7bdb9)
>>>
>>> [8] [Peer Review of Andrew Stone's Proposal](https://github.com/bitcoincashorg/bitcoincash.org/pull/10)
>>>
>>>
>>> --
>>> @JeremyRubin <https://twitter.com/JeremyRubin>
>>> <https://twitter.com/JeremyRubin>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/e56d5b04/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sun Jul  4 00:22:18 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 04 Jul 2021 00:22:18 +0000
Subject: [bitcoin-dev] CheckSigFromStack for Arithmetic Values
In-Reply-To: <CAJowKgJxsknJ_TnQU1bvz3VyBHFaykXjDQAfsnxSzoeE1KJhbw@mail.gmail.com>
References: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>
 <YEsEkExygpn5zEqfCXSt8duo9C0tgyx9YBTRejVn8ccwX2SQCPQVP5r2Nav6isQIbK8ED2Z-fYNwcN0VhXpxAIhCd3TWeU1et85cZFIVWdA=@protonmail.com>
 <CAD5xwhggR_uC-Dx9S8kXj-j8L2EdXhmXdGmht05wC6nB3Xn_+w@mail.gmail.com>
 <CAJowKgJxsknJ_TnQU1bvz3VyBHFaykXjDQAfsnxSzoeE1KJhbw@mail.gmail.com>
Message-ID: <5g9bzPMinzlRiQhDmlVBo1OQyR516-RABcphP1QiiLBbS47dZwvz_ufqLndLcUZL4OApEZvP60k4hliVuK50lEJkN1qY0QppKx2uUXpEkLY=@protonmail.com>

Good morning Erik,

> i may be ignorant here but i have a question:
>
> Given that schnorr signatures now allow signers to perform complex arithmetic signing operations out-of-band using their own communications techniques, couldn't you just perform the publishing and accumulation of these signature components without using a bitcoin script?
>
> In other?words, push the effort of combination and computation off of the bitcoin network and nodes.

Actually the post is not about *doing* Arithmetic using signing operations, it is about enabling signing operations *at all* using arithmetic operation `OP_ADD`.
Jeremy in the initial post is not doing arithmetic, he is using arithmetic to implement Lamport signatures (which cannot support arithmetic signing operations anyway, being a hash-based signing scheme).

The "for" arithmetic here is largely to mean that this cleverness allows an implementation of `OP_CHECKSIGFROMSTACK`, using arithmetic operation `OP_ADD`.

To my mind this cleverness is more of an argument against ever enabling `OP_ADD` and friends, LOL.
This is more of a "bad but ridiculously clever thing" post than a "Bitcoin should totally use this thing" post.

Regards,
ZmnSCPxj

>
> On Sat, Jul 3, 2021 at 12:01 AM Jeremy via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > Yep -- sorry for the confusing notation but seems like you got it. C++ templates have this issue too btw :)
> >
> > One cool thing is that if you have op_add for arbitrary width integers or op_cat you can also make a quantum proof signature by signing the signature made with checksig with the lamport.
> >
> > There are a couple gotchas wrt crypto assumptions on that but I'll write it up soon ? it also works better in segwit V0 because there's no keypath spend -- that breaks the quantum proofness of this scheme.
> >
> > On Fri, Jul 2, 2021, 4:58 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> >
> > > Good morning Jeremy,
> > >
> > > > Dear Bitcoin Devs,
> > > >
> > > > It recently occurred to me that it's possible to do a lamport signature in script for arithmetic values by using a binary expanded representation. There are some applications that might benefit from this and I don't recall seeing it discussed elsewhere, but would be happy for a citation/reference to the technique.
> > > >
> > > > blog post here, https://rubin.io/blog/2021/07/02/signing-5-bytes/, text reproduced below
> > > >
> > > > There are two insights in this post:
> > > > 1. to use a bitwise expansion of the number
> > > > 2. to use a lamport signature
> > > > Let's look at the code in python and then translate to bitcoin script:
> > > > ```python
> > > > def add_bit(idx, preimage, image_0, image_1):
> > > > ? ? s = sha256(preimage)
> > > > ? ? if s == image_1:
> > > > ? ? ? ? return (1 << idx)
> > > > ? ? if s == image_0:
> > > > ? ? ? ? return 0
> > > > ? ? else:
> > > > ? ? ? ? assert False
> > > > def get_signed_number(witnesses : List[Hash], keys : List[Tuple[Hash, Hash]]):
> > > > ? ? acc = 0
> > > > ? ? for (idx, preimage) in enumerate(witnesses):
> > > > ? ? ? ? acc += add_bit(idx, preimage, keys[idx][0], keys[idx][1])
> > > > ? ? return x
> > > > ```
> > > > So what's going on here? The signer generates a key which is a list of pairs of
> > > > hash images to create the script.
> > > > To sign, the signer provides a witness of a list of preimages that match one or the other.
> > > > During validation, the network adds up a weighted value per preimage and checks
> > > > that there are no left out values.
> > > > Let's imagine a concrete use case: I want a third party to post-hoc sign a sequence lock. This is 16 bits.
> > > > I can form the following script:
> > > > ```
> > > > <pk> checksigverify
> > > > 0
> > > > SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <1<<1> ADD ELSE <H(K_1_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <1<<2> ADD ELSE <H(K_2_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <1<<3> ADD ELSE <H(K_3_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <1<<4> ADD ELSE <H(K_4_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <1<<5> ADD ELSE <H(K_5_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <1<<6> ADD ELSE <H(K_6_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <1<<7> ADD ELSE <H(K_7_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <1<<8> ADD ELSE <H(K_8_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <1<<9> ADD ELSE <H(K_9_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1<<10> ADD ELSE <H(K_10_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <1<<11> ADD ELSE <H(K_11_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <1<<12> ADD ELSE <H(K_12_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <1<<13> ADD ELSE <H(K_13_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <1<<14> ADD ELSE <H(K_14_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <1<<15> ADD ELSE <H(K_15_0)> EQUALVERIFY ENDIF
> > > > CHECKSEQUENCEVERIFY
> > > > ```
> > >
> > > This took a bit of thinking to understand, mostly because you use the `<<` operator in a syntax that uses `< >` as delimiters, which was mildly confusing --- at first I thought you were pushing some kind of nested SCRIPT representation, but in any case, replacing it with the actual numbers is a little less confusing on the syntax front, and I think (hope?) most people who can understand `1<<1` have also memorized the first few powers of 2....
> > >
> > > > ```
> > > > <pk> checksigverify
> > > > 0
> > > > SWAP sha256 DUP <H(K_0_1)> EQUAL IF DROP <1> ADD ELSE <H(K_0_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_1_1)> EQUAL IF DROP <2> ADD ELSE <H(K_1_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_2_1)> EQUAL IF DROP <4> ADD ELSE <H(K_2_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_3_1)> EQUAL IF DROP <8> ADD ELSE <H(K_3_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_4_1)> EQUAL IF DROP <16> ADD ELSE <H(K_4_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_5_1)> EQUAL IF DROP <32> ADD ELSE <H(K_5_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_6_1)> EQUAL IF DROP <64> ADD ELSE <H(K_6_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_7_1)> EQUAL IF DROP <128> ADD ELSE <H(K_7_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_8_1)> EQUAL IF DROP <256> ADD ELSE <H(K_8_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_9_1)> EQUAL IF DROP <512> ADD ELSE <H(K_9_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_10_1)> EQUAL IF DROP <1024> ADD ELSE <H(K_10_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_11_1)> EQUAL IF DROP <2048> ADD ELSE <H(K_11_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_12_1)> EQUAL IF DROP <4096> ADD ELSE <H(K_12_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_13_1)> EQUAL IF DROP <8192> ADD ELSE <H(K_13_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_14_1)> EQUAL IF DROP <16384> ADD ELSE <H(K_14_0)> EQUALVERIFY ENDIF
> > > > SWAP sha256 DUP <H(K_15_1)> EQUAL IF DROP <32768> ADD ELSE <H(K_15_0)> EQUALVERIFY ENDIF
> > > > CHECKSEQUENCEVERIFY
> > > > ```
> > >
> > > On the other hand LOL WTF, this is cool.
> > >
> > > Basically you are showing that if we enable something as innocuous as `OP_ADD`, we can implement Lamport signatures for **arbitrary** values representable in small binary numbers (16 bits in the above example).
> > >
> > > I was thinking "why not Merkle signatures" since the pubkey would be much smaller but the signature would be much larger, but (a) the SCRIPT would be much more complicated and (b) in modern Bitcoin, the above SCRIPT would be in the witness stack anyway so there is no advantage to pushing the size towards the signature rather than the pubkey, they all have the same weight, and since both Lamport and Merkle are single-use-only and we do not want to encourage pubkey reuse even if they were not, the Merkle has much larger signature size, so Merkle sigs end up more expensive.
> > >
> > > Regards,
> > > ZmnSCPxj
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From dave at dtrt.org  Sun Jul  4 01:13:41 2021
From: dave at dtrt.org (David A. Harding)
Date: Sat, 3 Jul 2021 15:13:41 -1000
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
Message-ID: <20210704011341.ddbiruuomqovrjn6@ganymede>

On Sat, Jul 03, 2021 at 09:31:57AM -0700, Jeremy via bitcoin-dev wrote:
> Note that with *just* CheckSigFromStack, while you can do some very
> valuable use cases, but without OP_CAT it does not enable sophisticated
> covenants

Do you have concerns about sophisticated covenants, and if so, would you
mind describing them?  Your BIP119 CTV also mentions[1] being designed
to avoid sophisticated covenants.  If this is some sort of design
principle, I'd like to understand the logic behind it.

I'm a fan of CSFS, even mentioning it on zndtoshi's recent survey[2],
but it seems artificially limited without OP_CAT.  (I also stand by my
answer on that survey of believing there's a deep lack of developer
interest in CSFS at the moment.  But, if you'd like to tilt at that
windmill, I won't stop you.)

-Dave

[1] https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki#design-tradeoffs-and-risks

[2] https://twitter.com/zndtoshi/status/1405235814712422402

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210703/0e0be72f/attachment.sig>

From ZmnSCPxj at protonmail.com  Sun Jul  4 13:10:36 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sun, 04 Jul 2021 13:10:36 +0000
Subject: [bitcoin-dev] CheckSigFromStack for Arithmetic Values
In-Reply-To: <5g9bzPMinzlRiQhDmlVBo1OQyR516-RABcphP1QiiLBbS47dZwvz_ufqLndLcUZL4OApEZvP60k4hliVuK50lEJkN1qY0QppKx2uUXpEkLY=@protonmail.com>
References: <CAD5xwhiqwqRjMboX8z_xapBq5=KOfP3eOSQzRcY-Cc7wq1gXUQ@mail.gmail.com>
 <YEsEkExygpn5zEqfCXSt8duo9C0tgyx9YBTRejVn8ccwX2SQCPQVP5r2Nav6isQIbK8ED2Z-fYNwcN0VhXpxAIhCd3TWeU1et85cZFIVWdA=@protonmail.com>
 <CAD5xwhggR_uC-Dx9S8kXj-j8L2EdXhmXdGmht05wC6nB3Xn_+w@mail.gmail.com>
 <CAJowKgJxsknJ_TnQU1bvz3VyBHFaykXjDQAfsnxSzoeE1KJhbw@mail.gmail.com>
 <5g9bzPMinzlRiQhDmlVBo1OQyR516-RABcphP1QiiLBbS47dZwvz_ufqLndLcUZL4OApEZvP60k4hliVuK50lEJkN1qY0QppKx2uUXpEkLY=@protonmail.com>
Message-ID: <gke1-m0LNsMpPk9TB2ZeeUGgBza7guUJWFWjEhGRMt3MhkYZ7FDOhytx8gY7lv5P2lojyO943NL3T7Jkgwardq2UfLktKcU0TZeQCD70hr4=@protonmail.com>

Good morning Erik and Jeremy,

> The "for" arithmetic here is largely to mean that this cleverness allows an implementation of `OP_CHECKSIGFROMSTACK`, using arithmetic operation `OP_ADD`.
>
> To my mind this cleverness is more of an argument against ever enabling `OP_ADD` and friends, LOL.
> This is more of a "bad but ridiculously clever thing" post than a "Bitcoin should totally use this thing" post.

Turns out `OP_ADD` is actually still enabled in Bitcoin, LOL, I thought it was hit in the same banhammer that hit `OP_CAT` and `OP_MUL`.
Limited to 32 bits, but that simply means that you just validate longer bitvectors (e.g. the `s` in the "lamport-sign the EC signature") in sections of 32 bits.

In any case, the point still mostly stands, I think this is more of a "overall bad but still ridiculously clever" idea; the script and witness sizes are fairly awful.
Mostly just worth discussing just in case it triggers somebody else to think of a related idea that takes some of the cleverness but is overall better.

On the other hand if we can actually implement the "Lamport-sign the EC sig" idea (I imagine the 32-bit limit requires some kind of `OP_CAT` or similar, or other bit or vector slicing operetion), that does mean Bitcoin is already quantum-safe (but has a fairly lousy quantum-safe signing scheme, I really do not know the characteristics of better ones though).

Regards,
ZmnSCPxj

From jlrubin at mit.edu  Sun Jul  4 17:30:18 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 4 Jul 2021 10:30:18 -0700
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
 <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
 <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>
Message-ID: <CAD5xwhgtsqAX99NJRU6t-s14aF7frGZxFCL3-c9iBOYrkN_A_w@mail.gmail.com>

I don't really see the point of CHECKSIGFROMSTACKADD since it's not bound
to the txdata? When might you use this?

And yes -- "Add OP_CHECKSIGFROMSTACK and OP_CHECKSIGFROMSTACKVERIFY to
follow the semantics from bip340-342 when witness program is v1." is a bit
light on detail for what the BIP would end up looking like. If you're able
to open up the design process a bit more on that it would be good as I
think there are some topics worth discussing at large before things proceed
with Elements (assuming feature compatibility remains a goal).

The non-prehashed argument seems OK (at the cost of an extra byte...) but
are there specific applications for !=32 arguments? I can't think of a
particular one beyond perhaps efficiency. Can we safely use 0-520 byte
arguments?

Also do you have thoughts on the other questions i posed above? E.g.
splitting R/S could be helpful w/o CAT.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Sat, Jul 3, 2021 at 1:13 PM Russell O'Connor <roconnor at blockstream.com>
wrote:

> There is one line written at
> https://github.com/ElementsProject/elements/pull/949/files#r660130155.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/0301926c/attachment.html>

From jlrubin at mit.edu  Sun Jul  4 18:39:44 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 4 Jul 2021 11:39:44 -0700
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <20210704011341.ddbiruuomqovrjn6@ganymede>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
Message-ID: <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>

>
> Do you have concerns about sophisticated covenants, and if so, would you
> mind describing them?


Personally, not in particular worried about arbitrary covenants as I think
that: 1 validation costs can be kept in check; 2 you're free to burn your
coins it you want to.

I *do* care that when we enable covenants we don't make people jump through
too many hoops, but I also respect Russel's points that we can enable
functionality and then later figure out how to make it more efficient or
useful guided by use cases.


However, I think the broader community is unconvinced by the cost benefit
of arbitrary covenants. See
https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
as a recent example. Therefore as a critical part of building consensus on
various techniques I've worked to emphasize that specific additions do not
entail risk of accidentally introducing more than was bargained for to
respect the concerns of others.


>
> I'm a fan of CSFS, even mentioning it on zndtoshi's recent survey[2],
> but it seems artificially limited without OP_CAT.  (I also stand by my
> answer on that survey of believing there's a deep lack of developer
> interest in CSFS at the moment.  But, if you'd like to tilt at that
> windmill, I won't stop you.)


Well if you're a fan of it, I'm a fan of it, Russel's a fan of it, and
Sanket's a fan of it that sounds like a good amount of dev interest :) I
know Olaoluwa is also a fan of it too and has some cool L2 protocols using
it.

I think it might not be *hype* because it's been around a while and has
always been bundled with cat so been a non starter for the reasons above. I
think as an independent non-bundle it's exciting and acceptable to a number
of devs. I also believe upgrades can be developed and tracked in parallel
so I'm taking on the windmill tilting personally to spearhead that -- on
the shoulders of Giants who have been creating specs for this already of
course.

Best,

Jeremy

P.s. icymi https://rubin.io/blog/2021/07/02/covenants/ covers my current
thinking about how to proceed w.r.t. deploying and developing covenant
systems for bitcoin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/186f65c4/attachment.html>

From danielb at numberall.com  Sun Jul  4 17:56:28 2021
From: danielb at numberall.com (Daniel Bayerdorffer)
Date: Sun, 4 Jul 2021 13:56:28 -0400 (EDT)
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <CAPR5oBMnzzNxL1j5YRgJNLnC9aPTX0m=As23KB2Wf-UDahL40A@mail.gmail.com>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <20210703032405.j3mru5rbag5sbfil@ganymede>
 <ad7657ea-0c35-f065-1788-cc8663bf94b5@achow101.com>
 <CAPR5oBP+5r8WLOew6zOdp3BzOLNr0vf2SVK028zfgoCSyu2wnA@mail.gmail.com>
 <20210703100540.pr3nsgjhox26hhic@ganymede>
 <CAPR5oBMnzzNxL1j5YRgJNLnC9aPTX0m=As23KB2Wf-UDahL40A@mail.gmail.com>
Message-ID: <1628014947.8985.1625421388348.JavaMail.zimbra@numberall.com>

Hello, 

I just wanted to put my two cents in, on the metal backup aspect. We make the Bitcoin Recovery Tag for a similar purpose. We use a fixed font, so using ' (apostrophe) or H/h are both acceptable. Most metal stamping tools are fixed width fonts. 

You can see a picture here... 
[ https://cyphersafe.io/product/bitcoin-recovery-tag/ | https://cyphersafe.io/product/bitcoin-recovery-tag/ ] 

Thanks, 
Daniel 

-- 
Daniel Bayerdorffer, VP danielb at numberall.com 
Numberall Stamp & Tool Co., Inc. www.numberall.com 
Reuleaux Models www.reuleauxmodels.com 
CypherSafe www.cyphersafe.io 
PO BOX 187, Sangerville, ME 04479 USA 
TEL: 207-876-3541 FAX: 207-876-3566 


From: "Craig Raw via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org> 
To: "David A. Harding" <dave at dtrt.org> 
Cc: "Bitcoin Protocol Discussion" <bitcoin-dev at lists.linuxfoundation.org> 
Sent: Saturday, July 3, 2021 10:00:51 AM 
Subject: Re: [bitcoin-dev] BIP Proposals for Output Script Descriptors 

It's a consideration, not a serious concern. 
When I made the point around alphanumeric characters being similar to the path numbers, I was actually thinking of the output descriptor appearing in a fixed character width font, which I prefer as more appropriate for displaying hexidecimal values. In this case, the apostrophe provides more whitespace which makes the path easier to parse visually. It's difficult to reduce this to a mathematical argument, as is true for many UX considerations. Your example in fixed width here: [ https://gist.github.com/craigraw/fc98b9031a7e01e1bc5d75a77bdb72e5 | https://gist.github.com/craigraw/fc98b9031a7e01e1bc5d75a77bdb72e5 ] 

That said you make good arguments around the shell quoting and stamps for metal backups, and therefore I agree it is preferable to use the lowercase "h". Thanks for the detailed reply. 

Craig 

On Sat, Jul 3, 2021 at 12:11 PM David A. Harding < [ mailto:dave at dtrt.org | dave at dtrt.org ] > wrote: 


On Sat, Jul 03, 2021 at 10:35:48AM +0200, Craig Raw wrote: 
> There is a downside to using "h"/"H" from a UX perspective - taking up more 
> space 

Is this a serious concern of yours? An apostrophe is 1/2 en; an "h" is 
1 en; the following descriptor contains three hardened derivations in 149 
characters; assuming the average non-'/h character width is 1.5 en, the 
difference between 207 en and 208.5 en is barely more than half a 
percent. 

pkh([d34db33f/44h/0h/0h]xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/1/*)#ml40v0wf 

Here's a direct visual comparison: [ https://gist.github.com/harding/2fbbf2bfdce04c3e4110082f03ae3c80 | https://gist.github.com/harding/2fbbf2bfdce04c3e4110082f03ae3c80 ] 

> appearing as alphanumeric characters similar to the path numbers 

First, I think you'd have to be using an awful font to confuse "h" with 
any arabic numeral. Second, avoiding transcription errors is exactly 
why descriptors now have checksums. 

> they make derivation paths and descriptors more difficult to read. 

The example descriptor pasted above looks equally (un)readable to me 
whether it uses ' or h. 

> Also, although not as important, less efficient when making metal 
> backups. 

I think many metal backup schemes are using stamps or punch grids that 
are fixed-width in nature, so there's no difference either way. (And 
you can argue that h is better since it's part of both the base58check 
and bech32 character sets, so you already need a stamp or a grid row for 
it---but ' is otherwise unused, so a stamp or grid row for it would be 
special). 

But even if people are manually etching descriptors into metal, we're 
back to the original point where we're looking at something like a 0.7% 
difference in "efficiency". 

By comparison, the Bitcoin Core issue I cited in my earlier post 
contains several examples of actual users needing technical support 
because they tried to use '-containing descriptors in a bourne-style 
shell. (And I've personally lost time to that class of problems.) In 
the worst case, a shell-quoting accident can cause loss of money by 
sending bitcoins to the descriptor for a key your hardware signing 
device won't sign for. I think these problems are much more serious 
than using a tiny bit of extra space in a GUI or on a physical backup 
medium. 

-Dave 




_______________________________________________ 
bitcoin-dev mailing list 
bitcoin-dev at lists.linuxfoundation.org 
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/5ab210fd/attachment-0001.html>

From roconnor at blockstream.com  Sun Jul  4 19:03:40 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sun, 4 Jul 2021 15:03:40 -0400
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAD5xwhgtsqAX99NJRU6t-s14aF7frGZxFCL3-c9iBOYrkN_A_w@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
 <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
 <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>
 <CAD5xwhgtsqAX99NJRU6t-s14aF7frGZxFCL3-c9iBOYrkN_A_w@mail.gmail.com>
Message-ID: <CAMZUoKmWqSnWhTUmTXRuAsrgd0KsQ+XjPw1s+XsZWARhsDcGsA@mail.gmail.com>

On Sun, Jul 4, 2021 at 1:30 PM Jeremy <jlrubin at mit.edu> wrote:

> I don't really see the point of CHECKSIGFROMSTACKADD since it's not bound
> to the txdata? When might you use this?
>

I don't feel strongly about *ADD.  I just figured it might be useful to do
a 2-of-3 between Alice, Bob and an Oracle signed value.  But I don't have
any particular use case in mind.  Either way the *ADD functionality can be
replicated by various SWAPs and ADDs etc, so we could just leave it out
until it is wanted.


> And yes -- "Add OP_CHECKSIGFROMSTACK and OP_CHECKSIGFROMSTACKVERIFY to
> follow the semantics from bip340-342 when witness program is v1." is a bit
> light on detail for what the BIP would end up looking like. If you're able
> to open up the design process a bit more on that it would be good as I
> think there are some topics worth discussing at large before things proceed
> with Elements (assuming feature compatibility remains a goal).
>

I'm certainly open to a wider design process.  We can open a specific issue
on the Elements repo.  That said, I don't see a particularly wide design
space on this front.


> The non-prehashed argument seems OK (at the cost of an extra byte...) but
> are there specific applications for !=32 arguments? I can't think of a
> particular one beyond perhaps efficiency. Can we safely use 0-520 byte
> arguments?
>

One of the reasons given in the issue (yes, the thread there is very long)
was that hashing the message requires the hash to be collision resistant
while if you give the message directly it only requires the hash to be
"random-prefix" collision / preimage resistant.  For example SHA-1 is
clearly not collision resistant but it appears to still be random-prefix
collision resistant AFAIU.  Another reason is that it allows for extremely
fast signing oracles because and R value and the midstate of the hash can
be precomputed all the way upto the application prefix, and if the message
being signed is less than 55 bytes or so, the signing cost can be as low as
one compression function and a little bit of non-EC modular arithmetic to
compute S.  If the message were required to be prehashed, then it would
take a minimum of 2 compression function calls to sign, nearly doubling the
signing time needed for the fast oracle.

Even if BIP-0340 kept its requirements that the message be exactly 32
bytes, I would still be inclined to design CHECKSIGFROMSTACK for tapscript
to take the 32-byte message from the stack instead of hashing a message
itself (BIP-0340 does it's own hashing, so prehashing the message isn't a
security concern in the same way it is for ECDSA.)  This would keep the
message off the blockchain, saving space and adding some amount of privacy
and making the operation compatible with rolling SHA256 opcodes.  But given
that BIP-0340 is going to be extended to support non-32 byte messages, then
there is no reason to impose a message length restriction on
CHECKSIGFROMSTACK.  Yes the operation will still be subject to stack item
length restrictions.  This is something script writers will have to be
aware of, but I see little reason to support messages split across multiple
stack items when we expect, by far, most messages to be 32-bytes, and I
expect those rare non-32 byte messages are expected to be reasonably short.


> Also do you have thoughts on the other questions i posed above? E.g.
> splitting R/S could be helpful w/o CAT.
>

Regarding  internal pubkeys and invalid pubkeys, I see no reason to deviate
from whatever tapscript CHECKSIG* do.

Regarding splitting R/S, This is harder because Elements does have CAT and
I think we should add CAT to Bitcoin too.  This game of trying to prevent
covenants by restricting script to the point where we are not even allowed
to have a CAT operation is a losing game.  It's just a matter of time
before we accidently introduce some way to enable covenants anyways, and it
is not worth cutting off vast amounts of functionality in pursuit of this
questionable goal.  And I say this as someone who was originally of the
opinion that we should be very very cautious before enabling new
expressivity such as covenants.  All the scary scenarios of covenants that
I am aware of can be more easily, cheaply, and flexibility implemented by
just having a counterparty in a multi-party signature that enforces their
own policy that they only sign transactions that pay to outputs that they
remain a party to.  And even if scary covenants were scarier than what can
already be done by multisig and policy, I still don't think they are scary
enough to warrant keeping CAT disabled.

So I don't think we should get fancy with CHECKSIGFROMSTACK.  Just take a
normal 64-byte signature value as a stack item.  But I don't feel strongly
about this, and I wouldn't oppose splitting R and S in Bitcoin if that is
where consensus lies.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/b7f6ae05/attachment.html>

From dave at dtrt.org  Sun Jul  4 20:32:30 2021
From: dave at dtrt.org (David A. Harding)
Date: Sun, 4 Jul 2021 10:32:30 -1000
Subject: [bitcoin-dev] Unlimited covenants,
 was Re:  CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
Message-ID: <20210704203230.37hlpdyzr4aijiet@ganymede>

On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
> However, I think the broader community is unconvinced by the cost benefit
> of arbitrary covenants. See
> https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
> as a recent example. Therefore as a critical part of building consensus on
> various techniques I've worked to emphasize that specific additions do not
> entail risk of accidentally introducing more than was bargained for to
> respect the concerns of others.

Respecting the concerns of others doesn't require lobotomizing useful
tools.  Being respectful can also be accomplished by politely showing
that their concerns are unfounded (or at least less severe than they
thought).  This is almost always the better course IMO---it takes much
more effort to satisfy additional engineering constraints (and prove to
reviewers that you've done so!) than it does to simply discuss those
concerns with reasonable stakeholders.  As a demonstration, let's look
at the concerns from Shinobi's post linked above:

They seem to be worried that some Bitcoin users will choose to accept
coins that can't subsequently be fungibily mixed with other bitcoins.
But that's already been the case for a decade: users can accept altcoins
that are non-fungible with bitcoins.

They talk about covenants where spending is controlled by governments,
but that seems to me exactly like China's CBDC trial.

They talk about exchanges depositing users' BTC into a covenant, but 
that's just a variation on the classic not-your-keys-not-your-bitcoins
problem.  For all you know, your local exchange is keeping most of its
BTC balance commitments in ETH or USDT.

To me, it seems like the worst-case problems Shinobi describes with
covenants are some of the same problems that already exist with
altcoins.  I don't see how recursive covenants could make any of those
problems worse, and so I don't see any point in limiting Bitcoin's
flexibility to avoid those problems when there are so many interesting
and useful things that unlimited covenants could do.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/141168f5/attachment.sig>

From billy.tetrud at gmail.com  Sun Jul  4 20:50:43 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 4 Jul 2021 13:50:43 -0700
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <20210704203230.37hlpdyzr4aijiet@ganymede>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
Message-ID: <CAGpPWDbUs01-Q=5F5Tw3biGwPRnH5kwNd6v=bdRGLG0HihqtXA@mail.gmail.com>

I agree with you David. I think rather unconstrained covenants are
incredibly useful and important. Yes you can burn coins with them, you can
also permanently limit the usability of certain coins (which is less
destructive than burning them). But as Jeremy said, people are free to burn
their coins. People would also be free (in general) to reject coins
encumbered by weird government provisions or unknown provisions in hidden
scripts. A person/wallet shouldn't accept coins encumbered by scripts it
doesn't recognize.

Even if 99% of bitcoins became permanently encumbered by weird covenants,
the other 1% could still be plenty of bitcoins to run the economy, because
of its potentially infinite divisibility. Losing these coins, or someone
basically turning them into altcoin-like bitcoins shouldn't be a concern
really. What's the risk exactly? That people will be forced to take these
encumbered coins? A government can already force people to take whatever
altcoin they want to force on people - covenants don't make this worse.

Shinobi asks: "What if you extorted users with your 51% attack to move into
those?"

Well, you could do this anyway even without covenants existing already. The
51% attack could simply extort people to use whatever rules they want just
as easily (which isn't to say that easily - most users would probably
refuse to be extorted in either case). So I don't really think this is very
valid.

On Sun, Jul 4, 2021 at 1:33 PM David A. Harding via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
> > However, I think the broader community is unconvinced by the cost benefit
> > of arbitrary covenants. See
> >
> https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
> > as a recent example. Therefore as a critical part of building consensus
> on
> > various techniques I've worked to emphasize that specific additions do
> not
> > entail risk of accidentally introducing more than was bargained for to
> > respect the concerns of others.
>
> Respecting the concerns of others doesn't require lobotomizing useful
> tools.  Being respectful can also be accomplished by politely showing
> that their concerns are unfounded (or at least less severe than they
> thought).  This is almost always the better course IMO---it takes much
> more effort to satisfy additional engineering constraints (and prove to
> reviewers that you've done so!) than it does to simply discuss those
> concerns with reasonable stakeholders.  As a demonstration, let's look
> at the concerns from Shinobi's post linked above:
>
> They seem to be worried that some Bitcoin users will choose to accept
> coins that can't subsequently be fungibily mixed with other bitcoins.
> But that's already been the case for a decade: users can accept altcoins
> that are non-fungible with bitcoins.
>
> They talk about covenants where spending is controlled by governments,
> but that seems to me exactly like China's CBDC trial.
>
> They talk about exchanges depositing users' BTC into a covenant, but
> that's just a variation on the classic not-your-keys-not-your-bitcoins
> problem.  For all you know, your local exchange is keeping most of its
> BTC balance commitments in ETH or USDT.
>
> To me, it seems like the worst-case problems Shinobi describes with
> covenants are some of the same problems that already exist with
> altcoins.  I don't see how recursive covenants could make any of those
> problems worse, and so I don't see any point in limiting Bitcoin's
> flexibility to avoid those problems when there are so many interesting
> and useful things that unlimited covenants could do.
>
> -Dave
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/f743e180/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Mon Jul  5 00:50:50 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 05 Jul 2021 00:50:50 +0000
Subject: [bitcoin-dev] Unlimited covenants,
	was Re:  CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <20210704203230.37hlpdyzr4aijiet@ganymede>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
Message-ID: <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>

Good morning Dave,

> On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
>
> > However, I think the broader community is unconvinced by the cost benefit
> > of arbitrary covenants. See
> > https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
> > as a recent example. Therefore as a critical part of building consensus on
> > various techniques I've worked to emphasize that specific additions do not
> > entail risk of accidentally introducing more than was bargained for to
> > respect the concerns of others.
>
> Respecting the concerns of others doesn't require lobotomizing useful
> tools. Being respectful can also be accomplished by politely showing
> that their concerns are unfounded (or at least less severe than they
> thought). This is almost always the better course IMO---it takes much
> more effort to satisfy additional engineering constraints (and prove to
> reviewers that you've done so!) than it does to simply discuss those
> concerns with reasonable stakeholders. As a demonstration, let's look
> at the concerns from Shinobi's post linked above:
>
> They seem to be worried that some Bitcoin users will choose to accept
> coins that can't subsequently be fungibily mixed with other bitcoins.
> But that's already been the case for a decade: users can accept altcoins
> that are non-fungible with bitcoins.
>
> They talk about covenants where spending is controlled by governments,
> but that seems to me exactly like China's CBDC trial.
>
> They talk about exchanges depositing users' BTC into a covenant, but
> that's just a variation on the classic not-your-keys-not-your-bitcoins
> problem. For all you know, your local exchange is keeping most of its
> BTC balance commitments in ETH or USDT.
>
> To me, it seems like the worst-case problems Shinobi describes with
> covenants are some of the same problems that already exist with
> altcoins. I don't see how recursive covenants could make any of those
> problems worse, and so I don't see any point in limiting Bitcoin's
> flexibility to avoid those problems when there are so many interesting
> and useful things that unlimited covenants could do.

The "altcoins are even worse" argument does seem quite convincing, and if Bitcoin can survive altcoins, surely it can survive covenants too?

In before "turns out covenants are the next ICO".
i.e. ICOs are just colored coins, which are useful for keeping track of various stuff, but have then been used as a vehicle to scam people.
But I suppose that is a problem that humans will always have: limited cognition, so that *good* popular things that are outside your specific field of study are indistinguishable from *bad* popular things.
So perhaps it should not be a concern on a technical level.
Maybe we should instead make articles about covenants so boring nobody will hype about it (^^;)v.

Increased functionality implies increased processing, and hopefully computation devices are getting cheap enough that the increased processing implied by new features should not be too onerous.



To my mind, an "inescapable" covenant (i.e. one that requires the output to be paid to the same covenant) is basically a Turing machine, and equivalent to a `while (true);` loop.
In a `while (true);` loop, the state of the machine reverts back to the same state, and it repeats again.
In an inescpable covenant, the control of some amount of funds reverts back to the same controlling SCRIPT, and it repeats again.
Yes, you can certainly add more functionality on top of that loop, just think of program main loops for games or daemons, which are, in essence, "just" `while (true) ...`.
But basically, such unbounded infinite loops are possible only under Turing machines, thus I consider covenants to be Turing-complete.
Principle of Least Power should make us wonder if we need full Turing machines for the functionality.

On the other hand --- codata processing *does* allow for unbounded loops, without requiring full Turing-completeness; they just require total functionality, not partial (and Turing-completeness is partial, not total).
Basically, data structures are unbounded storage, while codata structures are unbounded processing.
Perhaps covenants can encode an upper bound on the number of recursions, which prevents full Turing-completeness while allowing for a large number of use-cases.

(if the above paragraph makes no sense to you, hopefully this Wikipedia article will help: https://en.wikipedia.org/wiki/Total_functional_programming )
(basically my argument here is based on academic programming stuff, and might not actually matter in real life)

Regards,
ZmnSCPxj

From roconnor at blockstream.com  Mon Jul  5 01:02:25 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sun, 4 Jul 2021 21:02:25 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
Message-ID: <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>

Bear in mind that when people are talking about enabling covenants, we are
talking about whether OP_CAT should be allowed or not.

That said, recursive covenants, the type that are most worrying, seems to
require some kind of OP_TWEAK operation, and I haven't yet seen any
evidence that this can be simulated with CHECKSIG(FROMSTACK).  So maybe we
should leave such worries for the OP_TWEAK operation.

On Sun, Jul 4, 2021 at 8:51 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Dave,
>
> > On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
> >
> > > However, I think the broader community is unconvinced by the cost
> benefit
> > > of arbitrary covenants. See
> > >
> https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
> > > as a recent example. Therefore as a critical part of building
> consensus on
> > > various techniques I've worked to emphasize that specific additions do
> not
> > > entail risk of accidentally introducing more than was bargained for to
> > > respect the concerns of others.
> >
> > Respecting the concerns of others doesn't require lobotomizing useful
> > tools. Being respectful can also be accomplished by politely showing
> > that their concerns are unfounded (or at least less severe than they
> > thought). This is almost always the better course IMO---it takes much
> > more effort to satisfy additional engineering constraints (and prove to
> > reviewers that you've done so!) than it does to simply discuss those
> > concerns with reasonable stakeholders. As a demonstration, let's look
> > at the concerns from Shinobi's post linked above:
> >
> > They seem to be worried that some Bitcoin users will choose to accept
> > coins that can't subsequently be fungibily mixed with other bitcoins.
> > But that's already been the case for a decade: users can accept altcoins
> > that are non-fungible with bitcoins.
> >
> > They talk about covenants where spending is controlled by governments,
> > but that seems to me exactly like China's CBDC trial.
> >
> > They talk about exchanges depositing users' BTC into a covenant, but
> > that's just a variation on the classic not-your-keys-not-your-bitcoins
> > problem. For all you know, your local exchange is keeping most of its
> > BTC balance commitments in ETH or USDT.
> >
> > To me, it seems like the worst-case problems Shinobi describes with
> > covenants are some of the same problems that already exist with
> > altcoins. I don't see how recursive covenants could make any of those
> > problems worse, and so I don't see any point in limiting Bitcoin's
> > flexibility to avoid those problems when there are so many interesting
> > and useful things that unlimited covenants could do.
>
> The "altcoins are even worse" argument does seem quite convincing, and if
> Bitcoin can survive altcoins, surely it can survive covenants too?
>
> In before "turns out covenants are the next ICO".
> i.e. ICOs are just colored coins, which are useful for keeping track of
> various stuff, but have then been used as a vehicle to scam people.
> But I suppose that is a problem that humans will always have: limited
> cognition, so that *good* popular things that are outside your specific
> field of study are indistinguishable from *bad* popular things.
> So perhaps it should not be a concern on a technical level.
> Maybe we should instead make articles about covenants so boring nobody
> will hype about it (^^;)v.
>
> Increased functionality implies increased processing, and hopefully
> computation devices are getting cheap enough that the increased processing
> implied by new features should not be too onerous.
>
>
>
> To my mind, an "inescapable" covenant (i.e. one that requires the output
> to be paid to the same covenant) is basically a Turing machine, and
> equivalent to a `while (true);` loop.
> In a `while (true);` loop, the state of the machine reverts back to the
> same state, and it repeats again.
> In an inescpable covenant, the control of some amount of funds reverts
> back to the same controlling SCRIPT, and it repeats again.
> Yes, you can certainly add more functionality on top of that loop, just
> think of program main loops for games or daemons, which are, in essence,
> "just" `while (true) ...`.
> But basically, such unbounded infinite loops are possible only under
> Turing machines, thus I consider covenants to be Turing-complete.
> Principle of Least Power should make us wonder if we need full Turing
> machines for the functionality.
>
> On the other hand --- codata processing *does* allow for unbounded loops,
> without requiring full Turing-completeness; they just require total
> functionality, not partial (and Turing-completeness is partial, not total).
> Basically, data structures are unbounded storage, while codata structures
> are unbounded processing.
> Perhaps covenants can encode an upper bound on the number of recursions,
> which prevents full Turing-completeness while allowing for a large number
> of use-cases.
>
> (if the above paragraph makes no sense to you, hopefully this Wikipedia
> article will help:
> https://en.wikipedia.org/wiki/Total_functional_programming )
> (basically my argument here is based on academic programming stuff, and
> might not actually matter in real life)
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/21a239fc/attachment.html>

From roconnor at blockstream.com  Mon Jul  5 02:10:17 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sun, 4 Jul 2021 22:10:17 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
Message-ID: <CAMZUoKnjAd8hUpa5nZyPWTx_uxHtLL8XOjbROxobfAC+6yMWUA@mail.gmail.com>

On Sun, Jul 4, 2021 at 9:02 PM Russell O'Connor <roconnor at blockstream.com>
wrote:

> Bear in mind that when people are talking about enabling covenants, we are
> talking about whether OP_CAT should be allowed or not.
>
> That said, recursive covenants, the type that are most worrying, seems to
> require some kind of OP_TWEAK operation, and I haven't yet seen any
> evidence that this can be simulated with CHECKSIG(FROMSTACK).  So maybe we
> should leave such worries for the OP_TWEAK operation.
>

Upon further thought, you can probably make recursive covenants even with a
fixed scritpubkey by sneaking the state into a few bits of the UTXO's
amount.  Or if you try really hard, you may be able to stash your state
into a sibling output that is accessed via the txid embedded in the
prevoutpoint.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210704/b5a2a3f1/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Mon Jul  5 02:39:08 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 05 Jul 2021 02:39:08 +0000
Subject: [bitcoin-dev] Unlimited covenants,
	was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnjAd8hUpa5nZyPWTx_uxHtLL8XOjbROxobfAC+6yMWUA@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
 <CAMZUoKnjAd8hUpa5nZyPWTx_uxHtLL8XOjbROxobfAC+6yMWUA@mail.gmail.com>
Message-ID: <l_aP9orUBtFIl4MZp7uritXRqdvsn-ZwC1LhVLwHXIiE8FNShKcbKtapcjvb92HEl1liepJSG1UYtrQW-qMSQnecCcQnf_HHkcVuWhvm1g4=@protonmail.com>

Good morning Russell,


> On Sun, Jul 4, 2021 at 9:02 PM Russell O'Connor <roconnor at blockstream.com> wrote:
>
> > Bear in mind that when people are talking about enabling covenants, we are talking about whether OP_CAT should be allowed or not.
> >
> > That said, recursive covenants, the type that are most worrying, seems to require some kind of OP_TWEAK operation, and I haven't yet seen any evidence that this can be simulated with CHECKSIG(FROMSTACK).? So maybe we should leave such worries for the OP_TWEAK operation.
>
> Upon further thought, you can probably make recursive covenants even with a fixed scritpubkey by sneaking the state into a few bits of the UTXO's amount.? Or if you try really hard, you may be able to stash your state into a sibling output that is accessed via the txid embedded in the prevoutpoint.

Which is kind of the point of avoiding giving too much power, because people can be very clever and start doing unexpected things from what you think is already a limited subset.
"Give an inch and they will take a mile".

Still, as pointed out, altcoins already exist and are substantially worse, and altcoin implementations are all going to run on Turing machines anyway (which are powerful enough to offer Turing-machine functionality), so maybe this is not really giving too much power, people can already fork Bitcoin and add full EVM support on it.

Regards,
ZmnSCPxj


From aj at erisian.com.au  Mon Jul  5 05:04:21 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 5 Jul 2021 15:04:21 +1000
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
Message-ID: <20210705050421.GA31145@erisian.com.au>

On Sun, Jul 04, 2021 at 09:02:25PM -0400, Russell O'Connor via bitcoin-dev wrote:
> Bear in mind that when people are talking about enabling covenants, we are
> talking about whether OP_CAT should be allowed or not.

In some sense multisig *alone* enables recursive covenants: a government
that wants to enforce KYC can require that funds be deposited into
a multisig of "2 <recipient> <gov_key> 2 CHECKMULTISIG", and that
"recipient" has gone through KYC. Once deposited to such an address,
the gov can refus to sign with gov_key unless the funds are being spent
to a new address that follows the same rules.

(That's also more efficient than an explicit covenant since it's all
off-chain -- recipient/gov_key can jointly sign via taproot/MuSig at
that point, so that full nodes are only validating a single pubkey and
signature per spend, rather than having to do analysis of whatever the
underlying covenant is supposed to be [0])

This is essentially what Liquid already does -- it locks bitcoins into
a multisig and enforces an "off-chain" covenant that those bitcoins can
only be redeemed after some valid set of signatures are entered into
the Liquid blockchain. Likewise for the various BTC-on-Ethereum tokens.
To some extent, likewise for coins held in exchanges/custodial wallets
where funds can be transferred between customers off-chain.

You can "escape" from that recursive covenant by having the government
(or Liquid functionaries, or exchange admins) change their signing
policy of course; but you could equally escape any consensus-enforced
covenant by having a hard fork to stop doing consensus-enforcement (cf
ETH Classic?). To me, that looks more like a difference of procedure
and difficulty, rather than a fundamental difference in kind.

Cheers,
aj

[0] https://twitter.com/pwuille/status/1411533549224693762


From lf-lists at mattcorallo.com  Mon Jul  5 13:46:21 2021
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Mon, 5 Jul 2021 09:46:21 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <20210705050421.GA31145@erisian.com.au>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
 <20210705050421.GA31145@erisian.com.au>
Message-ID: <5e694d37-ac49-3c24-26ee-ed2a5580d76d@mattcorallo.com>

I find this point to be incredibly important. Indeed I, like several others, have historically been concerned with 
covenants in the unbounded form. However, as more and more research has been done in what they can accomplish, the 
weighting of such arguments naturally has to be reduced. More importantly, AJ's point here neuters anti-covanent 
arguments rather strongly.

Matt

On 7/5/21 01:04, Anthony Towns via bitcoin-dev wrote:
> On Sun, Jul 04, 2021 at 09:02:25PM -0400, Russell O'Connor via bitcoin-dev wrote:
>> Bear in mind that when people are talking about enabling covenants, we are
>> talking about whether OP_CAT should be allowed or not.
> 
> In some sense multisig *alone* enables recursive covenants: a government
> that wants to enforce KYC can require that funds be deposited into
> a multisig of "2 <recipient> <gov_key> 2 CHECKMULTISIG", and that
> "recipient" has gone through KYC. Once deposited to such an address,
> the gov can refus to sign with gov_key unless the funds are being spent
> to a new address that follows the same rules.
> 
> (That's also more efficient than an explicit covenant since it's all
> off-chain -- recipient/gov_key can jointly sign via taproot/MuSig at
> that point, so that full nodes are only validating a single pubkey and
> signature per spend, rather than having to do analysis of whatever the
> underlying covenant is supposed to be [0])
> 
> This is essentially what Liquid already does -- it locks bitcoins into
> a multisig and enforces an "off-chain" covenant that those bitcoins can
> only be redeemed after some valid set of signatures are entered into
> the Liquid blockchain. Likewise for the various BTC-on-Ethereum tokens.
> To some extent, likewise for coins held in exchanges/custodial wallets
> where funds can be transferred between customers off-chain.
> 
> You can "escape" from that recursive covenant by having the government
> (or Liquid functionaries, or exchange admins) change their signing
> policy of course; but you could equally escape any consensus-enforced
> covenant by having a hard fork to stop doing consensus-enforcement (cf
> ETH Classic?). To me, that looks more like a difference of procedure
> and difficulty, rather than a fundamental difference in kind.
> 
> Cheers,
> aj
> 
> [0] https://twitter.com/pwuille/status/1411533549224693762
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From gsanders87 at gmail.com  Mon Jul  5 13:51:25 2021
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 5 Jul 2021 21:51:25 +0800
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <5e694d37-ac49-3c24-26ee-ed2a5580d76d@mattcorallo.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnVLRLgL1rcq8DYHRjM--8VEUC5kjUbzbY5S860QSbk5w@mail.gmail.com>
 <20210705050421.GA31145@erisian.com.au>
 <5e694d37-ac49-3c24-26ee-ed2a5580d76d@mattcorallo.com>
Message-ID: <CAB3F3DuSP5DUj5wLyP1_EC7hnv=THOYxRy0T9iK-FZzJKMJJhA@mail.gmail.com>

Funny AJ mentions the multisig idea, because I know for a fact it's being
used in certain permissioned systems in this exact way. Regulators will
dream up these ideas with or without more useful covenants!

On Mon, Jul 5, 2021 at 9:46 PM Matt Corallo via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I find this point to be incredibly important. Indeed I, like several
> others, have historically been concerned with
> covenants in the unbounded form. However, as more and more research has
> been done in what they can accomplish, the
> weighting of such arguments naturally has to be reduced. More importantly,
> AJ's point here neuters anti-covanent
> arguments rather strongly.
>
> Matt
>
> On 7/5/21 01:04, Anthony Towns via bitcoin-dev wrote:
> > On Sun, Jul 04, 2021 at 09:02:25PM -0400, Russell O'Connor via
> bitcoin-dev wrote:
> >> Bear in mind that when people are talking about enabling covenants, we
> are
> >> talking about whether OP_CAT should be allowed or not.
> >
> > In some sense multisig *alone* enables recursive covenants: a government
> > that wants to enforce KYC can require that funds be deposited into
> > a multisig of "2 <recipient> <gov_key> 2 CHECKMULTISIG", and that
> > "recipient" has gone through KYC. Once deposited to such an address,
> > the gov can refus to sign with gov_key unless the funds are being spent
> > to a new address that follows the same rules.
> >
> > (That's also more efficient than an explicit covenant since it's all
> > off-chain -- recipient/gov_key can jointly sign via taproot/MuSig at
> > that point, so that full nodes are only validating a single pubkey and
> > signature per spend, rather than having to do analysis of whatever the
> > underlying covenant is supposed to be [0])
> >
> > This is essentially what Liquid already does -- it locks bitcoins into
> > a multisig and enforces an "off-chain" covenant that those bitcoins can
> > only be redeemed after some valid set of signatures are entered into
> > the Liquid blockchain. Likewise for the various BTC-on-Ethereum tokens.
> > To some extent, likewise for coins held in exchanges/custodial wallets
> > where funds can be transferred between customers off-chain.
> >
> > You can "escape" from that recursive covenant by having the government
> > (or Liquid functionaries, or exchange admins) change their signing
> > policy of course; but you could equally escape any consensus-enforced
> > covenant by having a hard fork to stop doing consensus-enforcement (cf
> > ETH Classic?). To me, that looks more like a difference of procedure
> > and difficulty, rather than a fundamental difference in kind.
> >
> > Cheers,
> > aj
> >
> > [0] https://twitter.com/pwuille/status/1411533549224693762
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/091783a4/attachment.html>

From dscotese at litmocracy.com  Mon Jul  5 16:39:40 2021
From: dscotese at litmocracy.com (Dave Scotese)
Date: Mon, 5 Jul 2021 09:39:40 -0700
Subject: [bitcoin-dev] Fee estimation requirements
Message-ID: <CAGLBAhd+s9SurpSK+DAFv9t46hRtF7CEQr_XMO7L_aia95c9+Q@mail.gmail.com>

At https://github.com/bitcoin/bitcoin/issues/22404#issuecomment-874168305
no explanation is given for a peculiar rule about estimating fees, that "you
have to wait around for a couple of blocks *after* being synced before fee
estimation will work."  The rule is true, but it needn't be true, and the
software would be more useful if it were not true.  If it does seem
impossible to break this rule, perhaps some brainstorming is in order.  I
estimate fees quite often on my own, although I am trusting the block
explorers in their reporting of the fees for the most recent blocks.  The
software doesn't need to trust anything once it has been synced.

If this is simply a matter of priorities, it would be useful to point that
out.

Dave.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/cd63d653/attachment.html>

From roconnor at blockstream.com  Mon Jul  5 17:20:22 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Mon, 5 Jul 2021 13:20:22 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
Message-ID: <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>

Hi ZmnSCPxj,

I don't believe we need to ban Turing completeness for the sake of banning
Turing completeness.  My concerns have always been around ensuring that
transaction and block validation is not unduly burdensome for nodes.  So
for Bitcoin Script, we want to bound the amount of resources needed to
execute it, preferably as a linear function of weight[1], and preferably
have it clear what the evaluation costs are going to be prior to
evaluation[2].  We also want to keep Script execution as a pure function of
the transaction data so that nodes do not need to reevaluate their mempool
on every new block.  For consensus purposes we prefer to have simple
primitive operations that have clear and precise semantics that are as
likely as possible to be reimplemented correctly if they are reimplemented
(or at least let us not make this problem worse than it already is).  In
particular, Script needs to be easy to parse to avoid weird parsing
machines that lead to security vulnerabilities within node software.

While the above design constraints imply a prohibition on Turing complete
computation within a single Script, they do not imply a prohibition on
arbitrary, covenant-enabled computations that spans across multiple
transactions.  Neither would these constraints prohibit some kind of STARK
or SNARK tapleaf version that was somehow capable of succinctly
representing arbitrary computations, so long as validation costs remain
bounded.

And while it is true that covenant-enabled computations could allow users
to put their funds at risk through weird machines that manipulate their
money on the blockchain, as longs as that weirdness stays at that level of
the abstract Bitcoin Script machine, then I suppose it is *caveat emptor*;
don't send your funds to random unverified Bitcoin Scripts, advice that is
already the case today.  We can keep that potential weirdness at bay by
keeping Script simple, and maintaining our understanding that the Script
programs (like the rest of the blockchain data) are untrusted inputs and
they need to be validated and scrutinized before interpretation.

[1] In tapscript I believe all operations are linear time with the
exception of OP_ROLL.  However OP_ROLL is still constrained by global
limits on stack size, etc.
[2] In Bitcoin Script, without loops of any kind, every opcode is evaluated
at most once, so counting opcodes is an easy way to put an upper bound on
your costs before evaluation.

On Sun, Jul 4, 2021 at 8:51 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Dave,
>
> > On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
> >
> > > However, I think the broader community is unconvinced by the cost
> benefit
> > > of arbitrary covenants. See
> > >
> https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
> > > as a recent example. Therefore as a critical part of building
> consensus on
> > > various techniques I've worked to emphasize that specific additions do
> not
> > > entail risk of accidentally introducing more than was bargained for to
> > > respect the concerns of others.
> >
> > Respecting the concerns of others doesn't require lobotomizing useful
> > tools. Being respectful can also be accomplished by politely showing
> > that their concerns are unfounded (or at least less severe than they
> > thought). This is almost always the better course IMO---it takes much
> > more effort to satisfy additional engineering constraints (and prove to
> > reviewers that you've done so!) than it does to simply discuss those
> > concerns with reasonable stakeholders. As a demonstration, let's look
> > at the concerns from Shinobi's post linked above:
> >
> > They seem to be worried that some Bitcoin users will choose to accept
> > coins that can't subsequently be fungibily mixed with other bitcoins.
> > But that's already been the case for a decade: users can accept altcoins
> > that are non-fungible with bitcoins.
> >
> > They talk about covenants where spending is controlled by governments,
> > but that seems to me exactly like China's CBDC trial.
> >
> > They talk about exchanges depositing users' BTC into a covenant, but
> > that's just a variation on the classic not-your-keys-not-your-bitcoins
> > problem. For all you know, your local exchange is keeping most of its
> > BTC balance commitments in ETH or USDT.
> >
> > To me, it seems like the worst-case problems Shinobi describes with
> > covenants are some of the same problems that already exist with
> > altcoins. I don't see how recursive covenants could make any of those
> > problems worse, and so I don't see any point in limiting Bitcoin's
> > flexibility to avoid those problems when there are so many interesting
> > and useful things that unlimited covenants could do.
>
> The "altcoins are even worse" argument does seem quite convincing, and if
> Bitcoin can survive altcoins, surely it can survive covenants too?
>
> In before "turns out covenants are the next ICO".
> i.e. ICOs are just colored coins, which are useful for keeping track of
> various stuff, but have then been used as a vehicle to scam people.
> But I suppose that is a problem that humans will always have: limited
> cognition, so that *good* popular things that are outside your specific
> field of study are indistinguishable from *bad* popular things.
> So perhaps it should not be a concern on a technical level.
> Maybe we should instead make articles about covenants so boring nobody
> will hype about it (^^;)v.
>
> Increased functionality implies increased processing, and hopefully
> computation devices are getting cheap enough that the increased processing
> implied by new features should not be too onerous.
>
>
>
> To my mind, an "inescapable" covenant (i.e. one that requires the output
> to be paid to the same covenant) is basically a Turing machine, and
> equivalent to a `while (true);` loop.
> In a `while (true);` loop, the state of the machine reverts back to the
> same state, and it repeats again.
> In an inescpable covenant, the control of some amount of funds reverts
> back to the same controlling SCRIPT, and it repeats again.
> Yes, you can certainly add more functionality on top of that loop, just
> think of program main loops for games or daemons, which are, in essence,
> "just" `while (true) ...`.
> But basically, such unbounded infinite loops are possible only under
> Turing machines, thus I consider covenants to be Turing-complete.
> Principle of Least Power should make us wonder if we need full Turing
> machines for the functionality.
>
> On the other hand --- codata processing *does* allow for unbounded loops,
> without requiring full Turing-completeness; they just require total
> functionality, not partial (and Turing-completeness is partial, not total).
> Basically, data structures are unbounded storage, while codata structures
> are unbounded processing.
> Perhaps covenants can encode an upper bound on the number of recursions,
> which prevents full Turing-completeness while allowing for a large number
> of use-cases.
>
> (if the above paragraph makes no sense to you, hopefully this Wikipedia
> article will help:
> https://en.wikipedia.org/wiki/Total_functional_programming )
> (basically my argument here is based on academic programming stuff, and
> might not actually matter in real life)
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/67abbcb9/attachment-0001.html>

From billy.tetrud at gmail.com  Mon Jul  5 18:24:36 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 5 Jul 2021 11:24:36 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
Message-ID: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>

I had the idea recently for proof of reserves
<https://niccarter.info/proof-of-reserves/> done in a way that can be used
to verify reserves are sufficient on an ongoing basis. I'm curious if there
are any current approaches out there to proof of reserves that are similar.

The idea is to have users create actual private keys using a seed in pretty
much the normal way. Users would generate a public key from this seed to
represent their account, and would give the public key to the custodian to
represent their account in a public record of account balances.

When a user's account is credited, the custodian would update a map of
addresses (created from the public key of each account) to balances - this
map could be structured into a merkle tree in the usual "merkle approach".
The custodian would also store funds on one or more HD wallets (each with
many addresses) and create a proof that they own each HD wallet. The proof
could be as simple as a single signature created with the xpub for the
wallet, which would be sufficient for proving ownership over the whole
list/tree of addresses.

These two structures (the map and the HD wallet) would be combined and
hashed, and the hash published in an on chain transaction (possibly along
with a URI where the full data can be found), on something like a daily
basis. Software for each user could continuously validate that their
account has a balance that matches what it's supposed to have, and could
also verify that owned addresses have funds that have at least as many
coins as promised to accounts. If these things aren't verifiable (either
because the balances total to more than the HD wallet contains, or because
of data unavailability), people can raise hell about it.

To give user's additional proving ability, a receipt system could be added.
Users could request a receipt for any balance update. Eg the user would
create a message with a timestamp, their custodial "address", and the new
balance. The user would sign this receipt and send it to the custodian, who
would also sign it and send it back. This way, if something goes wrong, a
user can use this signed receipt to show that the custodian did in fact
promise a new updated balance at a particular time (which would cover the
case that the custodian records the wrong value in their map). Conversely,
the receipt would be useful to honest custodians as well, since they could
show the user's signed receipt request in the case a user is trying to lie
about what balance they should have. There is still the case that the
custodian simply refuses to return a signed receipt, in which case the
user's only recourse is to yell about it immediately and demand a receipt
or a refund.

Why record it on chain? Doing that gives a clear record of proof of
reserves that can be verified later by anyone in the future. It prevents a
custodian from being able to change history when it suits them (by creating
a new records with false timestamps in the past). Many of these records
could be aggregated together and recorded in the same transaction (with a
single hash), so a single transaction per day could record the records of
all participating custodians. If all custodians are using a standard
system, one can cross verify that addresses claimed by one custodian aren't
also claimed by another custodian.

Even tho the user is responsible for their keys in order to properly
verify, losing the keys isn't that big of a deal, since they could simply
create a new seed and give a new public key to the custodian - who would
have other identifying information they could use to validate that they own
the account. So it places less responsibility on the user, while still
introducing people, in a light-weight way, to self custody of keys.

Having a record like this every day would reduce the possibility of
shenanigans like taking a short term loan of a large amount of
cryptocurrency. Sure, they could take a 10 minute loan once per day, but it
would also be possible to trace on-chain transactions so you could tell if
such a thing was going on. I wonder if there would be some way to include
the ability to prove balances held on the lightning network, but I suspect
that isn't generally possible.

In any case, I'm curious what people think of this kind of thing, and if
systems with similar properties are already out there.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/fc1967cb/attachment.html>

From ZmnSCPxj at protonmail.com  Mon Jul  5 23:26:23 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 05 Jul 2021 23:26:23 +0000
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>
References: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>
Message-ID: <cLK-RFlIdmwOvuKag-cOImIVCltq97EWfT-mFpPFa5wJfbAgptlKFhmgt4WQNw2pYVt-sGCCCTtHi1s0Vdwwimun_fUdvrDeOOPnlFjYDdA=@protonmail.com>

Good morning Billy,

> I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible.?

Thinking about this in terms of economic logic:

Every channel is anchored onchain, and that anchor (the funding txout) is proof of the existence, and size, of the channel.

The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns.
One of the participants should provably be the custodian.

* If the counterparty is a true third party, it has no incentive to lie about its money.
  * Especially if the counterparty is *another* custodian who wants proof-of-reserves, it has every incentive to overreport, but then the first party will refuse to sign.
    It has a disincentive to underreport, and would itself refuse to sign a dishonest report that assigns more funds to the first party.
    The only case that would be acceptable to both custodians would be to honestly report their holdings in the Lightning channel.
* If the counterparty is a sockpuppet of the custodian, then the entire channel is owned by the custodian and it would be fairly dumb of he custodian to claim to have less funds than the entire channel.

Perhaps a more practical problem is that Lightning channel states change fairly quickly, and there are possible race conditions, due to network latency (remember, both nodes need to sign, meaning both of them need to communicate with each other, thus hit by network latency and other race conditions) where a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of *all* channels.

Regards,
ZmnSCPxj

From eric at voskuil.org  Mon Jul  5 23:32:04 2021
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 5 Jul 2021 16:32:04 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <cLK-RFlIdmwOvuKag-cOImIVCltq97EWfT-mFpPFa5wJfbAgptlKFhmgt4WQNw2pYVt-sGCCCTtHi1s0Vdwwimun_fUdvrDeOOPnlFjYDdA=@protonmail.com>
References: <cLK-RFlIdmwOvuKag-cOImIVCltq97EWfT-mFpPFa5wJfbAgptlKFhmgt4WQNw2pYVt-sGCCCTtHi1s0Vdwwimun_fUdvrDeOOPnlFjYDdA=@protonmail.com>
Message-ID: <F79C4763-619D-42B9-92C8-555AC128832E@voskuil.org>

If only one could prove that he won?t get into a boating accident.

e

> On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?Good morning Billy,
> 
>> I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible. 
> 
> Thinking about this in terms of economic logic:
> 
> Every channel is anchored onchain, and that anchor (the funding txout) is proof of the existence, and size, of the channel.
> 
> The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns.
> One of the participants should provably be the custodian.
> 
> * If the counterparty is a true third party, it has no incentive to lie about its money.
>  * Especially if the counterparty is *another* custodian who wants proof-of-reserves, it has every incentive to overreport, but then the first party will refuse to sign.
>    It has a disincentive to underreport, and would itself refuse to sign a dishonest report that assigns more funds to the first party.
>    The only case that would be acceptable to both custodians would be to honestly report their holdings in the Lightning channel.
> * If the counterparty is a sockpuppet of the custodian, then the entire channel is owned by the custodian and it would be fairly dumb of he custodian to claim to have less funds than the entire channel.
> 
> Perhaps a more practical problem is that Lightning channel states change fairly quickly, and there are possible race conditions, due to network latency (remember, both nodes need to sign, meaning both of them need to communicate with each other, thus hit by network latency and other race conditions) where a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of *all* channels.
> 
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Tue Jul  6 00:09:25 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 06 Jul 2021 00:09:25 +0000
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <F79C4763-619D-42B9-92C8-555AC128832E@voskuil.org>
References: <cLK-RFlIdmwOvuKag-cOImIVCltq97EWfT-mFpPFa5wJfbAgptlKFhmgt4WQNw2pYVt-sGCCCTtHi1s0Vdwwimun_fUdvrDeOOPnlFjYDdA=@protonmail.com>
 <F79C4763-619D-42B9-92C8-555AC128832E@voskuil.org>
Message-ID: <5EIOo5CwOeMAVo59ES88McUhlBpvJaRgsFKiyaASICQLHhfMC5Q-ALBKeeB77O3NVEQL11UE4WkNhfuTF23uFHYDv7iYzmiOU0RFjqSUUQA=@protonmail.com>

Good morning e,


> If only one could prove that he won?t get into a boating accident.

At least in the context of Lightning channels, if one party in the channel loses its key in a boating accident, the other party (assuming it is a true separate person and not a sockpuppet) has every incentive to unilaterally close the channel, which reveals the exact amounts (though not necessarily who owns which).
If the other party then uses its funds in a new proof-of-reserves, then obviously the other output of the unilateral close was the one lost in the boating accident.

On the other hand, yes, custodians losing custodied funds in boating accidents is much too common.
I believe it is one reason why custodian proof-of-reserves is not that popular --- it only proves that the funds were owned under a particular key at some snapshot of the past, it does not prove that the key will not get lost (or "lost and then salvaged by a scuba diver") later.


Regards,
ZmnSCPxj

>
> e
>
> > On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> > Good morning Billy,
> >
> > > I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible.
> >
> > Thinking about this in terms of economic logic:
> > Every channel is anchored onchain, and that anchor (the funding txout) is proof of the existence, and size, of the channel.
> > The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns.
> > One of the participants should provably be the custodian.
> >
> > -   If the counterparty is a true third party, it has no incentive to lie about its money.
> > -   Especially if the counterparty is another custodian who wants proof-of-reserves, it has every incentive to overreport, but then the first party will refuse to sign.
> >     It has a disincentive to underreport, and would itself refuse to sign a dishonest report that assigns more funds to the first party.
> >     The only case that would be acceptable to both custodians would be to honestly report their holdings in the Lightning channel.
> >
> > -   If the counterparty is a sockpuppet of the custodian, then the entire channel is owned by the custodian and it would be fairly dumb of he custodian to claim to have less funds than the entire channel.
> >
> > Perhaps a more practical problem is that Lightning channel states change fairly quickly, and there are possible race conditions, due to network latency (remember, both nodes need to sign, meaning both of them need to communicate with each other, thus hit by network latency and other race conditions) where a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of all channels.
> > Regards,
> > ZmnSCPxj
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ZmnSCPxj at protonmail.com  Tue Jul  6 04:54:11 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 06 Jul 2021 04:54:11 +0000
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDZpqhpgrO5BFyoB3w-+_xU6bU=sTA-r--vzY910K5c5aQ@mail.gmail.com>
References: <cLK-RFlIdmwOvuKag-cOImIVCltq97EWfT-mFpPFa5wJfbAgptlKFhmgt4WQNw2pYVt-sGCCCTtHi1s0Vdwwimun_fUdvrDeOOPnlFjYDdA=@protonmail.com>
 <F79C4763-619D-42B9-92C8-555AC128832E@voskuil.org>
 <5EIOo5CwOeMAVo59ES88McUhlBpvJaRgsFKiyaASICQLHhfMC5Q-ALBKeeB77O3NVEQL11UE4WkNhfuTF23uFHYDv7iYzmiOU0RFjqSUUQA=@protonmail.com>
 <CAGpPWDZpqhpgrO5BFyoB3w-+_xU6bU=sTA-r--vzY910K5c5aQ@mail.gmail.com>
Message-ID: <0C9QijB2q6YADZLIDMFtTksQon92ixWlHg5tECfETla5is1GGAX6AktIS-DNthydwtxG0l6Ao99hYlikx-sKSpWxxAMGGmUoUyrn6zDkBrE=@protonmail.com>

Good morning Billy,


>
> >? The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns
>
> Sure, but even if both participants in the channel sign a correct statement of truth, one of the participants can send funds out in the next second, invalidating that truth. While proof of ownership of on-chain UTXOs can be seen publicly in real time if they are spent, LN transactions aren't public like that. So any balance attestation is at best only valid the instant its taken, and can't be used as verification the money is still owned by the same channel partner in the next second.?

The same problem really also exists onchain --- a thief (or "thief") who has gotten a copy of the key can sign a transaction that spends it, one second after the proof-of-reserves is made.

Really, though, the issue is that ownership of funds is conditional on *knowledge* of keys.
And *knowledge* is easily copyable.

Thus, it is possible that the funds that are "proven" to be the reserve of a custodian is actually *also* owned by someone else who has gotten to the privkeys (e.g. somebody threw a copy of it from a boating accident and a fearless scuba diver rescued it), and thus can also move the funds outside of the control of the custodian.
This condition can remain for many months or years, as well, without knowledge of the custodian clients, *or* of the custodian itself.

There is no way to prove that there is no alternate copy of the privkeys, hence "if only one could prove that he won't get into a boating accident".

On the other hand, one could argue that at least the onchain proof requires more conditions to occur, so we might plausibly live with "we cannot prove we will never get into a boating accident but we can show evidence that we live in a landlocked city far from any lakes, seas, or rivers".

Regards,
ZmnSCPxj

>
> >? a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of *all* channels
>
> That would be a neat trick. But yeah, I don't know how that would be possible.?
>
> >? I believe it is one reason why custodian proof-of-reserves is not that popular ... it does not prove that the key will not get lost
>
> True, but at least if funds do get lost, it would be come clear far quicker. Today, an insolvent company could go many months without the public finding out.?
>
> On Mon, Jul 5, 2021 at 5:09 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> > Good morning e,
> >
> > > If only one could prove that he won?t get into a boating accident.
> >
> > At least in the context of Lightning channels, if one party in the channel loses its key in a boating accident, the other party (assuming it is a true separate person and not a sockpuppet) has every incentive to unilaterally close the channel, which reveals the exact amounts (though not necessarily who owns which).
> > If the other party then uses its funds in a new proof-of-reserves, then obviously the other output of the unilateral close was the one lost in the boating accident.
> >
> > On the other hand, yes, custodians losing custodied funds in boating accidents is much too common.
> > I believe it is one reason why custodian proof-of-reserves is not that popular --- it only proves that the funds were owned under a particular key at some snapshot of the past, it does not prove that the key will not get lost (or "lost and then salvaged by a scuba diver") later.
> >
> > Regards,
> > ZmnSCPxj
> >
> > >
> > > e
> > >
> > > > On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
> > > > Good morning Billy,
> > > >
> > > > > I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible.
> > > >
> > > > Thinking about this in terms of economic logic:
> > > > Every channel is anchored onchain, and that anchor (the funding txout) is proof of the existence, and size, of the channel.
> > > > The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns.
> > > > One of the participants should provably be the custodian.
> > > >
> > > > -? ?If the counterparty is a true third party, it has no incentive to lie about its money.
> > > > -? ?Especially if the counterparty is another custodian who wants proof-of-reserves, it has every incentive to overreport, but then the first party will refuse to sign.
> > > >? ? ?It has a disincentive to underreport, and would itself refuse to sign a dishonest report that assigns more funds to the first party.
> > > >? ? ?The only case that would be acceptable to both custodians would be to honestly report their holdings in the Lightning channel.
> > > >
> > > > -? ?If the counterparty is a sockpuppet of the custodian, then the entire channel is owned by the custodian and it would be fairly dumb of he custodian to claim to have less funds than the entire channel.
> > > >
> > > > Perhaps a more practical problem is that Lightning channel states change fairly quickly, and there are possible race conditions, due to network latency (remember, both nodes need to sign, meaning both of them need to communicate with each other, thus hit by network latency and other race conditions) where a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of all channels.
> > > > Regards,
> > > > ZmnSCPxj
> > > >
> > > > bitcoin-dev mailing list
> > > > bitcoin-dev at lists.linuxfoundation.org
> > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From eric at voskuil.org  Tue Jul  6 05:09:59 2021
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 5 Jul 2021 22:09:59 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <0C9QijB2q6YADZLIDMFtTksQon92ixWlHg5tECfETla5is1GGAX6AktIS-DNthydwtxG0l6Ao99hYlikx-sKSpWxxAMGGmUoUyrn6zDkBrE=@protonmail.com>
References: <0C9QijB2q6YADZLIDMFtTksQon92ixWlHg5tECfETla5is1GGAX6AktIS-DNthydwtxG0l6Ao99hYlikx-sKSpWxxAMGGmUoUyrn6zDkBrE=@protonmail.com>
Message-ID: <EC55B6BD-2BDD-4074-A813-459D73D89DB2@voskuil.org>

https://github.com/libbitcoin/libbitcoin-system/wiki/Auditability-Fallacy

> On Jul 5, 2021, at 21:54, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
> 
> ?Good morning Billy,
> 
> 
>> 
>>>   The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns
>> 
>> Sure, but even if both participants in the channel sign a correct statement of truth, one of the participants can send funds out in the next second, invalidating that truth. While proof of ownership of on-chain UTXOs can be seen publicly in real time if they are spent, LN transactions aren't public like that. So any balance attestation is at best only valid the instant its taken, and can't be used as verification the money is still owned by the same channel partner in the next second. 
> 
> The same problem really also exists onchain --- a thief (or "thief") who has gotten a copy of the key can sign a transaction that spends it, one second after the proof-of-reserves is made.
> 
> Really, though, the issue is that ownership of funds is conditional on *knowledge* of keys.
> And *knowledge* is easily copyable.
> 
> Thus, it is possible that the funds that are "proven" to be the reserve of a custodian is actually *also* owned by someone else who has gotten to the privkeys (e.g. somebody threw a copy of it from a boating accident and a fearless scuba diver rescued it), and thus can also move the funds outside of the control of the custodian.
> This condition can remain for many months or years, as well, without knowledge of the custodian clients, *or* of the custodian itself.
> 
> There is no way to prove that there is no alternate copy of the privkeys, hence "if only one could prove that he won't get into a boating accident".
> 
> On the other hand, one could argue that at least the onchain proof requires more conditions to occur, so we might plausibly live with "we cannot prove we will never get into a boating accident but we can show evidence that we live in a landlocked city far from any lakes, seas, or rivers".
> 
> Regards,
> ZmnSCPxj
> 
>> 
>>>   a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of *all* channels
>> 
>> That would be a neat trick. But yeah, I don't know how that would be possible. 
>> 
>>>   I believe it is one reason why custodian proof-of-reserves is not that popular ... it does not prove that the key will not get lost
>> 
>> True, but at least if funds do get lost, it would be come clear far quicker. Today, an insolvent company could go many months without the public finding out. 
>> 
>> On Mon, Jul 5, 2021 at 5:09 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>> 
>>> Good morning e,
>>> 
>>>> If only one could prove that he won?t get into a boating accident.
>>> 
>>> At least in the context of Lightning channels, if one party in the channel loses its key in a boating accident, the other party (assuming it is a true separate person and not a sockpuppet) has every incentive to unilaterally close the channel, which reveals the exact amounts (though not necessarily who owns which).
>>> If the other party then uses its funds in a new proof-of-reserves, then obviously the other output of the unilateral close was the one lost in the boating accident.
>>> 
>>> On the other hand, yes, custodians losing custodied funds in boating accidents is much too common.
>>> I believe it is one reason why custodian proof-of-reserves is not that popular --- it only proves that the funds were owned under a particular key at some snapshot of the past, it does not prove that the key will not get lost (or "lost and then salvaged by a scuba diver") later.
>>> 
>>> Regards,
>>> ZmnSCPxj
>>> 
>>>> 
>>>> e
>>>> 
>>>>> On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>>>>> Good morning Billy,
>>>>> 
>>>>>> I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible.
>>>>> 
>>>>> Thinking about this in terms of economic logic:
>>>>> Every channel is anchored onchain, and that anchor (the funding txout) is proof of the existence, and size, of the channel.
>>>>> The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns.
>>>>> One of the participants should provably be the custodian.
>>>>> 
>>>>> -   If the counterparty is a true third party, it has no incentive to lie about its money.
>>>>> -   Especially if the counterparty is another custodian who wants proof-of-reserves, it has every incentive to overreport, but then the first party will refuse to sign.
>>>>>      It has a disincentive to underreport, and would itself refuse to sign a dishonest report that assigns more funds to the first party.
>>>>>      The only case that would be acceptable to both custodians would be to honestly report their holdings in the Lightning channel.
>>>>> 
>>>>> -   If the counterparty is a sockpuppet of the custodian, then the entire channel is owned by the custodian and it would be fairly dumb of he custodian to claim to have less funds than the entire channel.
>>>>> 
>>>>> Perhaps a more practical problem is that Lightning channel states change fairly quickly, and there are possible race conditions, due to network latency (remember, both nodes need to sign, meaning both of them need to communicate with each other, thus hit by network latency and other race conditions) where a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of all channels.
>>>>> Regards,
>>>>> ZmnSCPxj
>>>>> 
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/60070878/attachment-0001.html>

From eric at voskuil.org  Tue Jul  6 07:37:07 2021
From: eric at voskuil.org (Eric Voskuil)
Date: Tue, 6 Jul 2021 00:37:07 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDaSVFAqvmfCugLCE2X2fSz0dRos76FejFutA1=dF+R2zw@mail.gmail.com>
References: <CAGpPWDaSVFAqvmfCugLCE2X2fSz0dRos76FejFutA1=dF+R2zw@mail.gmail.com>
Message-ID: <F66EEF92-AAA3-4BBB-B6E2-30D3A2939D17@voskuil.org>



> @Eric
> Auditability Fallacy
> 
> > A solvency audit requires simultaneous (atomic) proof of both the full amount of the asset held by a custodian and the securities issued against it.
> 
> > in the case where the security is issued on a distinct public chain the atomicity requirement is not satisfied.
> 
> I think what its saying is that you can't get atomicity of both the security and the reserve. While this is true, what you can get is a system where the order of events can be established to a degree of precision. Ie, you can know that between reserve-snapshot A and B, the balances add up to X. Each user can validate that their balance was indeed that value between A and B. With reserve snapshots and balance snapshots frequent enough, this can allow reasonably high accuracy of estimated solvency. However, it does seem clear that perfect accuracy is not possible.

If perfect is not possible, it?s not possible. It reduces to trust, which is the status quo.

All ?users? need to simultaneously share their individual and temporary audits with each other (ie publicly).

> > Historically it has not been difficult to detect such deviations. The difficulty arises in stopping them.
> 
> I disagree here that it has not been difficult to detect deviations (insolvency).

It is not hard to spot price inflation. Stopping or avoiding it is the actual issue. No ?proof? of reserve can do this. The federal reserve was clearly insolvent from its early days, as that was its purpose.

> I mean, "difficulty" isn't the right word. These things always become clear eventually. But I think its important to detect insolvency quickly. Historically insolvency has certainly not been detected quickly. Insolvency is instead practically perpetual, and the question is only how insolvent and when will it explode?

There is no ?proof? that answers this question.

> I'm of the opinion that you can't prevent insolvency.

It?s not a matter of opinion. Lending implies risk. When you invest you are in fact the owner of the insolvency, not someone else.

> Places will have money troubles and will try to cover it up, since usually there is no downside (admitting insolvency can lead to bankrupcy, and failure to conceal insolvency has the same result - so why not try to conceal it and hope you can shore it up). However, its important that people know the institutions they have their money in are insolvent, or to what degree they are. If that information were well tracked, it could become clear over time that a 10% insolvent company rarely goes out of business, but a 20% insolvent company usually does.

Nonsense, any business can fail, regardless of temporal cash reserves.

> Then people can have parameters where they're ok with a certain measurable degree of insolvency, but react swiftly and strongly when a company is too reckless. Currently the amount of recklessness any given company engages in is basically a company secret that their clients don't have insight into. PoR would greatly help this I think. You don't think so? 

Reckless is a subjective term. Proofs will not insure any investment.

e

>> On Mon, Jul 5, 2021 at 10:10 PM Eric Voskuil <eric at voskuil.org> wrote:
>> https://github.com/libbitcoin/libbitcoin-system/wiki/Auditability-Fallacy
>> 
>>>> On Jul 5, 2021, at 21:54, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>>>> 
>>> ?Good morning Billy,
>>> 
>>> 
>>>> 
>>>>>   The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns
>>>> 
>>>> Sure, but even if both participants in the channel sign a correct statement of truth, one of the participants can send funds out in the next second, invalidating that truth. While proof of ownership of on-chain UTXOs can be seen publicly in real time if they are spent, LN transactions aren't public like that. So any balance attestation is at best only valid the instant its taken, and can't be used as verification the money is still owned by the same channel partner in the next second. 
>>> 
>>> The same problem really also exists onchain --- a thief (or "thief") who has gotten a copy of the key can sign a transaction that spends it, one second after the proof-of-reserves is made.
>>> 
>>> Really, though, the issue is that ownership of funds is conditional on *knowledge* of keys.
>>> And *knowledge* is easily copyable.
>>> 
>>> Thus, it is possible that the funds that are "proven" to be the reserve of a custodian is actually *also* owned by someone else who has gotten to the privkeys (e.g. somebody threw a copy of it from a boating accident and a fearless scuba diver rescued it), and thus can also move the funds outside of the control of the custodian.
>>> This condition can remain for many months or years, as well, without knowledge of the custodian clients, *or* of the custodian itself.
>>> 
>>> There is no way to prove that there is no alternate copy of the privkeys, hence "if only one could prove that he won't get into a boating accident".
>>> 
>>> On the other hand, one could argue that at least the onchain proof requires more conditions to occur, so we might plausibly live with "we cannot prove we will never get into a boating accident but we can show evidence that we live in a landlocked city far from any lakes, seas, or rivers".
>>> 
>>> Regards,
>>> ZmnSCPxj
>>> 
>>>> 
>>>>>   a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of *all* channels
>>>> 
>>>> That would be a neat trick. But yeah, I don't know how that would be possible. 
>>>> 
>>>>>   I believe it is one reason why custodian proof-of-reserves is not that popular ... it does not prove that the key will not get lost
>>>> 
>>>> True, but at least if funds do get lost, it would be come clear far quicker. Today, an insolvent company could go many months without the public finding out. 
>>>> 
>>>>> On Mon, Jul 5, 2021 at 5:09 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>>>>> 
>>>>> Good morning e,
>>>>> 
>>>>>> If only one could prove that he won?t get into a boating accident.
>>>>> 
>>>>> At least in the context of Lightning channels, if one party in the channel loses its key in a boating accident, the other party (assuming it is a true separate person and not a sockpuppet) has every incentive to unilaterally close the channel, which reveals the exact amounts (though not necessarily who owns which).
>>>>> If the other party then uses its funds in a new proof-of-reserves, then obviously the other output of the unilateral close was the one lost in the boating accident.
>>>>> 
>>>>> On the other hand, yes, custodians losing custodied funds in boating accidents is much too common.
>>>>> I believe it is one reason why custodian proof-of-reserves is not that popular --- it only proves that the funds were owned under a particular key at some snapshot of the past, it does not prove that the key will not get lost (or "lost and then salvaged by a scuba diver") later.
>>>>> 
>>>>> Regards,
>>>>> ZmnSCPxj
>>>>> 
>>>>>> 
>>>>>> e
>>>>>> 
>>>>>>> On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>>>>>>> Good morning Billy,
>>>>>>> 
>>>>>>>> I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible.
>>>>>>> 
>>>>>>> Thinking about this in terms of economic logic:
>>>>>>> Every channel is anchored onchain, and that anchor (the funding txout) is proof of the existence, and size, of the channel.
>>>>>>> The two participants in the channel can sign a plaintext containing their node pubkeys and how much each owns.
>>>>>>> One of the participants should provably be the custodian.
>>>>>>> 
>>>>>>> -   If the counterparty is a true third party, it has no incentive to lie about its money.
>>>>>>> -   Especially if the counterparty is another custodian who wants proof-of-reserves, it has every incentive to overreport, but then the first party will refuse to sign.
>>>>>>>      It has a disincentive to underreport, and would itself refuse to sign a dishonest report that assigns more funds to the first party.
>>>>>>>      The only case that would be acceptable to both custodians would be to honestly report their holdings in the Lightning channel.
>>>>>>> 
>>>>>>> -   If the counterparty is a sockpuppet of the custodian, then the entire channel is owned by the custodian and it would be fairly dumb of he custodian to claim to have less funds than the entire channel.
>>>>>>> 
>>>>>>> Perhaps a more practical problem is that Lightning channel states change fairly quickly, and there are possible race conditions, due to network latency (remember, both nodes need to sign, meaning both of them need to communicate with each other, thus hit by network latency and other race conditions) where a custodian Lightning node is unable to "freeze" a snapshot of its current state and make an atomic proof-of-reserves of all channels.
>>>>>>> Regards,
>>>>>>> ZmnSCPxj
>>>>>>> 
>>>>>>> bitcoin-dev mailing list
>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> 
>>> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/fdd3ae32/attachment-0001.html>

From billy.tetrud at gmail.com  Tue Jul  6 01:34:53 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 5 Jul 2021 18:34:53 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <5EIOo5CwOeMAVo59ES88McUhlBpvJaRgsFKiyaASICQLHhfMC5Q-ALBKeeB77O3NVEQL11UE4WkNhfuTF23uFHYDv7iYzmiOU0RFjqSUUQA=@protonmail.com>
References: <cLK-RFlIdmwOvuKag-cOImIVCltq97EWfT-mFpPFa5wJfbAgptlKFhmgt4WQNw2pYVt-sGCCCTtHi1s0Vdwwimun_fUdvrDeOOPnlFjYDdA=@protonmail.com>
 <F79C4763-619D-42B9-92C8-555AC128832E@voskuil.org>
 <5EIOo5CwOeMAVo59ES88McUhlBpvJaRgsFKiyaASICQLHhfMC5Q-ALBKeeB77O3NVEQL11UE4WkNhfuTF23uFHYDv7iYzmiOU0RFjqSUUQA=@protonmail.com>
Message-ID: <CAGpPWDZpqhpgrO5BFyoB3w-+_xU6bU=sTA-r--vzY910K5c5aQ@mail.gmail.com>

@ ZmnSCPxj, Good Evening

>  The two participants in the channel can sign a plaintext containing
their node pubkeys and how much each owns

Sure, but even if both participants in the channel sign a correct statement
of truth, one of the participants can send funds out in the next second,
invalidating that truth. While proof of ownership of on-chain UTXOs can be
seen publicly in real time if they are spent, LN transactions aren't public
like that. So any balance attestation is at best only valid the instant its
taken, and can't be used as verification the money is still owned by the
same channel partner in the next second.

>  a custodian Lightning node is unable to "freeze" a snapshot of its
current state and make an atomic proof-of-reserves of *all* channels

That would be a neat trick. But yeah, I don't know how that would be
possible.

>  I believe it is one reason why custodian proof-of-reserves is not that
popular ... it does not prove that the key will not get lost

True, but at least if funds do get lost, it would be come clear far
quicker. Today, an insolvent company could go many months without the
public finding out.

On Mon, Jul 5, 2021 at 5:09 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning e,
>
>
> > If only one could prove that he won?t get into a boating accident.
>
> At least in the context of Lightning channels, if one party in the channel
> loses its key in a boating accident, the other party (assuming it is a true
> separate person and not a sockpuppet) has every incentive to unilaterally
> close the channel, which reveals the exact amounts (though not necessarily
> who owns which).
> If the other party then uses its funds in a new proof-of-reserves, then
> obviously the other output of the unilateral close was the one lost in the
> boating accident.
>
> On the other hand, yes, custodians losing custodied funds in boating
> accidents is much too common.
> I believe it is one reason why custodian proof-of-reserves is not that
> popular --- it only proves that the funds were owned under a particular key
> at some snapshot of the past, it does not prove that the key will not get
> lost (or "lost and then salvaged by a scuba diver") later.
>
>
> Regards,
> ZmnSCPxj
>
> >
> > e
> >
> > > On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
> > > Good morning Billy,
> > >
> > > > I wonder if there would be some way to include the ability to prove
> balances held on the lightning network, but I suspect that isn't generally
> possible.
> > >
> > > Thinking about this in terms of economic logic:
> > > Every channel is anchored onchain, and that anchor (the funding txout)
> is proof of the existence, and size, of the channel.
> > > The two participants in the channel can sign a plaintext containing
> their node pubkeys and how much each owns.
> > > One of the participants should provably be the custodian.
> > >
> > > -   If the counterparty is a true third party, it has no incentive to
> lie about its money.
> > > -   Especially if the counterparty is another custodian who wants
> proof-of-reserves, it has every incentive to overreport, but then the first
> party will refuse to sign.
> > >     It has a disincentive to underreport, and would itself refuse to
> sign a dishonest report that assigns more funds to the first party.
> > >     The only case that would be acceptable to both custodians would be
> to honestly report their holdings in the Lightning channel.
> > >
> > > -   If the counterparty is a sockpuppet of the custodian, then the
> entire channel is owned by the custodian and it would be fairly dumb of he
> custodian to claim to have less funds than the entire channel.
> > >
> > > Perhaps a more practical problem is that Lightning channel states
> change fairly quickly, and there are possible race conditions, due to
> network latency (remember, both nodes need to sign, meaning both of them
> need to communicate with each other, thus hit by network latency and other
> race conditions) where a custodian Lightning node is unable to "freeze" a
> snapshot of its current state and make an atomic proof-of-reserves of all
> channels.
> > > Regards,
> > > ZmnSCPxj
> > >
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/8f6b1e68/attachment-0001.html>

From billy.tetrud at gmail.com  Tue Jul  6 06:02:45 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 5 Jul 2021 23:02:45 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <EC55B6BD-2BDD-4074-A813-459D73D89DB2@voskuil.org>
References: <0C9QijB2q6YADZLIDMFtTksQon92ixWlHg5tECfETla5is1GGAX6AktIS-DNthydwtxG0l6Ao99hYlikx-sKSpWxxAMGGmUoUyrn6zDkBrE=@protonmail.com>
 <EC55B6BD-2BDD-4074-A813-459D73D89DB2@voskuil.org>
Message-ID: <CAGpPWDaSVFAqvmfCugLCE2X2fSz0dRos76FejFutA1=dF+R2zw@mail.gmail.com>

@ZmnSCPxj
>  a thief (or "thief") who has gotten a copy of the key can sign a
transaction that spends it, one second after the proof-of-reserves is made.

Sure, but anyone can easily see that transaction happen and can discount
that part of the attestation. The same isn't true on lightning.

> *knowledge* is easily copyable.

Knowledge isn't even really needed. Custodians could collude to sign each
other's balance attestations. However, if the network of proof of reserves
is cohesive, people could validate that addresses (and their balances)
aren't shared by anyone that's part of that PoR network.

> There is no way to prove that there is no alternate copy of the privkeys

Well there are only really 2 cases:

1. Only one entity has the keys
2. Two entities have the keys and trust each other

In case 1, the attestation is accurate. In case 2, its really another way
of saying case 1: you can view the two trusting entities as a single
entity. In the case there are 2 non-trusting entities, its very likely that
one would steal from the other, or that they would be very uncomfortable
with the situation such that it wouldn't last long.

But you can't prove that someone won't steal the reserves. You can't prove
cryptographically that the reserves aren't promised to someone else in a
legal contract (unless of course you make the proof of reserves system
legally binding). But this is why anyone that recommends PoR also
recommends independent audits to attest that the PoR actually matches
reality.

So yes, there are limitations, but I don't think that means that PoR isn't
worth doing. Is that what you're implying?

> we can show evidence that we live in a landlocked city far from any
lakes, seas, or rivers

I think that's the idea, if I understand you correctly.

@Eric
Auditability Fallacy
<https://github.com/libbitcoin/libbitcoin-system/wiki/Auditability-Fallacy>

> A solvency audit requires simultaneous (atomic) proof of both the full
amount of the asset held by a custodian and the securities issued against
it.

> in the case where the security is issued on a distinct public chain the
atomicity requirement is not satisfied.

I think what its saying is that you can't get atomicity of both the
security and the reserve. While this is true, what you can get is a system
where the order of events can be established to a degree of precision. Ie,
you can know that between reserve-snapshot A and B, the balances add up to
X. Each user can validate that their balance was indeed that value between
A and B. With reserve snapshots and balance snapshots frequent enough, this
can allow reasonably high accuracy of estimated solvency. However, it does
seem clear that perfect accuracy is not possible.

> Historically it has not been difficult to detect such deviations. The
difficulty arises in stopping them.

I disagree here that it has not been difficult to detect deviations
(insolvency). I mean, "difficulty" isn't the right word. These things
always become clear eventually. But I think its important to detect
insolvency quickly. Historically insolvency has certainly not been detected
quickly. Insolvency is instead practically perpetual, and the question is
only how insolvent and when will it explode?

I'm of the opinion that you can't prevent insolvency. Places will have
money troubles and will try to cover it up, since usually there is no
downside (admitting insolvency can lead to bankrupcy, and failure to
conceal insolvency has the same result - so why not try to conceal it and
hope you can shore it up). However, its important that people know the
institutions they have their money in are insolvent, or to what degree they
are. If that information were well tracked, it could become clear over time
that a 10% insolvent company rarely goes out of business, but a 20%
insolvent company usually does. Then people can have parameters where
they're ok with a certain measurable degree of insolvency, but react
swiftly and strongly when a company is too reckless. Currently the amount
of recklessness any given company engages in is basically a company secret
that their clients don't have insight into. PoR would greatly help this I
think. You don't think so?

On Mon, Jul 5, 2021 at 10:10 PM Eric Voskuil <eric at voskuil.org> wrote:

> https://github.com/libbitcoin/libbitcoin-system/wiki/Auditability-Fallacy
>
> On Jul 5, 2021, at 21:54, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> ?Good morning Billy,
>
>
>
>   The two participants in the channel can sign a plaintext containing
> their node pubkeys and how much each owns
>
>
> Sure, but even if both participants in the channel sign a correct
> statement of truth, one of the participants can send funds out in the next
> second, invalidating that truth. While proof of ownership of on-chain UTXOs
> can be seen publicly in real time if they are spent, LN transactions aren't
> public like that. So any balance attestation is at best only valid the
> instant its taken, and can't be used as verification the money is still
> owned by the same channel partner in the next second.
>
>
> The same problem really also exists onchain --- a thief (or "thief") who
> has gotten a copy of the key can sign a transaction that spends it, one
> second after the proof-of-reserves is made.
>
> Really, though, the issue is that ownership of funds is conditional on
> *knowledge* of keys.
> And *knowledge* is easily copyable.
>
> Thus, it is possible that the funds that are "proven" to be the reserve of
> a custodian is actually *also* owned by someone else who has gotten to the
> privkeys (e.g. somebody threw a copy of it from a boating accident and a
> fearless scuba diver rescued it), and thus can also move the funds outside
> of the control of the custodian.
> This condition can remain for many months or years, as well, without
> knowledge of the custodian clients, *or* of the custodian itself.
>
> There is no way to prove that there is no alternate copy of the privkeys,
> hence "if only one could prove that he won't get into a boating accident".
>
> On the other hand, one could argue that at least the onchain proof
> requires more conditions to occur, so we might plausibly live with "we
> cannot prove we will never get into a boating accident but we can show
> evidence that we live in a landlocked city far from any lakes, seas, or
> rivers".
>
> Regards,
> ZmnSCPxj
>
>
>   a custodian Lightning node is unable to "freeze" a snapshot of its
> current state and make an atomic proof-of-reserves of *all* channels
>
>
> That would be a neat trick. But yeah, I don't know how that would be
> possible.
>
>
>   I believe it is one reason why custodian proof-of-reserves is not that
> popular ... it does not prove that the key will not get lost
>
>
> True, but at least if funds do get lost, it would be come clear far
> quicker. Today, an insolvent company could go many months without the
> public finding out.
>
>
> On Mon, Jul 5, 2021 at 5:09 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>
> Good morning e,
>
>
> If only one could prove that he won?t get into a boating accident.
>
>
> At least in the context of Lightning channels, if one party in the channel
> loses its key in a boating accident, the other party (assuming it is a true
> separate person and not a sockpuppet) has every incentive to unilaterally
> close the channel, which reveals the exact amounts (though not necessarily
> who owns which).
>
> If the other party then uses its funds in a new proof-of-reserves, then
> obviously the other output of the unilateral close was the one lost in the
> boating accident.
>
>
> On the other hand, yes, custodians losing custodied funds in boating
> accidents is much too common.
>
> I believe it is one reason why custodian proof-of-reserves is not that
> popular --- it only proves that the funds were owned under a particular key
> at some snapshot of the past, it does not prove that the key will not get
> lost (or "lost and then salvaged by a scuba diver") later.
>
>
> Regards,
>
> ZmnSCPxj
>
>
>
> e
>
>
> On Jul 5, 2021, at 16:26, ZmnSCPxj via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
> Good morning Billy,
>
>
> I wonder if there would be some way to include the ability to prove
> balances held on the lightning network, but I suspect that isn't generally
> possible.
>
>
> Thinking about this in terms of economic logic:
>
> Every channel is anchored onchain, and that anchor (the funding txout) is
> proof of the existence, and size, of the channel.
>
> The two participants in the channel can sign a plaintext containing their
> node pubkeys and how much each owns.
>
> One of the participants should provably be the custodian.
>
>
> -   If the counterparty is a true third party, it has no incentive to lie
> about its money.
>
> -   Especially if the counterparty is another custodian who wants
> proof-of-reserves, it has every incentive to overreport, but then the first
> party will refuse to sign.
>
>      It has a disincentive to underreport, and would itself refuse to sign
> a dishonest report that assigns more funds to the first party.
>
>      The only case that would be acceptable to both custodians would be to
> honestly report their holdings in the Lightning channel.
>
>
> -   If the counterparty is a sockpuppet of the custodian, then the entire
> channel is owned by the custodian and it would be fairly dumb of he
> custodian to claim to have less funds than the entire channel.
>
>
> Perhaps a more practical problem is that Lightning channel states change
> fairly quickly, and there are possible race conditions, due to network
> latency (remember, both nodes need to sign, meaning both of them need to
> communicate with each other, thus hit by network latency and other race
> conditions) where a custodian Lightning node is unable to "freeze" a
> snapshot of its current state and make an atomic proof-of-reserves of all
> channels.
>
> Regards,
>
> ZmnSCPxj
>
>
> bitcoin-dev mailing list
>
> bitcoin-dev at lists.linuxfoundation.org
>
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/b2c7cab2/attachment-0001.html>

From billy.tetrud at gmail.com  Tue Jul  6 06:25:48 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 5 Jul 2021 23:25:48 -0700
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
Message-ID: <CAGpPWDZ6FhAn+dBf-_yf7YVzRB7NWV7zaKqKYewgZecBxWUx5A@mail.gmail.com>

>  when people are talking about enabling covenants, we are talking about
whether OP_CAT should be allowed or not

Are they? Are you implying that anything that enables covenants is
equivalent to enabling OP_CAT? Generally when I think about enabling
covenants, I'm thinking more about OP_CTV (or some similarly specific opcode
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/bip-constraindestination.md>
).

> OP_TWEAK

I wasn't able to find anything about what that is. Would you mind
clarifying what that concept is?

On Mon, Jul 5, 2021 at 10:20 AM Russell O'Connor via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi ZmnSCPxj,
>
> I don't believe we need to ban Turing completeness for the sake of banning
> Turing completeness.  My concerns have always been around ensuring that
> transaction and block validation is not unduly burdensome for nodes.  So
> for Bitcoin Script, we want to bound the amount of resources needed to
> execute it, preferably as a linear function of weight[1], and preferably
> have it clear what the evaluation costs are going to be prior to
> evaluation[2].  We also want to keep Script execution as a pure function of
> the transaction data so that nodes do not need to reevaluate their mempool
> on every new block.  For consensus purposes we prefer to have simple
> primitive operations that have clear and precise semantics that are as
> likely as possible to be reimplemented correctly if they are reimplemented
> (or at least let us not make this problem worse than it already is).  In
> particular, Script needs to be easy to parse to avoid weird parsing
> machines that lead to security vulnerabilities within node software.
>
> While the above design constraints imply a prohibition on Turing complete
> computation within a single Script, they do not imply a prohibition on
> arbitrary, covenant-enabled computations that spans across multiple
> transactions.  Neither would these constraints prohibit some kind of STARK
> or SNARK tapleaf version that was somehow capable of succinctly
> representing arbitrary computations, so long as validation costs remain
> bounded.
>
> And while it is true that covenant-enabled computations could allow users
> to put their funds at risk through weird machines that manipulate their
> money on the blockchain, as longs as that weirdness stays at that level of
> the abstract Bitcoin Script machine, then I suppose it is *caveat emptor*;
> don't send your funds to random unverified Bitcoin Scripts, advice that is
> already the case today.  We can keep that potential weirdness at bay by
> keeping Script simple, and maintaining our understanding that the Script
> programs (like the rest of the blockchain data) are untrusted inputs and
> they need to be validated and scrutinized before interpretation.
>
> [1] In tapscript I believe all operations are linear time with the
> exception of OP_ROLL.  However OP_ROLL is still constrained by global
> limits on stack size, etc.
> [2] In Bitcoin Script, without loops of any kind, every opcode is
> evaluated at most once, so counting opcodes is an easy way to put an upper
> bound on your costs before evaluation.
>
> On Sun, Jul 4, 2021 at 8:51 PM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Good morning Dave,
>>
>> > On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
>> >
>> > > However, I think the broader community is unconvinced by the cost
>> benefit
>> > > of arbitrary covenants. See
>> > >
>> https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
>> > > as a recent example. Therefore as a critical part of building
>> consensus on
>> > > various techniques I've worked to emphasize that specific additions
>> do not
>> > > entail risk of accidentally introducing more than was bargained for to
>> > > respect the concerns of others.
>> >
>> > Respecting the concerns of others doesn't require lobotomizing useful
>> > tools. Being respectful can also be accomplished by politely showing
>> > that their concerns are unfounded (or at least less severe than they
>> > thought). This is almost always the better course IMO---it takes much
>> > more effort to satisfy additional engineering constraints (and prove to
>> > reviewers that you've done so!) than it does to simply discuss those
>> > concerns with reasonable stakeholders. As a demonstration, let's look
>> > at the concerns from Shinobi's post linked above:
>> >
>> > They seem to be worried that some Bitcoin users will choose to accept
>> > coins that can't subsequently be fungibily mixed with other bitcoins.
>> > But that's already been the case for a decade: users can accept altcoins
>> > that are non-fungible with bitcoins.
>> >
>> > They talk about covenants where spending is controlled by governments,
>> > but that seems to me exactly like China's CBDC trial.
>> >
>> > They talk about exchanges depositing users' BTC into a covenant, but
>> > that's just a variation on the classic not-your-keys-not-your-bitcoins
>> > problem. For all you know, your local exchange is keeping most of its
>> > BTC balance commitments in ETH or USDT.
>> >
>> > To me, it seems like the worst-case problems Shinobi describes with
>> > covenants are some of the same problems that already exist with
>> > altcoins. I don't see how recursive covenants could make any of those
>> > problems worse, and so I don't see any point in limiting Bitcoin's
>> > flexibility to avoid those problems when there are so many interesting
>> > and useful things that unlimited covenants could do.
>>
>> The "altcoins are even worse" argument does seem quite convincing, and if
>> Bitcoin can survive altcoins, surely it can survive covenants too?
>>
>> In before "turns out covenants are the next ICO".
>> i.e. ICOs are just colored coins, which are useful for keeping track of
>> various stuff, but have then been used as a vehicle to scam people.
>> But I suppose that is a problem that humans will always have: limited
>> cognition, so that *good* popular things that are outside your specific
>> field of study are indistinguishable from *bad* popular things.
>> So perhaps it should not be a concern on a technical level.
>> Maybe we should instead make articles about covenants so boring nobody
>> will hype about it (^^;)v.
>>
>> Increased functionality implies increased processing, and hopefully
>> computation devices are getting cheap enough that the increased processing
>> implied by new features should not be too onerous.
>>
>>
>>
>> To my mind, an "inescapable" covenant (i.e. one that requires the output
>> to be paid to the same covenant) is basically a Turing machine, and
>> equivalent to a `while (true);` loop.
>> In a `while (true);` loop, the state of the machine reverts back to the
>> same state, and it repeats again.
>> In an inescpable covenant, the control of some amount of funds reverts
>> back to the same controlling SCRIPT, and it repeats again.
>> Yes, you can certainly add more functionality on top of that loop, just
>> think of program main loops for games or daemons, which are, in essence,
>> "just" `while (true) ...`.
>> But basically, such unbounded infinite loops are possible only under
>> Turing machines, thus I consider covenants to be Turing-complete.
>> Principle of Least Power should make us wonder if we need full Turing
>> machines for the functionality.
>>
>> On the other hand --- codata processing *does* allow for unbounded loops,
>> without requiring full Turing-completeness; they just require total
>> functionality, not partial (and Turing-completeness is partial, not total).
>> Basically, data structures are unbounded storage, while codata structures
>> are unbounded processing.
>> Perhaps covenants can encode an upper bound on the number of recursions,
>> which prevents full Turing-completeness while allowing for a large number
>> of use-cases.
>>
>> (if the above paragraph makes no sense to you, hopefully this Wikipedia
>> article will help:
>> https://en.wikipedia.org/wiki/Total_functional_programming )
>> (basically my argument here is based on academic programming stuff, and
>> might not actually matter in real life)
>>
>> Regards,
>> ZmnSCPxj
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210705/b9e7f0c5/attachment.html>

From sanket1729 at gmail.com  Tue Jul  6 10:20:53 2021
From: sanket1729 at gmail.com (Sanket Kanjalkar)
Date: Tue, 6 Jul 2021 03:20:53 -0700
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAGpPWDZ6FhAn+dBf-_yf7YVzRB7NWV7zaKqKYewgZecBxWUx5A@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <CAGpPWDZ6FhAn+dBf-_yf7YVzRB7NWV7zaKqKYewgZecBxWUx5A@mail.gmail.com>
Message-ID: <CAExE9c8eZz5i1gR5txdZaO1gyR5p6pBTzmNus4CHDS=ZQ2xApg@mail.gmail.com>

After some brainstorming about the possible drawbacks of enabling
covenants, I have also slowly become more comfortable with the idea of
"unlimited" covenants. AJs example clearly shows that _all_ possible
"misuses" of covenants are already possible by Multi-Sig today, so it's not
a new vector that we are adding today.

>  My concerns have always been around ensuring that transaction and block
validation is not unduly burdensome for nodes.  So for Bitcoin Script, we
want to bound the amount of resources needed to execute it, preferably as a
linear function of weight[1], and preferably have it clear what the
evaluation costs are going to be prior to evaluation[2].  We also want to
keep Script execution as a pure function of the transaction data so that
nodes do not need to reevaluate their mempool on every new block.

Many bitcoin upgrades, in particular, Segwit, and tapscript sigops budget
have been along with the same principle. And as mentioned before, none of
these go against enabling recursive covenants.

> Are they? Are you implying that anything that enables covenants is
equivalent to enabling OP_CAT?

No, it is not equivalent. Russell is referring to a way to do covenants by
only using `OP_CAT`(along with Schnorr sigs that we already have) as
mentioned by Andrew Poelstra here
<https://medium.com/blockstream/cat-and-schnorr-tricks-i-faf1b59bd298> .

I also am in general support of the `OP_CHECKSIGFROMSTACK` opcode. We would
need to update the suggestion to BIP340, and add it to sigops budget. I
have no strong preference for splitting R and s values or variable-length
messages.


On Tue, Jul 6, 2021 at 1:36 AM Billy Tetrud via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> >  when people are talking about enabling covenants, we are talking about
> whether OP_CAT should be allowed or not
>
> Are they? Are you implying that anything that enables covenants is
> equivalent to enabling OP_CAT? Generally when I think about enabling
> covenants, I'm thinking more about OP_CTV (or some similarly specific
> opcode
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/bip-constraindestination.md>
> ).
>
> > OP_TWEAK
>
> I wasn't able to find anything about what that is. Would you mind
> clarifying what that concept is?
>
> On Mon, Jul 5, 2021 at 10:20 AM Russell O'Connor via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi ZmnSCPxj,
>>
>> I don't believe we need to ban Turing completeness for the sake of
>> banning Turing completeness.  My concerns have always been around ensuring
>> that transaction and block validation is not unduly burdensome for nodes.
>> So for Bitcoin Script, we want to bound the amount of resources needed to
>> execute it, preferably as a linear function of weight[1], and preferably
>> have it clear what the evaluation costs are going to be prior to
>> evaluation[2].  We also want to keep Script execution as a pure function of
>> the transaction data so that nodes do not need to reevaluate their mempool
>> on every new block.  For consensus purposes we prefer to have simple
>> primitive operations that have clear and precise semantics that are as
>> likely as possible to be reimplemented correctly if they are reimplemented
>> (or at least let us not make this problem worse than it already is).  In
>> particular, Script needs to be easy to parse to avoid weird parsing
>> machines that lead to security vulnerabilities within node software.
>>
>> While the above design constraints imply a prohibition on Turing complete
>> computation within a single Script, they do not imply a prohibition on
>> arbitrary, covenant-enabled computations that spans across multiple
>> transactions.  Neither would these constraints prohibit some kind of STARK
>> or SNARK tapleaf version that was somehow capable of succinctly
>> representing arbitrary computations, so long as validation costs remain
>> bounded.
>>
>> And while it is true that covenant-enabled computations could allow users
>> to put their funds at risk through weird machines that manipulate their
>> money on the blockchain, as longs as that weirdness stays at that level of
>> the abstract Bitcoin Script machine, then I suppose it is *caveat emptor*;
>> don't send your funds to random unverified Bitcoin Scripts, advice that is
>> already the case today.  We can keep that potential weirdness at bay by
>> keeping Script simple, and maintaining our understanding that the Script
>> programs (like the rest of the blockchain data) are untrusted inputs and
>> they need to be validated and scrutinized before interpretation.
>>
>> [1] In tapscript I believe all operations are linear time with the
>> exception of OP_ROLL.  However OP_ROLL is still constrained by global
>> limits on stack size, etc.
>> [2] In Bitcoin Script, without loops of any kind, every opcode is
>> evaluated at most once, so counting opcodes is an easy way to put an upper
>> bound on your costs before evaluation.
>>
>> On Sun, Jul 4, 2021 at 8:51 PM ZmnSCPxj via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Good morning Dave,
>>>
>>> > On Sun, Jul 04, 2021 at 11:39:44AM -0700, Jeremy wrote:
>>> >
>>> > > However, I think the broader community is unconvinced by the cost
>>> benefit
>>> > > of arbitrary covenants. See
>>> > >
>>> https://medium.com/block-digest-mempool/my-worries-about-too-generalized-covenants-5eff33affbb6
>>> > > as a recent example. Therefore as a critical part of building
>>> consensus on
>>> > > various techniques I've worked to emphasize that specific additions
>>> do not
>>> > > entail risk of accidentally introducing more than was bargained for
>>> to
>>> > > respect the concerns of others.
>>> >
>>> > Respecting the concerns of others doesn't require lobotomizing useful
>>> > tools. Being respectful can also be accomplished by politely showing
>>> > that their concerns are unfounded (or at least less severe than they
>>> > thought). This is almost always the better course IMO---it takes much
>>> > more effort to satisfy additional engineering constraints (and prove to
>>> > reviewers that you've done so!) than it does to simply discuss those
>>> > concerns with reasonable stakeholders. As a demonstration, let's look
>>> > at the concerns from Shinobi's post linked above:
>>> >
>>> > They seem to be worried that some Bitcoin users will choose to accept
>>> > coins that can't subsequently be fungibily mixed with other bitcoins.
>>> > But that's already been the case for a decade: users can accept
>>> altcoins
>>> > that are non-fungible with bitcoins.
>>> >
>>> > They talk about covenants where spending is controlled by governments,
>>> > but that seems to me exactly like China's CBDC trial.
>>> >
>>> > They talk about exchanges depositing users' BTC into a covenant, but
>>> > that's just a variation on the classic not-your-keys-not-your-bitcoins
>>> > problem. For all you know, your local exchange is keeping most of its
>>> > BTC balance commitments in ETH or USDT.
>>> >
>>> > To me, it seems like the worst-case problems Shinobi describes with
>>> > covenants are some of the same problems that already exist with
>>> > altcoins. I don't see how recursive covenants could make any of those
>>> > problems worse, and so I don't see any point in limiting Bitcoin's
>>> > flexibility to avoid those problems when there are so many interesting
>>> > and useful things that unlimited covenants could do.
>>>
>>> The "altcoins are even worse" argument does seem quite convincing, and
>>> if Bitcoin can survive altcoins, surely it can survive covenants too?
>>>
>>> In before "turns out covenants are the next ICO".
>>> i.e. ICOs are just colored coins, which are useful for keeping track of
>>> various stuff, but have then been used as a vehicle to scam people.
>>> But I suppose that is a problem that humans will always have: limited
>>> cognition, so that *good* popular things that are outside your specific
>>> field of study are indistinguishable from *bad* popular things.
>>> So perhaps it should not be a concern on a technical level.
>>> Maybe we should instead make articles about covenants so boring nobody
>>> will hype about it (^^;)v.
>>>
>>> Increased functionality implies increased processing, and hopefully
>>> computation devices are getting cheap enough that the increased processing
>>> implied by new features should not be too onerous.
>>>
>>>
>>>
>>> To my mind, an "inescapable" covenant (i.e. one that requires the output
>>> to be paid to the same covenant) is basically a Turing machine, and
>>> equivalent to a `while (true);` loop.
>>> In a `while (true);` loop, the state of the machine reverts back to the
>>> same state, and it repeats again.
>>> In an inescpable covenant, the control of some amount of funds reverts
>>> back to the same controlling SCRIPT, and it repeats again.
>>> Yes, you can certainly add more functionality on top of that loop, just
>>> think of program main loops for games or daemons, which are, in essence,
>>> "just" `while (true) ...`.
>>> But basically, such unbounded infinite loops are possible only under
>>> Turing machines, thus I consider covenants to be Turing-complete.
>>> Principle of Least Power should make us wonder if we need full Turing
>>> machines for the functionality.
>>>
>>> On the other hand --- codata processing *does* allow for unbounded
>>> loops, without requiring full Turing-completeness; they just require total
>>> functionality, not partial (and Turing-completeness is partial, not total).
>>> Basically, data structures are unbounded storage, while codata
>>> structures are unbounded processing.
>>> Perhaps covenants can encode an upper bound on the number of recursions,
>>> which prevents full Turing-completeness while allowing for a large number
>>> of use-cases.
>>>
>>> (if the above paragraph makes no sense to you, hopefully this Wikipedia
>>> article will help:
>>> https://en.wikipedia.org/wiki/Total_functional_programming )
>>> (basically my argument here is based on academic programming stuff, and
>>> might not actually matter in real life)
>>>
>>> Regards,
>>> ZmnSCPxj
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
Sanket Kanjalkar
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/d62d9096/attachment-0001.html>

From roconnor at blockstream.com  Tue Jul  6 11:26:28 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Tue, 6 Jul 2021 07:26:28 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAGpPWDZ6FhAn+dBf-_yf7YVzRB7NWV7zaKqKYewgZecBxWUx5A@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <CAGpPWDZ6FhAn+dBf-_yf7YVzRB7NWV7zaKqKYewgZecBxWUx5A@mail.gmail.com>
Message-ID: <CAMZUoKkAUodCT+2aQG71xwHYD8KXeTAdQq4NmXZ4GBe0pcD=9A@mail.gmail.com>

On Tue, Jul 6, 2021 at 2:26 AM Billy Tetrud <billy.tetrud at gmail.com> wrote:

> >  when people are talking about enabling covenants, we are talking about
> whether OP_CAT should be allowed or not
>
> Are they? Are you implying that anything that enables covenants is
> equivalent to enabling OP_CAT? Generally when I think about enabling
> covenants, I'm thinking more about OP_CTV (or some similarly specific
> opcode
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/bip-constraindestination.md>
> ).
>
> > OP_TWEAK
>
> I wasn't able to find anything about what that is. Would you mind
> clarifying what that concept is?
>

In tapscript one can generally recover the current input's scriptPubkey
through sighash introspection via the usual covenant tricks.  This allows
you to make a recursive covenant by spending funds back to the same
identical scriptPubkey.  However, in order for a recursive covenant to be
actually interesting, there needs to be some sort of state update in each
transition.  If there is no state update then sending funds back to itself
is of very limited value.  It will reset the timer on relative locks, but
that is about all.

The "normal" way of writing useful recursive covenants is to modify the
scriptPubkey by changing a fragment of it that contains some sort of
state.  However in order to update a tapscript pubkey one needs to apply
not only hashing, to create a Merkel root, but also to create a tweaked
taproot pubkey that commits to this root.  While script currently comes
with a SHA-256 hashing opcode, there is no opcode that will let you perform
the necessary tweaking to create a taproot scriptPubkey.

But as I mentioned afterwards, there are other places in the UTXO that you
could put data in order to perform a state update.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/e7b418bc/attachment.html>

From jlrubin at mit.edu  Tue Jul  6 17:54:57 2021
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 6 Jul 2021 10:54:57 -0700
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKmWqSnWhTUmTXRuAsrgd0KsQ+XjPw1s+XsZWARhsDcGsA@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
 <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
 <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>
 <CAD5xwhgtsqAX99NJRU6t-s14aF7frGZxFCL3-c9iBOYrkN_A_w@mail.gmail.com>
 <CAMZUoKmWqSnWhTUmTXRuAsrgd0KsQ+XjPw1s+XsZWARhsDcGsA@mail.gmail.com>
Message-ID: <CAD5xwhhft7sKUS++LnS7-Fw37ovCioQWX3pV57JtTdDZ1MfzHg@mail.gmail.com>

Re-threading Sanket's comment on split R value:

I also am in general support of the `OP_CHECKSIGFROMSTACK` opcode. We would
> need to update the suggestion to BIP340, and add it to sigops budget. I
> have no strong preference for splitting R and s values or variable-length
> messages.
>

Back to my comment:


I see a few options:

1) Making a new 64 byte PK standard which is (R, PK)
2) Splitting (R,S)
3) Different opcodes
4) CAT

The drawback of option 1 is that it's designed to support only very
specific use cases. The main drawback of splitting via option 2 is that you
entail an extra push byte for every use. Option 3 wastes opcodes. CAT has
the general drawbacks of CAT, but worth noting that CAT will likely
eventually land making the splitting feature redundant.


Before getting too in the weeds, it might be worth listing out interesting
script fragments that people are aware of with split R/S so we can see how
useful it might be?

Use a specific R Value
- <S> <M> || <R> SWAP <PK> CSFS

Reuse arbitrary R for a specific M (pay to leak key)
-  <R> <S1> <S2>  ||  DUP2 EQUAL NOT VERIFY 2 PICK SWAP <M> DUP TOALTSTACK
CSFSV FROMALTSTACK CSFS

Verify 2 different messages reuse the same R.
- <S1> <R> <M1> <S2> <M2> ||  2 PICK EQUAL NOT VERIFY 3 PICK <PK> DUP
TOALTSTACK CSFSV FROMALTSTACK CSFS

Use a R Value signed by an oracle:
- <S> <M> <S_oracle> <R_oracle> <R> || DUP TOALTSTACK <PK_oracle> CSFSV
FROMALTSTACK SWAP <PK> CSFS
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/b480247e/attachment.html>

From roconnor at blockstream.com  Tue Jul  6 18:21:33 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Tue, 6 Jul 2021 14:21:33 -0400
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAD5xwhhft7sKUS++LnS7-Fw37ovCioQWX3pV57JtTdDZ1MfzHg@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
 <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
 <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>
 <CAD5xwhgtsqAX99NJRU6t-s14aF7frGZxFCL3-c9iBOYrkN_A_w@mail.gmail.com>
 <CAMZUoKmWqSnWhTUmTXRuAsrgd0KsQ+XjPw1s+XsZWARhsDcGsA@mail.gmail.com>
 <CAD5xwhhft7sKUS++LnS7-Fw37ovCioQWX3pV57JtTdDZ1MfzHg@mail.gmail.com>
Message-ID: <CAMZUoKnhUoQGgpx_+keb_vpobKkaT2cbdZWib4oA+VytFwOsDA@mail.gmail.com>

If the main outstanding issue is whether to split R or S, I think as far as
Elements goes, I am inclined to go with the CAT option regardless of
whether Bitcoin chooses to split R/S or not (not that I'm necessarily a
decision maker here).

The issue here is that (a) Elements already has CAT, and (b) updating
CHECKSIGFROMSTACK is effectively a blocking issue for deploying Taproot on
Elements.  I don't think we will be holding up CHECKSIGFROMSTACK for this
issue even if it risks being incompatible with an eventual Bitcoin
CHECKSIGFROMSTACK.

To be clear, I don't mean to prejudice this discussion by this statement.
This just happens to be what makes sense for the Elements project at this
time, and what makes sense for Elements may not necessarily make sense for
Bitcoin.

Of course, I think we should just go for CAT compatibility.  Otherwise we
are just going to have a proliferation of trusted CAT oracles paid for with
lightning by people wanting to perform CAT operations.

On Tue, Jul 6, 2021 at 1:55 PM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Re-threading Sanket's comment on split R value:
>
> I also am in general support of the `OP_CHECKSIGFROMSTACK` opcode. We
>> would need to update the suggestion to BIP340, and add it to sigops budget.
>> I have no strong preference for splitting R and s values or variable-length
>> messages.
>>
>
> Back to my comment:
>
>
> I see a few options:
>
> 1) Making a new 64 byte PK standard which is (R, PK)
> 2) Splitting (R,S)
> 3) Different opcodes
> 4) CAT
>
> The drawback of option 1 is that it's designed to support only very
> specific use cases. The main drawback of splitting via option 2 is that you
> entail an extra push byte for every use. Option 3 wastes opcodes. CAT has
> the general drawbacks of CAT, but worth noting that CAT will likely
> eventually land making the splitting feature redundant.
>
>
> Before getting too in the weeds, it might be worth listing out interesting
> script fragments that people are aware of with split R/S so we can see how
> useful it might be?
>
> Use a specific R Value
> - <S> <M> || <R> SWAP <PK> CSFS
>
> Reuse arbitrary R for a specific M (pay to leak key)
> -  <R> <S1> <S2>  ||  DUP2 EQUAL NOT VERIFY 2 PICK SWAP <M> DUP TOALTSTACK
> CSFSV FROMALTSTACK CSFS
>
> Verify 2 different messages reuse the same R.
> - <S1> <R> <M1> <S2> <M2> ||  2 PICK EQUAL NOT VERIFY 3 PICK <PK> DUP
> TOALTSTACK CSFSV FROMALTSTACK CSFS
>
> Use a R Value signed by an oracle:
> - <S> <M> <S_oracle> <R_oracle> <R> || DUP TOALTSTACK <PK_oracle> CSFSV
> FROMALTSTACK SWAP <PK> CSFS
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/d047ffd2/attachment.html>

From erik at q32.com  Tue Jul  6 16:39:36 2021
From: erik at q32.com (Erik Aronesty)
Date: Tue, 6 Jul 2021 12:39:36 -0400
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>
References: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>
Message-ID: <CAJowKgJEJr=LhYhuQs4zOyskdAwjZT6aEFd-3=rsShLUf7yWJw@mail.gmail.com>

you should check out some of the earlier work done here:

https://github.com/olalonde/proof-of-solvency#assets-proof

to be honest, if any exchange supported that proof, it would be more
than enough.

there's really no way to prevent a smash-and-grab, but this does
prevent a slow-leak


On Mon, Jul 5, 2021 at 5:10 PM Billy Tetrud via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> I had the idea recently for proof of reserves done in a way that can be used to verify reserves are sufficient on an ongoing basis. I'm curious if there are any current approaches out there to proof of reserves that are similar.
>
> The idea is to have users create actual private keys using a seed in pretty much the normal way. Users would generate a public key from this seed to represent their account, and would give the public key to the custodian to represent their account in a public record of account balances.
>
> When a user's account is credited, the custodian would update a map of addresses (created from the public key of each account) to balances - this map could be structured into a merkle tree in the usual "merkle approach". The custodian would also store funds on one or more HD wallets (each with many addresses) and create a proof that they own each HD wallet. The proof could be as simple as a single signature created with the xpub for the wallet, which would be sufficient for proving ownership over the whole list/tree of addresses.
>
> These two structures (the map and the HD wallet) would be combined and hashed, and the hash published in an on chain transaction (possibly along with a URI where the full data can be found), on something like a daily basis. Software for each user could continuously validate that their account has a balance that matches what it's supposed to have, and could also verify that owned addresses have funds that have at least as many coins as promised to accounts. If these things aren't verifiable (either because the balances total to more than the HD wallet contains, or because of data unavailability), people can raise hell about it.
>
> To give user's additional proving ability, a receipt system could be added. Users could request a receipt for any balance update. Eg the user would create a message with a timestamp, their custodial "address", and the new balance. The user would sign this receipt and send it to the custodian, who would also sign it and send it back. This way, if something goes wrong, a user can use this signed receipt to show that the custodian did in fact promise a new updated balance at a particular time (which would cover the case that the custodian records the wrong value in their map). Conversely, the receipt would be useful to honest custodians as well, since they could show the user's signed receipt request in the case a user is trying to lie about what balance they should have. There is still the case that the custodian simply refuses to return a signed receipt, in which case the user's only recourse is to yell about it immediately and demand a receipt or a refund.
>
> Why record it on chain? Doing that gives a clear record of proof of reserves that can be verified later by anyone in the future. It prevents a custodian from being able to change history when it suits them (by creating a new records with false timestamps in the past). Many of these records could be aggregated together and recorded in the same transaction (with a single hash), so a single transaction per day could record the records of all participating custodians. If all custodians are using a standard system, one can cross verify that addresses claimed by one custodian aren't also claimed by another custodian.
>
> Even tho the user is responsible for their keys in order to properly verify, losing the keys isn't that big of a deal, since they could simply create a new seed and give a new public key to the custodian - who would have other identifying information they could use to validate that they own the account. So it places less responsibility on the user, while still introducing people, in a light-weight way, to self custody of keys.
>
> Having a record like this every day would reduce the possibility of shenanigans like taking a short term loan of a large amount of cryptocurrency. Sure, they could take a 10 minute loan once per day, but it would also be possible to trace on-chain transactions so you could tell if such a thing was going on. I wonder if there would be some way to include the ability to prove balances held on the lightning network, but I suspect that isn't generally possible.
>
> In any case, I'm curious what people think of this kind of thing, and if systems with similar properties are already out there.
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jlrubin at mit.edu  Tue Jul  6 18:36:31 2021
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 6 Jul 2021 11:36:31 -0700
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKkAUodCT+2aQG71xwHYD8KXeTAdQq4NmXZ4GBe0pcD=9A@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <CAGpPWDZ6FhAn+dBf-_yf7YVzRB7NWV7zaKqKYewgZecBxWUx5A@mail.gmail.com>
 <CAMZUoKkAUodCT+2aQG71xwHYD8KXeTAdQq4NmXZ4GBe0pcD=9A@mail.gmail.com>
Message-ID: <CAD5xwhhm+TejnVV-pxEmE0_msUzXU1njMDbjrYb4vd0Kti-Xkg@mail.gmail.com>

heh -- I pointed out these evil multisig covenants in 2015 :)
https://medium.com/@jeremyrubin/regulating-bitcoin-by-mining-the-regulator-miner-attack-c8fd51185b78
I'm relatively unconcerned by it except to the extent that mining
centralizes to the point of censoring other traffic.

Overall, I think this is a great conversation to be having.

However, I want to push back on David's claim that  "Respecting the
concerns of others doesn't require lobotomizing useful tools.".

CHECKSIGFROMSTACK is a primitive and the opcode is not being nerfed in any
way shape or form. The argument here is that doing CSFS and not CAT is
nerfing CSFS... but CSFS is an independently useful and cool opcode that
has many of it's own merits.

Further, as described in my [blog post](
https://rubin.io/blog/2021/07/02/covenants/), CSFS has very high "design
specificity"... that is there's not *that* many design choices that could
possibly go into it. It's checking a signature. From the stack. That's all
folks! There are no design compromises in it. No lobotomy.

OP_CAT is more or less completely unrelated to CSFS. As Andrew has
[demonstrated](
https://www.wpsoftware.net/andrew/blog/cat-and-schnorr-tricks-i.html),
*just* OP_CAT alone (no CSFS) gives you covenants (albeit in a hacky way)
with Schnorr.

I think roconnor agrees that CAT(+CSFS?) are not really a "fantastic" way
to do covenants, that there are more direct approaches that will be better
or neccessary such as TWEAK or UPDATETAPLEAF. Let's work on those! But
let's also not hold up progress on other useful things while those are
brewing.

Non-Redundancy should be a non-goal for script -- although we strive to be
minimal, redundancy is inevitable. For example, OP_SWAP has identical
semantics to <1> ROLL, but SWAP is a common enough use that it is pragmatic
to assign it an opcode and OP_ROLL does something distinctly enhanced.
Similarly, even if we add CAT we will surely come up with saner ways to
implement covenant logic than Andrew's Schnorr tricks.

CTV in particular is designed to be a part of that story -- enough
functionality w/o OP_CAT to work *today* and serve a purpose long into the
future, but with OP_CAT (or shastream preferably) enhances it's
functionality in a useful way and with introspection opcodes (perhaps like
those being developed by elements) further gains functionality. Perhaps the
functionality available today will be redundant with a future way of doing
things, but we can only see so far into the future. However, we can see
that there are good things to build with it today.

It's the inverse of a lobotomy. Independent components that can come
together for a newer greater purpose rather than parts being torn apart
irreparably.

In the future when we have specific use cases in mind that *aren't* served
well (either efficiently or at all) by the existing primitives, it's
completely acceptable to add something new even if it makes an existing
feature redundant. APO, for example, will be redundant (afaict) will Glen
Willen's [Bitmask SigHash Flags](
https://bc-2.jp/archive/season2/materials/0203_NewElementsFeaturesEn.pdf)
should we ever get those.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/4bf5525a/attachment.html>

From eric at voskuil.org  Tue Jul  6 18:40:35 2021
From: eric at voskuil.org (eric at voskuil.org)
Date: Tue, 6 Jul 2021 11:40:35 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAJowKgJEJr=LhYhuQs4zOyskdAwjZT6aEFd-3=rsShLUf7yWJw@mail.gmail.com>
References: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>
 <CAJowKgJEJr=LhYhuQs4zOyskdAwjZT6aEFd-3=rsShLUf7yWJw@mail.gmail.com>
Message-ID: <006b01d77296$6898e370$39caaa50$@voskuil.org>

> you should check out some of the earlier work done here:
> 
> https://github.com/olalonde/proof-of-solvency#assets-proofNothing in this 

Nothing here refutes what I have said. Furthermore it relies on the
assumption that all assets and liabilities are provable. This is clearly
prohibitive.

> more than enough.

Arbitrary and subjective.

A business raises money (investment) so that it can spend more than it
previously had. This is net "insolvency" until (and assuming) it produces
and earns over time an amount sufficient to cover its capitalization and
time value.

These sort of schemes are relevant only to what Rothbard calls a money
"warehouse" (a literal vault), which is explicitly not a "bank" (banks
lend). Warehousing Bitcoin is a strange idea to start with. And given that
they are so larded with trust and race conditions it's hardly an improvement
over holding your own keys.

e

> -----Original Message-----
> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On
> Behalf Of Erik Aronesty via bitcoin-dev
> Sent: Tuesday, July 6, 2021 9:40 AM
> To: Billy Tetrud <billy.tetrud at gmail.com>; Bitcoin Protocol Discussion
> <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Proof of reserves - recording
> 
> you should check out some of the earlier work done here:
> 
> https://github.com/olalonde/proof-of-solvency#assets-proof
> 
> to be honest, if any exchange supported that proof, it would be more than
> enough.
> 
> there's really no way to prevent a smash-and-grab, but this does prevent a
> slow-leak
> 
> 
> On Mon, Jul 5, 2021 at 5:10 PM Billy Tetrud via bitcoin-dev <bitcoin-
> dev at lists.linuxfoundation.org> wrote:
> >
> > I had the idea recently for proof of reserves done in a way that can be
used
> to verify reserves are sufficient on an ongoing basis. I'm curious if
there are
> any current approaches out there to proof of reserves that are similar.
> >
> > The idea is to have users create actual private keys using a seed in
pretty
> much the normal way. Users would generate a public key from this seed to
> represent their account, and would give the public key to the custodian to
> represent their account in a public record of account balances.
> >
> > When a user's account is credited, the custodian would update a map of
> addresses (created from the public key of each account) to balances - this
> map could be structured into a merkle tree in the usual "merkle approach".
> The custodian would also store funds on one or more HD wallets (each with
> many addresses) and create a proof that they own each HD wallet. The proof
> could be as simple as a single signature created with the xpub for the
wallet,
> which would be sufficient for proving ownership over the whole list/tree
of
> addresses.
> >
> > These two structures (the map and the HD wallet) would be combined and
> hashed, and the hash published in an on chain transaction (possibly along
> with a URI where the full data can be found), on something like a daily
basis.
> Software for each user could continuously validate that their account has
a
> balance that matches what it's supposed to have, and could also verify
that
> owned addresses have funds that have at least as many coins as promised to
> accounts. If these things aren't verifiable (either because the balances
total
> to more than the HD wallet contains, or because of data unavailability),
> people can raise hell about it.
> >
> > To give user's additional proving ability, a receipt system could be
added.
> Users could request a receipt for any balance update. Eg the user would
> create a message with a timestamp, their custodial "address", and the new
> balance. The user would sign this receipt and send it to the custodian,
who
> would also sign it and send it back. This way, if something goes wrong, a
user
> can use this signed receipt to show that the custodian did in fact promise
a
> new updated balance at a particular time (which would cover the case that
> the custodian records the wrong value in their map). Conversely, the
receipt
> would be useful to honest custodians as well, since they could show the
> user's signed receipt request in the case a user is trying to lie about
what
> balance they should have. There is still the case that the custodian
simply
> refuses to return a signed receipt, in which case the user's only recourse
is to
> yell about it immediately and demand a receipt or a refund.
> >
> > Why record it on chain? Doing that gives a clear record of proof of
reserves
> that can be verified later by anyone in the future. It prevents a
custodian
> from being able to change history when it suits them (by creating a new
> records with false timestamps in the past). Many of these records could be
> aggregated together and recorded in the same transaction (with a single
> hash), so a single transaction per day could record the records of all
> participating custodians. If all custodians are using a standard system,
one can
> cross verify that addresses claimed by one custodian aren't also claimed
by
> another custodian.
> >
> > Even tho the user is responsible for their keys in order to properly
verify,
> losing the keys isn't that big of a deal, since they could simply create a
new
> seed and give a new public key to the custodian - who would have other
> identifying information they could use to validate that they own the
account.
> So it places less responsibility on the user, while still introducing
people, in a
> light-weight way, to self custody of keys.
> >
> > Having a record like this every day would reduce the possibility of
> shenanigans like taking a short term loan of a large amount of
> cryptocurrency. Sure, they could take a 10 minute loan once per day, but
it
> would also be possible to trace on-chain transactions so you could tell if
such
> a thing was going on. I wonder if there would be some way to include the
> ability to prove balances held on the lightning network, but I suspect
that
> isn't generally possible.
> >
> > In any case, I'm curious what people think of this kind of thing, and if
> systems with similar properties are already out there.
> >
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From jlrubin at mit.edu  Tue Jul  6 18:53:32 2021
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 6 Jul 2021 11:53:32 -0700
Subject: [bitcoin-dev] CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnhUoQGgpx_+keb_vpobKkaT2cbdZWib4oA+VytFwOsDA@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <CAMZUoK=-jrH+fr=tUTHmLojm2-Ff99KYm9H97yhd=7bcOVG=fg@mail.gmail.com>
 <CAD5xwhg0N1byx-G2tk=jjmZSHSBirpaX6OHTnh_x9iDEVF8PrQ@mail.gmail.com>
 <CAMZUoKnYAKum63fRUNJD-zAZX_p3MoFULGWRE7J2QkO69nOe8g@mail.gmail.com>
 <CAD5xwhgtsqAX99NJRU6t-s14aF7frGZxFCL3-c9iBOYrkN_A_w@mail.gmail.com>
 <CAMZUoKmWqSnWhTUmTXRuAsrgd0KsQ+XjPw1s+XsZWARhsDcGsA@mail.gmail.com>
 <CAD5xwhhft7sKUS++LnS7-Fw37ovCioQWX3pV57JtTdDZ1MfzHg@mail.gmail.com>
 <CAMZUoKnhUoQGgpx_+keb_vpobKkaT2cbdZWib4oA+VytFwOsDA@mail.gmail.com>
Message-ID: <CAD5xwhgZwCgu-t2GK+s3VKSQrh9cywPqxoToSC8W9M7bkxZe0A@mail.gmail.com>

I don't think Elements engineering decisions or management timelines should
have any bearing on what Bitcoin adopts, beyond learning what
works/doesn't. Same as litecoin, dogecoin, or bitcoin cash :)

With my understanding of elements it makes sense that you wouldn't want to
break compatibility script version to script version, although that seems
inevitable that you will need to either hard fork or break compatibility if
you want to fix the CHECKSIGFROMSTACK has verify semantics bug. But perhaps
that's a smaller change than the # of stack elements popped? It makes sense
having CAT that adding a split CSFS wouldn't be a priority. However, I'd
suggest that as far as elements is concerned, if the bitcoin community
decides on something that is incompatible, elements can use up some
addition opcodes or a keytype to add CSFS_BITCOIN_COMPAT ops.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/8660390f/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Wed Jul  7 04:26:31 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 07 Jul 2021 04:26:31 +0000
Subject: [bitcoin-dev] Unlimited covenants,
	was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
Message-ID: <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>

Good morning Russell,

> Hi ZmnSCPxj,
>
> I don't believe we need to ban Turing completeness for the sake of banning Turing completeness.

Well I believe we should ban partial Turing-completeness, but allow total Turing-completeness.

I just think that unlimited recursive covenants (with or without a convenient way to transform state at each iteration) are **not** partial Turing-complete, but *are* total Turing-complete. (^^)

(The rest of this writeup is mostly programming languages nerdery so anyone who is not interested in Haskell (or purely functional programming) and programming language nerdery can feel free to skip the rest of this post.
Basically, ZmnSCPxj thinks we should still ban Turing-completeness, but unbounded covenants get a pass because they are not, on a technicality, Turing-complete)

For now, let us first taboo the term "Turing-complete", and instead focus on what I think matters here, the distinction between partial and total,

In a total programming language we have a distinction between data and codata:

* Data is defined according to its constructors, i.e. an algebraic data type.
* Codata is defined according to its destructors, i.e. according to a "behavior" the codata has when a particular "action" is applied to it.

For example, a singly-linked list data type would be defined as follows:

    data List a where
        Cons :: a -> List a -> List a
        Nil :: List a

On the other hand, an infinite codata stream of objects would be defined as follows:

    codata Stream a where
        head :: Stream a -> a
        tail :: Stream a -> Stream a

For `data` types, the result type for each constructor listed in the definition *must* be the type being defined.
That is why `Cons` is declared as resulting in a `List a`.
We declare data according to its constructors.

For `codata` types, the *first argument* for each destructor listed in the definition *must* be the type being defined.
That is why `head` accepts as its first argument the `Stream a` type.

This is relevant because in a total function programming language, there exists some programming rule that restricts recursion.
The simplest such restriction is substructural recursion:

* If a function recurs:
  * Every self-call should pass in a substructure of an argument as that argument.

Every program that passes the above rule provably terminates.
Since every recursion passes in a smaller part of an argument, eventually we will reach an indivisible primitive object being passed in, and processing will stop recursing and can return some value.

Thus, a programing language that has substructural recursion rule check (and rejects programs that fail the substrucutral recursion check) are not "Turing-complete".
The reason is that Turing-complete languages cannot solve the Halting Problem.
But a language that includes the substructural recursion rule *does* have a Halting Problem solution: every program that passes the substructural recursion rule halts and the Halting Problem is decidable for all programs that pass the substructural recursion rule.
(i.e. we are deliberately restricting ourselves to a subset of programs that pass substructural recursion, and reject programs that do not pass this rule as "not really programs", so every program halts)

For example, the following definition of `mapList` is valid under substructural recursion:

    mapList :: (a -> b) -> (List a -> List b)
    mapList f Nil            = Nil
    mapList f (Cons a as)    = Cons (f a) (mapList f as)

The second sub-definition has a recursive call `mapList f as`.
The second argument to that call, however, is a substructure of the second argument `Cons a as` on the LHS of the definition, thus it is a substructural recursive call, and accepted in a total programming language.
*Every* recursion in `mapList` should then be a substructural call on the second argument of `mapList`.

Now let us consider the following definition of `fibonacci`:

    -- to use: fibonacci 1 1
    fibonacci :: Integer -> Integer -> List Integer
    fibonacci x y = Cons x (fibonacci y (x + y))

The above is not substructural recursive, neither argument in the recursive `fibonacci y (x + y)` call is a substructure of the arguments in the LHS of the `fibonacci` definition `fibonacci x y`.

Thus, we prevent certain unbounded computations like the above infinite sequence of fibonacci numbers.

Now, let us consider a definition of `mapStream`, the similar function on streams, using copattern matching rather than pattern matching:

    mapStream :: (a -> b) -> (Stream a -> Stream b)
    head (mapStream f as) = f (head as)
    tail (mapStream f as) = mapStream f (tail as)

Now the interesting thing here is that in the substructural recursion check, what is being defined in the above stanza is ***not*** `mapStream`, but `head` and `tail`!
Thus, it ignores the `mapStream f (tail as)`, because it is **not** recursion --- what is being defined here is `tail`.

Looking at the above stanza, we can see that the `head` definition recurses, in the call `head as`.
The first argument to `head as` is `as`, which is a substructure of the first argument of the LHS, `mapstream f as`.
Similarly for the `tail` definition, there is a recursive call `tail as` which is substructural recursive, since the LHS has the first argument as `mapStream f as` and `as` is a substructure of that call.

(Indeed, copatterns are an important advance in total programming languages, prior to copatterns people were bashing their heads trying to figure out a simple algorithm to ensure corecursion termination, and it turns out that copatterns make corecursion termination as trivial as substructural recursion on the destructurs)

Now let us consider the following alternate definition of `fibonacci` which returns a `Stream Integer` rather than a `List Integer`:

    fibonacci :: Integer -> Integer -> Stream Integer
    head (fibonacci x y) = x
    tail (fibonacci x y) = fibonacci y (x + y)

The first definition `head (fibonacci x y) = ...` is nonrecursive.
The sceon definition `tail (fibonacci x y) = ...` is ***also*** nonrecursive because what is being defined is `tail`, and `tail` does not even appear in the RHS of the definition!

With the syntax and its rules defined, let us now consider how to implement arbitrary-bound recursion in our total language.

Let us define the following types:

    data RecResult a where
        Complete ::     a -> RecResult a
        Continue :: Rec a -> RecResult a

    codata Rec a where
        step :: Rec a -> RecResult a

`Rec a` is a monad:

    instance Monad Rec where
        step (return a) = Complete a
        step (ma >>= f) = case (step ma) of
                            Complete a   -> Continue (f a)
                            Continue ma' -> Continue (ma' >>= f)
        -- pretend we do not have the Haskellian `fail` ^^

The definition of `step (ma >>= f)` is recursive, but it is a substructural recursion: we recurse on `(step ma)` but `ma` is a substructure of the first argument on the LHS, `ma >>= f`, thus the above still is provably corecursive terminating.

The above is sufficient to define an infinite loop:

    infiniteLoop :: Rec a
    step infiniteLoop = Continue infiniteLoop

The above is still accepted, since there is no recursion involved --- the RHS does not contain the function `step` being defined, thus no recursion.

Now the important thing to note here is that the above `Rec` type is a perfectly fine definition for the Haskellian `IO` type.

Then, the `main` program, of type `Rec ()`/`IO ()`, would then be passed to a driving function, written in C.
This C function would replace the C-level `main` function, and would just call `step` on the Haskell-level `main`.
If it results in `Complete ()`, the C function exits.
If it results in `Continue ma`, then it calls `step` again on the `ma` and checks the result again, in a loop.

    int main() {
        HaskellObject* ma = haskell_get_main_function();
        for (;;) {
            HaskellObject* result = haskell_step(ma);
            if (haskell_is_Complete(result))
                 break;
            ma = haskell_destructure_Continue(result);
        }
        return 0;
    }

The important point here is that *within* the total language, everything terminates.
We put all the dirty non-termination "outside", in the C function that drives the entire processing, and have a very simple infinite loop in it that is easy to audit for correctness.
Then, we can have significantly more confidence in the correctness of our program, since any infinite recursion would have to somehow resolve to some `IO` type, which explicitly allows for infinite recursion, and we can focus auditing on that part of the program alone.

Similarly, when we consider recursive covenants, we note always that there has to be some external driving program, written in something other than Bitcoin SCRIPT, which will continuously create transactions that will keep returning the funds to the same covenant (plus or minus some state update).
Otherwise, the funds will just sit there behind their protecting SCRIPT, just like every other UTXO owned by long-term HODLers.

Such a program that continually pays a fund to "the same" covenant is no different, in principle, from the above C driving function for our total-functional-programming dialect of Haskell.

Which is to say that I mostly agree with roconnor here (other than on exact definition of terms; I think my definition of "Turing-complete" is more restrictive than his, such that covenants are not in fact **technically** Turing-complete, but that is just semantics and I can live with that), I think that the recursive covenants in Bitcoin work equivalently to the `codata` types in total functional languages.
As long as Bitcoin SCRIPT itself is provably terminating, I have no objections to the fact that we get arbitrary-bound processing by use of covenants, as they are "outside" the SCRIPT and have to be operated separately by a separate program.

Indeed, we note as well that we can encode state in other parts of the TX anyway, so that we can write something more substantive than `while (true) { /* do nothing */ }`.
So we might as well make it easy on us and just add `OP_TWEAK` (and maybe convenience opcodes for building Taproot Merkle trees?) as well.


Regards,
ZmnSCPxj

From jlrubin at mit.edu  Wed Jul  7 05:58:15 2021
From: jlrubin at mit.edu (Jeremy)
Date: Tue, 6 Jul 2021 22:58:15 -0700
Subject: [bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was
 CheckSigFromStack for Arithmetic Values]
Message-ID: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>

Dear Bitcoin Devs,

As mentioned previously, OP_CAT (or similar operation) can be used to make
Bitcoin "quantum safe" by signing an EC signature. This should work in both
Segwit V0 and Tapscript, although you have to use HASH160 for it to fit in
Segwit V0.

See [my blog](https://rubin.io/blog/2021/07/06/quantum-bitcoin/) for the
specific construction, reproduced below.

Yet another entry to the "OP_CAT can do that too" list.

Best,

Jeremy
-----


I recently published [a blog
post](https://rubin.io/blog/2021/07/02/signing-5-bytes/) about signing up
to a
5 byte value using Bitcoin script arithmetic and Lamport signatures.

By itself, this is neat, but a little limited. What if we could sign longer
messages? If we can sign up to 20 bytes, we could sign a HASH160 digest
which
is most likely quantum safe...

What would it mean if we signed the HASH160 digest of a signature? What the
what? Why would we do that?

Well, as it turns out, even if a quantum computer were able to crack ECDSA,
it
would yield revealing the private key but not the ability to malleate the
content of what was actually signed.  I asked my good friend and
cryptographer
[Madars Virza](https://madars.org/) if my intuition was correct, and he
confirmed that it should be sufficient, but it's definitely worth closer
analysis before relying on this. While the ECDSA signature can be malleated
to a
different, negative form, if the signature is otherwise made immalleable
there
should only be one value the commitment can be opened to.

If we required the ECDSA signature be signed with a quantum proof signature
algorithm, then we'd have a quantum proof Bitcoin! And the 5 byte signing
scheme
we discussed previously is a Lamport signature, which is quantum secure.
Unfortunately, we need at least 20 contiguous bytes... so we need some sort
of
OP\_CAT like operation.

OP\_CAT can't be directly soft forked to Segwit v0 because it modifies the
stack, so instead we'll (for simplicity) also show how to use a new opcode
that
uses verify semantics, OP\_SUBSTRINGEQUALVERIFY that checks a splice of a
string
for equality.

```
... FOR j in 0..=5
    <0>
    ... FOR i in 0..=31
        SWAP hash160 DUP <H(K_j_i_1)> EQUAL IF DROP <2**i> ADD ELSE
<H(K_j_i_0)> EQUALVERIFY ENDIF
    ... END FOR
    TOALTSTACK
... END FOR

DUP HASH160

... IF CAT AVAILABLE
    FROMALTSTACK
    ... FOR j in 0..=5
        FROMALTSTACK
        CAT
    ... END FOR
    EQUALVERIFY
... ELSE SUBSTRINGEQUALVERIFY AVAILABLE
    ... FOR j in 0..=5
        FROMALTSTACK <0+j*4> <4+j*4> SUBSTRINGEQUALVERIFY DROP DROP DROP
    ...  END FOR
    DROP
... END IF

<pk> CHECKSIG
```

That's a long script... but will it fit? We need to verify 20 bytes of
message
each bit takes around 10 bytes script, an average of 3.375 bytes per number
(counting pushes), and two 21 bytes keys = 55.375 bytes of program space
and 21
bytes of witness element per bit.

It fits! `20*8*55.375 = 8860`, which leaves 1140 bytes less than the limit
for
the rest of the logic, which is plenty (around 15-40 bytes required for the
rest
of the logic, leaving 1100 free for custom signature checking). The stack
size
is 160 elements for the hash gadget, 3360 bytes.

This can probably be made a bit more efficient by expanding to a ternary
representation.

```
        SWAP hash160 DUP <H(K_j_i_0)> EQUAL  IF DROP  ELSE <3**i> SWAP DUP
<H(K_j_i_T)> EQUAL IF DROP SUB ELSE <H(K_j_i_1)> EQUALVERIFY ADD  ENDIF
ENDIF
```

This should bring it up to roughly 85 bytes per trit, and there should be
101
trits (`log(2**160)/log(3) == 100.94`), so about 8560 bytes... a bit
cheaper!
But the witness stack is "only" `2121` bytes...

As a homework exercise, maybe someone can prove the optimal choice of radix
for
this protocol... My guess is that base 4 is optimal!

## Taproot?

What about Taproot? As far as I'm aware the commitment scheme (`Q = pG +
hash(pG
|| m)G`) can be securely opened to m even with a quantum computer (finding
`q`
such that `qG = Q` might be trivial, but suppose key path was disabled, then
finding m and p such that the taproot equation holds should be difficult
because
of the hash, but I'd need to certify that claim better).  Therefore this
script can nest inside of a Tapscript path -- Tapscript also does not
impose a
length limit, 32 byte hashes could be used as well.

Further, to make keys reusable, there could be many Lamport keys comitted
inside
a taproot tree so that an address could be used for thousands of times
before
expiring. This could be used as a measure to protect accidental use rather
than
to support it.

Lastly, Schnorr actually has a stronger non-malleability property than
ECDSA,
the signatures will be binding to the approved transaction and once Lamport
signed, even a quantum computer could not steal the funds.






--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/3942eac0/attachment-0001.html>

From billy.tetrud at gmail.com  Wed Jul  7 03:20:38 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 6 Jul 2021 20:20:38 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <e843b5c28690557402b72fcd158dc1c2@riseup.net>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
Message-ID: <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>

>  As far as I know the ?claw back? mechanism doesn?t exist in Bitcoin
system, and probably most Bitcoiners won?t be agree on it.

It certainly doesn't. And it would definitely be a hard sell.

> It looks the miners still can abuse Sabu, but as I told before the miner
or better say the mining pool must be issuer .. or must be creditor .. or
collaborate one of them in a
conspiracy.

Yes. But it certainly incentivizes miners to become creditors and scam
people. Even if a small miner who mines one block a year does this, they
can mine all Guarantee Transactions in their possession. Larger miners that
mine one block every few days can scam that much more often. Even with $5
credits, that could be an extra $9000 gained in a block. That's pretty
substantial when fees are totaling around $45,000 per block.

> would be resolved by a slightly upgrade in Bitcoin protocol by applying
the BIPxxx ?for flagging/unflagging promised UTXOs?

As others have mentioned tho, doing something like that would be at very
least quite complex, and at worst impossible to do securely. The whole
reason why bitcoin's blockchain exists in the first place is to be a single
source of truth for transactions. The mempool is not a source of truth for
consensus. The Sabu network could not be a source of truth either for
consensus, without some serious innovations (that may not be possible). It
isn't as simple as you seem to be thinking.

>  The new transaction will use same 40,000 UTXO as input and the outputs
will be 6,500 Sat for creditor (he pays 2,500 Sat for transaction fee)
4,500 Sat for creditor 2

This is the part I was unable to find/understand quickly enough in the
original write up. So for creditor 1 to pay creditor 2, a new main
transaction and guarantee transaction are created that credit the
appropriate people, right? FYI, the MT and GT acronyms make it harder for
me to read/understand, so I'm preferring to write them out. But that helps.
Let me write this out in a different (more compact) way:

1. Creditor A $5 -> Issuer

2. Issuer creates and shares transactions:

Main Transaction (40k sats):
* Issuer: 19k sats
* Creditor A: 11k sats
* Fee: 10k sats (4k from creditor, 6k from issuer)

Guarantee Transaction (40k sats):
* Issuer: 13,300 sats
* Creditor A: 1650 sats
* Fee: 25,050 sats

3. Creditor A, 6k sats -> Creditor B. Issuer creates and shares
transactions:

Main Transaction (40k sats):
* Issuer: 19k sats
* Creditor A:  6,500 sats
* Creditor B:  4,500 sats
* Fee: 10k sats (4k from creditor, 6k from issuer)

Guarantee Transaction (40k sats):
* Issuer: 13300 sats
* Creditor A: 975 sats
* Creditor B: 675 sats
* Fee: 25050 sats

Is this right?

> The miner attack is just a failed plan as I explained before

I thought you acknowledged that the miner attack is an issue above. No?

>> Sabu has slightly greater risk comparing lightning
> It is not true,

What I mean is that a violation of trust results in more damaging effects
with Sabu than with lightning. In lightning, if your channel partner
cheats, at worst you must simply pay a normal transaction fee. With Sabu,
if a creditor cheats, you will likely pay an abnormally large transaction
fee. This is what I mean by "greater risk". Some attackers are what's known
as griefers - these are people willing to spend time and money hurting
someone else, even if they don't make a profit from it (other
than schadenfreude). It seems clear there is a greater risk of being
griefed in Sabu than in lightning.

Furthermore, while in lightning, if you perform the protocol properly, your
funds can never be stolen except in very extreme circumstances (eg
widespread long-running network congestion that prevents confirming a
revoke transaction). By contrast, Sabu has a significant likelihood that a
cheating transaction could be mined instead of the guarantee transaction.
Perhaps the likelihood is approximately 2 seconds / 10 minutes (0.3%
chance), but a 0.3% is clearly larger than approximately 0% chance in
lightning. Again, this is another part of what I mean by "higher risk".

These are both real counterparty risks that you shouldn't simply ignore. It
may be true that no rational actor will attempt an attack, however not all
actors are rational. People also make mistakes, write buggy software, etc
etc. The existence of risk doesn't ruin your idea - every protocol has
risks. But identifying the specific risks is the only way to compare the
properties against alternatives (like on chain transactions or the
lightning network). I think its important to acknowledge these risks in
your write up.

> I explained before this kind of attacks will not happened never

If people use your protocol, some will inevitably use it wrong. Those that
use it wrong should be the ones that pay the price for it - but it is a
downside of the protocol if the counter party of the person that makes a
mistake (or attempts something malicious) is harmed as a result. Again,
these kinds of trade offs are ok, but you should not be assuming that
attacks like this will never happen. They will happen sometimes. You must
assume that. The question is what is the result when an attack is
attempted? And how will that affect what kinds of actors will attempt an
attack (malicious, profit seeking, honest, stupid, wreckless, incompetent,
other types of actors etc etc)?

> I didn?t find any case Lightning can compete with Sabu.

As I explained above related to risk, there are trade offs. I would like to
see in your write up a clear list of these trade offs. The additional risk
(as I explained it above) is one trade off. It sounds like there are limits
in which a creditor or issuer can safely rely on incentives to prevent
attacks. Did you specify what those limits are? The Lightning network also
has limits - eg a lightning node can't allow its channel partner to spend
100% of their coins without taking on additional risk of attack. How do
those limits compare in Sabu? For example, an issuer couldn't allow any
creditor to spend so much of their credited bitcoin that their credit goes
below the amount they would receive in any past Guarantee Transaction
without taking on the risk that the creditor would post that guarantee
transaction and receive coins they shouldn't own anymore. I would love to
see a more detailed comparison of Sabu to lightning.

If your protocol works out, there are obvious benefits: transactions that
could be done with no on-chain footprint. However, even if the protocol
works out, there are trade offs and those trade offs should be made very
clear. Even if the comparative downsides are small.

~BT

Hi Billy
> > high-level overview of how all the pieces (How Sabu protocol works).
> > how normal transactions happen in their entirety.
> Ok, lets re-explain Sabu. In Sabu protocol we have two type of actors.
> The issuers who own Bitcoin (they own UTXOs on Bitcoin blockchain), and
> the creditors who will own Bitcoins (the UTXOs on Bitcoin blockchain),
> if the issuer or the creditor sends the prepared transaction to Bitcoin
> network. But for know creditors have the transaction in their hand.
> Before sending this transaction to Bitcoin network it acts (in Sabu
> protocol and Sabu network) as a liability of issuer.
> The story always starts from issuer, the person who get money or goods
> or services from a creditor and in exchange creates and sings a valid
> Bitcoin transaction by which the issuer spends his UTXO and as a one of
> the outputs of the transaction, there will be an output for creditor?s
> address equal to the money issuer already get paid.
> This transaction is a valid transaction which is signed ?only? by
> issuer. The outputs of transaction are just and exact balance of the
> parties (issuer and creditor).
> Lets, imagine the creditor payed 5$ (almost equal to 15,000 Sat) to
> issuer. Thus, issuer will create and sign a transaction by which he
> spends 40,000 Sat and the outputs will be
> 11,000 for creditor (the creditor has to pay 4,000 Sat in favor of
> transaction fee),
> 10,000 for Bitcoin-transaction-fee (4,000 by creditor and 6,000 by
> issuer) and
> 19,000 change back to issuer account address.
> It is our Main Transaction (MT) which is a pretty normal and valid
> transaction.
> Alongside the MT, issuer creates and signs a Guarantee Transaction (GT).
> In GT issuer spends same 40,000 Sat UTXO as input, and as outputs
> the creditor will get 15% of his 11,000 Sat in Main Transaction. Thus
> the creditor output will be 1,650 Sat and the rest of creditor?s money
> (11,000 ? 1,650 = 9,350 Sat) will be added to transaction fee.
> In GT also issuer will lose a part of his money. New output for issuer
> will be 19,000 * 70% = 13,300 and the rest will be added to transaction
> fee (19,000 ? 13,300 = 5,700 Sat)
> Thus, the new transaction fee in GT will be 10,000 + 9,350 + 5,700 =
> 25,050 Sat
> Now the creditor has 2 valid transactions (MT and GT) in his hands. He
> can send either MT or GT or both to Bitcoin Network. But in all cases,
> he will lose a portion of his money in favor of transaction fee (miner?s
> income). So, rationally he will never send transactions to Bitcoin
> network unless he wants consciously hurt himself.
> The creditor always prefers to spend his credit inside the Sabu
> protocol. It is ?how normal transactions happen in their entirety.?
> Creditor has equal to 15,000 Sat credit. Say he wants to buy a caffe
> worth 6,000 Sat. He has to ask the issuer to nullify previous MT and GT,
> and create and sign new transaction and cut 6,000 Sat from his credit
> and transfer it to a new creditor (say C2).
> The new transaction will use same 40,000 UTXO as input and the outputs
> will be
> 6,500 Sat for creditor (he pays 2,500 Sat for transaction fee)
> 4,500 Sat for creditor 2 (he has to pay 1,500 Sat for transaction fee as
> well)
> 10,000 for Bitcoin-transaction-fee (4,000 by two creditors and 6,000 by
> issuer) and
> 19,000 change back to issuer account address.
> This is the new MT, and as you can see the C1 and C2 have their new
> credit in transaction.
> You can calculate the new GT as well.
> Note: due to simplicity I just rounded the numbers and skipped the
> Sabu-transaction-fee
> I just wrote this long story to explain how creditors just transfer
> money in between.
> If we take a snapshot of Sabu network, we will see millions of valid
> transactions flowing in network and none of the issuers or creditors
> will send these transactions to Bitcoin network due the transaction fee,
> while in Bitcoin blockchain nothing is changed! The UTXOs are untouched,
> and no one can say which UTXO is promised to who.
> It is a pretty secure off-chain protocol.
> Although I expected more Bitcoiners to react about Sabu proposal and
> comment for or against it, so far, I have not seen any serious criticism
> or real threat about protocol.
> The miner attack is just a failed plan as I explained before.
> > Sabu has slightly greater risk comparing lightning
> It is not true, since creditors can manage they risk, and limit their
> credit to 5, 10 or 20 Dollar or 50$. It is totally up to creditor to
> accept more liability from issuers or not.
> The creditor can keep his credit around a fix number. That is, the
> creditor spends a part of his credit and then again increase its credit.
> Let imagine you already payed 5$ to a issuer and you got 15,000 Sat
> credit in your wallet. So, you will spend this 15,000 Sat (buy coffee,
> ice-cream, etc.) till your wallet run out of Satoshi and again you will
> pay another 5$ to issuer and get new 15,000 sat credit. Since all of
> these transactions has near zero cost you are not obliged to charge your
> wallet 200$ in one shot.
> It is absolutely low risk deal. In worst case the creditor (you) will
> lose 5$. And as I explained before this kind of attacks will not
> happened never. And as you told Sabu provides cheaper and a larger
> number of transactions.
> > This would be essentially worse than the lightning network in some ways,
> Disagree! Please explain the scenario exactly. I didn?t find any case
> Lightning can compete with Sabu.
> > ledger of accounts and their balances, along with proof that the entity
> owns?
> It is almost what I designed in Sabu. They are doc-watcher servers. They
> are a set of records of UTXOs and the proper Merkle root hash of related
> transaction in Sabu network. The intention was stopping issuer from
> spend and promises same UTXO to different people (that they are not
> aware of the existence of the other). So, any individual creditor (or
> their software) could verify that total liabilities (in account
> balances) are less than the half of the total bitcoins the entity owns.
> And if something doesn't match up, they won?t yell, instead they refuse
> the deal in first place, or send the GT to Bitcoin network and hurt the
> cheater issuer by slashing his money. it is ?Tit-for-tat?.
> > I think it likely has critical security holes. Perhaps you can fix them!
> There is no critical security hole. Please refer it by facts, numbers
> and proves.
> I think I already fixed all critics.
>
> Billy! I am actively working on this proposal and if no one cannot show
> a real problem or security issue in the project, I will start
> implementing it.
> Just imagine people regularly using Sabu protocol and send/receive
> Bitcoin (Satoshi) in billions of small amount transactions every day.
> This protocol will outspread Bitcoin and will attract a new crowd of
> penny investors to Bitcoin. The people who can afford 20$ or less
> monthly to invest on Bitcoin.
> Sabu brings Bitcoin to a whole new life.
> It will be the true scalable and mass adaption, and I do not know how to
> attract more real Bitcoin fans to this proposal!
> Guys! Here is the Bitcoin renascence.
> Maybe you can help it.
> Regards
> Raymo



On Sat, Jul 3, 2021 at 1:02 AM <raymo at riseup.net> wrote:

> Hi Billy,
>
> > What if it was possible for the creditor to claw back the funds
> As far as I know the ?claw back? mechanism doesn?t exist in Bitcoin
> system, and probably most Bitcoiners won?t be agree on it.
> Even if we want to add claw back to Bitcoin in general, and Sabu in
> particular, it would add too complexities and uncertainty to Bitcoin.
> So, it would be better to not touch that part, instead focusing on
> reduce the cheating risk by putting some penalty for both issuers,
> creditors and miners.
> We already have the penalties for both issuers and creditors.
> It looks the miners still can abuse Sabu, but as I told before the miner
> or better say the mining pool must be issuer (to be able to sign the
> promised UTXO in cheating way) or must be creditor (in order to have a
> copy of GT and not lose his money in favor of a stranger miner. Remember
> the fact that creditor will lose 70% of their money in favor of Bitcoin
> transaction fee in a typical GT) or collaborate one of them in a
> conspiracy. Otherwise, there will be no economic benefit in this attack.
>
> All these 3 cases of the attacks, theoretically could be happened, but
> the risk to reward ratio is enough high to hinder potential malevolent
> from a practical act.
> Even this very small risk of miner attacks (which don?t care the attack
> costs, since he is not interested in economic benefit, but he wants to
> ruin Sabu), would be resolved by a slightly upgrade in Bitcoin protocol
> by applying the BIPxxx ?for flagging/unflagging promised UTXOs?.
> I am not in rush to apply this upgrade on Bitcoin protocol, instead I am
> actively working in order to realize the Sabu protocol and Gazin wallet.
> Later the Sabu community will carry the BIPxxx.
>
> Best
>
> On 2021-07-02 17:57, Billy Tetrud wrote:
> > Thanks for the details Raymo. A thought occurred to me. Given the fact
> > that miners can abuse this system without penalty, it would be useful
> > to be able to fix this. What if it was possible for the creditor to
> > claw back the funds even if the cheating transaction was mined instead
> > of the guarantee transaction? Let's say there was a way to sign a
> > transaction that gives the receiver of that transaction the ability to
> > override any other transaction that uses the UTXO? If this were
> > possible, the issuer could give the creditor this kind of transaction
> > as the guarantee transaction, and in the case a cheat was done, the
> > creditor could still use the GT to reallocate that UTXO to themselves.
> >
> > Now there are issues with this. First of all, it could give anyone the
> > ability to double spend. So it would be prudent to limit this in some
> > way. The revocation probably should only be valid for up to 6 blocks,
> > such that if the transaction has 6 confirmations, it can no longer be
> > reallocated (thus preserving the 6 block finality rule). It could also
> > be required that the UTXO be marked as opting into this behavior (so
> > receivers would know about the possibility it could get revoked). This
> > second requirement would require Sabu issuers to make an on-chain
> > transaction to set themselves up as an issuer.
> >
> > Another issue is that this would make it possible for transactions to
> > expire. Any claw-back transaction would expire 6 blocks after the
> > initial transaction happened. This has been generally avoided in
> > bitcoin, but I think the relevant issues are solvable. You can find
> > additional discussion of that in this thread [1].
> >
> > I would imagine this kind of ability would be pretty controversial,
> > but since it can close out the possibility for miners to escape
> > punishment, it could make this protocol viable.
> >
> > On Thu, Jul 1, 2021 at 3:15 PM <raymo at riseup.net> wrote:
> >
> >> Hi Erik
> >>
> >> Please correct me if I misunderstood.
> >>
> >>> email is fully compromised.
> >>
> >> What I got is:
> >> Email is not good because the sender and receiver are compromised.
> >> Email is not good because the message content is revealed.
> >> I can claim same argue about any other client/server model. Since
> >> the
> >> server (website) service provider will ask some sort of KYC. And
> >> even if
> >> the server uses end-to-end encryption, the provider company still
> >> can
> >> read the packets content.
> >> In my model the passive listener only can discover who is
> >> communicate to
> >> whom and make a graph of connections. Although it is a threat for
> >> privacy but the server/client model has this flaw inherently, since
> >> provider already knew everything about everyone. In my model at
> >> least
> >> users can make some fake connections and send some fake emails in
> >> order
> >> to inject noise to communications.
> >> Please note the fact that entire communication between mobile
> >> wallets
> >> (via emails) are asymmetric PGP encrypted. The PGP keys are
> >> controlled
> >> by end users unlike ALL pretending secure messengers (e.g whatsApp,
> >> signal, zoom,?).
> >> If you are worried about the way of exchanging PGP public key, you
> >> are
> >> right. The most secure way is in-person PGP key exchanging.
> >> After that for payments the wallets communicate in pgp encrypted
> >> messages and they can transfer Bitcoin address through an PGP
> >> encrypted
> >> cipher, thus no revealing Bitcoin address to public would occur.
> >> Neither
> >> the amounts of transactions will be reviled.
> >> There for it would be a good practice for shops to put their email
> >> and
> >> PGP public key on shop website and/or PGP public key servers,
> >> instead of
> >> putting Bitcoin address on website or using 3rd parties services to
> >> hide
> >> their Bitcoin payment addresses.
> >>
> >> If I missed some points about ?fully compromised? please write
> >> it to me.
> >>
> >>> public keys / addresses are sent
> >> As I told before ALL communication in Sabu are PGP encrypted.
> >>
> >>> other routing data encrypted with public keys
> >>> (not sure how data is routed in sabu)
> >>
> >> Sabu is not responsible for routing at all. It simply sends emails.
> >> Indeed the wallets peer-to-peer network in Sabu is pretty straight
> >> forward. Each mobile wallet has one email address as its handler and
> >> identifier in mobile-wallets-network. Each mobile can send message
> >> to
> >> another mobile by knowing its email address and the PGP public key.
> >> This information can be prepared in first face-to-face contact of
> >> mobile
> >> owners, or later (something like signing the other?s public key in
> >> web
> >> of trust) when a creditor wants to spend his money and transfer it
> >> to
> >> another creditor. The creditor1 send the signed money transfer
> >> request
> >> alongside the email and public key of creditor2 all in a PGP
> >> encrypted
> >> message to issuer.
> >>
> >>> separate the Sabu protocol from the app... allow others to
> >> implement
> >>> desktop version, or other versions that use other routing systems
> >>
> >> Indeed, it is my approach too. As I told before users will decide
> >> between an unstoppable, permission less, self-sovereignty and
> >> decentralized pure peer-to-peer communication network (with some
> >> resolvable privacy issues) or some efficient, privacy-mimic central
> >> limited network.
> >>
> >>> you can allow direct-entry of a BIP-word-representation
> >>> of a public key/address to avoid privacy/central system concerns
> >> Agree. Actually, I was thinking about an easy mechanism to share
> >> your
> >> public key like what you suggested here.
> >> But what I consider for a ?central system concerns? is the
> >> ability of
> >> communication without dependency to any company.
> >> As an example, what can you do if the twitter bans your account?
> >> Nothing! Your content and entire connections will be lost.
> >> But if you form your friends list in your mobile (or computer) and
> >> have
> >> their PGP public keys and they have yours, and use email as a dual
> >> purpose tool. First as a handler (the tool for finding and to be
> >> found
> >> in internet) and second as a communication tool.
> >> Thus, no one can stop you, ban you or limit you to send/receive
> >> transaction to/from anyone.
> >> What I am trying to say is using email is far better than account
> >> (username) in a limited central service like twitter, Facebook,
> >> telegram... or even in future Sabu servers!
> >> You have your connections under your control in your phone. You can
> >> easily change your email and use a new email or even a new service
> >> provider without losing your connections and your control over it.
> >> You just sign your new email address and send it to your friends
> >> circle
> >> and notify them about changes.
> >> Of course, email is not good for millions of followers but it is
> >> obviously good for managing your payment network of hundreds of
> >> people
> >> (either issuers or creditors).
> >>
> >> Best
> >> Raymo
> >>
> >> On 2021-07-01 20:49, Erik Aronesty wrote:
> >>> your protocol should always assume the email system is fully
> >>> compromised, and only send public information over email:
> >>>
> >>> - public keys / addresses are sent
> >>> - other routing data encrypted with public keys (not sure how data
> >> is
> >>> routed in sabu)
> >>>
> >>> your end user should be able to verify public keys  / addresses
> >>>
> >>> - use QR-codes
> >>> - phone calls with users reading BIP words out loud
> >>> - other in-person information exchange
> >>>
> >>> separate the Sabu protocol from the app... allow others to
> >> implement
> >>> desktop version, or other versions that use other routing systems
> >>>
> >>> -  you can allow direct-entry of a BIP-word-representation of a
> >> public
> >>> key/address to avoid privacy/central system concerns
> >>>
> >>> On Thu, Jul 1, 2021 at 4:20 PM raymo via bitcoin-dev
> >>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>
> >>>> Hi Billy,
> >>>> Sorry for late reply. Let?s jump in proposal.
> >>>>
> >>>>> Some more information about the benefits of this approach vs
> >> alternatives (mainly lightning)
> >>>> The most important different is unlike the lightning, in Sabu no
> >> one
> >>>> have to open a channel and pay Bitcoin transaction fee,
> >> subsequently no
> >>>> one has to close channel and pay another Bitcoin transaction fee.
> >> It is
> >>>> the huge improvement since it drops the overhead cost of
> >> transactions.
> >>>> So, it will be more convenience to trade under Sabu protocol.
> >>>> In Sabu none of parties of a transaction are obliged to block
> >> money in
> >>>> any kind of smart contract or any other m of n signature accounts
> >>>> on-chain, so it provides more privacy.
> >>>> Since Sabu protocol is designed to motivate people to circulate
> >>>> transactions (AKA debt documents) in Sabu network, if every actor
> >> act
> >>>> rationally no one will aware how much money transferred from who
> >> to
> >>>> whom.
> >>>> In case of fraudulent activity by issuer, the creditor will send
> >>>> Guarantee Transaction (GT) to Bitcoin network in order to
> >> recapture the
> >>>> part of his credit. So, in this case the transaction is literally
> >>>> recorded on bitcoin blockchain.
> >>>> There is only one another reason to recording transaction on
> >> Bitcoin
> >>>> blockchain. Where one creditor eager to pay Bitcoin transaction
> >> fee in
> >>>> order to aggregate thousands or even millions different small
> >> amount
> >>>> debt-documents in a single transaction on Bitcoin blockchain.
> >>>> despite these two cases, the rest of transactions all occur in
> >> the Sabu
> >>>> network (supposed to be over 99%). Thus, no footprint no
> >> bottleneck and
> >>>> no over process.
> >>>>
> >>>> Another important power point of Sabu is its pure-peer-to-peer
> >> network
> >>>> architecture. In Sabu the mobile wallets communicating to each
> >> other
> >>>> directly without any central server. There is no centralization
> >> at all.
> >>>> As a result, there will be no routing as well.
> >>>> Since only issuer and creditors are aware of the content of
> >> transaction
> >>>> (who pay how much to whom) it is a huge privacy improvement,
> >> which
> >>>> doesn?t exist in other layer 2 solutions.
> >>>>
> >>>> About the usability of Sabu, although the protocol based on the
> >>>> collaborating 2 different peer-to-peer network and 3 classic
> >>>> server/client networks, but the end user (mobile wallet user)
> >> doesn?t
> >>>> see any of these complexities.
> >>>> The end user simply installs the mobile/desktop wallet and add
> >> her/his
> >>>> friends to his phonebook by adding their email address or
> >> scanning their
> >>>> email (and/or PGP public key). After that s/he can immediately
> >> start to
> >>>> send/receive Bitcoin through Sabu network. Entire communications
> >> between
> >>>> wallets are PGP encrypted.
> >>>> Another good point in Sabu design is, the 12 seed words are using
> >> for
> >>>> both Bitcoin wallet private key and the PGP private key. So, it
> >> is the
> >>>> key of user wealth and its identity as well. For more details,
> >> please
> >>>> read my previous answer to Alex Schoof.
> >>>> The issuer, by using his UTXOs and selling them to creditors earn
> >> money.
> >>>> the issuer creates the debt document (transaction) by which
> >> promises to
> >>>> creditor an amount of satoshi. These debt documents are valid
> >> Bitcoin
> >>>> transaction. The only difference is these transactions are
> >> intended to
> >>>> circulate in Sabu protocol instead of sending to Bitcoin
> >> blockchain.
> >>>> Each transaction is a small money transfer. 40,000 Satoshi as
> >> input and
> >>>> maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as
> >> Bitcoin
> >>>> transaction fee.
> >>>> The creditors will use these received transactions as money and
> >> will pay
> >>>> it in exchange of goods or services. For each transaction the
> >> creditor
> >>>> pays 10 Satoshi as Sabu-transaction-fee to issuer.
> >>>> Sabu is not custodial service and the UXTOs are always under
> >> issuer
> >>>> control, unless issuer or creditor send the signed transaction to
> >>>> Bitcoin network. When the transaction was recorded in Bitcoin
> >>>> blockchain, the creditor can spend proper UTXO in Bitcoin
> >> network.
> >>>> Imagine million people use their UTXOs in Sabu, they are issuer
> >> and
> >>>> issue/update/cancel million transactions per second. All they
> >> need is a
> >>>> mobile wallet. On the other hand, every one by knowing an issuer
> >> can buy
> >>>> some Satoshi (whit absolutely no KYC), even 1 Dollar or less, and
> >> spend
> >>>> it, this time Alice really can buy caffe by Bitcoin ;)
> >>>> The Bar can install the mobile wallet and every day receives
> >> thousands
> >>>> of debt documents (transactions), each worth maximum 20,000
> >> Satoshi in
> >>>> exchange of coffee. And every evening aggregates those small
> >>>> transactions to one single transaction and send it to Bitcoin
> >> network.
> >>>>
> >>>>
> >>>> The security model of Sabu is pretty straight forward.
> >>>> Issuer is the owner of UTXO(s) which will be used in
> >> transactions. The
> >>>> issuer is and will the only person who creates transactions and
> >> sign
> >>>> them. The transactions are valid transaction which either issuer
> >> or
> >>>> creditor can send them to Bitcoin network, but they will never
> >> send
> >>>> these transactions to Bitcoin network, because of the high
> >> Bitcoin
> >>>> transaction fee for each single transaction.
> >>>> Since issuer is the only one who can sign transaction (spend
> >> UTXOs),
> >>>> there is a risk of issuer cheating. And no one can stop issuer
> >> from
> >>>> cheating, because these are his UTXOs and he has the proper
> >> private
> >>>> keys.
> >>>> The Sabu solution is Guarantee transaction. It is a valid
> >> transaction
> >>>> that issuer has to sign it alongside the Main transaction. In GT
> >> both
> >>>> issuer and creditor cut a part of their output in favor of
> >> Bitcoin
> >>>> transaction fee.
> >>>> We suppose miners always seeking for more profit, thus in a case
> >> there
> >>>> are 2 or more transaction are spending same UTXO as input, miner
> >> will
> >>>> choose transaction with highest feeRate. There is no economically
> >>>> benefit for issuer to cheat creditors and pay less transaction
> >> fee
> >>>> simultaneously. So rationally the issuer won?t cheat creditor.
> >>>> It was the simplest explanation of Sabu security model.
> >>>>
> >>>>> I agree with others that using email is probably not
> >> appropriate for a protocol like this. I would highly recommend
> >> making your protocol transport-agnostic, allowing users of your
> >> protocol to use any transport they want.
> >>>> Indeed, the protocol is transparent-agnostic, if I insist of
> >> email as a
> >>>> user identifier and communicating tool is because of the idea of
> >>>> reforming part of internet architecture and make it more
> >> decentralized.
> >>>> The wallet users can choose classic architecture. In this case
> >> mobile
> >>>> wallets will connect to a central server and communicate through
> >> that
> >>>> server (pretty much like all existed mobile wallets). While some
> >> users
> >>>> decide to use a pure peer-to-peer communication. I knew email has
> >> some
> >>>> privacy issues but as always it is a tradeoff. Users can decide
> >> between
> >>>> an unstoppable, permission less, self-sovereignty and
> >> decentralized pure
> >>>> peer-to-peer communication network (with some resolvable privacy
> >> issues)
> >>>> or some efficient central limited network.
> >>>> Let me know the critics about email. Hopefully this would lead us
> >> to
> >>>> improve email instead of letting it die. I strongly suggest email
> >>>> because it is the ONLY neutral, free ?nonproprietary? and
> >> open
> >>>> protocol/technology for communication in the world that its
> >>>> infrastructure is well-established and is accessible all over the
> >> glob.
> >>>>
> >>>> I tried to explain it more, hope was useful. By the way the
> >> complete
> >>>> explanation is here
> >>>>
> >>
> >
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
> >>>>
> >>>>
> >>>>
> >>>> Regards
> >>>> Raymo
> >>>>
> >>>>
> >>>>
> >>>> On 2021-06-22 18:20, Billy Tetrud wrote:
> >>>>> I would be interested in seeing some more information about the
> >>>>> benefits of this approach vs alternatives up front in this
> >> write up.
> >>>>> Eg how does the security, cost, usability, and privacy compare
> >> to the
> >>>>> lightning network, which would be the most likely competitor to
> >> this
> >>>>> idea. It seems clear that there is more counterparty risk here,
> >> so it
> >>>>> would probably also be very helpful to compare against
> >> traditional
> >>>>> custodial solutions as well. If you have specific claims on how
> >> this
> >>>>> system is better than eg lightning in certain contexts, it
> >> would be
> >>>>> far easier to evaluate the protocol against those claims, and
> >> would
> >>>>> also be a lot easier for readers to be motivated to read the
> >> whole
> >>>>> protocol and do a more full analysis.
> >>>>>
> >>>>> I agree with others that using email is probably not
> >> appropriate for a
> >>>>> protocol like this. I would highly recommend making your
> >> protocol
> >>>>> transport-agnostic, allowing users of your protocol to use any
> >>>>> transport they want.
> >>>>>
> >>>>> On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
> >>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>>
> >>>>>> I think you're making a number of assumptions about mining
> >> that are
> >>>>>> not accurate.
> >>>>>>
> >>>>>>> First of all, how much chance in finding next block the
> >> corrupted
> >>>>>> miners have? One percent of all Bitcoin hash powers? Or
> >> maximum 5
> >>>>>> percent or 10? The cheaters must come up in dividing that 1.2
> >>>>>> Bitcoin between. After all the risk/reward must fit them. They
> >> can
> >>>>>> not be a big mining pool since there is no benefit, so they
> >> will be
> >>>>>> small miners with low hash rate. If they solve the puzzle and
> >>>>>> broadcast the block, no one in the entire Bitcoin network has
> >> block
> >>>>>> transactions or seen it before in their mempool!
> >>>>>>
> >>>>>> You're making the assumption that miners won't build on top of
> >> a
> >>>>>> block
> >>>>>> with transactions they have not seen before or transactions
> >> that may
> >>>>>> contain double spends of unconfirmed inputs, this is not how
> >> mining
> >>>>>> works, as long as the block passes the consensus rules
> >> effectively
> >>>>>> all
> >>>>>> miners will mine on top of it by default, this behavior is
> >>>>>> fundamental
> >>>>>> to how mining currently works and is fairly deeply baked into
> >> the
> >>>>>> current mining infrastructure.
> >>>>>>
> >>>>>>> Will they accept this block? In theory it is possible and
> >> have
> >>>>>> 0.01 percent chance but we can eliminate this small
> >> possibilities by
> >>>>>> a simple BIP for miners.
> >>>>>>
> >>>>>> What would this BIP look like? I don't see how this could work
> >> in a
> >>>>>> decentralized way as you would need another way of reaching
> >>>>>> consensus
> >>>>>> on what defines a valid block. Right now the chance is nearly
> >> 100
> >>>>>> percent that a miner will mine on top of the latest valid
> >> block,
> >>>>>> many
> >>>>>> pools(most last I checked) will even mine on the next block
> >> before
> >>>>>> they validate the latest block fully(ie validationless mining)
> >> to
> >>>>>> reduce their orphan rates.
> >>>>>>
> >>>>>>> We suppose the miners always control transactions with
> >>>>>> doc-watchers and avoid accepting transaction with same UTXO
> >> but
> >>>>>> different output.
> >>>>>>
> >>>>>> Miners have different mempool policy/rules for what
> >> transactions
> >>>>>> they
> >>>>>> themselves mine but all miners must mine on the most work
> >> chain of
> >>>>>> valid blocks otherwise they risk their own blocks being
> >> orphaned,
> >>>>>> any
> >>>>>> miner that does not do this is effectively guaranteed to have
> >> their
> >>>>>> block orphaned right now.
> >>>>>>
> >>>>>>> Because of high Bitcoin transaction fee, this guarantee
> >>>>>> transaction will take place in next block, even if other
> >> transaction
> >>>>>> which are using the same UTXO as input existed in mempool.
> >>>>>>
> >>>>>> When a new transaction is broadcast miners do not immediately
> >> start
> >>>>>> mining on a block template that includes that transaction, the
> >>>>>> template won't even be generated immediately when it enters a
> >> miners
> >>>>>> mempool in practice, for bandwidth/network efficiency reasons
> >> mining
> >>>>>> pools batch update the stratum templates/jobs they mine
> >> against so
> >>>>>> there can be significant latency between the time a
> >> transaction is
> >>>>>> actually broadcast and hits the miners mempool and the time
> >> the
> >>>>>> miners
> >>>>>> actually switch to mining on top it, these batched updates are
> >>>>>> essentially like point in time snapshots of the mempool and
> >>>>>> typically
> >>>>>> remain valid(as in the pool will accept shares submitted
> >> against
> >>>>>> that
> >>>>>> job as valid) until the bitcoin network finds the next block.
> >> I
> >>>>>> don't
> >>>>>> think these batch updates are done more often than every 30
> >> seconds
> >>>>>> typically, while often it is on the order of multiple minutes
> >>>>>> depending on the pool.
> >>>>>>
> >>>>>> Regards,
> >>>>>> James
> >>>>>>
> >>>>>> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
> >>>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >>>>>>>
> >>>>>>> Hi,
> >>>>>>> I have a proposal for improve Bitcoin TPS and privacy, here
> >> is the
> >>>>>> post.
> >>>>>>>
> >>>>>>
> >>>>>
> >>
> >
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
> >>>>>>> https://bitcointalk.org/index.php?topic=5344020.0
> >>>>>>> Can you please read it and share your idea about it.
> >>>>>>>
> >>>>>>> Cheers
> >>>>>>> Raymo
> >>>>>>> _______________________________________________
> >>>>>>> bitcoin-dev mailing list
> >>>>>>> bitcoin-dev at lists.linuxfoundation.org
> >>>>>>>
> >> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>>>> _______________________________________________
> >>>>>> bitcoin-dev mailing list
> >>>>>> bitcoin-dev at lists.linuxfoundation.org
> >>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >>>> _______________________________________________
> >>>> bitcoin-dev mailing list
> >>>> bitcoin-dev at lists.linuxfoundation.org
> >>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> >
> > Links:
> > ------
> > [1]
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019050.html
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/d1701ad9/attachment-0001.html>

From billy.tetrud at gmail.com  Wed Jul  7 06:12:24 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 6 Jul 2021 23:12:24 -0700
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>
Message-ID: <CAGpPWDZJ8CbsV+c7vt5w9Ejfa5dER19-uaLL4hKeaiogL1uixA@mail.gmail.com>

Thanks for the clarifications Sanket and Russel!

> OP_TWEAK

Ah gotcha. I'm very much in support of recursive covenants. I was lead to
them as a way to create more efficient and flexible wallet vaults. I
actually wrote a proposal
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/bip-pushoutputstack.md>
for an opcode to add state to an output. Its pretty useless without an
accompanying covenant opcode, but it seems a bit more straightforward than
the tricks you mentioned (op_tweak and otherwise). I don't plan on starting
a discussion on it yet tho, more work to be done on it and other things
to open discussion on first.

In any case, its nice to see so much general agreement on a topic that
could easily be embroidered in contention.

On Tue, Jul 6, 2021 at 9:26 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Russell,
>
> > Hi ZmnSCPxj,
> >
> > I don't believe we need to ban Turing completeness for the sake of
> banning Turing completeness.
>
> Well I believe we should ban partial Turing-completeness, but allow total
> Turing-completeness.
>
> I just think that unlimited recursive covenants (with or without a
> convenient way to transform state at each iteration) are **not** partial
> Turing-complete, but *are* total Turing-complete. (^^)
>
> (The rest of this writeup is mostly programming languages nerdery so
> anyone who is not interested in Haskell (or purely functional programming)
> and programming language nerdery can feel free to skip the rest of this
> post.
> Basically, ZmnSCPxj thinks we should still ban Turing-completeness, but
> unbounded covenants get a pass because they are not, on a technicality,
> Turing-complete)
>
> For now, let us first taboo the term "Turing-complete", and instead focus
> on what I think matters here, the distinction between partial and total,
>
> In a total programming language we have a distinction between data and
> codata:
>
> * Data is defined according to its constructors, i.e. an algebraic data
> type.
> * Codata is defined according to its destructors, i.e. according to a
> "behavior" the codata has when a particular "action" is applied to it.
>
> For example, a singly-linked list data type would be defined as follows:
>
>     data List a where
>         Cons :: a -> List a -> List a
>         Nil :: List a
>
> On the other hand, an infinite codata stream of objects would be defined
> as follows:
>
>     codata Stream a where
>         head :: Stream a -> a
>         tail :: Stream a -> Stream a
>
> For `data` types, the result type for each constructor listed in the
> definition *must* be the type being defined.
> That is why `Cons` is declared as resulting in a `List a`.
> We declare data according to its constructors.
>
> For `codata` types, the *first argument* for each destructor listed in the
> definition *must* be the type being defined.
> That is why `head` accepts as its first argument the `Stream a` type.
>
> This is relevant because in a total function programming language, there
> exists some programming rule that restricts recursion.
> The simplest such restriction is substructural recursion:
>
> * If a function recurs:
>   * Every self-call should pass in a substructure of an argument as that
> argument.
>
> Every program that passes the above rule provably terminates.
> Since every recursion passes in a smaller part of an argument, eventually
> we will reach an indivisible primitive object being passed in, and
> processing will stop recursing and can return some value.
>
> Thus, a programing language that has substructural recursion rule check
> (and rejects programs that fail the substrucutral recursion check) are not
> "Turing-complete".
> The reason is that Turing-complete languages cannot solve the Halting
> Problem.
> But a language that includes the substructural recursion rule *does* have
> a Halting Problem solution: every program that passes the substructural
> recursion rule halts and the Halting Problem is decidable for all programs
> that pass the substructural recursion rule.
> (i.e. we are deliberately restricting ourselves to a subset of programs
> that pass substructural recursion, and reject programs that do not pass
> this rule as "not really programs", so every program halts)
>
> For example, the following definition of `mapList` is valid under
> substructural recursion:
>
>     mapList :: (a -> b) -> (List a -> List b)
>     mapList f Nil            = Nil
>     mapList f (Cons a as)    = Cons (f a) (mapList f as)
>
> The second sub-definition has a recursive call `mapList f as`.
> The second argument to that call, however, is a substructure of the second
> argument `Cons a as` on the LHS of the definition, thus it is a
> substructural recursive call, and accepted in a total programming language.
> *Every* recursion in `mapList` should then be a substructural call on the
> second argument of `mapList`.
>
> Now let us consider the following definition of `fibonacci`:
>
>     -- to use: fibonacci 1 1
>     fibonacci :: Integer -> Integer -> List Integer
>     fibonacci x y = Cons x (fibonacci y (x + y))
>
> The above is not substructural recursive, neither argument in the
> recursive `fibonacci y (x + y)` call is a substructure of the arguments in
> the LHS of the `fibonacci` definition `fibonacci x y`.
>
> Thus, we prevent certain unbounded computations like the above infinite
> sequence of fibonacci numbers.
>
> Now, let us consider a definition of `mapStream`, the similar function on
> streams, using copattern matching rather than pattern matching:
>
>     mapStream :: (a -> b) -> (Stream a -> Stream b)
>     head (mapStream f as) = f (head as)
>     tail (mapStream f as) = mapStream f (tail as)
>
> Now the interesting thing here is that in the substructural recursion
> check, what is being defined in the above stanza is ***not*** `mapStream`,
> but `head` and `tail`!
> Thus, it ignores the `mapStream f (tail as)`, because it is **not**
> recursion --- what is being defined here is `tail`.
>
> Looking at the above stanza, we can see that the `head` definition
> recurses, in the call `head as`.
> The first argument to `head as` is `as`, which is a substructure of the
> first argument of the LHS, `mapstream f as`.
> Similarly for the `tail` definition, there is a recursive call `tail as`
> which is substructural recursive, since the LHS has the first argument as
> `mapStream f as` and `as` is a substructure of that call.
>
> (Indeed, copatterns are an important advance in total programming
> languages, prior to copatterns people were bashing their heads trying to
> figure out a simple algorithm to ensure corecursion termination, and it
> turns out that copatterns make corecursion termination as trivial as
> substructural recursion on the destructurs)
>
> Now let us consider the following alternate definition of `fibonacci`
> which returns a `Stream Integer` rather than a `List Integer`:
>
>     fibonacci :: Integer -> Integer -> Stream Integer
>     head (fibonacci x y) = x
>     tail (fibonacci x y) = fibonacci y (x + y)
>
> The first definition `head (fibonacci x y) = ...` is nonrecursive.
> The sceon definition `tail (fibonacci x y) = ...` is ***also***
> nonrecursive because what is being defined is `tail`, and `tail` does not
> even appear in the RHS of the definition!
>
> With the syntax and its rules defined, let us now consider how to
> implement arbitrary-bound recursion in our total language.
>
> Let us define the following types:
>
>     data RecResult a where
>         Complete ::     a -> RecResult a
>         Continue :: Rec a -> RecResult a
>
>     codata Rec a where
>         step :: Rec a -> RecResult a
>
> `Rec a` is a monad:
>
>     instance Monad Rec where
>         step (return a) = Complete a
>         step (ma >>= f) = case (step ma) of
>                             Complete a   -> Continue (f a)
>                             Continue ma' -> Continue (ma' >>= f)
>         -- pretend we do not have the Haskellian `fail` ^^
>
> The definition of `step (ma >>= f)` is recursive, but it is a
> substructural recursion: we recurse on `(step ma)` but `ma` is a
> substructure of the first argument on the LHS, `ma >>= f`, thus the above
> still is provably corecursive terminating.
>
> The above is sufficient to define an infinite loop:
>
>     infiniteLoop :: Rec a
>     step infiniteLoop = Continue infiniteLoop
>
> The above is still accepted, since there is no recursion involved --- the
> RHS does not contain the function `step` being defined, thus no recursion.
>
> Now the important thing to note here is that the above `Rec` type is a
> perfectly fine definition for the Haskellian `IO` type.
>
> Then, the `main` program, of type `Rec ()`/`IO ()`, would then be passed
> to a driving function, written in C.
> This C function would replace the C-level `main` function, and would just
> call `step` on the Haskell-level `main`.
> If it results in `Complete ()`, the C function exits.
> If it results in `Continue ma`, then it calls `step` again on the `ma` and
> checks the result again, in a loop.
>
>     int main() {
>         HaskellObject* ma = haskell_get_main_function();
>         for (;;) {
>             HaskellObject* result = haskell_step(ma);
>             if (haskell_is_Complete(result))
>                  break;
>             ma = haskell_destructure_Continue(result);
>         }
>         return 0;
>     }
>
> The important point here is that *within* the total language, everything
> terminates.
> We put all the dirty non-termination "outside", in the C function that
> drives the entire processing, and have a very simple infinite loop in it
> that is easy to audit for correctness.
> Then, we can have significantly more confidence in the correctness of our
> program, since any infinite recursion would have to somehow resolve to some
> `IO` type, which explicitly allows for infinite recursion, and we can focus
> auditing on that part of the program alone.
>
> Similarly, when we consider recursive covenants, we note always that there
> has to be some external driving program, written in something other than
> Bitcoin SCRIPT, which will continuously create transactions that will keep
> returning the funds to the same covenant (plus or minus some state update).
> Otherwise, the funds will just sit there behind their protecting SCRIPT,
> just like every other UTXO owned by long-term HODLers.
>
> Such a program that continually pays a fund to "the same" covenant is no
> different, in principle, from the above C driving function for our
> total-functional-programming dialect of Haskell.
>
> Which is to say that I mostly agree with roconnor here (other than on
> exact definition of terms; I think my definition of "Turing-complete" is
> more restrictive than his, such that covenants are not in fact
> **technically** Turing-complete, but that is just semantics and I can live
> with that), I think that the recursive covenants in Bitcoin work
> equivalently to the `codata` types in total functional languages.
> As long as Bitcoin SCRIPT itself is provably terminating, I have no
> objections to the fact that we get arbitrary-bound processing by use of
> covenants, as they are "outside" the SCRIPT and have to be operated
> separately by a separate program.
>
> Indeed, we note as well that we can encode state in other parts of the TX
> anyway, so that we can write something more substantive than `while (true)
> { /* do nothing */ }`.
> So we might as well make it easy on us and just add `OP_TWEAK` (and maybe
> convenience opcodes for building Taproot Merkle trees?) as well.
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/5186d9c3/attachment-0001.html>

From billy.tetrud at gmail.com  Wed Jul  7 06:18:58 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 6 Jul 2021 23:18:58 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAJowKgJEJr=LhYhuQs4zOyskdAwjZT6aEFd-3=rsShLUf7yWJw@mail.gmail.com>
References: <CAGpPWDbTyxMRxX4NM8C3H5+d5+H2PLcnVg_8hw8=TsBgOxLtLA@mail.gmail.com>
 <CAJowKgJEJr=LhYhuQs4zOyskdAwjZT6aEFd-3=rsShLUf7yWJw@mail.gmail.com>
Message-ID: <CAGpPWDa3uVxa+LR5JMmTjkgYTwFH9wWLChekg=8wCdtQ2=9eQg@mail.gmail.com>

I wanted to relay an interesting related link that Melvin PMed me:
https://petertodd.org/2016/commitments-and-single-use-seals

@Aronesty
Thanks, that system looks interesting, I'll have a closer look!

@Voskuil
I think we must disagree on at least one fundamental point. I'm finding
myself disagreeing with most of what you're saying.

> If perfect is not possible, it?s not possible. It reduces to trust, which
is the status quo.

Let not perfect be the enemy of good. Trust cannot be eliminated.
Perfection cannot be achieved. However trust can be reduced further than it
exists today, and we can clearly make things better than they are now. Are
you really saying that if its not perfect, its worthless?

> All ?users? need to simultaneously share their individual and temporary
audits with each other (ie publicly).

This is not the case. In both the mechanism I briefly described and Peter
Todd's mechanism from Melvin's link (top of this message), users need not
share any information with other users unless that information is "my
balance doesn't match the record". It doesn't even need to be in a timely
manner if these records are committed to the blockchain - one could
theoretically look back years and compare their personal records to the
records published by the custodian, and then tell the community about it if
they don't match. All that is required is that a critical mass of users
verify their balance (ideally using software that regularly checks
automatically).

> It is not hard to spot price inflation

I don't know why you think that's the case. Inflation is today vehemently
argued about. Are high real estate prices indications of inflation? What
about recovering stock prices? Is inflation temporary or will we expect it
to last more long term? If one company is inflating perceived supply, this
would almost certainly not show up as significant economy-wide inflation.
And if the majority of companies are doing it, how can you stop it if you
don't have any idea which ones are doing it? I do think spotting the
inflation in any kind of timely manner is indeed hard.

> Stopping or avoiding it is the actual issue. No ?proof? of reserve can do
this.

I of course agree that proof of reserves cannot stop inflation/insolvency.
I disagree with the idea that this is the "actual" issue - which seems to
imply to me that its the only issue that matters. Even if we can't stop a
company from promising more coins than they have in reserves, we can limit
how long these events happen for - and how big these bubbles can get. Don't
you agree that would be very helpful, if it were it possible (which it
seems you think it isn't)?

> The federal reserve was clearly insolvent from its early days, as that
was its purpose.

Do you have a source as evidence that it was widely understood that the Fed
was insolvent from its early days? I really don't think it was seen as the
purpose by the vast majority of people in the US. People were lead to
believe every dollar was backed by a unique chunk of gold. Had it been
possible to do a kind of proof of reserves (or estimate of reserves) as
we're talking about, it would have been clear much earlier that the Fed was
doing a lot of shinanigans. I think that would have been very useful
information for the public back then. Perhaps they wouldn't have been able
to do anything about the Fed (or maybe they would have). But people can
certainly pull their money out of companies that can't show solvency.

> Nonsense, any business can fail, regardless of temporal cash reserves.

I agree that any business can fail. But a bank that pretends it can serve
cash on demand is not a normal business, and cash reserves absolutely
relate to their ability to survive as a bank. Its honestly confusing to me
how you could think otherwise. Also, calling my thoughts "nonsense" is
rude, please check yourself, Eric.

> it's hardly an improvement over holding your own keys.

No one is claiming that proof of reserves is "an improvement" over holding
your own keys. Clearly holding your own keys is ideal. However, not
everyone is comfortable with that. The fact of the matter is that many will
choose a custodial wallet, for better or worse. PoR attempts to make thing
on the "better" side than the "worse" side.

On Tue, Jul 6, 2021 at 9:39 AM Erik Aronesty <erik at q32.com> wrote:

> you should check out some of the earlier work done here:
>
> https://github.com/olalonde/proof-of-solvency#assets-proof
>
> to be honest, if any exchange supported that proof, it would be more
> than enough.
>
> there's really no way to prevent a smash-and-grab, but this does
> prevent a slow-leak
>
>
> On Mon, Jul 5, 2021 at 5:10 PM Billy Tetrud via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > I had the idea recently for proof of reserves done in a way that can be
> used to verify reserves are sufficient on an ongoing basis. I'm curious if
> there are any current approaches out there to proof of reserves that are
> similar.
> >
> > The idea is to have users create actual private keys using a seed in
> pretty much the normal way. Users would generate a public key from this
> seed to represent their account, and would give the public key to the
> custodian to represent their account in a public record of account balances.
> >
> > When a user's account is credited, the custodian would update a map of
> addresses (created from the public key of each account) to balances - this
> map could be structured into a merkle tree in the usual "merkle approach".
> The custodian would also store funds on one or more HD wallets (each with
> many addresses) and create a proof that they own each HD wallet. The proof
> could be as simple as a single signature created with the xpub for the
> wallet, which would be sufficient for proving ownership over the whole
> list/tree of addresses.
> >
> > These two structures (the map and the HD wallet) would be combined and
> hashed, and the hash published in an on chain transaction (possibly along
> with a URI where the full data can be found), on something like a daily
> basis. Software for each user could continuously validate that their
> account has a balance that matches what it's supposed to have, and could
> also verify that owned addresses have funds that have at least as many
> coins as promised to accounts. If these things aren't verifiable (either
> because the balances total to more than the HD wallet contains, or because
> of data unavailability), people can raise hell about it.
> >
> > To give user's additional proving ability, a receipt system could be
> added. Users could request a receipt for any balance update. Eg the user
> would create a message with a timestamp, their custodial "address", and the
> new balance. The user would sign this receipt and send it to the custodian,
> who would also sign it and send it back. This way, if something goes wrong,
> a user can use this signed receipt to show that the custodian did in fact
> promise a new updated balance at a particular time (which would cover the
> case that the custodian records the wrong value in their map). Conversely,
> the receipt would be useful to honest custodians as well, since they could
> show the user's signed receipt request in the case a user is trying to lie
> about what balance they should have. There is still the case that the
> custodian simply refuses to return a signed receipt, in which case the
> user's only recourse is to yell about it immediately and demand a receipt
> or a refund.
> >
> > Why record it on chain? Doing that gives a clear record of proof of
> reserves that can be verified later by anyone in the future. It prevents a
> custodian from being able to change history when it suits them (by creating
> a new records with false timestamps in the past). Many of these records
> could be aggregated together and recorded in the same transaction (with a
> single hash), so a single transaction per day could record the records of
> all participating custodians. If all custodians are using a standard
> system, one can cross verify that addresses claimed by one custodian aren't
> also claimed by another custodian.
> >
> > Even tho the user is responsible for their keys in order to properly
> verify, losing the keys isn't that big of a deal, since they could simply
> create a new seed and give a new public key to the custodian - who would
> have other identifying information they could use to validate that they own
> the account. So it places less responsibility on the user, while still
> introducing people, in a light-weight way, to self custody of keys.
> >
> > Having a record like this every day would reduce the possibility of
> shenanigans like taking a short term loan of a large amount of
> cryptocurrency. Sure, they could take a 10 minute loan once per day, but it
> would also be possible to trace on-chain transactions so you could tell if
> such a thing was going on. I wonder if there would be some way to include
> the ability to prove balances held on the lightning network, but I suspect
> that isn't generally possible.
> >
> > In any case, I'm curious what people think of this kind of thing, and if
> systems with similar properties are already out there.
> >
> >
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210706/e5d86df3/attachment.html>

From roconnor at blockstream.com  Wed Jul  7 13:12:58 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 7 Jul 2021 09:12:58 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>
Message-ID: <CAMZUoK=rRDV4F7j64gTUqEB9EiBpwhZW6LP-FMR0FxR2Bc4iBw@mail.gmail.com>

On Wed, Jul 7, 2021 at 12:26 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Russell,
>
> > Hi ZmnSCPxj,
> >
> > I don't believe we need to ban Turing completeness for the sake of
> banning Turing completeness.
>
> Well I believe we should ban partial Turing-completeness, but allow total
> Turing-completeness.
>

Unfortunately, when it comes to cross-transaction computations, it is
infeasible to ban non-terminating computation.

The nature of recursive covenants is that the program "writes" the *source
code* next step of the computation to the scriptPubKey to one of the
outputs of its transaction. Technically speaking it verifies that the
scriptPubKey is a commitment to the source code of the next step of the
program, but morally that is the same as writing the source code.  Then the
next step of the computation is invoked by someone "evaluating* that next
step's source code by creating a valid transaction that spends the
generated output.

The point is this ability to create new source code and then evaluate it
leads to the ability to write universal (i.e non-terminating)
computations.  The only way to prevent it is to ban source code
manipulation, but since Bitcoin Script source code is just a string of
bytes, it would mean banning the manipulation of strings of bytes.  But the
entire Bitcoin Script language works by manipulating strings of bytes
within a stack machine.  Indeed the most trivial of non-terminating
programs can be implemented by extracting the current input's scriptPubKey
from the sighash and "writing" the identical scriptPubKey to one of its
outputs.  That example hardly takes any manipulation at all to implement.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210707/1a038896/attachment.html>

From roconnor at blockstream.com  Wed Jul  7 14:24:17 2021
From: roconnor at blockstream.com (Russell O'Connor)
Date: Wed, 7 Jul 2021 10:24:17 -0400
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoK=rRDV4F7j64gTUqEB9EiBpwhZW6LP-FMR0FxR2Bc4iBw@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>
 <CAMZUoK=rRDV4F7j64gTUqEB9EiBpwhZW6LP-FMR0FxR2Bc4iBw@mail.gmail.com>
Message-ID: <CAMZUoK=yeb2Tc0GSfPs6ezS09gpXf=xgzkuiPrj905dfT5n6LA@mail.gmail.com>

On Wed, Jul 7, 2021 at 9:12 AM Russell O'Connor <roconnor at blockstream.com>
wrote:

>
> On Wed, Jul 7, 2021 at 12:26 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Russell,
>>
>> > Hi ZmnSCPxj,
>> >
>> > I don't believe we need to ban Turing completeness for the sake of
>> banning Turing completeness.
>>
>> Well I believe we should ban partial Turing-completeness, but allow total
>> Turing-completeness.
>>
>
> Unfortunately, when it comes to cross-transaction computations, it is
> infeasible to ban non-terminating computation.
>
> The nature of recursive covenants is that the program "writes" the *source
> code* next step of the computation to the scriptPubKey to one of the
> outputs of its transaction. Technically speaking it verifies that the
> scriptPubKey is a commitment to the source code of the next step of the
> program, but morally that is the same as writing the source code.  Then the
> next step of the computation is invoked by someone "evaluating* that next
> step's source code by creating a valid transaction that spends the
> generated output.
>
> The point is this ability to create new source code and then evaluate it
> leads to the ability to write universal (i.e non-terminating)
> computations.  The only way to prevent it is to ban source code
> manipulation, but since Bitcoin Script source code is just a string of
> bytes, it would mean banning the manipulation of strings of bytes.  But the
> entire Bitcoin Script language works by manipulating strings of bytes
> within a stack machine.  Indeed the most trivial of non-terminating
> programs can be implemented by extracting the current input's scriptPubKey
> from the sighash and "writing" the identical scriptPubKey to one of its
> outputs.  That example hardly takes any manipulation at all to implement.
>

A follow up:  Because recursive covenants need to be sent to a new
transaction in order to recurse, you might choose to view this stepping
mechanism as productive by modeling each transaction step as the continue
constructor in your RecResult codata type.  Indeed after (drinking coffee
and) rereading your mailing list item, it seems that this is the point you
were making.

So sorry for my hasty response.  I believe we are largely in agreement here.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210707/9a33d4a0/attachment.html>

From jlrubin at mit.edu  Wed Jul  7 17:26:38 2021
From: jlrubin at mit.edu (Jeremy)
Date: Wed, 7 Jul 2021 10:26:38 -0700
Subject: [bitcoin-dev] Unlimited covenants,
 was Re: CHECKSIGFROMSTACK/{Verify} BIP for Bitcoin
In-Reply-To: <CAMZUoK=yeb2Tc0GSfPs6ezS09gpXf=xgzkuiPrj905dfT5n6LA@mail.gmail.com>
References: <CAD5xwhjmu-Eee47Ho5eA6E6+aAdnchLU0OVZo=RTHaXnN17x8A@mail.gmail.com>
 <20210704011341.ddbiruuomqovrjn6@ganymede>
 <CAD5xwhimPBEV_tLpSPxs9B+XGUhvPx_dnhok=8=hyksyi4=B6g@mail.gmail.com>
 <20210704203230.37hlpdyzr4aijiet@ganymede>
 <5keA_aPvmCO5yBh_mBQ6Z5SwnnvEW0T-3vahesaDh57f-qv4FbG1SFAzDvT3rFhre6kFl282VsxV_pynwn_CdvF7fzH2q9NW1ZQHPH1pmdo=@protonmail.com>
 <CAMZUoKnuRXNG1pyupHrL+Wo80TXTbADVrexoB=+BKC633v-qMw@mail.gmail.com>
 <u2ETzW2-k7sjRKEz48C2n2QJvmWPVdhZIqtva_KvDNvxNDTVnR2zzYCL2Q8RUVkLm93OMJ2S2GOfUOxmdvNTaCIK1liebb4yvCCBBFB75f0=@protonmail.com>
 <CAMZUoK=rRDV4F7j64gTUqEB9EiBpwhZW6LP-FMR0FxR2Bc4iBw@mail.gmail.com>
 <CAMZUoK=yeb2Tc0GSfPs6ezS09gpXf=xgzkuiPrj905dfT5n6LA@mail.gmail.com>
Message-ID: <CAD5xwhjfX+a3jSewCof4LUjcDR_dnffhnL7h-9dr4GZ53Jc2gA@mail.gmail.com>

Hah -- ZmnSCPxj that post's a doozy -- but it more or less makes sense the
argument you're making in favor of permitting recursion at the transaction
level.

One part that's less clear is if you can make a case against being
recursive in Script fragments themselves -- ignoring bitcoin script for the
moment, what would be wrong with a small VM that a spender is able to
"purchase" a number of cycles and available memory via the annex, and the
program must execute and halt within that time? Then, per block/txn, you
can enforce a total cycle and memory limit. This still isn't quite the EVM,
since there's no cross object calling convention and the output is still
UTXOs. What are the arguments against this model from a safety perspective?

<new topic>

One of my general concerns with recursive covenants is the ability to "go
wrong" in surprising ways. Consider the following program (Sapio
<http://learn.sapio-lang.org>-pseudocode), which is a non recursive
covenant (i.e., doable today with presigning oracles) that demonstrates the
issue.

struct Pool {
    members: Vec<(Amount, Key)>,
}
impl Pool {
    then!{
        fn withdraw(self, ctx) {
            let mut builder = ctx.template();
            for (a, k) in self.members.iter() {
                builder = builder.add_output(a, k.into(), None)?;
            }
            builder.into()
        }
    }
    guard! {
        fn all_signed(self, ctx) {
            Clause::And(self.members.iter().map(|(a,k)|
Clause::Key(k.clone())).into())
        }
    }
    finish! {
        guarded_by: [all_signed]
        fn add_member(self, ctx, o_member: Option<(Amount, Key)>) {
            let member = o_member.into()?;
            let mut new_members = self.members.clone();
            new_members.push(member.clone());
            ctx.template().add_output(ctx.funds() + member.0,
                  Pool {members: new_members}, None)?.into()
        }
    }
}

Essentially this is a recursive covenant that allows either Complete via
the withdraw call or Continue via add_member, while preserving the same
underlying code. In this case, all_signed must be signed by all current
participants to admit a new member.

This type of program is subtly "wrong" because the state transition of
add_member does not verify that the Pool's future withdraw call will be
valid. E.g., we could add more than a 1MB of outputs, and then our program
would be "stuck". So it's critical that in our "production grade" covenant
system we do some static analysis before proceeding to a next step to
ensure that all future txns are valid. This is a strength of the CTV/Sapio
model presently, you always output a list of future txns to aid static
analysis.

However, when we make the leap to "automatic" covenants, I posit that it
will be *incredibly* difficult to prove that recursive covenants don't have
a "premature termination" where a state transition that should be valid in
an idealized setting is accidentally invalid in the actual bitcoin
environment and the program reaches a untimely demise.

For instance, OP_CAT has this footgun -- by only permitting 520 bytes, you
hit covenant limits at around 13 outputs assuming you are length checking
each one and not permitting bare script. We can avoid this specific footgun
some of the time by using SHA256STREAM instead, of course.

However, it is generally very difficult to avoid all sorts of issues. E.g.,
with the ability to generate/update tapscript trees, what happens when
through updating a well formed tapscript tree 128 times you bump an
important clause past the 129 depth limit?

I don't think that these sorts of challenges mean that we shouldn't enable
covenants or avoid enabling them, but rather that as we explore we should
add primitives in a methodical way and give users/toolchain builders
primitives that enable and or encourage safety and good program design.

My personal view is that CTV/Sapio with it's AOT compilation of automated
state transitions and ability to statically analyze is a concept that can
mature and be used in production in the near term. But the tooling to
safely do recursive computations at the txn level will take quite a bit
longer to mature, and we should be investing effort in producing
compilers/frameworks for emitting well formed programs before we get too in
the weeds on things like OP_TWEAK. (side note -- there's an easy path for
adding this sort of experimental feature to Sapio if anyone is looking for
a place to start)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210707/b4ed93fc/attachment-0001.html>

From jlrubin at mit.edu  Thu Jul  8 01:00:20 2021
From: jlrubin at mit.edu (Jeremy)
Date: Wed, 7 Jul 2021 18:00:20 -0700
Subject: [bitcoin-dev] Eltoo / Anyprevout & Baked in Sequences
Message-ID: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>

I made a comment on
https://github.com/bitcoin/bips/pull/943#issuecomment-876034559 but it
occurred to me it is more ML appropriate.

In general, one thing that strikes me is that when anyprevout is used for
eltoo you're generally doing a script like:

```
IF
    10 CSV DROP
    1::musigkey(As,Bs) CHECKSIG
ELSE
    <S+1> CLTV DROP
   1::musigkey(Au,Bu) CHECKSIG
ENDIF
```

This means that you're overloading the CLTV clause, which means it's
impossible to use Eltoo and use a absolute lock time, it also means you
have to use fewer than a billion sequences, and if you pick a random # to
mask how many payments you've done / pick random gaps let's say that
reduces your numbers in half. That may be enough, but is still relatively
limited. There is also the issue that multiple inputs cannot be combined
into a transaction if they have signed on different locktimes.

Since Eltoo is the primary motivation for ANYPREVOUT, it's worth making
sure we have all the parts we'd need bundled together to see it be
successful.

A few options come to mind that might be desirable in order to better serve
the eltoo usecase

1) Define a new CSV type (e.g. define (1<<31 && 1<<30) as being dedicated
to eltoo sequences). This has the benefit of giving a per input sequence,
but the drawback of using a CSV bit. Because there's only 1 CSV per input,
this technique cannot be used with a sequence tag.
2) CSFS -- it would be possible to take a signature from stack for an
arbitrary higher number, e.g.:
```
IF
    10 CSV DROP
    1::musigkey(As,Bs) CHECKSIG
ELSE
    DUP musigkey(Aseq, BSeq) CSFSV <S+1> GTE VERIFY
   1::musigkey(Au,Bu) CHECKSIG
ENDIF
```
Then, posession of a higher signed sequence would allow for the use of the
update path. However, the downside is that there would be no guarantee that
the new state provided for update would be higher than the past one without
a more advanced covenant.
3) Sequenced Signature: It could be set up such that ANYPREVOUT keys are
tagged with a N byte sequence (instead of 1), and a part of the process of
signature verification includes hashing a sequence on the signature itself.

E.g.

```
IF
    10 CSV DROP
    1::musigkey(As,Bs) CHECKSIG
ELSE
   <N>::musigkey(Au,Bu) CHECKSIG
ENDIF
```
To satisfy this clause, a signature `<N+1>::S` would be required. When
validating the signature S, the APO digest would have to include the value
<N+1>. It is non cryptographically checked that N+1 > N.
5) Similar to 3, but look at more values off the stack. This is also OK,
but violates the principle of not making opcodes take variable numbers of
things off the stack. Verify semantics on the extra data fields could
ameliorate this concern, and it might make sense to do it that way.
4) Something in the Annex: It would also be possible to define a new
generic place for lock times in the annex (to permit dual height/time
relative/absolute, all per input. The pro of this approach is that it would
be solving an outstanding problem for script that we want to solve anyways,
the downside is that the Annex is totally undefined presently so it's
unclear that this is an appropriate use for it.
5) Do Nothing :)


Overall I'm somewhat partial to option 3 as it seems to be closest to
making ANYPREVOUT more precisely designed to support Eltoo. It would also
be possible to make it such that if the tag N=1, then the behavior is
identical to the proposal currently.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210707/9e3fa6d7/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Jul  8 08:12:01 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 08 Jul 2021 08:12:01 +0000
Subject: [bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was
	CheckSigFromStack for Arithmetic Values]
In-Reply-To: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>
References: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>
Message-ID: <MAfz2o3-uf5SfGKfMwONmT4TH4cmcAEJGyx21_dRQWBuCZZzFSXg38xyRY7HiMYMFB5zuTPorf_LYrnjE2K__uP578h7MZypf68yM0xjU3w=@protonmail.com>


Good morning Jeremy,

Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase *cough*

Since a quantum computer can derive the EC privkey from the EC pubkey and this scheme is resistant to that, I think you can use a single well-known EC privkey, you just need a unique Lamport keypair for each UTXO (uniqueness being mandatory due to Lamport requiring preimage revelation).

Regards,
ZmnSCPxj


> Dear Bitcoin Devs,
>
> As mentioned previously, OP_CAT (or similar operation) can be used to make Bitcoin "quantum safe" by signing an EC signature. This should work in both Segwit V0 and Tapscript, although you have to use HASH160 for it to fit in Segwit V0.
>
> See [my blog](https://rubin.io/blog/2021/07/06/quantum-bitcoin/) for the specific construction, reproduced below.
>
> Yet another entry to the "OP_CAT can do that too" list.
>
> Best,
>
> Jeremy
> -----
>
> I recently published [a blog
> post](https://rubin.io/blog/2021/07/02/signing-5-bytes/) about signing up to a
> 5 byte value using Bitcoin script arithmetic and Lamport signatures.
>
> By itself, this is neat, but a little limited. What if we could sign longer
> messages? If we can sign up to 20 bytes, we could sign a HASH160 digest which
> is most likely quantum safe...
>
> What would it mean if we signed the HASH160 digest of a signature? What the
> what? Why would we do that?
>
> Well, as it turns out, even if a quantum computer were able to crack ECDSA, it
> would yield revealing the private key but not the ability to malleate the
> content of what was actually signed.? I asked my good friend and cryptographer
> [Madars Virza](https://madars.org/) if my intuition was correct, and he
> confirmed that it should be sufficient, but it's definitely worth closer
> analysis before relying on this. While the ECDSA signature can be malleated to a
> different, negative form, if the signature is otherwise made immalleable there
> should only be one value the commitment can be opened to.
>
> If we required the ECDSA signature be signed with a quantum proof signature
> algorithm, then we'd have a quantum proof Bitcoin! And the 5 byte signing scheme
> we discussed previously is a Lamport signature, which is quantum secure.
> Unfortunately, we need at least 20 contiguous bytes... so we need some sort of
> OP\_CAT like operation.
>
> OP\_CAT can't be directly soft forked to Segwit v0 because it modifies the
> stack, so instead we'll (for simplicity) also show how to use a new opcode that
> uses verify semantics, OP\_SUBSTRINGEQUALVERIFY that checks a splice of a string
> for equality.
>
> ```
> ... FOR j in 0..=5
> ? ? <0>
> ? ? ... FOR i in 0..=31
> ? ? ? ? SWAP hash160 DUP <H(K_j_i_1)> EQUAL IF DROP <2**i> ADD ELSE <H(K_j_i_0)> EQUALVERIFY ENDIF
> ? ? ... END FOR
> ? ? TOALTSTACK
> ... END FOR
>
> DUP HASH160
>
> ... IF CAT AVAILABLE
> ? ? FROMALTSTACK
> ? ? ... FOR j in 0..=5
> ? ? ? ? FROMALTSTACK
> ? ? ? ? CAT
> ? ? ... END FOR
> ? ? EQUALVERIFY
> ... ELSE SUBSTRINGEQUALVERIFY AVAILABLE
> ? ? ... FOR j in 0..=5
> ? ? ? ? FROMALTSTACK <0+j*4> <4+j*4> SUBSTRINGEQUALVERIFY DROP DROP DROP
> ? ? ...? END FOR
> ? ? DROP
> ... END IF
>
> <pk> CHECKSIG
> ```
>
> That's a long script... but will it fit? We need to verify 20 bytes of message
> each bit takes around 10 bytes script, an average of 3.375 bytes per number
> (counting pushes), and two 21 bytes keys = 55.375 bytes of program space and 21
> bytes of witness element per bit.
>
> It fits! `20*8*55.375 = 8860`, which leaves 1140 bytes less than the limit for
> the rest of the logic, which is plenty (around 15-40 bytes required for the rest
> of the logic, leaving 1100 free for custom signature checking). The stack size
> is 160 elements for the hash gadget, 3360 bytes.
>
> This can probably be made a bit more efficient by expanding to a ternary
> representation.
>
> ```
> ? ? ? ? SWAP hash160 DUP <H(K_j_i_0)> EQUAL ?IF DROP ?ELSE <3**i> SWAP DUP <H(K_j_i_T)> EQUAL IF DROP SUB ELSE <H(K_j_i_1)> EQUALVERIFY ADD ?ENDIF ENDIF
> ```
>
> This should bring it up to roughly 85 bytes per trit, and there should be 101
> trits (`log(2**160)/log(3) == 100.94`), so about 8560 bytes... a bit cheaper!
> But the witness stack is "only" `2121` bytes...
>
> As a homework exercise, maybe someone can prove the optimal choice of radix for
> this protocol... My guess is that base 4 is optimal!
>
> ## Taproot?
>
> What about Taproot? As far as I'm aware the commitment scheme (`Q = pG + hash(pG
> || m)G`) can be securely opened to m even with a quantum computer (finding `q`
> such that `qG = Q` might be trivial, but suppose key path was disabled, then
> finding m and p such that the taproot equation holds should be difficult because
> of the hash, but I'd need to certify that claim better).? Therefore this
> script can nest inside of a Tapscript path -- Tapscript also does not impose a
> length limit, 32 byte hashes could be used as well.
>
> Further, to make keys reusable, there could be many Lamport keys comitted inside
> a taproot tree so that an address could be used for thousands of times before
> expiring. This could be used as a measure to protect accidental use rather than
> to support it.
>
> Lastly, Schnorr actually has a stronger non-malleability property than ECDSA,
> the signatures will be binding to the approved transaction and once Lamport
> signed, even a quantum computer could not steal the funds.
>
> --
> @JeremyRubin



From aj at erisian.com.au  Thu Jul  8 08:44:16 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 8 Jul 2021 18:44:16 +1000
Subject: [bitcoin-dev] Eltoo / Anyprevout & Baked in Sequences
In-Reply-To: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>
References: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>
Message-ID: <20210708084416.GB1339@erisian.com.au>

On Wed, Jul 07, 2021 at 06:00:20PM -0700, Jeremy via bitcoin-dev wrote:
> This means that you're overloading the CLTV clause, which means it's impossible
> to use Eltoo and use a absolute lock time,

It's already impossible to simultaneously spend two inputs if one
requires a locktime specified by mediantime and the other by block
height. Having per-input locktimes would satisfy both concerns.

> 1) Define a new CSV type (e.g. define (1<<31 && 1<<30) as being dedicated to
> eltoo sequences). This has the benefit of giving a per input sequence, but the
> drawback of using a CSV bit. Because there's only 1 CSV per input, this
> technique cannot be used with a sequence tag.

This would disallow using a relative locktime and an absolute locktime
for the same input. I don't think I've seen a use case for that so far,
but ruling it out seems suboptimal.

Adding a per-input absolute locktime to the annex is what I've had in
mind. That could also be used to cheaply add a commitment to an historical
block hash (eg "the block at height 650,000 ended in cc6a") in order to
disambiguate which branch of a chain split or reorg your tx is valid for.

Cheers,
aj


From aj at erisian.com.au  Thu Jul  8 11:17:16 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 8 Jul 2021 21:17:16 +1000
Subject: [bitcoin-dev] A Stroll through Fee-Bumping Techniques :
 Input-Based vs Child-Pay-For-Parent
In-Reply-To: <CALZpt+FvLb=N5Qygs+dPmh1o9QCwXj8RoznF5n47opOq7CG_0g@mail.gmail.com>
References: <CALZpt+FvLb=N5Qygs+dPmh1o9QCwXj8RoznF5n47opOq7CG_0g@mail.gmail.com>
Message-ID: <20210708111716.GC1339@erisian.com.au>

On Thu, May 27, 2021 at 04:14:13PM -0400, Antoine Riard via bitcoin-dev wrote:
> This overhead could be smoothed even further in the future with more advanced
> sighash malleability flags like SIGHASH_IOMAP, allowing transaction signers to
> commit to a map of inputs/outputs [2]. In the context of input-based, the
> overflowed fee value could be redirected to an outgoing output.

> Input-based (SIGHASH_ANYPREVOUT+SIGHASH_IOMAP): Multiple chains of transactions
> might be aggregated together *non-interactively*. One bumping input and
> outgoing output can be attached to the aggregated root.

> [2] https://bitcointalk.org/index.php?topic=252960.0

I haven't seen any recent specs for "IOMAP", but there are a few things
that have bugged me about them in the past:

 (1) allowing partially overlapping sets of outputs could allow "theft",
     eg if I give you a signature "you can spend A+B as long as I get X"
     and "you can spend A+C as long as I get X", you could combine them
     to spend A+B+C instead but still only give me 1 X.

 (2) a range specification or a whole bitfield is a lot heavier than an
     extra bit to add to the sighash

 (3) this lets you specify lots of different ways of hashing the
     outputs, which then can't be cached, so you get kind-of quadratic
     behaviour -- O(n^2/8) where n/2 is the size of the inputs, which
     gives you the number of signatures, and n/2 is also the size of the
     outputs, so n/4 is a different half of the output selected for each
     signature in the input.

But under the "don't bring me problems, bring me solutions" banner,
here's an idea.

The easy way to avoid O(n^2) behaviour in (3) is to disallow partial
overlaps. So let's treat the tx as being distinct bundles of x-inputs
and y-outputs, and we'll use the annex for grouping, since that is
committed to by singatures. Call the annex field "sig_group_count".

When processing inputs, setup a new state pair, (start, end), initially
(0,0).

When evaluating an input, lookup sig_group_count. If it's not present,
then set start := end. If it's present and 0, leave start and end
unchanged. Otherwise, if it's present and greather than 0, set
start := end, and then set end := start + sig_group_count.

Introduce a new SIGHASH_GROUP flag, as an alternative to ALL/SINGLE/NONE,
that commits to each output i, start <= i < end. If start==end or end >
num_outputs, signature is invalid.

That means each output in a tx could be hashed three times instead of
twice (once for its particular group, as well as once for SIGHASH_ALL
and once for SIGHASH_SINGLE), and I think would let you combine x-input
and y-outputs fairly safely, by having the first input commit to "y"
in the annex, and the remaining x-1 commit to "0".

That does mean if you have two different sets of inputs (x1 and x2)
each spending to the exact same set of y outputs, you could claim all
but one of them while only paying a single set of y outputs. But you
could include an "OP_RETURN hash(x1)" tapleaf branch in one of the y
outputs to ensure the outputs aren't precisely the same to avoid that
problem, so maybe that's fine?

Okay, now that I've written and re-written that a couple of times,
it looks like I'm just reinventing Rusty's signature bundles from 2018:

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-April/015862.html

(though at least I think using the annex is probably an improvement on
having values that affect other inputs being buried deeper in an input's
witness data)



Without something like this, I think it will be very hard to incorporate
fees into eltoo with layered commitments [0]. As a new sighash mode it
would make sense to include it as part of ANYPREVOUT to avoid introducing
many new "unknown key types".

[0] https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html
    also, https://www.erisian.com.au/lightning-dev/log-2021-07-08.html

Cheers,
aj


From jlrubin at mit.edu  Thu Jul  8 15:48:14 2021
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 8 Jul 2021 08:48:14 -0700
Subject: [bitcoin-dev] Eltoo / Anyprevout & Baked in Sequences
In-Reply-To: <20210708084416.GB1339@erisian.com.au>
References: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>
 <20210708084416.GB1339@erisian.com.au>
Message-ID: <CAD5xwhjVod-Lu-gjU89znmVZnmL4UrL7xVuy=gZuuG6JG9X5yg@mail.gmail.com>

>
> This would disallow using a relative locktime and an absolute locktime
> for the same input. I don't think I've seen a use case for that so far,
> but ruling it out seems suboptimal.


I think you meant disallowing a relative locktime and a sequence locktime?
I agree it is suboptimal.


What do you make of sequence tagged keys?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210708/6512bb4f/attachment.html>

From jlrubin at mit.edu  Thu Jul  8 20:06:08 2021
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 8 Jul 2021 13:06:08 -0700
Subject: [bitcoin-dev] Taproot Fields for PSBT
In-Reply-To: <CAMhCMoFD+W-13JFKuF5GnbO2V6htNM3U-rs1ELqEEeV5jF_VpQ@mail.gmail.com>
References: <795f917b-3883-1827-f39b-35123b500f36@achow101.com>
 <CAMhCMoF7N4BuXDz1cSDBLi5zH8c06uZ3T3gc750azFH3JagcNw@mail.gmail.com>
 <912b172b-009d-9d5f-32d8-189e7fbe7646@achow101.com>
 <CAMhCMoFD+W-13JFKuF5GnbO2V6htNM3U-rs1ELqEEeV5jF_VpQ@mail.gmail.com>
Message-ID: <CAD5xwhjrdijV0Qozb67_3YiAfzu5BYrP7nY9xxcWV7gXG_8nxw@mail.gmail.com>

Suggestion:

It should be allowed that different keys can specify different sighash
flags.

As an example, if chaperone signatures were desired with anyprevout, it
would be required to specify that the anyprevout key sign with APO and the
chaperone sign with ALL. As another example, Sapio emulator oracles sign
with SIGHASH_ALL whereas other signatories might be instructed to sign with
a different flag.

The current sighashtype key is per-input:
- If a sighash type is provided, the signer must check that the sighash is
acceptable. If unacceptable, they must fail.
- If a sighash type is not provided, the signer should sign using
SIGHASH_ALL, but may use any sighash type they wish.

So a new per-key mapping can be added safely.

I have no strong opinions on the format for said per-key sighash hints.

Why do this now? Well, I requested it when spec'ing V2 as well, but it
would be nice to get it spec'd and implemented.


--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Mon, Jun 28, 2021 at 1:32 PM Salvatore Ingala via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Andrew,
>
> Thanks for the clarification, I was indeed reading it under the mistaken
> assumption that only one leaf would be added to the PSBT.
>
> En passant, for the less experienced readers, it might be helpful if the
> key types that are possibly present multiple times (with different keydata)
> were somehow labeled in the tables.
>
> Best,
> Salvatore Ingala
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210708/d6ecda51/attachment.html>

From antoine.riard at gmail.com  Fri Jul  9 13:19:45 2021
From: antoine.riard at gmail.com (Antoine Riard)
Date: Fri, 9 Jul 2021 09:19:45 -0400
Subject: [bitcoin-dev] A Stroll through Fee-Bumping Techniques :
 Input-Based vs Child-Pay-For-Parent
In-Reply-To: <20210708111716.GC1339@erisian.com.au>
References: <CALZpt+FvLb=N5Qygs+dPmh1o9QCwXj8RoznF5n47opOq7CG_0g@mail.gmail.com>
 <20210708111716.GC1339@erisian.com.au>
Message-ID: <CALZpt+FCCgSiRh2qAL+RM0S9Vm8s-xS3VdTAZhS9VwLcFi_1QQ@mail.gmail.com>

On Thu, May 27, 2021 at 04:14:13PM -0400, Antoine Riard via bitcoin-dev
wrote:
> This overhead could be smoothed even further in the future with more
advanced
> sighash malleability flags like SIGHASH_IOMAP, allowing transaction
signers to
> commit to a map of inputs/outputs [2]. In the context of input-based, the
> overflowed fee value could be redirected to an outgoing output.

> Input-based (SIGHASH_ANYPREVOUT+SIGHASH_IOMAP): Multiple chains of
transactions
> might be aggregated together *non-interactively*. One bumping input and
> outgoing output can be attached to the aggregated root.

> [2] https://bitcointalk.org/index.php?topic=252960.0

> I haven't seen any recent specs for "IOMAP", but there are a few things
> that have bugged me about them in the past:

TBH, I don't think we have been further with Darosior than comparing the
compression schemes relevant for the bitfield :)

Thanks to start the hard grinding work!

>  (1) allowing partially overlapping sets of outputs could allow "theft",
>      eg if I give you a signature "you can spend A+B as long as I get X"
>      and "you can spend A+C as long as I get X", you could combine them
>      to spend A+B+C instead but still only give me 1 X.

Yes I think there is an even more unsafe case than described. A transaction
third-party knowledgeable about the partial sets could combine them, then
attach an additional siphoning output Y. E.g, if {A=50, B=50, C=50} and
X=100 the third-party could attach output Y=50 ?

Though I believe the validity of those thefts are a function of further
specification of the transaction digest coverage, as you might have a
malleability scheme where B or C's signatures hash are implicitly
committing to subset inputs order. If you have `H_prevouts(A || B)` and
`H_prevouts(A || C)`, an attacker wouldn't be able to satisfy both B and C
scripts in the same transaction ?

One mitigation which was mentioned in previous pinning discussion was to
add a per-participant finalizing key to A's script and thus lockdown
transaction template at broadcast. I don't think it works here as you can't
assume that your counterparties, from different protocol sessions, won't
collude together to combine their finalizing signatures and achieve a spend
replay across sessions ?

That said, I'm not even sure we should disallow partially overlapping sets
of outputs at the consensus-level, one could imagine a crowdfunding
application where you delegate A+B and A+C to different parties, and you
implicitly allow them to cooperate as long as they fulfill X's output value
?

>  (2) a range specification or a whole bitfield is a lot heavier than an
>      extra bit to add to the sighash

Yes, one quick optimization in case of far-depth output committed in the
bitfield could be to have a few initial bits serving as vectors to blank
out unused bitfield spaces. Though I concede a new sighash bits arithmetic
might be too fancy for consensus-code.


>  (3) this lets you specify lots of different ways of hashing the
>      outputs, which then can't be cached, so you get kind-of quadratic
>      behaviour -- O(n^2/8) where n/2 is the size of the inputs, which
>      gives you the number of signatures, and n/2 is also the size of the
>      outputs, so n/4 is a different half of the output selected for each
>      signature in the input.

If you assume n size of transaction data, and that each signature hash is
committing to inputs + half of outputs, yes I think it's even worst kind-of
quadratic, like O(3n^2/4) ? And you might even worsen the hashing in
function of flexibility allowed, like still committing to the whole
transaction size but a different combination order of outputs selected for
each signature.

But under the "don't bring me problems, bring me solutions" banner, here's
an idea.

> The easy way to avoid O(n^2) behaviour in (3) is to disallow partial
> overlaps. So let's treat the tx as being distinct bundles of x-inputs
> and y-outputs, and we'll use the annex for grouping, since that is
> committed to by singatures. Call the annex field "sig_group_count".

> When processing inputs, setup a new state pair, (start, end), initially
> (0,0).
>
> When evaluating an input, lookup sig_group_count. If it's not present,
> then set start := end. If it's present and 0, leave start and end
> unchanged. Otherwise, if it's present and greather than 0, set
> start := end, and then set end := start + sig_group_count.

IIUC the design rationale, the "sig_group_count" lockdowns the hashing of
outputs for a given input, thus allowing midstate reuse across signatures
input.

> Introduce a new SIGHASH_GROUP flag, as an alternative to ALL/SINGLE/NONE,
> that commits to each output i, start <= i < end. If start==end or end >
> num_outputs, signature is invalid.
>
> That means each output in a tx could be hashed three times instead of
> twice (once for its particular group, as well as once for SIGHASH_ALL
> and once for SIGHASH_SINGLE), and I think would let you combine x-input
> and y-outputs fairly safely, by having the first input commit to "y"
> in the annex, and the remaining x-1 commit to "0".
>
> That does mean if you have two different sets of inputs (x1 and x2)
> each spending to the exact same set of y outputs, you could claim all
> but one of them while only paying a single set of y outputs. But you
> could include an "OP_RETURN hash(x1)" tapleaf branch in one of the y
> outputs to ensure the outputs aren't precisely the same to avoid that
> problem, so maybe that's fine?

If the index i is absolute w.r.t to the transaction output index, I think
this design might have a shortcoming.

Let's say you want to combine {x_1, y_1} and {x_2, y_2} where {x, y}
denotes bundles of Lightning commitment transactions.

x_1 is dual-signed by Alice and Bob under the SIGHASH_GROUP flag with
`sig_group_count`=3.
x_2 is dual-signed by Alice and Caroll under the SIGHASH_GROUP flag, with
`sig_group_count`=2.
y_1 and y_2 are disjunctive.

At broadcast, Alice is not able to combine {x_1,y_1} and {x_2, y_2} for the
reason that x_1, x_2 are colliding on the absolute output position.

One fix could be to skim the "end > num_ouputs" semantic, and thus have
Alice negotiate (start,end) encompassing all her channels outputs index and
then strictly ordering her i indexes on all her counterparties. But I don't
think you can assume index order to be transitive across Lightning nodes,
at least without bundle combination gaps in your local set of channels.

I think this SIGHASH_GROUP proposal might solve other use-cases, but if I
understand the semantics correctly, it doesn't seem to achieve the batch
fee-bumping of multiple Lightning commitment with O(1) onchain footprint I
was thinking of for IOMAP...

One counter-proposal to solve this "pre-signed y-outputs ordinate" could be
instead to envision the SIGHASH_GROUP as vector coordinates and the annex
field as the projection.

Let's say annex field := (hashOutputsGroups) and SIGHASH_GROUP(i,j) where j
is a non-null integer.
Call i the starting index of the output group committed by this input.
Call j the output group size committed by this input.

At validation, compute `hashOutputsGroup` = H(outputs[i...i+j-1]).
If the computed `hashOutputGroup` isn't equal to the input annex field
`hashOutputsGroup`, fails validation.
Otherwise, substitute `hashOutputGroup` to bip-143 `hashOutputs` while
conserving , and proceed to signature verification.

As (i,j) are not included in the annex and are only part of witness data,
they can be selected by the bundles combiner at broadcast to construct a
valid transaction.

If the combiner is malicious and (i,j) points to another outputs group, the
computed hash is going to be invalid, as it doesn't satisfy the annex
`output_group` field.

If you want to disallow partial overlaps for your bundle, we could even
have a bit k. If k=1, verify that all transaction `output_group` fields are
not colliding.

Hmmmm, sounds more flexible but you might still have a bit of hashing
complexity to deal with ?

> Okay, now that I've written and re-written that a couple of times,
> it looks like I'm just reinventing Rusty's signature bundles from 2018:
>
>
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-April/015862.html
>
> (though at least I think using the annex is probably an improvement on
> having values that affect other inputs being buried deeper in an input's
> witness data)
>
> Without something like this, I think it will be very hard to incorporate
> fees into eltoo with layered commitments [0]. As a new sighash mode it
> would make sense to include it as part of ANYPREVOUT to avoid introducing
> many new "unknown key types".

Well, I agree on the overall direction though maybe we should detail
primitive requirements a bit more, otherwise it might not fit the
second-layer use-case we're interested with.

Cheers,
Antoine

Le jeu. 8 juil. 2021 ? 07:17, Anthony Towns <aj at erisian.com.au> a ?crit :

> On Thu, May 27, 2021 at 04:14:13PM -0400, Antoine Riard via bitcoin-dev
> wrote:
> > This overhead could be smoothed even further in the future with more
> advanced
> > sighash malleability flags like SIGHASH_IOMAP, allowing transaction
> signers to
> > commit to a map of inputs/outputs [2]. In the context of input-based, the
> > overflowed fee value could be redirected to an outgoing output.
>
> > Input-based (SIGHASH_ANYPREVOUT+SIGHASH_IOMAP): Multiple chains of
> transactions
> > might be aggregated together *non-interactively*. One bumping input and
> > outgoing output can be attached to the aggregated root.
>
> > [2] https://bitcointalk.org/index.php?topic=252960.0
>
> I haven't seen any recent specs for "IOMAP", but there are a few things
> that have bugged me about them in the past:
>
>  (1) allowing partially overlapping sets of outputs could allow "theft",
>      eg if I give you a signature "you can spend A+B as long as I get X"
>      and "you can spend A+C as long as I get X", you could combine them
>      to spend A+B+C instead but still only give me 1 X.
>
>  (2) a range specification or a whole bitfield is a lot heavier than an
>      extra bit to add to the sighash
>
>  (3) this lets you specify lots of different ways of hashing the
>      outputs, which then can't be cached, so you get kind-of quadratic
>      behaviour -- O(n^2/8) where n/2 is the size of the inputs, which
>      gives you the number of signatures, and n/2 is also the size of the
>      outputs, so n/4 is a different half of the output selected for each
>      signature in the input.
>
> But under the "don't bring me problems, bring me solutions" banner,
> here's an idea.
>
> The easy way to avoid O(n^2) behaviour in (3) is to disallow partial
> overlaps. So let's treat the tx as being distinct bundles of x-inputs
> and y-outputs, and we'll use the annex for grouping, since that is
> committed to by singatures. Call the annex field "sig_group_count".
>
> When processing inputs, setup a new state pair, (start, end), initially
> (0,0).
>
> When evaluating an input, lookup sig_group_count. If it's not present,
> then set start := end. If it's present and 0, leave start and end
> unchanged. Otherwise, if it's present and greather than 0, set
> start := end, and then set end := start + sig_group_count.
>
> Introduce a new SIGHASH_GROUP flag, as an alternative to ALL/SINGLE/NONE,
> that commits to each output i, start <= i < end. If start==end or end >
> num_outputs, signature is invalid.
>
> That means each output in a tx could be hashed three times instead of
> twice (once for its particular group, as well as once for SIGHASH_ALL
> and once for SIGHASH_SINGLE), and I think would let you combine x-input
> and y-outputs fairly safely, by having the first input commit to "y"
> in the annex, and the remaining x-1 commit to "0".
>
> That does mean if you have two different sets of inputs (x1 and x2)
> each spending to the exact same set of y outputs, you could claim all
> but one of them while only paying a single set of y outputs. But you
> could include an "OP_RETURN hash(x1)" tapleaf branch in one of the y
> outputs to ensure the outputs aren't precisely the same to avoid that
> problem, so maybe that's fine?
>
> Okay, now that I've written and re-written that a couple of times,
> it looks like I'm just reinventing Rusty's signature bundles from 2018:
>
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-April/015862.html
>
> (though at least I think using the annex is probably an improvement on
> having values that affect other inputs being buried deeper in an input's
> witness data)
>
>
>
> Without something like this, I think it will be very hard to incorporate
> fees into eltoo with layered commitments [0]. As a new sighash mode it
> would make sense to include it as part of ANYPREVOUT to avoid introducing
> many new "unknown key types".
>
> [0]
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002448.html
>     also, https://www.erisian.com.au/lightning-dev/log-2021-07-08.html
>
> Cheers,
> aj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210709/b5a0db96/attachment-0001.html>

From eric at voskuil.org  Fri Jul  9 14:55:14 2021
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 9 Jul 2021 07:55:14 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDa3uVxa+LR5JMmTjkgYTwFH9wWLChekg=8wCdtQ2=9eQg@mail.gmail.com>
References: <CAGpPWDa3uVxa+LR5JMmTjkgYTwFH9wWLChekg=8wCdtQ2=9eQg@mail.gmail.com>
Message-ID: <DE1DCFFC-66BC-4EA1-922B-CC3A84A3C9DE@voskuil.org>


> On Jul 7, 2021, at 01:20, Billy Tetrud via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> But people can certainly pull their money out of companies that can't show solvency. 

As I pointed out previously there is an unsupportable leap being made here between a vault (money warehouse) and any company (including a bank).

A company cannot possibly show that it has all of the money that every person has invested into it. At times a solvent company may even have zero cash. It is also not possible for a company provide cryptographic proof of its many necessarily non-crypto assets and liabilities. What is presumed here is a community-verified sort of crypto balance sheet, with no considerations of risk - a central aspect of business.

As I said, if you want a vault, you can just use your own wallet. Solvency does not in any way imply 100% cash balance of the amounts invested. Raising money under such terms is pointless for both company and investors (the owners of the company).

> > Nonsense, any business can fail, regardless of temporal cash reserves.
> 
> I agree that any business can fail. But a bank that pretends it can serve cash on demand is not a normal business,

Banks (lending institutions) do not operate under any such pretense. US banks require 7 day time deposits for all interest bearing accounts (read your depositor agreement), and it should be clear that your uninsured balance is at risk. Banks are investment funds, not money warehouses (in Rothbard?s terminology).

With a 100% of investment cash hoard, there is zero lending and zero return. This is true for all business.

> and cash reserves absolutely relate to their ability to survive as a bank.

?relate to? is a far cry from 100% ?reserve?. At 100% reserve an investment fund would most certainly fail. At 20% it would fail. Money markets (banks without a reserve requirement) don?t break the buck, compete effectively with banks with reserve requirements (required by the taxpayer who is insuring deposits and providing discount credit), and maintain around 10% reserve. This is consistent with a world of people with time preference that creates around a 10% interest rate (return on investment).

> Its honestly confusing to me how you could think otherwise.

It?s confusing to me how anyone would put money into a business and expect (even want) it to sit there.

> Also, calling my thoughts "nonsense" is rude, please check yourself, Eric. 

Check myself? Nonsense is English for ?doesn?t make sense?. It?s not an insult.

e

From eric at voskuil.org  Fri Jul  9 18:32:12 2021
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 9 Jul 2021 11:32:12 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDbtwDy2+6dD9eXs72UTf63fw6sK-4Xa6ty14hWP6pOCsA@mail.gmail.com>
References: <CAGpPWDbtwDy2+6dD9eXs72UTf63fw6sK-4Xa6ty14hWP6pOCsA@mail.gmail.com>
Message-ID: <0A99CF2C-36E4-475F-9160-A999D4AFDA7F@voskuil.org>


> On Jul 9, 2021, at 10:44, Billy Tetrud <billy.tetrud at gmail.com> wrote:
> 
> >  there is an unsupportable leap being made here
> 
> You think that because you're misinterpreting me. I'm in no way claiming that any solvent company can prove it, I'm simply claiming that any company can prove that they have bitcoin reserves to cover bitcoins promised as account balances. 

You can prove that in your own wallet. All other scenarios imply lending (which is what is implied by ?reserve?) and lending cannot be 100% reserve.

> > Banks (lending institutions) do not operate under any such pretense
> 
> You seem to be saying that banks are under no legal obligation to serve cash on demand to customers. While you might be right,

I am, as banks are lending institutions.

> again you're misinterpreting me. Banks do in fact make claims to their customers that they'll be able to get cash out of their account on demand.

Up to the insured limit, in 7 days. This is of course true because the taxpayer has insured the bank to that level.

> They're called demand deposit accounts for a reason.

They are time deposits, read your bank agreement. Not that it makes any difference. How the contract is satisfied is not a term of the contract, just that it is. And as I pointed out, money markets have had no reserve requirement and have a nearly spotless record of satisfying their obligations.

> And certainly customers expect to be able to withdraw their cash on demand. 

Irrelevant.

> > With a 100% of investment cash hoard, there is zero lending and zero return
> 
> I did say "pretend" did I not?

See above.

> > ?relate to? is a far cry from 100% ?reserve?
> 
> Indeed. Again, you seem to be misunderstanding me. You're putting the words "100% reserve" in my mouth, when I never said any such thing. Proof of 80%/50%/20% reserves is still useful if that's the clear expectation for the customer/client.

Without 100% ?reserve? there is no way to cryptographically demonstrate ?solvency?. And even with that, investors would have to accept the promise that there are no other liabilities.

The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or state seizure, no matter what the reserve.

It?s information, sure, but it?s not what people seem to think. If one wants full reserve banking, use a wallet. If one wants to invest, the money will be spent - that?s why it was raised. There can be no covenant placed on it that will ensure it?s return.

e

From eth3rs at gmail.com  Fri Jul  9 19:02:15 2021
From: eth3rs at gmail.com (Ethan Heilman)
Date: Fri, 9 Jul 2021 15:02:15 -0400
Subject: [bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was
 CheckSigFromStack for Arithmetic Values]
In-Reply-To: <MAfz2o3-uf5SfGKfMwONmT4TH4cmcAEJGyx21_dRQWBuCZZzFSXg38xyRY7HiMYMFB5zuTPorf_LYrnjE2K__uP578h7MZypf68yM0xjU3w=@protonmail.com>
References: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>
 <MAfz2o3-uf5SfGKfMwONmT4TH4cmcAEJGyx21_dRQWBuCZZzFSXg38xyRY7HiMYMFB5zuTPorf_LYrnjE2K__uP578h7MZypf68yM0xjU3w=@protonmail.com>
Message-ID: <CAEM=y+WkG9razw6uEhkXtNCgonaw2GHp9oGB3J7uf9N_JVdPoQ@mail.gmail.com>

>Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase *cough*

Couldn't you significantly compress the signatures by using either
Winternitz OTS or by using OP_CAT to build a merkle tree so that the
full signature can be derived during script execution from a much
shorter set of seed values?

On Thu, Jul 8, 2021 at 4:12 AM ZmnSCPxj via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
> Good morning Jeremy,
>
> Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase *cough*
>
> Since a quantum computer can derive the EC privkey from the EC pubkey and this scheme is resistant to that, I think you can use a single well-known EC privkey, you just need a unique Lamport keypair for each UTXO (uniqueness being mandatory due to Lamport requiring preimage revelation).
>
> Regards,
> ZmnSCPxj
>
>
> > Dear Bitcoin Devs,
> >
> > As mentioned previously, OP_CAT (or similar operation) can be used to make Bitcoin "quantum safe" by signing an EC signature. This should work in both Segwit V0 and Tapscript, although you have to use HASH160 for it to fit in Segwit V0.
> >
> > See [my blog](https://rubin.io/blog/2021/07/06/quantum-bitcoin/) for the specific construction, reproduced below.
> >
> > Yet another entry to the "OP_CAT can do that too" list.
> >
> > Best,
> >
> > Jeremy
> > -----
> >
> > I recently published [a blog
> > post](https://rubin.io/blog/2021/07/02/signing-5-bytes/) about signing up to a
> > 5 byte value using Bitcoin script arithmetic and Lamport signatures.
> >
> > By itself, this is neat, but a little limited. What if we could sign longer
> > messages? If we can sign up to 20 bytes, we could sign a HASH160 digest which
> > is most likely quantum safe...
> >
> > What would it mean if we signed the HASH160 digest of a signature? What the
> > what? Why would we do that?
> >
> > Well, as it turns out, even if a quantum computer were able to crack ECDSA, it
> > would yield revealing the private key but not the ability to malleate the
> > content of what was actually signed.  I asked my good friend and cryptographer
> > [Madars Virza](https://madars.org/) if my intuition was correct, and he
> > confirmed that it should be sufficient, but it's definitely worth closer
> > analysis before relying on this. While the ECDSA signature can be malleated to a
> > different, negative form, if the signature is otherwise made immalleable there
> > should only be one value the commitment can be opened to.
> >
> > If we required the ECDSA signature be signed with a quantum proof signature
> > algorithm, then we'd have a quantum proof Bitcoin! And the 5 byte signing scheme
> > we discussed previously is a Lamport signature, which is quantum secure.
> > Unfortunately, we need at least 20 contiguous bytes... so we need some sort of
> > OP\_CAT like operation.
> >
> > OP\_CAT can't be directly soft forked to Segwit v0 because it modifies the
> > stack, so instead we'll (for simplicity) also show how to use a new opcode that
> > uses verify semantics, OP\_SUBSTRINGEQUALVERIFY that checks a splice of a string
> > for equality.
> >
> > ```
> > ... FOR j in 0..=5
> >     <0>
> >     ... FOR i in 0..=31
> >         SWAP hash160 DUP <H(K_j_i_1)> EQUAL IF DROP <2**i> ADD ELSE <H(K_j_i_0)> EQUALVERIFY ENDIF
> >     ... END FOR
> >     TOALTSTACK
> > ... END FOR
> >
> > DUP HASH160
> >
> > ... IF CAT AVAILABLE
> >     FROMALTSTACK
> >     ... FOR j in 0..=5
> >         FROMALTSTACK
> >         CAT
> >     ... END FOR
> >     EQUALVERIFY
> > ... ELSE SUBSTRINGEQUALVERIFY AVAILABLE
> >     ... FOR j in 0..=5
> >         FROMALTSTACK <0+j*4> <4+j*4> SUBSTRINGEQUALVERIFY DROP DROP DROP
> >     ...  END FOR
> >     DROP
> > ... END IF
> >
> > <pk> CHECKSIG
> > ```
> >
> > That's a long script... but will it fit? We need to verify 20 bytes of message
> > each bit takes around 10 bytes script, an average of 3.375 bytes per number
> > (counting pushes), and two 21 bytes keys = 55.375 bytes of program space and 21
> > bytes of witness element per bit.
> >
> > It fits! `20*8*55.375 = 8860`, which leaves 1140 bytes less than the limit for
> > the rest of the logic, which is plenty (around 15-40 bytes required for the rest
> > of the logic, leaving 1100 free for custom signature checking). The stack size
> > is 160 elements for the hash gadget, 3360 bytes.
> >
> > This can probably be made a bit more efficient by expanding to a ternary
> > representation.
> >
> > ```
> >         SWAP hash160 DUP <H(K_j_i_0)> EQUAL  IF DROP  ELSE <3**i> SWAP DUP <H(K_j_i_T)> EQUAL IF DROP SUB ELSE <H(K_j_i_1)> EQUALVERIFY ADD  ENDIF ENDIF
> > ```
> >
> > This should bring it up to roughly 85 bytes per trit, and there should be 101
> > trits (`log(2**160)/log(3) == 100.94`), so about 8560 bytes... a bit cheaper!
> > But the witness stack is "only" `2121` bytes...
> >
> > As a homework exercise, maybe someone can prove the optimal choice of radix for
> > this protocol... My guess is that base 4 is optimal!
> >
> > ## Taproot?
> >
> > What about Taproot? As far as I'm aware the commitment scheme (`Q = pG + hash(pG
> > || m)G`) can be securely opened to m even with a quantum computer (finding `q`
> > such that `qG = Q` might be trivial, but suppose key path was disabled, then
> > finding m and p such that the taproot equation holds should be difficult because
> > of the hash, but I'd need to certify that claim better).  Therefore this
> > script can nest inside of a Tapscript path -- Tapscript also does not impose a
> > length limit, 32 byte hashes could be used as well.
> >
> > Further, to make keys reusable, there could be many Lamport keys comitted inside
> > a taproot tree so that an address could be used for thousands of times before
> > expiring. This could be used as a measure to protect accidental use rather than
> > to support it.
> >
> > Lastly, Schnorr actually has a stronger non-malleability property than ECDSA,
> > the signatures will be binding to the approved transaction and once Lamport
> > signed, even a quantum computer could not steal the funds.
> >
> > --
> > @JeremyRubin
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From billy.tetrud at gmail.com  Fri Jul  9 17:43:47 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Fri, 9 Jul 2021 10:43:47 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <DE1DCFFC-66BC-4EA1-922B-CC3A84A3C9DE@voskuil.org>
References: <CAGpPWDa3uVxa+LR5JMmTjkgYTwFH9wWLChekg=8wCdtQ2=9eQg@mail.gmail.com>
 <DE1DCFFC-66BC-4EA1-922B-CC3A84A3C9DE@voskuil.org>
Message-ID: <CAGpPWDbtwDy2+6dD9eXs72UTf63fw6sK-4Xa6ty14hWP6pOCsA@mail.gmail.com>

>  there is an unsupportable leap being made here

You think that because you're misinterpreting me. I'm in no way claiming
that any solvent company can prove it, I'm simply claiming that any company
can prove that they have bitcoin reserves to cover bitcoins promised as
account balances.

> Banks (lending institutions) do not operate under any such pretense

You seem to be saying that banks are under no legal obligation to serve
cash on demand to customers. While you might be right, again you're
misinterpreting me. Banks do in fact make claims to their customers that
they'll be able to get cash out of their account on demand. They're called
demand deposit accounts for a reason. And certainly customers expect to be
able to withdraw their cash on demand.

> With a 100% of investment cash hoard, there is zero lending and zero
return

I did say "pretend" did I not?

> ?relate to? is a far cry from 100% ?reserve?

Indeed. Again, you seem to be misunderstanding me. You're putting the words
"100% reserve" in my mouth, when I never said any such thing. Proof of
80%/50%/20% reserves is still useful if that's the clear expectation for
the customer/client.

> Nonsense is English for ?doesn?t make sense?

Literally, sure. But in actual use it carries a dismissive and rude
connotation.


On Fri, Jul 9, 2021 at 7:55 AM Eric Voskuil <eric at voskuil.org> wrote:

>
> > On Jul 7, 2021, at 01:20, Billy Tetrud via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > But people can certainly pull their money out of companies that can't
> show solvency.
>
> As I pointed out previously there is an unsupportable leap being made here
> between a vault (money warehouse) and any company (including a bank).
>
> A company cannot possibly show that it has all of the money that every
> person has invested into it. At times a solvent company may even have zero
> cash. It is also not possible for a company provide cryptographic proof of
> its many necessarily non-crypto assets and liabilities. What is presumed
> here is a community-verified sort of crypto balance sheet, with no
> considerations of risk - a central aspect of business.
>
> As I said, if you want a vault, you can just use your own wallet. Solvency
> does not in any way imply 100% cash balance of the amounts invested.
> Raising money under such terms is pointless for both company and investors
> (the owners of the company).
>
> > > Nonsense, any business can fail, regardless of temporal cash reserves.
> >
> > I agree that any business can fail. But a bank that pretends it can
> serve cash on demand is not a normal business,
>
> Banks (lending institutions) do not operate under any such pretense. US
> banks require 7 day time deposits for all interest bearing accounts (read
> your depositor agreement), and it should be clear that your uninsured
> balance is at risk. Banks are investment funds, not money warehouses (in
> Rothbard?s terminology).
>
> With a 100% of investment cash hoard, there is zero lending and zero
> return. This is true for all business.
>
> > and cash reserves absolutely relate to their ability to survive as a
> bank.
>
> ?relate to? is a far cry from 100% ?reserve?. At 100% reserve an
> investment fund would most certainly fail. At 20% it would fail. Money
> markets (banks without a reserve requirement) don?t break the buck, compete
> effectively with banks with reserve requirements (required by the taxpayer
> who is insuring deposits and providing discount credit), and maintain
> around 10% reserve. This is consistent with a world of people with time
> preference that creates around a 10% interest rate (return on investment).
>
> > Its honestly confusing to me how you could think otherwise.
>
> It?s confusing to me how anyone would put money into a business and expect
> (even want) it to sit there.
>
> > Also, calling my thoughts "nonsense" is rude, please check yourself,
> Eric.
>
> Check myself? Nonsense is English for ?doesn?t make sense?. It?s not an
> insult.
>
> e
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210709/52b8cdb6/attachment-0001.html>

From billy.tetrud at gmail.com  Fri Jul  9 22:02:23 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Fri, 9 Jul 2021 15:02:23 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <0A99CF2C-36E4-475F-9160-A999D4AFDA7F@voskuil.org>
References: <CAGpPWDbtwDy2+6dD9eXs72UTf63fw6sK-4Xa6ty14hWP6pOCsA@mail.gmail.com>
 <0A99CF2C-36E4-475F-9160-A999D4AFDA7F@voskuil.org>
Message-ID: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>

@Voskuil
> You can prove that in your own wallet. All other scenarios imply lending
(which is what is implied by ?reserve?) and lending cannot be 100% reserve.

You're using terms in non-standard ways. Putting money into a bank is not
considered "lending" to the bank. You may make a case that you're lending
to a bank, and that they legally owe you repayment of that money on demand
limited by the terms you mentioned. But regardless of a case that can be
made there, pretty much no one considers that "lending". Since you you like
defining things legally, depositing money in a bank is legally not defined
as lending to the bank.

So no, all other scenarios do not imply lending. You can have your coins in
custody with someone else, and that someone else can keep 100% reserves if
they choose (or agreed to) and can prove it to you via the method I
described or the methods others have linked to.

> They are time deposits, read your bank agreement.

You are not correct
<https://www.investopedia.com/terms/t/timedeposit.asp#:~:text=A%20time%20deposit%20is%20an,pre%2Dset%20date%20of%20maturity.&text=Time%20deposits%20generally%20pay%20a,of%20investment%20is%20term%20deposit.>.
Another source
<https://www.slsp.sk/en/personal/faq/what-is-the-difference-between-a-term-deposit-and-savings-account>
if you don't believe me. The only way you would be correct is if banks were
committing fraud and calling something a "savings account" when it isn't in
fact a savings account.

> money markets have had no reserve requirement and have a nearly spotless
record of satisfying their obligations.

Lol, money markets are so new that they've had no opportunity to show their
true risk. In the finance world, things work fine for a long time until
they fail spectacularly, losing more than the gain they made in the first
place. This is a regular occurence. Its the reason bitcoin was created.

> Irrelevant.

It is certainly not irrelevant. People have been lead to believe that they
can withdraw their money from their accounts. People expect this. Banks are
doing nothing to educate people on the limitations of that fact. PoR would
give people the ability to see quite accurately how much reserves there are
and can use this knowledge to put pressure on institutions to keep the
reserves those people think they should keep.

> Without 100% ?reserve? there is no way to cryptographically demonstrate
?solvency?.

You can show proof that you're 80% solvent, and then claim the other 20% is
in other assets. This is, again, still useful.

>The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or
state seizure, no matter what the reserve

You're right, but that's irrelevant.

But it seems like you're not interested in understanding what I'm saying or
discussing these things honestly. So I'm going to end my conversation with
you here.


On Fri, Jul 9, 2021 at 11:32 AM Eric Voskuil via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> > On Jul 9, 2021, at 10:44, Billy Tetrud <billy.tetrud at gmail.com> wrote:
> >
> > >  there is an unsupportable leap being made here
> >
> > You think that because you're misinterpreting me. I'm in no way claiming
> that any solvent company can prove it, I'm simply claiming that any company
> can prove that they have bitcoin reserves to cover bitcoins promised as
> account balances.
>
> You can prove that in your own wallet. All other scenarios imply lending
> (which is what is implied by ?reserve?) and lending cannot be 100% reserve.
>
> > > Banks (lending institutions) do not operate under any such pretense
> >
> > You seem to be saying that banks are under no legal obligation to serve
> cash on demand to customers. While you might be right,
>
> I am, as banks are lending institutions.
>
> > again you're misinterpreting me. Banks do in fact make claims to their
> customers that they'll be able to get cash out of their account on demand.
>
> Up to the insured limit, in 7 days. This is of course true because the
> taxpayer has insured the bank to that level.
>
> > They're called demand deposit accounts for a reason.
>
> They are time deposits, read your bank agreement. Not that it makes any
> difference. How the contract is satisfied is not a term of the contract,
> just that it is. And as I pointed out, money markets have had no reserve
> requirement and have a nearly spotless record of satisfying their
> obligations.
>
> > And certainly customers expect to be able to withdraw their cash on
> demand.
>
> Irrelevant.
>
> > > With a 100% of investment cash hoard, there is zero lending and zero
> return
> >
> > I did say "pretend" did I not?
>
> See above.
>
> > > ?relate to? is a far cry from 100% ?reserve?
> >
> > Indeed. Again, you seem to be misunderstanding me. You're putting the
> words "100% reserve" in my mouth, when I never said any such thing. Proof
> of 80%/50%/20% reserves is still useful if that's the clear expectation for
> the customer/client.
>
> Without 100% ?reserve? there is no way to cryptographically demonstrate
> ?solvency?. And even with that, investors would have to accept the promise
> that there are no other liabilities.
>
> The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or
> state seizure, no matter what the reserve.
>
> It?s information, sure, but it?s not what people seem to think. If one
> wants full reserve banking, use a wallet. If one wants to invest, the money
> will be spent - that?s why it was raised. There can be no covenant placed
> on it that will ensure it?s return.
>
> e
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210709/35b046ea/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Jul  9 22:38:18 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 09 Jul 2021 22:38:18 +0000
Subject: [bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was
	CheckSigFromStack for Arithmetic Values]
In-Reply-To: <CAEM=y+WkG9razw6uEhkXtNCgonaw2GHp9oGB3J7uf9N_JVdPoQ@mail.gmail.com>
References: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>
 <MAfz2o3-uf5SfGKfMwONmT4TH4cmcAEJGyx21_dRQWBuCZZzFSXg38xyRY7HiMYMFB5zuTPorf_LYrnjE2K__uP578h7MZypf68yM0xjU3w=@protonmail.com>
 <CAEM=y+WkG9razw6uEhkXtNCgonaw2GHp9oGB3J7uf9N_JVdPoQ@mail.gmail.com>
Message-ID: <XFMgrCKhdCuJ7LJ2KLv-r8dAGNs89H3NkvZgio5X6evKQ506p54HUF0hyxq0kQ48QeNJzmc--fy5keaSrzUQ7ylteCxe9TJNXnqJvaDy_X4=@protonmail.com>

Good morning Ethan,

> > Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase cough
>
> Couldn't you significantly compress the signatures by using either
> Winternitz OTS or by using OP_CAT to build a merkle tree so that the
> full signature can be derived during script execution from a much
> shorter set of seed values?

To implement Winternitz we need some kind of limited-repeat construct, which is not available in SCRIPT, but may be emulatable with enough `OP_IF` and sheer brute force.
But what you gain in smaller signatures, you lose in a more complex and longer SCRIPT, and there are limits to SCRIPT size (in order to limit the processing done in each node).

Merkle signatures trade off shorter pubkeys for longer signatures (signatures need to provide the hash of the *other* preimage you are not revealing), but in the modern post-SegWit Bitcoin context both pubkeys and signatures are stored in the witness area, which have the same weight, thus it is actually a loss compared to Lamport.


So yes, maybe Winternitz (could be a replacement for the "trinary" Jeremy refers to), Merkle not so much.

Regards,
ZmnSCPxj

> On Thu, Jul 8, 2021 at 4:12 AM ZmnSCPxj via bitcoin-dev
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > Good morning Jeremy,
> > Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase cough
> > Since a quantum computer can derive the EC privkey from the EC pubkey and this scheme is resistant to that, I think you can use a single well-known EC privkey, you just need a unique Lamport keypair for each UTXO (uniqueness being mandatory due to Lamport requiring preimage revelation).
> > Regards,
> > ZmnSCPxj
> >
> > > Dear Bitcoin Devs,
> > > As mentioned previously, OP_CAT (or similar operation) can be used to make Bitcoin "quantum safe" by signing an EC signature. This should work in both Segwit V0 and Tapscript, although you have to use HASH160 for it to fit in Segwit V0.
> > > See my blog for the specific construction, reproduced below.
> > > Yet another entry to the "OP_CAT can do that too" list.
> > > Best,
> > >
> > > Jeremy
> > >
> > > -------
> > >
> > > I recently published a blogpost about signing up to a5 byte value using Bitcoin script arithmetic and Lamport signatures.
> > > By itself, this is neat, but a little limited. What if we could sign longer
> > > messages? If we can sign up to 20 bytes, we could sign a HASH160 digest which
> > > is most likely quantum safe...
> > > What would it mean if we signed the HASH160 digest of a signature? What the
> > > what? Why would we do that?
> > > Well, as it turns out, even if a quantum computer were able to crack ECDSA, it
> > > would yield revealing the private key but not the ability to malleate the
> > > content of what was actually signed. I asked my good friend and cryptographer
> > > Madars Virza if my intuition was correct, and he
> > > confirmed that it should be sufficient, but it's definitely worth closer
> > > analysis before relying on this. While the ECDSA signature can be malleated to a
> > > different, negative form, if the signature is otherwise made immalleable there
> > > should only be one value the commitment can be opened to.
> > > If we required the ECDSA signature be signed with a quantum proof signature
> > > algorithm, then we'd have a quantum proof Bitcoin! And the 5 byte signing scheme
> > > we discussed previously is a Lamport signature, which is quantum secure.
> > > Unfortunately, we need at least 20 contiguous bytes... so we need some sort of
> > > OP\_CAT like operation.
> > > OP\_CAT can't be directly soft forked to Segwit v0 because it modifies the
> > > stack, so instead we'll (for simplicity) also show how to use a new opcode that
> > > uses verify semantics, OP\_SUBSTRINGEQUALVERIFY that checks a splice of a string
> > > for equality.
> > >
> > >     ... FOR j in 0..=5
> > >         <0>
> > >         ... FOR i in 0..=31
> > >             SWAP hash160 DUP <H(K_j_i_1)> EQUAL IF DROP <2**i> ADD ELSE <H(K_j_i_0)> EQUALVERIFY ENDIF
> > >         ... END FOR
> > >         TOALTSTACK
> > >     ... END FOR
> > >
> > >     DUP HASH160
> > >
> > >     ... IF CAT AVAILABLE
> > >         FROMALTSTACK
> > >         ... FOR j in 0..=5
> > >             FROMALTSTACK
> > >             CAT
> > >         ... END FOR
> > >         EQUALVERIFY
> > >     ... ELSE SUBSTRINGEQUALVERIFY AVAILABLE
> > >         ... FOR j in 0..=5
> > >             FROMALTSTACK <0+j*4> <4+j*4> SUBSTRINGEQUALVERIFY DROP DROP DROP
> > >         ...  END FOR
> > >         DROP
> > >     ... END IF
> > >
> > >     <pk> CHECKSIG
> > >
> > >
> > > That's a long script... but will it fit? We need to verify 20 bytes of message
> > > each bit takes around 10 bytes script, an average of 3.375 bytes per number
> > > (counting pushes), and two 21 bytes keys = 55.375 bytes of program space and 21
> > > bytes of witness element per bit.
> > > It fits! `20*8*55.375 = 8860`, which leaves 1140 bytes less than the limit for
> > > the rest of the logic, which is plenty (around 15-40 bytes required for the rest
> > > of the logic, leaving 1100 free for custom signature checking). The stack size
> > > is 160 elements for the hash gadget, 3360 bytes.
> > > This can probably be made a bit more efficient by expanding to a ternary
> > > representation.
> > >
> > >             SWAP hash160 DUP <H(K_j_i_0)> EQUAL  IF DROP  ELSE <3**i> SWAP DUP <H(K_j_i_T)> EQUAL IF DROP SUB ELSE <H(K_j_i_1)> EQUALVERIFY ADD  ENDIF ENDIF
> > >
> > >
> > > This should bring it up to roughly 85 bytes per trit, and there should be 101
> > > trits (`log(2**160)/log(3) == 100.94`), so about 8560 bytes... a bit cheaper!
> > > But the witness stack is "only" `2121` bytes...
> > > As a homework exercise, maybe someone can prove the optimal choice of radix for
> > > this protocol... My guess is that base 4 is optimal!
> > >
> > > Taproot?
> > >
> > > ---------
> > >
> > > What about Taproot? As far as I'm aware the commitment scheme (`Q = pG + hash(pG || m)G`) can be securely opened to m even with a quantum computer (finding `q`
> > > such that `qG = Q` might be trivial, but suppose key path was disabled, then
> > > finding m and p such that the taproot equation holds should be difficult because
> > > of the hash, but I'd need to certify that claim better). Therefore this
> > > script can nest inside of a Tapscript path -- Tapscript also does not impose a
> > > length limit, 32 byte hashes could be used as well.
> > > Further, to make keys reusable, there could be many Lamport keys comitted inside
> > > a taproot tree so that an address could be used for thousands of times before
> > > expiring. This could be used as a measure to protect accidental use rather than
> > > to support it.
> > > Lastly, Schnorr actually has a stronger non-malleability property than ECDSA,
> > > the signatures will be binding to the approved transaction and once Lamport
> > > signed, even a quantum computer could not steal the funds.
> > > --
> > > @JeremyRubin
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jlrubin at mit.edu  Fri Jul  9 22:52:56 2021
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 9 Jul 2021 15:52:56 -0700
Subject: [bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was
 CheckSigFromStack for Arithmetic Values]
In-Reply-To: <CAEM=y+WkG9razw6uEhkXtNCgonaw2GHp9oGB3J7uf9N_JVdPoQ@mail.gmail.com>
References: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>
 <MAfz2o3-uf5SfGKfMwONmT4TH4cmcAEJGyx21_dRQWBuCZZzFSXg38xyRY7HiMYMFB5zuTPorf_LYrnjE2K__uP578h7MZypf68yM0xjU3w=@protonmail.com>
 <CAEM=y+WkG9razw6uEhkXtNCgonaw2GHp9oGB3J7uf9N_JVdPoQ@mail.gmail.com>
Message-ID: <CAD5xwhjaHdp5Rm2O4fS_M=VX3-Orz6jA2=ZUZw1k3zbRWYBWVA@mail.gmail.com>

I thought about this, but at the time of writing I couldn't come up with
something I thought was substantially better. I spent a few more cycles
thinking on it -- you can definitely do better. It's not clear how much
better Winternitz might be, or if it would be secure in this context?
Here's some exploration...

maybe you can do something like:

<x0> <H(x1)> <dir in {0,1}> || IF SWAP HASH SWAP ELSE HASH FROMALTSTACK
<2**n> TOALTSTACK ADD ENDIF CAT

you can process this (assume HASH160) into chunks of 26 bits, cat them all
together, and then stash that hash. You would need 6 gadgets, and then 1
overflow + 4 bare hashes for the final key hash (e.g. your tree looks like)
H(H(26x20) || H(26x20)...H(bit)|| H(bit) || H(bit) || H(bit)). It doesn't
make sense to have a "nice" merkle tree, just fit in as much data as
possible per call (520 bytes). If OP_SHASTREAM, this is even better since
you can ignore structuring...

This would bring your cost down by about 20 bytes per bit, for 160 bits, so
around a savings of 3200 bytes... not bad! 1/3 cheaper.

Script is about 15x160 = 2400 and change, witness is 43x160 = 6880

If you were to convert to 3-ary, you could cut this down to 101 gates with
a script like:

witnesses:
<H(xT)> <H(x1)>   <0> <x0>
<H(x0) || H(x1)> <1> <xT>
<H(xT) || H(x0)>  <2> <x1>

script:
HASH SWAP
IFDUP
NOTIF    # 0 passed in (0)
    SWAP CAT
ELSE
    <3**n> TOALT
    1SUB
    IF # 2 passed in (+1)
        FROMALT # do nothing
    ELSE # 1 passed in (T)
        SWAP # Swaps H(xT) to back
        FROMALT NEGATE # negate
    END
    FROMALT ADD TOALT # add to accumulator
ENDIF
CAT


you would end up having to publish ~64x101 data in the witness, so only
6464 total (and about 24x101 = 2424 and change for the script)

Making the script smaller also means that choice of hash160/sha256 doesn't
change script size much, just witness. And the witnesses are free to
provide their own preimages, so it would be OK to use something > 20 bytes,
< 32 for more variable security/length tradeoff.


At the cost of marginally bigger script (by about 6x101 bytes), you can
save 20x101 off the witness stack by making each key H(H(xT) || H(x0)) ||
H(x1). 43x101 + 30x101 = 7373 + change for the final grouping.

witnesses:
<H(xT)> <H(x1)>   <0> <x0>
<H(x0)> <H(x1)> <1> <xT>
<H(H(xT) || H(x0))>  <2> <x1>

script:
HASH SWAP
IFDUP
NOTIF    # 0 passed in (0)
    ROT SWAP CAT HASH
ELSE
    <3**n> TOALT
    1SUB
    IF # 2 passed in (+1)
        FROMALT # do nothing
    ELSE # 1 passed in (T)
        TOALTSTACK CAT HASH FROMALTSTACK SWAP # Swaps H(xT) to back
        FROMALT NEGATE # negate
    END
    FROMALT ADD TOALT # add to accumulator
ENDIF
CAT


--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Fri, Jul 9, 2021 at 12:03 PM Ethan Heilman <eth3rs at gmail.com> wrote:

> >Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple
> kilobytes)... blocksize increase *cough*
>
> Couldn't you significantly compress the signatures by using either
> Winternitz OTS or by using OP_CAT to build a merkle tree so that the
> full signature can be derived during script execution from a much
> shorter set of seed values?
>
> On Thu, Jul 8, 2021 at 4:12 AM ZmnSCPxj via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >
> > Good morning Jeremy,
> >
> > Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple
> kilobytes)... blocksize increase *cough*
> >
> > Since a quantum computer can derive the EC privkey from the EC pubkey
> and this scheme is resistant to that, I think you can use a single
> well-known EC privkey, you just need a unique Lamport keypair for each UTXO
> (uniqueness being mandatory due to Lamport requiring preimage revelation).
> >
> > Regards,
> > ZmnSCPxj
> >
> >
> > > Dear Bitcoin Devs,
> > >
> > > As mentioned previously, OP_CAT (or similar operation) can be used to
> make Bitcoin "quantum safe" by signing an EC signature. This should work in
> both Segwit V0 and Tapscript, although you have to use HASH160 for it to
> fit in Segwit V0.
> > >
> > > See [my blog](https://rubin.io/blog/2021/07/06/quantum-bitcoin/) for
> the specific construction, reproduced below.
> > >
> > > Yet another entry to the "OP_CAT can do that too" list.
> > >
> > > Best,
> > >
> > > Jeremy
> > > -----
> > >
> > > I recently published [a blog
> > > post](https://rubin.io/blog/2021/07/02/signing-5-bytes/) about
> signing up to a
> > > 5 byte value using Bitcoin script arithmetic and Lamport signatures.
> > >
> > > By itself, this is neat, but a little limited. What if we could sign
> longer
> > > messages? If we can sign up to 20 bytes, we could sign a HASH160
> digest which
> > > is most likely quantum safe...
> > >
> > > What would it mean if we signed the HASH160 digest of a signature?
> What the
> > > what? Why would we do that?
> > >
> > > Well, as it turns out, even if a quantum computer were able to crack
> ECDSA, it
> > > would yield revealing the private key but not the ability to malleate
> the
> > > content of what was actually signed.  I asked my good friend and
> cryptographer
> > > [Madars Virza](https://madars.org/) if my intuition was correct, and
> he
> > > confirmed that it should be sufficient, but it's definitely worth
> closer
> > > analysis before relying on this. While the ECDSA signature can be
> malleated to a
> > > different, negative form, if the signature is otherwise made
> immalleable there
> > > should only be one value the commitment can be opened to.
> > >
> > > If we required the ECDSA signature be signed with a quantum proof
> signature
> > > algorithm, then we'd have a quantum proof Bitcoin! And the 5 byte
> signing scheme
> > > we discussed previously is a Lamport signature, which is quantum
> secure.
> > > Unfortunately, we need at least 20 contiguous bytes... so we need some
> sort of
> > > OP\_CAT like operation.
> > >
> > > OP\_CAT can't be directly soft forked to Segwit v0 because it modifies
> the
> > > stack, so instead we'll (for simplicity) also show how to use a new
> opcode that
> > > uses verify semantics, OP\_SUBSTRINGEQUALVERIFY that checks a splice
> of a string
> > > for equality.
> > >
> > > ```
> > > ... FOR j in 0..=5
> > >     <0>
> > >     ... FOR i in 0..=31
> > >         SWAP hash160 DUP <H(K_j_i_1)> EQUAL IF DROP <2**i> ADD ELSE
> <H(K_j_i_0)> EQUALVERIFY ENDIF
> > >     ... END FOR
> > >     TOALTSTACK
> > > ... END FOR
> > >
> > > DUP HASH160
> > >
> > > ... IF CAT AVAILABLE
> > >     FROMALTSTACK
> > >     ... FOR j in 0..=5
> > >         FROMALTSTACK
> > >         CAT
> > >     ... END FOR
> > >     EQUALVERIFY
> > > ... ELSE SUBSTRINGEQUALVERIFY AVAILABLE
> > >     ... FOR j in 0..=5
> > >         FROMALTSTACK <0+j*4> <4+j*4> SUBSTRINGEQUALVERIFY DROP DROP
> DROP
> > >     ...  END FOR
> > >     DROP
> > > ... END IF
> > >
> > > <pk> CHECKSIG
> > > ```
> > >
> > > That's a long script... but will it fit? We need to verify 20 bytes of
> message
> > > each bit takes around 10 bytes script, an average of 3.375 bytes per
> number
> > > (counting pushes), and two 21 bytes keys = 55.375 bytes of program
> space and 21
> > > bytes of witness element per bit.
> > >
> > > It fits! `20*8*55.375 = 8860`, which leaves 1140 bytes less than the
> limit for
> > > the rest of the logic, which is plenty (around 15-40 bytes required
> for the rest
> > > of the logic, leaving 1100 free for custom signature checking). The
> stack size
> > > is 160 elements for the hash gadget, 3360 bytes.
> > >
> > > This can probably be made a bit more efficient by expanding to a
> ternary
> > > representation.
> > >
> > > ```
> > >         SWAP hash160 DUP <H(K_j_i_0)> EQUAL  IF DROP  ELSE <3**i> SWAP
> DUP <H(K_j_i_T)> EQUAL IF DROP SUB ELSE <H(K_j_i_1)> EQUALVERIFY ADD  ENDIF
> ENDIF
> > > ```
> > >
> > > This should bring it up to roughly 85 bytes per trit, and there should
> be 101
> > > trits (`log(2**160)/log(3) == 100.94`), so about 8560 bytes... a bit
> cheaper!
> > > But the witness stack is "only" `2121` bytes...
> > >
> > > As a homework exercise, maybe someone can prove the optimal choice of
> radix for
> > > this protocol... My guess is that base 4 is optimal!
> > >
> > > ## Taproot?
> > >
> > > What about Taproot? As far as I'm aware the commitment scheme (`Q = pG
> + hash(pG
> > > || m)G`) can be securely opened to m even with a quantum computer
> (finding `q`
> > > such that `qG = Q` might be trivial, but suppose key path was
> disabled, then
> > > finding m and p such that the taproot equation holds should be
> difficult because
> > > of the hash, but I'd need to certify that claim better).  Therefore
> this
> > > script can nest inside of a Tapscript path -- Tapscript also does not
> impose a
> > > length limit, 32 byte hashes could be used as well.
> > >
> > > Further, to make keys reusable, there could be many Lamport keys
> comitted inside
> > > a taproot tree so that an address could be used for thousands of times
> before
> > > expiring. This could be used as a measure to protect accidental use
> rather than
> > > to support it.
> > >
> > > Lastly, Schnorr actually has a stronger non-malleability property than
> ECDSA,
> > > the signatures will be binding to the approved transaction and once
> Lamport
> > > signed, even a quantum computer could not steal the funds.
> > >
> > > --
> > > @JeremyRubin
> >
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210709/61192298/attachment-0001.html>

From eric at voskuil.org  Fri Jul  9 23:18:26 2021
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 9 Jul 2021 16:18:26 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>
References: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>
Message-ID: <00e201d77518$b8ed8e00$2ac8aa00$@voskuil.org>

>> You can prove that in your own wallet. All other scenarios imply lending (which is what is implied by ?reserve?) and lending cannot be 100% reserve.

>You're using terms in non-standard ways. Putting money into a bank is not considered "lending" to the bank.

What people consider is irrelevant, all that matters is what is correct. A bank account as you are referring to it is indistinguishable from a money market (investment) fund in all aspects but federal reserve membership and regulatory controls. Interest (and offset expenses) derives directly from their earnings on this *investment*. Describing it otherwise is either an error (leading to false conclusions) or a lie.

> You may make a case that you're lending to a bank, and that they legally owe you repayment of that money on demand limited by the terms you mentioned. But regardless of a case that can be made there, pretty much no one considers that "lending". Since you you like defining things legally, depositing money in a bank is legally not defined as lending to the bank.

Please don?t bother to try and use statue as if it was at all relevant regarding economic concepts.

> So no, all other scenarios do not imply lending. You can have your coins in custody with someone else, and that someone else can keep 100% reserves if they choose (or agreed to) and can prove it to you via the method I described or the methods others have linked to. 

That?s what Rothbard calls a ?warehouse? - in order to distinguish it from investment. I?ve already made this distinction. Easier to prove with your own wallet, as I said. You are conflating this with banking, which should be obvious.

>> They are time deposits, read your bank agreement.

> You are https://www.investopedia.com/terms/t/timedeposit.asp#:~:text=A%20time%20deposit%20is%20an,pre%2Dset%20date%20of%20maturity.&text=Time%20deposits%20generally%20pay%20a,of%20investment%20is%20term%20deposit.. https://www.slsp.sk/en/personal/faq/what-is-the-difference-between-a-term-deposit-and-savings-account if you don't believe me. The only way you would be correct is if banks were committing fraud and calling something a "savings account" when it isn't in fact a savings account.

No, I am not wrong. It's not a question of believing you, it's a question of understanding the concepts. You will find this language in your deposit agreement (as required by statute):

"9. Our right to require advance notice of withdrawals
For all savings accounts and all personal interest-bearing checking accounts, we reserve the right to require seven days? prior written notice of withdrawal."
https://www.chase.com/content/dam/chasecom/en/checking/documents/deposit_account_agreement.pdf

"When a man deposits goods at a warehouse, he is given a receipt and pays the owner of the warehouse a certain sum for the service of storage. He still retains ownership of the property; the owner of the warehouse is simply guarding it for him. When the warehouse receipt is presented, the owner is obligated to restore the good deposited. A warehouse specializing in money is known as a "bank.""
- Rothbard

As you can see, he is not talking about what you are talking about when it comes to colloquial use of the term "bank", he is clear to define what he means by "bank".

"Someone else's property is taken by the warehouse and used for its own money-making purposes. It is not borrowed, since no interest is paid for the use of the money."
- Rothbard

Any expectation of interest implies *borrowing*, in other words, a *loan* to the bank.

"Whether saved capital is channeled into investments via stocks or via loans is unimportant. The only difference is in the legal technicalities. Indeed, even the legal difference between the creditor and the owner is a negligible one."
- Rothbard

> You're using terms in non-standard ways. Putting money into a bank is not considered "lending" to the bank.

I think it's quite clear that Rothbard considers it lending. I'm not big on appeal to authority, but sometimes it helps open minds. Links here:

https://github.com/libbitcoin/libbitcoin-system/wiki/Full-Reserve-Fallacy

>> money markets have had no reserve requirement and have a nearly spotless record of satisfying their obligations.

> Lol, money markets are so new that they've had no opportunity to show their true risk.

1971, 50 years.
https://en.wikipedia.org/wiki/Money_market_fund

> In the finance world, things work fine for a long time until they fail spectacularly, losing more than the gain they made in the first place. This is a regular occurence. Its the reason bitcoin was created.

regular occurrence...

"Buck breaking has rarely happened. Up to the 2008 financial crisis, only three money funds had broken the buck in the 37-year history of money funds... The first money market mutual fund to break the buck was First Multifund for Daily Income (FMDI) in 1978, liquidating and restating NAV at 94 cents per share"

An investment loss of 6%.

"The Community Bankers US Government Fund broke the buck in 1994, paying investors 96 cents per share."

An investment loss of 4%.

"This was only the second failure in the then 23-year history of money funds and there were no further failures for 14 years... No further failures occurred until September 2008, a month that saw tumultuous events for money funds."

It was a "tumultuous" month for nearly all investments. The feds of course doled out the pork, and the funds had to take it (as if their competition did and they didn't they would fail due to higher relative capital costs and thereby lower rates). In the past, absent pork, they had raised money where necessary to maintain their NAV (just as banks do, but they go to the taxpayer, and just as all business do from time to time).

These are remarkably stable in terms of NAV. And people seem to be satisfied with them:

"At the end of 2011, there were 632 money market funds in operation,[19] with total assets of nearly US$2.7 trillion.[19] Of this $2.7 trillion, retail money market funds had $940 billion in Assets Under Management (AUM). Institutional funds had $1.75 trillion under management.[19]"

The point being, that this is as close to free market bank-based investing as exists in the white market. In a money market fund, the NAV is reflected in the share price, so any losses are evenly distributed - no different than when all those HODLers take a hit when Elon farts, and the reserve they maintain has been very effective in maintaining their $1/share *target* despite paying *interest* on *investments*. They are merely shifting market returns into interest, just like banks. Market returns over short periods aren't always positive. No surprise. The larger point being, BANKS ARE INVESTMENT FUNDS.

>> Irrelevant.

> It is certainly not irrelevant. People have been lead to believe that they can withdraw their money from their accounts. People expect this.

Irrelevant, people have minds and free will and can read the contracts they are actually signing. Contracts are the *actual* Law associated with non-aggression.

> Banks are doing nothing to educate people on the limitations of that fact.

Again, irrelevant. And wholly unnecessary given compulsory taxpayer deposit insurance.

> PoR would give people the ability to see quite accurately how much reserves there are and can use this knowledge to put pressure on institutions to keep the reserves those people think they should keep. 

For all of the reasons I've stated, it's a fairly pointless exercise, but people can do what they want. But if they are doing this with a deeply flawed understanding of banking to start with, they will be disappointed in the outcome.

>> Without 100% ?reserve? there is no way to cryptographically demonstrate ?solvency?. 

> You can show proof that you're 80% solvent, and then claim the other 20% is in other assets. This is, again, still useful. 

80% solvent ... 50% pregnant.

>>The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or state seizure, no matter what the reserve

> You're right, but that's irrelevant. 

I'll leave that to the reader. The alternative is to use your own wallet.

> But it seems like you're not interested in understanding what I'm saying or discussing these things honestly.

I'm not interested in allowing flawed concepts to be perpetuated without question. This is just a drain on capital that could be put to much better use. How many times have I heard the oxymoron "full reserve banking", and how much capital has been burned on this futile exercise, simply due to a failure to understand these concepts.

> So I'm going to end my conversation with you here.

While seemingly off-topic, these are things that need to be aired in this community. Thanks for the discourse.

e

On Fri, Jul 9, 2021 at 11:32 AM Eric Voskuil via bitcoin-dev <mailto:bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Jul 9, 2021, at 10:44, Billy Tetrud <mailto:billy.tetrud at gmail.com> wrote:
> 
> >  there is an unsupportable leap being made here
> 
> You think that because you're misinterpreting me. I'm in no way claiming that any solvent company can prove it, I'm simply claiming that any company can prove that they have bitcoin reserves to cover bitcoins promised as account balances. 

You can prove that in your own wallet. All other scenarios imply lending (which is what is implied by ?reserve?) and lending cannot be 100% reserve.

> > Banks (lending institutions) do not operate under any such pretense
> 
> You seem to be saying that banks are under no legal obligation to serve cash on demand to customers. While you might be right,

I am, as banks are lending institutions.

> again you're misinterpreting me. Banks do in fact make claims to their customers that they'll be able to get cash out of their account on demand.

Up to the insured limit, in 7 days. This is of course true because the taxpayer has insured the bank to that level.

> They're called demand deposit accounts for a reason.

They are time deposits, read your bank agreement. Not that it makes any difference. How the contract is satisfied is not a term of the contract, just that it is. And as I pointed out, money markets have had no reserve requirement and have a nearly spotless record of satisfying their obligations.

> And certainly customers expect to be able to withdraw their cash on demand. 

Irrelevant.

> > With a 100% of investment cash hoard, there is zero lending and zero return
> 
> I did say "pretend" did I not?

See above.

> > ?relate to? is a far cry from 100% ?reserve?
> 
> Indeed. Again, you seem to be misunderstanding me. You're putting the words "100% reserve" in my mouth, when I never said any such thing. Proof of 80%/50%/20% reserves is still useful if that's the clear expectation for the customer/client.

Without 100% ?reserve? there is no way to cryptographically demonstrate ?solvency?. And even with that, investors would have to accept the promise that there are no other liabilities.

The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or state seizure, no matter what the reserve.

It?s information, sure, but it?s not what people seem to think. If one wants full reserve banking, use a wallet. If one wants to invest, the money will be spent - that?s why it was raised. There can be no covenant placed on it that will ensure it?s return.

e
_______________________________________________
bitcoin-dev mailing list
mailto:bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From eth3rs at gmail.com  Fri Jul  9 23:25:06 2021
From: eth3rs at gmail.com (Ethan Heilman)
Date: Fri, 9 Jul 2021 19:25:06 -0400
Subject: [bitcoin-dev] OP_CAT Makes Bitcoin Quantum Secure [was
 CheckSigFromStack for Arithmetic Values]
In-Reply-To: <XFMgrCKhdCuJ7LJ2KLv-r8dAGNs89H3NkvZgio5X6evKQ506p54HUF0hyxq0kQ48QeNJzmc--fy5keaSrzUQ7ylteCxe9TJNXnqJvaDy_X4=@protonmail.com>
References: <CAD5xwhgzR8e5r1e4H-5EH2mSsE1V39dd06+TgYniFnXFSBqLxw@mail.gmail.com>
 <MAfz2o3-uf5SfGKfMwONmT4TH4cmcAEJGyx21_dRQWBuCZZzFSXg38xyRY7HiMYMFB5zuTPorf_LYrnjE2K__uP578h7MZypf68yM0xjU3w=@protonmail.com>
 <CAEM=y+WkG9razw6uEhkXtNCgonaw2GHp9oGB3J7uf9N_JVdPoQ@mail.gmail.com>
 <XFMgrCKhdCuJ7LJ2KLv-r8dAGNs89H3NkvZgio5X6evKQ506p54HUF0hyxq0kQ48QeNJzmc--fy5keaSrzUQ7ylteCxe9TJNXnqJvaDy_X4=@protonmail.com>
Message-ID: <CAEM=y+U4EsS+gLyEqtxkG-8pEDtmMV8NEug5uQ_q0niwDHmkEw@mail.gmail.com>

>To implement Winternitz we need some kind of limited-repeat construct, which is not available in SCRIPT, but may be emulatable with enough `OP_IF` and sheer brute force.
But what you gain in smaller signatures, you lose in a more complex
and longer SCRIPT, and there are limits to SCRIPT size (in order to
limit the processing done in each node).

Using depth 4 Winternitz would increase the number of instructions in
SCRIPT by 4*(signature bits/2) instructions, but decrease the
signature size by (signature bits/2) hash preimages. Given that
instructions are significantly smaller in size than the hash preimages
used, it seems like this would significantly reduce total size.

>Merkle signatures trade off shorter pubkeys for longer signatures (signatures need to provide the hash of the *other* preimage you are not revealing), but in the modern post-SegWit Bitcoin context both pubkeys and signatures are stored in the witness area, which have the same weight, thus it is actually a loss compared to Lamport.

I wasn't proposing using plain merkle signatures, rather I was
thinking about something where if particular chunks of the message fit
a pattern you could release a seed higher in the commitment tree. For
instance 1,1,1 could be signed as by releasing H(01||H(01||H(01||x))),
 H(11||H(11||H(11||x))), H(21||H(21||H(21||x))), or by releasing X.
However, you would want to only release X in that one specific case
(1,1,1) but no others. Again this would bloat the SCRIPT and decrease
signature size but at a favorable ratio.

I am not convinced anyone should do these things, but they are fun to
think about and I suspect with more thought such signature sizes and
SCRIPT sizes could be even further reduced.

On Fri, Jul 9, 2021 at 6:38 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> Good morning Ethan,
>
> > > Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase cough
> >
> > Couldn't you significantly compress the signatures by using either
> > Winternitz OTS or by using OP_CAT to build a merkle tree so that the
> > full signature can be derived during script execution from a much
> > shorter set of seed values?
>
> To implement Winternitz we need some kind of limited-repeat construct, which is not available in SCRIPT, but may be emulatable with enough `OP_IF` and sheer brute force.
> But what you gain in smaller signatures, you lose in a more complex and longer SCRIPT, and there are limits to SCRIPT size (in order to limit the processing done in each node).
>
> Merkle signatures trade off shorter pubkeys for longer signatures (signatures need to provide the hash of the *other* preimage you are not revealing), but in the modern post-SegWit Bitcoin context both pubkeys and signatures are stored in the witness area, which have the same weight, thus it is actually a loss compared to Lamport.
>
>
> So yes, maybe Winternitz (could be a replacement for the "trinary" Jeremy refers to), Merkle not so much.
>
> Regards,
> ZmnSCPxj
>
> > On Thu, Jul 8, 2021 at 4:12 AM ZmnSCPxj via bitcoin-dev
> > bitcoin-dev at lists.linuxfoundation.org wrote:
> >
> > > Good morning Jeremy,
> > > Yes, quite neat indeed, too bad Lamport signatures are so huge (a couple kilobytes)... blocksize increase cough
> > > Since a quantum computer can derive the EC privkey from the EC pubkey and this scheme is resistant to that, I think you can use a single well-known EC privkey, you just need a unique Lamport keypair for each UTXO (uniqueness being mandatory due to Lamport requiring preimage revelation).
> > > Regards,
> > > ZmnSCPxj
> > >
> > > > Dear Bitcoin Devs,
> > > > As mentioned previously, OP_CAT (or similar operation) can be used to make Bitcoin "quantum safe" by signing an EC signature. This should work in both Segwit V0 and Tapscript, although you have to use HASH160 for it to fit in Segwit V0.
> > > > See my blog for the specific construction, reproduced below.
> > > > Yet another entry to the "OP_CAT can do that too" list.
> > > > Best,
> > > >
> > > > Jeremy
> > > >
> > > > -------
> > > >
> > > > I recently published a blogpost about signing up to a5 byte value using Bitcoin script arithmetic and Lamport signatures.
> > > > By itself, this is neat, but a little limited. What if we could sign longer
> > > > messages? If we can sign up to 20 bytes, we could sign a HASH160 digest which
> > > > is most likely quantum safe...
> > > > What would it mean if we signed the HASH160 digest of a signature? What the
> > > > what? Why would we do that?
> > > > Well, as it turns out, even if a quantum computer were able to crack ECDSA, it
> > > > would yield revealing the private key but not the ability to malleate the
> > > > content of what was actually signed. I asked my good friend and cryptographer
> > > > Madars Virza if my intuition was correct, and he
> > > > confirmed that it should be sufficient, but it's definitely worth closer
> > > > analysis before relying on this. While the ECDSA signature can be malleated to a
> > > > different, negative form, if the signature is otherwise made immalleable there
> > > > should only be one value the commitment can be opened to.
> > > > If we required the ECDSA signature be signed with a quantum proof signature
> > > > algorithm, then we'd have a quantum proof Bitcoin! And the 5 byte signing scheme
> > > > we discussed previously is a Lamport signature, which is quantum secure.
> > > > Unfortunately, we need at least 20 contiguous bytes... so we need some sort of
> > > > OP\_CAT like operation.
> > > > OP\_CAT can't be directly soft forked to Segwit v0 because it modifies the
> > > > stack, so instead we'll (for simplicity) also show how to use a new opcode that
> > > > uses verify semantics, OP\_SUBSTRINGEQUALVERIFY that checks a splice of a string
> > > > for equality.
> > > >
> > > >     ... FOR j in 0..=5
> > > >         <0>
> > > >         ... FOR i in 0..=31
> > > >             SWAP hash160 DUP <H(K_j_i_1)> EQUAL IF DROP <2**i> ADD ELSE <H(K_j_i_0)> EQUALVERIFY ENDIF
> > > >         ... END FOR
> > > >         TOALTSTACK
> > > >     ... END FOR
> > > >
> > > >     DUP HASH160
> > > >
> > > >     ... IF CAT AVAILABLE
> > > >         FROMALTSTACK
> > > >         ... FOR j in 0..=5
> > > >             FROMALTSTACK
> > > >             CAT
> > > >         ... END FOR
> > > >         EQUALVERIFY
> > > >     ... ELSE SUBSTRINGEQUALVERIFY AVAILABLE
> > > >         ... FOR j in 0..=5
> > > >             FROMALTSTACK <0+j*4> <4+j*4> SUBSTRINGEQUALVERIFY DROP DROP DROP
> > > >         ...  END FOR
> > > >         DROP
> > > >     ... END IF
> > > >
> > > >     <pk> CHECKSIG
> > > >
> > > >
> > > > That's a long script... but will it fit? We need to verify 20 bytes of message
> > > > each bit takes around 10 bytes script, an average of 3.375 bytes per number
> > > > (counting pushes), and two 21 bytes keys = 55.375 bytes of program space and 21
> > > > bytes of witness element per bit.
> > > > It fits! `20*8*55.375 = 8860`, which leaves 1140 bytes less than the limit for
> > > > the rest of the logic, which is plenty (around 15-40 bytes required for the rest
> > > > of the logic, leaving 1100 free for custom signature checking). The stack size
> > > > is 160 elements for the hash gadget, 3360 bytes.
> > > > This can probably be made a bit more efficient by expanding to a ternary
> > > > representation.
> > > >
> > > >             SWAP hash160 DUP <H(K_j_i_0)> EQUAL  IF DROP  ELSE <3**i> SWAP DUP <H(K_j_i_T)> EQUAL IF DROP SUB ELSE <H(K_j_i_1)> EQUALVERIFY ADD  ENDIF ENDIF
> > > >
> > > >
> > > > This should bring it up to roughly 85 bytes per trit, and there should be 101
> > > > trits (`log(2**160)/log(3) == 100.94`), so about 8560 bytes... a bit cheaper!
> > > > But the witness stack is "only" `2121` bytes...
> > > > As a homework exercise, maybe someone can prove the optimal choice of radix for
> > > > this protocol... My guess is that base 4 is optimal!
> > > >
> > > > Taproot?
> > > >
> > > > ---------
> > > >
> > > > What about Taproot? As far as I'm aware the commitment scheme (`Q = pG + hash(pG || m)G`) can be securely opened to m even with a quantum computer (finding `q`
> > > > such that `qG = Q` might be trivial, but suppose key path was disabled, then
> > > > finding m and p such that the taproot equation holds should be difficult because
> > > > of the hash, but I'd need to certify that claim better). Therefore this
> > > > script can nest inside of a Tapscript path -- Tapscript also does not impose a
> > > > length limit, 32 byte hashes could be used as well.
> > > > Further, to make keys reusable, there could be many Lamport keys comitted inside
> > > > a taproot tree so that an address could be used for thousands of times before
> > > > expiring. This could be used as a measure to protect accidental use rather than
> > > > to support it.
> > > > Lastly, Schnorr actually has a stronger non-malleability property than ECDSA,
> > > > the signatures will be binding to the approved transaction and once Lamport
> > > > signed, even a quantum computer could not steal the funds.
> > > > --
> > > > @JeremyRubin
> > >
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>

From ZmnSCPxj at protonmail.com  Fri Jul  9 23:50:45 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 09 Jul 2021 23:50:45 +0000
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <00e201d77518$b8ed8e00$2ac8aa00$@voskuil.org>
References: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>
 <00e201d77518$b8ed8e00$2ac8aa00$@voskuil.org>
Message-ID: <ZoFreCcyjxc8AE2qCEEsUaxR9JmnqCftuu45MV2K9hcusSnF4hIWQzfs1I3A_2efCF0TMTVzGOata5RZfR_hLz0i4wuWO-JTfU9vqbEuxYY=@protonmail.com>

Good morning e,


>     Any expectation of interest implies borrowing, in other words, a loan to the bank.

Perhaps this is the key point of contention?

In cases where Bitcoin is given over to an exchange, there is no expectation of interest, at least in the sense that there is no expectation that the number of Bitcoins deposited in the exchange *increase* over time.
(There may be an expectation of an increase in the number of green-ink historical commemoration papers it can buy, but the point is that the number of Bitcoins held in behalf of the user is not expected to change)

The expectation is that exchanges earn money from the difference between buy-price and sell-price, and the money-warehousing service they provide is simply provided for free to facilitate their *main* business (i.e. brokers for *exchange*).
Thus, the expectation is that the exchange provides a warehouse service, not a bank service, and this service is provided for free since it enables their *real* business of earning from bid-ask spreads.

On the other hand, not your keys not your coins, so anyone who uses such a warehouse has whatever happens to the funds coming for them...

And of course exchanges need not earn money *just* from bid-ask spreads *in practice*, so they are unlikely to provide proof-of-reserves either.

Indeed, money warehousing may very well be provided by means other than proof-of-reserves, such as by using multisig the way Green wallet does, with better security.
Perhaps "pure exchanges" would be more amenable to such a scheme rather than proof-of-reserves.

Regards,
ZmnSCPxj

>
>     "Whether saved capital is channeled into investments via stocks or via loans is unimportant. The only difference is in the legal technicalities. Indeed, even the legal difference between the creditor and the owner is a negligible one."
>
> -   Rothbard
>
> > You're using terms in non-standard ways. Putting money into a bank is not considered "lending" to the bank.
>
> I think it's quite clear that Rothbard considers it lending. I'm not big on appeal to authority, but sometimes it helps open minds. Links here:
>
> https://github.com/libbitcoin/libbitcoin-system/wiki/Full-Reserve-Fallacy
>
> > > money markets have had no reserve requirement and have a nearly spotless record of satisfying their obligations.
>
> > Lol, money markets are so new that they've had no opportunity to show their true risk.
>
> 1971, 50 years.
> https://en.wikipedia.org/wiki/Money_market_fund
>
> > In the finance world, things work fine for a long time until they fail spectacularly, losing more than the gain they made in the first place. This is a regular occurence. Its the reason bitcoin was created.
>
> regular occurrence...
>
> "Buck breaking has rarely happened. Up to the 2008 financial crisis, only three money funds had broken the buck in the 37-year history of money funds... The first money market mutual fund to break the buck was First Multifund for Daily Income (FMDI) in 1978, liquidating and restating NAV at 94 cents per share"
>
> An investment loss of 6%.
>
> "The Community Bankers US Government Fund broke the buck in 1994, paying investors 96 cents per share."
>
> An investment loss of 4%.
>
> "This was only the second failure in the then 23-year history of money funds and there were no further failures for 14 years... No further failures occurred until September 2008, a month that saw tumultuous events for money funds."
>
> It was a "tumultuous" month for nearly all investments. The feds of course doled out the pork, and the funds had to take it (as if their competition did and they didn't they would fail due to higher relative capital costs and thereby lower rates). In the past, absent pork, they had raised money where necessary to maintain their NAV (just as banks do, but they go to the taxpayer, and just as all business do from time to time).
>
> These are remarkably stable in terms of NAV. And people seem to be satisfied with them:
>
> "At the end of 2011, there were 632 money market funds in operation,[19] with total assets of nearly US$2.7 trillion.[19] Of this $2.7 trillion, retail money market funds had $940 billion in Assets Under Management (AUM). Institutional funds had $1.75 trillion under management.[19]"
>
> The point being, that this is as close to free market bank-based investing as exists in the white market. In a money market fund, the NAV is reflected in the share price, so any losses are evenly distributed - no different than when all those HODLers take a hit when Elon farts, and the reserve they maintain has been very effective in maintaining their $1/share target despite paying interest on investments. They are merely shifting market returns into interest, just like banks. Market returns over short periods aren't always positive. No surprise. The larger point being, BANKS ARE INVESTMENT FUNDS.
>
> > > Irrelevant.
>
> > It is certainly not irrelevant. People have been lead to believe that they can withdraw their money from their accounts. People expect this.
>
> Irrelevant, people have minds and free will and can read the contracts they are actually signing. Contracts are theactual Law associated with non-aggression.
>
> > Banks are doing nothing to educate people on the limitations of that fact.
>
> Again, irrelevant. And wholly unnecessary given compulsory taxpayer deposit insurance.
>
> > PoR would give people the ability to see quite accurately how much reserves there are and can use this knowledge to put pressure on institutions to keep the reserves those people think they should keep.
>
> For all of the reasons I've stated, it's a fairly pointless exercise, but people can do what they want. But if they are doing this with a deeply flawed understanding of banking to start with, they will be disappointed in the outcome.
>
> > > Without 100% ?reserve? there is no way to cryptographically demonstrate ?solvency?.
>
> > You can show proof that you're 80% solvent, and then claim the other 20% is in other assets. This is, again, still useful.
>
> 80% solvent ... 50% pregnant.
>
> > > The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or state seizure, no matter what the reserve
>
> > You're right, but that's irrelevant.
>
> I'll leave that to the reader. The alternative is to use your own wallet.
>
> > But it seems like you're not interested in understanding what I'm saying or discussing these things honestly.
>
> I'm not interested in allowing flawed concepts to be perpetuated without question. This is just a drain on capital that could be put to much better use. How many times have I heard the oxymoron "full reserve banking", and how much capital has been burned on this futile exercise, simply due to a failure to understand these concepts.
>
> > So I'm going to end my conversation with you here.
>
> While seemingly off-topic, these are things that need to be aired in this community. Thanks for the discourse.
>
> e
>
> On Fri, Jul 9, 2021 at 11:32 AM Eric Voskuil via bitcoin-dev mailto:bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > On Jul 9, 2021, at 10:44, Billy Tetrud mailto:billy.tetrud at gmail.com wrote:
> >
> > > there is an unsupportable leap being made here
> >
> > You think that because you're misinterpreting me. I'm in no way claiming that any solvent company can prove it, I'm simply claiming that any company can prove that they have bitcoin reserves to cover bitcoins promised as account balances.
>
> You can prove that in your own wallet. All other scenarios imply lending (which is what is implied by ?reserve?) and lending cannot be 100% reserve.
>
> > > Banks (lending institutions) do not operate under any such pretense
> >
> > You seem to be saying that banks are under no legal obligation to serve cash on demand to customers. While you might be right,
>
> I am, as banks are lending institutions.
>
> > again you're misinterpreting me. Banks do in fact make claims to their customers that they'll be able to get cash out of their account on demand.
>
> Up to the insured limit, in 7 days. This is of course true because the taxpayer has insured the bank to that level.
>
> > They're called demand deposit accounts for a reason.
>
> They are time deposits, read your bank agreement. Not that it makes any difference. How the contract is satisfied is not a term of the contract, just that it is. And as I pointed out, money markets have had no reserve requirement and have a nearly spotless record of satisfying their obligations.
>
> > And certainly customers expect to be able to withdraw their cash on demand.
>
> Irrelevant.
>
> > > With a 100% of investment cash hoard, there is zero lending and zero return
> >
> > I did say "pretend" did I not?
>
> See above.
>
> > > ?relate to? is a far cry from 100% ?reserve?
> >
> > Indeed. Again, you seem to be misunderstanding me. You're putting the words "100% reserve" in my mouth, when I never said any such thing. Proof of 80%/50%/20% reserves is still useful if that's the clear expectation for the customer/client.
>
> Without 100% ?reserve? there is no way to cryptographically demonstrate ?solvency?. And even with that, investors would have to accept the promise that there are no other liabilities.
>
> The schemes don?t preclude hacks, insider or otherwise, bankruptcy, or state seizure, no matter what the reserve.
>
> It?s information, sure, but it?s not what people seem to think. If one wants full reserve banking, use a wallet. If one wants to invest, the money will be spent - that?s why it was raised. There can be no covenant placed on it that will ensure it?s return.
>
> e
>
> bitcoin-dev mailing list
> mailto:bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From jlrubin at mit.edu  Sat Jul 10 00:11:58 2021
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 9 Jul 2021 17:11:58 -0700
Subject: [bitcoin-dev] BIP-118 / SigHash "what's covered" Cheatsheet
Message-ID: <CAD5xwhjtrME--5ORiYvHyFbeBhhyJsJmsc9W5r-NsgvWYfLurA@mail.gmail.com>

As a part of my ongoing review of BIP-118 I put together the following
chart.

Source:
https://docs.google.com/spreadsheets/d/1KeWJ_cly9zoRX5_h70RTniRT2m8_iaVceK_aF6obWeM

Not tightly checked to be free of errors, but I figured such a chart would
be helpful for folks evaluating BIP-118.

Perhaps the BIPs (generally, incl 34x) could be updated to present the
information in such a chart -- at least for me it's much clearer than
following a bunch of conditional logic (maybe if there's ever desire for
some consensus refactoring this could be a table in the code replacing the
cond logic).

[image: image.png]

A few highlighted nuances:

- input index is never signed (i previously thought one mode signed it).
Key reuse under APOAS|Default and APOAS|All is a bit extra unsafe given
susceptibility to the "half-spend" problem. This limits usability of APO
for covenants a-la CTV because you can't stop someone from adding inputs to
your contract nor can you prevent half-spend problems when reusing
addresses.
- APO signs the Amounts, APOAS never does.
- APO signs both the SPK and the Tapleaf hash, meaning that APO binds
itself to the entire script rather than just it's fragment. There's no
setting which is "just this fragment"
- APO's signature binds it to a specific script fragment *within* a taproot
key, but not a specific script path
- the flag "default" is not really a flag at all -- when default is used
(as a or'd byte) there are different results than when default is inferred
(by absence of a byte) (this is maybe a bitcoin core specific quirk).
- There are 16 different possible modes total, so all combinations of flags
mean *something* (advisable or not as with ACP | None)
- | Default and | All overlap, so there's an opportunity to either reserve
or assign 4 additional sighash modes if desired. These could cover some of
the gaps above, or be saved for future purposes rather than be wasted now.
Another point of interest is -- not to rock the boat -- but because BIP-118
is defining a new key type we could do away with the notion that sighash
flags are "flags" and convert to an enum (e.g., numbered 0-256 for whatever
combination of fields each would incur) and give each signature type a
sensible name, rather than thinking of things as a combo of flags (e.g.,
APOAS is not some intersection of what APO and ACP do independently).

Hopefully this helps!

Cheers,

Jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210709/620c1d70/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: image.png
Type: image/png
Size: 1104237 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210709/620c1d70/attachment-0001.png>

From eric at voskuil.org  Sat Jul 10 00:49:52 2021
From: eric at voskuil.org (eric at voskuil.org)
Date: Fri, 9 Jul 2021 17:49:52 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <ZoFreCcyjxc8AE2qCEEsUaxR9JmnqCftuu45MV2K9hcusSnF4hIWQzfs1I3A_2efCF0TMTVzGOata5RZfR_hLz0i4wuWO-JTfU9vqbEuxYY=@protonmail.com>
References: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>
 <00e201d77518$b8ed8e00$2ac8aa00$@voskuil.org>
 <ZoFreCcyjxc8AE2qCEEsUaxR9JmnqCftuu45MV2K9hcusSnF4hIWQzfs1I3A_2efCF0TMTVzGOata5RZfR_hLz0i4wuWO-JTfU9vqbEuxYY=@protonmail.com>
Message-ID: <00fb01d77525$7e9913c0$7bcb3b40$@voskuil.org>

> Good morning e,

Good afternoon Z.

> >     Any expectation of interest implies borrowing, in other words, a loan to
> the bank.
> 
> Perhaps this is the key point of contention?

I'm not sure, but from my observations it's long been a point of confusion in Bitcoiner understanding of banking.

To put a finer point on it, Rothbard's criteria is a vague in a couple ways. Earnings that offset fees are also "interest" in the economic context - in which he writes. So even a zero-interest account (or negative up to the full cost of maintaining the account) qualifies under this criterion. Yet he is careful to say "implies". The arrangement may of course be explicit, in which case one no longer relies on implied contract, one relies on explicit contract. Finally, one may "expect" no interest, and even pay fees, but it may nonetheless be a loan. This is what contracts are for.

If one contracts for warehousing service, such Safe Deposit, as opposed to a time deposit, such as Certificate of Deposit, Savings Account, or Checking Account, then one gets a warehousing service - full fees and a contractual obligation to maintain 100% of the deposit. There are also money transmission services that move money around for a fee. The inability to distinguish money from credit (including money substitutes) and warehousing from investment (including "banking") leads directly to false conclusions regarding money and banking. Unfortunately a good number of self-described "Austrians" perpetuate these errors.

> In cases where Bitcoin is given over to an exchange, there is no expectation
> of interest, at least in the sense that there is no expectation that the number
> of Bitcoins deposited in the exchange *increase* over time.
> (There may be an expectation of an increase in the number of green-ink
> historical commemoration papers it can buy, but the point is that the number
> of Bitcoins held in behalf of the user is not expected to change)
> 
> The expectation is that exchanges earn money from the difference between
> buy-price and sell-price, and the money-warehousing service they provide is
> simply provided for free to facilitate their *main* business (i.e. brokers for
> *exchange*).
> Thus, the expectation is that the exchange provides a warehouse service,
> not a bank service, and this service is provided for free since it enables their
> *real* business of earning from bid-ask spreads.

I'm not aware of what are people's expectations, nor would I judge what qualifies as someone's "real" business, but a warehouse that facilitates trades for a fee is of course a possible business model. PayPal's intended (real?) business model was to earn from the float. That didn't pan out, because people didn't retain money in their transmitter service. 

Exchanges that deal in monopoly money must move this through traditional finance. This incurs all manner of risk. When someone sends them monopoly money, there is no crypto-surety possible. This is part of their "reserve" just as is the other side of trades.

What matters is what people contract for - agree to, voluntarily.

> On the other hand, not your keys not your coins, so anyone who uses such a
> warehouse has whatever happens to the funds coming for them...

One of the essential benefits of Bitcoin being that you can be your own warehouse, and be your own money transmitter.

But all production requires investment, which inherently entails letting go of your money, producing something with it, and selling it to people for other money. All investment is from someone's "reserve". Full reserve investment (including banking) is an oxymoron. So whether through exchanges or otherwise, there will be production, risk, loss and earnings. Otherwise there will be nothing at all to buy, and all money will be worthless. This idea of assuring that money is fully reserved applies only to that which one does not invest (one's hoard); it does not apply to banks, or the capital of any other companies. If it can help people feel better about their Safe Deposit (warehousing), I'm all for it. But if one wants a 20% bitcoin reserve, one can certainly place 20% into cold storage.

> And of course exchanges need not earn money *just* from bid-ask spreads
> *in practice*, so they are unlikely to provide proof-of-reserves either.

If they did not earn money as a bank, the explicit cost of their services would be that much higher. Which people prefer is of course entirely up to them. I don't know which is more likely.

> Indeed, money warehousing may very well be provided by means other than
> proof-of-reserves, such as by using multisig the way Green wallet does, with
> better security.

Right, this is an aspect of using your own wallet.

> Perhaps "pure exchanges" would be more amenable to such a scheme
> rather than proof-of-reserves.

Or simply pairing traders, which is of course an existing model.

Best,
e

> Regards,
> ZmnSCPxj


From ZmnSCPxj at protonmail.com  Sat Jul 10 01:26:14 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 10 Jul 2021 01:26:14 +0000
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <00fb01d77525$7e9913c0$7bcb3b40$@voskuil.org>
References: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>
 <00e201d77518$b8ed8e00$2ac8aa00$@voskuil.org>
 <ZoFreCcyjxc8AE2qCEEsUaxR9JmnqCftuu45MV2K9hcusSnF4hIWQzfs1I3A_2efCF0TMTVzGOata5RZfR_hLz0i4wuWO-JTfU9vqbEuxYY=@protonmail.com>
 <00fb01d77525$7e9913c0$7bcb3b40$@voskuil.org>
Message-ID: <P3nHrkeDxaIVVC4zqhoNVXPqNQv7id4dyB3tmz8JZ1xo2B2FTaK-lUSQvDuieKUlG4VyfB-gHR__qcLmcJIG5YiDvKasiinwh682x9xJJuI=@protonmail.com>

Good morning e,

Okay, it seems to me that what you are saying is something like this:

> Proof-of-reserves would (partially) work for a "pure" warehousing service (i.e. user pays some fee, service keeps money and provides proofs that money is kept).
> However, "pure" warehousing is not what a typical exchange does (else the explicit fees in their exchanges would be higher), as it takes on risk due to having to deal with non-Bitcoin monopoly money (by definition, since they are *exchanges*).
> Further, with Bitcoin you can be your own warehouse (including Green-like multisig schemes where you own your own keys that are part of the scheme), which is an alternative choice to hiring a "pure warehouse" (i.e. Safe Deposit).

Would that be a fair (if somewhat rough and undetailed) restatement?

Regards,
ZmnSCPxj

> > Good morning e,
>
> Good afternoon Z.
>
> > >     Any expectation of interest implies borrowing, in other words, a loan to
> > >
> >
> > the bank.
> > Perhaps this is the key point of contention?
>
> I'm not sure, but from my observations it's long been a point of confusion in Bitcoiner understanding of banking.
>
> To put a finer point on it, Rothbard's criteria is a vague in a couple ways. Earnings that offset fees are also "interest" in the economic context - in which he writes. So even a zero-interest account (or negative up to the full cost of maintaining the account) qualifies under this criterion. Yet he is careful to say "implies". The arrangement may of course be explicit, in which case one no longer relies on implied contract, one relies on explicit contract. Finally, one may "expect" no interest, and even pay fees, but it may nonetheless be a loan. This is what contracts are for.
>
> If one contracts for warehousing service, such Safe Deposit, as opposed to a time deposit, such as Certificate of Deposit, Savings Account, or Checking Account, then one gets a warehousing service - full fees and a contractual obligation to maintain 100% of the deposit. There are also money transmission services that move money around for a fee. The inability to distinguish money from credit (including money substitutes) and warehousing from investment (including "banking") leads directly to false conclusions regarding money and banking. Unfortunately a good number of self-described "Austrians" perpetuate these errors.
>
> > In cases where Bitcoin is given over to an exchange, there is no expectation
> > of interest, at least in the sense that there is no expectation that the number
> > of Bitcoins deposited in the exchange increase over time.
> > (There may be an expectation of an increase in the number of green-ink
> > historical commemoration papers it can buy, but the point is that the number
> > of Bitcoins held in behalf of the user is not expected to change)
> > The expectation is that exchanges earn money from the difference between
> > buy-price and sell-price, and the money-warehousing service they provide is
> > simply provided for free to facilitate their main business (i.e. brokers for
> > exchange).
> > Thus, the expectation is that the exchange provides a warehouse service,
> > not a bank service, and this service is provided for free since it enables their
> > real business of earning from bid-ask spreads.
>
> I'm not aware of what are people's expectations, nor would I judge what qualifies as someone's "real" business, but a warehouse that facilitates trades for a fee is of course a possible business model. PayPal's intended (real?) business model was to earn from the float. That didn't pan out, because people didn't retain money in their transmitter service.
>
> Exchanges that deal in monopoly money must move this through traditional finance. This incurs all manner of risk. When someone sends them monopoly money, there is no crypto-surety possible. This is part of their "reserve" just as is the other side of trades.
>
> What matters is what people contract for - agree to, voluntarily.
>
> > On the other hand, not your keys not your coins, so anyone who uses such a
> > warehouse has whatever happens to the funds coming for them...
>
> One of the essential benefits of Bitcoin being that you can be your own warehouse, and be your own money transmitter.
>
> But all production requires investment, which inherently entails letting go of your money, producing something with it, and selling it to people for other money. All investment is from someone's "reserve". Full reserve investment (including banking) is an oxymoron. So whether through exchanges or otherwise, there will be production, risk, loss and earnings. Otherwise there will be nothing at all to buy, and all money will be worthless. This idea of assuring that money is fully reserved applies only to that which one does not invest (one's hoard); it does not apply to banks, or the capital of any other companies. If it can help people feel better about their Safe Deposit (warehousing), I'm all for it. But if one wants a 20% bitcoin reserve, one can certainly place 20% into cold storage.
>
> > And of course exchanges need not earn money just from bid-ask spreads
> > in practice, so they are unlikely to provide proof-of-reserves either.
>
> If they did not earn money as a bank, the explicit cost of their services would be that much higher. Which people prefer is of course entirely up to them. I don't know which is more likely.
>
> > Indeed, money warehousing may very well be provided by means other than
> > proof-of-reserves, such as by using multisig the way Green wallet does, with
> > better security.
>
> Right, this is an aspect of using your own wallet.
>
> > Perhaps "pure exchanges" would be more amenable to such a scheme
> > rather than proof-of-reserves.
>
> Or simply pairing traders, which is of course an existing model.
>
> Best,
> e
>
> > Regards,
> > ZmnSCPxj



From aj at erisian.com.au  Sat Jul 10 01:47:32 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Sat, 10 Jul 2021 11:47:32 +1000
Subject: [bitcoin-dev] A Stroll through Fee-Bumping Techniques :
 Input-Based vs Child-Pay-For-Parent
In-Reply-To: <CALZpt+FCCgSiRh2qAL+RM0S9Vm8s-xS3VdTAZhS9VwLcFi_1QQ@mail.gmail.com>
References: <CALZpt+FvLb=N5Qygs+dPmh1o9QCwXj8RoznF5n47opOq7CG_0g@mail.gmail.com>
 <20210708111716.GC1339@erisian.com.au>
 <CALZpt+FCCgSiRh2qAL+RM0S9Vm8s-xS3VdTAZhS9VwLcFi_1QQ@mail.gmail.com>
Message-ID: <20210710014732.GA5164@erisian.com.au>

On Fri, Jul 09, 2021 at 09:19:45AM -0400, Antoine Riard via bitcoin-dev wrote:
> > The easy way to avoid O(n^2) behaviour in (3) is to disallow partial
> > overlaps. So let's treat the tx as being distinct bundles of x-inputs
> > and y-outputs, and we'll use the annex for grouping, since that is
> > committed to by singatures. Call the annex field "sig_group_count".
> > When processing inputs, setup a new state pair, (start, end), initially
> > (0,0).
> > When evaluating an input, lookup sig_group_count. If it's not present,
> > then set start := end. If it's present and 0, leave start and end
> > unchanged. Otherwise, if it's present and greather than 0, set
> > start := end, and then set end := start + sig_group_count.
> IIUC the design rationale, the "sig_group_count" lockdowns the hashing of
> outputs for a given input, thus allowing midstate reuse across signatures
> input.

No midstates, the message being signed would just replace
SIGHASH_SINGLE's:

  sha_single_output: the SHA256 of the corresponding output in CTxOut
  format

with

  sha_group_outputs: the SHA256 of the serialization of the group
  outputs in CTxOut format.

ie, you'd take span<CTxOut>{start,end}, serialize it (same as if it were
a vector of just those CTxOuts), and sha256 it.

> Let's say you want to combine {x_1, y_1} and {x_2, y_2} where {x, y} denotes
> bundles of Lightning commitment transactions.
> x_1 is dual-signed by Alice and Bob under the SIGHASH_GROUP flag with
> `sig_group_count`=3.
> x_2 is dual-signed by Alice and Caroll under the SIGHASH_GROUP flag, with
> `sig_group_count`=2.
> y_1 and y_2 are disjunctive.
> At broadcast, Alice is not able to combine {x_1,y_1} and {x_2, y_2} for the
> reason that x_1, x_2 are colliding on the absolute output position.

So the sha256 of the span of the group doesn't commit to start and end
-- it just serializes a vector, so commits to the number of elements,
the order, and the elements themselves. So you're taking serialize(y_1)
and serialize(y_2), and each of x_1 signs against the former, and each
of x_2 signs against the latter.

(Note that the annex for x_1_0 specifies sig_group_count=len(y_1)
and the annex for x_1_{1..} specifies sig_group_count=0, for "reuse
previous input's group", and the signatures for each input commit to
the annex anyway)

> One fix could be to skim the "end > num_ouputs" semantic,

That's only there to ensure the span doesn't go out of range, so I don't
think it makes any sense to skip it?

> I think this SIGHASH_GROUP proposal might solve other use-cases, but if I
> understand the semantics correctly, it doesn't seem to achieve the batch
> fee-bumping of multiple Lightning commitment with O(1) onchain footprint I was
> thinking of for IOMAP...

Does the above resolve that?

Cheers,
aj


From eric at voskuil.org  Sat Jul 10 01:49:37 2021
From: eric at voskuil.org (eric at voskuil.org)
Date: Fri, 9 Jul 2021 18:49:37 -0700
Subject: [bitcoin-dev] Proof of reserves - recording
In-Reply-To: <P3nHrkeDxaIVVC4zqhoNVXPqNQv7id4dyB3tmz8JZ1xo2B2FTaK-lUSQvDuieKUlG4VyfB-gHR__qcLmcJIG5YiDvKasiinwh682x9xJJuI=@protonmail.com>
References: <CAGpPWDYgYjUp+PRirca-QrbJZxwtyAnaQmr1kLbuKHSs2K+OBw@mail.gmail.com>
 <00e201d77518$b8ed8e00$2ac8aa00$@voskuil.org>
 <ZoFreCcyjxc8AE2qCEEsUaxR9JmnqCftuu45MV2K9hcusSnF4hIWQzfs1I3A_2efCF0TMTVzGOata5RZfR_hLz0i4wuWO-JTfU9vqbEuxYY=@protonmail.com>
 <00fb01d77525$7e9913c0$7bcb3b40$@voskuil.org>
 <P3nHrkeDxaIVVC4zqhoNVXPqNQv7id4dyB3tmz8JZ1xo2B2FTaK-lUSQvDuieKUlG4VyfB-gHR__qcLmcJIG5YiDvKasiinwh682x9xJJuI=@protonmail.com>
Message-ID: <010201d7752d$d78f7480$86ae5d80$@voskuil.org>

All reasonable.

e

> Okay, it seems to me that what you are saying is something like this:
> 
> > Proof-of-reserves would (partially) work for a "pure" warehousing service
> (i.e. user pays some fee, service keeps money and provides proofs that
> money is kept).
> > However, "pure" warehousing is not what a typical exchange does (else
> the explicit fees in their exchanges would be higher), as it takes on risk due
> to having to deal with non-Bitcoin monopoly money (by definition, since they
> are *exchanges*).
> > Further, with Bitcoin you can be your own warehouse (including Green-like
> multisig schemes where you own your own keys that are part of the
> scheme), which is an alternative choice to hiring a "pure warehouse" (i.e.
> Safe Deposit).
> 
> Would that be a fair (if somewhat rough and undetailed) restatement?
> 
> Regards,
> ZmnSCPxj



From antoine.riard at gmail.com  Mon Jul 12 00:02:12 2021
From: antoine.riard at gmail.com (Antoine Riard)
Date: Sun, 11 Jul 2021 20:02:12 -0400
Subject: [bitcoin-dev] A Stroll through Fee-Bumping Techniques :
 Input-Based vs Child-Pay-For-Parent
In-Reply-To: <20210710014732.GA5164@erisian.com.au>
References: <CALZpt+FvLb=N5Qygs+dPmh1o9QCwXj8RoznF5n47opOq7CG_0g@mail.gmail.com>
 <20210708111716.GC1339@erisian.com.au>
 <CALZpt+FCCgSiRh2qAL+RM0S9Vm8s-xS3VdTAZhS9VwLcFi_1QQ@mail.gmail.com>
 <20210710014732.GA5164@erisian.com.au>
Message-ID: <CALZpt+G0uN_ek5kVre_e38OtSZ5izRUC2qb5qJC3bVkh5FV-Fw@mail.gmail.com>

> So the sha256 of the span of the group doesn't commit to start and end
> -- it just serializes a vector, so commits to the number of elements,
> the order, and the elements themselves.

Gotcha wasn't clear to me that the new state pair isn't committed as part
of the annex.

Have been confused by "Introduce a new SIGHASH_GROUP flag, as an
alternative to ALL/SINGLE/NONE, that commits to each output i, start <= i <
end."

> Does the above resolve that?

I think so. It shouldn't be susceptible to any spend replay attack, as the
state pair prevents output group overlapping though you might still have to
be careful about siphoning ? Something you should already care about if you
use SIGHASH_SINGLE and your x's amount > y's value.

Le ven. 9 juil. 2021 ? 21:47, Anthony Towns <aj at erisian.com.au> a ?crit :

> On Fri, Jul 09, 2021 at 09:19:45AM -0400, Antoine Riard via bitcoin-dev
> wrote:
> > > The easy way to avoid O(n^2) behaviour in (3) is to disallow partial
> > > overlaps. So let's treat the tx as being distinct bundles of x-inputs
> > > and y-outputs, and we'll use the annex for grouping, since that is
> > > committed to by singatures. Call the annex field "sig_group_count".
> > > When processing inputs, setup a new state pair, (start, end), initially
> > > (0,0).
> > > When evaluating an input, lookup sig_group_count. If it's not present,
> > > then set start := end. If it's present and 0, leave start and end
> > > unchanged. Otherwise, if it's present and greather than 0, set
> > > start := end, and then set end := start + sig_group_count.
> > IIUC the design rationale, the "sig_group_count" lockdowns the hashing of
> > outputs for a given input, thus allowing midstate reuse across signatures
> > input.
>
> No midstates, the message being signed would just replace
> SIGHASH_SINGLE's:
>
>   sha_single_output: the SHA256 of the corresponding output in CTxOut
>   format
>
> with
>
>   sha_group_outputs: the SHA256 of the serialization of the group
>   outputs in CTxOut format.
>
> ie, you'd take span<CTxOut>{start,end}, serialize it (same as if it were
> a vector of just those CTxOuts), and sha256 it.
>
> > Let's say you want to combine {x_1, y_1} and {x_2, y_2} where {x, y}
> denotes
> > bundles of Lightning commitment transactions.
> > x_1 is dual-signed by Alice and Bob under the SIGHASH_GROUP flag with
> > `sig_group_count`=3.
> > x_2 is dual-signed by Alice and Caroll under the SIGHASH_GROUP flag, with
> > `sig_group_count`=2.
> > y_1 and y_2 are disjunctive.
> > At broadcast, Alice is not able to combine {x_1,y_1} and {x_2, y_2} for
> the
> > reason that x_1, x_2 are colliding on the absolute output position.
>
> So the sha256 of the span of the group doesn't commit to start and end
> -- it just serializes a vector, so commits to the number of elements,
> the order, and the elements themselves. So you're taking serialize(y_1)
> and serialize(y_2), and each of x_1 signs against the former, and each
> of x_2 signs against the latter.
>
> (Note that the annex for x_1_0 specifies sig_group_count=len(y_1)
> and the annex for x_1_{1..} specifies sig_group_count=0, for "reuse
> previous input's group", and the signatures for each input commit to
> the annex anyway)
>
> > One fix could be to skim the "end > num_ouputs" semantic,
>
> That's only there to ensure the span doesn't go out of range, so I don't
> think it makes any sense to skip it?
>
> > I think this SIGHASH_GROUP proposal might solve other use-cases, but if I
> > understand the semantics correctly, it doesn't seem to achieve the batch
> > fee-bumping of multiple Lightning commitment with O(1) onchain footprint
> I was
> > thinking of for IOMAP...
>
> Does the above resolve that?
>
> Cheers,
> aj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210711/87c953b3/attachment.html>

From aj at erisian.com.au  Mon Jul 12 05:01:15 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Mon, 12 Jul 2021 15:01:15 +1000
Subject: [bitcoin-dev] [Lightning-dev] Eltoo / Anyprevout & Baked in
 Sequences
In-Reply-To: <CAD5xwhjVod-Lu-gjU89znmVZnmL4UrL7xVuy=gZuuG6JG9X5yg@mail.gmail.com>
References: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>
 <20210708084416.GB1339@erisian.com.au>
 <CAD5xwhjVod-Lu-gjU89znmVZnmL4UrL7xVuy=gZuuG6JG9X5yg@mail.gmail.com>
Message-ID: <20210712050115.GA6250@erisian.com.au>

On Thu, Jul 08, 2021 at 08:48:14AM -0700, Jeremy wrote:
>     This would disallow using a relative locktime and an absolute locktime
>     for the same input. I don't think I've seen a use case for that so far,
>     but ruling it out seems suboptimal.
> I think you meant disallowing a relative locktime and a sequence locktime? I
> agree it is suboptimal.

No? If you overload the nSequence for a per-input absolute locktime
(well in the past for eltoo), then you can't reuse the same input's
nSequence for a per-input relative locktime (ie CSV).

Apparently I have thought of a use for it now -- cut-through of PTLC
refunds when the timeout expires well after the channel settlement delay
has passed. (You want a signature that's valid after a relative locktime
of the delay and after the absolute timeout)

> What do you make of sequence tagged keys?

I think we want sequencing restrictions to be obvious from some (simple)
combination of nlocktime/nsequence/annex so that you don't have to
evaluate scripts/signatures in order to determine if a transaction
is final.

Perhaps there's a more general principle -- evaluating a script should
only return one bit of info: "bool tx_is_invalid_script_failed"; every
other bit of information -- how much is paid in fees (cf ethereum gas
calculations), when the tx is final, if the tx is only valid in some
chain fork, if other txs have to have already been mined / can't have
been mined, who loses funds and who gets funds, etc... -- should already
be obvious from a "simple" parsing of the tx.

Cheers,
aj


From jlrubin at mit.edu  Mon Jul 12 22:07:29 2021
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 12 Jul 2021 15:07:29 -0700
Subject: [bitcoin-dev] [Lightning-dev] Eltoo / Anyprevout & Baked in
	Sequences
In-Reply-To: <20210712050115.GA6250@erisian.com.au>
References: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>
 <20210708084416.GB1339@erisian.com.au>
 <CAD5xwhjVod-Lu-gjU89znmVZnmL4UrL7xVuy=gZuuG6JG9X5yg@mail.gmail.com>
 <20210712050115.GA6250@erisian.com.au>
Message-ID: <CAD5xwhitb0g3-JPsn2tQF-KqgSp+goLnVbSmRX0LUh-818tSVw@mail.gmail.com>

On Sun, Jul 11, 2021 at 10:01 PM Anthony Towns <aj at erisian.com.au> wrote:

> On Thu, Jul 08, 2021 at 08:48:14AM -0700, Jeremy wrote:
> >     This would disallow using a relative locktime and an absolute
> locktime
> >     for the same input. I don't think I've seen a use case for that so
> far,
> >     but ruling it out seems suboptimal.
> > I think you meant disallowing a relative locktime and a sequence
> locktime? I
> > agree it is suboptimal.
>
> No? If you overload the nSequence for a per-input absolute locktime
> (well in the past for eltoo), then you can't reuse the same input's
> nSequence for a per-input relative locktime (ie CSV).
>
> Apparently I have thought of a use for it now -- cut-through of PTLC
> refunds when the timeout expires well after the channel settlement delay
> has passed. (You want a signature that's valid after a relative locktime
> of the delay and after the absolute timeout)
>

Ah -- I didn't mean a per input abs locktime, I mean the  tx global
locktime.

I agree that at some point we should just separate all locktime types per
input so we get rid of all weirdness/overlap.



>
> > What do you make of sequence tagged keys?
>
> I think we want sequencing restrictions to be obvious from some (simple)
> combination of nlocktime/nsequence/annex so that you don't have to
> evaluate scripts/signatures in order to determine if a transaction
> is final.
>
> Perhaps there's a more general principle -- evaluating a script should
> only return one bit of info: "bool tx_is_invalid_script_failed"; every
> other bit of information -- how much is paid in fees (cf ethereum gas
> calculations), when the tx is final, if the tx is only valid in some
> chain fork, if other txs have to have already been mined / can't have
> been mined, who loses funds and who gets funds, etc... -- should already
> be obvious from a "simple" parsing of the tx.
>
> Cheers,
> aj
>
>
I don't think we have this property as is.

E.g. consider the transaction:

TX:
   locktime: None
   sequence: 100
   scriptpubkey: 101 CSV

How will you tell it is able to be included without running the script?

I agree this is a useful property, but I don't think we can do it
practically.

What's nice is the transaction in this form cannot go from invalid to valid
-- once invalid it is always invalid for a given UTXO.

sequence tagged keys have this property -- a txn is either valid or invalid
and that never changes w/o any external information needing to be passed up.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210712/d6b5a929/attachment.html>

From ali at notatether.com  Mon Jul 12 23:33:16 2021
From: ali at notatether.com (Ali Sherief)
Date: Mon, 12 Jul 2021 23:33:16 +0000
Subject: [bitcoin-dev] An idea to block invalid addresses from reaching the
	peers.dat buckets
Message-ID: <PKeS7M-QWkdvfikZ0M_yH-Gj4t1VlxmSF43XMEuR8aCGps1WAbt-kglEm1ee-YDhsmSIM68G4-_xNMFgOB9u5H6UAT1qow8sW1yt4iaIShI=@notatether.com>

This is an interesting read: https://bitcointalk.org/index.php?topic=5348856.0

So according to this, somebody is spamming the bitcoin network with addr message pointing to invalid addresses and ports, which bloats the peers.dat and corresponding structure in memory.

Since peers.dat uses a custom record type which I don't know how to parse, I wasn't able to check specifics of IP addresses listed in there, but I believe I have a workaround to prevent this kind of thing from happening. Exactly how easy or difficult it will be to implement this change I don't know.

- Change the AddrDb updating functionality so that it does not add nodes that are unreachable. Not unreachable by timeout, but "connection refused" kind of errors.

Such addresses can either be stored in a new, separate database-like file such as "ignore.dat", or they can be augmented in the peers.dat file under a new entry type (I'm not sure if this is even possible). In both cases the invalid nodes can be immediately flushed from memory to avoid processing them.

-- This is only done the first time the node is seen in the wild. To avoid blocking nodes which happened to go offline, the check won't be made if it's already in the buckets. So it won't clean up an attack like this (meaning peers.dat files have to be recreated to fix this) but it will prevent another in the future.

- In order to facilitate other nodes discovering blocked nodes, a new ZMQ message can be made that sends the node's list of ignored addresses. Since I haven't used ZMQ much I don't know the specifics of how to do this.

- Introduce a new file or command-line/config option called "ignorelist" or something with a list of subnets that will *not* be read into the AddrDB buckets in any case.

It will work differently from the banlist, whose primary job is to block peers that send invalid messages, not peers that are not, and cannot, be unreachable in the first place.

- Ali Sherief
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210712/0c857f86/attachment.html>

From bitcoin-dev at wuille.net  Tue Jul 13 00:54:29 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 13 Jul 2021 00:54:29 +0000
Subject: [bitcoin-dev] An idea to block invalid addresses from reaching
	the peers.dat buckets
In-Reply-To: <PKeS7M-QWkdvfikZ0M_yH-Gj4t1VlxmSF43XMEuR8aCGps1WAbt-kglEm1ee-YDhsmSIM68G4-_xNMFgOB9u5H6UAT1qow8sW1yt4iaIShI=@notatether.com>
References: <PKeS7M-QWkdvfikZ0M_yH-Gj4t1VlxmSF43XMEuR8aCGps1WAbt-kglEm1ee-YDhsmSIM68G4-_xNMFgOB9u5H6UAT1qow8sW1yt4iaIShI=@notatether.com>
Message-ID: <7onDqKwXHBsQUhahHnz9HH2127d2xdI-r2GgcX1DiOarSlWj9569-lEmppxRkY-aDfGHyqk62_YwxaoAUYAVJfCwK90-khTmPYntT7veF_g=@wuille.net>

> This is an interesting read: https://bitcointalk.org/index.php?topic=5348856.0
>
> So according to this, somebody is spamming the bitcoin network with addr message pointing to invalid addresses and ports, which bloats the peers.dat and corresponding structure in memory.

The peers.dat file and the structure in memory have a fixed size, so those are not a problem.

> Since peers.dat uses a custom record type which I don't know how to parse, I wasn't able to check specifics of IP addresses listed in there, but I believe I have a workaround to prevent this kind of thing from happening. Exactly how easy or difficult it will be to implement this change I don't know.

The "addrman" database is organized into 1024 buckets with "new" addresses (which we haven't tried to connect to), and 256 buckets with "tried" addresses (which we have connected to ourselves). Each bucket consists of 64 positions, and each of those can hold 1 address. Along with the addresses we remember where we originally heard about them (which IP).

Each group of source IPs (/16s etc) selects a subset of just 64 buckets (salted using a host-specific secret key), and inserts the newly received IPs in a position in a bucket in one of those, if certain criteria are met (the position was empty, or it held an IP address that also occurs elsewhere in the table already). This limits the impact an attacker can have, because they cannot under any circumstances affect IPs in buckets outside of the 64 their group maps to.

This database structure is a design from 2012, which was significantly improved following recommendations in the Eclipse Attacks paper (https://cs-people.bu.edu/heilman/eclipse/).

> - Change the AddrDb updating functionality so that it does not add nodes that are unreachable. Not unreachable by timeout, but "connection refused" kind of errors.

In a way we have that; there are separate tables in peers.dat for new and tried addresses. I don't think it's feasible to not add untried addresses at all, as our ability to create connections is far too low to try everything we receive. But I think the existing structure should reasonably protect against spam (in terms of database poisoning; there is certainly a processing cost to it).

Cheers,

--
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210713/a19693ad/attachment-0001.html>

From aj at erisian.com.au  Wed Jul 14 03:32:00 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 14 Jul 2021 13:32:00 +1000
Subject: [bitcoin-dev] [Lightning-dev] Eltoo / Anyprevout & Baked in
 Sequences
In-Reply-To: <CAD5xwhitb0g3-JPsn2tQF-KqgSp+goLnVbSmRX0LUh-818tSVw@mail.gmail.com>
References: <CAD5xwhgO5p2Ldy1P1rUuqDHcJ0opSe7Tg_mX_rb+ZpLOxa47cA@mail.gmail.com>
 <20210708084416.GB1339@erisian.com.au>
 <CAD5xwhjVod-Lu-gjU89znmVZnmL4UrL7xVuy=gZuuG6JG9X5yg@mail.gmail.com>
 <20210712050115.GA6250@erisian.com.au>
 <CAD5xwhitb0g3-JPsn2tQF-KqgSp+goLnVbSmRX0LUh-818tSVw@mail.gmail.com>
Message-ID: <20210714033200.GA7155@erisian.com.au>

On Mon, Jul 12, 2021 at 03:07:29PM -0700, Jeremy wrote:
>     Perhaps there's a more general principle -- evaluating a script should
>     only return one bit of info: "bool tx_is_invalid_script_failed"; every
>     other bit of information -- how much is paid in fees (cf ethereum gas
>     calculations), when the tx is final, if the tx is only valid in some
>     chain fork, if other txs have to have already been mined / can't have
>     been mined, who loses funds and who gets funds, etc... -- should already
>     be obvious from a "simple" parsing of the tx.
> I don't think we have this property as is.
> E.g. consider the transaction:
> TX:
> ? ?locktime: None
> ? ?sequence: 100
> ? ?scriptpubkey: 101 CSV

That tx will never be valid, no matter the state of the chain -- even if
it's 420 blocks after the utxo it's spending: it fails because "top stack
item is greater than the transaction input sequence" rule from BIP 112.

> How will you tell it is able to be included without running the script?

You have to run the script at some point, but you don't need to run the
script to differentiate between it being valid on one chain vs valid on
some other chain.

> What's nice is the transaction in this form cannot go from invalid to valid --
> once invalid it is always invalid for a given UTXO.

Huh? Timelocks always go from invalid to valid -- they're invalid prior
to some block height (IsFinal() returns false), then valid after.

Not going from valid to invalid is valuable because it limits the cases
where you have to remove txs (and their descendents) from the mempool.

Cheers,
aj


From karel.kyovsky at generalbytes.com  Fri Jul 16 14:35:21 2021
From: karel.kyovsky at generalbytes.com (Karel Kyovsky)
Date: Fri, 16 Jul 2021 16:35:21 +0200
Subject: [bitcoin-dev] Travel rule, VASP UID and bitcoin URI - A new BIP
Message-ID: <CALSqm3bG0pYhPvGQd-uxN5fTQXS_rbzQFq3L5+d2xbaLUuCE3Q@mail.gmail.com>

Hi There,
I would like to propose a standardization of the bitcoin URI parameter name
that could be optionally used to contain the unique id of VASP (Virtual
asset service provider as defined by FATF) hosting the user's wallet
address.
My question is: Should I prepare a completely new BIP or should I prepare a
modification of BIP21?
BIP21 status is FINAL so I guess it should be a completely new BIP that
would just extend the BIP21. I'm looking for confirmation of this approach.
Thank you for answering that.

Please let's NOT start a discussion whether the FATF travel rule is a good
thing or not. This could derail my initial question.

Background:
We are going to be soon working on travel rule integration for our Bitcoin
ATM product.
The current user scenario is that the user shows on his phone QR code to
the ATM with bitcoin URI containing an address, inserts cash and walks away
with BTC arriving to his wallet.

In a Travel Rule compliant scenario the ATM operator must perform the "best
effort" to find out who(VASP) is hosting the user's wallet, contact such
VASP and send VASP customer identity data. This can be achieved by:

a) ATM contacting every possible known VASP that is travel rule compliant
via some platform and ask him whether the address read from the QR code
belongs to him. Such search could be done also with bloom filter to protect
the privacy of a user. But of course this is very far from ideal.

or

b) ATM could use blockchain analytics tools to find who might be serving
this wallet (major exchange etc). If the wallet address is empty prior to
the purchase on the ATM this address would have to be monitored for some
time to find out if it doesn't fall into some exchange's(VASP) cluster and
that would have to be later contacted.

or

c) User will choose from the list of VASPs on the ATM screen to match his
wallet provider(imagine phonebook with search field - terrible). Most
people will select irrelevant VASP because they will not be willing to
spend time to search VASP's name on the screen.

or

d) The user could enable in settings of their mobile wallet that VASP UID
would be provided in URI as one of the parameters so that Bitcoin ATM
operator will not have to search for VASP and could communicate with VASP
immediately after scanning URI from QR code. In such a case options a) or
b) or c) would not have to be performed and user experience for ATM users
would stay the same as before travel rule compliance. In order to achieve
this all wallet providers need to use the same parameter name in URI so
that ATM will read this parameter - standardization of this parameter name
is the purpose of proposed new BIP.

VASP UID could be also a public key that could be used to encrypt the
customer's identity information before sending it to wallet provider VASP
from the bitcoin ATM. Directory of VASP UIDs, how VASP could be contacted,
method of transfer when one knows VASP UID should be all outside of scope
of this BIP. I expect this to be covered by 3rd party
tools/platforms/regulators.

Bitcoin ATM operators want to stay in business and for that they need to
stay compliant with US regulation. Therefore they ask us to improve our
products to comply with the FATF-Travel Rule.
The same probably applies to US custodian wallet service providers so I
envision that the majority of custodian wallets offered on Appstore/Google
play in the US would provide their VASP UID in bitcoin URI as a new default
with an option for users to turn it off.

Please note that Travel Rule doesn't apply for unhosted(non-custodian)
wallets.

Thank you,
Karel Kyovsky
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210716/51c92af6/attachment.html>

From dave at dtrt.org  Fri Jul 16 21:42:16 2021
From: dave at dtrt.org (David A. Harding)
Date: Fri, 16 Jul 2021 11:42:16 -1000
Subject: [bitcoin-dev] Travel rule, VASP UID and bitcoin URI - A new BIP
In-Reply-To: <CALSqm3bG0pYhPvGQd-uxN5fTQXS_rbzQFq3L5+d2xbaLUuCE3Q@mail.gmail.com>
References: <CALSqm3bG0pYhPvGQd-uxN5fTQXS_rbzQFq3L5+d2xbaLUuCE3Q@mail.gmail.com>
Message-ID: <20210716214216.mtc6h55ahopxt32q@ganymede>

On Fri, Jul 16, 2021 at 04:35:21PM +0200, Karel Kyovsky via bitcoin-dev wrote:
> I would like to propose a standardization of [a new] bitcoin URI parameter name
> [...]
> My question is: Should I prepare a completely new BIP or should I prepare a
> modification of BIP21?

Please use a new BIP.  See BIP72 for a previous instance where another
URI parameter for BIP21 was standardized.
https://github.com/bitcoin/bips/blob/master/bip-0072.mediawiki

(I think your compliance situation is mostly off topic for this list, so
I'm not commenting on that.)

-Dave


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210716/7e4e83e1/attachment.sig>

From michaelfolkson at gmail.com  Sat Jul 17 13:16:19 2021
From: michaelfolkson at gmail.com (Michael Folkson)
Date: Sat, 17 Jul 2021 14:16:19 +0100
Subject: [bitcoin-dev] Online discussion on Taproot roll out - Tuesday July
	20th 17:15 UTC
Message-ID: <CAFvNmHSdozmBK44jSEAQdZYo+1-01fVuaVATAimgGCohiy-BHQ@mail.gmail.com>

Hi

There is an online Zoom call (also livestreamed on YouTube) on Tuesday
July 20th at 17:15 UTC discussing Taproot roll out post activation in
November. It will be focused at developers and so discussion will be
technical but all are welcome to attend/watch.

Murch has this wiki page monitoring planned ecosystem support of P2TR
addresses and it would be great to hear from projects and businesses
that have Taproot support on their medium/long term development
roadmap or are considering it:
https://en.bitcoin.it/wiki/Bech32_adoption

Meetup link (Zoom link will be announced here):
https://www.meetup.com/BitDevsLDN/events/279041693/

Draft pre-reading link (will be finalized before Tuesday):
https://gist.github.com/michaelfolkson/0803271754f851530fe8242087859254

Thanks
Michael

-- 
Michael Folkson
Email: michaelfolkson at gmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

From raymo at riseup.net  Sat Jul 17 15:50:30 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Sat, 17 Jul 2021 08:50:30 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
 <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
Message-ID: <6016816a7ea36b8a88f48d69462d0308@riseup.net>

After introducing Sabu protocol as a solution for Bitcoin scaling
(https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180),
I shared this idea with Bitcoin developers through the bitcoin-dev
mailing list.
I got some constructive feedbacks and critiques leading me to add this
part to the proposal which I was skipped due to brevity of proposal
introduction.

Here I will investigate on more real live scenarios, general usages and
corner cases, and the consequences of some attacks or buggy
implementation of protocol, as well as different actors (malicious,
irrational, profit seeker, griefer, stupid, reckless, incompetent, etc.)
activity effects.

In proposal introduction (previous post), I did not talk about Lightning
deliberately, although it seems that this solution is an alternative to
Lightning.
Most of readers misunderstood Sabu and asking what differs it from
Lightning?
Indeed, Sabu has nothing with Lightning. It has totally different
design, network architecture, security model and implementation. The
only thing in common with Lightning is both are intended to cover micro
payments.
The good thing about Bitcoin is that it does not require any kind of
permission. Consequently, related products do not need to ask permission
too. We are in a permission-less free market. I think Sabu will work
perfectly and if a group of users think like me, we are done. Sabu will
work parallel the other scaling solutions without need to drive them
out.
However, I have made a comparison between Sabu, on-chain and Lightning
transactions to get a clearer understanding of the advantages and
disadvantages of Sabu and answer to ?why we should implement and use
Sabu in our day-to-day deals?.
Most probably this paper is not comprehensive document, therefore this
article will be updated.

You will find the complete post here:
https://raymo-49157.medium.com/scaling-bitcoin-by-sabu-protocol-risks-and-benefits-62157f8a664e

Raymo

On 2021-07-07 03:20, Billy Tetrud wrote:
>>  As far as I know the ?claw back? mechanism doesn?t exist in
> Bitcoin
> system, and probably most Bitcoiners won?t be agree on it.
> 
> It certainly doesn't. And it would definitely be a hard sell.
> 
>> It looks the miners still can abuse Sabu, but as I told before the
> mineror better say the mining pool must be issuer .. or must be
> creditor .. or collaborate one of them in a
> conspiracy.
> 
> Yes. But it certainly incentivizes miners to become creditors and scam
> people. Even if a small miner who mines one block a year does this,
> they can mine all Guarantee Transactions in their possession. Larger
> miners that mine one block every few days can scam that much more
> often. Even with $5 credits, that could be an extra $9000 gained in a
> block. That's pretty substantial when fees are totaling around $45,000
> per block.
> 
>> would be resolved by a slightly upgrade in Bitcoin protocol by
> applying the BIPxxx ?for flagging/unflagging promised UTXOs?
> 
> As others have mentioned tho, doing something like that would be at
> very least quite complex, and at worst impossible to do securely. The
> whole reason why bitcoin's blockchain exists in the first place is to
> be a single source of truth for transactions. The mempool is not a
> source of truth for consensus. The Sabu network could not be a source
> of truth either for consensus, without some serious innovations (that
> may not be possible). It isn't as simple as you seem to be thinking.
> 
>>  The new transaction will use same 40,000 UTXO as input and the
> outputs will be 6,500 Sat for creditor (he pays 2,500 Sat for
> transaction fee) 4,500 Sat for creditor 2
> 
> This is the part I was unable to find/understand quickly enough in the
> original write up. So for creditor 1 to pay creditor 2, a new main
> transaction and guarantee transaction are created that credit the
> appropriate people, right? FYI, the MT and GT acronyms make it harder
> for me to read/understand, so I'm preferring to write them out. But
> that helps. Let me write this out in a different (more compact) way:
> 
> 1. Creditor A $5 -> Issuer
> 
> 2. Issuer creates and shares transactions:
> 
> Main Transaction (40k sats):
> * Issuer: 19k sats
> * Creditor A: 11k sats
> * Fee: 10k sats (4k from creditor, 6k from issuer)
> 
> Guarantee Transaction (40k sats):
> * Issuer: 13,300 sats
> * Creditor A: 1650 sats
> * Fee: 25,050 sats
> 
> 3. Creditor A, 6k sats -> Creditor B. Issuer creates and shares
> transactions:
> 
> Main Transaction (40k sats):
> * Issuer: 19k sats* Creditor A:  6,500 sats
> * Creditor B:  4,500 sats
> 
> * Fee: 10k sats (4k from creditor, 6k from issuer)
> 
> Guarantee Transaction (40k sats):
> * Issuer: 13300 sats* Creditor A: 975 sats
> * Creditor B: 675 sats
> * Fee: 25050 sats
> 
> Is this right?
> 
>> The miner attack is just a failed plan as I explained before
> 
> I thought you acknowledged that the miner attack is an issue above.
> No?
> 
>>> Sabu has slightly greater risk comparing lightning
>> It is not true,
> 
> What I mean is that a violation of trust results in more damaging
> effects with Sabu than with lightning. In lightning, if your channel
> partner cheats, at worst you must simply pay a normal transaction fee.
> With Sabu, if a creditor cheats, you will likely pay an abnormally
> large transaction fee. This is what I mean by "greater risk". Some
> attackers are what's known as griefers - these are people willing to
> spend time and money hurting someone else, even if they don't make a
> profit from it (other than schadenfreude). It seems clear there is a
> greater risk of being griefed in Sabu than in lightning.
> 
> Furthermore, while in lightning, if you perform the protocol properly,
> your funds can never be stolen except in very extreme circumstances
> (eg widespread long-running network congestion that prevents
> confirming a revoke transaction). By contrast, Sabu has a significant
> likelihood that a cheating transaction could be mined instead of the
> guarantee transaction. Perhaps the likelihood is approximately 2
> seconds / 10 minutes (0.3% chance), but a 0.3% is clearly larger than
> approximately 0% chance in lightning. Again, this is another part of
> what I mean by "higher risk".
> 
> These are both real counterparty risks that you shouldn't simply
> ignore. It may be true that no rational actor will attempt an attack,
> however not all actors are rational. People also make mistakes, write
> buggy software, etc etc. The existence of risk doesn't ruin your idea
> - every protocol has risks. But identifying the specific risks is the
> only way to compare the properties against alternatives (like on chain
> transactions or the lightning network). I think its important to
> acknowledge these risks in your write up.
> 
>> I explained before this kind of attacks will not happened never
> 
> If people use your protocol, some will inevitably use it wrong. Those
> that use it wrong should be the ones that pay the price for it - but
> it is a downside of the protocol if the counter party of the person
> that makes a mistake (or attempts something malicious) is harmed as a
> result. Again, these kinds of trade offs are ok, but you should not be
> assuming that attacks like this will never happen. They will happen
> sometimes. You must assume that. The question is what is the result
> when an attack is attempted? And how will that affect what kinds of
> actors will attempt an attack (malicious, profit seeking, honest,
> stupid, wreckless, incompetent, other types of actors etc etc)?
> 
>> I didn?t find any case Lightning can compete with Sabu.
> 
> As I explained above related to risk, there are trade offs. I would
> like to see in your write up a clear list of these trade offs. The
> additional risk (as I explained it above) is one trade off. It sounds
> like there are limits in which a creditor or issuer can safely rely on
> incentives to prevent attacks. Did you specify what those limits are?
> The Lightning network also has limits - eg a lightning node can't
> allow its channel partner to spend 100% of their coins without taking
> on additional risk of attack. How do those limits compare in Sabu? For
> example, an issuer couldn't allow any creditor to spend so much of
> their credited bitcoin that their credit goes below the amount they
> would receive in any past Guarantee Transaction without taking on the
> risk that the creditor would post that guarantee transaction and
> receive coins they shouldn't own anymore. I would love to see a more
> detailed comparison of Sabu to lightning.
> 
> If your protocol works out, there are obvious benefits: transactions
> that could be done with no on-chain footprint. However, even if the
> protocol works out, there are trade offs and those trade offs should
> be made very clear. Even if the comparative downsides are small.
> 
> ~BT
> 
>> Hi Billy
>>> high-level overview of how all the pieces (How Sabu protocol
>> works).
>>> how normal transactions happen in their entirety.
>> Ok, lets re-explain Sabu. In Sabu protocol we have two type of
>> actors.
>> The issuers who own Bitcoin (they own UTXOs on Bitcoin blockchain),
>> and
>> the creditors who will own Bitcoins (the UTXOs on Bitcoin
>> blockchain),
>> if the issuer or the creditor sends the prepared transaction to
>> Bitcoin
>> network. But for know creditors have the transaction in their hand.
>> Before sending this transaction to Bitcoin network it acts (in Sabu
>> protocol and Sabu network) as a liability of issuer.
>> The story always starts from issuer, the person who get money or
>> goods
>> or services from a creditor and in exchange creates and sings a
>> valid
>> Bitcoin transaction by which the issuer spends his UTXO and as a one
>> of
>> the outputs of the transaction, there will be an output for
>> creditor?s
>> address equal to the money issuer already get paid.
>> This transaction is a valid transaction which is signed ?only?
>> by
>> issuer. The outputs of transaction are just and exact balance of the
>> parties (issuer and creditor).
>> Lets, imagine the creditor payed 5$ (almost equal to 15,000 Sat) to
>> issuer. Thus, issuer will create and sign a transaction by which he
>> spends 40,000 Sat and the outputs will be
>> 11,000 for creditor (the creditor has to pay 4,000 Sat in favor of
>> transaction fee),
>> 10,000 for Bitcoin-transaction-fee (4,000 by creditor and 6,000 by
>> issuer) and
>> 19,000 change back to issuer account address.
>> It is our Main Transaction (MT) which is a pretty normal and valid
>> transaction.
>> Alongside the MT, issuer creates and signs a Guarantee Transaction
>> (GT).
>> In GT issuer spends same 40,000 Sat UTXO as input, and as outputs
>> the creditor will get 15% of his 11,000 Sat in Main Transaction.
>> Thus
>> the creditor output will be 1,650 Sat and the rest of creditor?s
>> money
>> (11,000 ? 1,650 = 9,350 Sat) will be added to transaction fee.
>> In GT also issuer will lose a part of his money. New output for
>> issuer
>> will be 19,000 * 70% = 13,300 and the rest will be added to
>> transaction
>> fee (19,000 ? 13,300 = 5,700 Sat)
>> Thus, the new transaction fee in GT will be 10,000 + 9,350 + 5,700 =
>> 25,050 Sat
>> Now the creditor has 2 valid transactions (MT and GT) in his hands.
>> He
>> can send either MT or GT or both to Bitcoin Network. But in all
>> cases,
>> he will lose a portion of his money in favor of transaction fee
>> (miner?s
>> income). So, rationally he will never send transactions to Bitcoin
>> network unless he wants consciously hurt himself.
>> The creditor always prefers to spend his credit inside the Sabu
>> protocol. It is ?how normal transactions happen in their
>> entirety.?
>> Creditor has equal to 15,000 Sat credit. Say he wants to buy a caffe
>> worth 6,000 Sat. He has to ask the issuer to nullify previous MT and
>> GT,
>> and create and sign new transaction and cut 6,000 Sat from his
>> credit
>> and transfer it to a new creditor (say C2).
>> The new transaction will use same 40,000 UTXO as input and the
>> outputs
>> will be
>> 6,500 Sat for creditor (he pays 2,500 Sat for transaction fee)
>> 4,500 Sat for creditor 2 (he has to pay 1,500 Sat for transaction
>> fee as
>> well)
>> 10,000 for Bitcoin-transaction-fee (4,000 by two creditors and 6,000
>> by
>> issuer) and
>> 19,000 change back to issuer account address.
>> This is the new MT, and as you can see the C1 and C2 have their new
>> credit in transaction.
>> You can calculate the new GT as well.
>> Note: due to simplicity I just rounded the numbers and skipped the
>> Sabu-transaction-fee
>> I just wrote this long story to explain how creditors just transfer
>> money in between.
>> If we take a snapshot of Sabu network, we will see millions of valid
>> transactions flowing in network and none of the issuers or creditors
>> will send these transactions to Bitcoin network due the transaction
>> fee,
>> while in Bitcoin blockchain nothing is changed! The UTXOs are
>> untouched,
>> and no one can say which UTXO is promised to who.
>> It is a pretty secure off-chain protocol.
>> Although I expected more Bitcoiners to react about Sabu proposal and
>> comment for or against it, so far, I have not seen any serious
>> criticism
>> or real threat about protocol.
>> The miner attack is just a failed plan as I explained before.
>>> Sabu has slightly greater risk comparing lightning
>> It is not true, since creditors can manage they risk, and limit
>> their
>> credit to 5, 10 or 20 Dollar or 50$. It is totally up to creditor to
>> accept more liability from issuers or not.
>> The creditor can keep his credit around a fix number. That is, the
>> creditor spends a part of his credit and then again increase its
>> credit.
>> Let imagine you already payed 5$ to a issuer and you got 15,000 Sat
>> credit in your wallet. So, you will spend this 15,000 Sat (buy
>> coffee,
>> ice-cream, etc.) till your wallet run out of Satoshi and again you
>> will
>> pay another 5$ to issuer and get new 15,000 sat credit. Since all of
>> these transactions has near zero cost you are not obliged to charge
>> your
>> wallet 200$ in one shot.
>> It is absolutely low risk deal. In worst case the creditor (you)
>> will
>> lose 5$. And as I explained before this kind of attacks will not
>> happened never. And as you told Sabu provides cheaper and a larger
>> number of transactions.
>>> This would be essentially worse than the lightning network in some
>> ways,
>> Disagree! Please explain the scenario exactly. I didn?t find any
>> case
>> Lightning can compete with Sabu.
>>> ledger of accounts and their balances, along with proof that the
>> entity owns?
>> It is almost what I designed in Sabu. They are doc-watcher servers.
>> They
>> are a set of records of UTXOs and the proper Merkle root hash of
>> related
>> transaction in Sabu network. The intention was stopping issuer from
>> spend and promises same UTXO to different people (that they are not
>> aware of the existence of the other). So, any individual creditor
>> (or
>> their software) could verify that total liabilities (in account
>> balances) are less than the half of the total bitcoins the entity
>> owns.
>> And if something doesn't match up, they won?t yell, instead they
>> refuse
>> the deal in first place, or send the GT to Bitcoin network and hurt
>> the
>> cheater issuer by slashing his money. it is ?Tit-for-tat?.
>>> I think it likely has critical security holes. Perhaps you can fix
>> them!
>> There is no critical security hole. Please refer it by facts,
>> numbers
>> and proves.
>> I think I already fixed all critics.
>> 
>> Billy! I am actively working on this proposal and if no one cannot
>> show
>> a real problem or security issue in the project, I will start
>> implementing it.
>> Just imagine people regularly using Sabu protocol and send/receive
>> Bitcoin (Satoshi) in billions of small amount transactions every
>> day.
>> This protocol will outspread Bitcoin and will attract a new crowd of
>> penny investors to Bitcoin. The people who can afford 20$ or less
>> monthly to invest on Bitcoin.
>> Sabu brings Bitcoin to a whole new life.
>> It will be the true scalable and mass adaption, and I do not know
>> how to
>> attract more real Bitcoin fans to this proposal!
>> Guys! Here is the Bitcoin renascence.
>> Maybe you can help it.
>> Regards
>> Raymo
> 
> On Sat, Jul 3, 2021 at 1:02 AM <raymo at riseup.net> wrote:
> 
>> Hi Billy,
>> 
>>> What if it was possible for the creditor to claw back the funds
>> As far as I know the ?claw back? mechanism doesn?t exist in
>> Bitcoin
>> system, and probably most Bitcoiners won?t be agree on it.
>> Even if we want to add claw back to Bitcoin in general, and Sabu in
>> particular, it would add too complexities and uncertainty to
>> Bitcoin.
>> So, it would be better to not touch that part, instead focusing on
>> reduce the cheating risk by putting some penalty for both issuers,
>> creditors and miners.
>> We already have the penalties for both issuers and creditors.
>> It looks the miners still can abuse Sabu, but as I told before the
>> miner
>> or better say the mining pool must be issuer (to be able to sign the
>> promised UTXO in cheating way) or must be creditor (in order to have
>> a
>> copy of GT and not lose his money in favor of a stranger miner.
>> Remember
>> the fact that creditor will lose 70% of their money in favor of
>> Bitcoin
>> transaction fee in a typical GT) or collaborate one of them in a
>> conspiracy. Otherwise, there will be no economic benefit in this
>> attack.
>> 
>> All these 3 cases of the attacks, theoretically could be happened,
>> but
>> the risk to reward ratio is enough high to hinder potential
>> malevolent
>> from a practical act.
>> Even this very small risk of miner attacks (which don?t care the
>> attack
>> costs, since he is not interested in economic benefit, but he wants
>> to
>> ruin Sabu), would be resolved by a slightly upgrade in Bitcoin
>> protocol
>> by applying the BIPxxx ?for flagging/unflagging promised UTXOs?.
>> 
>> I am not in rush to apply this upgrade on Bitcoin protocol, instead
>> I am
>> actively working in order to realize the Sabu protocol and Gazin
>> wallet.
>> Later the Sabu community will carry the BIPxxx.
>> 
>> Best
>> 
>> On 2021-07-02 17:57, Billy Tetrud wrote:
>>> Thanks for the details Raymo. A thought occurred to me. Given the
>> fact
>>> that miners can abuse this system without penalty, it would be
>> useful
>>> to be able to fix this. What if it was possible for the creditor
>> to
>>> claw back the funds even if the cheating transaction was mined
>> instead
>>> of the guarantee transaction? Let's say there was a way to sign a
>>> transaction that gives the receiver of that transaction the
>> ability to
>>> override any other transaction that uses the UTXO? If this were
>>> possible, the issuer could give the creditor this kind of
>> transaction
>>> as the guarantee transaction, and in the case a cheat was done,
>> the
>>> creditor could still use the GT to reallocate that UTXO to
>> themselves.
>>> 
>>> Now there are issues with this. First of all, it could give anyone
>> the
>>> ability to double spend. So it would be prudent to limit this in
>> some
>>> way. The revocation probably should only be valid for up to 6
>> blocks,
>>> such that if the transaction has 6 confirmations, it can no longer
>> be
>>> reallocated (thus preserving the 6 block finality rule). It could
>> also
>>> be required that the UTXO be marked as opting into this behavior
>> (so
>>> receivers would know about the possibility it could get revoked).
>> This
>>> second requirement would require Sabu issuers to make an on-chain
>>> transaction to set themselves up as an issuer.
>>> 
>>> Another issue is that this would make it possible for transactions
>> to
>>> expire. Any claw-back transaction would expire 6 blocks after the
>>> initial transaction happened. This has been generally avoided in
>>> bitcoin, but I think the relevant issues are solvable. You can
>> find
>>> additional discussion of that in this thread [1].
>>> 
>>> I would imagine this kind of ability would be pretty
>> controversial,
>>> but since it can close out the possibility for miners to escape
>>> punishment, it could make this protocol viable.
>>> 
>>> On Thu, Jul 1, 2021 at 3:15 PM <raymo at riseup.net> wrote:
>>> 
>>>> Hi Erik
>>>> 
>>>> Please correct me if I misunderstood.
>>>> 
>>>>> email is fully compromised.
>>>> 
>>>> What I got is:
>>>> Email is not good because the sender and receiver are
>> compromised.
>>>> Email is not good because the message content is revealed.
>>>> I can claim same argue about any other client/server model. Since
>>>> the
>>>> server (website) service provider will ask some sort of KYC. And
>>>> even if
>>>> the server uses end-to-end encryption, the provider company still
>>>> can
>>>> read the packets content.
>>>> In my model the passive listener only can discover who is
>>>> communicate to
>>>> whom and make a graph of connections. Although it is a threat for
>>>> privacy but the server/client model has this flaw inherently,
>> since
>>>> provider already knew everything about everyone. In my model at
>>>> least
>>>> users can make some fake connections and send some fake emails in
>>>> order
>>>> to inject noise to communications.
>>>> Please note the fact that entire communication between mobile
>>>> wallets
>>>> (via emails) are asymmetric PGP encrypted. The PGP keys are
>>>> controlled
>>>> by end users unlike ALL pretending secure messengers (e.g
>> whatsApp,
>>>> signal, zoom,?).
>>>> If you are worried about the way of exchanging PGP public key,
>> you
>>>> are
>>>> right. The most secure way is in-person PGP key exchanging.
>>>> After that for payments the wallets communicate in pgp encrypted
>>>> messages and they can transfer Bitcoin address through an PGP
>>>> encrypted
>>>> cipher, thus no revealing Bitcoin address to public would occur.
>>>> Neither
>>>> the amounts of transactions will be reviled.
>>>> There for it would be a good practice for shops to put their
>> email
>>>> and
>>>> PGP public key on shop website and/or PGP public key servers,
>>>> instead of
>>>> putting Bitcoin address on website or using 3rd parties services
>> to
>>>> hide
>>>> their Bitcoin payment addresses.
>>>> 
>>>> If I missed some points about ?fully compromised? please
>> write
>>>> it to me.
>>>> 
>>>>> public keys / addresses are sent
>>>> As I told before ALL communication in Sabu are PGP encrypted.
>>>> 
>>>>> other routing data encrypted with public keys
>>>>> (not sure how data is routed in sabu)
>>>> 
>>>> Sabu is not responsible for routing at all. It simply sends
>> emails.
>>>> Indeed the wallets peer-to-peer network in Sabu is pretty
>> straight
>>>> forward. Each mobile wallet has one email address as its handler
>> and
>>>> identifier in mobile-wallets-network. Each mobile can send
>> message
>>>> to
>>>> another mobile by knowing its email address and the PGP public
>> key.
>>>> This information can be prepared in first face-to-face contact of
>>>> mobile
>>>> owners, or later (something like signing the other?s public key
>> in
>>>> web
>>>> of trust) when a creditor wants to spend his money and transfer
>> it
>>>> to
>>>> another creditor. The creditor1 send the signed money transfer
>>>> request
>>>> alongside the email and public key of creditor2 all in a PGP
>>>> encrypted
>>>> message to issuer.
>>>> 
>>>>> separate the Sabu protocol from the app... allow others to
>>>> implement
>>>>> desktop version, or other versions that use other routing
>> systems
>>>> 
>>>> Indeed, it is my approach too. As I told before users will decide
>>>> between an unstoppable, permission less, self-sovereignty and
>>>> decentralized pure peer-to-peer communication network (with some
>>>> resolvable privacy issues) or some efficient, privacy-mimic
>> central
>>>> limited network.
>>>> 
>>>>> you can allow direct-entry of a BIP-word-representation
>>>>> of a public key/address to avoid privacy/central system concerns
>>>> Agree. Actually, I was thinking about an easy mechanism to share
>>>> your
>>>> public key like what you suggested here.
>>>> But what I consider for a ?central system concerns? is the
>>>> ability of
>>>> communication without dependency to any company.
>>>> As an example, what can you do if the twitter bans your account?
>>>> Nothing! Your content and entire connections will be lost.
>>>> But if you form your friends list in your mobile (or computer)
>> and
>>>> have
>>>> their PGP public keys and they have yours, and use email as a
>> dual
>>>> purpose tool. First as a handler (the tool for finding and to be
>>>> found
>>>> in internet) and second as a communication tool.
>>>> Thus, no one can stop you, ban you or limit you to send/receive
>>>> transaction to/from anyone.
>>>> What I am trying to say is using email is far better than account
>>>> (username) in a limited central service like twitter, Facebook,
>>>> telegram... or even in future Sabu servers!
>>>> You have your connections under your control in your phone. You
>> can
>>>> easily change your email and use a new email or even a new
>> service
>>>> provider without losing your connections and your control over
>> it.
>>>> You just sign your new email address and send it to your friends
>>>> circle
>>>> and notify them about changes.
>>>> Of course, email is not good for millions of followers but it is
>>>> obviously good for managing your payment network of hundreds of
>>>> people
>>>> (either issuers or creditors).
>>>> 
>>>> Best
>>>> Raymo
>>>> 
>>>> On 2021-07-01 20:49, Erik Aronesty wrote:
>>>>> your protocol should always assume the email system is fully
>>>>> compromised, and only send public information over email:
>>>>> 
>>>>> - public keys / addresses are sent
>>>>> - other routing data encrypted with public keys (not sure how
>> data
>>>> is
>>>>> routed in sabu)
>>>>> 
>>>>> your end user should be able to verify public keys  / addresses
>>>>> 
>>>>> - use QR-codes
>>>>> - phone calls with users reading BIP words out loud
>>>>> - other in-person information exchange
>>>>> 
>>>>> separate the Sabu protocol from the app... allow others to
>>>> implement
>>>>> desktop version, or other versions that use other routing
>> systems
>>>>> 
>>>>> -  you can allow direct-entry of a BIP-word-representation of a
>>>> public
>>>>> key/address to avoid privacy/central system concerns
>>>>> 
>>>>> On Thu, Jul 1, 2021 at 4:20 PM raymo via bitcoin-dev
>>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>> 
>>>>>> Hi Billy,
>>>>>> Sorry for late reply. Let?s jump in proposal.
>>>>>> 
>>>>>>> Some more information about the benefits of this approach vs
>>>> alternatives (mainly lightning)
>>>>>> The most important different is unlike the lightning, in Sabu
>> no
>>>> one
>>>>>> have to open a channel and pay Bitcoin transaction fee,
>>>> subsequently no
>>>>>> one has to close channel and pay another Bitcoin transaction
>> fee.
>>>> It is
>>>>>> the huge improvement since it drops the overhead cost of
>>>> transactions.
>>>>>> So, it will be more convenience to trade under Sabu protocol.
>>>>>> In Sabu none of parties of a transaction are obliged to block
>>>> money in
>>>>>> any kind of smart contract or any other m of n signature
>> accounts
>>>>>> on-chain, so it provides more privacy.
>>>>>> Since Sabu protocol is designed to motivate people to circulate
>>>>>> transactions (AKA debt documents) in Sabu network, if every
>> actor
>>>> act
>>>>>> rationally no one will aware how much money transferred from
>> who
>>>> to
>>>>>> whom.
>>>>>> In case of fraudulent activity by issuer, the creditor will
>> send
>>>>>> Guarantee Transaction (GT) to Bitcoin network in order to
>>>> recapture the
>>>>>> part of his credit. So, in this case the transaction is
>> literally
>>>>>> recorded on bitcoin blockchain.
>>>>>> There is only one another reason to recording transaction on
>>>> Bitcoin
>>>>>> blockchain. Where one creditor eager to pay Bitcoin transaction
>>>> fee in
>>>>>> order to aggregate thousands or even millions different small
>>>> amount
>>>>>> debt-documents in a single transaction on Bitcoin blockchain.
>>>>>> despite these two cases, the rest of transactions all occur in
>>>> the Sabu
>>>>>> network (supposed to be over 99%). Thus, no footprint no
>>>> bottleneck and
>>>>>> no over process.
>>>>>> 
>>>>>> Another important power point of Sabu is its pure-peer-to-peer
>>>> network
>>>>>> architecture. In Sabu the mobile wallets communicating to each
>>>> other
>>>>>> directly without any central server. There is no centralization
>>>> at all.
>>>>>> As a result, there will be no routing as well.
>>>>>> Since only issuer and creditors are aware of the content of
>>>> transaction
>>>>>> (who pay how much to whom) it is a huge privacy improvement,
>>>> which
>>>>>> doesn?t exist in other layer 2 solutions.
>>>>>> 
>>>>>> About the usability of Sabu, although the protocol based on the
>>>>>> collaborating 2 different peer-to-peer network and 3 classic
>>>>>> server/client networks, but the end user (mobile wallet user)
>>>> doesn?t
>>>>>> see any of these complexities.
>>>>>> The end user simply installs the mobile/desktop wallet and add
>>>> her/his
>>>>>> friends to his phonebook by adding their email address or
>>>> scanning their
>>>>>> email (and/or PGP public key). After that s/he can immediately
>>>> start to
>>>>>> send/receive Bitcoin through Sabu network. Entire
>> communications
>>>> between
>>>>>> wallets are PGP encrypted.
>>>>>> Another good point in Sabu design is, the 12 seed words are
>> using
>>>> for
>>>>>> both Bitcoin wallet private key and the PGP private key. So, it
>>>> is the
>>>>>> key of user wealth and its identity as well. For more details,
>>>> please
>>>>>> read my previous answer to Alex Schoof.
>>>>>> The issuer, by using his UTXOs and selling them to creditors
>> earn
>>>> money.
>>>>>> the issuer creates the debt document (transaction) by which
>>>> promises to
>>>>>> creditor an amount of satoshi. These debt documents are valid
>>>> Bitcoin
>>>>>> transaction. The only difference is these transactions are
>>>> intended to
>>>>>> circulate in Sabu protocol instead of sending to Bitcoin
>>>> blockchain.
>>>>>> Each transaction is a small money transfer. 40,000 Satoshi as
>>>> input and
>>>>>> maximum 20,000 Satoshi as credit and minimum 10,000 Satoshi as
>>>> Bitcoin
>>>>>> transaction fee.
>>>>>> The creditors will use these received transactions as money and
>>>> will pay
>>>>>> it in exchange of goods or services. For each transaction the
>>>> creditor
>>>>>> pays 10 Satoshi as Sabu-transaction-fee to issuer.
>>>>>> Sabu is not custodial service and the UXTOs are always under
>>>> issuer
>>>>>> control, unless issuer or creditor send the signed transaction
>> to
>>>>>> Bitcoin network. When the transaction was recorded in Bitcoin
>>>>>> blockchain, the creditor can spend proper UTXO in Bitcoin
>>>> network.
>>>>>> Imagine million people use their UTXOs in Sabu, they are issuer
>>>> and
>>>>>> issue/update/cancel million transactions per second. All they
>>>> need is a
>>>>>> mobile wallet. On the other hand, every one by knowing an
>> issuer
>>>> can buy
>>>>>> some Satoshi (whit absolutely no KYC), even 1 Dollar or less,
>> and
>>>> spend
>>>>>> it, this time Alice really can buy caffe by Bitcoin ;)
>>>>>> The Bar can install the mobile wallet and every day receives
>>>> thousands
>>>>>> of debt documents (transactions), each worth maximum 20,000
>>>> Satoshi in
>>>>>> exchange of coffee. And every evening aggregates those small
>>>>>> transactions to one single transaction and send it to Bitcoin
>>>> network.
>>>>>> 
>>>>>> 
>>>>>> The security model of Sabu is pretty straight forward.
>>>>>> Issuer is the owner of UTXO(s) which will be used in
>>>> transactions. The
>>>>>> issuer is and will the only person who creates transactions and
>>>> sign
>>>>>> them. The transactions are valid transaction which either
>> issuer
>>>> or
>>>>>> creditor can send them to Bitcoin network, but they will never
>>>> send
>>>>>> these transactions to Bitcoin network, because of the high
>>>> Bitcoin
>>>>>> transaction fee for each single transaction.
>>>>>> Since issuer is the only one who can sign transaction (spend
>>>> UTXOs),
>>>>>> there is a risk of issuer cheating. And no one can stop issuer
>>>> from
>>>>>> cheating, because these are his UTXOs and he has the proper
>>>> private
>>>>>> keys.
>>>>>> The Sabu solution is Guarantee transaction. It is a valid
>>>> transaction
>>>>>> that issuer has to sign it alongside the Main transaction. In
>> GT
>>>> both
>>>>>> issuer and creditor cut a part of their output in favor of
>>>> Bitcoin
>>>>>> transaction fee.
>>>>>> We suppose miners always seeking for more profit, thus in a
>> case
>>>> there
>>>>>> are 2 or more transaction are spending same UTXO as input,
>> miner
>>>> will
>>>>>> choose transaction with highest feeRate. There is no
>> economically
>>>>>> benefit for issuer to cheat creditors and pay less transaction
>>>> fee
>>>>>> simultaneously. So rationally the issuer won?t cheat
>> creditor.
>>>>>> It was the simplest explanation of Sabu security model.
>>>>>> 
>>>>>>> I agree with others that using email is probably not
>>>> appropriate for a protocol like this. I would highly recommend
>>>> making your protocol transport-agnostic, allowing users of your
>>>> protocol to use any transport they want.
>>>>>> Indeed, the protocol is transparent-agnostic, if I insist of
>>>> email as a
>>>>>> user identifier and communicating tool is because of the idea
>> of
>>>>>> reforming part of internet architecture and make it more
>>>> decentralized.
>>>>>> The wallet users can choose classic architecture. In this case
>>>> mobile
>>>>>> wallets will connect to a central server and communicate
>> through
>>>> that
>>>>>> server (pretty much like all existed mobile wallets). While
>> some
>>>> users
>>>>>> decide to use a pure peer-to-peer communication. I knew email
>> has
>>>> some
>>>>>> privacy issues but as always it is a tradeoff. Users can decide
>>>> between
>>>>>> an unstoppable, permission less, self-sovereignty and
>>>> decentralized pure
>>>>>> peer-to-peer communication network (with some resolvable
>> privacy
>>>> issues)
>>>>>> or some efficient central limited network.
>>>>>> Let me know the critics about email. Hopefully this would lead
>> us
>>>> to
>>>>>> improve email instead of letting it die. I strongly suggest
>> email
>>>>>> because it is the ONLY neutral, free ?nonproprietary? and
>>>> open
>>>>>> protocol/technology for communication in the world that its
>>>>>> infrastructure is well-established and is accessible all over
>> the
>>>> glob.
>>>>>> 
>>>>>> I tried to explain it more, hope was useful. By the way the
>>>> complete
>>>>>> explanation is here
>>>>>> 
>>>> 
>>> 
>> 
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>>>>>> 
>>>>>> 
>>>>>> 
>>>>>> Regards
>>>>>> Raymo
>>>>>> 
>>>>>> 
>>>>>> 
>>>>>> On 2021-06-22 18:20, Billy Tetrud wrote:
>>>>>>> I would be interested in seeing some more information about
>> the
>>>>>>> benefits of this approach vs alternatives up front in this
>>>> write up.
>>>>>>> Eg how does the security, cost, usability, and privacy compare
>>>> to the
>>>>>>> lightning network, which would be the most likely competitor
>> to
>>>> this
>>>>>>> idea. It seems clear that there is more counterparty risk
>> here,
>>>> so it
>>>>>>> would probably also be very helpful to compare against
>>>> traditional
>>>>>>> custodial solutions as well. If you have specific claims on
>> how
>>>> this
>>>>>>> system is better than eg lightning in certain contexts, it
>>>> would be
>>>>>>> far easier to evaluate the protocol against those claims, and
>>>> would
>>>>>>> also be a lot easier for readers to be motivated to read the
>>>> whole
>>>>>>> protocol and do a more full analysis.
>>>>>>> 
>>>>>>> I agree with others that using email is probably not
>>>> appropriate for a
>>>>>>> protocol like this. I would highly recommend making your
>>>> protocol
>>>>>>> transport-agnostic, allowing users of your protocol to use any
>>>>>>> transport they want.
>>>>>>> 
>>>>>>> On Sat, Jun 19, 2021 at 7:00 PM James Hilliard via bitcoin-dev
>>>>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>>> 
>>>>>>>> I think you're making a number of assumptions about mining
>>>> that are
>>>>>>>> not accurate.
>>>>>>>> 
>>>>>>>>> First of all, how much chance in finding next block the
>>>> corrupted
>>>>>>>> miners have? One percent of all Bitcoin hash powers? Or
>>>> maximum 5
>>>>>>>> percent or 10? The cheaters must come up in dividing that 1.2
>>>>>>>> Bitcoin between. After all the risk/reward must fit them.
>> They
>>>> can
>>>>>>>> not be a big mining pool since there is no benefit, so they
>>>> will be
>>>>>>>> small miners with low hash rate. If they solve the puzzle and
>>>>>>>> broadcast the block, no one in the entire Bitcoin network has
>>>> block
>>>>>>>> transactions or seen it before in their mempool!
>>>>>>>> 
>>>>>>>> You're making the assumption that miners won't build on top
>> of
>>>> a
>>>>>>>> block
>>>>>>>> with transactions they have not seen before or transactions
>>>> that may
>>>>>>>> contain double spends of unconfirmed inputs, this is not how
>>>> mining
>>>>>>>> works, as long as the block passes the consensus rules
>>>> effectively
>>>>>>>> all
>>>>>>>> miners will mine on top of it by default, this behavior is
>>>>>>>> fundamental
>>>>>>>> to how mining currently works and is fairly deeply baked into
>>>> the
>>>>>>>> current mining infrastructure.
>>>>>>>> 
>>>>>>>>> Will they accept this block? In theory it is possible and
>>>> have
>>>>>>>> 0.01 percent chance but we can eliminate this small
>>>> possibilities by
>>>>>>>> a simple BIP for miners.
>>>>>>>> 
>>>>>>>> What would this BIP look like? I don't see how this could
>> work
>>>> in a
>>>>>>>> decentralized way as you would need another way of reaching
>>>>>>>> consensus
>>>>>>>> on what defines a valid block. Right now the chance is nearly
>>>> 100
>>>>>>>> percent that a miner will mine on top of the latest valid
>>>> block,
>>>>>>>> many
>>>>>>>> pools(most last I checked) will even mine on the next block
>>>> before
>>>>>>>> they validate the latest block fully(ie validationless
>> mining)
>>>> to
>>>>>>>> reduce their orphan rates.
>>>>>>>> 
>>>>>>>>> We suppose the miners always control transactions with
>>>>>>>> doc-watchers and avoid accepting transaction with same UTXO
>>>> but
>>>>>>>> different output.
>>>>>>>> 
>>>>>>>> Miners have different mempool policy/rules for what
>>>> transactions
>>>>>>>> they
>>>>>>>> themselves mine but all miners must mine on the most work
>>>> chain of
>>>>>>>> valid blocks otherwise they risk their own blocks being
>>>> orphaned,
>>>>>>>> any
>>>>>>>> miner that does not do this is effectively guaranteed to have
>>>> their
>>>>>>>> block orphaned right now.
>>>>>>>> 
>>>>>>>>> Because of high Bitcoin transaction fee, this guarantee
>>>>>>>> transaction will take place in next block, even if other
>>>> transaction
>>>>>>>> which are using the same UTXO as input existed in mempool.
>>>>>>>> 
>>>>>>>> When a new transaction is broadcast miners do not immediately
>>>> start
>>>>>>>> mining on a block template that includes that transaction,
>> the
>>>>>>>> template won't even be generated immediately when it enters a
>>>> miners
>>>>>>>> mempool in practice, for bandwidth/network efficiency reasons
>>>> mining
>>>>>>>> pools batch update the stratum templates/jobs they mine
>>>> against so
>>>>>>>> there can be significant latency between the time a
>>>> transaction is
>>>>>>>> actually broadcast and hits the miners mempool and the time
>>>> the
>>>>>>>> miners
>>>>>>>> actually switch to mining on top it, these batched updates
>> are
>>>>>>>> essentially like point in time snapshots of the mempool and
>>>>>>>> typically
>>>>>>>> remain valid(as in the pool will accept shares submitted
>>>> against
>>>>>>>> that
>>>>>>>> job as valid) until the bitcoin network finds the next block.
>>>> I
>>>>>>>> don't
>>>>>>>> think these batch updates are done more often than every 30
>>>> seconds
>>>>>>>> typically, while often it is on the order of multiple minutes
>>>>>>>> depending on the pool.
>>>>>>>> 
>>>>>>>> Regards,
>>>>>>>> James
>>>>>>>> 
>>>>>>>> On Thu, Jun 17, 2021 at 2:14 PM raymo via bitcoin-dev
>>>>>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>>>>> 
>>>>>>>>> Hi,
>>>>>>>>> I have a proposal for improve Bitcoin TPS and privacy, here
>>>> is the
>>>>>>>> post.
>>>>>>>>> 
>>>>>>>> 
>>>>>>> 
>>>> 
>>> 
>> 
> https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180
>>>>>>>>> https://bitcointalk.org/index.php?topic=5344020.0
>>>>>>>>> Can you please read it and share your idea about it.
>>>>>>>>> 
>>>>>>>>> Cheers
>>>>>>>>> Raymo
>>>>>>>>> _______________________________________________
>>>>>>>>> bitcoin-dev mailing list
>>>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>>>> 
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>>>> _______________________________________________
>>>>>>>> bitcoin-dev mailing list
>>>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>>>> 
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>> _______________________________________________
>>>>>> bitcoin-dev mailing list
>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> 
>>> 
>>> Links:
>>> ------
>>> [1]
>> 
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019050.html


From contact at taoeffect.com  Sat Jul 17 18:54:22 2021
From: contact at taoeffect.com (Tao Effect)
Date: Sat, 17 Jul 2021 11:54:22 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <6016816a7ea36b8a88f48d69462d0308@riseup.net>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
 <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
 <6016816a7ea36b8a88f48d69462d0308@riseup.net>
Message-ID: <CFDC9C2D-8EBC-4967-977A-702856997655@taoeffect.com>

Hi Raymo,

I personally am excited about what you?re working on, and wish you the best of luck with it!

Cheers,
Greg

> On Jul 17, 2021, at 8:50 AM, raymo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> After introducing Sabu protocol as a solution for Bitcoin scaling
> (https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180),
> I shared this idea with Bitcoin developers through the bitcoin-dev
> mailing list.
> I got some constructive feedbacks and critiques leading me to add this
> part to the proposal which I was skipped due to brevity of proposal
> introduction.
>  [..]

From michael.flaxman at protonmail.com  Tue Jul 20 19:44:19 2021
From: michael.flaxman at protonmail.com (Michael Flaxman)
Date: Tue, 20 Jul 2021 19:44:19 +0000
Subject: [bitcoin-dev] Multisig Enhanced Privacy Scheme
Message-ID: <CfD2116tK9mH7-X40QXgiPw8lf-DoWqz_YaqurUg-6LhTPgCjhSq94gVHg4SOChkJZtOTafy4Qd9-_TkBr1tjAOO9GZojVjr3U65ruPhLlI=@protonmail.com>

I've been working on ways to prevent privacy leaks in multisig quorums, and have come up with a creative use of BIP32 paths.

Working code with broadcasted transactions can be found here:
https://github.com/mflaxman/blind-xpub

This scheme allows for some powerful new features:

- If an unauthorized party gains access to a BIP39 seed phrase, that party learns nothing about transactions in any multisig quorum that seed participates in
- It allows trusted-minimized third parties (e.g. a lawyer, accountant, heir, close friend, "uncle Jim" bitcoiner, collaborative custody service, etc) to hold an emergency recovery key in a multisig quorum with zero knowledge of what that key protects

This scheme has been live on mainnet for some time and has multi-vendor support from several Coordinators and Signers. I am anecdotally aware of large sums of bitcoin that are currently being HODLed with it.

My hope in publishing this is to encourage more interoperable hardware wallet / coordinator software support for enhanced privacy, along with improved UX at each step. Feedback is welcome.

Best,

Michael
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210720/d3326b7d/attachment.html>

From billy.tetrud at gmail.com  Wed Jul 21 05:56:10 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 20 Jul 2021 22:56:10 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION (an
	alternative to OP_CTV)
Message-ID: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>

Hi All,

I have been working on a proposal for an opcode I call
OP_CONSTRAINDESTINATION. The purpose of the opcode is to allow a spend-path
to restrict the destination address that an output's coins can be directed
to. When the destination address is something like a P2SH address, this
allows step-wise covenant scripts (where one script must lead to another).

This involves both specifying particular addresses the output is allowed to
send coins to, as well as constraining the amount of the fee that output is
allowed to contribute to. For example, if you had an output that contains
1000 satoshi, you could specify that a maximum of ~100 sats of that output
go to the miner fee and the other ~900 sats must go to one of a list of
specified addresses (~ meaning approximately, because the fee is specified
relative to recent median fee rates - details in the proposal).

This opcode has a few different applications, but my primary motivation for
creating this opcode is to create more flexible wallet vaults
<https://hackingdistributed.com/2016/02/26/how-to-implement-secure-bitcoin-vaults>
.

To compare this opcode to OP_CHECKTEMPLATEVERIFY, wallet vaults that can be
created with OP_CTV must be created in specified chunks: the address is
explicitly tied to a particular utxo sent to it. To retrieve coins from the
vault, the output must be spent by one of a specific set of transactions
(potentially one per spend path). Outputs cannot be arbitrarily combined
into a transaction, and there is no flexibility whatsoever in deciding
options at the time of spending from the vault - all options must be
premeditated and encoded into the address itself when sending money to the
vault. This has some related foot-gun scenarios, where the wallet vault has
addresses that if sent to would generally result in burning those coins,
unless done in a very specific way by the owner of the vault.

By contrast, OP_CD allows a lot more flexibility because it only constrains
the address to be sent to from the vault, but doesn't put additional
constraints on the transaction. This means that outputs can be combined
into a single transaction like you would expect in a normal transaction. It
also means that external users (people who don't own the vault) can safely
send money directly into the vault without coins being burned.

*I have the proposal for this opcode up here:
https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md>*.
I'd love to hear what people think about it, what problems it might have
that I've missed, or other issues or suggestions surrounding this. I'd also
appreciate any input that would help me improve the presentation of the
opcode.

Thanks!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210720/71264b19/attachment.html>

From belcher at riseup.net  Thu Jul 22 14:44:11 2021
From: belcher at riseup.net (Chris Belcher)
Date: Thu, 22 Jul 2021 15:44:11 +0100
Subject: [bitcoin-dev] BIP proposal: Anti-fee-sniping protection with
 nSequence in taproot transactions to improve privacy for off-chain
 protocols
In-Reply-To: <3dc2e965-77c6-f923-4c00-0cbea7b6d9e5@riseup.net>
References: <3dc2e965-77c6-f923-4c00-0cbea7b6d9e5@riseup.net>
Message-ID: <5c367528-5fc9-1225-5c32-150e71a9de45@riseup.net>

Hello list,

Someone reviewing my taproot privacy BIP proposal suggested
clarification on the spec, so I've written some python-like pseudocode.
It implements the suggestion of choosing a random input instead of the
first one.

Some wallet teams are already working on implementing taproot for their
on-chain app. I urge wallet developers to include this BIP as well, so
that their user's spends will improve the privacy and fungibility of
off-chain protocols. Also, and admittedly a less urgently,
anti-fee-sniping will improve the incentives for miners in the
low-inflation future of bitcoin.

As before find the latest version of this BIP here:
https://gist.github.com/chris-belcher/903feab321bf41055c91eaec46581e89


def apply_anti_fee_sniping_fields(transaction):
    # bip68 requires v=2
    transaction.version = 2
    # always set nlocktime if any of the transaction inputs have more
    # confirmations than 65535 or are taproot inputs
    # otherwise choose either nlocktime or nsequence with 50% odds
    if any(map(lambda input: input.confirmations() > 65535
	    || input.is_taproot(), transaction.inputs))\
	    || randint(2) == 0:
	transaction.nlocktime = blockchain.height()
	if randint(10) == 0:
	    transaction.nlocktime = max(0, transaction.nlocktime
	    - randint(0, 99))
    else:
	input_index = randint(len(transaction.inputs))
	transaction.inputs[input_index].nsequence = transaction.inputs\
	    [input_index].confirmations()
	if randint(10) == 0:
	    transaction.inputs[input_index].nsequence = max(0,
		transaction.inputs[input_index].nsequence
                - randint(0, 99))

From prayank at tutanota.de  Fri Jul 23 18:48:31 2021
From: prayank at tutanota.de (Prayank)
Date: Fri, 23 Jul 2021 20:48:31 +0200 (CEST)
Subject: [bitcoin-dev] Bitcoin Privacy Week/Month
Message-ID: <MfJgdEO--3-2@tutanota.de>

Hello World,

What?

I would love if Bitcoin developers would celebrate a 'Bitcoin Privacy week or month' once in an year. Not sure about the dates. Enthusiasm can be similar to Valentines week or Secret Santa week but Seriousness should be like Wikileaks or Human Rights Foundation.

Why?

I am not sure if we need reasons, charts, etc. to discuss privacy and make all users aware of things involved. People consider privacy issues as something that can be ignored, for me they are same as security issues and very important in network like Bitcoin. Most of the people may still ignore it considering the feedback on few issues related to privacy in past. Although we can still try and its a new day. Not giving up is what makes the difference in the end.

Also I would like to clarify, there are lot of positives and people that have contributed a lot to improve privacy in Bitcoin but they will never get similar appreciation as compared to few others because of different reasons which I don't want to discuss here and one of them is decentralization.? Don't want to mention names but there have been influencers in past who are followed by lot of people for their thoughts on privacy but a normal Bitcoin Core Contributor with less than 1000 followers and lot of work that improved privacy in Bitcoin is ignored.

This is a speech from an Indian web series which only people who know Hindi would understand:?https://www.youtube.com/watch?v=ztBfQU41s-o

TL;DR:?
This guy was not allowed to talk about his product
He still argued that he cannot talk about the product but still talk about something in 5 minutes.
He says nobody cares about "What", they are interested in "Why"
He is scared and feels like a contestant in reality show in which he can't even perform.
Most important thing: Never give up
Mentors, Angel Investors etc. are external things that you don't control, what you can do is prove things with your work.
He couldn't sell his product so he sold himself.
I will keep trying to improve privacy or talk about it when I cannot code in few things. Request other developers to help.
How?

Share 1 issue from repository of any Bitcoin project related to privacy and your thoughts.
Share 1 pull request
Share anything else that you think may help improve things related to privacy
Mailing list or Twitter or something else? I am not sure.

Is this off topic? If yes, apologize and maybe request same people on other channels.?
-- 
 Prayank

A3B1 E430 2298 178F
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210723/801e0768/attachment.html>

From dave at dtrt.org  Sun Jul 25 04:49:24 2021
From: dave at dtrt.org (David A. Harding)
Date: Sat, 24 Jul 2021 18:49:24 -1000
Subject: [bitcoin-dev] Multisig Enhanced Privacy Scheme
In-Reply-To: <CfD2116tK9mH7-X40QXgiPw8lf-DoWqz_YaqurUg-6LhTPgCjhSq94gVHg4SOChkJZtOTafy4Qd9-_TkBr1tjAOO9GZojVjr3U65ruPhLlI=@protonmail.com>
References: <CfD2116tK9mH7-X40QXgiPw8lf-DoWqz_YaqurUg-6LhTPgCjhSq94gVHg4SOChkJZtOTafy4Qd9-_TkBr1tjAOO9GZojVjr3U65ruPhLlI=@protonmail.com>
Message-ID: <20210725044924.k5zhlwiatyq4i3c2@ganymede>

On Tue, Jul 20, 2021 at 07:44:19PM +0000, Michael Flaxman via bitcoin-dev wrote:
> I've been working on ways to prevent privacy leaks in multisig
> quorums, and have come up with a creative use of BIP32 paths.

It seems to me like it would be rare for an attacker to obtain a private
BIP32 seed but not simultaneously learn what HD paths it's being used with.
I assume basically everyone is storing their descriptors (or descriptor
equivalents) alongside their seeds; doing so helps ensure a robust
recovery.

However, to the degree that privacy from seed thieves is a problem we
want to solve, I think it's largely fixed by using taproot with
multisignatures and threshold signatures.  As long as participants
aren't reusing the same keys in different contexts, it shouldn't be
possible for a third party who doesn't know all involved pubkeys to
determine that any particular aggregated pubkey contained material from
a certain base pubkey.

I would suggest that it's probably more beneficial for wallet authors to
work on implementing support for taproot and MuSig or MuSig2 than
support for this scheme, although maybe I'm misunderstanding this
scheme's motivation.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210724/8873de50/attachment.sig>

From dave at dtrt.org  Sun Jul 25 05:38:03 2021
From: dave at dtrt.org (David A. Harding)
Date: Sat, 24 Jul 2021 19:38:03 -1000
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
Message-ID: <20210725053803.fnmd6etv3f7x3u3p@ganymede>

On Tue, Jul 20, 2021 at 10:56:10PM -0700, Billy Tetrud via bitcoin-dev wrote:
> This involves [...] constraining the amount of the fee that output is
> allowed to contribute to.  [...] fee is specified relative to recent
> median fee rates - details in the proposal).

Here are the relevant details:

> The medianFeeRate is defined as the median fee rate per vbyte for the
> most recent windowLength blocks. The maxFeeContribution is defined as
> medianFeeRate * 2^feeFactor of the fee. Note that this is a limitation
> on the fee, not on the fee-rate. If feeFactor is -1,
> maxFeeContribution is 0.

First, I don't think we want full nodes to have to store the feerate for
every transaction in a 3,000 block window (~2.5 million txes, assuming
all segwit).  I'm sure you could tweak this proposal to require a much
smaller dataset.

Second, I think this requires careful consideration of how it might
affect the incentives for miners.  Miners can include many small high-fee
pay-to-self transactions in their blocks to raise the median feerate,
but this puts them at increased risk of fee sniping from other miners,
which may incentivize fee-raisers to centralize their mining, which is
ultimately bad.  I'm not sure that's a huge concern with this proposal,
but I think it and other incentive problems require consideration.

Finally, I think this fee mechanism is redundant.  For any case where
this opcode will be used, you'll want to have two things:

    1. A mutual spend clause (e.g. a multisignature taproot keypath
       spend) where all parties agree on a spend of the output and so
       can set an appropriate feerate at that time.  You want this
       because it'll be the most efficient way to spend.

    2. A fee override that allows paying additional fees beyond what
       OP_CONSTRAINDESTINATION allows, either through attaching an
       additional input or through CPFP.  You want this because you
       will know more about feerate conditions at spend time than you
       did when you created the receiving script.

If you have the ability to choose feerates through the above mechanisms,
you don't need a constrained feerate mechanism that might be
manipulable by miners.

(I haven't looked closely at the rest of your proposal; the above just
caught my attention.)

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210724/e5c1bfe3/attachment.sig>

From billy.tetrud at gmail.com  Sun Jul 25 19:49:38 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 25 Jul 2021 12:49:38 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <20210725053803.fnmd6etv3f7x3u3p@ganymede>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
Message-ID: <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>

Thanks for taking a look at the proposal David. I appreciate it.

> I don't think we want full nodes to have to store the feerate for every
transaction in a 3,000 block window

That's a good point. It would probably be just as good to find the median
fee-rate for each block and store that, then calculate the average of those
stored per-block median numbers. Do you think that would be sufficiently
cheap to store?

> Miners can include many small high-fee pay-to-self transactions in their
blocks to raise the median feerate

Definitely a reasonable thing to consider. One point I want to make about
that tho is that the opcode only limits how much of a particular output can
be put towards the transaction fee - for the vast majority of transactions
using this opcode, a lower fee would be used and the limit would be
irrelevant (and therefore raising the median fee rate would not affect
those transactions). The point of limiting the fee is to limit an
attacker's ability to grief a victim by sending all their funds as
transaction fee. So the only situations where miners would gain something
from raising the fee rate is for griefing situations, which should be so
rare as to be completely insignificant to miners. If griefing is not rare,
something else is pretty broken.

> I think this fee mechanism is redundant

See above, but to break down that situation a bit further, these are the
two situations I can think of:

   1. The opcode limits user/group A to send the output to user/group B
   2. The opcode limits user A to send from one address they own to another
   address they own.

In case 1, user/group A could be the attacker that attempts to direct as
much of the outputs as possible towards the fee (instead of the agreed upon
recipient user/group B). In case 2, the attacker would be someone that
steals a key from the user (eg in the case the attacker gets access to 1
key of the wallet vault keys) and attempts to grief them by making a
transaction with the highest possible fee. In both these scenarios, the fee
limit helps limit the amount of damage these attackers could do to their
victim. Without a fee limit, these attack vectors could spend up to the
full output amount as fee, which could be very damaging.

> A mutual spend clause

Have you considered the use case of wallet vaults? I designed this opcode
primarily with wallet vaults in mind. In such a case there is a "mutual
spend clause" of a kind - but all the keys may be owned by a single
individual. One of the keys would be kept close at hand, and other keys
would be kept in more secure and more difficult-to-access places (like a
safe in a remote location). While the key-spend-path would be cheapest on
chain, traveling to get the key itself might often be more expensive than
using the script spend-path (because it takes time and effort to travel to
those locations and access the keys). It might be informative to take a
look at these wallet vault scripts
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
that
could use this opcode or the larger vision
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/README.md>
I have for wallet vaults (which involves 2 other new opcodes). There are
certainly also multi-user multisig use cases for OP_CD that have similar
properties to this single-user use case.

> A fee override that allows paying additional fees .. through attaching an
additional input or through CPFP

I definitely agree those are desirable mechanisms. To reiterate what I said
above, the fee limitation is there to limit griefing attack vectors that
spend an unreasonable amount of a particular output towards the fee.
Spending *other* outputs (via either of those mechanisms) towards a
transaction's fee is perfectly acceptable and doesn't undermine the purpose
of the fee limitation.

At its core, the limitation is there because the miner is another
destination that the output's funds can be sent to, and while it wouldn't
be wise to prevent an output from being spent as fee at all (because then
the output is unspendable on its own, or with any other similarly
constrained outputs), if OP_CD allowed spending the entire output as a fee
then it wouldn't be successful in constraining the destination to the
listed addresses.

Do you see my points here, or do you still think the limitation is
redundant?

Thanks,
BT




On Sat, Jul 24, 2021 at 10:39 PM David A. Harding via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Jul 20, 2021 at 10:56:10PM -0700, Billy Tetrud via bitcoin-dev
> wrote:
> > This involves [...] constraining the amount of the fee that output is
> > allowed to contribute to.  [...] fee is specified relative to recent
> > median fee rates - details in the proposal).
>
> Here are the relevant details:
>
> > The medianFeeRate is defined as the median fee rate per vbyte for the
> > most recent windowLength blocks. The maxFeeContribution is defined as
> > medianFeeRate * 2^feeFactor of the fee. Note that this is a limitation
> > on the fee, not on the fee-rate. If feeFactor is -1,
> > maxFeeContribution is 0.
>
> First, I don't think we want full nodes to have to store the feerate for
> every transaction in a 3,000 block window (~2.5 million txes, assuming
> all segwit).  I'm sure you could tweak this proposal to require a much
> smaller dataset.
>
> Second, I think this requires careful consideration of how it might
> affect the incentives for miners.  Miners can include many small high-fee
> pay-to-self transactions in their blocks to raise the median feerate,
> but this puts them at increased risk of fee sniping from other miners,
> which may incentivize fee-raisers to centralize their mining, which is
> ultimately bad.  I'm not sure that's a huge concern with this proposal,
> but I think it and other incentive problems require consideration.
>
> Finally, I think this fee mechanism is redundant.  For any case where
> this opcode will be used, you'll want to have two things:
>
>     1. A mutual spend clause (e.g. a multisignature taproot keypath
>        spend) where all parties agree on a spend of the output and so
>        can set an appropriate feerate at that time.  You want this
>        because it'll be the most efficient way to spend.
>
>     2. A fee override that allows paying additional fees beyond what
>        OP_CONSTRAINDESTINATION allows, either through attaching an
>        additional input or through CPFP.  You want this because you
>        will know more about feerate conditions at spend time than you
>        did when you created the receiving script.
>
> If you have the ability to choose feerates through the above mechanisms,
> you don't need a constrained feerate mechanism that might be
> manipulable by miners.
>
> (I haven't looked closely at the rest of your proposal; the above just
> caught my attention.)
>
> -Dave
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210725/2257a16a/attachment.html>

From dave at dtrt.org  Mon Jul 26 00:05:53 2021
From: dave at dtrt.org (David A. Harding)
Date: Sun, 25 Jul 2021 14:05:53 -1000
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
Message-ID: <20210726000553.tetqypkqj34lcztt@ganymede>

On Sun, Jul 25, 2021 at 12:49:38PM -0700, Billy Tetrud wrote:
> find the median fee-rate for each block and store that, then calculate
> the average of those stored per-block median numbers. 

One datapoint per block seems fine to me and it works much nicer with
pruned nodes.

> So the only situations where miners would gain something
> from raising the fee rate is for griefing situations, which should be so
> rare as to be completely insignificant to miners. 

I don't believe the problem scope can be reduced this way.  Although we
we often look at miners as separate from users, it's important to
remember that every miner is also a user of Bitcoin and ever user of
Bitcoin may also someday be a miner.  Users may also employ miners
directly via out-of-band payments.

In your usecase of vaults, we can imagine Bob is attempting to store
100,000 BTC.  He designs his vault to allow spending on fees up to 10x
the 3,000 block median fee.  Mallory steals Bob's encumbered spending
key.  Mallory could immediately go to a miner and offer them a 50/50
split on the 10x fees over the median (~10,000 sat?), or Mallory could
take a bit more time and work with a cartel of miners to raise the
median over a period of three weeks (3k blocks) to 10,000
BTC/transaction, allowing them to take all of Bob's coins in fees.

> if OP_CD allowed spending the entire output as a fee then it wouldn't
> be successful in constraining the destination to the listed addresses.

The alternative is to never allow OP_CD to spend any of the UTXOs it
encumbers to fees, requiring all fees be paid via another mechanism.
Since satisfactory designs are going to provide those other mechanisms
anyway, it seems to me that there's no need for OP_CD to manage fees.
That said, I don't have a real strong opinion here.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210725/b442f887/attachment.sig>

From billy.tetrud at gmail.com  Mon Jul 26 20:18:35 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 26 Jul 2021 13:18:35 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <SN7PR18MB3981DC1CD23B90367045995FD2E89@SN7PR18MB3981.namprd18.prod.outlook.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <20210726000553.tetqypkqj34lcztt@ganymede>
 <SN7PR18MB3981DC1CD23B90367045995FD2E89@SN7PR18MB3981.namprd18.prod.outlook.com>
Message-ID: <CAGpPWDbW8y+ZMBqog72A0H9C3azZ+9sjnRZBvnCKG3NtaHSpxA@mail.gmail.com>

>  it's important to remember that every miner is also a user of Bitcoin
and ever user of Bitcoin may also someday be a miner

That's certainly true. One good quantification for how much of a problem
this could be is to calculate the cost of the attack vs the damage done in
the attack. So let me try to estimate that:

Miners could collectively shift the fee rate up by sending payments to
themselves, like you said. However, each one represents an opportunity cost
of a low-value transaction. Given a bell curve distribution of transaction
fee-rates, filling 15% of each block with these self-pay transactions could
raise the median fee rate by about 1/4 of a standard deviation, or
something probably around a 5% increase in median fee rate. This would lose
miners approximately 5% of the fees for the blocks they did this for. So in
order to do 1-to-1 damage (which would have them break even on the attack),
there would have to be enough of these transactions to fill up maybe 1% of
3000 blocks (if we assume these transactions will generally have 10 times
the fee-rate of the displaced low-value transactions). That would be on the
order of hundreds of thousands of transactions. A shorter sample
window would be easier to abuse this way, but even still likely at least
hundreds of transactions would be needed to make up the difference.

Manipulating fees this way has diminishing returns, meaning that filling a
smaller percent of a block with high-fee self-payment transactions would
lead to a greater increase in the median fee rate per amount of fees lost.

Something interesting about this attack is that a successful attack would
make the next attack easier, because mining these transactions from stolen
keys would also help raise the median fee-rate a bit (tho only a fraction
of the self-pay transactions that would still be necessary for the next
round of attacks).

And the above is a situation with 100% dishonest miners. With fewer
dishonest miners, say 25%, the attack would have a much lower ROI.

For the wallet vault use case, this is still a security improvement over a
normal wallet, since in a normal wallet, a stolen key means all your funds
can be stolen, but in an OP_CD wallet vault the attackers are still limited
in how much can be stolen via the fee, stealing via the fee requires paying
miners a cut to receive back some of the fee, and stealing extra  (via
raising the median fee rate) has a real cost placed on the miners.

For multi-party scenarios, I think the fee limit might be slightly less
effective. Eg in contracts where some money is promised to be sent to
another person's address (e.g. congestion controlled payments), if a miner
controls the sending address that miner can simply send the maximum fee to
gain more money directly. The limit is still partially effective, but its
definitely worth noting that malicious miners can abuse the fee limit
mechanism. I would think manipulating the median fee rate is just as
difficult in this scenario tho.

> pay-to-self transactions .. puts them at increased risk of fee sniping
from other miners, which may incentivize fee-raisers to centralize their
mining

This is an interesting point I forgot to respond to from your first email.
I think even without the threat of fee-sniping, fee raisers would want to
cartelize because coordinating the timing of attacks would reduce their
collective costs. Tho fee-sniping would increase this pressure, I agree. It
seems like cartels like this would have to get near the range of being able
to 51% attack to really be effective tho.

> The alternative is to never allow OP_CD to spend any of the UTXOs it
encumbers to fees

I agree that functionally this would work ok. However, both other
mechanisms (gathering keys for a multisig spend or CPFP / adding other
inputs) are likely to often be more expensive than letting the UTXO
contribute to the fee directly. Also, it would complicate usability of
these outputs, sometimes even making them unspendable by the user directly
(in the case they don't have access to external outputs to contribute to
the fee).

In any case, I've updated my proposal with some of the things we've
discussed. Thanks!

@Randy What are you agreeing with?

On Mon, Jul 26, 2021 at 5:59 AM Randy Fox <mrkingfoxx at hotmail.com> wrote:

> Agree.
>
>
> Sent from Yahoo Mail for iPhone
> <https://overview.mail.yahoo.com/?.src=iOS>
>
> On Sunday, July 25, 2021, 7:07 PM, David A. Harding via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> On Sun, Jul 25, 2021 at 12:49:38PM -0700, Billy Tetrud wrote:
> > find the median fee-rate for each block and store that, then calculate
> > the average of those stored per-block median numbers.
>
> One datapoint per block seems fine to me and it works much nicer with
> pruned nodes.
>
> > So the only situations where miners would gain something
> > from raising the fee rate is for griefing situations, which should be so
> > rare as to be completely insignificant to miners.
>
> I don't believe the problem scope can be reduced this way.  Although we
> we often look at miners as separate from users, it's important to
> remember that every miner is also a user of Bitcoin and ever user of
> Bitcoin may also someday be a miner.  Users may also employ miners
> directly via out-of-band payments.
>
> In your usecase of vaults, we can imagine Bob is attempting to store
> 100,000 BTC.  He designs his vault to allow spending on fees up to 10x
> the 3,000 block median fee.  Mallory steals Bob's encumbered spending
> key.  Mallory could immediately go to a miner and offer them a 50/50
> split on the 10x fees over the median (~10,000 sat?), or Mallory could
> take a bit more time and work with a cartel of miners to raise the
> median over a period of three weeks (3k blocks) to 10,000
> BTC/transaction, allowing them to take all of Bob's coins in fees.
>
> > if OP_CD allowed spending the entire output as a fee then it wouldn't
> > be successful in constraining the destination to the listed addresses.
>
> The alternative is to never allow OP_CD to spend any of the UTXOs it
> encumbers to fees, requiring all fees be paid via another mechanism.
> Since satisfactory designs are going to provide those other mechanisms
> anyway, it seems to me that there's no need for OP_CD to manage fees.
> That said, I don't have a real strong opinion here.
>
>
> -Dave
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210726/64ebe96d/attachment.html>

From macwhyte at gmail.com  Mon Jul 26 21:08:09 2021
From: macwhyte at gmail.com (James MacWhyte)
Date: Mon, 26 Jul 2021 22:08:09 +0100
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
Message-ID: <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>

Hi Billy!

See above, but to break down that situation a bit further, these are the
> two situations I can think of:
>
>    1. The opcode limits user/group A to send the output to user/group B
>    2. The opcode limits user A to send from one address they own to
>    another address they own.
>
> I'm trying to think of a good use case for this type of opcode. In these
examples, an attacker who compromises the key for user A can't steal the
money because it can only be sent to user B. So if the attacker wants to
steal the funds, they would need to compromise the keys of both user A and
user B.

But how is that any better than a 2-of-2 multisig? Isn't the end result
exactly the same?

James
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210726/688c8adb/attachment.html>

From billy.tetrud at gmail.com  Tue Jul 27 00:41:29 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 26 Jul 2021 17:41:29 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
Message-ID: <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>

Hey James,

In the examples you mentioned, what I was exploring was a mechanism of
attack by which the attacker could steal user A's key and use that key to
send a transaction with the maximum possible fee. User B would still
receive some funds (probably), but if the fee could be large, the attacker
would either do a lot of damage to user B (griefing) or could make an
agreement with a miner to give back some of the large fee (theft).

But as for use cases, the proposal mentions a number of use cases
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md#motivation>
and
most overlap with the use cases of op_ctv <https://utxos.org/uses/> (Jeremy
Rubin's website for op_ctv has a lot of good details, most of which are
also relevant to op_cd). The use case I'm most interested in is wallet
vaults. This opcode can be used to create a wallet vault where the user
only needs to use, for example, 1 key to spend funds, but the attacker must
steal 2 or more keys to spend funds. The benefits of a 2 key wallet vault
like this vs a normal 2-of-2 multisig wallet are that not only does an
attacker have to steal both keys (same level of security), but also the
user can lose one key and still recover their funds (better redundancy) and
also that generally the user doesn't need to access their second key - so
that can remain in a much more secure location (which would also probably
make that key harder to steal). The only time the second key only comes
into play if one key is stolen and the attacker attempts to send a
transaction. At that point, the user would go find and use his second key
(along with the first) to send a revoke transaction to prevent the attacker
from stealing their funds. This is somewhat akin to a lightning watchtower
scenario, where your wallet would watch the chain and alert you about an
unexpected transaction, at which point you'd manually do a revoke (vs a
watchtower's automated response). You might be interested in taking a look
at this wallet vault design
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
that uses OP_CD or even my full vision
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults> of the wallet
vault I want to be able to create.

With a covenant opcode like this, its possible to create very usable and
accessible but highly secure wallets that can allow normal people to hold
self custody of their keys without fear of loss or theft and without the
hassle of a lot of safe deposit boxes (or other secure seed storage
locations).

Cheers,
BT





On Mon, Jul 26, 2021 at 2:08 PM James MacWhyte <macwhyte at gmail.com> wrote:

> Hi Billy!
>
> See above, but to break down that situation a bit further, these are the
>> two situations I can think of:
>>
>>    1. The opcode limits user/group A to send the output to user/group B
>>    2. The opcode limits user A to send from one address they own to
>>    another address they own.
>>
>> I'm trying to think of a good use case for this type of opcode. In these
> examples, an attacker who compromises the key for user A can't steal the
> money because it can only be sent to user B. So if the attacker wants to
> steal the funds, they would need to compromise the keys of both user A and
> user B.
>
> But how is that any better than a 2-of-2 multisig? Isn't the end result
> exactly the same?
>
> James
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210726/9bec6c43/attachment-0001.html>

From zachgrw at gmail.com  Tue Jul 27 11:18:11 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Tue, 27 Jul 2021 13:18:11 +0200
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
Message-ID: <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>

Hi Billy,

On the topic of wallet vaults, are there any plans to implement a way to
limit the maximum amount to be sent from an address?

An example of such limit might be: the maximum amount allowed to send is
max(s, p) where s is a number of satoshi and p a percentage of the total
available (sendable) amount.

A minimum value may be imposed on the percentage to ensure that the address
can be emptied within a reasonable number of transactions. The second
parameter s allows a minimum permitted amount. (This is necessary because
with only the percentage parameter the minimum permitted amount converges
to zero, making it impossible to empty the address).

There may be other ways too. In my view, such kind of restriction would be
extremely effective in thwarting the most damaging type of theft being the
one where all funds are swept in a single transaction.

Zac


On Tue, 27 Jul 2021 at 03:26, Billy Tetrud via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hey James,
>
> In the examples you mentioned, what I was exploring was a mechanism of
> attack by which the attacker could steal user A's key and use that key to
> send a transaction with the maximum possible fee. User B would still
> receive some funds (probably), but if the fee could be large, the attacker
> would either do a lot of damage to user B (griefing) or could make an
> agreement with a miner to give back some of the large fee (theft).
>
> But as for use cases, the proposal mentions a number of use cases
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md#motivation> and
> most overlap with the use cases of op_ctv <https://utxos.org/uses/> (Jeremy
> Rubin's website for op_ctv has a lot of good details, most of which are
> also relevant to op_cd). The use case I'm most interested in is wallet
> vaults. This opcode can be used to create a wallet vault where the user
> only needs to use, for example, 1 key to spend funds, but the attacker must
> steal 2 or more keys to spend funds. The benefits of a 2 key wallet vault
> like this vs a normal 2-of-2 multisig wallet are that not only does an
> attacker have to steal both keys (same level of security), but also the
> user can lose one key and still recover their funds (better redundancy) and
> also that generally the user doesn't need to access their second key - so
> that can remain in a much more secure location (which would also probably
> make that key harder to steal). The only time the second key only comes
> into play if one key is stolen and the attacker attempts to send a
> transaction. At that point, the user would go find and use his second key
> (along with the first) to send a revoke transaction to prevent the attacker
> from stealing their funds. This is somewhat akin to a lightning watchtower
> scenario, where your wallet would watch the chain and alert you about an
> unexpected transaction, at which point you'd manually do a revoke (vs a
> watchtower's automated response). You might be interested in taking a look
> at this wallet vault design
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
> that uses OP_CD or even my full vision
> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults> of the
> wallet vault I want to be able to create.
>
> With a covenant opcode like this, its possible to create very usable and
> accessible but highly secure wallets that can allow normal people to hold
> self custody of their keys without fear of loss or theft and without the
> hassle of a lot of safe deposit boxes (or other secure seed storage
> locations).
>
> Cheers,
> BT
>
>
>
>
>
> On Mon, Jul 26, 2021 at 2:08 PM James MacWhyte <macwhyte at gmail.com> wrote:
>
>> Hi Billy!
>>
>> See above, but to break down that situation a bit further, these are the
>>> two situations I can think of:
>>>
>>>    1. The opcode limits user/group A to send the output to user/group B
>>>    2. The opcode limits user A to send from one address they own to
>>>    another address they own.
>>>
>>> I'm trying to think of a good use case for this type of opcode. In these
>> examples, an attacker who compromises the key for user A can't steal the
>> money because it can only be sent to user B. So if the attacker wants to
>> steal the funds, they would need to compromise the keys of both user A and
>> user B.
>>
>> But how is that any better than a 2-of-2 multisig? Isn't the end result
>> exactly the same?
>>
>> James
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210727/c75c3771/attachment.html>

From billy.tetrud at gmail.com  Tue Jul 27 17:21:11 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 27 Jul 2021 10:21:11 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
Message-ID: <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>

Hi Zac,

I haven't heard of any proposal for limiting the amount that can be sent
from an address. I assume you mean limiting the amount that can be sent in
a period of time - eg something that would encode that for address A, only
X bitcoin can be sent from the address in a given day/week/etc, is that
right? That would actually be a somewhat difficult thing to do in the
output-based system Bitcoin uses, and would be easier in an account based
system like Ethereum. The problem is that each output is separate, and
there's no concept in bitcoin of encumbering outputs together.

What you could do is design a system where coins would be combined in a
single output, and then encumber that output with a script that allows a
limited amount of coin be sent to a destination address and requires all
other bitcoins be returned to sender in a new change output that is also
timelocked. That way, the new change output can't be used again until the
timelock expires (eg a week). However, to ensure this wallet works
properly, any deposit into the wallet would have to also spend the wallet's
single output, so as to create a new single output at that address. So 3rd
parties wouldn't be able to arbitrarily send money in (or rather, they
could, but each output would have its own separate spending limit).

> such kind of restriction would be extremely effective in thwarting the
most damaging type of theft being the one where all funds are swept in a
single transaction

It would. However a normal wallet vault basically already has this property
- a thief can't simply sweep funds instantly, but instead the victim will
see an initiated transaction and will be able to reverse it within a delay
time-window. I don't think adding a spending limit would add meaningful
security to a delayed-send wallet vault like that. But it could be used to
increase the security of a wallet vault that can be instantly spent from -
ie if the attacker successfully steals funds, then the victim has time to
go gather their additional keys and move the remaining (unstolen) funds
into a new wallet.

OP_CD could potentially be augmented to allow specifying limit amounts for
each destination, which would allow you to create a wallet like this. It
would be a bit of an awkward wallet to use tho, since you couldn't receive
directly into it from a 3rd party and you also couldn't keep separate
outputs (which is bad for privacy).

An alternate way of doing this that you don't need any new opcodes for
would be to have a 3rd party service that signs multisig transactions from
a wallet only up to a limit. The end-user could have additional keys such
that the 3rd party can't prevent them from accessing that (if they turn
uncooperative), and the 3rd party would only have a single key so they
can't steal funds, but the user would sign a transaction with one key, and
the 3rd party with another as long as the spending limit hasn't been
reached. This wouldn't have much counterparty risk, but would be a less
awkward wallet than what I described above - meaning anyone could send
funds into the wallet without defeating the spending limit, and privacy
could be kept intact (minus the fact that the 3rd party would know what
your outputs are).

BT

On Tue, Jul 27, 2021 at 4:18 AM Zac Greenwood <zachgrw at gmail.com> wrote:

> Hi Billy,
>
> On the topic of wallet vaults, are there any plans to implement a way to
> limit the maximum amount to be sent from an address?
>
> An example of such limit might be: the maximum amount allowed to send is
> max(s, p) where s is a number of satoshi and p a percentage of the total
> available (sendable) amount.
>
> A minimum value may be imposed on the percentage to ensure that the
> address can be emptied within a reasonable number of transactions. The
> second parameter s allows a minimum permitted amount. (This is necessary
> because with only the percentage parameter the minimum permitted amount
> converges to zero, making it impossible to empty the address).
>
> There may be other ways too. In my view, such kind of restriction would be
> extremely effective in thwarting the most damaging type of theft being the
> one where all funds are swept in a single transaction.
>
> Zac
>
>
> On Tue, 27 Jul 2021 at 03:26, Billy Tetrud via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hey James,
>>
>> In the examples you mentioned, what I was exploring was a mechanism of
>> attack by which the attacker could steal user A's key and use that key to
>> send a transaction with the maximum possible fee. User B would still
>> receive some funds (probably), but if the fee could be large, the attacker
>> would either do a lot of damage to user B (griefing) or could make an
>> agreement with a miner to give back some of the large fee (theft).
>>
>> But as for use cases, the proposal mentions a number of use cases
>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md#motivation> and
>> most overlap with the use cases of op_ctv <https://utxos.org/uses/> (Jeremy
>> Rubin's website for op_ctv has a lot of good details, most of which are
>> also relevant to op_cd). The use case I'm most interested in is wallet
>> vaults. This opcode can be used to create a wallet vault where the user
>> only needs to use, for example, 1 key to spend funds, but the attacker must
>> steal 2 or more keys to spend funds. The benefits of a 2 key wallet vault
>> like this vs a normal 2-of-2 multisig wallet are that not only does an
>> attacker have to steal both keys (same level of security), but also the
>> user can lose one key and still recover their funds (better redundancy) and
>> also that generally the user doesn't need to access their second key - so
>> that can remain in a much more secure location (which would also probably
>> make that key harder to steal). The only time the second key only comes
>> into play if one key is stolen and the attacker attempts to send a
>> transaction. At that point, the user would go find and use his second key
>> (along with the first) to send a revoke transaction to prevent the attacker
>> from stealing their funds. This is somewhat akin to a lightning watchtower
>> scenario, where your wallet would watch the chain and alert you about an
>> unexpected transaction, at which point you'd manually do a revoke (vs a
>> watchtower's automated response). You might be interested in taking a look
>> at this wallet vault design
>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
>> that uses OP_CD or even my full vision
>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults> of the
>> wallet vault I want to be able to create.
>>
>> With a covenant opcode like this, its possible to create very usable and
>> accessible but highly secure wallets that can allow normal people to hold
>> self custody of their keys without fear of loss or theft and without the
>> hassle of a lot of safe deposit boxes (or other secure seed storage
>> locations).
>>
>> Cheers,
>> BT
>>
>>
>>
>>
>>
>> On Mon, Jul 26, 2021 at 2:08 PM James MacWhyte <macwhyte at gmail.com>
>> wrote:
>>
>>> Hi Billy!
>>>
>>> See above, but to break down that situation a bit further, these are the
>>>> two situations I can think of:
>>>>
>>>>    1. The opcode limits user/group A to send the output to user/group B
>>>>    2. The opcode limits user A to send from one address they own to
>>>>    another address they own.
>>>>
>>>> I'm trying to think of a good use case for this type of opcode. In
>>> these examples, an attacker who compromises the key for user A can't steal
>>> the money because it can only be sent to user B. So if the attacker wants
>>> to steal the funds, they would need to compromise the keys of both user A
>>> and user B.
>>>
>>> But how is that any better than a 2-of-2 multisig? Isn't the end result
>>> exactly the same?
>>>
>>> James
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210727/098ffbde/attachment-0001.html>

From zachgrw at gmail.com  Wed Jul 28 04:57:33 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Wed, 28 Jul 2021 06:57:33 +0200
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
Message-ID: <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>

Hi Billy,

Thank you for your comprehensive reply. My purpose was to find out whether
a proposal to somehow limit the amount being sent from an address exists
and to further illustrate my thoughts by giving a concrete example of how
this might work functionally without getting to deep into the
technicalities.

As for your assumption: for an amount limit to have the desired effect, I
realize now that there must also exist some limit on the number of
transactions that will be allowed from the encumbered address.

Taking a step back, a typical use case would be a speculating user
intending to hodl bitcoin but who still wishes to be able to occasionally
transact minor amounts.

Ideally, such user should optionally still be able to bypass the rate limit
and spend the entire amount in a single transaction by signing with an
additional private key (multisig).

During the setup phase, a user sends all their to-be-rate-limited coin to a
single address. When spending from this rate limited address, any change
sent to the change address must be rate limited as well using identical
parameters. I believe that?s also what you?re suggesting.

I believe that a smart wallet should be able to set up and maintain
multiple rate-limited addresses in such a way that their aggregate
behaviour meets any rate-limiting parameters as desired by the user. This
ought to alleviate your privacy concerns because it means that the wallet
will be able to mix outputs.

The options for the to-be implemented rate-limiting parameters vary from
completely arbitrary to more restrictive.

Completely arbitrary parameters would allow users to set up a rate limit
that basically destroys their funds, for instance rate-limiting an address
to an amount of 1 satoshi per 100 blocks.

More restrictive rate limits would remove such footgun and may require that
only a combination of parameters are allowed such that all funds will be
spendable within a set number of blocks (for instance 210,000).

As for the rate-limiting parameters, in addition to a per-transaction
maximum of (minimum amount in satoshi or a percentage of the total amount
stored at the address), also the transaction frequency must be limited. I
would propose this to be expressed as a number of blocks before a next
transaction can be sent from the encumbered address(es).

I believe such user-enabled rate-limiting is superior to one that requires
a third party.

As an aside, I am not sure how a vault solution would be able to prevent an
attacker who is in possession of the vaults? private key from sabotaging
the user by replacing the user transaction with one having a higher fee
every time the user attempts to transact. I am probably missing something
here though.

Zac


On Tue, 27 Jul 2021 at 19:21, Billy Tetrud <billy.tetrud at gmail.com> wrote:

> Hi Zac,
>
> I haven't heard of any proposal for limiting the amount that can be sent
> from an address. I assume you mean limiting the amount that can be sent in
> a period of time - eg something that would encode that for address A, only
> X bitcoin can be sent from the address in a given day/week/etc, is that
> right? That would actually be a somewhat difficult thing to do in the
> output-based system Bitcoin uses, and would be easier in an account based
> system like Ethereum. The problem is that each output is separate, and
> there's no concept in bitcoin of encumbering outputs together.
>
> What you could do is design a system where coins would be combined in a
> single output, and then encumber that output with a script that allows a
> limited amount of coin be sent to a destination address and requires all
> other bitcoins be returned to sender in a new change output that is also
> timelocked. That way, the new change output can't be used again until the
> timelock expires (eg a week). However, to ensure this wallet works
> properly, any deposit into the wallet would have to also spend the wallet's
> single output, so as to create a new single output at that address. So 3rd
> parties wouldn't be able to arbitrarily send money in (or rather, they
> could, but each output would have its own separate spending limit).
>
> > such kind of restriction would be extremely effective in thwarting the
> most damaging type of theft being the one where all funds are swept in a
> single transaction
>
> It would. However a normal wallet vault basically already has this
> property - a thief can't simply sweep funds instantly, but instead the
> victim will see an initiated transaction and will be able to reverse it
> within a delay time-window. I don't think adding a spending limit would add
> meaningful security to a delayed-send wallet vault like that. But it could
> be used to increase the security of a wallet vault that can be instantly
> spent from - ie if the attacker successfully steals funds, then the victim
> has time to go gather their additional keys and move the remaining
> (unstolen) funds into a new wallet.
>
> OP_CD could potentially be augmented to allow specifying limit amounts for
> each destination, which would allow you to create a wallet like this. It
> would be a bit of an awkward wallet to use tho, since you couldn't receive
> directly into it from a 3rd party and you also couldn't keep separate
> outputs (which is bad for privacy).
>
> An alternate way of doing this that you don't need any new opcodes for
> would be to have a 3rd party service that signs multisig transactions from
> a wallet only up to a limit. The end-user could have additional keys such
> that the 3rd party can't prevent them from accessing that (if they turn
> uncooperative), and the 3rd party would only have a single key so they
> can't steal funds, but the user would sign a transaction with one key, and
> the 3rd party with another as long as the spending limit hasn't been
> reached. This wouldn't have much counterparty risk, but would be a less
> awkward wallet than what I described above - meaning anyone could send
> funds into the wallet without defeating the spending limit, and privacy
> could be kept intact (minus the fact that the 3rd party would know what
> your outputs are).
>
> BT
>
> On Tue, Jul 27, 2021 at 4:18 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>
>> Hi Billy,
>>
>> On the topic of wallet vaults, are there any plans to implement a way to
>> limit the maximum amount to be sent from an address?
>>
>> An example of such limit might be: the maximum amount allowed to send is
>> max(s, p) where s is a number of satoshi and p a percentage of the total
>> available (sendable) amount.
>>
>> A minimum value may be imposed on the percentage to ensure that the
>> address can be emptied within a reasonable number of transactions. The
>> second parameter s allows a minimum permitted amount. (This is necessary
>> because with only the percentage parameter the minimum permitted amount
>> converges to zero, making it impossible to empty the address).
>>
>> There may be other ways too. In my view, such kind of restriction would
>> be extremely effective in thwarting the most damaging type of theft being
>> the one where all funds are swept in a single transaction.
>>
>> Zac
>>
>>
>> On Tue, 27 Jul 2021 at 03:26, Billy Tetrud via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Hey James,
>>>
>>> In the examples you mentioned, what I was exploring was a mechanism of
>>> attack by which the attacker could steal user A's key and use that key to
>>> send a transaction with the maximum possible fee. User B would still
>>> receive some funds (probably), but if the fee could be large, the attacker
>>> would either do a lot of damage to user B (griefing) or could make an
>>> agreement with a miner to give back some of the large fee (theft).
>>>
>>> But as for use cases, the proposal mentions a number of use cases
>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md#motivation> and
>>> most overlap with the use cases of op_ctv <https://utxos.org/uses/> (Jeremy
>>> Rubin's website for op_ctv has a lot of good details, most of which are
>>> also relevant to op_cd). The use case I'm most interested in is wallet
>>> vaults. This opcode can be used to create a wallet vault where the user
>>> only needs to use, for example, 1 key to spend funds, but the attacker must
>>> steal 2 or more keys to spend funds. The benefits of a 2 key wallet vault
>>> like this vs a normal 2-of-2 multisig wallet are that not only does an
>>> attacker have to steal both keys (same level of security), but also the
>>> user can lose one key and still recover their funds (better redundancy) and
>>> also that generally the user doesn't need to access their second key - so
>>> that can remain in a much more secure location (which would also probably
>>> make that key harder to steal). The only time the second key only comes
>>> into play if one key is stolen and the attacker attempts to send a
>>> transaction. At that point, the user would go find and use his second key
>>> (along with the first) to send a revoke transaction to prevent the attacker
>>> from stealing their funds. This is somewhat akin to a lightning watchtower
>>> scenario, where your wallet would watch the chain and alert you about an
>>> unexpected transaction, at which point you'd manually do a revoke (vs a
>>> watchtower's automated response). You might be interested in taking a look
>>> at this wallet vault design
>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
>>> that uses OP_CD or even my full vision
>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults> of the
>>> wallet vault I want to be able to create.
>>>
>>> With a covenant opcode like this, its possible to create very usable and
>>> accessible but highly secure wallets that can allow normal people to hold
>>> self custody of their keys without fear of loss or theft and without the
>>> hassle of a lot of safe deposit boxes (or other secure seed storage
>>> locations).
>>>
>>> Cheers,
>>> BT
>>>
>>>
>>>
>>>
>>>
>>> On Mon, Jul 26, 2021 at 2:08 PM James MacWhyte <macwhyte at gmail.com>
>>> wrote:
>>>
>>>> Hi Billy!
>>>>
>>>> See above, but to break down that situation a bit further, these are
>>>>> the two situations I can think of:
>>>>>
>>>>>    1. The opcode limits user/group A to send the output to user/group
>>>>>    B
>>>>>    2. The opcode limits user A to send from one address they own to
>>>>>    another address they own.
>>>>>
>>>>> I'm trying to think of a good use case for this type of opcode. In
>>>> these examples, an attacker who compromises the key for user A can't steal
>>>> the money because it can only be sent to user B. So if the attacker wants
>>>> to steal the funds, they would need to compromise the keys of both user A
>>>> and user B.
>>>>
>>>> But how is that any better than a 2-of-2 multisig? Isn't the end result
>>>> exactly the same?
>>>>
>>>> James
>>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210728/9ad7f8bf/attachment-0001.html>

From billy.tetrud at gmail.com  Wed Jul 28 17:57:09 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Wed, 28 Jul 2021 10:57:09 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
Message-ID: <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>

Hi Zac,

> a smart wallet should be able to set up and maintain multiple
rate-limited addresses in such a way that their aggregate behaviour meets
any rate-limiting parameters as desired by the user

I think that would be possible if there was a way to say "within the last B
blocks, this output can only spend to addresses other than X,Y,Z an amount
less than C coins minus however much coins have been spent by those
addresses in the last B blocks". This would require that full nodes keep
around information about which addresses have been spent from recently, so
that information is accessible during script execution. This could be made
a bit less heavy by requiring countable transactions to run some particular
opcode (so only opted-in transactions would need to be stored).

> This ought to alleviate your privacy concerns because it means that the
wallet will be able to mix outputs.

The ability to mix outputs isn't a privacy issue. The ability to keep
outputs separate is the privacy issue. For rate-limiting to work, the
outputs must be associated with eachother so that rate limiting can take
them all into account. It seems to me that its fundamentally impossible to
do this while keeping outputs uncorrelated.

> such user-enabled rate-limiting is superior to one that requires a third
party.

Removing a 3rd party certainly has upsides. However, using a 3rd party
would be able to solve the privacy issue by keeping outputs uncorrelated
(in different addresses) to the outside world. Trade offs.

In any case, if you want to continue talking about rate-limiting
transactions, it might be a good idea to start a new thread for that, since
its a bit off topic for this one.

> how a vault solution would be able to prevent an attacker who is in
possession of the vaults? private key from sabotaging the user by replacing
the user transaction with one having a higher fee every time the user
attempts to transact

A wallet vault has multiple keys. If one key is stolen, the user can use
two keys to override the attacker's transaction. If two keys are stolen,
the user can use three keys. Etc. The attacker must have as many keys as
the user can use in order to successfully steal funds. This can happen in
one of these kinds of ways:

A. The attacker steals all keys.
B. The attacker steals half the keys and ensures that the victim doesn't
have access to those keys (eg the attacker steals the only copy of half the
keys).
C. The attacker steals any key and incapacitates the victim for the entire
cooldown period, so they can't use any of their keys.

In case C, it would be useful to have rate limiting actually.

On Tue, Jul 27, 2021 at 9:57 PM Zac Greenwood <zachgrw at gmail.com> wrote:

> Hi Billy,
>
> Thank you for your comprehensive reply. My purpose was to find out whether
> a proposal to somehow limit the amount being sent from an address exists
> and to further illustrate my thoughts by giving a concrete example of how
> this might work functionally without getting to deep into the
> technicalities.
>
> As for your assumption: for an amount limit to have the desired effect, I
> realize now that there must also exist some limit on the number of
> transactions that will be allowed from the encumbered address.
>
> Taking a step back, a typical use case would be a speculating user
> intending to hodl bitcoin but who still wishes to be able to occasionally
> transact minor amounts.
>
> Ideally, such user should optionally still be able to bypass the rate
> limit and spend the entire amount in a single transaction by signing with
> an additional private key (multisig).
>
> During the setup phase, a user sends all their to-be-rate-limited coin to
> a single address. When spending from this rate limited address, any change
> sent to the change address must be rate limited as well using identical
> parameters. I believe that?s also what you?re suggesting.
>
> I believe that a smart wallet should be able to set up and maintain
> multiple rate-limited addresses in such a way that their aggregate
> behaviour meets any rate-limiting parameters as desired by the user. This
> ought to alleviate your privacy concerns because it means that the wallet
> will be able to mix outputs.
>
> The options for the to-be implemented rate-limiting parameters vary from
> completely arbitrary to more restrictive.
>
> Completely arbitrary parameters would allow users to set up a rate limit
> that basically destroys their funds, for instance rate-limiting an address
> to an amount of 1 satoshi per 100 blocks.
>
> More restrictive rate limits would remove such footgun and may require
> that only a combination of parameters are allowed such that all funds will
> be spendable within a set number of blocks (for instance 210,000).
>
> As for the rate-limiting parameters, in addition to a per-transaction
> maximum of (minimum amount in satoshi or a percentage of the total amount
> stored at the address), also the transaction frequency must be limited. I
> would propose this to be expressed as a number of blocks before a next
> transaction can be sent from the encumbered address(es).
>
> I believe such user-enabled rate-limiting is superior to one that requires
> a third party.
>
> As an aside, I am not sure how a vault solution would be able to prevent
> an attacker who is in possession of the vaults? private key from sabotaging
> the user by replacing the user transaction with one having a higher fee
> every time the user attempts to transact. I am probably missing something
> here though.
>
> Zac
>
>
> On Tue, 27 Jul 2021 at 19:21, Billy Tetrud <billy.tetrud at gmail.com> wrote:
>
>> Hi Zac,
>>
>> I haven't heard of any proposal for limiting the amount that can be sent
>> from an address. I assume you mean limiting the amount that can be sent in
>> a period of time - eg something that would encode that for address A, only
>> X bitcoin can be sent from the address in a given day/week/etc, is that
>> right? That would actually be a somewhat difficult thing to do in the
>> output-based system Bitcoin uses, and would be easier in an account based
>> system like Ethereum. The problem is that each output is separate, and
>> there's no concept in bitcoin of encumbering outputs together.
>>
>> What you could do is design a system where coins would be combined in a
>> single output, and then encumber that output with a script that allows a
>> limited amount of coin be sent to a destination address and requires all
>> other bitcoins be returned to sender in a new change output that is also
>> timelocked. That way, the new change output can't be used again until the
>> timelock expires (eg a week). However, to ensure this wallet works
>> properly, any deposit into the wallet would have to also spend the wallet's
>> single output, so as to create a new single output at that address. So 3rd
>> parties wouldn't be able to arbitrarily send money in (or rather, they
>> could, but each output would have its own separate spending limit).
>>
>> > such kind of restriction would be extremely effective in thwarting the
>> most damaging type of theft being the one where all funds are swept in a
>> single transaction
>>
>> It would. However a normal wallet vault basically already has this
>> property - a thief can't simply sweep funds instantly, but instead the
>> victim will see an initiated transaction and will be able to reverse it
>> within a delay time-window. I don't think adding a spending limit would add
>> meaningful security to a delayed-send wallet vault like that. But it could
>> be used to increase the security of a wallet vault that can be instantly
>> spent from - ie if the attacker successfully steals funds, then the victim
>> has time to go gather their additional keys and move the remaining
>> (unstolen) funds into a new wallet.
>>
>> OP_CD could potentially be augmented to allow specifying limit amounts
>> for each destination, which would allow you to create a wallet like this.
>> It would be a bit of an awkward wallet to use tho, since you couldn't
>> receive directly into it from a 3rd party and you also couldn't keep
>> separate outputs (which is bad for privacy).
>>
>> An alternate way of doing this that you don't need any new opcodes for
>> would be to have a 3rd party service that signs multisig transactions from
>> a wallet only up to a limit. The end-user could have additional keys such
>> that the 3rd party can't prevent them from accessing that (if they turn
>> uncooperative), and the 3rd party would only have a single key so they
>> can't steal funds, but the user would sign a transaction with one key, and
>> the 3rd party with another as long as the spending limit hasn't been
>> reached. This wouldn't have much counterparty risk, but would be a less
>> awkward wallet than what I described above - meaning anyone could send
>> funds into the wallet without defeating the spending limit, and privacy
>> could be kept intact (minus the fact that the 3rd party would know what
>> your outputs are).
>>
>> BT
>>
>> On Tue, Jul 27, 2021 at 4:18 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>
>>> Hi Billy,
>>>
>>> On the topic of wallet vaults, are there any plans to implement a way to
>>> limit the maximum amount to be sent from an address?
>>>
>>> An example of such limit might be: the maximum amount allowed to send is
>>> max(s, p) where s is a number of satoshi and p a percentage of the total
>>> available (sendable) amount.
>>>
>>> A minimum value may be imposed on the percentage to ensure that the
>>> address can be emptied within a reasonable number of transactions. The
>>> second parameter s allows a minimum permitted amount. (This is necessary
>>> because with only the percentage parameter the minimum permitted amount
>>> converges to zero, making it impossible to empty the address).
>>>
>>> There may be other ways too. In my view, such kind of restriction would
>>> be extremely effective in thwarting the most damaging type of theft being
>>> the one where all funds are swept in a single transaction.
>>>
>>> Zac
>>>
>>>
>>> On Tue, 27 Jul 2021 at 03:26, Billy Tetrud via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Hey James,
>>>>
>>>> In the examples you mentioned, what I was exploring was a mechanism of
>>>> attack by which the attacker could steal user A's key and use that key to
>>>> send a transaction with the maximum possible fee. User B would still
>>>> receive some funds (probably), but if the fee could be large, the attacker
>>>> would either do a lot of damage to user B (griefing) or could make an
>>>> agreement with a miner to give back some of the large fee (theft).
>>>>
>>>> But as for use cases, the proposal mentions a number of use cases
>>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md#motivation> and
>>>> most overlap with the use cases of op_ctv <https://utxos.org/uses/> (Jeremy
>>>> Rubin's website for op_ctv has a lot of good details, most of which are
>>>> also relevant to op_cd). The use case I'm most interested in is wallet
>>>> vaults. This opcode can be used to create a wallet vault where the user
>>>> only needs to use, for example, 1 key to spend funds, but the attacker must
>>>> steal 2 or more keys to spend funds. The benefits of a 2 key wallet vault
>>>> like this vs a normal 2-of-2 multisig wallet are that not only does an
>>>> attacker have to steal both keys (same level of security), but also the
>>>> user can lose one key and still recover their funds (better redundancy) and
>>>> also that generally the user doesn't need to access their second key - so
>>>> that can remain in a much more secure location (which would also probably
>>>> make that key harder to steal). The only time the second key only comes
>>>> into play if one key is stolen and the attacker attempts to send a
>>>> transaction. At that point, the user would go find and use his second key
>>>> (along with the first) to send a revoke transaction to prevent the attacker
>>>> from stealing their funds. This is somewhat akin to a lightning watchtower
>>>> scenario, where your wallet would watch the chain and alert you about an
>>>> unexpected transaction, at which point you'd manually do a revoke (vs a
>>>> watchtower's automated response). You might be interested in taking a look
>>>> at this wallet vault design
>>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/op_cdWalletVault1.md>
>>>> that uses OP_CD or even my full vision
>>>> <https://github.com/fresheneesz/bip-efficient-bitcoin-vaults> of the
>>>> wallet vault I want to be able to create.
>>>>
>>>> With a covenant opcode like this, its possible to create very usable
>>>> and accessible but highly secure wallets that can allow normal people to
>>>> hold self custody of their keys without fear of loss or theft and without
>>>> the hassle of a lot of safe deposit boxes (or other secure seed storage
>>>> locations).
>>>>
>>>> Cheers,
>>>> BT
>>>>
>>>>
>>>>
>>>>
>>>>
>>>> On Mon, Jul 26, 2021 at 2:08 PM James MacWhyte <macwhyte at gmail.com>
>>>> wrote:
>>>>
>>>>> Hi Billy!
>>>>>
>>>>> See above, but to break down that situation a bit further, these are
>>>>>> the two situations I can think of:
>>>>>>
>>>>>>    1. The opcode limits user/group A to send the output to
>>>>>>    user/group B
>>>>>>    2. The opcode limits user A to send from one address they own to
>>>>>>    another address they own.
>>>>>>
>>>>>> I'm trying to think of a good use case for this type of opcode. In
>>>>> these examples, an attacker who compromises the key for user A can't steal
>>>>> the money because it can only be sent to user B. So if the attacker wants
>>>>> to steal the funds, they would need to compromise the keys of both user A
>>>>> and user B.
>>>>>
>>>>> But how is that any better than a 2-of-2 multisig? Isn't the end
>>>>> result exactly the same?
>>>>>
>>>>> James
>>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210728/d57202f0/attachment-0001.html>

From jlrubin at mit.edu  Wed Jul 28 22:30:19 2021
From: jlrubin at mit.edu (Jeremy)
Date: Wed, 28 Jul 2021 15:30:19 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
Message-ID: <CAD5xwhhAcup2pKyazopqz7aYAWYmXCJsq1OPni94+OJ8ErUXjQ@mail.gmail.com>

High level feedback:

you should spec out the opcodes as separate pieces of functionality as it
sounds like OP_CD is really 3 or 4 opcodes in one (e.g., amounts to
outputs, output addresses, something with fees).

One major drawback of your approach is that all transactions are twice as
large as they might otherwise need to be for simple things like congestion
control trees, since you have to repeat all of the output data twice.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210728/327b67b8/attachment.html>

From michaelfolkson at gmail.com  Thu Jul 29 11:36:25 2021
From: michaelfolkson at gmail.com (Michael Folkson)
Date: Thu, 29 Jul 2021 12:36:25 +0100
Subject: [bitcoin-dev] Last week's second IRC workshop on L2 onchain
	support and wrap up
In-Reply-To: <CAFvNmHSs0V8M8wjonoXKmBF6pgdtzQdgK-apsvd80+0k8WWZMg@mail.gmail.com>
References: <CAFvNmHSs0V8M8wjonoXKmBF6pgdtzQdgK-apsvd80+0k8WWZMg@mail.gmail.com>
Message-ID: <CAFvNmHRw3j77ZrtY0bhDEom_0ZQ_7=31bzwDc0THzh07vze7XA@mail.gmail.com>

There was some additional discussion on L2 onchain support at the
recent online Sydney Socratic Seminar. It wasn't recorded but a
transcript is below.

Transcript: https://btctranscripts.com/sydney-bitcoin-meetup/2021-07-06-socratic-seminar/

The discussion focused partly on the rules [1] of BIP 125 RBF and the
rationale for these rules (which isn't clear from the BIP). Proposed
ideas such as SIGHASH_IOMAP, fee sponsorship and transaction mutation
were also discussed that weren't covered during the IRC workshops.

[1] https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki#implementation-details

On Tue, Jun 29, 2021 at 10:44 AM Michael Folkson
<michaelfolkson at gmail.com> wrote:
>
> A summary of the first workshop is here:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019079.html
>
> The focus for this second workshop was fee bumping and package relay.
> For more details on package relay see:
> https://github.com/ariard/L2-zoology/blob/master/workshops/package-relay-and-friends.md
>
> The conversation log for the second workshop is here:
> https://gist.github.com/ariard/32b51ecceccc5c6f647bae86d083c442
>
> Package relay background
>
> Package relay is potentially useful for L2 protocols to address the
> inherent unpredictability of future fees. CPFP (child-pays-for-parent)
> seeks to ensure say a justice transaction, in Lightning?s case, with a
> lower fee, gets confirmed in a more timely manner because miners are
> incentivized to include the child transaction in a block. To do so
> they must include the parent transaction in that block or a preceding
> block. By ?packaging? the parent and the child the initiator of the
> transaction(s) can ensure the miner?s mempool doesn?t initially reject
> the parent transaction for having a too low fee.
>
> There has been prior work done in previous years on package relay,
> mainly by Suhas Daftuar.
>
> Draft BIP: https://gist.github.com/sdaftuar/8756699bfcad4d3806ba9f3396d4e66a
>
> Package relay design questions: https://github.com/bitcoin/bitcoin/issues/14895
>
> Recently Gloria Zhao has been advancing package relay in Bitcoin Core:
> https://gist.github.com/glozow/7064717e727a3eb27fad4f8504513add
>
> Package relay implementation
>
> Attendees seemed in agreement that enabling 2 transaction packages
> would be sufficient (at least for now) for Lightning and DLCs. A L2
> protocol should always be able to design a two step process where the
> first transaction has an effective zero fee rate and the second
> transaction sets the fee. Restricting the size of the package to 2 may
> have the cost of slightly longer confirmation times and/or slightly
> higher fees (t-bast) but it compares well to the increased
> implementation complexity of larger package sizes. Two generation:
> multi parent, single child shouldn?t introduce material implementation
> complexity over two generation: single parent, single child (glozow).
>
> Package RBF (replace-by-fee) is possible where there are two competing
> packages with competing Lightning commitment transactions in them and
> the second package is given a higher fee to attempt to get it
> confirmed before the first package. However, supporting RBF within a
> package (ie replacing a transaction in a package with a higher fee
> transaction) increases implementation complexity and makes it harder
> to reason about (glozow).
>
> rgrant raised the possibility of using two packages {A,B} and {B,C} if
> three transaction packages e.g. {A,B,C} weren?t supported but it was
> suggested it is perhaps better to just broadcast a high fee CPFP
> transaction for the {A,B} package rather than creating two packages.
> If the first package has been evicted from the mempool the {B,C}
> package wouldn?t propagate because it would be an orphan package
> (t-bast).
>
> glozow suggested that only hints (wtxids of transactions you think
> should be package validated) could be communicated rather than
> relaying the transaction themselves but there were concerns from
> others on whether these hints would successfully propagate across the
> network. Instead fee rate hints could be sent to inform a peer?s
> decision on whether it makes sense to fetch the rest of the package
> (t-bast).
>
> darosior suggested the idea of a package based CBlockPolicyEstimator
> in Bitcoin Core if CPFP is going to be increasingly used on the
> network.
>
> Witness replacement and Taproot
>
> Tapscripts can be unlimited in size so with current Taproot rules you
> could in theory go from a 100,000 vbyte witness to an empty witness.
> L2 protocols may have a UTXO shared by two parties where Alice?s
> witness for her branch is say 1,000 vbytes and Bob?s witness is only
> say 250 vbytes. Replacing Alice?s larger witness with Bob?s smaller
> witness could reduce transaction fees. For Lightning the best case is
> a Taproot key path spend (16 vbyte witness) and the worst case is
> going to be a 150 vbyte witness. Miniscript can tell you your worst
> case transaction size and this can be used to assess the transaction
> pinning risk of a bloated witness (all harding).
>
> A future soft fork could give meaning to the annex in Taproot
> (darosior) which could be used for inflating the fee rate of a
> witness. Then you could have a same-txid-different-wtxid coming after
> with a lower fee rate but higher vbytes size to override package
> limits (ariard). But fee rate is purely a policy concept and the annex
> operates at the consensus level. In addition the annex can only
> increase the weight of a transaction, it cannot decrease it (harding).
>
> Wrap up and initial goals
>
> With regards to the goals of the workshops that were initially
> announced here:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003002.html
>
> 1) 2 transactions packages sounds enough to support currently deployed
> L2 protocols
> 2) There are ongoing discussions in the ecosystem regarding
> deprecation of opt in RBF and implementation of full RBF:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-June/019074.html
> 3) Generally status quo and ad hoc security incident response policy
> in the case of cross-layer security issues
> 4) Generally status quo on L2 security philosophy design. L2 protocol
> designers should seek to minimize assumptions on the base layer.
>
> --
> Michael Folkson
> Email: michaelfolkson at gmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3



-- 
Michael Folkson
Email: michaelfolkson at gmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

From billy.tetrud at gmail.com  Fri Jul 30 18:42:23 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Fri, 30 Jul 2021 11:42:23 -0700
Subject: [bitcoin-dev] Covenant opcode proposal OP_CONSTRAINDESTINATION
 (an alternative to OP_CTV)
In-Reply-To: <CAD5xwhhAcup2pKyazopqz7aYAWYmXCJsq1OPni94+OJ8ErUXjQ@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAD5xwhhAcup2pKyazopqz7aYAWYmXCJsq1OPni94+OJ8ErUXjQ@mail.gmail.com>
Message-ID: <CAGpPWDZcK7gV0ZC92NzWYk58mYxR6E_UOZ-3W8FPSRLe7cvnmA@mail.gmail.com>

Thanks for taking another look Jeremy. That's an interesting idea to split
it up into simpler opcodes, however there are some
limitations/considerations there.

For example, with output addresses, I added specifying amounts to outputs
in order to make script evaluation simpler and eliminate a potential DOS
vector. I wrote about this in the section 'Specifying values sent to each
output
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/blob/main/cd/bip-constraindestination.md#specifying-values-sent-to-each-output>'.
Originally, I designed OP_CD without specifying what amounts an input
contributes to what outputs, but it seemed like this would require
calculating various combinations of inequalities, which could get expensive
in scenarios where many inputs had overlapping destinations. See the
examples under the OP_CD section in this commit
<https://github.com/fresheneesz/bip-efficient-bitcoin-vaults/commit/9b2257410b5f0fc991f68e774c3faf601c02cc5d>
.

Maybe there's an elegant and cheap way of verifying that a number of inputs
that have destination address limitations is within limits, but if so I
don't know how to do that. If there was a good way to do that, then I
wouldn't want to propose the ability to validate that specific amounts go
to specific outputs. So unless there's a simple and dos-vector-free way of
evaluating what addresses an input goes to without knowing what amounts an
input contributes to each output, I don't think these functionalities
should be separated.

And about a fee-limit opcode, that could certainly be done on its own.
However, a version of OP_CD that doesn't specify fees would have to take
the fee-limit into account, and the calculation for the stand-alone
fee-limit operation would be moot for that output.

So I think it could make sense to split the fee limit off from the rest of
OP_CD. I'm curious to know what others think of that.

> all transactions are twice as large as they might otherwise need to be
for simple things like congestion control trees, since you have to repeat
all of the output data twice

Well, the transaction wouldn't be quite twice as large. Each output would
add 9 bytes to the transaction, and outputs already are a minimum of about
30 bytes I think? So for transactions with a lot of outputs, it could make
the transaction about 1/3 larger. I'll add a section on this into my
proposal.

Perhaps it would be a reasonable optimization to allow omitting an output
value in cases where the entire output amount is contributed by that input.
This would reduce the overhead of specifying output amounts to 2 bytes for
most outputs (1 byte for the index, another to indicate the full value),
meaning that it would only make the transaction about 7% larger. What do
you think about that idea?

On Wed, Jul 28, 2021 at 3:30 PM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> High level feedback:
>
> you should spec out the opcodes as separate pieces of functionality as it
> sounds like OP_CD is really 3 or 4 opcodes in one (e.g., amounts to
> outputs, output addresses, something with fees).
>
> One major drawback of your approach is that all transactions are twice as
> large as they might otherwise need to be for simple things like congestion
> control trees, since you have to repeat all of the output data twice.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210730/b2f29d8d/attachment.html>

From zachgrw at gmail.com  Sat Jul 31 20:01:49 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Sat, 31 Jul 2021 22:01:49 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as a
 function of total input value
In-Reply-To: <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
Message-ID: <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>

Hi list,

I'd like to explore whether it is feasible to implement new scripting
capabilities in Bitcoin that enable limiting the output amount of a
transaction based on the total value of its inputs. In other words, to
implement the ability to limit the maximum amount that can be sent from an
address.

Two use cases come to mind:

UC1: enable a user to add additional protection their funds by
rate-limiting the amount they are able to send during a certain period
(measured in blocks). A typical use case might be a user that intends to
hodl their bitcoin, but still wishes to occasionally send small amounts.
This avoids an attacker from sweeping all their funds in a single
transaction, allowing the user to become aware of the theft and intervene
to prevent further theft.

UC2: exchanges may wish to rate-limit addresses containing large amounts of
bitcoin, adding warm- or hot-wallet functionality to a cold-storage
address. This would enable an exchange to drastically reduce the number of
times a cold wallet must be accessed with private keys that enable access
to the full amount.

In a typical setup, I'd envision using multisig such that the user has two
sets of private keys to their encumbered address (with a "set" of keys
meaning "one or more" keys). One set of private keys allows only for
sending with rate-limiting restrictions in place, and a s second set of
private keys allowing for sending any amount without rate-limiting,
effectively overriding such restriction.

The parameters that define in what way an output is rate-limited might be
defined as follows:

Param 1: a block height "h0" indicating the first block height of an epoch;
Param 2: a block height "h1" indicating the last block height of an epoch;
Param 3: an amount "a" in satoshi indicating the maximum amount that is
allowed to be sent in any epoch;
Param 4: an amount "a_remaining" (in satoshi) indicating the maximum amount
that is allowed to be sent within the current epoch.

For example, consider an input containing 100m sats (1 BTC) which has been
rate-limited with parameters (h0, h1, a, a_remaning) of (800000, 800143,
500k, 500k). These parameters define that the address is rate-limited to
sending a maximum of 500k sats in the current epoch that starts at block
height 800000 and ends at height 800143 (or about one day ignoring block
time variance) and that the full amount of 500k is still sendable. These
rate-limiting parameters ensure that it takes at minimum 100m / 500k = 200
transactions and 200 x 144 blocks or about 200 days to spend the full 100m
sats. As noted earlier, in a typical setup a user should retain the option
to transact the entire amount using a second (set of) private key(s).

For rate-limiting to work, any change output created by a transaction from
a rate-limited address must itself be rate-limited as well. For instance,
expanding on the above example, assume that the user spends 200k sats from
a rate-limited address a1 containing 100m sats:

Start situation:
At block height 800000: rate-limited address a1 is created;
Value of a1: 100.0m sats;
Rate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;

Transaction t1:
Included at block height 800100;
Spend: 200k + fee;
Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.

Result:
Value at destination address: 200k sats;
Rate limiting params at destination address: none;
Value at change address a2: 99.8m sats;
Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,
a_remaining=300k.

In order to properly enforce rate limiting, the change address must be
rate-limited such that the original rate limit of 500k sats per 144 blocks
cannot be exceeded. In this example, the change address a2 were given the
same rate limiting parameters as the transaction that served as its input.
As a result, from block 800100 up until and including block 800143, a
maximum amount of 300k sats is allowed to be spent from the change address.

Example continued:
a2: 99.8 sats at height 800100;
Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;

Transaction t2:
Included at block height 800200
Spend: 400k + fees.
Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.

Result:
Value at destination address: 400k sats;
Rate limiting params at destination address: none;
Value at change address a3: 99.4m sats;
Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
a_remaining=100k.

Transaction t2 is allowed because it falls within the next epoch (running
from 800144 to 800287) so a spend of 400k does not violate the constraint
of 500k per epoch.

As could be seen, the rate limiting parameters are part of the transaction
and chosen by the user (or their wallet). This means that the parameters
must be validated to ensure that they do not violate the intended
constraints.

For instance, this transaction should not be allowed:
a2: 99.8 sats at height 800100;
Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;

Transaction t2a:
Included at block height 800200;
Spend: 400k + fees;
Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.

This transaction t2a attempts to shift the epoch forward by 20 blocks such
that it starts at 800124 instead of 800144. Shifting the epoch forward like
this must not be allowed because it enables spending more that the rate
limit allows, which is 500k in any epoch of 144 blocks. It would enable
overspending:

t1: spend 200k at 800100 (epoch 1: total: 200k);
t2a: spend 400k at 800200 (epoch 2: total: 400k);
t3a: spend 100k at 800201 (epoch 2: total: 500k);
t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch 2).

Specifying the rate-limiting parameters explicitly at every transaction
allows the user to tighten the spending limit by setting tighter limits or
for instance by setting a_remainder to 0 if they wish to enforce not
spending more during an epoch.

I will stop here because I would like to gauge interest in this idea first
before continuing work on other aspects. Two main pieces of work jump to
mind:

Define all validations;
Describe aggregate behaviour of multiple (rate-limited) inputs, proof that
two rate-limited addresses cannot spend more than the sum of their
individual limits.

Zac
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210731/48005608/attachment.html>

