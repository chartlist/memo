From zachgrw at gmail.com  Sun Aug  1 08:09:26 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Sun, 1 Aug 2021 10:09:26 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as a
 function of total input value
Message-ID: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>

[Resubmitting to list with minor edits. My previous submission ended up
inside an existing thread, apologies.]

Hi list,

I'd like to explore whether it is feasible to implement new scripting
capabilities in Bitcoin that enable limiting the output amount of a
transaction based on the total value of its inputs. In other words, to
implement the ability to limit the maximum amount that can be sent from an
address.

Two use cases come to mind:

UC1: enable a user to add additional protection their funds by
rate-limiting the amount that they are allowed to send during a certain
period (measured in blocks). A typical use case might be a user that
intends to hodl their bitcoin, but still wishes to occasionally send small
amounts. Rate-limiting avoids an attacker from sweeping all the users'
funds in a single transaction, allowing the user to become aware of the
theft and intervene to prevent further thefts.

UC2: exchanges may wish to rate-limit addresses containing large amounts of
bitcoin, adding warm- or hot-wallet functionality to a cold-storage
address. This would enable an exchange to drastically reduce the number of
times a cold wallet must be accessed with private keys that give access to
the full amount.

In a typical setup, I'd envision using multisig such that the user has two
sets of private keys to their encumbered address (with a "set" of keys
meaning "one or more" keys). One set of private keys allows only for
sending with rate-limiting restrictions in place, and a second set of
private keys allowing for sending any amount without rate-limiting,
effectively overriding such restriction.

The parameters that define in what way an output is rate-limited might be
defined as follows:

Param 1: a block height "h0" indicating the first block height of an epoch;
Param 2: a block height "h1" indicating the last block height of an epoch;
Param 3: an amount "a" in satoshi indicating the maximum amount that is
allowed to be sent in any epoch;
Param 4: an amount "a_remaining" (in satoshi) indicating the maximum amount
that is allowed to be sent within the current epoch.

For example, consider an input containing 100m sats (1 BTC) which has been
rate-limited with parameters (h0, h1, a, a_remaining) of (800000, 800143,
500k, 500k). These parameters define that the address is rate-limited to
sending a maximum of 500k sats in the current epoch that starts at block
height 800000 and ends at height 800143 (or about one day ignoring block
time variance) and that the full amount of 500k is still sendable. These
rate-limiting parameters ensure that it takes at minimum 100m / 500k = 200
transactions and 200 x 144 blocks or about 200 days to spend the full 100m
sats. As noted earlier, in a typical setup a user should retain the option
to transact the entire amount using a second (set of) private key(s).

For rate-limiting to work, any change output created by a transaction from
a rate-limited address must itself be rate-limited as well. For instance,
expanding on the above example, assume that the user spends 200k sats from
a rate-limited address a1 containing 100m sats:

Start situation:
At block height 800000: rate-limited address a1 is created;
Value of a1: 100.0m sats;
Rate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;

Transaction t1:
Included at block height 800100;
Spend: 200k + fee;
Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.

Result:
Value at destination address: 200k sats;
Rate limiting params at destination address: none;
Value at change address a2: 99.8m sats;
Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,
a_remaining=300k.

In order to properly enforce rate limiting, the change address must be
rate-limited such that the original rate limit of 500k sats per 144 blocks
cannot be exceeded. In this example, the change address a2 were given the
same rate limiting parameters as the transaction that served as its input.
As a result, from block 800100 up until and including block 800143, a
maximum amount of 300k sats is allowed to be spent from the change address.

Example continued:
a2: 99.8 sats at height 800100;
Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;

Transaction t2:
Included at block height 800200
Spend: 400k + fees.
Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.

Result:
Value at destination address: 400k sats;
Rate limiting params at destination address: none;
Value at change address a3: 99.4m sats;
Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
a_remaining=100k.

Transaction t2 is allowed because it falls within the next epoch (running
from 800144 to 800287) so a spend of 400k does not violate the constraint
of 500k per epoch.

As could be seen, the rate limiting parameters are part of the transaction
and chosen by the user (or their wallet). This means that the parameters
must be validated to ensure that they do not violate the intended
constraints.

For instance, this transaction should not be allowed:
a2: 99.8 sats at height 800100;
Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;

Transaction t2a:
Included at block height 800200;
Spend: 400k + fees;
Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.

This transaction t2a attempts to shift the epoch forward by 20 blocks such
that it starts at 800124 instead of 800144. Shifting the epoch forward like
this must not be allowed because it enables spending more that the rate
limit allows, which is 500k in any epoch of 144 blocks. It would enable
overspending:

t1: spend 200k at 800100 (epoch 1: total: 200k);
t2a: spend 400k at 800200 (epoch 2: total: 400k);
t3a: spend 100k at 800201 (epoch 2: total: 500k);
t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch 2).

Specifying the rate-limiting parameters explicitly at every transaction
allows the user to tighten the spending limit by setting tighter limits or
for instance by setting a_remainder to 0 if they wish to enforce not
spending more during an epoch. A second advantage of explicitly specifying
the four rate-limiting parameters with each transaction is that it allows
the system to fully validate the transaction without having to consider any
previous transactions within an epoch.

I will stop here because I would like to gauge interest in this idea first
before continuing work on other aspects. Two main pieces of work jump to
mind:

Define all validations;
Describe aggregate behaviour of multiple (rate-limited) inputs, proof that
two rate-limited addresses cannot spend more than the sum of their
individual limits.

Zac
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210801/0082071c/attachment.html>

From billy.tetrud at gmail.com  Mon Aug  2 04:40:47 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Sun, 1 Aug 2021 21:40:47 -0700
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
Message-ID: <CAGpPWDZ8sCEjqbN-PM4kc7k7K-3qUqzmHW8hHrBzh7tTJRUs6A@mail.gmail.com>

Hey Zac,

I think this could be a useful opcode. It kinda seems like UC1 and UC2 are
basically the same use case: using rate-limiting to reduce risk of theft or
mistake. I think this could be a helpful addition to a good wallet setup.

I don't quite understand why you'd want to define a specific span of blocks
for the rate limit. Why not just specify the size of the window (in blocks)
to rate limit within, and the limit?

You mentioned change addresses, however, with the parameters you defined,
there would be no way to connect together the change address with the
original address, meaning they would have completely separate rate limits,
which wouldn't work since the change output would ignore the previous rate
limit. I can think of the following options:

A. You could always send change back to the *same* address. This is the
simplest option, and the only downside I can think of is exposing the
public key of an address. I'm not quite sure what the consensus is on the
dangers of exposing the public key. It theoretically reduces quantum
resistance a bit, but I think I read that some of taproot's mechanisms
expose the bare public key, so maybe consensus has changed about that in
recent years?

B. Have some way to specify connected addresses in the output. This has the
edge case that one of the addresses wouldn't be able to specify all the
addresses that it should be connected with, because it would create a hash
loop (ie if you had address A and B that should be connected, you can
create address A and then specify that address B be connected to address A,
but address A cannot specify its connection to B because A was created
before B was created). You wouldn't want one address to be able to simply
define a connection to another address, because this would open up attack
vectors where people could encumber other people's addresses with rate
limits connected to theirs. You could define connections based on
signatures, which could be done without creating a hash loop, however it
would require exposing the public keys of other addresses when you do that,
at which point you might as well go with option A.

C. You could specify that rate limits follow a certain output. Eg, if you
create a transaction with destination output 1 and change output 2, your
rate limiting opcode could specify that output 2 should inherit the rate
limit. These inherited rate limits could all be connected together
automatically.

Another consideration is what to use for a receive-address. I would say the
simplest option here is to receive at an address that contains an existing
output already. If you allowed receiving at an address that contains no
coins, you'd have to specify at least one other address to connect it with.
This could work, but I don't see any advantage to it, since you don't gain
any privacy by creating a new address if you're going to immediately
programmatically tie it to the other addresses.

One thing to consider is the cost of carrying around and checking these
rate limits. Ideally it should be a very small amount of data carried
around in the UTXO set, and be very cheap to verify when the opcode comes
up. I think it would make sense for such an opcode to only be able to track
rate-limits over short spans, like a month or less. Allowing the user to
specify an arbitrary window over which to track a rate-limit seems like
something that would probably open up a dos vector or other node resource
usage abuse attacks. It might be useful enough to simply rate limit over
each epoch (two weeks), but having a small set of options could also be
useful (eg 1 day, 1 week, or 1 month).

In any case, I'd be interested in seeing you write a BIP for this. Of
course, don't take my word as community interest. I'm reasonably new to the
bitcoin dev community, so definitely don't jump the gun based on my
interest.

On Sat, Jul 31, 2021 at 2:51 PM Zac Greenwood via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi list,
>
> I'd like to explore whether it is feasible to implement new scripting
> capabilities in Bitcoin that enable limiting the output amount of a
> transaction based on the total value of its inputs. In other words, to
> implement the ability to limit the maximum amount that can be sent from an
> address.
>
> Two use cases come to mind:
>
> UC1: enable a user to add additional protection their funds by
> rate-limiting the amount they are able to send during a certain period
> (measured in blocks). A typical use case might be a user that intends to
> hodl their bitcoin, but still wishes to occasionally send small amounts.
> This avoids an attacker from sweeping all their funds in a single
> transaction, allowing the user to become aware of the theft and intervene
> to prevent further theft.
>
> UC2: exchanges may wish to rate-limit addresses containing large amounts
> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage
> address. This would enable an exchange to drastically reduce the number of
> times a cold wallet must be accessed with private keys that enable access
> to the full amount.
>
> In a typical setup, I'd envision using multisig such that the user has two
> sets of private keys to their encumbered address (with a "set" of keys
> meaning "one or more" keys). One set of private keys allows only for
> sending with rate-limiting restrictions in place, and a s second set of
> private keys allowing for sending any amount without rate-limiting,
> effectively overriding such restriction.
>
> The parameters that define in what way an output is rate-limited might be
> defined as follows:
>
> Param 1: a block height "h0" indicating the first block height of an epoch;
> Param 2: a block height "h1" indicating the last block height of an epoch;
> Param 3: an amount "a" in satoshi indicating the maximum amount that is
> allowed to be sent in any epoch;
> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
> amount that is allowed to be sent within the current epoch.
>
> For example, consider an input containing 100m sats (1 BTC) which has been
> rate-limited with parameters (h0, h1, a, a_remaning) of (800000, 800143,
> 500k, 500k). These parameters define that the address is rate-limited to
> sending a maximum of 500k sats in the current epoch that starts at block
> height 800000 and ends at height 800143 (or about one day ignoring block
> time variance) and that the full amount of 500k is still sendable. These
> rate-limiting parameters ensure that it takes at minimum 100m / 500k = 200
> transactions and 200 x 144 blocks or about 200 days to spend the full 100m
> sats. As noted earlier, in a typical setup a user should retain the option
> to transact the entire amount using a second (set of) private key(s).
>
> For rate-limiting to work, any change output created by a transaction from
> a rate-limited address must itself be rate-limited as well. For instance,
> expanding on the above example, assume that the user spends 200k sats from
> a rate-limited address a1 containing 100m sats:
>
> Start situation:
> At block height 800000: rate-limited address a1 is created;
> Value of a1: 100.0m sats;
> Rate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;
>
> Transaction t1:
> Included at block height 800100;
> Spend: 200k + fee;
> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>
> Result:
> Value at destination address: 200k sats;
> Rate limiting params at destination address: none;
> Value at change address a2: 99.8m sats;
> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,
> a_remaining=300k.
>
> In order to properly enforce rate limiting, the change address must be
> rate-limited such that the original rate limit of 500k sats per 144 blocks
> cannot be exceeded. In this example, the change address a2 were given the
> same rate limiting parameters as the transaction that served as its input.
> As a result, from block 800100 up until and including block 800143, a
> maximum amount of 300k sats is allowed to be spent from the change address.
>
> Example continued:
> a2: 99.8 sats at height 800100;
> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>
> Transaction t2:
> Included at block height 800200
> Spend: 400k + fees.
> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>
> Result:
> Value at destination address: 400k sats;
> Rate limiting params at destination address: none;
> Value at change address a3: 99.4m sats;
> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
> a_remaining=100k.
>
> Transaction t2 is allowed because it falls within the next epoch (running
> from 800144 to 800287) so a spend of 400k does not violate the constraint
> of 500k per epoch.
>
> As could be seen, the rate limiting parameters are part of the transaction
> and chosen by the user (or their wallet). This means that the parameters
> must be validated to ensure that they do not violate the intended
> constraints.
>
> For instance, this transaction should not be allowed:
> a2: 99.8 sats at height 800100;
> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;
>
> Transaction t2a:
> Included at block height 800200;
> Spend: 400k + fees;
> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>
> This transaction t2a attempts to shift the epoch forward by 20 blocks such
> that it starts at 800124 instead of 800144. Shifting the epoch forward like
> this must not be allowed because it enables spending more that the rate
> limit allows, which is 500k in any epoch of 144 blocks. It would enable
> overspending:
>
> t1: spend 200k at 800100 (epoch 1: total: 200k);
> t2a: spend 400k at 800200 (epoch 2: total: 400k);
> t3a: spend 100k at 800201 (epoch 2: total: 500k);
> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch
> 2).
>
> Specifying the rate-limiting parameters explicitly at every transaction
> allows the user to tighten the spending limit by setting tighter limits or
> for instance by setting a_remainder to 0 if they wish to enforce not
> spending more during an epoch.
>
> I will stop here because I would like to gauge interest in this idea first
> before continuing work on other aspects. Two main pieces of work jump to
> mind:
>
> Define all validations;
> Describe aggregate behaviour of multiple (rate-limited) inputs, proof that
> two rate-limited addresses cannot spend more than the sum of their
> individual limits.
>
> Zac
>
>
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210801/731b3ebe/attachment-0001.html>

From zachgrw at gmail.com  Mon Aug  2 09:32:36 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Mon, 2 Aug 2021 11:32:36 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
References: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
Message-ID: <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>

[Note: I've moved your reply to the newly started thread]

Hi Billy,

Thank you for your kind and encouraging feedback.

I don't quite understand why you'd want to define a specific span of blocks
> for the rate limit. Why not just specify the size of the window (in blocks)
> to rate limit within, and the limit?


To enable more straightforward validation logic.

You mentioned change addresses, however, with the parameters you defined,
> there would be no way to connect together the change address with the
> original address, meaning they would have completely separate rate limits,
> which wouldn't work since the change output would ignore the previous rate
> limit.


The rate-limiting parameters must be re-specified for each rate-limited
input. So, a transaction that has a rate-limited input is only valid if its
output is itself rate-limited such that it does not violate the
rate-limiting constraints of its input.

In my thread-starter, I gave the below example of a rate-limited address a2
that serves as input for transaction t2:

a2: 99.8 sats at height 800100;
Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;

Transaction t2:
Included at block height 800200
Spend: 400k + fees.
Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.

Note how transaction t2 re-specifies the rate-limiting parameters.
Validation must ensure that the re-specified parameters are within bounds,
i.e., do not allow more spending per epoch than the rate-limiting
parameters of its input address a2. Re-specifying the rate-limiting
parameters offers the flexibility to further restrict spending, or to
disable any additional spending within the current epoch by setting
a_remaining to zero.

Result:
Value at destination address: 400k sats;
Rate limiting params at destination address: none;
Value at change address a3: 99.4m sats;
Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
a_remaining=100k.

As a design principle I believe it makes sense if the system is able to
verify the validity of a transaction without having to consider any
transactions that precede its inputs. As a side-note, doing away with this
design principle would however enable more sophisticated rate-limiting
(such as rate-limiting per sliding window instead of rate-limiting per
epoch having a fixed start and end block), but while at the same time
reducing the size of per rate-limiting transaction (because it would enable
specifying the rate-limiting parameters more space-efficiently). To test
the waters and to keep things relatively simple, I chose not to go into
this enhanced form of rate-limiting.

I haven't gone into how to process a transaction having multiple
rate-limited inputs. The easiest way to handle this case is to not allow
any transaction having more than one rate-limited input. One could imagine
complex logic to handle transactions having multiple rate-limited inputs by
creating multiple rate-limited change addresses. However at first glance I
don't believe that the marginal added functionality would justify the
increased implementation complexity.

 I'd be interested in seeing you write a BIP for this.


Thank you, but sadly my understanding of Bitcoin is way too low to be able
to write a BIP and do the implementation. However I see tremendous value in
this functionality. Favorable feedback of the list regarding the usefulness
and the technical feasibility of rate-limiting functionality would of
course be an encouragement for me to descend further down the rabbit hole.

Zac


On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:

> [Resubmitting to list with minor edits. My previous submission ended up
> inside an existing thread, apologies.]
>
> Hi list,
>
> I'd like to explore whether it is feasible to implement new scripting
> capabilities in Bitcoin that enable limiting the output amount of a
> transaction based on the total value of its inputs. In other words, to
> implement the ability to limit the maximum amount that can be sent from an
> address.
>
> Two use cases come to mind:
>
> UC1: enable a user to add additional protection their funds by
> rate-limiting the amount that they are allowed to send during a certain
> period (measured in blocks). A typical use case might be a user that
> intends to hodl their bitcoin, but still wishes to occasionally send small
> amounts. Rate-limiting avoids an attacker from sweeping all the users'
> funds in a single transaction, allowing the user to become aware of the
> theft and intervene to prevent further thefts.
>
> UC2: exchanges may wish to rate-limit addresses containing large amounts
> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage
> address. This would enable an exchange to drastically reduce the number of
> times a cold wallet must be accessed with private keys that give access to
> the full amount.
>
> In a typical setup, I'd envision using multisig such that the user has two
> sets of private keys to their encumbered address (with a "set" of keys
> meaning "one or more" keys). One set of private keys allows only for
> sending with rate-limiting restrictions in place, and a second set of
> private keys allowing for sending any amount without rate-limiting,
> effectively overriding such restriction.
>
> The parameters that define in what way an output is rate-limited might be
> defined as follows:
>
> Param 1: a block height "h0" indicating the first block height of an epoch;
> Param 2: a block height "h1" indicating the last block height of an epoch;
> Param 3: an amount "a" in satoshi indicating the maximum amount that is
> allowed to be sent in any epoch;
> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
> amount that is allowed to be sent within the current epoch.
>
> For example, consider an input containing 100m sats (1 BTC) which has been
> rate-limited with parameters (h0, h1, a, a_remaining) of (800000, 800143,
> 500k, 500k). These parameters define that the address is rate-limited to
> sending a maximum of 500k sats in the current epoch that starts at block
> height 800000 and ends at height 800143 (or about one day ignoring block
> time variance) and that the full amount of 500k is still sendable. These
> rate-limiting parameters ensure that it takes at minimum 100m / 500k = 200
> transactions and 200 x 144 blocks or about 200 days to spend the full 100m
> sats. As noted earlier, in a typical setup a user should retain the option
> to transact the entire amount using a second (set of) private key(s).
>
> For rate-limiting to work, any change output created by a transaction from
> a rate-limited address must itself be rate-limited as well. For instance,
> expanding on the above example, assume that the user spends 200k sats from
> a rate-limited address a1 containing 100m sats:
>
> Start situation:
> At block height 800000: rate-limited address a1 is created;
> Value of a1: 100.0m sats;
> Rate limiting params of a1: h0=800000, h1=800143, a=500k, a_remaining=500k;
>
> Transaction t1:
> Included at block height 800100;
> Spend: 200k + fee;
> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>
> Result:
> Value at destination address: 200k sats;
> Rate limiting params at destination address: none;
> Value at change address a2: 99.8m sats;
> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,
> a_remaining=300k.
>
> In order to properly enforce rate limiting, the change address must be
> rate-limited such that the original rate limit of 500k sats per 144 blocks
> cannot be exceeded. In this example, the change address a2 were given the
> same rate limiting parameters as the transaction that served as its input.
> As a result, from block 800100 up until and including block 800143, a
> maximum amount of 300k sats is allowed to be spent from the change address.
>
> Example continued:
> a2: 99.8 sats at height 800100;
> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>
> Transaction t2:
> Included at block height 800200
> Spend: 400k + fees.
> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>
> Result:
> Value at destination address: 400k sats;
> Rate limiting params at destination address: none;
> Value at change address a3: 99.4m sats;
> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
> a_remaining=100k.
>
> Transaction t2 is allowed because it falls within the next epoch (running
> from 800144 to 800287) so a spend of 400k does not violate the constraint
> of 500k per epoch.
>
> As could be seen, the rate limiting parameters are part of the transaction
> and chosen by the user (or their wallet). This means that the parameters
> must be validated to ensure that they do not violate the intended
> constraints.
>
> For instance, this transaction should not be allowed:
> a2: 99.8 sats at height 800100;
> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;
>
> Transaction t2a:
> Included at block height 800200;
> Spend: 400k + fees;
> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>
> This transaction t2a attempts to shift the epoch forward by 20 blocks such
> that it starts at 800124 instead of 800144. Shifting the epoch forward like
> this must not be allowed because it enables spending more that the rate
> limit allows, which is 500k in any epoch of 144 blocks. It would enable
> overspending:
>
> t1: spend 200k at 800100 (epoch 1: total: 200k);
> t2a: spend 400k at 800200 (epoch 2: total: 400k);
> t3a: spend 100k at 800201 (epoch 2: total: 500k);
> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch
> 2).
>
> Specifying the rate-limiting parameters explicitly at every transaction
> allows the user to tighten the spending limit by setting tighter limits or
> for instance by setting a_remainder to 0 if they wish to enforce not
> spending more during an epoch. A second advantage of explicitly specifying
> the four rate-limiting parameters with each transaction is that it allows
> the system to fully validate the transaction without having to consider any
> previous transactions within an epoch.
>
> I will stop here because I would like to gauge interest in this idea first
> before continuing work on other aspects. Two main pieces of work jump to
> mind:
>
> Define all validations;
> Describe aggregate behaviour of multiple (rate-limited) inputs, proof that
> two rate-limited addresses cannot spend more than the sum of their
> individual limits.
>
> Zac
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210802/49badd38/attachment.html>

From michaelfolkson at gmail.com  Tue Aug  3 09:59:25 2021
From: michaelfolkson at gmail.com (Michael Folkson)
Date: Tue, 3 Aug 2021 10:59:25 +0100
Subject: [bitcoin-dev] Online discussion on Taproot roll out - Tuesday
	July 20th 17:15 UTC
In-Reply-To: <CAFvNmHSdozmBK44jSEAQdZYo+1-01fVuaVATAimgGCohiy-BHQ@mail.gmail.com>
References: <CAFvNmHSdozmBK44jSEAQdZYo+1-01fVuaVATAimgGCohiy-BHQ@mail.gmail.com>
Message-ID: <CAFvNmHS0yLYhrZu-iiz0vxi6PjpeZN-=Qz240s5vy75KmV9XpQ@mail.gmail.com>

Please find below the video and transcript from the online discussion
on Taproot roll out that was held on July 20th.

Video: https://www.youtube.com/watch?v=GAkLuZNsZzw
Transcript: https://btctranscripts.com/london-bitcoin-devs/2021-07-20-socratic-seminar-taproot-rollout/
Reading list: https://gist.github.com/michaelfolkson/0803271754f851530fe8242087859254

On Sat, Jul 17, 2021 at 2:16 PM Michael Folkson
<michaelfolkson at gmail.com> wrote:
>
> Hi
>
> There is an online Zoom call (also livestreamed on YouTube) on Tuesday
> July 20th at 17:15 UTC discussing Taproot roll out post activation in
> November. It will be focused at developers and so discussion will be
> technical but all are welcome to attend/watch.
>
> Murch has this wiki page monitoring planned ecosystem support of P2TR
> addresses and it would be great to hear from projects and businesses
> that have Taproot support on their medium/long term development
> roadmap or are considering it:
> https://en.bitcoin.it/wiki/Bech32_adoption
>
> Meetup link (Zoom link will be announced here):
> https://www.meetup.com/BitDevsLDN/events/279041693/
>
> Draft pre-reading link (will be finalized before Tuesday):
> https://gist.github.com/michaelfolkson/0803271754f851530fe8242087859254
>
> Thanks
> Michael
>
> --
> Michael Folkson
> Email: michaelfolkson at gmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3



-- 
Michael Folkson
Email: michaelfolkson at gmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

From billy.tetrud at gmail.com  Tue Aug  3 18:12:28 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Tue, 3 Aug 2021 11:12:28 -0700
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>
References: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
 <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>
Message-ID: <CAGpPWDbidOBqUXHpoteAf50WXeMi392PJZmApyT8h2Gk6n1gKQ@mail.gmail.com>

> To enable more straightforward validation logic.
> within the current epoch

Ah I see, this is all limited to within a single epoch. I think that
sufficiently limits the window of time in which nodes have to store
information for rate limited outputs. However, I don't see how specifying
block ranges simplifies the logic - wouldn't this complicate the logic with
additional user-specified constraints? It also prevents the output from
being able to be rate limited over the span of multiple epochs, which would
seem to make it a lot more difficult to use for certain types of wallets
(eg cold wallets).

I think I see the logic of your 'remaining' parameter there. If you start
with a single rate-limited input, you can split that into many outputs,
only one of which have a 'remaining' balance. The rest can simply remain
unspendable for the rest of the epoch. That way these things don't need to
be tied together. However, that doesn't solve the problem of 3rd parties
being able to send money into the wallet.

> I don't believe that the marginal added functionality would justify the
increased implementation complexity

Perhaps, but I think there is a lot of benefit in allowing these kinds of
things to operate as similarly as possible to normal transactions, for one
because of usability reasons. If each opcode has its own quirks that are
not intuitively related to their purpose (eg if a rate-limited wallet had
no way to get a receiving address), it would confuse end-users (eg who
wonder how to get a receiving address and how they can ask people to send
money into their wallet) or require a lot of technical complexity in
applications (eg to support something like cooperatively connecting with
their wallet so that a transaction can be made that creates a new
single-output for the wallet). A little complexity in this opcode can save
a lot of external complexity here I think.

> my understanding of Bitcoin is way too low to be able to write a BIP and
do the implementation

You might be able to find people willing to help. I would be willing to
help write the BIP spec. I'm not the right person to help with the
implementation, but perhaps you could find someone else who is. Even if the
BIP isn't adopted, it could be a starting point or inspiration for someone
else to write an improved version.

On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:

> [Note: I've moved your reply to the newly started thread]
>
> Hi Billy,
>
> Thank you for your kind and encouraging feedback.
>
> I don't quite understand why you'd want to define a specific span of
>> blocks for the rate limit. Why not just specify the size of the window (in
>> blocks) to rate limit within, and the limit?
>
>
> To enable more straightforward validation logic.
>
> You mentioned change addresses, however, with the parameters you defined,
>> there would be no way to connect together the change address with the
>> original address, meaning they would have completely separate rate limits,
>> which wouldn't work since the change output would ignore the previous rate
>> limit.
>
>
> The rate-limiting parameters must be re-specified for each rate-limited
> input. So, a transaction that has a rate-limited input is only valid if its
> output is itself rate-limited such that it does not violate the
> rate-limiting constraints of its input.
>
> In my thread-starter, I gave the below example of a rate-limited address
> a2 that serves as input for transaction t2:
>
> a2: 99.8 sats at height 800100;
> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>
> Transaction t2:
> Included at block height 800200
> Spend: 400k + fees.
> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>
> Note how transaction t2 re-specifies the rate-limiting parameters.
> Validation must ensure that the re-specified parameters are within bounds,
> i.e., do not allow more spending per epoch than the rate-limiting
> parameters of its input address a2. Re-specifying the rate-limiting
> parameters offers the flexibility to further restrict spending, or to
> disable any additional spending within the current epoch by setting
> a_remaining to zero.
>
> Result:
> Value at destination address: 400k sats;
> Rate limiting params at destination address: none;
> Value at change address a3: 99.4m sats;
> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
> a_remaining=100k.
>
> As a design principle I believe it makes sense if the system is able to
> verify the validity of a transaction without having to consider any
> transactions that precede its inputs. As a side-note, doing away with this
> design principle would however enable more sophisticated rate-limiting
> (such as rate-limiting per sliding window instead of rate-limiting per
> epoch having a fixed start and end block), but while at the same time
> reducing the size of per rate-limiting transaction (because it would enable
> specifying the rate-limiting parameters more space-efficiently). To test
> the waters and to keep things relatively simple, I chose not to go into
> this enhanced form of rate-limiting.
>
> I haven't gone into how to process a transaction having multiple
> rate-limited inputs. The easiest way to handle this case is to not allow
> any transaction having more than one rate-limited input. One could imagine
> complex logic to handle transactions having multiple rate-limited inputs by
> creating multiple rate-limited change addresses. However at first glance I
> don't believe that the marginal added functionality would justify the
> increased implementation complexity.
>
>  I'd be interested in seeing you write a BIP for this.
>
>
> Thank you, but sadly my understanding of Bitcoin is way too low to be able
> to write a BIP and do the implementation. However I see tremendous value in
> this functionality. Favorable feedback of the list regarding the usefulness
> and the technical feasibility of rate-limiting functionality would of
> course be an encouragement for me to descend further down the rabbit hole.
>
> Zac
>
>
> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>
>> [Resubmitting to list with minor edits. My previous submission ended up
>> inside an existing thread, apologies.]
>>
>> Hi list,
>>
>> I'd like to explore whether it is feasible to implement new scripting
>> capabilities in Bitcoin that enable limiting the output amount of a
>> transaction based on the total value of its inputs. In other words, to
>> implement the ability to limit the maximum amount that can be sent from an
>> address.
>>
>> Two use cases come to mind:
>>
>> UC1: enable a user to add additional protection their funds by
>> rate-limiting the amount that they are allowed to send during a certain
>> period (measured in blocks). A typical use case might be a user that
>> intends to hodl their bitcoin, but still wishes to occasionally send small
>> amounts. Rate-limiting avoids an attacker from sweeping all the users'
>> funds in a single transaction, allowing the user to become aware of the
>> theft and intervene to prevent further thefts.
>>
>> UC2: exchanges may wish to rate-limit addresses containing large amounts
>> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage
>> address. This would enable an exchange to drastically reduce the number of
>> times a cold wallet must be accessed with private keys that give access to
>> the full amount.
>>
>> In a typical setup, I'd envision using multisig such that the user has
>> two sets of private keys to their encumbered address (with a "set" of keys
>> meaning "one or more" keys). One set of private keys allows only for
>> sending with rate-limiting restrictions in place, and a second set of
>> private keys allowing for sending any amount without rate-limiting,
>> effectively overriding such restriction.
>>
>> The parameters that define in what way an output is rate-limited might be
>> defined as follows:
>>
>> Param 1: a block height "h0" indicating the first block height of an
>> epoch;
>> Param 2: a block height "h1" indicating the last block height of an epoch;
>> Param 3: an amount "a" in satoshi indicating the maximum amount that is
>> allowed to be sent in any epoch;
>> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
>> amount that is allowed to be sent within the current epoch.
>>
>> For example, consider an input containing 100m sats (1 BTC) which has
>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,
>> 800143, 500k, 500k). These parameters define that the address is
>> rate-limited to sending a maximum of 500k sats in the current epoch that
>> starts at block height 800000 and ends at height 800143 (or about one day
>> ignoring block time variance) and that the full amount of 500k is still
>> sendable. These rate-limiting parameters ensure that it takes at minimum
>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to
>> spend the full 100m sats. As noted earlier, in a typical setup a user
>> should retain the option to transact the entire amount using a second (set
>> of) private key(s).
>>
>> For rate-limiting to work, any change output created by a transaction
>> from a rate-limited address must itself be rate-limited as well. For
>> instance, expanding on the above example, assume that the user spends 200k
>> sats from a rate-limited address a1 containing 100m sats:
>>
>> Start situation:
>> At block height 800000: rate-limited address a1 is created;
>> Value of a1: 100.0m sats;
>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,
>> a_remaining=500k;
>>
>> Transaction t1:
>> Included at block height 800100;
>> Spend: 200k + fee;
>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>>
>> Result:
>> Value at destination address: 200k sats;
>> Rate limiting params at destination address: none;
>> Value at change address a2: 99.8m sats;
>> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,
>> a_remaining=300k.
>>
>> In order to properly enforce rate limiting, the change address must be
>> rate-limited such that the original rate limit of 500k sats per 144 blocks
>> cannot be exceeded. In this example, the change address a2 were given the
>> same rate limiting parameters as the transaction that served as its input.
>> As a result, from block 800100 up until and including block 800143, a
>> maximum amount of 300k sats is allowed to be spent from the change address.
>>
>> Example continued:
>> a2: 99.8 sats at height 800100;
>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>
>> Transaction t2:
>> Included at block height 800200
>> Spend: 400k + fees.
>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>
>> Result:
>> Value at destination address: 400k sats;
>> Rate limiting params at destination address: none;
>> Value at change address a3: 99.4m sats;
>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
>> a_remaining=100k.
>>
>> Transaction t2 is allowed because it falls within the next epoch (running
>> from 800144 to 800287) so a spend of 400k does not violate the constraint
>> of 500k per epoch.
>>
>> As could be seen, the rate limiting parameters are part of the
>> transaction and chosen by the user (or their wallet). This means that the
>> parameters must be validated to ensure that they do not violate the
>> intended constraints.
>>
>> For instance, this transaction should not be allowed:
>> a2: 99.8 sats at height 800100;
>> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>
>> Transaction t2a:
>> Included at block height 800200;
>> Spend: 400k + fees;
>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>>
>> This transaction t2a attempts to shift the epoch forward by 20 blocks
>> such that it starts at 800124 instead of 800144. Shifting the epoch forward
>> like this must not be allowed because it enables spending more that the
>> rate limit allows, which is 500k in any epoch of 144 blocks. It would
>> enable overspending:
>>
>> t1: spend 200k at 800100 (epoch 1: total: 200k);
>> t2a: spend 400k at 800200 (epoch 2: total: 400k);
>> t3a: spend 100k at 800201 (epoch 2: total: 500k);
>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch
>> 2).
>>
>> Specifying the rate-limiting parameters explicitly at every transaction
>> allows the user to tighten the spending limit by setting tighter limits or
>> for instance by setting a_remainder to 0 if they wish to enforce not
>> spending more during an epoch. A second advantage of explicitly specifying
>> the four rate-limiting parameters with each transaction is that it allows
>> the system to fully validate the transaction without having to consider any
>> previous transactions within an epoch.
>>
>> I will stop here because I would like to gauge interest in this idea
>> first before continuing work on other aspects. Two main pieces of work jump
>> to mind:
>>
>> Define all validations;
>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof
>> that two rate-limited addresses cannot spend more than the sum of their
>> individual limits.
>>
>> Zac
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210803/2ef771b3/attachment-0001.html>

From justin at odm.ro  Wed Aug  4 10:30:37 2021
From: justin at odm.ro (Justin Valceanu)
Date: Wed, 4 Aug 2021 13:30:37 +0300
Subject: [bitcoin-dev] Bip-0039/Wordlist - Romanian
In-Reply-To: <d40d7068-3b13-64ad-aef5-30210212a79c@odm.ro>
References: <d40d7068-3b13-64ad-aef5-30210212a79c@odm.ro>
Message-ID: <112f5fa6-510c-8280-4f65-fbb0d41a5aa4@odm.ro>

Hello,

I have created a new Romanian wordlist for Bip-0039;
Requesting permission to push to github the attached modified files.

Thanks
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bip-0039-wordlists.md
Type: text/markdown
Size: 6792 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210804/0445cdb6/attachment-0001.bin>
-------------- next part --------------
abajur
abanos
abatere
abator
abces
abdomen
abecedar
abisal
abordat
abortare
abrogat
absent
absint
absolvent
abundent
aburi
acadea
academic
acalmie
acatist
acetat
aclama
acomodat
acord
acordat
acordeon
acostament
acrobat
activat
actor
actualitate
acvaplanare
acvatic
adaos
adaptabil
adesiv
adeziune
adiacent
adiere
adjectiv
administrare
admis
adorat
adresa
adverb
adversar
aerat
aerogen
afacere
afluent
agale
agent
agrement
ahtiere
airbag
aiurea
ajutat
alambic
alarmat
alb
albastru
albatros
alegoric
alert
alfabet
aliaj
alifie
alint
alpin
altruism
amabil
amalgam
amanet
amant
amestec
ametist
amfocit
amiabil
amnezie
amoniac
amonte
amorf
amper
amplu
amprenta
amurg
ananas
ancestru
anexa
anonimat
ansamblu
antet
antidot
antonim
antricot
anual
aparat
aperitiv
apometru
aprig
aprilie
aproape
aprozar
aracet
aragaz
arcas
arctic
ardei
argat
argint
argou
argument
arhaism
arhiduce
arhitect
aritmic
armament
armat
armonie
artezian
artifact
asalt
asertiv
asfalt
astro
ateneu
atlas
atomic
atractiv
audit
august
aur
autentic
autocar
autor
avanport
avans
avatar
avere
axial
axiom
azimut
babic
babuin
baclava
bacterie
bagaj
balans
balast
balastru
balaur
balcanic
balcon
balet
balistic
baliza
balnear
balon
balsam
bambus
banal
banca
bancher
banda
bandit
baraj
barbaric
barion
barman
baron
baros
basculant
basist
basm
bastion
baston
batalion
baterie
baton
bazalt
bazar
bazin
bec
belciug
benefic
benzen
berbec
beta
beton
bezea
biban
bibelou
biceps
bideu
bidon
bijutier
bilet
binar
binoclu
biolog
bioritm
biped
birjar
birou
biscuit
bisturiu
bitum
biuvac
bizar
bizon
blindat
bloc
blond
blugi
bluza
boboc
bocanc
boier
bolovan
bondar
bostan
brad
breaz
breloc
bretea
briceag
bronz
bruiat
bruma
brutar
bufet
buimac
bujor
bulbar
buldozer
buletin
bulevard
burbon
buric
butan
butic
butoi
butuc
buzunar
cabanier
cabanos
cabaret
cabinet
cablu
cacao
cactus
cadastru
cadet
cadou
cadru
cafea
caiac
caiet
cal
calcul
calendar
caligraf
calup
camarad
camion
camping
campus
canal
cangur
canibal
canion
canton
capabil
capac
caporal
captiv
carapace
carbon
cargo
carie
carne
carpatic
cartier
casant
castel
castron
cater
catod
catolic
cauciuc
cazan
ceainic
ceas
ceaun
celest
celofan
centaur
cenzor
cer
ceramic
cerdac
cerebel
cezar
cheag
cheie
chimic
chiot
cidru
cifru
ciment
cinci
cinema
cineva
cinic
ciocan
civil
cizmar
clandestin
clarinet
claxon
clema
cleric
clima
clocot
clona
clopot
cobalt
codex
codru
coeficient
coeziune
cofetar
coiot
colac
colaps
coleg
colerat
color
comoara
comod
compact
compas
conclav
contra
copac
copios
corabie
corect
coroziv
corset
cortex
cosmic
covor
covrig
creion
croitor
cronic
cruce
crupier
ctitor
cuantic
cuget
cui
culme
culpabil
cumin
cuptor
curaj
curcan
curea
curte
cutanat
cutie
cutremur
cvorum
cyborg
dacic
dafin
dansator
datare
datorie
debara
deblocat
debut
decalat
decan
decizie
deconectat
decor
decret
decriptat
defensiv
degaja
degerat
deget
dejun
delir
delta
demagog
demarcat
demis
demizeu
democratic
demon
depanat
depou
depus
deranj
derapat
desert
detectiv
determinat
detonator
deviz
dexteritate
diabolic
diacritic
dialect
diamant
diavol
diedru
difan
diftong
diligent
dinar
dinozaur
dinte
dipol
directorat
discografie
dispozitiv
distribuit
divers
doctor
document
dolofan
domeniu
domestic
domiciliu
dormitor
dosar
dovleac
dozaj
drapel
draperie
drojdie
druid
drumar
dualism
dubios
duhovnic
dulceag
dulgher
durere
echer
echilater
echilibru
echipa
echitabil
echitate
eclectic
ecler
ecler
ecograf
ecologie
economat
economic
ecran
ecuator
ecuson
ecvestru
edificiu
edil
editor
efect
efemer
eficace
eficient
efort
efractor
egal
elaborat
electric
electrolit
elefant
elementar
eleron
elev
elice
elicopter
eligibil
eliminat
eliptic
elixir
elocvent
elogiat
elucidat
eluziv
emanat
embargo
emblematic
eminent
emirat
emotiv
empatic
emulsie
endomorf
endoscop
energie
enigmatic
entitate
entuziast
eolian
epicentru
epidemic
epilog
episod
epitaf
epolet
epsilon
epuizat
equestru
eradicat
ereditar
ergonomic
ermetic
eroare
erou
eroziune
erudit
escalop
est
etaj
etalat
etalon
eteric
etern
etnie
etnograf
eucariot
euforie
eugenie
europa
evacua
evalua
evantai
eveniment
evident
evitat
evocat
evolua
exagera
exaltat
examen
excavator
excedent
exces
excursie
executa
exod
exomorf
expansiv
expat
experient
expert
explicat
explorat
explozie
export
extaz
extins
extract
ezoteric
fabrica
fabulos
fachir
facil
factor
factorial
facultate
fagure
faima
falie
faliment
fals
familie
fandare
fanion
fanta
fapt
faraon
farfurie
faringe
farmacie
farmec
fascicul
fason
fatal
fault
fauna
februarie
fecior
federal
felie
felin
felinar
feminin
fenicul
fenomen
ferbinte
feribot
fericire
ferie
ferm
fermentare
feroce
feros
fertil
festivitate
feudalism
fezabilitate
fiabil
fiare
fiasco
ficat
fictiv
ficus
fier
fierar
fierbe
fierbinte
fiert
figurant
filaj
filet
film
filon
finisaj
finit
fior
fiord
fioros
firav
fiscalizat
fisiune
fistic
fisura
fixat
flacon
flagrant
flambat
flamingo
flaps
flaut
flirt
floral
florian
fluent
fluier
fluture
fluviu
flux
focal
folos
fonic
foraj
formular
fortificat
fosfor
fotbal
fotograf
fotoliu
foton
fractal
frag
fragment
franjur
frasin
frate
frecvent
frenetic
frigider
frizer
front
fruct
fucsia
fular
fulger
fum
funciar
fundal
funebru
funerar
fungibil
funie
furaj
furie
furios
furnal
furnizor
fursec
furtun
futurism
fuziune
gabarit
gabion
galactic
galantar
galaxie
galop
gama
garantat
gard
gardian
garou
gastronom
gazifer
gazoduct
gazos
geam
gelos
gem
gemut
generat
generic
genist
geniu
genotip
gentil
genunchi
geodezic
geoid
geomagnetic
geometric
germen
ghemotoc
ghepard
ghidat
ghilimele
ghimpe
ghiocel
ghiont
ghiozdan
ghips
ghiuden
gigafon
gigantic
gimnaziast
gin
ginere
girofar
giroplan
giroscop
giulgiu
giuvaier
gladiator
glazura
gletuit
glisant
global
glorie
gluten
gofra
golem
goliat
gonac
gonflabil
gong
gonit
grabnic
grade
grafit
gramaj
gramatic
gramofon
grangur
granit
gratis
graur
graviton
gravor
grefa
greier
grenada
gresie
greutate
grifon
grind
grindina
grosolan
grozav
grupat
guler
gulie
guma
guru
guvern
guvid
habar
habitat
haiduc
haihui
halterofil
halucinant
hamac
hamal
hambar
hamei
hamsie
hamster
handbal
hangiu
hanorac
haos
haotic
harbuz
harnic
harpa
harpon
harta
hazliu
hectolitru
heliograf
heliomat
heliport
heliu
helium
helix
hexagon
hidrant
hidratat
hipiot
hipnotizat
holografic
homar
horoscop
horticultor
hotel
hrean
iaht
iatagan
iaurt
ibric
iconic
idealism
identic
ideolog
iedera
ieftin
ienuper
ignat
ignorat
igrasie
ilegal
ilustrat
iluzie
imaculat
imaginat
imagine
imatur
imbus
imens
iminent
impact
impas
impediment
imperiu
implant
import
impuls
imun
inactiv
incert
incipit
incolor
incomod
indexat
inedit
informat
ingenios
inima
injust
inocent
inox
insistent
insomnie
instalator
instructor
inteligent
intens
interviu
intravilan
inundat
inutil
inventator
iobag
ipsos
iregular
iscusit
isoscel
iunie
ivit
izbit
izolat
izomorf
izopren
jaguar
jambon
jandarm
jargon
jenat
jeton
jgheab
jnepen
joben
joi
joker
junime
jurist
juriu
justificat
juvete
juxtapunere
karaoke
karate
karma
katana
kelvin
kerosen
ketchup
kevlar
kilogram
kilometru
kilovolt
kitsch
kripton
labirint
lac
lada
lambda
laminaj
lampion
lance
lansat
laptop
laser
latent
lateral
lecuit
lefter
legal
lege
legenda
lemur
leopard
lespede
letal
levier
lexicon
leziune
liant
liceu
lider
lift
ligament
lighean
limax
limba
limbic
limita
limpede
lingou
linie
lipie
literal
livret
lizibil
locatar
locuitor
logaritm
logic
logoped
loial
lombar
longevitate
lucid
lucru
luminos
lunar
lunatic
lunetist
luni
lutier
luxos
lynx
macadam
macao
macara
macaragiu
macaz
machiaj
macrou
maestru
mafiot
magazin
magic
magnat
magnet
mahamur
mahon
maidan
maior
majordom
majoritar
majuscul
malac
malaxor
malefic
mamaie
mamograf
manager
mandatar
manej
manevra
manierat
manipulat
manometru
mansarda
mantra
mapamond
maraton
marcaj
marginal
margine
marinar
martie
martini
martor
masaj
mascat
masculin
mason
master
materie
matur
mausoleu
mecanic
mecet
medalie
median
medical
medie
mediocru
meditat
melc
melc
memento
memorat
memorie
menajer
menisc
menit
meniu
mental
mercur
merge
merit
mesaj
metaforic
metal
metalic
metan
meteo
meteorit
metrou
metru
miaun
microb
microfon
midie
miel
miercuri
miere
mijloc
mijluc
mileu
miliard
milos
mima
mimetism
mina
miner
mineralist
minereu
minerit
minge
minicar
minimal
minion
minte
minune
mioritic
miotrop
miracol
mirat
miriapod
miros
misionar
misterios
mistuit
mit
mitic
mitocan
mitologie
mixaj
mixt
mnemonic
mobilat
mobilizat
mocasin
model
modelat
modem
modern
modernizat
modest
modificat
modul
moft
molid
molie
moment
monarh
mondial
monitor
monolog
monopol
monsenior
monstru
montabil
montaj
montan
montat
monument
moped
morar
morcov
morfologic
morman
morse
mortar
motel
motiv
motor
motorizat
mucegai
muget
mugur
mulat
mumie
munte
muntos
mural
murat
murdar
murmur
murmure
musaca
musafir
mutant
mutare
muzeolog
muzeu
muzical
nabab
nailon
naiv
napalm
narativ
nasture
national
nativ
neant
nebulos
necesar
nectar
nedormit
nedumerit
negare
negociabil
negru
negustor
nelimitat
nemilos
neobosit
neon
neopren
nervos
nesemnat
neserios
nesigur
nesupus
neted
neural
neuron
neutru
nevoie
nibelung
nihilism
nimbus
nimeni
nimfa
ninsoare
nirvana
nisip
nobel
nociv
nocturn
nod
noiembrie
nomadic
nonsens
nor
nord
nordic
normal
noroc
notabil
notar
nucleu
nudism
nufar
numai
numar
nume
numeric
numismatic
numit
oaie
oameni
oarba
oaspete
oaste
obedient
obelisc
obicei
obiect
oblic
obligat
oblon
obor
obosit
obraz
obscur
obsesie
obsidian
obstacol
obturat
obtuz
ocazie
ocean
ochelari
ocolit
ocrotit
octagon
octombrie
ocult
ocupat
odaie
odihnit
odios
odorizant
ofenziv
oftat
oinar
oituz
olar
olfactiv
oligarh
olimpian
olograf
omagiu
omega
omenie
omenos
omnia
omniprezent
omogen
ondulat
onest
onorat
opac
opera
opiat
opinie
opozabil
oprire
optar
optic
optimal
optimizat
optzeci
opulent
oracol
orar
orbital
ordin
ordinal
ordonat
organic
organizat
orguliu
orice
oricine
orient
origine
orion
orizont
ornament
ortac
ortodox
oscilant
oseminte
osmiu
osmotic
ostenit
ostil
osuar
oua
oxidat
oxigen
oximetru
oximoron
ozana
pace
pachebot
pachet
pacient
pacific
pact
pager
palid
palindrom
palton
pancreas
panorama
panou
pantalon
pantof
papagal
papuc
parapet
parbriz
parfum
paritate
parter
pasaj
pasiune
patogen
patriot
patru
pavaj
pavea
pavilion
pecete
pegas
pelican
penaj
penar
pendul
pensie
pensiune
pensula
pepene
perceptiv
perdea
perete
perie
periodic
perla
permisie
perplex
personaj
pescar
petrol
pianist
picant
picior
picolo
pictor
piele
piftie
pigment
pilon
pinguin
piolet
pirat
pistol
piston
placaj
plafon
plasa
plat
pleonasm
plete
plic
ploape
plumb
podea
podium
poem
poezie
pogon
polar
polen
polonic
popas
popor
popular
port
portocaliu
portret
posesiv
posteritate
potasiu
potent
potir
potop
poveste
pozitiv
practic
pragmatic
praznic
preambul
precar
prefect
premolar
prenume
preot
pretabil
priceput
prieten
primit
privat
priza
proba
problema
profit
program
proiect
prolific
prompt
propulsie
prosop
protest
provincie
prudent
prunc
public
pudra
pufulete
puhoi
puiet
pulpa
puls
pumnal
punct
pupic
pustnic
putere
putred
quark
quasar
quasi
quinet
rabat
rabin
rachiu
racord
radar
radial
radian
radiat
radiator
radioactiv
radiofonic
radiolog
radiometrie
radon
rafinat
rafting
raion
raliu
ramuri
randomizat
raport
rarefiat
rarisim
rastel
rateu
raton
razant
reactivat
realizat
reanimat
reaprins
rebel
rebus
rebut
recalculat
rece
recesiune
rechin
recreativ
recrut
rector
recuperat
recursiv
redactare
redresor
redus
redut
reflexiv
reflux
refuz
rege
regenerat
regim
registru
reglabil
regret
regular
relax
religie
remediu
remix
remiza
rentabil
renume
repaus
repede
reper
repezit
reporter
reportofon
resemnat
respins
restaurant
retoric
retras
revizie
revocat
rezervor
ridicol
rigla
rindea
ring
rininchi
rinocer
ritmic
rivanol
roade
robotic
robust
rodaj
rodie
roditor
rotisor
rotor
rotula
rotunjit
roz
rudimentar
rugina
rulat
ruleta
rulment
rulou
rumenit
rupestru
sabie
sabot
sabotaj
sac
safir
salam
salariu
saleu
saltea
salut
salvamont
salvat
salvie
samurai
sanie
sarcasm
sare
satelit
saturat
saturn
scadent
scala
scaun
schimb
sciatic
sclipire
scorpion
scrum
scula
secat
secera
secol
secret
sector
secure
sediment
seism
seismograf
sejur
semafor
sensibil
senzor
senzorial
septembrie
serafim
sergent
sesiune
sever
sezon
sfernic
sfinx
shogun
sibiu
sigiliu
sigma
silicon
siloz
silvia
simbiot
simbolism
simfonic
simpatic
sistem
smerit
smog
soare
sobru
sociabil
societate
solar
solemn
solomonar
solubil
solvabil
somelier
somon
sonar
sondaj
sonerie
sonor
sorbet
spanac
spate
specialist
spectru
speolog
spic
spionaj
stabil
stagiar
stand
start
stativ
stea
steag
stejar
stilou
stimulant
straniu
strat
stropitor
strug
student
stufos
subsol
subtil
suculent
sufix
sugar
sulfat
sumbru
sunet
supernatural
surcele
surplus
surprins
susan
suspect
suspendat
svelt
tabel
tabiet
tabla
tablou
tabu
tabular
tachet
tacit
tactil
tahion
talaz
talcioc
talentat
talie
talisman
talon
talpa
tamponat
tanc
tandem
tandru
tangibil
tapet
taraf
tardiv
tarif
tartor
tasat
tatuaj
teanc
teatru
teflon
tegument
tejghea
telefon
teleghidat
telepat
telescop
televizor
telex
temelie
temerar
temperat
templu
temporar
tenace
tendon
tenor
tentant
teolog
teorie
terapeut
terariu
terasament
teren
terestru
teribil
teritoriu
terminator
termometru
testament
testat
texturat
tezaur
tibie
tigaie
tigru
timid
timonerie
timp
timpan
tipar
tipizat
tipografie
tiraj
titlu
toamna
toane
tocilar
tocitor
toiag
tolerat
tomograf
toner
tonomat
topmodel
topograf
toponim
topor
torace
toroid
totalitar
totem
trabant
trabuc
tractare
tractor
traducere
trafalet
trafic
traforaj
trainic
tramvai
trandafir
transcendent
transfer
transfuzie
transport
tranzit
traseu
travaliu
treaz
trece
trei
tren
trepte
trestie
triaj
tribal
tribord
tribut
triceps
tricou
trifoi
trigon
trilateral
trimestru
triumf
trivial
trofeu
trompetist
tronson
tropical
tropot
trotuar
trucaj
trucat
trunchi
tsunami
tuareg
tulbure
tun
tunel
tunet
tunsoare
tupeu
turban
turbo
turnir
turometru
tutore
tutun
ucenic
uger
uimit
uimitor
uituc
ulcior
ulei
ulterior
ultimatum
ultracentral
uman
umanitar
umbra
umed
umeri
umezit
umflat
umil
umor
uncie
unde
undeva
unghie
unicat
uniform
unit
unitate
uniune
univers
uns
unsprezece
unt
unu
uragan
urangutan
uraniu
urare
urcare
ureche
urgent
urmare
urnit
urs
ursit
ursitoare
ursuz
uruit
urzici
usturoi
util
utilaj
utilat
utilizat
uzabil
uzina
uzufruct
uzurpat
vacant
vacum
vagon
valabil
vale
valet
valid
valoare
valoros
vals
valuta
vamal
vanilie
vaporizator
variabil
vast
vatman
vechi
vecie
vector
vedere
vega
vegetal
vehement
velur
venin
ventilator
venus
verb
verbal
verificat
veritabil
vermut
vernisaj
vers
vertex
vertical
vesel
vespar
vest
vestiar
vestit
veterinar
viabil
viaduct
vibrant
viciu
viclean
victorie
vierme
viespe
vigilent
viguros
vineri
violoncel
vipera
virament
virtual
visare
viscol
vital
vizibil
vizionar
vizir
vizitator
vizitiu
vizor
vizuine
vlavie
voal
vocabular
vocal
vocalist
voce
voievod
voievodat
voios
voitor
volan
volatil
volei
volt
volum
vopsea
vortex
vraci
vreasc
vrednic
vreme
vuiet
vulcan
vulgar
vulnerabil
vulpe
vulture
walkman
web
xenograf
xerox
yacht
yachting
yeti
yoga
yogin
zadar
zahar
zaharisit
zambilie
zbanghiu
zbor
zbucium
zdravan
zdrobit
zdrucit
zebra
zece
zeitate
zemos
zero
zeta
zeu
zgomot
zguduit
zgurav
ziar
ziarist
zid
zidar
zidit
zigot
zilier
zinc
zodiac
zodie
zombi
zona
zonal
zulu
zumzet

From zachgrw at gmail.com  Wed Aug  4 10:48:44 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Wed, 4 Aug 2021 12:48:44 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAGpPWDbidOBqUXHpoteAf50WXeMi392PJZmApyT8h2Gk6n1gKQ@mail.gmail.com>
References: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
 <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>
 <CAGpPWDbidOBqUXHpoteAf50WXeMi392PJZmApyT8h2Gk6n1gKQ@mail.gmail.com>
Message-ID: <CAJ4-pEAi-ooVMvJmeXhrS9J6-JVQ1jxy1On1NTQYpOSD49cbrw@mail.gmail.com>

> Ah I see, this is all limited to within a single epoch.

No, that wouldn't be useful. A maximum amount is allowed to be spent within
EVERY epoch.

Consider an epoch length of 100 blocks with a spend limit of 200k per
epoch. The following is allowed:

epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for epoch1:
80k;
epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining for
epoch1: 20k;
epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for epoch2:
40k.

Since the limit pertains to each individual epoch, it is allowed to spend
up to the full limit at the start of any new epoch. In this example, the
spending was as follows:

800140: 120k
800195: 60k
800201: 160k.

Note that in a span of 62 blocks a total of 340k sats was spent. This may
seem to violate the 200k limit per 100 blocks, but this is the result of
using a per-epoch limit. This allows a maximum of 400k to be spent in 2
blocks llke so: 200k in the last block of an epoch and another 200k in the
first block of the next epoch. However this is inconsequential for the
intended goal of rate-limiting which is to enable small spends over time
from a large amount and to prevent theft of a large amount with a single
transaction.

To explain the proposed design more clearly, I have renamed the params as
follows:

epochStart: block height of first block of the current epoch (was: h0);
epochEnd: block height of last block of the current epoch (was: h1);
limit: the maximum total amount allowed to be spent within the current
epoch (was: a);
remain: the remaining amount allowed to be spent within the current epoch
(was: a_remaining);

Also, to illustrate that the params are specific to a transaction, I will
hence precede the param with the transaction name like so:
tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.

For simplicity, only transactions with no more than one rate-limited input
are considered, and with no more than two outputs: one rate-limited change
output, and a normal (not rate-limited) output.

Normally, a simple transaction generates two outputs: one for a payment to
a third party and one for the change address. Again for simplicity, we
demand that a transaction which introduces rate-limiting must have only a
single, rate-limited output. The validation rule might be: if a transaction
has rate-limiting params and none of its inputs are rate-limited, then
there must be only a single (rate-limited) output (and no second or change
output).

Consider rate limiting transactions tx1 having one or more normal (non
rate-limited) inputs:

tx1 gets included at block height 800004;
The inputs of tx1 are not rate-limited => tx1 must have only a single
output which will become rate-limited;
params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,
tx1_remain=200k;
=> This defines that an epoch has 100 blocks and no more than 200k sats may
be spent in any one epoch. Within the current epoch, 200k sats may still be
spent.

This transaction begins to rate-limit a set of inputs, so it has a single
rate-limited output.
Let's explore transactions that have the output of tx1 as their input. I
will denote the output of tx1 as "out1".

tx2a has out1 as its only input;
tx2a spends 50k sats and gets included at block height 803050;
tx2a specifies the following params for its change output "chg2a":
chg2a_epochStart=803001, chg2a_epochEnd=803100;
chg2a_limit=200k, chg2a_remain=150k.

To enforce rate-limiting, the system must validate the params of the change
output chg2a to ensure that overspending is not allowed.

The above params are allowed because:
=> 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd -
chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]
=> 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)
=> 3. the amount spent (50k sats) does not exceed tx1_remain AND does not
exceed chg2a_limit;
=> 4. chg2a_remain" is 50k sats less than chg2a_limit.

A transaction may also further constrain further spending like so:

tx2b has out1as its only input;
tx2b spends 8k sats and gets included at block height 808105;
tx2b specifies the following params for its change output "chg2b":
chg2b_epochStart=808101, chg2b_epochEnd=808250;
chg2b_limit=10k, chg2b_remain=0.

These params are allowed because:
=> 1. the epoch does not become smaller than100 blocks. It is fine to
increase the epoch to 150 blocks because it does not enable exceeding the
original rate-limit;
=> 2. the limit (chg2b_limit) has been decreased to 10k sats, further
restricting the maximum amount allowed to be spent within the current and
any subsequent epochs;
=> 3. the amount spent (10k sats) does not exceed tx1_remain AND does not
exceed chg2b_limit;
=> 4. chg2b_remain has been set to zero, meaning that within the current
epoch (block height 808101 to and including 808250), tx2b cannot be used as
a spending input to any transaction.

Starting from block height 808251, a new epoch will start and the
rate-limited output of tx2b may again be used as an input for a subsequent
rate-limited transaction tx3b. This transaction tx3b must again be
accompanied by params that do not violate the rate-limit as defined by the
params of tx2b and which are stored with output out2b. So, the epoch of
tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent
per epoch is at most 10k sats, and chg3b_remain must be decreased by at
least the amount spent by tx3b.

>From the above, the rate-limiting mechanics should hopefully be clear and
full set of validation rules could be defined in a more generalized way
with little additional effort.

Note that I conveniently avoided talking about how to represent the
parameters within transactions or outputs, simply because I currently lack
enough understanding to reason about this. I am hoping that others may
offer help.

Zac


On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com> wrote:

> > To enable more straightforward validation logic.
> > within the current epoch
>
> Ah I see, this is all limited to within a single epoch. I think that
> sufficiently limits the window of time in which nodes have to store
> information for rate limited outputs. However, I don't see how specifying
> block ranges simplifies the logic - wouldn't this complicate the logic with
> additional user-specified constraints? It also prevents the output from
> being able to be rate limited over the span of multiple epochs, which would
> seem to make it a lot more difficult to use for certain types of wallets
> (eg cold wallets).
>
> I think I see the logic of your 'remaining' parameter there. If you start
> with a single rate-limited input, you can split that into many outputs,
> only one of which have a 'remaining' balance. The rest can simply remain
> unspendable for the rest of the epoch. That way these things don't need to
> be tied together. However, that doesn't solve the problem of 3rd parties
> being able to send money into the wallet.
>
> > I don't believe that the marginal added functionality would justify the
> increased implementation complexity
>
> Perhaps, but I think there is a lot of benefit in allowing these kinds of
> things to operate as similarly as possible to normal transactions, for one
> because of usability reasons. If each opcode has its own quirks that are
> not intuitively related to their purpose (eg if a rate-limited wallet had
> no way to get a receiving address), it would confuse end-users (eg who
> wonder how to get a receiving address and how they can ask people to send
> money into their wallet) or require a lot of technical complexity in
> applications (eg to support something like cooperatively connecting with
> their wallet so that a transaction can be made that creates a new
> single-output for the wallet). A little complexity in this opcode can save
> a lot of external complexity here I think.
>
> > my understanding of Bitcoin is way too low to be able to write a BIP and
> do the implementation
>
> You might be able to find people willing to help. I would be willing to
> help write the BIP spec. I'm not the right person to help with the
> implementation, but perhaps you could find someone else who is. Even if the
> BIP isn't adopted, it could be a starting point or inspiration for someone
> else to write an improved version.
>
> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>
>> [Note: I've moved your reply to the newly started thread]
>>
>> Hi Billy,
>>
>> Thank you for your kind and encouraging feedback.
>>
>> I don't quite understand why you'd want to define a specific span of
>>> blocks for the rate limit. Why not just specify the size of the window (in
>>> blocks) to rate limit within, and the limit?
>>
>>
>> To enable more straightforward validation logic.
>>
>> You mentioned change addresses, however, with the parameters you defined,
>>> there would be no way to connect together the change address with the
>>> original address, meaning they would have completely separate rate limits,
>>> which wouldn't work since the change output would ignore the previous rate
>>> limit.
>>
>>
>> The rate-limiting parameters must be re-specified for each rate-limited
>> input. So, a transaction that has a rate-limited input is only valid if its
>> output is itself rate-limited such that it does not violate the
>> rate-limiting constraints of its input.
>>
>> In my thread-starter, I gave the below example of a rate-limited address
>> a2 that serves as input for transaction t2:
>>
>> a2: 99.8 sats at height 800100;
>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>
>> Transaction t2:
>> Included at block height 800200
>> Spend: 400k + fees.
>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>
>> Note how transaction t2 re-specifies the rate-limiting parameters.
>> Validation must ensure that the re-specified parameters are within bounds,
>> i.e., do not allow more spending per epoch than the rate-limiting
>> parameters of its input address a2. Re-specifying the rate-limiting
>> parameters offers the flexibility to further restrict spending, or to
>> disable any additional spending within the current epoch by setting
>> a_remaining to zero.
>>
>> Result:
>> Value at destination address: 400k sats;
>> Rate limiting params at destination address: none;
>> Value at change address a3: 99.4m sats;
>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
>> a_remaining=100k.
>>
>> As a design principle I believe it makes sense if the system is able to
>> verify the validity of a transaction without having to consider any
>> transactions that precede its inputs. As a side-note, doing away with this
>> design principle would however enable more sophisticated rate-limiting
>> (such as rate-limiting per sliding window instead of rate-limiting per
>> epoch having a fixed start and end block), but while at the same time
>> reducing the size of per rate-limiting transaction (because it would enable
>> specifying the rate-limiting parameters more space-efficiently). To test
>> the waters and to keep things relatively simple, I chose not to go into
>> this enhanced form of rate-limiting.
>>
>> I haven't gone into how to process a transaction having multiple
>> rate-limited inputs. The easiest way to handle this case is to not allow
>> any transaction having more than one rate-limited input. One could imagine
>> complex logic to handle transactions having multiple rate-limited inputs by
>> creating multiple rate-limited change addresses. However at first glance I
>> don't believe that the marginal added functionality would justify the
>> increased implementation complexity.
>>
>>  I'd be interested in seeing you write a BIP for this.
>>
>>
>> Thank you, but sadly my understanding of Bitcoin is way too low to be
>> able to write a BIP and do the implementation. However I see tremendous
>> value in this functionality. Favorable feedback of the list regarding the
>> usefulness and the technical feasibility of rate-limiting functionality
>> would of course be an encouragement for me to descend further down the
>> rabbit hole.
>>
>> Zac
>>
>>
>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>
>>> [Resubmitting to list with minor edits. My previous submission ended up
>>> inside an existing thread, apologies.]
>>>
>>> Hi list,
>>>
>>> I'd like to explore whether it is feasible to implement new scripting
>>> capabilities in Bitcoin that enable limiting the output amount of a
>>> transaction based on the total value of its inputs. In other words, to
>>> implement the ability to limit the maximum amount that can be sent from an
>>> address.
>>>
>>> Two use cases come to mind:
>>>
>>> UC1: enable a user to add additional protection their funds by
>>> rate-limiting the amount that they are allowed to send during a certain
>>> period (measured in blocks). A typical use case might be a user that
>>> intends to hodl their bitcoin, but still wishes to occasionally send small
>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'
>>> funds in a single transaction, allowing the user to become aware of the
>>> theft and intervene to prevent further thefts.
>>>
>>> UC2: exchanges may wish to rate-limit addresses containing large amounts
>>> of bitcoin, adding warm- or hot-wallet functionality to a cold-storage
>>> address. This would enable an exchange to drastically reduce the number of
>>> times a cold wallet must be accessed with private keys that give access to
>>> the full amount.
>>>
>>> In a typical setup, I'd envision using multisig such that the user has
>>> two sets of private keys to their encumbered address (with a "set" of keys
>>> meaning "one or more" keys). One set of private keys allows only for
>>> sending with rate-limiting restrictions in place, and a second set of
>>> private keys allowing for sending any amount without rate-limiting,
>>> effectively overriding such restriction.
>>>
>>> The parameters that define in what way an output is rate-limited might
>>> be defined as follows:
>>>
>>> Param 1: a block height "h0" indicating the first block height of an
>>> epoch;
>>> Param 2: a block height "h1" indicating the last block height of an
>>> epoch;
>>> Param 3: an amount "a" in satoshi indicating the maximum amount that is
>>> allowed to be sent in any epoch;
>>> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
>>> amount that is allowed to be sent within the current epoch.
>>>
>>> For example, consider an input containing 100m sats (1 BTC) which has
>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,
>>> 800143, 500k, 500k). These parameters define that the address is
>>> rate-limited to sending a maximum of 500k sats in the current epoch that
>>> starts at block height 800000 and ends at height 800143 (or about one day
>>> ignoring block time variance) and that the full amount of 500k is still
>>> sendable. These rate-limiting parameters ensure that it takes at minimum
>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to
>>> spend the full 100m sats. As noted earlier, in a typical setup a user
>>> should retain the option to transact the entire amount using a second (set
>>> of) private key(s).
>>>
>>> For rate-limiting to work, any change output created by a transaction
>>> from a rate-limited address must itself be rate-limited as well. For
>>> instance, expanding on the above example, assume that the user spends 200k
>>> sats from a rate-limited address a1 containing 100m sats:
>>>
>>> Start situation:
>>> At block height 800000: rate-limited address a1 is created;
>>> Value of a1: 100.0m sats;
>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,
>>> a_remaining=500k;
>>>
>>> Transaction t1:
>>> Included at block height 800100;
>>> Spend: 200k + fee;
>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>>>
>>> Result:
>>> Value at destination address: 200k sats;
>>> Rate limiting params at destination address: none;
>>> Value at change address a2: 99.8m sats;
>>> Rate limiting params at change address a2: h0=800000, h1=800143, a=500k,
>>> a_remaining=300k.
>>>
>>> In order to properly enforce rate limiting, the change address must be
>>> rate-limited such that the original rate limit of 500k sats per 144 blocks
>>> cannot be exceeded. In this example, the change address a2 were given the
>>> same rate limiting parameters as the transaction that served as its input.
>>> As a result, from block 800100 up until and including block 800143, a
>>> maximum amount of 300k sats is allowed to be spent from the change address.
>>>
>>> Example continued:
>>> a2: 99.8 sats at height 800100;
>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>
>>> Transaction t2:
>>> Included at block height 800200
>>> Spend: 400k + fees.
>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>
>>> Result:
>>> Value at destination address: 400k sats;
>>> Rate limiting params at destination address: none;
>>> Value at change address a3: 99.4m sats;
>>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
>>> a_remaining=100k.
>>>
>>> Transaction t2 is allowed because it falls within the next epoch
>>> (running from 800144 to 800287) so a spend of 400k does not violate the
>>> constraint of 500k per epoch.
>>>
>>> As could be seen, the rate limiting parameters are part of the
>>> transaction and chosen by the user (or their wallet). This means that the
>>> parameters must be validated to ensure that they do not violate the
>>> intended constraints.
>>>
>>> For instance, this transaction should not be allowed:
>>> a2: 99.8 sats at height 800100;
>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>
>>> Transaction t2a:
>>> Included at block height 800200;
>>> Spend: 400k + fees;
>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>>>
>>> This transaction t2a attempts to shift the epoch forward by 20 blocks
>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward
>>> like this must not be allowed because it enables spending more that the
>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would
>>> enable overspending:
>>>
>>> t1: spend 200k at 800100 (epoch 1: total: 200k);
>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);
>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);
>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for epoch
>>> 2).
>>>
>>> Specifying the rate-limiting parameters explicitly at every transaction
>>> allows the user to tighten the spending limit by setting tighter limits or
>>> for instance by setting a_remainder to 0 if they wish to enforce not
>>> spending more during an epoch. A second advantage of explicitly specifying
>>> the four rate-limiting parameters with each transaction is that it allows
>>> the system to fully validate the transaction without having to consider any
>>> previous transactions within an epoch.
>>>
>>> I will stop here because I would like to gauge interest in this idea
>>> first before continuing work on other aspects. Two main pieces of work jump
>>> to mind:
>>>
>>> Define all validations;
>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof
>>> that two rate-limited addresses cannot spend more than the sum of their
>>> individual limits.
>>>
>>> Zac
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210804/d529d396/attachment-0001.html>

From lists at benappy.com  Wed Aug  4 13:28:55 2021
From: lists at benappy.com (ic)
Date: Wed, 4 Aug 2021 15:28:55 +0200
Subject: [bitcoin-dev] Bip-0039/Wordlist - Romanian
In-Reply-To: <112f5fa6-510c-8280-4f65-fbb0d41a5aa4@odm.ro>
References: <d40d7068-3b13-64ad-aef5-30210212a79c@odm.ro>
 <112f5fa6-510c-8280-4f65-fbb0d41a5aa4@odm.ro>
Message-ID: <680CB4BF-5991-4648-8DF0-78077E514482@benappy.com>

Hi,

> On 4 Aug 2021, at 12:30, Justin Valceanu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> I have created a new Romanian wordlist for Bip-0039;
> Requesting permission to push to github the attached modified files.

Although I don?t think it ?s hard requirement, it would be great if the words could be uniquely identified using the first 4 letters (most metal backup ?plates? only have space for 4 letters).

I see several occurrences of conflicting words in the first page alone.

++ ic


From s7r at sky-ip.org  Wed Aug  4 22:29:07 2021
From: s7r at sky-ip.org (s7r)
Date: Thu, 5 Aug 2021 01:29:07 +0300
Subject: [bitcoin-dev] Bip-0039/Wordlist - Romanian
In-Reply-To: <680CB4BF-5991-4648-8DF0-78077E514482@benappy.com>
References: <d40d7068-3b13-64ad-aef5-30210212a79c@odm.ro>
 <112f5fa6-510c-8280-4f65-fbb0d41a5aa4@odm.ro>
 <680CB4BF-5991-4648-8DF0-78077E514482@benappy.com>
Message-ID: <3e1f87f0-f221-6e58-acd6-4312fc8ecb9b@sky-ip.org>

ic via bitcoin-dev wrote:
> Hi,
> 
>> On 4 Aug 2021, at 12:30, Justin Valceanu via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> I have created a new Romanian wordlist for Bip-0039;
>> Requesting permission to push to github the attached modified files.
> 
> Although I don?t think it ?s hard requirement, it would be great if the words could be uniquely identified using the first 4 letters (most metal backup ?plates? only have space for 4 letters).
> 
> I see several occurrences of conflicting words in the first page alone.
> 
> ++ ic
> 


I am +1 on the unique identification using the first 4 letters, makes it 
easy for restoring from seed on mobile wallets. Don't know if this is 
really a blocker but since RO is a rich enough language in terms of 
words, this shouldn't be too hard.

Also, world list is not acceptable in this form. it should be revised by 
someone with knowledge in Romanian lexical area, I just briefly reviewed 
and:

- _adesiv_ shouldn't be *adeziv* ?

- _walkman_ - this is not a Romanian word, while it is of course 
sometimes used in Romania.

- _web_ - this is not a Romanian word, while it is of course sometimes 
used in Romania.

- _yachting_ - this is not a Romanian word and it most certainly not 
used in Romania :)) Why not use *navigatie* or something?

- _topmodel_ - it's two words merged in one

- _acvatic_ and _acvaplanare_ - they are both independent words but very 
close to each other while one is an adjective and one substantive. These 
two for example break the "no confusing words" spec.

I didn't review the entire word list and no sense to make this message 
too long, but I'm sure you see the point. Word list needs changes, 
please correct.

From justin at odm.ro  Thu Aug  5 06:16:27 2021
From: justin at odm.ro (Justin Valceanu)
Date: Thu, 5 Aug 2021 09:16:27 +0300
Subject: [bitcoin-dev] Bip-0039/Wordlist - Romanian
In-Reply-To: <3e1f87f0-f221-6e58-acd6-4312fc8ecb9b@sky-ip.org>
References: <d40d7068-3b13-64ad-aef5-30210212a79c@odm.ro>
 <112f5fa6-510c-8280-4f65-fbb0d41a5aa4@odm.ro>
 <680CB4BF-5991-4648-8DF0-78077E514482@benappy.com>
 <3e1f87f0-f221-6e58-acd6-4312fc8ecb9b@sky-ip.org>
Message-ID: <149091b4-e6a4-d2c6-4626-7801e7c385a2@odm.ro>

Hi,

@IC

There were 325 words that were not uniquely identified by the first 4 
chars. I've fixed that.

Also, simple words (* by simple I mean 4 char words *) now fill more space;

@S7R

You were right about __adesiv__ - fixed that; The other sugestions, 
_topmodel_, _walkman_, _web_, _yachting_ were also removed. Between 
_acvatic_ and _acvaplanare_ only _acvatic_ remains in the list;

I have also remove words starting with the letters _Q_, _W_, _X_ and _Y_ 
because most of the words used in Romanian were borrowed from other 
languages (mostly English, eg. web / yacht / walkman ...);

I am confident that the wordlist is now complete and correct;

Please see attached, the wordlist and some statistics about the word 
distribution.

Thanks,



Attached is the new list;

Thanks,



On 8/5/21 1:29 AM, s7r wrote:
> ic via bitcoin-dev wrote:
>> Hi,
>>
>>> On 4 Aug 2021, at 12:30, Justin Valceanu via bitcoin-dev 
>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> I have created a new Romanian wordlist for Bip-0039;
>>> Requesting permission to push to github the attached modified files.
>>
>> Although I don?t think it ?s hard requirement, it would be great if 
>> the words could be uniquely identified using the first 4 letters 
>> (most metal backup ?plates? only have space for 4 letters).
>>
>> I see several occurrences of conflicting words in the first page alone.
>>
>> ++ ic
>>
>
>
> I am +1 on the unique identification using the first 4 letters, makes 
> it easy for restoring from seed on mobile wallets. Don't know if this 
> is really a blocker but since RO is a rich enough language in terms of 
> words, this shouldn't be too hard.
>
> Also, world list is not acceptable in this form. it should be revised 
> by someone with knowledge in Romanian lexical area, I just briefly 
> reviewed and:
>
> - _adesiv_ shouldn't be *adeziv* ?
>
> - _walkman_ - this is not a Romanian word, while it is of course 
> sometimes used in Romania.
>
> - _web_ - this is not a Romanian word, while it is of course sometimes 
> used in Romania.
>
> - _yachting_ - this is not a Romanian word and it most certainly not 
> used in Romania :)) Why not use *navigatie* or something?
>
> - _topmodel_ - it's two words merged in one
>
> - _acvatic_ and _acvaplanare_ - they are both independent words but 
> very close to each other while one is an adjective and one 
> substantive. These two for example break the "no confusing words" spec.
>
> I didn't review the entire word list and no sense to make this message 
> too long, but I'm sure you see the point. Word list needs changes, 
> please correct.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bip-0039-wordlists.md
Type: text/markdown
Size: 6792 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/4b9a1b70/attachment-0001.bin>
-------------- next part --------------
abajur
abanos
abator
abces
abdomen
abecedar
abisal
abordat
abrogat
absent
absint
absolvent
abundent
aburi
acadea
acalmie
acatist
acetat
acid
aclama
acomodat
acord
acostament
acrobat
activ
actor
actualitate
acvatic
adaos
adaptabil
adeziv
adiacent
adiere
adio
adjectiv
admis
adorat
adresa
adult
adverb
aerat
aerogen
afacere
afin
afluent
agale
agent
agil
agrement
agricol
ahtiere
airbag
aiurea
ajutat
alambic
alarmat
alb
albastru
alegoric
alert
alfabet
aliaj
alibi
alifie
aligator
alint
aloe
alpin
altitudine
altruism
aluat
alun
amabil
amalgam
amant
ambrozie
amestec
ametist
amfiteatru
amfocit
amiabil
amidon
amintire
amnezie
amonte
amorf
amper
amplu
amprenta
amurg
ananas
ancestru
ancora
anexa
angajat
angelic
animal
aniversare
anonim
ansamblu
antet
antidot
antonim
antricot
anturaj
anual
aparat
apel
aperitiv
apex
apolo
apometru
apostrof
aprig
aproape
apt
aracet
aragaz
arbitru
arcas
arctic
ardei
argat
argint
argou
argument
arhaism
arhiduce
aritmic
armat
armonie
arsenal
artezian
artifact
asalt
asertiv
asfalt
asigurare
aspirator
asteroid
astro
ateneu
atestat
atlas
atletic
atomic
atractiv
audit
august
aur
autentic
autor
avans
avarie
avatar
avere
aviz
axial
axiom
azimut
azot
babic
babuin
baclava
bacon
bacterie
bagaj
balans
balcon
balet
baliza
balnear
balon
balsam
bambus
banal
banc
banda
baraj
barbaric
barion
barman
baron
basculant
basist
basm
baston
batalion
baterie
baton
bazar
bazin
bec
bej
belciug
benefic
benzen
berbec
bere
bestie
beta
beton
bezea
biban
bibelou
biceps
bici
bideu
bidon
bijutier
bilet
biliard
binar
binoclu
biolog
bioritm
biped
birjar
birou
biscuit
bistro
bitum
biuvac
bivol
bizar
bizon
blindat
blister
bloc
blond
blugi
bluza
boboc
bocanc
boem
boier
boiler
bolovan
bondar
borcan
bord
bostan
botez
brad
breaz
breloc
bretea
brici
bronz
bruiat
bruma
brutar
bucle
bufet
buget
buimac
bujor
bulbar
buldozer
buletin
bulion
bulz
burbon
buric
burlan
bursuc
bust
busuioc
butan
butic
butoi
butuc
buzunar
cabaret
cabinet
cablu
cacao
cactus
cadastru
cadet
cadou
cadru
cafea
caiac
caiet
cal
calamar
calcul
calendar
caligraf
calm
calup
camarad
camion
campus
canal
cangur
canion
canoe
canton
capac
capital
caporal
capra
capsator
captiv
carapace
carbon
cardinal
cargo
carie
carne
carou
carpatic
carte
casant
casetofon
casier
castel
cater
catod
cauciuc
cavalerie
cazan
cazino
ceai
ceas
ceaun
cedru
celest
celofan
centru
cenzor
cer
ceramic
cerb
cercel
cerdac
cerebel
cesiune
cetate
cezar
cheag
chei
cherestea
chibrit
chimic
chiot
chip
chirie
ciclism
cidru
cifru
ciment
cimpoi
cina
cinci
cinema
cinic
cioban
ciocan
ciorap
circ
citat
citit
citrus
civil
cizmar
clandestin
clar
claxon
clema
cleric
cleste
client
clima
clocot
clona
clopot
clor
club
coafor
cobalt
cocor
codex
codru
coeficient
coeziune
cofetar
cofraj
coiot
cojoc
colac
coleg
colind
color
comic
comod
compas
comunism
conac
concav
conector
confort
congelator
consul
conte
copac
copios
coral
corb
corect
corn
coroziv
corset
cort
cositor
cosmic
costum
covor
covrig
cozonac
credit
creion
creol
crevete
crin
cristal
crocodil
croitor
cronic
cruce
crupier
ctitor
cuantic
cub
cuget
cui
culinar
culme
culori
culpabil
cumin
cuptor
curaj
curcan
curea
curier
cursor
curte
cusut
cutanat
cutie
cutremur
cvorum
cyborg
dacic
dafin
dans
data
datorie
deal
debara
debit
deblocat
debut
decan
deceniu
decizie
decor
decret
defect
degaja
deget
dejun
delfin
delir
delta
demagog
demis
demon
dens
dental
depanat
depou
depus
deranj
desen
despot
detectiv
detonator
deviz
dexteritate
diabolic
diacritic
dialog
diamant
diavol
diedru
diesel
diez
difan
diferit
diftong
difuz
dig
digestie
diligent
dinar
dinozaur
dinte
diplomat
dipol
directorat
disc
dispozitiv
distribuit
divers
doctor
document
doi
dolofan
domeniu
domiciliu
dormitor
dosar
dovleac
dozaj
dragon
drapel
dren
drept
drob
drojdie
druid
drumar
dualism
dubiu
duhovnic
dulceag
dulgher
duplex
durere
echer
echipa
ecler
ecograf
ecologie
economat
ecran
ecuator
ecuson
ecvestru
edificiu
edil
editor
efect
efemer
eficace
efort
efractor
egal
elaborat
elan
elastic
electric
elefant
elegant
elementar
eleron
elev
elice
eligibil
eliminat
eliptic
elixir
elocvent
elogiat
elucidat
eluziv
emanat
embargo
emblematic
eminent
emirat
emotiv
empatic
emulsie
endomorf
energie
enigmatic
entitate
entuziast
eolian
epicentru
epidemic
epilog
episod
epitaf
epolet
epsilon
epuizat
equestru
eradicat
ereditar
ergonomic
ermetic
eroare
erou
eroziune
erudit
escalop
est
etaj
etalat
etanol
etern
etnie
etnograf
eucariot
euforie
eugenie
europa
evacua
evalua
evantai
eveniment
evident
evitat
evocat
evolua
exact
exagera
exaltat
examen
excavator
exces
excursie
executa
exod
exomorf
exotic
expat
expert
expirat
explicat
export
extaz
extins
extract
ezoteric
fabrica
fabulos
fachir
facil
factor
facultate
fagure
faima
falie
fals
familie
fandare
fanion
fanta
fapt
faraon
farfurie
faringe
farmec
fascicul
fason
fatal
fault
fauna
faur
fazan
februarie
fecior
federal
felie
femeie
feminin
fenicul
fenomen
ferbinte
fericit
ferm
feros
fertil
festival
feudal
fezabil
fiabil
fiare
fiasco
ficat
fictiv
ficus
fier
figurant
filaj
filet
film
filon
filtru
finit
fior
firav
fiscal
fisiune
fistic
fisura
fixat
flacon
flagrant
flambat
flaps
flaut
flirt
floral
fluent
fluier
fluture
fluviu
flux
focal
fochist
folie
folos
fond
fonic
foraj
forceps
formular
fortificat
fosfor
fotbal
foton
frac
frag
franjur
frasin
frate
frecvent
frenetic
freon
frigider
frizer
front
fruct
fucsia
fular
fulg
fum
funciar
fundal
funebru
fungibil
funie
furaj
furie
furnal
furou
fursec
furtun
futurism
fuziune
gabarit
gabion
galaxie
galerie
galop
gama
garaj
gard
garou
gastronom
gazetar
gazifer
gazos
geam
gelos
gem
gemut
generat
geniu
genotip
gentil
genunchi
geodezic
geoid
geometric
germen
ghemotoc
ghepard
ghicit
ghid
ghilimele
ghimpe
ghiont
ghips
ghiuden
gigafon
gimnaziast
gin
ginere
girofar
giulgiu
giuvaier
gladiator
glazura
gletuit
glisant
global
glorie
gluten
goblen
gofra
gol
golem
goliat
gonac
gonflabil
gong
gonit
gospodar
grabnic
grade
grafit
gramaj
granit
gratis
graur
gravor
grefa
greier
grenada
gresie
greutate
grifon
grind
grosolan
grozav
grupat
guler
gulie
guma
guru
gust
gutui
guvern
guvid
habar
habitat
haiduc
haihui
halat
halterofil
halucinant
hamac
hambar
hamei
hamsie
handbal
hangiu
hanorac
haos
haotic
harbuz
harnic
harpa
harta
hazard
hazliu
hectar
heliu
hexagon
hibrid
hidrant
hipiot
hipnotizat
holografic
homar
horn
horoscop
horticultor
hota
hotel
hrean
iaht
iasomie
iatagan
iaurt
iaz
ibric
iconic
idealism
identic
ideolog
idol
iedera
ieftin
ienuper
iepure
iglu
ignat
ignorat
igrasie
ilegal
iluminat
ilustrat
iluzie
imaculat
imagine
imatur
imbus
imens
iminent
imn
impas
imperiu
implant
import
imprimat
impuls
imun
inactiv
incert
incipit
incolor
indexat
indigo
industrie
inedit
infinit
informat
ingenios
inginer
inima
injust
inocent
inox
insectar
insigna
insomnie
instinct
intens
intim
intravilan
inundat
inutil
inventator
invidie
iobag
iod
ipsos
iregular
iridiu
ironic
iscusit
isoscel
iubire
iulie
iunie
ivit
izbit
izolat
izomorf
izopren
jaguar
jambon
jandarm
janta
jargon
jenat
jeton
jgheab
jnepen
joben
joc
joi
joker
jumate
junime
juriu
justificat
juvete
juxtapunere
karate
karma
katana
kelvin
kerosen
ketchup
kevlar
kilogram
kilt
kitsch
kripton
labirint
lac
lada
lambda
laminaj
lampion
lance
lansat
lapte
laser
latent
latin
lecuit
lefter
legal
lege
lemn
lemur
lenjerie
leopard
lespede
letal
levier
lexicon
leziune
liant
liber
liceu
lichior
lider
lift
ligament
lighean
lignit
limax
limba
limita
limpede
lingou
linie
lipie
literal
litigiu
livret
lizibil
locatar
locuitor
logaritm
logic
logoped
loial
lombar
longevitate
loto
lucid
lucru
lujer
luminos
lunar
lunetist
luni
lutier
luxos
lynx
macao
machiaj
macrou
maestru
mafiot
magazin
magic
magnat
mahamur
mahon
maidan
maior
majordom
majuscul
malac
malefic
mamaie
mamograf
manager
mandatar
manej
manierat
manometru
mansarda
mantra
mapamond
maraton
marcaj
margine
marinar
maro
martie
masaj
mascat
mason
master
materie
matur
mausoleu
mecanic
mecet
medalie
medie
melc
memento
memorat
menajer
meniu
mental
mercur
merge
merit
mesaj
metal
meteo
metru
miaun
microb
midie
miel
miere
miez
mijloc
mileu
miliard
milos
mima
mimetism
mina
miner
minge
minion
minte
minut
mioritic
miotrop
mirat
miriapod
miros
misionar
mistuit
mit
mitic
mitocan
mixaj
mixt
mnemonic
mobilat
mocasin
model
modificat
modul
moft
molid
moloz
moment
monarh
mondial
monitor
monolog
monstru
montan
monument
moped
mops
morar
morcov
morfologic
morman
morse
mortar
motan
motel
motiv
motor
mucegai
muget
mugur
mulat
mumie
munte
mural
murdar
murmur
musaca
mutant
muzeu
muzical
nabab
nailon
naiv
nanism
napalm
narativ
nasture
nativ
naturist
navigator
neant
nebulos
necesar
nectar
nedormit
nedumerit
negare
negociabil
negru
negustor
nelimitat
nemilos
neobosit
neon
neopren
neptun
nervos
nesemnat
nesigur
nesupus
neted
neural
neutru
nevoie
nibelung
nihilism
nimbus
nimeni
nimfa
ninsoare
nirvana
nisip
nivel
nobel
nociv
nocturn
nod
noiembrie
nomadic
nonsens
nor
nord
normal
noroc
notar
nuc
nucleu
nudism
nufar
numai
nume
numit
oaie
oameni
oarba
oaspete
oaste
obedient
obelisc
obicei
obiect
oblic
oblon
obor
obosit
obraz
obscur
obsesie
obsidian
obstacol
obtuz
ocazie
ocean
ochelari
ocolit
ocrotit
octagon
octombrie
ocult
ocupat
odaie
odihnit
odios
odorizant
ofenziv
oftat
ogar
oinar
oituz
olar
olfactiv
oligarh
olimpian
olograf
omagiu
omega
omenie
omnia
omogen
ondulat
onest
onorat
opac
opera
opiat
opinie
opozabil
oprire
optar
optic
optzeci
opulent
oracol
orar
orbital
ordin
ordonat
orez
organic
orgoliu
orguliu
orice
orient
origine
orion
orizont
ornament
ortac
ortodox
oscilant
oseminte
osmiu
osmotic
ostenit
ostil
osuar
otel
otet
otoman
oua
oxidat
oxigen
oximetru
ozana
ozon
pace
pachet
pacient
pact
pager
palid
palmier
palton
pancreas
panda
panou
pantof
papagal
papion
papuc
paradis
parbriz
parc
parfum
paritate
parlament
parter
pasaj
pasiune
paste
pateu
patine
patogen
patru
pavaj
pavea
pavilion
pecete
pedometru
pegas
peisaj
pelican
penaj
pendul
pensie
pepene
perceptiv
perdea
perete
perfect
perie
perla
permis
perplex
personaj
pescar
petrol
pianist
picant
picior
picnic
picolo
pictor
piele
piftie
pigment
pilaf
pilon
pinguin
pinion
piolet
pipa
piper
pirat
pistol
pitic
piton
pivot
placaj
plafon
plan
plasa
plat
pleonasm
plete
plex
plic
ploape
plop
plumb
plus
pod
podea
podium
poem
poezie
pogon
polar
polen
polizor
polonic
pompa
ponton
popas
popor
popular
porc
port
porumb
posesiv
post
potasiu
potent
potir
potop
poveste
pozitiv
practic
prag
praznic
preambul
precar
prefix
premolar
prenume
preot
pretabil
priceput
prieten
primit
privat
priza
proba
procent
produs
profit
program
proiect
prolific
prompt
propan
prosop
protest
provincie
prudent
prunc
pubertate
public
pudel
pudra
puf
pufulete
puhoi
puiet
pulover
pulpa
puls
pumn
punct
punte
pupic
purtat
pustnic
putere
putred
rabat
rabin
rachiu
racord
radar
radial
radon
rafinat
raft
raid
raion
raliu
rama
ramuri
randomizat
rapid
raport
rarefiat
rarisim
rastel
rateu
raton
razant
reactivat
realizat
reanimat
reaprins
rebel
rebus
recalculat
rece
rechin
recrut
rector
recursiv
redactare
redresor
redus
referat
reflux
refuz
rege
regim
reglabil
regret
regular
relax
releu
relief
remediu
remix
rentabil
renume
repaus
reper
reporter
resemnat
respins
restaurant
retoric
retras
revers
revizie
revocat
rezervor
ricin
ridicol
rigla
rima
rindea
ring
rininchi
rinocer
ritmic
ritual
rivanol
roaba
roade
robinet
robot
robust
rochie
rodaj
rodie
rom
romb
rosu
rotisor
rotor
rotula
roz
rubin
rudimentar
rugina
rulat
ruleta
rulment
rulou
rumenit
rupestru
rustic
sabie
sabot
sac
safari
safir
salam
saleu
salon
salsa
saltea
salut
salvie
samurai
sanie
sarcasm
sare
satelit
satin
saturn
scadent
scala
scaun
schi
sciatic
sclipire
scorpion
scrum
scula
scut
secat
secera
secol
secret
sector
secure
sediment
seif
seism
sejur
seleniu
semafor
senat
sensibil
senzor
sepie
septembrie
serafim
sergent
serial
sertar
sesiune
sever
sezon
sfecla
sfernic
sfinx
shogun
sibiu
sifon
sigiliu
sigma
signal
silicon
siloz
silvia
simbiot
simfonic
simplu
sincer
sindrom
sirop
sistem
smerit
smog
soare
sobru
soc
social
soclu
soia
solar
solemn
solomonar
solubil
solvabil
somelier
somon
sonar
sondaj
sonerie
sonor
sorbet
sortit
spanac
spart
spate
spectru
speolog
spic
spin
spion
spirit
spital
splina
sport
stabil
stagiar
stand
start
stativ
stea
stejar
stilou
stimulant
stivuitor
stop
storno
strat
stropitor
strug
studio
stufos
stup
sublim
subsol
subtil
suculent
sudor
sufix
sugar
sulfat
sultan
sumbru
sunet
supernatural
surcele
surplus
susan
suspect
sutien
suveran
svelt
tabel
tabiet
tabla
tabu
tachet
tacit
tactil
tahion
taifun
talaz
talcioc
talentat
talie
talon
talpa
tambur
tamponat
tanc
tandem
tangibil
tapet
taraf
tardiv
tarif
tartor
tasat
tatuaj
teanc
teatru
teflon
tegument
tejghea
telex
temelie
templu
tenace
tendon
tenor
tentant
teolog
teorie
terariu
teren
teribil
terminator
testat
texturat
tezaur
tibie
tigaie
tigru
timbru
timid
timonerie
timp
tipar
tipizat
tipografie
tiraj
titan
titlu
titular
toamna
toane
tocat
tocilar
toiag
tolerat
tomograf
ton
toner
tonomat
topor
torace
toroid
tort
totalitar
totem
toxic
trabuc
tractor
traducere
trafic
trainic
tramvai
tranzit
trapez
traseu
travaliu
treaz
trece
trei
tren
trepte
trestie
triaj
trib
tricou
trifoi
trigon
trilateral
trimestru
triumf
trivial
trofeu
troliu
trompetist
tronson
tropot
trotuar
trucaj
trunchi
trust
tsunami
tuareg
tulbure
tun
tuna
tunel
tunsoare
tupeu
turbo
turcoaz
turnir
turometru
tuse
tutore
tutun
ucenic
uger
uimit
uituc
ulcior
ulei
ulterior
ultimatum
ultracentral
uman
umbra
umed
umeri
umezit
umflat
umil
umor
uncie
unde
unghie
unicat
uniform
unit
uniune
univers
uns
unsprezece
unt
unu
uragan
uraniu
urare
urban
urcare
ureche
urgent
urmare
urnit
urs
ursit
ursuz
uruit
urzici
usturoi
util
utopie
uzabil
uzina
uzufruct
uzurpat
vacant
vacum
vagon
valabil
vale
valid
valoare
vals
valuta
vamal
vanilie
vapor
variabil
vast
vatman
veac
vechi
vecie
vector
vedere
vega
vegetal
vehement
velur
venin
ventilator
venus
verb
verde
verificat
vermut
vernisaj
vers
vertex
vesel
vespar
vest
veterinar
viabil
viaduct
vibrant
viciu
viclean
victorie
vierme
viespe
vigilent
viguros
vijelie
vineri
violet
vipera
virament
virtual
vis
visare
viscol
vital
vitraliu
vizir
vizor
vizuine
vlavie
voal
vocal
voce
voievod
voios
voitor
volan
volei
volt
volum
vopsea
vortex
vrabie
vraci
vreasc
vrednic
vreme
vuiet
vulcan
vulgar
vulnerabil
vulpe
vulture
zadar
zahar
zambilie
zbanghiu
zbor
zbucium
zdravan
zdrobit
zdrucit
zebra
zece
zeitate
zemos
zero
zeta
zeu
zgomot
zguduit
zgurav
ziar
zid
zidar
zidit
zigot
zilier
zimbru
zinc
zmeu
zodie
zombi
zona
zugrav
zulu
zumzet
-------------- next part --------------
2021-08-05 :: 09:07:05 :: 2048 Words :: Completed: 100.00% :: Ramaining 0
2021-08-05 :: 09:07:05 :: Min/Max: _alb_ (3) :: _supernatural_ (12)
2021-08-05 :: 09:07:05 :: First 4 char distict groups: 2048
2021-08-05 :: 09:07:05 :: Words with 3 characters in length :: 42 - 2.05%
2021-08-05 :: 09:07:05 :: Words with 4 characters in length :: 186 - 9.08%
2021-08-05 :: 09:07:05 :: Words with 5 characters in length :: 595 - 29.05%
2021-08-05 :: 09:07:05 :: Words with 6 characters in length :: 549 - 26.81%
2021-08-05 :: 09:07:05 :: Words with 7 characters in length :: 383 - 18.70%
2021-08-05 :: 09:07:05 :: Words with 8 characters in length :: 199 - 9.72%
2021-08-05 :: 09:07:05 :: Words with 9 characters in length :: 53 - 2.59%
2021-08-05 :: 09:07:05 :: Words with 10 characters in length :: 34 - 1.66%
2021-08-05 :: 09:07:05 :: Words with 11 characters in length :: 5 - 0.24%
2021-08-05 :: 09:07:05 :: Words with 12 characters in length :: 2 - 0.10%
2021-08-05 :: 09:07:05 :: Words starting with letter _A_ :: R 7.86% :: # of words 161
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 3 chars # 3 words (1.86%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 4 chars # 10 words (6.21%) -> 0.49% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 5 chars # 41 words (25.47%) -> 2.00% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 6 chars # 37 words (22.98%) -> 1.81% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 7 chars # 35 words (21.74%) -> 1.71% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 8 chars # 26 words (16.15%) -> 1.27% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 9 chars # 4 words (2.48%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 10 chars # 4 words (2.48%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _A_ :: 11 chars # 1 word (0.62%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _B_ :: R 5.47% :: # of words 112
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 3 chars # 2 words (1.79%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 4 chars # 11 words (9.82%) -> 0.54% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 5 chars # 44 words (39.29%) -> 2.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 6 chars # 33 words (29.46%) -> 1.61% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 7 chars # 16 words (14.29%) -> 0.78% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 8 chars # 5 words (4.46%) -> 0.24% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _B_ :: 9 chars # 1 word (0.89%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _C_ :: R 8.94% :: # of words 183
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 3 chars # 4 words (2.19%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 4 chars # 15 words (8.20%) -> 0.73% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 5 chars # 61 words (33.33%) -> 2.98% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 6 chars # 59 words (32.24%) -> 2.88% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 7 chars # 25 words (13.66%) -> 1.22% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 8 chars # 13 words (7.10%) -> 0.64% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 9 chars # 3 words (1.64%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _C_ :: 10 chars # 3 words (1.64%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _D_ :: R 4.25% :: # of words 87
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 3 chars # 2 words (2.30%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 4 chars # 8 words (9.20%) -> 0.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 5 chars # 26 words (29.89%) -> 1.27% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 6 chars # 19 words (21.84%) -> 0.93% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 7 chars # 15 words (17.24%) -> 0.73% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 8 chars # 10 words (11.49%) -> 0.49% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 9 chars # 3 words (3.45%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 10 chars # 3 words (3.45%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _D_ :: 11 chars # 1 word (1.15%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _E_ :: R 5.27% :: # of words 108
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 3 chars # 1 word (0.93%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 4 chars # 7 words (6.48%) -> 0.34% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 5 chars # 12 words (11.11%) -> 0.59% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 6 chars # 30 words (27.78%) -> 1.47% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 7 chars # 27 words (25.00%) -> 1.32% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 8 chars # 23 words (21.30%) -> 1.12% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 9 chars # 7 words (6.48%) -> 0.34% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _E_ :: 10 chars # 1 word (0.93%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _F_ :: R 5.71% :: # of words 117
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 3 chars # 1 word (0.86%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 4 chars # 12 words (10.26%) -> 0.59% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 5 chars # 38 words (32.48%) -> 1.86% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 6 chars # 31 words (26.50%) -> 1.51% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 7 chars # 20 words (17.09%) -> 0.98% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 8 chars # 12 words (10.26%) -> 0.59% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 9 chars # 2 words (1.71%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _F_ :: 10 chars # 1 word (0.86%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _G_ :: R 4.15% :: # of words 85
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 3 chars # 3 words (3.53%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 4 chars # 8 words (9.41%) -> 0.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 5 chars # 21 words (24.71%) -> 1.03% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 6 chars # 23 words (27.06%) -> 1.12% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 7 chars # 17 words (20.00%) -> 0.83% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 8 chars # 7 words (8.24%) -> 0.34% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 9 chars # 5 words (5.88%) -> 0.24% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _G_ :: 10 chars # 1 word (1.18%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _H_ :: R 1.81% :: # of words 37
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 4 chars # 3 words (8.11%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 5 chars # 10 words (27.03%) -> 0.49% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 6 chars # 13 words (35.14%) -> 0.64% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 7 chars # 5 words (13.51%) -> 0.24% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 8 chars # 1 word (2.70%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 10 chars # 4 words (10.81%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _H_ :: 11 chars # 1 word (2.70%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _I_ :: R 3.91% :: # of words 80
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 3 chars # 3 words (3.75%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 4 chars # 6 words (7.50%) -> 0.29% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 5 chars # 13 words (16.25%) -> 0.64% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 6 chars # 19 words (23.75%) -> 0.93% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 7 chars # 25 words (31.25%) -> 1.22% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 8 chars # 11 words (13.75%) -> 0.54% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 9 chars # 1 word (1.25%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _I_ :: 10 chars # 2 words (2.50%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _J_ :: R 0.93% :: # of words 19
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 3 chars # 2 words (10.53%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 5 chars # 6 words (31.58%) -> 0.29% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 6 chars # 8 words (42.11%) -> 0.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 7 chars # 1 word (5.26%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 10 chars # 1 word (5.26%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _J_ :: 11 chars # 1 word (5.26%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _K_ :: R 0.54% :: # of words 11
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 4 chars # 1 word (9.09%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 5 chars # 1 word (9.09%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 6 chars # 5 words (45.46%) -> 0.24% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 7 chars # 3 words (27.27%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _K_ :: 8 chars # 1 word (9.09%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _L_ :: R 3.13% :: # of words 64
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 3 chars # 1 word (1.56%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 4 chars # 7 words (10.94%) -> 0.34% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 5 chars # 22 words (34.38%) -> 1.07% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 6 chars # 12 words (18.75%) -> 0.59% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 7 chars # 15 words (23.44%) -> 0.73% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 8 chars # 6 words (9.38%) -> 0.29% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _L_ :: 11 chars # 1 word (1.56%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _M_ :: R 6.25% :: # of words 128
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 3 chars # 1 word (0.78%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 4 chars # 9 words (7.03%) -> 0.44% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 5 chars # 49 words (38.28%) -> 2.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 6 chars # 25 words (19.53%) -> 1.22% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 7 chars # 27 words (21.09%) -> 1.32% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 8 chars # 14 words (10.94%) -> 0.68% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 9 chars # 2 words (1.56%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _M_ :: 10 chars # 1 word (0.78%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _N_ :: R 3.03% :: # of words 62
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 3 chars # 3 words (4.84%) -> 0.15% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 4 chars # 4 words (6.45%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 5 chars # 15 words (24.19%) -> 0.73% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 6 chars # 15 words (24.19%) -> 0.73% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 7 chars # 12 words (19.36%) -> 0.59% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 8 chars # 8 words (12.90%) -> 0.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 9 chars # 4 words (6.45%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _N_ :: 10 chars # 1 word (1.61%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _O_ :: R 4.54% :: # of words 93
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 3 chars # 1 word (1.08%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 4 chars # 10 words (10.75%) -> 0.49% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 5 chars # 28 words (30.11%) -> 1.37% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 6 chars # 19 words (20.43%) -> 0.93% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 7 chars # 22 words (23.66%) -> 1.07% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 8 chars # 11 words (11.83%) -> 0.54% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _O_ :: 9 chars # 2 words (2.15%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _P_ :: R 7.81% :: # of words 160
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 3 chars # 2 words (1.25%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 4 chars # 17 words (10.63%) -> 0.83% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 5 chars # 47 words (29.38%) -> 2.30% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 6 chars # 47 words (29.38%) -> 2.30% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 7 chars # 31 words (19.38%) -> 1.51% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 8 chars # 11 words (6.88%) -> 0.54% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _P_ :: 9 chars # 5 words (3.13%) -> 0.24% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _Q_ :: R 0 :: # of words 0
2021-08-05 :: 09:07:05 :: Words starting with letter _R_ :: R 4.93% :: # of words 101
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 3 chars # 2 words (1.98%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 4 chars # 9 words (8.91%) -> 0.44% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 5 chars # 29 words (28.71%) -> 1.42% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 6 chars # 26 words (25.74%) -> 1.27% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 7 chars # 16 words (15.84%) -> 0.78% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 8 chars # 13 words (12.87%) -> 0.64% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 9 chars # 2 words (1.98%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _R_ :: 10 chars # 4 words (3.96%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _S_ :: R 6.93% :: # of words 142
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 3 chars # 2 words (1.41%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 4 chars # 11 words (7.75%) -> 0.54% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 5 chars # 49 words (34.51%) -> 2.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 6 chars # 42 words (29.58%) -> 2.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 7 chars # 24 words (16.90%) -> 1.17% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 8 chars # 8 words (5.63%) -> 0.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 9 chars # 4 words (2.82%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 10 chars # 1 word (0.70%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _S_ :: 12 chars # 1 word (0.70%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _T_ :: R 6.25% :: # of words 128
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 3 chars # 2 words (1.56%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 4 chars # 9 words (7.03%) -> 0.44% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 5 chars # 37 words (28.91%) -> 1.81% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 6 chars # 40 words (31.25%) -> 1.95% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 7 chars # 23 words (17.97%) -> 1.12% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 8 chars # 8 words (6.25%) -> 0.39% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 9 chars # 5 words (3.91%) -> 0.24% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _T_ :: 10 chars # 4 words (3.13%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _U_ :: R 2.44% :: # of words 50
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 3 chars # 4 words (8.00%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 4 chars # 9 words (18.00%) -> 0.44% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 5 chars # 12 words (24.00%) -> 0.59% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 6 chars # 16 words (32.00%) -> 0.78% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 7 chars # 4 words (8.00%) -> 0.20% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 8 chars # 2 words (4.00%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 9 chars # 1 word (2.00%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 10 chars # 1 word (2.00%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _U_ :: 12 chars # 1 word (2.00%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _V_ :: R 4.20% :: # of words 86
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 3 chars # 1 word (1.16%) -> 0.05% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 4 chars # 11 words (12.79%) -> 0.54% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 5 chars # 25 words (29.07%) -> 1.22% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 6 chars # 24 words (27.91%) -> 1.17% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 7 chars # 14 words (16.28%) -> 0.68% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 8 chars # 7 words (8.14%) -> 0.34% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 9 chars # 2 words (2.33%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _V_ :: 10 chars # 2 words (2.33%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: Words starting with letter _W_ :: R 0 :: # of words 0
2021-08-05 :: 09:07:05 :: Words starting with letter _X_ :: R 0 :: # of words 0
2021-08-05 :: 09:07:05 :: Words starting with letter _Y_ :: R 0 :: # of words 0
2021-08-05 :: 09:07:05 :: Words starting with letter _Z_ :: R 1.66% :: # of words 34
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 3 chars # 2 words (5.88%) -> 0.10% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 4 chars # 9 words (26.47%) -> 0.44% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 5 chars # 9 words (26.47%) -> 0.44% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 6 chars # 6 words (17.65%) -> 0.29% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 7 chars # 6 words (17.65%) -> 0.29% from dict
2021-08-05 :: 09:07:05 :: ::::::::::: Letter _Z_ :: 8 chars # 2 words (5.88%) -> 0.10% from dict

From billy.tetrud at gmail.com  Thu Aug  5 06:39:34 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Wed, 4 Aug 2021 23:39:34 -0700
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAJ4-pEAi-ooVMvJmeXhrS9J6-JVQ1jxy1On1NTQYpOSD49cbrw@mail.gmail.com>
References: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
 <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>
 <CAGpPWDbidOBqUXHpoteAf50WXeMi392PJZmApyT8h2Gk6n1gKQ@mail.gmail.com>
 <CAJ4-pEAi-ooVMvJmeXhrS9J6-JVQ1jxy1On1NTQYpOSD49cbrw@mail.gmail.com>
Message-ID: <CAGpPWDZNrPT9Li_neNOr3BDGdusMorWjFodNPo6YqNC3SDaf3w@mail.gmail.com>

>   A maximum amount is allowed to be spent within EVERY epoch.

It sounds like you're proposing an opcode that takes in epochStart and
epochEnd as parameters. I still don't understand why its useful to specify
those as absolute block heights. You mentioned that this enables more
straightforward validation logic, but I don't see how. Eg, if you have a
UTXO encumbered by rateLimit(epochStart = 800100, epochEnd = 800200, limit
= 100k, remain = 100k), what happens if you don't spend that UTXO before
block 800200? Is the output no longer rate limited then? Or is the opcode
calculating 800200-800100 = 100 and applying a rate limit for the next
epoch? If the first, then the UTXO must be spent within one epoch to remain
rate limited. If the second, then it seems nearly identical to simply
specifying window=100 as a parameter instead of epochStart and epochEnd.

> then there must be only a single (rate-limited) output

This rule would make transactions tricky if you're sending money into
someone else's wallet that may be rate limited. If the requirement is that
only you yourself can send money into a rate limited wallet, then this
point is moot but it would be ideal to not have such a requirement.

This is how I'd imagine creating an opcode like this:

rateLimit(windowSize = 144 blocks, limit = 100k sats)

This would define that the epoch is 1 day's worth of blocks. This would
evenly divide bitcoin's retarget period and so each window would start and
end at those dividing lines (eg the first 144 blocks of the retargetting
period, then the second, then the third, etc).

When this output is spent, it ensures that there's a maximum of 100k sats
is sent to addresses other than the originating address. It also records
the amount spent in the current 144 block window for that address (eg by
simply recording the already-spent amount on the resulting UTXO and having
an index that allows looking up UTXOs by address and adding them up). That
way, when any output from that address is spent again, if a new 144 block
window has started, the limit is reset, but if its still within the same
window, the already-spent amounts for UTXOs from that address are added up
and subtracted from the limit, and that number is the remaining limit a
subsequent transaction needs to adhere to.

This way, 3rd party could send transactions into an address like this, and
multiple outputs can be combined and used to spend to arbitrary outputs (up
to the rate limit of course).

On Wed, Aug 4, 2021 at 3:48 AM Zac Greenwood <zachgrw at gmail.com> wrote:

> > Ah I see, this is all limited to within a single epoch.
>
> No, that wouldn't be useful. A maximum amount is allowed to be spent
> within EVERY epoch.
>
> Consider an epoch length of 100 blocks with a spend limit of 200k per
> epoch. The following is allowed:
>
> epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for
> epoch1: 80k;
> epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining for
> epoch1: 20k;
> epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for
> epoch2: 40k.
>
> Since the limit pertains to each individual epoch, it is allowed to spend
> up to the full limit at the start of any new epoch. In this example, the
> spending was as follows:
>
> 800140: 120k
> 800195: 60k
> 800201: 160k.
>
> Note that in a span of 62 blocks a total of 340k sats was spent. This may
> seem to violate the 200k limit per 100 blocks, but this is the result of
> using a per-epoch limit. This allows a maximum of 400k to be spent in 2
> blocks llke so: 200k in the last block of an epoch and another 200k in the
> first block of the next epoch. However this is inconsequential for the
> intended goal of rate-limiting which is to enable small spends over time
> from a large amount and to prevent theft of a large amount with a single
> transaction.
>
> To explain the proposed design more clearly, I have renamed the params as
> follows:
>
> epochStart: block height of first block of the current epoch (was: h0);
> epochEnd: block height of last block of the current epoch (was: h1);
> limit: the maximum total amount allowed to be spent within the current
> epoch (was: a);
> remain: the remaining amount allowed to be spent within the current epoch
> (was: a_remaining);
>
> Also, to illustrate that the params are specific to a transaction, I will
> hence precede the param with the transaction name like so:
> tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.
>
> For simplicity, only transactions with no more than one rate-limited input
> are considered, and with no more than two outputs: one rate-limited change
> output, and a normal (not rate-limited) output.
>
> Normally, a simple transaction generates two outputs: one for a payment to
> a third party and one for the change address. Again for simplicity, we
> demand that a transaction which introduces rate-limiting must have only a
> single, rate-limited output. The validation rule might be: if a transaction
> has rate-limiting params and none of its inputs are rate-limited, then
> there must be only a single (rate-limited) output (and no second or change
> output).
>
> Consider rate limiting transactions tx1 having one or more normal (non
> rate-limited) inputs:
>
> tx1 gets included at block height 800004;
> The inputs of tx1 are not rate-limited => tx1 must have only a single
> output which will become rate-limited;
> params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,
> tx1_remain=200k;
> => This defines that an epoch has 100 blocks and no more than 200k sats
> may be spent in any one epoch. Within the current epoch, 200k sats may
> still be spent.
>
> This transaction begins to rate-limit a set of inputs, so it has a single
> rate-limited output.
> Let's explore transactions that have the output of tx1 as their input. I
> will denote the output of tx1 as "out1".
>
> tx2a has out1 as its only input;
> tx2a spends 50k sats and gets included at block height 803050;
> tx2a specifies the following params for its change output "chg2a":
> chg2a_epochStart=803001, chg2a_epochEnd=803100;
> chg2a_limit=200k, chg2a_remain=150k.
>
> To enforce rate-limiting, the system must validate the params of the
> change output chg2a to ensure that overspending is not allowed.
>
> The above params are allowed because:
> => 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd -
> chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]
> => 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)
> => 3. the amount spent (50k sats) does not exceed tx1_remain AND does not
> exceed chg2a_limit;
> => 4. chg2a_remain" is 50k sats less than chg2a_limit.
>
> A transaction may also further constrain further spending like so:
>
> tx2b has out1as its only input;
> tx2b spends 8k sats and gets included at block height 808105;
> tx2b specifies the following params for its change output "chg2b":
> chg2b_epochStart=808101, chg2b_epochEnd=808250;
> chg2b_limit=10k, chg2b_remain=0.
>
> These params are allowed because:
> => 1. the epoch does not become smaller than100 blocks. It is fine to
> increase the epoch to 150 blocks because it does not enable exceeding the
> original rate-limit;
> => 2. the limit (chg2b_limit) has been decreased to 10k sats, further
> restricting the maximum amount allowed to be spent within the current and
> any subsequent epochs;
> => 3. the amount spent (10k sats) does not exceed tx1_remain AND does not
> exceed chg2b_limit;
> => 4. chg2b_remain has been set to zero, meaning that within the current
> epoch (block height 808101 to and including 808250), tx2b cannot be used as
> a spending input to any transaction.
>
> Starting from block height 808251, a new epoch will start and the
> rate-limited output of tx2b may again be used as an input for a subsequent
> rate-limited transaction tx3b. This transaction tx3b must again be
> accompanied by params that do not violate the rate-limit as defined by the
> params of tx2b and which are stored with output out2b. So, the epoch of
> tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent
> per epoch is at most 10k sats, and chg3b_remain must be decreased by at
> least the amount spent by tx3b.
>
> From the above, the rate-limiting mechanics should hopefully be clear and
> full set of validation rules could be defined in a more generalized way
> with little additional effort.
>
> Note that I conveniently avoided talking about how to represent the
> parameters within transactions or outputs, simply because I currently lack
> enough understanding to reason about this. I am hoping that others may
> offer help.
>
> Zac
>
>
> On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com>
> wrote:
>
>> > To enable more straightforward validation logic.
>> > within the current epoch
>>
>> Ah I see, this is all limited to within a single epoch. I think that
>> sufficiently limits the window of time in which nodes have to store
>> information for rate limited outputs. However, I don't see how specifying
>> block ranges simplifies the logic - wouldn't this complicate the logic with
>> additional user-specified constraints? It also prevents the output from
>> being able to be rate limited over the span of multiple epochs, which would
>> seem to make it a lot more difficult to use for certain types of wallets
>> (eg cold wallets).
>>
>> I think I see the logic of your 'remaining' parameter there. If you start
>> with a single rate-limited input, you can split that into many outputs,
>> only one of which have a 'remaining' balance. The rest can simply remain
>> unspendable for the rest of the epoch. That way these things don't need to
>> be tied together. However, that doesn't solve the problem of 3rd parties
>> being able to send money into the wallet.
>>
>> > I don't believe that the marginal added functionality would justify the
>> increased implementation complexity
>>
>> Perhaps, but I think there is a lot of benefit in allowing these kinds of
>> things to operate as similarly as possible to normal transactions, for one
>> because of usability reasons. If each opcode has its own quirks that are
>> not intuitively related to their purpose (eg if a rate-limited wallet had
>> no way to get a receiving address), it would confuse end-users (eg who
>> wonder how to get a receiving address and how they can ask people to send
>> money into their wallet) or require a lot of technical complexity in
>> applications (eg to support something like cooperatively connecting with
>> their wallet so that a transaction can be made that creates a new
>> single-output for the wallet). A little complexity in this opcode can save
>> a lot of external complexity here I think.
>>
>> > my understanding of Bitcoin is way too low to be able to write a BIP
>> and do the implementation
>>
>> You might be able to find people willing to help. I would be willing to
>> help write the BIP spec. I'm not the right person to help with the
>> implementation, but perhaps you could find someone else who is. Even if the
>> BIP isn't adopted, it could be a starting point or inspiration for someone
>> else to write an improved version.
>>
>> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>
>>> [Note: I've moved your reply to the newly started thread]
>>>
>>> Hi Billy,
>>>
>>> Thank you for your kind and encouraging feedback.
>>>
>>> I don't quite understand why you'd want to define a specific span of
>>>> blocks for the rate limit. Why not just specify the size of the window (in
>>>> blocks) to rate limit within, and the limit?
>>>
>>>
>>> To enable more straightforward validation logic.
>>>
>>> You mentioned change addresses, however, with the parameters you
>>>> defined, there would be no way to connect together the change address with
>>>> the original address, meaning they would have completely separate rate
>>>> limits, which wouldn't work since the change output would ignore the
>>>> previous rate limit.
>>>
>>>
>>> The rate-limiting parameters must be re-specified for each rate-limited
>>> input. So, a transaction that has a rate-limited input is only valid if its
>>> output is itself rate-limited such that it does not violate the
>>> rate-limiting constraints of its input.
>>>
>>> In my thread-starter, I gave the below example of a rate-limited address
>>> a2 that serves as input for transaction t2:
>>>
>>> a2: 99.8 sats at height 800100;
>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>
>>> Transaction t2:
>>> Included at block height 800200
>>> Spend: 400k + fees.
>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>
>>> Note how transaction t2 re-specifies the rate-limiting parameters.
>>> Validation must ensure that the re-specified parameters are within bounds,
>>> i.e., do not allow more spending per epoch than the rate-limiting
>>> parameters of its input address a2. Re-specifying the rate-limiting
>>> parameters offers the flexibility to further restrict spending, or to
>>> disable any additional spending within the current epoch by setting
>>> a_remaining to zero.
>>>
>>> Result:
>>> Value at destination address: 400k sats;
>>> Rate limiting params at destination address: none;
>>> Value at change address a3: 99.4m sats;
>>> Rate limiting params at change address a3: h0=800144, h1=800287, a=500k,
>>> a_remaining=100k.
>>>
>>> As a design principle I believe it makes sense if the system is able to
>>> verify the validity of a transaction without having to consider any
>>> transactions that precede its inputs. As a side-note, doing away with this
>>> design principle would however enable more sophisticated rate-limiting
>>> (such as rate-limiting per sliding window instead of rate-limiting per
>>> epoch having a fixed start and end block), but while at the same time
>>> reducing the size of per rate-limiting transaction (because it would enable
>>> specifying the rate-limiting parameters more space-efficiently). To test
>>> the waters and to keep things relatively simple, I chose not to go into
>>> this enhanced form of rate-limiting.
>>>
>>> I haven't gone into how to process a transaction having multiple
>>> rate-limited inputs. The easiest way to handle this case is to not allow
>>> any transaction having more than one rate-limited input. One could imagine
>>> complex logic to handle transactions having multiple rate-limited inputs by
>>> creating multiple rate-limited change addresses. However at first glance I
>>> don't believe that the marginal added functionality would justify the
>>> increased implementation complexity.
>>>
>>>  I'd be interested in seeing you write a BIP for this.
>>>
>>>
>>> Thank you, but sadly my understanding of Bitcoin is way too low to be
>>> able to write a BIP and do the implementation. However I see tremendous
>>> value in this functionality. Favorable feedback of the list regarding the
>>> usefulness and the technical feasibility of rate-limiting functionality
>>> would of course be an encouragement for me to descend further down the
>>> rabbit hole.
>>>
>>> Zac
>>>
>>>
>>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>>
>>>> [Resubmitting to list with minor edits. My previous submission ended up
>>>> inside an existing thread, apologies.]
>>>>
>>>> Hi list,
>>>>
>>>> I'd like to explore whether it is feasible to implement new scripting
>>>> capabilities in Bitcoin that enable limiting the output amount of a
>>>> transaction based on the total value of its inputs. In other words, to
>>>> implement the ability to limit the maximum amount that can be sent from an
>>>> address.
>>>>
>>>> Two use cases come to mind:
>>>>
>>>> UC1: enable a user to add additional protection their funds by
>>>> rate-limiting the amount that they are allowed to send during a certain
>>>> period (measured in blocks). A typical use case might be a user that
>>>> intends to hodl their bitcoin, but still wishes to occasionally send small
>>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'
>>>> funds in a single transaction, allowing the user to become aware of the
>>>> theft and intervene to prevent further thefts.
>>>>
>>>> UC2: exchanges may wish to rate-limit addresses containing large
>>>> amounts of bitcoin, adding warm- or hot-wallet functionality to a
>>>> cold-storage address. This would enable an exchange to drastically reduce
>>>> the number of times a cold wallet must be accessed with private keys that
>>>> give access to the full amount.
>>>>
>>>> In a typical setup, I'd envision using multisig such that the user has
>>>> two sets of private keys to their encumbered address (with a "set" of keys
>>>> meaning "one or more" keys). One set of private keys allows only for
>>>> sending with rate-limiting restrictions in place, and a second set of
>>>> private keys allowing for sending any amount without rate-limiting,
>>>> effectively overriding such restriction.
>>>>
>>>> The parameters that define in what way an output is rate-limited might
>>>> be defined as follows:
>>>>
>>>> Param 1: a block height "h0" indicating the first block height of an
>>>> epoch;
>>>> Param 2: a block height "h1" indicating the last block height of an
>>>> epoch;
>>>> Param 3: an amount "a" in satoshi indicating the maximum amount that is
>>>> allowed to be sent in any epoch;
>>>> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
>>>> amount that is allowed to be sent within the current epoch.
>>>>
>>>> For example, consider an input containing 100m sats (1 BTC) which has
>>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,
>>>> 800143, 500k, 500k). These parameters define that the address is
>>>> rate-limited to sending a maximum of 500k sats in the current epoch that
>>>> starts at block height 800000 and ends at height 800143 (or about one day
>>>> ignoring block time variance) and that the full amount of 500k is still
>>>> sendable. These rate-limiting parameters ensure that it takes at minimum
>>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to
>>>> spend the full 100m sats. As noted earlier, in a typical setup a user
>>>> should retain the option to transact the entire amount using a second (set
>>>> of) private key(s).
>>>>
>>>> For rate-limiting to work, any change output created by a transaction
>>>> from a rate-limited address must itself be rate-limited as well. For
>>>> instance, expanding on the above example, assume that the user spends 200k
>>>> sats from a rate-limited address a1 containing 100m sats:
>>>>
>>>> Start situation:
>>>> At block height 800000: rate-limited address a1 is created;
>>>> Value of a1: 100.0m sats;
>>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,
>>>> a_remaining=500k;
>>>>
>>>> Transaction t1:
>>>> Included at block height 800100;
>>>> Spend: 200k + fee;
>>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>>>>
>>>> Result:
>>>> Value at destination address: 200k sats;
>>>> Rate limiting params at destination address: none;
>>>> Value at change address a2: 99.8m sats;
>>>> Rate limiting params at change address a2: h0=800000, h1=800143,
>>>> a=500k, a_remaining=300k.
>>>>
>>>> In order to properly enforce rate limiting, the change address must be
>>>> rate-limited such that the original rate limit of 500k sats per 144 blocks
>>>> cannot be exceeded. In this example, the change address a2 were given the
>>>> same rate limiting parameters as the transaction that served as its input.
>>>> As a result, from block 800100 up until and including block 800143, a
>>>> maximum amount of 300k sats is allowed to be spent from the change address.
>>>>
>>>> Example continued:
>>>> a2: 99.8 sats at height 800100;
>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>>
>>>> Transaction t2:
>>>> Included at block height 800200
>>>> Spend: 400k + fees.
>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>>
>>>> Result:
>>>> Value at destination address: 400k sats;
>>>> Rate limiting params at destination address: none;
>>>> Value at change address a3: 99.4m sats;
>>>> Rate limiting params at change address a3: h0=800144, h1=800287,
>>>> a=500k, a_remaining=100k.
>>>>
>>>> Transaction t2 is allowed because it falls within the next epoch
>>>> (running from 800144 to 800287) so a spend of 400k does not violate the
>>>> constraint of 500k per epoch.
>>>>
>>>> As could be seen, the rate limiting parameters are part of the
>>>> transaction and chosen by the user (or their wallet). This means that the
>>>> parameters must be validated to ensure that they do not violate the
>>>> intended constraints.
>>>>
>>>> For instance, this transaction should not be allowed:
>>>> a2: 99.8 sats at height 800100;
>>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>>
>>>> Transaction t2a:
>>>> Included at block height 800200;
>>>> Spend: 400k + fees;
>>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>>>>
>>>> This transaction t2a attempts to shift the epoch forward by 20 blocks
>>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward
>>>> like this must not be allowed because it enables spending more that the
>>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would
>>>> enable overspending:
>>>>
>>>> t1: spend 200k at 800100 (epoch 1: total: 200k);
>>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);
>>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);
>>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for
>>>> epoch 2).
>>>>
>>>> Specifying the rate-limiting parameters explicitly at every transaction
>>>> allows the user to tighten the spending limit by setting tighter limits or
>>>> for instance by setting a_remainder to 0 if they wish to enforce not
>>>> spending more during an epoch. A second advantage of explicitly specifying
>>>> the four rate-limiting parameters with each transaction is that it allows
>>>> the system to fully validate the transaction without having to consider any
>>>> previous transactions within an epoch.
>>>>
>>>> I will stop here because I would like to gauge interest in this idea
>>>> first before continuing work on other aspects. Two main pieces of work jump
>>>> to mind:
>>>>
>>>> Define all validations;
>>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof
>>>> that two rate-limited addresses cannot spend more than the sum of their
>>>> individual limits.
>>>>
>>>> Zac
>>>>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210804/ecdc6902/attachment-0001.html>

From zachgrw at gmail.com  Thu Aug  5 14:22:12 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Thu, 5 Aug 2021 16:22:12 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAGpPWDZNrPT9Li_neNOr3BDGdusMorWjFodNPo6YqNC3SDaf3w@mail.gmail.com>
References: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
 <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>
 <CAGpPWDbidOBqUXHpoteAf50WXeMi392PJZmApyT8h2Gk6n1gKQ@mail.gmail.com>
 <CAJ4-pEAi-ooVMvJmeXhrS9J6-JVQ1jxy1On1NTQYpOSD49cbrw@mail.gmail.com>
 <CAGpPWDZNrPT9Li_neNOr3BDGdusMorWjFodNPo6YqNC3SDaf3w@mail.gmail.com>
Message-ID: <CAJ4-pEByppCRQwKqkPaAMMLiqw0ZcCECuSjGZjeW529BKMAhRg@mail.gmail.com>

Hi Billy,

> It sounds like you're proposing an opcode

No. I don?t have enough knowledge of Bitcoin to be able to tell how (and
if) rate-limiting can be implemented as I suggested. I am not able to
reason about opcodes, so I kept my description at a more functional level.

> I still don't understand why its useful to specify those as absolute
block heights

I feel that this a rather uninteresting data representation aspect that?s
not worth going back and forth about. Sure, specifying the length of the
epoch may also be an option, although at the price of giving up some
functionality, and without much if any gains.

By explicitly specifying the start and end block of an epoch, the user has
more flexibility in shifting the epoch (using alternate values for
epochStart and epochEnd) and simultaneously increasing the length of an
epoch. These seem rather exotic features, but there?s no harm in retaining
them.

> if you have a UTXO encumbered by rateLimit(epochStart = 800100, epochEnd
= 800200, limit = 100k, remain = 100k), what happens if you don't spend
that UTXO before block 800200?

The rate limit remains in place. So if this UTXO is spent in block 900000,
then at most 100k may be spent. Also, the new epoch must be at least 100
blocks and remain must correctly account for the actual amount spent.

> This is how I'd imagine creating an opcode like this:

> rateLimit(windowSize = 144 blocks, limit = 100k sats)

This would require the system to bookkeep how much was spent since the
first rate-limited output. It is a more intuitive way of rate-limiting but
it may be much more difficult to implement, which is why I went with the
epoch-based rate limiting solution. In terms of functionality, I believe
the two solutions are nearly identical for all practical purposes.

Your next section confuses me. As I understand it, using an address as
input for a transaction will always spends the full amount at that address.
That?s why change addresses are required, no? If Bitcoin were able to pay
exact amounts then there wouldn?t be any need for change outputs.

Zac


On Thu, 5 Aug 2021 at 08:39, Billy Tetrud <billy.tetrud at gmail.com> wrote:

> >   A maximum amount is allowed to be spent within EVERY epoch.
>
> It sounds like you're proposing an opcode that takes in epochStart and
> epochEnd as parameters. I still don't understand why its useful to specify
> those as absolute block heights. You mentioned that this enables more
> straightforward validation logic, but I don't see how. Eg, if you have a
> UTXO encumbered by rateLimit(epochStart = 800100, epochEnd = 800200, limit
> = 100k, remain = 100k), what happens if you don't spend that UTXO before
> block 800200? Is the output no longer rate limited then? Or is the opcode
> calculating 800200-800100 = 100 and applying a rate limit for the next
> epoch? If the first, then the UTXO must be spent within one epoch to remain
> rate limited. If the second, then it seems nearly identical to simply
> specifying window=100 as a parameter instead of epochStart and epochEnd.
>
> > then there must be only a single (rate-limited) output
>
> This rule would make transactions tricky if you're sending money into
> someone else's wallet that may be rate limited. If the requirement is that
> only you yourself can send money into a rate limited wallet, then this
> point is moot but it would be ideal to not have such a requirement.
>
> This is how I'd imagine creating an opcode like this:
>
> rateLimit(windowSize = 144 blocks, limit = 100k sats)
>
> This would define that the epoch is 1 day's worth of blocks. This would
> evenly divide bitcoin's retarget period and so each window would start and
> end at those dividing lines (eg the first 144 blocks of the retargetting
> period, then the second, then the third, etc).
>
> When this output is spent, it ensures that there's a maximum of 100k sats
> is sent to addresses other than the originating address. It also records
> the amount spent in the current 144 block window for that address (eg by
> simply recording the already-spent amount on the resulting UTXO and having
> an index that allows looking up UTXOs by address and adding them up). That
> way, when any output from that address is spent again, if a new 144 block
> window has started, the limit is reset, but if its still within the same
> window, the already-spent amounts for UTXOs from that address are added up
> and subtracted from the limit, and that number is the remaining limit a
> subsequent transaction needs to adhere to.
>
> This way, 3rd party could send transactions into an address like this, and
> multiple outputs can be combined and used to spend to arbitrary outputs (up
> to the rate limit of course).
>
> On Wed, Aug 4, 2021 at 3:48 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>
>> > Ah I see, this is all limited to within a single epoch.
>>
>> No, that wouldn't be useful. A maximum amount is allowed to be spent
>> within EVERY epoch.
>>
>> Consider an epoch length of 100 blocks with a spend limit of 200k per
>> epoch. The following is allowed:
>>
>> epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for
>> epoch1: 80k;
>> epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining
>> for epoch1: 20k;
>> epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for
>> epoch2: 40k.
>>
>> Since the limit pertains to each individual epoch, it is allowed to spend
>> up to the full limit at the start of any new epoch. In this example, the
>> spending was as follows:
>>
>> 800140: 120k
>> 800195: 60k
>> 800201: 160k.
>>
>> Note that in a span of 62 blocks a total of 340k sats was spent. This may
>> seem to violate the 200k limit per 100 blocks, but this is the result of
>> using a per-epoch limit. This allows a maximum of 400k to be spent in 2
>> blocks llke so: 200k in the last block of an epoch and another 200k in the
>> first block of the next epoch. However this is inconsequential for the
>> intended goal of rate-limiting which is to enable small spends over time
>> from a large amount and to prevent theft of a large amount with a single
>> transaction.
>>
>> To explain the proposed design more clearly, I have renamed the params as
>> follows:
>>
>> epochStart: block height of first block of the current epoch (was: h0);
>> epochEnd: block height of last block of the current epoch (was: h1);
>> limit: the maximum total amount allowed to be spent within the current
>> epoch (was: a);
>> remain: the remaining amount allowed to be spent within the current epoch
>> (was: a_remaining);
>>
>> Also, to illustrate that the params are specific to a transaction, I will
>> hence precede the param with the transaction name like so:
>> tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.
>>
>> For simplicity, only transactions with no more than one rate-limited
>> input are considered, and with no more than two outputs: one rate-limited
>> change output, and a normal (not rate-limited) output.
>>
>> Normally, a simple transaction generates two outputs: one for a payment
>> to a third party and one for the change address. Again for simplicity, we
>> demand that a transaction which introduces rate-limiting must have only a
>> single, rate-limited output. The validation rule might be: if a transaction
>> has rate-limiting params and none of its inputs are rate-limited, then
>> there must be only a single (rate-limited) output (and no second or change
>> output).
>>
>> Consider rate limiting transactions tx1 having one or more normal (non
>> rate-limited) inputs:
>>
>> tx1 gets included at block height 800004;
>> The inputs of tx1 are not rate-limited => tx1 must have only a single
>> output which will become rate-limited;
>> params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,
>> tx1_remain=200k;
>> => This defines that an epoch has 100 blocks and no more than 200k sats
>> may be spent in any one epoch. Within the current epoch, 200k sats may
>> still be spent.
>>
>> This transaction begins to rate-limit a set of inputs, so it has a single
>> rate-limited output.
>> Let's explore transactions that have the output of tx1 as their input. I
>> will denote the output of tx1 as "out1".
>>
>> tx2a has out1 as its only input;
>> tx2a spends 50k sats and gets included at block height 803050;
>> tx2a specifies the following params for its change output "chg2a":
>> chg2a_epochStart=803001, chg2a_epochEnd=803100;
>> chg2a_limit=200k, chg2a_remain=150k.
>>
>> To enforce rate-limiting, the system must validate the params of the
>> change output chg2a to ensure that overspending is not allowed.
>>
>> The above params are allowed because:
>> => 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd
>> - chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]
>> => 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)
>> => 3. the amount spent (50k sats) does not exceed tx1_remain AND does not
>> exceed chg2a_limit;
>> => 4. chg2a_remain" is 50k sats less than chg2a_limit.
>>
>> A transaction may also further constrain further spending like so:
>>
>> tx2b has out1as its only input;
>> tx2b spends 8k sats and gets included at block height 808105;
>> tx2b specifies the following params for its change output "chg2b":
>> chg2b_epochStart=808101, chg2b_epochEnd=808250;
>> chg2b_limit=10k, chg2b_remain=0.
>>
>> These params are allowed because:
>> => 1. the epoch does not become smaller than100 blocks. It is fine to
>> increase the epoch to 150 blocks because it does not enable exceeding the
>> original rate-limit;
>> => 2. the limit (chg2b_limit) has been decreased to 10k sats, further
>> restricting the maximum amount allowed to be spent within the current and
>> any subsequent epochs;
>> => 3. the amount spent (10k sats) does not exceed tx1_remain AND does not
>> exceed chg2b_limit;
>> => 4. chg2b_remain has been set to zero, meaning that within the current
>> epoch (block height 808101 to and including 808250), tx2b cannot be used as
>> a spending input to any transaction.
>>
>> Starting from block height 808251, a new epoch will start and the
>> rate-limited output of tx2b may again be used as an input for a subsequent
>> rate-limited transaction tx3b. This transaction tx3b must again be
>> accompanied by params that do not violate the rate-limit as defined by the
>> params of tx2b and which are stored with output out2b. So, the epoch of
>> tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent
>> per epoch is at most 10k sats, and chg3b_remain must be decreased by at
>> least the amount spent by tx3b.
>>
>> From the above, the rate-limiting mechanics should hopefully be clear and
>> full set of validation rules could be defined in a more generalized way
>> with little additional effort.
>>
>> Note that I conveniently avoided talking about how to represent the
>> parameters within transactions or outputs, simply because I currently lack
>> enough understanding to reason about this. I am hoping that others may
>> offer help.
>>
>> Zac
>>
>>
>> On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com>
>> wrote:
>>
>>> > To enable more straightforward validation logic.
>>> > within the current epoch
>>>
>>> Ah I see, this is all limited to within a single epoch. I think that
>>> sufficiently limits the window of time in which nodes have to store
>>> information for rate limited outputs. However, I don't see how specifying
>>> block ranges simplifies the logic - wouldn't this complicate the logic with
>>> additional user-specified constraints? It also prevents the output from
>>> being able to be rate limited over the span of multiple epochs, which would
>>> seem to make it a lot more difficult to use for certain types of wallets
>>> (eg cold wallets).
>>>
>>> I think I see the logic of your 'remaining' parameter there. If you
>>> start with a single rate-limited input, you can split that into many
>>> outputs, only one of which have a 'remaining' balance. The rest can simply
>>> remain unspendable for the rest of the epoch. That way these things don't
>>> need to be tied together. However, that doesn't solve the problem of 3rd
>>> parties being able to send money into the wallet.
>>>
>>> > I don't believe that the marginal added functionality would justify
>>> the increased implementation complexity
>>>
>>> Perhaps, but I think there is a lot of benefit in allowing these kinds
>>> of things to operate as similarly as possible to normal transactions, for
>>> one because of usability reasons. If each opcode has its own quirks that
>>> are not intuitively related to their purpose (eg if a rate-limited wallet
>>> had no way to get a receiving address), it would confuse end-users (eg who
>>> wonder how to get a receiving address and how they can ask people to send
>>> money into their wallet) or require a lot of technical complexity in
>>> applications (eg to support something like cooperatively connecting with
>>> their wallet so that a transaction can be made that creates a new
>>> single-output for the wallet). A little complexity in this opcode can save
>>> a lot of external complexity here I think.
>>>
>>> > my understanding of Bitcoin is way too low to be able to write a BIP
>>> and do the implementation
>>>
>>> You might be able to find people willing to help. I would be willing to
>>> help write the BIP spec. I'm not the right person to help with the
>>> implementation, but perhaps you could find someone else who is. Even if the
>>> BIP isn't adopted, it could be a starting point or inspiration for someone
>>> else to write an improved version.
>>>
>>> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>>
>>>> [Note: I've moved your reply to the newly started thread]
>>>>
>>>> Hi Billy,
>>>>
>>>> Thank you for your kind and encouraging feedback.
>>>>
>>>> I don't quite understand why you'd want to define a specific span of
>>>>> blocks for the rate limit. Why not just specify the size of the window (in
>>>>> blocks) to rate limit within, and the limit?
>>>>
>>>>
>>>> To enable more straightforward validation logic.
>>>>
>>>> You mentioned change addresses, however, with the parameters you
>>>>> defined, there would be no way to connect together the change address with
>>>>> the original address, meaning they would have completely separate rate
>>>>> limits, which wouldn't work since the change output would ignore the
>>>>> previous rate limit.
>>>>
>>>>
>>>> The rate-limiting parameters must be re-specified for each rate-limited
>>>> input. So, a transaction that has a rate-limited input is only valid if its
>>>> output is itself rate-limited such that it does not violate the
>>>> rate-limiting constraints of its input.
>>>>
>>>> In my thread-starter, I gave the below example of a rate-limited
>>>> address a2 that serves as input for transaction t2:
>>>>
>>>> a2: 99.8 sats at height 800100;
>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>>
>>>> Transaction t2:
>>>> Included at block height 800200
>>>> Spend: 400k + fees.
>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>>
>>>> Note how transaction t2 re-specifies the rate-limiting parameters.
>>>> Validation must ensure that the re-specified parameters are within bounds,
>>>> i.e., do not allow more spending per epoch than the rate-limiting
>>>> parameters of its input address a2. Re-specifying the rate-limiting
>>>> parameters offers the flexibility to further restrict spending, or to
>>>> disable any additional spending within the current epoch by setting
>>>> a_remaining to zero.
>>>>
>>>> Result:
>>>> Value at destination address: 400k sats;
>>>> Rate limiting params at destination address: none;
>>>> Value at change address a3: 99.4m sats;
>>>> Rate limiting params at change address a3: h0=800144, h1=800287,
>>>> a=500k, a_remaining=100k.
>>>>
>>>> As a design principle I believe it makes sense if the system is able to
>>>> verify the validity of a transaction without having to consider any
>>>> transactions that precede its inputs. As a side-note, doing away with this
>>>> design principle would however enable more sophisticated rate-limiting
>>>> (such as rate-limiting per sliding window instead of rate-limiting per
>>>> epoch having a fixed start and end block), but while at the same time
>>>> reducing the size of per rate-limiting transaction (because it would enable
>>>> specifying the rate-limiting parameters more space-efficiently). To test
>>>> the waters and to keep things relatively simple, I chose not to go into
>>>> this enhanced form of rate-limiting.
>>>>
>>>> I haven't gone into how to process a transaction having multiple
>>>> rate-limited inputs. The easiest way to handle this case is to not allow
>>>> any transaction having more than one rate-limited input. One could imagine
>>>> complex logic to handle transactions having multiple rate-limited inputs by
>>>> creating multiple rate-limited change addresses. However at first glance I
>>>> don't believe that the marginal added functionality would justify the
>>>> increased implementation complexity.
>>>>
>>>>  I'd be interested in seeing you write a BIP for this.
>>>>
>>>>
>>>> Thank you, but sadly my understanding of Bitcoin is way too low to be
>>>> able to write a BIP and do the implementation. However I see tremendous
>>>> value in this functionality. Favorable feedback of the list regarding the
>>>> usefulness and the technical feasibility of rate-limiting functionality
>>>> would of course be an encouragement for me to descend further down the
>>>> rabbit hole.
>>>>
>>>> Zac
>>>>
>>>>
>>>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com>
>>>> wrote:
>>>>
>>>>> [Resubmitting to list with minor edits. My previous submission ended
>>>>> up inside an existing thread, apologies.]
>>>>>
>>>>> Hi list,
>>>>>
>>>>> I'd like to explore whether it is feasible to implement new scripting
>>>>> capabilities in Bitcoin that enable limiting the output amount of a
>>>>> transaction based on the total value of its inputs. In other words, to
>>>>> implement the ability to limit the maximum amount that can be sent from an
>>>>> address.
>>>>>
>>>>> Two use cases come to mind:
>>>>>
>>>>> UC1: enable a user to add additional protection their funds by
>>>>> rate-limiting the amount that they are allowed to send during a certain
>>>>> period (measured in blocks). A typical use case might be a user that
>>>>> intends to hodl their bitcoin, but still wishes to occasionally send small
>>>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'
>>>>> funds in a single transaction, allowing the user to become aware of the
>>>>> theft and intervene to prevent further thefts.
>>>>>
>>>>> UC2: exchanges may wish to rate-limit addresses containing large
>>>>> amounts of bitcoin, adding warm- or hot-wallet functionality to a
>>>>> cold-storage address. This would enable an exchange to drastically reduce
>>>>> the number of times a cold wallet must be accessed with private keys that
>>>>> give access to the full amount.
>>>>>
>>>>> In a typical setup, I'd envision using multisig such that the user has
>>>>> two sets of private keys to their encumbered address (with a "set" of keys
>>>>> meaning "one or more" keys). One set of private keys allows only for
>>>>> sending with rate-limiting restrictions in place, and a second set of
>>>>> private keys allowing for sending any amount without rate-limiting,
>>>>> effectively overriding such restriction.
>>>>>
>>>>> The parameters that define in what way an output is rate-limited might
>>>>> be defined as follows:
>>>>>
>>>>> Param 1: a block height "h0" indicating the first block height of an
>>>>> epoch;
>>>>> Param 2: a block height "h1" indicating the last block height of an
>>>>> epoch;
>>>>> Param 3: an amount "a" in satoshi indicating the maximum amount that
>>>>> is allowed to be sent in any epoch;
>>>>> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
>>>>> amount that is allowed to be sent within the current epoch.
>>>>>
>>>>> For example, consider an input containing 100m sats (1 BTC) which has
>>>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,
>>>>> 800143, 500k, 500k). These parameters define that the address is
>>>>> rate-limited to sending a maximum of 500k sats in the current epoch that
>>>>> starts at block height 800000 and ends at height 800143 (or about one day
>>>>> ignoring block time variance) and that the full amount of 500k is still
>>>>> sendable. These rate-limiting parameters ensure that it takes at minimum
>>>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to
>>>>> spend the full 100m sats. As noted earlier, in a typical setup a user
>>>>> should retain the option to transact the entire amount using a second (set
>>>>> of) private key(s).
>>>>>
>>>>> For rate-limiting to work, any change output created by a transaction
>>>>> from a rate-limited address must itself be rate-limited as well. For
>>>>> instance, expanding on the above example, assume that the user spends 200k
>>>>> sats from a rate-limited address a1 containing 100m sats:
>>>>>
>>>>> Start situation:
>>>>> At block height 800000: rate-limited address a1 is created;
>>>>> Value of a1: 100.0m sats;
>>>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,
>>>>> a_remaining=500k;
>>>>>
>>>>> Transaction t1:
>>>>> Included at block height 800100;
>>>>> Spend: 200k + fee;
>>>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>>>>>
>>>>> Result:
>>>>> Value at destination address: 200k sats;
>>>>> Rate limiting params at destination address: none;
>>>>> Value at change address a2: 99.8m sats;
>>>>> Rate limiting params at change address a2: h0=800000, h1=800143,
>>>>> a=500k, a_remaining=300k.
>>>>>
>>>>> In order to properly enforce rate limiting, the change address must be
>>>>> rate-limited such that the original rate limit of 500k sats per 144 blocks
>>>>> cannot be exceeded. In this example, the change address a2 were given the
>>>>> same rate limiting parameters as the transaction that served as its input.
>>>>> As a result, from block 800100 up until and including block 800143, a
>>>>> maximum amount of 300k sats is allowed to be spent from the change address.
>>>>>
>>>>> Example continued:
>>>>> a2: 99.8 sats at height 800100;
>>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>>>
>>>>> Transaction t2:
>>>>> Included at block height 800200
>>>>> Spend: 400k + fees.
>>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>>>
>>>>> Result:
>>>>> Value at destination address: 400k sats;
>>>>> Rate limiting params at destination address: none;
>>>>> Value at change address a3: 99.4m sats;
>>>>> Rate limiting params at change address a3: h0=800144, h1=800287,
>>>>> a=500k, a_remaining=100k.
>>>>>
>>>>> Transaction t2 is allowed because it falls within the next epoch
>>>>> (running from 800144 to 800287) so a spend of 400k does not violate the
>>>>> constraint of 500k per epoch.
>>>>>
>>>>> As could be seen, the rate limiting parameters are part of the
>>>>> transaction and chosen by the user (or their wallet). This means that the
>>>>> parameters must be validated to ensure that they do not violate the
>>>>> intended constraints.
>>>>>
>>>>> For instance, this transaction should not be allowed:
>>>>> a2: 99.8 sats at height 800100;
>>>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k,
>>>>> a_remaining=300k;
>>>>>
>>>>> Transaction t2a:
>>>>> Included at block height 800200;
>>>>> Spend: 400k + fees;
>>>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>>>>>
>>>>> This transaction t2a attempts to shift the epoch forward by 20 blocks
>>>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward
>>>>> like this must not be allowed because it enables spending more that the
>>>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would
>>>>> enable overspending:
>>>>>
>>>>> t1: spend 200k at 800100 (epoch 1: total: 200k);
>>>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);
>>>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);
>>>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for
>>>>> epoch 2).
>>>>>
>>>>> Specifying the rate-limiting parameters explicitly at every
>>>>> transaction allows the user to tighten the spending limit by setting
>>>>> tighter limits or for instance by setting a_remainder to 0 if they wish to
>>>>> enforce not spending more during an epoch. A second advantage of explicitly
>>>>> specifying the four rate-limiting parameters with each transaction is that
>>>>> it allows the system to fully validate the transaction without having to
>>>>> consider any previous transactions within an epoch.
>>>>>
>>>>> I will stop here because I would like to gauge interest in this idea
>>>>> first before continuing work on other aspects. Two main pieces of work jump
>>>>> to mind:
>>>>>
>>>>> Define all validations;
>>>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof
>>>>> that two rate-limited addresses cannot spend more than the sum of their
>>>>> individual limits.
>>>>>
>>>>> Zac
>>>>>
>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/55d5d18c/attachment-0001.html>

From sjors at sprovoost.nl  Thu Aug  5 14:27:12 2021
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Thu, 5 Aug 2021 16:27:12 +0200
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
Message-ID: <38AE919F-7EA2-4CF4-9AF8-7E38C7542C59@sprovoost.nl>

Thanks for writing this up!

I think your modular BIP approach makes sense. (the abstract should mention this too)

Contents look good to me, modulo missing test vectors. I also suggest dropping combo(), see below.


Regarding the use of h vs ', especially since they result in a different checksum, and equality is more tedious to verify, should we just pick one and recommend that software normalises to that?

For bip-descriptors-segwit, regardless of what Bitcoin Core does, is any hex encoded script allowed for wsh()? If so is it mandatory and/or allowed to use raw() as a sub descriptor?

Conversely, its BIP says: "The <tt>raw(HEX)</tt> expression can only be used as a top level descriptor". That answers the above, but not the why.

In the backwards compatibility section it may be worth pointing out that descriptors are also used by:
* Specter since at least v1.2.2: https://github.com/cryptoadvance/specter-desktop/releases/tag/v1.2.2
* Coldcard since 2.0.1: https://github.com/Coldcard/firmware/commit/af00f8778947664f2d74f19879b98f7925feb327
* HWI since 1.0.3: https://github.com/bitcoin-core/HWI/releases/tag/1.0.3

None of these support the tr(), raw() and addr() descriptors afaik. HWI doesn't implement (sorted_)multi.

Does anyone actually use combo? It seems useless, because even with the help of BIP 88 there's no way to compress all three in a single descriptor, since BIP 44/49/84 each have a different derivation. Afaik Bitcoin Core doesn't really use them either. And for future wallet migration, we might as well make separate descriptors for each key type.

One thing on my wish list - for this BIP, BIP 88 (Hierarchical Deterministic Path Templates) or yet another one - is to include a birth date (minimum block height). E.g. tr([m/86'/0'/0']xpub.../{0-1}/*)>709631

And then of course there's the gap limit. Perhaps we just need a "metadata" format to go along with descriptors to track the birth data, gap limit and anything else you need (nonce collection for musig2 setup?). E.g. a simple dictionary: tr([m/86'/0'/0']xpub.../{0-1}/*){dob:709631,gap:1000}

- Sjors


> Op 29 jun. 2021, om 23:14 heeft Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> Hi All,
> 
> I've been working on formalizing the Output Script Descriptors that have
> been available in Bitcoin Core for a while into BIPs. Since descriptors
> are modular and have optional components, I've decided to split it into
> 7 BIPs, rather than a single one. The first describes descriptors in
> general and does not specify any particular descriptor. However it does
> describe the general operation, key expressions (including derivation
> paths and key origin info), and the descriptor checksum. The following 6
> BIPs specify the actual descriptors themselves. These are non-segwit
> descriptor (pk, pkh, sh), segwit descriptors (wpkh, wsh), multisig
> descriptors (multi, sortedmulti), the taproot descriptor (tr), the combo
> descriptor, and opaque descriptors (raw, addr). This separation is so
> that implementors can choose to not implement some descriptors and still
> say which descriptors they support without being too difficult to
> understand.
> 
> The text of all of the documents are below, and they can also be found
> on github:https://github.com/achow101/bips/tree/descriptors/
> 
> Thanks,
> Andrew Chow
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-general
>   Layer: Applications
>   Title: Output Script Descriptors General Operation
>   Author: Pieter Wuille <pieter at wuille.net>
>           Andrew Chow <andrew at achow101.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-general
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> Output Script Descriptors are a simple language which can be used to
> describe collections ofoutput scripts.
> There can be many different descriptor fragments and functions.
> This document describes the general syntax for descriptors, descriptor
> checksums, and common expressions.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> Bitcoin wallets traditionally have stored a set of keys which are later
> serialized and mutated to produce the output scripts that the wallet
> watches and the addresses it provides to users.
> Typically backups have consisted of solely the private keys, nowadays
> primarily in the form of BIP 39 mnemonics.
> However this backup solution is insuffient, especially since the
> introduction of Segregated Witness which added new output types.
> Given just the private keys, it is not possible for restored wallets to
> know which kinds of output scripts and addresses to produce.
> This has lead to incompatibilities between wallets when restoring a
> backup or exporting data for a watch only wallet.
> 
> Further complicating matters are BIP 32 derivation paths.
> Although BIPs 44, 49, and 84 have specified standard BIP 32 derivation
> paths for different output scripts and addresses, not all wallets
> support them nor use those derivation paths.
> The lack of derivation path information in these backups and exports
> leads to further incompatibilities between wallets.
> 
> Current solutions to these issues have not been generic and can be
> viewed as being layer violations.
> Solutions such as introducing different version bytes for extended key
> serialization both are a layer violation (key derivation should be
> separate from script type meaning) and specific only to a particular
> derivation path and script type.
> 
> Output Script Descriptors introduces a generic solution to these issues.
> Script types are specified explicitly through the use of Script Expressions.
> Key derivation paths are specified explicitly in Key Expressions.
> These allow for creating wallet backups and exports which specify the
> exact scripts, subscripts (redeemScript, witnessScript, etc.), and keys
> to produce.
> With the general structure specified in this BIP, new Script Expressions
> can be introduced as new script types are added.
> Lastly, the use of common terminology and existing standards allow for
> Output Script Descriptors to be engineer readable so that the results
> can be understood at a glance.
> 
> ==Specification==
> 
> Descriptors consist of several types of expressions.
> The top level expression is a <tt>SCRIPT</tt>.
> This expression may be followed by <tt>#CHECKSUM</tt>, where
> <tt>CHECKSUM</tt> is an 8 character alphanumeric descriptor checksum.
> 
> ===Script Expressions===
> 
> Script Expressions (denoted <tt>SCRIPT</tt>) are expressions which
> correspond directly with a Bitcoin script.
> These expressions are written as functions and take arguments.
> Such expressions have a script template which is filled with the
> arguments correspondingly.
> Expressions are written with a human readable identifier string with the
> arguments enclosed with parentheses.
> The identifier string should be alphanumeric and may include underscores.
> 
> The arguments to a script expression are defined by that expression itself.
> They could be a script expression, a key expression, or some other
> expression entirely.
> 
> ===Key Expressions===
> 
> A common expression used as an argument to script expressions are key
> expressions (denoted <tt>KEY</tt>).
> These represent a public or private key and, optionally, information
> about the origin of that key.
> Key expressions can only be used as arguments to script expressions.
> 
> Key expressions consist of:
> * Optionally, key origin information, consisting of:
> ** An open bracket <tt>[</tt>
> ** Exactly 8 hex characters for the fingerprint of the key where the
> derivation starts (see BIP 32 for details)
> ** Followed by zero or more <tt>/NUM</tt> or <tt>/NUM'</tt>  path
> elements to indicate the unhardened or hardened derivation steps between
> the fingerprint and the key that follows.
> ** A closing bracket <tt>]</tt>
> * Followed by the actual key, which is either:
> ** A hex encoded public key, which depending the script expression, may
> be either:
> *** 66 hex character string beginning with <tt>02</tt> or <tt>03</tt>
> representing a compressed public key
> *** 130 hex character string beginning with <tt>04</tt> representing an
> uncompressed public key
> *** 64 hex character string representing an x-only public key
> ** A [[https://en.bitcoin.it/wiki/Wallet_import_format|WIF]] encoded
> private key
> ** <tt>xpub</tt> encoded extended public key or <tt>xprv</tt> encoded
> extended private key (as defined in BIP 32)
> *** Followed by zero or more <tt>/NUM</tt> or <tt>/NUM'</tt> path
> elements indicating BIP 32 derivation steps to be taken after the given
> extended key.
> *** Optionally followed by a single <tt>/*</tt> or <tt>/*'</tt> final
> step to denote all direct unhardened or hardened children.
> 
> If the <tt>KEY</tt> is a BIP 32 extended key, before output scripts can
> be created, child keys must be derived using the derivation information
> that follows the extended key.
> When the final step is <tt>/*</tt> or <tt>/*'</tt>, an output script
> will be produced for every child key index.
> The derived key must be serialized as a compressed public key.
> 
> In the above specification, the hardened indicator <tt>'</tt> may be
> replaced with alternative hardnened indicators of <tt>h</tt> or <tt>H</tt>.
> 
> ===Character Set===
> 
> The expressions used in descriptors must only contain characters within
> this character set so that the descriptor checksum will work.
> 
> The allowed characters are:
> <pre>
> 0123456789()[],'/*abcdefgh@:$%{}
> IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~
> ijklmnopqrstuvwxyzABCDEFGH`#"\<space>
> </pre>
> Note that <tt><space></tt> on the last line is a space character.
> 
> This character set is written as 3 groups of 32 characters in this
> specific order so that the checksum below can identify more errors.
> The first group are the most common "unprotected" characters (i.e.
> things such as hex and keypaths that do not already have their own
> checksums).
> Case errors cause an offset that is a multiple of 32 while as many
> alphabetic characters are in the same group while following the previous
> restrictions.
> 
> ===Checksum===
> 
> Follwing the top level script expression is a single octothorpe
> (<tt>#</tt>) followed by the 8 character checksum.
> The checksum is an error correcting checksum similar to bech32.
> 
> The checksum has the following properties:
> * Mistakes in a descriptor string are measured in "symbol errors". The
> higher the number of symbol errors, the harder it is to detect:
> ** An error substituting a character from
> <tt>0123456789()[],'/*abcdefgh@:$%{}</tt> for another in that set always
> counts as 1 symbol error.
> *** Note that hex encoded keys are covered by these characters. Extended
> keys (<tt>xpub</tt> and <tt>xprv</tt>) use other characters too, but
> also have their own checksum mechansim.
> *** <tt>SCRIPT</tt> expression function names use other characters, but
> mistakes in these would generally result in an unparsable descriptor.
> ** A case error always counts as 1 symbol error.
> ** Any other 1 character substitution error counts as 1 or 2 symbol errors.
> * Any 1 symbol error is always detected.
> * Any 2 or 3 symbol error in a descriptor of up to 49154 characters is
> always detected.
> * Any 4 symbol error in a descriptor of up to 507 characters is always
> detected.
> * Any 5 symbol error in a descriptor of up to 77 characters is always
> detected.
> * Is optimized to minimize the chance of a 5 symbol error in a
> descriptor up to 387 characters is undetected
> * Random errors have a chance of 1 in 2<super>40</super> of being
> undetected.
> 
> The checksum itself uses the same character set as bech32:
> <tt>qpzry9x8gf2tvdw0s3jn54khce6mua7l</tt>
> 
> Valid descriptor strings with a checksum must pass the criteria for
> validity specified by the Python3 code snippet below.
> The function <tt>descsum_check</tt> must return true when its argument
> <tt>s</tt> is a descriptor consisting in the form <tt>SCRIPT#CHECKSUM</tt>.
> 
> <pre>
> INPUT_CHARSET =
> "0123456789()[],'/*abcdefgh@:$%{}IJKLMNOPQRSTUVWXYZ&+-.;<=>?!^_|~ijklmnopqrstuvwxyzABCDEFGH`#\"\\
> "
> CHECKSUM_CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"
> GENERATOR = [0xf5dee51989, 0xa9fdca3312, 0x1bab10e32d, 0x3706b1677a,
> 0x644d626ffd]
> 
> def descsum_polymod(symbols):
>     """Internal function that computes the descriptor checksum."""
>     chk = 1
>     for value in symbols:
>         top = chk >> 35
>         chk = (chk & 0x7ffffffff) << 5 ^ value
>         for i in range(5):
>             chk ^= GENERATOR[i] if ((top >> i) & 1) else 0
>     return chk
> 
> def descsum_expand(s):
>     """Internal function that does the character to symbol expansion"""
>     groups = []
>     symbols = []
>     for c in s:
>         if not c in INPUT_CHARSET:
>             return None
>         v = INPUT_CHARSET.find(c)
>         symbols.append(v & 31)
>         groups.append(v >> 5)
>         if len(groups) == 3:
>             symbols.append(groups[0] * 9 + groups[1] * 3 + groups[2])
>             groups = []
>     if len(groups) == 1:
>         symbols.append(groups[0])
>     elif len(groups) == 2:
>         symbols.append(groups[0] * 3 + groups[1])
>     return symbols
> 
> def descsum_check(s):
>     """Verify that the checksum is correct in a descriptor"""
>     if s[-9] != '#':
>         return False
>     if not all(x in CHECKSUM_CHARSET for x in s[-8:]):
>         return False
>     symbols = descsum_expand(s[:-9]) + [CHECKSUM_CHARSET.find(x) for x
> in s[-8:]]
>     return descsum_polymod(symbols) == 1
> </pre>
> 
> This implements a BCH code that has the properties described above.
> The entire descriptor string is first processed into an array of symbols.
> The symbol for each character is its position within its group.
> After every 3rd symbol, a 4th symbol is inserted which represents the
> group numbers combined together.
> This means that a change that only affects the position within a group,
> or only a group number change, will only affect a single symbol.
> 
> To construct a valid checksum given a script expression, the code below
> can be used:
> 
> <pre>
> def descsum_create(s):
>     """Add a checksum to a descriptor without"""
>     symbols = descsum_expand(s) + [0, 0, 0, 0, 0, 0, 0, 0]
>     checksum = descsum_polymod(symbols) ^ 1
>     return s + '#' + ''.join(CHECKSUM_CHARSET[(checksum >> (5 * (7 -
> i))) & 31] for i in range(8))
> 
> </pre>
> 
> ==Backwards Compatibility==
> 
> Output script descriptors are an entirely new language which is not
> compatible with any existing software.
> However many components of the expressions reuse encodings and
> serializations defined by previous BIPs.
> 
> Output script descriptors are designed for future extension with further
> fragment types and new script expressions.
> These will be specified in additional BIPs.
> 
> ==Reference Implemntation==
> 
> Descriptors have been implemented in Bitcoin Core since version 0.17.
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-segwit
>   Layer: Applications
>   Title: segwit Output Script Descriptors
>   Author: Pieter Wuille <pieter at wuille.net>
>           Andrew Chow <andrew at achow101.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-segwit
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies <tt>wpkh()</tt>, and <tt>wsh()</tt> output
> script descriptors.
> <tt>wpkh()</tt> descriptors take a key and produces a P2WPKH output script.
> <tt>wsh()</tt> descriptors take a script and produces a P2WSH output script.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> Segregated Witness added 2 additional standard output script formats:
> P2WPKH and P2WSH.
> These expressions allow specifying those formats as a descriptor.
> 
> ==Specification==
> 
> Two new script expressions are defined: <tt>wpkh()</tt>, and <tt>wsh()</tt>.
> 
> ===<tt>wpkh()</tt>===
> 
> The <tt>wpkh(KEY)</tt> expression can be used as a top level expression,
> or inside of a <tt>sh()</tt> descriptor.
> It takes a single key expression as an argument and produces a P2WPKH
> output script.
> Only keys which are/has compressed public keys can be contained in a
> <tt>wpkh()</tt> expression.
> 
> The output script produced is:
> <pre>
> OP_0 <KEY_hash160>
> </pre>
> 
> ===<tt>wsh()</tt>===
> 
> The <tt>wsh(SCRIPT)</tt> expression can be used as a top level
> expression, or inside of a <tt>sh()</tt> descriptor.
> It takes a single script expression as an argument and produces a P2WSH
> output script.
> <tt>wsh()</tt> expressions also create a witnessScript which is required
> in order to spend outputs which use its output script.
> This redeemScript is the output script produced by the <tt>SCRIPT</tt>
> argument to <tt>wsh()</tt>.
> Any key expression found in any script expression contained by a
> <tt>wsh()</tt> expression must only produce compresed public keys.
> 
> The output script produced is:
> <pre>
> OP_0 <SCRIPT_sha256>
> </pre>
> 
> ==Test Vectors==
> 
> TBD
> 
> ==Backwards Compatibility==
> 
> <tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors use the format and
> general operation specified in
> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
> As these are a wholly new descriptors, they are not compatible with any
> implementation.
> However the scripts produced are standard scripts so existing software
> are likely to be familiar with them.
> 
> ==Reference Implemntation==
> 
> <tt>wpkh()</tt>, and <tt>wsh()</tt> descriptors have been implemented in
> Bitcoin Core since version 0.17.
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-non-segwit
>   Layer: Applications
>   Title: Non-segwit Output Script Descriptors
>   Author: Pieter Wuille <pieter at wuille.net>
>           Andrew Chow <andrew at achow101.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-non-segwit
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt>
> output script descriptors.
> <tt>pk()</tt> descriptors take a key and produces a P2PK output script.
> <tt>pkh()</tt> descriptors take a key and produces a P2PKH output script.
> <tt>sh()</tt> descriptors take a script and produces a P2SH output script.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> Prior to the activation of Segregated Witness, there were 3 main
> standard output script formats: P2PK, P2PKH, and P2SH.
> These expressions allow specifying those formats as a descriptor.
> 
> ==Specification==
> 
> Three new script expressions are defined: <tt>pk()</tt>, <tt>pkh()</tt>,
> and <tt>sh()</tt>.
> 
> ===<tt>pk()</tt>===
> 
> The <tt>pk(KEY)</tt> expression can be used in any context or level of a
> descriptor.
> It takes a single key expression as an argument and produces a P2PK
> output script.
> Depending on the higher level descriptors, there may be restrictions on
> the type of public keys that can be included.
> Such restrictions will be specified by those descriptors.
> 
> The output script produced is:
> <pre>
> <KEY> OP_CHECKSIG
> </pre>
> 
> ===<tt>pkh()</tt>===
> 
> The <tt>pkh(KEY)</tt> expression can be used as a top level expression,
> or inside of either a <tt>sh()</tt> or <tt>wsh()</tt> descriptor.
> It takes a single key expression as an argument and produces a P2PKH
> output script.
> Depending on the higher level descriptors, there may be restrictions on
> the type of public keys that can be included.
> Such restrictions will be specified by those descriptors.
> 
> The output script produced is:
> <pre>
> OP_DUP OP_HASH160 <KEY_hash160> OP_EQUALVERIFY OP_CHECKSIG
> </pre>
> 
> ===<tt>sh()</tt>===
> 
> The <tt>sh(SCRIPT)</tt> expression can only be used as a top level
> expression.
> It takes a single script expression as an argument and produces a P2SH
> output script.
> <tt>sh()</tt> expressions also create a redeemScript which is required
> in order to spend outputs which use its output script.
> This redeemScript is the output script produced by the <tt>SCRIPT</tt>
> argument to <tt>sh()</tt>.
> 
> The output script produced is:
> <pre>
> OP_HASH160 <SCRIPT_hash160> OP_EQUAL
> </pre>
> 
> ==Test Vectors==
> 
> TBD
> 
> ==Backwards Compatibility==
> 
> <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors use the
> format and general operation specified in
> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
> As these are a wholly new descriptors, they are not compatible with any
> implementation.
> However the scripts produced are standard scripts so existing software
> are likely to be familiar with them.
> 
> ==Reference Implemntation==
> 
> <tt>pk()</tt>, <tt>pkh()</tt>, and <tt>sh()</tt> descriptors have been
> implemented in Bitcoin Core since version 0.17.
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-tr
>   Layer: Applications
>   Title: tr() Output Script Descriptors
>   Author: Pieter Wuille <pieter at wuille.net>
>           Andrew Chow <andrew at achow101.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-tr
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies <tt>tr()</tt> output script descriptors.
> <tt>tr()</tt> descriptors take a key and optionally a tree of scripts
> and produces a P2TR output script.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> Taproot added one additional standard output script format: P2TR.
> These expressions allow specifying those formats as a descriptor.
> 
> ==Specification==
> 
> A new script expressions are defined: <tt>tr()</tt>.
> A new expression is defined: Tree Expressions
> 
> ===Tree Expression===
> 
> A Tree Expression (denoted <tt>TREE</tt>) is an expression which
> represents a tree of scripts.
> The way the tree is represented in an output script is dependent on the
> higher level expressions.
> 
> A Tree Expression is:
> * Any Script Expression that is allowed at the level this Tree
> Expression is in.
> * A pair of Tree Expressions consisting of:
> ** An open brace <tt>{</tt>
> ** A Tree Expression
> ** A comma <tt>,</tt>
> ** A Tree Expression
> ** A closing brance <tt>}</tt>
> 
> ===<tt>tr()</tt>===
> 
> The <tt>tr(KEY)</tt> or <tt>tr(KEY, TREE)</tt> expression can only be
> used as a top level expression.
> All key expressions under any <tt>tr()</tt> expression must create
> x-only public keys.
> 
> <tt>tr(KEY</tt> takes a single key expression as an argument and
> produces a P2TR output script which does not have a script path.
> The keys produced by the key expression are used as the internal key as
> specified by [[bip-0341.mediawiki#cite_ref-22-0|BIP 341]].
> Specifically, "If the spending conditions do not require a script path,
> the output key should commit to an unspendable script path instead of
> having no script path.
> This can be achieved by computing the output key point as ''Q = P +
> int(hash<sub>TapTweak</sub>(bytes(P)))G''."
> 
> <pre>
> internal_key:       lift_x(KEY)
> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)))G
> scriptPubKey:       OP_1 <32_byte_output_key>
> </pre>
> 
> <tt>tr(KEY, TREE)</tt> takes a key expression as the first argument, and
> a tree expression as the second argument and produces a P2TR output
> script which has a script path.
> The keys produced by the first key expression are used as the internal
> key as specified by
> [[bip-0341.mediawiki#Constructing_and_spending_Taproot_outputs|BIP 341]].
> The Tree expression becomes the Taproot script tree as described in BIP 341.
> A merkle root is computed from this tree and combined with the internal
> key to create the Taproot output key.
> 
> <pre>
> internal_key:       lift_x(KEY)
> merkle_root:        HashTapBranch(TREE)
> 32_byte_output_key: internal_key + int(HashTapTweak(bytes(internal_key)
> || merkle_root))G
> scriptPubKey:       OP_1 <32_byte_output_key>
> </pre>
> 
> ==Test Vectors==
> 
> TBD
> 
> ==Backwards Compatibility==
> 
> <tt>tr()</tt> descriptors use the format and general operation specified
> in [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
> As these are a wholly new descriptors, they are not compatible with any
> implementation.
> However the scripts produced are standard scripts so existing software
> are likely to be familiar with them.
> 
> Tree Expressions are largely incompatible with existing script
> expressions due to the restrictions in those expressions.
> As of 2021-06-27, the only allowed script expression that can be used in
> a tree expression is <tt>pk()</tt>.
> However there will be future BIPs that specify script expressions that
> can be used in tree expressions.
> 
> ==Reference Implemntation==
> 
> <tt>tr()</tt> descriptors have been implemented in Bitcoin Core since
> version 22.0.
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-multi
>   Layer: Applications
>   Title: Multisig Output Script Descriptors
>   Author: Pieter Wuille <pieter at wuille.net>
>           Andrew Chow <andrew at achow101.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-multi
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies <tt>multi()</tt>, and <tt>sortedmulti()</tt>
> output script descriptors.
> Both functions take a threshold and one or more public keys and produce
> a multisig output script.
> <tt>multi()</tt> specifies the public keys in the output script in the
> order given in the descriptor while <tt>sortedmulti()</tt> sorts the
> public keys lexicographically when the output script is produced.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> The most common complex script used in Bitcoin is a threshold multisig.
> These expressions allow specifying multisig scripts as a descriptor.
> 
> ==Specification==
> 
> Two new script expressions are defined: <tt>multi()</tt>, and
> <tt>sortedmulti()</tt>.
> Both expressions produce the scripts of the same template and take the
> same arguments.
> They are written as <tt>multi(k,KEY_1,KEY_2,...,KEY_n)</tt>.
> <tt>k</tt> is the threshold - the number of keys that must sign the
> input for the script to be valid.
> <tt>KEY_1,KEY_2,...,KEY_n</tt> are the key expressions for the multisig.
> <tt>k</tt> must be less than or equal to <tt>n<tt>.
> 
> <tt>multi()</tt> and <tt>sortedmulti()</tt> expressions can be used as a
> top level expression, or inside of either a <tt>sh()</tt> or
> <tt>wsh()</tt> descriptor.
> Depending on the higher level descriptors, there may be restrictions on
> the type of public keys that can be included.
> 
> Depending on the higher level descriptors, there are also restrictions
> on the number of keys that can be present, i.e. the maximum value of
> <tt>n</tt>.
> When used at the top level, there can only be at most 3 keys.
> When used inside of a <tt>sh()</tt> expression, there can only be most
> 15 compressed public keys (this is limited by the P2SH script limit).
> Otherwise the maximum number of keys is 20.
> 
> The output script produced also depends on the value of <tt>k</tt>. If
> <tt>k</tt> is less than or equal to 16:
> <pre>
> OP_k KEY_1 KEY_2 ... KEY_n OP_CHECKMULTISIG
> </pre>
> 
> if <tt>k</tt> is greater than 16:
> <pre>
> k KEY_1 KEY_2 ... KEY_n OP_CHECKMULTISIG
> </pre>
> 
> ===<tt>sortedmulti()</tt>===
> 
> The only change for <tt>sortedmulti()</tt> is that the keys are sorted
> lexicographically prior to the creation of the output script.
> This sorting is on the keys that are to be put into the output script,
> i.e. after all extended keys are derived.
> 
> ===Multiple Extended Keys</tt>===
> 
> When one or more the key expressions in a <tt>multi()</tt> or
> <tt>sortedmulti()</tt> expression are extended keys, the derived keys
> use the same child index.
> This changes the keys in lockstep and allows for output scripts to be
> indexed in the same way that the derived keys are indexed.
> 
> ==Test Vectors==
> 
> TBD
> 
> ==Backwards Compatibility==
> 
> <tt>multi()</tt>, and <tt>sortedmulti()</tt> descriptors use the format
> and general operation specified in
> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
> As these are a wholly new descriptors, they are not compatible with any
> implementation.
> However the scripts produced are standard scripts so existing software
> are likely to be familiar with them.
> 
> ==Reference Implemntation==
> 
> <tt>multi()</tt>, and <tt>multi()</tt> descriptors have been implemented
> in Bitcoin Core since version 0.17.
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-combo
>   Layer: Applications
>   Title: combo() Output Script Descriptors
>   Author: Pieter Wuille <pieter at wuille.net>
>           Andrew Chow <andrew at achow101.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-combo
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies <tt>combo()</tt> output script descriptors.
> These take a key and produce P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH output
> scripts if applicable to the key.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> In order to make the transition from traditional key based wallets to
> descriptor based wallets easier, it is useful to be able to take a key
> and produce the scripts which have traditionally been produced by wallet
> software.
> 
> ==Specification==
> 
> A new top level script expression is defined: <tt>combo(KEY)</tt>.
> This expression can only be used as a top level expression.
> It takes a single key expression as an argument and produces either 2 or
> 4 output scripts, depending on the key.
> A <tt>combo()</tt> expression always produces a P2PK and P2PKH script,
> the same as putting the key in both a <tt>pk()</tt> and a <tt>pkh()</tt>
> expression.
> If the key is/has a compressed public key, then P2WPKH and P2SH-P2WPKH
> scripts are also produced, the same as putting the key in both a
> <tt>wpkh()</tt> and <tt>sh(wpkh())</tt> expression.
> 
> ==Test Vectors==
> 
> TBD
> 
> ==Backwards Compatibility==
> 
> <tt>combo()</tt> descriptors use the format and general operation
> specified in [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
> As this is a wholly new descriptor, it is not compatible with any
> implementation.
> However the scripts produced are standard scripts so existing software
> are likely to be familiar with them.
> 
> ==Reference Implemntation==
> 
> <tt>combo</tt> descriptors have been implemented in Bitcoin Core since
> version 0.17.
> 
> ---
> 
> <pre>
>   BIP: bip-descriptors-encap
>   Layer: Applications
>   Title: raw() and addr() Output Script Descriptors
>   Author: Andrew Chow <andrew at achow101.com>
>           Pieter Wuille <pieter at wuille.net>
>   Comments-Summary: No comments yet.
>   Comments-URI:
> https://github.com/bitcoin/bips/wiki/Comments:BIP-descriptors-raw
>   Status: Draft
>   Type: Informational
>   Created: 2021-06-27
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This document specifies <tt>raw()</tt> and <tt>addr()</tt> output script
> descriptors.
> <tt>raw()</tt> encapsulates a raw script as a descriptor.
> <tt>addr()</tt> encapsulates an address as a descriptor.
> 
> ==Copyright==
> 
> This BIP is licensed under the BSD 2-clause license.
> 
> ==Motivation==
> 
> In order to make descriptors maximally compatible with scripts in use
> today, it is useful to be able to wrap any arbitrary output script or an
> address into a descriptor.
> 
> ==Specification==
> 
> Two new script expressions are defined: <tt>raw()</tt> and <tt>addr()</tt>.
> 
> ===<tt>raw()</tt>===
> 
> The <tt>raw(HEX)</tt> expression can only be used as a top level descriptor.
> As the argument, it takes a hex string representing a Bitcoin script.
> The output script produced by this descriptor is the script represented
> by <tt>HEX</tt>.
> 
> ===<tt>addr()</tt>===
> 
> The <tt>addr(ADDR)</tt> expression can only be used as a top level
> descriptor.
> It takes an address as its single argument.
> The output script produced by this descriptor is the output script
> produced by the address <tt>ADDR</tt>.
> 
> ==Test Vectors==
> 
> TBD
> 
> ==Backwards Compatibility==
> 
> <tt>raw()</tt> and <tt>addr()</tt> descriptors use the format and
> general operation specified in
> [[bip-descriptor-general.mediawiki|bip-descriptor-general]].
> As this is a wholly new descriptor, it is not compatible with any
> implementation.
> The reuse of existing Bitcoin addresses allows for this to be more
> easily implemented.
> 
> ==Reference Implemntation==
> 
> <tt>raw()</tt> and <tt>addr</tt> descriptors have been implemented in
> Bitcoin Core since version 0.17.
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/d32d322c/attachment-0001.sig>

From ChristopherA at lifewithalacrity.com  Thu Aug  5 20:49:43 2021
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Thu, 5 Aug 2021 13:49:43 -0700
Subject: [bitcoin-dev] BIP Proposals for Output Script Descriptors
In-Reply-To: <38AE919F-7EA2-4CF4-9AF8-7E38C7542C59@sprovoost.nl>
References: <1eb7b635-094c-a583-7dc0-21cea58ed1fb@achow101.com>
 <38AE919F-7EA2-4CF4-9AF8-7E38C7542C59@sprovoost.nl>
Message-ID: <CACrqygAVreg0ALPeg50vrHB+J=X6quUaEyGv9ia5WgDQzDL10A@mail.gmail.com>

On Thu, Aug 5, 2021 at 8:07 AM Sjors Provoost via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> One thing on my wish list - for this BIP, BIP 88 (Hierarchical
> Deterministic Path Templates) or yet another one - is to include a birth
> date (minimum block height). E.g. tr([m/86'/0'/0']xpub.../{0-1}/*)>709631
>
> And then of course there's the gap limit. Perhaps we just need a
> "metadata" format to go along with descriptors to track the birth data, gap
> limit and anything else you need (nonce collection for musig2 setup?). E.g.
> a simple dictionary: tr([m/86'/0'/0']xpub.../{0-1}/*){dob:709631,gap:1000}
>

The UR standards we use in Airgap Wallet Community for interoperability
(currently used by a number of recent wallets for airgap PSBT via animated
QR) leverages CBOR's tagging capability, and thus explicitly supports
metadata. In particular the spec reference code support optional seed
birthdate as some wallet vendors really wanted that metadata.

It would be trivial to support it for hd-keys, and if gap is important, we
could also easily add this to the hd-keys spec as well. That is part of the
reason why use CBOR for the underlying binary encoding is tagging lets
us add important metadata. The UR standards themselves adds to binary CBOR
encoding a very efficient transport via QRs or URLs that leverage native QR
compression.

See:
* Video: [Blockchain Commons Technology Overview](
https://www.youtube.com/watch?v=RYgOFSdUqWY)
* Articles: [URs: An Overview](Docs/ur-1-overview.md)
  * [A Guide to Using URs for Key Material](Docs/ur-2-keys.md)
  *[A Guide to Using URs for SSKRs](Docs/ur-3-sskrs.md)**
  * [A Guide to Using UR Request & Response](Docs/ur-99-request-response.md)
* Specs:
  * [Research 2020-05 - Uniform Resources (UR): Encoding Structured Binary
Data for Transport in URIs and QR Codes](
https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-005-ur.md
)
  * [Reserach 2020 - UR Type Definition for Hierarchical Deterministic (HD)
Keys](
https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-007-hdkey.md
)

If you have questions about these, drop by the Airgapped Wallet Community
on GitHub at https://github.com/BlockchainCommons/Airgapped-Wallet-Community

-- Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210805/9bc986ff/attachment.html>

From raymo at riseup.net  Sun Aug  8 09:11:42 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Sun, 08 Aug 2021 02:11:42 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <6016816a7ea36b8a88f48d69462d0308@riseup.net>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
 <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
 <6016816a7ea36b8a88f48d69462d0308@riseup.net>
Message-ID: <0555e82561666007e7ce367e3a204f53@riseup.net>

Fine tuning Sabu in order to minimize the protocol risks

After representing Sabu protocol 
here
(https://raymo-49157.medium.com/time-to-boost-bitcoin-circulation-million-transactions-per-second-and-privacy-1eef8568d180)

and answer some comments and critics here
(https://raymo-49157.medium.com/scaling-bitcoin-by-sabu-protocol-risks-and-benefits-62157f8a664e),

I dedicated some days to tuning the Sabu transaction criteria in order
to reduce the risks either for issuers or creditors. After that fine
tuning, most of risks were decreased dramatically. In this post I?ll
represent these details. For whom may forget about how Sabu protocol
work, the core points are repeated for concept recall.

Why should we use Sabu protocol?
The main goal of Sabu is ?boosting Bitcoin C2C circulation? by
distributing it between far more people. The protocol incentivizes the
small Bitcoin owners (people who has a tenth of Bitcoin or less) to sell
few Satoshi (4 or 5 dollar or so) in person with no KYC due to Bitcoin
ethos and earn small transaction fees for each transaction. This
movement will end up to 10x or more bigger Bitcoin users, which
definitely improves Bitcoin?s community and its proper ecosystem.

How Bitcoin transaction work?
Owning Bitcoin, means having some UTXO (recorded in Bitcoin blockchain)
under your control. That is, you can sign that UTXO to prove you are the
legitimate owner of that money. Thus, if you want to spend your
Bitcoins, you create a transaction by which sign your under-controlled
UTXO(s) and represent your desire to transfer this ownership to the
other person. This transaction is a document that issued by you and
provides a legitimate order for this money transfer. In order to execute
this money transfer, you need to broadcast your signed document to
Bitcoin network aimed to record it in Bitcoin blockchain, otherwise, no
money transfer has taken place. After recording this transaction in
Bitcoin blockchain, the transfer is settled and "everyone" will be aware
of the new owner(s) of that particular spent coins.

How Sabu protocol work?
You -as a UTXO owner- are an "issuer", and always can issue a document
(AKA transaction) by which you represent your will to transfer some of
your UTXOs to others. Thus, Sabu is a non-custodial protocol. As long as
this debt document is not registered in the Bitcoin blockchain, it is
nothing more than a liability, i.e., you owe some Bitcoins to someone
else. That guy naming her/him "creditor" payed money to you or provided
goods or services for you, in exchange of this debt-document. Thus s/he
has a copy of this transaction in her/his wallet. The issuer or creditor
always can send this transaction to Bitcoin blockchain network aimed to
record this money transformation in Bitcoin blockchain, or keep this
transaction in wallet. But due to the high transaction fee on the
Bitcoin blockchain and the insignificance of the amount transferred (a
few Dollars), they will not send the document to the Bitcoin network,
instead prefers to use this document as a payment method and exchange
these documents in Sabu protocol and in an off-chain manner.
When the creditor wants to spend his money, his wallet will send a
request to the issuer?s wallet and ask it to transfer the issuer?s
liability to another creditor. The issuer prepares a new transaction in
which issuer owes the new creditor(s), and delivers this new transaction
to both old and new creditors.
The issuers earn small Sabu-transaction-fee per each money transfer (one
or two Sat per transaction). Millions of issuers and creditors are
exchanging these documents (transactions) in a peer-to-peer network
continually, with no central authority. There is no blockchain nor
public ledger.
After each dealing, the issuer cancels the old transaction and creates a
new document, and updates the creditor balances. These documents will be
in circulation between issuers and creditors in the Sabu network forever
meanwhile less than one percent of these transactions will be recorded
on the Bitcoin blockchain.
Either issuers or creditors in order to use Sabu protocol need to
install Sabu mobile wallet (called Gazin) and start to deal. That is all
they need. No technical skill or extra cost needed.

How Sabu prevents frauds?
The main mechanism of the system against fraud is the un-profitability
of fraud in terms of economic benefits. In other words, all of malicious
activities will end up in losing money of attacker.
In short, the Sabu anti-fraud system works like that. The issuer always
creates and signs a transaction pair.  The Main Transaction which
represents the real amount of outputs. And the Guarantee Transaction
which pays relatively higher Bitcoin-transaction-fee. This fee increment
is obtained by cutting from the issuer and creditor outputs in Main
Transaction.
Check out this simple transaction to learn more about how the system
works.
Consider Alice as an issuer. She owns a UTXO worth 20,000 Satoshi. So,
she can spend it by create a transaction and sign it and broadcast it to
Bitcoin network.
Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys 12,000
Satoshi from Alice in exchange.
Alice gets this 5$ and prepare a Main transaction that represents this
liability of Alice to Bob.

Main Transaction (20,000 Sat input):
* Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000, but Bob
has to pay 3,000 as BTC fee)
* Alice (issuer): 6,000 Sat
* BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)
This is a valid transaction and both Bob and/or Alice can send it to
Bitcoin network, but none of them are interested in doing so. Because
they will lose 5,000 Satoshi of their own money as Bitcoin transaction
fee.

Alongside this transaction Alice (the issuer) has to create the
Guarantee Transaction as well and deliver it to Bob. Otherwise, Bob will
not consider the deal completed. The Guarantee Transaction is another
valid Bitcoin transaction. It is created based on Main Transaction and
will cut a part of Bob and Alice money in favor of transaction fee.

Guarantee Transaction (20,000 Sat input):
* Bob (creditor): 9,000 ? 80.77%*9,000 = 9,000 ? 7,260 = 1,740 Sat
* Alice (issuer): 6,000 ? 58%*6,000 = 6,000 ? 3,480 = 2,520 Sat
* BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260 (from
Bob) + 3,480 (from Al-ice) = 15,739 Sat

The Guarantee Transaction applies when the issuer does not live up to
its promise and intends to spend the promised UTXO(s) in a way other
than that agreed upon. We already knew the fact that Sabu is not a
custodial solution, neither a M of N signature schema. As a result, the
UTXO owner always can spend the already promised UTXO(s) in Sabu
protocol or out of Sabu on Bitcoin blockchain, Contrary to what was
promised.
When the Alice (issuer) breaks such a promise and sends the fraudulent
transaction to the Bitcoin network, Bob's wallet realizes that she
(issuer) is spending the promised UTXO(s) and it sends the Guarantee
Transaction(s) to the network as a last resort. The miners will face two
(or more) transactions which are spending same UTXO(s), but one of them
is paying notably higher Bitcoin transaction fee, thus they chose the
highest fee payer transaction, which is the Guarantee Transaction. The
miner will put the Guarantee Transaction in next block and reject the
rest double-spend transactions. Certainly, poor Bob cannot recoup all
his Satoshis. But he can retrieve a portion of his money and forces
Alice to lose some of her money as well. tit for tat!
Because of this mechanism, the issuer will try to not cheat on creditor.

By the way there are some attacks that have very small chance to succeed
but the risk to reward ratio for these scenarios are too high to be
considered as a real possible attack threat. I will review them a little
later in this post.

What are the advantages of Sabu over Lightning?
There are four benefits to using Sabu.
Cost: In Sabu unlike Lightning, the transaction parties do not need to
open a channel and consequently they do not need to close it. Therefore,
they do not need to pay Bitcoin transaction fees two times. The
transaction parties will pay small Sabu-transaction-fee per each
transaction to the issuer because of creating and signing new
transaction. Every Sabu user can be an issuer (something like Lightning
node) and earn Bitcoin because of issuing credit liability document
(pretty much like banks).

Ease of use:  All a user needs to use protocol is install wallet -called
Gazin- on mobile or desktop by one click. The user can be an issuer and
issue transactions or be a creditor and buys Bitcoin or both
simultaneously. Users can then transfer their money to each other in
Sabu network. Every Sabu user can be a creditor and buy some Satoshi
from issuer and spend it in small shopping. It seems that Bitcoiners can
finally buy coffee with Bitcoin without worrying about transaction fee
or system scalability or even recording transaction forever on Bitcoin
blockchain.

Privacy: Since the communication between nodes is PGP encrypted, and no
transaction will go to record on Bitcoin blockchain, the Sabu protocol
provides a strong privacy for transaction parties. Except sender and
receiver, no one will know how much Bitcoin between who was transferred.
Billions of micro transfers will be scattered between thousands of nodes
without no central control point and no transaction history recording
and absolutely no KYC.

Scalability: Since the Sabu has no routing overhead and peers use the
direct communication it will be more scalable than Lightning.

New criteria:
-	Each transaction input must be 20,000 Satoshi or more.
-	Maximum liability in a single transaction would be 15,000 Satoshi. 14k
for creditor whose credit is more than 1k, so he is eligible to have
both MT & GT in his wallet, and 1k for the creditor without the right of
having MT & GT due to his small amount of credit.
-	The maximum transaction fee (for Bitcoin blockchain) for Main
Transaction is 5,000 Satoshi. For transaction with liability less than
4,000 Satoshi this fee would be less than 5,000 Satoshi relatively.
-	In Guarantee Transaction the issuer loses 1% to 68% of his output in
favor of Bitcoin transaction fee depends to the liability amount. More
liability more loss.
-	In Guarantee Transaction the creditor loses 100% to 78% of his output
in favor of Bitcoin transaction fee in reverse of the credit amount.
More credit less loss.
-	The transaction fee (for Bitcoin blockchain) for Guarantee Transaction
would be transaction fee of Main Transaction plus 100% to 78% of
creditor?s output plus 1% to 68% of issuer?s output.
-	The issuer has to issue both Main Transaction and Guarantee
transaction and deliver them to creditor.

Both issuer and creditor (sender and receiver) control these criteria
before confirm the deal.

Fraudulent activities risk:

The griefers, - people who willing to spend time and money hurting
someone else, even if they don't make a profit from it (other than
schadenfreude). - still can hurt himself and the other party
simultaneously, but the damage amount is reduced dramatically.
The lowest amount that a griefer as a creditor can lose is 1,000 Satoshi
to hurt the issuer 685 Satoshi (loss ratio 1.45), and the highest amount
is losing 11,506 Satoshi to hurt issuer 4,720 Satoshi (loss ratio 2.43).
In any case, a griefer still has trouble finding big number of victims,
since the protocol is not centralized and the user?s information is
scattered among thousands of different nodes.

How can prevent the issuer from spending UTXO in a cheating way?
There are two possible scenarios for fraudulent issuer. First is paying
high Bitcoin transaction fee, even higher than Guarantee Transaction
fee, with the intention of placing the transaction desired by the issuer
in the next block. Even Guarantee Transaction will cause the issuer to
waive part of his output in favor of Bitcoin transaction fee. Its loss
is between 685 to 5,190 Satoshi. Therefore, carrying out this attack
will not be economically viable.
The second scenario is double spending the promised UTXO, hopping in a
race condition, the cheating transaction win the Guarantee Transaction.
The likelihood of success for this scenario is approximately 2 seconds /
10 minutes (0.3% chance). In other word, the issuer has 0.3% chance to
win 10,000 Satoshi (15,000 Max liability in a transaction ? 5,000
minimum transaction fee), and relatively he has 99.7% chance to lose
4,720 Satoshi. The risk to reward ratio is too high to consider this
scenario as a practical attack at all.

What if issuer is miner as well?
What a wicked issuer can earn from a block full of fraudulent
transactions or a real big batch transaction would be in maximum
spending 10,000 promised UTXO as inputs. The issuer already got paid
equal to 10,000 * 15,000 Satoshi from deceived creditors in fiat money
or goods or services. He is a miner as well so the transaction fee is
not the case, thus we can say all the 1.5 Bitcoin is the issuer/miner
benefit. But a normal honest block usually makes same or more profit for
its miner! So, what is the benefit of cheating creditors? The
issuer/miner has to mine solely and take the risk of wasting energy for
almost nothing advanced a normal honest participating in network!
In other word, due to the small amount of inputs and outputs, spending
these Satoshis on any type of Bitcoin transaction is not cost effective
in most cases.

What if creditor is miner as well?
The wicked creditor in every case will lose part of his money, since he
can only put Main transaction or Guarantee Transaction in next block. In
first case he paid unnecessary Bitcoin transaction fee. In second case
he paid even more unnecessary Bitcoin transaction fee.

Conclusion:
Till here, after tuning the transaction parameters and the criteria of a
successful deal, seems most of the risks of Sabu protocol have been
addressed.
I intentionally didn?t talk about BIPxxx ?mark/unmark promised UTXOs?,
because the Sabu protocol will work enough good without touching current
Bitcoin core protocol. In future, after implementing BIPxxx, the Sabu
protocol can remove some limitations and improve its features and
functionalities.


What is the next step?
The next step would be putting protocol in practice and developing a
Minimum Viable Product (MVP). I am a developer and I think -for now- the
best technology and stack to develop the protocol and the proper mobile
wallet would be ?react native?. The protocol and the software will be
open source and under GPL v3.0. Let me know if you have alternate idea.

At the moment I cannot work full-time on this project and I need some
help,
But I am gradually working on this project and looking forward to hear
from Bitcoin real supporters.

Regards
Raymo <raymo at riseup.net> d89a49057b817be0



this post on medium.com
https://raymo-49157.medium.com/fine-tuning-sabu-in-order-to-minimize-the-protocol-risks-95361dc5282b

From jlrubin at mit.edu  Sun Aug  8 18:52:55 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 8 Aug 2021 11:52:55 -0700
Subject: [bitcoin-dev] Removing the Dust Limit
Message-ID: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>

We should remove the dust limit from Bitcoin. Five reasons:

1) it's not our business what outputs people want to create
2) dust outputs can be used in various authentication/delegation smart
contracts
3) dust sized htlcs in lightning (
https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)
force channels to operate in a semi-trusted mode which has implications
(AFAIU) for the regulatory classification of channels in various
jurisdictions; agnostic treatment of fund transfers would simplify this
(like getting a 0.01 cent dividend check in the mail)
4) thinly divisible colored coin protocols might make use of sats as value
markers for transactions.
5) should we ever do confidential transactions we can't prevent it without
compromising privacy / allowed transfers

The main reasons I'm aware of not allow dust creation is that:

1) dust is spam
2) dust fingerprinting attacks

1 is (IMO) not valid given the 5 reasons above, and 2 is preventable by
well behaved wallets to not redeem outputs that cost more in fees than they
are worth.

cheers,

jeremy

--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/c022237a/attachment.html>

From lf-lists at mattcorallo.com  Sun Aug  8 21:14:23 2021
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Sun, 8 Aug 2021 17:14:23 -0400
Subject: [bitcoin-dev] Removing the Dust Limit
In-Reply-To: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
Message-ID: <e22dde6c-9a31-60ae-64d0-5e2ff84a6b79@mattcorallo.com>

If it weren't for the implications in changing standardness here, I think we should consider increasing the dust limit 
instead.

The size of the UTXO set is a fundamental scalability constraint of the system. In fact, with proposals like 
assume-utxo/background history sync it is arguably *the* fundamental scalability constraint of the system. Today's dust 
limit is incredibly low - its based on a feerate of only 3 sat/vByte in order for claiming the UTXO to have *any* value, 
not just having enough value to be worth bothering. As feerates have gone up over time, and as we expect them to go up 
further, we should be considering drastically increasing the 3 sat/vByte basis to something more like 20 sat/vB.

Matt

On 8/8/21 14:52, Jeremy via bitcoin-dev wrote:
> We should remove the dust limit from Bitcoin. Five reasons:
> 
> 1) it's not our business what outputs people want to create

It is precisely our business - the costs are born by us, not the creator. If someone wants to create outputs which don't 
make sense to spend, they can do so using OP_RETURN, since they won't spend it anyway.

> 2) dust outputs can be used in various authentication/delegation smart contracts

So can low-value-but-enough-to-be-worth-spending-when-you're-done-with-them outputs.

> 3) dust sized htlcs in lightning 
> (https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light 
> <https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light>) 
> force channels to operate in a semi-trusted mode which has implications (AFAIU) for the regulatory classification of 
> channels in various jurisdictions; agnostic treatment of fund transfers?would simplify this (like getting a 0.01 cent 
> dividend check in the mail)

This is unrelated to the consensus dust limit. This is related to the practical question about the value of claiming an 
output. Again, the appropriate way to solve this instead of including spendable dust outputs would be an OP_RETURN 
output (though I believe this particular problem is actually better solved elsewhere in the lightning protocol).

> 4) thinly divisible colored coin protocols might make use of sats as value markers for transactions.

These schemes can and should use values which make them economical to spend. The whole *point* of the dust limit is to 
encourage people to use values which make sense economically to "clean up" after they're done with them. If people want 
to use outputs which they will not spend/"clean up" later, they should be using OP_RETURN.

> 5) should we ever do confidential transactions we can't prevent it without compromising?privacy / allowed transfers

This is the reason the dust limit is not a *consensus* limit. If and when CT were to happen we can and would relax the 
standardness rules around the dust limit to allow for CT.

> 
> The main reasons I'm aware of not allow dust creation is that:
> 
> 1) dust is spam
> 2) dust fingerprinting attacks

3) The significant costs to every miner and full node operator.

From oleganza at gmail.com  Sun Aug  8 21:41:32 2021
From: oleganza at gmail.com (Oleg Andreev)
Date: Mon, 9 Aug 2021 00:41:32 +0300
Subject: [bitcoin-dev] Removing the Dust Limit
In-Reply-To: <e22dde6c-9a31-60ae-64d0-5e2ff84a6b79@mattcorallo.com>
References: <e22dde6c-9a31-60ae-64d0-5e2ff84a6b79@mattcorallo.com>
Message-ID: <29C08A0C-E9DA-4D9A-B27A-A5479D2B434E@gmail.com>

I agree with Jeremy. Dust limit works due to design accident: that outputs are not encrypted. But outputs are private business and the real issue is only the cost of utxo set storage born by every user. There are two ways to address this:

1) either make ppl pay for renting that storage (which creates a ton of problems of its own)
2) or make storage extremely cheap so it remains cheap at any scale. This is perfectly solved by Utreexo.

But looking at the private data because you can is a hack that creates issues of its own.

> On 9 Aug 2021, at 00:16, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?If it weren't for the implications in changing standardness here, I think we should consider increasing the dust limit instead.
> 
> The size of the UTXO set is a fundamental scalability constraint of the system. In fact, with proposals like assume-utxo/background history sync it is arguably *the* fundamental scalability constraint of the system. Today's dust limit is incredibly low - its based on a feerate of only 3 sat/vByte in order for claiming the UTXO to have *any* value, not just having enough value to be worth bothering. As feerates have gone up over time, and as we expect them to go up further, we should be considering drastically increasing the 3 sat/vByte basis to something more like 20 sat/vB.
> 
> Matt
> 
>> On 8/8/21 14:52, Jeremy via bitcoin-dev wrote:
>> We should remove the dust limit from Bitcoin. Five reasons:
>> 1) it's not our business what outputs people want to create
> 
> It is precisely our business - the costs are born by us, not the creator. If someone wants to create outputs which don't make sense to spend, they can do so using OP_RETURN, since they won't spend it anyway.
> 
>> 2) dust outputs can be used in various authentication/delegation smart contracts
> 
> So can low-value-but-enough-to-be-worth-spending-when-you're-done-with-them outputs.
> 
>> 3) dust sized htlcs in lightning (https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light <https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light>) force channels to operate in a semi-trusted mode which has implications (AFAIU) for the regulatory classification of channels in various jurisdictions; agnostic treatment of fund transfers would simplify this (like getting a 0.01 cent dividend check in the mail)
> 
> This is unrelated to the consensus dust limit. This is related to the practical question about the value of claiming an output. Again, the appropriate way to solve this instead of including spendable dust outputs would be an OP_RETURN output (though I believe this particular problem is actually better solved elsewhere in the lightning protocol).
> 
>> 4) thinly divisible colored coin protocols might make use of sats as value markers for transactions.
> 
> These schemes can and should use values which make them economical to spend. The whole *point* of the dust limit is to encourage people to use values which make sense economically to "clean up" after they're done with them. If people want to use outputs which they will not spend/"clean up" later, they should be using OP_RETURN.
> 
>> 5) should we ever do confidential transactions we can't prevent it without compromising privacy / allowed transfers
> 
> This is the reason the dust limit is not a *consensus* limit. If and when CT were to happen we can and would relax the standardness rules around the dust limit to allow for CT.
> 
>> The main reasons I'm aware of not allow dust creation is that:
>> 1) dust is spam
>> 2) dust fingerprinting attacks
> 
> 3) The significant costs to every miner and full node operator.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From dave at dtrt.org  Sun Aug  8 21:51:01 2021
From: dave at dtrt.org (David A. Harding)
Date: Sun, 8 Aug 2021 11:51:01 -1000
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
Message-ID: <20210808215101.wuaidu5ww63ajx6h@ganymede>

On Sun, Aug 08, 2021 at 11:52:55AM -0700, Jeremy wrote:
> We should remove the dust limit from Bitcoin. Five reasons:

Jeremy knows this, but to be clear for other readers, the dust limit is
a policy in Bitcoin Core (and other software) where it refuses by
default to relay or mine transactions with outputs below a certain
amount.  If nodes or miners running with non-default policy choose to
relay or mine those transactions, they are not penalized (not directly,
at least; there's BIP152 to consider).

Question for Jeremy: would you also allow zero-value outputs?  Or would
you just move the dust limit down to a fixed 1-sat?

I think the dust limit is worth keeping:

> 1) it's not our business what outputs people want to create

Every additional output added to the UTXO set increases the amount of
work full nodes need to do to validate new transactions.  For miners
for whom fast validation of new blocks can significantly affect their
revenue, larger UTXO sets increase their costs and so contributes
towards centralization of mining.

Allowing 0-value or 1-sat outputs minimizes the cost for polluting the
UTXO set during periods of low feerates.

If your stuff is going to slow down my node and possibly reduce my
censorship resistance, how is that not my business?

> 2) dust outputs can be used in various authentication/delegation smart
> contracts

All of which can also use amounts that are economically rational to
spend on their own.  If you're gonna use the chain for something besides
value transfer, and you're already wiling to pay X in fees per onchain
use, why is it not reasonable for us to ask you to put up something on
the order of X as a bond that you'll actually clean up your mess when
you're no longer interested in your thing?

> 3) dust sized htlcs in lightning (
> https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)
> force channels to operate in a semi-trusted mode 

Nope, nothing is forced.  Any LN node can simply refuse to accept/route
HTLCs below the dust limit.

> which has implications
> (AFAIU) for the regulatory classification of channels in various
> jurisdictions

Sucks for the people living there.  They should change their laws.  If
they can't do that, they should change their LN node policies not to
route uneconomic HTLCs.  We shouldn't make Bitcoin worse to make
complying with regulations easier.

I also doubt your proposed solution fixes the problem.  Any LN node that
accepts an uneconomic HTLC cannot recover that value, so the money is
lost either way.  Any sane regulation would treat losing value to
transaction fees the same as losing value to uneconomical conditions.

Finally, if LN nodes start polluting the UTXO set with no economic way
to clean up their mess, I think that's going to cause tension between
full node operators and LN node operators.

> agnostic treatment of fund transfers would simplify this
> (like getting a 0.01 cent dividend check in the mail)

I'm not sure I understand this point.  It sounds to me like you're
comparing receiving an uneconomic output to receiving a check that isn't
worth the time to cash.  But the costs of checks are borne only by the
people who send, receive, and process them.  The costs of uneconomic
outputs polluting the UTXO set are borne by every full node forever (or
for every archival full node forever if non-archival nodes end up using
something like utreexo).

> 4) thinly divisible colored coin protocols might make use of sats as value
> markers for transactions.

I'm not exactly sure what you're talking about, but if Alice wants to
communicate the number n onchain, she can do:

    if n < dust:
      nSequence = 0x0000 + n  # should probably check endianess
    else:
      nValue = n

There's at least 15 bits of nSequence currently without consensus or
policy meaning, and the dust limits are currently in the hundreds of
sat, so there's plenty of space.

Alice could probably also communicate the same thing by grinding her
output script's hash or pubkey; again, with dust limits just being
hundreds of sats, that's not too much grinding.

> 5) should we ever do confidential transactions we can't prevent it without
> compromising privacy / allowed transfers

I'm not an expert, but it seems to me that you can do that with range
proofs.  The range proof for >dust doesn't need to become part of the
block chain, it can be relay only.

I haven't looked since they upgraded to bulletproofs, but ISTR the
original CT implementation leaked the most significant digits or
something (that kept down the byte size of the proofs), so maybe it was
already possible to know what was certainly not dust and what might be
dust.

In short, it's my opinion that the dust limit is not creating any real
problems, so it should be kept for its contribution to keeping full
nodes faster, cheaper, and more efficient.

-Dave

P.S. As I prepared to send this, Matt's email arrived about "If it
weren't for the implications in changing standardness here, I think we
should consider increasing the dust limit instead."  I'm in agreement
with both parts of that statement.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/3feb232d/attachment.sig>

From jlrubin at mit.edu  Sun Aug  8 22:46:26 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 8 Aug 2021 15:46:26 -0700
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <20210808215101.wuaidu5ww63ajx6h@ganymede>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <20210808215101.wuaidu5ww63ajx6h@ganymede>
Message-ID: <CAD5xwhhbo6yMiNbSSgtjK8o0m5gm+2hmQN54Xj+pX7nu4xtByw@mail.gmail.com>

Under no circumstances do I think we should *increase* the dust limit. That
would have a mildly confiscatory effect on current Lightning Channel
operators, among others.

Generally, the UTXO set will grow. We should work to accommodate the worst
case scenario under current consensus rules. I think this points to using
things like Utreexo or similar rather than meddling in the user's business.

I am skeptical that 0 value outputs are a real spam problem given the cost
to create. Generally one creates an output when one either believes it
would make sense to redeem it in the future. So surely this is a market
problem, if people want them they can pay what it is worth for them to have
it. Again, it's not my business.

Matt proposes that people might use a nominal amount of bitcoin on a zero
value input so that it doesn't look like dust. What Matt is asking for is
that in any protocol you pay for your space not via fees, but instead via
an assurance bond that you will eventually redeem it and clean the state
up. In my opinion, this is worse than just allowing a zero value input
since then you might accrue the need for an additional change output to
which the bond's collateral be returned.

With respect to the check in the mail analogy, cutting down trees for paper
is bad for everyone and shipping things using fossil fuels contributes to
climate change. Therefore it's a cost borne by society in some respects.
Still, if someone else decides it's worth sending a remittance of whichever
value, it is still not my business.

With respect to CT and using the range proofs to exclude dust, I'm aware
that can be done (hence compromising allowed transfers). Again, I don't
think it's quite our business what people do, but on a technical level,
this would have the impact of shrinking the anonymity set so is also
suspect to me.

---------------

If we really want to create incentives for state clean up, I think it's a
decent design space to consider.

e.g., we could set up a bottle deposit program whereby miners contribute an
amount of funds from fee revenue from creating N outputs to a "rolling
utxo" (e.g., a coinbase utxo that gets spent each block op_true to op_true
under some miner rules) and the rolling utxo can either disperse funds to
the miner reward or soak up funds from the fees in order to encourage
blocks which have a better ratio of inputs to outputs than the mean. Miners
can then apply this rule in the mempool to prioritize transactions that
help their block's ratio. This is all without directly interfering with the
user's intent to create whatever outputs they want, it just provides a way
of paying miners to clean up the public common.

Gas Token by Daian et al comes to mind, from Eth, w.r.t. many pitfalls
arbing these state space freeing return curves, but it's worth thinking
through nonetheless.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/8fcb4331/attachment.html>

From jlrubin at mit.edu  Sun Aug  8 23:07:27 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 8 Aug 2021 16:07:27 -0700
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <20210808215101.wuaidu5ww63ajx6h@ganymede>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <20210808215101.wuaidu5ww63ajx6h@ganymede>
Message-ID: <CAD5xwhgNUuXW=ZnXHgawQrM6ywRrZAR5HFi+kkyUt3bLe1u99Q@mail.gmail.com>

some additional answers/clarifications



> Question for Jeremy: would you also allow zero-value outputs?  Or would
> you just move the dust limit down to a fixed 1-sat?
>

I would remove it entirely -- i don't think there's a difference between
the two realistically.



>
> Allowing 0-value or 1-sat outputs minimizes the cost for polluting the
> UTXO set during periods of low feerates.
>
>
Maybe that incentivizes people to make better use of the low
feerate periods to do more important work like consolidations so that
others do not have the opportunity to pollute (therefore eliminating the
low fee period ;)



> If your stuff is going to slow down my node and possibly reduce my
> censorship resistance, how is that not my business?
>

You don't know that's what I'm doing, it's a guess as to my future behavior.

If it weren't worth it to me, I wouldn't be doing it. Market will solve
what is worth v.s. not worth.



>
> > 2) dust outputs can be used in various authentication/delegation smart
> > contracts
>
> All of which can also use amounts that are economically rational to
> spend on their own.  If you're gonna use the chain for something besides
> value transfer, and you're already wiling to pay X in fees per onchain
> use, why is it not reasonable for us to ask you to put up something on
> the order of X as a bond that you'll actually clean up your mess when
> you're no longer interested in your thing?
>

These authentication/delegation smart contracts can be a part of value
transfer e.g. some type of atomic swaps or other escrowed payment.

A bond to clean it up is a fair reason; but perhaps in a protocol it might
not make sense to clean up the utxo otherwise and so you're creating a
cleanup transaction (potentially has to be presigned in a way it can't be
done as a consolidation) and then some future consolidation to make the
dusts+eps aggregately convenient to spend. So you'd be trading a decent
amount more chainspace v.s. just ignoring the output and writing it to disk
and maybe eventually into a utreexo (e.g. imagine utreexo where the last N
years of outputs are held in memory, but eventually things get tree'd up)
so the long term costs need not be entirely bourne in permanent storage.


>
> Nope, nothing is forced.  Any LN node can simply refuse to accept/route
> HTLCs below the dust limit.
>

I'd love to hear some broad thoughts on the impact of this on routing (cc
Tarun who thinks about these things a decent amount) as this means for
things like multipath routes you have much stricter constraints on which
nodes you can route payments through. The impact on capacity from every
user's pov might be not insubstantial.



>
> I also doubt your proposed solution fixes the problem.  Any LN node that
> accepts an uneconomic HTLC cannot recover that value, so the money is
> lost either way.  Any sane regulation would treat losing value to
> transaction fees the same as losing value to uneconomical conditions.
>
> Finally, if LN nodes start polluting the UTXO set with no economic way
> to clean up their mess, I think that's going to cause tension between
> full node operators and LN node operators.
>



My anticipation is that the LN operators would stick the uneconomic HTLCs
aggregately into a fan out utxo and try to cooperate, but failing that only
pollute the chain by O(1) for O(n) non economic HTLCs. There is a
difference between losing money and knowing exactly where it is but not
claiming it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210808/b39f4a28/attachment-0001.html>

From s7r at sky-ip.org  Mon Aug  9 00:03:31 2021
From: s7r at sky-ip.org (s7r)
Date: Mon, 9 Aug 2021 03:03:31 +0300
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <0555e82561666007e7ce367e3a204f53@riseup.net>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
 <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
 <6016816a7ea36b8a88f48d69462d0308@riseup.net>
 <0555e82561666007e7ce367e3a204f53@riseup.net>
Message-ID: <f5720b0e-d660-473e-00fa-aa275d062e30@sky-ip.org>

raymo via bitcoin-dev wrote:

TL,DR: you were explained by ZmnSCPxj why this protocol will not work. 
The possibility for just one party to sign will not work. I will explain 
again why but in much more simpler description.


> Check out this simple transaction to learn more about how the system
> works.
> Consider Alice as an issuer. She owns a UTXO worth 20,000 Satoshi. So,
> she can spend it by create a transaction and sign it and broadcast it to
> Bitcoin network.
> Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys 12,000
> Satoshi from Alice in exchange.
> Alice gets this 5$ and prepare a Main transaction that represents this
> liability of Alice to Bob.
> 
> Main Transaction (20,000 Sat input):
> * Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000, but Bob
> has to pay 3,000 as BTC fee)
> * Alice (issuer): 6,000 Sat
> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)
> This is a valid transaction and both Bob and/or Alice can send it to
> Bitcoin network, but none of them are interested in doing so. Because
> they will lose 5,000 Satoshi of their own money as Bitcoin transaction
> fee.
> 
> Alongside this transaction Alice (the issuer) has to create the
> Guarantee Transaction as well and deliver it to Bob. Otherwise, Bob will
> not consider the deal completed. The Guarantee Transaction is another
> valid Bitcoin transaction. It is created based on Main Transaction and
> will cut a part of Bob and Alice money in favor of transaction fee.
> 
> Guarantee Transaction (20,000 Sat input):
> * Bob (creditor): 9,000 ? 80.77%*9,000 = 9,000 ? 7,260 = 1,740 Sat
> * Alice (issuer): 6,000 ? 58%*6,000 = 6,000 ? 3,480 = 2,520 Sat
> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260 (from
> Bob) + 3,480 (from Al-ice) = 15,739 Sat
> 
> The Guarantee Transaction applies when the issuer does not live up to
> its promise and intends to spend the promised UTXO(s) in a way other
> than that agreed upon. We already knew the fact that Sabu is not a
> custodial solution, neither a M of N signature schema. As a result, the
> UTXO owner always can spend the already promised UTXO(s) in Sabu
> protocol or out of Sabu on Bitcoin blockchain, Contrary to what was
> promised.
> When the Alice (issuer) breaks such a promise and sends the fraudulent
> transaction to the Bitcoin network, Bob's wallet realizes that she
> (issuer) is spending the promised UTXO(s) and it sends the Guarantee
> Transaction(s) to the network as a last resort. The miners will face two
> (or more) transactions which are spending same UTXO(s), but one of them
> is paying notably higher Bitcoin transaction fee, thus they chose the
> highest fee payer transaction, which is the Guarantee Transaction. The
> miner will put the Guarantee Transaction in next block and reject the
> rest double-spend transactions. Certainly, poor Bob cannot recoup all
> his Satoshis. But he can retrieve a portion of his money and forces
> Alice to lose some of her money as well. tit for tat!
> Because of this mechanism, the issuer will try to not cheat on creditor.
> 
> By the way there are some attacks that have very small chance to succeed
> but the risk to reward ratio for these scenarios are too high to be
> considered as a real possible attack threat. I will review them a little
> later in this post.
> 
>

You said that the guarantee transaction is created based on Main 
Transaction, how do you mean? If it is a child transaction of the Main 
Transaction it already doesn't work because Alice needs to broadcast the 
*Main Transaction* to the blockchain in order for the Guarantee 
transaction to be accepted, and of she does this, Bob doesn't care 
because the transaction pays to him already the correct agreed amount. 
If you did not mean this, still it won't work, because

Simple:
1. Alice will create transaction #3, or call it Sabu-killing-transaction 
(20,000 Sat input):
* Alice (issuer): 15,000 Sat
* BTC Fee: 5,000 Sat

PERIOD.

When Bob tries to broadcast the "guarantee transaction" he will get an 
error: REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT. The much 
larger fee in the guarantee transaction will not matter. You have to 
assume a miner will violate the Bitcoin protocol and somehow drop 
Sabu-killing-transaction from mempool and consider the Guarantee 
transaction only. This is very unlikely to happen and you might also 
need connection direct with the miners because most full nodes will not 
even accept the Guarantee transaction to their mempools in order to 
further broadcast it until it reaches the miners.

With the simple attack described above Alice's chance to fraud Bob are, 
from my point of view, 99%.

(the only way to replace a transaction is Replace-By-Fee but this 
implies the transaction that IS TO BE REPLACED has a certain flag set, 
and it is optional).

Given the Sabu-Killing-transaction comes first, Alice will of course 
create it without this flag set so even if you add to Sabu the 
requirement of RBF enabled to the Guarantee transaction it will not 
work, because it's the other way around.


The second question is just for an observation that it has no real 
benefits over Lightning even if #1 wasn't true:

2. The creditor (Bob) has to leave his wallet running 24x7 and ensure he 
is connected to the internet, otherwise if he loses connection to the 
internet or energy supply, Alice attack will succeed entirely with 100% 
chances. So this means Bob needs to always be online like forever and ever.

The 3rd one is hypothetical and you don't even have to answer it:
3. How does Bob (first creditor) spend the coins received / how does Bob 
become an issuer himself in relation to Dave (another creditor)? What 
happens if Alice tries to fraud Bob after Bob spent its Sabu credit to 
Dave? Dave has to hold all parent "guarantee transactions" and watch the 
network for any potential fraudulent transactions that cancels his credit?

From prayank at tutanota.de  Mon Aug  9 10:25:50 2021
From: prayank at tutanota.de (Prayank)
Date: Mon, 9 Aug 2021 12:25:50 +0200 (CEST)
Subject: [bitcoin-dev] Removing the Dust Limit
Message-ID: <MgeRbNh--3-2@tutanota.de>

>?As feerates have gone up over time, and as we expect them to go up further, we should be considering drastically increasing the 3 sat/vByte basis to something more like 20 sat/vB.

I have no opinion on changing or removing dust limit. However, fee rates are not going up. Yes, we expect them to go up and miners revenue from fees as well. Although, fees/day (in terms of BTC) has been decreasing in each cycle. Fee rates have been ranging between 1 sat/vByte to 200-300 sat/vByte, regularly reset to 1-5 sat/vByte and very low since long time now except when hash rate went down.

Fees per MB since 2016: https://i.imgur.com/XEkkf99.png?

Highest in this cycle on April 19 2021: 2.5 BTC
Highest in previous cycle on December 18 2017: 10 BTC

It stays low all the time except few days in each cycle.

-- 
Prayank
?
A3B1 E430 2298 178F

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/84b29654/attachment.html>

From gmkarl at gmail.com  Mon Aug  9 11:58:03 2021
From: gmkarl at gmail.com (Karl)
Date: Mon, 9 Aug 2021 07:58:03 -0400
Subject: [bitcoin-dev] Removing the Dust Limit
In-Reply-To: <MgeRbNh--3-2@tutanota.de>
References: <MgeRbNh--3-2@tutanota.de>
Message-ID: <CALL-=e6EgTgaTcdHcXabhWA_HyXVwLRHB37vn_Jt3B4aH-OOng@mail.gmail.com>

Why would removing the dust limit impact decentralisation of mining if
miners can reconfigure the dust limit for their mined blocks?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/42d76e8d/attachment.html>

From antoine.riard at gmail.com  Mon Aug  9 13:22:28 2021
From: antoine.riard at gmail.com (Antoine Riard)
Date: Mon, 9 Aug 2021 09:22:28 -0400
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
Message-ID: <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>

I'm pretty conservative about increasing the standard dust limit in any
way. This would convert a higher percentage of LN channels capacity into
dust, which is coming with a lowering of funds safety [0]. Of course, we
can adjust the LN security model around dust handling to mitigate the
safety risk in case of adversarial settings, but ultimately the standard
dust limit creates a  "hard" bound, and as such it introduces a trust
vector in the reliability of your peer to not goes
onchain with a commitment heavily-loaded with dust-HTLC you own.

LN node operators might be willingly to compensate this "dust" trust vector
by relying on side-trust model, such as PKI to authenticate their peers or
API tokens (LSATs, PoW tokens), probably not free from consequences for the
"openness" of the LN topology...

Further, I think any authoritative setting of the dust limit presents the
risk of becoming ill-adjusted  w.r.t to market realities after a few months
or years, and would need periodic reevaluations. Those reevaluations, if
not automated, would become a vector of endless dramas and bikeshedding as
the L2s ecosystems grow bigger...

Note, this would also constrain the design space of newer fee schemes. Such
as negotiated-with-mining-pool and discounted consolidation during low
feerate periods deployed by such producers of low-value outputs.
`
Moreover as an operational point, if we proceed to such an increase on the
base-layer, e.g to 20 sat/vb, we're going to severely damage the
propagation of any LN transaction, where a commitment transaction is built
with less than 20 sat/vb outputs. Of course, core's policy deployment on
the base layer is gradual, but we should first give a time window for the
LN ecosystem to upgrade and as of today we're still devoid of the mechanism
to do it cleanly and asynchronously (e.g dynamic upgrade or quiescence
protocol [1]).

That said, as raised by other commentators, I don't deny we have a
long-term tension between L2 nodes and full-nodes operators about the UTXO
set growth, but for now I would rather solve this with smarter engineering
such as utreexo on the base-layer side or multi-party shared-utxo or
compressed colored coins/authentication smart contracts (e.g
opentimestamp's merkle tree in OP_RETURN) on the upper layers rather than
altering the current equilibrium.

I think the status quo is good enough for now, and I believe we would be
better off to learn from another development cycle before tweaking the dust
limit in any sense.

Antoine

[0]
https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html
[1] https://github.com/lightningnetwork/lightning-rfc/pull/869

Le dim. 8 ao?t 2021 ? 14:53, Jeremy <jlrubin at mit.edu> a ?crit :

> We should remove the dust limit from Bitcoin. Five reasons:
>
> 1) it's not our business what outputs people want to create
> 2) dust outputs can be used in various authentication/delegation smart
> contracts
> 3) dust sized htlcs in lightning (
> https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)
> force channels to operate in a semi-trusted mode which has implications
> (AFAIU) for the regulatory classification of channels in various
> jurisdictions; agnostic treatment of fund transfers would simplify this
> (like getting a 0.01 cent dividend check in the mail)
> 4) thinly divisible colored coin protocols might make use of sats as value
> markers for transactions.
> 5) should we ever do confidential transactions we can't prevent it without
> compromising privacy / allowed transfers
>
> The main reasons I'm aware of not allow dust creation is that:
>
> 1) dust is spam
> 2) dust fingerprinting attacks
>
> 1 is (IMO) not valid given the 5 reasons above, and 2 is preventable by
> well behaved wallets to not redeem outputs that cost more in fees than they
> are worth.
>
> cheers,
>
> jeremy
>
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
> _______________________________________________
> Lightning-dev mailing list
> Lightning-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/83985422/attachment.html>

From raymo at riseup.net  Mon Aug  9 16:22:29 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Mon, 09 Aug 2021 09:22:29 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <f5720b0e-d660-473e-00fa-aa275d062e30@sky-ip.org>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
 <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
 <6016816a7ea36b8a88f48d69462d0308@riseup.net>
 <0555e82561666007e7ce367e3a204f53@riseup.net>
 <f5720b0e-d660-473e-00fa-aa275d062e30@sky-ip.org>
Message-ID: <9403a01d93b3fe2e871517304b552194@riseup.net>

Hi s7r,
I already answered to ZmnSCPxj's comments.

Let?s go to yours.

> If it is a child transaction of the Main Transaction
Sorry for my shortcoming in English, because it caused the
misunderstanding of proposal.
There is not any relation between Main Transaction and Guarantee
transaction. when I said ?the Guarantee Transaction is created based on
Main Transaction? I was intended only the numbers. I mean the output
amounts of Guarantee Transaction are calculated relatively based on Main
Transaction output amounts, in order to make a Guarantee Transaction
with relatively higher transaction fee. So, either of MT or GT can be
broadcasted or toke place in next block independently.  

> When Bob tries to broadcast the "guarantee transaction" he will get an error: 
> REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT
Here is the part which I am not sure you are right about it. I do not
know in detail and I'm not sure how miners will react to the two
double-spend transactions and which one they will prefer.
Will they use the first seen transaction for block pre-image, or will
use the transaction with higher transaction fee?
We need the help of Bitcoin core developers to clarify this transaction
selection mechanism. 
If miners prefer the highest fee my scenario still is valid. But if
miners always keep the first transaction received and drop subsequent
transactions, I have three different solution to solve that I will
explain in later posts.

> 2. The creditor (Bob) has to leave his wallet running 24x7 and ensure he is connected 
> to the internet, otherwise if he loses connection to the internet or energy supply, 
> Alice attack will succeed entirely with 100% chances. 
> So this means Bob needs to always be online like forever and ever.
Somehow you are right. Definitely Bob can delegate this task to a
doc-watcher, pretty much like watch-tower in Lightning, but due to the
small amount of creditor's credits and the fact that this amount is
scattered among many different issuers, I removed this part from the
original design of Sabu architecture.
BTW major creditors, such as stores that receives debt-documents worth
thousands of dollars a day, should (and better say must) always be
online to protect their money. This job also creates a safe margin for
other creditors.
IMHO at the moment the protocol is good enough to start, but we can
always talk about improving the protocol.

> The 3rd one is hypothetical and you don't even have to answer it:
> 3. How does Bob (first creditor) spend the coins received / 
> how does Bob become an issuer himself in relation to Dave (another creditor)? 
> What happens if Alice tries to fraud Bob after Bob spent its Sabu credit to Dave? 
> Dave has to hold all parent "guarantee transactions" and watch the network for 
> any potential fraudulent transactions that cancels his credit?
I already explained it in response of Billy here
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019271.html

just look for ?how normal transactions happen in their entirety.?

Looking forward to hear from core developers about ?how miners will
react to the two double-spend transactions and which one they will
prefer?.

Regards
Raymo


On 2021-08-09 00:03, s7r wrote:
> raymo via bitcoin-dev wrote:
> 
> TL,DR: you were explained by ZmnSCPxj why this protocol will not work.
> The possibility for just one party to sign will not work. I will
> explain again why but in much more simpler description.
> 
> 
>> Check out this simple transaction to learn more about how the system
>> works.
>> Consider Alice as an issuer. She owns a UTXO worth 20,000 Satoshi. So,
>> she can spend it by create a transaction and sign it and broadcast it to
>> Bitcoin network.
>> Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys 12,000
>> Satoshi from Alice in exchange.
>> Alice gets this 5$ and prepare a Main transaction that represents this
>> liability of Alice to Bob.
>>
>> Main Transaction (20,000 Sat input):
>> * Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000, but Bob
>> has to pay 3,000 as BTC fee)
>> * Alice (issuer): 6,000 Sat
>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)
>> This is a valid transaction and both Bob and/or Alice can send it to
>> Bitcoin network, but none of them are interested in doing so. Because
>> they will lose 5,000 Satoshi of their own money as Bitcoin transaction
>> fee.
>>
>> Alongside this transaction Alice (the issuer) has to create the
>> Guarantee Transaction as well and deliver it to Bob. Otherwise, Bob will
>> not consider the deal completed. The Guarantee Transaction is another
>> valid Bitcoin transaction. It is created based on Main Transaction and
>> will cut a part of Bob and Alice money in favor of transaction fee.
>>
>> Guarantee Transaction (20,000 Sat input):
>> * Bob (creditor): 9,000 ? 80.77%*9,000 = 9,000 ? 7,260 = 1,740 Sat
>> * Alice (issuer): 6,000 ? 58%*6,000 = 6,000 ? 3,480 = 2,520 Sat
>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260 (from
>> Bob) + 3,480 (from Al-ice) = 15,739 Sat
>>
>> The Guarantee Transaction applies when the issuer does not live up to
>> its promise and intends to spend the promised UTXO(s) in a way other
>> than that agreed upon. We already knew the fact that Sabu is not a
>> custodial solution, neither a M of N signature schema. As a result, the
>> UTXO owner always can spend the already promised UTXO(s) in Sabu
>> protocol or out of Sabu on Bitcoin blockchain, Contrary to what was
>> promised.
>> When the Alice (issuer) breaks such a promise and sends the fraudulent
>> transaction to the Bitcoin network, Bob's wallet realizes that she
>> (issuer) is spending the promised UTXO(s) and it sends the Guarantee
>> Transaction(s) to the network as a last resort. The miners will face two
>> (or more) transactions which are spending same UTXO(s), but one of them
>> is paying notably higher Bitcoin transaction fee, thus they chose the
>> highest fee payer transaction, which is the Guarantee Transaction. The
>> miner will put the Guarantee Transaction in next block and reject the
>> rest double-spend transactions. Certainly, poor Bob cannot recoup all
>> his Satoshis. But he can retrieve a portion of his money and forces
>> Alice to lose some of her money as well. tit for tat!
>> Because of this mechanism, the issuer will try to not cheat on creditor.
>>
>> By the way there are some attacks that have very small chance to succeed
>> but the risk to reward ratio for these scenarios are too high to be
>> considered as a real possible attack threat. I will review them a little
>> later in this post.
>>
>>
> 
> You said that the guarantee transaction is created based on Main
> Transaction, how do you mean? If it is a child transaction of the Main
> Transaction it already doesn't work because Alice needs to broadcast
> the *Main Transaction* to the blockchain in order for the Guarantee
> transaction to be accepted, and of she does this, Bob doesn't care
> because the transaction pays to him already the correct agreed amount.
> If you did not mean this, still it won't work, because
> 
> Simple:
> 1. Alice will create transaction #3, or call it
> Sabu-killing-transaction (20,000 Sat input):
> * Alice (issuer): 15,000 Sat
> * BTC Fee: 5,000 Sat
> 
> PERIOD.
> 
> When Bob tries to broadcast the "guarantee transaction" he will get an
> error: REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT. The much
> larger fee in the guarantee transaction will not matter. You have to
> assume a miner will violate the Bitcoin protocol and somehow drop
> Sabu-killing-transaction from mempool and consider the Guarantee
> transaction only. This is very unlikely to happen and you might also
> need connection direct with the miners because most full nodes will
> not even accept the Guarantee transaction to their mempools in order
> to further broadcast it until it reaches the miners.
> 
> With the simple attack described above Alice's chance to fraud Bob
> are, from my point of view, 99%.
> 
> (the only way to replace a transaction is Replace-By-Fee but this
> implies the transaction that IS TO BE REPLACED has a certain flag set,
> and it is optional).
> 
> Given the Sabu-Killing-transaction comes first, Alice will of course
> create it without this flag set so even if you add to Sabu the
> requirement of RBF enabled to the Guarantee transaction it will not
> work, because it's the other way around.
> 
> 
> The second question is just for an observation that it has no real
> benefits over Lightning even if #1 wasn't true:
> 
> 2. The creditor (Bob) has to leave his wallet running 24x7 and ensure
> he is connected to the internet, otherwise if he loses connection to
> the internet or energy supply, Alice attack will succeed entirely with
> 100% chances. So this means Bob needs to always be online like forever
> and ever.
> 
> The 3rd one is hypothetical and you don't even have to answer it:
> 3. How does Bob (first creditor) spend the coins received / how does
> Bob become an issuer himself in relation to Dave (another creditor)?
> What happens if Alice tries to fraud Bob after Bob spent its Sabu
> credit to Dave? Dave has to hold all parent "guarantee transactions"
> and watch the network for any potential fraudulent transactions that
> cancels his credit?

From raymo at riseup.net  Mon Aug  9 20:22:57 2021
From: raymo at riseup.net (raymo at riseup.net)
Date: Mon, 09 Aug 2021 13:22:57 -0700
Subject: [bitcoin-dev] Boost Bitcoin circulation,
 Million Transactions Per Second with stronger privacy
In-Reply-To: <CAL5BAw2f=xJBO743sTb-Cms80ZLsNNbGPAsWsR_Z3JDF51ssoQ@mail.gmail.com>
References: <bea8122aea550f1141170829aac252af@riseup.net>
 <CADvTj4q42bQ0mTWwdMyJM9UpW57pV0feZk-vYynPu91N_aZSZw@mail.gmail.com>
 <CAGpPWDZtRnnv-Hinn4x=9ukJcuHkZv-6Yt32AK-9e+BJ=6r-kA@mail.gmail.com>
 <f46159f0286fe48720bc3f3fead1b575@riseup.net>
 <CAJowKgKELBmLdA-w5ghGoiWe5RQdNkKsV3OGRFbDJCOeA04AWw@mail.gmail.com>
 <d8b3ba5b940473165ad72d689a01602a@riseup.net>
 <CAGpPWDYAJE4jh=G2g=KSRuLLucEAyZGAD+r4XMpcmw6nk4+Wbg@mail.gmail.com>
 <e843b5c28690557402b72fcd158dc1c2@riseup.net>
 <CAGpPWDYPutiURUtenkU_zr4nW_tZVe5oWykXxWCDyROwqTdW5Q@mail.gmail.com>
 <6016816a7ea36b8a88f48d69462d0308@riseup.net>
 <0555e82561666007e7ce367e3a204f53@riseup.net>
 <f5720b0e-d660-473e-00fa-aa275d062e30@sky-ip.org>
 <9403a01d93b3fe2e871517304b552194@riseup.net>
 <CAL5BAw2f=xJBO743sTb-Cms80ZLsNNbGPAsWsR_Z3JDF51ssoQ@mail.gmail.com>
Message-ID: <392a21eef848045f827990a5044b1c94@riseup.net>

Hi Chris,

Thanks for your detailed answer. So, as you answered there is an
uncertainty about this case. For me, even this uncertainty would be a
good point to start. Because if the miners realize the potentiality for
increasing revenue under Sabu protocol, very soon they will want to
update their transaction selecting mechanism priorities, even before
occurring the first real attack on the protocol in ?production
software?. This upgrade in Bitcoin protocol will eliminate uncertainty
totally.

How hard do you think it will be this upgrade on protocol?
IMO the most important thing will be the consensus on the implementation
of these changes, while the code upgrading won't be a difficult
technical issue.
If it were difficult to agree on a Bitcoin core protocol change, we
might be able to achieve our goals by changing the Stratum protocol.
Unlike miners who would welcome that offer, full-nodes without hash
power would probably not be interested in upgrading the software. Maybe
because they do not want to disrupt the broadcasting of transactions by
relying double-spend transactions.
I'm not sure if the normal full nodes (without hash power) use the same
software that miners use. If not, we have to fight on two fronts to
upgrade the software.

Again, thanks for your fast and flourish reply :-)
Raymo


On 2021-08-09 18:03, Chris Riley wrote:
>> I'm not sure how miners will react to the two double-spend
> transactions and which one they will prefer.
>> Will they use the first seen transaction for block pre-image, or will
> use the transaction with higher transaction fee?
>> We need the help of Bitcoin core developers to clarify this
> transaction selection mechanism.  If miners
>> prefer the highest fee my scenario still is valid. But if miners
> always keep the first transaction received
>> and drop subsequent transactions,
> Hi,
> 
> Miners have the incentive to accept the highest fee transaction
> whenever they see it.  That does not imply that miners _will_ accept
> the highest fee transaction they see for a variety of reasons.  If a
> transaction does not signal RBF (BIP 125) then in general a "first
> seen" rule is applied, if a transaction does signal RBF, then in
> general the highest fee is prefered.  Since this is an untrusted
> network, a miner could use RBF even for transactions that don't signal
> it, since she could claim she saw it first, assuming the miner was
> aware of it which might imply it was submitted directly since the
> network might not relay a higher fee transaction for a non-RBF
> transaction.  Or a miner could see the first transaction and include
> it in a block just after the RBF transaction is broadcast but before
> the block is propagated. etc
> 
> So there is only a question of probabilities:  in general miners
> prefer the highest fee for RBF transactions and in general, miners
> will not replace a non-RBF transaction with a later one.  However,
> nothing is guaranteed given it is an untrusted network and people
> could use non-standard rules for selection of what transactions are
> included in a block.
> 
> :-)
> 
> On Mon, Aug 9, 2021 at 12:57 PM raymo via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> Hi s7r,
>> I already answered to ZmnSCPxj's comments.
>> 
>> Let?s go to yours.
>> 
>>> If it is a child transaction of the Main Transaction
>> Sorry for my shortcoming in English, because it caused the
>> misunderstanding of proposal.
>> There is not any relation between Main Transaction and Guarantee
>> transaction. when I said ?the Guarantee Transaction is created
>> based on
>> Main Transaction? I was intended only the numbers. I mean the
>> output
>> amounts of Guarantee Transaction are calculated relatively based on
>> Main
>> Transaction output amounts, in order to make a Guarantee Transaction
>> with relatively higher transaction fee. So, either of MT or GT can
>> be
>> broadcasted or toke place in next block independently.
>> 
>>> When Bob tries to broadcast the "guarantee transaction" he will
>> get an error:
>>> REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT
>> Here is the part which I am not sure you are right about it. I do
>> not
>> know in detail and I'm not sure how miners will react to the two
>> double-spend transactions and which one they will prefer.
>> Will they use the first seen transaction for block pre-image, or
>> will
>> use the transaction with higher transaction fee?
>> We need the help of Bitcoin core developers to clarify this
>> transaction
>> selection mechanism.
>> If miners prefer the highest fee my scenario still is valid. But if
>> miners always keep the first transaction received and drop
>> subsequent
>> transactions, I have three different solution to solve that I will
>> explain in later posts.
>> 
>>> 2. The creditor (Bob) has to leave his wallet running 24x7 and
>> ensure he is connected
>>> to the internet, otherwise if he loses connection to the internet
>> or energy supply,
>>> Alice attack will succeed entirely with 100% chances.
>>> So this means Bob needs to always be online like forever and ever.
>> Somehow you are right. Definitely Bob can delegate this task to a
>> doc-watcher, pretty much like watch-tower in Lightning, but due to
>> the
>> small amount of creditor's credits and the fact that this amount is
>> scattered among many different issuers, I removed this part from the
>> original design of Sabu architecture.
>> BTW major creditors, such as stores that receives debt-documents
>> worth
>> thousands of dollars a day, should (and better say must) always be
>> online to protect their money. This job also creates a safe margin
>> for
>> other creditors.
>> IMHO at the moment the protocol is good enough to start, but we can
>> always talk about improving the protocol.
>> 
>>> The 3rd one is hypothetical and you don't even have to answer it:
>>> 3. How does Bob (first creditor) spend the coins received /
>>> how does Bob become an issuer himself in relation to Dave (another
>> creditor)?
>>> What happens if Alice tries to fraud Bob after Bob spent its Sabu
>> credit to Dave?
>>> Dave has to hold all parent "guarantee transactions" and watch the
>> network for
>>> any potential fraudulent transactions that cancels his credit?
>> I already explained it in response of Billy here
>> 
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019271.html
>> 
>> just look for ?how normal transactions happen in their
>> entirety.?
>> 
>> Looking forward to hear from core developers about ?how miners
>> will
>> react to the two double-spend transactions and which one they will
>> prefer?.
>> 
>> Regards
>> Raymo
>> 
>> On 2021-08-09 00:03, s7r wrote:
>>> raymo via bitcoin-dev wrote:
>>> 
>>> TL,DR: you were explained by ZmnSCPxj why this protocol will not
>> work.
>>> The possibility for just one party to sign will not work. I will
>>> explain again why but in much more simpler description.
>>> 
>>> 
>>>> Check out this simple transaction to learn more about how the
>> system
>>>> works.
>>>> Consider Alice as an issuer. She owns a UTXO worth 20,000
>> Satoshi. So,
>>>> she can spend it by create a transaction and sign it and
>> broadcast it to
>>>> Bitcoin network.
>>>> Suppose Bob (as a creditor) pays Alice 5 dollars cash, and buys
>> 12,000
>>>> Satoshi from Alice in exchange.
>>>> Alice gets this 5$ and prepare a Main transaction that represents
>> this
>>>> liability of Alice to Bob.
>>>> 
>>>> Main Transaction (20,000 Sat input):
>>>> * Bob (creditor): 9,000 Sat (the real credit of Bob is 12,000,
>> but Bob
>>>> has to pay 3,000 as BTC fee)
>>>> * Alice (issuer): 6,000 Sat
>>>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob)
>>>> This is a valid transaction and both Bob and/or Alice can send it
>> to
>>>> Bitcoin network, but none of them are interested in doing so.
>> Because
>>>> they will lose 5,000 Satoshi of their own money as Bitcoin
>> transaction
>>>> fee.
>>>> 
>>>> Alongside this transaction Alice (the issuer) has to create the
>>>> Guarantee Transaction as well and deliver it to Bob. Otherwise,
>> Bob will
>>>> not consider the deal completed. The Guarantee Transaction is
>> another
>>>> valid Bitcoin transaction. It is created based on Main
>> Transaction and
>>>> will cut a part of Bob and Alice money in favor of transaction
>> fee.
>>>> 
>>>> Guarantee Transaction (20,000 Sat input):
>>>> * Bob (creditor): 9,000 ? 80.77%*9,000 = 9,000 ? 7,260 =
>> 1,740 Sat
>>>> * Alice (issuer): 6,000 ? 58%*6,000 = 6,000 ? 3,480 = 2,520
>> Sat
>>>> * BTC Fee: 5,000 Sat (2,000 from Alice + 3,000 from Bob) + 7,260
>> (from
>>>> Bob) + 3,480 (from Al-ice) = 15,739 Sat
>>>> 
>>>> The Guarantee Transaction applies when the issuer does not live
>> up to
>>>> its promise and intends to spend the promised UTXO(s) in a way
>> other
>>>> than that agreed upon. We already knew the fact that Sabu is not
>> a
>>>> custodial solution, neither a M of N signature schema. As a
>> result, the
>>>> UTXO owner always can spend the already promised UTXO(s) in Sabu
>>>> protocol or out of Sabu on Bitcoin blockchain, Contrary to what
>> was
>>>> promised.
>>>> When the Alice (issuer) breaks such a promise and sends the
>> fraudulent
>>>> transaction to the Bitcoin network, Bob's wallet realizes that
>> she
>>>> (issuer) is spending the promised UTXO(s) and it sends the
>> Guarantee
>>>> Transaction(s) to the network as a last resort. The miners will
>> face two
>>>> (or more) transactions which are spending same UTXO(s), but one
>> of them
>>>> is paying notably higher Bitcoin transaction fee, thus they chose
>> the
>>>> highest fee payer transaction, which is the Guarantee
>> Transaction. The
>>>> miner will put the Guarantee Transaction in next block and reject
>> the
>>>> rest double-spend transactions. Certainly, poor Bob cannot recoup
>> all
>>>> his Satoshis. But he can retrieve a portion of his money and
>> forces
>>>> Alice to lose some of her money as well. tit for tat!
>>>> Because of this mechanism, the issuer will try to not cheat on
>> creditor.
>>>> 
>>>> By the way there are some attacks that have very small chance to
>> succeed
>>>> but the risk to reward ratio for these scenarios are too high to
>> be
>>>> considered as a real possible attack threat. I will review them a
>> little
>>>> later in this post.
>>>> 
>>>> 
>>> 
>>> You said that the guarantee transaction is created based on Main
>>> Transaction, how do you mean? If it is a child transaction of the
>> Main
>>> Transaction it already doesn't work because Alice needs to
>> broadcast
>>> the *Main Transaction* to the blockchain in order for the
>> Guarantee
>>> transaction to be accepted, and of she does this, Bob doesn't care
>>> because the transaction pays to him already the correct agreed
>> amount.
>>> If you did not mean this, still it won't work, because
>>> 
>>> Simple:
>>> 1. Alice will create transaction #3, or call it
>>> Sabu-killing-transaction (20,000 Sat input):
>>> * Alice (issuer): 15,000 Sat
>>> * BTC Fee: 5,000 Sat
>>> 
>>> PERIOD.
>>> 
>>> When Bob tries to broadcast the "guarantee transaction" he will
>> get an
>>> error: REJECTED FROM MEMPOOL, INPUTS (UTXO) ALREADY SPENT. The
>> much
>>> larger fee in the guarantee transaction will not matter. You have
>> to
>>> assume a miner will violate the Bitcoin protocol and somehow drop
>>> Sabu-killing-transaction from mempool and consider the Guarantee
>>> transaction only. This is very unlikely to happen and you might
>> also
>>> need connection direct with the miners because most full nodes
>> will
>>> not even accept the Guarantee transaction to their mempools in
>> order
>>> to further broadcast it until it reaches the miners.
>>> 
>>> With the simple attack described above Alice's chance to fraud Bob
>>> are, from my point of view, 99%.
>>> 
>>> (the only way to replace a transaction is Replace-By-Fee but this
>>> implies the transaction that IS TO BE REPLACED has a certain flag
>> set,
>>> and it is optional).
>>> 
>>> Given the Sabu-Killing-transaction comes first, Alice will of
>> course
>>> create it without this flag set so even if you add to Sabu the
>>> requirement of RBF enabled to the Guarantee transaction it will
>> not
>>> work, because it's the other way around.
>>> 
>>> 
>>> The second question is just for an observation that it has no real
>>> benefits over Lightning even if #1 wasn't true:
>>> 
>>> 2. The creditor (Bob) has to leave his wallet running 24x7 and
>> ensure
>>> he is connected to the internet, otherwise if he loses connection
>> to
>>> the internet or energy supply, Alice attack will succeed entirely
>> with
>>> 100% chances. So this means Bob needs to always be online like
>> forever
>>> and ever.
>>> 
>>> The 3rd one is hypothetical and you don't even have to answer it:
>>> 3. How does Bob (first creditor) spend the coins received / how
>> does
>>> Bob become an issuer himself in relation to Dave (another
>> creditor)?
>>> What happens if Alice tries to fraud Bob after Bob spent its Sabu
>>> credit to Dave? Dave has to hold all parent "guarantee
>> transactions"
>>> and watch the network for any potential fraudulent transactions
>> that
>>> cancels his credit?
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From ZmnSCPxj at protonmail.com  Tue Aug 10 02:17:47 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 10 Aug 2021 02:17:47 +0000
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
	a function of total input value
In-Reply-To: <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
Message-ID: <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>

 fromGood morning Zac,


With some work, what you want can be implemented, to some extent, today, without changes to consensus.

The point you want, I believe, is to have two sets of keys:

* A long-term-storage keyset, in "cold" storage.
* A short-term-spending keyset, in "warm" storage, controlling only a small amount of funds.

What you can do would be:

* Put all your funds in a single UTXO, with an k-of-n of your cold keys (ideally P2TR, or some P2WSH k-of-n).
* Put your cold keys online, and sign a transaction spending the above UTXO, and spending most of it to a new address that is a tweaked k-of-n of your cold keys, and a smaller output (up to the limit you want) controlled by the k-of-n of your warm keys.
  * Keep this transaction offchain, in your warm storage.
* Put your cold keys back offline.
* When you need to spend using your warm keys, bring the above transaction onchain, then spend from the budget as needed.


If you need to have some estimated amount of usable funds for every future unit of time, just create a chain of transactions with future `nLockTime`.

                                  nLocktime +1day  nLockTime +2day
                  +------------+   +------------+   +------------+
     cold UTXO -->|    cold TXO|-->|    cold TXO|-->|    cold TXO|--> etc.
                  |            |   |            |   |            |
                  |    warm TXO|   |    warm TXO|   |    warm TXO|
                  +------------+   +------------+   +------------+

Pre-sign the above transactions, store the pre-signed transactions in warm storage together with your warm keys.
Then put the cold keys back offline.

Then from today to tomorrow, you can spend only the first warm TXO.
>From tomorrow to the day after, you can spend only the first two warm TXOs.
And so on.

If tomorrow your warm keys are stolen, you can bring the cold keys online to claim the second cold TXO and limit your fund loss to only just the first two warm TXOs.

The above is bulky, but it has the advantage of not using any special opcodes or features (improving privacy, especially with P2TR which would in theory allow k-of-n/n-of-n to be indistinguishable from 1-of-1), and using just `nLockTime`, which is much easier to hide since most modern wallets will set `nLockTime` to recent block heights.

Regards,
ZmnSCPxj


From jlrubin at mit.edu  Tue Aug 10 05:04:07 2021
From: jlrubin at mit.edu (Jeremy)
Date: Mon, 9 Aug 2021 22:04:07 -0700
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAGpPWDZn6dcuEJXRjUP4VYvJbL9u4mmVoS9xTVzBrGWOM5CeZw@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <CAGpPWDZn6dcuEJXRjUP4VYvJbL9u4mmVoS9xTVzBrGWOM5CeZw@mail.gmail.com>
Message-ID: <CAD5xwhi_Sf1NRPBSAcWWFiAjyFsnmWbtowBF96j=EM4NXxfOKw@mail.gmail.com>

You might be interested in https://eprint.iacr.org/2017/1066.pdf which
claims that you can make CT computationally hiding and binding, see section
4.6.

with respect to utreexo, you might review
https://github.com/mit-dci/utreexo/discussions/249?sort=new which discusses
tradeoffs between different accumulator designs. With a swap tree, old
things that never move more or less naturally "fall leftward", although
there are reasons to prefer alternative designs.


>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/b93d8107/attachment.html>

From dave at dtrt.org  Tue Aug 10 06:14:41 2021
From: dave at dtrt.org (David A. Harding)
Date: Mon, 9 Aug 2021 20:14:41 -1000
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
Message-ID: <20210810061441.6rg3quotiycomcp6@ganymede>

On Mon, Aug 09, 2021 at 09:22:28AM -0400, Antoine Riard wrote:
> I'm pretty conservative about increasing the standard dust limit in any
> way. This would convert a higher percentage of LN channels capacity into
> dust, which is coming with a lowering of funds safety [0]. 

I think that reasoning is incomplete.  There are two related things here:

- **Uneconomical outputs:** outputs that would cost more to spend than
  the value they contain.

- **Dust limit:** an output amount below which Bitcoin Core (and other
  nodes) will not relay the transaction containing that output.

Although raising the dust limit can have the effect you describe, 
increases in the minimum necessary feerate to get a transaction
confirmed in an appropriate amount of time also "converts a higher
percentage of LN channel capacity into dust".  As developers, we have no
control over prevailing feerates, so this is a problem LN needs to deal
with regardless of Bitcoin Core's dust limit.

(Related to your linked thread, that seems to be about the risk of
"burning funds" by paying them to a miner who may be a party to the
attack.  There's plenty of other alternative ways to burn funds that can
change the risk profile.)

> the standard dust limit [...] introduces a trust vector 

My point above is that any trust vector is introduced not by the dust
limit but by the economics of outputs being worth less than they cost to
spend.

> LN node operators might be willingly to compensate this "dust" trust vector
> by relying on side-trust model

They could also use trustless probabalistic payments, which have been
discussed in the context of LN for handling the problem of payments too
small to be represented onchain since early 2016:
https://docs.google.com/presentation/d/1G4xchDGcO37DJ2lPC_XYyZIUkJc2khnLrCaZXgvDN0U/edit?pref=2&pli=1#slide=id.g85f425098_0_178

(Probabalistic payments were discussed in the general context of Bitcoin
well before LN was proposed, and Elements even includes an opcode for
creating them.)

> smarter engineering such as utreexo on the base-layer side 

Utreexo doesn't solve this problem.  Many nodes (such as miners) will
still want to store the full UTXO set and access it quickly,  Utreexo
proofs will grow in size with UTXO set size (though, at best, only
log(n)), so full node operators will still not want their bandwidth
wasted by people who create UTXOs they have no reason to spend.

> I think the status quo is good enough for now

I agree.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/24595273/attachment-0001.sig>

From billy.tetrud at gmail.com  Tue Aug 10 00:30:02 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 9 Aug 2021 17:30:02 -0700
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
Message-ID: <CAGpPWDZn6dcuEJXRjUP4VYvJbL9u4mmVoS9xTVzBrGWOM5CeZw@mail.gmail.com>

> 5) should we ever do confidential transactions we can't prevent it without compromising
privacy / allowed transfers

I wanted to mention the dubiousness of adding confidential transactions to
bitcoin. Because adding CT would eliminate the ability for users to audit
the supply of Bitcoin, I think its incredibly unlikely to ever happen. I'm
in the camp that we shouldn't do anything that prevents people from
auditing the supply. I think that camp is probably pretty large. Regardless
of what I think should happen there, and even if CT were to eventually
happen in bitcoin, I don't think that future possibility is a good reason
to change the dust limit today.

It seems like dust is a scalability problem regardless of whether we use
Utreexo eventually or not, tho an accumulator would help a ton. One idea
would be to destroy/delete dust at some point in the future. However, even
if we were to plan to do this, I still don't think the dust limit should be
removed. But the dust limit should probably be lowered a bit, given that
the 546 sats limit is about 7 cents and its very doable to send 1 sat/vbyte
transactions, so lowering it to 200 sats seems reasonable.


On Mon, Aug 9, 2021 at 6:24 AM Antoine Riard via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'm pretty conservative about increasing the standard dust limit in any
> way. This would convert a higher percentage of LN channels capacity into
> dust, which is coming with a lowering of funds safety [0]. Of course, we
> can adjust the LN security model around dust handling to mitigate the
> safety risk in case of adversarial settings, but ultimately the standard
> dust limit creates a  "hard" bound, and as such it introduces a trust
> vector in the reliability of your peer to not goes
> onchain with a commitment heavily-loaded with dust-HTLC you own.
>
> LN node operators might be willingly to compensate this "dust" trust
> vector by relying on side-trust model, such as PKI to authenticate their
> peers or API tokens (LSATs, PoW tokens), probably not free from
> consequences for the "openness" of the LN topology...
>
> Further, I think any authoritative setting of the dust limit presents the
> risk of becoming ill-adjusted  w.r.t to market realities after a few months
> or years, and would need periodic reevaluations. Those reevaluations, if
> not automated, would become a vector of endless dramas and bikeshedding as
> the L2s ecosystems grow bigger...
>
> Note, this would also constrain the design space of newer fee schemes.
> Such as negotiated-with-mining-pool and discounted consolidation during low
> feerate periods deployed by such producers of low-value outputs.
> `
> Moreover as an operational point, if we proceed to such an increase on the
> base-layer, e.g to 20 sat/vb, we're going to severely damage the
> propagation of any LN transaction, where a commitment transaction is built
> with less than 20 sat/vb outputs. Of course, core's policy deployment on
> the base layer is gradual, but we should first give a time window for the
> LN ecosystem to upgrade and as of today we're still devoid of the mechanism
> to do it cleanly and asynchronously (e.g dynamic upgrade or quiescence
> protocol [1]).
>
> That said, as raised by other commentators, I don't deny we have a
> long-term tension between L2 nodes and full-nodes operators about the UTXO
> set growth, but for now I would rather solve this with smarter engineering
> such as utreexo on the base-layer side or multi-party shared-utxo or
> compressed colored coins/authentication smart contracts (e.g
> opentimestamp's merkle tree in OP_RETURN) on the upper layers rather than
> altering the current equilibrium.
>
> I think the status quo is good enough for now, and I believe we would be
> better off to learn from another development cycle before tweaking the dust
> limit in any sense.
>
> Antoine
>
> [0]
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html
> [1] https://github.com/lightningnetwork/lightning-rfc/pull/869
>
> Le dim. 8 ao?t 2021 ? 14:53, Jeremy <jlrubin at mit.edu> a ?crit :
>
>> We should remove the dust limit from Bitcoin. Five reasons:
>>
>> 1) it's not our business what outputs people want to create
>> 2) dust outputs can be used in various authentication/delegation smart
>> contracts
>> 3) dust sized htlcs in lightning (
>> https://bitcoin.stackexchange.com/questions/46730/can-you-send-amounts-that-would-typically-be-considered-dust-through-the-light)
>> force channels to operate in a semi-trusted mode which has implications
>> (AFAIU) for the regulatory classification of channels in various
>> jurisdictions; agnostic treatment of fund transfers would simplify this
>> (like getting a 0.01 cent dividend check in the mail)
>> 4) thinly divisible colored coin protocols might make use of sats as
>> value markers for transactions.
>> 5) should we ever do confidential transactions we can't prevent it
>> without compromising privacy / allowed transfers
>>
>> The main reasons I'm aware of not allow dust creation is that:
>>
>> 1) dust is spam
>> 2) dust fingerprinting attacks
>>
>> 1 is (IMO) not valid given the 5 reasons above, and 2 is preventable by
>> well behaved wallets to not redeem outputs that cost more in fees than they
>> are worth.
>>
>> cheers,
>>
>> jeremy
>>
>> --
>> @JeremyRubin <https://twitter.com/JeremyRubin>
>> <https://twitter.com/JeremyRubin>
>> _______________________________________________
>> Lightning-dev mailing list
>> Lightning-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/lightning-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/84b13e96/attachment-0001.html>

From billy.tetrud at gmail.com  Tue Aug 10 00:41:12 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 9 Aug 2021 17:41:12 -0700
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <CAJ4-pEByppCRQwKqkPaAMMLiqw0ZcCECuSjGZjeW529BKMAhRg@mail.gmail.com>
References: <CAJ4-pEAETy7_vOez5H32mZLg9gRpRajvoBjZyBT_v=DEqdQJvQ@mail.gmail.com>
 <CAJ4-pEAxqvMc89xSp9NXXNwnpJ3NhMqE6p=dRbpYCAB3Gbb14g@mail.gmail.com>
 <CAGpPWDbidOBqUXHpoteAf50WXeMi392PJZmApyT8h2Gk6n1gKQ@mail.gmail.com>
 <CAJ4-pEAi-ooVMvJmeXhrS9J6-JVQ1jxy1On1NTQYpOSD49cbrw@mail.gmail.com>
 <CAGpPWDZNrPT9Li_neNOr3BDGdusMorWjFodNPo6YqNC3SDaf3w@mail.gmail.com>
 <CAJ4-pEByppCRQwKqkPaAMMLiqw0ZcCECuSjGZjeW529BKMAhRg@mail.gmail.com>
Message-ID: <CAGpPWDY5-pUx8+Ne9VzL-=XeE8uTH7djzgngXxghKpMZOPGzoQ@mail.gmail.com>

>  By explicitly specifying the start and end block of an epoch, the user
has more flexibility in shifting the epoch

Ok I see. I think I understand your proposal better now. If the output is
spent within the range epochStart - epochEnd, the limit holds, if it is
spent outside that range the change output must also have a range of the
same length (or shorter?). So you want there to be the ability for the user
to precisely define the length and starting block of the
rate-limiting-period (epoch). I'd say it'd be clearer to specify the window
length and the starting block in that case. The same semantics can be kept.

> This would require the system to bookkeep how much was spent since the
first rate-limited output

Yes, for the length of the epoch, after which the bookkeeping can be
discarded/reset until a new transaction is sent. Your proposal also
requires bookkeeping tho - it needs to store the 'remain' value with the
UTXO as well because its not efficient to go back and re-execute the script
just to grab that value.

> using an address as input for a transaction will always spends the full
amount at that address

Using a UTXO will spend the full UTXO. The address may contain many UTXOs.
I'm not suggesting that a change address isn't needed - I'm suggesting that
the *same* address be used as the change address for the change output. Eg
consider the following UTXO info:

Address X: rateLimit(windowSize = 144 blocks, limit = 100k sats)
* UTXO 1: 100k sats, 50k spent by ancestor inputs since epochStart 800100
* UTXO 2: 200k sats, 10k spent since epochStart

When sending a transaction using UTXO 2, a node would look up the list of
UTXOs in Address X, add up the amount spent since epochStart (60k) and
ensure that at most 40k is going to an address that isn't address X. So a
valid transaction might look like:

Input: UTXO 2
Output 1: 30k -> Address A
Output 2: 170k -> Address X

On Thu, Aug 5, 2021 at 7:22 AM Zac Greenwood <zachgrw at gmail.com> wrote:

> Hi Billy,
>
> > It sounds like you're proposing an opcode
>
> No. I don?t have enough knowledge of Bitcoin to be able to tell how (and
> if) rate-limiting can be implemented as I suggested. I am not able to
> reason about opcodes, so I kept my description at a more functional level.
>
> > I still don't understand why its useful to specify those as absolute
> block heights
>
> I feel that this a rather uninteresting data representation aspect that?s
> not worth going back and forth about. Sure, specifying the length of the
> epoch may also be an option, although at the price of giving up some
> functionality, and without much if any gains.
>
> By explicitly specifying the start and end block of an epoch, the user has
> more flexibility in shifting the epoch (using alternate values for
> epochStart and epochEnd) and simultaneously increasing the length of an
> epoch. These seem rather exotic features, but there?s no harm in retaining
> them.
>
> > if you have a UTXO encumbered by rateLimit(epochStart = 800100,
> epochEnd = 800200, limit = 100k, remain = 100k), what happens if you don't
> spend that UTXO before block 800200?
>
> The rate limit remains in place. So if this UTXO is spent in block 900000,
> then at most 100k may be spent. Also, the new epoch must be at least 100
> blocks and remain must correctly account for the actual amount spent.
>
> > This is how I'd imagine creating an opcode like this:
>
> > rateLimit(windowSize = 144 blocks, limit = 100k sats)
>
> This would require the system to bookkeep how much was spent since the
> first rate-limited output. It is a more intuitive way of rate-limiting but
> it may be much more difficult to implement, which is why I went with the
> epoch-based rate limiting solution. In terms of functionality, I believe
> the two solutions are nearly identical for all practical purposes.
>
> Your next section confuses me. As I understand it, using an address as
> input for a transaction will always spends the full amount at that address.
> That?s why change addresses are required, no? If Bitcoin were able to pay
> exact amounts then there wouldn?t be any need for change outputs.
>
> Zac
>
>
> On Thu, 5 Aug 2021 at 08:39, Billy Tetrud <billy.tetrud at gmail.com> wrote:
>
>> >   A maximum amount is allowed to be spent within EVERY epoch.
>>
>> It sounds like you're proposing an opcode that takes in epochStart and
>> epochEnd as parameters. I still don't understand why its useful to specify
>> those as absolute block heights. You mentioned that this enables more
>> straightforward validation logic, but I don't see how. Eg, if you have a
>> UTXO encumbered by rateLimit(epochStart = 800100, epochEnd = 800200, limit
>> = 100k, remain = 100k), what happens if you don't spend that UTXO before
>> block 800200? Is the output no longer rate limited then? Or is the opcode
>> calculating 800200-800100 = 100 and applying a rate limit for the next
>> epoch? If the first, then the UTXO must be spent within one epoch to remain
>> rate limited. If the second, then it seems nearly identical to simply
>> specifying window=100 as a parameter instead of epochStart and epochEnd.
>>
>> > then there must be only a single (rate-limited) output
>>
>> This rule would make transactions tricky if you're sending money into
>> someone else's wallet that may be rate limited. If the requirement is that
>> only you yourself can send money into a rate limited wallet, then this
>> point is moot but it would be ideal to not have such a requirement.
>>
>> This is how I'd imagine creating an opcode like this:
>>
>> rateLimit(windowSize = 144 blocks, limit = 100k sats)
>>
>> This would define that the epoch is 1 day's worth of blocks. This would
>> evenly divide bitcoin's retarget period and so each window would start and
>> end at those dividing lines (eg the first 144 blocks of the retargetting
>> period, then the second, then the third, etc).
>>
>> When this output is spent, it ensures that there's a maximum of 100k sats
>> is sent to addresses other than the originating address. It also records
>> the amount spent in the current 144 block window for that address (eg by
>> simply recording the already-spent amount on the resulting UTXO and having
>> an index that allows looking up UTXOs by address and adding them up). That
>> way, when any output from that address is spent again, if a new 144 block
>> window has started, the limit is reset, but if its still within the same
>> window, the already-spent amounts for UTXOs from that address are added up
>> and subtracted from the limit, and that number is the remaining limit a
>> subsequent transaction needs to adhere to.
>>
>> This way, 3rd party could send transactions into an address like this,
>> and multiple outputs can be combined and used to spend to arbitrary outputs
>> (up to the rate limit of course).
>>
>> On Wed, Aug 4, 2021 at 3:48 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>
>>> > Ah I see, this is all limited to within a single epoch.
>>>
>>> No, that wouldn't be useful. A maximum amount is allowed to be spent
>>> within EVERY epoch.
>>>
>>> Consider an epoch length of 100 blocks with a spend limit of 200k per
>>> epoch. The following is allowed:
>>>
>>> epoch1 (800101 - 800200): spend 120k in block 800140. Remaining for
>>> epoch1: 80k;
>>> epoch1 (800101 - 800200): spend another 60k in block 800195. Remaining
>>> for epoch1: 20k;
>>> epoch2 (800201 - 800300): spend 160k in block 800201. Remaining for
>>> epoch2: 40k.
>>>
>>> Since the limit pertains to each individual epoch, it is allowed to
>>> spend up to the full limit at the start of any new epoch. In this example,
>>> the spending was as follows:
>>>
>>> 800140: 120k
>>> 800195: 60k
>>> 800201: 160k.
>>>
>>> Note that in a span of 62 blocks a total of 340k sats was spent. This
>>> may seem to violate the 200k limit per 100 blocks, but this is the result
>>> of using a per-epoch limit. This allows a maximum of 400k to be spent in 2
>>> blocks llke so: 200k in the last block of an epoch and another 200k in the
>>> first block of the next epoch. However this is inconsequential for the
>>> intended goal of rate-limiting which is to enable small spends over time
>>> from a large amount and to prevent theft of a large amount with a single
>>> transaction.
>>>
>>> To explain the proposed design more clearly, I have renamed the params
>>> as follows:
>>>
>>> epochStart: block height of first block of the current epoch (was: h0);
>>> epochEnd: block height of last block of the current epoch (was: h1);
>>> limit: the maximum total amount allowed to be spent within the current
>>> epoch (was: a);
>>> remain: the remaining amount allowed to be spent within the current
>>> epoch (was: a_remaining);
>>>
>>> Also, to illustrate that the params are specific to a transaction, I
>>> will hence precede the param with the transaction name like so:
>>> tx8_limit, tx31c_remain, tx42z_epochStart, ... etc.
>>>
>>> For simplicity, only transactions with no more than one rate-limited
>>> input are considered, and with no more than two outputs: one rate-limited
>>> change output, and a normal (not rate-limited) output.
>>>
>>> Normally, a simple transaction generates two outputs: one for a payment
>>> to a third party and one for the change address. Again for simplicity, we
>>> demand that a transaction which introduces rate-limiting must have only a
>>> single, rate-limited output. The validation rule might be: if a transaction
>>> has rate-limiting params and none of its inputs are rate-limited, then
>>> there must be only a single (rate-limited) output (and no second or change
>>> output).
>>>
>>> Consider rate limiting transactions tx1 having one or more normal (non
>>> rate-limited) inputs:
>>>
>>> tx1 gets included at block height 800004;
>>> The inputs of tx1 are not rate-limited => tx1 must have only a single
>>> output which will become rate-limited;
>>> params: tx1_epochStart=800001, tx1_epochEnd=800100, tx1_limit=200k,
>>> tx1_remain=200k;
>>> => This defines that an epoch has 100 blocks and no more than 200k sats
>>> may be spent in any one epoch. Within the current epoch, 200k sats may
>>> still be spent.
>>>
>>> This transaction begins to rate-limit a set of inputs, so it has a
>>> single rate-limited output.
>>> Let's explore transactions that have the output of tx1 as their input. I
>>> will denote the output of tx1 as "out1".
>>>
>>> tx2a has out1 as its only input;
>>> tx2a spends 50k sats and gets included at block height 803050;
>>> tx2a specifies the following params for its change output "chg2a":
>>> chg2a_epochStart=803001, chg2a_epochEnd=803100;
>>> chg2a_limit=200k, chg2a_remain=150k.
>>>
>>> To enforce rate-limiting, the system must validate the params of the
>>> change output chg2a to ensure that overspending is not allowed.
>>>
>>> The above params are allowed because:
>>> => 1. the epoch does not become smaller than 100 blocks [(chg2a_epochEnd
>>> - chg2a_epochStart) >= (tx1_epochEnd - tx1_epochStart)]
>>> => 2. tx1_limit has not been increased (ch2a_limit <= tx1_limit)
>>> => 3. the amount spent (50k sats) does not exceed tx1_remain AND does
>>> not exceed chg2a_limit;
>>> => 4. chg2a_remain" is 50k sats less than chg2a_limit.
>>>
>>> A transaction may also further constrain further spending like so:
>>>
>>> tx2b has out1as its only input;
>>> tx2b spends 8k sats and gets included at block height 808105;
>>> tx2b specifies the following params for its change output "chg2b":
>>> chg2b_epochStart=808101, chg2b_epochEnd=808250;
>>> chg2b_limit=10k, chg2b_remain=0.
>>>
>>> These params are allowed because:
>>> => 1. the epoch does not become smaller than100 blocks. It is fine to
>>> increase the epoch to 150 blocks because it does not enable exceeding the
>>> original rate-limit;
>>> => 2. the limit (chg2b_limit) has been decreased to 10k sats, further
>>> restricting the maximum amount allowed to be spent within the current and
>>> any subsequent epochs;
>>> => 3. the amount spent (10k sats) does not exceed tx1_remain AND does
>>> not exceed chg2b_limit;
>>> => 4. chg2b_remain has been set to zero, meaning that within the current
>>> epoch (block height 808101 to and including 808250), tx2b cannot be used as
>>> a spending input to any transaction.
>>>
>>> Starting from block height 808251, a new epoch will start and the
>>> rate-limited output of tx2b may again be used as an input for a subsequent
>>> rate-limited transaction tx3b. This transaction tx3b must again be
>>> accompanied by params that do not violate the rate-limit as defined by the
>>> params of tx2b and which are stored with output out2b. So, the epoch of
>>> tx3b must be at minimum 150 blocks, the maximum that is allowed to be spent
>>> per epoch is at most 10k sats, and chg3b_remain must be decreased by at
>>> least the amount spent by tx3b.
>>>
>>> From the above, the rate-limiting mechanics should hopefully be clear
>>> and full set of validation rules could be defined in a more generalized way
>>> with little additional effort.
>>>
>>> Note that I conveniently avoided talking about how to represent the
>>> parameters within transactions or outputs, simply because I currently lack
>>> enough understanding to reason about this. I am hoping that others may
>>> offer help.
>>>
>>> Zac
>>>
>>>
>>> On Tue, Aug 3, 2021 at 8:12 PM Billy Tetrud <billy.tetrud at gmail.com>
>>> wrote:
>>>
>>>> > To enable more straightforward validation logic.
>>>> > within the current epoch
>>>>
>>>> Ah I see, this is all limited to within a single epoch. I think that
>>>> sufficiently limits the window of time in which nodes have to store
>>>> information for rate limited outputs. However, I don't see how specifying
>>>> block ranges simplifies the logic - wouldn't this complicate the logic with
>>>> additional user-specified constraints? It also prevents the output from
>>>> being able to be rate limited over the span of multiple epochs, which would
>>>> seem to make it a lot more difficult to use for certain types of wallets
>>>> (eg cold wallets).
>>>>
>>>> I think I see the logic of your 'remaining' parameter there. If you
>>>> start with a single rate-limited input, you can split that into many
>>>> outputs, only one of which have a 'remaining' balance. The rest can simply
>>>> remain unspendable for the rest of the epoch. That way these things don't
>>>> need to be tied together. However, that doesn't solve the problem of 3rd
>>>> parties being able to send money into the wallet.
>>>>
>>>> > I don't believe that the marginal added functionality would justify
>>>> the increased implementation complexity
>>>>
>>>> Perhaps, but I think there is a lot of benefit in allowing these kinds
>>>> of things to operate as similarly as possible to normal transactions, for
>>>> one because of usability reasons. If each opcode has its own quirks that
>>>> are not intuitively related to their purpose (eg if a rate-limited wallet
>>>> had no way to get a receiving address), it would confuse end-users (eg who
>>>> wonder how to get a receiving address and how they can ask people to send
>>>> money into their wallet) or require a lot of technical complexity in
>>>> applications (eg to support something like cooperatively connecting with
>>>> their wallet so that a transaction can be made that creates a new
>>>> single-output for the wallet). A little complexity in this opcode can save
>>>> a lot of external complexity here I think.
>>>>
>>>> > my understanding of Bitcoin is way too low to be able to write a BIP
>>>> and do the implementation
>>>>
>>>> You might be able to find people willing to help. I would be willing to
>>>> help write the BIP spec. I'm not the right person to help with the
>>>> implementation, but perhaps you could find someone else who is. Even if the
>>>> BIP isn't adopted, it could be a starting point or inspiration for someone
>>>> else to write an improved version.
>>>>
>>>> On Mon, Aug 2, 2021 at 2:32 AM Zac Greenwood <zachgrw at gmail.com> wrote:
>>>>
>>>>> [Note: I've moved your reply to the newly started thread]
>>>>>
>>>>> Hi Billy,
>>>>>
>>>>> Thank you for your kind and encouraging feedback.
>>>>>
>>>>> I don't quite understand why you'd want to define a specific span of
>>>>>> blocks for the rate limit. Why not just specify the size of the window (in
>>>>>> blocks) to rate limit within, and the limit?
>>>>>
>>>>>
>>>>> To enable more straightforward validation logic.
>>>>>
>>>>> You mentioned change addresses, however, with the parameters you
>>>>>> defined, there would be no way to connect together the change address with
>>>>>> the original address, meaning they would have completely separate rate
>>>>>> limits, which wouldn't work since the change output would ignore the
>>>>>> previous rate limit.
>>>>>
>>>>>
>>>>> The rate-limiting parameters must be re-specified for each
>>>>> rate-limited input. So, a transaction that has a rate-limited input is only
>>>>> valid if its output is itself rate-limited such that it does not violate
>>>>> the rate-limiting constraints of its input.
>>>>>
>>>>> In my thread-starter, I gave the below example of a rate-limited
>>>>> address a2 that serves as input for transaction t2:
>>>>>
>>>>> a2: 99.8 sats at height 800100;
>>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>>>
>>>>> Transaction t2:
>>>>> Included at block height 800200
>>>>> Spend: 400k + fees.
>>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>>>
>>>>> Note how transaction t2 re-specifies the rate-limiting parameters.
>>>>> Validation must ensure that the re-specified parameters are within bounds,
>>>>> i.e., do not allow more spending per epoch than the rate-limiting
>>>>> parameters of its input address a2. Re-specifying the rate-limiting
>>>>> parameters offers the flexibility to further restrict spending, or to
>>>>> disable any additional spending within the current epoch by setting
>>>>> a_remaining to zero.
>>>>>
>>>>> Result:
>>>>> Value at destination address: 400k sats;
>>>>> Rate limiting params at destination address: none;
>>>>> Value at change address a3: 99.4m sats;
>>>>> Rate limiting params at change address a3: h0=800144, h1=800287,
>>>>> a=500k, a_remaining=100k.
>>>>>
>>>>> As a design principle I believe it makes sense if the system is able
>>>>> to verify the validity of a transaction without having to consider any
>>>>> transactions that precede its inputs. As a side-note, doing away with this
>>>>> design principle would however enable more sophisticated rate-limiting
>>>>> (such as rate-limiting per sliding window instead of rate-limiting per
>>>>> epoch having a fixed start and end block), but while at the same time
>>>>> reducing the size of per rate-limiting transaction (because it would enable
>>>>> specifying the rate-limiting parameters more space-efficiently). To test
>>>>> the waters and to keep things relatively simple, I chose not to go into
>>>>> this enhanced form of rate-limiting.
>>>>>
>>>>> I haven't gone into how to process a transaction having multiple
>>>>> rate-limited inputs. The easiest way to handle this case is to not allow
>>>>> any transaction having more than one rate-limited input. One could imagine
>>>>> complex logic to handle transactions having multiple rate-limited inputs by
>>>>> creating multiple rate-limited change addresses. However at first glance I
>>>>> don't believe that the marginal added functionality would justify the
>>>>> increased implementation complexity.
>>>>>
>>>>>  I'd be interested in seeing you write a BIP for this.
>>>>>
>>>>>
>>>>> Thank you, but sadly my understanding of Bitcoin is way too low to be
>>>>> able to write a BIP and do the implementation. However I see tremendous
>>>>> value in this functionality. Favorable feedback of the list regarding the
>>>>> usefulness and the technical feasibility of rate-limiting functionality
>>>>> would of course be an encouragement for me to descend further down the
>>>>> rabbit hole.
>>>>>
>>>>> Zac
>>>>>
>>>>>
>>>>> On Sun, Aug 1, 2021 at 10:09 AM Zac Greenwood <zachgrw at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> [Resubmitting to list with minor edits. My previous submission ended
>>>>>> up inside an existing thread, apologies.]
>>>>>>
>>>>>> Hi list,
>>>>>>
>>>>>> I'd like to explore whether it is feasible to implement new scripting
>>>>>> capabilities in Bitcoin that enable limiting the output amount of a
>>>>>> transaction based on the total value of its inputs. In other words, to
>>>>>> implement the ability to limit the maximum amount that can be sent from an
>>>>>> address.
>>>>>>
>>>>>> Two use cases come to mind:
>>>>>>
>>>>>> UC1: enable a user to add additional protection their funds by
>>>>>> rate-limiting the amount that they are allowed to send during a certain
>>>>>> period (measured in blocks). A typical use case might be a user that
>>>>>> intends to hodl their bitcoin, but still wishes to occasionally send small
>>>>>> amounts. Rate-limiting avoids an attacker from sweeping all the users'
>>>>>> funds in a single transaction, allowing the user to become aware of the
>>>>>> theft and intervene to prevent further thefts.
>>>>>>
>>>>>> UC2: exchanges may wish to rate-limit addresses containing large
>>>>>> amounts of bitcoin, adding warm- or hot-wallet functionality to a
>>>>>> cold-storage address. This would enable an exchange to drastically reduce
>>>>>> the number of times a cold wallet must be accessed with private keys that
>>>>>> give access to the full amount.
>>>>>>
>>>>>> In a typical setup, I'd envision using multisig such that the user
>>>>>> has two sets of private keys to their encumbered address (with a "set" of
>>>>>> keys meaning "one or more" keys). One set of private keys allows only for
>>>>>> sending with rate-limiting restrictions in place, and a second set of
>>>>>> private keys allowing for sending any amount without rate-limiting,
>>>>>> effectively overriding such restriction.
>>>>>>
>>>>>> The parameters that define in what way an output is rate-limited
>>>>>> might be defined as follows:
>>>>>>
>>>>>> Param 1: a block height "h0" indicating the first block height of an
>>>>>> epoch;
>>>>>> Param 2: a block height "h1" indicating the last block height of an
>>>>>> epoch;
>>>>>> Param 3: an amount "a" in satoshi indicating the maximum amount that
>>>>>> is allowed to be sent in any epoch;
>>>>>> Param 4: an amount "a_remaining" (in satoshi) indicating the maximum
>>>>>> amount that is allowed to be sent within the current epoch.
>>>>>>
>>>>>> For example, consider an input containing 100m sats (1 BTC) which has
>>>>>> been rate-limited with parameters (h0, h1, a, a_remaining) of (800000,
>>>>>> 800143, 500k, 500k). These parameters define that the address is
>>>>>> rate-limited to sending a maximum of 500k sats in the current epoch that
>>>>>> starts at block height 800000 and ends at height 800143 (or about one day
>>>>>> ignoring block time variance) and that the full amount of 500k is still
>>>>>> sendable. These rate-limiting parameters ensure that it takes at minimum
>>>>>> 100m / 500k = 200 transactions and 200 x 144 blocks or about 200 days to
>>>>>> spend the full 100m sats. As noted earlier, in a typical setup a user
>>>>>> should retain the option to transact the entire amount using a second (set
>>>>>> of) private key(s).
>>>>>>
>>>>>> For rate-limiting to work, any change output created by a transaction
>>>>>> from a rate-limited address must itself be rate-limited as well. For
>>>>>> instance, expanding on the above example, assume that the user spends 200k
>>>>>> sats from a rate-limited address a1 containing 100m sats:
>>>>>>
>>>>>> Start situation:
>>>>>> At block height 800000: rate-limited address a1 is created;
>>>>>> Value of a1: 100.0m sats;
>>>>>> Rate limiting params of a1: h0=800000, h1=800143, a=500k,
>>>>>> a_remaining=500k;
>>>>>>
>>>>>> Transaction t1:
>>>>>> Included at block height 800100;
>>>>>> Spend: 200k + fee;
>>>>>> Rate limiting params: h0=800000, h1=800143, a=500k, a_remaining=300k.
>>>>>>
>>>>>> Result:
>>>>>> Value at destination address: 200k sats;
>>>>>> Rate limiting params at destination address: none;
>>>>>> Value at change address a2: 99.8m sats;
>>>>>> Rate limiting params at change address a2: h0=800000, h1=800143,
>>>>>> a=500k, a_remaining=300k.
>>>>>>
>>>>>> In order to properly enforce rate limiting, the change address must
>>>>>> be rate-limited such that the original rate limit of 500k sats per 144
>>>>>> blocks cannot be exceeded. In this example, the change address a2 were
>>>>>> given the same rate limiting parameters as the transaction that served as
>>>>>> its input. As a result, from block 800100 up until and including block
>>>>>> 800143, a maximum amount of 300k sats is allowed to be spent from the
>>>>>> change address.
>>>>>>
>>>>>> Example continued:
>>>>>> a2: 99.8 sats at height 800100;
>>>>>> Rate-limit params: h0=800000, h1=800143, a=500k, a_remaining=300k;
>>>>>>
>>>>>> Transaction t2:
>>>>>> Included at block height 800200
>>>>>> Spend: 400k + fees.
>>>>>> Rate-limiting params: h0=800144, h1=800287, a=500k, a_remaining=100k.
>>>>>>
>>>>>> Result:
>>>>>> Value at destination address: 400k sats;
>>>>>> Rate limiting params at destination address: none;
>>>>>> Value at change address a3: 99.4m sats;
>>>>>> Rate limiting params at change address a3: h0=800144, h1=800287,
>>>>>> a=500k, a_remaining=100k.
>>>>>>
>>>>>> Transaction t2 is allowed because it falls within the next epoch
>>>>>> (running from 800144 to 800287) so a spend of 400k does not violate the
>>>>>> constraint of 500k per epoch.
>>>>>>
>>>>>> As could be seen, the rate limiting parameters are part of the
>>>>>> transaction and chosen by the user (or their wallet). This means that the
>>>>>> parameters must be validated to ensure that they do not violate the
>>>>>> intended constraints.
>>>>>>
>>>>>> For instance, this transaction should not be allowed:
>>>>>> a2: 99.8 sats at height 800100;
>>>>>> Rate-limit params of a2: h0=800000, h1=800143, a=500k,
>>>>>> a_remaining=300k;
>>>>>>
>>>>>> Transaction t2a:
>>>>>> Included at block height 800200;
>>>>>> Spend: 400k + fees;
>>>>>> Rate-limit params: h0=800124, h1=800267, a=500k, a_remaining=100k.
>>>>>>
>>>>>> This transaction t2a attempts to shift the epoch forward by 20 blocks
>>>>>> such that it starts at 800124 instead of 800144. Shifting the epoch forward
>>>>>> like this must not be allowed because it enables spending more that the
>>>>>> rate limit allows, which is 500k in any epoch of 144 blocks. It would
>>>>>> enable overspending:
>>>>>>
>>>>>> t1: spend 200k at 800100 (epoch 1: total: 200k);
>>>>>> t2a: spend 400k at 800200 (epoch 2: total: 400k);
>>>>>> t3a: spend 100k at 800201 (epoch 2: total: 500k);
>>>>>> t4a: spend 500k at 800268 (epoch 2: total: 1000k, overspending for
>>>>>> epoch 2).
>>>>>>
>>>>>> Specifying the rate-limiting parameters explicitly at every
>>>>>> transaction allows the user to tighten the spending limit by setting
>>>>>> tighter limits or for instance by setting a_remainder to 0 if they wish to
>>>>>> enforce not spending more during an epoch. A second advantage of explicitly
>>>>>> specifying the four rate-limiting parameters with each transaction is that
>>>>>> it allows the system to fully validate the transaction without having to
>>>>>> consider any previous transactions within an epoch.
>>>>>>
>>>>>> I will stop here because I would like to gauge interest in this idea
>>>>>> first before continuing work on other aspects. Two main pieces of work jump
>>>>>> to mind:
>>>>>>
>>>>>> Define all validations;
>>>>>> Describe aggregate behaviour of multiple (rate-limited) inputs, proof
>>>>>> that two rate-limited addresses cannot spend more than the sum of their
>>>>>> individual limits.
>>>>>>
>>>>>> Zac
>>>>>>
>>>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/689af0be/attachment-0001.html>

From billy.tetrud at gmail.com  Tue Aug 10 05:44:04 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Mon, 9 Aug 2021 22:44:04 -0700
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAD5xwhi_Sf1NRPBSAcWWFiAjyFsnmWbtowBF96j=EM4NXxfOKw@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <CAGpPWDZn6dcuEJXRjUP4VYvJbL9u4mmVoS9xTVzBrGWOM5CeZw@mail.gmail.com>
 <CAD5xwhi_Sf1NRPBSAcWWFiAjyFsnmWbtowBF96j=EM4NXxfOKw@mail.gmail.com>
Message-ID: <CAGpPWDYsRSv0Teiq5JD1iHJnAbRdCmr+e6UGvV5JDpoXL-7M0w@mail.gmail.com>

For sure, CT can be done with computational soundness. The advantage of
unhidden amounts (as with current bitcoin) is that you get unconditional
soundness. My understanding is that there is a fundamental tradeoff between
unconditional soundness and unconditional privacy. I believe Monero has
taken this alternate tradeoff path with unconditional privacy but only
computational soundness
<https://www.reddit.com/r/Monero/comments/8erg8e/what_should_monero_do_about_the_soundness_problem/dxy59ad?utm_source=share&utm_medium=web2x&context=3>
.

> old things that never move more or less naturally "fall leftward"

Ah yes, something like that would definitely be interesting to basically
make dust a moot point. Sounds like the tradeoff mentioned is that proofs
would be twice as big? Except newer UTXOs would have substantially shorter
proofs. It sounds like the kind of thing where there's some point where
there would be so many old UTXOs that proofs would be smaller on average in
the swap tree version vs the dead-leaf version. Maybe someone smarter than
me could estimate where that point is.

On Mon, Aug 9, 2021 at 10:04 PM Jeremy <jlrubin at mit.edu> wrote:

> You might be interested in https://eprint.iacr.org/2017/1066.pdf which
> claims that you can make CT computationally hiding and binding, see section
> 4.6.
>
> with respect to utreexo, you might review
> https://github.com/mit-dci/utreexo/discussions/249?sort=new which
> discusses tradeoffs between different accumulator designs. With a swap
> tree, old things that never move more or less naturally "fall leftward",
> although there are reasons to prefer alternative designs.
>
>
>>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210809/c4607f2b/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Aug 10 11:37:37 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 10 Aug 2021 11:37:37 +0000
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAGpPWDYsRSv0Teiq5JD1iHJnAbRdCmr+e6UGvV5JDpoXL-7M0w@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <CAGpPWDZn6dcuEJXRjUP4VYvJbL9u4mmVoS9xTVzBrGWOM5CeZw@mail.gmail.com>
 <CAD5xwhi_Sf1NRPBSAcWWFiAjyFsnmWbtowBF96j=EM4NXxfOKw@mail.gmail.com>
 <CAGpPWDYsRSv0Teiq5JD1iHJnAbRdCmr+e6UGvV5JDpoXL-7M0w@mail.gmail.com>
Message-ID: <JaAZipQkFFuBwE0ZQoFpmBe3K2WAOEUSNiGqQTx8ak5FqCPXSOZzjvjFAhaUX9e5i-TLnT8LmdzrUsLXi_RE3R3WsFEhybXiCJrg2YEyHdM=@protonmail.com>

Good morning Billy, et al.,

> For sure, CT can be done with computational soundness. The advantage of unhidden amounts (as with current bitcoin) is that you get unconditional soundness.

My understanding is that it should be possible to have unconditional soundness with the use of El-Gamal commitment scheme, am I wrong?

Alternately, one possible softforkable design would be for Bitcoin to maintain a non-CT block (the current scheme) and a separately-committed CT block (i.e. similar to how SegWit has a "separate" "block"/Merkle tree that includes witnesses).
When transferring funds from the legacy non-CT block, on the legacy block you put it into a "burn" transaction that magically causes the same amount to be created (with a trivial/publicly known salt) in the CT block.
Then to move from the CT block back to legacy non-CT you would match one of those "burn" TXOs and spend it, with a proof that the amount you are removing from the CT block is exactly the same value as the "burn" TXO you are now spending.

(for additional privacy, the values of the "burn" TXOs might be made into some fixed single allowed value, so that transfers passing through the CT portion would have fewer identifying features)

The "burn" TXOs would be some trivial anyone-can-spend, such as `<saltpoint> <0> OP_EQUAL OP_NOT` with `<saltpoint>` being what is used in the CT to cover the value, and knowledge of the scalar behind this point would allow the CT output to be spent (assuming something very much like MimbleWimble is used; otherwise it could be the hash of some P2WSH or similar analogue on the CT side).

Basically, this is "CT as a 'sidechainlike' that every fullnode runs".

In the legacy non-CT block, the total amount of funds that are in all CT outputs is known (it would be the sum total of all the "burn" TXOs) and will have a known upper limit, that cannot be higher than the supply limit of the legacy non-CT block, i.e. 21 million BTC.
At the same time, *individual* CT-block TXOs cannot have their values known; what is learnable is only how many BTC are in all CT block TXOs, which should be sufficient privacy if there are a large enough number of users of the CT block.

This allows the CT block to use an unconditional privacy and computational soundness scheme, and if somehow the computational soundness is broken then the first one to break it would be able to steal all the CT coins, but not *all* Bitcoin coins, as there would not be enough "burn" TXOs on the legacy non-CT blockchain.

This may be sufficient for practical privacy.


On the other hand, I think the dust limit still makes sense to keep for now, though.

Regards,
ZmnSCPxj

From lkcl at lkcl.net  Tue Aug 10 12:54:55 2021
From: lkcl at lkcl.net (Luke Kenneth Casson Leighton)
Date: Tue, 10 Aug 2021 13:54:55 +0100
Subject: [bitcoin-dev] Fwd: NLnet cryotoprimitives grant approved
In-Reply-To: <D93B223B-4030-46FB-8247-B197643560CE@gmail.com>
References: <mailman.13.1628596802.29734.bitcoin-dev@lists.linuxfoundation.org>
 <D93B223B-4030-46FB-8247-B197643560CE@gmail.com>
Message-ID: <CAPweEDznjs_LruZs1A5x6jQTpK4mwkDGLuP-NjEOqNCpjUNZyA@mail.gmail.com>

with many thanks to NLnet, the EUR 50,000 grant to research and
develop Draft cryptographic primitives and instructions to the
newly-open Power ISA has been approved.

unlike RISC-V where full transparency and trust is problematic and
there are many participants whose interests may not necessarily align,
the OpenPOWER initiative, which has been in careful planning for
nearly 10 years, is a much less crowded space and, crucially, does not
require non-transparent membership of OPF in order to submit ISA RFCs
(Requests for Change)

[non-OPF members cannot participate in actual ISA WG meetings and
certainly cannot vote on RFCs, but they can at least submit them.
whereas whilst the RISC-V Foundation's Commercial Confidence
Requirements are perfectly reasonable, the blanket secrecy even for
submitting RFCs is not]

we at Libre-SOC aim to use this process, based on taking apart key
strategic cryptographic algorithms back to their mathematical roots,
then applying Vector ISA design analysis and seeing what can be
created.

examples include going back to the fundamental basis of Rijndael, and
instead of creating hardcoded custom silicon for MixColumns as is the
"normal" practice, adding a generic Galois Field ALU and a generic
Matrix Multiply system.  another is to design instructions suitable
for "big integer math"

this in turn means that the resultant ISA would be ideally suited to
the experimental development of future cryptographic algorithms for
use in securing wallets and other purposes related to blockchain
management.

[as bitcoin stands we cannot possibly hope to compete with custom
silicon dedicated to SHA hash production, however we would very much
like to see a future version of bitcoin that uses far less power yet
retains its high strategic value, and, at the same time, like e.g.
monero RandomX, is better suited to a general-purpose Vector
Supercomputer ISA, which is what we are developing]

OpenPOWER's commitment to a transparent RFC process allows us to do
that without compromising trust: no discussions that we participate in
will ever be behind closed doors.

if anyone would be interested to participate or collaborate on this,
we have funding available, and welcome involvement in designing and
testing an ISA suitable for securing bitcoin for end-users in a fully
transparent fashion.

l.

---
crowd-funded eco-conscious hardware: https://www.crowdsupply.com/eoma68

From antoine.riard at gmail.com  Tue Aug 10 22:37:48 2021
From: antoine.riard at gmail.com (Antoine Riard)
Date: Tue, 10 Aug 2021 18:37:48 -0400
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <20210810061441.6rg3quotiycomcp6@ganymede>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
Message-ID: <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>

>  As developers, we have no
control over prevailing feerates, so this is a problem LN needs to deal
with regardless of Bitcoin Core's dust limit.

Right, as of today, we're going to trim-to-dust any commitment output of
which the value is inferior to the transaction owner's
`dust_limit_satoshis` plus the HTLC-claim (either success/timeout) fee at
the agreed on feerate. So the feerate is the most significant variable in
defining what's a LN *uneconomical output*.

IMO this approach presents annoying limitations. First, you still need to
come with an agreement among channel operators on the mempools feerate.
Such agreement might be problematic to find, as on one side you would like
to let your counterparty free to pick up a feerate gauged as efficient for
the confirmation of their transactions but at the same time not too high to
burn to fees your low-values HTLCs that *your* fee-estimator judged as sane
to claim.

Secondly, the trim-to-dust evaluation doesn't correctly match the lifetime
of the HTLC. A HTLC might be considered as dust at block 100, at which
mempools are full. Though its expiration only occurs at block 200, at which
mempools are empty and this HTLC is fine to claim again. I think this
inaccuracy will even become worse with a wider deployment of long-lived
routed packets over LN, such as DLCs or hodl invoices.

All this to say, if for those reasons LN devs remove feerate negotiation
from the trim-to-dust definition to a static feerate, it would likely put a
higher pressure on the full-nodes operators, as the number of uneconomical
outputs might increase.

(From a LN viewpoint, I would say we're trying to solve a price discovery
issue, namely the cost to write on the UTXO set, in a distributed system,
where any deviation from the "honest" price means you trust more your LN
counterparty)

> They could also use trustless probabalistic payments, which have been
discussed in the context of LN for handling the problem of payments too
small to be represented onchain since early 2016:
https://docs.google.com/presentation/d/1G4xchDGcO37DJ2lPC_XYyZIUkJc2khnLrCaZXgvDN0U/edit?pref=2&pli=1#slide=id.g85f425098

Thanks to bringing to the surface probabilistic payments, yes that's a
worthy alternative approach for low-value payments to keep in mind.

Le mar. 10 ao?t 2021 ? 02:15, David A. Harding <dave at dtrt.org> a ?crit :

> On Mon, Aug 09, 2021 at 09:22:28AM -0400, Antoine Riard wrote:
> > I'm pretty conservative about increasing the standard dust limit in any
> > way. This would convert a higher percentage of LN channels capacity into
> > dust, which is coming with a lowering of funds safety [0].
>
> I think that reasoning is incomplete.  There are two related things here:
>
> - **Uneconomical outputs:** outputs that would cost more to spend than
>   the value they contain.
>
> - **Dust limit:** an output amount below which Bitcoin Core (and other
>   nodes) will not relay the transaction containing that output.
>
> Although raising the dust limit can have the effect you describe,
> increases in the minimum necessary feerate to get a transaction
> confirmed in an appropriate amount of time also "converts a higher
> percentage of LN channel capacity into dust".  As developers, we have no
> control over prevailing feerates, so this is a problem LN needs to deal
> with regardless of Bitcoin Core's dust limit.
>
> (Related to your linked thread, that seems to be about the risk of
> "burning funds" by paying them to a miner who may be a party to the
> attack.  There's plenty of other alternative ways to burn funds that can
> change the risk profile.)
>
> > the standard dust limit [...] introduces a trust vector
>
> My point above is that any trust vector is introduced not by the dust
> limit but by the economics of outputs being worth less than they cost to
> spend.
>
> > LN node operators might be willingly to compensate this "dust" trust
> vector
> > by relying on side-trust model
>
> They could also use trustless probabalistic payments, which have been
> discussed in the context of LN for handling the problem of payments too
> small to be represented onchain since early 2016:
>
> https://docs.google.com/presentation/d/1G4xchDGcO37DJ2lPC_XYyZIUkJc2khnLrCaZXgvDN0U/edit?pref=2&pli=1#slide=id.g85f425098_0_178
>
> (Probabalistic payments were discussed in the general context of Bitcoin
> well before LN was proposed, and Elements even includes an opcode for
> creating them.)
>
> > smarter engineering such as utreexo on the base-layer side
>
> Utreexo doesn't solve this problem.  Many nodes (such as miners) will
> still want to store the full UTXO set and access it quickly,  Utreexo
> proofs will grow in size with UTXO set size (though, at best, only
> log(n)), so full node operators will still not want their bandwidth
> wasted by people who create UTXOs they have no reason to spend.
>
> > I think the status quo is good enough for now
>
> I agree.
>
> -Dave
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210810/c82980c2/attachment.html>

From ZmnSCPxj at protonmail.com  Wed Aug 11 00:46:36 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 11 Aug 2021 00:46:36 +0000
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
Message-ID: <A_6Qw_n4M_OknLaXunPNuVQG8rSndTGftVktnz2Z0bhTfO5VfkQDyGuFRrF2Y89fDhq8dRfY11oHWpg7EyGoS5EZuUkwoXNZD_RtDcmBZ3Q=@protonmail.com>

Good morning all,

Thinking a little more, if the dust limit is intended to help keep UTXO sets down, then on the LN side, this could be achieved as well by using channel factories (including "one-shot" factories which do not allow changing the topology of the subgraph inside the factory, but have the advantage of not requiring either `SIGHASH_NOINPUT` or an extra CSV constraint that is difficult to weigh in routing algorithms), where multiple channels are backed by a single UTXO.

Of course, with channel factories there is now a greater set of participants who will have differing opinions on appropriate feerate.

So I suppose one can argue that the dust limit becomes less material to higher layers, than actual onchain feerates.


Regards,
ZmnSCPxj

From coblee at litecoin.org  Tue Aug 10 18:39:39 2021
From: coblee at litecoin.org (Charlie Lee)
Date: Tue, 10 Aug 2021 12:39:39 -0600
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <JaAZipQkFFuBwE0ZQoFpmBe3K2WAOEUSNiGqQTx8ak5FqCPXSOZzjvjFAhaUX9e5i-TLnT8LmdzrUsLXi_RE3R3WsFEhybXiCJrg2YEyHdM=@protonmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <CAGpPWDZn6dcuEJXRjUP4VYvJbL9u4mmVoS9xTVzBrGWOM5CeZw@mail.gmail.com>
 <CAD5xwhi_Sf1NRPBSAcWWFiAjyFsnmWbtowBF96j=EM4NXxfOKw@mail.gmail.com>
 <CAGpPWDYsRSv0Teiq5JD1iHJnAbRdCmr+e6UGvV5JDpoXL-7M0w@mail.gmail.com>
 <JaAZipQkFFuBwE0ZQoFpmBe3K2WAOEUSNiGqQTx8ak5FqCPXSOZzjvjFAhaUX9e5i-TLnT8LmdzrUsLXi_RE3R3WsFEhybXiCJrg2YEyHdM=@protonmail.com>
Message-ID: <CA+Xj7Rxi2ouGk=qxB2nrEem58wutdoQ+aL=Z8egpSwotMMKHKg@mail.gmail.com>

ZmnSCPxj, what you are describing is pretty much what Litecoin is doing
with MWEB. Basically MimbleWimble (which has CT) with extension blocks. If
you are interested:
https://github.com/litecoin-project/lips/blob/master/lip-0002.mediawiki
https://github.com/litecoin-project/lips/blob/master/lip-0003.mediawiki

Sorry to derail the conversation with non-Bitcoin stuff. ?

- Charlie


On Tue, Aug 10, 2021 at 5:38 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Billy, et al.,
>
> > For sure, CT can be done with computational soundness. The advantage of
> unhidden amounts (as with current bitcoin) is that you get unconditional
> soundness.
>
> My understanding is that it should be possible to have unconditional
> soundness with the use of El-Gamal commitment scheme, am I wrong?
>
> Alternately, one possible softforkable design would be for Bitcoin to
> maintain a non-CT block (the current scheme) and a separately-committed CT
> block (i.e. similar to how SegWit has a "separate" "block"/Merkle tree that
> includes witnesses).
> When transferring funds from the legacy non-CT block, on the legacy block
> you put it into a "burn" transaction that magically causes the same amount
> to be created (with a trivial/publicly known salt) in the CT block.
> Then to move from the CT block back to legacy non-CT you would match one
> of those "burn" TXOs and spend it, with a proof that the amount you are
> removing from the CT block is exactly the same value as the "burn" TXO you
> are now spending.
>
> (for additional privacy, the values of the "burn" TXOs might be made into
> some fixed single allowed value, so that transfers passing through the CT
> portion would have fewer identifying features)
>
> The "burn" TXOs would be some trivial anyone-can-spend, such as
> `<saltpoint> <0> OP_EQUAL OP_NOT` with `<saltpoint>` being what is used in
> the CT to cover the value, and knowledge of the scalar behind this point
> would allow the CT output to be spent (assuming something very much like
> MimbleWimble is used; otherwise it could be the hash of some P2WSH or
> similar analogue on the CT side).
>
> Basically, this is "CT as a 'sidechainlike' that every fullnode runs".
>
> In the legacy non-CT block, the total amount of funds that are in all CT
> outputs is known (it would be the sum total of all the "burn" TXOs) and
> will have a known upper limit, that cannot be higher than the supply limit
> of the legacy non-CT block, i.e. 21 million BTC.
> At the same time, *individual* CT-block TXOs cannot have their values
> known; what is learnable is only how many BTC are in all CT block TXOs,
> which should be sufficient privacy if there are a large enough number of
> users of the CT block.
>
> This allows the CT block to use an unconditional privacy and computational
> soundness scheme, and if somehow the computational soundness is broken then
> the first one to break it would be able to steal all the CT coins, but not
> *all* Bitcoin coins, as there would not be enough "burn" TXOs on the legacy
> non-CT blockchain.
>
> This may be sufficient for practical privacy.
>
>
> On the other hand, I think the dust limit still makes sense to keep for
> now, though.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210810/2943c106/attachment.html>

From john.tromp at gmail.com  Tue Aug 10 21:03:11 2021
From: john.tromp at gmail.com (John Tromp)
Date: Tue, 10 Aug 2021 23:03:11 +0200
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
	Message-ID:
Message-ID: <CAOU__fx0ajVfuEyoYCOkf8nZPOkbuYDctTfuzhCDdoU=jcA0Tg@mail.gmail.com>

> Alternately, one possible softforkable design would be for Bitcoin to maintain a non-CT block (the current scheme) and a separately-committed CT block (i.e. similar to how SegWit has a "separate" "block"/Merkle tree that includes witnesses).
> When transferring funds from the legacy non-CT block, on the legacy block you put it into a "burn" transaction that magically causes the same amount to be created (with a trivial/publicly known salt) in the CT block.
> Then to move from the CT block back to legacy non-CT you would match one of those "burn" TXOs and spend it, with a proof that the amount you are removing from the CT block is exactly the same value as the "burn" TXO you are now spending.

> (for additional privacy, the values of the "burn" TXOs might be made into some fixed single allowed value, so that transfers passing through the CT portion would have fewer identifying features)
>
> The "burn" TXOs would be some trivial anyone-can-spend, such as `<saltpoint> <0> OP_EQUAL OP_NOT` with `<saltpoint>` being what is used in the CT to cover the value, and knowledge of the scalar behind this point would allow the CT output to be spent (assuming something very much like MimbleWimble is used; otherwise it could be the hash of some P2WSH or similar analogue on the CT side).
>
> Basically, this is "CT as a 'sidechainlike' that every fullnode runs".
>
> In the legacy non-CT block, the total amount of funds that are in all CT outputs is known (it would be the sum total of all the "burn" TXOs) and will have a known upper limit, that cannot be higher than the supply limit of the legacy non-CT block, i.e. 21 million BTC.
> At the same time, *individual* CT-block TXOs cannot have their values known; what is learnable is only how many BTC are in all CT block TXOs, which should be sufficient privacy if there are a large enough number of users of the CT block.
>
> This allows the CT block to use an unconditional privacy and computational soundness scheme, and if somehow the computational soundness is broken then the first one to break it would be able to steal all the CT coins, but not *all* Bitcoin coins, as there would not be enough "burn" TXOs on the legacy non-CT blockchain.
>
> This may be sufficient for practical privacy.

This is pretty much the Mimble Wimble Extension Block (MWEB) design
for Litecoin, as described at
https://vaultoro.com/what-is-mweb-on-litecoin/

True to the Harry Potter background theme of Mimblewimble, the regular
Litecoin transaction responsible for pegging into and out of the
extension block is call the Hogwarts Express (hogex).

If all goes well, it may activate as early as the end of this year...

regards,
-John

From ali at notatether.com  Thu Aug 12 16:26:23 2021
From: ali at notatether.com (Ali Sherief)
Date: Thu, 12 Aug 2021 16:26:23 +0000
Subject: [bitcoin-dev] src/httprpc.cpp InterruptHTTPRPC
Message-ID: <RR0E6V2u2GMj2AgH5MEy4nAI4PUOdWClgWtoErKa-Gf-mdWIuqLYGVxFQdYhLXE23nXbBnEWGNkmEYts3G3SosNlkgcDDzlr9aTRDnJ8XNk=@notatether.com>

I am using Bitcoin Core's HTTP RPC server as a basis for my own application. While browsing the source code of src/httprpc.cpp, I notice that the InterruptHTTPRPC function https://github.com/bitcoin/bitcoin/blob/7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/src/httprpc.cpp#L310-L314 just calls LogPrint() without doing anything else.

Does the HTTP RPC server support interrupting the event loop at this time, or is this method a stub?

- Ali
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210812/40816fcb/attachment.html>

From jlrubin at mit.edu  Thu Aug 12 18:09:19 2021
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 12 Aug 2021 11:09:19 -0700
Subject: [bitcoin-dev] src/httprpc.cpp InterruptHTTPRPC
In-Reply-To: <RR0E6V2u2GMj2AgH5MEy4nAI4PUOdWClgWtoErKa-Gf-mdWIuqLYGVxFQdYhLXE23nXbBnEWGNkmEYts3G3SosNlkgcDDzlr9aTRDnJ8XNk=@notatether.com>
References: <RR0E6V2u2GMj2AgH5MEy4nAI4PUOdWClgWtoErKa-Gf-mdWIuqLYGVxFQdYhLXE23nXbBnEWGNkmEYts3G3SosNlkgcDDzlr9aTRDnJ8XNk=@notatether.com>
Message-ID: <CAD5xwhhM8uJBnfHEUoorGza_osRaQ1uHm0e0=67aW44pvY71jw@mail.gmail.com>

This is probably best to open as an issue in github!
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Thu, Aug 12, 2021 at 11:03 AM Ali Sherief via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I am using Bitcoin Core's HTTP RPC server as a basis for my own
> application. While browsing the source code of src/httprpc.cpp, I notice
> that the InterruptHTTPRPC function
> https://github.com/bitcoin/bitcoin/blob/7fcf53f7b4524572d1d0c9a5fdc388e87eb02416/src/httprpc.cpp#L310-L314 just
> calls LogPrint() without doing anything else.
>
> Does the HTTP RPC server support interrupting the event loop at this time,
> or is this method a stub?
>
> - Ali
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210812/63ded220/attachment.html>

From aj at erisian.com.au  Thu Aug 12 22:03:39 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 13 Aug 2021 08:03:39 +1000
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
Message-ID: <20210812220339.GA3416@erisian.com.au>

On Tue, Aug 10, 2021 at 06:37:48PM -0400, Antoine Riard via bitcoin-dev wrote:
> Secondly, the trim-to-dust evaluation doesn't correctly match the lifetime of
> the HTLC.

Right: but that just means it's not something you should determine once
for the HTLC, but something you should determine each time you update the
channel commitment -- if fee rates are at 1sat/vb, then a 10,000 sat HTLC
that's going to cost 100 sats to create the utxo and eventually claim it
might be worth committing to, but if fee rates suddenly rise to 75sat/vb,
then the combined cost of 7500 sat probably isn't worthwhile (and it
certainly isn't worthwhile if fees rise to above 100sat/vb).

That's independent of dust limits -- those only give you a fixed size
lower limit or about 305sats for p2wsh outputs.

Things become irrational before they become uneconomic as well: ie the
100vb is perhaps 40vb to create then 60vb to spend, so if you create
the utxo anyway then the 40vb is a sunk cost, and redeeming the 10k sats
might still be marginally wortwhile up until about 167sat/vb fee rate.

But note the logic there: it's an uneconomic output if fees rise above
167sat/vb, but it was already economically irrational for the two parties
to create it in the first place when fees were at or above 100sat/vb. If
you're trying to save every sat, dust limits aren't your problem. If
you're not trying to save every sat, then just add 305 sats to your
output so you avoid the dust limit.

(And the dust limit is only preventing you from creating outputs that
would be irrational if they only required a pubkey reveal and signature
to spend -- so a HTLC that requires revealing a script, two hashes,
two pubkeys, a hash preimage and two signatures with the same dust
threshold value for p2wsh of ~305sats would already be irrational at
about 2.1sat/vb and unconomic at 2.75 sat/vb).

> (From a LN viewpoint, I would say we're trying to solve a price discovery
> issue, namely the cost to write on the UTXO set, in a distributed system, where
> any deviation from the "honest" price means you trust more your LN
> counterparty)

At these amounts you're already trusting your LN counterparty to not just
close the channel unilaterally at a high fee rate time and waste your
funds in fees, vs doing a much for efficient mutual/cooperative close.

Cheers,
aj


From erik at q32.com  Thu Aug 12 22:08:40 2021
From: erik at q32.com (Erik Aronesty)
Date: Thu, 12 Aug 2021 18:08:40 -0400
Subject: [bitcoin-dev] PSA: Taproot loss of quantum protections
In-Reply-To: <CAJowKgLuWOkD=_jDaLqG=FOG02qX7p4-EZ69yvw4UqcWpz+rRg@mail.gmail.com>
References: <202103152148.15477.luke@dashjr.org>
 <CAJowKgLuWOkD=_jDaLqG=FOG02qX7p4-EZ69yvw4UqcWpz+rRg@mail.gmail.com>
Message-ID: <CAJowKgJ5ko2Xac+-Mr9RQgdDKmuX__wOBgpUe_Qe6Egjavj7BQ@mail.gmail.com>

Noe: for A. Chow's upgrade to work, there obviously has to be an
effort to deliberately-blacklist unupgraded coins, say after 10-20
years of opportunity to upgrade, or something like that, as long as
the transition to quantum isn't so fast that there's no way to do
this.

On Mon, Mar 22, 2021 at 10:24 AM Erik Aronesty <erik at q32.com> wrote:
>
> The argument that hashed public addresses provide meaningful quantum
> resistance is flawed *when considered in the context*.of Bitcoin
> itself.
>
> This article by Andrew Chow is easy to read and makes a strong case
> against the quantum utility of hashed public keys:
> https://cryptowords.github.io/why-does-hashing-public-keys-not-actually-provide-any-quantum-resistance
>
> And then, of course, one should be mindful of the case against quantum
> computing itself - it is neither inevitable nor "just around the
> corner".   Mikhail Dyakonov summarized the arguments well here:
> https://t.co/cgrfrroTTT?amp=1.
>
> My current stance (at my company at least) is that planning for
> quantum computing should be limited to "a provable and written ability
> to upgrade if it becomes clear that it's necessary."
>
> Does anyone think it would it be useful to write up a more official,
> and even partly functional plan for Bitcoin to use zero-knowledge
> proofs to transition to quantum resistance?
>
> - Erik Aronesty
>   CTO, Atkama
>
> On Mon, Mar 15, 2021 at 5:48 PM Luke Dashjr via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > I do not personally see this as a reason to NACK Taproot, but it has become
> > clear to me over the past week or so that many others are unaware of this
> > tradeoff, so I am sharing it here to ensure the wider community is aware of
> > it and can make their own judgements.
> >
> > Mark Friedenbach explains on his blog:
> >     https://freicoin.substack.com/p/why-im-against-taproot
> >
> > In short, Taproot loses an important safety protection against quantum.
> > Note that in all circumstances, Bitcoin is endangered when QC becomes a
> > reality, but pre-Taproot, it is possible for the network to "pause" while a
> > full quantum-safe fix is developed, and then resume transacting. With Taproot
> > as-is, it could very well become an unrecoverable situation if QC go online
> > prior to having a full quantum-safe solution.
> >
> > Also, what I didn't know myself until today, is that we do not actually gain
> > anything from this: the features proposed to make use of the raw keys being
> > public prior to spending can be implemented with hashed keys as well.
> > It would use significantly more CPU time and bandwidth (between private
> > parties, not on-chain), but there should be no shortage of that for anyone
> > running a full node (indeed, CPU time is freed up by Taproot!); at worst, it
> > would create an incentive for more people to use their own full node, which
> > is a good thing!
> >
> > Despite this, I still don't think it's a reason to NACK Taproot: it should be
> > fairly trivial to add a hash on top in an additional softfork and fix this.
> >
> > In addition to the points made by Mark, I also want to add two more, in
> > response to Pieter's "you can't claim much security if 37% of the supply is
> > at risk" argument. This argument is based in part on the fact that many
> > people reuse Bitcoin invoice addresses.
> >
> > First, so long as we have hash-based addresses as a best practice, we can
> > continue to shrink the percentage of bitcoins affected through social efforts
> > discouraging address use. If the standard loses the hash, the situation
> > cannot be improved, and will indeed only get worse.
> >
> > Second, when/if quantum does compromise these coins, so long as they are
> > neglected or abandoned/lost coins (inherent in the current model), it can be
> > seen as equivalent to Bitcoin mining. At the end of the day, 37% of supply
> > minable by QCs is really no different than 37% minable by ASICs. (We've seen
> > far higher %s available for mining obviously.)
> >
> > To conclude, I recommend anyone using Bitcoin to read Mark's article, my
> > thoughts, and any other arguments on the topic; decide if this is a concern
> > to you, and make your own post(s) accordingly. Mark has conceded the argument
> > (AFAIK he doesn't have an interest in bitcoins anyway), and I do not consider
> > it a showstopper - so if anyone else out there does, please make yourself
> > known ASAP since Taproot has already moved on to the activation phase and it
> > is likely software will be released within the next month or two as things
> > stand.
> >
> > Luke
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From zachgrw at gmail.com  Fri Aug 13 11:02:14 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Fri, 13 Aug 2021 13:02:14 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <20210725053803.fnmd6etv3f7x3u3p@ganymede>
 <CAGpPWDZ8EWd7kGV5pFZadQM1kqETrTK2zybsGF1hW9fx2oZb7w@mail.gmail.com>
 <CAH+Axy7cPufMUCMQbCz2MUgRqQbgenAozPBFD8kPYrSjwcRG8w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
Message-ID: <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>

Hi ZmnSCPxj,

Thank you for your insightful response.

Perhaps I should take a step back and take a strictly functional angle.
Perhaps the list could help me to establish whether the proposed
functionality is:

Desirable;
Not already possible;
Feasible to implement.

The proposed functionality is as follows:

The ability to control some coin with two private keys (or two sets of
private keys) such that spending is limited over time for one private key
(i.e., it is for instance not possible to spend all coin in a single
transaction) while spending is unrestricted for the other private key (no
limits apply). No limits must apply to coin transacted to a third party.

Also, it must be possible never having to bring the unrestricted private
key online unless more than the limit imposed on the restrictive private
key is desired to be spent.

Less generally, taking the perspective of a hodler: the user must be able
to keep one key offline and one key online. The offline key allows
unrestricted spending, the online key is limited in how much it is allowed
to spend over time.

Furthermore, the spending limit must be intuitive. Best candidate I believe
would be a maximum spend per some fixed number of blocks. For instance, the
restrictive key may allow a maximum of 100k sats per any window of 144
blocks. Ofcourse the user must be able to set these parameters freely.

I look forward to any feedback you may have.

Zac



On Tue, 10 Aug 2021 at 04:17, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

>  fromGood morning Zac,
>
>
> With some work, what you want can be implemented, to some extent, today,
> without changes to consensus.
>
> The point you want, I believe, is to have two sets of keys:
>
> * A long-term-storage keyset, in "cold" storage.
> * A short-term-spending keyset, in "warm" storage, controlling only a
> small amount of funds.
>
> What you can do would be:
>
> * Put all your funds in a single UTXO, with an k-of-n of your cold keys
> (ideally P2TR, or some P2WSH k-of-n).
> * Put your cold keys online, and sign a transaction spending the above
> UTXO, and spending most of it to a new address that is a tweaked k-of-n of
> your cold keys, and a smaller output (up to the limit you want) controlled
> by the k-of-n of your warm keys.
>   * Keep this transaction offchain, in your warm storage.
> * Put your cold keys back offline.
> * When you need to spend using your warm keys, bring the above transaction
> onchain, then spend from the budget as needed.
>
>
> If you need to have some estimated amount of usable funds for every future
> unit of time, just create a chain of transactions with future `nLockTime`.
>
>                                   nLocktime +1day  nLockTime +2day
>                   +------------+   +------------+   +------------+
>      cold UTXO -->|    cold TXO|-->|    cold TXO|-->|    cold TXO|--> etc.
>                   |            |   |            |   |            |
>                   |    warm TXO|   |    warm TXO|   |    warm TXO|
>                   +------------+   +------------+   +------------+
>
> Pre-sign the above transactions, store the pre-signed transactions in warm
> storage together with your warm keys.
> Then put the cold keys back offline.
>
> Then from today to tomorrow, you can spend only the first warm TXO.
> From tomorrow to the day after, you can spend only the first two warm TXOs.
> And so on.
>
> If tomorrow your warm keys are stolen, you can bring the cold keys online
> to claim the second cold TXO and limit your fund loss to only just the
> first two warm TXOs.
>
> The above is bulky, but it has the advantage of not using any special
> opcodes or features (improving privacy, especially with P2TR which would in
> theory allow k-of-n/n-of-n to be indistinguishable from 1-of-1), and using
> just `nLockTime`, which is much easier to hide since most modern wallets
> will set `nLockTime` to recent block heights.
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210813/35283ad0/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat Aug 14 01:50:45 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 14 Aug 2021 01:50:45 +0000
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
	a function of total input value
In-Reply-To: <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
Message-ID: <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>

Good morning Zac,


> Hi?ZmnSCPxj,
>
> Thank you for your insightful response.
>
> Perhaps I should take a step back and take a strictly functional angle. Perhaps the list could help me to establish whether?the proposed functionality is:
>
> Desirable;
> Not already possible;
> Feasible to implement.
>
> The proposed functionality is as follows:
>
> The ability to control some coin with two private keys (or two sets of private keys) such that spending is limited over time for one private key (i.e., it is for instance not possible to spend all coin in a single transaction) while spending is unrestricted for the other private key (no limits apply). No limits must apply to coin transacted to a third party.
>
> Also, it must be possible never having to bring the unrestricted private key online unless more than the limit imposed on the restrictive private key is desired to be spent.
>
> Less generally, taking the perspective of a hodler: the user must be able to keep one key offline and one key online. The offline key allows unrestricted spending, the online key is limited in how much it is allowed to spend over time.
>
> Furthermore, the spending limit must be intuitive. Best candidate I believe would be a maximum spend per some fixed number of blocks. For instance, the restrictive key may allow a maximum of 100k sats per any window of 144 blocks. Ofcourse the user must be able to set these parameters freely.

My proposal does not *quite* implement a window.
However, that is because it uses `nLockTime`.

With the use of `nSequence` in relative-locktime mode, however, it *does* implement a window, sort of.
More specifically, it implements a timeout on spending --- if you spend using a presigned transaction (which creates an unencumbered specific-valued TXO that can be arbitrarily spent with your online keyset) then you cannot get another "batch" of funds until the `nSequence` relative locktime passes.
However, this *does* implement a window that limits a maximum value spendable per any window of the relative timelock you select.

The disadvantage is that `nSequence` use is a lot more obvious and discernible than `nLockTime` use.
Many wallets today use non-zero `nLockTime` for anti-fee-sniping, and that is a good cover for `nLockTime` transactions.
I believe Dave Harding proposed that wallets should also use, at random, (say 50-50) `nSequence`-in-relative-locktime-mode as an alternate anti-fee-sniping mechanism.
This alternate anti-fee-sniping would help cover `nSequence` use.

Note that my proposal does impose a maximum limit on the number of windows.
With `nSequence`-in-relative-locktime-mode the limit is the number of times that the online keyset can spend.
After spending that many windows, the offline keyset has to be put back online to generate a new set of transactions.

It has the massive massive advantage that you can implement it today without any consensus change, and I think you can expect that consensus change will take a LONG time (xref SegWit, Taproot).

Certainly the functionality is desirable.
But it seems it can be implemented with Bitcoin today.

Regards,
ZmnSCPxj


From prayank at tutanota.de  Sat Aug 14 01:15:20 2021
From: prayank at tutanota.de (Prayank)
Date: Sat, 14 Aug 2021 03:15:20 +0200 (CEST)
Subject: [bitcoin-dev] bitcoin-ps | Desktop application to test Bitcoin Core
 using PowerShell scripts
Message-ID: <Mh1DZ-N--3-2@tutanota.de>

Hello World,

I was working on an intern project in last few weeks which is almost ready for first release. Will be helpful if devs working on Bitcoin Core and .NET projects related to Bitcoin can share feedback. Pieter Wuille and Luke Dashjr had already shared few things before I started working on this project which wasn't really positive considering the use of .NET and PowerShell in this project. I respect their opinion and agree we could make better applications however I have tried my best to express the goal I am trying to achieve with this project below.

Project repository:?https://github.com/prayank23/bitcoin-ps

Other details about related milestones:?https://github.com/BlockchainCommons/Community/discussions/51

Project is inspired by Burp Suite and I want to create a similar application which is only used to test privacy and security of Bitcoin Core RPC using GUI. I used WPF instead of Avalonia right now to save time. I will use it in future to make bitcoin-ps cross platform, most of the code will remain same and I have shared a proof of concept in milestones link above in which application works fine on Ubuntu with no pwsh installed. Hopefully this issue will also be resolved soon:?https://github.com/AvaloniaUI/Avalonia/issues/4361

Default scripts:

1.CPU_RAM_sendtoaddress.ps1 : Check CPU and RAM usage while using some wallet RPCs multiple times. Results for Ubuntu and Windows were interesting. For some reason it almost used 100% CPU in Ubuntu.

2.onlynet_i2p.ps1 : Outbound connections are made to onion peers while onlynet=i2p is used without any proxy

3.lock_unspent.ps1 : Check if locked UTXOs are unlocked on restart

4.custom_change_rbf.ps1: Compares the inputs for Tx1 and Tx2 where Tx1 is RBF transaction with 1 input, 2 ouputs (custom change address with label), Tx2 is replacement transaction

Why PowerShell?

1.I have worked on 2 similar projects in past: A basic application for Office 365 admins and support engineers and One project related to Infosec.
2.Testing using different languages locally doesn't impact Bitcoin Core or require any changes.
3.Easier to write and devs who use PowerShell scripts in their projects could relate to it, find interesting and maybe start contributing to Bitcoin Core.
4.It can be done using bash or maybe python scripts as well. For me using PowerShell in this project is like meeting a college friend and exploring new places.
5.PowerShell Core is open source and works on Linux, Mac etc.

Last but not least, I would like to thank Christopher, Vinay, guests in meetings, other interns and everyone involved in Blockchain Commons. I have learnt lot of new things during internship. Would suggest everyone to start with 'Learning Bitcoin from the Command Line' if they have recently started reading about Bitcoin. I wish I could do more projects, will work on DEX and OfflineTx even after internship ends to complete by end of this year.
-- 
Prayank

A3B1 E430 2298 178F 
?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210814/617f14bf/attachment.html>

From ts at cronosurf.com  Mon Aug 16 04:23:25 2021
From: ts at cronosurf.com (ts)
Date: Sun, 15 Aug 2021 23:23:25 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to avoid
 errors on BTC public addresses
Message-ID: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>

Entering a BTC address for a transaction can pose a risk of error (human or technical). While 
there is a checksum integrated in BTC addresses already, this is used only at a technical 
level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not 
improve the overall user experience.

In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets 
call it 4DC for this text), generated as checksum from the address. This 4DC should be shown 
in all wallets next to the receiving address. When entering a new address to send BTC, the 
sending wallet should also show the 4DC next to the entered address. This way, the sending 
person can easily verify that the resulting 4DC matches the one from the receiving address.

This would mean that a receiver would not only send his public address to the sender, but also 
the 4DC. A minor disadvantage since a) it is not mandatory and b) it is very easy to do. 
However, it would greatly reduce the probability of performing transactions to a wrong address.

Technically, this is very easy to implement. The only effort needed is agreeing on a checksum 
standard to generate the code. Once the standard is established, all wallet and exchange 
developers can start implementing this.

Agreeing on a good name for this code would be helpful for a fast adoption (human readable 
checksum, verification code or 4DC are just examples).

Obviously, this solution could be used for all other coins/networks. But ideally, each of them 
should have its own checksum algorithm, in order to further avoid sending funds to the wrong 
network. Especially when the address standard is the same like it is the case with BTC and BCH.

Hopefully, Bitcoin can implement this first and serve as example-to-follow to other 
coins/networks.

Cheers,
TS

From ZmnSCPxj at protonmail.com  Mon Aug 16 10:34:36 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 16 Aug 2021 10:34:36 +0000
Subject: [bitcoin-dev] Human readable checksum (verification code) to
	avoid errors on BTC public addresses
In-Reply-To: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
Message-ID: <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>

Good morning TS,

> Entering a BTC address for a transaction can pose a risk of error (human or technical). While
> there is a checksum integrated in BTC addresses already, this is used only at a technical
> level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not
> improve the overall user experience.
>
> In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets
> call it 4DC for this text), generated as checksum from the address. This 4DC should be shown
> in all wallets next to the receiving address. When entering a new address to send BTC, the
> sending wallet should also show the 4DC next to the entered address. This way, the sending
> person can easily verify that the resulting 4DC matches the one from the receiving address.
>
> This would mean that a receiver would not only send his public address to the sender, but also
> the 4DC. A minor disadvantage since a) it is not mandatory and b) it is very easy to do.
> However, it would greatly reduce the probability of performing transactions to a wrong address.
>
> Technically, this is very easy to implement. The only effort needed is agreeing on a checksum
> standard to generate the code. Once the standard is established, all wallet and exchange
> developers can start implementing this.

I think the "only" effort here is going to be the main bulk of the effort, and it will still take years of agreement (or sipa doing it, because every review is "either sipa made it, or we have to check *everything* in detail for several months to make sure it is correct").

In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?

On the other side of the coin, if you say "the existing bech32 checksum is automatically checked by the software", why is forcing something to be manually checked by a human better than leaving the checking to software?


Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Mon Aug 16 11:48:43 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 16 Aug 2021 11:48:43 +0000
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
	a function of total input value
In-Reply-To: <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
 <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
 <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>
Message-ID: <wdlRrp4fZxH79mzVpTQWp99V9uI8jLvRU40mwdJ8lZ5A2mGMsxUK1TmZEZTV7O4_eUnNyq3feEGv5BUN-ecPSlbL-EYR6ZyLxk9ErsFiPlE=@protonmail.com>

Good morning Zac,

> Thank you for your counterproposal. I fully agree that as a first step we must establish whether the proposed functionality can be implemented without making any changes to consensus.
>
> Your counterproposal is understandably more technical in nature because it explores an implementation on top of Bitcoin as-is. However I feel that for a fair comparison of the functionality of both proposals a purely functional description of your proposal is essential.
>
> If I understand your proposal correctly, then I believe there are some major gaps between yours and mine:
>
> Keys for unrestricted spending: in my proposal, they never have to come online unless spending more than the limit is desired. In your proposal, these keys are required to come online in several situations.

Correct, that is indeed a weakness.

It is helpful to see https://zmnscpxj.github.io/bitcoin/unchained.html
Basically: any quorum of signers can impose any rules that are not implementable on the base layer, including the rules you desire.
That quorum is the "offline keyset" in my proposal.

>
> Presigning transactions: not required in my proposal. Wouldn?t such presigning requirement be detrimental for the usability of your proposal? Does it mean that for instance the amount and window in which the transaction can be spent is determined at the time of signing? In my proposal, there is no limit in the number of transactions per window.

No.
Remember, the output is a simple 1-of-1 or k-of-n of the online keyset.
The online keyset can spend that wherever and however, including paying it out to N parties, or paying part of the limit to 1 party and then paying the remainder back to the same onchain keyset so it can access the funds in the future.
Both cases are also available in your proposal, and the latter case (pay out part of the limit to a single output, then keep the rest back to the same onchain keyset) can be used to add an indefinite number of transactions per window.

>
> Number of windows: limited in your proposal, unlimited in mine.

Correct, though you can always have a fairly large number of windows ("640kB ought to be enough for anybody").

>
> There are probably additional gaps that I am currently not technically able to recognize.

It requires a fair amount of storage for the signatures at minimum, though that may be as small as 64 bytes per window.
1Mb of storage for signatures would allow 16,384 windows, assuming you use 1-day windows that is about 44.88 years, probably more than enough that a one-time onlining of the offline keys (or just print out the signatures on paper or display as a QR code, whatever) is acceptable.

> I feel that the above gaps are significant enough to state that your proposal does not meet the basic requirements of my proposal.
>
> Next to consider is whether the gap is acceptable, weighing the effort to implement the required consensus changes against the effort and feasibility of implementing your counterproposal.
>
> I feel that your counterproposal has little chance of being implemented because of the still considerable effort required and the poor result in functional terms. I also wonder if your proposal is feasible considering wallet operability.

See above, particularly the gap that does not, in fact, exist.

>
> Considering all the above, I believe that implementing consensus changes in order to support the proposed functionality would preferable ?over your counterproposal.
>
> I acknowledge that a consensus change takes years and is difficult to achieve, but that should not be any reason to stop exploring the appetite for the proposed functionality and perhaps start looking at possible technical solutions.

You can also look into the "covenant" opcodes (`OP_CHECKSIGFROMSTACK`, `OP_CHECKTEMPLATEVERIFY`, etc.), I think JeremyRubin has a bunch of them listed somewhere, which may be used to implement something similar without requiring presigning.

Since the basic "just use `nSequence`" scheme already implements what you need, what the covenant opcodes buy you is that you do not need the offline keyset to be onlined and there is no need to keep signatures, removing the remaining gaps you identified.
With a proper looping covenant opcode, there is also no limit on the number of windows.

The issue with the covenant opcodes is that there are several proposals with overlapping abilities and different tradeoffs.
This is the sort of thing that invites bikeshed-painting.

I suggest looking into the covenant opcodes and supporting those instead of your own proposal, as your application is very close to one of the motivating examples for covenants in the first place.

Regards,
ZmnSCPxj

From zachgrw at gmail.com  Mon Aug 16 11:17:19 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Mon, 16 Aug 2021 13:17:19 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <CAGpPWDb8yzGO-VtCO-x09e-phKHT7ezOms+DzeWc9vS3rN1AAw@mail.gmail.com>
 <CAJ4-pEDWuNfdE4NXkZBsOnuSQ4YOv28YVwGavyiU+FPvpC6y1w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
 <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
Message-ID: <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>

Hi ZmnSCPxj,

Thank you for your counterproposal. I fully agree that as a first step we
must establish whether the proposed functionality can be implemented
without making any changes to consensus.

Your counterproposal is understandably more technical in nature because it
explores an implementation on top of Bitcoin as-is. However I feel that for
a fair comparison of the functionality of both proposals a purely
functional description of your proposal is essential.

If I understand your proposal correctly, then I believe there are some
major gaps between yours and mine:

Keys for unrestricted spending: in my proposal, they never have to come
online unless spending more than the limit is desired. In your proposal,
these keys are required to come online in several situations.

Presigning transactions: not required in my proposal. Wouldn?t such
presigning requirement be detrimental for the usability of your proposal?
Does it mean that for instance the amount and window in which the
transaction can be spent is determined at the time of signing? In my
proposal, there is no limit in the number of transactions per window.

Number of windows: limited in your proposal, unlimited in mine.

There are probably additional gaps that I am currently not technically able
to recognize.

I feel that the above gaps are significant enough to state that your
proposal does not meet the basic requirements of my proposal.

Next to consider is whether the gap is acceptable, weighing the effort to
implement the required consensus changes against the effort and feasibility
of implementing your counterproposal.

I feel that your counterproposal has little chance of being implemented
because of the still considerable effort required and the poor result in
functional terms. I also wonder if your proposal is feasible considering
wallet operability.

Considering all the above, I believe that implementing consensus changes in
order to support the proposed functionality would preferable  over your
counterproposal.

I acknowledge that a consensus change takes years and is difficult to
achieve, but that should not be any reason to stop exploring the appetite
for the proposed functionality and perhaps start looking at possible
technical solutions.

Zac


On Sat, 14 Aug 2021 at 03:50, ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Zac,
>
>
> > Hi ZmnSCPxj,
> >
> > Thank you for your insightful response.
> >
> > Perhaps I should take a step back and take a strictly functional angle.
> Perhaps the list could help me to establish whether the proposed
> functionality is:
> >
> > Desirable;
> > Not already possible;
> > Feasible to implement.
> >
> > The proposed functionality is as follows:
> >
> > The ability to control some coin with two private keys (or two sets of
> private keys) such that spending is limited over time for one private key
> (i.e., it is for instance not possible to spend all coin in a single
> transaction) while spending is unrestricted for the other private key (no
> limits apply). No limits must apply to coin transacted to a third party.
> >
> > Also, it must be possible never having to bring the unrestricted private
> key online unless more than the limit imposed on the restrictive private
> key is desired to be spent.
> >
> > Less generally, taking the perspective of a hodler: the user must be
> able to keep one key offline and one key online. The offline key allows
> unrestricted spending, the online key is limited in how much it is allowed
> to spend over time.
> >
> > Furthermore, the spending limit must be intuitive. Best candidate I
> believe would be a maximum spend per some fixed number of blocks. For
> instance, the restrictive key may allow a maximum of 100k sats per any
> window of 144 blocks. Ofcourse the user must be able to set these
> parameters freely.
>
> My proposal does not *quite* implement a window.
> However, that is because it uses `nLockTime`.
>
> With the use of `nSequence` in relative-locktime mode, however, it *does*
> implement a window, sort of.
> More specifically, it implements a timeout on spending --- if you spend
> using a presigned transaction (which creates an unencumbered
> specific-valued TXO that can be arbitrarily spent with your online keyset)
> then you cannot get another "batch" of funds until the `nSequence` relative
> locktime passes.
> However, this *does* implement a window that limits a maximum value
> spendable per any window of the relative timelock you select.
>
> The disadvantage is that `nSequence` use is a lot more obvious and
> discernible than `nLockTime` use.
> Many wallets today use non-zero `nLockTime` for anti-fee-sniping, and that
> is a good cover for `nLockTime` transactions.
> I believe Dave Harding proposed that wallets should also use, at random,
> (say 50-50) `nSequence`-in-relative-locktime-mode as an alternate
> anti-fee-sniping mechanism.
> This alternate anti-fee-sniping would help cover `nSequence` use.
>
> Note that my proposal does impose a maximum limit on the number of windows.
> With `nSequence`-in-relative-locktime-mode the limit is the number of
> times that the online keyset can spend.
> After spending that many windows, the offline keyset has to be put back
> online to generate a new set of transactions.
>
> It has the massive massive advantage that you can implement it today
> without any consensus change, and I think you can expect that consensus
> change will take a LONG time (xref SegWit, Taproot).
>
> Certainly the functionality is desirable.
> But it seems it can be implemented with Bitcoin today.
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210816/298ee64f/attachment.html>

From remyers at yakshaver.org  Tue Aug 17 11:24:14 2021
From: remyers at yakshaver.org (Richard Myers)
Date: Tue, 17 Aug 2021 11:24:14 +0000
Subject: [bitcoin-dev] Anyprevout functional tests using eltoo scripts
Message-ID: <bKBvblUbWYaUVwNep6qrX76vo0l3jZgOgNcS1DI0HwIeKSfpz7D-uN4RaZ82xmLV5KvKrGjLDBUUYAgwV_JqajRzvhQQ1lA-526wGk6VTSw=@yakshaver.org>

I implemented some basic functional test scripts for the eltoo channel update scheme to better understand BIP-118/Anyprevout (APO). My tests are based on the rough Taproot eltoo scripts AJ Towns outlined on this list back in 2019. These tests also require AJ's APO branch of core. This is just the start of a real eltoo implementation, but I wanted to share it to get feedback and to help others interested in understanding APO and eltoo.

If you want to take a quick look, my functional tests are implemented in the function "test_tapscript_eltoo":
https://github.com/remyers/bitcoin/blob/eltoo-anyprevout/test/functional/simulate_eltoo.py#L1623

I've also written a blog post that describes in more detail how to run the tests and includes notes that I hope will be helpful to anyone else interested in APO and eltoo:
https://yakshaver.org/2021/07/26/first.html

I'd love to work with anyone else interested in eltoo and APO who wants to help extend and elaborate these tests. Any PRs for the eltoo tests or blog post would be very welcome.

Many thanks to AJ and Christian Decker who have both been very generous with their time in helping me understand the finer details of APO and eltoo.

All the best,

-- Richard
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210817/3302d5cf/attachment.html>

From shymaa.arafat at gmail.com  Wed Aug 18 19:06:30 2021
From: shymaa.arafat at gmail.com (shymaa arafat)
Date: Wed, 18 Aug 2021 21:06:30 +0200
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
Message-ID: <CAM98U8m9=D115g-wHuVsVcSP6z7Q0EqNt0bbQKFo00ZZx0QR1g@mail.gmail.com>

Dear Sir,

I'm not discussing the dust limit here, but I'm suggesting some mitigations
to the dust problem which tackles almost the same points mentioned here
especially the scalability of the UTXOS set and the corresponding Merkle
proofs/witnesses in Utreexo or any similar design ....
.
I suggest:
1-Dust UTXOS, along with burned & non-standard UTXOS, to be stored
separately in secondary storage; their Hashes in a separate Merkle too in
any accumulator design
(an earlier draft of the idea
https://bitcointalk.org/index.php?topic=5343748.new#new)
.
-In fact, the idea of separating the real UTXO values was first suggested in
https://royalsocietypublishing.org/doi/10.1098/rsos.180817
In their words
"Similarly, one can think of a two-tier data structure where a UTXO subset
containing UTXOs with a low probability of being selected such as dust is
kept on disk, while the other UTXOs are kept in memory."
.
2-I suggest also that existing dust UTXOS (from the same paper, in some
cases a UTXO could be added as an extra input with the cost of 68*fee/byte)
, to be selected with large UTXO whenever they fit in a spending ( use one
large & one small to get rid of the small)
.
3-In general when user is not willing to leave the dust to the fee, and if
there's no dust UTXOS, do not let the coin selection algorithm select the
closest match; let it choose the smallest that doesn't create dust.
For example if there's UTXOS 0.00013 & 0.00012 and user want to spend
0.0001198 choose 0.00013 so that the change is not dust (with same cost).
.
Thank you for your time,
This is the first time I send a suggestion to your emailing list, so sorry
if I missed any regulations
.
Shymaa M. Arafat
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210818/05bf3a96/attachment.html>

From ts at cronosurf.com  Thu Aug 19 17:02:38 2021
From: ts at cronosurf.com (ts)
Date: Thu, 19 Aug 2021 12:02:38 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
Message-ID: <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>

Hello ZmnSCPxj,

ZmnSCPxj wrote on 8/16/21 5:34 AM:
> Good morning TS,
> 
>> Entering a BTC address for a transaction can pose a risk of error (human or technical). While
>> there is a checksum integrated in BTC addresses already, this is used only at a technical
>> level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not
>> improve the overall user experience.
>>
>> In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets
>> call it 4DC for this text), generated as checksum from the address. This 4DC should be shown
>> in all wallets next to the receiving address. When entering a new address to send BTC, the
>> sending wallet should also show the 4DC next to the entered address. This way, the sending
>> person can easily verify that the resulting 4DC matches the one from the receiving address.
>>
>> This would mean that a receiver would not only send his public address to the sender, but also
>> the 4DC. A minor disadvantage since a) it is not mandatory and b) it is very easy to do.
>> However, it would greatly reduce the probability of performing transactions to a wrong address.
>>
>> Technically, this is very easy to implement. The only effort needed is agreeing on a checksum
>> standard to generate the code. Once the standard is established, all wallet and exchange
>> developers can start implementing this.
> 


Thanks for your comments.


> I think the "only" effort here is going to be the main bulk of the effort, and it will still take years of agreement (or sipa doing it, because every review is "either sipa made it, or we have to check *everything* in detail for several months to make sure it is correct").

I understand. If sipa could do it that would greatly simplify the process. Once an algorithm 
for the generation of the code exists, it just needs to be communicated to wallet developers 
and let it grow organically. No need of extensive testing, since it is only a very simple 
function.


> In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?

Well, because
a) most people don't know that
b) it is specific to bech32
c) it is not easily readable being the last digits of a long address (although this could be 
fixed by the wallet by showing those digits bigger or separately)
d) and most importantly: as mentioned in above my proposal, it only proves that an address is 
valid, but not necessarily the correct one (perhaps the user copied the wrong address, there 
was an old address in the clipboard, etc.)


> On the other side of the coin, if you say "the existing bech32 checksum is automatically checked by the software", why is forcing something to be manually checked by a human better than leaving the checking to software?

Not better, it should be on top. And not forced, but just as an optional check for the user. 
The SW can (and should) only check that the address is valid (the SW doesn't know the user's 
intent). Only the human can "double-check" an easy-to-read-code to quickly know that he is 
doing the right thing. (Entering a valid but wrong address is even worse than entering an 
invalid one, since the latter will be stopped by the wallet. But the former most likely 
results in loosing the funds.)

Note: The code should never be entered manually or even copied together with the address in 
one string. From the SW point of view, the code is an output only, never an input. It is 
merely a visual verification for the user.

Example of use: person A calls via phone person B and says: "Send me 0.1 BTC to my address I 
just sent you via whatsapp. When entering the address, make sure that you get the verification 
code 4385."

Regards,
TS


> 
> 
> Regards,
> ZmnSCPxj
> 

From ChristopherA at lifewithalacrity.com  Thu Aug 19 17:37:29 2021
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Thu, 19 Aug 2021 10:37:29 -0700
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
 <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
Message-ID: <CACrqygDK4oKSvY0XXPXH=MmKAvHkmw2CoASwySn0qGteBUYr9Q@mail.gmail.com>

As an alternative, you might want to consider LifeHash, which includes a
visual indicator as well as a readable fingerprint value.

LifeHash is an open source visual hashing algorithm that we use for all our
projects. Lifehash has a number of desirable qualities, including high
complexity, good aesthetics, a printer-friendly (CMYK) color gamut and
robustness when transformed to grayscale.

* [LifeHask Overview and links to reference code](
https://github.com/BlockchainCommons/lifehash)

* [LifeHash Explainer on YouTube](
https://www.youtube.com/watch?v=cu0K__KLxKo)

* [Our LifeHash UX best practices - The Object Identity Block](
https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2021-002-digest.md#object-identity-block
)

-- Christopher Allen
   Principal Architect, Blockchain Commons
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210819/54be28d3/attachment.html>

From gmkarl at gmail.com  Thu Aug 19 21:05:28 2021
From: gmkarl at gmail.com (Karl)
Date: Thu, 19 Aug 2021 17:05:28 -0400
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
 <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
Message-ID: <CALL-=e4BJvr21W=MY-xG9i+CSvSmKC2UsO9A=B4DKq-WV6_-Bg@mail.gmail.com>

Something that could work really well here could be having a norm of using
the checksum for bright colors, weights, sizes, capitalizations, and/or
spacing of the characters of the address, making different addresses more
clearly visually distinct.

Ethereum uses mixed case to do this a little bit:
https://eips.ethereum.org/EIPS/eip-55#implementation

It seems to me the checksum at the end of the address is sufficient for
differentiating error, but making a checksum more visually distinctive is
indeed an opportunity to add another digest, reducing collisions and such.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210819/566d8d96/attachment.html>

From jlrubin at mit.edu  Fri Aug 20 04:51:31 2021
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 19 Aug 2021 23:51:31 -0500
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <20210812220339.GA3416@erisian.com.au>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
 <20210812220339.GA3416@erisian.com.au>
Message-ID: <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>

one interesting point that came up at the bitdevs in austin today that
favors remove that i believe is new to this discussion (it was new to me):

the argument can be reduced to:

- dust limit is a per-node relay policy.
- it is rational for miners to mine dust outputs given their cost of
maintenance (storing the output potentially forever) is lower than their
immediate reward in fees.
- if txn relaying nodes censor something that a miner would mine, users
will seek a private/direct relay to the miner and vice versa.
- if direct relay to miner becomes popular, it is both bad for privacy and
decentralization.
- therefore the dust limit, should there be demand to create dust at
prevailing mempool feerates, causes an incentive to increase network
centralization (immediately)

the tradeoff is if a short term immediate incentive to promote network
centralization is better or worse than a long term node operator overhead.


///////////////////

my take is that:

1) having a dust limit is worse since we'd rather not have an incentive to
produce or roll out centralizing software, whereas not having a dust limit
creates an mild incentive for node operators to improve utreexo
decentralizing software.
2) it's hard to quantify the magnitude of the incentives, which does matter.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210819/831b9608/attachment.html>

From shymaa.arafat at gmail.com  Fri Aug 20 05:45:31 2021
From: shymaa.arafat at gmail.com (shymaa arafat)
Date: Fri, 20 Aug 2021 07:45:31 +0200
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
 <20210812220339.GA3416@erisian.com.au>
 <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
Message-ID: <CAM98U8nmzHOGNS63sw9C_U-capnaOBuMLYzOHaX7YMuk91JO4Q@mail.gmail.com>

On Fri, Aug 20, 2021, 06:52 Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> one interesting point that came up at the bitdevs in austin today that
> favors remove that i believe is new to this discussion (it was new to me):
>
> the argument can be reduced to:
>
> - dust limit is a per-node relay policy.
> - it is rational for miners to mine dust outputs given their cost of
> maintenance (storing the output potentially forever) is lower than their
> immediate reward in fees.
>
-Here, u  r assuming miners not running full nodes, or even stateless nodes
as in Utreexo
-otherwise they suffer from storing dust UTXOS/their effect on proof
length, right?

- if txn relaying nodes censor something that a miner would mine, users
> will seek a private/direct relay to the miner and vice versa.
> - if direct relay to miner becomes popular, it is both bad for privacy and
> decentralization.
> - therefore the dust limit, should there be demand to create dust at
> prevailing mempool feerates, causes an incentive to increase network
> centralization (immediately)
>
> the tradeoff is if a short term immediate incentive to promote network
> centralization is better or worse than a long term node operator overhead.
>
>
> ///////////////////
>
> my take is that:
>
> 1) having a dust limit is worse since we'd rather not have an incentive to
> produce or roll out centralizing software, whereas not having a dust limit
> creates an mild incentive for node operators to improve utreexo
> decentralizing software.
>
Why not having dust limit improves Utreexo, I think (and tried to suggest
many times) separate storing of dust&other non spendable UTXOS (and their
hashes) so that they do not affect other UTXOS proofs ( and not brought
into main memory unless called as a TXO)

2) it's hard to quantify the magnitude of the incentives, which does matter.
>
I honestly don't get the long term perspective of miners Incentivised to
storing small dust UTXOS instead of having their values added to the fee.

> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210820/607a4fa6/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Sat Aug 21 03:10:46 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 21 Aug 2021 03:10:46 +0000
Subject: [bitcoin-dev] [Lightning-dev]   Removing the Dust Limit
In-Reply-To: <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
 <20210812220339.GA3416@erisian.com.au>
 <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
Message-ID: <50s2eg2qZ_BSHhI1mT_mHP7fkDQ8EXnakOb9NmDfZlx_hN44l37UmopfAr2V4ws4yhx0YihNYBIOelJ01vhITI8K4G1UgmobTwf9FyJq_Yo=@protonmail.com>

Good morning Jeremy,

> one interesting point that came up at the bitdevs in austin today that favors remove that i believe is new to this discussion (it was new to me):
>
> the argument can be reduced to:
>
> - dust limit is a per-node relay policy.
> - it is rational for miners to mine dust outputs given their cost of maintenance?(storing the output potentially forever) is lower than their immediate reward in fees.
> - if txn relaying nodes censor something that a miner would mine, users will seek a private/direct relay to the miner and vice versa.
> - if direct relay to miner becomes popular, it is both bad for privacy and decentralization.
> - therefore the dust limit, should there be demand to create dust at prevailing mempool feerates, causes an incentive to increase network centralization?(immediately)
>
> the tradeoff is if a short term immediate incentive to promote network centralization is better or worse than a long term node operator overhead.

Against the above, we should note that in the Lightning spec, when an output *would have been* created that is less than the dust limit, the output is instead put into fees.
https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs

Thus, the existence of a dust limit encourages L2 protocols to have similar rules, where outputs below the dust limit are just given over as fees to miners, so the existence of a dust limit might very well be incentivize-compatible for miners, regardless of centralization effects or not.


Regards,
ZmnSCPxj

From ts at cronosurf.com  Sat Aug 21 04:52:16 2021
From: ts at cronosurf.com (ts)
Date: Fri, 20 Aug 2021 23:52:16 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <CACrqygDK4oKSvY0XXPXH=MmKAvHkmw2CoASwySn0qGteBUYr9Q@mail.gmail.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
 <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
 <CACrqygDK4oKSvY0XXPXH=MmKAvHkmw2CoASwySn0qGteBUYr9Q@mail.gmail.com>
Message-ID: <54c434c9-2efb-a7aa-1e71-8123a92d3bfd@cronosurf.com>

Good day Christopher,

Thanks for your comment! LifeHash looks indeed quite interesting. I can imagine some examples 
where it would be very useful, and I guess it could be used as a visual verification for the 
address in a wallet as well.

However, for my proposal (Human readable checksum (verification code) to avoid errors) it 
could have the following disadvantages:

1. It would be only one standard instead of one standard per crypto network (it should be 
different on each of them as described in the proposal). This could be solved with the 
inclusion of a network identifier somehow, but would increase the complexity of the 
implementation.

2. For this special use case, a simple 3 to 4 digit code is easier to implement than a 
graphic, and easier to include in an existing app, with minimal layout changes. The simpler it 
is, the more likely it will be for developers to actually implement it.

3. A graphic cannot be communicated by voice (in some situations this could be an easier way 
to communicate the verification code)

Greetings,
TS



Christopher Allen wrote on 8/19/21 12:37 PM:
> As an alternative, you might want to consider LifeHash, which includes a visual indicator as 
> well as a readable fingerprint value.
> 
> LifeHash is an open source visual hashing algorithm that we use for all our projects. Lifehash 
> has a number of desirable qualities, including high complexity, good aesthetics, a 
> printer-friendly (CMYK) color gamut and robustness when transformed to grayscale.
> 
> * [LifeHask Overview and links to reference 
> code](https://github.com/BlockchainCommons/lifehash 
> <https://github.com/BlockchainCommons/lifehash>)
> 
> * [LifeHash Explainer on YouTube](https://www.youtube.com/watch?v=cu0K__KLxKo 
> <https://www.youtube.com/watch?v=cu0K__KLxKo>)
> 
> * [Our LifeHash UX best practices - The Object Identity 
> Block](https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2021-002-digest.md#object-identity-block 
> <https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2021-002-digest.md#object-identity-block>)
> 
> -- Christopher Allen
>  ? ?Principal Architect, Blockchain Commons
> 
> 

From ts at cronosurf.com  Sat Aug 21 04:52:26 2021
From: ts at cronosurf.com (ts)
Date: Fri, 20 Aug 2021 23:52:26 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <CALL-=e4BJvr21W=MY-xG9i+CSvSmKC2UsO9A=B4DKq-WV6_-Bg@mail.gmail.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
 <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
 <CALL-=e4BJvr21W=MY-xG9i+CSvSmKC2UsO9A=B4DKq-WV6_-Bg@mail.gmail.com>
Message-ID: <f1bfc456-4adc-2f3a-5598-b0d7947f8de0@cronosurf.com>

Hello Karl,

Yes, I agree in general. But while the visual checksum could be sometimes more interesting and 
even useful, I guess that the technically simpler solution might be more likely to be adopted. 
And also less prone to error. Just a thought.

Cheers,
TS


Karl wrote on 8/19/21 4:05 PM:
> Something that could work really well here could be having a norm of using the checksum for 
> bright colors, weights, sizes, capitalizations, and/or spacing of the characters of the 
> address, making different addresses more clearly visually distinct.
> 
> Ethereum uses mixed case to do this a little bit: 
> https://eips.ethereum.org/EIPS/eip-55#implementation 
> <https://eips.ethereum.org/EIPS/eip-55#implementation>
> 
> It seems to me the checksum at the end of the address is sufficient for differentiating error, 
> but making a checksum more visually distinctive is indeed an opportunity to add another 
> digest, reducing collisions and such.

From ebbe52e5 at gmail.com  Tue Aug 24 03:39:44 2021
From: ebbe52e5 at gmail.com (Null Null)
Date: Tue, 24 Aug 2021 11:39:44 +0800
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
Message-ID: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>

Hi all,

Is there a tool like Ethereum EVM at present? Users can write bitcoin scripts in a syntax just like python(or like other programming language); through this tool, they can be translated into bitcoin original scripts; it sounds like a new programming language has been invented.

In my opinion? Bitcoin script programming is based on reverse Polish expression; this is not friendly to programmers;

In fact, Bitcoin's opcode expression ability is very rich, and it may be unfriendly, which has affected the promotion of Bitcoin in the technical community.

Hope for hearing some voice about this.

Best wish.


From gvandam at gmail.com  Tue Aug 24 07:36:29 2021
From: gvandam at gmail.com (Gijs van Dam)
Date: Tue, 24 Aug 2021 15:36:29 +0800
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
In-Reply-To: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>
References: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>
Message-ID: <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>

Hi,


Bitcoin does not have a virtual machine. But you do have [Miniscript][1],
[Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level
languages that compile to Bitcoin Script. Sapio is "just" Rust, so that
might fit your setting best.

By the way, this question also has an answer on [Bitcoin Stackexchange][5]
which is a great resource for questions like this.

[1]: http://bitcoin.sipa.be/miniscript/
[2]: https://min.sc/
[3]: https://github.com/ElementsProject/simplicity
[4]: https://learn.sapio-lang.org/
[5]:
https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script

On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi all,
>
> Is there a tool like Ethereum EVM at present? Users can write bitcoin
> scripts in a syntax just like python(or like other programming language);
> through this tool, they can be translated into bitcoin original scripts; it
> sounds like a new programming language has been invented.
>
> In my opinion? Bitcoin script programming is based on reverse Polish
> expression; this is not friendly to programmers;
>
> In fact, Bitcoin's opcode expression ability is very rich, and it may be
> unfriendly, which has affected the promotion of Bitcoin in the technical
> community.
>
> Hope for hearing some voice about this.
>
> Best wish.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210824/233f3b92/attachment.html>

From apoelstra at wpsoftware.net  Tue Aug 24 13:08:49 2021
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Tue, 24 Aug 2021 13:08:49 +0000
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
In-Reply-To: <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>
References: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>
 <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>
Message-ID: <YSTvYSEdDYVQhukr@camus>


Simplicity does not compile to Bitcoin Script, and Sapio assumes extensions
to Bitcoin Script that are not currently part of the consensus code.


On Tue, Aug 24, 2021 at 03:36:29PM +0800, Gijs van Dam via bitcoin-dev wrote:
> Hi,
> 
> 
> Bitcoin does not have a virtual machine. But you do have [Miniscript][1],
> [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level
> languages that compile to Bitcoin Script. Sapio is "just" Rust, so that
> might fit your setting best.
> 
> By the way, this question also has an answer on [Bitcoin Stackexchange][5]
> which is a great resource for questions like this.
> 
> [1]: http://bitcoin.sipa.be/miniscript/
> [2]: https://min.sc/
> [3]: https://github.com/ElementsProject/simplicity
> [4]: https://learn.sapio-lang.org/
> [5]:
> https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script
> 
> On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > Hi all,
> >
> > Is there a tool like Ethereum EVM at present? Users can write bitcoin
> > scripts in a syntax just like python(or like other programming language);
> > through this tool, they can be translated into bitcoin original scripts; it
> > sounds like a new programming language has been invented.
> >
> > In my opinion? Bitcoin script programming is based on reverse Polish
> > expression; this is not friendly to programmers;
> >
> > In fact, Bitcoin's opcode expression ability is very rich, and it may be
> > unfriendly, which has affected the promotion of Bitcoin in the technical
> > community.
> >
> > Hope for hearing some voice about this.
> >
> > Best wish.
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >

> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster


From alekos.filini at gmail.com  Wed Aug 25 18:03:24 2021
From: alekos.filini at gmail.com (Alekos Filini)
Date: Wed, 25 Aug 2021 20:03:24 +0200
Subject: [bitcoin-dev] Announcing bip174.org,
	a web-based PSBT viewer and editor
Message-ID: <CAAWg4suCsqU6CZ1F7Pgrebn99n_8HMwtROKNOapwF6YqDnCjyA@mail.gmail.com>

Hello list,

I'm writing this email to announce the launch of bip174.org, a PSBT viewer
and editor that runs in the browser. The website itself is pretty simple,
you can paste a PSBT to see its content and whenever a change is made to
one of the various fields the PSBT is automatically updated. There are a
few examples built in if you just want to quickly try it out.

Daniela Brozzoni and I have been working on this tool for a while, mainly
because we felt the need ourselves for something that would allow us to
easily dump/modify the PSBTs we work with in our day to day job. We are not
aware of any other tool that does something similar (`decodepsbt` in
Bitcoin Core can only show the content of a PSBT but not change it), so we
decided to build this instead, taking inspiration from the great bip32.org.

For anyone who's interested, the webapp is made entirely in Rust compiled
to WASM. The source code is available on GitHub
<https://github.com/afilini/bip174.org/>.

Contributions, feedback and bug reports are all very welcome!


Alekos
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210825/09d93c0a/attachment.html>

From ChristopherA at lifewithalacrity.com  Wed Aug 25 20:05:31 2021
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Wed, 25 Aug 2021 13:05:31 -0700
Subject: [bitcoin-dev] Announcing bip174.org,
	a web-based PSBT viewer and editor
In-Reply-To: <CAAWg4suCsqU6CZ1F7Pgrebn99n_8HMwtROKNOapwF6YqDnCjyA@mail.gmail.com>
References: <CAAWg4suCsqU6CZ1F7Pgrebn99n_8HMwtROKNOapwF6YqDnCjyA@mail.gmail.com>
Message-ID: <CACrqygCe4X4KeWzW+xTnraJtCf2MRWQGuAxzpgZ-2FZa6-TYhQ@mail.gmail.com>

On Wed, Aug 25, 2021 at 12:42 PM Alekos Filini via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I'm writing this email to announce the launch of bip174.org, a PSBT
> viewer and editor that runs in the browser.
>

This will be useful.

>
I, and the larger Airgapped Wallet Community would love to see you add
output of UR-based animated QRs to your website. An increasing number of
advanced hardware & software wallets are now supporting Airgapped UR/QR
PSBT signing.
https://github.com/BlockchainCommons/Airgapped-Wallet-Community

You can see a video example of this in action between the Foundation
Devices hardware wallet & Blue Wallet in this video, at the 17m48s mark:
https://youtu.be/bYeoCBAUDYs

The easiest to do is output these UR QRs from your site, as there are
multiple libraries in multiple languages to support them, but I also know
that there are some major web-based transaction coordinator services also
planning to add Browser scanning of PSBTs on laptops with cameras as well.

? Christopher Allen

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210825/0715c389/attachment.html>

From ebbe52e5 at gmail.com  Thu Aug 26 02:43:27 2021
From: ebbe52e5 at gmail.com (Null Null)
Date: Thu, 26 Aug 2021 10:43:27 +0800
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
In-Reply-To: <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>
References: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>
 <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>
Message-ID: <B6ADF0FE-0FCD-4564-A78E-6FA8310924D0@gmail.com>

thanks for you suggestion, Gijs.

I spent some time learning miniscript, and there are some problems that need to confirm for me:

1. Is miniscript a brand new Bitcoin scripting language?
2. If I use miniscript, do I need to compile it into a Bitcoin OP_CODE script? If so, how to do that ? has someone written a compiler? 
I found that @sipa has open sourced a compiler implemented in C++ on github( https://github.com/sipa/miniscript ). This should translate the policy language into miniscript;

> 2021?8?24? ??3:36?Gijs van Dam via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> ???
> 
> Hi,
> 
> 
> Bitcoin does not have a virtual machine. But you do have [Miniscript][1], [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level languages that compile to Bitcoin Script. Sapio is "just" Rust, so that might fit your setting best.
> 
> By the way, this question also has an answer on [Bitcoin Stackexchange][5] which is a great resource for questions like this.
> 
> [1]: http://bitcoin.sipa.be/miniscript/
> [2]: https://min.sc/
> [3]: https://github.com/ElementsProject/simplicity
> [4]: https://learn.sapio-lang.org/
> [5]: https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script
> 
> On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Hi all,
> 
> Is there a tool like Ethereum EVM at present? Users can write bitcoin scripts in a syntax just like python(or like other programming language); through this tool, they can be translated into bitcoin original scripts; it sounds like a new programming language has been invented.
> 
> In my opinion? Bitcoin script programming is based on reverse Polish expression; this is not friendly to programmers;
> 
> In fact, Bitcoin's opcode expression ability is very rich, and it may be unfriendly, which has affected the promotion of Bitcoin in the technical community.
> 
> Hope for hearing some voice about this.
> 
> Best wish.
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From oleganza at gmail.com  Thu Aug 26 08:12:22 2021
From: oleganza at gmail.com (Oleg Andreev)
Date: Thu, 26 Aug 2021 11:12:22 +0300
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
In-Reply-To: <YSTvYSEdDYVQhukr@camus>
References: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>
 <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>
 <YSTvYSEdDYVQhukr@camus>
Message-ID: <7491EAD3-9335-47B6-B48A-3B544CA605FC@gmail.com>

It is worth checking out Ivy lang Playground by Dan Robinson, but AFAIK, it's not actively maintained. It compiles contracts to Bitcoin Script: https://www.ivylang.org/bitcoin

> On 24. Aug 2021, at 16:08, Andrew Poelstra via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> Simplicity does not compile to Bitcoin Script, and Sapio assumes extensions
> to Bitcoin Script that are not currently part of the consensus code.
> 
> 
> On Tue, Aug 24, 2021 at 03:36:29PM +0800, Gijs van Dam via bitcoin-dev wrote:
>> Hi,
>> 
>> 
>> Bitcoin does not have a virtual machine. But you do have [Miniscript][1],
>> [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level
>> languages that compile to Bitcoin Script. Sapio is "just" Rust, so that
>> might fit your setting best.
>> 
>> By the way, this question also has an answer on [Bitcoin Stackexchange][5]
>> which is a great resource for questions like this.
>> 
>> [1]: http://bitcoin.sipa.be/miniscript/
>> [2]: https://min.sc/
>> [3]: https://github.com/ElementsProject/simplicity
>> [4]: https://learn.sapio-lang.org/
>> [5]:
>> https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script
>> 
>> On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>>> Hi all,
>>> 
>>> Is there a tool like Ethereum EVM at present? Users can write bitcoin
>>> scripts in a syntax just like python(or like other programming language);
>>> through this tool, they can be translated into bitcoin original scripts; it
>>> sounds like a new programming language has been invented.
>>> 
>>> In my opinion? Bitcoin script programming is based on reverse Polish
>>> expression; this is not friendly to programmers;
>>> 
>>> In fact, Bitcoin's opcode expression ability is very rich, and it may be
>>> unfriendly, which has affected the promotion of Bitcoin in the technical
>>> community.
>>> 
>>> Hope for hearing some voice about this.
>>> 
>>> Best wish.
>>> 
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> 
> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> -- 
> Andrew Poelstra
> Director of Research, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
> 
> The sun is always shining in space
>    -Justin Lewis-Webster
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From prayank at tutanota.de  Thu Aug 26 09:20:02 2021
From: prayank at tutanota.de (Prayank)
Date: Thu, 26 Aug 2021 11:20:02 +0200 (CEST)
Subject: [bitcoin-dev] Announcing bip174.org,
 a web-based PSBT viewer and editor
Message-ID: <Mi0k_G9--3-2@tutanota.de>

Hi Alekos,

> bip174.org, a PSBT viewer and editor that runs in the browser

The PSBT editor looks good and will be helpful. Thanks for working on it. Would love to see an option to switch between light and dark theme and highlighting few things with different colors.

Maybe a similar project for descriptors with options to experiment with descriptors would also be useful.
-- 
Prayank

A3B1 E430 2298 178F
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/49a87b63/attachment.html>

From jlrubin at mit.edu  Thu Aug 26 10:26:23 2021
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 26 Aug 2021 03:26:23 -0700
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
In-Reply-To: <YSTvYSEdDYVQhukr@camus>
References: <E541FB6E-AB06-4B8D-86CF-530C13AF62DD@gmail.com>
 <CAGB645aYFvxBctxXHwH0bB=qRMTaEW263H5BxpT8b27i9S3B7w@mail.gmail.com>
 <YSTvYSEdDYVQhukr@camus>
Message-ID: <CAD5xwhgmAepA4jW3tK7nihMFsMEdgs0Z6UEs3k=3J1soDea0QQ@mail.gmail.com>

This has actually never been true (Sapio assumes extensions).

If the extensions are not present, you can stub them out with a signing
federation instead, configurable as flags, and you can also write many
contracts that do not use the ctv based components at all.

The protocol for emulation is a bit clever (if I do say so myself) since it
ensures that contract compilation is completely offline and the oracles are
completely stateless.

Relevant links:

https://learn.sapio-lang.org/ch05-01-ctv-emulator.html
https://learn.sapio-lang.org/ch03-02-finish.html

Cheers,

Jeremy

On Tue, Aug 24, 2021, 6:19 AM Andrew Poelstra via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Simplicity does not compile to Bitcoin Script, and Sapio assumes extensions
> to Bitcoin Script that are not currently part of the consensus code.
>
>
> On Tue, Aug 24, 2021 at 03:36:29PM +0800, Gijs van Dam via bitcoin-dev
> wrote:
> > Hi,
> >
> >
> > Bitcoin does not have a virtual machine. But you do have [Miniscript][1],
> > [Min.sc][2], [Simplicity][3] and [Sapio][4]. These are all higher level
> > languages that compile to Bitcoin Script. Sapio is "just" Rust, so that
> > might fit your setting best.
> >
> > By the way, this question also has an answer on [Bitcoin
> Stackexchange][5]
> > which is a great resource for questions like this.
> >
> > [1]: http://bitcoin.sipa.be/miniscript/
> > [2]: https://min.sc/
> > [3]: https://github.com/ElementsProject/simplicity
> > [4]: https://learn.sapio-lang.org/
> > [5]:
> >
> https://bitcoin.stackexchange.com/questions/108261/is-there-a-tool-like-ethereum-evm-at-present-for-bitcoin-script
> >
> > On Tue, Aug 24, 2021 at 2:55 PM Null Null via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > Hi all,
> > >
> > > Is there a tool like Ethereum EVM at present? Users can write bitcoin
> > > scripts in a syntax just like python(or like other programming
> language);
> > > through this tool, they can be translated into bitcoin original
> scripts; it
> > > sounds like a new programming language has been invented.
> > >
> > > In my opinion? Bitcoin script programming is based on reverse Polish
> > > expression; this is not friendly to programmers;
> > >
> > > In fact, Bitcoin's opcode expression ability is very rich, and it may
> be
> > > unfriendly, which has affected the promotion of Bitcoin in the
> technical
> > > community.
> > >
> > > Hope for hearing some voice about this.
> > >
> > > Best wish.
> > >
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > >
>
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> --
> Andrew Poelstra
> Director of Research, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> The sun is always shining in space
>     -Justin Lewis-Webster
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/90095c1d/attachment.html>

From michaelfolkson at gmail.com  Thu Aug 26 13:09:49 2021
From: michaelfolkson at gmail.com (Michael Folkson)
Date: Thu, 26 Aug 2021 14:09:49 +0100
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
Message-ID: <CAFvNmHQwifysNTumzoVj6+T8kTfj9Bcr3M1RZKuWRBQ7VRonCw@mail.gmail.com>

The "No Taproot" section of the Sapio docs need updating :) What are
your plans to take advantage of Taproot with Sapio? It would have been
interesting to see what a Taproot emulator would have looked like,
although no need for it now. It seems to me Taproot would have been
harder to emulate than CTV though I could be wrong.

https://learn.sapio-lang.org/ch05-02-taproot.html

Also there have been a number of people asking questions about Sapio
and CTV on the Libera equivalents of Freenode channels #sapio and
##ctv-bip-review over the past months. Do you plan to join and claim
those channels?

Date: Thu, 26 Aug 2021 03:26:23 -0700
From: Jeremy <jlrubin at mit.edu>
To: Andrew Poelstra <apoelstra at wpsoftware.net>, Bitcoin Protocol
        Discussion <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] Is there a tool like Ethereum EVM at
        present for Bitcoin script?
Message-ID:
        <CAD5xwhgmAepA4jW3tK7nihMFsMEdgs0Z6UEs3k=3J1soDea0QQ at mail.gmail.com>
Content-Type: text/plain; charset="utf-8"

This has actually never been true (Sapio assumes extensions).

If the extensions are not present, you can stub them out with a signing
federation instead, configurable as flags, and you can also write many
contracts that do not use the ctv based components at all.

The protocol for emulation is a bit clever (if I do say so myself) since it
ensures that contract compilation is completely offline and the oracles are
completely stateless.

Relevant links:

https://learn.sapio-lang.org/ch05-01-ctv-emulator.html
https://learn.sapio-lang.org/ch03-02-finish.html

Cheers,

Jeremy

-- 
Michael Folkson
Email: michaelfolkson at gmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3

From alekos.filini at gmail.com  Thu Aug 26 13:57:47 2021
From: alekos.filini at gmail.com (Alekos Filini)
Date: Thu, 26 Aug 2021 15:57:47 +0200
Subject: [bitcoin-dev] Announcing bip174.org,
	a web-based PSBT viewer and editor
In-Reply-To: <CACrqygCe4X4KeWzW+xTnraJtCf2MRWQGuAxzpgZ-2FZa6-TYhQ@mail.gmail.com>
References: <CAAWg4suCsqU6CZ1F7Pgrebn99n_8HMwtROKNOapwF6YqDnCjyA@mail.gmail.com>
 <CACrqygCe4X4KeWzW+xTnraJtCf2MRWQGuAxzpgZ-2FZa6-TYhQ@mail.gmail.com>
Message-ID: <CAAWg4svFhzo-guOWNuBNOHAcAet12ZSg+un5N57u7UL0cR9Nsw@mail.gmail.com>

(sending it again as I forgot to "reply-all", sorry for the spam!)

The easiest to do is output these UR QRs from your site, as there are
> multiple libraries in multiple languages to support them, but I also know
> that there are some major web-based transaction coordinator services also
> planning to add Browser scanning of PSBTs on laptops with cameras as well.
>

That's a really good suggestion, thanks! I think it should be pretty
doable, we could also try working on reading a PSBT from a QR code using
the webcam.


Alekos
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/718c6917/attachment.html>

From alekos.filini at gmail.com  Thu Aug 26 14:07:30 2021
From: alekos.filini at gmail.com (Alekos Filini)
Date: Thu, 26 Aug 2021 16:07:30 +0200
Subject: [bitcoin-dev] Announcing bip174.org,
	a web-based PSBT viewer and editor
In-Reply-To: <Mi0k_G9--3-2@tutanota.de>
References: <Mi0k_G9--3-2@tutanota.de>
Message-ID: <CAAWg4ss+BVz9pLGHj-pwX1wrS=eb5bGatrSJ-OqoSa00vYB14g@mail.gmail.com>

> Would love to see an option to switch between light and dark theme and
> highlighting few things with different colors.
>

Neither of us is particularly good at UI/UX stuff, but we can give it a
shot! :)


> Maybe a similar project for descriptors with options to experiment with
> descriptors would also be useful.
>

I don't think this is exactly what you have in mind, but a while back I
made a web-based tool to build descriptors graphically, based on Scratch.
You can find it here <https://bitcoindevkit.org/bdk-cli/playground/>, on
BDK's website.


Alekos
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/9eccca80/attachment.html>

From jlrubin at mit.edu  Thu Aug 26 20:03:47 2021
From: jlrubin at mit.edu (Jeremy)
Date: Thu, 26 Aug 2021 13:03:47 -0700
Subject: [bitcoin-dev] Is there a tool like Ethereum EVM at present for
 Bitcoin script?
In-Reply-To: <CAFvNmHQwifysNTumzoVj6+T8kTfj9Bcr3M1RZKuWRBQ7VRonCw@mail.gmail.com>
References: <CAFvNmHQwifysNTumzoVj6+T8kTfj9Bcr3M1RZKuWRBQ7VRonCw@mail.gmail.com>
Message-ID: <CAD5xwhhDS8T9YGftmavJ4V68hdHeEnSb7HwPuZNpkeJSGy1Zvg@mail.gmail.com>

Will update those soon / in November. Sapio needs the rust Bitcoin taproot
ecosystem to mature, as well as a spec for miniscript taproot (altho we can
kinda monkey patch one in without it).

To be honest, I had some technical difficulties with getting Libera to work
and I gave up... But perhaps I can retry getting it to work again. Irc
infra ???? struggles...


On Thu, Aug 26, 2021, 6:10 AM Michael Folkson <michaelfolkson at gmail.com>
wrote:

> The "No Taproot" section of the Sapio docs need updating :) What are
> your plans to take advantage of Taproot with Sapio? It would have been
> interesting to see what a Taproot emulator would have looked like,
> although no need for it now. It seems to me Taproot would have been
> harder to emulate than CTV though I could be wrong.
>
> https://learn.sapio-lang.org/ch05-02-taproot.html
>
> Also there have been a number of people asking questions about Sapio
> and CTV on the Libera equivalents of Freenode channels #sapio and
> ##ctv-bip-review over the past months. Do you plan to join and claim
> those channels?
>
> Date: Thu, 26 Aug 2021 03:26:23 -0700
> From: Jeremy <jlrubin at mit.edu>
> To: Andrew Poelstra <apoelstra at wpsoftware.net>, Bitcoin Protocol
>         Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Is there a tool like Ethereum EVM at
>         present for Bitcoin script?
> Message-ID:
>         <CAD5xwhgmAepA4jW3tK7nihMFsMEdgs0Z6UEs3k=
> 3J1soDea0QQ at mail.gmail.com>
> Content-Type: text/plain; charset="utf-8"
>
> This has actually never been true (Sapio assumes extensions).
>
> If the extensions are not present, you can stub them out with a signing
> federation instead, configurable as flags, and you can also write many
> contracts that do not use the ctv based components at all.
>
> The protocol for emulation is a bit clever (if I do say so myself) since it
> ensures that contract compilation is completely offline and the oracles are
> completely stateless.
>
> Relevant links:
>
> https://learn.sapio-lang.org/ch05-01-ctv-emulator.html
> https://learn.sapio-lang.org/ch03-02-finish.html
>
> Cheers,
>
> Jeremy
>
> --
> Michael Folkson
> Email: michaelfolkson at gmail.com
> Keybase: michaelfolkson
> PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/b648e893/attachment.html>

From billy.tetrud at gmail.com  Thu Aug 26 21:21:25 2021
From: billy.tetrud at gmail.com (Billy Tetrud)
Date: Thu, 26 Aug 2021 14:21:25 -0700
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <50s2eg2qZ_BSHhI1mT_mHP7fkDQ8EXnakOb9NmDfZlx_hN44l37UmopfAr2V4ws4yhx0YihNYBIOelJ01vhITI8K4G1UgmobTwf9FyJq_Yo=@protonmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
 <20210812220339.GA3416@erisian.com.au>
 <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
 <50s2eg2qZ_BSHhI1mT_mHP7fkDQ8EXnakOb9NmDfZlx_hN44l37UmopfAr2V4ws4yhx0YihNYBIOelJ01vhITI8K4G1UgmobTwf9FyJq_Yo=@protonmail.com>
Message-ID: <CAGpPWDbseo6eYT1a54YB2-fpxpzj2cg9DL+s2_rpoa+dGfnhaQ@mail.gmail.com>

One interesting thing I thought of: the cost of maintenance of the dust
creates a (very) small incentive to mine transactions that *use* dust
outputs with a slightly lower fee that contain dust, in order to reduce the
future maintenance cost for themselves. However, the rational discount
would likely be vanishingly small.  It would be interesting to add
something to the consensus rules to decrease the vbytes for a transaction
that consumes dust outputs such that the value of removing them from the
system (saving the future cost of maintenance) is approximately equal to
the amount that the fee could be made lower for such transactions. Even
measuring this as a value over the whole (future) bitcoin network, I'm not
sure how to evaluate the magnitude of this future cost.





On Fri, Aug 20, 2021 at 8:12 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Jeremy,
>
> > one interesting point that came up at the bitdevs in austin today that
> favors remove that i believe is new to this discussion (it was new to me):
> >
> > the argument can be reduced to:
> >
> > - dust limit is a per-node relay policy.
> > - it is rational for miners to mine dust outputs given their cost of
> maintenance (storing the output potentially forever) is lower than their
> immediate reward in fees.
> > - if txn relaying nodes censor something that a miner would mine, users
> will seek a private/direct relay to the miner and vice versa.
> > - if direct relay to miner becomes popular, it is both bad for privacy
> and decentralization.
> > - therefore the dust limit, should there be demand to create dust at
> prevailing mempool feerates, causes an incentive to increase network
> centralization (immediately)
> >
> > the tradeoff is if a short term immediate incentive to promote network
> centralization is better or worse than a long term node operator overhead.
>
> Against the above, we should note that in the Lightning spec, when an
> output *would have been* created that is less than the dust limit, the
> output is instead put into fees.
>
> https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs
>
> Thus, the existence of a dust limit encourages L2 protocols to have
> similar rules, where outputs below the dust limit are just given over as
> fees to miners, so the existence of a dust limit might very well be
> incentivize-compatible for miners, regardless of centralization effects or
> not.
>
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210826/952bece6/attachment-0001.html>

From shymaa.arafat at gmail.com  Fri Aug 27 09:07:35 2021
From: shymaa.arafat at gmail.com (shymaa arafat)
Date: Fri, 27 Aug 2021 11:07:35 +0200
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAGpPWDbseo6eYT1a54YB2-fpxpzj2cg9DL+s2_rpoa+dGfnhaQ@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
 <20210812220339.GA3416@erisian.com.au>
 <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
 <50s2eg2qZ_BSHhI1mT_mHP7fkDQ8EXnakOb9NmDfZlx_hN44l37UmopfAr2V4ws4yhx0YihNYBIOelJ01vhITI8K4G1UgmobTwf9FyJq_Yo=@protonmail.com>
 <CAGpPWDbseo6eYT1a54YB2-fpxpzj2cg9DL+s2_rpoa+dGfnhaQ@mail.gmail.com>
Message-ID: <CAM98U8nOqvOSBvP15dGup-LoW-af9EHFKyTy_XDOjfR-NGjJYA@mail.gmail.com>

Allow me to ask:

-Untill you find a mitigation that consolidate all dust UTXOS, why don't
you separate them and all probably Unspendable UTXOS in a different
partition?
-I'm talking at the real UTXO storage level (to be kept in secondary
storage), and at the Merkleization level in any accumulator design Utreexo
or what so ever(putting them in one or two subtree/forest with hardly
changing roots according to the categorization will reduce the proof size,
even if slightly)
-This will also help things like Bloom filters, assume UTXOs,...etc when
about 10% with almost zero probability are trimmed from the pool you are
withdrawing from.
.
-The paper I mentioned earlier says in Feb 2018, there was about 2.4m UTXOS
less than 1000 Satoshi, of which ~824,892 holds exactly 1 Satoshi
-I don't think any of those were spent since that time, in fact there could
be a possibility that the numbers may have increased
-As the last previous reply mentioned you have to consider the long run
effect on the UTXO set forever, this is a straight forward improvement that
comes with almost no effort
.
Ps.
-If there is something wrong, something I missed in this idea please
explain it to me
-Or do you find the improvement itself a "dust" that doesn't worth the
effort???
.
Regards & thank you all for your time in reading & replying
Shymaa M. Arafat
On Fri, Aug 27, 2021, 00:06 Billy Tetrud via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> One interesting thing I thought of: the cost of maintenance of the dust
> creates a (very) small incentive to mine transactions that *use* dust
> outputs with a slightly lower fee that contain dust, in order to reduce the
> future maintenance cost for themselves. However, the rational discount
> would likely be vanishingly small.  It would be interesting to add
> something to the consensus rules to decrease the vbytes for a transaction
> that consumes dust outputs such that the value of removing them from the
> system (saving the future cost of maintenance) is approximately equal to
> the amount that the fee could be made lower for such transactions. Even
> measuring this as a value over the whole (future) bitcoin network, I'm not
> sure how to evaluate the magnitude of this future cost.
>
>
>
>
>
> On Fri, Aug 20, 2021 at 8:12 PM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Good morning Jeremy,
>>
>> > one interesting point that came up at the bitdevs in austin today that
>> favors remove that i believe is new to this discussion (it was new to me):
>> >
>> > the argument can be reduced to:
>> >
>> > - dust limit is a per-node relay policy.
>> > - it is rational for miners to mine dust outputs given their cost of
>> maintenance (storing the output potentially forever) is lower than their
>> immediate reward in fees.
>> > - if txn relaying nodes censor something that a miner would mine, users
>> will seek a private/direct relay to the miner and vice versa.
>> > - if direct relay to miner becomes popular, it is both bad for privacy
>> and decentralization.
>> > - therefore the dust limit, should there be demand to create dust at
>> prevailing mempool feerates, causes an incentive to increase network
>> centralization (immediately)
>> >
>> > the tradeoff is if a short term immediate incentive to promote network
>> centralization is better or worse than a long term node operator overhead.
>>
>> Against the above, we should note that in the Lightning spec, when an
>> output *would have been* created that is less than the dust limit, the
>> output is instead put into fees.
>>
>> https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs
>>
>> Thus, the existence of a dust limit encourages L2 protocols to have
>> similar rules, where outputs below the dust limit are just given over as
>> fees to miners, so the existence of a dust limit might very well be
>> incentivize-compatible for miners, regardless of centralization effects or
>> not.
>>
>>
>> Regards,
>> ZmnSCPxj
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210827/f42a4a62/attachment.html>

From prayank at tutanota.de  Fri Aug 27 21:29:35 2021
From: prayank at tutanota.de (Prayank)
Date: Fri, 27 Aug 2021 23:29:35 +0200 (CEST)
Subject: [bitcoin-dev] Camouflage: A project dedicated to Hal Finney
Message-ID: <Mi8W8of--3-2@tutanota.de>

I wish Hal Finney was with us today and help us improve privacy in Bitcoin. I like reading his posts and one of them is https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654 

I had emailed about Privacy related things on July 23: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html

It was my birthday on 23 and had few beers so maybe email wasn't very focused. Although basic idea was to initiate discussion about improving privacy in different Bitcoin projects. I did not receive any response except one person who liked the video I mentioned in the email. So here is one project which uses GitHub pages and will have the following things:

1.Issues and PRs related to privacy from different Bitcoin projects. I have added few from Bitcoin Core (full node implementation), Bisq(DEX) and LND (LN implementation) right now.
2.Blog section for my opinion on different privacy related issues and PRs.
3.'Hall of Fame' section to appreciate the contribution of devs who are improving privacy in different Bitcoin projects.

I will be happy if this project helps in improving privacy or helps users/devs in any other way. This project will never turn in to a paid newsletter or needs any sponsors, however any contribution to make the website better would be appreciated. Edward Snowden can also contribute if he wants to do more than just tweets to help improve Bitcoin privacy.

Link: https://prayank23.github.io/camouflage/

Will move everything to new repository this weekend: https://github.com/BlockchainCommons/Bitcoin-Camouflage

-- 
Prayank

A3B1 E430 2298 178F
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210827/20e53400/attachment.html>

From aymeric at peersm.com  Sat Aug 28 16:36:26 2021
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sat, 28 Aug 2021 18:36:26 +0200
Subject: [bitcoin-dev] Camouflage: A project dedicated to Hal Finney
In-Reply-To: <Mi8W8of--3-2@tutanota.de>
References: <Mi8W8of--3-2@tutanota.de>
Message-ID: <b8a18c30-d9f4-27cb-9a81-7c3b0bfcbf65@peersm.com>

Probably you could add to your links this discussion/issue
https://github.com/bitcoin/bitcoin/pull/18988#issuecomment-646564853


Le 27/08/2021 ? 23:29, Prayank via bitcoin-dev a ?crit :
> I wish Hal Finney was with us today and help us improve privacy in
> Bitcoin. I like reading his posts and one of them is
> https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654
>
> I had emailed about Privacy related things on July 23:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html
>
> It was my birthday on 23 and had few beers so maybe email wasn't very
> focused. Although basic idea was to initiate discussion about
> improving privacy in different Bitcoin projects. I did not receive any
> response except one person who liked the video I mentioned in the
> email. So here is one project which uses GitHub pages and will have
> the following things:
>
> 1.Issues and PRs related to privacy from different Bitcoin projects. I
> have added few from Bitcoin Core (full node implementation), Bisq(DEX)
> and LND (LN implementation) right now.
> 2.Blog section for my opinion on different privacy related issues and PRs.
> 3.'Hall of Fame' section to appreciate the contribution of devs who
> are improving privacy in different Bitcoin projects.
>
> I will be happy if this project helps in improving privacy or helps
> users/devs in any other way. This project will never turn in to a paid
> newsletter or needs any sponsors, however any contribution to make the
> website better would be appreciated. Edward Snowden can also
> contribute if he wants to do more than just tweets to help improve
> Bitcoin privacy.
>
> Link: https://prayank23.github.io/camouflage/
>
> Will move everything to new repository this weekend:
> https://github.com/BlockchainCommons/Bitcoin-Camouflage
>
> -- 
> Prayank
>
> A3B1 E430 2298 178F
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210828/76d7d468/attachment.html>

From ts at cronosurf.com  Sat Aug 28 21:17:35 2021
From: ts at cronosurf.com (ts)
Date: Sat, 28 Aug 2021 16:17:35 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
Message-ID: <6f69f132-211f-9d42-8023-c3b0264af439@cronosurf.com>

Following up on my original proposal, I would like to get some more feedback of the community 
to see if this could be realized at some point. Also, any recommendations as to who to contact 
to get things rolling?

Thanks,
TS



ts wrote on 8/15/21 11:23 PM:
> Entering a BTC address for a transaction can pose a risk of error (human or technical). While 
> there is a checksum integrated in BTC addresses already, this is used only at a technical 
> level and does not avoid entering a valid but otherwise wrong address. Moreover, it does not 
> improve the overall user experience.
> 
> In case this hasn't been discussed before, I propose to implement a 3 or 4 digit code (lets 
> call it 4DC for this text), generated as checksum from the address. This 4DC should be shown 
> in all wallets next to the receiving address. When entering a new address to send BTC, the 
> sending wallet should also show the 4DC next to the entered address. This way, the sending 
> person can easily verify that the resulting 4DC matches the one from the receiving address.
> 
> This would mean that a receiver would not only send his public address to the sender, but also 
> the 4DC (or communicate it via a different channel). A minor disadvantage since a) it is not  > mandatory and b) it is very easy to do.
> However, it would greatly reduce the probability of performing transactions to a wrong address.
> 
> Technically, this is very easy to implement. The only effort needed is agreeing on a checksum 
> standard to generate the code. Once the standard is established, all wallet and exchange 
> developers can start implementing this.
> 
> Agreeing on a good name for this code would be helpful for a fast adoption (human readable 
> checksum, verification code or 4DC are just examples).
> 
> Obviously, this solution could be used for all other coins/networks. But ideally, each of them 
> should have its own checksum algorithm, in order to further avoid sending funds to the wrong 
> network. Especially when the address standard is the same like it is the case with BTC and BCH.
> 
> Hopefully, Bitcoin can implement this first and serve as example-to-follow to other 
> coins/networks.
> 
> Cheers,
> TS

From prayank at tutanota.de  Sat Aug 28 22:40:38 2021
From: prayank at tutanota.de (Prayank)
Date: Sun, 29 Aug 2021 00:40:38 +0200 (CEST)
Subject: [bitcoin-dev] Camouflage: A project dedicated to Hal Finney
In-Reply-To: <b8a18c30-d9f4-27cb-9a81-7c3b0bfcbf65@peersm.com>
References: <Mi8W8of--3-2@tutanota.de>
 <b8a18c30-d9f4-27cb-9a81-7c3b0bfcbf65@peersm.com>
Message-ID: <MiDv-Qo--3-2@tutanota.de>

Hi Aymeric,

Thanks for sharing the link. 'bitcoin-transactions' and 'node-Tor' looks interesting although I will have to check details and try things.

One observation: I noticed it's in JavaScript and will use WebRTC. Users who care about privacy normally disable both while using a browser.
-- 
Prayank

A3B1 E430 2298 178F



Aug 28, 2021, 22:06 by aymeric at peersm.com:

>
> Probably you could add to your links this discussion/issue > https://github.com/bitcoin/bitcoin/pull/18988#issuecomment-646564853
>
>
> Le 27/08/2021 ? 23:29, Prayank via      bitcoin-dev a ?crit?:
>
>> I wish Hal Finney was with us today and help us improve        privacy in Bitcoin. I like reading his posts and one of them is >> https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654>>  
>>
>> I had emailed about Privacy related things on July        23: >> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html
>>
>> It was my birthday on 23 and had few beers so        maybe email wasn't very focused. Although basic idea was to        initiate discussion about improving privacy in different Bitcoin        projects. I did not receive any response except one person who        liked the video I mentioned in the email. So here is one project        which uses GitHub pages and will have the following things:
>>
>> 1.Issues and PRs related to privacy from different        Bitcoin projects. I have added few from Bitcoin Core (full node        implementation), Bisq(DEX) and LND (LN implementation) right        now.
>> 2.Blog section for my opinion on different privacy        related issues and PRs.
>> 3.'Hall of Fame' section to appreciate the        contribution of devs who are improving privacy in different        Bitcoin projects.
>>
>> I will be happy if this project helps in improving        privacy or helps users/devs in any other way. This project will        never turn in to a paid newsletter or needs any sponsors,        however any contribution to make the website better would be        appreciated. Edward Snowden can also contribute if he wants to        do more than just tweets to help improve Bitcoin privacy.
>>
>> Link: >> https://prayank23.github.io/camouflage/
>>
>> Will move everything to new repository this        weekend: >> https://github.com/BlockchainCommons/Bitcoin-Camouflage
>>
>> -- 
>> Prayank
>>
>> A3B1 E430 2298 178F
>>
>>
>> _______________________________________________bitcoin-dev mailing list>> bitcoin-dev at lists.linuxfoundation.org>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/643f0d40/attachment.html>

From kohli at ctemplar.com  Sun Aug 29 05:57:43 2021
From: kohli at ctemplar.com (pool2win)
Date: Sun, 29 Aug 2021 05:57:43 -0000
Subject: [bitcoin-dev] Braidpool: Proposal for a decentralised mining pool
Message-ID: <0aff157f62ea4abba71df4f87eb54880-kohli@ctemplar.com>

We have been working on a peer to peer mining pool that overcomes the
problems faced by P2Pool and enables building a futures market for
hashrate.
?
The proposal can be found here:
https://github.com/pool2win/braidpool/raw/main/proposal/proposal.pdf
?
The key features of the pool are:
?
1. Lower variance for smaller miners, even when large miners join
? the pool.
2. Miners build their own blocks, just like in P2Pool.
3. Payouts require a constant size blockspace, independent of the
? number of miners in the pool.
4. Provide building blocks for enabling a futures market of hash
? rates.
?
Braidpool: Decentralised Mining Pool for Bitcoin
?
Abstract. Bitcoin P2Pool's usage has steadily declined over the years,
negatively impacting bitcoin's decentralisation. The variance in
earnings for miners increases with total hashrate participating in
P2Pool, and payouts require a linearly increasing block space with the
number of miners participating in the pool. We present a solution that
uses a DAG of shares replicated at all miners. The DAG is then used to
compute rewards for miners. Rewards are paid out using one-way payment
channels by an anonymous hub communicating with the miners using Tor's
hidden services. Using the payment channels construction, neither the
hub nor the miners can cheat.

Full proposal at
https://github.com/pool2win/braidpool/raw/main/proposal/proposal.pdf
?
Details on trading hashrate are here:
https://pool2win.github.io/braidpool/2021/08/18/deliver-hashrate-to-market-makers.html
?
@pool2win

From prayank at tutanota.de  Sun Aug 29 09:32:47 2021
From: prayank at tutanota.de (Prayank)
Date: Sun, 29 Aug 2021 11:32:47 +0200 (CEST)
Subject: [bitcoin-dev] Using transaction version number in different projects
Message-ID: <MiGFGDc--3-2@tutanota.de>

print('Hello, world!')

I had asked related question on Bitcoin Stackexchange:?https://bitcoin.stackexchange.com/questions/108248/version-in-transaction

Wanted to know if others think we should allow more numbers in transaction version by considering such transaction standard. I have shared an example how transaction version can be used to bet on something that involves 2 outcomes:

https://gist.github.com/prayank23/6f54e9a27f057abd1182436e7f88d1ac

Anything wrong with this approach? We could use oracles (DLC) or something else later to settle the bet and create a release transaction. However wanted to confirm if everything looks okay until funding transaction. Nothing involves any centralized server or trusting third parties:
1.Tx1 is a normal OP_RETURN transaction.
2.App will save results for `getrawmempool` regularly in local db. It will check if any transaction wants to participate in bets.
3.Multisig address will be created using two public keys. One entered by user and other from mempool.
4.Funding transaction will use the version bits to indicate if Alice wants to bet on India or Australia.


-- 
Prayank

A3B1 E430 2298 178F
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/4daf00e3/attachment.html>

From aymeric at peersm.com  Sun Aug 29 09:51:39 2021
From: aymeric at peersm.com (Aymeric Vitte)
Date: Sun, 29 Aug 2021 11:51:39 +0200
Subject: [bitcoin-dev] Camouflage: A project dedicated to Hal Finney
In-Reply-To: <MiDv-Qo--3-2@tutanota.de>
References: <Mi8W8of--3-2@tutanota.de>
 <b8a18c30-d9f4-27cb-9a81-7c3b0bfcbf65@peersm.com> <MiDv-Qo--3-2@tutanota.de>
Message-ID: <b677cd41-46b9-5868-331b-04eabca04099@peersm.com>

Hi,

Maybe let's discuss the details privately since some might be off topic
for this list, as a quick answer the discussion I linked to is about
using the Tor protocol between bitcoin nodes piping the bitcoin protocol
via node-Tor (not to be misunderstood with the Tor network again), nodes
can be whatever you like including browsers (but the use of the Tor
browser is not foreseen neither encouraged, disabling js and WebRTC is
valid when you are browsing, but browsing is not what is proposed here),
they can be wallets too, if you look at the browserification of
bitcoin-transactions (https://peersm.com/wallet) there is a mechanism to
make sure the js code you loaded is the correct one, you can also create
a bookmarklet button with the js code to run it directly inside the
browser without having to load it

Regards

Aymeric


Le 29/08/2021 ? 00:40, Prayank a ?crit :
> Hi Aymeric,
>
> Thanks for sharing the link. 'bitcoin-transactions' and 'node-Tor'
> looks interesting although I will have to check details and try things.
>
> One observation: I noticed it's in JavaScript and will use WebRTC.
> Users who care about privacy normally disable both while using a browser.
>
> -- 
> Prayank
>
> A3B1 E430 2298 178F
>
>
>
> Aug 28, 2021, 22:06 by aymeric at peersm.com:
>
>     Probably you could add to your links this discussion/issue
>     https://github.com/bitcoin/bitcoin/pull/18988#issuecomment-646564853
>
>
>     Le 27/08/2021 ? 23:29, Prayank via bitcoin-dev a ?crit :
>>     I wish Hal Finney was with us today and help us improve privacy
>>     in Bitcoin. I like reading his posts and one of them is
>>     https://bitcointalk.org/index.php?topic=156390.msg1659654#msg1659654
>>
>>     I had emailed about Privacy related things on July 23:
>>     https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-July/019276.html
>>
>>     It was my birthday on 23 and had few beers so maybe email wasn't
>>     very focused. Although basic idea was to initiate discussion
>>     about improving privacy in different Bitcoin projects. I did not
>>     receive any response except one person who liked the video I
>>     mentioned in the email. So here is one project which uses GitHub
>>     pages and will have the following things:
>>
>>     1.Issues and PRs related to privacy from different Bitcoin
>>     projects. I have added few from Bitcoin Core (full node
>>     implementation), Bisq(DEX) and LND (LN implementation) right now.
>>     2.Blog section for my opinion on different privacy related issues
>>     and PRs.
>>     3.'Hall of Fame' section to appreciate the contribution of devs
>>     who are improving privacy in different Bitcoin projects.
>>
>>     I will be happy if this project helps in improving privacy or
>>     helps users/devs in any other way. This project will never turn
>>     in to a paid newsletter or needs any sponsors, however any
>>     contribution to make the website better would be appreciated.
>>     Edward Snowden can also contribute if he wants to do more than
>>     just tweets to help improve Bitcoin privacy.
>>
>>     Link: https://prayank23.github.io/camouflage/
>>
>>     Will move everything to new repository this weekend:
>>     https://github.com/BlockchainCommons/Bitcoin-Camouflage
>>
>>     -- 
>>     Prayank
>>
>>     A3B1 E430 2298 178F
>>
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>

-- 
Sophia-Antipolis, France
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
GitHub : https://www.github.com/Ayms
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.peersm.com
Peersm : http://www.peersm.com

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/3e69e234/attachment.html>

From bitcoin-dev at wuille.net  Sun Aug 29 14:24:48 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Sun, 29 Aug 2021 14:24:48 +0000
Subject: [bitcoin-dev] Human readable checksum (verification code) to
	avoid errors on BTC public addresses
In-Reply-To: <6f69f132-211f-9d42-8023-c3b0264af439@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <6f69f132-211f-9d42-8023-c3b0264af439@cronosurf.com>
Message-ID: <3isqiyeCtgJdzEvbbm3ZoS6h1_4l3YjtPypqJAPto5cp2K1BebmgEdVGLGTYt2j803RnfaiIbFxjGdPIac8vHHpMmelwStYm0om_szvX7xc=@wuille.net>

On Saturday, August 28th, 2021 at 5:17 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Following up on my original proposal, I would like to get some more feedback of the community
>
> to see if this could be realized at some point. Also, any recommendations as to who to contact
>
> to get things rolling?

I honestly don't understand the point of what you're suggesting.

* If you're concerned about random typos, this is something already automatically protected against through the checksum (both base58check or bech32/bech32m).

* If you're concerned about accidentally entering the wrong - but honestly created - address, comparing any few characters of the address is just as good as any other. It doesn't even require the presence of a checksum. Looking at the last N characters, or the middle N, or anything except the first few, will do, and is just as good as an "external" checksum added at the end. For randomly-generated addresses (as honest ones are), each of those has exactly as much entropy.

* If you're concerned about maliciously constructed addresses, which are designed to look similar in specific places, an attacker can just as easily make the external checksum collide (and having one might even worsen this, as now the attacker can focus on exactly that, rather than needing to focus on every other character).

Things would be different if you'd suggest a checksum in another medium than text (e.g. a visual/drawing/colorcoding one). But I don't see any added value for an additional text-based checksum when addresses are already text themselves. This is even disregarding the difficulty of getting the ecosystem to adopt such changes.

Cheers,

--
Pieter


From bitcoin-dev at wuille.net  Sun Aug 29 14:42:07 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Sun, 29 Aug 2021 14:42:07 +0000
Subject: [bitcoin-dev] Human readable checksum (verification code) to
	avoid errors on BTC public addresses
In-Reply-To: <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
 <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
Message-ID: <ZJqjnpWzG9qKb0N02X9WLkBM2hRWk7w0hmAXlIuHj1bQZptdxVJzdVGXAwSPjkM187aRo5GkQq4oSnCurryxKRkWTeA5HgNL9VxmFMoTpF4=@wuille.net>

On Thursday, August 19th, 2021 at 1:02 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> > In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?

Side note: it's actually the last six characters.

>
> Well, because
>
> a) most people don't know that
>
> b) it is specific to bech32
>
> c) it is not easily readable being the last digits of a long address (although this could be

I think this is a misconception. For the purpose of verifying that you have the *right* address (rather than just a valid one), the checksum, or even the knowledge that a checksum is present, is completely irrelevant.

In honestly-generated addresses, every character except the prefix (the ~2 first characters for P2PKH and P2SH, and the ~4 first characters for BIP173/BIP350 native segwit addresses) has exactly the same amount of entropy. Instead of adding say a 4 character code, just tell people to compare any 4 characters of their choosing. Or more - I would hope people are already comparing (much) more than 4 characters already.

It doesn't matter if the characters being compared are checksum characters or data characters. In honestly-generated addresses, both are equally random.

Adding a special 4 character "external" checksum IMO would instead encourage people to perhaps just compare those 4 characters instead of the rest (or at least, focus mostly on those). That could easily worsen how well comparisons are done in practice...

Cheers,

--
Pieter


From bitcoin-dev at wuille.net  Sun Aug 29 14:56:16 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Sun, 29 Aug 2021 14:56:16 +0000
Subject: [bitcoin-dev] Using transaction version number in different
	projects
In-Reply-To: <MiGFGDc--3-2@tutanota.de>
References: <MiGFGDc--3-2@tutanota.de>
Message-ID: <yOqiOQR1CIkTZxaWD4RtISMbpaDldcI0gBENXJj3blXBOuK2nDROxa6hECucO01mTpNcZtwqqzXwrVf8aC2YpFr7lznBxc2xKqiBECvVkzw=@wuille.net>

On Sunday, August 29th, 2021 at 5:32 AM, Prayank via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Wanted to know if others think we should allow more numbers in transaction version by considering such transaction standard. I have shared an example how transaction version can be used to bet on something that involves 2 outcomes:
> https://gist.github.com/prayank23/6f54e9a27f057abd1182436e7f88d1ac

I can't say I understand what you're suggesting, or what transaction version numbers have to do with it, so take the following with the caveat that I may be missing your point.

Generally, my view is that Bitcoin transactions should solely contain the information necessary for the world to validate them. Given that, as of now, there are no consensus rules (or even generally-adopted relay policies) that care about the version number except it being 1 or 2 (due to BIP68), I would say that the usage of anything but those 2 possible numbers is both pointless and a gratuitous loss of privacy: for numbers with no protocol-defined meaning, the usage of an uncommon one reveals something to the world that should be privately communicated to the parties involved instead.

Combined with the fact that currently-unused version numbers may well be used for future consensus rules like BIP68, which any use you're suggesting may interfere with, I say no: versions numbers with no protocol-defined meaning should not be standard. They are reserved for future extensions.

Cheers,

--
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210829/37bf2c9a/attachment.html>

From willtech at live.com.au  Mon Aug 30 03:31:56 2021
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Mon, 30 Aug 2021 03:31:56 +0000
Subject: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit
In-Reply-To: <CAM98U8nOqvOSBvP15dGup-LoW-af9EHFKyTy_XDOjfR-NGjJYA@mail.gmail.com>
References: <CAD5xwhjFBjvkMKev_6HFRuRGcZUi7WjO5d963GNXWN4n-06Pqg@mail.gmail.com>
 <CALZpt+F9FScaLsvXUozdBL4Ss8r71-gtUS_Fh9i53cK_rSGBeA@mail.gmail.com>
 <20210810061441.6rg3quotiycomcp6@ganymede>
 <CALZpt+G0CRitWLwUTA+7NnnZWNNrsEmFTMW3VmFSQ=vzXZOQGA@mail.gmail.com>
 <20210812220339.GA3416@erisian.com.au>
 <CAD5xwhiEDa2KjF265iDZ1ism4AFzh3S3D4cJSESVVKNwv9L7zA@mail.gmail.com>
 <50s2eg2qZ_BSHhI1mT_mHP7fkDQ8EXnakOb9NmDfZlx_hN44l37UmopfAr2V4ws4yhx0YihNYBIOelJ01vhITI8K4G1UgmobTwf9FyJq_Yo=@protonmail.com>
 <CAGpPWDbseo6eYT1a54YB2-fpxpzj2cg9DL+s2_rpoa+dGfnhaQ@mail.gmail.com>
 <CAM98U8nOqvOSBvP15dGup-LoW-af9EHFKyTy_XDOjfR-NGjJYA@mail.gmail.com>
Message-ID: <PS2P216MB108951BFE0724BD49D8EEA809DCB9@PS2P216MB1089.KORP216.PROD.OUTLOOK.COM>

Good Afternoon,

It is worth reconsidering the value accumulated in dust. Speculatively, when the value of 1 BTC reaches US$ 1,000,000.00 then the value of one satoshi will be US$ 0.01 so, for 1 satoshi to be of any substantial value the value of Bitcoin will have to rise substantially higher. I ask what then should the value of fees be? Is there not a future case foreseeable at least in consideration of Bitcoin's comparison with Gold that the value may be so high as to allow that 1 satoshi may cover the mining cost of any transaction despite the reduction in sat/B for including the additional transaction. Is it not that we can foresee the dust has value and that the wealthy may have in fact millions of dust transactions that are inheritable, though I hesitate to make my business collecting them I may set up a website. The current reason for excluding dust is because it costs more to the transaction to add the dust than its value but that does not say that will always be the case.

KING JAMES HRMH
Great British Empire

Regards,
The Australian
LORD HIS EXCELLENCY JAMES HRMH (& HMRH)
of Hougun Manor & Glencoe & British Empire
MR. Damian A. James Williamson
Wills

et al.


Willtech
www.willtech.com.au
www.go-overt.com
and other projects

earn.com/willtech
linkedin.com/in/damianwilliamson


m. 0487135719
f. +61261470192


This email does not constitute a general advice. Please disregard this email if misdelivered.
----
________________________________
From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of shymaa arafat via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Friday, 27 August 2021 7:07 PM
To: Billy Tetrud <billy.tetrud at gmail.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
Cc: lightning-dev <lightning-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] [Lightning-dev] Removing the Dust Limit

Allow me to ask:

-Untill you find a mitigation that consolidate all dust UTXOS, why don't you separate them and all probably Unspendable UTXOS in a different partition?
-I'm talking at the real UTXO storage level (to be kept in secondary storage), and at the Merkleization level in any accumulator design Utreexo or what so ever(putting them in one or two subtree/forest with hardly changing roots according to the categorization will reduce the proof size, even if slightly)
-This will also help things like Bloom filters, assume UTXOs,...etc when about 10% with almost zero probability are trimmed from the pool you are withdrawing from.
.
-The paper I mentioned earlier says in Feb 2018, there was about 2.4m UTXOS less than 1000 Satoshi, of which ~824,892 holds exactly 1 Satoshi
-I don't think any of those were spent since that time, in fact there could be a possibility that the numbers may have increased
-As the last previous reply mentioned you have to consider the long run effect on the UTXO set forever, this is a straight forward improvement that comes with almost no effort
.
Ps.
-If there is something wrong, something I missed in this idea please explain it to me
-Or do you find the improvement itself a "dust" that doesn't worth the effort???
.
Regards & thank you all for your time in reading & replying
Shymaa M. Arafat
On Fri, Aug 27, 2021, 00:06 Billy Tetrud via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:

One interesting thing I thought of: the cost of maintenance of the dust creates a (very) small incentive to mine transactions that *use* dust outputs with a slightly lower fee that contain dust, in order to reduce the future maintenance cost for themselves. However, the rational discount would likely be vanishingly small.  It would be interesting to add something to the consensus rules to decrease the vbytes for a transaction that consumes dust outputs such that the value of removing them from the system (saving the future cost of maintenance) is approximately equal to the amount that the fee could be made lower for such transactions. Even measuring this as a value over the whole (future) bitcoin network, I'm not sure how to evaluate the magnitude of this future cost.





On Fri, Aug 20, 2021 at 8:12 PM ZmnSCPxj via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
Good morning Jeremy,

> one interesting point that came up at the bitdevs in austin today that favors remove that i believe is new to this discussion (it was new to me):
>
> the argument can be reduced to:
>
> - dust limit is a per-node relay policy.
> - it is rational for miners to mine dust outputs given their cost of maintenance (storing the output potentially forever) is lower than their immediate reward in fees.
> - if txn relaying nodes censor something that a miner would mine, users will seek a private/direct relay to the miner and vice versa.
> - if direct relay to miner becomes popular, it is both bad for privacy and decentralization.
> - therefore the dust limit, should there be demand to create dust at prevailing mempool feerates, causes an incentive to increase network centralization (immediately)
>
> the tradeoff is if a short term immediate incentive to promote network centralization is better or worse than a long term node operator overhead.

Against the above, we should note that in the Lightning spec, when an output *would have been* created that is less than the dust limit, the output is instead put into fees.
https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#trimmed-outputs

Thus, the existence of a dust limit encourages L2 protocols to have similar rules, where outputs below the dust limit are just given over as fees to miners, so the existence of a dust limit might very well be incentivize-compatible for miners, regardless of centralization effects or not.


Regards,
ZmnSCPxj
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210830/252c9f16/attachment-0001.html>

From zachgrw at gmail.com  Mon Aug 30 14:43:30 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Mon, 30 Aug 2021 16:43:30 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <wdlRrp4fZxH79mzVpTQWp99V9uI8jLvRU40mwdJ8lZ5A2mGMsxUK1TmZEZTV7O4_eUnNyq3feEGv5BUN-ecPSlbL-EYR6ZyLxk9ErsFiPlE=@protonmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <CAGpPWDZL6BpzoNa0Qgf-Ux60fyWPjZH=NESkgbhEQO_My=XiAg@mail.gmail.com>
 <CAJ4-pEBwdUJ3kg=yb-kWZLoaX5f_2t353K7Tr+dJy+JpAoKTmQ@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
 <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
 <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>
 <wdlRrp4fZxH79mzVpTQWp99V9uI8jLvRU40mwdJ8lZ5A2mGMsxUK1TmZEZTV7O4_eUnNyq3feEGv5BUN-ecPSlbL-EYR6ZyLxk9ErsFiPlE=@protonmail.com>
Message-ID: <CAJ4-pECwGfrrB15oS0t-+vsjn11sC=9Bz6JGsGsicUorCjuYpA@mail.gmail.com>

Hi ZmnSCPxj,

> I suggest looking into the covenant opcodes and supporting those instead
of your own proposal, as your application is very close to one of the
motivating examples for covenants in the first place.

I believe it is not the right approach to take a proposal, chop off key
aspects of its functionality, and rely to some future change in Bitcoin
that may perhaps enable implementing some watered down version of the
intended functionality. In my opinion the right order would be to first
discuss the unmodified proposal on a functional level and gauge community
interest, then move forward to discuss technical challenges for the
*unmodified* proposal instead of first knee-capping the proposal in order
to (presumably) reduce cost of implementation.

I believe that we both recognize that the proposed functionality would be
beneficial. I believe that your position is that functionality close to
what I have in mind can be implemented using covenants, albeit with some
gaps. For me personally however these gaps would not be acceptable because
they severely hurt the predictability and intuitiveness of the behavior of
the functionality for the end-user. But as noted, I believe at this point
it is premature to have this discussion.

Perhaps you could help me understand what would be required to implement
the *unmodified* proposal. That way, the community will be able to better
assess the cost (in terms of effort and risk) and weigh it against the
perceived benefits. Perhaps *then* we find that the cost could be
significantly reduced without any significant reduction of the benefits,
for instance by slightly compromising on the functionality such that no
changes to consensus would be required for its implementation. (I am
skeptical that this would be possible though). The cost reduction must be
carefully weighed against the functional gaps it creates.

I am aware that my proposal must be well-defined functionally before being
able to reason about its benefits and implementational aspects. I believe
that the proposed functionality is pretty straightforward, but I am happy
to come up with a more precise functional spec. However, such effort would
be wasted if there is no community interest for this functionality. So far
only few people have engaged with this thread, and I am not sure that this
is because there is no interest in the proposal or because most people just
lurk here and do not feel like giving their opinion on random proposals. It
would be great however to learn about more people's opinions.

As a reminder, the proposed functionality is to enable a user to limit the
amount that they able to spent from an address within a certain time-frame
or window (defined in number of blocks) while retaining the ability to
spend arbitrary amounts using a secondary private key (or set of private
keys). The general use case is to prevent theft of large amounts while
still allowing a user to spend small amounts over time. Hodlers as well as
exchanges dealing with cold, warm and hot wallets come to mind as users who
could materially benefit from this functionality.

Zac



On Mon, Aug 16, 2021 at 1:48 PM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Zac,
>
> > Thank you for your counterproposal. I fully agree that as a first step
> we must establish whether the proposed functionality can be implemented
> without making any changes to consensus.
> >
> > Your counterproposal is understandably more technical in nature because
> it explores an implementation on top of Bitcoin as-is. However I feel that
> for a fair comparison of the functionality of both proposals a purely
> functional description of your proposal is essential.
> >
> > If I understand your proposal correctly, then I believe there are some
> major gaps between yours and mine:
> >
> > Keys for unrestricted spending: in my proposal, they never have to come
> online unless spending more than the limit is desired. In your proposal,
> these keys are required to come online in several situations.
>
> Correct, that is indeed a weakness.
>
> It is helpful to see https://zmnscpxj.github.io/bitcoin/unchained.html
> Basically: any quorum of signers can impose any rules that are not
> implementable on the base layer, including the rules you desire.
> That quorum is the "offline keyset" in my proposal.
>
> >
> > Presigning transactions: not required in my proposal. Wouldn?t such
> presigning requirement be detrimental for the usability of your proposal?
> Does it mean that for instance the amount and window in which the
> transaction can be spent is determined at the time of signing? In my
> proposal, there is no limit in the number of transactions per window.
>
> No.
> Remember, the output is a simple 1-of-1 or k-of-n of the online keyset.
> The online keyset can spend that wherever and however, including paying it
> out to N parties, or paying part of the limit to 1 party and then paying
> the remainder back to the same onchain keyset so it can access the funds in
> the future.
> Both cases are also available in your proposal, and the latter case (pay
> out part of the limit to a single output, then keep the rest back to the
> same onchain keyset) can be used to add an indefinite number of
> transactions per window.
>
> >
> > Number of windows: limited in your proposal, unlimited in mine.
>
> Correct, though you can always have a fairly large number of windows
> ("640kB ought to be enough for anybody").
>
> >
> > There are probably additional gaps that I am currently not technically
> able to recognize.
>
> It requires a fair amount of storage for the signatures at minimum, though
> that may be as small as 64 bytes per window.
> 1Mb of storage for signatures would allow 16,384 windows, assuming you use
> 1-day windows that is about 44.88 years, probably more than enough that a
> one-time onlining of the offline keys (or just print out the signatures on
> paper or display as a QR code, whatever) is acceptable.
>
> > I feel that the above gaps are significant enough to state that your
> proposal does not meet the basic requirements of my proposal.
> >
> > Next to consider is whether the gap is acceptable, weighing the effort
> to implement the required consensus changes against the effort and
> feasibility of implementing your counterproposal.
> >
> > I feel that your counterproposal has little chance of being implemented
> because of the still considerable effort required and the poor result in
> functional terms. I also wonder if your proposal is feasible considering
> wallet operability.
>
> See above, particularly the gap that does not, in fact, exist.
>
> >
> > Considering all the above, I believe that implementing consensus changes
> in order to support the proposed functionality would preferable  over your
> counterproposal.
> >
> > I acknowledge that a consensus change takes years and is difficult to
> achieve, but that should not be any reason to stop exploring the appetite
> for the proposed functionality and perhaps start looking at possible
> technical solutions.
>
> You can also look into the "covenant" opcodes (`OP_CHECKSIGFROMSTACK`,
> `OP_CHECKTEMPLATEVERIFY`, etc.), I think JeremyRubin has a bunch of them
> listed somewhere, which may be used to implement something similar without
> requiring presigning.
>
> Since the basic "just use `nSequence`" scheme already implements what you
> need, what the covenant opcodes buy you is that you do not need the offline
> keyset to be onlined and there is no need to keep signatures, removing the
> remaining gaps you identified.
> With a proper looping covenant opcode, there is also no limit on the
> number of windows.
>
> The issue with the covenant opcodes is that there are several proposals
> with overlapping abilities and different tradeoffs.
> This is the sort of thing that invites bikeshed-painting.
>
> I suggest looking into the covenant opcodes and supporting those instead
> of your own proposal, as your application is very close to one of the
> motivating examples for covenants in the first place.
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210830/0da8e013/attachment.html>

From ts at cronosurf.com  Tue Aug 31 02:16:00 2021
From: ts at cronosurf.com (ts)
Date: Mon, 30 Aug 2021 21:16:00 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <3isqiyeCtgJdzEvbbm3ZoS6h1_4l3YjtPypqJAPto5cp2K1BebmgEdVGLGTYt2j803RnfaiIbFxjGdPIac8vHHpMmelwStYm0om_szvX7xc=@wuille.net>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <6f69f132-211f-9d42-8023-c3b0264af439@cronosurf.com>
 <3isqiyeCtgJdzEvbbm3ZoS6h1_4l3YjtPypqJAPto5cp2K1BebmgEdVGLGTYt2j803RnfaiIbFxjGdPIac8vHHpMmelwStYm0om_szvX7xc=@wuille.net>
Message-ID: <75a02b16-0aac-4afd-1a9e-f71a8396baea@cronosurf.com>

Pieter, thanks for your comments. Here my thoughts:

Pieter Wuille wrote on 8/29/21 9:24 AM:
> On Saturday, August 28th, 2021 at 5:17 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>> Following up on my original proposal, I would like to get some more feedback of the community
>>
>> to see if this could be realized at some point. Also, any recommendations as to who to contact
>>
>> to get things rolling?
> 
> I honestly don't understand the point of what you're suggesting.

It is about creating a simple technical assistance that makes it more user friendly and less 
error prone to verify the entered address. For all types of users, including those who are 
less tech savvy.


> * If you're concerned about random typos, this is something already automatically protected against through the checksum (both base58check or bech32/bech32m).

I agree, but as mentioned in the original proposal, it is not about random typos (although 
this would help for other coins without integrated checksum of course), but rather about 
copy&paste errors (both technical or user caused).


> * If you're concerned about accidentally entering the wrong - but honestly created - address, comparing any few characters of the address is just as good as any other. It doesn't even require the presence of a checksum. Looking at the last N characters, or the middle N, or anything except the first few, will do, and is just as good as an "external" checksum added at the end. For randomly-generated addresses (as honest ones are), each of those has exactly as much entropy.

Correct. However, I believe that ADDITIONALLY to looking at N characters, a quick check of a 3 
or 4 digit code in bigger font next to the address would make for a better user experience. 
This gives the user the reassurance that there is definitely no error. I agree that most users 
with technical background including most of us here will routinely check the first/last N 
characters. I usually check the first 3 + last 3 characters. But I don't think this is very 
user friendly. More importantly, I once had the case that two addresses were very similar at 
precisely those 6 characters, and only a more close and concentrated look made me see the 
difference. Moreover, some inexperienced users that are not aware of the consequences of 
entering a wrong address (much worse than entering the wrong bank account in an online bank 
transfer) might forget to look at the characters altogether.


> * If you're concerned about maliciously constructed addresses, which are designed to look similar in specific places, an attacker can just as easily make the external checksum collide (and having one might even worsen this, as now the attacker can focus on exactly that, rather than needing to focus on every other character).

Not so concerned about this case, since this is a very special case that can only occur under 
certain circumstances. But taking this case also into consideration, this is why the user 
should use the verification code ADDITIONALLY to the normal way of verifying, not instead. If 
the attacker only focuses on the verification code, he will only be successful with users that 
ONLY look at this code. But if the attacker intends to be more successful, he now needs to 
create a valid address that is both similar in specific places AND produces the same 
verification code, which is way more difficult to achieve.


> Things would be different if you'd suggest a checksum in another medium than text (e.g. a visual/drawing/colorcoding one). But I don't see any added value for an additional text-based checksum when addresses are already text themselves.

Yes, a visual checksum could also work. Christopher Allen proposed to use LifeHash as an 
alternative. It would be a matter of balancing the more complex implementation and need of 
space in the app's layout with the usability and advantages of use. One advantage of the digit 
verification code is that it can be spoken in a call or written in a message.

> This is even disregarding the difficulty of getting the ecosystem to adopt such changes.

No changes are needed, only an agreement or recommendation on which algorithm for the code 
generation should be used. Once this is done, it is up to the developers of wallets and 
exchanges to implement this feature as they see fit.

Greetings,
TS

From ts at cronosurf.com  Tue Aug 31 02:17:07 2021
From: ts at cronosurf.com (ts)
Date: Mon, 30 Aug 2021 21:17:07 -0500
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <ZJqjnpWzG9qKb0N02X9WLkBM2hRWk7w0hmAXlIuHj1bQZptdxVJzdVGXAwSPjkM187aRo5GkQq4oSnCurryxKRkWTeA5HgNL9VxmFMoTpF4=@wuille.net>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <aO1qYUmtGXPJupl0ol3E221AR4XKwqriqk3Y5fVS2_asquaV8Vaxkb4Ffq2EiVMrR5bb4cXAzxAV3cOciaYsuqJoFXoc6vTOoveKURVTmLU=@protonmail.com>
 <8565f40b-2f32-cf31-6c47-971a6e57cb41@cronosurf.com>
 <ZJqjnpWzG9qKb0N02X9WLkBM2hRWk7w0hmAXlIuHj1bQZptdxVJzdVGXAwSPjkM187aRo5GkQq4oSnCurryxKRkWTeA5HgNL9VxmFMoTpF4=@wuille.net>
Message-ID: <58562a1c-b1e3-95da-59b6-6cd5eae0b137@cronosurf.com>

Pieter Wuille wrote on 8/29/21 9:42 AM:
> On Thursday, August 19th, 2021 at 1:02 PM, ts via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>>> In any case --- the last 5 characters of a bech32 string are already a human-readable 5-digit code, with fairly good properties, why is it not usable for this case?
> 
> Side note: it's actually the last six characters.
> 
>>
>> Well, because
>>
>> a) most people don't know that
>>
>> b) it is specific to bech32
>>
>> c) it is not easily readable being the last digits of a long address (although this could be
> 
> I think this is a misconception. For the purpose of verifying that you have the *right* address (rather than just a valid one), the checksum, or even the knowledge that a checksum is present, is completely irrelevant.

Exactly, it is irrelevant in that case. That's why I added d) "...it only proves that an 
address is valid, but not necessarily the correct one..."


> In honestly-generated addresses, every character except the prefix (the ~2 first characters for P2PKH and P2SH, and the ~4 first characters for BIP173/BIP350 native segwit addresses) has exactly the same amount of entropy. Instead of adding say a 4 character code, just tell people to compare any 4 characters of their choosing. Or more - I would hope people are already comparing (much) more than 4 characters already.
> 
> It doesn't matter if the characters being compared are checksum characters or data characters. In honestly-generated addresses, both are equally random.

Yes, I agree with this basically, the entropy would be the same. My proposal is all about 
improving the user experience.


> Adding a special 4 character "external" checksum IMO would instead encourage people to perhaps just compare those 4 characters instead of the rest (or at least, focus mostly on those). That could easily worsen how well comparisons are done in practice...

This is a good point. This feature should not encourage people to just compare the code on its 
own or to focus mostly on it. It should be understood as a verification ON TOP. But then 
again, is there a perfect solution? As it is now, most users focus on only a few characters, 
if any.

* New variant
This discussion is now leading me to a new thought. Since the entropy is the same with a given 
number of characters from the address as you say and the address has already an inbuilt 
checksum, an alternative way to do this would be to just take 4 or 5 characters (as you 
proposed above) from a fixed position and present them to the user separately. Say, characters 
from position 11th to 15th. Those 5 characters should be displayed by the wallet next or 
bellow to the address in a clear box and big font. It could be called "Quick Verification Box" 
or some other catchy name.

Of course, the user could do this by looking at the address on his own. But this way he is 
encouraged to look at a given number of characters. Plus, a the bigger font makes it easier to 
see.

Example (characters 11th-15th):
1KM7GsxUvQiYC8eohKA2QHr9fCjkJXDFvg  [YC8eo] <- in a bigger font
            ^^^^^

Or alternatively, the first 2 characters, chars. at position 11 and 12, and the last 2 characters:
1KM7GsxUvQiYC8eohKA2QHr9fCjkJXDFvg  [1K-YC-vg] <- in a bigger font
^^         ^^                   ^^

Or characters at pos. 11-13 and 18-20:
1KM7GsxUvQiYC8eohKA2QHr9fCjkJXDFvg  [YC8-A2Q] <- in a bigger font
            ^^^    ^^^

Whatever combination is used, the important thing is that it becomes a standard and all 
wallets use the same one.

The advantage of this solution is that it would be technically even easier to implement, and 
more transparent at the same time. It is again all about agreeing on which characters to pick.


* Avoiding the confusion among networks (or blockchains)
In my original proposal, I mentioned that each network should use its own code generation 
algorithm. This way, for networks sharing the same address format, like BTC and BCH, the user 
would have this extra level of verification (in case he intends to send coins from BCH network 
to BTC or viceversa).
For the new variant above, this is easy to achieve too - each network should agree on a 
different subset of characters,

I hope I could explain this clearly enough, and that someone can see a value in this.

Cheers,
TS


From marek at palatinus.cz  Tue Aug 31 08:47:26 2021
From: marek at palatinus.cz (Marek Palatinus)
Date: Tue, 31 Aug 2021 09:47:26 +0100
Subject: [bitcoin-dev] Human readable checksum (verification code) to
 avoid errors on BTC public addresses
In-Reply-To: <75a02b16-0aac-4afd-1a9e-f71a8396baea@cronosurf.com>
References: <f31bc6b0-f9b3-be4c-190c-fc292821b24b@cronosurf.com>
 <6f69f132-211f-9d42-8023-c3b0264af439@cronosurf.com>
 <3isqiyeCtgJdzEvbbm3ZoS6h1_4l3YjtPypqJAPto5cp2K1BebmgEdVGLGTYt2j803RnfaiIbFxjGdPIac8vHHpMmelwStYm0om_szvX7xc=@wuille.net>
 <75a02b16-0aac-4afd-1a9e-f71a8396baea@cronosurf.com>
Message-ID: <CAJna-Hhtr0v_uEE-4ET4FPNnGnPv8sW2JXkVka0XDkphy_YmSg@mail.gmail.com>

I fully agree with sipa and his reasoning that this proposal is not solving
any particular problem, but making it actually a bit worse.

Also, do you know what I hate more than copy&pasting bitcoin addresses?
Copy pasting zillion random fields for SEPA/wire transfers. And I believe
that a single copy pasta of a bitcoin address is a much better user
experience after all.

Best,
slush

On Tue, Aug 31, 2021 at 9:08 AM ts via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Pieter, thanks for your comments. Here my thoughts:
>
> Pieter Wuille wrote on 8/29/21 9:24 AM:
> > On Saturday, August 28th, 2021 at 5:17 PM, ts via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> >> Following up on my original proposal, I would like to get some more
> feedback of the community
> >>
> >> to see if this could be realized at some point. Also, any
> recommendations as to who to contact
> >>
> >> to get things rolling?
> >
> > I honestly don't understand the point of what you're suggesting.
>
> It is about creating a simple technical assistance that makes it more user
> friendly and less
> error prone to verify the entered address. For all types of users,
> including those who are
> less tech savvy.
>
>
> > * If you're concerned about random typos, this is something already
> automatically protected against through the checksum (both base58check or
> bech32/bech32m).
>
> I agree, but as mentioned in the original proposal, it is not about random
> typos (although
> this would help for other coins without integrated checksum of course),
> but rather about
> copy&paste errors (both technical or user caused).
>
>
> > * If you're concerned about accidentally entering the wrong - but
> honestly created - address, comparing any few characters of the address is
> just as good as any other. It doesn't even require the presence of a
> checksum. Looking at the last N characters, or the middle N, or anything
> except the first few, will do, and is just as good as an "external"
> checksum added at the end. For randomly-generated addresses (as honest ones
> are), each of those has exactly as much entropy.
>
> Correct. However, I believe that ADDITIONALLY to looking at N characters,
> a quick check of a 3
> or 4 digit code in bigger font next to the address would make for a better
> user experience.
> This gives the user the reassurance that there is definitely no error. I
> agree that most users
> with technical background including most of us here will routinely check
> the first/last N
> characters. I usually check the first 3 + last 3 characters. But I don't
> think this is very
> user friendly. More importantly, I once had the case that two addresses
> were very similar at
> precisely those 6 characters, and only a more close and concentrated look
> made me see the
> difference. Moreover, some inexperienced users that are not aware of the
> consequences of
> entering a wrong address (much worse than entering the wrong bank account
> in an online bank
> transfer) might forget to look at the characters altogether.
>
>
> > * If you're concerned about maliciously constructed addresses, which are
> designed to look similar in specific places, an attacker can just as easily
> make the external checksum collide (and having one might even worsen this,
> as now the attacker can focus on exactly that, rather than needing to focus
> on every other character).
>
> Not so concerned about this case, since this is a very special case that
> can only occur under
> certain circumstances. But taking this case also into consideration, this
> is why the user
> should use the verification code ADDITIONALLY to the normal way of
> verifying, not instead. If
> the attacker only focuses on the verification code, he will only be
> successful with users that
> ONLY look at this code. But if the attacker intends to be more successful,
> he now needs to
> create a valid address that is both similar in specific places AND
> produces the same
> verification code, which is way more difficult to achieve.
>
>
> > Things would be different if you'd suggest a checksum in another medium
> than text (e.g. a visual/drawing/colorcoding one). But I don't see any
> added value for an additional text-based checksum when addresses are
> already text themselves.
>
> Yes, a visual checksum could also work. Christopher Allen proposed to use
> LifeHash as an
> alternative. It would be a matter of balancing the more complex
> implementation and need of
> space in the app's layout with the usability and advantages of use. One
> advantage of the digit
> verification code is that it can be spoken in a call or written in a
> message.
>
> > This is even disregarding the difficulty of getting the ecosystem to
> adopt such changes.
>
> No changes are needed, only an agreement or recommendation on which
> algorithm for the code
> generation should be used. Once this is done, it is up to the developers
> of wallets and
> exchanges to implement this feature as they see fit.
>
> Greetings,
> TS
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/3f498943/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Aug 31 09:00:15 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 31 Aug 2021 09:00:15 +0000
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
	a function of total input value
In-Reply-To: <CAJ4-pECwGfrrB15oS0t-+vsjn11sC=9Bz6JGsGsicUorCjuYpA@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
 <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
 <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>
 <wdlRrp4fZxH79mzVpTQWp99V9uI8jLvRU40mwdJ8lZ5A2mGMsxUK1TmZEZTV7O4_eUnNyq3feEGv5BUN-ecPSlbL-EYR6ZyLxk9ErsFiPlE=@protonmail.com>
 <CAJ4-pECwGfrrB15oS0t-+vsjn11sC=9Bz6JGsGsicUorCjuYpA@mail.gmail.com>
Message-ID: <RrFU9zB125CEEua75KWb6IfANybTVN9AGfvjxE65Ysa1zOIgM-h48HmdBcfynW7HEd6kOaA5G-FhAVbmrq5DJXJJYHNArJDORGJklnBCU_I=@protonmail.com>

Good morning Zac,


> Perhaps you could help me understand what would be required to implement the *unmodified* proposal. That way, the community will be able to better assess the cost (in terms of effort and risk) and weigh it against the perceived benefits. Perhaps *then* we find that the cost could be significantly reduced without any significant reduction of the benefits, for instance by slightly compromising on the functionality such that no changes to consensus would be required for its implementation. (I am skeptical that this would be possible though). The cost reduction must be carefully weighed against the functional gaps it creates.

For one, such output need to be explicitly visible, to implement the "change outputs must also be rate-limited".
A tx spending a rate-limited output has to know that one of the outputs is also a rate-limited output.

This flagging needs to be done by either allocating a new SegWit version --- a resource that is not lightly allocated, there being only 30 versions left if my understanding is correct --- or blessing yet another anyone-can-spend `scriptPubKey` template, something we want to avoid which is why SegWit has versions (i.e. we want SegWit to be the last anyone-can-spend `scriptPubKey` template we bless for a **long** time).

Explicit flagging is bad as well for privacy, which is another mark against it.
Notice how Taproot improves privacy by making n-of-n indistinguishable from 1-of-1 (and with proper design or a setup ritual, k-of-n can be made indistinguishable from 1-of-1).
Notice as well that my first counterproposal is significantly more private than explicit flagging, and my second coutnerproposal is also more private if wallets change their anti-fee-sniping mitigation.
This privacy loss represented by explicit flagging will be resisted by some people, especially those that use a bunch of random letters as a pseudonym (because duh, privacy).

(Yes, people can just decide not to use the privacy-leaking explicitly-flagged outputs, but that reduces the anonymity set of people who *are* interested in privacy, so people who are interested in privacy will prefer that other people do not leak their privacy so they can hide among *those* people as well.)

You also probably need to keep some data with each output.
This can be done by explicitly storing that data in the output directly, rather than a commitment to that data --- again, the "change outputs must also be rate-limited" requirement needs to check those data.

The larger data stored with the output is undesirable, ideally we want each output to just be a commitment rather than contain any actual data, because often a 20-byte commitment is smaller than the data that needs to be stored.
For example, I imagine that your original proposal requires, for change outputs, to store:

* The actual rate limit.
* The time frame of the rate limit.
* The reduced rate limit, since we spent an amount within a specific time frame (i.e. residual limit) which is why this is a change output.
* How long that time frame lasts.
* A commitment to the keys that can spend this.

Basically, until the residual limit expires, we impose the residual limit, then after the expiry of the residual limit we go back to the original rate limit.

The commitment to the keys itself takes at least 20 bytes, and if you are planning a to support k-of-n then that takes at least 32 bytes.
If this was not explicitly tagged, then a 32 byte commitment to all the necessary data would have been enough, but you do need the explicit tagging for the "change outputs must be rate-limited too".

Note as well that the residual needs to be kept with the output.
Bitcoin Core does not store transactions in a lookup table, it stores individual *outputs*.
While the residual can be derived from the transaction, we do not have a transaction table.
Thus, we need to explicitly put it on the output itself, directly, since we only have a lookup table for the unspent outputs, not individual transactions.

(well there is `txindex` but that is an option for each node, not something consensus code can rely on)

So yes, that "change outputs must also be rate-limited" is the big sticking point, and a lot of the "gaps" you worry about occur when we drop this bit.
Drop this bit and you can implement it today without any consensus code change, and with privacy good enough to prevent people with random letters as pseudonym from trying to stop you.

Regards,
ZmnSCPxj


From zachgrw at gmail.com  Tue Aug 31 14:09:04 2021
From: zachgrw at gmail.com (Zac Greenwood)
Date: Tue, 31 Aug 2021 16:09:04 +0200
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
 a function of total input value
In-Reply-To: <RrFU9zB125CEEua75KWb6IfANybTVN9AGfvjxE65Ysa1zOIgM-h48HmdBcfynW7HEd6kOaA5G-FhAVbmrq5DJXJJYHNArJDORGJklnBCU_I=@protonmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <CAGpPWDYMZ+w3VSaLhR68f4WVq7NCUp3SedwW2e8QnRHOgLQqQg@mail.gmail.com>
 <CAJ4-pEAT8Rrf7dN9A+F2SUvaRz0-DqgDw45whtZcWCTPeQ+uxA@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
 <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
 <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>
 <wdlRrp4fZxH79mzVpTQWp99V9uI8jLvRU40mwdJ8lZ5A2mGMsxUK1TmZEZTV7O4_eUnNyq3feEGv5BUN-ecPSlbL-EYR6ZyLxk9ErsFiPlE=@protonmail.com>
 <CAJ4-pECwGfrrB15oS0t-+vsjn11sC=9Bz6JGsGsicUorCjuYpA@mail.gmail.com>
 <RrFU9zB125CEEua75KWb6IfANybTVN9AGfvjxE65Ysa1zOIgM-h48HmdBcfynW7HEd6kOaA5G-FhAVbmrq5DJXJJYHNArJDORGJklnBCU_I=@protonmail.com>
Message-ID: <CAJ4-pEC_NTScPFg822Va+Sw1_yC87tWBAL4y7y-m7PSx+JcccQ@mail.gmail.com>

Hi ZmnSCPxj,

Thank you for your helpful response. We're on the same page concerning
privacy so I'll focus on that. I understand from your mail that privacy
would be reduced by this proposal because:

* It requires the introduction of a new type of transaction that is
different from a "standard" transaction (would that be P2TR in the
future?), reducing the anonymity set for everyone;
* The payment and change output will be identifiable because the change
output must be marked encumbered on-chain;
* The specifics of how the output is encumbered must be visible on-chain as
well reducing privacy even further.

I don't have the technical skills to judge whether these issues can somehow
be resolved. In functional terms, the output should be spendable in a way
that does not reveal that the output is encumbered, and produce a change
output that cannot be distinguished from a non-change output while still
being encumbered. Perhaps some clever MAST-fu could somehow help?

I imagine that the offered functionality does not justify the above
mentioned privacy reductions, so unless these can be addressed, without
functional modification this proposal sadly seems dead in the water.

Thanks again.

Zac


On Tue, Aug 31, 2021 at 11:00 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Zac,
>
>
> > Perhaps you could help me understand what would be required to implement
> the *unmodified* proposal. That way, the community will be able to better
> assess the cost (in terms of effort and risk) and weigh it against the
> perceived benefits. Perhaps *then* we find that the cost could be
> significantly reduced without any significant reduction of the benefits,
> for instance by slightly compromising on the functionality such that no
> changes to consensus would be required for its implementation. (I am
> skeptical that this would be possible though). The cost reduction must be
> carefully weighed against the functional gaps it creates.
>
> For one, such output need to be explicitly visible, to implement the
> "change outputs must also be rate-limited".
> A tx spending a rate-limited output has to know that one of the outputs is
> also a rate-limited output.
>
> This flagging needs to be done by either allocating a new SegWit version
> --- a resource that is not lightly allocated, there being only 30 versions
> left if my understanding is correct --- or blessing yet another
> anyone-can-spend `scriptPubKey` template, something we want to avoid which
> is why SegWit has versions (i.e. we want SegWit to be the last
> anyone-can-spend `scriptPubKey` template we bless for a **long** time).
>
> Explicit flagging is bad as well for privacy, which is another mark
> against it.
> Notice how Taproot improves privacy by making n-of-n indistinguishable
> from 1-of-1 (and with proper design or a setup ritual, k-of-n can be made
> indistinguishable from 1-of-1).
> Notice as well that my first counterproposal is significantly more private
> than explicit flagging, and my second coutnerproposal is also more private
> if wallets change their anti-fee-sniping mitigation.
> This privacy loss represented by explicit flagging will be resisted by
> some people, especially those that use a bunch of random letters as a
> pseudonym (because duh, privacy).
>
> (Yes, people can just decide not to use the privacy-leaking
> explicitly-flagged outputs, but that reduces the anonymity set of people
> who *are* interested in privacy, so people who are interested in privacy
> will prefer that other people do not leak their privacy so they can hide
> among *those* people as well.)
>
> You also probably need to keep some data with each output.
> This can be done by explicitly storing that data in the output directly,
> rather than a commitment to that data --- again, the "change outputs must
> also be rate-limited" requirement needs to check those data.
>
> The larger data stored with the output is undesirable, ideally we want
> each output to just be a commitment rather than contain any actual data,
> because often a 20-byte commitment is smaller than the data that needs to
> be stored.
> For example, I imagine that your original proposal requires, for change
> outputs, to store:
>
> * The actual rate limit.
> * The time frame of the rate limit.
> * The reduced rate limit, since we spent an amount within a specific time
> frame (i.e. residual limit) which is why this is a change output.
> * How long that time frame lasts.
> * A commitment to the keys that can spend this.
>
> Basically, until the residual limit expires, we impose the residual limit,
> then after the expiry of the residual limit we go back to the original rate
> limit.
>
> The commitment to the keys itself takes at least 20 bytes, and if you are
> planning a to support k-of-n then that takes at least 32 bytes.
> If this was not explicitly tagged, then a 32 byte commitment to all the
> necessary data would have been enough, but you do need the explicit tagging
> for the "change outputs must be rate-limited too".
>
> Note as well that the residual needs to be kept with the output.
> Bitcoin Core does not store transactions in a lookup table, it stores
> individual *outputs*.
> While the residual can be derived from the transaction, we do not have a
> transaction table.
> Thus, we need to explicitly put it on the output itself, directly, since
> we only have a lookup table for the unspent outputs, not individual
> transactions.
>
> (well there is `txindex` but that is an option for each node, not
> something consensus code can rely on)
>
> So yes, that "change outputs must also be rate-limited" is the big
> sticking point, and a lot of the "gaps" you worry about occur when we drop
> this bit.
> Drop this bit and you can implement it today without any consensus code
> change, and with privacy good enough to prevent people with random letters
> as pseudonym from trying to stop you.
>
> Regards,
> ZmnSCPxj
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/d45764e3/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Aug 31 14:22:29 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 31 Aug 2021 14:22:29 +0000
Subject: [bitcoin-dev] Exploring: limiting transaction output amount as
	a function of total input value
In-Reply-To: <CAJ4-pEC_NTScPFg822Va+Sw1_yC87tWBAL4y7y-m7PSx+JcccQ@mail.gmail.com>
References: <CAGpPWDZ0aos5qHw2=popCpjuH7OXC0geEj8i3dwDTfP0j=or4w@mail.gmail.com>
 <T9dyi_J_ZLwT8hXaxOBlCEhdoB9hsBcvFZX3r1JrtxunUTnFe7wefV6hi3Itw8z84drqAn64ZCJhfSfz7Aw0cqx4Aa8DtN1irvE-d4JPoeE=@protonmail.com>
 <CAJ4-pED7sAe+yNqxv_1HSaku=kuTQYTU3nm2o6vUVCEnhkxxFA@mail.gmail.com>
 <1qkQ1p1rAZApZhMKVFwQV6gfLyZxMYIUPrhcjtXNU4z0DBRwslPSbi76GnNnllpvPPfqt1bH3EyzJNhfK0Uxum7zJ_dh3H0DXqUpf2nmHyk=@protonmail.com>
 <CAJ4-pECSE=by2ag4QmqrXbX_R0sk6HOL1KH0z2h=+915jaEE6Q@mail.gmail.com>
 <wdlRrp4fZxH79mzVpTQWp99V9uI8jLvRU40mwdJ8lZ5A2mGMsxUK1TmZEZTV7O4_eUnNyq3feEGv5BUN-ecPSlbL-EYR6ZyLxk9ErsFiPlE=@protonmail.com>
 <CAJ4-pECwGfrrB15oS0t-+vsjn11sC=9Bz6JGsGsicUorCjuYpA@mail.gmail.com>
 <RrFU9zB125CEEua75KWb6IfANybTVN9AGfvjxE65Ysa1zOIgM-h48HmdBcfynW7HEd6kOaA5G-FhAVbmrq5DJXJJYHNArJDORGJklnBCU_I=@protonmail.com>
 <CAJ4-pEC_NTScPFg822Va+Sw1_yC87tWBAL4y7y-m7PSx+JcccQ@mail.gmail.com>
Message-ID: <A8O_5wbTwq48sO02LAHT_t0RN0GVY0yrygt2DiSPrCavXCYu_0LsZWKf3jEQUyBbboW7zQnXyVSHkNJV7CP-VliKOYXjmmnfQIF2Q6E4pl8=@protonmail.com>

Good morning Zac,

> Hi ZmnSCPxj,
>
> Thank you for your helpful response. We're on the same page concerning privacy so I'll focus on that. I understand from your mail that privacy would be reduced by this proposal because:
>
> * It requires the introduction of a new type of transaction that is different from a "standard" transaction (would that be P2TR in the future?), reducing the anonymity set for everyone;
> * The payment and change output will be identifiable because the change output must be marked encumbered on-chain;
> * The specifics of how the output is encumbered must be visible on-chain as well reducing privacy even further.
>
> I don't have the technical skills to judge whether these issues can somehow be resolved. In functional terms, the output should be spendable in a way that does not reveal that the output is encumbered, and produce a change output that cannot be distinguished from a non-change output while still being encumbered. Perhaps some clever MAST-fu could somehow help?

I believe some of the covenant efforts may indeed have such clever MAST-fu integrated into them, which is why I pointed you to them --- the people developing these (aj I think? RubenSomsen?) might be able to accommodate this or some subset of the desired feature in a sufficiently clever covenant scheme.

There are a number of such proposals, though, so I cannot really point you to one that seems likely to have a lot of traction.

Regards,
ZmnSCPxj

From peter at coinkite.com  Tue Aug 31 18:27:41 2021
From: peter at coinkite.com (Peter D. Gray)
Date: Tue, 31 Aug 2021 14:27:41 -0400
Subject: [bitcoin-dev] Proposal for a few IANA mime-types related to Bitcoin
In-Reply-To: <mailman.9346.1630015566.1160.bitcoin-dev@lists.linuxfoundation.org>
References: <mailman.9346.1630015566.1160.bitcoin-dev@lists.linuxfoundation.org>
Message-ID: <20210831182741.GV91472@coinkite.com>

Hi list!

I am proposing to register the following MIME (RFC 2046) media types with the IANA:


bitcoin/psbt

    - aka. a BIP-174 file, in binary
    - does not make any claims about signed/unsigned status; lets leave that to the file

bitcoin/txn

    - aka. wire-ready fully-signed transaction in binary

bitcoin/uri

    - aka [BIP-21](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)
    - could be just a bare bech32 or base58 payment address
    - but can also encode amount, comments in URL args
    - potentially interesting as a response to 402 - Payment required


Other thoughts

- some mime-types are proposed in BIP-71 but those are unrelated to above, and never
  seem to have been registered

- for those who like to encode their binary as base64 or hex, that can be indicated
  as "encoding=hex" or "encoding=base64" in the optional parameters, just like
  "text/plain; encoding=utf-8" does. However, the default must be binary.

- although the above are useful for web servers, they are also useful elsewhere and I
  intend to use them in NFC (NDEF records) where a shorter length is critical.

- I have no idea how easily IANA will accept these proposals.

- current approved mime types: https://www.iana.org/assignments/media-types/media-types.xhtml

Thoughts?

---
@DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/a4aa0e7d/attachment.sig>

From achow101-lists at achow101.com  Tue Aug 31 19:46:55 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Tue, 31 Aug 2021 19:46:55 +0000
Subject: [bitcoin-dev] Proposal for a few IANA mime-types related to
	Bitcoin
In-Reply-To: <20210831182741.GV91472@coinkite.com>
References: <mailman.9346.1630015566.1160.bitcoin-dev@lists.linuxfoundation.org>
 <20210831182741.GV91472@coinkite.com>
Message-ID: <775f2a59-7cd7-6234-23d2-1780e2c4da58@achow101.com>

Hi Peter,

It would be nice to have mime types registered for Bitcoin things, but
I'm not sure that it will be possible, at least not in the way that we
would like. I tried doing this with "application/bitcoin-psbt" back in
2019 but it was not accepted. From that attempt, here is what I have
learned:

There are only a few accepted top level types, so we would not be able
to use "bitcoin" as the top level (unless you want to submit an RFC to
add a "bitcoin" top level). Of the available top level types,
"application" is the most appropriate for Bitcoin.

Next is the tree that the mime type should be in. The best would be the
Standards tree, but it has some requirements that Bitcoin doesn't really
meet. In order to be in the standards tree, the registration must be
either associated with an IETF specification (so a RFC) or registered by
a recognized standards related organization. Unfortunately the closest
thing to a standards organization that Bitcoin has is the BIPs process,
and that is not a really a standards organization nor is it recognized
by IANA. So in order to register the mimetypes as Standards tree types,
we would need to write an RFC, but this could be an independent
submission (https://www.rfc-editor.org/about/independent/) rather than
IETF-stream submission. I did not continue to pursue this because I
didn't have the time.

Another alternative would be to use the Vendor tree, but that would
prefix the mimetype with "vnd." so it would end up being something like
"application/vnd.bitcoin.psbt". I did not think this was an reasonable
so I did not continue to pursue this avenue.


Andrew Chow

On 8/31/21 2:27 PM, Peter D. Gray via bitcoin-dev wrote:
> Hi list!
>
> I am proposing to register the following MIME (RFC 2046) media types with the IANA:
>
>
> bitcoin/psbt
>
>      - aka. a BIP-174 file, in binary
>      - does not make any claims about signed/unsigned status; lets leave that to the file
>
> bitcoin/txn
>
>      - aka. wire-ready fully-signed transaction in binary
>
> bitcoin/uri
>
>      - aka [BIP-21](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)
>      - could be just a bare bech32 or base58 payment address
>      - but can also encode amount, comments in URL args
>      - potentially interesting as a response to 402 - Payment required
>
>
> Other thoughts
>
> - some mime-types are proposed in BIP-71 but those are unrelated to above, and never
>    seem to have been registered
>
> - for those who like to encode their binary as base64 or hex, that can be indicated
>    as "encoding=hex" or "encoding=base64" in the optional parameters, just like
>    "text/plain; encoding=utf-8" does. However, the default must be binary.
>
> - although the above are useful for web servers, they are also useful elsewhere and I
>    intend to use them in NFC (NDEF records) where a shorter length is critical.
>
> - I have no idea how easily IANA will accept these proposals.
>
> - current approved mime types: https://www.iana.org/assignments/media-types/media-types.xhtml
>
> Thoughts?
>
> ---
> @DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ChristopherA at lifewithalacrity.com  Tue Aug 31 19:01:23 2021
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Tue, 31 Aug 2021 12:01:23 -0700
Subject: [bitcoin-dev] Proposal for a few IANA mime-types related to
	Bitcoin
In-Reply-To: <20210831182741.GV91472@coinkite.com>
References: <mailman.9346.1630015566.1160.bitcoin-dev@lists.linuxfoundation.org>
 <20210831182741.GV91472@coinkite.com>
Message-ID: <CACrqygDZGWxrv+3w=gmwVRO4iTLYJnn8QLBEwNQ_EdkXNr46Ww@mail.gmail.com>

Note that a number of wallet companies are now supporting the UR encoded
version of PSBTs, allowing for better QR & Airgap solutions, and also
leverage CBOR which is an IETF standard.

We have a community of Airgap wallet developers at
https://github.com/BlockchainCommons/Airgapped-Wallet-Community

?and libraries at
https://github.com/BlockchainCommons/crypto-commons#urs

We?d love for you to register UR as well, maybe as bitcoin/psbt+ur

Can you bring this up in our community for further discussion?
https://github.com/BlockchainCommons/Airgapped-Wallet-Community/discussions

Thanks!

? Christopher Allen [via iPhone]

On Tue, Aug 31, 2021 at 11:41 AM Peter D. Gray via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi list!
>
> I am proposing to register the following MIME (RFC 2046) media types with
> the IANA:
>
>
> bitcoin/psbt
>
>     - aka. a BIP-174 file, in binary
>     - does not make any claims about signed/unsigned status; lets leave
> that to the file
>
> bitcoin/txn
>
>     - aka. wire-ready fully-signed transaction in binary
>
> bitcoin/uri
>
>     - aka [BIP-21](
> https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)
>     - could be just a bare bech32 or base58 payment address
>     - but can also encode amount, comments in URL args
>     - potentially interesting as a response to 402 - Payment required
>
>
> Other thoughts
>
> - some mime-types are proposed in BIP-71 but those are unrelated to above,
> and never
>   seem to have been registered
>
> - for those who like to encode their binary as base64 or hex, that can be
> indicated
>   as "encoding=hex" or "encoding=base64" in the optional parameters, just
> like
>   "text/plain; encoding=utf-8" does. However, the default must be binary.
>
> - although the above are useful for web servers, they are also useful
> elsewhere and I
>   intend to use them in NFC (NDEF records) where a shorter length is
> critical.
>
> - I have no idea how easily IANA will accept these proposals.
>
> - current approved mime types:
> https://www.iana.org/assignments/media-types/media-types.xhtml
>
> Thoughts?
>
> ---
> @DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/5b3915b1/attachment.html>

From peter at coinkite.com  Tue Aug 31 19:18:00 2021
From: peter at coinkite.com (Peter D. Gray)
Date: Tue, 31 Aug 2021 15:18:00 -0400
Subject: [bitcoin-dev] Proposal for a few IANA mime-types related to
 Bitcoin
In-Reply-To: <CACrqygDZGWxrv+3w=gmwVRO4iTLYJnn8QLBEwNQ_EdkXNr46Ww@mail.gmail.com>
References: <mailman.9346.1630015566.1160.bitcoin-dev@lists.linuxfoundation.org>
 <20210831182741.GV91472@coinkite.com>
 <CACrqygDZGWxrv+3w=gmwVRO4iTLYJnn8QLBEwNQ_EdkXNr46Ww@mail.gmail.com>
Message-ID: <20210831191800.GW91472@coinkite.com>

QR Codes do not use IANA mime-types.

If anyone wanted to use UR encoding for PSBT data in a web context (http),
NFC, or email, it would probably be best to discourage them.

While I can understand the need for UR encoding in animated QR
codes, I don't think any other use-case could justify introducing
a new word list (ByteWords), a unique checksum algo (Xoshiro256),
fountain codes (Luby Transform) and CBOR... just to wrap a few k
of binary.

I do love CBOR though. It's the best.

---
@DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10

On Tue, Aug 31, 2021 at 12:01:23PM -0700, Christopher Allen wrote:
> Note that a number of wallet companies are now supporting the UR encoded
> version of PSBTs, allowing for better QR & Airgap solutions, and also
> leverage CBOR which is an IETF standard.
> 
> We have a community of Airgap wallet developers at
> https://github.com/BlockchainCommons/Airgapped-Wallet-Community
> 
> ?and libraries at
> https://github.com/BlockchainCommons/crypto-commons#urs
> 
> We?d love for you to register UR as well, maybe as bitcoin/psbt+ur
> 
> Can you bring this up in our community for further discussion?
> https://github.com/BlockchainCommons/Airgapped-Wallet-Community/discussions
> 
> Thanks!
> 
> ? Christopher Allen [via iPhone]
> 
> On Tue, Aug 31, 2021 at 11:41 AM Peter D. Gray via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > Hi list!
> >
> > I am proposing to register the following MIME (RFC 2046) media types with
> > the IANA:
> >
> >
> > bitcoin/psbt
> >
> >     - aka. a BIP-174 file, in binary
> >     - does not make any claims about signed/unsigned status; lets leave
> > that to the file
> >
> > bitcoin/txn
> >
> >     - aka. wire-ready fully-signed transaction in binary
> >
> > bitcoin/uri
> >
> >     - aka [BIP-21](
> > https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki)
> >     - could be just a bare bech32 or base58 payment address
> >     - but can also encode amount, comments in URL args
> >     - potentially interesting as a response to 402 - Payment required
> >
> >
> > Other thoughts
> >
> > - some mime-types are proposed in BIP-71 but those are unrelated to above,
> > and never
> >   seem to have been registered
> >
> > - for those who like to encode their binary as base64 or hex, that can be
> > indicated
> >   as "encoding=hex" or "encoding=base64" in the optional parameters, just
> > like
> >   "text/plain; encoding=utf-8" does. However, the default must be binary.
> >
> > - although the above are useful for web servers, they are also useful
> > elsewhere and I
> >   intend to use them in NFC (NDEF records) where a shorter length is
> > critical.
> >
> > - I have no idea how easily IANA will accept these proposals.
> >
> > - current approved mime types:
> > https://www.iana.org/assignments/media-types/media-types.xhtml
> >
> > Thoughts?
> >
> > ---
> > @DocHEX  ||  Coinkite  ||  PGP: A3A31BAD 5A2A5B10
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >

From ChristopherA at lifewithalacrity.com  Tue Aug 31 20:02:44 2021
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Tue, 31 Aug 2021 13:02:44 -0700
Subject: [bitcoin-dev] Proposal for a few IANA mime-types related to
	Bitcoin
In-Reply-To: <20210831191800.GW91472@coinkite.com>
References: <mailman.9346.1630015566.1160.bitcoin-dev@lists.linuxfoundation.org>
 <20210831182741.GV91472@coinkite.com>
 <CACrqygDZGWxrv+3w=gmwVRO4iTLYJnn8QLBEwNQ_EdkXNr46Ww@mail.gmail.com>
 <20210831191800.GW91472@coinkite.com>
Message-ID: <CACrqygABxGBDHf4n68UxbHLg3Ai60c6Z9gcF=-XFc2FyoBSqeg@mail.gmail.com>

On Tue, Aug 31, 2021 at 12:18 PM Peter D. Gray <peter at coinkite.com> wrote:

> QR Codes do not use IANA mime-types.
>
> If anyone wanted to use UR encoding for PSBT data in a web context (http),
> NFC, or email, it would probably be best to discourage them.
>
> While I can understand the need for UR encoding in animated QR
> codes, I don't think any other use-case could justify introducing
> a new word list (ByteWords), a unique checksum algo (Xoshiro256),
> fountain codes (Luby Transform) and CBOR... just to wrap a few k
> of binary.
>
> I do love CBOR though. It's the best.


UR is more than just a QR, it is URL conformant text that is optimized for
compression in QRs.

In particular, take a look at the explanation of the UR format at the 20m0s
mark in this video:
https://youtu.be/RYgOFSdUqWY

The rest of the video explains why we made the choices we did. We wanted to
leverage existing standards, but there were too many compromises expecially
give QR requirements. See the section on ?Why Another Standard? in our
overview at
https://github.com/BlockchainCommons/crypto-commons/blob/master/Docs/ur-1-overview.md#why-another-standard

Note that the UR specification just is not just being adopted by wallet
vendors, but also a number of online services / transaction coordinators
that only have access watch-only keys. These services can then do a
crypto-request for the airgapped wallet to sign the PSBT.

? Christopher Allen

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210831/555ef40b/attachment.html>

