From rsomsen at gmail.com  Fri Jan  1 00:05:59 2021
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 1 Jan 2021 01:05:59 +0100
Subject: [bitcoin-dev] Softchains: Sidechains as a Soft Fork via
 Proof-of-Work Fraud Proofs
In-Reply-To: <CAKzdR-rWe6ecFV6AjxEzBKnH=+PYdfkuuo0-Su8-SPj=SQrS9A@mail.gmail.com>
References: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
 <CAKzdR-rWe6ecFV6AjxEzBKnH=+PYdfkuuo0-Su8-SPj=SQrS9A@mail.gmail.com>
Message-ID: <CAPv7Tja9K6XO-8G+fcaK4amW0eNQH8=0EiVWrry+EdWH3U8epw@mail.gmail.com>

Hi Sergio,

Thanks for taking an interest.

>I don't understand how your proposal prevents miners proposing a peg-out
for an invalid sidechain fork which is not made available to the nodes
(there are missing blocks)

Good question. Data availability is a common problem for sidechain designs,
but PoW FP are actually a unique solution to this problem. In order for a
block with missing data to be accepted for a peg-out, it has to a.) remain
in the chain with the most PoW for a whole year, and b.) no fork that
questions the validity/availability of that block must exist. If a fork
does exist, this triggers all nodes to attempt to download the block with
the missing data. Since they will fail, the chain will be considered
invalid. I recommend reading the original posts about PoW FP ([1] and [2]
in my original post) for more elaboration.

>it is very limited in the types of sidechains it can verify

I agree that something like drivechains is much more flexible, but it comes
with a security tradeoff that many find uncomfortable.

>based on both a large multisig AND a drivechain, where both groups need to
agree for the peg-out to occur.  It's a censorship/security trade-off that
most users would be willing to accept

I think federations are an absolutely fine tradeoff, but of course the
softchain design is one that deliberately tries to avoid them for reasons
that I assume are obvious.

>until a trusted-setup-free SNARK-like based solution is finally available

>From my research into SNARKs I concluded that they still won't get you away
from having the sidechain function like an extension block, so the fruit
doesn't seem to be hanging that low from my perspective. This is because
SNARKs actually do suffer from the data availability problem you were
asking about. You can definitely save a lot by aggregating witness data
with SNARKs, but non-witness data cannot be aggregated and must be
downloaded by everyone, so you're still going to be restricted by
bandwidth. I described the issue here in detail:
https://medium.com/@RubenSomsen/snarks-and-the-future-of-blockchains-55b82012452b

Cheers,
Ruben




On Fri, Jan 1, 2021 at 12:38 AM Sergio Demian Lerner <
sergio.d.lerner at gmail.com> wrote:

> Hi Roben,
>  It's an interesting proposal, but I have two issues with it, one
> technical and one philosophical.
>
> On the technical side, I don't understand how your proposal prevents
> miners proposing a peg-out for an invalid sidechain fork which is not made
> available to the nodes (there are missing blocks). It seems that the system
> would need to allow users to challenge miners to make available full
> sidechain blocks that are missing, which really complicates the protocol.
>
> On the philosophical side, as you mentioned, it is very limited in the
> types of sidechains it can verify. I won't be able to verify RSK
> (merge-mined with Bitcoin, but with different block format and different
> functionality). It cannot verify a zCash-like sidechain for the same
> reasons. Therefore it is strictly a payment scalability solution.
> Drivechains, on the other hand, enable many new use cases apart from
> scaling, which have a much lower level of complexity (if implemented
> correctly).
>
> Since the inception of RSK sidechain, I suggested in its white-paper that
> sidechains should be designed to support an hybrid peg-out system, based on
> both a large multisig AND a drivechain, where both groups need to agree for
> the peg-out to occur.  It's a censorship/security trade-off that most users
> would be willing to accept until a trusted-setup-free SNARK-like based
> solution is finally available.
> Until we have a sidechain-selectable SNARK-like succinct verification of
> any block state transition function, having a single succint proof to cover
> the whole sidechain validity, as in Coda (now renamed Mina), drivechains
> are the low-hanging-fruit.
>
> regards
>
> On Thu, Dec 31, 2020 at 7:01 PM Ruben Somsen via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi everyone,
>>
>> This post describes a fully decentralized two-way peg sidechain design.
>> Activating new sidechains requires a soft fork, hence the name softchains.
>> The key aspect is that all softchains are validated by everyone via
>> Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus
>> mechanism that only requires the validation of disputed blocks. This does
>> increase the validation burden of mainchain full nodes, but only by a
>> minimal amount (~100MB per chain per year). It's similar to drivechains[0],
>> but without the major downside of having to rely on miners, since all
>> Bitcoin full node users can efficiently validate each sidechain.
>>
>>
>> Proof-of-Work Fraud Proofs
>>
>> Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].
>> The idea is that we can use the existence of a fork in Bitcoin's PoW as
>> evidence that a block might be invalid (i.e. a proof of potential fraud).
>> Whenever this occurs, we download the block in question to verify whether
>> it was valid (and available), and reject it if it was not. We forego the
>> need for maintaining a UTXO set with UTXO set commitments (such as
>> utreexo[3]), by assuming that the commitment inside the last block to exist
>> in both forks is valid. As a result, we only need to download as many
>> blocks (and their corresponding UTXO set proofs) as there are orphans,
>> which lowers the validation costs considerably compared to running a full
>> node.
>>
>> In the past 4 months, Forkmonitor has registered 11 stale and invalid
>> blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin
>> consensus would have to download and verify a little over 100MB per year in
>> order to have consensus guarantees that come close to that of a full node:
>> - All PoW headers (~4MB per year)
>> - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)
>> - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)
>>
>> The reason consensus is considered slow, is because we need to allow time
>> for a honest PoW minority to fork away from an invalid chain. If we assume
>> only 1% of all miners are honest, this means consensus slows down by 100x.
>> If you are normally satisfied waiting for 6 confirmations, you now need to
>> wait 600 confirmations. The longer you wait, the less honest miners you
>> need.
>>
>>
>> Softchains
>>
>> In order to have two-way pegged sidechains, you need a succinct method
>> for proving to the mainchain that a peg-out is valid. PoW FP provides
>> exactly that -- a low-bandwidth way of determining if a chain, and thus a
>> peg-out, is valid. The slowness of PoW FP consensus is not an issue, as
>> peg-outs can be made arbitrarily slow (e.g. one year).
>>
>> The safest design would be a set of softchains that shares its consensus
>> code with Bitcoin Core, with the addition of UTXO set commitments, and
>> disabling non-taproot address types to minimize certain resource usage
>> issues[5]. All users validate the mainchain as usual with their full node,
>> and all softchains are validated with PoW FP consensus. If a user is
>> interested in directly using a specific softchain, they should run it as a
>> full node in order to get fast consensus.
>>
>> Peg-ins occur by freezing coins on the mainchain and assigning them to a
>> softchain. Peg-outs occur by creating a mainchain transaction that points
>> to a peg-out transaction on a softchain and waiting for a sufficient number
>> of mainchain confirmations. If the peg-out transaction remains part of the
>> softchain according to PoW FP consensus, the coins become spendable.
>>
>> The peg-in/peg-out mechanism itself would require a soft fork (the exact
>> design is an open question), and subsequently every softchain that gets
>> activated will also require a soft fork.
>>
>>
>> Potential dangers
>>
>> Softchain consensus still requires a form of validation from mainchain
>> users, which means that consensus bugs can have an adverse effect. In
>> particular, if a softchain suffers from a non-deterministic consensus bug,
>> it may be the case that a majority accepts a peg-in, while a minority
>> rejects it. This specific scenario could cause a chain split in mainchain
>> consensus. This is why it would be safest to base softchain designs on
>> Bitcoin Core.
>>
>> Similarly, it can theoretically be possible that a softchain gets a major
>> reorg, invalidating a peg-out right as it would have become accepted on the
>> mainchain, thus splitting consensus. The slow peg-out process makes this
>> increasingly unlikely, but not impossible. One thing that might help (or
>> perhaps only make it worse) is introducing a consensus rule that disallows
>> reorgs that are bigger than half the peg-out time (e.g. half a year, if the
>> peg-out is one year). This kind of rule does not actually solve this
>> consensus problem, but instead pushes the problem forward so it plays out
>> first on the softchain, giving time to take action before the problem
>> affects the mainchain.
>>
>> It is also important that each softchain produces a non-trivial amount of
>> PoW, because if the difficulty is too low, the cost of creating forks and
>> increasing the resource usage of PoW FP consensus goes down. It may
>> therefore make sense to have a minimum accepted difficulty for softchain
>> blocks (slowing down the chain when fees are not sufficient). Merged Mining
>> could also help here, since that would allow the softchains to potentially
>> receive the same hashrate as Bitcoin (assuming all miners participate), but
>> of course this would also put an additional validation burden on miners.
>>
>>
>> In closing
>>
>> It may turn out that the consensus risks outlined above make this
>> prohibitively risky, but at the very least it seems worth exploring the
>> possibilities. At a minimum it would provide more opt-in block space, and
>> it could potentially open the door to chains with entirely different
>> consensus rules.
>>
>> Thank you for taking the time to read and comprehend my work. I will
>> happily answer any questions and I look forward to any feedback on issues
>> that I might have overlooked, and ideas on mitigating problems to ensure
>> maximum safety.
>>
>> Hopefully this will bring decentralized two-way peg sidechains one step
>> closer to becoming a reality.
>>
>> Happy new year, everyone.
>>
>>
>> -- Ruben Somsen
>>
>>
>>
>> This post is mirrored and kept up-to-date here:
>> https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1
>>
>>
>> [0] Drivechains
>> https://www.drivechain.info/
>>
>> [1] PoW FP
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html
>>
>> [2] PoW FP without a soft fork
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html
>>
>> [3]: utreexo
>> https://eprint.iacr.org/2019/611.pdf
>>
>> [4]: Forkmonitor
>> https://forkmonitor.info/notifications
>>
>> [5]: Harding on worst-case utreexo
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210101/57365dee/attachment-0001.html>

From rsomsen at gmail.com  Fri Jan  1 00:05:59 2021
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 1 Jan 2021 01:05:59 +0100
Subject: [bitcoin-dev] Softchains: Sidechains as a Soft Fork via
 Proof-of-Work Fraud Proofs
In-Reply-To: <CAKzdR-rWe6ecFV6AjxEzBKnH=+PYdfkuuo0-Su8-SPj=SQrS9A@mail.gmail.com>
References: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
 <CAKzdR-rWe6ecFV6AjxEzBKnH=+PYdfkuuo0-Su8-SPj=SQrS9A@mail.gmail.com>
Message-ID: <CAPv7Tja9K6XO-8G+fcaK4amW0eNQH8=0EiVWrry+EdWH3U8epw@mail.gmail.com>

Hi Sergio,

Thanks for taking an interest.

>I don't understand how your proposal prevents miners proposing a peg-out
for an invalid sidechain fork which is not made available to the nodes
(there are missing blocks)

Good question. Data availability is a common problem for sidechain designs,
but PoW FP are actually a unique solution to this problem. In order for a
block with missing data to be accepted for a peg-out, it has to a.) remain
in the chain with the most PoW for a whole year, and b.) no fork that
questions the validity/availability of that block must exist. If a fork
does exist, this triggers all nodes to attempt to download the block with
the missing data. Since they will fail, the chain will be considered
invalid. I recommend reading the original posts about PoW FP ([1] and [2]
in my original post) for more elaboration.

>it is very limited in the types of sidechains it can verify

I agree that something like drivechains is much more flexible, but it comes
with a security tradeoff that many find uncomfortable.

>based on both a large multisig AND a drivechain, where both groups need to
agree for the peg-out to occur.  It's a censorship/security trade-off that
most users would be willing to accept

I think federations are an absolutely fine tradeoff, but of course the
softchain design is one that deliberately tries to avoid them for reasons
that I assume are obvious.

>until a trusted-setup-free SNARK-like based solution is finally available

>From my research into SNARKs I concluded that they still won't get you away
from having the sidechain function like an extension block, so the fruit
doesn't seem to be hanging that low from my perspective. This is because
SNARKs actually do suffer from the data availability problem you were
asking about. You can definitely save a lot by aggregating witness data
with SNARKs, but non-witness data cannot be aggregated and must be
downloaded by everyone, so you're still going to be restricted by
bandwidth. I described the issue here in detail:
https://medium.com/@RubenSomsen/snarks-and-the-future-of-blockchains-55b82012452b

Cheers,
Ruben




On Fri, Jan 1, 2021 at 12:38 AM Sergio Demian Lerner <
sergio.d.lerner at gmail.com> wrote:

> Hi Roben,
>  It's an interesting proposal, but I have two issues with it, one
> technical and one philosophical.
>
> On the technical side, I don't understand how your proposal prevents
> miners proposing a peg-out for an invalid sidechain fork which is not made
> available to the nodes (there are missing blocks). It seems that the system
> would need to allow users to challenge miners to make available full
> sidechain blocks that are missing, which really complicates the protocol.
>
> On the philosophical side, as you mentioned, it is very limited in the
> types of sidechains it can verify. I won't be able to verify RSK
> (merge-mined with Bitcoin, but with different block format and different
> functionality). It cannot verify a zCash-like sidechain for the same
> reasons. Therefore it is strictly a payment scalability solution.
> Drivechains, on the other hand, enable many new use cases apart from
> scaling, which have a much lower level of complexity (if implemented
> correctly).
>
> Since the inception of RSK sidechain, I suggested in its white-paper that
> sidechains should be designed to support an hybrid peg-out system, based on
> both a large multisig AND a drivechain, where both groups need to agree for
> the peg-out to occur.  It's a censorship/security trade-off that most users
> would be willing to accept until a trusted-setup-free SNARK-like based
> solution is finally available.
> Until we have a sidechain-selectable SNARK-like succinct verification of
> any block state transition function, having a single succint proof to cover
> the whole sidechain validity, as in Coda (now renamed Mina), drivechains
> are the low-hanging-fruit.
>
> regards
>
> On Thu, Dec 31, 2020 at 7:01 PM Ruben Somsen via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hi everyone,
>>
>> This post describes a fully decentralized two-way peg sidechain design.
>> Activating new sidechains requires a soft fork, hence the name softchains.
>> The key aspect is that all softchains are validated by everyone via
>> Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus
>> mechanism that only requires the validation of disputed blocks. This does
>> increase the validation burden of mainchain full nodes, but only by a
>> minimal amount (~100MB per chain per year). It's similar to drivechains[0],
>> but without the major downside of having to rely on miners, since all
>> Bitcoin full node users can efficiently validate each sidechain.
>>
>>
>> Proof-of-Work Fraud Proofs
>>
>> Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].
>> The idea is that we can use the existence of a fork in Bitcoin's PoW as
>> evidence that a block might be invalid (i.e. a proof of potential fraud).
>> Whenever this occurs, we download the block in question to verify whether
>> it was valid (and available), and reject it if it was not. We forego the
>> need for maintaining a UTXO set with UTXO set commitments (such as
>> utreexo[3]), by assuming that the commitment inside the last block to exist
>> in both forks is valid. As a result, we only need to download as many
>> blocks (and their corresponding UTXO set proofs) as there are orphans,
>> which lowers the validation costs considerably compared to running a full
>> node.
>>
>> In the past 4 months, Forkmonitor has registered 11 stale and invalid
>> blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin
>> consensus would have to download and verify a little over 100MB per year in
>> order to have consensus guarantees that come close to that of a full node:
>> - All PoW headers (~4MB per year)
>> - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)
>> - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)
>>
>> The reason consensus is considered slow, is because we need to allow time
>> for a honest PoW minority to fork away from an invalid chain. If we assume
>> only 1% of all miners are honest, this means consensus slows down by 100x.
>> If you are normally satisfied waiting for 6 confirmations, you now need to
>> wait 600 confirmations. The longer you wait, the less honest miners you
>> need.
>>
>>
>> Softchains
>>
>> In order to have two-way pegged sidechains, you need a succinct method
>> for proving to the mainchain that a peg-out is valid. PoW FP provides
>> exactly that -- a low-bandwidth way of determining if a chain, and thus a
>> peg-out, is valid. The slowness of PoW FP consensus is not an issue, as
>> peg-outs can be made arbitrarily slow (e.g. one year).
>>
>> The safest design would be a set of softchains that shares its consensus
>> code with Bitcoin Core, with the addition of UTXO set commitments, and
>> disabling non-taproot address types to minimize certain resource usage
>> issues[5]. All users validate the mainchain as usual with their full node,
>> and all softchains are validated with PoW FP consensus. If a user is
>> interested in directly using a specific softchain, they should run it as a
>> full node in order to get fast consensus.
>>
>> Peg-ins occur by freezing coins on the mainchain and assigning them to a
>> softchain. Peg-outs occur by creating a mainchain transaction that points
>> to a peg-out transaction on a softchain and waiting for a sufficient number
>> of mainchain confirmations. If the peg-out transaction remains part of the
>> softchain according to PoW FP consensus, the coins become spendable.
>>
>> The peg-in/peg-out mechanism itself would require a soft fork (the exact
>> design is an open question), and subsequently every softchain that gets
>> activated will also require a soft fork.
>>
>>
>> Potential dangers
>>
>> Softchain consensus still requires a form of validation from mainchain
>> users, which means that consensus bugs can have an adverse effect. In
>> particular, if a softchain suffers from a non-deterministic consensus bug,
>> it may be the case that a majority accepts a peg-in, while a minority
>> rejects it. This specific scenario could cause a chain split in mainchain
>> consensus. This is why it would be safest to base softchain designs on
>> Bitcoin Core.
>>
>> Similarly, it can theoretically be possible that a softchain gets a major
>> reorg, invalidating a peg-out right as it would have become accepted on the
>> mainchain, thus splitting consensus. The slow peg-out process makes this
>> increasingly unlikely, but not impossible. One thing that might help (or
>> perhaps only make it worse) is introducing a consensus rule that disallows
>> reorgs that are bigger than half the peg-out time (e.g. half a year, if the
>> peg-out is one year). This kind of rule does not actually solve this
>> consensus problem, but instead pushes the problem forward so it plays out
>> first on the softchain, giving time to take action before the problem
>> affects the mainchain.
>>
>> It is also important that each softchain produces a non-trivial amount of
>> PoW, because if the difficulty is too low, the cost of creating forks and
>> increasing the resource usage of PoW FP consensus goes down. It may
>> therefore make sense to have a minimum accepted difficulty for softchain
>> blocks (slowing down the chain when fees are not sufficient). Merged Mining
>> could also help here, since that would allow the softchains to potentially
>> receive the same hashrate as Bitcoin (assuming all miners participate), but
>> of course this would also put an additional validation burden on miners.
>>
>>
>> In closing
>>
>> It may turn out that the consensus risks outlined above make this
>> prohibitively risky, but at the very least it seems worth exploring the
>> possibilities. At a minimum it would provide more opt-in block space, and
>> it could potentially open the door to chains with entirely different
>> consensus rules.
>>
>> Thank you for taking the time to read and comprehend my work. I will
>> happily answer any questions and I look forward to any feedback on issues
>> that I might have overlooked, and ideas on mitigating problems to ensure
>> maximum safety.
>>
>> Hopefully this will bring decentralized two-way peg sidechains one step
>> closer to becoming a reality.
>>
>> Happy new year, everyone.
>>
>>
>> -- Ruben Somsen
>>
>>
>>
>> This post is mirrored and kept up-to-date here:
>> https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1
>>
>>
>> [0] Drivechains
>> https://www.drivechain.info/
>>
>> [1] PoW FP
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html
>>
>> [2] PoW FP without a soft fork
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html
>>
>> [3]: utreexo
>> https://eprint.iacr.org/2019/611.pdf
>>
>> [4]: Forkmonitor
>> https://forkmonitor.info/notifications
>>
>> [5]: Harding on worst-case utreexo
>>
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210101/57365dee/attachment-0002.html>

From jlrubin at mit.edu  Sat Jan  2 06:34:00 2021
From: jlrubin at mit.edu (Jeremy)
Date: Fri, 1 Jan 2021 22:34:00 -0800
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <a0b996d1-049c-1c7a-e8c1-a6bc3834b0bd@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <1768da5c6f0.f63a34dc413157.2741477427673569054@alhur.es>
 <a0b996d1-049c-1c7a-e8c1-a6bc3834b0bd@achow101.com>
Message-ID: <CAD5xwhhz=cdS78KaigLycOWznv6RHWHAmn+STrpxhyT6SZzJ9Q@mail.gmail.com>

One thing I think should be added in V2 is the ability to specify sighash
flags per-key as opposed to per-input.

The per-key restriction is unfitting given that there are circumstances
where multisig signers may validate heterogenous logic.
--
@JeremyRubin <https://twitter.com/JeremyRubin>
<https://twitter.com/JeremyRubin>


On Wed, Dec 23, 2020 at 1:37 PM Andrew Chow via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> On 12/22/20 10:30 PM, fiatjaf wrote:
> > Hi Andrew.
> >
> > I'm just a lurker here and I have not much experience with PSBTs, but
> still let me pose this very obvious question and concern: isn't this change
> going to create a compatibility nightmare, with some software supporting
> version 1, others supporting version 2, and the ones that care enough about
> UX and are still maintained being forced to support both versions -- and
> for no very important reason except some improvements in the way data is
> structured?
> No, it is not just "improvements in the way data is structured."
>
> The primary reason for these changes is to allow PSBT to properly
> support adding inputs and outputs. This is a feature that many people
> have requested, and the ways that people have been doing it are honestly
> just hacks and not really the right way to be doing that. These changes
> allow for that feature to be supported well.
>
> Furthermore, it is possible to downgrade and upgrade PSBTs between the
> two versions, once all inputs and outputs have been decided. Since
> PSBTv2 is essentially just taking all of the normal transaction fields
> and grouping them all with the rest of the data for those inputs and
> outputs, it is easy to reconstruct a global unsigned transaction and
> turn a PSBTv2 into a PSBTv0. It is likewise just as easy to go the other
> way and break apart the global unsigned tx to turn a PSBTv0 into a
> PSBTv2. Originally, I had considered requiring that once a transaction
> was fully constructed it must be downgraded to a PSBTv0, but the
> structure changes that were made do make it easier to work with PSBT so
> I decided not to add this requirement.
>
> Perhaps to maintain compatibility PSBT_GLOBAL_UNSIGNED_TX shouldn't be
> disallowed in PSBTv2 once the transaction is constructed? It would make
> things much more confusing though as it would no longer be a clean break.
>
>
> Andrew Chow
>
> > Ultimately I don't think it should matter if some data is structured in
> not-the-best-possible way, as long as it is clear enough for the computer
> and for the libraries already written to deal with it.
> Backwards-compatibility and general interoperability is worth much more
> than anything else in these cases.
> >
> > Also let me leave this article here, which I find very important (even
> if for some reason it ends up not being relevant to this specific case):
> http://scripting.com/2017/05/09/rulesForStandardsmakers.html
> >
> >   ---- On Tue, 22 Dec 2020 17:12:22 -0300 Andrew Chow via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote ----
> >   > Hi All,
> >   >
> >   > I have some updates on this after speaking with some people off-list.
> >   >
> >   > Firstly, the version number will be set to 2. In most discussions,
> this
> >   > proposal was being referred to as PSBT version 2, so it'll be easier
> and
> >   > clearer to set the version number to 2.
> >   >
> >   > For lock times, instead of a single  PSBT_IN_REQUIRED_LOCKTIME field,
> >   > there will be 2 of them, one for a time based lock time, and the
> other
> >   > for height based. These will be:
> >   > * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
> >   >    * Key: empty
> >   >    * Value: 32 bit unsigned little endian integer greater than or
> equal
> >   > to 500000000 representing the minimum Unix timestamp that this input
> >   > requires to be set as the transaction's lock time. Must be omitted in
> >   > PSBTv0, and may be omitted in PSBTv2
> >   > * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
> >   >    * Key: empty
> >   >    * Value: 32 bit unsigned little endian integer less than 500000000
> >   > representing the minimum block height that this input requires to be
> set
> >   > as the transaction's lock time. Must be omitted in PSBTv0, and may be
> >   > omitted in PSBTv2.
> >   >
> >   > Having two lock time fields is necessary due to the behavior where
> all
> >   > inputs must use the same type of lock time (height or time). Thus if
> an
> >   > input requires a particular type of lock time, it must set the
> requisite
> >   > field. Any new inputs being added must be able to accommodate all
> >   > existing inputs' lock time type. This means they either must not
> have a
> >   > lock time specified (i.e. no OP_CLTV involved), or have branches that
> >   > allow the acceptance of either type. If an input has a lock time type
> >   > that is incompatible with the rest of the transaction, it must not
> be added.
> >   >
> >   > PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback
> >   > option if no input lock time fields are present. If there are input
> lock
> >   > times, all lock time calculations must ignore it.
> >   >
> >   > Any role which does lock time calculation will first check if there
> are
> >   > input lock time fields. If there are not, it must then check for a
> >   > PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is
> the
> >   > transaction's lock time. If it does not, the lock time is 0. If there
> >   > are input lock time fields, it must choose the type which does not
> >   > invalidate any inputs. The lock time is then determined to be the
> >   > maximum value of all of the lock time fields for the chosen type.
> >   >
> >   >
> >   > Additionally, I would like to add a new global field:
> >   > * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
> >   >    * Key: empty
> >   >    * Value: A single byte as a boolean. 0 for False, 1 for True. All
> >   > other values ore prohibited. Must be omitted for PSBTv0, may be
> omitted
> >   > in PSBTv2.
> >   >
> >   > PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
> >   > outputs can be added to the PSBT. This flag may be set to True when
> >   > inputs and outputs are being updated, signed, and finalized. However
> >   > care must be taken when there are existing signatures. If this field
> is
> >   > omitted or set to False, no further inputs and outputs may be added
> to
> >   > the PSBT.
> >   >
> >   > Several rules must be followed to ensure that adding additional
> inputs
> >   > and outputs will not invalidate existing signatures. First, an input
> or
> >   > output adder must check for any existing signatures in all of the
> other
> >   > inputs. If there are none, the input or output may be added in any
> >   > position. If there are one or more signatures, each signature's
> sighash
> >   > type must be examined. Inputs may only be added if all existing
> >   > signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all
> >   > existing signatures use SIGHASH_NONE. If an input has a signature
> using
> >   > SIGHASH_SINGLE, the same number of inputs and outputs must be added
> >   > before that input and it's corresponding output. For all other
> sighash
> >   > types (i.e. SIGHASH_ALL and any future sighash types), no inputs or
> >   > outputs may be added to the PSBT. Specific exceptions can be made in
> the
> >   > future for additional sighash types.
> >   >
> >   > Furthermore, these newly added inputs must follow additional lock
> time
> >   > rules. Because all signatures, regardless of sighash type, sign the
> >   > transaction lock time, newly added inputs when there are existing
> >   > signatures must have the same type of lock time used in the
> transaction,
> >   > and must be less than or equal to the transaction lock time. It must
> not
> >   > cause the transaction lock time to change, otherwise the signatures
> will
> >   > be invalidated.
> >   >
> >   >
> >   > Lastly, to uniquely identify transactions for combiners, a txid can
> be
> >   > computed from the information present in the PSBT. Internally,
> combiners
> >   > can create an unsigned transaction given the transaction version, the
> >   > input prevouts, the outputs, and the computed locktime. This can
> then be
> >   > used to calculate a txid and thus used as a way to identify PSBTs.
> >   > Combiners will need to do this for all version 2 PSBTs in order to
> avoid
> >   > combining distinct transactions.
> >   >
> >   >
> >   > Andrew Chow
> >   >
> >   > On 12/9/20 5:25 PM, Andrew Chow wrote:
> >   > > Hi All,
> >   > >
> >   > > I would like to propose a new PSBT version that addresses a few
> >   > > deficiencies in the current PSBT v0. As this will be backwards
> >   > > incompatible, a new PSBT version will be used, v1.
> >   > >
> >   > > The primary change is to truly have all input and output data for
> each
> >   > > in their respective maps. Instead of having to parse an unsigned
> >   > > transaction and lookup some data from there, and other data from
> the
> >   > > correct map, all of the data for an input will be contained in its
> map.
> >   > > Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new
> version.
> >   > > Thus I propose that the following fields be added:
> >   > >
> >   > > Global:
> >   > > * PSBT_GLOBAL_TX_VERSION = 0x02
> >   > >     * Key: empty
> >   > >     * Value: 32-bit little endian unsigned integer for the
> transaction
> >   > > version number. Must be provided in PSBT v1 and omitted in v0.
> >   > > * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
> >   > >     * Key: empty
> >   > >     * Value: 32 bit little endian unsigned integer for the
> preferred
> >   > > transaction lock time. Must be omitted in PSBT v0. May be provided
> in
> >   > > PSBT v1, assumed to be 0 if not provided.
> >   > > * PSBT_GLOBAL_INPUT_COUNT = 0x04
> >   > >     * Key: empty
> >   > >     * Value: Compact size unsigned integer. Number of inputs in
> this
> >   > > PSBT. Must be provided in PSBT v1 and omitted in v0.
> >   > > * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
> >   > >     * Key: empty
> >   > >     * Value: Compact size unsigned integer. Number of outputs in
> this
> >   > > PSBT. Must be provided in PSBT v1 and omitted in v0.
> >   > >
> >   > > Input:
> >   > > * PSBT_IN_PREVIOUS_TXID = 0x0e
> >   > >     * Key: empty
> >   > >     * Value: 32 byte txid of the previous transaction whose output
> at
> >   > > PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1
> and
> >   > > omitted in v0.
> >   > > * PSBT_IN_OUTPUT_INDEX = 0x0f
> >   > >     * Key: empty
> >   > >     * Value: 32 bit little endian integer for the index of the
> output
> >   > > being spent. Must be provided in PSBT v1 and omitted in v0.
> >   > > * PSBT_IN_SEQUENCE = 0x0f
> >   > >     * Key: empty
> >   > >     * Value: 32 bit unsigned little endian integer for the sequence
> >   > > number. Must be omitted in PSBT v0. May be provided in PSBT v1
> assumed
> >   > > to be max sequence (0xffffffff) if not provided.
> >   > > * PSBT_IN_REQUIRED_LOCKTIME = 0x10
> >   > >     * Key: empty
> >   > >     * Value: 32 bit unsigned little endian integer for the lock
> time that
> >   > > this input requires. Must be omitted in PSBT v0. May be provided
> in PSBT
> >   > > v1, assumed to be 0 if not provided.
> >   > >
> >   > > Output:
> >   > > * PSBT_OUT_VALUE = 0x03
> >   > >     * Key: empty
> >   > >     * Value: 64-bit unsigned little endian integer for the output's
> >   > > amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
> >   > > * PSBT_OUT_OUTPUT_SCRIPT = 0x04
> >   > >     * Key: empty
> >   > >     * Value: The script for this output. Otherwise known as the
> >   > > scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
> >   > >
> >   > > This change allows for PSBT to be used in the construction of
> >   > > transactions. With these new fields, inputs and outputs can be
> added as
> >   > > needed. One caveat is that there is no longer a unique transaction
> >   > > identifier so more care must be taken when combining PSBTs.
> >   > > Additionally, adding new inputs and outputs must be done such that
> >   > > signatures are not invalidated. This may be harder to specify.
> >   > >
> >   > > An important thing to note in this proposal are the fields
> >   > > PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A
> Bitcoin
> >   > > transaction only has a single locktime yet a PSBT may have multiple
> >   > > locktimes. To choose the locktime for the transaction, finalizers
> must
> >   > > choose the maximum of all of the *_LOCKTIME fields.
> >   > > PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as
> those
> >   > > involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum
> locktime to
> >   > > be set. This field allows finalizers to choose a locktime that is
> high
> >   > > enough for all inputs without needing to understand the scripts
> >   > > involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to
> use if
> >   > > no inputs require a particular locktime.
> >   > >
> >   > > As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT
> v1
> >   > > needs the version number bump to enforce backwards incompatibility.
> >   > > However once the inputs and outputs of a PSBT are decided, a PSBT
> could
> >   > > be "downgraded" back to v0 by creating the unsigned transaction
> from the
> >   > > above fields, and then dropping these new fields.
> >   > >
> >   > > If the list finds that these changes are reasonable, I will write
> a PR
> >   > > to modify BIP 174 to incorporate them.
> >   > >
> >   > > Thanks,
> >   > > Andrew Chow
> >   >
> >   >
> >   > _______________________________________________
> >   > bitcoin-dev mailing list
> >   > bitcoin-dev at lists.linuxfoundation.org
> >   > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >   >
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210101/98abd4fd/attachment-0001.html>

From bitcoin-dev at wuille.net  Tue Jan  5 00:14:12 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 05 Jan 2021 00:14:12 +0000
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
Message-ID: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>

Hello all,

here is a BIP draft for changing the checksum in native segwit addresses for v1 and higher, following the discussion in https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018293.html

Overall, the idea is:
* Define a new encoding which is a tweaked variant of Bech32, called Bech32m. It refers to the Bech32 section of BIP173, which remains in effect.
* Define a new segwit address encoding which replaces the corresponding section in BIP173. It prescribes using Bech32 for v0 witness addresses, and Bech32m for other versions.

Comments, suggestions, ideas?

Cheers,

--
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210105/a7a489de/attachment.html>

From bitcoin-dev at wuille.net  Tue Jan  5 01:25:29 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 05 Jan 2021 01:25:29 +0000
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
Message-ID: <yRPu_9VJPU75ohEyqSNqVVC5J33GCDcl7ZlXFc94xJmYral9o3xA3SuoWfq2p_gVaZagKraZ7Du569y3L3f4s6k7xF3-SDx7M2Sv3VnCO-4=@wuille.net>

On Monday, January 4, 2021 4:14 PM, Pieter Wuille <bitcoin-dev at wuille.net> wrote:

> Hello all,
>
> here is a BIP draft for changing the checksum in native segwit addresses for v1 and higher, following the discussion in https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018293.html
>
> Overall, the idea is:
> * Define a new encoding which is a tweaked variant of Bech32, called Bech32m. It refers to the Bech32 section of BIP173, which remains in effect.
> * Define a new segwit address encoding which replaces the corresponding section in BIP173. It prescribes using Bech32 for v0 witness addresses, and Bech32m for other versions.

Of course I forgot the actual link: https://github.com/sipa/bips/blob/bip-bech32m/bip-bech32m.mediawiki

Cheers,

--
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210105/bf63d22d/attachment.html>

From sdaftuar at gmail.com  Wed Jan  6 16:35:11 2021
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Wed, 6 Jan 2021 11:35:11 -0500
Subject: [bitcoin-dev] Proposal for new "disabletx" p2p message
Message-ID: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>

Hi,

I'm proposing the addition of a new, optional p2p message to allow peers to
communicate that they do not want to send or receive (loose) transactions
for the lifetime of a connection.

The goal of this message is to help facilitate connections on the network
over which only block-related data (blocks/headers/compact blocks/etc) are
relayed, to create low-resource connections that help protect against
partition attacks on the network.  In particular, by adding a network
message that communicates that transactions will not be relayed for the
life of the connection, we ease the implementation of software that could
have increased inbound connection limits for such peers, which in turn will
make it easier to add additional persistent block-relay-only connections on
the network -- strengthening network security for little additional
bandwidth.

Software has been deployed for over a year now which makes such
connections, using the BIP37/BIP60 "fRelay" field in the version message to
signal that transactions should not be sent initially.  However, BIP37
allows for transaction relay to be enabled later in the connection's
lifetime, complicating software that would try to distinguish inbound peers
that will never relay transactions from those that might.

This proposal would add a single new p2p message, "disabletx", which (if
used at all) must be sent between version and verack.  I propose that this
message is valid for peers advertising protocol version 70017 or higher.
Software is free to implement this BIP or ignore this message and remain
compatible with software that does implement it.

Full text of the proposed BIP is below.

Thanks,
Suhas

---------------------------------------------------

<pre>
  BIP: XXX
  Layer: Peer Services
  Title: Disable transaction relay message
  Author: Suhas Daftuar <sdaftuar at chaincode.com>
  Comments-Summary: No comments yet.
  Comments-URI:
  Status: Draft
  Type: Standards Track
  Created: 2020-09-03
  License: BSD-2-Clause
</pre>

==Abstract==

This BIP describes a change to the p2p protocol to allow a node to tell a peer
that a connection will not be used for transaction relay, to support
block-relay-only connections that are currently in use on the network.

==Motivation==

For nearly the past year, software has been deployed[1] which initiates
connections on the Bitcoin network and sets the transaction relay field
(introduced by BIP 37 and also defined in BIP 60) to false, to prevent
transaction relay from occurring on the connection. Additionally, addr messages
received from the peer are ignored by this software.

The purpose of these connections is two-fold: by making additional
low-bandwidth connections on which blocks can propagate, the robustness of a
node to network partitioning attacks is strengthened.  Additionally, by not
relaying transactions and ignoring received addresses, the ability of an
adversary to learn the complete network graph (or a subgraph) is reduced[2],
which in turn increases the cost or difficulty to an attacker seeking to carry
out a network partitioning attack (when compared with having such knowledge).

The low-bandwidth / minimal-resource nature of these connections is currently
known only by the initiator of the connection; this is because the transaction
relay field in the version message is not a permanent setting for the lifetime
of the connection.  Consequently, a node receiving an inbound connection with
transaction relay disabled cannot distinguish between a peer that will never
enable transaction relay (as described in BIP 37) and one that will.  Moreover,
the node also cannot determine that the incoming connection will ignore relayed
addresses; with that knowledge a node would likely choose other peers to
receive announced addresses instead.

This proposal adds a new, optional message that a node can send a peer when
initiating a connection to that peer, to indicate that connection should not be
used for transaction-relay for the connection's lifetime. In addition, without
a current mechanism to negotiate whether addresses should be relayed on a
connection, this BIP suggests that address messages not be sent on links where
tx-relay has been disabled.

==Specification==

# A new disabletx message is added, which is defined as an empty
message where pchCommand == "disabletx".
# The protocol version of nodes implementing this BIP must be set to
70017 or higher.
# If a node sets the transaction relay field in the version message to
a peer to false, then the disabletx message MAY also be sent in
response to a version message from that peer if the peer's protocol
version is >= 70017. If sent, the disabletx message MUST be sent prior
to sending a verack.
# A node that has sent or received a disabletx message to/from a peer
MUST NOT send any of these messages to the peer:
## inv messages for transactions
## getdata messages for transactions
## getdata messages for merkleblock (BIP 37)
## filteradd/filterload/filterclear (BIP 37)
## mempool (BIP 35)
# It is RECOMMENDED that a node that has sent or received a disabletx
message to/from a peer not send any of these messages to the peer:
## addr/getaddr
## addrv2 (BIP 155)
# The behavior regarding sending or processing other message types is
not specified by this BIP.
# Nodes MAY decide to not remain connected to peers that send this
message (for example, if trying to find a peer that will relay
transactions).

==Compatibility==

Nodes with protocol version >= 70017 that do not implement this BIP, and nodes
with protocol version < 70017, will continue to remain compatible with
implementing software: transactions would not be relayed to peers sending the
disabletx message (provided that BIP 37 or BIP 60 has been
implemented), and while
periodic address relay may still take place, software implementing this BIP
should not be disconnecting such peers solely for that reason.

Disabling address relay is suggested but not required by this BIP, to allow for
future protocol extensions that might specify more carefully how address relay
is to be negotiated. This BIP's recommendations for software to not relay
addresses is intended to be interpreted as guidance in the absence of any such
future protocol extension, to accommodate existing software behavior.

Note that all messages specified in BIP 152, including blocktxn and
getblocktxn, are permitted between peers that have sent/received a disabletx
message, subject to the feature negotiation of BIP 152.

==Implementation==

TBD

==References==

# Bitcoin Core has [https://github.com/bitcoin/bitcoin/pull/15759
implemented this functionality] since version 0.19.0.1, released in
November 2019.
# For example, see
https://www.cs.umd.edu/projects/coinscope/coinscope.pdf and
https://arxiv.org/pdf/1812.00942.pdf.

==Copyright==

This BIP is licensed under the 2-clause BSD license.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210106/a6651b31/attachment.html>

From rusty at rustcorp.com.au  Wed Jan  6 23:26:25 2021
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Thu, 07 Jan 2021 09:56:25 +1030
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
Message-ID: <87wnwpabq6.fsf@rustcorp.com.au>

Hi Andrew et al,

        Very excited to see this progress; thanks for doing all the
work!  Sorry for the delayed feedback, I didn't get to this before the
break.

> Additionally, I would like to add a new global field:
> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>  ? * Key: empty
>  ? * Value: A single byte as a boolean. 0 for False, 1 for True. All 
> other values ore prohibited. Must be omitted for PSBTv0, may be omitted 
> in PSBTv2.
>
> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and 
> outputs can be added to the PSBT. This flag may be set to True when 
> inputs and outputs are being updated, signed, and finalized. However 
> care must be taken when there are existing signatures. If this field is 
> omitted or set to False, no further inputs and outputs may be added to 
> the PSBT.

I wonder if this can be flagged simply by omitting the (AFAICT
redundant) PSBT_GLOBAL_INPUT_COUNT and PSBT_GLOBAL_OUTPUT_COUNT?  What
are the purposes of those fields?

For our uses, there would be no signatures at this stage; it's simply a
subdivision of the Creator role.  This role would be terminated by
removing the under-construction marker.  For this, it could be clear
that such an under-construction PSBT SHOULD NOT be signed.

Otherwise, if an explicit marker is required, I would omit the value and
simply use its existence to as a flag.  Having two "false" values is
simply asking for trouble.

Thanks!
Rusty.
PS.  Perhaps we should change the name to PBT (Partial Bitcoin
     Transaction) now, since it's more than just signing...

From achow101-lists at achow101.com  Wed Jan  6 23:48:31 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Wed, 06 Jan 2021 23:48:31 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <87wnwpabq6.fsf@rustcorp.com.au>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <87wnwpabq6.fsf@rustcorp.com.au>
Message-ID: <f20b7586-26b5-2250-322c-3004563f561e@achow101.com>

Hi Rusty,

On 1/6/21 6:26 PM, Rusty Russell wrote:
> Hi Andrew et al,
>
>          Very excited to see this progress; thanks for doing all the
> work!  Sorry for the delayed feedback, I didn't get to this before the
> break.
>
>> Additionally, I would like to add a new global field:
>> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>>   ? * Key: empty
>>   ? * Value: A single byte as a boolean. 0 for False, 1 for True. All
>> other values ore prohibited. Must be omitted for PSBTv0, may be omitted
>> in PSBTv2.
>>
>> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
>> outputs can be added to the PSBT. This flag may be set to True when
>> inputs and outputs are being updated, signed, and finalized. However
>> care must be taken when there are existing signatures. If this field is
>> omitted or set to False, no further inputs and outputs may be added to
>> the PSBT.
> I wonder if this can be flagged simply by omitting the (AFAICT
> redundant) PSBT_GLOBAL_INPUT_COUNT and PSBT_GLOBAL_OUTPUT_COUNT?  What
> are the purposes of those fields?
The purpose of those fields is to know how many input and output maps 
there are. Without PSBT_GLOBAL_UNSIGNED_TX, there is no way to determine 
whether a map is an input map or an output map. So the counts are there 
to allow that.
> For our uses, there would be no signatures at this stage; it's simply a
> subdivision of the Creator role.  This role would be terminated by
> removing the under-construction marker.  For this, it could be clear
> that such an under-construction PSBT SHOULD NOT be signed.
There are some protocols where signed inputs are added to transactions.
> Otherwise, if an explicit marker is required, I would omit the value and
> simply use its existence to as a flag.  Having two "false" values is
> simply asking for trouble.
Seems reasonable.


Andrew

> Thanks!
> Rusty.
> PS.  Perhaps we should change the name to PBT (Partial Bitcoin
>       Transaction) now, since it's more than just signing...



From rusty at rustcorp.com.au  Fri Jan  8 00:40:06 2021
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Fri, 08 Jan 2021 11:10:06 +1030
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <f20b7586-26b5-2250-322c-3004563f561e@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <87wnwpabq6.fsf@rustcorp.com.au>
 <f20b7586-26b5-2250-322c-3004563f561e@achow101.com>
Message-ID: <87a6tk9s7t.fsf@rustcorp.com.au>

Andrew Chow <achow101-lists at achow101.com> writes:
> Hi Rusty,
>
> On 1/6/21 6:26 PM, Rusty Russell wrote:
>> Hi Andrew et al,
>>
>>          Very excited to see this progress; thanks for doing all the
>> work!  Sorry for the delayed feedback, I didn't get to this before the
>> break.
>>
>>> Additionally, I would like to add a new global field:
>>> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>>>   ? * Key: empty
>>>   ? * Value: A single byte as a boolean. 0 for False, 1 for True. All
>>> other values ore prohibited. Must be omitted for PSBTv0, may be omitted
>>> in PSBTv2.
>>>
>>> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
>>> outputs can be added to the PSBT. This flag may be set to True when
>>> inputs and outputs are being updated, signed, and finalized. However
>>> care must be taken when there are existing signatures. If this field is
>>> omitted or set to False, no further inputs and outputs may be added to
>>> the PSBT.
>> I wonder if this can be flagged simply by omitting the (AFAICT
>> redundant) PSBT_GLOBAL_INPUT_COUNT and PSBT_GLOBAL_OUTPUT_COUNT?  What
>> are the purposes of those fields?
> The purpose of those fields is to know how many input and output maps 
> there are. Without PSBT_GLOBAL_UNSIGNED_TX, there is no way to determine 
> whether a map is an input map or an output map. So the counts are there 
> to allow that.

Ah, yeah, you need at least the number of input maps :(

It's generally preferable to have sections be self-describing;
internally if you have a function which takes all the input maps you
should be able to trivially tell if you're handed the output maps by
mistake.  Similarly, it would have been nice to have an input map be a
distinctly marked type from global or output maps.

Nonetheless, that's a bigger change.  You could just require a double-00
terminator between the global, input and output sections though.

>> For our uses, there would be no signatures at this stage; it's simply a
>> subdivision of the Creator role.  This role would be terminated by
>> removing the under-construction marker.  For this, it could be clear
>> that such an under-construction PSBT SHOULD NOT be signed.
>
> There are some protocols where signed inputs are added to transactions.

Sure, but you can't solve every problem.  We've now created the
possibility that a PSBT is "under construction" but can't be modified,
*and* a very invasive requirement to determine that.

I disagree with Andrew's goal here:

>   1. PSBT provides no way to modify the set of inputs or outputs after the
>      Creator role is done.

It's simpler if, "the under-construction PSBT can be used within the
Creator role, which can now have sub-roles".

If you really want to allow this (and I think we need to explore
concrete examples to justify this complexity!), better to add data to
PSBT_GLOBAL_UNDER_CONSTRUCTION:
1. a flag to indicate whether inputs are modifiable.
2. a flag to indicate whether outputs are modifiable.
3. a bitmap of what inputs are SIGHASH_SINGLE.

If you add a signature which is not SIGHASH_NONE, you clear the "outputs
modifiable" flag.  If you add a signature which is not
SIGHASH_ANYONECANPAY, you clear the "inputs modifiable" flag.  If you
clear both flags, you remove the PSBT_GLOBAL_UNDER_CONSTRUCTION
altogether.  You similarly set the bitmap depending on whether all sigs
are SIGHASH_SINGLE.

Cheers,
Rusty.

From rusty at rustcorp.com.au  Sat Jan  9 05:00:24 2021
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Sat, 09 Jan 2021 15:30:24 +1030
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <yRPu_9VJPU75ohEyqSNqVVC5J33GCDcl7ZlXFc94xJmYral9o3xA3SuoWfq2p_gVaZagKraZ7Du569y3L3f4s6k7xF3-SDx7M2Sv3VnCO-4=@wuille.net>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
 <yRPu_9VJPU75ohEyqSNqVVC5J33GCDcl7ZlXFc94xJmYral9o3xA3SuoWfq2p_gVaZagKraZ7Du569y3L3f4s6k7xF3-SDx7M2Sv3VnCO-4=@wuille.net>
Message-ID: <87lfd27lhz.fsf@rustcorp.com.au>

Perhaps title 'Bech32m address format for native v0-16 segregated
witness outputs' should probably be v1-16?

This is a thorough and clear write up; a superb read.

Side note: I am deeply impressed with your mathematical jujitsu that no
bech32 string is also a valid bech32m string *even with three errors*.

This sways me even more that this approach is correct.

Untested-Ack.

Thanks,
Rusty.

Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:

> On Monday, January 4, 2021 4:14 PM, Pieter Wuille <bitcoin-dev at wuille.net> wrote:
>
>> Hello all,
>>
>> here is a BIP draft for changing the checksum in native segwit addresses for v1 and higher, following the discussion in https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018293.html
>>
>> Overall, the idea is:
>> * Define a new encoding which is a tweaked variant of Bech32, called Bech32m. It refers to the Bech32 section of BIP173, which remains in effect.
>> * Define a new segwit address encoding which replaces the corresponding section in BIP173. It prescribes using Bech32 for v0 witness addresses, and Bech32m for other versions.
>
> Of course I forgot the actual link: https://github.com/sipa/bips/blob/bip-bech32m/bip-bech32m.mediawiki
>
> Cheers,
>
> --
> Pieter
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jlrubin at mit.edu  Sun Jan 10 19:39:15 2021
From: jlrubin at mit.edu (Jeremy)
Date: Sun, 10 Jan 2021 11:39:15 -0800
Subject: [bitcoin-dev] Extension to BIP Format for Multiple Required SigHash
	Flags
Message-ID: <CAD5xwhg-+QLrXFRLXyPoYRRE6dDLzXVhzbqP2iwc6MHq3j=Pag@mail.gmail.com>

- *# The Issue:*
- Currently the PSBT BIP has a slight "conceptual gap" where it is possible
to both:
-
- 1) Have a PSBT which obtains multiple signatures per-input with any set
of SIGHASH Flags
- 2) Have a PSBT which obtains multiple signatures per-input with a fixed
SigHash type applying to all signatures.
-
- But not possible to:
3) Have a PSBT which obtains multiple signatures per-input with a fixed
sighash type applying to a specific key's signature
4) Gracefully handle a PSBT with multiple uses of the same key, but
different code-separators.

To solve this we should introduce a new key type compatible with the
existing PSBT Spec (no V2 Requirement).

(I'm not convinced that 4 needs to be fully supported, but I believe that
it makes sense to lay the groundwork for it to be supported as the handling
of different requests for sighash flags and multiple uses of the same key
with different codeseps should happen from the same field.)

Excerpted relevant BIP text:
```

* Type: Partial Signature <tt>PSBT_IN_PARTIAL_SIG = 0x02</tt>
** Key: The public key which corresponds to this signature.
*** <tt>{0x02}|{public key}</tt>
** Value: The signature as would be pushed to the stack from a
scriptSig or witness.
*** <tt>{signature}</tt>

* Type: Sighash Type <tt>PSBT_IN_SIGHASH_TYPE = 0x03</tt>
** Key: None. The key must only contain the 1 byte type.
*** <tt>{0x03}</tt>
** Value: The 32-bit unsigned integer specifying the sighash type to
be used for this input. Signatures for this input must use the sighash
type, finalizers must fail to finalize inputs which have signatures
that do not match the specified sighash type. Signers who cannot
produce signatures with the sighash type must not provide a signature.
*** <tt>{sighash type}</tt>

```

*# Motivation*:
As An example where it may be relevant to cleanly support this, consider
the script:

`2 <Key 1 Checks Approved Output Addresses> <Key 2 Checks Input Allowed to
Spend> 2 CHECKMULTI`

Under such a script, we might have 2 HSMs operating each key. Key 2 is used
first which verifies internal business logic only about the permissibility
of spending an output, but does not sign off on any other logic. Key 1 is
used last which checks that transaction sends only to the currently allowed
addresses and is signed by Key 1. In such an example (discussion of this
particular application is off topic, this is a contrived example to
demonstrate the technical issue), it is not possible to express that Key 1
will sign with SIGHASH_ALL | ANYONECANPAY and Key 2 will sign with
SIGHASH_NONE | ANYONECANPAY. It would be impossible to finalize a PSBT with
SigHash type set, because the sighashes conflict. And while it is possible
to not have any Sighash type set and successfully finalize, this fails to
capture the relevant information around which sighash types are supposed to
be used.

(why the example is contrived: one could argue that you should just have
such business logic *always* use SIGHASH_ALL for such business logic
servers, but there are technical reasons (e.g., adding a change input or
output dynamically with SIGHASH_SINGLES) that you might have to do post-hoc)

*# A Solution*
To address this I propose to add a new key type
PSBT_IN_SIGHASH_PER_KEY_TYPE (e.g., 0x0e) which is followed by a public
key, a 8-bit bool (must be 0 or 1) if the next field will be a sighash
flag, optionally a 32-bit unsigned integer representing the sighash type,
and a compact size integer representing the codeseparator position + 1 (so
that 0 may represent no codeseparator) in the scriptpubkey. If a
codeseparator is set, the redeem script (+ witness script if witness) must
be present.

Finalizers should verify that each requested signature is available.

PSBT_IN_SIGHASH_PER_KEY_TYPE is fully compatible with existing PSBT as long
as PSBT_IN_SIGHASH_TYPE is not set (or, trivially, if it is set and all
PSBT_IN_SIGHASH_PER_KEY_TYPE's match it).

Finalizers could deduce which codeseparator was used if multiple
PSBT_IN_PARTIAL_SIGS are delivered by process of elimination, thus a new
PSBT_IN_PARTIAL_SIG type to specify codeseparator is not required. However,
in the case of multiple signatures, PSBT_IN_PARTIAL_SIG would lead to a
duplicated key-pair specification error so we should also introduce the
type PSBT_IN_PARTIAL_SIG_EXTRA which has a key of a public key followed by
a compact size integer code separator (n.b. no +1 value to exclude the
default!), and a signature as a value. Finalizers shall check that the
PSBT_IN_PARTIAL_SIG_EXTRA values match the corresponding
PSBT_IN_SIGHASH_PER_KEY_TYPE requests. Compatibility: PSBT_IN_PARTIAL_SIG
does not overlap with PSBT_IN_PARTIAL_SIG_EXTRA as '_EXTRA must specify a
codeseparator. Thus, as long as no repeated key/codeseparators are used,
the new PSBT remains fully backwards compatible.

--
@JeremyRubin <https://twitter.com/JeremyRubin>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210110/9f254819/attachment.html>

From lf-lists at mattcorallo.com  Wed Jan 13 06:40:03 2021
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Wed, 13 Jan 2021 01:40:03 -0500
Subject: [bitcoin-dev] Proposal for new "disabletx" p2p message
In-Reply-To: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>
References: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>
Message-ID: <10E92E80-75A3-4C45-8CEA-F1EAA2149761@mattcorallo.com>

Out of curiosity, was the interaction between fRelay and bloom disabling ever specified? ie if you aren?t allowed to enable bloom filters on a connection due to resource constraints/new limits, is it ever possible to ?set? fRelay later?

Matt

> On Jan 6, 2021, at 11:35, Suhas Daftuar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?
> Hi,
> 
> I'm proposing the addition of a new, optional p2p message to allow peers to communicate that they do not want to send or receive (loose) transactions for the lifetime of a connection. 
> 
> The goal of this message is to help facilitate connections on the network over which only block-related data (blocks/headers/compact blocks/etc) are relayed, to create low-resource connections that help protect against partition attacks on the network.  In particular, by adding a network message that communicates that transactions will not be relayed for the life of the connection, we ease the implementation of software that could have increased inbound connection limits for such peers, which in turn will make it easier to add additional persistent block-relay-only connections on the network -- strengthening network security for little additional bandwidth.
> 
> Software has been deployed for over a year now which makes such connections, using the BIP37/BIP60 "fRelay" field in the version message to signal that transactions should not be sent initially.  However, BIP37 allows for transaction relay to be enabled later in the connection's lifetime, complicating software that would try to distinguish inbound peers that will never relay transactions from those that might.
> 
> This proposal would add a single new p2p message, "disabletx", which (if used at all) must be sent between version and verack.  I propose that this message is valid for peers advertising protocol version 70017 or higher.  Software is free to implement this BIP or ignore this message and remain compatible with software that does implement it.
> 
> Full text of the proposed BIP is below.
> 
> Thanks,
> Suhas
> 
> ---------------------------------------------------
> 
> <pre>
>   BIP: XXX
>   Layer: Peer Services
>   Title: Disable transaction relay message
>   Author: Suhas Daftuar <sdaftuar at chaincode.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
>   Status: Draft
>   Type: Standards Track
>   Created: 2020-09-03
>   License: BSD-2-Clause
> </pre>
> 
> ==Abstract==
> 
> This BIP describes a change to the p2p protocol to allow a node to tell a peer
> that a connection will not be used for transaction relay, to support
> block-relay-only connections that are currently in use on the network.
> 
> ==Motivation==
> 
> For nearly the past year, software has been deployed[1] which initiates
> connections on the Bitcoin network and sets the transaction relay field
> (introduced by BIP 37 and also defined in BIP 60) to false, to prevent
> transaction relay from occurring on the connection. Additionally, addr messages
> received from the peer are ignored by this software.
> 
> The purpose of these connections is two-fold: by making additional
> low-bandwidth connections on which blocks can propagate, the robustness of a
> node to network partitioning attacks is strengthened.  Additionally, by not
> relaying transactions and ignoring received addresses, the ability of an
> adversary to learn the complete network graph (or a subgraph) is reduced[2],
> which in turn increases the cost or difficulty to an attacker seeking to carry
> out a network partitioning attack (when compared with having such knowledge).
> 
> The low-bandwidth / minimal-resource nature of these connections is currently
> known only by the initiator of the connection; this is because the transaction
> relay field in the version message is not a permanent setting for the lifetime
> of the connection.  Consequently, a node receiving an inbound connection with
> transaction relay disabled cannot distinguish between a peer that will never
> enable transaction relay (as described in BIP 37) and one that will.  Moreover,
> the node also cannot determine that the incoming connection will ignore relayed
> addresses; with that knowledge a node would likely choose other peers to
> receive announced addresses instead.
> 
> This proposal adds a new, optional message that a node can send a peer when
> initiating a connection to that peer, to indicate that connection should not be
> used for transaction-relay for the connection's lifetime. In addition, without
> a current mechanism to negotiate whether addresses should be relayed on a
> connection, this BIP suggests that address messages not be sent on links where
> tx-relay has been disabled.
> 
> ==Specification==
> 
> # A new disabletx message is added, which is defined as an empty message where pchCommand == "disabletx".
> # The protocol version of nodes implementing this BIP must be set to 70017 or higher.
> # If a node sets the transaction relay field in the version message to a peer to false, then the disabletx message MAY also be sent in response to a version message from that peer if the peer's protocol version is >= 70017. If sent, the disabletx message MUST be sent prior to sending a verack.
> # A node that has sent or received a disabletx message to/from a peer MUST NOT send any of these messages to the peer:
> ## inv messages for transactions
> ## getdata messages for transactions
> ## getdata messages for merkleblock (BIP 37)
> ## filteradd/filterload/filterclear (BIP 37)
> ## mempool (BIP 35)
> # It is RECOMMENDED that a node that has sent or received a disabletx message to/from a peer not send any of these messages to the peer:
> ## addr/getaddr
> ## addrv2 (BIP 155)
> # The behavior regarding sending or processing other message types is not specified by this BIP.
> # Nodes MAY decide to not remain connected to peers that send this message (for example, if trying to find a peer that will relay transactions).
> 
> ==Compatibility==
> 
> Nodes with protocol version >= 70017 that do not implement this BIP, and nodes
> with protocol version < 70017, will continue to remain compatible with
> implementing software: transactions would not be relayed to peers sending the
> disabletx message (provided that BIP 37 or BIP 60 has been implemented), and while
> periodic address relay may still take place, software implementing this BIP
> should not be disconnecting such peers solely for that reason.
> 
> Disabling address relay is suggested but not required by this BIP, to allow for
> future protocol extensions that might specify more carefully how address relay
> is to be negotiated. This BIP's recommendations for software to not relay
> addresses is intended to be interpreted as guidance in the absence of any such
> future protocol extension, to accommodate existing software behavior.
> 
> Note that all messages specified in BIP 152, including blocktxn and
> getblocktxn, are permitted between peers that have sent/received a disabletx
> message, subject to the feature negotiation of BIP 152.
> 
> ==Implementation==
> 
> TBD
> 
> ==References==
> 
> # Bitcoin Core has [https://github.com/bitcoin/bitcoin/pull/15759 implemented this functionality] since version 0.19.0.1, released in November 2019.
> # For example, see https://www.cs.umd.edu/projects/coinscope/coinscope.pdf and https://arxiv.org/pdf/1812.00942.pdf.
> 
> ==Copyright==
> 
> This BIP is licensed under the 2-clause BSD license.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210113/573ec1b9/attachment.html>

From aj at erisian.com.au  Thu Jan 14 05:32:57 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 14 Jan 2021 15:32:57 +1000
Subject: [bitcoin-dev] Proposal for new "disabletx" p2p message
In-Reply-To: <10E92E80-75A3-4C45-8CEA-F1EAA2149761@mattcorallo.com>
References: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>
 <10E92E80-75A3-4C45-8CEA-F1EAA2149761@mattcorallo.com>
Message-ID: <20210114053257.4ctg3qdvo7s44s72@erisian.com.au>

On Wed, Jan 13, 2021 at 01:40:03AM -0500, Matt Corallo via bitcoin-dev wrote:
> Out of curiosity, was the interaction between fRelay and bloom disabling ever
> specified? ie if you aren?t allowed to enable bloom filters on a connection due
> to resource constraints/new limits, is it ever possible to ?set? fRelay later?

(Maybe I'm missing something, but...)

In the current bitcoin implementation, no -- you either set
m_tx_relay->fRelayTxes to true via the VERSION message (either explicitly
or by not setting fRelay), or you enable it later with FILTERLOAD or
FILTERCLEAR, both of which will cause a disconnect if bloom filters
aren't supported. Bloom filter support is (optionally?) indicated via
a service bit (BIP 111), so you could assume you know whether they're
supported as soon as you receive the VERSION line.

fRelay is specified in BIP 37 as:

  | 1 byte || fRelay || bool || If false then broadcast transactions will
  not be announced until a filter{load,add,clear} command is received. If
  missing or true, no change in protocol behaviour occurs.

BIP 60 defines the field as "relay" and references BIP 37. Don't think
it's referenced in any other bips.

Cheers,
aj


From lf-lists at mattcorallo.com  Thu Jan 14 05:39:16 2021
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 14 Jan 2021 00:39:16 -0500
Subject: [bitcoin-dev] Proposal for new "disabletx" p2p message
In-Reply-To: <20210114053257.4ctg3qdvo7s44s72@erisian.com.au>
References: <20210114053257.4ctg3qdvo7s44s72@erisian.com.au>
Message-ID: <DDE19B4D-9272-4645-8016-BDC377902751@mattcorallo.com>

So we?d kill two birds with one stone if all bloom support was dropped. As far as I understand, precomputed filters are now provided via p2p connections as well.

Matt

> On Jan 14, 2021, at 00:33, Anthony Towns <aj at erisian.com.au> wrote:
> 
> ?On Wed, Jan 13, 2021 at 01:40:03AM -0500, Matt Corallo via bitcoin-dev wrote:
>> Out of curiosity, was the interaction between fRelay and bloom disabling ever
>> specified? ie if you aren?t allowed to enable bloom filters on a connection due
>> to resource constraints/new limits, is it ever possible to ?set? fRelay later?
> 
> (Maybe I'm missing something, but...)
> 
> In the current bitcoin implementation, no -- you either set
> m_tx_relay->fRelayTxes to true via the VERSION message (either explicitly
> or by not setting fRelay), or you enable it later with FILTERLOAD or
> FILTERCLEAR, both of which will cause a disconnect if bloom filters
> aren't supported. Bloom filter support is (optionally?) indicated via
> a service bit (BIP 111), so you could assume you know whether they're
> supported as soon as you receive the VERSION line.
> 
> fRelay is specified in BIP 37 as:
> 
>  | 1 byte || fRelay || bool || If false then broadcast transactions will
>  not be announced until a filter{load,add,clear} command is received. If
>  missing or true, no change in protocol behaviour occurs.
> 
> BIP 60 defines the field as "relay" and references BIP 37. Don't think
> it's referenced in any other bips.
> 
> Cheers,
> aj
> 

From aj at erisian.com.au  Thu Jan 14 06:46:00 2021
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 14 Jan 2021 16:46:00 +1000
Subject: [bitcoin-dev] Proposal for new "disabletx" p2p message
In-Reply-To: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>
References: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>
Message-ID: <20210114064600.gu2qetgo5cw4tl5q@erisian.com.au>

On Wed, Jan 06, 2021 at 11:35:11AM -0500, Suhas Daftuar via bitcoin-dev wrote:
> I'm proposing the addition of a new, optional p2p message to allow peers to
> communicate that they do not want to send or receive (loose) transactions for
> the lifetime of a connection.?
> 
> The goal of this message is to help facilitate?connections on the network over
> which only block-related data (blocks/headers/compact blocks/etc) are relayed,
> to create low-resource connections that help protect against partition attacks
> on the network.

I think we should separate these ideas -- ie, the protocol change to
allow indicating that you don't want transactions, and the policy change
to protect against partition attacks using that protocol addition.

The idea (obviously?) being that the protocol should be simple and
flexible enough to support many possible policies.

> ==Specification==
> # A new disabletx message is added, [...]
> # A node that has sent or received a disabletx message to/from a peer MUST NOT send any of these messages to the peer:
> ## inv messages for transactions
> [...]
> # It is RECOMMENDED that a node that has sent or received a disabletx message to/from a peer not send any of these messages to the peer:
> ## addr/getaddr
> ## addrv2 (BIP 155)

In particular, I think combining these doesn't make sense for:

 * nodes running with -blocksonly (that want to stay up to date with
   the blockchain, but don't care about txes)
    - not sending disabletx reduces their potential connectivity, if
      nodes are willing to accept more disabletx peers due to the lower
      resource usage
    - sending disabletx means they can't maintain their addr db and find
      other nodes to connect to

 * non-listening nodes running with -connect to one/more preselected peers
    - they can't send disabletx generally because they want txes
    - they don't need addr information (since they only make connections
      to some known peers), and don't have many peers to relay addresses
      on to, so are essentially blackholes, so would like to disable
      addr relay for much the same reasons

So to me that says the protocol part of the design's not as flexible as
it should be, which suggests DISABLETX and DISABLEADDR.

(I think I'm going to flesh out the "FEATURE" idea as an alternative
way of dealing with this, but that can be its own thread)

Cheers,
aj


From laanwj at protonmail.com  Thu Jan 14 13:58:35 2021
From: laanwj at protonmail.com (Wladimir J. van der Laan)
Date: Thu, 14 Jan 2021 13:58:35 +0000
Subject: [bitcoin-dev] Bitcoin Core 0.21.0 released
Message-ID: <ytQAmQfHpGOeao8JSMSk2dnnKkuYmJI35IMqNq2P2qt6C0j6LV610A1_2kNVPFCGyWSu-E80ffYd9Dy8S3F2l_l9XtwP1YGAqRFcGX-oo9I=@protonmail.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

0.21.0 Release Notes
====================

Bitcoin Core version 0.21.0 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.21.0/>

Or through BitTorrent:

    magnet:?xt=urn:btih:665c5bdc6f49948e47c1098d91ace98bd216150e&dn=bitcoin-core-0.21.0&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969

This release includes new features, various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes in some cases), then run the
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

Upgrading directly from a version of Bitcoin Core that has reached its EOL is
possible, but it might take some time if the data directory needs to be migrated. Old
wallet versions of Bitcoin Core are generally supported.

Compatibility
==============

Bitcoin Core is supported and extensively tested on operating systems
using the Linux kernel, macOS 10.12+, and Windows 7 and newer.  Bitcoin
Core should also work on most other Unix-like systems but is not as
frequently tested on them.  It is not recommended to use Bitcoin Core on
unsupported systems.

- From Bitcoin Core 0.20.0 onwards, macOS versions earlier than 10.12 are no
longer supported. Additionally, Bitcoin Core does not yet change appearance
when macOS "dark mode" is activated.

The node's known peers are persisted to disk in a file called `peers.dat`. The
format of this file has been changed in a backwards-incompatible way in order to
accommodate the storage of Tor v3 and other BIP155 addresses. This means that if
the file is modified by 0.21.0 or newer then older versions will not be able to
read it. Those old versions, in the event of a downgrade, will log an error
message "Incorrect keysize in addrman deserialization" and will continue normal
operation as if the file was missing, creating a new empty one. (#19954, #20284)

Notable changes
===============

P2P and network changes
- -----------------------

- - The mempool now tracks whether transactions submitted via the wallet or RPCs
  have been successfully broadcast. Every 10-15 minutes, the node will try to
  announce unbroadcast transactions until a peer requests it via a `getdata`
  message or the transaction is removed from the mempool for other reasons.
  The node will not track the broadcast status of transactions submitted to the
  node using P2P relay. This version reduces the initial broadcast guarantees
  for wallet transactions submitted via P2P to a node running the wallet. (#18038)

- - The size of the set of transactions that peers have announced and we consider
  for requests has been reduced from 100000 to 5000 (per peer), and further
  announcements will be ignored when that limit is reached. If you need to dump
  (very) large batches of transactions, exceptions can be made for trusted
  peers using the "relay" network permission. For localhost for example it can
  be enabled using the command line option `-whitelist=relay at 127.0.0.1`.
  (#19988)

- - This release adds support for Tor version 3 hidden services, and rumoring them
  over the network to other peers using
  [BIP155](https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki).
  Version 2 hidden services are still fully supported by Bitcoin Core, but the
  Tor network will start
  [deprecating](https://blog.torproject.org/v2-deprecation-timeline) them in the
  coming months. (#19954)

- - The Tor onion service that is automatically created by setting the
  `-listenonion` configuration parameter will now be created as a Tor v3 service
  instead of Tor v2. The private key that was used for Tor v2 (if any) will be
  left untouched in the `onion_private_key` file in the data directory (see
  `-datadir`) and can be removed if not needed. Bitcoin Core will no longer
  attempt to read it. The private key for the Tor v3 service will be saved in a
  file named `onion_v3_private_key`. To use the deprecated Tor v2 service (not
  recommended), the `onion_private_key` can be copied over
  `onion_v3_private_key`, e.g.
  `cp -f onion_private_key onion_v3_private_key`. (#19954)

- - The client writes a file (`anchors.dat`) at shutdown with the network addresses
  of the node?s two outbound block-relay-only peers (so called "anchors"). The
  next time the node starts, it reads this file and attempts to reconnect to those
  same two peers. This prevents an attacker from using node restarts to trigger a
  complete change in peers, which would be something they could use as part of an
  eclipse attack. (#17428)

- - This release adds support for serving
  [BIP157](https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki) compact
  filters to peers on the network when enabled using
  `-blockfilterindex=1 -peercfilters=1`. (#16442)

- - This release adds support for signets
  ([BIP325](https://github.com/bitcoin/bips/blob/master/bip-0325.mediawiki)) in
  addition to the existing mainnet, testnet, and regtest networks. Signets are
  centrally-controlled test networks, allowing them to be more predictable
  test environments than the older testnet. One public signet is maintained, and
  selectable using `-signet`. It is also possible to create personal signets.
  (#18267).

- - This release implements
  [BIP339](https://github.com/bitcoin/bips/blob/master/bip-0339.mediawiki)
  wtxid relay. When negotiated, transactions are announced using their wtxid
  instead of their txid. (#18044).

- - This release implements the proposed Taproot consensus rules
  ([BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) and
  [BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)),
  without activation on mainnet. Experimentation with Taproot can be done on
  signet, where its rules are already active. (#19553)

Updated RPCs
- ------------

- - The `getpeerinfo` RPC has a new `network` field that provides the type of
  network ("ipv4", "ipv6", or "onion") that the peer connected through. (#20002)

- - The `getpeerinfo` RPC now has additional `last_block` and `last_transaction`
  fields that return the UNIX epoch time of the last block and the last *valid*
  transaction received from each peer. (#19731)

- - `getnetworkinfo` now returns two new fields, `connections_in` and
  `connections_out`, that provide the number of inbound and outbound peer
  connections. These new fields are in addition to the existing `connections`
  field, which returns the total number of peer connections. (#19405)

- - Exposed transaction version numbers are now treated as unsigned 32-bit
  integers instead of signed 32-bit integers. This matches their treatment in
  consensus logic. Versions greater than 2 continue to be non-standard
  (matching previous behavior of smaller than 1 or greater than 2 being
  non-standard). Note that this includes the `joinpsbt` command, which combines
  partially-signed transactions by selecting the highest version number.
  (#16525)

- - `getmempoolinfo` now returns an additional `unbroadcastcount` field. The
  mempool tracks locally submitted transactions until their initial broadcast
  is acknowledged by a peer. This field returns the count of transactions
  waiting for acknowledgement.

- - Mempool RPCs such as `getmempoolentry` and `getrawmempool` with
  `verbose=true` now return an additional `unbroadcast` field. This indicates
  whether initial broadcast of the transaction has been acknowledged by a
  peer. `getmempoolancestors` and `getmempooldescendants` are also updated.

- - The `getpeerinfo` RPC no longer returns the `banscore` field unless the configuration
  option `-deprecatedrpc=banscore` is used. The `banscore` field will be fully
  removed in the next major release. (#19469)

- - The `testmempoolaccept` RPC returns `vsize` and a `fees` object with the `base` fee
  if the transaction would pass validation. (#19940)

- - The `getpeerinfo` RPC now returns a `connection_type` field. This indicates
  the type of connection established with the peer. It will return one of six
  options. For more information, see the `getpeerinfo` help documentation.
  (#19725)

- - The `getpeerinfo` RPC no longer returns the `addnode` field by default. This
  field will be fully removed in the next major release.  It can be accessed
  with the configuration option `-deprecatedrpc=getpeerinfo_addnode`. However,
  it is recommended to instead use the `connection_type` field (it will return
  `manual` when addnode is true). (#19725)

- - The `getpeerinfo` RPC no longer returns the `whitelisted` field by default.
  This field will be fully removed in the next major release. It can be accessed
  with the configuration option `-deprecatedrpc=getpeerinfo_whitelisted`. However,
  it is recommended to instead use the `permissions` field to understand if specific
  privileges have been granted to the peer. (#19770)

- - The `walletcreatefundedpsbt` RPC call will now fail with
  `Insufficient funds` when inputs are manually selected but are not enough to cover
  the outputs and fee. Additional inputs can automatically be added through the
  new `add_inputs` option. (#16377)

- - The `fundrawtransaction` RPC now supports `add_inputs` option that when `false`
  prevents adding more inputs if necessary and consequently the RPC fails.

Changes to Wallet or GUI related RPCs can be found in the GUI or Wallet section below.

New RPCs
- --------

- - The `getindexinfo` RPC returns the actively running indices of the node,
  including their current sync status and height. It also accepts an `index_name`
  to specify returning the status of that index only. (#19550)

Build System
- ------------

Updated settings
- ----------------

- - The same ZeroMQ notification (e.g. `-zmqpubhashtx=address`) can now be
  specified multiple times to publish the same notification to different ZeroMQ
  sockets. (#18309)

- - The `-banscore` configuration option, which modified the default threshold for
  disconnecting and discouraging misbehaving peers, has been removed as part of
  changes in 0.20.1 and in this release to the handling of misbehaving peers.
  Refer to "Changes regarding misbehaving peers" in the 0.20.1 release notes for
  details. (#19464)

- - The `-debug=db` logging category, which was deprecated in 0.20 and replaced by
  `-debug=walletdb` to distinguish it from `coindb`, has been removed. (#19202)

- - A `download` permission has been extracted from the `noban` permission. For
  compatibility, `noban` implies the `download` permission, but this may change
  in future releases. Refer to the help of the affected settings `-whitebind`
  and `-whitelist` for more details. (#19191)

- - Netmasks that contain 1-bits after 0-bits (the 1-bits are not contiguous on
  the left side, e.g. 255.0.255.255) are no longer accepted. They are invalid
  according to RFC 4632. Netmasks are used in the `-rpcallowip` and `-whitelist`
  configuration options and in the `setban` RPC. (#19628)

- - The `-blocksonly` setting now completely disables fee estimation. (#18766)

Changes to Wallet or GUI related settings can be found in the GUI or Wallet section below.

Tools and Utilities
- -------------------

- - A new `bitcoin-cli -netinfo` command provides a network peer connections
  dashboard that displays data from the `getpeerinfo` and `getnetworkinfo` RPCs
  in a human-readable format. An optional integer argument from `0` to `4` may
  be passed to see increasing levels of detail. (#19643)

- - A new `bitcoin-cli -generate` command, equivalent to RPC `generatenewaddress`
  followed by `generatetoaddress`, can generate blocks for command line testing
  purposes. This is a client-side version of the former `generate` RPC. See the
  help for details. (#19133)

- - The `bitcoin-cli -getinfo` command now displays the wallet name and balance for
  each of the loaded wallets when more than one is loaded (e.g. in multiwallet
  mode) and a wallet is not specified with `-rpcwallet`. (#18594)

- - The `connections` field of `bitcoin-cli -getinfo` is now expanded to return a JSON
  object with `in`, `out` and `total` numbers of peer connections. It previously
  returned a single integer value for the total number of peer connections. (#19405)

New settings
- ------------

- - The `startupnotify` option is used to specify a command to
  execute when Bitcoin Core has finished with its startup
  sequence. (#15367)

Wallet
- ------

- - Backwards compatibility has been dropped for two `getaddressinfo` RPC
  deprecations, as notified in the 0.20 release notes. The deprecated `label`
  field has been removed as well as the deprecated `labels` behavior of
  returning a JSON object containing `name` and `purpose` key-value pairs. Since
  0.20, the `labels` field returns a JSON array of label names. (#19200)

- - To improve wallet privacy, the frequency of wallet rebroadcast attempts is
  reduced from approximately once every 15 minutes to once every 12-36 hours.
  To maintain a similar level of guarantee for initial broadcast of wallet
  transactions, the mempool tracks these transactions as a part of the newly
  introduced unbroadcast set. See the "P2P and network changes" section for
  more information on the unbroadcast set. (#18038)

- - The `sendtoaddress` and `sendmany` RPCs accept an optional `verbose=True`
  argument to also return the fee reason about the sent tx. (#19501)

- - The wallet can create a transaction without change even when the keypool is
  empty. Previously it failed. (#17219)

- - The `-salvagewallet` startup option has been removed. A new `salvage` command
  has been added to the `bitcoin-wallet` tool which performs the salvage
  operations that `-salvagewallet` did. (#18918)

- - A new configuration flag `-maxapsfee` has been added, which sets the max
  allowed avoid partial spends (APS) fee. It defaults to 0 (i.e. fee is the
  same with and without APS). Setting it to -1 will disable APS, unless
  `-avoidpartialspends` is set. (#14582)

- - The wallet will now avoid partial spends (APS) by default, if this does not
  result in a difference in fees compared to the non-APS variant. The allowed
  fee threshold can be adjusted using the new `-maxapsfee` configuration
  option. (#14582)

- - The `createwallet`, `loadwallet`, and `unloadwallet` RPCs now accept
  `load_on_startup` options to modify the settings list. Unless these options
  are explicitly set to true or false, the list is not modified, so the RPC
  methods remain backwards compatible. (#15937)

- - A new `send` RPC with similar syntax to `walletcreatefundedpsbt`, including
  support for coin selection and a custom fee rate, is added. The `send` RPC is
  experimental and may change in subsequent releases. (#16378)

- - The `estimate_mode` parameter is now case-insensitive in the `bumpfee`,
  `fundrawtransaction`, `sendmany`, `sendtoaddress`, `send` and
  `walletcreatefundedpsbt` RPCs. (#11413)

- - The `bumpfee` RPC now uses `conf_target` rather than `confTarget` in the
  options. (#11413)

- - `fundrawtransaction` and `walletcreatefundedpsbt` when used with the
  `lockUnspents` argument now lock manually selected coins, in addition to
  automatically selected coins. Note that locked coins are never used in
  automatic coin selection, but can still be manually selected. (#18244)

- - The `-zapwallettxes` startup option has been removed and its functionality
  removed from the wallet.  This option was originally intended to allow for
  rescuing wallets which were affected by a malleability attack. More recently,
  it has been used in the fee bumping of transactions that did not signal RBF.
  This functionality has been superseded with the abandon transaction feature. (#19671)

- - The error code when no wallet is loaded, but a wallet RPC is called, has been
  changed from `-32601` (method not found) to `-18` (wallet not found).
  (#20101)

### Automatic wallet creation removed

Bitcoin Core will no longer automatically create new wallets on startup. It will
load existing wallets specified by `-wallet` options on the command line or in
`bitcoin.conf` or `settings.json` files. And by default it will also load a
top-level unnamed ("") wallet. However, if specified wallets don't exist,
Bitcoin Core will now just log warnings instead of creating new wallets with
new keys and addresses like previous releases did.

New wallets can be created through the GUI (which has a more prominent create
wallet option), through the `bitcoin-cli createwallet` or `bitcoin-wallet
create` commands, or the `createwallet` RPC. (#15454, #20186)

### Experimental Descriptor Wallets

Please note that Descriptor Wallets are still experimental and not all expected functionality
is available. Additionally there may be some bugs and current functions may change in the future.
Bugs and missing functionality can be reported to the [issue tracker](https://github.com/bitcoin/bitcoin/issues).

0.21 introduces a new type of wallet - Descriptor Wallets. Descriptor Wallets store
scriptPubKey information using output descriptors. This is in contrast to the Legacy Wallet
structure where keys are used to implicitly generate scriptPubKeys and addresses. Because of this
shift to being script based instead of key based, many of the confusing things that Legacy
Wallets do are not possible with Descriptor Wallets. Descriptor Wallets use a definition
of "mine" for scripts which is simpler and more intuitive than that used by Legacy Wallets.
Descriptor Wallets also uses different semantics for watch-only things and imports.

As Descriptor Wallets are a new type of wallet, their introduction does not affect existing wallets.
Users who already have a Bitcoin Core wallet can continue to use it as they did before without
any change in behavior. Newly created Legacy Wallets (which remains the default type of wallet) will
behave as they did in previous versions of Bitcoin Core.

The differences between Descriptor Wallets and Legacy Wallets are largely limited to non user facing
things. They are intended to behave similarly except for the import/export and watchonly functionality
as described below.

#### Creating Descriptor Wallets

Descriptor wallets are not the default type of wallet.

In the GUI, a checkbox has been added to the Create Wallet Dialog to indicate that a
Descriptor Wallet should be created. And a `descriptors` option has been added to `createwallet` RPC.
Setting `descriptors` to `true` will create a Descriptor Wallet instead of a Legacy Wallet.

Without those options being set, a Legacy Wallet will be created instead.

#### `IsMine` Semantics

`IsMine` refers to the function used to determine whether a script belongs to the wallet.
This is used to determine whether an output belongs to the wallet. `IsMine` in Legacy Wallets
returns true if the wallet would be able to sign an input that spends an output with that script.
Since keys can be involved in a variety of different scripts, this definition for `IsMine` can
lead to many unexpected scripts being considered part of the wallet.

With Descriptor Wallets, descriptors explicitly specify the set of scripts that are owned by
the wallet. Since descriptors are deterministic and easily enumerable, users will know exactly
what scripts the wallet will consider to belong to it. Additionally the implementation of `IsMine`
in Descriptor Wallets is far simpler than for Legacy Wallets. Notably, in Legacy Wallets, `IsMine`
allowed for users to take one type of address (e.g. P2PKH), mutate it into another address type
(e.g. P2WPKH), and the wallet would still detect outputs sending to the new address type
even without that address being requested from the wallet. Descriptor Wallets do not
allow for this and will only watch for the addresses that were explicitly requested from the wallet.

These changes to `IsMine` will make it easier to reason about what scripts the wallet will
actually be watching for in outputs. However for the vast majority of users, this change is
largely transparent and will not have noticeable effect.

#### Imports and Exports

In Legacy Wallets, raw scripts and keys could be imported to the wallet. Those imported scripts
and keys are treated separately from the keys generated by the wallet. This complicates the `IsMine`
logic as it has to distinguish between spendable and watchonly.

Descriptor Wallets handle importing scripts and keys differently. Only complete descriptors can be
imported. These descriptors are then added to the wallet as if it were a descriptor generated by
the wallet itself. This simplifies the `IsMine` logic so that it no longer has to distinguish
between spendable and watchonly. As such, the watchonly model for Descriptor Wallets is also
different and described in more detail in the next section.

To import into a Descriptor Wallet, a new `importdescriptors` RPC has been added that uses a syntax
similar to that of `importmulti`.

As Legacy Wallets and Descriptor Wallets use different mechanisms for storing and importing scripts and keys
the existing import RPCs have been disabled for descriptor wallets.
New export RPCs for Descriptor Wallets have not yet been added.

The following RPCs are disabled for Descriptor Wallets:

* `importprivkey`
* `importpubkey`
* `importaddress`
* `importwallet`
* `dumpprivkey`
* `dumpwallet`
* `importmulti`
* `addmultisigaddress`
* `sethdseed`

#### Watchonly Wallets

A Legacy Wallet contains both private keys and scripts that were being watched.
Those watched scripts would not contribute to your normal balance. In order to see the watchonly
balance and to use watchonly things in transactions, an `include_watchonly` option was added
to many RPCs that would allow users to do that. However it is easy to forget to include this option.

Descriptor Wallets move to a per-wallet watchonly model. Instead an entire wallet is considered to be
watchonly depending on whether it was created with private keys disabled. This eliminates the need
to distinguish between things that are watchonly and things that are not within a wallet itself.

This change does have a caveat. If a Descriptor Wallet with private keys *enabled* has
a multiple key descriptor without all of the private keys (e.g. `multi(...)` with only one private key),
then the wallet will fail to sign and broadcast transactions. Such wallets would need to use the PSBT
workflow but the typical GUI Send, `sendtoaddress`, etc. workflows would still be available, just
non-functional.

This issue is worsened if the wallet contains both single key (e.g. `wpkh(...)`) descriptors and such
multiple key descriptors as some transactions could be signed and broadcast and others not. This is
due to some transactions containing only single key inputs, while others would contain both single
key and multiple key inputs, depending on which are available and how the coin selection algorithm
selects inputs. However this is not considered to be a supported use case; multisigs
should be in their own wallets which do not already have descriptors. Although users cannot export
descriptors with private keys for now as explained earlier.

#### BIP 44/49/84 Support

The change to using descriptors changes the default derivation paths used by Bitcoin Core
to adhere to BIP 44/49/84. Descriptors with different derivation paths can be imported without
issue.

#### SQLite Database Backend

Descriptor wallets use SQLite for the wallet file instead of the Berkeley DB used in legacy wallets.
This will break compatibility with any existing tooling that operates on wallets, however compatibility
was already being broken by the move to descriptors.

### Wallet RPC changes

- - The `upgradewallet` RPC replaces the `-upgradewallet` command line option.
  (#15761)

- - The `settxfee` RPC will fail if the fee was set higher than the `-maxtxfee`
  command line setting. The wallet will already fail to create transactions
  with fees higher than `-maxtxfee`. (#18467)

- - A new `fee_rate` parameter/option denominated in satoshis per vbyte (sat/vB)
  is introduced to the `sendtoaddress`, `sendmany`, `fundrawtransaction` and
  `walletcreatefundedpsbt` RPCs as well as to the experimental new `send`
  RPC. The legacy `feeRate` option in `fundrawtransaction` and
  `walletcreatefundedpsbt` still exists for setting a fee rate in BTC per 1,000
  vbytes (BTC/kvB), but it is expected to be deprecated soon to avoid
  confusion. For these RPCs, the fee rate error message is updated from BTC/kB
  to sat/vB and the help documentation in BTC/kB is updated to BTC/kvB. The
  `send` and `sendtoaddress` RPC examples are updated to aid users in creating
  transactions with explicit fee rates. (#20305, #11413)

- - The `bumpfee` RPC `fee_rate` option is changed from BTC/kvB to sat/vB and the
  help documentation is updated. Users are warned that this is a breaking API
  change, but it should be relatively benign: the large (100,000 times)
  difference between BTC/kvB and sat/vB units means that a transaction with a
  fee rate mistakenly calculated in BTC/kvB rather than sat/vB should raise an
  error due to the fee rate being set too low. In the worst case, the
  transaction may send at 1 sat/vB, but as Replace-by-Fee (BIP125 RBF) is active
  by default when an explicit fee rate is used, the transaction fee can be
  bumped. (#20305)

GUI changes
- -----------

- - Wallets created or loaded in the GUI will now be automatically loaded on
  startup, so they don't need to be manually reloaded next time Bitcoin Core is
  started. The list of wallets to load on startup is stored in
  `\<datadir\>/settings.json` and augments any command line or `bitcoin.conf`
  `-wallet=` settings that specify more wallets to load. Wallets that are
  unloaded in the GUI get removed from the settings list so they won't load
  again automatically next startup. (#19754)

- - The GUI Peers window no longer displays a "Ban Score" field. This is part of
  changes in 0.20.1 and in this release to the handling of misbehaving
  peers. Refer to "Changes regarding misbehaving peers" in the 0.20.1 release
  notes for details. (#19512)

Low-level changes
=================

RPC
- ---

- - To make RPC `sendtoaddress` more consistent with `sendmany` the following error
    `sendtoaddress` codes were changed from `-4` to `-6`:
  - Insufficient funds
  - Fee estimation failed
  - Transaction has too long of a mempool chain

- - The `sendrawtransaction` error code for exceeding `maxfeerate` has been changed from
  `-26` to `-25`. The error string has been changed from "absurdly-high-fee" to
  "Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)." The
  `testmempoolaccept` RPC returns `max-fee-exceeded` rather than `absurdly-high-fee`
  as the `reject-reason`. (#19339)

- - To make wallet and rawtransaction RPCs more consistent, the error message for
  exceeding maximum feerate has been changed to "Fee exceeds maximum configured by user
  (e.g. -maxtxfee, maxfeerate)." (#19339)

Tests
- -----

- - The BIP 325 default signet can be enabled by the `-chain=signet` or `-signet`
  setting. The settings `-signetchallenge` and `-signetseednode` allow
  enabling a custom signet.

- - The `generateblock` RPC allows testers using regtest mode to
  generate blocks that consist of a custom set of transactions. (#17693)

0.21.0 change log
=================

### Consensus
- - #18267 BIP-325: Signet (kallewoof)
- - #20016 uint256: 1 is a constant (ajtowns)
- - #20006 Fix misleading error message: Clean stack rule (sanket1729)
- - #19953 Implement BIP 340-342 validation (Schnorr/taproot/tapscript) (sipa)
- - #20169 Taproot follow-up: Make ComputeEntrySchnorr and ComputeEntryECDSA const to clarify contract (practicalswift)

### Policy
- - #18766 Disable fee estimation in blocksonly mode (darosior)
- - #19630 Cleanup fee estimation code (darosior)
- - #20165 Only relay Taproot spends if next block has it active (sipa)

### Mining
- - #17946 Fix GBT: Restore "!segwit" and "csv" to "rules" key (luke-jr)

### Privacy
- - #16432 Add privacy to the Overview page (hebasto)
- - #18861 Do not answer GETDATA for to-be-announced tx (sipa)
- - #18038 Mempool tracks locally submitted transactions to improve wallet privacy (amitiuttarwar)
- - #19109 Only allow getdata of recently announced invs (sipa)

### Block and transaction handling
- - #17737 Add ChainstateManager, remove BlockManager global (jamesob)
- - #18960 indexes: Add compact block filter headers cache (jnewbery)
- - #13204 Faster sigcache nonce (JeremyRubin)
- - #19088 Use std::chrono throughout some validation functions (fanquake)
- - #19142 Make VerifyDB level 4 interruptible (MarcoFalke)
- - #17994 Flush undo files after last block write (kallewoof)
- - #18990 log: Properly log txs rejected from mempool (MarcoFalke)
- - #18984 Remove unnecessary input blockfile SetPos (dgenr8)
- - #19526 log: Avoid treating remote misbehvior as local system error (MarcoFalke)
- - #18044 Use wtxid for transaction relay (sdaftuar)
- - #18637 coins: allow cache resize after init (jamesob)
- - #19854 Avoid locking CTxMemPool::cs recursively in simple cases (hebasto)
- - #19478 Remove CTxMempool::mapLinks data structure member (JeremyRubin)
- - #19927 Reduce direct `g_chainman` usage (dongcarl)
- - #19898 log: print unexpected version warning in validation log category (n-thumann)
- - #20036 signet: Add assumed values for default signet (MarcoFalke)
- - #20048 chainparams: do not log signet startup messages for other chains (jonatack)
- - #19339 re-delegate absurd fee checking from mempool to clients (glozow)
- - #20035 signet: Fix uninitialized read in validation (MarcoFalke)
- - #20157 Bugfix: chainparams: Add missing (always enabled) Taproot deployment for Signet (luke-jr)
- - #20263 Update assumed chain params (MarcoFalke)
- - #20372 Avoid signed integer overflow when loading a mempool.dat file with a malformed time field (practicalswift)
- - #18621 script: Disallow silent bool -> cscript conversion (MarcoFalke)
- - #18612, #18732 script: Remove undocumented and unused operator+ (MarcoFalke)
- - #19317 Add a left-justified width field to `log2_work` component for a uniform debug.log output (jamesgmorgan)

### P2P protocol and network code
- - #18544 Limit BIP37 filter lifespan (active between `filterload`..`filterclear`) (theStack)
- - #18806 Remove is{Empty,Full} flags from CBloomFilter, clarify CVE fix (theStack)
- - #18512 Improve asmap checks and add sanity check (sipa)
- - #18877 Serve cfcheckpt requests (jnewbery)
- - #18895 Unbroadcast followups: rpcs, nLastResend, mempool sanity check (gzhao408)
- - #19010 net processing: Add support for `getcfheaders` (jnewbery)
- - #16939 Delay querying DNS seeds (ajtowns)
- - #18807 Unbroadcast follow-ups (amitiuttarwar)
- - #19044 Add support for getcfilters (jnewbery)
- - #19084 improve code documentation for dns seed behaviour (ajtowns)
- - #19260 disconnect peers that send filterclear + update existing filter msg disconnect logic (gzhao408)
- - #19284 Add seed.bitcoin.wiz.biz to DNS seeds (wiz)
- - #19322 split PushInventory() (jnewbery)
- - #19204 Reduce inv traffic during IBD (MarcoFalke)
- - #19470 banlist: log post-swept banlist size at startup (fanquake)
- - #19191 Extract download permission from noban (MarcoFalke)
- - #14033 Drop `CADDR_TIME_VERSION` checks now that `MIN_PEER_PROTO_VERSION` is greater (Empact)
- - #19464 net, rpc: remove -banscore option, deprecate banscore in getpeerinfo (jonatack)
- - #19514 [net/net processing] check banman pointer before dereferencing (jnewbery)
- - #19512 banscore updates to gui, tests, release notes (jonatack)
- - #19360 improve encapsulation of CNetAddr (vasild)
- - #19217 disambiguate block-relay-only variable names from blocksonly variables (glowang)
- - #19473 Add -networkactive option (hebasto)
- - #19472 [net processing] Reduce `cs_main` scope in MaybeDiscourageAndDisconnect() (jnewbery)
- - #19583 clean up Misbehaving() (jnewbery)
- - #19534 save the network type explicitly in CNetAddr (vasild)
- - #19569 Enable fetching of orphan parents from wtxid peers (sipa)
- - #18991 Cache responses to GETADDR to prevent topology leaks (naumenkogs)
- - #19596 Deduplicate parent txid loop of requested transactions and missing parents of orphan transactions (sdaftuar)
- - #19316 Cleanup logic around connection types (amitiuttarwar)
- - #19070 Signal support for compact block filters with `NODE_COMPACT_FILTERS` (jnewbery)
- - #19705 Shrink CAddress from 48 to 40 bytes on x64 (vasild)
- - #19704 Move ProcessMessage() to PeerLogicValidation (jnewbery)
- - #19628 Change CNetAddr::ip to have flexible size (vasild)
- - #19797 Remove old check for 3-byte shifted IP addresses from pre-0.2.9 nodes (#19797)
- - #19607 Add Peer struct for per-peer data in net processing (jnewbery)
- - #19857 improve nLastBlockTime and nLastTXTime documentation (jonatack)
- - #19724 Cleanup connection types- followups (amitiuttarwar)
- - #19670 Protect localhost and block-relay-only peers from eviction (sdaftuar)
- - #19728 Increase the ip address relay branching factor for unreachable networks (sipa)
- - #19879 Miscellaneous wtxid followups (amitiuttarwar)
- - #19697 Improvements on ADDR caching (naumenkogs)
- - #17785 Unify Send and Receive protocol versions (hebasto)
- - #19845 CNetAddr: add support to (un)serialize as ADDRv2 (vasild)
- - #19107 Move all header verification into the network layer, extend logging (troygiorshev)
- - #20003 Exit with error message if -proxy is specified without arguments (instead of continuing without proxy server) (practicalswift)
- - #19991 Use alternative port for incoming Tor connections (hebasto)
- - #19723 Ignore unknown messages before VERACK (sdaftuar)
- - #19954 Complete the BIP155 implementation and upgrade to TORv3 (vasild)
- - #20119 BIP155 follow-ups (sipa)
- - #19988 Overhaul transaction request logic (sipa)
- - #17428 Try to preserve outbound block-relay-only connections during restart (hebasto)
- - #19911 Guard `vRecvGetData` with `cs_vRecv` and `orphan_work_set` with `g_cs_orphans` (narula)
- - #19753 Don't add AlreadyHave transactions to recentRejects (troygiorshev)
- - #20187 Test-before-evict bugfix and improvements for block-relay-only peers (sdaftuar)
- - #20237 Hardcoded seeds update for 0.21 (laanwj)
- - #20212 Fix output of peer address in version message (vasild)
- - #20284 Ensure old versions don't parse peers.dat (vasild)
- - #20405 Avoid calculating onion address checksum when version is not 3 (lontivero)
- - #20564 Don't send 'sendaddrv2' to pre-70016 software, and send before 'verack' (sipa)
- - #20660 Move signet onion seed from v2 to v3 (Sjors)

### Wallet
- - #18262 Exit selection when `best_waste` is 0 (achow101)
- - #17824 Prefer full destination groups in coin selection (fjahr)
- - #17219 Allow transaction without change if keypool is empty (Sjors)
- - #15761 Replace -upgradewallet startup option with upgradewallet RPC (achow101)
- - #18671 Add BlockUntilSyncedToCurrentChain to dumpwallet (MarcoFalke)
- - #16528 Native Descriptor Wallets using DescriptorScriptPubKeyMan (achow101)
- - #18777 Recommend absolute path for dumpwallet (MarcoFalke)
- - #16426 Reverse `cs_main`, `cs_wallet` lock order and reduce `cs_main` locking (ariard)
- - #18699 Avoid translating RPC errors (MarcoFalke)
- - #18782 Make sure no DescriptorScriptPubKeyMan or WalletDescriptor members are left uninitialized after construction (practicalswift)
- - #9381 Remove CWalletTx merging logic from AddToWallet (ryanofsky)
- - #16946 Include a checksum of encrypted private keys (achow101)
- - #17681 Keep inactive seeds after sethdseed and derive keys from them as needed (achow101)
- - #18918 Move salvagewallet into wallettool (achow101)
- - #14988 Fix for confirmed column in csv export for payment to self transactions (benthecarman)
- - #18275 Error if an explicit fee rate was given but the needed fee rate differed (kallewoof)
- - #19054 Skip hdKeypath of 'm' when determining inactive hd seeds (achow101)
- - #17938 Disallow automatic conversion between disparate hash types (Empact)
- - #19237 Check size after unserializing a pubkey (elichai)
- - #11413 sendtoaddress/sendmany: Add explicit feerate option (kallewoof)
- - #18850 Fix ZapSelectTx to sync wallet spends (bvbfan)
- - #18923 Never schedule MaybeCompactWalletDB when `-flushwallet` is off (MarcoFalke)
- - #19441 walletdb: Don't reinitialize desc cache with multiple cache entries (achow101)
- - #18907 walletdb: Don't remove database transaction logs and instead error (achow101)
- - #19334 Introduce WalletDatabase abstract class (achow101)
- - #19335 Cleanup and separate BerkeleyDatabase and BerkeleyBatch (achow101)
- - #19102 Introduce and use DummyDatabase instead of dummy BerkeleyDatabase (achow101)
- - #19568 Wallet should not override signing errors (fjahr)
- - #17204 Do not turn `OP_1NEGATE` in scriptSig into `0x0181` in signing code (sipa) (meshcollider)
- - #19457 Cleanup wallettool salvage and walletdb extraneous declarations (achow101)
- - #15937 Add loadwallet and createwallet `load_on_startup` options (ryanofsky)
- - #16841 Replace GetScriptForWitness with GetScriptForDestination (meshcollider)
- - #14582 always do avoid partial spends if fees are within a specified range (kallewoof)
- - #19743 -maxapsfee follow-up (kallewoof)
- - #19289 GetWalletTx and IsMine require `cs_wallet` lock (promag)
- - #19671 Remove -zapwallettxes (achow101)
- - #19805 Avoid deserializing unused records when salvaging (achow101)
- - #19754 wallet, gui: Reload previously loaded wallets on startup (achow101)
- - #19738 Avoid multiple BerkeleyBatch in DelAddressBook (promag)
- - #19919 bugfix: make LoadWallet assigns status always (AkioNak)
- - #16378 The ultimate send RPC (Sjors)
- - #15454 Remove the automatic creation and loading of the default wallet (achow101)
- - #19501 `send*` RPCs in the wallet returns the "fee reason" (stackman27)
- - #20130 Remove db mode string (S3RK)
- - #19077 Add sqlite as an alternative wallet database and use it for new descriptor wallets (achow101)
- - #20125 Expose database format in getwalletinfo (promag)
- - #20198 Show name, format and if uses descriptors in bitcoin-wallet tool (jonasschnelli)
- - #20216 Fix buffer over-read in SQLite file magic check (theStack)
- - #20186 Make -wallet setting not create wallets (ryanofsky)
- - #20230 Fix bug when just created encrypted wallet cannot get address (hebasto)
- - #20282 Change `upgradewallet` return type to be an object (jnewbery)
- - #20220 Explicit fee rate follow-ups/fixes for 0.21 (jonatack)
- - #20199 Ignore (but warn) on duplicate -wallet parameters (jonasschnelli)
- - #20324 Set DatabaseStatus::SUCCESS in MakeSQLiteDatabase (MarcoFalke)
- - #20266 Fix change detection of imported internal descriptors (achow101)
- - #20153 Do not import a descriptor with hardened derivations into a watch-only wallet (S3RK)
- - #20344 Fix scanning progress calculation for single block range (theStack)
- - #19502 Bugfix: Wallet: Soft-fail exceptions within ListWalletDir file checks (luke-jr)
- - #20378 Fix potential division by 0 in WalletLogPrintf (jonasschnelli)
- - #18836 Upgradewallet fixes and additional tests (achow101)
- - #20139 Do not return warnings from UpgradeWallet() (stackman27)
- - #20305 Introduce `fee_rate` sat/vB param/option (jonatack)
- - #20426 Allow zero-fee fundrawtransaction/walletcreatefundedpsbt and other fixes (jonatack)
- - #20573 wallet, bugfix: allow send with string `fee_rate` amounts (jonatack)

### RPC and other APIs
- - #18574 cli: Call getbalances.ismine.trusted instead of getwalletinfo.balance (jonatack)
- - #17693 Add `generateblock` to mine a custom set of transactions (andrewtoth)
- - #18495 Remove deprecated migration code (vasild)
- - #18493 Remove deprecated "size" from mempool txs (vasild)
- - #18467 Improve documentation and return value of settxfee (fjahr)
- - #18607 Fix named arguments in documentation (MarcoFalke)
- - #17831 doc: Fix and extend getblockstats examples (asoltys)
- - #18785 Prevent valgrind false positive in `rest_blockhash_by_height` (ryanofsky)
- - #18999 log: Remove "No rpcpassword set" from logs (MarcoFalke)
- - #19006 Avoid crash when `g_thread_http` was never started (MarcoFalke)
- - #18594 cli: Display multiwallet balances in -getinfo (jonatack)
- - #19056 Make gettxoutsetinfo/GetUTXOStats interruptible (MarcoFalke)
- - #19112 Remove special case for unknown service flags (MarcoFalke)
- - #18826 Expose txinwitness for coinbase in JSON form from RPC (rvagg)
- - #19282 Rephrase generatetoaddress help, and use `PACKAGE_NAME` (luke-jr)
- - #16377 don't automatically append inputs in walletcreatefundedpsbt (Sjors)
- - #19200 Remove deprecated getaddressinfo fields (jonatack)
- - #19133 rpc, cli, test: add bitcoin-cli -generate command (jonatack)
- - #19469 Deprecate banscore field in getpeerinfo (jonatack)
- - #16525 Dump transaction version as an unsigned integer in RPC/TxToUniv (TheBlueMatt)
- - #19555 Deduplicate WriteHDKeypath() used in decodepsbt (theStack)
- - #19589 Avoid useless mempool query in gettxoutproof (MarcoFalke)
- - #19585 RPCResult Type of MempoolEntryDescription should be OBJ (stylesuxx)
- - #19634 Document getwalletinfo's `unlocked_until` field as optional (justinmoon)
- - #19658 Allow RPC to fetch all addrman records and add records to addrman (jnewbery)
- - #19696 Fix addnode remove command error (fjahr)
- - #18654 Separate bumpfee's psbt creation function into psbtbumpfee (achow101)
- - #19655 Catch listsinceblock `target_confirmations` exceeding block count (adaminsky)
- - #19644 Document returned error fields as optional if applicable (theStack)
- - #19455 rpc generate: print useful help and error message (jonatack)
- - #19550 Add listindices RPC (fjahr)
- - #19169 Validate provided keys for `query_options` parameter in listunspent (PastaPastaPasta)
- - #18244 fundrawtransaction and walletcreatefundedpsbt also lock manually selected coins (Sjors)
- - #14687 zmq: Enable TCP keepalive (mruddy)
- - #19405 Add network in/out connections to `getnetworkinfo` and `-getinfo` (jonatack)
- - #19878 rawtransaction: Fix argument in combinerawtransaction help message (pinheadmz)
- - #19940 Return fee and vsize from testmempoolaccept (gzhao408)
- - #13686 zmq: Small cleanups in the ZMQ code (domob1812)
- - #19386, #19528, #19717, #19849, #19994 Assert that RPCArg names are equal to CRPCCommand ones (MarcoFalke)
- - #19725 Add connection type to getpeerinfo, improve logs (amitiuttarwar)
- - #19969 Send RPC bug fix and touch-ups (Sjors)
- - #18309 zmq: Add support to listen on multiple interfaces (n-thumann)
- - #20055 Set HTTP Content-Type in bitcoin-cli (laanwj)
- - #19956 Improve invalid vout value rpc error message (n1rna)
- - #20101 Change no wallet loaded message to be clearer (achow101)
- - #19998 Add `via_tor` to `getpeerinfo` output (hebasto)
- - #19770 getpeerinfo: Deprecate "whitelisted" field (replaced by "permissions") (luke-jr)
- - #20120 net, rpc, test, bugfix: update GetNetworkName, GetNetworksInfo, regression tests (jonatack)
- - #20595 Improve heuristic hex transaction decoding (sipa)
- - #20731 Add missing description of vout in getrawtransaction help text (benthecarman)
- - #19328 Add gettxoutsetinfo `hash_type` option (fjahr)
- - #19731 Expose nLastBlockTime/nLastTXTime as last `block/last_transaction` in getpeerinfo (jonatack)
- - #19572 zmq: Create "sequence" notifier, enabling client-side mempool tracking (instagibbs)
- - #20002 Expose peer network in getpeerinfo; simplify/improve -netinfo (jonatack)

### GUI
- - #17905 Avoid redundant tx status updates (ryanofsky)
- - #18646 Use `PACKAGE_NAME` in exception message (fanquake)
- - #17509 Save and load PSBT (Sjors)
- - #18769 Remove bug fix for Qt < 5.5 (10xcryptodev)
- - #15768 Add close window shortcut (IPGlider)
- - #16224 Bilingual GUI error messages (hebasto)
- - #18922 Do not translate InitWarning messages in debug.log (hebasto)
- - #18152 Use NotificationStatus enum for signals to GUI (hebasto)
- - #18587 Avoid wallet tryGetBalances calls in WalletModel::pollBalanceChanged (ryanofsky)
- - #17597 Fix height of QR-less ReceiveRequestDialog (hebasto)
- - #17918 Hide non PKHash-Addresses in signing address book (emilengler)
- - #17956 Disable unavailable context menu items in transactions tab (kristapsk)
- - #17968 Ensure that ModalOverlay is resized properly (hebasto)
- - #17993 Balance/TxStatus polling update based on last block hash (furszy)
- - #18424 Use parent-child relation to manage lifetime of OptionsModel object (hebasto)
- - #18452 Fix shutdown when `waitfor*` cmds are called from RPC console (hebasto)
- - #15202 Add Close All Wallets action (promag)
- - #19132 lock `cs_main`, `m_cached_tip_mutex` in that order (vasild)
- - #18898 Display warnings as rich text (hebasto)
- - #19231 add missing translation.h include to fix build (fanquake)
- - #18027 "PSBT Operations" dialog (gwillen)
- - #19256 Change combiner for signals to `optional_last_value` (fanquake)
- - #18896 Reset toolbar after all wallets are closed (hebasto)
- - #18993 increase console command max length (10xcryptodev)
- - #19323 Fix regression in *txoutset* in GUI console (hebasto)
- - #19210 Get rid of cursor in out-of-focus labels (hebasto)
- - #19011 Reduce `cs_main` lock accumulation during GUI startup (jonasschnelli)
- - #19844 Remove usage of boost::bind (fanquake)
- - #20479 Fix QPainter non-determinism on macOS (0.21 backport) (laanwj)
- - gui#6 Do not truncate node flag strings in debugwindow peers details tab (Saibato)
- - gui#8 Fix regression in TransactionTableModel (hebasto)
- - gui#17 doc: Remove outdated comment in TransactionTablePriv (MarcoFalke)
- - gui#20 Wrap tooltips in the intro window (hebasto)
- - gui#30 Disable the main window toolbar when the modal overlay is shown (hebasto)
- - gui#34 Show permissions instead of whitelisted (laanwj)
- - gui#35 Parse params directly instead of through node (ryanofsky)
- - gui#39 Add visual accenting for the 'Create new receiving address' button (hebasto)
- - gui#40 Clarify block height label (hebasto)
- - gui#43 bugfix: Call setWalletActionsEnabled(true) only for the first wallet (hebasto)
- - gui#97 Relax GUI freezes during IBD (jonasschnelli)
- - gui#71 Fix visual quality of text in QR image (hebasto)
- - gui#96 Slight improve create wallet dialog (Sjors)
- - gui#102 Fix SplashScreen crash when run with -disablewallet (hebasto)
- - gui#116 Fix unreasonable default size of the main window without loaded wallets (hebasto)
- - gui#120 Fix multiwallet transaction notifications (promag)

### Build system
- - #18504 Drop bitcoin-tx and bitcoin-wallet dependencies on libevent (ryanofsky)
- - #18586 Bump gitian descriptors to 0.21 (laanwj)
- - #17595 guix: Enable building for `x86_64-w64-mingw32` target (dongcarl)
- - #17929 add linker optimisation flags to gitian & guix (Linux) (fanquake)
- - #18556 Drop make dist in gitian builds (hebasto)
- - #18088 ensure we aren't using GNU extensions (fanquake)
- - #18741 guix: Make source tarball using git-archive (dongcarl)
- - #18843 warn on potentially uninitialized reads (vasild)
- - #17874 make linker checks more robust (fanquake)
- - #18535 remove -Qunused-arguments workaround for clang + ccache (fanquake)
- - #18743 Add --sysroot option to mac os native compile flags (ryanofsky)
- - #18216 test, build: Enable -Werror=sign-compare (Empact)
- - #18928 don't pass -w when building for Windows (fanquake)
- - #16710 Enable -Wsuggest-override if available (hebasto)
- - #18738 Suppress -Wdeprecated-copy warnings (hebasto)
- - #18862 Remove fdelt_chk back-compat code and sanity check (fanquake)
- - #18887 enable -Werror=gnu (vasild)
- - #18956 enforce minimum required Windows version (7) (fanquake)
- - #18958 guix: Make V=1 more powerful for debugging (dongcarl)
- - #18677 Multiprocess build support (ryanofsky)
- - #19094 Only allow ASCII identifiers (laanwj)
- - #18820 Propagate well-known vars into depends (dongcarl)
- - #19173 turn on --enable-c++17 by --enable-fuzz (vasild)
- - #18297 Use pkg-config in BITCOIN_QT_CONFIGURE for all hosts including Windows (hebasto)
- - #19301 don't warn when doxygen isn't found (fanquake)
- - #19240 macOS toolchain simplification and bump (dongcarl)
- - #19356 Fix search for brew-installed BDB 4 on OS X (gwillen)
- - #19394 Remove unused `RES_IMAGES` (Bushstar)
- - #19403 improve `__builtin_clz*` detection (fanquake)
- - #19375 target Windows 7 when building libevent and fix ipv6 usage (fanquake)
- - #19331 Do not include server symbols in wallet (MarcoFalke)
- - #19257 remove BIP70 configure option (fanquake)
- - #18288 Add MemorySanitizer (MSan) in Travis to detect use of uninitialized memory (practicalswift)
- - #18307 Require pkg-config for all of the hosts (hebasto)
- - #19445 Update msvc build to use ISO standard C++17 (sipsorcery)
- - #18882 fix -Wformat-security check when compiling with GCC (fanquake)
- - #17919 Allow building with system clang (dongcarl)
- - #19553 pass -fcommon when building genisoimage (fanquake)
- - #19565 call `AC_PATH_TOOL` for dsymutil in macOS cross-compile (fanquake)
- - #19530 build LTO support into Apple's ld64 (theuni)
- - #19525 add -Wl,-z,separate-code to hardening flags (fanquake)
- - #19667 set minimum required Boost to 1.58.0 (fanquake)
- - #19672 make clean removes .gcda and .gcno files from fuzz directory (Crypt-iQ)
- - #19622 Drop ancient hack in gitian-linux descriptor (hebasto)
- - #19688 Add support for llvm-cov (hebasto)
- - #19718 Add missed gcov files to 'make clean' (hebasto)
- - #19719 Add Werror=range-loop-analysis (MarcoFalke)
- - #19015 Enable some commonly enabled compiler diagnostics (practicalswift)
- - #19689 build, qt: Add Qt version checking (hebasto)
- - #17396 modest Android improvements (icota)
- - #18405 Drop all of the ZeroMQ patches (hebasto)
- - #15704 Move Win32 defines to configure.ac to ensure they are globally defined (luke-jr)
- - #19761 improve sed robustness by not using sed (fanquake)
- - #19758 Drop deprecated and unused `GUARDED_VAR` and `PT_GUARDED_VAR` annotations (hebasto)
- - #18921 add stack-clash and control-flow protection options to hardening flags (fanquake)
- - #19803 Bugfix: Define and use `HAVE_FDATASYNC` correctly outside LevelDB (luke-jr)
- - #19685 CMake invocation cleanup (dongcarl)
- - #19861 add /usr/local/ to `LCOV_FILTER_PATTERN` for macOS builds (Crypt-iQ)
- - #19916 allow user to specify `DIR_FUZZ_SEED_CORPUS` for `cov_fuzz` (Crypt-iQ)
- - #19944 Update secp256k1 subtree (including BIP340 support) (sipa)
- - #19558 Split pthread flags out of ldflags and dont use when building libconsensus (fanquake)
- - #19959 patch qt libpng to fix powerpc build (fanquake)
- - #19868 Fix target name (hebasto)
- - #19960 The vcpkg tool has introduced a proper way to use manifests (sipsorcery)
- - #20065 fuzz: Configure check for main function (MarcoFalke)
- - #18750 Optionally skip external warnings (vasild)
- - #20147 Update libsecp256k1 (endomorphism, test improvements) (sipa)
- - #20156 Make sqlite support optional (compile-time) (luke-jr)
- - #20318 Ensure source tarball has leading directory name (MarcoFalke)
- - #20447 Patch `qt_intersect_spans` to avoid non-deterministic behavior in LLVM 8 (achow101)
- - #20505 Avoid secp256k1.h include from system (dergoegge)
- - #20527 Do not ignore Homebrew's SQLite on macOS (hebasto)
- - #20478 Don't set BDB flags when configuring without (jonasschnelli)
- - #20563 Check that Homebrew's berkeley-db4 package is actually installed (hebasto)
- - #19493 Fix clang build on Mac (bvbfan)

### Tests and QA
- - #18593 Complete impl. of `msg_merkleblock` and `wait_for_merkleblock` (theStack)
- - #18609 Remove REJECT message code (hebasto)
- - #18584 Check that the version message does not leak the local address (MarcoFalke)
- - #18597 Extend `wallet_dump` test to cover comments (MarcoFalke)
- - #18596 Try once more when RPC connection fails on Windows (MarcoFalke)
- - #18451 shift coverage from getunconfirmedbalance to getbalances (jonatack)
- - #18631 appveyor: Disable functional tests for now (MarcoFalke)
- - #18628 Add various low-level p2p tests (MarcoFalke)
- - #18615 Avoid accessing free'd memory in `validation_chainstatemanager_tests` (MarcoFalke)
- - #18571 fuzz: Disable debug log file (MarcoFalke)
- - #18653 add coverage for bitcoin-cli -rpcwait (jonatack)
- - #18660 Verify findCommonAncestor always initializes outputs (ryanofsky)
- - #17669 Have coins simulation test also use CCoinsViewDB (jamesob)
- - #18662 Replace gArgs with local argsman in bench (MarcoFalke)
- - #18641 Create cached blocks not in the future (MarcoFalke)
- - #18682 fuzz: `http_request` workaround for libevent < 2.1.1 (theStack)
- - #18692 Bump timeout in `wallet_import_rescan` (MarcoFalke)
- - #18695 Replace boost::mutex with std::mutex (hebasto)
- - #18633 Properly raise FailedToStartError when rpc shutdown before warmup finished (MarcoFalke)
- - #18675 Don't initialize PrecomputedTransactionData in txvalidationcache tests (jnewbery)
- - #18691 Add `wait_for_cookie_credentials()` to framework for rpcwait tests (jonatack)
- - #18672 Add further BIP37 size limit checks to `p2p_filter.py` (theStack)
- - #18721 Fix linter issue (hebasto)
- - #18384 More specific `feature_segwit` test error messages and fixing incorrect comments (gzhao408)
- - #18575 bench: Remove requirement that all benches use same testing setup (MarcoFalke)
- - #18690 Check object hashes in `wait_for_getdata` (robot-visions)
- - #18712 display command line options passed to `send_cli()` in debug log (jonatack)
- - #18745 Check submitblock return values (MarcoFalke)
- - #18756 Use `wait_for_getdata()` in `p2p_compactblocks.py` (theStack)
- - #18724 Add coverage for -rpcwallet cli option (jonatack)
- - #18754 bench: Add caddrman benchmarks (vasild)
- - #18585 Use zero-argument super() shortcut (Python 3.0+) (theStack)
- - #18688 fuzz: Run in parallel (MarcoFalke)
- - #18770 Remove raw-tx byte juggling in `mempool_reorg` (MarcoFalke)
- - #18805 Add missing `sync_all` to `wallet_importdescriptors.py` (achow101)
- - #18759 bench: Start nodes with -nodebuglogfile (MarcoFalke)
- - #18774 Added test for upgradewallet RPC (brakmic)
- - #18485 Add `mempool_updatefromblock.py` (hebasto)
- - #18727 Add CreateWalletFromFile test (ryanofsky)
- - #18726 Check misbehavior more independently in `p2p_filter.py` (robot-visions)
- - #18825 Fix message for `ECC_InitSanityCheck` test (fanquake)
- - #18576 Use unittest for `test_framework` unit testing (gzhao408)
- - #18828 Strip down previous releases boilerplate (MarcoFalke)
- - #18617 Add factor option to adjust test timeouts (brakmic)
- - #18855 `feature_backwards_compatibility.py` test downgrade after upgrade (achow101)
- - #18864 Add v0.16.3 backwards compatibility test, bump v0.19.0.1 to v0.19.1 (Sjors)
- - #18917 fuzz: Fix vector size problem in system fuzzer (brakmic)
- - #18901 fuzz: use std::optional for `sep_pos_opt` variable (brakmic)
- - #18888 Remove RPCOverloadWrapper boilerplate (MarcoFalke)
- - #18952 Avoid os-dependent path (fametrano)
- - #18938 Fill fuzzing coverage gaps for functions in consensus/validation.h, primitives/block.h and util/translation.h (practicalswift)
- - #18986 Add capability to disable RPC timeout in functional tests (rajarshimaitra)
- - #18530 Add test for -blocksonly and -whitelistforcerelay param interaction (glowang)
- - #19014 Replace `TEST_PREVIOUS_RELEASES` env var with `test_framework` option (MarcoFalke)
- - #19052 Don't limit fuzzing inputs to 1 MB for afl-fuzz (now: ? ? fuzzers) (practicalswift)
- - #19060 Remove global `wait_until` from `p2p_getdata` (MarcoFalke)
- - #18926 Pass ArgsManager into `getarg_tests` (glowang)
- - #19110 Explain that a bug should be filed when the tests fail (MarcoFalke)
- - #18965 Implement `base58_decode` (10xcryptodev)
- - #16564 Always define the `raii_event_tests` test suite (candrews)
- - #19122 Add missing `sync_blocks` to `wallet_hd` (MarcoFalke)
- - #18875 fuzz: Stop nodes in `process_message*` fuzzers (MarcoFalke)
- - #18974 Check that invalid witness destinations can not be imported (MarcoFalke)
- - #18210 Type hints in Python tests (kiminuo)
- - #19159 Make valgrind.supp work on aarch64 (MarcoFalke)
- - #19082 Moved the CScriptNum asserts into the unit test in script.py (gillichu)
- - #19172 Do not swallow flake8 exit code (hebasto)
- - #19188 Avoid overwriting the NodeContext member of the testing setup [-Wshadow-field] (MarcoFalke)
- - #18890 `disconnect_nodes` should warn if nodes were already disconnected (robot-visions)
- - #19227 change blacklist to blocklist (TrentZ)
- - #19230 Move base58 to own module to break circular dependency (sipa)
- - #19083 `msg_mempool`, `fRelay`, and other bloomfilter tests (gzhao408)
- - #16756 Connection eviction logic tests (mzumsande)
- - #19177 Fix and clean `p2p_invalid_messages` functional tests (troygiorshev)
- - #19264 Don't import asyncio to test magic bytes (jnewbery)
- - #19178 Make `mininode_lock` non-reentrant (jnewbery)
- - #19153 Mempool compatibility test (S3RK)
- - #18434 Add a test-security target and run it in CI (fanquake)
- - #19252 Wait for disconnect in `disconnect_p2ps` + bloomfilter test followups (gzhao408)
- - #19298 Add missing `sync_blocks` (MarcoFalke)
- - #19304 Check that message sends successfully when header is split across two buffers (troygiorshev)
- - #19208 move `sync_blocks` and `sync_mempool` functions to `test_framework.py` (ycshao)
- - #19198 Check that peers with forcerelay permission are not asked to feefilter (MarcoFalke)
- - #19351 add two edge case tests for CSubNet (vasild)
- - #19272 net, test: invalid p2p messages and test framework improvements (jonatack)
- - #19348 Bump linter versions (duncandean)
- - #19366 Provide main(?) function in fuzzer. Allow building uninstrumented harnesses with --enable-fuzz (practicalswift)
- - #19412 move `TEST_RUNNER_EXTRA` into native tsan setup (fanquake)
- - #19368 Improve functional tests compatibility with BSD/macOS (S3RK)
- - #19028 Set -logthreadnames in unit tests (MarcoFalke)
- - #18649 Add std::locale::global to list of locale dependent functions (practicalswift)
- - #19140 Avoid fuzzer-specific nullptr dereference in libevent when handling PROXY requests (practicalswift)
- - #19214 Auto-detect SHA256 implementation in benchmarks (sipa)
- - #19353 Fix mistakenly swapped "previous" and "current" lock orders (hebasto)
- - #19533 Remove unnecessary `cs_mains` in `denialofservice_tests` (jnewbery)
- - #19423 add functional test for txrelay during and after IBD (gzhao408)
- - #16878 Fix non-deterministic coverage of test `DoS_mapOrphans` (davereikher)
- - #19548 fuzz: add missing overrides to `signature_checker` (jonatack)
- - #19562 Fix fuzzer compilation on macOS (freenancial)
- - #19370 Static asserts for consistency of fee defaults (domob1812)
- - #19599 clean `message_count` and `last_message` (troygiorshev)
- - #19597 test decodepsbt fee calculation (count input value only once per UTXO) (theStack)
- - #18011 Replace current benchmarking framework with nanobench (martinus)
- - #19489 Fail `wait_until` early if connection is lost (MarcoFalke)
- - #19340 Preserve the `LockData` initial state if "potential deadlock detected" exception thrown (hebasto)
- - #19632 Catch decimal.InvalidOperation from `TestNodeCLI#send_cli` (Empact)
- - #19098 Remove duplicate NodeContext hacks (ryanofsky)
- - #19649 Restore test case for p2p transaction blinding (instagibbs)
- - #19657 Wait until `is_connected` in `add_p2p_connection` (MarcoFalke)
- - #19631 Wait for 'cmpctblock' in `p2p_compactblocks` when it is expected (Empact)
- - #19674 use throwaway _ variable for unused loop counters (theStack)
- - #19709 Fix 'make cov' with clang (hebasto)
- - #19564 `p2p_feefilter` improvements (logging, refactoring, speedup) (theStack)
- - #19756 add `sync_all` to fix race condition in wallet groups test (kallewoof)
- - #19727 Removing unused classes from `p2p_leak.py` (dhruv)
- - #19722 Add test for getblockheader verboseness (torhte)
- - #19659 Add a seed corpus generation option to the fuzzing `test_runner` (darosior)
- - #19775 Activate segwit in TestChain100Setup (MarcoFalke)
- - #19760 Remove confusing mininode terminology (jnewbery)
- - #19752 Update `wait_until` usage in tests not to use the one from utils (slmtpz)
- - #19839 Set appveyor VM version to previous Visual Studio 2019 release (sipsorcery)
- - #19830 Add tsan supp for leveldb::DBImpl::DeleteObsoleteFiles (MarcoFalke)
- - #19710 bench: Prevent thread oversubscription and decreases the variance of result values (hebasto)
- - #19842 Update the vcpkg checkout commit ID in appveyor config (sipsorcery)
- - #19507 Expand functional zmq transaction tests (instagibbs)
- - #19816 Rename wait until helper to `wait_until_helper` (MarcoFalke)
- - #19859 Fixes failing functional test by changing version (n-thumann)
- - #19887 Fix flaky `wallet_basic` test (fjahr)
- - #19897 Change `FILE_CHAR_BLOCKLIST` to `FILE_CHARS_DISALLOWED` (verretor)
- - #19800 Mockwallet (MarcoFalke)
- - #19922 Run `rpc_txoutproof.py` even with wallet disabled (MarcoFalke)
- - #19936 batch rpc with params (instagibbs)
- - #19971 create default wallet in extended tests (Sjors)
- - #19781 add parameterized constructor for `msg_sendcmpct()` (theStack)
- - #19963 Clarify blocksonly whitelistforcerelay test (t-bast)
- - #20022 Use explicit p2p objects where available (guggero)
- - #20028 Check that invalid peer traffic is accounted for (MarcoFalke)
- - #20004 Add signet witness commitment section parse tests (MarcoFalke)
- - #20034 Get rid of default wallet hacks (ryanofsky)
- - #20069 Mention commit id in scripted diff error (laanwj)
- - #19947 Cover `change_type` option of "walletcreatefundedpsbt" RPC (guggero)
- - #20126 `p2p_leak_tx.py` improvements (use MiniWallet, add `p2p_lock` acquires) (theStack)
- - #20129 Don't export `in6addr_loopback` (vasild)
- - #20131 Remove unused nVersion=1 in p2p tests (MarcoFalke)
- - #20161 Minor Taproot follow-ups (sipa)
- - #19401 Use GBT to get block versions correct (luke-jr)
- - #20159 `mining_getblocktemplate_longpoll.py` improvements (use MiniWallet, add logging) (theStack)
- - #20039 Convert amounts from float to decimal (prayank23)
- - #20112 Speed up `wallet_resendwallettransactions` with mockscheduler RPC (MarcoFalke)
- - #20247 fuzz: Check for addrv1 compatibility before using addrv1 serializer. Fuzz addrv2 serialization (practicalswift)
- - #20167 Add test for -blockversion (MarcoFalke)
- - #19877 Clarify `rpc_net` & `p2p_disconnect_ban functional` tests (amitiuttarwar)
- - #20258 Remove getnettotals/getpeerinfo consistency test (jnewbery)
- - #20242 fuzz: Properly initialize PrecomputedTransactionData (MarcoFalke)
- - #20262 Skip --descriptor tests if sqlite is not compiled (achow101)
- - #18788 Update more tests to work with descriptor wallets (achow101)
- - #20289 fuzz: Check for addrv1 compatibility before using addrv1 serializer/deserializer on CService (practicalswift)
- - #20290 fuzz: Fix DecodeHexTx fuzzing harness issue (practicalswift)
- - #20245 Run `script_assets_test` even if built --with-libs=no (MarcoFalke)
- - #20300 fuzz: Add missing `ECC_Start` to `descriptor_parse` test (S3RK)
- - #20283 Only try witness deser when checking for witness deser failure (MarcoFalke)
- - #20303 fuzz: Assert expected DecodeHexTx behaviour when using legacy decoding (practicalswift)
- - #20316 Fix `wallet_multiwallet` test issue on Windows (MarcoFalke)
- - #20326 Fix `ecdsa_verify` in test framework (stepansnigirev)
- - #20328 cirrus: Skip tasks on the gui repo main branch (MarcoFalke)
- - #20355 fuzz: Check for addrv1 compatibility before using addrv1 serializer/deserializer on CSubNet (practicalswift)
- - #20332 Mock IBD in `net_processing` fuzzers (MarcoFalke)
- - #20218 Suppress `epoll_ctl` data race (MarcoFalke)
- - #20375 fuzz: Improve coverage for CPartialMerkleTree fuzzing harness (practicalswift)
- - #19669 contrib: Fixup valgrind suppressions file (MarcoFalke)
- - #18879 valgrind: remove outdated suppressions (fanquake)
- - #19226 Add BerkeleyDatabase tsan suppression (MarcoFalke)
- - #20379 Remove no longer needed UBSan suppression (float divide-by-zero in validation.cpp) (practicalswift)
- - #18190, #18736, #18744, #18775, #18783, #18867, #18994, #19065,
  #19067, #19143, #19222, #19247, #19286, #19296, #19379, #19934,
  #20188, #20395 Add fuzzing harnessses (practicalswift)
- - #18638 Use mockable time for ping/pong, add tests (MarcoFalke)
- - #19951 CNetAddr scoped ipv6 test coverage, rename scopeId to `m_scope_id` (jonatack)
- - #20027 Use mockable time everywhere in `net_processing` (sipa)
- - #19105 Add Muhash3072 implementation in Python (fjahr)
- - #18704, #18752, #18753, #18765, #18839, #18866, #18873, #19022,
  #19023, #19429, #19552, #19778, #20176, #20179, #20214, #20292,
  #20299, #20322 Fix intermittent test issues (MarcoFalke)
- - #20390 CI/Cirrus: Skip `merge_base` step for non-PRs (luke-jr)
- - #18634 ci: Add fuzzbuzz integration configuration file (practicalswift)
- - #18591 Add C++17 build to Travis (sipa)
- - #18581, #18667, #18798, #19495, #19519, #19538 CI improvements (hebasto)
- - #18683, #18705, #18735, #18778, #18799, #18829, #18912, #18929,
  #19008, #19041, #19164, #19201, #19267, #19276, #19321, #19371,
  #19427, #19730, #19746, #19881, #20294, #20339, #20368 CI improvements (MarcoFalke)
- - #20489, #20506 MSVC CI improvements (sipsorcery)

### Miscellaneous
- - #18713 scripts: Add macho stack canary check to security-check.py (fanquake)
- - #18629 scripts: Add pe .reloc section check to security-check.py (fanquake)
- - #18437 util: `Detect posix_fallocate()` instead of assuming (vasild)
- - #18413 script: Prevent ub when computing abs value for num opcode serialize (pierreN)
- - #18443 lockedpool: avoid sensitive data in core files (FreeBSD) (vasild)
- - #18885 contrib: Move optimize-pngs.py script to the maintainer repo (MarcoFalke)
- - #18317 Serialization improvements step 6 (all except wallet/gui) (sipa)
- - #16127 More thread safety annotation coverage (ajtowns)
- - #19228 Update libsecp256k1 subtree (sipa)
- - #19277 util: Add assert identity function (MarcoFalke)
- - #19491 util: Make assert work with any value (MarcoFalke)
- - #19205 script: `previous_release.sh` rewritten in python (bliotti)
- - #15935 Add <datadir>/settings.json persistent settings storage (ryanofsky)
- - #19439 script: Linter to check commit message formatting (Ghorbanian)
- - #19654 lint: Improve commit message linter in travis (fjahr)
- - #15382 util: Add runcommandparsejson (Sjors)
- - #19614 util: Use `have_fdatasync` to determine fdatasync() use (fanquake)
- - #19813 util, ci: Hard code previous release tarball checksums (hebasto)
- - #19841 Implement Keccak and `SHA3_256` (sipa)
- - #19643 Add -netinfo peer connections dashboard (jonatack)
- - #15367 feature: Added ability for users to add a startup command (benthecarman)
- - #19984 log: Remove static log message "Initializing chainstate Chainstate [ibd] @ height -1 (null)" (practicalswift)
- - #20092 util: Do not use gargs global in argsmanager member functions (hebasto)
- - #20168 contrib: Fix `gen_key_io_test_vectors.py` imports (MarcoFalke)
- - #19624 Warn on unknown `rw_settings` (MarcoFalke)
- - #20257 Update secp256k1 subtree to latest master (sipa)
- - #20346 script: Modify security-check.py to use "==" instead of "is" for literal comparison (tylerchambers)
- - #18881 Prevent UB in DeleteLock() function (hebasto)
- - #19180, #19189, #19190, #19220, #19399 Replace RecursiveMutex with Mutex (hebasto)
- - #19347 Make `cs_inventory` nonrecursive (jnewbery)
- - #19773 Avoid recursive lock in IsTrusted (promag)
- - #18790 Improve thread naming (hebasto)
- - #20140 Restore compatibility with old CSubNet serialization (sipa)
- - #17775 DecodeHexTx: Try case where txn has inputs first (instagibbs)

### Documentation
- - #18502 Update docs for getbalance (default minconf should be 0) (uzyn)
- - #18632 Fix macos comments in release-notes (MarcoFalke)
- - #18645 Update thread information in developer docs (jnewbery)
- - #18709 Note why we can't use `thread_local` with glibc back compat (fanquake)
- - #18410 Improve commenting for coins.cpp|h (jnewbery)
- - #18157 fixing init.md documentation to not require rpcpassword (jkcd)
- - #18739 Document how to fuzz Bitcoin Core using Honggfuzz (practicalswift)
- - #18779 Better explain GNU ld's dislike of ld64's options (fanquake)
- - #18663 Mention build docs in README.md (saahilshangle)
- - #18810 Update rest info on block size and json (chrisabrams)
- - #18939 Add c++17-enable flag to fuzzing instructions (mzumsande)
- - #18957 Add a link from ZMQ doc to ZMQ example in contrib/ (meeDamian)
- - #19058 Drop protobuf stuff (hebasto)
- - #19061 Add link to Visual Studio build readme (maitrebitcoin)
- - #19072 Expand section on Getting Started (MarcoFalke)
- - #18968 noban precludes maxuploadtarget disconnects (MarcoFalke)
- - #19005 Add documentation for 'checklevel' argument in 'verifychain' RPC? (kcalvinalvin)
- - #19192 Extract net permissions doc (MarcoFalke)
- - #19071 Separate repository for the gui (MarcoFalke)
- - #19018 fixing description of the field sequence in walletcreatefundedpsbt RPC method (limpbrains)
- - #19367 Span pitfalls (sipa)
- - #19408 Windows WSL build recommendation to temporarily disable Win32 PE support (sipsorcery)
- - #19407 explain why passing -mlinker-version is required when cross-compiling (fanquake)
- - #19452 afl fuzzing comment about afl-gcc and afl-g++ (Crypt-iQ)
- - #19258 improve subtree check instructions (Sjors)
- - #19474 Use precise permission flags where possible (MarcoFalke)
- - #19494 CONTRIBUTING.md improvements (jonatack)
- - #19268 Add non-thread-safe note to FeeFilterRounder::round() (hebasto)
- - #19547 Update macOS cross compilation dependencies for Focal (hebasto)
- - #19617 Clang 8 or later is required with `FORCE_USE_SYSTEM_CLANG` (fanquake)
- - #19639 Remove Reference Links #19582 (RobertHosking)
- - #19605 Set `CC_FOR_BUILD` when building on OpenBSD (fanquake)
- - #19765 Fix getmempoolancestors RPC result doc (MarcoFalke)
- - #19786 Remove label from good first issue template (MarcoFalke)
- - #19646 Updated outdated help command for getblocktemplate (jakeleventhal)
- - #18817 Document differences in bitcoind and bitcoin-qt locale handling (practicalswift)
- - #19870 update PyZMQ install instructions, fix `zmq_sub.py` file permissions (jonatack)
- - #19903 Update build-openbsd.md with GUI support (grubles)
- - #19241 help: Generate checkpoint height from chainparams (luke-jr)
- - #18949 Add CODEOWNERS file to automatically nominate PR reviewers (adamjonas)
- - #20014 Mention signet in -help output (hebasto)
- - #20015 Added default signet config for linearize script (gr0kchain)
- - #19958 Better document features of feelers (naumenkogs)
- - #19871 Clarify scope of eviction protection of outbound block-relay peers (ariard)
- - #20076 Update and improve files.md (hebasto)
- - #20107 Collect release-notes snippets (MarcoFalke)
- - #20109 Release notes and followups from 19339 (glozow)
- - #20090 Tiny followups to new getpeerinfo connection type field (amitiuttarwar)
- - #20152 Update wallet files in files.md (hebasto)
- - #19124 Document `ALLOW_HOST_PACKAGES` dependency option (skmcontrib)
- - #20271 Document that wallet salvage is experimental (MarcoFalke)
- - #20281 Correct getblockstats documentation for `(sw)total_weight` (shesek)
- - #20279 release process updates/fixups (jonatack)
- - #20238 Missing comments for signet parameters (decryp2kanon)
- - #20756 Add missing field (permissions) to the getpeerinfo help (amitiuttarwar)
- - #20668 warn that incoming conns are unlikely when not using default ports (adamjonas)
- - #19961 tor.md updates (jonatack)
- - #19050 Add warning for rest interface limitation (fjahr)
- - #19390 doc/REST-interface: Remove stale info (luke-jr)
- - #19344 docs: update testgen usage example (Bushstar)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - 10xcryptodev
- - Aaron Clauson
- - Aaron Hook
- - Adam Jonas
- - Adam Soltys
- - Adam Stein
- - Akio Nakamura
- - Alex Willmer
- - Amir Ghorbanian
- - Amiti Uttarwar
- - Andrew Chow
- - Andrew Toth
- - Anthony Fieroni
- - Anthony Towns
- - Antoine Poinsot
- - Antoine Riard
- - Ben Carman
- - Ben Woosley
- - Benoit Verret
- - Brian Liotti
- - Bushstar
- - Calvin Kim
- - Carl Dong
- - Chris Abrams
- - Chris L
- - Christopher Coverdale
- - codeShark149
- - Cory Fields
- - Craig Andrews
- - Damian Mee
- - Daniel Kraft
- - Danny Lee
- - David Reikher
- - DesWurstes
- - Dhruv Mehta
- - Duncan Dean
- - Elichai Turkel
- - Elliott Jin
- - Emil Engler
- - Ethan Heilman
- - eugene
- - Fabian Jahr
- - fanquake
- - Ferdinando M. Ametrano
- - freenancial
- - furszy
- - Gillian Chu
- - Gleb Naumenko
- - Glenn Willen
- - Gloria Zhao
- - glowang
- - gr0kchain
- - Gregory Sanders
- - grubles
- - gzhao408
- - Harris
- - Hennadii Stepanov
- - Hugo Nguyen
- - Igor Cota
- - Ivan Metlushko
- - Ivan Vershigora
- - Jake Leventhal
- - James O'Beirne
- - Jeremy Rubin
- - jgmorgan
- - Jim Posen
- - ?jkcd?
- - jmorgan
- - John Newbery
- - Johnson Lau
- - Jon Atack
- - Jonas Schnelli
- - Jonathan Schoeller
- - Jo?o Barbosa
- - Justin Moon
- - kanon
- - Karl-Johan Alm
- - Kiminuo
- - Kristaps Kaupe
- - lontivero
- - Luke Dashjr
- - Marcin Jachymiak
- - MarcoFalke
- - Martin Ankerl
- - Martin Zumsande
- - maskoficarus
- - Matt Corallo
- - Matthew Zipkin
- - MeshCollider
- - Miguel Herranz
- - MIZUTA Takeshi
- - mruddy
- - Nadav Ivgi
- - Neha Narula
- - Nicolas Thumann
- - Niklas G?gge
- - Nima Yazdanmehr
- - nsa
- - nthumann
- - Oliver Gugger
- - pad
- - pasta
- - Peter Bushnell
- - pierrenn
- - Pieter Wuille
- - practicalswift
- - Prayank
- - Ra?l Mart?nez (RME)
- - RandyMcMillan
- - Rene Pickhardt
- - Riccardo Masutti
- - Robert
- - Rod Vagg
- - Roy Shao
- - Russell Yanofsky
- - Saahil Shangle
- - sachinkm77
- - saibato
- - Samuel Dobson
- - sanket1729
- - Sebastian Falbesoner
- - Seleme Topuz
- - Sishir Giri
- - Sjors Provoost
- - skmcontrib
- - Stepan Snigirev
- - Stephan Oeste
- - Suhas Daftuar
- - t-bast
- - Tom Harding
- - Torhte Butler
- - TrentZ
- - Troy Giorshev
- - tryphe
- - Tyler Chambers
- - U-Zyn Chua
- - Vasil Dimov
- - wiz
- - Wladimir J. van der Laan

As well as to everyone that helped with translations on
[Transifex](https://www.transifex.com/bitcoin/bitcoin/).

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAmAAS08ACgkQHkrtYphs
0l1GQgf/R7yRDnaAiyvnIkpgO9LE5J6zjr8Ll3pc3xNEPuqRikFo5F3CQJpiFO22
kvoasiXzHNJxGxYiiKlDdC+uHXj5mmlMi6yewLHa+w9gWf4XnEAIa6jhKmUjGQgD
hLB44+g9d64lY+moBl4pi3mjbVxdTzSF7V1ZEvq3pjiOIvVN0jyLkW1yv2CRTuSO
6IqTr0TqlNRtty+yfObycGAW/K/P+WWKbbfSulvDICtMt8MlcFODlc3pPXa3G+tD
AC7B17LQsNX6veIBQxksm/pH5E/B4aYsuV65gweSrdklAwLRAAVU27zKr3flgBzR
U58PFN0TycoDQAICy8Sjffd933bjVw==
=nyFT
-----END PGP SIGNATURE-----


From achow101-lists at achow101.com  Thu Jan 14 17:07:44 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Thu, 14 Jan 2021 17:07:44 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <87a6tk9s7t.fsf@rustcorp.com.au>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <87wnwpabq6.fsf@rustcorp.com.au>
 <f20b7586-26b5-2250-322c-3004563f561e@achow101.com>
 <87a6tk9s7t.fsf@rustcorp.com.au>
Message-ID: <40f91a9a-6905-ad94-2824-16b43a0fa1fa@achow101.com>



On 1/7/21 7:40 PM, Rusty Russell wrote:
> Andrew Chow <achow101-lists at achow101.com> writes:
>> Hi Rusty,
>>
>> On 1/6/21 6:26 PM, Rusty Russell wrote:
>>> Hi Andrew et al,
>>>
>>>           Very excited to see this progress; thanks for doing all the
>>> work!  Sorry for the delayed feedback, I didn't get to this before the
>>> break.
>>>
>>>> Additionally, I would like to add a new global field:
>>>> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>>>>    ? * Key: empty
>>>>    ? * Value: A single byte as a boolean. 0 for False, 1 for True. All
>>>> other values ore prohibited. Must be omitted for PSBTv0, may be omitted
>>>> in PSBTv2.
>>>>
>>>> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
>>>> outputs can be added to the PSBT. This flag may be set to True when
>>>> inputs and outputs are being updated, signed, and finalized. However
>>>> care must be taken when there are existing signatures. If this field is
>>>> omitted or set to False, no further inputs and outputs may be added to
>>>> the PSBT.
>>> I wonder if this can be flagged simply by omitting the (AFAICT
>>> redundant) PSBT_GLOBAL_INPUT_COUNT and PSBT_GLOBAL_OUTPUT_COUNT?  What
>>> are the purposes of those fields?
>> The purpose of those fields is to know how many input and output maps
>> there are. Without PSBT_GLOBAL_UNSIGNED_TX, there is no way to determine
>> whether a map is an input map or an output map. So the counts are there
>> to allow that.
> Ah, yeah, you need at least the number of input maps :(
>
> It's generally preferable to have sections be self-describing;
> internally if you have a function which takes all the input maps you
> should be able to trivially tell if you're handed the output maps by
> mistake.  Similarly, it would have been nice to have an input map be a
> distinctly marked type from global or output maps.
>
> Nonetheless, that's a bigger change.  You could just require a double-00
> terminator between the global, input and output sections though.
Changing that is a bigger change and I'd rather keep this as minimal as 
possible. Having only new fields is simpler.

>>> For our uses, there would be no signatures at this stage; it's simply a
>>> subdivision of the Creator role.  This role would be terminated by
>>> removing the under-construction marker.  For this, it could be clear
>>> that such an under-construction PSBT SHOULD NOT be signed.
>> There are some protocols where signed inputs are added to transactions.
> Sure, but you can't solve every problem.  We've now created the
> possibility that a PSBT is "under construction" but can't be modified,
> *and* a very invasive requirement to determine that.
>
> I disagree with Andrew's goal here:
>
>>    1. PSBT provides no way to modify the set of inputs or outputs after the
>>       Creator role is done.
> It's simpler if, "the under-construction PSBT can be used within the
> Creator role, which can now have sub-roles".
>
> If you really want to allow this (and I think we need to explore
> concrete examples to justify this complexity!), better to add data to
> PSBT_GLOBAL_UNDER_CONSTRUCTION:
> 1. a flag to indicate whether inputs are modifiable.
> 2. a flag to indicate whether outputs are modifiable.
> 3. a bitmap of what inputs are SIGHASH_SINGLE.
>
> If you add a signature which is not SIGHASH_NONE, you clear the "outputs
> modifiable" flag.  If you add a signature which is not
> SIGHASH_ANYONECANPAY, you clear the "inputs modifiable" flag.  If you
> clear both flags, you remove the PSBT_GLOBAL_UNDER_CONSTRUCTION
> altogether.  You similarly set the bitmap depending on whether all sigs
> are SIGHASH_SINGLE.
I think we do need to support adding signed inputs and adding inputs to 
signed transactions. Someone had asked for this feature before. 
Additionally Nicolas Dorier informed me that his NTumbleBit project does 
those things.

In that case, I will include your suggestions for 
PSBT_GLOBAL_UNDER_CONSTRUCTION in the BIP.


Andrew Chow
>
> Cheers,
> Rusty.



From kevin at revault.dev  Thu Jan 14 18:17:09 2021
From: kevin at revault.dev (Kevin Loaec)
Date: Thu, 14 Jan 2021 18:17:09 +0000
Subject: [bitcoin-dev] Hardware wallets and "advanced" Bitcoin features
Message-ID: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>

Hello everyone,

I would like to start a discussion on improving Hardware Wallets.

My approach to this right now is from a vault protocol we are developing (Revault, [1]), and its Hardware Wallet
requirements. I started working on a Github Issue in our repo [2], other people recommended us to do a more general
discussion on the mailing list instead as it could benefit many other protocols and users.
This email discusses improvements that would benefit everyone, and some that are more suitable for "layer 2" or pre-
signed transactions protocols.
The goal is to spark discussions and hopefully iterate to a more secure and more usable hardware ecosystem for all
bitcoiners.
While I mainly foresee issues/improvements that may affect Revault, I would be really happy to see people joining this
thread with any other ideas and remarks that would benefit some parts of Bitcoin that I overlooked.



Prior work on similar problematics:
===================================
- ZmnSCPx
j: [Lightning-dev] Speculations on hardware wallet support for Lightning [3]
- mflaxman: Known Issues: Verifying a Receive Address [4]
- ksedgwic and devrandom01: Lightning-signer [5]
- benma: How nearly all personal hardware wallet multisig setups are insecure [6]


The postulate we start from is that Hardware Wallets (HW) are useful to mitigate the compromission of the day-to-day
device of a user. They mainly prevent private-key extraction today, and aren't very suitable against an attack on the
transaction being signed, as explained further.
To make this discussion security-focused, let's assume the general purpose device (laptop, for example) is compromised
with a malware implanted by an attacker, capable of modifying PSBTs, displayed addresses, etc.

Our study so far:


Output Script Parsing:
======================
Problem: A typical HW today would display the "destination" of a transaction in the form of a bitcoin address. A user
would generally compare this wit
h the address displayed on his laptop screen... which might have been compromised
already. The correct usage would be for a user to verify this address on a third device (mobile phone, for example).
This is weak security and bad user experience.
Proposed improvement: The HW should display the Bitcoin Script itself when possible (including the unlock conditions).
The best way to do so would be to lift this Script to a more user-friendly format such as a MiniScript Policy display,
but anything would be better than an "address".
This applies to pre-signed transaction protocols especially well as the template of these transactions could be known
and recognized by the HW. Typically for Revault, the HW could display: "Unvault Transaction, all expected pubkeys
present in the script".


Pubkey Interpretation:
======================
Problem: currently HW cannot "identify" addresses or keys.
Proposed improvement: The HW could know pubkeys or xpubs it does not hold the private keys 
for, and display a label (or
understand it for logic reasons, such as "expected pubkeys" as the previous example). Going further, the xpubs could be
aliased the first time they are entered/verified (as part of, say, an initial setup ceremony) for instance with the
previously mentioned Miniscript policy: or(pk(Alice), and(pk(Bob), after(42))).
This should be done in the Secure Element if possible to avoid physical compromission, but would be a strong improvement
versus a day-to-day laptop in any case.


Better Bitcoin Compatibility:
=============================
Problem: most HW cannot interpret some Script OPs such as OP_CSV, or any conditional outputs. This is a major issue for
anyone using Bitcoin "advanced" features. Related to this are the Sighash flags: most HW do not support most Sighash
flags. Kind of annoying for a signing device. Then there is PSBT support and the maximum transaction size limit for
these: we need more transparency from HW manufacturers on their li
mitations.
Solution: Make Bitcoin HW actually compatible with Bitcoin :D


Inputs (mainly for pre-signed Tx):
==================================
Problem: Poisoned inputs are a major risk for HW as they don't know the UTXO set. While this can be exploited for fee
attacks, it is a bigger threat to pre-signed transactions protocols. Once any input of a (pre-signed)transaction is
spent, this transaction isn't valid anymore. Most pre-signed transactions protocols are used today as a form of defense
mechanism, spending any input would mean incapacitating the entire defense mechanism.
Proposed improvement: for protocols that requires it, keeping track of inputs already signed once would be extremely
helpful. Going further, most of these protocols require to follow a specific signing order (typically the "clawback"
first, then the regular spend path) so adding a way to check that a "clawback" has been signed first, with the same
input, would be very helpful. All of this on the dev
ice itself.




I understand some of these changes may be very difficult, especially given the low memory and computational power of
secure elements. However I truly believe most of these points are a MUST have for any decent security. If you don't
assume the computer on which the transaction is crafted is compromised, then you don't need a hardware wallet. If you
assume it may be compromised, then the HW needs to be able to defend against those.

Revault does not plan on building hardware wallets, we hope existing and upcoming manufacturers will implement a strong
security that we could use for the Revault protocol users. Vault users will likely hold very large sums and would be
happy to pay a high premium for more secure HW. This will hopefully encourage existing players to keep on improving
their devices and that will ultimately benefit us all.

Feel free to reply with your comments or adding suggestions, I am not a hardware wallet expert and would take criticism
wit
hout being offended.

Kind Regards,
Kevin Loaec

[1]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017835.html
[2]: https://github.com/re-vault/practical-revault/issues/59
[3]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002425.html
[4]: https://btcguide.github.io/known-issues/verify-receive-address
[5]: https://gitlab.com/lightning-signer/docs
[6]: https://shiftcrypto.ch/blog/how-nearly-all-personal-hardware-wallet-multisig-setups-are-insecure/

-------------- next part --------------
A non-text attachment was scrubbed...
Name: publickey - kevin at revault.dev - 7c1d686c.asc
Type: application/pgp-keys
Size: 643 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210114/7adc4c33/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 233 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210114/7adc4c33/attachment.sig>

From ZmnSCPxj at protonmail.com  Fri Jan 15 00:28:21 2021
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 15 Jan 2021 00:28:21 +0000
Subject: [bitcoin-dev] Hardware wallets and "advanced" Bitcoin features
In-Reply-To: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>
References: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>
Message-ID: <IUjfIb-kgkDrL-Lq2aezCk5sjSoICBCUEZbchHqLDFStputPn0Y8xmPHdIwg6tEwZIMI-075CMO1jwy4FgIhhTgDclpdJXwRYlrESFDqfSc=@protonmail.com>

Good Morning Kevin,

>     Inputs (mainly for pre-signed Tx):
>     ==================================
>     Problem: Poisoned inputs are a major risk for HW as they don't know the UTXO set. While this can be exploited for fee
>     attacks, it is a bigger threat to pre-signed transactions protocols. Once any input of a (pre-signed)transaction is
>     spent, this transaction isn't valid anymore. Most pre-signed transactions protocols are used today as a form of defense
>     mechanism, spending any input would mean incapacitating the entire defense mechanism.
>     Proposed improvement: for protocols that requires it, keeping track of inputs already signed once would be extremely
>     helpful. Going further, most of these protocols require to follow a specific signing order (typically the "clawback"
>     first, then the regular spend path) so adding a way to check that a "clawback" has been signed first, with the same
>     input, would be very helpful. All of this on the dev
>     ice itself.

This requires the hardware device to maintain some state in order to remember that the clawback has been signed before.
My post on HW devices for Lightning (which you already linked) contains a suggestion to use a Merklized persistent data structure to maintain state for the hardware device, with a majority of the state storage on the trust-minimized software.

The primary issue here is that we have a base assumption that the hardware wallet cannot be sophisticated enough to have Internet access; "do not enter seed words on an online device", as the typical advice goes.
Most clawback transactions are time-based, and *must* be broadcast at a particular blockheight.
Yet if the hardware wallet cannot be an online device, then it cannot know the current blockheight is now at a time when the clawback transaction *must* be broadcast.

Thus, the hardware must always tr\*st the software to actually perform the clawback in that case.
In protocols where clawbacks are at all necessary, often the counterparty can have an advantage / can steal if the clawback is not broadcast in a timely manner, thus the software that is corrupted by the counterparty can be corrupted to simply not broadcast the clawback.

If the software on an online device cannot be tr\*sted (which is the model that hardware wallets use) then the software cannot be tr\*sted to provide correct information on the current blockheight to the offline hardware device, and cannot be tr\*sted to use clawback transactions.

It seems to me that we cannot use the same model of "do not enter seed words on an online device" for any protocol with a time-based clawback component (and honestly there seems to be no clawback mechanism that is not time-based).

Ultimately, I consider the blockchain as a proof of time passing, and as the blockchain is an online structure, we can only get at that proof by going online and actively searching for the block tip.
Yet going online increases our attack surface.


Regards,
ZmnSCPxj

From nakagat at gmail.com  Fri Jan 15 08:01:24 2021
From: nakagat at gmail.com (nakagat)
Date: Fri, 15 Jan 2021 17:01:24 +0900
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
Message-ID: <CAHk9a9d_xm2nO1t5GsLJiny1V3H=uv8jGuUTywQetZQOXxyG9w@mail.gmail.com>

Dear Pieter,

I read the BIP draft of Bech32m and implemented it in Go.

Let me ask you one question.
Does Checksum have to be fixed?
The 'bech32_verify_checksum' function has hrp and data as parameters,
so how about committing Checksum with these two values?

For example, calculate Checksum from hrp and data using hash, chacha20, etc.

Thank you.
Takatoshi Nakagawa

2021?1?5?(?) 9:14 Pieter Wuille via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org>:
>
> Hello all,
>
> here is a BIP draft for changing the checksum in native segwit addresses for v1 and higher, following the discussion in https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-December/018293.html
>
> Overall, the idea is:
> * Define a new encoding which is a tweaked variant of Bech32, called Bech32m. It refers to the Bech32 section of BIP173, which remains in effect.
> * Define a new segwit address encoding which replaces the corresponding section in BIP173. It prescribes using Bech32 for v0 witness addresses, and Bech32m for other versions.
>
> Comments, suggestions, ideas?
>
> Cheers,
>
> --
> Pieter
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From achow101-lists at achow101.com  Fri Jan 15 17:28:09 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Fri, 15 Jan 2021 17:28:09 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <40089cb5-8d68-1868-c87b-241f2bd747fb@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <40089cb5-8d68-1868-c87b-241f2bd747fb@achow101.com>
Message-ID: <e87f1e08-4bf2-8bf5-d408-3c0b603b8a7f@achow101.com>

Hi All,

I've made some reorganization changes to the way that new PSBT versions 
should be handled in BIP 174 (see 
https://github.com/bitcoin/bips/pull/1055) so PSBTv2 will be submitted 
as a separate BIP. The full document can be read at 
https://github.com/achow101/bips/blob/psbt2/bip-psbt2.mediawiki and I 
have also included it in this email.

I've included Rusty's suggestion for PSBT_GLOBAL_UNDER_CONSTRUCTION and 
made a few modifications. First, the field will be named 
PSBT_GLOBAL_TX_MODIFIABLE and only include the inputs modifiable and 
outputs modifiable flags. The SIGHASH_SINGLE bitmap will be included as 
a separate field PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS. This allows most 
PSBTs to not have to carry around a useless bitmap.

Andrew

***

<pre>
 ? BIP: PSBTv2
 ? Layer: Applications
 ? Title: PSBT Version 2
 ? Author: Andrew Chow <achow101 at gmail.com>
 ? Comments-Summary: No comments yet.
 ? Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-PSBT2
 ? Status: Draft
 ? Type: Standards Track
 ? Created: 2021-01-14
 ? License: BSD-2-Clause
</pre>

==Introduction==

===Abstract===

This document proposes a second version of the Partially Signed Bitcoin 
Transaction format
described in BIP 174 which allows for inputs and outputs to be added to 
the PSBT after creation.

===Copyright===

This BIP is licensed under the 2-clause BSD license.

===Motivation===

Partially Signed Bitcoin Transaction Version 0 as described in BIP 174 
is unable to have new
inputs and outputs be added to the transaction. The fixed global 
unsigned transaction
cannot be changed which prevents any additional inputs or outputs to be 
added.
PSBT Version 2 is intended to rectify this problem.

An additional benficial side effect is that all information for a given 
input or output will be
provided by its <tt><input-map></tt> or <tt><output-map></tt>. With 
Version 0, to retrieve
all of the information for an input or output, data would need to be 
found in two locations:
the <tt><input-map></tt>/<tt><output-map></tt> and the global unsigned 
transaction. PSBT
Version 2 now moves all related information to one place.

==Specification==

PSBT Version 2 (PSBTv2) only specifies new fields and field 
inclusion/exclusion requirements.

<tt>PSBT_GLOBAL_UNSIGNED_TX</tt> must be excluded in PSBTv2.
<tt>PSBT_GLOBAL_VERSION</tt> must be included in PSBTv2 and set to 
version number 2<ref>'''What happened to version number 1?'''
Version number 1 is skipped because PSBT Version 0 has been colloquially 
referred to as version 1. Originally this BIP was to be
version 1, but because it has been colloquially referred to as version 2 
during its design phrase, it was decided to change the
version number to 2 so that there would not be any confusion</ref>.

The new global types for PSBT Version 2 are as follows:

{|
! Name
! <tt><keytype></tt>
! <tt><keydata></tt>
! <tt><keydata></tt> Description
! <tt><valuedata></tt>
! <tt><valuedata></tt> Description
! Versions Requiring Inclusion
! Versions Requiring Exclusion
! Versions Allowing Inclusion
|-
| Transaction Version
| <tt>PSBT_GLOBAL_TX_VERSION = 0x02</tt>
| None
| No key data
| <tt><32-bit uint></tt>
| The 32-bit little endian signed integer representing the version 
number of the transaction being created. Note that this is not the same 
as the PSBT version number specified by the PSBT_GLOBAL_VERSION field.
| 2
| 0
| 2
|-
| Fallback Locktime
| <tt>PSBT_GLOBAL_FALLBACK_LOCKTIME = 0x03</tt>
| None
| No key data
| <tt><32-bit uint></tt>
| The 32-bit little endian unsigned integer representing the transaction 
locktime to use if no inputs specify a required locktime.
|
| 0
| 2
|-
| Input Count
| <tt>PSBT_GLOBAL_INPUT_COUNT = 0x04</tt>
| None
| No key data
| <tt><compact size uint></tt>
| Compact size unsigned integer representing the number of inputs in 
this PSBT.
| 2
| 0
| 2
|-
| Output Count
| <tt>PSBT_GLOBAL_OUTPUT_COUNT = 0x05</tt>
| None
| No key data
| <tt><compact size uint></tt>
| Compact size unsigned integer representing the number of outputs in 
this PSBT.
| 2
| 0
| 2
|-
| Transaction Modifiable Flags
| <tt>PSBT_GLOBAL_TX_MODIFIABLE = 0x06</tt>
| None
| No key data
| <tt><single byte boolean> <single byte boolean></tt>
| A single byte boolean (0 for False, 1 for True) representing whether 
inputs can be modified, referred to as the Inputs Modifiable Flag. This 
is followed by a single byte boolean representing whether outputs can be 
modified, referred to as the Outputs Modifiable Flag.
|
| 0
| 2
|-
| SIGHASH_SINGLE Inputs
| <tt>PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS = 0x07</tt>
| None
| No key data
| <tt><bit vector></tt>
| A bit vector representing which input indexes use SIGHASH_SINGLE. If 
the bit for an index is set to 1, then the input and output pair at that 
index are tied together with SIGHASH_SINGLE and must be moved together.
|
| 0
| 2
|}

The new per-input types for PSBT Version 2 are defined as follows:

{|
! Name
! <tt><keytype></tt>
! <tt><keydata></tt>
! <tt><keydata></tt> Description
! <tt><valuedata></tt>
! <tt><valuedata></tt> Description
! Versions Requiring Inclusion
! Versions Requiring Exclusion
! Versions Allowing Inclusion
|-
| Previous TXID
| <tt>PSBT_IN_PREVIOUS_TXID = 0x0e</tt>
| None
| No key data
| <tt><txid></tt>
| 32 byte txid of the previous transaction whose output at 
PSBT_IN_OUTPUT_INDEX is being spent.
| 2
| 0
| 2
|-
| Spent Output Index
| <tt>PSBT_IN_OUTPUT_INDEX = 0x0f</tt>
| None
| No key data
| <tt><32-bit uint></tt>
| 32 bit little endian integer representing the index of the output 
being spent in the transaction with the txid of PSBT_IN_PREVIOUS_TXID.
| 2
| 0
| 2
|-
| Sequence Number
| <tt>PSBT_IN_SEQUENCE = 0x10</tt>
| None
| No key data
| <tt><32-bit uint></tt>
| The 32 bit unsigned little endian integer for the sequence number of 
this input. If omitted, the sequence number is assumed to be the final 
sequence number (0xffffffff).
|
| 0
| 2
|-
| Required Time-based Locktime
| <tt>PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x11</tt>
| None
| No key data
| <tt><32-bit uint></tt>
| 32 bit unsigned little endian integer greater than or equal to 
500000000 representing the minimum Unix timestamp that this input 
requires to be set as the transaction's lock time.
|
| 0
| 2
|-
| Required Height-based Locktime
| <tt>PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x12</tt>
| None
| No key data
| <tt><32-bit uiht></tt>
| 32 bit unsigned little endian integer less than 500000000 representing 
the minimum block height that this input requires to be set as the 
transaction's lock time.
|
| 0
| 2
|}

The new per-output types for PSBT Version 2 are defined as follows:

{|
! Name
! <tt><keytype></tt>
! <tt><keydata></tt>
! <tt><keydata></tt> Description
! <tt><valuedata></tt>
! <tt><valuedata></tt> Description
! Versions Requiring Inclusion
! Versions Requiring Exclusion
! Versions Allowing Inclusion
|-
| Output Amount
| <tt>PSBT_OUT_AMOUNT = 0x03</tt>
| None
| No key data
| <tt><64-bit uint></tt>
| 64 bit signed little endian integer representing the output's amount 
in satoshis.
| 2
| 0
| 2
|-
| Output Script
| <tt>PSBT_OUT_SCRIPT = 0x03</tt>
| None
| No key data
| <tt><script></tt>
| The script for this output, also known as the scriptPubKey. Must be 
omitted in PSBTv0. Must be provided in PSBTv2.
| 2
| 0
| 2
|}

===Determining Lock Time===

The nLockTime field of a transaction is determined by inspecting the 
PSBT_GLOBAL_PREFERRED_LOCKTIME and each input's 
PSBT_IN_REQUIRED_TIME_LOCKTIME and PSBT_IN_REQUIRED_HEIGHT_LOCKTIME fields.
If none of the inputs have a PSBT_IN_REQUIRED_TIME_LOCKTIME and 
PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then PSBT_GLOBAL_PREFERRED_LOCKTIME 
must be used.
If PSBT_GLOBAL_PREFERRED_LOCKTIME is not provided, then it is assumed to 
be 0.

If one or more inuts have a PSBT_IN_REQUIRED_TIME_LOCKTIME or 
PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then the field chosen is the one which 
is supported by all of the inputs.
This can be determined by looking at all of the inputs which specify a 
locktime in either of those fields, and choosing the field which is 
present in all of those inputs.
Inputs not specifying a lock time field can take both types of lock 
times, as can those that specify both.
The lock time chosen is then the maximum value of the chosen type of 
lock time.

===Unique Identification===

PSBTv2s can be uniquely identified by constructing an unsigned 
transaction given the information provided in the PSBT and computing the 
transaction ID of that transaction.
Since PSBT_IN_SEQUENCE can be changed by Updaters and Combiners, the 
sequence number in this unsigned transaction must be set to 0 (not 
final, nor the sequence in PSBT_IN_SEQUENCE).
The lock time in this unsigned transaction must be computed as described 
previously.

==Roles==

PSBTv2 introduces new roles and modifies some existing roles.

===Creator===

In PSBTv2, the Creator initializes the PSBT with 0 inputs and 0 outputs.
The PSBT version number is set to 2. The transaction version number must 
be set to at least 2. <ref>'''Why does the transaction version number 
need to be at least 2?''' The transaction version number is part of the 
validation rules for some features such as OP_CHECKSEQUENCEVERIFY. Since 
it is backwards compatible, and there are other ways to disable those 
features (e.g. through sequence numbers), it is easier to require 
transactions be able to support these features than to try to negotiate 
the transaction version number.</ref>
The Creator should also PSBT_GLOBAL_PREFERRED_LOCKTIME.
If the Creator is not also a Constructor and will be giving the PSBT to 
others to add inputs and outputs, the PSBT_GLOBAL_TX_MODIFIABLE field 
must be present and and the Inputs Modifiable and Outputs Modifiable 
flags set appropriately.
If the Creator is a Constructor and no inputs and outputs will be added 
by other entities, PSBT_GLOBAL_TX_MODIFIABLE may be omitted.

===Constructor===

This Constructor is only present for PSBTv2.
Once a Creator initializes the PSBT, a constructor will add inputs and 
outputs.
Before any input or output may be added, the constructor must check the 
PSBT_GLOBAL_TX_MODIFIABLE field.
Inputs may only be added if the Inputs Modifiable flag (first boolean) 
is True.
Outputs may only be added if the Outputs Modifiable flag (second 
boolean) is True.
If PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS is present and its bitvector 
indicates any inputs use SIGHASH_SINGLE, then the same number of inputs 
and outputs must be added before that input and its corresponding outputs.

When an input or output is added, the corresponding 
PSBT_GLOBAL_INPUT_COUNT or PSBT_GLOBAL_OUTPUT_COUNT must be incremeted 
to reflect the number of inputs and outputs in the PSBT.
When an input is added, it must have PSBT_IN_PREVIOUS_TXID and 
PSBT_IN_OUTPUT_INDEX set.
When an output is added, it must have PSBT_OUT_VALUE and 
PSBT_OUT_OUTPUT_SCRIPT set.
If the input has a required timelock, Constructors must set the 
requisite timelock field.
If the input has a required time based timelock, then 
PSBT_IN_REQUIRED_TIME_TIMELOCK.
If the input has a required height based timelock, then 
PSBT_IN_REQUIRED_HEIGHT_TIMELOCK.
If an input has both types of timelocks, then both may be set.
In some cases, an input that can allow both types, but a particular 
branch supporting only one type of timelock will be taken, then the type 
of timelock that will be used can be the only one set.

When adding a new input, the new input must be compatible with the 
timelock types of all existing inputs.
Since Bitcoin requires that a transaction uses only one type of 
timelock, all of the inputs must be able to support the same type of 
timelock.
If the type of timelock is incompatible with the timelock type of the 
other inputs, then the input must not be added.

Since a Constructor may be adding inputs to a PSBT that has inputs with 
existing signatures, the Constructor must be careful to not invalidate 
any existing signatures.
The PSBT_GLOBAL_TX_MODIFIABLE and PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS 
fields caches this information so that constructors do not need to 
inspect every input.
If the PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS bit vector indicates an input 
index uses SIGHASH_SINGLE, the same number of inputs and outputs must be 
added before that input and its corresponding output.
When an input is added, the bit vector, if present, must be expanded to 
include a bit for this input in the correct position.
When there are signatures, in addition to respecting the lock time rules 
described previously, the newly added inputs must not change the lock 
time used by the transaction.
It cannot cause the lock time to change as that will invalidate all 
signatures since they all include the lock time regardless of the 
sighash type.

A Constructor may choose to declare that no further inputs and outputs 
can be added to the transaction by setting the booleans in 
PSBT_GLOBAL_TX_MODIFIABLE to False or by removing this field entirely.

A single entity is likely to be both a Creator and Constructor.

===Updater===

For PSBTv2, an Updater can set the sequence number.

===Signer===

For PSBTv2s, a signer must update the PSBT_GLOBAL_TX_MODIFIABLE and 
PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS fields after signing inputs so
that these fields accurately reflects the state of the PSBT.
If the Signer added a signature that does not use SIGHASH_ANYONECANPAY, 
the Input Modifiable flag must be set to False.
If the Signer added a signature that does not use SIGHASH_NONE, the 
Outputs Modifiable flag must be set to False.
If the Signer added a signature that uses SIGHASH_SINGLE, a 
PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS field must be added if not present, 
and the corresponding bit in its bit vector must be set to 1.

===Transaction Extractor===

For PSBTv2s, the transaction is constructed using the PSBTv2 fields.
The lock time for this transaction is determined as described in the 
Determining Lock Time section.
The Extractor should produce a fully valid, network serialized 
transaction if all inputs are complete.

==Compatibility==

PSBTv2 shares the same gemeric format as PSBTv0 as defined in BIP 174. 
Parsers for PSBTv0 should
be able to deserialize PSBTv2 with only changes to support the new fields.

However PSBTv2 is incompatible with PSBTv0, and vice versa due to the 
use of the PSBT_GLOBAL_VERSION.
This incompatibility is intentional so that PSBT_GLOBAL_UNSIGNED_TX 
could be removed in PSBTv2.
However it is possible to convert a PSBTv2 to a PSBTv0 by creating an 
unsigned
transaction from the PSBTv2 fields.

==Test Vectors==

TBD

==Rationale==

<references/>

==Reference implementation==

The reference implementation of the PSBT format is available at 
https://github.com/achow101/bitcoin/tree/psbt2.


On 12/23/20 4:32 PM, Andrew Chow wrote:
> Hi All,
>
> The full modified BIP can be read at
> https://github.com/achow101/bips/blob/psbt2/bip-0174.mediawiki.
>
> I will open a PR to the BIPs repo soon after further discussion on this.
>
>
> Andrew
>
> On 12/22/20 3:12 PM, Andrew Chow wrote:
>> Hi All,
>>
>> I have some updates on this after speaking with some people off-list.
>>
>> Firstly, the version number will be set to 2. In most discussions, this
>> proposal was being referred to as PSBT version 2, so it'll be easier and
>> clearer to set the version number to 2.
>>
>> For lock times, instead of a single? PSBT_IN_REQUIRED_LOCKTIME field,
>> there will be 2 of them, one for a time based lock time, and the other
>> for height based. These will be:
>> * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
>>    ? * Key: empty
>>    ? * Value: 32 bit unsigned little endian integer greater than or equal
>> to 500000000 representing the minimum Unix timestamp that this input
>> requires to be set as the transaction's lock time. Must be omitted in
>> PSBTv0, and may be omitted in PSBTv2
>> * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
>>    ? * Key: empty
>>    ? * Value: 32 bit unsigned little endian integer less than 500000000
>> representing the minimum block height that this input requires to be set
>> as the transaction's lock time. Must be omitted in PSBTv0, and may be
>> omitted in PSBTv2.
>>
>> Having two lock time fields is necessary due to the behavior where all
>> inputs must use the same type of lock time (height or time). Thus if an
>> input requires a particular type of lock time, it must set the requisite
>> field. Any new inputs being added must be able to accommodate all
>> existing inputs' lock time type. This means they either must not have a
>> lock time specified (i.e. no OP_CLTV involved), or have branches that
>> allow the acceptance of either type. If an input has a lock time type
>> that is incompatible with the rest of the transaction, it must not be added.
>>
>> PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback
>> option if no input lock time fields are present. If there are input lock
>> times, all lock time calculations must ignore it.
>>
>> Any role which does lock time calculation will first check if there are
>> input lock time fields. If there are not, it must then check for a
>> PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the
>> transaction's lock time. If it does not, the lock time is 0. If there
>> are input lock time fields, it must choose the type which does not
>> invalidate any inputs. The lock time is then determined to be the
>> maximum value of all of the lock time fields for the chosen type.
>>
>>
>> Additionally, I would like to add a new global field:
>> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>>    ? * Key: empty
>>    ? * Value: A single byte as a boolean. 0 for False, 1 for True. All
>> other values ore prohibited. Must be omitted for PSBTv0, may be omitted
>> in PSBTv2.
>>
>> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
>> outputs can be added to the PSBT. This flag may be set to True when
>> inputs and outputs are being updated, signed, and finalized. However
>> care must be taken when there are existing signatures. If this field is
>> omitted or set to False, no further inputs and outputs may be added to
>> the PSBT.
>>
>> Several rules must be followed to ensure that adding additional inputs
>> and outputs will not invalidate existing signatures. First, an input or
>> output adder must check for any existing signatures in all of the other
>> inputs. If there are none, the input or output may be added in any
>> position. If there are one or more signatures, each signature's sighash
>> type must be examined. Inputs may only be added if all existing
>> signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all
>> existing signatures use SIGHASH_NONE. If an input has a signature using
>> SIGHASH_SINGLE, the same number of inputs and outputs must be added
>> before that input and it's corresponding output. For all other sighash
>> types (i.e. SIGHASH_ALL and any future sighash types), no inputs or
>> outputs may be added to the PSBT. Specific exceptions can be made in the
>> future for additional sighash types.
>>
>> Furthermore, these newly added inputs must follow additional lock time
>> rules. Because all signatures, regardless of sighash type, sign the
>> transaction lock time, newly added inputs when there are existing
>> signatures must have the same type of lock time used in the transaction,
>> and must be less than or equal to the transaction lock time. It must not
>> cause the transaction lock time to change, otherwise the signatures will
>> be invalidated.
>>
>>
>> Lastly, to uniquely identify transactions for combiners, a txid can be
>> computed from the information present in the PSBT. Internally, combiners
>> can create an unsigned transaction given the transaction version, the
>> input prevouts, the outputs, and the computed locktime. This can then be
>> used to calculate a txid and thus used as a way to identify PSBTs.
>> Combiners will need to do this for all version 2 PSBTs in order to avoid
>> combining distinct transactions.
>>
>>
>> Andrew Chow
>>
>> On 12/9/20 5:25 PM, Andrew Chow wrote:
>>> Hi All,
>>>
>>> I would like to propose a new PSBT version that addresses a few
>>> deficiencies in the current PSBT v0. As this will be backwards
>>> incompatible, a new PSBT version will be used, v1.
>>>
>>> The primary change is to truly have all input and output data for each
>>> in their respective maps. Instead of having to parse an unsigned
>>> transaction and lookup some data from there, and other data from the
>>> correct map, all of the data for an input will be contained in its map.
>>> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
>>> Thus I propose that the following fields be added:
>>>
>>> Global:
>>> * PSBT_GLOBAL_TX_VERSION = 0x02
>>>     ? * Key: empty
>>>     ? * Value: 32-bit little endian unsigned integer for the transaction
>>> version number. Must be provided in PSBT v1 and omitted in v0.
>>> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
>>>     ? * Key: empty
>>>     ? * Value: 32 bit little endian unsigned integer for the preferred
>>> transaction lock time. Must be omitted in PSBT v0. May be provided in
>>> PSBT v1, assumed to be 0 if not provided.
>>> * PSBT_GLOBAL_INPUT_COUNT = 0x04
>>>     ? * Key: empty
>>>     ? * Value: Compact size unsigned integer. Number of inputs in this
>>> PSBT. Must be provided in PSBT v1 and omitted in v0.
>>> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
>>>     ? * Key: empty
>>>     ? * Value: Compact size unsigned integer. Number of outputs in this
>>> PSBT. Must be provided in PSBT v1 and omitted in v0.
>>>
>>> Input:
>>> * PSBT_IN_PREVIOUS_TXID = 0x0e
>>>     ? * Key: empty
>>>     ? * Value: 32 byte txid of the previous transaction whose output at
>>> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
>>> omitted in v0.
>>> * PSBT_IN_OUTPUT_INDEX = 0x0f
>>>     ? * Key: empty
>>>     ? * Value: 32 bit little endian integer for the index of the output
>>> being spent. Must be provided in PSBT v1 and omitted in v0.
>>> * PSBT_IN_SEQUENCE = 0x0f
>>>     ? * Key: empty
>>>     ? * Value: 32 bit unsigned little endian integer for the sequence
>>> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
>>> to be max sequence (0xffffffff) if not provided.
>>> * PSBT_IN_REQUIRED_LOCKTIME = 0x10
>>>     ? * Key: empty
>>>     ? * Value: 32 bit unsigned little endian integer for the lock time that
>>> this input requires. Must be omitted in PSBT v0. May be provided in PSBT
>>> v1, assumed to be 0 if not provided.
>>>
>>> Output:
>>> * PSBT_OUT_VALUE = 0x03
>>>     ? * Key: empty
>>>     ? * Value: 64-bit unsigned little endian integer for the output's
>>> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
>>> * PSBT_OUT_OUTPUT_SCRIPT = 0x04
>>>     ? * Key: empty
>>>     ? * Value: The script for this output. Otherwise known as the
>>> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
>>>
>>> This change allows for PSBT to be used in the construction of
>>> transactions. With these new fields, inputs and outputs can be added as
>>> needed. One caveat is that there is no longer a unique transaction
>>> identifier so more care must be taken when combining PSBTs.
>>> Additionally, adding new inputs and outputs must be done such that
>>> signatures are not invalidated. This may be harder to specify.
>>>
>>> An important thing to note in this proposal are the fields
>>> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
>>> transaction only has a single locktime yet a PSBT may have multiple
>>> locktimes. To choose the locktime for the transaction, finalizers must
>>> choose the maximum of all of the *_LOCKTIME fields.
>>> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
>>> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
>>> be set. This field allows finalizers to choose a locktime that is high
>>> enough for all inputs without needing to understand the scripts
>>> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
>>> no inputs require a particular locktime.
>>>
>>> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
>>> needs the version number bump to enforce backwards incompatibility.
>>> However once the inputs and outputs of a PSBT are decided, a PSBT could
>>> be "downgraded" back to v0 by creating the unsigned transaction from the
>>> above fields, and then dropping these new fields.
>>>
>>> If the list finds that these changes are reasonable, I will write a PR
>>> to modify BIP 174 to incorporate them.
>>>
>>> Thanks,
>>> Andrew Chow



From belcher at riseup.net  Sat Jan 16 00:07:08 2021
From: belcher at riseup.net (Chris Belcher)
Date: Sat, 16 Jan 2021 00:07:08 +0000
Subject: [bitcoin-dev] PayJoin adoption
Message-ID: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>

PayJoin is an exciting bitcoin privacy technology which has the
potential to damage the ability of blockchain surveillance to spy on
bitcoin users and destroy bitcoin's fungibility. A protocol standard has
already been defined and implemented by a couple of projects such as
BTCPayServer, Wasabi Wallet, JoinMarket and BlueWallet.

I've made a wiki page tracking adoption:
https://en.bitcoin.it/wiki/PayJoin_adoption

It is similar to the Bech32 adoption page.


Recently a UK bitcoin exchange shut down due to new regulations, with
the owner writing a very interesting and relevant blog post that I'll
quote here:

> you?re considered suspicious if you used a marketplace and not an
exchange. Coinjoin counts as high risk. Gambling is high risk. As you
use entities that are paranoid about keeping their coins clean and
adhering to all the regulations, your risk scores will continue to
increase and without you even knowing why, your deposits will become
rejected, you may be asked to supply documents or lose the coins, your
account may become suspended without you having any clue what you did
wrong. And quite possibly you didn?t do anything wrong. But that won?t
matter.
>
> The goal post, the risk score threshold will keep moving along this
trend until the point where you will be afraid of using your personal
wallet, donating to someone online, receiving bitcoins from anywhere
except for regulated exchanges. At that point, crypto will be akin to a
regular bank account. You won?t have a bitcoin wallet, you will have
accounts to websites.

https://blog.bitbargain.com/post/638504004285054976/goodbye

If we want bitcoin to fulfill its dream of a permissionless money for
the internet then we'll have to work on this. What can we do to increase
adoption of PayJoin?

From dev at fitti.io  Sat Jan 16 02:52:34 2021
From: dev at fitti.io (dev_f)
Date: Sat, 16 Jan 2021 02:52:34 +0000
Subject: [bitcoin-dev] PayJoin adoption
In-Reply-To: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>
References: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>
Message-ID: <MRPJ51OJKiOHFfMaz1Y0XC-BWAyJqQFRQttP5sApf8_gtlVk3k-jziFACTwFZ3QPK3jFZ9yaVmFXf9BuN-dbo3J1JrWjLTkk3wKw1LfocKk=@fitti.io>

Hey Chris,

I assume that a major reason for the lack of adoption is the lack of visibility.
I personally first found out about PayJoin when using BTCPayServer for a donation
and being told by the site that PayJoin was available (https://hrf.org/donate-bitcoin/payjoin/).
The wiki page you created is a good starting point. Bringing up the issue of implementing
PayJoin directly with the companies / in the respective software repos seems like it would
be a strong first step for greater adoption. Gets more eyes on it in general.
(Directly contributing to the software by writing an implementation is obviously the
most helpful, though clearly harder.)

As a second option, pushing merchants towards accepting Bitcoin specifically via
software like BTCPayServer, which already supports PayJoin, might be immensely
helpful when Bitcoin adoption itself rises.

Fitti

Sent with ProtonMail Secure Email.

??????? Original Message ???????

On Saturday, January 16th, 2021 at 1:07 AM, Chris Belcher via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> PayJoin is an exciting bitcoin privacy technology which has the
> 

> potential to damage the ability of blockchain surveillance to spy on
> 

> bitcoin users and destroy bitcoin's fungibility. A protocol standard has
> 

> already been defined and implemented by a couple of projects such as
> 

> BTCPayServer, Wasabi Wallet, JoinMarket and BlueWallet.
> 

> I've made a wiki page tracking adoption:
> 

> https://en.bitcoin.it/wiki/PayJoin_adoption
> 

> It is similar to the Bech32 adoption page.
> 

> Recently a UK bitcoin exchange shut down due to new regulations, with
> 

> the owner writing a very interesting and relevant blog post that I'll
> 

> quote here:
> 

> > you?re considered suspicious if you used a marketplace and not an
> 

> exchange. Coinjoin counts as high risk. Gambling is high risk. As you
> 

> use entities that are paranoid about keeping their coins clean and
> 

> adhering to all the regulations, your risk scores will continue to
> 

> increase and without you even knowing why, your deposits will become
> 

> rejected, you may be asked to supply documents or lose the coins, your
> 

> account may become suspended without you having any clue what you did
> 

> wrong. And quite possibly you didn?t do anything wrong. But that won?t
> 

> matter.
> 

> > The goal post, the risk score threshold will keep moving along this
> 

> trend until the point where you will be afraid of using your personal
> 

> wallet, donating to someone online, receiving bitcoins from anywhere
> 

> except for regulated exchanges. At that point, crypto will be akin to a
> 

> regular bank account. You won?t have a bitcoin wallet, you will have
> 

> accounts to websites.
> 

> https://blog.bitbargain.com/post/638504004285054976/goodbye
> 

> If we want bitcoin to fulfill its dream of a permissionless money for
> 

> the internet then we'll have to work on this. What can we do to increase
> 

> adoption of PayJoin?
> 

> bitcoin-dev mailing list
> 

> bitcoin-dev at lists.linuxfoundation.org
> 

> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
A non-text attachment was scrubbed...
Name: publickey - dev at fitti.io - 0xC413574E.asc
Type: application/pgp-keys
Size: 640 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210116/2bc4b8db/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 249 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210116/2bc4b8db/attachment.sig>

From craigraw at gmail.com  Sat Jan 16 06:15:27 2021
From: craigraw at gmail.com (Craig Raw)
Date: Sat, 16 Jan 2021 08:15:27 +0200
Subject: [bitcoin-dev] PayJoin adoption
In-Reply-To: <MRPJ51OJKiOHFfMaz1Y0XC-BWAyJqQFRQttP5sApf8_gtlVk3k-jziFACTwFZ3QPK3jFZ9yaVmFXf9BuN-dbo3J1JrWjLTkk3wKw1LfocKk=@fitti.io>
References: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>
 <MRPJ51OJKiOHFfMaz1Y0XC-BWAyJqQFRQttP5sApf8_gtlVk3k-jziFACTwFZ3QPK3jFZ9yaVmFXf9BuN-dbo3J1JrWjLTkk3wKw1LfocKk=@fitti.io>
Message-ID: <CAPR5oBPJPs1g32K3XDnNyV3bKCq58fti3mNd-ooFhKNMVxCf9g@mail.gmail.com>

Hey Chris,

You can add Sparrow Wallet to the list for Sending :)

I think one of the barriers to greater Payjoin adoption is the need for a
server endpoint on the receiving side. Ideally, all wallets should be able
to conduct Payjoin transactions with each other. This would require a
different mechanism to exchange the PSBTs, but otherwise the specification
should need no amendment. Samourai has implemented their Soroban protocol
to do this over Tor, but as far as I know it's not yet documented.

Given Payjoin is fee efficient (much more so than coinjoin) and relatively
simple to implement, it appears to hold great promise in disrupting
blockchain analysis. I'd love to see a standard that wallets can adopt to
receive Payjoin transactions without a server endpoint.

Craig

On Sat, Jan 16, 2021 at 5:13 AM dev_f via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hey Chris,
>
> I assume that a major reason for the lack of adoption is the lack of
> visibility.
> I personally first found out about PayJoin when using BTCPayServer for a
> donation
> and being told by the site that PayJoin was available (
> https://hrf.org/donate-bitcoin/payjoin/).
> The wiki page you created is a good starting point. Bringing up the issue
> of implementing
> PayJoin directly with the companies / in the respective software repos
> seems like it would
> be a strong first step for greater adoption. Gets more eyes on it in
> general.
> (Directly contributing to the software by writing an implementation is
> obviously the
> most helpful, though clearly harder.)
>
> As a second option, pushing merchants towards accepting Bitcoin
> specifically via
> software like BTCPayServer, which already supports PayJoin, might be
> immensely
> helpful when Bitcoin adoption itself rises.
>
> Fitti
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
>
> On Saturday, January 16th, 2021 at 1:07 AM, Chris Belcher via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > PayJoin is an exciting bitcoin privacy technology which has the
> >
>
> > potential to damage the ability of blockchain surveillance to spy on
> >
>
> > bitcoin users and destroy bitcoin's fungibility. A protocol standard has
> >
>
> > already been defined and implemented by a couple of projects such as
> >
>
> > BTCPayServer, Wasabi Wallet, JoinMarket and BlueWallet.
> >
>
> > I've made a wiki page tracking adoption:
> >
>
> > https://en.bitcoin.it/wiki/PayJoin_adoption
> >
>
> > It is similar to the Bech32 adoption page.
> >
>
> > Recently a UK bitcoin exchange shut down due to new regulations, with
> >
>
> > the owner writing a very interesting and relevant blog post that I'll
> >
>
> > quote here:
> >
>
> > > you?re considered suspicious if you used a marketplace and not an
> >
>
> > exchange. Coinjoin counts as high risk. Gambling is high risk. As you
> >
>
> > use entities that are paranoid about keeping their coins clean and
> >
>
> > adhering to all the regulations, your risk scores will continue to
> >
>
> > increase and without you even knowing why, your deposits will become
> >
>
> > rejected, you may be asked to supply documents or lose the coins, your
> >
>
> > account may become suspended without you having any clue what you did
> >
>
> > wrong. And quite possibly you didn?t do anything wrong. But that won?t
> >
>
> > matter.
> >
>
> > > The goal post, the risk score threshold will keep moving along this
> >
>
> > trend until the point where you will be afraid of using your personal
> >
>
> > wallet, donating to someone online, receiving bitcoins from anywhere
> >
>
> > except for regulated exchanges. At that point, crypto will be akin to a
> >
>
> > regular bank account. You won?t have a bitcoin wallet, you will have
> >
>
> > accounts to websites.
> >
>
> > https://blog.bitbargain.com/post/638504004285054976/goodbye
> >
>
> > If we want bitcoin to fulfill its dream of a permissionless money for
> >
>
> > the internet then we'll have to work on this. What can we do to increase
> >
>
> > adoption of PayJoin?
> >
>
> > bitcoin-dev mailing list
> >
>
> > bitcoin-dev at lists.linuxfoundation.org
> >
>
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210116/005e8719/attachment.html>

From antoine.riard at gmail.com  Sun Jan 17 01:31:07 2021
From: antoine.riard at gmail.com (Antoine Riard)
Date: Sat, 16 Jan 2021 20:31:07 -0500
Subject: [bitcoin-dev] Hardware wallets and "advanced" Bitcoin features
In-Reply-To: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>
References: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>
Message-ID: <CALZpt+EMHkYFxkO+SxFEjbiG2hU2Rm5kpMd8+71+Wjxc48J5ig@mail.gmail.com>

Hello Kevin,

Thanks for starting this thread, that's a really relevant discussion
ecosystem-wise !

> * Proposed improvement: The HW should display the Bitcoin Script itself
when possible (including the unlock conditions).

What level of script literacy are you assuming on your users ? I can see
enterprise/hobbyist folks to know enough of Script to understand the
intended behavior but I don't think that's a reasonable assumption for your
average user. Of course, Miniscript Policy makes things easier, but IMHO, I
still hope to see some mature, higher-level language (e.g Ivy) to ease
script semantic understanding and thus widen the crowd of users.

Further, I would do a bit on UX research on the correctness model expected
by your users. I.e if they fail to verify accordingly, are they losing
funds, transaction doesn't confirm, transaction doesn't even propagate,
etc. You should also make assumptions on the mental resources you're
required from them. Time-sensitive L2 protocols have a wide scope to check,
e.g not verifying the nSequence/nLocktime fields can provoke funds failures.

> This applies to pre-signed transaction protocols especially well as the
template of these transactions could be known
and recognized by the HW. Typically for Revault, the HW could display:
"Unvault Transaction, all expected pubkeys
present in the script".

In the future, I would expect templates of high-security protocols like
vaults to be part of the trusted computing base of any decent HW. I think
good standards there would avoid HW vendors to come with some kind of
certified-templates scheme and thus having to bless custom scripts of every
vaults implementations.

> Proposed improvement: The HW could know pubkeys or xpubs it does not hold
the private keys
for, and display a label (or
understand it for logic reasons, such as "expected pubkeys" as the previous
example).

I don't think you even need user input on this, the absence of pubkeys
knowledge itself is a trigger to display a label or ask for further
information. Where absence of pubkeys knowledge can be interpreted as
devoid from key whitelisting or privkey ownership.

> Going further, the xpubs could be
aliased the first time they are entered/verified (as part of, say, an
initial setup ceremony) for instance with the
previously mentioned Miniscript policy: or(pk(Alice), and(pk(Bob),
after(42))).

I would be careful about accidental or malicious alias collisions. But yes
that can be something, you can even conserve a merkle tree root in the
Secure Element where the hashed element are
previously authenticated alias/pubkeys. And require from the non-trusted
challenger to come with a merkle branch to validate address inclusion.

> Then there is PSBT support and the maximum transaction size limit for
these: we need more transparency from HW manufacturers on their li
mitations.

I understand them, Script is full of subtleties, taproot is likely to have
more of them and if you take sighash malleability that's not something you
want your average user to play with. Maybe it
would be better to come up with a first wave of script features on which
you expect transparency ? For sure, OP_CSV is a good candidate.

> Once any input of a (pre-signed)transaction is
spent, this transaction isn't valid anymore. Most pre-signed transactions
protocols are used today as a form of defense
mechanism, spending any input would mean incapacitating the entire defense
mechanism.

I don't see the exact issue here. E.g in Lightning, even if you pre-sign a
justice transaction punishing every revokeable outputs on counterparty
transaction, and one input is spent, will current HWs prevent you to-resign
an updated justice transaction ?

> I understand some of these changes may be very difficult, especially
given the low memory and computational power of
secure elements.

Instead of relying on hand-sized devices, what about relying on HSMs for a
first-wave of adoptions, those ones have far enough resources to run a
reasonable L2 stack on the trusted-side ?

But overall agree, on the requirement to level-up HWs for L2. IMO, a first
step could be to list a  common set of features beyond
deployed/soon-to-be-deployed L2s, that would make things easier for HW
vendors to have a unique list of grievances. Before they engage in further,
dedicated tweaks to adapt for each protocol security model. OP_CSV/OP_CTLV
decoding/"burned" standard scripts support would be a good starter.

> Feel free to reply with your comments or adding suggestions, I am not a
hardware wallet expert and would take criticism
wit
hout being offended.

I don't know yet any *L2* hardware wallet expert :)

Cheers,
Antoine

Le jeu. 14 janv. 2021 ? 13:46, Kevin Loaec via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> a ?crit :

> Hello everyone,
>
> I would like to start a discussion on improving Hardware Wallets.
>
> My approach to this right now is from a vault protocol we are developing
> (Revault, [1]), and its Hardware Wallet
> requirements. I started working on a Github Issue in our repo [2], other
> people recommended us to do a more general
> discussion on the mailing list instead as it could benefit many other
> protocols and users.
> This email discusses improvements that would benefit everyone, and some
> that are more suitable for "layer 2" or pre-
> signed transactions protocols.
> The goal is to spark discussions and hopefully iterate to a more secure
> and more usable hardware ecosystem for all
> bitcoiners.
> While I mainly foresee issues/improvements that may affect Revault, I
> would be really happy to see people joining this
> thread with any other ideas and remarks that would benefit some parts of
> Bitcoin that I overlooked.
>
>
>
> Prior work on similar problematics:
> ===================================
> - ZmnSCPx
> j: [Lightning-dev] Speculations on hardware wallet support for Lightning
> [3]
> - mflaxman: Known Issues: Verifying a Receive Address [4]
> - ksedgwic and devrandom01: Lightning-signer [5]
> - benma: How nearly all personal hardware wallet multisig setups are
> insecure [6]
>
>
> The postulate we start from is that Hardware Wallets (HW) are useful to
> mitigate the compromission of the day-to-day
> device of a user. They mainly prevent private-key extraction today, and
> aren't very suitable against an attack on the
> transaction being signed, as explained further.
> To make this discussion security-focused, let's assume the general purpose
> device (laptop, for example) is compromised
> with a malware implanted by an attacker, capable of modifying PSBTs,
> displayed addresses, etc.
>
> Our study so far:
>
>
> Output Script Parsing:
> ======================
> Problem: A typical HW today would display the "destination" of a
> transaction in the form of a bitcoin address. A user
> would generally compare this wit
> h the address displayed on his laptop screen... which might have been
> compromised
> already. The correct usage would be for a user to verify this address on a
> third device (mobile phone, for example).
> This is weak security and bad user experience.
> Proposed improvement: The HW should display the Bitcoin Script itself when
> possible (including the unlock conditions).
> The best way to do so would be to lift this Script to a more user-friendly
> format such as a MiniScript Policy display,
> but anything would be better than an "address".
> This applies to pre-signed transaction protocols especially well as the
> template of these transactions could be known
> and recognized by the HW. Typically for Revault, the HW could display:
> "Unvault Transaction, all expected pubkeys
> present in the script".
>
>
> Pubkey Interpretation:
> ======================
> Problem: currently HW cannot "identify" addresses or keys.
> Proposed improvement: The HW could know pubkeys or xpubs it does not hold
> the private keys
> for, and display a label (or
> understand it for logic reasons, such as "expected pubkeys" as the
> previous example). Going further, the xpubs could be
> aliased the first time they are entered/verified (as part of, say, an
> initial setup ceremony) for instance with the
> previously mentioned Miniscript policy: or(pk(Alice), and(pk(Bob),
> after(42))).
> This should be done in the Secure Element if possible to avoid physical
> compromission, but would be a strong improvement
> versus a day-to-day laptop in any case.
>
>
> Better Bitcoin Compatibility:
> =============================
> Problem: most HW cannot interpret some Script OPs such as OP_CSV, or any
> conditional outputs. This is a major issue for
> anyone using Bitcoin "advanced" features. Related to this are the Sighash
> flags: most HW do not support most Sighash
> flags. Kind of annoying for a signing device. Then there is PSBT support
> and the maximum transaction size limit for
> these: we need more transparency from HW manufacturers on their li
> mitations.
> Solution: Make Bitcoin HW actually compatible with Bitcoin :D
>
>
> Inputs (mainly for pre-signed Tx):
> ==================================
> Problem: Poisoned inputs are a major risk for HW as they don't know the
> UTXO set. While this can be exploited for fee
> attacks, it is a bigger threat to pre-signed transactions protocols. Once
> any input of a (pre-signed)transaction is
> spent, this transaction isn't valid anymore. Most pre-signed transactions
> protocols are used today as a form of defense
> mechanism, spending any input would mean incapacitating the entire defense
> mechanism.
> Proposed improvement: for protocols that requires it, keeping track of
> inputs already signed once would be extremely
> helpful. Going further, most of these protocols require to follow a
> specific signing order (typically the "clawback"
> first, then the regular spend path) so adding a way to check that a
> "clawback" has been signed first, with the same
> input, would be very helpful. All of this on the dev
> ice itself.
>
>
>
>
> I understand some of these changes may be very difficult, especially given
> the low memory and computational power of
> secure elements. However I truly believe most of these points are a MUST
> have for any decent security. If you don't
> assume the computer on which the transaction is crafted is compromised,
> then you don't need a hardware wallet. If you
> assume it may be compromised, then the HW needs to be able to defend
> against those.
>
> Revault does not plan on building hardware wallets, we hope existing and
> upcoming manufacturers will implement a strong
> security that we could use for the Revault protocol users. Vault users
> will likely hold very large sums and would be
> happy to pay a high premium for more secure HW. This will hopefully
> encourage existing players to keep on improving
> their devices and that will ultimately benefit us all.
>
> Feel free to reply with your comments or adding suggestions, I am not a
> hardware wallet expert and would take criticism
> wit
> hout being offended.
>
> Kind Regards,
> Kevin Loaec
>
> [1]:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017835.html
> [2]: https://github.com/re-vault/practical-revault/issues/59
> [3]:
> https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002425.html
> [4]: https://btcguide.github.io/known-issues/verify-receive-address
> [5]: https://gitlab.com/lightning-signer/docs
> [6]:
> https://shiftcrypto.ch/blog/how-nearly-all-personal-hardware-wallet-multisig-setups-are-insecure/
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210116/7b763fff/attachment.html>

From c1.bitcoin at niftybox.net  Sun Jan 17 02:40:44 2021
From: c1.bitcoin at niftybox.net (Devrandom)
Date: Sat, 16 Jan 2021 18:40:44 -0800
Subject: [bitcoin-dev] Hardware wallets and "advanced" Bitcoin features
In-Reply-To: <IUjfIb-kgkDrL-Lq2aezCk5sjSoICBCUEZbchHqLDFStputPn0Y8xmPHdIwg6tEwZIMI-075CMO1jwy4FgIhhTgDclpdJXwRYlrESFDqfSc=@protonmail.com>
References: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>
 <IUjfIb-kgkDrL-Lq2aezCk5sjSoICBCUEZbchHqLDFStputPn0Y8xmPHdIwg6tEwZIMI-075CMO1jwy4FgIhhTgDclpdJXwRYlrESFDqfSc=@protonmail.com>
Message-ID: <CAB0O3SWvARDpdPt562SY-p+FE63rhEYg_DGEVJsBnmG-pdkw5Q@mail.gmail.com>

Dear ZmnSCPxj,

On Thu, Jan 14, 2021 at 4:28 PM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The primary issue here is that we have a base assumption that the hardware
> wallet cannot be sophisticated enough to have Internet access; "do not
> enter seed words on an online device", as the typical advice goes.
> Most clawback transactions are time-based, and *must* be broadcast at a
> particular blockheight.
> Yet if the hardware wallet cannot be an online device, then it cannot know
> the current blockheight is now at a time when the clawback transaction
> *must* be broadcast.
>
> Thus, the hardware must always tr\*st the software to actually perform the
> clawback in that case.
>

I believe it is possible to achieve much of the desired "liveness"
requirements without compromising too much on the air-gap.  The solution
requires the following:

- a set of UTXO oracles which attest to the UTXO set
- optionally, a set of clock oracles which attest to the current time (e.g.
using the roughtime protocol)
- an air-gap connection between the node software and the signer, e.g.
using a narrow optical or serial protocol
- a set of operators that can react to lack of liveness

The Signer performs the following steps periodically:

- if the funding UTXO has not been spent (per oracle attestation), proceed
normally with any channel commitment signing
- if the funding UTXO has been spent, ensure that the node provided the
spending tx, and check if there is any reaction needed (e.g. a justice tx
is needed)
- if a reaction is needed, ensure that there is a further spend within a
certain deadline (shorter than the CSV/CLTV deadline)
- if there is no deadline violation, sign a heartbeat message with the
current time (either from a local clock or from oracle clock)

The node software then relays the signed heartbeat message to the
operators, e.g. through Tor.  If a heartbeat is not seen by the operators,
they manually intervene (e.g. by standing up a clean node).

Of course, we will never have Lightning paper wallets, by definition, since
you can't participate in the network without being online.  But the above
setup seems to be at least as secure as USB hardware wallets attached to
online machines.  You could even have intermittently connected signers for
slow-moving channels, or signers behind Tor, etc. .

--
devrandom
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210116/25ea76d6/attachment-0001.html>

From darosior at protonmail.com  Sun Jan 17 10:02:32 2021
From: darosior at protonmail.com (darosior)
Date: Sun, 17 Jan 2021 10:02:32 +0000
Subject: [bitcoin-dev] Hardware wallets and "advanced" Bitcoin features
In-Reply-To: <CALZpt+EMHkYFxkO+SxFEjbiG2hU2Rm5kpMd8+71+Wjxc48J5ig@mail.gmail.com>
References: <da42f7e09cabcaa935bce4036340ef14f4bf454c.camel@revault.dev>
 <CALZpt+EMHkYFxkO+SxFEjbiG2hU2Rm5kpMd8+71+Wjxc48J5ig@mail.gmail.com>
Message-ID: <-dbEbZdrKCipubghS84uRlP0r158rIrh9dfQQb5QPCpWgAMimf3sMygdMyEXNXKgnE_ttcIB3JhbDxvp8_xEDWuFS9NAp5zi3R_qnbuBarc=@protonmail.com>

Hi Antoine, and Kevin,

>> * Proposed improvement: The HW should display the Bitcoin Script itself when possible (including the unlock conditions).
>
> What level of script literacy are you assuming on your users ? I can see enterprise/hobbyist folks to know enough of Script to understand the intended behavior but I don't think that's a reasonable assumption for your average user. Of course, Miniscript Policy makes things easier, but IMHO, I still hope to see some mature, higher-level language (e.g Ivy) to ease script semantic understanding and thus widen the crowd of users.

No Script literacy should be assumed. I believe with Miniscript Policy (with possibly alias instead of pubkeys, see below) we are to the highest possible level of abstraction
without loss of meaning for user verification. I don't think Ivy would be helpful here.
Also, as Kevin mentioned, anything would be better than an address anyways.

> Further, I would do a bit on UX research on the correctness model expected by your users. I.e if they fail to verify accordingly, are they losing funds, transaction doesn't confirm, transaction doesn't even propagate, etc. You should also make assumptions on the mental resources you're required from them. Time-sensitive L2 protocols have a wide scope to check, e.g not verifying the nSequence/nLocktime fields can provoke funds failures.

Regarding the correctness, with the OP threat model (laptop compromised), for any transaction: if they fail to verify the locking policy, fund loss.
Re nSeq: If we trust the HM, and the HM support Miniscript, it must be able to satisfy inputs in a sa[n,f]e way.

>> This applies to pre-signed transaction protocols especially well as the template of these transactions could be known
> and recognized by the HW. Typically for Revault, the HW could display: "Unvault Transaction, all expected pubkeys
> present in the script".
>
> In the future, I would expect templates of high-security protocols like vaults to be part of the trusted computing base of any decent HW. I think good standards there would avoid HW vendors to come with some kind of certified-templates scheme and thus having to bless custom scripts of every vaults implementations.

+1

>> Then there is PSBT support and the maximum transaction size limit for
> these: we need more transparency from HW manufacturers on their li
> mitations.
>
> I understand them, Script is full of subtleties, taproot is likely to have more of them and if you take sighash malleability that's not something you want your average user to play with. Maybe it
> would be better to come up with a first wave of script features on which you expect transparency ? For sure, OP_CSV is a good candidate.

I agree that rather than supporting all of Script it would be better to support a "safe", analyzable subset of Script: that's Miniscript :p
I also believe supporting any new Script capabilities without Miniscript would be a huge footgun. It would also ease the upgrade to Tapscript.

>> Once any input of a (pre-signed)transaction is
> spent, this transaction isn't valid anymore. Most pre-signed transactions protocols are used today as a form of defense
> mechanism, spending any input would mean incapacitating the entire defense mechanism.
>
> I don't see the exact issue here. E.g in Lightning, even if you pre-sign a justice transaction punishing every revokeable outputs on counterparty transaction, and one input is spent, will current HWs prevent you to-resign an updated justice transaction ?

That's because in Revault we don't require HMs for watchtowers. Funds holders are expected to have a routine signing of cancel / deterrent / unvault transactions
and share them with the watchtowers. The attack Kevin is talking about is a (expected-to-be-stateless) HM will happily sign a cancel of deterrent transaction that
spends an already-signed input. So let's say a fund holder sends a signature for an Unvault tx and a Cancel tx that does not spend this Unvault to their watchtower.
The watchtower would cringe (in our v0 protocol, send an NACK): but the NACK isn't handled by the HM therefore at the end of the day the already-compromised laptop
is ensuring the (statefull) validity of the signature.

Thanks,
Antoine

> Le jeu. 14 janv. 2021 ? 13:46, Kevin Loaec via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> a ?crit :
>
>> Hello everyone,
>>
>> I would like to start a discussion on improving Hardware Wallets.
>>
>> My approach to this right now is from a vault protocol we are developing (Revault, [1]), and its Hardware Wallet
>> requirements. I started working on a Github Issue in our repo [2], other people recommended us to do a more general
>> discussion on the mailing list instead as it could benefit many other protocols and users.
>> This email discusses improvements that would benefit everyone, and some that are more suitable for "layer 2" or pre-
>> signed transactions protocols.
>> The goal is to spark discussions and hopefully iterate to a more secure and more usable hardware ecosystem for all
>> bitcoiners.
>> While I mainly foresee issues/improvements that may affect Revault, I would be really happy to see people joining this
>> thread with any other ideas and remarks that would benefit some parts of Bitcoin that I overlooked.
>>
>> Prior work on similar problematics:
>> ===================================
>> - ZmnSCPx
>> j: [Lightning-dev] Speculations on hardware wallet support for Lightning [3]
>> - mflaxman: Known Issues: Verifying a Receive Address [4]
>> - ksedgwic and devrandom01: Lightning-signer [5]
>> - benma: How nearly all personal hardware wallet multisig setups are insecure [6]
>>
>> The postulate we start from is that Hardware Wallets (HW) are useful to mitigate the compromission of the day-to-day
>> device of a user. They mainly prevent private-key extraction today, and aren't very suitable against an attack on the
>> transaction being signed, as explained further.
>> To make this discussion security-focused, let's assume the general purpose device (laptop, for example) is compromised
>> with a malware implanted by an attacker, capable of modifying PSBTs, displayed addresses, etc.
>>
>> Our study so far:
>>
>> Output Script Parsing:
>> ======================
>> Problem: A typical HW today would display the "destination" of a transaction in the form of a bitcoin address. A user
>> would generally compare this wit
>> h the address displayed on his laptop screen... which might have been compromised
>> already. The correct usage would be for a user to verify this address on a third device (mobile phone, for example).
>> This is weak security and bad user experience.
>> Proposed improvement: The HW should display the Bitcoin Script itself when possible (including the unlock conditions).
>> The best way to do so would be to lift this Script to a more user-friendly format such as a MiniScript Policy display,
>> but anything would be better than an "address".
>> This applies to pre-signed transaction protocols especially well as the template of these transactions could be known
>> and recognized by the HW. Typically for Revault, the HW could display: "Unvault Transaction, all expected pubkeys
>> present in the script".
>>
>> Pubkey Interpretation:
>> ======================
>> Problem: currently HW cannot "identify" addresses or keys.
>> Proposed improvement: The HW could know pubkeys or xpubs it does not hold the private keys
>> for, and display a label (or
>> understand it for logic reasons, such as "expected pubkeys" as the previous example). Going further, the xpubs could be
>> aliased the first time they are entered/verified (as part of, say, an initial setup ceremony) for instance with the
>> previously mentioned Miniscript policy: or(pk(Alice), and(pk(Bob), after(42))).
>> This should be done in the Secure Element if possible to avoid physical compromission, but would be a strong improvement
>> versus a day-to-day laptop in any case.
>>
>> Better Bitcoin Compatibility:
>> =============================
>> Problem: most HW cannot interpret some Script OPs such as OP_CSV, or any conditional outputs. This is a major issue for
>> anyone using Bitcoin "advanced" features. Related to this are the Sighash flags: most HW do not support most Sighash
>> flags. Kind of annoying for a signing device. Then there is PSBT support and the maximum transaction size limit for
>> these: we need more transparency from HW manufacturers on their li
>> mitations.
>> Solution: Make Bitcoin HW actually compatible with Bitcoin :D
>>
>> Inputs (mainly for pre-signed Tx):
>> ==================================
>> Problem: Poisoned inputs are a major risk for HW as they don't know the UTXO set. While this can be exploited for fee
>> attacks, it is a bigger threat to pre-signed transactions protocols. Once any input of a (pre-signed)transaction is
>> spent, this transaction isn't valid anymore. Most pre-signed transactions protocols are used today as a form of defense
>> mechanism, spending any input would mean incapacitating the entire defense mechanism.
>> Proposed improvement: for protocols that requires it, keeping track of inputs already signed once would be extremely
>> helpful. Going further, most of these protocols require to follow a specific signing order (typically the "clawback"
>> first, then the regular spend path) so adding a way to check that a "clawback" has been signed first, with the same
>> input, would be very helpful. All of this on the dev
>> ice itself.
>>
>> I understand some of these changes may be very difficult, especially given the low memory and computational power of
>> secure elements. However I truly believe most of these points are a MUST have for any decent security. If you don't
>> assume the computer on which the transaction is crafted is compromised, then you don't need a hardware wallet. If you
>> assume it may be compromised, then the HW needs to be able to defend against those.
>>
>> Revault does not plan on building hardware wallets, we hope existing and upcoming manufacturers will implement a strong
>> security that we could use for the Revault protocol users. Vault users will likely hold very large sums and would be
>> happy to pay a high premium for more secure HW. This will hopefully encourage existing players to keep on improving
>> their devices and that will ultimately benefit us all.
>>
>> Feel free to reply with your comments or adding suggestions, I am not a hardware wallet expert and would take criticism
>> wit
>> hout being offended.
>>
>> Kind Regards,
>> Kevin Loaec
>>
>> [1]: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-May/017835.html
>> [2]: https://github.com/re-vault/practical-revault/issues/59
>> [3]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-January/002425.html
>> [4]: https://btcguide.github.io/known-issues/verify-receive-address
>> [5]: https://gitlab.com/lightning-signer/docs
>> [6]: https://shiftcrypto.ch/blog/how-nearly-all-personal-hardware-wallet-multisig-setups-are-insecure/
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210117/8d1d6722/attachment-0001.html>

From bitcoin-dev at wuille.net  Mon Jan 18 04:15:49 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Mon, 18 Jan 2021 04:15:49 +0000
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <CAHk9a9d_xm2nO1t5GsLJiny1V3H=uv8jGuUTywQetZQOXxyG9w@mail.gmail.com>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
 <CAHk9a9d_xm2nO1t5GsLJiny1V3H=uv8jGuUTywQetZQOXxyG9w@mail.gmail.com>
Message-ID: <N9ny4XfpI4SATvCXSKO_ns03ONm4p17tAGXxInoXIe16S7zfH6b8Uj2SkS-pL5sEEp7Wpyi0RZ8J92WZPDeHYKBBuq1xnV6eEUbKouej-TU=@wuille.net>

Hi all,

A few updates, in response to comments here and in a few other places:

- Updated several reference implementations (C, C++, Python, Javascript) to support Bech32m: https://github.com/sipa/bech32/tree/bech32m (but contributions to update other languages are welcome!)

- Updated website, including error-locating JS decoder, and demo: http://bitcoin.sipa.be/bech32/demo/demo.html

- Opened a Bitcoin Core PR: https://github.com/bitcoin/bitcoin/pull/20861

- Updates to the BIP draft (https://github.com/sipa/bips/blob/bip-bech32m/bip-bech32m.mediawiki):
  * Made the title clearer (so it doesn't imply Bech32m is used for v0)
  * Added rationale for not permitting both Bech32 and Bech32m for v0
  * Added a section on error location
  * Added links for more reference implementations

On Friday, January 15, 2021 12:01 AM, nakagat <nakagat at gmail.com> wrote:

> I read the BIP draft of Bech32m and implemented it in Go.

Cool! Do feel like contributing it to https://github.com/sipa/bech32/tree/bech32m?

> Let me ask you one question.
> Does Checksum have to be fixed?
> The 'bech32_verify_checksum' function has hrp and data as parameters,
> so how about committing Checksum with these two values?
>
> For example, calculate Checksum from hrp and data using hash, chacha20, etc.

I'm not entirely sure what you mean. Do you mean:

1) Can we use a hash function to compute the checksum instead of Bech32's algorithm?

If you compute the checksum using the HRP and the data using a hash function, you just 2^-30 failure probability for any error. The idea behind Bech32 was doing better than that for common errors: any error that consists of up to 4 substitutions are a failure probability of 0 - far better than a hash can do.

2) Can we keep using Bech32's algorithm, but compute the final xorred-in constant from the HRP and the data using a hash function?

That would be functionally equivalent to (1).

3) Can we keep using Bech32's algorithm, but compute the final xorred-in constant from the HRP (but not the data) using a hash function?

It would mean that some (very) small set of potential HRPs would exhibit much worse behavior than others - including the 'q'-before-'p' that the original Bech32 has.

Does that clarify things?

Cheers,

--
Pieter


From nakagat at gmail.com  Mon Jan 18 05:59:05 2021
From: nakagat at gmail.com (nakagat)
Date: Mon, 18 Jan 2021 14:59:05 +0900
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <N9ny4XfpI4SATvCXSKO_ns03ONm4p17tAGXxInoXIe16S7zfH6b8Uj2SkS-pL5sEEp7Wpyi0RZ8J92WZPDeHYKBBuq1xnV6eEUbKouej-TU=@wuille.net>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
 <CAHk9a9d_xm2nO1t5GsLJiny1V3H=uv8jGuUTywQetZQOXxyG9w@mail.gmail.com>
 <N9ny4XfpI4SATvCXSKO_ns03ONm4p17tAGXxInoXIe16S7zfH6b8Uj2SkS-pL5sEEp7Wpyi0RZ8J92WZPDeHYKBBuq1xnV6eEUbKouej-TU=@wuille.net>
Message-ID: <CAHk9a9egxmTQqSLs9PUuH1L8q_c7hp_oo4jT1+BP0ga=aFCPhQ@mail.gmail.com>

Dear. Peter,

I'm not good at English, so I'm sorry for the poor explanation.

I thought that BECH32M_CONST could be created from hrp and data
instead of constants.

I thought that the error position would be the same as bech32 by
recalculating the value created from hrp and data.

If this were possible, I thought I could commit hrp and data to the checksum.

Thank you.
Takatoshi Nakagawa

2021?1?18?(?) 13:15 Pieter Wuille <bitcoin-dev at wuille.net>:
>
> Hi all,
>
> A few updates, in response to comments here and in a few other places:
>
> - Updated several reference implementations (C, C++, Python, Javascript) to support Bech32m: https://github.com/sipa/bech32/tree/bech32m (but contributions to update other languages are welcome!)
>
> - Updated website, including error-locating JS decoder, and demo: http://bitcoin.sipa.be/bech32/demo/demo.html
>
> - Opened a Bitcoin Core PR: https://github.com/bitcoin/bitcoin/pull/20861
>
> - Updates to the BIP draft (https://github.com/sipa/bips/blob/bip-bech32m/bip-bech32m.mediawiki):
>   * Made the title clearer (so it doesn't imply Bech32m is used for v0)
>   * Added rationale for not permitting both Bech32 and Bech32m for v0
>   * Added a section on error location
>   * Added links for more reference implementations
>
> On Friday, January 15, 2021 12:01 AM, nakagat <nakagat at gmail.com> wrote:
>
> > I read the BIP draft of Bech32m and implemented it in Go.
>
> Cool! Do feel like contributing it to https://github.com/sipa/bech32/tree/bech32m?
>
> > Let me ask you one question.
> > Does Checksum have to be fixed?
> > The 'bech32_verify_checksum' function has hrp and data as parameters,
> > so how about committing Checksum with these two values?
> >
> > For example, calculate Checksum from hrp and data using hash, chacha20, etc.
>
> I'm not entirely sure what you mean. Do you mean:
>
> 1) Can we use a hash function to compute the checksum instead of Bech32's algorithm?
>
> If you compute the checksum using the HRP and the data using a hash function, you just 2^-30 failure probability for any error. The idea behind Bech32 was doing better than that for common errors: any error that consists of up to 4 substitutions are a failure probability of 0 - far better than a hash can do.
>
> 2) Can we keep using Bech32's algorithm, but compute the final xorred-in constant from the HRP and the data using a hash function?
>
> That would be functionally equivalent to (1).
>
> 3) Can we keep using Bech32's algorithm, but compute the final xorred-in constant from the HRP (but not the data) using a hash function?
>
> It would mean that some (very) small set of potential HRPs would exhibit much worse behavior than others - including the 'q'-before-'p' that the original Bech32 has.
>
> Does that clarify things?
>
> Cheers,
>
> --
> Pieter
>

From lucasontivero at gmail.com  Mon Jan 18 20:38:51 2021
From: lucasontivero at gmail.com (Lucas Ontivero)
Date: Mon, 18 Jan 2021 17:38:51 -0300
Subject: [bitcoin-dev] PayJoin adoption
In-Reply-To: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>
References: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>
Message-ID: <CALHvQn3Z39cBLrtVfrd9_DGQnSZm9EuymoaaAB0qKWA4QYc2_w@mail.gmail.com>

Hi

Before all, thanks for the wiki page tracking the payjoin adoption, it is a
good idea.

-----

Even when there is a reasonable economical incentive to use segwit
transactions to save fees a big percentage of the transactions are not
using segwit yet. In the case of payjoins the economic incentives are not
so big while the privacy benefits are not so clear for the payer as they
are for the global transactions graph as a whole. This means that payjoins
requires some level of altruist attitude from the payers. The payjoins UX
is also not good because I think most users are not familiar with bip21
uris (users still request support because they pay a bech32 address in an
exchange and the exchange tells them that's not a valid bitcoin address).
All this is relative and subjective but in general terms I would say it is
more or less true for many people.

Anyway, imagine wallets' developers agree on making payjoins payment by
default because it is the right thing to do (fight against surveillance to
spy on bitcoin users and improve bitcoin's fungibility). In that case it
should be completely transparent to the users and at not cost, it shouldn't
require the user to do anything different, it shouldn't be noticeable
slower, etc. In fact, users should have to know they are payjoining at all.

The only way I see to achieve something like that is by moving to schemes
where wallets can communicate and interact. I should be able to know
something about you that allows me to select your name from my contact list
and select "Pay to Chris" and if my wallet knows how to find yours then it
can request a new address and pays, or generate a new one for you (probably
using a output descriptor you created to share with me).

Sorry for the long semi-random rant.

El vie, 15 ene 2021 a las 21:07, Chris Belcher via bitcoin-dev (<
bitcoin-dev at lists.linuxfoundation.org>) escribi?:

> PayJoin is an exciting bitcoin privacy technology which has the
> potential to damage the ability of blockchain surveillance to spy on
> bitcoin users and destroy bitcoin's fungibility. A protocol standard has
> already been defined and implemented by a couple of projects such as
> BTCPayServer, Wasabi Wallet, JoinMarket and BlueWallet.
>
> I've made a wiki page tracking adoption:
> https://en.bitcoin.it/wiki/PayJoin_adoption
>
> It is similar to the Bech32 adoption page.
>
>
> Recently a UK bitcoin exchange shut down due to new regulations, with
> the owner writing a very interesting and relevant blog post that I'll
> quote here:
>
> > you?re considered suspicious if you used a marketplace and not an
> exchange. Coinjoin counts as high risk. Gambling is high risk. As you
> use entities that are paranoid about keeping their coins clean and
> adhering to all the regulations, your risk scores will continue to
> increase and without you even knowing why, your deposits will become
> rejected, you may be asked to supply documents or lose the coins, your
> account may become suspended without you having any clue what you did
> wrong. And quite possibly you didn?t do anything wrong. But that won?t
> matter.
> >
> > The goal post, the risk score threshold will keep moving along this
> trend until the point where you will be afraid of using your personal
> wallet, donating to someone online, receiving bitcoins from anywhere
> except for regulated exchanges. At that point, crypto will be akin to a
> regular bank account. You won?t have a bitcoin wallet, you will have
> accounts to websites.
>
> https://blog.bitbargain.com/post/638504004285054976/goodbye
>
> If we want bitcoin to fulfill its dream of a permissionless money for
> the internet then we'll have to work on this. What can we do to increase
> adoption of PayJoin?
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210118/d900c8f8/attachment.html>

From belcher at riseup.net  Tue Jan 19 15:44:11 2021
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 19 Jan 2021 15:44:11 +0000
Subject: [bitcoin-dev] PayJoin adoption
In-Reply-To: <CALHvQn3Z39cBLrtVfrd9_DGQnSZm9EuymoaaAB0qKWA4QYc2_w@mail.gmail.com>
References: <2b8ba39f-8fe9-8800-b8e6-47ca263774d5@riseup.net>
 <CALHvQn3Z39cBLrtVfrd9_DGQnSZm9EuymoaaAB0qKWA4QYc2_w@mail.gmail.com>
Message-ID: <828e0ad4-8fe6-7db9-630f-daae51c04c3a@riseup.net>

Regarding incentives, privacy is itself an incentive.

If your business suffers from being spied on (for example you're a
casino or p2p exchange, and regulated exchanges keep banning your
customers) then the cost of adopting payjoin is worth it. That's why I
expect and hope that p2p exchanges will be one of the earlier adopters.

While researching for the Adoption page I was surprised to find that one
exchange has already adopted PayJoin: a no-signup altcoin exchange
called sideshift.ai


On 18/01/2021 20:38, Lucas Ontivero wrote:
> Hi
> 
> Before all, thanks for the wiki page tracking the payjoin adoption, it is a
> good idea.
> 
> -----
> 
> Even when there is a reasonable economical incentive to use segwit
> transactions to save fees a big percentage of the transactions are not
> using segwit yet. In the case of payjoins the economic incentives are not
> so big while the privacy benefits are not so clear for the payer as they
> are for the global transactions graph as a whole. This means that payjoins
> requires some level of altruist attitude from the payers. The payjoins UX
> is also not good because I think most users are not familiar with bip21
> uris (users still request support because they pay a bech32 address in an
> exchange and the exchange tells them that's not a valid bitcoin address).
> All this is relative and subjective but in general terms I would say it is
> more or less true for many people.
> 
> Anyway, imagine wallets' developers agree on making payjoins payment by
> default because it is the right thing to do (fight against surveillance to
> spy on bitcoin users and improve bitcoin's fungibility). In that case it
> should be completely transparent to the users and at not cost, it shouldn't
> require the user to do anything different, it shouldn't be noticeable
> slower, etc. In fact, users should have to know they are payjoining at all.
> 
> The only way I see to achieve something like that is by moving to schemes
> where wallets can communicate and interact. I should be able to know
> something about you that allows me to select your name from my contact list
> and select "Pay to Chris" and if my wallet knows how to find yours then it
> can request a new address and pays, or generate a new one for you (probably
> using a output descriptor you created to share with me).
> 
> Sorry for the long semi-random rant.
> 
> El vie, 15 ene 2021 a las 21:07, Chris Belcher via bitcoin-dev (<
> bitcoin-dev at lists.linuxfoundation.org>) escribi?:
> 
>> PayJoin is an exciting bitcoin privacy technology which has the
>> potential to damage the ability of blockchain surveillance to spy on
>> bitcoin users and destroy bitcoin's fungibility. A protocol standard has
>> already been defined and implemented by a couple of projects such as
>> BTCPayServer, Wasabi Wallet, JoinMarket and BlueWallet.
>>
>> I've made a wiki page tracking adoption:
>> https://en.bitcoin.it/wiki/PayJoin_adoption
>>
>> It is similar to the Bech32 adoption page.
>>
>>
>> Recently a UK bitcoin exchange shut down due to new regulations, with
>> the owner writing a very interesting and relevant blog post that I'll
>> quote here:
>>
>>> you?re considered suspicious if you used a marketplace and not an
>> exchange. Coinjoin counts as high risk. Gambling is high risk. As you
>> use entities that are paranoid about keeping their coins clean and
>> adhering to all the regulations, your risk scores will continue to
>> increase and without you even knowing why, your deposits will become
>> rejected, you may be asked to supply documents or lose the coins, your
>> account may become suspended without you having any clue what you did
>> wrong. And quite possibly you didn?t do anything wrong. But that won?t
>> matter.
>>>
>>> The goal post, the risk score threshold will keep moving along this
>> trend until the point where you will be afraid of using your personal
>> wallet, donating to someone online, receiving bitcoins from anywhere
>> except for regulated exchanges. At that point, crypto will be akin to a
>> regular bank account. You won?t have a bitcoin wallet, you will have
>> accounts to websites.
>>
>> https://blog.bitbargain.com/post/638504004285054976/goodbye
>>
>> If we want bitcoin to fulfill its dream of a permissionless money for
>> the internet then we'll have to work on this. What can we do to increase
>> adoption of PayJoin?
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> 

From bitcoin-dev at wuille.net  Tue Jan 19 17:57:08 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 19 Jan 2021 17:57:08 +0000
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <CAHk9a9egxmTQqSLs9PUuH1L8q_c7hp_oo4jT1+BP0ga=aFCPhQ@mail.gmail.com>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
 <CAHk9a9d_xm2nO1t5GsLJiny1V3H=uv8jGuUTywQetZQOXxyG9w@mail.gmail.com>
 <N9ny4XfpI4SATvCXSKO_ns03ONm4p17tAGXxInoXIe16S7zfH6b8Uj2SkS-pL5sEEp7Wpyi0RZ8J92WZPDeHYKBBuq1xnV6eEUbKouej-TU=@wuille.net>
 <CAHk9a9egxmTQqSLs9PUuH1L8q_c7hp_oo4jT1+BP0ga=aFCPhQ@mail.gmail.com>
Message-ID: <ER4Y1yqunl3NMmLFDYpDeXsw-MhtS3KBmSTnDQib7yVXas_HGoD7GgOPcQ6v0lSr9BG2ntXoYW4kEKiZ0VdDgecwxJOLMAvuIpUzbCpM6WI=@wuille.net>

On Sunday, January 17, 2021 9:59 PM, nakagat <nakagat at gmail.com> wrote:

> I thought that BECH32M_CONST could be created from hrp and data
> instead of constants.
>
> I thought that the error position would be the same as bech32 by
> recalculating the value created from hrp and data.

So, bech32 can be written as:

* checksum = polymod(expand(hrp) + data) xor 1

Bech32m changes that to:

* checksum = polymod(expand(hrp) + data) xor 0x2bc830a3

I believe that your idea is:

* checksum = polymod(expand(hrp) + data) xor hash(hrp, data)

That has exactly the same error detecting capabilities as:

* checksum = hash(hrp, data)

The hashing makes all types of errors uniform, and it doesn't matter what other things are added to the checksum. Once you hash the data, the checksum is uniformly random, and you can't make it "less random" anymore.

In this case, we *want* non-uniformity. The polymod function as a checksum detects some kinds of errors much better than others, and this is what we want.

Does that clarify things?

Cheers,

--
Pieter



From sdaftuar at gmail.com  Tue Jan 19 19:19:12 2021
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Tue, 19 Jan 2021 14:19:12 -0500
Subject: [bitcoin-dev] Proposal for new "disabletx" p2p message
In-Reply-To: <20210114064600.gu2qetgo5cw4tl5q@erisian.com.au>
References: <CAFp6fsE6gb2PaL3ikDRjS-hNnPLjvtWB+8qZJr3trQe2K9YN+g@mail.gmail.com>
 <20210114064600.gu2qetgo5cw4tl5q@erisian.com.au>
Message-ID: <CAFp6fsH3s1Jtbsa0+uzd=HweO09RRfJHovmyqsT6f3+E30KqsA@mail.gmail.com>

On Thu, Jan 14, 2021 at 1:46 AM Anthony Towns <aj at erisian.com.au> wrote:

> > ==Specification==
> > # A new disabletx message is added, [...]
> > # A node that has sent or received a disabletx message to/from a peer
> MUST NOT send any of these messages to the peer:
> > ## inv messages for transactions
> > [...]
> > # It is RECOMMENDED that a node that has sent or received a disabletx
> message to/from a peer not send any of these messages to the peer:
> > ## addr/getaddr
> > ## addrv2 (BIP 155)
>
> In particular, I think combining these doesn't make sense for:
>
>  * nodes running with -blocksonly (that want to stay up to date with
>    the blockchain, but don't care about txes)
>     - not sending disabletx reduces their potential connectivity, if
>       nodes are willing to accept more disabletx peers due to the lower
>       resource usage
>     - sending disabletx means they can't maintain their addr db and find
>       other nodes to connect to
>

This is quite implementation specific, but the Bitcoin Core implementation
of -blocksonly already differs from what you would get if all outbound
connections were treated as block-relay-only peers; I initially tried to
make the -blocksonly setting behave the same as block-relay-only
connections and never relay transactions, but it turned out that Bitcoin
Core currently allows users running in -blocksonly mode to sometimes relay
transactions themselves (there's even a test for it [1]).

This isn't compatible with the design of disabletx, so I don't think it
could be used.  I think that is okay, as I don't think we need to make
allowances right now to encourage the use of more -blocksonly nodes on the
network by prioritizing their existing outbound connections[2]. In the case
of block-relay-only connections, the next step I plan to propose in the
Bitcoin Core implementation is an increase in the number of inbound slots
to accommodate additional disabletx peers, to facilitate an eventual
increase in the number of outbound block-relay-only connections that
Bitcoin Core would initiate by default (and reduce potential concern about
overwhelming the network's capacity).

 * non-listening nodes running with -connect to one/more preselected peers
>     - they can't send disabletx generally because they want txes
>     - they don't need addr information (since they only make connections
>       to some known peers), and don't have many peers to relay addresses
>       on to, so are essentially blackholes, so would like to disable
>       addr relay for much the same reasons
>

While I think it's a valid use-case if someone wants to run nodes in this
way, I don't see why it has direct bearing on this discussion -- adding
protocol support for this use case is not incompatible with my disabletx
proposal; indeed, once we have worked out an addr relay protocol that
supports a peer telling another to not relay addresses, I would plan to use
it along with disabletx.

-----

There was some discussion about this proposal on IRC recently as well [3]
and this issue of mentioning addr-relay in a BIP about tx-relay seems to
have drawn some critique.  I think if there were some other use case that
other developers have which would use disabletx (say, because the current
fRelay solution also is inadequate for those use cases today), yet would
want addr relay on these links, then that would be a good reason to drop
mention of it from the BIP and defer discussion of addr relay entirely to
some new future proposal.  However, I'm not yet aware of such a use case,
as the -blocksonly one mentioned above does not actually fit (and nor do I
think that a -blocksonly mode where transactions are never sent but addr
messages are exchanged is necessary beyond how we already do that today, by
just sending fRelay=false).

Moreover, because there is no specification/BIP that governs how address
relay should work on the network, I think that if we just dropped mention
of addr-relay from the BIP, that software ought to just disable addr-relay
to nodes sending disabletx, anyway!  Addr relay is currently purely local
policy, so I think it's reasonable to conclude that if the only known use
case of a peer sending disabletx is for a behavior that also would drop
addr messages, then optimizing software for that use case is logical and I
would propose that myself for how Bitcoin Core behaves.  It seems polite to
mention this in the BIP as well, so that other software implementors have
the same understanding that I have for how this should work, until we have
an address relay protocol extension that governs it explicitly.

-----

Why not simply add a "disableaddr" type of message now?  I am not opposed
to someone championing an addr relay protocol, but I personally think it is
premature.  I'm not aware of any research or shared understanding of what
the goals of address relay are or ought to be, particularly as they pertain
to how addresses for obscure networks ought to propagate to nodes that may
or may not support those networks.  Moreover, I'm not aware of any research
into what relay strategies make sense to achieve any particular relay goals
we might come up with.  I imagine that we will someday propose a way for
software to communicate support for various network types (as defined in
BIP 155), and that will relate to the kinds of relay policies we expect
software on the network to be running.  But I think any p2p message we add
now to simply "disableaddr" would be made redundant by a more extensive
protocol in the future, so I don't feel comfortable defending a proposal to
add such a message at this time, when it seems to be unnecessary for
today's use cases.

So to summarize my view on this BIP's recommendation against sending addr
messages to disabletx peers: if there is some software that someone plans
to deploy soon that would seek to use disabletx but would prefer addr relay
on these links, then I think that would cause me to re-evaluate this
proposal to figure out the best way to achieve both use cases.  For now I
think the recommendation I've proposed still makes sense.

--Suhas

[1]
https://github.com/bitcoin/bitcoin/blob/f91587f050d9dceb45fe10129a76a4a9a060a09c/test/functional/p2p_blocksonly.py#L36

[2] Perhaps confusingly, running in -blocksonly mode is largely irrelevant
to the outbound peering of such a node, as it makes 10 outbound connections
by default, 8 of which are considered "full-relay" yet send fRelay=false to
not receive inbound transaction traffic, and 2 considered
"block-relay-only", also setting fRelay=false, but also not ever announcing
transactions on those links.  I anticipate that in the future, Bitcoin Core
software running in -blocksonly mode will continue to treat those 8
"full-relay" connections the same as today, and just start sending the
disabletx message on the connections it considers to be truly
block-relay-only (the two existing connections, along with any additional
ones we later add).

[3]
https://bitcoin.jonasschnelli.ch/ircmeetings/logs/bitcoin-core-dev/2021/bitcoin-core-dev.2021-01-12-15.00.log.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210119/996bcadd/attachment-0001.html>

From bitcoin-dev at wuille.net  Wed Jan 20 00:29:36 2021
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Wed, 20 Jan 2021 00:29:36 +0000
Subject: [bitcoin-dev] Bech32m BIP: new checksum,
	and usage for segwit address
In-Reply-To: <CAHk9a9crrQJFUZ5EcBUfz5QCdxHzgTiN1b9_ocfMgf4Qhx98Pw@mail.gmail.com>
References: <jfRUzc8uB5fpIQy-a_TfTwjAD4FMtf2eInfHdgZRoLwc0NdTv7srnRLtmwFHPLInJfglSzOXXe0SVR3cgHejGPi0Kwl81UV_wkwVJcQi1rA=@wuille.net>
 <CAHk9a9d_xm2nO1t5GsLJiny1V3H=uv8jGuUTywQetZQOXxyG9w@mail.gmail.com>
 <N9ny4XfpI4SATvCXSKO_ns03ONm4p17tAGXxInoXIe16S7zfH6b8Uj2SkS-pL5sEEp7Wpyi0RZ8J92WZPDeHYKBBuq1xnV6eEUbKouej-TU=@wuille.net>
 <CAHk9a9egxmTQqSLs9PUuH1L8q_c7hp_oo4jT1+BP0ga=aFCPhQ@mail.gmail.com>
 <ER4Y1yqunl3NMmLFDYpDeXsw-MhtS3KBmSTnDQib7yVXas_HGoD7GgOPcQ6v0lSr9BG2ntXoYW4kEKiZ0VdDgecwxJOLMAvuIpUzbCpM6WI=@wuille.net>
 <CAHk9a9crrQJFUZ5EcBUfz5QCdxHzgTiN1b9_ocfMgf4Qhx98Pw@mail.gmail.com>
Message-ID: <WbHmWTdrVtO8kbI3xfn9S7-g8zruzRt_hngpxvJQWC0ibNSNMWXo3I1gjt9vzhF53pRbh-14VjPcA1JKckgaogi-fu3F48Yfwqmm2rX8K8g=@wuille.net>

On Tuesday, January 19, 2021 4:23 PM, nakagat <nakagat at gmail.com> wrote:

> Dear. Pieter,
>
> My idea is exactly what you wrote.
>
> However, I don't think it is the same as "checksum = hash (hrp, data)".

No, it is not the same. But it has the same error-detection properties as just a hash. Hash-based checksums aren't bad, but:
* The BCH based checksum that Bech32 uses is better at detecting certain subsets of errors than a hash can be. Once you add in a hash you irrevocably lose these properties.
* If we wanted a checksum with error detection properties that are equivalent to a hash, we should just use a hash like Base58Check did. However, that's not the goal of Bech32/Bech32m.

If this isn't clear, I'm afraid I don't know how to continue discussing this. We can take if off this list, if you want.

Cheers,

--
Pieter


From achow101-lists at achow101.com  Thu Jan 21 19:50:45 2021
From: achow101-lists at achow101.com (Andrew Chow)
Date: Thu, 21 Jan 2021 19:50:45 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <e87f1e08-4bf2-8bf5-d408-3c0b603b8a7f@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <40089cb5-8d68-1868-c87b-241f2bd747fb@achow101.com>
 <e87f1e08-4bf2-8bf5-d408-3c0b603b8a7f@achow101.com>
Message-ID: <16f16c05-c3b3-57c2-5070-9e70c1823b40@achow101.com>

While working on the reference implementation for this, it occurred to 
me that the Inputs Modifiable flag needs to be more than just a boolean.

If there are existing signatures in the PSBT, then any added inputs 
cannot change the transaction's locktime as all signatures, regardless 
of sighash type, commit to the locktime. Additionally if an input with a 
signature is being added, it also needs to set the locktime for the 
transaction.

It also seems like the SIGHASH_SINGLE bitmap is unnecessary. Signers can 
instead iterate all inputs, check for existing signatures, and extract 
the sighash byte from those signatures to determine whether any are 
SIGHASH_SINGLE. This bitmap doesn't seem to provide much benefit and 
also causes headaches for implementation. So I've decided to remove it.

But it is still useful to know that there are SIGHASH_SINGLE inputs and 
that iteration of the inputs vector will be necessary. It is also useful 
to know that there are already some signatures in the transaction so the 
locktime must be preserved. Thus I would like to change 
PSBT_GLOBAL_TX_MODIFIABLE to include those. I propose making 
PSBT_GLOBAL_TX_MODIFIABLE an 8 bit unsigned little endian integer that 
is treated as a bit field. If bit 0 is set, inputs may be added. This 
will be the Inputs Modifiable flag. If bit 1 is set, outputs may be 
added. This will be the Outputs Modifiable flag. If bit 2 is set, the 
transaction contains signatures and locktime must be preserved. This 
will be the Has Signatures flag. If bit 3 is set, the transaction 
contains SIGHASH_SINGLE inputs and their index pairings must be 
preserved. This will be the Has SIGHASH_SINGLE flag.

Changing PSBT_GLOBAL_TX_MODIFIABLE to a bitfield like this allows us to 
include more conditions that need to be considered when adding inputs 
and outputs. I think these are all of the conditions for now, but with 8 
bits, there is still some space for additional conditions in the future. 
Perhaps it should be changed to be larger if we think there will be more 
conditions, but I think that is unlikely.


Andrew

On 1/15/21 12:28 PM, Andrew Chow wrote:
> Hi All,
>
> I've made some reorganization changes to the way that new PSBT versions
> should be handled in BIP 174 (see
> https://github.com/bitcoin/bips/pull/1055) so PSBTv2 will be submitted
> as a separate BIP. The full document can be read at
> https://github.com/achow101/bips/blob/psbt2/bip-psbt2.mediawiki and I
> have also included it in this email.
>
> I've included Rusty's suggestion for PSBT_GLOBAL_UNDER_CONSTRUCTION and
> made a few modifications. First, the field will be named
> PSBT_GLOBAL_TX_MODIFIABLE and only include the inputs modifiable and
> outputs modifiable flags. The SIGHASH_SINGLE bitmap will be included as
> a separate field PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS. This allows most
> PSBTs to not have to carry around a useless bitmap.
>
> Andrew
>
> ***
>
> <pre>
>   ? BIP: PSBTv2
>   ? Layer: Applications
>   ? Title: PSBT Version 2
>   ? Author: Andrew Chow <achow101 at gmail.com>
>   ? Comments-Summary: No comments yet.
>   ? Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-PSBT2
>   ? Status: Draft
>   ? Type: Standards Track
>   ? Created: 2021-01-14
>   ? License: BSD-2-Clause
> </pre>
>
> ==Introduction==
>
> ===Abstract===
>
> This document proposes a second version of the Partially Signed Bitcoin
> Transaction format
> described in BIP 174 which allows for inputs and outputs to be added to
> the PSBT after creation.
>
> ===Copyright===
>
> This BIP is licensed under the 2-clause BSD license.
>
> ===Motivation===
>
> Partially Signed Bitcoin Transaction Version 0 as described in BIP 174
> is unable to have new
> inputs and outputs be added to the transaction. The fixed global
> unsigned transaction
> cannot be changed which prevents any additional inputs or outputs to be
> added.
> PSBT Version 2 is intended to rectify this problem.
>
> An additional benficial side effect is that all information for a given
> input or output will be
> provided by its <tt><input-map></tt> or <tt><output-map></tt>. With
> Version 0, to retrieve
> all of the information for an input or output, data would need to be
> found in two locations:
> the <tt><input-map></tt>/<tt><output-map></tt> and the global unsigned
> transaction. PSBT
> Version 2 now moves all related information to one place.
>
> ==Specification==
>
> PSBT Version 2 (PSBTv2) only specifies new fields and field
> inclusion/exclusion requirements.
>
> <tt>PSBT_GLOBAL_UNSIGNED_TX</tt> must be excluded in PSBTv2.
> <tt>PSBT_GLOBAL_VERSION</tt> must be included in PSBTv2 and set to
> version number 2<ref>'''What happened to version number 1?'''
> Version number 1 is skipped because PSBT Version 0 has been colloquially
> referred to as version 1. Originally this BIP was to be
> version 1, but because it has been colloquially referred to as version 2
> during its design phrase, it was decided to change the
> version number to 2 so that there would not be any confusion</ref>.
>
> The new global types for PSBT Version 2 are as follows:
>
> {|
> ! Name
> ! <tt><keytype></tt>
> ! <tt><keydata></tt>
> ! <tt><keydata></tt> Description
> ! <tt><valuedata></tt>
> ! <tt><valuedata></tt> Description
> ! Versions Requiring Inclusion
> ! Versions Requiring Exclusion
> ! Versions Allowing Inclusion
> |-
> | Transaction Version
> | <tt>PSBT_GLOBAL_TX_VERSION = 0x02</tt>
> | None
> | No key data
> | <tt><32-bit uint></tt>
> | The 32-bit little endian signed integer representing the version
> number of the transaction being created. Note that this is not the same
> as the PSBT version number specified by the PSBT_GLOBAL_VERSION field.
> | 2
> | 0
> | 2
> |-
> | Fallback Locktime
> | <tt>PSBT_GLOBAL_FALLBACK_LOCKTIME = 0x03</tt>
> | None
> | No key data
> | <tt><32-bit uint></tt>
> | The 32-bit little endian unsigned integer representing the transaction
> locktime to use if no inputs specify a required locktime.
> |
> | 0
> | 2
> |-
> | Input Count
> | <tt>PSBT_GLOBAL_INPUT_COUNT = 0x04</tt>
> | None
> | No key data
> | <tt><compact size uint></tt>
> | Compact size unsigned integer representing the number of inputs in
> this PSBT.
> | 2
> | 0
> | 2
> |-
> | Output Count
> | <tt>PSBT_GLOBAL_OUTPUT_COUNT = 0x05</tt>
> | None
> | No key data
> | <tt><compact size uint></tt>
> | Compact size unsigned integer representing the number of outputs in
> this PSBT.
> | 2
> | 0
> | 2
> |-
> | Transaction Modifiable Flags
> | <tt>PSBT_GLOBAL_TX_MODIFIABLE = 0x06</tt>
> | None
> | No key data
> | <tt><single byte boolean> <single byte boolean></tt>
> | A single byte boolean (0 for False, 1 for True) representing whether
> inputs can be modified, referred to as the Inputs Modifiable Flag. This
> is followed by a single byte boolean representing whether outputs can be
> modified, referred to as the Outputs Modifiable Flag.
> |
> | 0
> | 2
> |-
> | SIGHASH_SINGLE Inputs
> | <tt>PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS = 0x07</tt>
> | None
> | No key data
> | <tt><bit vector></tt>
> | A bit vector representing which input indexes use SIGHASH_SINGLE. If
> the bit for an index is set to 1, then the input and output pair at that
> index are tied together with SIGHASH_SINGLE and must be moved together.
> |
> | 0
> | 2
> |}
>
> The new per-input types for PSBT Version 2 are defined as follows:
>
> {|
> ! Name
> ! <tt><keytype></tt>
> ! <tt><keydata></tt>
> ! <tt><keydata></tt> Description
> ! <tt><valuedata></tt>
> ! <tt><valuedata></tt> Description
> ! Versions Requiring Inclusion
> ! Versions Requiring Exclusion
> ! Versions Allowing Inclusion
> |-
> | Previous TXID
> | <tt>PSBT_IN_PREVIOUS_TXID = 0x0e</tt>
> | None
> | No key data
> | <tt><txid></tt>
> | 32 byte txid of the previous transaction whose output at
> PSBT_IN_OUTPUT_INDEX is being spent.
> | 2
> | 0
> | 2
> |-
> | Spent Output Index
> | <tt>PSBT_IN_OUTPUT_INDEX = 0x0f</tt>
> | None
> | No key data
> | <tt><32-bit uint></tt>
> | 32 bit little endian integer representing the index of the output
> being spent in the transaction with the txid of PSBT_IN_PREVIOUS_TXID.
> | 2
> | 0
> | 2
> |-
> | Sequence Number
> | <tt>PSBT_IN_SEQUENCE = 0x10</tt>
> | None
> | No key data
> | <tt><32-bit uint></tt>
> | The 32 bit unsigned little endian integer for the sequence number of
> this input. If omitted, the sequence number is assumed to be the final
> sequence number (0xffffffff).
> |
> | 0
> | 2
> |-
> | Required Time-based Locktime
> | <tt>PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x11</tt>
> | None
> | No key data
> | <tt><32-bit uint></tt>
> | 32 bit unsigned little endian integer greater than or equal to
> 500000000 representing the minimum Unix timestamp that this input
> requires to be set as the transaction's lock time.
> |
> | 0
> | 2
> |-
> | Required Height-based Locktime
> | <tt>PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x12</tt>
> | None
> | No key data
> | <tt><32-bit uiht></tt>
> | 32 bit unsigned little endian integer less than 500000000 representing
> the minimum block height that this input requires to be set as the
> transaction's lock time.
> |
> | 0
> | 2
> |}
>
> The new per-output types for PSBT Version 2 are defined as follows:
>
> {|
> ! Name
> ! <tt><keytype></tt>
> ! <tt><keydata></tt>
> ! <tt><keydata></tt> Description
> ! <tt><valuedata></tt>
> ! <tt><valuedata></tt> Description
> ! Versions Requiring Inclusion
> ! Versions Requiring Exclusion
> ! Versions Allowing Inclusion
> |-
> | Output Amount
> | <tt>PSBT_OUT_AMOUNT = 0x03</tt>
> | None
> | No key data
> | <tt><64-bit uint></tt>
> | 64 bit signed little endian integer representing the output's amount
> in satoshis.
> | 2
> | 0
> | 2
> |-
> | Output Script
> | <tt>PSBT_OUT_SCRIPT = 0x03</tt>
> | None
> | No key data
> | <tt><script></tt>
> | The script for this output, also known as the scriptPubKey. Must be
> omitted in PSBTv0. Must be provided in PSBTv2.
> | 2
> | 0
> | 2
> |}
>
> ===Determining Lock Time===
>
> The nLockTime field of a transaction is determined by inspecting the
> PSBT_GLOBAL_PREFERRED_LOCKTIME and each input's
> PSBT_IN_REQUIRED_TIME_LOCKTIME and PSBT_IN_REQUIRED_HEIGHT_LOCKTIME fields.
> If none of the inputs have a PSBT_IN_REQUIRED_TIME_LOCKTIME and
> PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then PSBT_GLOBAL_PREFERRED_LOCKTIME
> must be used.
> If PSBT_GLOBAL_PREFERRED_LOCKTIME is not provided, then it is assumed to
> be 0.
>
> If one or more inuts have a PSBT_IN_REQUIRED_TIME_LOCKTIME or
> PSBT_IN_REQUIRED_HEIGHT_LOCKTIME, then the field chosen is the one which
> is supported by all of the inputs.
> This can be determined by looking at all of the inputs which specify a
> locktime in either of those fields, and choosing the field which is
> present in all of those inputs.
> Inputs not specifying a lock time field can take both types of lock
> times, as can those that specify both.
> The lock time chosen is then the maximum value of the chosen type of
> lock time.
>
> ===Unique Identification===
>
> PSBTv2s can be uniquely identified by constructing an unsigned
> transaction given the information provided in the PSBT and computing the
> transaction ID of that transaction.
> Since PSBT_IN_SEQUENCE can be changed by Updaters and Combiners, the
> sequence number in this unsigned transaction must be set to 0 (not
> final, nor the sequence in PSBT_IN_SEQUENCE).
> The lock time in this unsigned transaction must be computed as described
> previously.
>
> ==Roles==
>
> PSBTv2 introduces new roles and modifies some existing roles.
>
> ===Creator===
>
> In PSBTv2, the Creator initializes the PSBT with 0 inputs and 0 outputs.
> The PSBT version number is set to 2. The transaction version number must
> be set to at least 2. <ref>'''Why does the transaction version number
> need to be at least 2?''' The transaction version number is part of the
> validation rules for some features such as OP_CHECKSEQUENCEVERIFY. Since
> it is backwards compatible, and there are other ways to disable those
> features (e.g. through sequence numbers), it is easier to require
> transactions be able to support these features than to try to negotiate
> the transaction version number.</ref>
> The Creator should also PSBT_GLOBAL_PREFERRED_LOCKTIME.
> If the Creator is not also a Constructor and will be giving the PSBT to
> others to add inputs and outputs, the PSBT_GLOBAL_TX_MODIFIABLE field
> must be present and and the Inputs Modifiable and Outputs Modifiable
> flags set appropriately.
> If the Creator is a Constructor and no inputs and outputs will be added
> by other entities, PSBT_GLOBAL_TX_MODIFIABLE may be omitted.
>
> ===Constructor===
>
> This Constructor is only present for PSBTv2.
> Once a Creator initializes the PSBT, a constructor will add inputs and
> outputs.
> Before any input or output may be added, the constructor must check the
> PSBT_GLOBAL_TX_MODIFIABLE field.
> Inputs may only be added if the Inputs Modifiable flag (first boolean)
> is True.
> Outputs may only be added if the Outputs Modifiable flag (second
> boolean) is True.
> If PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS is present and its bitvector
> indicates any inputs use SIGHASH_SINGLE, then the same number of inputs
> and outputs must be added before that input and its corresponding outputs.
>
> When an input or output is added, the corresponding
> PSBT_GLOBAL_INPUT_COUNT or PSBT_GLOBAL_OUTPUT_COUNT must be incremeted
> to reflect the number of inputs and outputs in the PSBT.
> When an input is added, it must have PSBT_IN_PREVIOUS_TXID and
> PSBT_IN_OUTPUT_INDEX set.
> When an output is added, it must have PSBT_OUT_VALUE and
> PSBT_OUT_OUTPUT_SCRIPT set.
> If the input has a required timelock, Constructors must set the
> requisite timelock field.
> If the input has a required time based timelock, then
> PSBT_IN_REQUIRED_TIME_TIMELOCK.
> If the input has a required height based timelock, then
> PSBT_IN_REQUIRED_HEIGHT_TIMELOCK.
> If an input has both types of timelocks, then both may be set.
> In some cases, an input that can allow both types, but a particular
> branch supporting only one type of timelock will be taken, then the type
> of timelock that will be used can be the only one set.
>
> When adding a new input, the new input must be compatible with the
> timelock types of all existing inputs.
> Since Bitcoin requires that a transaction uses only one type of
> timelock, all of the inputs must be able to support the same type of
> timelock.
> If the type of timelock is incompatible with the timelock type of the
> other inputs, then the input must not be added.
>
> Since a Constructor may be adding inputs to a PSBT that has inputs with
> existing signatures, the Constructor must be careful to not invalidate
> any existing signatures.
> The PSBT_GLOBAL_TX_MODIFIABLE and PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS
> fields caches this information so that constructors do not need to
> inspect every input.
> If the PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS bit vector indicates an input
> index uses SIGHASH_SINGLE, the same number of inputs and outputs must be
> added before that input and its corresponding output.
> When an input is added, the bit vector, if present, must be expanded to
> include a bit for this input in the correct position.
> When there are signatures, in addition to respecting the lock time rules
> described previously, the newly added inputs must not change the lock
> time used by the transaction.
> It cannot cause the lock time to change as that will invalidate all
> signatures since they all include the lock time regardless of the
> sighash type.
>
> A Constructor may choose to declare that no further inputs and outputs
> can be added to the transaction by setting the booleans in
> PSBT_GLOBAL_TX_MODIFIABLE to False or by removing this field entirely.
>
> A single entity is likely to be both a Creator and Constructor.
>
> ===Updater===
>
> For PSBTv2, an Updater can set the sequence number.
>
> ===Signer===
>
> For PSBTv2s, a signer must update the PSBT_GLOBAL_TX_MODIFIABLE and
> PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS fields after signing inputs so
> that these fields accurately reflects the state of the PSBT.
> If the Signer added a signature that does not use SIGHASH_ANYONECANPAY,
> the Input Modifiable flag must be set to False.
> If the Signer added a signature that does not use SIGHASH_NONE, the
> Outputs Modifiable flag must be set to False.
> If the Signer added a signature that uses SIGHASH_SINGLE, a
> PSBT_GLOBAL_SIGHASH_SINGLE_INPUTS field must be added if not present,
> and the corresponding bit in its bit vector must be set to 1.
>
> ===Transaction Extractor===
>
> For PSBTv2s, the transaction is constructed using the PSBTv2 fields.
> The lock time for this transaction is determined as described in the
> Determining Lock Time section.
> The Extractor should produce a fully valid, network serialized
> transaction if all inputs are complete.
>
> ==Compatibility==
>
> PSBTv2 shares the same gemeric format as PSBTv0 as defined in BIP 174.
> Parsers for PSBTv0 should
> be able to deserialize PSBTv2 with only changes to support the new fields.
>
> However PSBTv2 is incompatible with PSBTv0, and vice versa due to the
> use of the PSBT_GLOBAL_VERSION.
> This incompatibility is intentional so that PSBT_GLOBAL_UNSIGNED_TX
> could be removed in PSBTv2.
> However it is possible to convert a PSBTv2 to a PSBTv0 by creating an
> unsigned
> transaction from the PSBTv2 fields.
>
> ==Test Vectors==
>
> TBD
>
> ==Rationale==
>
> <references/>
>
> ==Reference implementation==
>
> The reference implementation of the PSBT format is available at
> https://github.com/achow101/bitcoin/tree/psbt2.
>
>
> On 12/23/20 4:32 PM, Andrew Chow wrote:
>> Hi All,
>>
>> The full modified BIP can be read at
>> https://github.com/achow101/bips/blob/psbt2/bip-0174.mediawiki.
>>
>> I will open a PR to the BIPs repo soon after further discussion on this.
>>
>>
>> Andrew
>>
>> On 12/22/20 3:12 PM, Andrew Chow wrote:
>>> Hi All,
>>>
>>> I have some updates on this after speaking with some people off-list.
>>>
>>> Firstly, the version number will be set to 2. In most discussions, this
>>> proposal was being referred to as PSBT version 2, so it'll be easier and
>>> clearer to set the version number to 2.
>>>
>>> For lock times, instead of a single? PSBT_IN_REQUIRED_LOCKTIME field,
>>> there will be 2 of them, one for a time based lock time, and the other
>>> for height based. These will be:
>>> * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
>>>     ? * Key: empty
>>>     ? * Value: 32 bit unsigned little endian integer greater than or equal
>>> to 500000000 representing the minimum Unix timestamp that this input
>>> requires to be set as the transaction's lock time. Must be omitted in
>>> PSBTv0, and may be omitted in PSBTv2
>>> * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
>>>     ? * Key: empty
>>>     ? * Value: 32 bit unsigned little endian integer less than 500000000
>>> representing the minimum block height that this input requires to be set
>>> as the transaction's lock time. Must be omitted in PSBTv0, and may be
>>> omitted in PSBTv2.
>>>
>>> Having two lock time fields is necessary due to the behavior where all
>>> inputs must use the same type of lock time (height or time). Thus if an
>>> input requires a particular type of lock time, it must set the requisite
>>> field. Any new inputs being added must be able to accommodate all
>>> existing inputs' lock time type. This means they either must not have a
>>> lock time specified (i.e. no OP_CLTV involved), or have branches that
>>> allow the acceptance of either type. If an input has a lock time type
>>> that is incompatible with the rest of the transaction, it must not be added.
>>>
>>> PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback
>>> option if no input lock time fields are present. If there are input lock
>>> times, all lock time calculations must ignore it.
>>>
>>> Any role which does lock time calculation will first check if there are
>>> input lock time fields. If there are not, it must then check for a
>>> PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the
>>> transaction's lock time. If it does not, the lock time is 0. If there
>>> are input lock time fields, it must choose the type which does not
>>> invalidate any inputs. The lock time is then determined to be the
>>> maximum value of all of the lock time fields for the chosen type.
>>>
>>>
>>> Additionally, I would like to add a new global field:
>>> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>>>     ? * Key: empty
>>>     ? * Value: A single byte as a boolean. 0 for False, 1 for True. All
>>> other values ore prohibited. Must be omitted for PSBTv0, may be omitted
>>> in PSBTv2.
>>>
>>> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
>>> outputs can be added to the PSBT. This flag may be set to True when
>>> inputs and outputs are being updated, signed, and finalized. However
>>> care must be taken when there are existing signatures. If this field is
>>> omitted or set to False, no further inputs and outputs may be added to
>>> the PSBT.
>>>
>>> Several rules must be followed to ensure that adding additional inputs
>>> and outputs will not invalidate existing signatures. First, an input or
>>> output adder must check for any existing signatures in all of the other
>>> inputs. If there are none, the input or output may be added in any
>>> position. If there are one or more signatures, each signature's sighash
>>> type must be examined. Inputs may only be added if all existing
>>> signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all
>>> existing signatures use SIGHASH_NONE. If an input has a signature using
>>> SIGHASH_SINGLE, the same number of inputs and outputs must be added
>>> before that input and it's corresponding output. For all other sighash
>>> types (i.e. SIGHASH_ALL and any future sighash types), no inputs or
>>> outputs may be added to the PSBT. Specific exceptions can be made in the
>>> future for additional sighash types.
>>>
>>> Furthermore, these newly added inputs must follow additional lock time
>>> rules. Because all signatures, regardless of sighash type, sign the
>>> transaction lock time, newly added inputs when there are existing
>>> signatures must have the same type of lock time used in the transaction,
>>> and must be less than or equal to the transaction lock time. It must not
>>> cause the transaction lock time to change, otherwise the signatures will
>>> be invalidated.
>>>
>>>
>>> Lastly, to uniquely identify transactions for combiners, a txid can be
>>> computed from the information present in the PSBT. Internally, combiners
>>> can create an unsigned transaction given the transaction version, the
>>> input prevouts, the outputs, and the computed locktime. This can then be
>>> used to calculate a txid and thus used as a way to identify PSBTs.
>>> Combiners will need to do this for all version 2 PSBTs in order to avoid
>>> combining distinct transactions.
>>>
>>>
>>> Andrew Chow
>>>
>>> On 12/9/20 5:25 PM, Andrew Chow wrote:
>>>> Hi All,
>>>>
>>>> I would like to propose a new PSBT version that addresses a few
>>>> deficiencies in the current PSBT v0. As this will be backwards
>>>> incompatible, a new PSBT version will be used, v1.
>>>>
>>>> The primary change is to truly have all input and output data for each
>>>> in their respective maps. Instead of having to parse an unsigned
>>>> transaction and lookup some data from there, and other data from the
>>>> correct map, all of the data for an input will be contained in its map.
>>>> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
>>>> Thus I propose that the following fields be added:
>>>>
>>>> Global:
>>>> * PSBT_GLOBAL_TX_VERSION = 0x02
>>>>      ? * Key: empty
>>>>      ? * Value: 32-bit little endian unsigned integer for the transaction
>>>> version number. Must be provided in PSBT v1 and omitted in v0.
>>>> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
>>>>      ? * Key: empty
>>>>      ? * Value: 32 bit little endian unsigned integer for the preferred
>>>> transaction lock time. Must be omitted in PSBT v0. May be provided in
>>>> PSBT v1, assumed to be 0 if not provided.
>>>> * PSBT_GLOBAL_INPUT_COUNT = 0x04
>>>>      ? * Key: empty
>>>>      ? * Value: Compact size unsigned integer. Number of inputs in this
>>>> PSBT. Must be provided in PSBT v1 and omitted in v0.
>>>> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
>>>>      ? * Key: empty
>>>>      ? * Value: Compact size unsigned integer. Number of outputs in this
>>>> PSBT. Must be provided in PSBT v1 and omitted in v0.
>>>>
>>>> Input:
>>>> * PSBT_IN_PREVIOUS_TXID = 0x0e
>>>>      ? * Key: empty
>>>>      ? * Value: 32 byte txid of the previous transaction whose output at
>>>> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
>>>> omitted in v0.
>>>> * PSBT_IN_OUTPUT_INDEX = 0x0f
>>>>      ? * Key: empty
>>>>      ? * Value: 32 bit little endian integer for the index of the output
>>>> being spent. Must be provided in PSBT v1 and omitted in v0.
>>>> * PSBT_IN_SEQUENCE = 0x0f
>>>>      ? * Key: empty
>>>>      ? * Value: 32 bit unsigned little endian integer for the sequence
>>>> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
>>>> to be max sequence (0xffffffff) if not provided.
>>>> * PSBT_IN_REQUIRED_LOCKTIME = 0x10
>>>>      ? * Key: empty
>>>>      ? * Value: 32 bit unsigned little endian integer for the lock time that
>>>> this input requires. Must be omitted in PSBT v0. May be provided in PSBT
>>>> v1, assumed to be 0 if not provided.
>>>>
>>>> Output:
>>>> * PSBT_OUT_VALUE = 0x03
>>>>      ? * Key: empty
>>>>      ? * Value: 64-bit unsigned little endian integer for the output's
>>>> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
>>>> * PSBT_OUT_OUTPUT_SCRIPT = 0x04
>>>>      ? * Key: empty
>>>>      ? * Value: The script for this output. Otherwise known as the
>>>> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
>>>>
>>>> This change allows for PSBT to be used in the construction of
>>>> transactions. With these new fields, inputs and outputs can be added as
>>>> needed. One caveat is that there is no longer a unique transaction
>>>> identifier so more care must be taken when combining PSBTs.
>>>> Additionally, adding new inputs and outputs must be done such that
>>>> signatures are not invalidated. This may be harder to specify.
>>>>
>>>> An important thing to note in this proposal are the fields
>>>> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
>>>> transaction only has a single locktime yet a PSBT may have multiple
>>>> locktimes. To choose the locktime for the transaction, finalizers must
>>>> choose the maximum of all of the *_LOCKTIME fields.
>>>> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
>>>> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
>>>> be set. This field allows finalizers to choose a locktime that is high
>>>> enough for all inputs without needing to understand the scripts
>>>> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
>>>> no inputs require a particular locktime.
>>>>
>>>> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
>>>> needs the version number bump to enforce backwards incompatibility.
>>>> However once the inputs and outputs of a PSBT are decided, a PSBT could
>>>> be "downgraded" back to v0 by creating the unsigned transaction from the
>>>> above fields, and then dropping these new fields.
>>>>
>>>> If the list finds that these changes are reasonable, I will write a PR
>>>> to modify BIP 174 to incorporate them.
>>>>
>>>> Thanks,
>>>> Andrew Chow



From michaelfolkson at gmail.com  Fri Jan 22 12:01:37 2021
From: michaelfolkson at gmail.com (Michael Folkson)
Date: Fri, 22 Jan 2021 12:01:37 +0000
Subject: [bitcoin-dev] Taproot activation meeting on IRC - Tuesday 2nd
	February 19:00 UTC
Message-ID: <CAFvNmHS4s_MbXP8o3kWmaUZ5Xks1b76jSDymp1Bjr--4R8_v3Q@mail.gmail.com>

There has been an incredible community effort to make progress towards
consensus on an activation method for the proposed Taproot soft fork.


Special mentions go to David Harding, AJ Towns, Aaron van Wirdum, Jonathan
Bier, Ben Carman, Alejandro De La Torre whose resources are linked below
but there have been many others, too many to name, who have all made an
impact on moving the needle in recent months.


Taproot activation proposals:
https://en.bitcoin.it/wiki/Taproot_activation_proposals


Activating Soft Forks in Bitcoin:
http://www.erisian.com.au/wordpress/2020/10/26/activating-soft-forks-in-bitcoin


BIP 8, BIP 9 or Modern Soft Fork Activation: How Bitcoin Could Upgrade
Next:
https://bitcoinmagazine.com/articles/bip-8-bip-9-or-modern-soft-fork-activation-how-bitcoin-could-upgrade-next


Bitcoin Softfork Activation Methodology:
https://blog.bitmex.com/bitcoin-softfork-activation-methodology/


Activating Taproot: https://suredbits.com/activating-taproot/


Taproot activation website: https://taprootactivation.com/


In an effort to get this closer to the finish line we are organizing a
meeting on IRC on the ##taproot-activation channel on Tuesday 2nd February
at 19:00 UTC. The primary objective will be to finalize the revised BIP 8
activation method but general questions or discussion on Taproot activation
are welcome too. There is lots of prior context so please do sufficient
pre-reading in advance of attending if you would like to participate.


The relevant pull requests relating to revised BIP 8 are:


Replace unused BIP 9 logic with draft BIP 8 (Bitcoin Core PR)


https://github.com/bitcoin/bitcoin/pull/19573


BIP 8: Make signalling during LOCKED_IN recommended rather than mandatory
(BIP PR)


https://github.com/bitcoin/bips/pull/1020


BIP 8: allow some MUST_SIGNAL blocks to not signal (BIP PR)


https://github.com/bitcoin/bips/pull/1021


Feel free to post comments or questions at any time on the
##taproot-activation channel IRC in advance or following the meeting.

-- 
Michael Folkson
Email: michaelfolkson at gmail.com
Keybase: michaelfolkson
PGP: 43ED C999 9F85 1D40 EAF4 9835 92D6 0159 214C FEE3
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210122/47eaf1f3/attachment.html>

From lkcl at lkcl.net  Mon Jan 25 18:00:35 2021
From: lkcl at lkcl.net (Luke Kenneth Casson Leighton)
Date: Mon, 25 Jan 2021 18:00:35 +0000
Subject: [bitcoin-dev] Libre/Open blockchain / cryptographic ASICs
Message-ID: <CAPweEDx4wH_PG8=wqLgM_+RfTQEUSGfax=SOkgTZhe1FagXF9g@mail.gmail.com>

folks, hi, please do cc me as i am subscribed "digest", apologies for the
inconvenience.

i've been speaking on and off with kanzure, asking his advice about a libre
/ transparently-developed ASIC / SoC, for some time, since meeting a very
interesting person at the Barcelona RISC-V Workshop in 2018.

this person pointed out that FIPS-approved algorithms, implemented in
FIPS-approved crypto-chips used in hardware wallets to protect billions to
trillions in cryptocurrency assets world-wide are basically asking for
trouble.  i heard 3rd-hand that the constants used in the original bitcoin
protocol were very deliberately changed from those approved by FIPS and the
NSA for exactly the reasons that drive people to question whether it is a
good idea to trust closed and secretive crypto-chips, no matter how
well-intentioned the company that manufactures them.  the person i met was
there to "sound out" interested parties willing to help with such a
venture, even to the extent of actually buying a Foundry, in order to
guarantee that the crypto-chip they would like to see made had not been
tampered with at any point during manufacturing.

at FOSDEM2019 i was also approached by a team that also wanted to do a
basic "embedded" processor, entirely libre-licensed, only in 350nm or
180nm, with just enough horsepower to do digital signing and so on.  since
then, fascinatingly, NLnet has obtained a new EU Horizon Grant and started
their "Assure" Programme:
https://nlnet.nl/assure/

(our application may be found here):
https://libre-soc.org/nlnet_2021_crypto_router/

in addition, betrusted (headed by Bunnie Huang) is also funded by NLnet and
is along similar lines:
https://betrusted.io/

NLnet is even funding LibreSOC with a 180nm test chip tape-out of the
LibreSOC Core, with help from Sorbonne University and
https://chips4makers.io
https://bugs.libre-soc.org/show_bug.cgi?id=199

and we also have funding to do Formal Correctness Proofs for the low-level
portions of the HDL (similar to c++ and python "assert", but for hardware)
https://bugs.libre-soc.org/show_bug.cgi?id=158

the point being that where even one year ago the idea of an open source
developer creating and paying for an actual ASIC was so ridiculous they
would be laughed at and viewed in a derisive fashion thereafter, reality is
that things are opening up to the point where even Foundry PDKs are now
open source:
https://github.com/google/skywater-pdk

technically it is possible to use Open Hardware to create commercial
(closed) products.  Richard Herveille, most well-known for his early
involvement in Opencores, was the Open Hardware developer responsible for
the HDL behind the first Antminer product by Bitmain, for example.  It used
his RV32 core and i believe he also developed the SHA256 HDL for them.
however that is different in that it was a closed product, not open for
independent public audit and review.

what i am therefore trying to say is that it is a genuinely achievable
goal, now, to create fully transparently-openly-developed ASICs that could
perform crytographic tasks such as mining and hardware wallet key
protection *and have a full audit trail* even to the extent of having
mathematical Formal Correctness Proofs.

my question is - therefore - with all that background in mind - is: is this
something that is of interest?

now, before getting all excited about the possibilities, it's critically
important to provide a reality-check on the costs involved:

* 350nm ASICs: https://chips4makers.io - EUR 1750 for 20 samples
* 180nm ASICs: EUR $600 per mm^2 MPW Shuttle (test ASICs) and EUR 50,000
for production masks
* ... exponential curve going through 130nm, 65nm, 45nm gets to around
$500k...
* 28nm ASICs: USD 100,000 for MPW and USD $1 million for production masks
* 22nm ASICs: double 28nm
* 14nm: double 22nm
* 7nm: quadruple 14nm

you get where that is going.  where higher geometries are now easily within
reach even of a hobbyist ASIC developer, USD 20 million is a bare minimum
to design, develop and bring to manufacture a 7nm Custom ASIC.  full-custom
silicon, as carried out regularly by Intel, is USD 100 million.

this is not to say that it is completely outside the realm of possibility
to do something in these lower geometries: you either simply have to have a
damn good reason, or a hell of a lot of money, or a product that's so
compelling that customers really *really* want it, or you have OEMs lining
up to sign LOIs or put up cash-with-preorder.

[my personal favourite is a focus on power-efficiency: battery-operated
hand-held devices at or below 3.5 watts (thus not requiring thermal pipes
or fans - which tend to break). i have to admit i am a little alarmed at
the world-wide energy consumption of bitcoin: personally i would very much
prefer to be involved in eco-conscious blockchain and crypto-currency
products].

so - as an open question: what would people really like to see happen,
here, what do people feel would be of interest to the wider bitcoin
community, and, crucially, is there a realistic way to bridge (fund) the
gap and actually deliver to the bitcoin user community?

best,

l.

---
crowd-funded eco-conscious hardware: https://www.crowdsupply.com/eoma68


-- 
---
crowd-funded eco-conscious hardware: https://www.crowdsupply.com/eoma68
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210125/7f74fdde/attachment.html>

From nadav at suredbits.com  Mon Jan 25 22:17:36 2021
From: nadav at suredbits.com (Nadav Kohen)
Date: Mon, 25 Jan 2021 16:17:36 -0600
Subject: [bitcoin-dev] Update on DLCs (new mailing list)
Message-ID: <CALGTLwMwja3Jj8imfEeqZU8h9R3oSDuqn9L7xCFHQKeEO6L7mg@mail.gmail.com>

Hi all,

A Discreet Log Contract (DLC) is a Bitcoin-compatible oracle contract
enabling transactions to be contingent on signatures broadcasted by some
set of oblivious oracles. This scheme is a contracting building block that
enables a variety of applications such as disintermediated betting,
hedging, financial contracts, and even such things as synthetic assets.

I am excited to announce that there is now a dlc-dev mailing list (
https://mailmanlists.org/mailman/listinfo/dlc-dev) for anyone who wants to
follow or participate in work related to Discreet Log Contracts! Here is
the repository which has links to many resources including blog posts and
the white paper: https://github.com/discreetlogcontracts/dlcspecs.

We also have monthly specification meetings on the first Tuesday of every
month, if you are interested in attending and do not have an invite feel
free to reach out.

In case you haven't been following recent progress in DLCs, here's a quick
(incomplete) list of updates:

* We are using ECDSA Adaptor signatures, soon to be PR'd to secp256k1-zkp:
https://github.com/discreetlogcontracts/dlcspecs/pull/114.

* We have defined TLV-serializations for messages (like Lightning) required
to set up DLCs between parties (including messages from oracles).

* We have multiple compatible DLC implementations.

* We have specified (and implemented) compression algorithms which make
DLCs that are contingent on numeric outcomes (such as prices) practical and
expressive enough to support any payout curve.

* We have specified (and implemented) algorithms which allow users to use a
threshold t-of-n oracles, even supporting numeric cases where some bounded
difference is permitted between oracles.

* We are aiming to have a more stable v0 tag/release of the specification
in a few months!

Best,
Nadav Kohen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210125/64d643d3/attachment.html>

From stick at satoshilabs.com  Tue Jan 26 10:47:50 2021
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Tue, 26 Jan 2021 11:47:50 +0100
Subject: [bitcoin-dev] Libre/Open blockchain / cryptographic ASICs
In-Reply-To: <CAPweEDx4wH_PG8=wqLgM_+RfTQEUSGfax=SOkgTZhe1FagXF9g@mail.gmail.com>
References: <CAPweEDx4wH_PG8=wqLgM_+RfTQEUSGfax=SOkgTZhe1FagXF9g@mail.gmail.com>
Message-ID: <CAF90AvkTncMo0PUyGpizODGf0Sp8pH7epgWU3w3s3YiN0v6PkQ@mail.gmail.com>

On Tue, 26 Jan 2021 at 00:10, Luke Kenneth Casson Leighton via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> so - as an open question: what would people really like to see happen,
> here, what do people feel would be of interest to the wider bitcoin
> community, and, crucially, is there a realistic way to bridge (fund) the
> gap and actually deliver to the bitcoin user community?


Hi Luke!

Very excited to hear more about your effort! Recently, SatoshiLabs
(creators of Trezor) spinned off a new entity Tropic Square[1], which has
the same goal - to bring the truly open security chips to the general
public. I'll send you another email, where we can arrange the call to
exchange ideas.

[1] https://tropicsquare.com

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210126/bdf172f3/attachment.html>

