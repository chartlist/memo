From dustinpaystaxes at gmail.com  Mon Mar  2 19:45:02 2020
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Mon, 2 Mar 2020 11:45:02 -0800
Subject: [bitcoin-dev] Nonce blinding protocol for hardware wallets and
 airgapped signers
In-Reply-To: <c6709c19-a6b2-37a8-0d58-4800126f145f@gmail.com>
References: <CACL8y1vNEOfATJvkYTOV3pZQA5uac3hbTe9Onfz-38zJUzL_Ug@mail.gmail.com>
 <c6709c19-a6b2-37a8-0d58-4800126f145f@gmail.com>
Message-ID: <CABLeJxQHav=3itLiWCjHGhuEk84JA=WFmLSE4iTa_Cv5cDYizg@mail.gmail.com>

+1 love that progress is being made on this. Excited to implement it once
it?s ready.

Would love if things like the incrementing number were included in the
standard as well.

Cheers! ?

On Fri, Feb 28, 2020 at 9:51 AM Marko via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks for starting this initiative; it has been a long standing goal of
> mine to implement and release this protocol. Your blog post on the topic
> actually inspired me to pick up this work again a few months ago.
>
> Jonas Nick has implemented the protocol in the secp256k1 library for
> Schnorr sigs here: https://github.com/bitcoin-core/secp256k1/pull/590
>
> I have backported the same scheme to ECDSA in the secp256k1 library
> here, so it can be used also for current transactions:
>
> https://github.com/bitcoin-core/secp256k1/pull/669
>
> I also made proof of concepts for the BitBox02 hw wallet firmware and
> BitBoxApp wallet to verify that the protocol also works well in practice.
>
> The actual scheme used in those implementations is a generalized
> sign-to-contract scheme, where the final nonce is computed as `k' = k +
> H(k*G, n)` instead of `k'=k+n`, but otherwise it works mostly the same
> for the anti nonce covert channel protocol. I suggest to use this scheme
> in PSBT as well.
>
> > We can either use proprietary fields [4] or define key-value pairs and
> add
> > them to the BIP-174. Depends if anyone else is interested in using this
> > protocol or not.
>
> I'd definitely be interested in seeing widespread support for this, and
> standardizing it would help with that.
>
> With PSBT used with an air-gapped signer, there is increased danger in
> implementing the protocol wrongly by relying on the contents of the PSBT
> alone in the final verification step of a signature. The PSBT must be
> verified carefully against state stored by the host for the PSBT.
> Otherwise the signer can for example change or pre-fill the relevant
> NONCE fields and leak the private keys anyway. Is there a current best
> practice for how a PSBT can be identified by the host to store/retrieve
> the state?
>
> Are there other examples in PSBT where the host can't trust the contents
> of the PSBT the signer returns (except of course for the parts the user
> can verify themselves, like recipients, amounts, etc.)? In any case,
> guidelines or conventions on how to avoid the pitfalls would be good.
>
> Best, Marko
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200302/668d43e4/attachment.html>

From dustinpaystaxes at gmail.com  Mon Mar  2 20:01:51 2020
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Mon, 2 Mar 2020 12:01:51 -0800
Subject: [bitcoin-dev] Nonce blinding protocol for hardware wallets and
 airgapped signers
In-Reply-To: <CACL8y1vNEOfATJvkYTOV3pZQA5uac3hbTe9Onfz-38zJUzL_Ug@mail.gmail.com>
References: <CACL8y1vNEOfATJvkYTOV3pZQA5uac3hbTe9Onfz-38zJUzL_Ug@mail.gmail.com>
Message-ID: <CABLeJxT4mCfrM7K+ygHk6CwSEnHUTdCPjR5VOrMVvA6EmDm6VA@mail.gmail.com>

Stepan have you spent any time considering a scheme that could involve HD
keys, preregistering n (ie. 1000) preimages, or something similar to reduce
the number of rounds at time of signing?

Would a zero knowledge solution allow for a reduction in rounds?

On Wed, Feb 26, 2020 at 7:13 PM Stepan Snigirev via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This topic appeared in the list a few times so I would like to discuss it
> in more detail and maybe push forward to standardization.
>
> We have to accept that any hardware wallet or an air-gapped computer we
> use to sign transactions can be compromised. It may happen via a supply
> chain attack or malicious firmware update.
>
> If the signer is isolated (faraday cage, airgap and so on), it still can
> leak private keys to the outside world by choosing nonces for signatures in
> a funny way such that the attacker can calculate our private keys. Back in
> the days, I wrote a small post [1] and a proof-of-concept demo [2] of this
> attack.
>
> Deterministic nonce generation can be verified only if we have private
> keys somewhere else. It doubles the attack surface - now we need to
> maintain two independent signers from different vendors that use the same
> private key and the same deterministic algorithm for a nonce generation. In
> addition to that, as Pieter mentioned in the Schnorr-BIP, deterministic
> nonces are vulnerable to glitch attacks [3].
>
> A simple way to fix it is by forcing the signer to use additional entropy
> from the host. This protocol takes away the privilege of picking nonce from
> the signer and doesn't require any secret material outside the signer.
>
> I suggest the following implementation of the protocol for signing a
> message `m`:
>
> 1. Host picks a random number `n` and sends its hash together with the
> message `m` to the signer.
> 2. Signer computes a nonce `k` it wants to use for signing. It can be
> either a deterministic scheme or using RNG. Signer commits to the chosen
> nonce by sending the corresponding point `R=kG` to the host.
> 3. Host sends the preimage `n` to the signer
> 4. Signer tweaks the nonce by this number `k'=k+n`, signs the message and
> sends back the signature (R',s)
> 5. Host verifies that the public point in the signature is tweaked by n:
> `R'==R+nG`
>
> ASCII-art:
>
>    Host                                Untrusted signer
> 1. Pick random n   --- sha256(n),m -->  calculate nonce k
> 2.                 <------ R=kG ------  commit to k
> 3. Send preimage   -------- n ------->  sign with nonce k'=k+n
> 4. Verify R'==R+nG <------- sig ------
>
> I believe this protocol solves the problem. A drawback of this scheme is
> that the number of communication rounds doubles, so it might be pretty
> inconvenient for air-gapped remotely located signers.
>
> I also suggest the following extensions that might be helpful for certain
> use-cases
>
> # Extensions
>
> ## Multiple hosts
>
> There are some use-cases where multiple hosts are involved in the setup
> and all hosts don't trust each other and the signer. So all of them want to
> give extra entropy to the signer and verify that it was included. At the
> moment I have exactly this scenario - our main MCU doesn't trust the
> proprietary closed-source secure element, and the computer doesn't trust
> the whole hardware wallet. We need a way to convince both of them that
> their entropy was used in the nonce.
>
> It can be solved by concatenating hashes and preimages:
>
> Host1 ------- h(n1) --> Host 2 -- h(n1) h(n2) --> Signer
>       <--- R+n2 G -----        <------- R -------
>       ------- n1 ----->        ------ n1 n2 ----> sign with k''=k+n1+n2
> Ver: R''==R'+n1 G       Ver: R''==R+n2 G + n1 G
>
> In this case, the first host doesn't even notice that the second host was
> also using this protocol and mixing in the entropy. And the signer only
> needs to add one extra number to the nonce.
>
> ## Stateless random signer
>
> If the signer wants to generate a nonce non-deterministically but doesn't
> have an ability to store a generated nonce it may send back to the host
> some meta-information that would help it to re-generate the same nonce
> later. It can be for example additional random data used in a deterministic
> scheme, either encrypted and authenticated or just as a plain text (I am
> more a fan of encrypted though).
>
> Generally, the host shouldn't care what this data is about - he just
> stores the data between rounds and sends it back to the signer with the
> next round.
>
> # Implementation for PSBT
>
> We can either use proprietary fields [4] or define key-value pairs and add
> them to the BIP-174. Depends if anyone else is interested in using this
> protocol or not.
>
> I would suggest the following key-value per-input pairs assuming multiple
> hosts want to mix in external entropy:
>
> 1. Key: {PSBT_IN_EXT_NONCE_HASH}|{pubkey}, Value:
> {sha256(n1)}|{sha256(n2)}|...
> 2. Key: {PSBT_IN_NONCE_COMMITMENT}|{pubkey}, Value: {33-byte R point}
> 3. Key: {PSBT_IN_NONCE_SIGNER_METADATA}|{pubkey}, Value: {anything}
> 4. Key: {PSBT_IN_EXT_NONCE_PREIMAGE}|{pubkey}, Value: {n1}|{n2}|...
>
> Then the signature from the signer is placed into existing
> PSBT_IN_PARTIAL_SIG. Combiner and Finaliser should verify that nonce in the
> signature includes external entropy and may remove their own entropy from
> the set. They should also verify that the values of the fields did not
> change between rounds.
>
> So, list, what do you think? Am I missing something? Would it be
> interesting to have this protocol standardized and deployed?
>
> # References
>
> [1]
> https://medium.com/cryptoadvance/hardware-wallets-can-be-hacked-but-this-is-fine-a6156bbd199
> [2]
> https://github.com/stepansnigirev/chosen_nonce_demo/blob/master/HD_key.ipynb
> [3]
> https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#alternative-signing
> [4]
> https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#proprietary-use-type
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200302/7860629d/attachment.html>

From mbencun at gmail.com  Tue Mar  3 11:29:22 2020
From: mbencun at gmail.com (Marko)
Date: Tue, 3 Mar 2020 12:29:22 +0100
Subject: [bitcoin-dev] Fwd: BIP 340 updates: even pubkeys,
 more secure nonce generation
Message-ID: <ceeb0cd5-e5fe-5c01-df84-bbb761c41f95@gmail.com>

That is an interesting point. Does the same concern apply to anti nonce
covert channel protocols? In those, the host would mix in a random nonce
of its own. The process is still deterministic and can be checked during
signing, but unless the host persists the nonce contributions it
provides, one can't check how the nonce was computed for past
signatures. I am unsure how desirable this property would be in
practice, though. I am guessing not that desirable, but it would be good
to hear other opinions.

See

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017655.html


and

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017663.html

Best, Marko



From bitcoin-dev at wuille.net  Tue Mar  3 21:35:55 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 03 Mar 2020 21:35:55 +0000
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
Message-ID: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>

Hi all,

Given the recent activity and attention [1,2] around anti-covert channel
signing schemes, I decided to create this overview of the various techniques
that I know of, their trade-offs, and the various issues they protect against.
Most of this is based on various schemes by a number of authors, and credit
goes to them. I'm putting this together into something hopefully more
comprehensive, but mistakes and omissions in this writeup are likely mine.

I don't believe we have security proofs for any of the schemes, or for any of
the claims I make about the mitigation techniques below. I hope that having
all properties written up in one place makes it easier to eventually get those.

1) Security model
-----------------

When talking about signing with covert channels, we consider 3 parties:
* HW, the hardware wallet (or other offline signing device) with secret data
  (a private key, or a seed from which the private key is derived).
* SW, the software wallet (or whatever communicates with HW and the network).
* OO, the outside observer who is trying to learn information about HW's
  secret data.

We consider two distinct attack models:
* MSW, "malicious software wallet", but with honest HW. OO and SW are the
  same party here, so this models the usual scenarios hardware wallets are
  designed for, including side-channel attacks if those are considered to be
  part of the threat model.
* MHW, "malicious hardware wallet", but with honest SW and no malicious party
  being able to communicate with HW directly. OO and HW may have shared secret
  information that SW (or anyone else) is unaware of. SW's job is trying to
  prevent HW from using this to leak any information about its secret.

When both the HW and the SW are compromised, clearly no security is possible,
as all entities are controlled by the same party in that case.

In case HW uses a deterministic algorithm, it is possible to protect against
the MHW case by spot checking HW's behavior, by using an externally known
secret/seed. However, we'd like to have better than just spot checking
security, and for protection against side-channel attacks we may want
something that keeps working even when randomness is used by HW.

To keep the scope limited, we assume SW has no secret key of their own. This
rules out solutions like using 2-of-2 MuSig between HW and SW, which work, but
come with their own complications (like needing secure storage for that
secret).

2) Issues and solutions
-----------------------

In this section I will go over the various issues that exist in the MHW and MSW
models, the known mitigation techniques, and the resulting schemes.

I'm assuming a Schnorr-like signature protocol, though everything should apply
equally to ECDSA, and to a lesser extent probably also to multisignature
schemes. These variable names are used:
* H is a hash function.
* G is the curve generator.
* m is the message to be signed, known to and agreed upon by SW and HW.
* d is HW's secret key, with corresponding public key Q=dG.
* k is the secret nonce k, with corresponding public nonce R=kG.

The simplest protocol is naive Schnorr with deterministic nonce generation,
where SW only verifies that a signature created by HW is valid:

[Scheme 1: deterministic nonce, no tweak]
* SW requests a signature by sending (Q,m) to HW.
* HW computes k=H(d,m), R=kG, s=k+H(R,Q,m)d, and sends (R,s) to SW.
* SW verifies sG=R+H(R,Q,m)Q, and publishes sig (R,s) in case of success.

2.a) Predictable k value

There is a simple attack against Scheme 1 that will leak the entire private
key undetectably using a single signature, under MHW. Assume HW and OO both
have access to a shared secret a, unknown to anyone else. HW computes
k=H(a,Q,m) instead, which SW cannot distinguish from the honest k=H(d,m) as it
knows neither a or d. OO can compute k using the same formula, and thus
recover the private key as d=(s-k)/H(R,Q,m).

The general strategy to avoid this is by letting SW provide entropy that is
included into the nonce computation. A very naive (and ineffective) way of
doing that would be:
* SW generates random t, and requests a signature by sending (Q,m,t) to HW.
* HW computes k0=H(d,m,t), R0=k0G, k=k0+t, R=kG, s=k+H(R,Q,m)d, and sends
  (R0,R,s) to SW.
* SW verifies sG=R+H(R,Q,m)Q, R=R0+tG, and publishes sig (R,s) if all is good.

This does not help as HW can still choose k directly, and retroactively
compute R0 as R-tG, satsifying SW's requirements. To address that, there are
two options:
* Turning R into a binding commitment to R0 and t (see Scheme 2).
* Only revealing t after HW has revealed their R0 (see Scheme 3).

The first approach is based on making R a commitment to R0 and t using
R=R0+H(R0,t)G. When applied to public keys this is known as pay-to-contract
(and is the basis for Taproot); when applied to the R point in signatures it's
known as sign-to-contract [3]. These are generally useful approaches to make
public keys and signatures commit to/timestamp external data, but using this
to protect against covert channels in signatures was first discussed by Greg
Maxwell [4]:

[Scheme 2: deterministic nonce, S2C tweak]
* SW generates random t, and requests a signature by sending (Q,m,t) to HW.
* HW computes k0=H(d,m,t), R0=k0G, k=k0+H(R0,t), R=kG,
  s=k+H(R,Q,m)d, and sends (R0,R,s) to SW.
* SW verifies sG=R+H(R,Q,m)Q, R=R0+H(R0,t)G, and publishes sig (R,s) if all
  is good.

The second approach is adding a round, and only revealing the tweak t after HW
has revealed their R0:

[Scheme 3: deterministic nonce, tweak revealed after nonce]
* SW requests a signature by sending (Q,m) to HW.
* HW computes k0=H(d,m), R0=k0G, and sends R0 to SW.
* SW generates a random t, and sends it to HW.
* HW computes k=k0+t, R=kG, s=k+H(R,Q,m)d, and sends (R,s) to SW.
* SW verifies sG=R+H(R,Q,m)Q, R=R0+tG, and publishes (R,s) if all is good.

2.b) Replay attacks

Scheme 3 introduces another problem however, this time under MSW. SW can ask
HW to sign the same message twice, but then pick distinct values for t (t and
t'). The resulting R points will be R=(k0+t)G and R'=(k0+t')G, and the s
values will be s=k0+t+H(R,Q,m)d and s'=k0+t'+H(R',Q,m)d. This allows SW to
compute d=(s'-t'-s+t)/(H(R',Q,m)-H(R,Q,m)). A similar problem would also exist
in Scheme 2 if t wasn't included in the formula for k0.

The problem is that SW is allowed to change their tweak while the nonce
only undergoes a linear function known to SW. There are again two ways to
address this problem:
* Making k0 generation non-repeating by including a counter or randomness
  in it (Scheme 4).
* Making SW commit to their tweak before revealing it as well (Scheme 5).

[Scheme 4: counter/random nonce, tweak revealed after nonce]
* SW requests a signature by sending (Q,m) to HW.
* HW uses a global counter c, or fresh randomness b, and computes k0=H(d,m,c)
  or k0=H(d,m,b), R0=k0G, and sends R0 to SW.
* SW generates a random t, and sends it to HW.
* HW computes k=k0+t, R=kG, s=k+H(R,Q,m)d, and sends (R,s) to SW.
* SW verifies sG=R+H(R,Q,m)Q, R=R0+tH, and publishes (R,s) if all is good.

A variant of Scheme 4, but with multiplicative tweak rather than additive,
and only revealing H(R0) rather than R0 immediately, was suggested by Sergio
Demian Lerner in [5].

[Scheme 5: deterministic nonce, precommited tweak revealed after nonce]
* SW generates a random t, computes h=H(t), and requests a signature by
  sending (Q,m,h) to HW.
* HW computes k0=H(d,m,h), R0=k0G, and sends R0 to SW.
* SW sends t to HW.
* HW verifies h=H(t), and if so, computes k=k0+t, R=kG, s=k+H(R,Q,m)d, and
  sends (R,s) to SW.
* SW verifies sG=R+H(R,Q,m)Q, R=R0+tG, and publishes (R,s) if all is good.

Scheme 5 is the one suggested by Stepan Snigirev in [2,6]. A variant with
S2C tweaking instead of additive tweaked was suggested by Andrew Poelstra
in his talk [7], with transcript by Bryan Bishop in [8].

2.c) k0 grinding

So far Schemes 2, 4, and 5 protect against predictable k values and replay
attacks. Predictable k values are however not the only way MWH can leak
secrets.

If we imagine HW has significant computational power, in Scheme 2 it can try
many different k0 values (by deviating from k0=H(d,m,t)), and observe what the
resulting (R,s) signature will be. For example, by iterating on average 256
times, it can choose 8 bits in (R,s) that convey information about k, d, or
whatever seed or master key they are derived from. Using forward error
correction (FEC) schemes, this channel of a few bits per signature may be
enough to leak an entire seed over enough signatures. Using a shared secret a
between HW and OO those bits can again be made undetectable to anyone else.

Schemes 4 and 5 are not vulnerable to this problem, as they force HW to commit
to its R0 before knowing the resulting R. One might think that Scheme 4 merely
shifts this problem to MSW, where SW can grind t to make R biased in a similar
way. We assumed that SW does not have access to any secrets however, so this
is harmless.

2.d) Statefulness

We're left with Schemes 4 and 5 that protect against all listed issues. Both
need two interaction rounds, with state that needs to be kept by HW between
the rounds (the k0 value). While not a problem in theory, this may be hard to
implement safely in simple APIs.

One possibility is sticking with our "best one-round" Scheme 2, and accepting
that that implies the k0 grinding vulnerability.

There is another possibility, namely splitting Scheme 5 into two independent
interactions with HW, where no memory between them is needed on the HW side:

[Scheme 6: deterministic nonce, precommitted tweak revealed separately]
First interaction:
* SW generates a random t, computes h=H(t), and requests the R0 point that HW
  would use by sending (Q,m,h) to HW.
* HW computes k0=H(d,m,h), R0=k0G, and sends R0 to SW.
Second interaction:
* SW requests a signature by sending (Q,m,t) to HW
* HW computes k0=H(d,m,H(t)), k=k0+t, R0=R0k, R=kG, s=k+H(R,Q,m)d, and sends
  (R0,R,s) to SW.
* SW verifies that R0 matches the earlier R0 it received, and that
  sG=R+H(R,Q,m)Q, R=R0+tG, and publishes (R,s) if all is good.

A variant of Scheme 6, with S2C tweaking instead of additive tweaking, is what
is being worked on by Jonas Nick [9] and Marko Bencun [10] for the
libsecp256k1 library.

The same technique cannot be applied to Scheme 4, as HW inherently needs state
to keep the counter c, or to remember the randomness b between interactions
there.

2.e) Failure bias

There is yet another, and even weaker, leak that is available in MHW: whenever
HW learns what the eventual signature (R,s) will be, it could pretend to fail
and go offline, or return some kind of error. In theory, this is enough to
introduce a similar bias, though it would come at possibly enormous failure
rates. If HW is allowed to fail 255 times out of 256, it can introduce an
8-bit bias, and employ similar techniques (FEC and shared HW/OO secret).
The obvious solution is showing a big warning to the user whenever any kind of
failure occurs (including device going offline, or returning invalid
responses) that the device is failing, and that if this happens frequently, it
should be treated as malicious.

Interestingly, Scheme 6 can be adapted to reduce this (already very weak)
channel further. The observation is that HW cannot predict during the first
interaction what (R,s) is going to be, as t is not known. This means it can
only fail during the second interaction when the result is already committed
to. Thus, if failure occurs during the second interaction, SW can simply
retry it with the same t value. If that succeeds, either a glitch occurred and
was safely retried, or the device's attempt to bias was prevented. If the
failure persists, the user should still be warned - as restarting with a
different k would reintroduce the possibility for bias.

2.f) Side-channel attacks

As a last consideration, let's see if these schemes have an impact on
potential resilience against side-channel attacks. I say potential, because
these classes of attacks are in general hard to protect against and model,
as they depend on implementation details and hardware protections. Still,
there are some general observations possible.

A significant amount of time in HW is likely spent on the EC multiplications
to obtain R0 and R from k0 and k. As s=k+H(R,Q,m)d, an variation of the replay
attack is possible here. In schemes with deterministic nonces, SW can ask for
the same signature twice, but use a fault injection to hopefully (only) cause
an error in R, R'. This would reveal (R,s) and (R',s') to SW, where s' is
k+H(R',Q,m)d, which would let them compute d=(s'-s)/(H(R',Q,m)-H(R,q,m)).
There is an easy solution against this, namely verifying the final signature
(R,s) in HW before sending it to SW, as almost certainly the result of such
a fault would not result in a valid signature. This comes at an extra
computational cost, though.

For other side-channel attacks like different power analysis, research [11]
shows that introducing fresh randomness in the right place may be helpful.
This approach is called "synthetic nonces" [12]. Unfortunately usage of these
rules out the deterministic approach from Scheme 6. A variant of Scheme 5
with fresh randomness in the k0 computation can be used, though.

3) Summary
----------

Six different issues of various levels of severity were discussed:
  (a) Predictable k: (MHW) a single signature leaks the entire private key.
  (b) Replay attacks: (MSW) a single signature leaks the entire private key.
  (c) k0 grinding: (MHW) the HW can leak n bits with 2^n work.
  (d) Statefulness: HW has to correctly maintain state, complicating things.
  (e) Failure bias: (MHW) a selective failure rate of (2^n-1)/2^n can be used
      to leak n bits of secret per signature.
  (f) Side-channel attacks: (MSW) physical access to HW can help extracting
      secrets.

It seems any reasonable solution should at least protect against (a), (b), and
(c), but it seems no solution can be optimal for all of (d), (e), and (f) too.

If statelessness and protection against failure bias are prioritized, Scheme 6
seems best. Its additive tweaking can be replaced with S2C (or multiplicative)
tweaking too. S2C in particular may be desirable to unify with support for
S2C-based timestamping.

If resistance against side-channels is prioritized, solutions with synthetic
nonces seem best; either Scheme 4, or Scheme 5 with randomness added to the
k0 computation. Again, any tweaking approach can be chosen.

If the 2-round approaches for Schemes 4, 5, and 6 are really unacceptable,
Scheme 2 (with S2C tweaking) could be used, but in that case protection
against k0 grinding is reduced to spot checking. If randomness is additionally
added for side-channel resistance, the ability to spot check disappears
entirely.

4) References
-------------

  [1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017649.html
  [2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017655.html
  [3] https://blog.eternitywall.com/2018/04/13/sign-to-contract/
  [4] https://bitcointalk.org/index.php?topic=893898.msg9861102#msg9861102
  [5] https://bitcointalk.org/index.php?topic=893898.msg9841502#msg9841502
  [6] https://medium.com/cryptoadvance/hardware-wallets-can-be-hacked-but-this-is-fine-a6156bbd199
  [7] https://youtu.be/j9Wvz7zI_Ac?t=640
  [8] https://diyhpl.us/wiki/transcripts/sf-bitcoin-meetup/2019-02-04-threshold-signatures-and-accountability/
  [9] https://github.com/bitcoin-core/secp256k1/pull/590
  [10] https://github.com/bitcoin-core/secp256k1/pull/669
  [11] https://eprint.iacr.org/2017/985
  [12] https://moderncrypto.org/mail-archive/curves/2017/000925.html


From karljohan-alm at garage.co.jp  Wed Mar  4 06:23:53 2020
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Wed, 4 Mar 2020 15:23:53 +0900
Subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion
Message-ID: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>

Hello,

I noticed recently that a PR to Bitcoin Core that pretty much touched
everything my BIP-322 pull request touches (around the same
complexity) was merged without a thought given to BIP-322
compatibility, despite the BIP-322 PR being open for 2x the time. I
can only conclude from this that people dislike BIP-322 in its current
form, which the 9 month old pull request stagnating can probably
attest to.

There are several things that I can do to make this a bit more
appealing to people, which would hopefully kick the progress on this
forward. I have already put in a non-trivial amount of energy and
effort into maintaining the pull request as is, so I'd prefer if
people were harsh and unfiltered in their criticism rather than polite
and buffered, so I can beat this thing into shape (or abandon it, in
the worst case).

=============
1. People use signmessage as a way to prove funds. This is misleading
and should be discouraged; throw the sign message stuff out and
replace it entirely with a prove funds system.

I know in particular luke-jr is of this opinion, and Greg Maxwell in
https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168
leans towards this opinion as well, it seems.

=============
2. Use a transaction rather than a new format; make the first input's
txid the message hash to ensure the tx cannot be broadcasted. This has
the benefit of being able to provide to an existing hardware wallet
without making any modifications to its firmware.

I think Mark Friedenbach and Johnson Lau are of this opinion, except
Johnson Lau also suggests that the signature hash is modified, see
https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --
which defeats the benefit above since now hw wallets can no longer
sign.

Prusnak (I think he works at Trezor; apologies if I am mistaken) is
against this idea, and proposes (3) below:
https://github.com/bitcoin/bips/pull/725#issuecomment-420210488

=============
3. Use Trezor style

See https://github.com/trezor/trezor-mcu/issues/169

This has the benefit of already being adopted (which clearly BIP-322
is failing hard at right now), but has the drawback that we can no
longer do *generic* signing; we are stuck with the exact same
limitations as in the legacy system, which we kinda wanted to fix in
the updated version.

=============
4. Introduce OP_MESSAGEONLY

Quoting Johnson Lau at
https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :
"""
OP_MESSAGEONLY means the script following the code would never be
valid. For example, a scriptPubKey:

OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG

For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is
ignored. A message could be signed with either key_m or key_s.

For spending, only key_s is valid.

I don't think it is a big problem to consume a op_code. If this is a
real concern, I could modify it as follow: in message system,
OP_RETURN will pop the top stack. If top stack is msg in hex, it is
ignored. Otherwise, the script fails.
"""

=============
5. Some other solution

From karljohan-alm at garage.co.jp  Wed Mar  4 07:03:34 2020
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Wed, 4 Mar 2020 16:03:34 +0900
Subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion
In-Reply-To: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>
References: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>
Message-ID: <CALJw2w5h=rdzhy+uVFs6w5qLe4hT+hfkdqOz6QkW9+cx_pzkjg@mail.gmail.com>

I forgot one:

=============
5. The current BIP itself is poorly written and/or unnecessarily
complex: e.g. remove the multi-proof support, and/or remove the
extensibility stuff for a future proof-of-funds extension, and/or
focus solely on the generic sign message stuff.

=============
6. Some other solution

On Wed, Mar 4, 2020 at 3:23 PM Karl-Johan Alm
<karljohan-alm at garage.co.jp> wrote:
>
> Hello,
>
> I noticed recently that a PR to Bitcoin Core that pretty much touched
> everything my BIP-322 pull request touches (around the same
> complexity) was merged without a thought given to BIP-322
> compatibility, despite the BIP-322 PR being open for 2x the time. I
> can only conclude from this that people dislike BIP-322 in its current
> form, which the 9 month old pull request stagnating can probably
> attest to.
>
> There are several things that I can do to make this a bit more
> appealing to people, which would hopefully kick the progress on this
> forward. I have already put in a non-trivial amount of energy and
> effort into maintaining the pull request as is, so I'd prefer if
> people were harsh and unfiltered in their criticism rather than polite
> and buffered, so I can beat this thing into shape (or abandon it, in
> the worst case).
>
> =============
> 1. People use signmessage as a way to prove funds. This is misleading
> and should be discouraged; throw the sign message stuff out and
> replace it entirely with a prove funds system.
>
> I know in particular luke-jr is of this opinion, and Greg Maxwell in
> https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168
> leans towards this opinion as well, it seems.
>
> =============
> 2. Use a transaction rather than a new format; make the first input's
> txid the message hash to ensure the tx cannot be broadcasted. This has
> the benefit of being able to provide to an existing hardware wallet
> without making any modifications to its firmware.
>
> I think Mark Friedenbach and Johnson Lau are of this opinion, except
> Johnson Lau also suggests that the signature hash is modified, see
> https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --
> which defeats the benefit above since now hw wallets can no longer
> sign.
>
> Prusnak (I think he works at Trezor; apologies if I am mistaken) is
> against this idea, and proposes (3) below:
> https://github.com/bitcoin/bips/pull/725#issuecomment-420210488
>
> =============
> 3. Use Trezor style
>
> See https://github.com/trezor/trezor-mcu/issues/169
>
> This has the benefit of already being adopted (which clearly BIP-322
> is failing hard at right now), but has the drawback that we can no
> longer do *generic* signing; we are stuck with the exact same
> limitations as in the legacy system, which we kinda wanted to fix in
> the updated version.
>
> =============
> 4. Introduce OP_MESSAGEONLY
>
> Quoting Johnson Lau at
> https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :
> """
> OP_MESSAGEONLY means the script following the code would never be
> valid. For example, a scriptPubKey:
>
> OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG
>
> For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is
> ignored. A message could be signed with either key_m or key_s.
>
> For spending, only key_s is valid.
>
> I don't think it is a big problem to consume a op_code. If this is a
> real concern, I could modify it as follow: in message system,
> OP_RETURN will pop the top stack. If top stack is msg in hex, it is
> ignored. Otherwise, the script fails.
> """
>
> =============
> 5. Some other solution

From lloyd.fourn at gmail.com  Wed Mar  4 07:10:04 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Wed, 4 Mar 2020 18:10:04 +1100
Subject: [bitcoin-dev] Hash function requirements for Taproot
Message-ID: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>

Hi List,

I recently presented a poster at the Financial Cryptography conference
'2020 which you can find here:
https://github.com/LLFourn/taproot-ggm/blob/master/main.pdf.  It attempts
to show the security requirements for the tweak hash function in Taproot.
In this post I'll give a long description of it but first let me tl;dr:

Taproot requires no new assumptions of SHA256 over what are already made by
Schnorr signatures themselves with one exception: when using a
non-interactive key generation protocol to produce a Taproot internal key
(e.g MuSig). To prove security in this scenario we need a make an
additional assumption about SHA256: as well as being collision resistant
(i.e. find two hashes h_1 - h_2 = 0), it must satisfy a more general kind
of collision resistance where it is hard to find h_1 - h_2 = d for *any d*
when the adversary is challenged to find h_1 and h_2 with random prefixes.
This is obviously a plausible assumption. Put informally, it says that zero
is not a special case where finding collisions is difficult but rather
solving the 2-sum problem is hard for all values of d (when challenged with
random prefixes).

Now the long version.

My motivation for creating this poster came from questions I had after
discussions in Taproot Study Group #18 (this study group initiative was a
great idea btw). The main question I had was "Why is Taproot binding?" i.e.
why is it true that I can only commit to one Merkle root. Isn't it possible
that a malicious party could produce a second covert Taproot spend that
none of the other parties to the output agreed to? I submitted a poster
proposal to FC to force myself to get to the bottom of it.

The premise of the poster is to use the Generic Group Model to try and
figure out how the hash function would have to fail for Taproot to be
insecure. Most of the poster is taken up cartoon reductions I made to
remind myself as to why what I was saying might be true. They are
incomplete and difficult to parse on their own so hopefully this post is a
useful companion to them.

=== The Security of Taproot ===

There are three scenarios/games we must consider when asking whether
Taproot is secure in the context of Bitcoin:

1. Taproot Forge: Forging taproot spends must be hard. The adversary must
not be able to take a public key off the blockchain and produce a forged
Taproot spend from it.
2. Covert Taproot: When an adversary is executing a multi-party key
generation protocol (e.g. MuSig) it should be hard for them to produce a
covert malicious Taproot spend from the joint key  i.e. when honest parties
think there is no Taproot on a key there shouldn't be any Taproot on the
key. Note this is not guaranteed to be hard by 1 being hard.
3. Second Covert Taproot: Like 2, except that if honest parties agree to a
Taproot spend then the adversary shouldn't be able to generate a second
Taproot spend they are unaware of.

Properties (1) and (2) can be argued succinctly if we just prove that
Taproot is a secure commitment scheme. It should be clear that if a Taproot
external key T = X + H(X||m)*G is a secure commitment scheme (Hiding and
Binding) to any arbitrary message m, then it is a secure commitment scheme
to a Merkle root. If so, then properties (1) and (3) hold. (1) holds
because if you can create an opening to a commitment not generated by you,
you either broke hiding (if your opening is the same as the honest one) or
broke binding (if it's different). (3) holds because you must have broken
binding as there are now two openings to the same commitment.

Property (2) is more difficult to argue as it depends on the multi-party
key generation protocol. Case in point: Taproot is completely broken when
combined with a proof of knowledge key generation protocol where along with
their public keys each party provides a proof of knowledge of the secret
key. Where X_1 is the key of the honest party, the malicious party can
choose their key X_2 to be G*H(X_1 || m) where m is a malicious Merkle
root. Clearly the malicious party has a covert Taproot for X = X_1 + X_2
and can produce a proof of knowledge for X_2.

Given this definition of security, we now move onto how we should model the
problem to prove they hold.

=== Generic Group Model vs Random Oracle Model ===

For practical cryptographic schemes you often have to idealise one of its
components to prove it secure. The most popular candidate for idealisation
is the hash function in the Random Oracle Model (ROM), which idealises a
hash function as a "random oracle", a black box which spits out random
values for each input. For example, the original "forking lemma" proof by
Pointcheval and Stern [1] shows the Schnorr signature scheme is unforgeable
in this model if the discrete logarithm problem is hard. In other words,
idealising the hash function allows us to isolate what security assumptions
we are making about the group (e.g. the discrete logarithm problem being
hard in it).

But what if we want to know what assumptions we are making about the hash
function? Does the challenge hash in Schnorr signatures have to be
collision resistant or pre-image resistant or something else? To answer
this question Neven et al.[2] analysed Schnorr signatures by idealising the
group in the "Generic Group Model" (GGM). By idealising the group, they
were able to isolate the security requirements of the hash function away
from any assumptions being made about the group. In the GGM, the group
becomes a black box which, when given two group elements, spits out their
subtraction (for technical reasons it's subtraction rather than addition).
The adversary can only produce new group elements by querying the oracle.
Using the GGM they prove that the hash function needs to be Random-Prefix
Preimage (RPP) resistant (and Random-Prefix Second-Preimage resistant)
which are strictly weaker assumptions than collision resistance.

=== Taproot in the Random Oracle Model ===

Proving that Taproot is a binding commitment scheme in the ROM is
straightforward (hiding is too but I'm going to skip that). To produce two
openings for the same external key, the adversary must have two random
oracle queries H(X || m) that result in the same external key T = X +
H(X||m)*G. Since H(X||m)*G is an (almost) uniformly distributed group
element in the ROM, T is also uniformly distributed, thus breaking the
binding of Taproot is equivalent to solving a birthday problem of size
2^256 (the same as finding hash collisions in the ROM). Note that this
statement is true regardless of the discrete logarithm problem being hard
or not. This proves properties (1) and (3).

For property (2) let's consider MuSig as the key generation protocol. If we
model the MuSig key tweak hash function as a random oracle as well then for
every key X_2,  the adversary has to query the MuSig hash oracle to
determine the joint key X = X_1*H(X_1||L) + X_2*H(X_2| L). As before, it is
clear to see that this makes X a uniform group element for every X_2 in the
ROM. Liekwise for every covert Taproot internal key C and message pair the
external key T = C + H(C||m) *G will be uniform as before in the ROM. Thus,
breaking property (2) is the same as finding T = X, where you the adversary
can only sample T and X from uniform distributions and so we have another
birthday problem. This completes the proof of all three properties.

Poelstra presented a proof in the ROM for the security of Taproot [3]. It
frames Taproot as a way of combining two signature schemes into one public
key (in our case Schnorr and Tapscript). He uses a similar line of
reasoning to what I have just presented in his proof (Lemma 1, step 3) but
this approach brings in many other considerations that I think can be
avoided by modelling it as a commitment scheme. Note that this proof only
shows that Taproot forgeries are hard i.e. property (1).

=== Taproot in the Generic Group Model ===

The ROM proof is an important first step -- if it couldn't be proved secure
in ROM then it would probably be completely broken. But Taproot, unlike
Schnorr, only relies on the security of its hash function when viewed as a
commitment scheme so it would be prudent to figure out what those
properties are. By using the ROM we artificially hide what those properties
from our analysis. As in the case of Schnorr, we can idealise the group in
the GGM to help isolate the hash function's properties.

To prove Taproot was a binding commitment scheme in the GGM I had to
introduce a new property I called "Chosen Offset Prefix-Collision" (COPC)
resistance. The precise security game is sketched in the poster, but I like
to describe it as a more general kind of collision resistance. Instead of
it being hard to find two preimages a and b where H(a) - H(b) = 0, it must
be hard to find H(P_1 || a) - H(P_2 || b) = d for any d (not just d  = 0)
with random prefixes P_1 and P_2 given by the challenger (d chosen by the
adversary). COPC is necessary and sufficient to prove Taproot is a secure
commitment scheme in the GGM (the proof for this isn't in the poster but is
very similar to Second Covert Taproot proof).

This was not the ideal outcome, so I decided to analyse properties Taproot
(1) and (3) independently rather than just imply them from the commitment
scheme result. What ended up in the poster is three independent proofs for
each Taproot security property with MuSig assumed to be key generation
scheme for properties (2) and (3). Here's a summary of what I concluded for
each property.

1. Taproot Forge: In the GGM, an adversary who forges Taproot openings can
be used as a black box to mount a "Random Prefix-Preimage" (RPP) attack
against the hash function. This is a very good result as RPP is already
required by Schnorr. Essentially, this means anyone who can forge Taproot
spends can also forge Schnorr signatures.

2. Covert Taproot (MuSig): For this problem I had to split the adversary
into two types: those who query their MuSig public key X_2 from the group
oracle before their malicious internal key C and those that query C first
or set X_2 = C. For the first case I was able to show another reduction
from RRP (which shown in the poster).  The other case I was able to break
preimage resistance as long as I modelled the MuSig hash function as a
random oracle (not shown in the poster and this is only from memory). In
both cases the reduction does not work for n-party MuSig (only for 2
parties). Obviously, this is not totally satisfying. The problem with
n-party MuSig is it becomes exponentially more unlikely (in n) for the
reduction to guess which keys the adversary will use for their MuSig keys.

3. Second Covert Taproot (MuSig): Once again, this is where honest parties
agree on a joint key and Taproot spend from it, but the adversary is
somehow able to create a second covert spend during the key generation
phase. This is where I found that COPC does actually need to be hard to
ensure this property. This is true regardless of the number of parties.
Thus this is the only scenario where you need the additional security
assumption to prove security.

== Concluding Remarks ==

The main important take away of this is that there is actually a small
security cost to using a group element as both a commitment scheme and as a
public key. It would be very surprising if we got this for free. By using
the random oracle model we merely hide this in the idealisation of the hash
function. The generic group model exposes it. The question is: is the cost
worth it and who bears it? Here's what I consider to be the most important
points:

1. You only take on this COPC assumption if you use Tapscript. If you're
just putting your funds into a Taproot output without an internal key,
either as a group or an individual there is no extra security assumption.
(with the caveat that my technique only really works for  2-party MuSig).
2. The COPC assumption seems to be very plausible.
3. Even if COPC is broken and an adversary can output two openings to the
same external key, both those openings must be valid taproot spends for
anyone to lose coins (i.e. Merkle roots with valid paths to leaves with
valid tapscript).
4. Even if COPC was that badly broken on SHA256, old taproot outputs would
not be affected, the adversary has to break it during key generation before
funds are put into the output.
5. You can completely circumvent this result by using coin-tossing rather
than MuSig for the key generation protocol. In most cases this doesn't even
add any extra rounds of communication since you are doing 3-round coin
tossing to choose the R values for the signatures that spend from the joint
output anyway. You can just toss your public keys in parallel.

In my opinion, the cost of Taproot is mostly borne by theoreticians. They
can no longer treat a a public key ideally but have to consider the
implications of it also being a commitment. For the user and Bitcoin as a
whole it seems to offer an overwhelming benefit. In exchange for the
complexity it adds to making security claims in the GGM (if using
Taprscript and MuSig), it offers exciting new opportunities for
non-interactivity and fungibility over what just what Schnorr would provide.

I don't consider my work to be a final proof of anything. I would welcome
anyone who wants to take over this research direction and do a proper job
of it! I didn't have any personal motivation for doing this work other than
curiosity and that curiosity has been satisfied. Questions and thoughts
welcome :)

[1] https://www.di.ens.fr/david.pointcheval/Documents/Papers/2000_joc.pdf
[2] http://www.neven.org/papers/schnorr.pdf
[3] https://github.com/apoelstra/taproot/blob/master/main.pdf

Cheers,

LL
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200304/1254933a/attachment-0001.html>

From luke at dashjr.org  Wed Mar  4 14:35:16 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 4 Mar 2020 14:35:16 +0000
Subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion
In-Reply-To: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>
References: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>
Message-ID: <202003041435.17644.luke@dashjr.org>

In addition to starting with proof-of-funds instead of proof-of-receiver, it 
would be nice to integrate with Taproot somehow or another. Perhaps 
OP_MESSAGEONLY is the most straightforward way to do this? It might be a good 
idea to have a message type after the opcode too.

On Wednesday 04 March 2020 06:23:53 Karl-Johan Alm via bitcoin-dev wrote:
> Hello,
>
> I noticed recently that a PR to Bitcoin Core that pretty much touched
> everything my BIP-322 pull request touches (around the same
> complexity) was merged without a thought given to BIP-322
> compatibility, despite the BIP-322 PR being open for 2x the time. I
> can only conclude from this that people dislike BIP-322 in its current
> form, which the 9 month old pull request stagnating can probably
> attest to.
>
> There are several things that I can do to make this a bit more
> appealing to people, which would hopefully kick the progress on this
> forward. I have already put in a non-trivial amount of energy and
> effort into maintaining the pull request as is, so I'd prefer if
> people were harsh and unfiltered in their criticism rather than polite
> and buffered, so I can beat this thing into shape (or abandon it, in
> the worst case).
>
> =============
> 1. People use signmessage as a way to prove funds. This is misleading
> and should be discouraged; throw the sign message stuff out and
> replace it entirely with a prove funds system.
>
> I know in particular luke-jr is of this opinion, and Greg Maxwell in
> https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168
> leans towards this opinion as well, it seems.
>
> =============
> 2. Use a transaction rather than a new format; make the first input's
> txid the message hash to ensure the tx cannot be broadcasted. This has
> the benefit of being able to provide to an existing hardware wallet
> without making any modifications to its firmware.
>
> I think Mark Friedenbach and Johnson Lau are of this opinion, except
> Johnson Lau also suggests that the signature hash is modified, see
> https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --
> which defeats the benefit above since now hw wallets can no longer
> sign.
>
> Prusnak (I think he works at Trezor; apologies if I am mistaken) is
> against this idea, and proposes (3) below:
> https://github.com/bitcoin/bips/pull/725#issuecomment-420210488
>
> =============
> 3. Use Trezor style
>
> See https://github.com/trezor/trezor-mcu/issues/169
>
> This has the benefit of already being adopted (which clearly BIP-322
> is failing hard at right now), but has the drawback that we can no
> longer do *generic* signing; we are stuck with the exact same
> limitations as in the legacy system, which we kinda wanted to fix in
> the updated version.
>
> =============
> 4. Introduce OP_MESSAGEONLY
>
> Quoting Johnson Lau at
> https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :
> """
> OP_MESSAGEONLY means the script following the code would never be
> valid. For example, a scriptPubKey:
>
> OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG
>
> For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is
> ignored. A message could be signed with either key_m or key_s.
>
> For spending, only key_s is valid.
>
> I don't think it is a big problem to consume a op_code. If this is a
> real concern, I could modify it as follow: in message system,
> OP_RETURN will pop the top stack. If top stack is msg in hex, it is
> ignored. Otherwise, the script fails.
> """
>
> =============
> 5. Some other solution
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From gsanders87 at gmail.com  Wed Mar  4 14:43:13 2020
From: gsanders87 at gmail.com (Greg Sanders)
Date: Wed, 4 Mar 2020 09:43:13 -0500
Subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion
In-Reply-To: <202003041435.17644.luke@dashjr.org>
References: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>
 <202003041435.17644.luke@dashjr.org>
Message-ID: <CAB3F3DtruOW8q7E8=wP+Jf-bdcPGrypgXjFjcABrD1qQcrX+gg@mail.gmail.com>

OP_MESSAGEONLY would make "dumb" signers like HWW more difficult to
support. They'd have to do script interpretation to make sure they're not
signing something real with funds.

Just FYI.

On Wed, Mar 4, 2020 at 9:35 AM Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> In addition to starting with proof-of-funds instead of proof-of-receiver,
> it
> would be nice to integrate with Taproot somehow or another. Perhaps
> OP_MESSAGEONLY is the most straightforward way to do this? It might be a
> good
> idea to have a message type after the opcode too.
>
> On Wednesday 04 March 2020 06:23:53 Karl-Johan Alm via bitcoin-dev wrote:
> > Hello,
> >
> > I noticed recently that a PR to Bitcoin Core that pretty much touched
> > everything my BIP-322 pull request touches (around the same
> > complexity) was merged without a thought given to BIP-322
> > compatibility, despite the BIP-322 PR being open for 2x the time. I
> > can only conclude from this that people dislike BIP-322 in its current
> > form, which the 9 month old pull request stagnating can probably
> > attest to.
> >
> > There are several things that I can do to make this a bit more
> > appealing to people, which would hopefully kick the progress on this
> > forward. I have already put in a non-trivial amount of energy and
> > effort into maintaining the pull request as is, so I'd prefer if
> > people were harsh and unfiltered in their criticism rather than polite
> > and buffered, so I can beat this thing into shape (or abandon it, in
> > the worst case).
> >
> > =============
> > 1. People use signmessage as a way to prove funds. This is misleading
> > and should be discouraged; throw the sign message stuff out and
> > replace it entirely with a prove funds system.
> >
> > I know in particular luke-jr is of this opinion, and Greg Maxwell in
> > https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168
> > leans towards this opinion as well, it seems.
> >
> > =============
> > 2. Use a transaction rather than a new format; make the first input's
> > txid the message hash to ensure the tx cannot be broadcasted. This has
> > the benefit of being able to provide to an existing hardware wallet
> > without making any modifications to its firmware.
> >
> > I think Mark Friedenbach and Johnson Lau are of this opinion, except
> > Johnson Lau also suggests that the signature hash is modified, see
> > https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --
> > which defeats the benefit above since now hw wallets can no longer
> > sign.
> >
> > Prusnak (I think he works at Trezor; apologies if I am mistaken) is
> > against this idea, and proposes (3) below:
> > https://github.com/bitcoin/bips/pull/725#issuecomment-420210488
> >
> > =============
> > 3. Use Trezor style
> >
> > See https://github.com/trezor/trezor-mcu/issues/169
> >
> > This has the benefit of already being adopted (which clearly BIP-322
> > is failing hard at right now), but has the drawback that we can no
> > longer do *generic* signing; we are stuck with the exact same
> > limitations as in the legacy system, which we kinda wanted to fix in
> > the updated version.
> >
> > =============
> > 4. Introduce OP_MESSAGEONLY
> >
> > Quoting Johnson Lau at
> > https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :
> > """
> > OP_MESSAGEONLY means the script following the code would never be
> > valid. For example, a scriptPubKey:
> >
> > OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG
> >
> > For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is
> > ignored. A message could be signed with either key_m or key_s.
> >
> > For spending, only key_s is valid.
> >
> > I don't think it is a big problem to consume a op_code. If this is a
> > real concern, I could modify it as follow: in message system,
> > OP_RETURN will pop the top stack. If top stack is msg in hex, it is
> > ignored. Otherwise, the script fails.
> > """
> >
> > =============
> > 5. Some other solution
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200304/4a364551/attachment.html>

From ZmnSCPxj at protonmail.com  Wed Mar  4 23:29:09 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Wed, 04 Mar 2020 23:29:09 +0000
Subject: [bitcoin-dev] Hash function requirements for Taproot
In-Reply-To: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>
References: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>
Message-ID: <tXbP-9UVzs4Je3MdjTYAbm0ZWVMctlhY15v6_G8CCRnaWJjo8VU8h2WDfUSiqnWl8rQa0zbrsupNRNtss0gDFjMiqwNil_ahiqSraICAP9Q=@protonmail.com>

Good morning LL,

Thank you very much for this work, it seems quite interesting.

> 5. You can completely circumvent this result by using coin-tossing rather than MuSig for the key generation protocol. In most cases this doesn't even add any extra rounds of communication since you are doing 3-round coin tossing to choose the R values for the signatures that spend from the joint output anyway. You can just toss your public keys in parallel.

I am uncertain what you mean here by "coin-tossing".
>From the comparison to MuSig, I imagine it is an interactive key generation protocol like this:

* Everybody generates fresh keypairs.
* Everybody sends the hash of their pubkey to everyone else.
* After receiving a hash of pubkey from everyone else, everybody sends their pubkey to everyone else.
* They add all their pubkeys to generate the aggregate key (and if using Taproot, use it as the internal key).

Is that correct?

In any case, the comparison to MuSig signing appears to imply interactive key generation.
The advantage of MuSig is that it requires no interactivity for key generation of n-of-n (I am told it requires interactivity to generate k-of-n).

However, it can generally be pointed out that, before you put anything into an n-of-n, you would damn well sure want to have *some* assurance that you can get it out later.
So in general you would need coordination and interaction anyway to arrange getting into an n-of-n in the first place.

On the other hand, it would be best to have at least some minimum of privacy by always interacting over Tor and having a Tor .onion address, which has absolutely horrid latency because human beings cry when peeling onions.
So in general reducing the latency by reducing communication rounds is better in general.
Counter to this, assuming you use an n-of-n in an offchain protocol of some sort, the number of communication rounds to generate the aggregate key may be dwarfed by the total number of communication rounds to create signatures to update the offchain protocol.
Counter counter to this is that one plan for reducing communications rounds for creating signatures during offchain operation is to (haha) use a Taproot with an n-of-n internal key and a tapscript that has n `OP_CHECKSIG` operations, so that for normal operation you just toss individual signatures at each other but at termination of the offchain protocol you can do the heavy MuSig-style signing with the n-of-n aggregate key.

Regards,
ZmnSCPxj

From karljohan-alm at garage.co.jp  Thu Mar  5 06:43:03 2020
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Thu, 5 Mar 2020 15:43:03 +0900
Subject: [bitcoin-dev] Signet: static genesis block,
	and dynamic message start
Message-ID: <CALJw2w6Yr8ajeibptc8mJYCyAaVnqqQbWw6xnW9DtfApUOKSZA@mail.gmail.com>

Hello,

I am proposing a modification to BIP-325 to make the genesis block
static and to rely on the message start to avoid collision between
signets when multiple nets exist simultaneously:

https://github.com/bitcoin/bips/pull/900

From lloyd.fourn at gmail.com  Thu Mar  5 09:56:54 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Thu, 5 Mar 2020 20:56:54 +1100
Subject: [bitcoin-dev] Hash function requirements for Taproot
In-Reply-To: <tXbP-9UVzs4Je3MdjTYAbm0ZWVMctlhY15v6_G8CCRnaWJjo8VU8h2WDfUSiqnWl8rQa0zbrsupNRNtss0gDFjMiqwNil_ahiqSraICAP9Q=@protonmail.com>
References: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>
 <tXbP-9UVzs4Je3MdjTYAbm0ZWVMctlhY15v6_G8CCRnaWJjo8VU8h2WDfUSiqnWl8rQa0zbrsupNRNtss0gDFjMiqwNil_ahiqSraICAP9Q=@protonmail.com>
Message-ID: <CAH5Bsr0tGFrH5qgUr20fUaceZZvJMY4_RBY6EU769L10KGc3Ng@mail.gmail.com>

> I am uncertain what you mean here by "coin-tossing".
> From the comparison to MuSig, I imagine it is an interactive key
generation protocol like this:

> * Everybody generates fresh keypairs.
> * Everybody sends the hash of their pubkey to everyone else.
> * After receiving a hash of pubkey from everyone else, everybody sends
their pubkey to everyone else.
> * They add all their pubkeys to generate the aggregate key (and if using
Taproot, use it as the internal key).

> Is that correct?

Yes exactly. The reason it's called coin tossing is that the resulting key
is guaranteed to be uniformly random (in the random oracle model at least),
so it's like tossing a fair 2^256 sided coin. This is not true in MuSig for
example, where the aggregate key is not guaranteed to be from a uniform
distribution against a malicious party (but still secure as an aggregate
key).

> However, it can generally be pointed out that, before you put anything
into an n-of-n, you would damn well sure want to have *some* assurance that
you can get it out later. So in general you would need coordination and
interaction anyway to arrange getting into an n-of-n in the first place.

Right. Taking your example of a lightning channel, when you set it up I
don't *think* there is a way to use the non-interactivity of MuSig to
remove any rounds of communication to get to the starting state where there
is a channel funding on-chain and both parties have a tx that spends from
it which returns their funds. Doing coin tossing for the aggregate key as
well as the aggregate nonce shouldn't lead to any extra rounds of
communication. The downside of coin tossing is that it requires honest
parties to sample their keys non-deterministically (or at least have a
counter to avoid using the same key twice).

> On the other hand, it would be best to have at least some minimum of
privacy by always interacting over Tor and having a Tor .onion address,
which has absolutely horrid latency because human beings cry when peeling
onions.
> So in general reducing the latency by reducing communication rounds is
better in general.
> Counter to this, assuming you use an n-of-n in an offchain protocol of
some sort, the number of communication rounds to generate the aggregate key
may be dwarfed by the total number of communication rounds to create
signatures to update the offchain protocol.
> Counter counter to this is that one plan for reducing communications
rounds for creating signatures during offchain operation is to (haha) use a
Taproot with an n-of-n internal key and a tapscript that has n
`OP_CHECKSIG` operations, so that for normal operation you just toss
individual signatures at each other but at termination of the offchain
protocol you can do the heavy MuSig-style signing with the n-of-n aggregate
key.

Counter? to this is that, in the case of lightning, the aggregate key for a
PTLC does not need to be chosen at payment time.  They channel members
could simply use the "master" aggregate key they generated by coin tossing
at the channel's inception and pseudorandomly randomise it every time they
need a new joint key (so the keys do not look related to everyone else on
the chain but you would effectively just be reusing the same public key).

Having said that if there is some advantage to using MuSig in some
particular case I wouldn't hesitate to use it in combination with Taproot.
I don't think the new assumption that I think you have to make wrt to the
hash function really weighs up against most design considerations. In
general, it is probably worth considering whether your protocol actually
benefits from the non-interactivity MuSig gives in the key generation
stage. If it doesn't due to the fact that it doesn't make signing anymore
non-interactive, then coin tossing might be the answer.

LL
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200305/fdfb6b5c/attachment.html>

From erik at q32.com  Thu Mar  5 19:01:27 2020
From: erik at q32.com (Erik Aronesty)
Date: Thu, 5 Mar 2020 14:01:27 -0500
Subject: [bitcoin-dev] Schnorr sigs vs pairing sigs
Message-ID: <CAJowKg+Sgfv-FxZ2gyYWO4HmVwVFZjpjN3RkGN4y1TJwpuLMtQ@mail.gmail.com>

Schnorr sigs rely so heavily on the masking provided by a random
nonce.   There are so many easy ways to introduce bias (hash + modulo,
for example).

Even 2 bits of bias can result in serious attacks:

https://ecc2017.cs.ru.nl/slides/ecc2017-tibouchi.pdf

Maybe pairing based sigs  - which are slower - might be both more
flexible, and better suited to secure implemetnations?

From lloyd.fourn at gmail.com  Fri Mar  6 06:40:24 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Fri, 6 Mar 2020 17:40:24 +1100
Subject: [bitcoin-dev] Schnorr sigs vs pairing sigs
In-Reply-To: <CAJowKg+Sgfv-FxZ2gyYWO4HmVwVFZjpjN3RkGN4y1TJwpuLMtQ@mail.gmail.com>
References: <CAJowKg+Sgfv-FxZ2gyYWO4HmVwVFZjpjN3RkGN4y1TJwpuLMtQ@mail.gmail.com>
Message-ID: <CAH5Bsr3CbG6b4tk0hkLECfg0LM38BNp7nfspLv+NbMg6f79iDg@mail.gmail.com>

Hi Erik,

There are a strong arguments for and against pairing based sigs in Bitcoin.
One very strong argument in favour over non-deterministic signatures like
Schnorr over BLS is it enables a kind of signature encryption called
"adaptor signatures". This construction is key to many exciting up and
coming layer 2 protocols and isn't possible unless the signature scheme
uses randomness.

self plug: I have a paper on this topic called "One-Time Verifiably
Encrypted Signatures A.K.A Adaptor Signatures"
 https://github.com/LLFourn/one-time-VES/blob/master/main.pdf

LL


On Fri, Mar 6, 2020 at 6:03 AM Erik Aronesty via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Schnorr sigs rely so heavily on the masking provided by a random
> nonce.   There are so many easy ways to introduce bias (hash + modulo,
> for example).
>
> Even 2 bits of bias can result in serious attacks:
>
> https://ecc2017.cs.ru.nl/slides/ecc2017-tibouchi.pdf
>
> Maybe pairing based sigs  - which are slower - might be both more
> flexible, and better suited to secure implemetnations?
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200306/777ed685/attachment.html>

From roconnor at blockstream.com  Fri Mar  6 11:11:11 2020
From: roconnor at blockstream.com (Russell O'Connor)
Date: Fri, 6 Mar 2020 06:11:11 -0500
Subject: [bitcoin-dev] Removing Single Point of Failure with Seed Phrase
	Storage
In-Reply-To: <CAD5xwhgP=9-AvMOVO+-b9c3DZ_vYd-bPLYM26Qvawmcj28UOZw@mail.gmail.com>
References: <CAEcfjBRCA1sKcFC5M++WECsgYD-jDBYGuwxLfh0PSzRkCehEDA@mail.gmail.com>
 <CAD5xwhgP=9-AvMOVO+-b9c3DZ_vYd-bPLYM26Qvawmcj28UOZw@mail.gmail.com>
Message-ID: <CAMZUoKnNK-_shu4BQXK=FbtqYUn8MT=yjNDY1VFx73AAcSAzsQ@mail.gmail.com>

On Wed, Feb 26, 2020 at 2:56 PM Jeremy via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> As a replacement for paper, something like this makes sense v.s. what you
> do with a ledger presently.
>
> However, shamir's shares notoriously have the issue that the key does
> exist plaintext on a device at some point.
>
> Non-interactive multisig has the benefit of being able to sign
> transactions without having keys in the same room/place/device ever.
> --
> @JeremyRubin <https://twitter.com/JeremyRubin>
> <https://twitter.com/JeremyRubin>
>

The way I see it, the main benefit of Shamir's Secret Sharing is for those
people who are already willing or wanting to be able to sign transactions
on a single device, in a single room, etc., but would prefer not to keep
their secret backup in a single room/place/device.  It is one thing to go
and gather your shares whenever you need to recover from a broken/wiped
hardware wallet versus having to go gather your shares whenever you want to
make a transaction.  (I do agree that SSS is not a suitabl for creating a
multisig from multiple participants.)

This thread inspired me tidy up and post my concept for creating secret
shares using paper computers (slide charts) and can be found at
https://github.com/roconnor-blockstream/SSS32/blob/master/SSS32.ps. It is a
design for splitting a secret encoded in the Bech32 alphabet into 2-of-n
shares (where n <= 31) using pencil, paper and lookup tables.  There are
numerous issues <https://github.com/roconnor-blockstream/SSS32/issues> and
more that need to be addressed before one could even think about using it
for actual valuable data.  Right now I'm mostly interested to find out if
paper sharing is really feasible.

A secret of 26 random Bech32 characters provides 130 bits of entropy, and a
secret of 51 random Bech32 characters provides 255 bits of entropy.
However, to enable robust recovery, the secret data ought to contain an
error correcting code.  Because each character of the secret is
independently split into shares, any single character error in one of the
shares translates into a single character error in the recovered secret
which can be corrected by the error correcting code.  See the exercise at
the end of "Verifying Bech32 Checksums with Pen and Paper" <
http://r6.ca/blog/20180106T164028Z.html> on how to attach the Bech32 error
correcting code to a raw secret string by hand.  However, protecting the
secret data is so important that one would want to design a checksum BCH
code longer than 6 characters to get strong error correcting capabilities.

I still don't know if this proposed method all a good idea or not.  I've
only experimented with encoding and recovering a 10 character "secret"
data.  Generating 2-of-n shares is quite easy as all the shares are a
function of the secret share and the first random share.  It only takes
lookup up a pair of coordinates in a table to generate one character for
each of the n shares together.  Recovering the secret data is more work;
however, if your plan is to recover a hardware wallet anyways, it is
reasonable for the hardware wallet to do the recovery from the shares
itself for you.  Generating the error correcting code by hand is a bit more
worrying, because it doesn't do you much good if your generate an incorrect
checksum.  However, by doing 1 or 2 manual passes to verify the checksum is
maybe adequate.  Also passing the secret data into the hardware wallet you
wish to use, along with its checksum, would let the hardware wallet tell
you if there was an error in the checksum.  I think creating more general
3-of-n schemes can be implemented too, but require work similar to recovery
to generate rather than the simple lookup table process.  Generating 4-of-n
and higher schemes may also be possible, but would require even more hand
computation (i.e. computing lagrange polynomials.)

Maybe this scheme is workable for the subset of people that this would
appeal to.  In anycase, my document is open source and available for those
who want to tinker with it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200306/00d09243/attachment.html>

From luke at dashjr.org  Sat Mar  7 19:47:36 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 7 Mar 2020 19:47:36 +0000
Subject: [bitcoin-dev] Bitcoin Knots 0.19.1.knots20200304 released
Message-ID: <202003071947.49737.luke@dashjr.org>

Bitcoin Knots version 0.19.1.knots20200304 is now available from:

  https://bitcoinknots.org/files/0.19.x/0.19.1.knots20200304/

This release includes new features, various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  https://github.com/bitcoinknots/bitcoin/issues

To receive security and update notifications, please subscribe to:

  https://bitcoinknots.org/list/announcements/join/

For the full release notes and change log, see:
  
https://github.com/bitcoinknots/bitcoin/blob/v0.19.1.knots20200304/doc/release-notes.md
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 1528 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200307/dcd345ed/attachment.sig>

From laanwj at gmail.com  Mon Mar  9 12:33:14 2020
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Mon, 9 Mar 2020 13:33:14 +0100
Subject: [bitcoin-dev] Bitcoin Core 0.19.1 released
Message-ID: <20200309123314.i4iq3rstnrj2cuc5@aurora.visucore.com>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

0.19.1 Release Notes
===============================

Bitcoin Core version 0.19.1 is now available from:

  <https://bitcoincore.org/bin/bitcoin-core-0.19.1/>

or through BitTorrent:

  magnet:?xt=urn:btih:8b6ad1da5bbb24656234efc2370abc14781a6f83&dn=bitcoin-core-0.19.1&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A80&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Ftracker.coppersurfer.tk%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.leechers-paradise.org%3A6969%2Fannounce&tr=udp%3A%2F%2Fexplodie.org%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.torrent.eu.org%3A451%2Fannounce&tr=udp%3A%2F%2Ftracker.bitcoin.sprovoost.nl%3A6969

This minor release includes various bug fixes and performance
improvements, as well as updated translations.

Please report bugs using the issue tracker at GitHub:

  <https://github.com/bitcoin/bitcoin/issues>

To receive security and update notifications, please subscribe to:

  <https://bitcoincore.org/en/list/announcements/join/>

How to Upgrade
==============

If you are running an older version, shut it down. Wait until it has completely
shut down (which might take a few minutes for older versions), then run the
installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)
or `bitcoind`/`bitcoin-qt` (on Linux).

Upgrading directly from a version of Bitcoin Core that has reached its EOL is
possible, but it might take some time if the datadir needs to be migrated. Old
wallet versions of Bitcoin Core are generally supported.

Compatibility
==============

Bitcoin Core is supported and extensively tested on operating systems using
the Linux kernel, macOS 10.10+, and Windows 7 and newer. It is not recommended
to use Bitcoin Core on unsupported systems.

Bitcoin Core should also work on most other Unix-like systems but is not
as frequently tested on them.

- From Bitcoin Core 0.17.0 onwards, macOS versions earlier than 10.10 are no
longer supported, as Bitcoin Core is now built using Qt 5.9.x which requires
macOS 10.10+. Additionally, Bitcoin Core does not yet change appearance when
macOS "dark mode" is activated.

In addition to previously supported CPU platforms, this release's pre-compiled
distribution provides binaries for the RISC-V platform.

0.19.1 change log
=================

### Wallet
- - #17643 Fix origfee return for bumpfee with feerate arg (instagibbs)
- - #16963 Fix `unique_ptr` usage in boost::signals2 (promag)
- - #17258 Fix issue with conflicted mempool tx in listsinceblock (adamjonas, mchrostowski)
- - #17924 Bug: IsUsedDestination shouldn't use key id as script id for ScriptHash (instagibbs)
- - #17621 IsUsedDestination should count any known single-key address (instagibbs)
- - #17843 Reset reused transactions cache (fjahr)

### RPC and other APIs
- - #17687 cli: Fix fatal leveldb error when specifying -blockfilterindex=basic twice (brakmic)
- - #17728 require second argument only for scantxoutset start action (achow101)
- - #17445 zmq: Fix due to invalid argument and multiple notifiers (promag)
- - #17524 psbt: handle unspendable psbts (achow101)
- - #17156 psbt: check that various indexes and amounts are within bounds (achow101)

### GUI
- - #17427 Fix missing qRegisterMetaType for `size_t` (hebasto)
- - #17695 disable File-\>CreateWallet during startup (fanquake)
- - #17634 Fix comparison function signature (hebasto)
- - #18062 Fix unintialized WalletView::progressDialog (promag)

### Tests and QA
- - #17416 Appveyor improvement - text file for vcpkg package list (sipsorcery)
- - #17488 fix "bitcoind already running" warnings on macOS (fanquake)
- - #17980 add missing #include to fix compiler errors (kallewoof)

### Platform support
- - #17736 Update msvc build for Visual Studio 2019 v16.4 (sipsorcery)
- - #17364 Updates to appveyor config for VS2019 and Qt5.9.8 + msvc project fixes (sipsorcery)
- - #17887 bug-fix macos: give free bytes to `F_PREALLOCATE` (kallewoof)

### Miscellaneous
- - #17897 init: Stop indexes on shutdown after ChainStateFlushed callback (jimpo)
- - #17450 util: Add missing headers to util/fees.cpp (hebasto)
- - #17654 Unbreak build with Boost 1.72.0 (jbeich)
- - #17857 scripts: Fix symbol-check & security-check argument passing (fanquake)
- - #17762 Log to net category for exceptions in ProcessMessages (laanwj)
- - #18100 Update univalue subtree (MarcoFalke)

Credits
=======

Thanks to everyone who directly contributed to this release:

- - Aaron Clauson
- - Adam Jonas
- - Andrew Chow
- - Fabian Jahr
- - fanquake
- - Gregory Sanders
- - Harris
- - Hennadii Stepanov
- - Jan Beich
- - Jim Posen
- - Jo?o Barbosa
- - Karl-Johan Alm
- - Luke Dashjr
- - MarcoFalke
- - Michael Chrostowski
- - Russell Yanofsky
- - Wladimir J. van der Laan

As well as to everyone that helped with translations on
[Transifex](https://www.transifex.com/bitcoin/bitcoin/).

-----BEGIN PGP SIGNATURE-----

iQEzBAEBCgAdFiEEnerg3HBjJJ+wVHRoHkrtYphs0l0FAl5mN1QACgkQHkrtYphs
0l1BuAf/RTyeosxcO4/VxR5nm2AEDb/gaaBDByRNgSxjZMT5dNnYDV8rmJgDoGAe
FTHvp+/yC224TvDEFc2tcfU44L0nDfBfhZIPXkVQNVb75LGyN7nHCLIcLxxmutLZ
HQ5cqehjzhbKdo0jGUhFa2vyVydbl823ZfJwt9gYRtIISxp78ZeXRFjm/2Br+TS0
J/9iA77eA1j4euVPoHs9K07AqCm2gIYYpZNiP1Xg6HEErPT6+7/nPzH95XRW2wX6
ea+QeuJcMRdoLXwxfENC9ywyxP3zgPvPPV6KFUBwchp+YczEZrQywbbYGRhbAcRh
AOUVQ1tEfxN+wjBZjL5vcymwrChgiA==
=M98k
-----END PGP SIGNATURE-----

From crypto at timruffing.de  Thu Mar 12 17:04:47 2020
From: crypto at timruffing.de (Tim Ruffing)
Date: Thu, 12 Mar 2020 18:04:47 +0100
Subject: [bitcoin-dev] Hash function requirements for Taproot
In-Reply-To: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>
References: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>
Message-ID: <3e5b438ce1487412d203387d6c0e8f53cfdb7449.camel@timruffing.de>

Hi Lloyd,

This is great research, thanks for this effort!

Here are some comments:

On Wed, 2020-03-04 at 18:10 +1100, Lloyd Fournier via bitcoin-dev
wrote:
> 
> Property (2) is more difficult to argue as it depends on the multi-
> party key generation protocol. Case in point: Taproot is completely
> broken when combined with a proof of knowledge key generation
> protocol where along with their public keys each party provides a
> proof of knowledge of the secret key. Where X_1 is the key of the
> honest party, the malicious party can choose their key X_2 to be
> G*H(X_1 || m) where m is a malicious Merkle root. Clearly the
> malicious party has a covert Taproot for X = X_1 + X_2 and can
> produce a proof of knowledge for X_2.

I mean, the good thing is that there's a general method to defend
against this, namely always adding a Merkle root on top. Maybe it's
useful to make the warning here a litte bit more drastic:
https://github.com/sipa/bips/blob/bip-taproot/bip-0341.mediawiki#cite_ref-22-0
Maybe we could actually mention this in BIP340, too, when we talk about
key generation,

> 
> Poelstra presented a proof in the ROM for the security of Taproot
> [3]. It frames Taproot as a way of combining two signature schemes
> into one public key (in our case Schnorr and Tapscript). He uses a
> similar line of reasoning to what I have just presented in his proof
> (Lemma 1, step 3) but this approach brings in many other
> considerations that I think can be avoided by modelling it as a
> commitment scheme. Note that this proof only shows that Taproot
> forgeries are hard i.e. property (1).

I agree that modeling it as a commitment scheme is more natural. But I
think an optimal model would capture both worlds, and would give the
attacker signing oracles for the inner and the outer key, and an
commitment opening oracle That is, it would capture that 
 * the ability to obtain signatures for the inner key does not help you
   to forge for the outer key
 * the ability to obtain signatures for the outer key does not help you
   to open the commitment, and --- if already opened --- do not help
   you to forge for the inner key
 * the ability to obtain an opening does not help you to forge for
   either key... 
 * etc

I believe that all these properties hold, and I believe this even
without a formal proof. 

Still, it would be great to have one. The problem here is really that
things get complex so quickly. For example, how do you model key
generation in the game(s) that I sketched above? The traditional way or
with MuSig. The reality is that we want to have everything combined:
 * BIP32
 * MuSig (and variants of it)
 * Taproot (with scripts that refer to the inner key)
 * sign-to-contract stuff (e.g., to prevent covert channels with
   hardware wallets)
 * scriptless scrips
 * blind signatures
 * threshold signtures
 * whatever you can imagine on top of this

It's very cumbersome to come up with a formal model that includes all
of this. One common approach to protocols that are getting too complex
is to switch to simpler models, e.g., symbolic models/Dolev-Yao models
but that's hard here given that we don't have clear layering. Things
would be easier to analyze if Taproot was really  just a commitment to
a verification key. But it's more, it's something that's both a
verification and a commitment. Taproot interferes with Schnorr
signatures on an algebraic level (not at all black-box), and that's
actually the reason why it's so powerful and efficient. The same is
true for almost everything in the list above, and this puts Taproot
outside the scope of proof assistants for cryptographic protocols that
work on a symbolic level of abstraction. I really wonder how we can
handle this better. This would improve our understanding of the
interplay between various crypto components better, and make it easier
to judge future proposals on all levels, from consensus changes to new
multi-signature protocols, etc.

> 
> In my opinion, the cost of Taproot is mostly borne by theoreticians.
> They can no longer treat a a public key ideally but have to consider
> the implications of it also being a commitment. For the user and
> Bitcoin as a whole it seems to offer an overwhelming benefit. In
> exchange for the complexity it adds to making security claims in the
> GGM (if using Taprscript and MuSig), it offers exciting new
> opportunities for non-interactivity and fungibility over what just
> what Schnorr would provide.

I agree with this overall statement. I'm confident in Taproot, and I
guess what say above really applies to the cost for theoreticians.
(Let's just make sure that we don't forget how theory is relevant to
security in practice.) 

Tim


From lloyd.fourn at gmail.com  Mon Mar 16 07:31:44 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Mon, 16 Mar 2020 18:31:44 +1100
Subject: [bitcoin-dev] Hash function requirements for Taproot
In-Reply-To: <3e5b438ce1487412d203387d6c0e8f53cfdb7449.camel@timruffing.de>
References: <CAH5Bsr2m3+kN67h0Dd+60-i3WCnCRXr_ywzub5_OV=UxxzN3hQ@mail.gmail.com>
 <3e5b438ce1487412d203387d6c0e8f53cfdb7449.camel@timruffing.de>
Message-ID: <CAH5Bsr0DJVHiQYbN1KkdRVx8E4MgAp0Hwu5bSKZuXkhy8uONQQ@mail.gmail.com>

On Fri, Mar 13, 2020 at 4:04 AM Tim Ruffing <crypto at timruffing.de> wrote:
>
> I mean, the good thing is that there's a general method to defend
> against this, namely always adding a Merkle root on top. Maybe it's
> useful to make the warning here a litte bit more drastic:
>
https://github.com/sipa/bips/blob/bip-taproot/bip-0341.mediawiki#cite_ref-22-0
> Maybe we could actually mention this in BIP340, too, when we talk about
> key generation,

I missed this note in the BIP. This trick means you get property 2  (covert
taproot) for free if you prove property 3 (second covert taproot). This is
a big improvement as property 2 was dependent on the particulars of the key
generation scheme whereas property 3 is just based on Taproot being a
secure commitment scheme. Nice!

> I agree that modeling it as a commitment scheme is more natural. But I
> think an optimal model would capture both worlds, and would give the
> attacker signing oracles for the inner and the outer key, and an
> commitment opening oracle That is, it would capture that
>  * the ability to obtain signatures for the inner key does not help you
>    to forge for the outer key
>  * the ability to obtain signatures for the outer key does not help you
>    to open the commitment, and --- if already opened --- do not help
>    you to forge for the inner key
>  * the ability to obtain an opening does not help you to forge for
>    either key...
>  * etc
>
> I believe that all these properties hold, and I believe this even
> without a formal proof.
>
>
> Still, it would be great to have one. The problem here is really that
> things get complex so quickly. For example, how do you model key
> generation in the game(s) that I sketched above? The traditional way or
> with MuSig. The reality is that we want to have everything combined:
>  * BIP32
>  * MuSig (and variants of it)
>  * Taproot (with scripts that refer to the inner key)
>  * sign-to-contract stuff (e.g., to prevent covert channels with
>    hardware wallets)
>  * scriptless scrips
>  * blind signatures
>  * threshold signtures
>  * whatever you can imagine on top of this
>
> It's very cumbersome to come up with a formal model that includes all
> of this. One common approach to protocols that are getting too complex
> is to switch to simpler models, e.g., symbolic models/Dolev-Yao models
> but that's hard here given that we don't have clear layering. Things
> would be easier to analyze if Taproot was really  just a commitment to
> a verification key. But it's more, it's something that's both a
> verification and a commitment. Taproot interferes with Schnorr
> signatures on an algebraic level (not at all black-box), and that's
> actually the reason why it's so powerful and efficient. The same is
> true for almost everything in the list above, and this puts Taproot
> outside the scope of proof assistants for cryptographic protocols that
> work on a symbolic level of abstraction. I really wonder how we can
> handle this better. This would improve our understanding of the
> interplay between various crypto components better, and make it easier
> to judge future proposals on all levels, from consensus changes to new
> multi-signature protocols, etc.
>

I hope we can prove these things in a more modular way without creating a
hybrid scheme with multiple oracles. My hope is that you can prove that any
secure key generation method will be secure once Taproot is applied to it
if it is a secure commitment scheme. This was difficult before I knew about
the empty commitment trick! Although the Taprooted key and the internal key
are algebraically related, the security requirements on the two primitives
(the group and the hash function) are nicely separated. Intuitively,
1. being able to  break the Taproot hash function (e.g. find pre-images)
does not help you forge signatures on any external key; it can only help
you forge fake commitment openings (for the sake of this point assume that
Schnorr uses an unrelated hash function for the challenge).
2. being able solve discrete logarithms doesn't help you break Taproot; it
just helps you forge signatures.

I believe we can formally prove these two points and therefore dismiss the
need for any signing or commitment opening oracles in any security notion
of Taproot:

1. We can dismiss the idea of an adversary that uses a commitment opening
oracle to forge a signature because the commitment opening is not even an
input into the signing algorithm. Therefore it is information theoretically
impossible to learn anything about forging a signature from a Taproot
opening.
2. I think we can dismiss the idea of an adversary that uses a signing
oracle to forge a fake Taproot opening. To see this note that the Taproot
Forge reduction to RPP in my poster actually still holds if the adversary
is given the secret key x (with a few other modifications). In the proof I
kept it hidden just because that seemed more realistic. If we give the
adversary the secret key we can dismiss the idea that a signing oracle will
help them because they can just simulate it. Furthermore, if honest parties
always require the empty commitment be applied to their key we can dismiss
the idea of an adversary that forges just based on the binding of the
commitment scheme even if they know the secret key and regardless of the
key generation algorithm.

This allows us to restrict our notion of Taproot's security to its
interaction with the key generation protocol only. It should be sufficient
to prove these three things:
1. The key generation scheme is secure. I don't believe we have a
definition for this yet but I guess it would be something like "if the
adversary can't output the secret key of the agg key then it is secure".
2. The Taproot transformation of any key generation scheme satisfying (1)
also satisfies (1).
3. The external key produced by any transformed protocol is a secure
commitment to the message (if one is desired, if not the empty commitment
trick fixes this).

This gives us a modular and composable security model for Taproot. We can
just prove that MuSig, threshold keygen, and all the other things you
mentioned satisfy (1) and then by implication the Taprooted version of it
is also secure. Or something like that!

LL
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200316/144eb7a8/attachment.html>

From ethankosakovsky at protonmail.com  Fri Mar 20 15:44:01 2020
From: ethankosakovsky at protonmail.com (Ethan Kosakovsky)
Date: Fri, 20 Mar 2020 15:44:01 +0000
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
Message-ID: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>

I would like to present a proposal for discussion and peer review. It aims to solve the problem of "too many seeds and too many backups" due to the many reasons stipulated in the proposal text.

https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki

<pre>
  BIP:
  Title: Deterministic Entropy From BIP32 Keychains
  Author: Ethan Kosakovsky <ethankosakovsky at protonmail.com>
  Comments-Summary: No comments yet.
  Comments-URI:
  Status: Proposed
  Type: Standards Track
  Created: 2020-03-20
  License: BSD-2-Clause
           OPL
</pre>

==Abstract==

This proposal provides a way to derive entropy from a HD keychain path in order to deterministically derive the initial entropy used to create keychain mnemonics and seeds.

==Motivation==

BIP32 uses some initial entropy as a seed to deterministically derive a BIP32 root for hierarchical deterministic keychains. BIP39 introduced a method of encoding initial entropy into a mnemonic phrase which is used as input to a one way hash function in order to deterministically derive a BIP32 seed. The motivation behind mnemonic phrases was to make it easier for humans to backup and store offline. There are also other variations of this theme.

The initial motivation of BIP32 was to make handling of large numbers of private keys easier to manage and backup, since you only need one BIP32 seed to cover all possible keys in the keychain. In practice however, due to various wallet implementations and security models, the average user may be faced with the need to handle an ever growing number of seeds/mnemonics. This is due to incompatible wallet standards, hardware wallets (HWW), seed formats and standards, as well as, the need to used a mix of hot and cold wallets depending on the application and environment.

Examples would span wallets on mobile phones, online servers running protocols like Join Market or Lightning, and the difference between Electrum and BIP39 mnemonic seed formats. The reference implementation of Bitcoin Core uses BIP32, while other cryptocurrencies like Monero use different mnemonic encoding schemes.

We must also consider the different variety of physical backups including paper, metal and other physical storage devices, as well as the potentially splitting backups across different geographical locations. This complexity may result in less care being taken with subsequently generated seeds for new wallets need to be stored and it ultimately results in less security. In reality, the idea of having "one seed for all" has proven to be more difficult in practice than originally thought.

Since all these derivation schemes are deterministic based on some initial entropy, this proposal aims to solve the above problems by detailing a way to deterministically derive the initial entropy used for new root keychains using a single BIP32 style "master root key". This will allow one root key or mnemonic to derive any variety of different root keychains in whatever format is required (like BIP32 and BIP39 etc).

==Specification==

Input starts with a BIP32 seed. Derivation scheme uses the format `m/83696968'/type'/index'` where `type` is the final seed type, and `index` in the key index of the hardened child private key.

| type | bits| output                    |
|------|-----|---------------------------|
|   0  | 128 | 12 word BIP39 mnemonic    |
|   1  | 256 | 24 word BIP39 mnemonic    |
|   2  | 128 | 12 word Electrum mnemonic |
|   3  | 256 | 24 word Electrum mnemonic |
|   4  | 256 | WIF for Bitcoin Core      |
|   5  | 256 | 25 word Monero mnemonic   |

Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-from-bip32') of the derived 32 byte private key (k). Entropy is taken from the result according to the number of bits required. This entropy can then be used as input to derive a mnemonic, wallet etc according to the `type` specified.

==Compatibility==

In order to maintain the widest compatibility, the input to this function is a BIP32 seed, which may or may not have been derived from a BIP39 like mnemonic scheme. This maintains the original motivation that one backup can store any and all child derivation schemes depending on the user's preference or hardware signing devices. For example, devices that store the HD seed as a BIP39 mnemonic, Electrum seed, or BIP32 root key would all be able to implement this standard.

==Discussion==

This proposal could be split into multiple discrete BIPs in the same way that BIP32 described the derivation mechanics, BIP39 the input encoding with mnemonics, and the derivation paths like BIP44, BIP49 and BIP84. This has been avoided to reduce complexity. The resulting private key processed with HMAC-SHA512 and truncated as necessary. HMAC-SHA512 was chosen because it may have better compatibility in embedded devices as it's already required in devices supporting BIP32.

==Test Vectors==

===Test case 1===

MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance
MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
PATH: m/83696968'/0'/0'
BITS REQUIRED: 128

DERIVED CHILD WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3
DERIVED CHILD k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23
CHILD ENTROPY=6458698fae3578b48a64124ea3514e12
CONVERT ENTROPY TO WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9
CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil liquid exchange box fatal caught
CHILD BIP39 SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d238cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153
CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkGbwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb


===Test case 2===

MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance
MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
PATH: m/83696968'/1'/0'
BITS REQUIRED: 256

DERIVED CHILD WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg
DERIVED CHILD k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192
CHILD ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e53639670b
CONVERT ENTROPY TO WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs
CHILD BIP39 MNEMONIC=unable imitate test flash witness escape stadium early inner thank company betray lecture chuckle swift hurt battle illness bicycle stable fat bronze order high
CHILD BIP39 SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bde6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803
CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHfetVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm


===Test case 3===

MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance
MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
PATH: m/83696968'/4'/0'
BITS REQUIRED: 256

DERIVED CHILD WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2
DERIVED CHILD k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2
CHILD ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d90832974
CONVERT ENTROPY TO WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G
CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team job mammal sing bracket reject smile limit comfort pluck extend picture race soda suit dose place obtain
CHILD BIP39 SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d54647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418
CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBoynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am

==References==

BIP32, BIP39

==Copyright==

This BIP is dual-licensed under the Open Publication License and BSD 2-clause license.

From stick at satoshilabs.com  Fri Mar 20 16:29:49 2020
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Fri, 20 Mar 2020 17:29:49 +0100
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
Message-ID: <4cc5041f-3960-8f42-256f-5e00e12d05c5@satoshilabs.com>

On 20/03/2020 16:44, Ethan Kosakovsky via bitcoin-dev wrote:
> I would like to present a proposal for discussion and peer review

I read your proposal twice and I still don't know what kind of problem
are you trying to solve.

This should be obvious from the "Abstract" and it's bad if it's not.




-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From ethankosakovsky at protonmail.com  Fri Mar 20 17:34:05 2020
From: ethankosakovsky at protonmail.com (Ethan Kosakovsky)
Date: Fri, 20 Mar 2020 17:34:05 +0000
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <4cc5041f-3960-8f42-256f-5e00e12d05c5@satoshilabs.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
 <4cc5041f-3960-8f42-256f-5e00e12d05c5@satoshilabs.com>
Message-ID: <x3wT5bNuZTOXW6pY5-zsu-5BOKYMRqrEoyOaK0kSpprkj7ikNhsLvzBoNqK1_KcWhnsn80Ld0f1jZdhZ4xol0rjnBtxbpH5fm3f2yKTGsVk=@protonmail.com>

Pavol,

Yes thank you. I find abstracts hard, I will try again.

Currently I need a separate BIP30 for many of my wallets. I cant have one master seed for all my wallets because some are less safe than others and storing the master in each environment will increase the chance it could be compromised (e.g. hot environments). I cant export a hardened xprv from my main BIP32 keychain and import it to my JM/Android wallet because they dont support it. There's also a usability issue there since xprvs are not easy to type.

e.g.
1. Join Market server (online)
2. Lightning node (online)
3. Trezor (offline)
4. Smartphone wallet with coffee money (online) (and no HWW support)
5. Bitcoin Core (doesn't use BIP39 at all)

I cannot use the same BIP39 seed across all these services. 1,2,4,5 are effectively hot wallets.

The problem is BIP39. BIP32 is fine but the backup process is not human friendly. It would have been better to simply serialize 128 or 256 bits of entropy into words like BIP39 does and be done with it. After that, it's all deterministic anyway. Instead BIP39 tries to ensure pseudorandom entropy by hash-stretching the initial entropy.

We can already export keychains from BIP32, as xprvs, but there is also no easy way to make as a human readable/typeable like BIP39 mnemonics. Most wallets don't allow you to import an xprv anyway, but again, good luck typing it.

What we are left with is an ecosystem that widely implements BIP39, so practically speaking if I want to use multiple wallets and cannot share an existing seed with that device, I need separate 12 or 24 word mnemonics. That's 5 times the complexity to store than one (in my case). I need a new cryptosteel. If I have two different geological locations for backup, it's hard to add more, since I need to travel. The whole point of BIP32 was one master key would rule them all - set up once, back up once and it's done. BIP39 was simply to make it human friendly to write down the seed on paper.

The easy solution as I see it is have one BIP39 mnemonic as my "master root key". From there it makes a BIP32 keychain and I can deterministically create child BIP39 seeds by taking a hardened path, using the private key as entropy ENT to create a new BIP39 mnemonic. If I do it this way I can have one initial backup, and if I need more wallets with a different seed, I can do it without worrying about backups. I'm future proof this way.

Ethan


??????? Original Message ???????
On Friday, March 20, 2020 5:29 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:

> On 20/03/2020 16:44, Ethan Kosakovsky via bitcoin-dev wrote:
>
> > I would like to present a proposal for discussion and peer review
>
> I read your proposal twice and I still don't know what kind of problem
> are you trying to solve.
>
> This should be obvious from the "Abstract" and it's bad if it's not.
>
>
> -------------------------------------------------------------------------------------------------------------------------------------------------------------------------
>
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs



From ethankosakovsky at protonmail.com  Fri Mar 20 17:35:13 2020
From: ethankosakovsky at protonmail.com (Ethan Kosakovsky)
Date: Fri, 20 Mar 2020 17:35:13 +0000
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <x3wT5bNuZTOXW6pY5-zsu-5BOKYMRqrEoyOaK0kSpprkj7ikNhsLvzBoNqK1_KcWhnsn80Ld0f1jZdhZ4xol0rjnBtxbpH5fm3f2yKTGsVk=@protonmail.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
 <4cc5041f-3960-8f42-256f-5e00e12d05c5@satoshilabs.com>
 <x3wT5bNuZTOXW6pY5-zsu-5BOKYMRqrEoyOaK0kSpprkj7ikNhsLvzBoNqK1_KcWhnsn80Ld0f1jZdhZ4xol0rjnBtxbpH5fm3f2yKTGsVk=@protonmail.com>
Message-ID: <k30xrtCAvArvTk-CMOGYZO7dVLYnnxkH1NJCDVrmNP_d75_sy9ljZ7bwW5UyRe4x6f3W3b476D4YnnXiWOX_gYiH7fdgT65UvRyzVvvVZcg=@protonmail.com>

I think my proposal can be summarized simply:

1. get a child private key, hmac it and get entropy bits.
2. Use that entropy to feed BIP39 to make a new mnemonic seed

Bitcoin Core hdseed is a private key, so we can also do the same steps here

1. get a child private key, hmac it and get entropy bits.
2. Use that entropy to create a WIF to become the key for hdseed in Bitcoin Core.

I standardize this by using paths (like BIP44/49)

m/SEED'/BIP39'/index'
m/SEED'/CORE'/index'

index allows me to generate multiple childs for that type.

Ethen

??????? Original Message ???????
On Friday, March 20, 2020 6:34 PM, Ethan Kosakovsky <ethankosakovsky at protonmail.com> wrote:

> Pavol,
>
> Yes thank you. I find abstracts hard, I will try again.
>
> Currently I need a separate BIP30 for many of my wallets. I cant have one master seed for all my wallets because some are less safe than others and storing the master in each environment will increase the chance it could be compromised (e.g. hot environments). I cant export a hardened xprv from my main BIP32 keychain and import it to my JM/Android wallet because they dont support it. There's also a usability issue there since xprvs are not easy to type.
>
> e.g.
>
> 1.  Join Market server (online)
> 2.  Lightning node (online)
> 3.  Trezor (offline)
> 4.  Smartphone wallet with coffee money (online) (and no HWW support)
> 5.  Bitcoin Core (doesn't use BIP39 at all)
>
>     I cannot use the same BIP39 seed across all these services. 1,2,4,5 are effectively hot wallets.
>
>     The problem is BIP39. BIP32 is fine but the backup process is not human friendly. It would have been better to simply serialize 128 or 256 bits of entropy into words like BIP39 does and be done with it. After that, it's all deterministic anyway. Instead BIP39 tries to ensure pseudorandom entropy by hash-stretching the initial entropy.
>
>     We can already export keychains from BIP32, as xprvs, but there is also no easy way to make as a human readable/typeable like BIP39 mnemonics. Most wallets don't allow you to import an xprv anyway, but again, good luck typing it.
>
>     What we are left with is an ecosystem that widely implements BIP39, so practically speaking if I want to use multiple wallets and cannot share an existing seed with that device, I need separate 12 or 24 word mnemonics. That's 5 times the complexity to store than one (in my case). I need a new cryptosteel. If I have two different geological locations for backup, it's hard to add more, since I need to travel. The whole point of BIP32 was one master key would rule them all - set up once, back up once and it's done. BIP39 was simply to make it human friendly to write down the seed on paper.
>
>     The easy solution as I see it is have one BIP39 mnemonic as my "master root key". From there it makes a BIP32 keychain and I can deterministically create child BIP39 seeds by taking a hardened path, using the private key as entropy ENT to create a new BIP39 mnemonic. If I do it this way I can have one initial backup, and if I need more wallets with a different seed, I can do it without worrying about backups. I'm future proof this way.
>
>     Ethan
>
>     ??????? Original Message ???????
>     On Friday, March 20, 2020 5:29 PM, Pavol Rusnak stick at satoshilabs.com wrote:
>
>
> > On 20/03/2020 16:44, Ethan Kosakovsky via bitcoin-dev wrote:
> >
> > > I would like to present a proposal for discussion and peer review
> >
> > I read your proposal twice and I still don't know what kind of problem
> > are you trying to solve.
> > This should be obvious from the "Abstract" and it's bad if it's not.
> >
> > Best Regards / S pozdravom,
> > Pavol "stick" Rusnak
> > CTO, SatoshiLabs



From peter at coinkite.com  Fri Mar 20 20:02:53 2020
From: peter at coinkite.com (Peter D. Gray)
Date: Fri, 20 Mar 2020 16:02:53 -0400
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
Message-ID: <20200320200253.GC13916@coinkite.com>


I like this proposal and I see it's value: "One seed to rule them all."

Not hard to implement either.

---
Peter D. Gray  ||  Founder, Coinkite  ||  Twitter: @dochex  ||  GPG: A3A31BAD 5A2A5B10


On Fri, Mar 20, 2020 at 03:44:01PM +0000, Ethan Kosakovsky wrote:
> I would like to present a proposal for discussion and peer review. It aims to solve the problem of "too many seeds and too many backups" due to the many reasons stipulated in the proposal text.
> 
> https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki
> 
> <pre>
>   BIP:
>   Title: Deterministic Entropy From BIP32 Keychains
>   Author: Ethan Kosakovsky <ethankosakovsky at protonmail.com>
>   Comments-Summary: No comments yet.
>   Comments-URI:
>   Status: Proposed
>   Type: Standards Track
>   Created: 2020-03-20
>   License: BSD-2-Clause
>            OPL
> </pre>
> 
> ==Abstract==
> 
> This proposal provides a way to derive entropy from a HD keychain path in order to deterministically derive the initial entropy used to create keychain mnemonics and seeds.
> 
...
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 529 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200320/4e6f725f/attachment.sig>

From ChristopherA at lifewithalacrity.com  Sat Mar 21 01:46:19 2020
From: ChristopherA at lifewithalacrity.com (Christopher Allen)
Date: Fri, 20 Mar 2020 18:46:19 -0700
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <20200320200253.GC13916@coinkite.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
 <20200320200253.GC13916@coinkite.com>
Message-ID: <CACrqygBm+mprR3Efo2pdMhprHJ3xQCBeKuZBF15QmDpcg93-5Q@mail.gmail.com>

I agree with the problem statement in this proposal, but not the proposed
solution.

The challenge of safely securing a seed for a single signature is not
insignificant. Blockchain Commons has published procedures that we consider
the current best practices for cold storage in a free book at
http://bit.ly/SmartCustodyBookV101 and in github at
https://github.com/BlockchainCommons/smartcustodybook. It currently
requires a couple of hours and $200 or more of materials (home safe, 2
ledgers, titanium blanks, etc.) to safely product (significantly less time
and money than Glacier Protocol).

Presumably, people are not going to go to this level of protection for too
many keys, thus there needs to be methods to leverage the root seeds that
are properly protected.

Currently Blockchain Commons is working on standards for airgap solutions
for storing and signing from offline keys. Scenarios include using Shamir
and SLIP-39  on an offline device with no-WiFi or Bluetooth, an air-gapped
mobile phone in airplane mode, or another dedicated device (for instance
the SafeKey device if open source was an option). You would use this device
to create and restore seeds, convert seeds from BIP-39 to SLIP-39, derive
HD keys, and then use QR code from the device to transfer the generated
child keys for use by different apps. In some cases, this offline device
could also read QR transactions and sign them. We have working prototypes
of this today.

This technique works fine for online Bitcoin apps that accept child keys in
the form of xprv (or equivalents) such as those our FullyNoded2 iOS wallet
supports, but the problem for other wallets is that you can't go from an
xprv back to a seed ? the xprv creation is a one-way hmac-sha512 operation
(still not convinced this was a good decision).

What I think Ethan is proposing is the ability to turn any child derived
xprv key into a new set valid seed words that could be used by a wallet or
other devices that don't understand xprv and will only allow import of new
seeds words. This gets even more complicated if the seed words are not the
standard BIP-39 set (which BTW, are not an ideal set of words, the
selection of the SLIP-39 words is much better).

Though possibly pragmatic, this approach would be a hack ? starting with
some raw entropy, convert this to an entropy seed, then to words, then hmac
to xprv, then derive child keys, then convert that child key to a new
entropy seed, then hmac to xprv, and then derive child keys again, etc.

I'd really prefer to start with finding standards ways to protect the
entropy seed (not specifically the bip39 words derived from that but also
as derived roots for WebAuthN/FIDO, GPG, Signal/Session, etc.) that can be
then be used to create other hierarchies of keys using airgap solutions.

For instance, here is what FullyNoded 2 currently uses to restore a Bitcoin
wallet including root seed:

{
  "birthdate": 1584725088,
  "label": "Testnet Single Signature",
  "entropy": "b3b17e8f425bf7b96d68b67867cdc816",
  "walletName": "DEFAULT_EBaiuGgZQS_StandUp",
  "descriptor":
"wpkh([6955c2cb/84'/1'/0']tprv8giCxdrRRrKfQkXTJ4q2PNZBsPL7HiTXXteajiG8wqAGpLVsHJfN1EwwKM8F8x1Cuk8p6vh1KrKBCuZtZdDtL6Sc2CB1ou8sYiGSf6hcujv/0/*)",
  "blockheight": 1
}

Alternatively, FullyNoded 2 can also restore a wallets without the full
seed, so for instance, if this QR restore was missing the entropy field,
only derived child xprv from the descriptor could be used, so no other
accounts could be created but new addresses as children of the xprv could
be created.

The advantage of of an entropy seed storage centered technique is that I
can convert that entropy seed into either BIP39 words, or any number of
SLIP-39 shards, or Lightning words, and back. We are also looking at using
this with the VSS that underlies Schnorr Musig. We can talk other secure
tool makers on how to use this raw entropy for other purposes to create
chains or hierarchies of keys for their unique needs.

Blockchain Common's doesn't have a full architecture for this yet as we are
working on our POC and are seeking suggestions from other wallet vendors
(in particular lightning and non-bitcoin secure services) on requirements.
Let me know if you'd like to participate in the discussions (currently
either Github issues or a Signal group for the group)

? Christopher Allen
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200320/c56bcc9e/attachment.html>

From crypto at timruffing.de  Sat Mar 21 13:34:14 2020
From: crypto at timruffing.de (Tim Ruffing)
Date: Sat, 21 Mar 2020 14:34:14 +0100
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
Message-ID: <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>

Hi Pieter, 

That's a really nice overview.

Let's take a step back first. If we believe that malicious hardware
wallets are big enough of a concern, then signing is only part of the
problem. The other issue is key generation. The PRG from which the seed
is derived can be malicious, e.g., just H(k_OO,counter) for a key k_OO
chosen by the hardware manufacturer. I haven't seen an argument why
attacks during the signing model should more realistic than attacks
during key generation, so I'd be very hesitant to deploy anti-covert
channel singing protocols without deploying protocols for key
generation that are secure in the same attacker model.

While there's a bunch of protocols for signing, there's not much
research for key generation. One simple idea is a simple commit-and-
reveal protocol to generate a master (elliptic curve) public key pair
with entropy contributions from both HW and SW (similar to the
protocols here for generating R). Then use BIP32 public derivation for
all other keys in order to make sure that SW can verify the derivation
of the public kyes. The corresponding master secret key would replace
the seed, i.e., there's no "symmetric" seed. That idea comes with other
drawbacks however, most importantly this is not compatible with
hardened derivation, which creates a new security risk. If we want
(something like) hardened derivation, zero-knowledge proofs of correct
derivation could maybe used but they again come with other issues
(efficiency, complexity). 

By the way, here's a paper that considers a similar setting where the
hardware wallet is also malicious during key generation: 
https://fc19.ifca.ai/preproceedings/93-preproceedings.pdf
This model goes a step further and assumes threshold signatures but
interestingly here the human user (instead of the SW) is the trusted
party interacting with the HW. In this model the human user has a low-
entropy password.

Now back to the signing process: I think yet another security property
to look at is security against a malicious SW with parallel signing
sessions. I think it's reasonable to restrict a single HW device to a
single session but what if the same seed is stored in two or more HW
wallets? That's plausible at least. Taking this additional security
property into account, it appears that Scheme 4 is vulnerable to
Wagner's attack because SW can influence R by choosing t after seeing
R0. (This can be fixed, e.g., by using Scheme 5 instead.) 


On Tue, 2020-03-03 at 21:35 +0000, Pieter Wuille via bitcoin-dev wrote:
> 2.d) Statefulness
> 
> We're left with Schemes 4 and 5 that protect against all listed
> issues. Both
> need two interaction rounds, with state that needs to be kept by HW
> between
> the rounds (the k0 value). While not a problem in theory, this may be
> hard to
> implement safely in simple APIs.

A generic way to make one party (HW in this case) stateless is to let
it encrypt and authenticate its state, e.g., using AEAD. In our
particular case I think that the state does not need to be
confidential, and a simple MAC suffices. For simplicity let's assume we
have another hash function H' (modeled as a random oracle) used as MAC.
We can (ab)use d as a MAC key.

If we don't want to spend an entire signature verification on the side
of HW to protect against fault attacks, we can additionally let SW
compute and send the challenge hash e=H(R,Q,m) and let HW only verify
the computation of e. This helps against fault-attacks in the
computation of R and e because now SW needs to commit to e, which is a
commitment to the exact computation fault that HW will suffer from. But
I'm not sure yet if this is weaker or stronger or incomparable to
verifying the signature. I guess it's weaker [1]. If we don't drop
signature verification, this technique does not hurt at least.  

[Scheme 7: synthetic nonce, two interactions, stateless using MAC,
verifying e]

First interaction:
 * SW generates a random t, computes h=H(t), and requests the R0 point
   that HW would use by sending (Q,m,h) to HW.
 * HW uses a global counter c (or fresh randomness c), and computes
   k0=H(d,m,c,h), R0=k0G, mac=H'(d,m,c,h) and sends R0,c,mac to SW.

Second interaction:
 * SW computes R=R0+tG, e=H(R,Q,m) and requests a signature by sending
   (Q,m,t,e,c,mac) to HW
 * HW verifies mac=H'(d,m,c,H(t)), recomputes k0=H(d,m,c,H(t)), k=k0+t,
   computes R=kG, verifies e=H(R,Q,m), and if all is good computes
   s=k+H(R,Q,m)d and sends s to SW.
 * SW verifies that sG=R+eQ and publishes (R,s) if all is good.

One last observation: Since the inputs to H and H' are the same, we
could even use H'(x)=H(H(x)). Not sure if that's useful.

Best,
Tim

[1] In the (admittedly weird) case that faults in two runs of the
executions are independent and can be made highly likely (say
probability almost 1), verifying e could indeed be stronger than
verifying the signature: When verifying the signature, the fault attack
is successful if  the *same* fault happens during signing and
verification (birthday collision!). When verifying e instead, the
attack is successful if the attacker predicts the fault correctly. But
I guess if faults can be made very likely, there's no hope anyway.



From ethankosakovsky at protonmail.com  Sat Mar 21 15:10:48 2020
From: ethankosakovsky at protonmail.com (Ethan Kosakovsky)
Date: Sat, 21 Mar 2020 15:10:48 +0000
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <CACrqygBm+mprR3Efo2pdMhprHJ3xQCBeKuZBF15QmDpcg93-5Q@mail.gmail.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
 <20200320200253.GC13916@coinkite.com>
 <CACrqygBm+mprR3Efo2pdMhprHJ3xQCBeKuZBF15QmDpcg93-5Q@mail.gmail.com>
Message-ID: <g5SKiolnI0CG11Iq7Pj4IGhMkqmtpB5qXP5hpbEafVpfDbM3sdCvQuvgzlkFLOI3di6KIvwJZjeO7tB6PFpWlvZmhRxTXO3aqyuYD8Qge0s=@protonmail.com>

Chris,

Thank you for taking the time to share your thoughts. I agree there are wide considerations surrounding key handling and storage. I dont think my proposal interferes with that perspective any more than BIP32 itself would. How keys are handled is a separate matter than the cryptography of key derivation and trying to get back to the one single backup that is future proof.

My proposal is not concerned with how the initial master key/seed is generated, just that we have one. My proposal is concerned with how to avoid having to generate more master keys because of the wide adoption of standards that impose restrictions (like BIP39); or the fragmented methods of initialization various wallets; as well as the instances where sharing the BIP39 seed with multiple wallets is undesirable due to security concerns (for example hot and offline wallet); or just plain incompatible standards.

If we were to start everything from scratch, we would obviously do things differently. However, there are already millions of wallets created using existing standards. It's just not possible to reset sadly.

> What I think Ethan is proposing is the ability to turn any child derived
> xprv key into a new set valid seed words that could be used by a wallet or
> other devices that don't understand xprv and will only allow import of new
> seeds words. This gets even more complicated if the seed words are not the
> standard BIP-39 set (which BTW, are not an ideal set of words, the
> selection of the SLIP-39 words is much better).

I am proposing two separate things.

  - that we use fully hardened paths to derive keys in order to derive entropy.
  - that a BIP44 like derivation path can be used to describe what the entropy is intended for

    For example we use the prefix 83696968 (ASCII seed in decimal) `m/83696968'/type'/index'`
      - `type` defines how the entropy will be used
        `0` means use 128 bits of the entropy as input to BIP39, producing a 12 word BIP39 mnemonic
        `4` means use 256 bits of the entropy as the secret exponent to create a compressed WIF (for use as hdseed in Bitcoin Core)

    In this way, we can neatly define the specific use-cases of the entropy maintaining some order.

      - `index` is the key index so we can generate multiple instances of this type of entropy

To answer your question about whether to one-way-transform the resulting k. In practice, k is already safe because it was derived from a fully hardened path which protects the parent tree. However, the purpose here semantically is to be entropy. But k is not entropy, it's a private key on that derivation path. Neither are we exporting and xprv. We want entropy to seed the derivation of something else specified by the `type`. For that reason I consider it important to transform k by way of a hash or hmac. Using HMAC over hash is a decision based on an abundance of caution to ensure ward off unwanted side effects should k be used for a dual purpose, including as a nonce hash(k), where undesirable and unforeseen interactions could occur.

> Though possibly pragmatic, this approach would be a hack ? starting with some raw entropy, convert this to an entropy seed, then to words, then hmac to xprv, then derive child keys, then convert that child key to a new entropy seed, then hmac to xprv, and then derive child keys again, etc.

I am not proposing the nesting, although nothing would prohibit it, I'm just proposing one master root key from which all child keychains can be derived and overcome the incompatibilities and impracticalities detailed.

> Let me know if you'd like to participate in the discussions (currently either Github issues or a Signal group for the group)

Sure! What's the URL of the Github?

Ethan


??????? Original Message ???????
On Saturday, March 21, 2020 2:46 AM, Christopher Allen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I agree with the problem statement in this proposal, but not the proposed solution.
>
> The challenge of safely securing a seed for a single signature is not insignificant. Blockchain Commons has published procedures that we consider the current best practices for cold storage in a free book at?http://bit.ly/SmartCustodyBookV101 and in github at?https://github.com/BlockchainCommons/smartcustodybook. It currently requires a couple of hours and $200 or more of materials (home safe, 2 ledgers, titanium blanks, etc.) to safely product (significantly less time and money than Glacier Protocol).?
>
> Presumably, people are not going to go to this level of protection for too many keys, thus there needs to be methods to leverage the root seeds that are properly protected.
>
> Currently Blockchain Commons is working on standards for airgap solutions for storing and signing from offline keys. Scenarios include using Shamir and SLIP-39? on an offline device with no-WiFi or Bluetooth, an air-gapped mobile phone in airplane mode, or another dedicated device (for instance the SafeKey device if open source was an option). You would use this device to create and restore seeds, convert seeds from BIP-39 to SLIP-39, derive HD keys, and then use QR code from the device to transfer the generated child keys for use by different apps. In some cases, this offline device could also read QR transactions and sign them. We have working prototypes of this today.
>
> This technique works fine for online Bitcoin apps that accept child keys in the form of xprv (or equivalents) such as those our FullyNoded2 iOS wallet supports, but the problem for other wallets is that you can't go from an xprv back to a seed ? the xprv creation is a one-way hmac-sha512 operation (still not convinced this was a good decision).?
>
> What I think Ethan is proposing is the ability to turn any child derived xprv key into a new set valid seed words that could be used by a wallet or other devices that don't understand xprv and will only allow import of new seeds words. This gets even more complicated if the seed words are not the standard BIP-39 set (which BTW, are not an ideal set of words, the selection of the SLIP-39 words is much better).?
>
> Though possibly pragmatic, this approach would be a hack ? starting with some raw entropy, convert this to an entropy seed, then to words, then hmac to xprv, then derive child keys, then convert that child key to a new entropy seed, then hmac to xprv, and then derive child keys again, etc.
>
> I'd really prefer to start with finding standards ways to protect the entropy seed (not specifically the bip39 words derived from that but also as derived roots for WebAuthN/FIDO, GPG, Signal/Session, etc.) that can be then be used to create other hierarchies of keys using airgap solutions.
>
> For instance, here is what FullyNoded 2 currently uses to restore a Bitcoin wallet including root seed:
>
> {
> ? "birthdate": 1584725088,
> ? "label": "Testnet Single Signature",
> ? "entropy": "b3b17e8f425bf7b96d68b67867cdc816",
> ? "walletName": "DEFAULT_EBaiuGgZQS_StandUp",
> ? "descriptor": "wpkh([6955c2cb/84'/1'/0']tprv8giCxdrRRrKfQkXTJ4q2PNZBsPL7HiTXXteajiG8wqAGpLVsHJfN1EwwKM8F8x1Cuk8p6vh1KrKBCuZtZdDtL6Sc2CB1ou8sYiGSf6hcujv/0/*)",
> ? "blockheight": 1
> }
>
> Alternatively, FullyNoded 2 can also restore a wallets without the full seed, so for instance, if this QR restore was missing the entropy field, only derived child xprv from the descriptor could be used, so no other accounts could be created but new addresses as children of the xprv could be created.
>
> The advantage of of an entropy seed storage centered technique is that I can convert that entropy seed into either BIP39 words, or any number of SLIP-39 shards, or Lightning words, and back. We are also looking at using this with the VSS that underlies Schnorr Musig. We can talk other secure tool makers on how to use this raw entropy for other purposes to create chains or hierarchies of keys for their unique needs.
>
> Blockchain Common's doesn't have a full architecture for this yet as we are working on our POC and are seeking suggestions from other wallet vendors (in particular lightning and non-bitcoin secure services) on requirements. Let me know if you'd like to participate in the discussions (currently either Github issues or a Signal group for the group)
>
> ? Christopher Allen

From roconnor at blockstream.com  Sat Mar 21 16:59:47 2020
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sat, 21 Mar 2020 12:59:47 -0400
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
Message-ID: <CAMZUoKk6uFAfZkUQUbDY_Kw=3bc5LUb2ihDUT9Wqh0zrO64Erw@mail.gmail.com>

On Sat, Mar 21, 2020 at 12:46 PM Tim Ruffing via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Pieter,
>
> Let's take a step back first. If we believe that malicious hardware
> wallets are big enough of a concern, then signing is only part of the
> problem. The other issue is key generation. The PRG from which the seed
> is derived can be malicious, e.g., just H(k_OO,counter) for a key k_OO
> chosen by the hardware manufacturer. I haven't seen an argument why
> attacks during the signing model should more realistic than attacks
> during key generation, so I'd be very hesitant to deploy anti-covert
> channel singing protocols without deploying protocols for key
> generation that are secure in the same attacker model.
>

Public keys are deterministic and can be spot checked.  In fact, AFAIU if
hardened HD key derivations are not used, then spot checking is very easy.

While spot checking isn't ideal, my original concern with the synthetic
none standard proposal was that it is inherently non-deterministic and
cannot ever be spot checked.  This is why anti-covert signing protocols are
so important if we are going to use synthetic nonces.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200321/33b4ef58/attachment.html>

From dscotese at litmocracy.com  Sat Mar 21 18:40:24 2020
From: dscotese at litmocracy.com (Dave Scotese)
Date: Sat, 21 Mar 2020 11:40:24 -0700
Subject: [bitcoin-dev] Block solving slowdown question/poll
Message-ID: <CAGLBAhcS5oxGvrcG7QdO7Ya6X2n1=H_nzx5Eh=69rcje6SQpgA@mail.gmail.com>

It seems that many on this list think deeply enough to imagine the scenario
where we have  few days left before a difficulty adjustment comes up but we
also see mining power dropping off at a rate that suggests the few days
might become a few weeks, and then, possibly, a few months or even the
unthinkable, a few eons.  I'm curious to know if anyone has ideas on how
this might be handled because I'm sure we're not going to let it happen.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200321/ba94cdf9/attachment-0001.html>

From mbencun at gmail.com  Sat Mar 21 20:29:26 2020
From: mbencun at gmail.com (Marko Bencun)
Date: Sat, 21 Mar 2020 21:29:26 +0100
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
Message-ID: <CAOkeP8tn42PQvnSy_5BZ4H54F9myBODqsYFrGHDs=sncyohYfA@mail.gmail.com>

Practically speaking, most hardware wallets allow you to import your own
BIP39 seed, so you can work around key generation attacks today, with a one
time inconvenience at the start. However, with the signing nonce attacks, a
user today has no protection.

Mitigating key generation attacks would be very desirable, but I see it as
independent of anti nonce covert channel protection.

On Sat, Mar 21, 2020 at 5:46 PM Tim Ruffing via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Pieter,
>
> That's a really nice overview.
>
> Let's take a step back first. If we believe that malicious hardware
> wallets are big enough of a concern, then signing is only part of the
> problem. The other issue is key generation. The PRG from which the seed
> is derived can be malicious, e.g., just H(k_OO,counter) for a key k_OO
> chosen by the hardware manufacturer. I haven't seen an argument why
> attacks during the signing model should more realistic than attacks
> during key generation, so I'd be very hesitant to deploy anti-covert
> channel singing protocols without deploying protocols for key
> generation that are secure in the same attacker model.
>
> While there's a bunch of protocols for signing, there's not much
> research for key generation. One simple idea is a simple commit-and-
> reveal protocol to generate a master (elliptic curve) public key pair
> with entropy contributions from both HW and SW (similar to the
> protocols here for generating R). Then use BIP32 public derivation for
> all other keys in order to make sure that SW can verify the derivation
> of the public kyes. The corresponding master secret key would replace
> the seed, i.e., there's no "symmetric" seed. That idea comes with other
> drawbacks however, most importantly this is not compatible with
> hardened derivation, which creates a new security risk. If we want
> (something like) hardened derivation, zero-knowledge proofs of correct
> derivation could maybe used but they again come with other issues
> (efficiency, complexity).
>
> By the way, here's a paper that considers a similar setting where the
> hardware wallet is also malicious during key generation:
> https://fc19.ifca.ai/preproceedings/93-preproceedings.pdf
> This model goes a step further and assumes threshold signatures but
> interestingly here the human user (instead of the SW) is the trusted
> party interacting with the HW. In this model the human user has a low-
> entropy password.
>
> Now back to the signing process: I think yet another security property
> to look at is security against a malicious SW with parallel signing
> sessions. I think it's reasonable to restrict a single HW device to a
> single session but what if the same seed is stored in two or more HW
> wallets? That's plausible at least. Taking this additional security
> property into account, it appears that Scheme 4 is vulnerable to
> Wagner's attack because SW can influence R by choosing t after seeing
> R0. (This can be fixed, e.g., by using Scheme 5 instead.)
>
>
> On Tue, 2020-03-03 at 21:35 +0000, Pieter Wuille via bitcoin-dev wrote:
> > 2.d) Statefulness
> >
> > We're left with Schemes 4 and 5 that protect against all listed
> > issues. Both
> > need two interaction rounds, with state that needs to be kept by HW
> > between
> > the rounds (the k0 value). While not a problem in theory, this may be
> > hard to
> > implement safely in simple APIs.
>
> A generic way to make one party (HW in this case) stateless is to let
> it encrypt and authenticate its state, e.g., using AEAD. In our
> particular case I think that the state does not need to be
> confidential, and a simple MAC suffices. For simplicity let's assume we
> have another hash function H' (modeled as a random oracle) used as MAC.
> We can (ab)use d as a MAC key.
>
> If we don't want to spend an entire signature verification on the side
> of HW to protect against fault attacks, we can additionally let SW
> compute and send the challenge hash e=H(R,Q,m) and let HW only verify
> the computation of e. This helps against fault-attacks in the
> computation of R and e because now SW needs to commit to e, which is a
> commitment to the exact computation fault that HW will suffer from. But
> I'm not sure yet if this is weaker or stronger or incomparable to
> verifying the signature. I guess it's weaker [1]. If we don't drop
> signature verification, this technique does not hurt at least.
>
> [Scheme 7: synthetic nonce, two interactions, stateless using MAC,
> verifying e]
>
> First interaction:
>  * SW generates a random t, computes h=H(t), and requests the R0 point
>    that HW would use by sending (Q,m,h) to HW.
>  * HW uses a global counter c (or fresh randomness c), and computes
>    k0=H(d,m,c,h), R0=k0G, mac=H'(d,m,c,h) and sends R0,c,mac to SW.
>
> Second interaction:
>  * SW computes R=R0+tG, e=H(R,Q,m) and requests a signature by sending
>    (Q,m,t,e,c,mac) to HW
>  * HW verifies mac=H'(d,m,c,H(t)), recomputes k0=H(d,m,c,H(t)), k=k0+t,
>    computes R=kG, verifies e=H(R,Q,m), and if all is good computes
>    s=k+H(R,Q,m)d and sends s to SW.
>  * SW verifies that sG=R+eQ and publishes (R,s) if all is good.
>
> One last observation: Since the inputs to H and H' are the same, we
> could even use H'(x)=H(H(x)). Not sure if that's useful.
>
> Best,
> Tim
>
> [1] In the (admittedly weird) case that faults in two runs of the
> executions are independent and can be made highly likely (say
> probability almost 1), verifying e could indeed be stronger than
> verifying the signature: When verifying the signature, the fault attack
> is successful if  the *same* fault happens during signing and
> verification (birthday collision!). When verifying e instead, the
> attack is successful if the attacker predicts the fault correctly. But
> I guess if faults can be made very likely, there's no hope anyway.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200321/da2e74e6/attachment.html>

From lloyd.fourn at gmail.com  Sun Mar 22 05:51:59 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Sun, 22 Mar 2020 16:51:59 +1100
Subject: [bitcoin-dev] BIP 340 updates: even pubkeys,
	more secure nonce generation
In-Reply-To: <CAPg+sBgxvRM5ncQAnbNLN=4bdkQrM+-DxibMoTG+6gqk7EY9hQ@mail.gmail.com>
References: <CAPg+sBgxvRM5ncQAnbNLN=4bdkQrM+-DxibMoTG+6gqk7EY9hQ@mail.gmail.com>
Message-ID: <CAH5Bsr2A7BepO9qYdL=Vzeajm1ZpoyH7-6AjLjcNDA8k5Qq0fA@mail.gmail.com>

* To protect against differential power analysis, a different way of
> mixing in this randomness is used (masking the private key completely
> with randomness before continuing, rather than hashing them together,
> which is known in the literature to be vulnerable to DPA in some
> scenarios).
>

I think citation for this would improve the spec.

I haven't studied these attacks but it seems to me that every hardware
wallet would be vulnerable to them while doing key derivation. If the
attacker can get side channel information from hashes in nonce derivation
then they can surely get side channel information from hashes in HD key
derivation. It should actually be easier since the master seed is hashed
for anything the hardware device needs to do including signing.

is this the case?

LL
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/2f7cb908/attachment.html>

From dave at dtrt.org  Sun Mar 22 07:54:15 2020
From: dave at dtrt.org (David A. Harding)
Date: Sun, 22 Mar 2020 03:54:15 -0400
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <CAGLBAhcS5oxGvrcG7QdO7Ya6X2n1=H_nzx5Eh=69rcje6SQpgA@mail.gmail.com>
References: <CAGLBAhcS5oxGvrcG7QdO7Ya6X2n1=H_nzx5Eh=69rcje6SQpgA@mail.gmail.com>
Message-ID: <20200322075415.3xttkgldluzqyv4g@ganymede>

On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev wrote:
> [Imagine] we also see mining power dropping off at a rate that
> suggests the few days [until retarget] might become a few weeks, and
> then, possibly, a few months or even the unthinkable, a few eons.  I'm
> curious to know if anyone has ideas on how this might be handled

There are only two practical solutions I'm aware of:

1. Do nothing
2. Hard fork a difficulty reduction

If bitcoins retain even a small fraction of their value compared to the
previous retarget period and if most mining equipment is still available
for operation, then doing nothing is probably the best choice---as block
space becomes scarcer, transaction feerates will increase and miners
will be incentivized to increase their block production rate.

If the bitcoin price has plummeted more than, say, 99% in two weeks
with no hope of short-term recovery or if a large fraction of mining
equipment has become unusable (again, say, 99% in two weeks with no
hope of short-term recovery), then it's probably worth Bitcoin users
discussing a hard fork to reduce difficulty to a currently sustainable
level.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/12e12a70/attachment.sig>

From crypto at timruffing.de  Sun Mar 22 09:43:12 2020
From: crypto at timruffing.de (Tim Ruffing)
Date: Sun, 22 Mar 2020 10:43:12 +0100
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <CAMZUoKk6uFAfZkUQUbDY_Kw=3bc5LUb2ihDUT9Wqh0zrO64Erw@mail.gmail.com>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
 <CAMZUoKk6uFAfZkUQUbDY_Kw=3bc5LUb2ihDUT9Wqh0zrO64Erw@mail.gmail.com>
Message-ID: <c14db3d600c0c60bbf06ea832fc438a5c9fd97da.camel@timruffing.de>

On Sat, 2020-03-21 at 12:59 -0400, Russell O'Connor wrote:
> Public keys are deterministic and can be spot checked.  In fact,
> AFAIU if hardened HD key derivations are not used, then spot checking
> is very easy.
> 
> While spot checking isn't ideal, my original concern with the
> synthetic none standard proposal was that it is inherently non-
> deterministic and cannot ever be spot checked.  This is why anti-
> covert signing protocols are so important if we are going to use
> synthetic nonces.

If spot checking means checking a few instances, then I think this is a
pretty weak defense. What if the device starts to behave differently
after a year?

On Sat, 2020-03-21 at 21:29 +0100, Marko Bencun wrote:
> Practically speaking, most hardware wallets allow you to import your
> own BIP39 seed, so you can work around key generation attacks today,
> with a one time inconvenience at the start. However, with the signing
> nonce attacks, a user today has no protection.
> 

How do you know that the device really uses your seed? This can only be
done by comparing the public keys output by the HW with a second
computation. Even if you use only non-hardened derivation, you need to
check the master (root) public key and that means you need compute the
master root public key once from the seed. You can't do this manually
on a sheet of paper after you rolled a few dice to generate your seed.
So you need to store the seed on a second device (if only for a short
time). And I think this defeats the purpose of a HW wallet.

And even if assume that spot checking and importing the seed works, the
problem is not solved. We still need a clearly specified full protocol
that we can analyze. 

Best,
Tim


From ethankosakovsky at protonmail.com  Sun Mar 22 11:58:53 2020
From: ethankosakovsky at protonmail.com (Ethan Kosakovsky)
Date: Sun, 22 Mar 2020 11:58:53 +0000
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
Message-ID: <S90SB9DcluBjzhnWrbT1Urh61XgVcn6ynEU7EGsfR-UhGGMxPOXMuJdwM0BPtdAcIaL22B4zR0Pooe4Yaoi0zBPFnnwQ4WSSpL7FoW4OOBA=@protonmail.com>

I have completely revised the wording of this proposal I hope to be clearer in explaining the motivation and methodology.

https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6

Ethan

??????? Original Message ???????
On Friday, March 20, 2020 4:44 PM, Ethan Kosakovsky via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I would like to present a proposal for discussion and peer review. It aims to solve the problem of "too many seeds and too many backups" due to the many reasons stipulated in the proposal text.
>
> https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki
>
> <pre>
> BIP:
> Title: Deterministic Entropy From BIP32 Keychains
> Author: Ethan Kosakovsky ethankosakovsky at protonmail.com
> Comments-Summary: No comments yet.
> Comments-URI:
> Status: Proposed
> Type: Standards Track
> Created: 2020-03-20
> License: BSD-2-Clause
> OPL
> </pre>
>
> ==Abstract==
>
> This proposal provides a way to derive entropy from a HD keychain path in order to deterministically derive the initial entropy used to create keychain mnemonics and seeds.
>
> ==Motivation==
>
> BIP32 uses some initial entropy as a seed to deterministically derive a BIP32 root for hierarchical deterministic keychains. BIP39 introduced a method of encoding initial entropy into a mnemonic phrase which is used as input to a one way hash function in order to deterministically derive a BIP32 seed. The motivation behind mnemonic phrases was to make it easier for humans to backup and store offline. There are also other variations of this theme.
>
> The initial motivation of BIP32 was to make handling of large numbers of private keys easier to manage and backup, since you only need one BIP32 seed to cover all possible keys in the keychain. In practice however, due to various wallet implementations and security models, the average user may be faced with the need to handle an ever growing number of seeds/mnemonics. This is due to incompatible wallet standards, hardware wallets (HWW), seed formats and standards, as well as, the need to used a mix of hot and cold wallets depending on the application and environment.
>
> Examples would span wallets on mobile phones, online servers running protocols like Join Market or Lightning, and the difference between Electrum and BIP39 mnemonic seed formats. The reference implementation of Bitcoin Core uses BIP32, while other cryptocurrencies like Monero use different mnemonic encoding schemes.
>
> We must also consider the different variety of physical backups including paper, metal and other physical storage devices, as well as the potentially splitting backups across different geographical locations. This complexity may result in less care being taken with subsequently generated seeds for new wallets need to be stored and it ultimately results in less security. In reality, the idea of having "one seed for all" has proven to be more difficult in practice than originally thought.
>
> Since all these derivation schemes are deterministic based on some initial entropy, this proposal aims to solve the above problems by detailing a way to deterministically derive the initial entropy used for new root keychains using a single BIP32 style "master root key". This will allow one root key or mnemonic to derive any variety of different root keychains in whatever format is required (like BIP32 and BIP39 etc).
>
> ==Specification==
>
> Input starts with a BIP32 seed. Derivation scheme uses the format `m/83696968'/type'/index'` where `type` is the final seed type, and `index` in the key index of the hardened child private key.
>
> type
>
> bits
>
> output
>
> 0
>
> 128
>
> 12 word BIP39 mnemonic
>
> 1
>
> 256
>
> 24 word BIP39 mnemonic
>
> 2
>
> 128
>
> 12 word Electrum mnemonic
>
> 3
>
> 256
>
> 24 word Electrum mnemonic
>
> 4
>
> 256
>
> WIF for Bitcoin Core
>
> 5
>
> 256
>
> 25 word Monero mnemonic
>
> Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-from-bip32') of the derived 32 byte private key (k). Entropy is taken from the result according to the number of bits required. This entropy can then be used as input to derive a mnemonic, wallet etc according to the`type` specified.
>
> ==Compatibility==
>
> In order to maintain the widest compatibility, the input to this function is a BIP32 seed, which may or may not have been derived from a BIP39 like mnemonic scheme. This maintains the original motivation that one backup can store any and all child derivation schemes depending on the user's preference or hardware signing devices. For example, devices that store the HD seed as a BIP39 mnemonic, Electrum seed, or BIP32 root key would all be able to implement this standard.
>
> ==Discussion==
>
> This proposal could be split into multiple discrete BIPs in the same way that BIP32 described the derivation mechanics, BIP39 the input encoding with mnemonics, and the derivation paths like BIP44, BIP49 and BIP84. This has been avoided to reduce complexity. The resulting private key processed with HMAC-SHA512 and truncated as necessary. HMAC-SHA512 was chosen because it may have better compatibility in embedded devices as it's already required in devices supporting BIP32.
>
> ==Test Vectors==
>
> ===Test case 1===
>
> MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance
> MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> PATH: m/83696968'/0'/0'
> BITS REQUIRED: 128
>
> DERIVED CHILD WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3
> DERIVED CHILD k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23
> CHILD ENTROPY=6458698fae3578b48a64124ea3514e12
> CONVERT ENTROPY TO WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9
> CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil liquid exchange box fatal caught
> CHILD BIP39 SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d238cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153
> CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkGbwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb
>
> ===Test case 2===
>
> MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance
> MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> PATH: m/83696968'/1'/0'
> BITS REQUIRED: 256
>
> DERIVED CHILD WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg
> DERIVED CHILD k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192
> CHILD ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e53639670b
> CONVERT ENTROPY TO WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs
> CHILD BIP39 MNEMONIC=unable imitate test flash witness escape stadium early inner thank company betray lecture chuckle swift hurt battle illness bicycle stable fat bronze order high
> CHILD BIP39 SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bde6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803
> CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHfetVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm
>
> ===Test case 3===
>
> MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind employ giant era attitude exit final oval one finger decorate pair useless super method float toddler dance
> MASTER BIP32 ROOT KEY: xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfGJNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> PATH: m/83696968'/4'/0'
> BITS REQUIRED: 256
>
> DERIVED CHILD WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2
> DERIVED CHILD k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2
> CHILD ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d90832974
> CONVERT ENTROPY TO WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G
> CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team job mammal sing bracket reject smile limit comfort pluck extend picture race soda suit dose place obtain
> CHILD BIP39 SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d54647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418
> CHILD BIP32 ROOT KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBoynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am
>
> ==References==
>
> BIP32, BIP39
>
> ==Copyright==
>
> This BIP is dual-licensed under the Open Publication License and BSD 2-clause license.
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From willtech at live.com.au  Sun Mar 22 11:58:33 2020
From: willtech at live.com.au (LORD HIS EXCELLENCY JAMES HRMH)
Date: Sun, 22 Mar 2020 11:58:33 +0000
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <20200322075415.3xttkgldluzqyv4g@ganymede>
References: <CAGLBAhcS5oxGvrcG7QdO7Ya6X2n1=H_nzx5Eh=69rcje6SQpgA@mail.gmail.com>,
 <20200322075415.3xttkgldluzqyv4g@ganymede>
Message-ID: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

There seems to be the real possibility that miners are simply trying to optimise mining profit by limiting the average hash rate during the retargeting, saving some electricity but poorly considering the overall situation where they give opportunity to other miners probably raising the hashrate for the next period. It is far more profitable for the ecosystem considering the whole to hold a lottery for minig as has been discussed elsewhere some time ago.

Regards,
LORD HIS EXCELLENCY JAMES HRMH


________________________________
From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Sunday, 22 March 2020 6:54 PM
To: Dave Scotese <dscotese at litmocracy.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] Block solving slowdown question/poll

On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev wrote:
> [Imagine] we also see mining power dropping off at a rate that
> suggests the few days [until retarget] might become a few weeks, and
> then, possibly, a few months or even the unthinkable, a few eons.  I'm
> curious to know if anyone has ideas on how this might be handled

There are only two practical solutions I'm aware of:

1. Do nothing
2. Hard fork a difficulty reduction

If bitcoins retain even a small fraction of their value compared to the
previous retarget period and if most mining equipment is still available
for operation, then doing nothing is probably the best choice---as block
space becomes scarcer, transaction feerates will increase and miners
will be incentivized to increase their block production rate.

If the bitcoin price has plummeted more than, say, 99% in two weeks
with no hope of short-term recovery or if a large fraction of mining
equipment has become unusable (again, say, 99% in two weeks with no
hope of short-term recovery), then it's probably worth Bitcoin users
discussing a hard fork to reduce difficulty to a currently sustainable
level.

-Dave
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/f1e2fa82/attachment.html>

From roconnor at blockstream.com  Sun Mar 22 15:30:34 2020
From: roconnor at blockstream.com (Russell O'Connor)
Date: Sun, 22 Mar 2020 11:30:34 -0400
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <c14db3d600c0c60bbf06ea832fc438a5c9fd97da.camel@timruffing.de>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
 <CAMZUoKk6uFAfZkUQUbDY_Kw=3bc5LUb2ihDUT9Wqh0zrO64Erw@mail.gmail.com>
 <c14db3d600c0c60bbf06ea832fc438a5c9fd97da.camel@timruffing.de>
Message-ID: <CAMZUoKkNvdegQFzosD-_DHZuu+qiCS6dKXvW7vDTpuB+T_j7dg@mail.gmail.com>

On Sun, Mar 22, 2020 at 5:43 AM Tim Ruffing <crypto at timruffing.de> wrote:

> On Sat, 2020-03-21 at 12:59 -0400, Russell O'Connor wrote:
> > Public keys are deterministic and can be spot checked.  In fact,
> > AFAIU if hardened HD key derivations are not used, then spot checking
> > is very easy.
> >
> > While spot checking isn't ideal, my original concern with the
> > synthetic none standard proposal was that it is inherently non-
> > deterministic and cannot ever be spot checked.  This is why anti-
> > covert signing protocols are so important if we are going to use
> > synthetic nonces.
>
> If spot checking means checking a few instances, then I think this is a
> pretty weak defense. What if the device starts to behave differently
> after a year?
>

I agree, which is why there perhaps is merit in using a non-hardered
derivation path so that the software side of a hardware wallet can check
the pubkey. Though I understand there are some disadvantages to the
non-hardened paths.

However, spot checking can even be done retroactively (and thoroughly).
Again, I agree that this is less than ideal, but does let you take some
action once you notice a deviation.

Your claim is that if we don't fix the pubkey issue there is no point in
fixing the signature issue.  I disagree.  While I think both issues need to
be fully addressed, the issues around the original proposed
non-deterministic signature scheme are far more severe. The proposal would
move us from a deterministic scheme, where spot checks are possible, with
all the caveats that entails, to a non-deterministic scheme where spot
checks are impossible.  My hope is that we can standardise a scheme that
has the advantages of non-determinism without the threat of covert channels.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/53768608/attachment-0001.html>

From crypto at timruffing.de  Sun Mar 22 15:38:21 2020
From: crypto at timruffing.de (Tim Ruffing)
Date: Sun, 22 Mar 2020 16:38:21 +0100
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <CAMZUoKkNvdegQFzosD-_DHZuu+qiCS6dKXvW7vDTpuB+T_j7dg@mail.gmail.com>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <de7bd393327015a5b97ffff0d15a7c90d2d2196a.camel@timruffing.de>
 <CAMZUoKk6uFAfZkUQUbDY_Kw=3bc5LUb2ihDUT9Wqh0zrO64Erw@mail.gmail.com>
 <c14db3d600c0c60bbf06ea832fc438a5c9fd97da.camel@timruffing.de>
 <CAMZUoKkNvdegQFzosD-_DHZuu+qiCS6dKXvW7vDTpuB+T_j7dg@mail.gmail.com>
Message-ID: <bb7b0773f2a103e168ebe131fc834a045cb83b02.camel@timruffing.de>

On Sun, 2020-03-22 at 11:30 -0400, Russell O'Connor wrote:
> Your claim is that if we don't fix the pubkey issue there is no point
> in fixing the signature issue.  I disagree.  While I think both
> issues need to be fully addressed, the issues around the original
> proposed non-deterministic signature scheme are far more severe. The
> proposal would move us from a deterministic scheme, where spot checks
> are possible, with all the caveats that entails, to a non-
> deterministic scheme where spot checks are impossible.  My hope is
> that we can standardise a scheme that has the advantages of non-
> determinism without the threat of covert channels.

I think we agree that both issues should be addressed, and this is all
what matters in the end. Now that we have a proposal for Schnorr
signatures, it's indeed a good time to work on these issues.

Tim


From eric at voskuil.org  Sun Mar 22 16:54:19 2020
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 22 Mar 2020 09:54:19 -0700
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>

Mining is a lottery.

e

> On Mar 22, 2020, at 07:10, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?
> There seems to be the real possibility that miners are simply trying to optimise mining profit by limiting the average hash rate during the retargeting, saving some electricity but poorly considering the overall situation where they give opportunity to other miners probably raising the hashrate for the next period. It is far more profitable for the ecosystem considering the whole to hold a lottery for minig as has been discussed elsewhere some time ago.
> 
> Regards,
> LORD HIS EXCELLENCY JAMES HRMH
> 
> 
> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of David A. Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> Sent: Sunday, 22 March 2020 6:54 PM
> To: Dave Scotese <dscotese at litmocracy.com>; Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
> Subject: Re: [bitcoin-dev] Block solving slowdown question/poll
>  
> On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev wrote:
> > [Imagine] we also see mining power dropping off at a rate that
> > suggests the few days [until retarget] might become a few weeks, and
> > then, possibly, a few months or even the unthinkable, a few eons.  I'm
> > curious to know if anyone has ideas on how this might be handled
> 
> There are only two practical solutions I'm aware of:
> 
> 1. Do nothing
> 2. Hard fork a difficulty reduction
> 
> If bitcoins retain even a small fraction of their value compared to the
> previous retarget period and if most mining equipment is still available
> for operation, then doing nothing is probably the best choice---as block
> space becomes scarcer, transaction feerates will increase and miners
> will be incentivized to increase their block production rate.
> 
> If the bitcoin price has plummeted more than, say, 99% in two weeks
> with no hope of short-term recovery or if a large fraction of mining
> equipment has become unusable (again, say, 99% in two weeks with no
> hope of short-term recovery), then it's probably worth Bitcoin users
> discussing a hard fork to reduce difficulty to a currently sustainable
> level.
> 
> -Dave
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/25b0e225/attachment.html>

From dscotese at litmocracy.com  Sun Mar 22 18:17:26 2020
From: dscotese at litmocracy.com (Dave Scotese)
Date: Sun, 22 Mar 2020 11:17:26 -0700
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
Message-ID: <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>

The software currently allows up to a two hour difference between the
system clock and the time implied by a fresh block's timestamp (if I
remember correctly).  This reliance on realtime system clocks can be used
in a much weaker form to justify a plan for a difficulty adjustment to be
built into the software for when the expected block production rate is far
enough behind its expected value.

We would have to agree on how far behind mining should be to justify
expediting the adjustment.  The sooner we decide on and implement this
second difficulty adjustment trigger, the better.  It cuts off a nightmare
scenario made possible by collusion between states through regulation and
fiat, as well as any other external factors.  I propose that miners
detecting that the expected 2016 blocks have not been mined after twice the
expected wait time (4032 * 10 minutes = 28 days) ought to signal their
recognition in any block they produce, to be rejected by any miner whose
clock disagrees (after taking into account the 2-hour leeway), and that any
block produced on top of one with such a signal should reflect an expedited
difficulty adjustment (and also include the signal), which is then in
effect for the rest of the 2016 blocks and the entire following difficulty
period.  Every block from there until the modulo 2016 block should have the
same signal, which not only indicates that a difficulty adjustment was
expedited, but also that the next modulo 2016 block should not make one,
but rather turn off the signal.

If anyone thinks it's a good enough idea for a BIP, I will consider writing
one unless someone else wants to.

Dave.

On Sun, Mar 22, 2020 at 9:54 AM Eric Voskuil via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Mining is a lottery.
>
> e
>
> On Mar 22, 2020, at 07:10, LORD HIS EXCELLENCY JAMES HRMH via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> ?
> There seems to be the real possibility that miners are simply trying to
> optimise mining profit by limiting the average hash rate during the
> retargeting, saving some electricity but poorly considering the overall
> situation where they give opportunity to other miners probably raising the
> hashrate for the next period. It is far more profitable for the ecosystem
> considering the whole to hold a lottery for minig as has been discussed
> elsewhere some time ago.
>
> Regards,
> LORD HIS EXCELLENCY JAMES HRMH
>
>
> ------------------------------
> *From:* bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> on
> behalf of David A. Harding via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>
> *Sent:* Sunday, 22 March 2020 6:54 PM
> *To:* Dave Scotese <dscotese at litmocracy.com>; Bitcoin Protocol Discussion
> <bitcoin-dev at lists.linuxfoundation.org>
> *Subject:* Re: [bitcoin-dev] Block solving slowdown question/poll
>
> On Sat, Mar 21, 2020 at 11:40:24AM -0700, Dave Scotese via bitcoin-dev
> wrote:
> > [Imagine] we also see mining power dropping off at a rate that
> > suggests the few days [until retarget] might become a few weeks, and
> > then, possibly, a few months or even the unthinkable, a few eons.  I'm
> > curious to know if anyone has ideas on how this might be handled
>
> There are only two practical solutions I'm aware of:
>
> 1. Do nothing
> 2. Hard fork a difficulty reduction
>
> If bitcoins retain even a small fraction of their value compared to the
> previous retarget period and if most mining equipment is still available
> for operation, then doing nothing is probably the best choice---as block
> space becomes scarcer, transaction feerates will increase and miners
> will be incentivized to increase their block production rate.
>
> If the bitcoin price has plummeted more than, say, 99% in two weeks
> with no hope of short-term recovery or if a large fraction of mining
> equipment has become unusable (again, say, 99% in two weeks with no
> hope of short-term recovery), then it's probably worth Bitcoin users
> discussing a hard fork to reduce difficulty to a currently sustainable
> level.
>
> -Dave
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>


-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/dde91e34/attachment-0001.html>

From chris at suredbits.com  Sun Mar 22 22:09:00 2020
From: chris at suredbits.com (Chris Stewart)
Date: Sun, 22 Mar 2020 17:09:00 -0500
Subject: [bitcoin-dev] Bitcoin-s v0.3.0 release
Message-ID: <CAFQwNuxo4h3c7h2ODxomgOFzSyANJ-+Aepi_UyqcQMj7a1tqDw@mail.gmail.com>

Hi all

We just released v0.3.0 of bitcoin-s.

Bitcoin-s is a loosely coupled set of cryptocurrency libraries for the JVM.
They work well together, but also can be used independently. This project's
goal is NOT to be a full node implementation, rather a set of scalable
cryptocurrency libraries that use industry standard tools (rather than
esoteric tech often found in cryptocurrency) where possible to make the
lives of professional software engineers, security engineers, devops
engineers and accountants easier. We are rapidly iterating on development
with the goal of getting to a set of stable APIs that only change when the
underlying bitcoin protocol changes.

Here is an interactive code editor that allows you to play around with
basic data structures in bitcoin-s like private keys, psbts, and block
filters:

https://scastie.scala-lang.org/Christewart/IqidPZ3gTbOUbMmAf6F2MA/5

You can find more examples of how our neutrino node, wallet, bitcoind rpc
client and secp256k1jni (bindings for libsecp256k1) work on our website:

https://bitcoin-s.org/docs/next/getting-setup

You can find the release notes for v0.3.0 here:

https://github.com/bitcoin-s/bitcoin-s/releases/tag/v0.3.0

-Chris
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200322/214a9a57/attachment.html>

From dustinpaystaxes at gmail.com  Mon Mar 23 14:38:45 2020
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Mon, 23 Mar 2020 07:38:45 -0700
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
Message-ID: <CABLeJxQsse99aw35DxSDOyVTruFCgi0hmZntvgbYtPLSRGQ+xA@mail.gmail.com>

Excellent write up, thanks for putting it together.

On Tue, Mar 3, 2020 at 1:47 PM Pieter Wuille wrote:

> When both the HW and the SW are compromised, clearly no security is
> possible,
> as all entities are controlled by the same party in that case.
>
While all SW being compromised can?t be stopped, splitting the SW over two
stages can dramatically increase your security if both HW & SW are
compromised. You can do that by:

1) When you setup your storage solution (whatever it may be), export the
xpub(s) and verify the receiving addresses match xpubs with external
software before receiving.
2) Generate and export withdrawal transactions offline
3) Verify transactions against the same xpub(s) using external software
4) Upload transactions

This mitigates, I believe, all leak vectors besides k/R hacking and
prechosen entropy.

I made an external tool to just that here:
https://github.com/koinkeep/gatekeeper

Would love to add k commitments when (if?) we settle on best practices for
it.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200323/114914d9/attachment.html>

From dscotese at litmocracy.com  Mon Mar 23 18:39:05 2020
From: dscotese at litmocracy.com (Dave Scotese)
Date: Mon, 23 Mar 2020 11:39:05 -0700
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <20200323125922.GA29881@canndrew.org>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
 <20200323125922.GA29881@canndrew.org>
Message-ID: <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>

I believe this isn't something we need to address.  The fact is that every
byte stored in the blockchain is already valuable to everyone who downloads
the blockchain because of what it allows them to prove - by adding more
bytes to it.  Over time, the value per byte will increase.  Perhaps there
will be holding companies with specialized scripts that cost $500 - $1000
to add to the blockchain and allow those companies to handle transactions
for thousands of customers, kind of like a community lightning channel.

Anyway, yes, your idea is fundamentally broken because a zero block reward
happens because creating even one more satoshi will push the amount of
bitcoin over 21,000,0000, breaking the meaning of "bitcoin," or, if you
like, creating a fundamental contradiction in our use of the term.

On Mon, Mar 23, 2020 at 5:59 AM Andrew Cann <shum at canndrew.org> wrote:

> Hi, noob question here: Is there a long-term plan for if the block reward
> drops
> too low to ensure the security of the network?
>
> IIUC miners only make profit from block rewards and transaction fees, and
> once
> the block reward drop to zero we're merely hoping that transaction fees
> will
> keep mining expensive enough to stop a state actor or someone from buying
> enough hash power to attack the network. If that's the case, should we
> start
> making plans now to change the protocol to allow an adjustable block
> reward?
>
> Here's a half-baked idea I had of how that could work: Since the block
> reward
> dilutes the value of the currency bitcoin holders have an incentive to
> keep the
> reward low. However, since the block reward is also (partly) what
> incentivizes
> mining, bitcoin holders also have an incentive to keep the reward high
> enough
> to keep the network secure. So if bitcoin holders were able to vote to
> decide
> the block reward they "should", hypothetically, reliably choose a value
> that
> balances these two concerns. You could implement this voting by adding an
> optional extra field to every txout that signals what the holder thinks the
> inflation rate should be. If the field is missing you just assume the
> default
> value based on the current protocol. Then, whenever a new block is mined,
> you
> take the median inflation rate of all the pre-existing utxos, weighted by
> the
> utxo value, to calculate the block's reward.
>
> Is this idea fundamentally broken somehow? Or are there already better
> ideas
> for how to tackle this problem (I don't follow this list very closely)? Or
> is
> this actually a non-issue to start with?
>
>  - Andrew
>
>

-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200323/f83f9d48/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Mar 24 07:42:46 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 24 Mar 2020 07:42:46 +0000
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
 <20200323125922.GA29881@canndrew.org>
 <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>
Message-ID: <C_qo1AhQuklVr4owEXVgLXsvJomb9Usd1NP2zf_D_23r6Cmz9-iB7ygSfNihJp3FIfAf4c1P41fT3qQP7SFiKdCfXxpogcstHsOnpgLgbok=@protonmail.com>

Good morning Andrew,


> > Hi, noob question here: Is there a long-term plan for if the block reward drops
> > too low to ensure the security of the network?
> >
> > IIUC miners only make profit from block rewards and transaction fees, and once
> > the block reward drop to zero we're merely hoping that transaction fees will
> > keep mining expensive enough to stop a state actor or someone from buying
> > enough hash power to attack the network. If that's the case, should we start
> > making plans now to change the protocol to allow an adjustable block reward?
> >
> > Here's a half-baked idea I had of how that could work: Since the block reward
> > dilutes the value of the currency bitcoin holders have an incentive to keep the
> > reward low. However, since the block reward is also (partly) what incentivizes
> > mining, bitcoin holders also have an incentive to keep the reward high enough
> > to keep the network secure. So if bitcoin holders were able to vote to decide
> > the block reward they "should", hypothetically, reliably choose a value that
> > balances these two concerns.

They already do so, via an implicit "field", known as the transaction fee.
This is "implicit" since it is only the difference of the sum of all inputs with the sum of all outputs, but any Bitcoin HODLer spending their coins always need to make this decision.

This makes the vote for how much security is needed to be costly to the voter, which is appropriate: you pay for your security.

This mechanism is the same mechanism as well that is the long-term plan for the lowered block rewards in the future, and is already the best known idea to tackle this problem as well.


Regards,
ZmnSCPxj

From crypto at timruffing.de  Tue Mar 24 07:49:38 2020
From: crypto at timruffing.de (Tim Ruffing)
Date: Tue, 24 Mar 2020 08:49:38 +0100
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <CABLeJxQsse99aw35DxSDOyVTruFCgi0hmZntvgbYtPLSRGQ+xA@mail.gmail.com>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <CABLeJxQsse99aw35DxSDOyVTruFCgi0hmZntvgbYtPLSRGQ+xA@mail.gmail.com>
Message-ID: <c182227876c47f476000b0b54618dac73e45a03f.camel@timruffing.de>

Hi Dustin,

That sounds interesting but I can't follow your email to be honest.

On Mon, 2020-03-23 at 07:38 -0700, Dustin Dettmer via bitcoin-dev
wrote:
> This mitigates, I believe, all leak vectors besides k/R hacking and
> prechosen entropy.

Hm, so what vectors is this supposed to mitigate? Leaking through the
generated public keys? Anything else?

Here are a few questions:
 - What are you trying to achieve? You seem to describe how you get
from the setup to the goal in four steps but I don't understand what
the setup is or what the goal is. (What's a storage solution?)
 - "all SW being compromised" do you mean "SW and HW compromised"? Note
that SW and HW are parties in Pieter's writeup, not just abbreviations
for software and hardware. 
 - Where are the two stages? You mention four steps.
 - Where do you run the external software? On a second SW? Is this the
second stage?
 - Do you use unhardened derivation?
 - What's a k commitment?


Best,
Tim



From crypto at timruffing.de  Tue Mar 24 08:07:04 2020
From: crypto at timruffing.de (Tim Ruffing)
Date: Tue, 24 Mar 2020 09:07:04 +0100
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <S90SB9DcluBjzhnWrbT1Urh61XgVcn6ynEU7EGsfR-UhGGMxPOXMuJdwM0BPtdAcIaL22B4zR0Pooe4Yaoi0zBPFnnwQ4WSSpL7FoW4OOBA=@protonmail.com>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
 <S90SB9DcluBjzhnWrbT1Urh61XgVcn6ynEU7EGsfR-UhGGMxPOXMuJdwM0BPtdAcIaL22B4zR0Pooe4Yaoi0zBPFnnwQ4WSSpL7FoW4OOBA=@protonmail.com>
Message-ID: <c7b9bd243e7ae6a5a4e55f4b18d7d656c3690380.camel@timruffing.de>

I think your proposal is simply to use BIP32 for all derivations and
the observation that you can work with derived keys with the
corresponding suffixes of the path. I believe that this is a good idea.

But I don't think that simply writing a standard will help. It's just
one step. If all your wallets support incompatible formats, we should
work on fixing this because that's the root of the issue. Otherwise you
end up converting keys back and forth manually (as Chris pointed out),
and this can't be the goal. 

But then you need to reach out to wallet devs explicitly and get them
involved in creating the standard. Otherwise they won't use it. That's
a hard process, and it's even harder to make sure that the resulting
proposal isn't way too complex because everyone brings their special
case to the table. 

Tim 

On Sun, 2020-03-22 at 11:58 +0000, Ethan Kosakovsky via bitcoin-dev
wrote:
> I have completely revised the wording of this proposal I hope to be
> clearer in explaining the motivation and methodology.
> 
> https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6
> 
> Ethan
> 
> ??????? Original Message ???????
> On Friday, March 20, 2020 4:44 PM, Ethan Kosakovsky via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> > I would like to present a proposal for discussion and peer review.
> > It aims to solve the problem of "too many seeds and too many
> > backups" due to the many reasons stipulated in the proposal text.
> > 
> > https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki
> > 
> > <pre>
> > BIP:
> > Title: Deterministic Entropy From BIP32 Keychains
> > Author: Ethan Kosakovsky ethankosakovsky at protonmail.com
> > Comments-Summary: No comments yet.
> > Comments-URI:
> > Status: Proposed
> > Type: Standards Track
> > Created: 2020-03-20
> > License: BSD-2-Clause
> > OPL
> > </pre>
> > 
> > ==Abstract==
> > 
> > This proposal provides a way to derive entropy from a HD keychain
> > path in order to deterministically derive the initial entropy used
> > to create keychain mnemonics and seeds.
> > 
> > ==Motivation==
> > 
> > BIP32 uses some initial entropy as a seed to deterministically
> > derive a BIP32 root for hierarchical deterministic keychains. BIP39
> > introduced a method of encoding initial entropy into a mnemonic
> > phrase which is used as input to a one way hash function in order
> > to deterministically derive a BIP32 seed. The motivation behind
> > mnemonic phrases was to make it easier for humans to backup and
> > store offline. There are also other variations of this theme.
> > 
> > The initial motivation of BIP32 was to make handling of large
> > numbers of private keys easier to manage and backup, since you only
> > need one BIP32 seed to cover all possible keys in the keychain. In
> > practice however, due to various wallet implementations and
> > security models, the average user may be faced with the need to
> > handle an ever growing number of seeds/mnemonics. This is due to
> > incompatible wallet standards, hardware wallets (HWW), seed formats
> > and standards, as well as, the need to used a mix of hot and cold
> > wallets depending on the application and environment.
> > 
> > Examples would span wallets on mobile phones, online servers
> > running protocols like Join Market or Lightning, and the difference
> > between Electrum and BIP39 mnemonic seed formats. The reference
> > implementation of Bitcoin Core uses BIP32, while other
> > cryptocurrencies like Monero use different mnemonic encoding
> > schemes.
> > 
> > We must also consider the different variety of physical backups
> > including paper, metal and other physical storage devices, as well
> > as the potentially splitting backups across different geographical
> > locations. This complexity may result in less care being taken with
> > subsequently generated seeds for new wallets need to be stored and
> > it ultimately results in less security. In reality, the idea of
> > having "one seed for all" has proven to be more difficult in
> > practice than originally thought.
> > 
> > Since all these derivation schemes are deterministic based on some
> > initial entropy, this proposal aims to solve the above problems by
> > detailing a way to deterministically derive the initial entropy
> > used for new root keychains using a single BIP32 style "master root
> > key". This will allow one root key or mnemonic to derive any
> > variety of different root keychains in whatever format is required
> > (like BIP32 and BIP39 etc).
> > 
> > ==Specification==
> > 
> > Input starts with a BIP32 seed. Derivation scheme uses the format
> > `m/83696968'/type'/index'` where `type` is the final seed type, and
> > `index` in the key index of the hardened child private key.
> > 
> > type
> > 
> > bits
> > 
> > output
> > 
> > 0
> > 
> > 128
> > 
> > 12 word BIP39 mnemonic
> > 
> > 1
> > 
> > 256
> > 
> > 24 word BIP39 mnemonic
> > 
> > 2
> > 
> > 128
> > 
> > 12 word Electrum mnemonic
> > 
> > 3
> > 
> > 256
> > 
> > 24 word Electrum mnemonic
> > 
> > 4
> > 
> > 256
> > 
> > WIF for Bitcoin Core
> > 
> > 5
> > 
> > 256
> > 
> > 25 word Monero mnemonic
> > 
> > Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-
> > from-bip32') of the derived 32 byte private key (k). Entropy is
> > taken from the result according to the number of bits required.
> > This entropy can then be used as input to derive a mnemonic, wallet
> > etc according to the`type` specified.
> > 
> > ==Compatibility==
> > 
> > In order to maintain the widest compatibility, the input to this
> > function is a BIP32 seed, which may or may not have been derived
> > from a BIP39 like mnemonic scheme. This maintains the original
> > motivation that one backup can store any and all child derivation
> > schemes depending on the user's preference or hardware signing
> > devices. For example, devices that store the HD seed as a BIP39
> > mnemonic, Electrum seed, or BIP32 root key would all be able to
> > implement this standard.
> > 
> > ==Discussion==
> > 
> > This proposal could be split into multiple discrete BIPs in the
> > same way that BIP32 described the derivation mechanics, BIP39 the
> > input encoding with mnemonics, and the derivation paths like BIP44,
> > BIP49 and BIP84. This has been avoided to reduce complexity. The
> > resulting private key processed with HMAC-SHA512 and truncated as
> > necessary. HMAC-SHA512 was chosen because it may have better
> > compatibility in embedded devices as it's already required in
> > devices supporting BIP32.
> > 
> > ==Test Vectors==
> > 
> > ===Test case 1===
> > 
> > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind
> > employ giant era attitude exit final oval one finger decorate pair
> > useless super method float toddler dance
> > MASTER BIP32 ROOT KEY:
> > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG
> > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> > PATH: m/83696968'/0'/0'
> > BITS REQUIRED: 128
> > 
> > DERIVED CHILD
> > WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3
> > DERIVED CHILD
> > k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23
> > CHILD ENTROPY=6458698fae3578b48a64124ea3514e12
> > CONVERT ENTROPY TO
> > WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9
> > CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil
> > liquid exchange box fatal caught
> > CHILD BIP39
> > SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d23
> > 8cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153
> > CHILD BIP32 ROOT
> > KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkG
> > bwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb
> > 
> > ===Test case 2===
> > 
> > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind
> > employ giant era attitude exit final oval one finger decorate pair
> > useless super method float toddler dance
> > MASTER BIP32 ROOT KEY:
> > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG
> > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> > PATH: m/83696968'/1'/0'
> > BITS REQUIRED: 256
> > 
> > DERIVED CHILD
> > WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg
> > DERIVED CHILD
> > k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192
> > CHILD
> > ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e5363
> > 9670b
> > CONVERT ENTROPY TO
> > WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs
> > CHILD BIP39 MNEMONIC=unable imitate test flash witness escape
> > stadium early inner thank company betray lecture chuckle swift hurt
> > battle illness bicycle stable fat bronze order high
> > CHILD BIP39
> > SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bd
> > e6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803
> > CHILD BIP32 ROOT
> > KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHf
> > etVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm
> > 
> > ===Test case 3===
> > 
> > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind
> > employ giant era attitude exit final oval one finger decorate pair
> > useless super method float toddler dance
> > MASTER BIP32 ROOT KEY:
> > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG
> > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> > PATH: m/83696968'/4'/0'
> > BITS REQUIRED: 256
> > 
> > DERIVED CHILD
> > WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2
> > DERIVED CHILD
> > k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2
> > CHILD
> > ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d908
> > 32974
> > CONVERT ENTROPY TO
> > WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G
> > CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team
> > job mammal sing bracket reject smile limit comfort pluck extend
> > picture race soda suit dose place obtain
> > CHILD BIP39
> > SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d5
> > 4647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418
> > CHILD BIP32 ROOT
> > KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBo
> > ynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am
> > 
> > ==References==
> > 
> > BIP32, BIP39
> > 
> > ==Copyright==
> > 
> > This BIP is dual-licensed under the Open Publication License and
> > BSD 2-clause license.
> > 
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From lloyd.fourn at gmail.com  Tue Mar 24 13:00:45 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Wed, 25 Mar 2020 00:00:45 +1100
Subject: [bitcoin-dev] Mitigating Differential Power Analysis in BIP-340
Message-ID: <CAH5Bsr3EtFpecXPG07so1KA0sre9Cy-XPv=BADBgUe4M7kuxFg@mail.gmail.com>

Hi List,

I felt this topic deserved it's own thread but it follows on from the
mailing list post [2] announcing a new PR [1] to change BIP-340 in several
ways, including adding random auxiliary data into the nonce
derivation function. Rather than hashing the randomness with the secret key
and message etc, the randomness is hashed then XOR'd (^) with the secret
key and the result is hashed like so to determine the secret nonce k:

(1) k = H_derive( sec_key ^ H_aux(rand) || pub_key_x || message)

The claim made in the mailing list post is that this is more secure against
"differential power analysis" (DPA) attacks than just doing the simpler and
more efficient:

(2) k = H_derive(sec_key || rand || pub_key_x || message)

The TL;DR here is that I don't think this is the case.

There was no citation for this claim, so I did some digging and found two
papers that seemed like they might be the origin of the idea [3,4] (I had
no idea about these attacks before). A relatively easy to understand
explanation of DPA attacks against is in [3]:

The fundamental principle behind all DPA attacks is that at some point in
> an algorithm?s execution, a function f exists that combines a fixed secret
> value with a variable which an attacker knows. An attacker can form
> hypotheses about the fixed secret value, and compute the corresponding
> output values of f by using an appropriate leakage model, such as the
> Hamming Distance model. The attacker can then use the acquired power
> consumption traces to verify her hypotheses, by partitioning the
> acquisitions or using Pearson?s correlation coefficient. These side-channel
> analysis attacks are aided by knowledge of details of the implementation
> under attack. Moreover, these attacks can be used to validate hypotheses
> about implementation details. In subsequent sections, these side-channel
> analysis attacks are referred to as DPA attacks.


For example, in the original BIP-340 proposal the nonce derivation was
vulnerable to DPA attacks as it was derived simply by doing
H_derive(sec_key || message). Since, the message is known to the attacker
and variable (even if it is not controller by her), the SHA256 compression
function run on (sec_key || message) may leak information about sec_key. It
is crucial to understand that just hashing sec_key before passing it into
the H_derive does *not* fix the problem. Although the attacker would be
unable to find sec_key directly, they could learn H(sec_key) and with that
know all the inputs into H_derive and therefore get the value of the secret
nonce k and from there extract the secret key from any signature made with
this nonce derivation algorithm.

The key thing I want to argue with this post is that there is no advantage
of (1) over (2) against DPA attacks, at least not given my understanding of
these papers. The way the attack in [3] works is by assuming that
operations in the compression function leak the "hamming distance" [5] (HD)
between the static secret thing that is being combined with the variable
public thing. In practice the attack involves many particulars about SHA256
but that is, at a high level, the right way to simplify it I think. The way
the paper suggests to fix the problem is to mask the secret data with
secret randomness before each sensitive operation and then strip off the
secret randomness afterwards. This seems to be the inspiration for the
structure of updated BIP-340 (1), however I don't believe that it provides
any extra protection over (2). My argument is as follows:

Claim A: If the randomness used during signing is kept secret from the
attacker then (2) is secure against DPA.

Since SHA256 has 64-byte blocks the hash H_derive(sec_key || rand ||
pub_key_x || message) will be split up into two 64 byte blocks, one
containing secret data (sec_key || rand) and the other containing data
known to the attacker (pub_key_x || message). The compression function will
run on (sec_key || rand) but DPA will be useless here because the
HD(sec_key, rand) will contain no information about sec_key since rand is
also secret. The output of the compression function on the first block will
be secret but *variable* so the intermediate hash state will not reveal
useful information when compressed with the second block.

Then I thought perhaps (1) is more robust in the case where the randomness
is known by the attacker (maybe the attacker can physically modify the
chipset to control the rng). We'd have to assume that the sec_key ^
H_aux(rand) isn't vulnerable to DPA (the LHS is under the control of the
attacker) to be true. Even under this assumption it turned out not to be
the case:

Claim B: If the randomness used during signing is known to the attacker,
then (1) is not secure against DPA.

In (1)  there are 96 bytes to be hashed and therefore two SHA256 blocks:
(H_aux(sec_key) ^ rand || pub_key_x) and (message). During the first
compression function call the attacker gets the HD of:
HD( sec_key ^ H_aux(rand),  pub_key_x)
which is equal to the following as applying the same XOR to both sides does
not change the HD.
HD(sec_key, H_aux(rand) ^ pub_key_x)
Since the LHS is secret and static, and the RHS is variable and known to
the adversary we have a successful DPA attack -- the attacker will learn
sec_key after enough runs.

Maybe it's just a general rule if you can't produce randomness hidden to
the attacker then no defence is possible against DPA but I wanted to check
this anyway.

My conclusion from this is that (2) is preferable to (1) because it is
simpler and more efficient (it has one less SHA256 compression run) and no
less secure against DPA (in this model). This is not really my area so
perhaps there is a justification for (1) over (2) that I don't understand
yet. If so, someone needs to write it down! If not then I think changing
the proposal to (2) is preferable.

Cheers,

LL


[1] https://github.com/bitcoin/bips/pull/893
[2]
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017639.html
[3] http://www.oocities.org/mike.tunstall/papers/MTMM07.pdf
[4] https://www.cryptoexperts.com/sbelaid/articleHMAC.pdf
[5] https://en.wikipedia.org/wiki/Hamming_distance
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200325/e3675bf9/attachment.html>

From dustinpaystaxes at gmail.com  Tue Mar 24 14:51:32 2020
From: dustinpaystaxes at gmail.com (Dustin Dettmer)
Date: Tue, 24 Mar 2020 07:51:32 -0700
Subject: [bitcoin-dev] Overview of anti-covert-channel signing techniques
In-Reply-To: <c182227876c47f476000b0b54618dac73e45a03f.camel@timruffing.de>
References: <VZTbLR9RlkkyNg6mOOIxedh7H0g8NGlaCmgBfCVXZ4RNfW3axefgoTqZGXjAQZFEuekujVGjRMv8SifDIodZ6tRGaaXQ_R63rFa03SGS6rg=@wuille.net>
 <CABLeJxQsse99aw35DxSDOyVTruFCgi0hmZntvgbYtPLSRGQ+xA@mail.gmail.com>
 <c182227876c47f476000b0b54618dac73e45a03f.camel@timruffing.de>
Message-ID: <CABLeJxT6aZxrFn4apHOrELcdo37iGhmwsLH-BJxNb4Sbhotbog@mail.gmail.com>

Hi Tim,

Hm, so what vectors is this supposed to mitigate? Leaking through the
> generated public keys? Anything else?


The main thing it?s protecting against is the stealing of your funds by
malicious hardware & software. There are some side benefits as well though.

 - What are you trying to achieve? You seem to describe how you get
> from the setup to the goal in four steps but I don't understand what
> the setup is or what the goal is. (What's a storage solution?)


?Storage solution? is however you?re storing bitcoins today. Could be 12
words on some paper plus a computer running electrum. Could be a Ledger +
computer. Point is this technique works regardless of how you?re storing
your bitcoin.

 - "all SW being compromised" do you mean "SW and HW compromised"? Note
> that SW and HW are parties in Pieter's writeup, not just abbreviations
> for software and hardware.


Yeah ? if you split the SW party into two, ?generator? and ?validator? some
interesting and useful security properties emerge.

 - Where are the two stages? You mention four steps.


?Generator? and ?validator?. The generator creates and passes on receiving
addresses and withdrawal transactions (while remaining offline). The
validator double checks everything the generator did..

It works best if the validator is written entirely independently of the
generator.

 - Where do you run the external software? On a second SW? Is this the
> second stage?


Yes

 - Do you use unhardened derivation?


It?s an open ended solution ? it would work with a (presumably
non-trivial/random) unhardened derivation just fine.

 - What's a k commitment?


It is one of the proposed solutions presented (collected?) by Peter in this
thread. As I understand it k is used to generate R in the signature. By
committing to some k value the hardware wallet can?t ?sneak out? your
private key(s) in the R value.

Best,
Dustin

>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200324/db2f881c/attachment.html>

From bitcoin-dev at wuille.net  Tue Mar 24 18:56:38 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 24 Mar 2020 18:56:38 +0000
Subject: [bitcoin-dev] Mitigating Differential Power Analysis in BIP-340
In-Reply-To: <CAH5Bsr3EtFpecXPG07so1KA0sre9Cy-XPv=BADBgUe4M7kuxFg@mail.gmail.com>
References: <CAH5Bsr3EtFpecXPG07so1KA0sre9Cy-XPv=BADBgUe4M7kuxFg@mail.gmail.com>
Message-ID: <143g8W700TxSwkQM6rPf7NfRYcaVJoBqYLfR99gwtb-kBfL76EK556d4U8aNyEVRz5bp1eFzApLwPMSnhwAnK5m_htjqVREn5yZxXRCORiU=@wuille.net>

On Tuesday, March 24, 2020 6:00 AM, Lloyd Fournier via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi List,
>
> I felt this topic deserved it's own thread but it follows on from the mailing list post [2] announcing a new PR [1] to change BIP-340 in several ways, including adding random auxiliary?data into the nonce derivation?function. Rather than hashing the randomness with the secret key and message etc, the randomness is hashed then XOR'd (^) with the secret key and the result is hashed like so to determine the secret nonce k:
>
> (1) k = H_derive( sec_key ^ H_aux(rand) || pub_key_x || message)
>
> The claim made in the mailing list post is that this is more secure against "differential power analysis" (DPA) attacks than just doing the simpler and more efficient:
>
> (2) k = H_derive(sec_key || rand || pub_key_x || message)
>
> The TL;DR here is that I don't think this is the case.

Hi Lloyd,

Thank you for looking into this. I very much agree we haven't given nearly enough justification for the use of a non-standard scheme here.

I'll try to summarize the discussion we had that led to this choice, but most of it is on https://github.com/sipa/bips/issues/195 if you want the details.

Let me first try to address what I think you're overlooking: in a BIP32/Taproot like scenario, the private key that goes into the signing algorithm functions as *both* secret and known to the attacker. That is to say, there is a master secret s, and signing key x that goes into the hash is x=s+a (mod n) for some value a that the attacker knows, and can modify (he cannot control it directly, but he may be able to grind it to have a structure he likes). I believe that means that feeding x to a hash directly itself is already a problem, regardless of what else goes into the hash - interactions between bits inside the hash operation that all come from x itself can leak bit-level information of x.  XORing (or any other simple mix operation that does not expose bit-level information) into the private key before giving it to a hash function seems like it would address this.

That said, all these DPA issues are very hard to reason about, as it's hard to find a realistic attack model that both (a) leaks some information but (b) doesn't obviously leak the entire key immediately. In the reasoning above I assumed an attacker who can observe word-level Hamming weight aggregates of all variables in the algorithm (which seems to match what one of the papers observed), but not bit level information. It also assumes that somehow the computation of x itself is immune from leaks (something you pointed out in a previous e-mail, I noticed).

So really, all of this is trying to choose one alternative among a set of (when ignoring DPA) nearly equally good constructions. Note that randomness is useful for protection against fault attacks, but for that purpose it doesn't matter where in the hash it goes, or even that it's particularly strong randomness (a counter would also work). There are a number of other concerns we discussed in the linked thread:
* Efficiency (how many SHA256 transformations, including the ability for some to be precomputed)
* The risk that the randomness added is correlated with the private key in a way that cancels things out when they're naively XORed together.
* The risk of having a midstate in the hash function leak (without leaking the actual private key, but enough to predict nonces).
* The issue with public keys that are input to the signing algorithm which come directly from an attacker (which is the reason why pubkey goes into the nonce function too).

The solution we came up with (H(priv XOR H(aux) || pub || msg)) is the only that ticks most of the boxes - but a different prioritization may certainly lead to a different conclusion.

I'm happy for any input you may have here. In particular, the recent discussions around the interactions between anti-covert channel protection, randomness, and the ability to spot check hardware devices may mean we should revise the advice to consider not adding randomness unless such a anti-covert channel scheme is used.

Cheers,

--
Pieter


From karljohan-alm at garage.co.jp  Wed Mar 25 06:31:56 2020
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Wed, 25 Mar 2020 15:31:56 +0900
Subject: [bitcoin-dev] RFC: Kicking BIP-322 (message signing) into motion
In-Reply-To: <CAB3F3DtruOW8q7E8=wP+Jf-bdcPGrypgXjFjcABrD1qQcrX+gg@mail.gmail.com>
References: <CALJw2w4ENV3y3Ufu=YRquDNwvQnewcwGHOe1njw8-ztNXJF-XQ@mail.gmail.com>
 <202003041435.17644.luke@dashjr.org>
 <CAB3F3DtruOW8q7E8=wP+Jf-bdcPGrypgXjFjcABrD1qQcrX+gg@mail.gmail.com>
Message-ID: <CALJw2w7r=rBFwkXpLZL_Vd40on7KGNuMOkv0-rFArk4k+-tEkQ@mail.gmail.com>

Hello,

I propose simplifying BIP-322 down to the single-proof case, and
removing some abstractions (e.g. the "actions"/"purposes" stuff):
https://github.com/bitcoin/bips/pull/903

Feedback welcome.

New version below:
```
<pre>
BIP: 322
Layer: Applications
Title: Generic Signed Message Format
Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>
Comments-Summary: No comments yet.
Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322
Status: Draft
Type: Standards Track
Created: 2018-09-10
License: CC0-1.0
</pre>

== Abstract ==

A standard for interoperable generic signed messages based on the
Bitcoin Script format.

== Background ==

* Assume two actors, a prover <code>P</code> and a verifier <code>V</code>.
* <code>P</code> wants to prove that they own the private key
<code>k</code> associated with a given address <code>A</code> (which
in turn is derived from the pubkey <code>kG</code>).
* Let <code>V</code> generate a message <code>M</code> and hand this
to <code>P</code>.
* <code>P</code> generates a signature <code>S</code> by signing the
message <code>M</code> using <code>k</code>. Given <code>S</code>,
<code>V</code> can prove that <code>P</code> has the private key
associated with <code>A</code>.

The astute reader will notice that the above is missing a critical
part, namely the pubkey <code>kG</code>, without which the verifier
cannot actually verify the message. The current message signing
standard solves this via a cryptographic trick, wherein the signature
<code>S</code> above is a special "recoverable signature" type. Given
the message <code>M</code> and the signature <code>S</code>, it is
then possible to recover the pubkey <code>kG</code>. The system thus
derives the address for the pubkey <code>kG</code>, and if it does not
match <code>A</code>, the proof is deemed invalid.

While this is a neat trick, it unnecessarily restricts and complicates
the message signing mechanism; for instance, it is currently not
possible to sign a message for a P2SH address, because there is no
pubkey to recover from the resulting signature.

== Motivation ==

The current message signing standard only works for P2PKH (1...)
addresses. By extending it to use a Bitcoin Script based approach, it
could be made more generic without causing a too big burden on
implementers, who most likely have access to Bitcoin Script
interpreters already.

== Specification ==

A new structure <code>SignatureProof</code> is added, which is a
simple serializable scriptSig & witness container.

=== SignatureProof container ===

{|class="wikitable" style="text-align: center;"
|-
!Type
!Length
!Name
!Comment
|-
|VarInt||1-8||scriptsiglen||Number of bytes in scriptSig data
|-
|Uint8*||[scriptsiglen]||scriptsig||ScriptSig data
|-
|VarInt||1-8||witlen||Number of entries in witness stack
|-
|Uint8[]*||[witlen]||wit||Witness stack, as [witlen] uint8* vectors,
each one prepended with a varint of its size
|}

In some cases, the scriptsig or wit may be empty. If both are empty,
the proof is incomplete.

=== Result Codes ===

A verification call will return a result code according to the table below.

{|class="wikitable" style="text-align: center;"
|-
!Code
!Description
|-
|INCOMPLETE||Empty proof.
|-
|INCONCLUSIVE||The given proof was consensus-valid but policy-invalid.
|-
|VALID||The proof was valid.
|-
|INVALID||The proof was invalid
|-
|ERROR||An error was encountered
|}

== Signing and Verifying ==

If the challenge consists of an address is in the P2PKH (legacy)
format, sign using the legacy format (further information below).
Otherwise continue as stated below.

For both cases, generate a sighash based on the given scriptPubKey and
message as follows:

# Define the message pre-image as the sequence "Bitcoin Signed
Message:\n" concatenated with the message, encoded in UTF-8 using
Normalization Form Compatibility Decomposition (NFKD)
# Let sighash = sha256(sha256(scriptPubKey || pre-image))

A private key may be used directly to sign a message. In this case,
its P2WPKH bech32 address shall be derived, and used as the input.

=== Signing ===

The signature is generated as follows:

# Derive the private key privkey for the scriptPubKey; FAIL if not VALID
# Generate and return a signature sig with privkey=privkey, sighash=sighash

=== Verifying ===

Verify a proof, given a standard flags value, a script sig, an
optional witness, and a derived sighash as described above.

While omitted below, ERROR is returned if an unforeseen error occurs
at any point in the process. A concrete example of this is if a legacy
proof is given as input to a non-legacy address; the deserialization
of the proof will fail in this case, and this should result in an
ERROR result.

# Verify Script with flags=consensus flags (currently P2SH, DERSIG,
NULLDUMMY, CLTV, CSV, WITNESS), scriptSig=script sig,
scriptPubKey=scriptPubKey, witness=witness, and sighash=sighash
# Return INVALID if verification fails
# Verify Script with flags=standard flags (above plus STRICTENC,
MINIMALDATA, etc.), scriptSig=script sig, scriptPubKey=scriptPubKey,
witness=witness, and sighash=sighash
# Return VALID if verification succeeds, otherwise return INCONCLUSIVE

== Legacy format ==

The legacy format is restricted to the legacy P2PKH address format.

Any other input (i.e. non-P2PKH address format) must be signed using
the new format described above.

=== Signing ===

Given the P2PKH address <code>a</code> and the message <code>m</code>,
and the pubkey-hash function <code>pkh(P) =
ripemd160(sha256(P))</code>:

# let <code>p</code> be the pubkey-hash <code>pkh(P)</code> for the
pubkey <code>P</code>, contained in <code>a</code>
# let <code>x</code> be the private key associated with <code>P</code>
so that <code>pkh(xG) = p</code>
# let <code>digest</code> be <code>SHA56d("Bitcoin Signed Message:\n"||m)</code>
# create a compact signature <code>sig</code> (aka "recoverable ECDSA
signature") using <code>x</code> on <code>digest</code>

The resulting proof is <code>sig</code>, serialized using the base64 encoding.

=== Verifying ===

Given the P2PKH address <code>a</code>, the message <code>m</code>,
the compact signature <code>sig</code>, and the pubkey-hash function
<code>pkh(P) = ripemd160(sha256(P))</code>:

# let <code>p</code> be the pubkey-hash <code>pkh(P)</code> for the
pubkey <code>P</code>, contained in <code>a</code>
# let <code>digest</code> be <code>SHA56d("Bitcoin Signed Message:\n"||m)</code>
# attempt pubkey recovery for <code>digest</code> using the signature
<code>sig</code> and store the resulting pubkey into <code>Q</code>
## fail verification if pubkey recovery above fails
# let <code>q</code> be the pubkey-hash <code>pkh(Q)</code> for the
pubkey <code>Q</code>
# if <code>p == q</code>, the proof is valid, otherwise it is invalid

== Compatibility ==

This specification is backwards compatible with the legacy
signmessage/verifymessage specification through the special case as
described above.

== Reference implementation ==

# Pull request to Bitcoin Core: https://github.com/bitcoin/bitcoin/pull/16440

== Acknowledgements ==

Thanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille,
and many others for their feedback on the specification.

== References ==

# Original mailing list thread:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html

== Copyright ==

This document is licensed under the Creative Commons CC0 1.0 Universal license.

== Consensus and standard flags ==

Each flag is associated with some type of enforced rule (most often a
soft fork). There are two sets of flags: consensus flags (which result
in a block being rejected, if violated), and policy flags (which
result in a transaction being accepted only if it is contained within
an actual block, and rejected otherwise, if violated). The policy
flags are a super-set of the consensus flags.

BIP322 specifies that a proof that validates for both rulesets is
valid, a proof that validates for consensus rules, but not for policy
rules, is "inconclusive", and a proof that does not validate for
consensus rules is "invalid" (regardless of policy rule validation).

The ruleset sometimes changes. This BIP does not intend to be
complete, nor does it indicate enforcement of rules, it simply lists
the rules as they stand at the point of writing.

=== Consensus rules ===

* P2SH: evaluate P2SH
([https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki
BIP16]) subscripts
* DERSIG: enforce strict DER
([https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
BIP66]) compliance
* NULLDUMMY: enforce NULLDUMMY
([https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki
BIP147])
* CHECKLOCKTIMEVERIFY: enable CHECKLOCKTIMEVERIFY
([https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki
BIP65])
* CHECKSEQUENCEVERIFY: enable CHECKSEQUENCEVERIFY
([https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki
BIP112])
* WITNESS: enable WITNESS
([https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki
BIP141])

=== Policy rules ===

All of the above, plus (subject to change):

* STRICTENC: non-strict DER signature or undefined hashtype
* MINIMALDATA: require minimal encodings for all push operations
* DISCOURAGE_UPGRADABLE_NOPS: discourage use of NOPs reserved for upgrades
* CLEANSTACK: require that only a single stack element remains after evaluation
* MINIMALIF: Segwit script only: require the argument of OP_IF/NOTIF
to be exactly 0x01 or empty vector
* NULLFAIL: signature(s) must be empty vector if a CHECK(MULTI)SIG
operation failed
* LOW_S: signature with S > order/2 in a checksig operation
* DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: v1-16 witness programs are
non-standard (i.e. forbidden)
* WITNESS_PUBKEYTYPE: public keys in segregated witness scripts must
be compressed
* CONST_SCRIPTCODE: OP_CODESEPARATOR and FindAndDelete fail any
non-segwit scripts

== Test vectors ==

(TODO: update test vectors, which are based on previous iteration
where signature proofs contained additional data)

== Native segwit test vector ==

<pre>
address = bcrt1qe7nte4zk4ayly5tc53dtdjupgkz0lr8azx3rzz
scriptpubkey = 0014cfa6bcd456af49f25178a45ab6cb814584ff8cfd
message = hello
preimage = 0014cfa6bcd456af49f25178a45ab6cb814584ff8cfd426974636f696e205369
676e6564204d6573736167653a0a68656c6c6f
(scriptpubkey || "Bitcoin Signed Message:\nhello")
sighash = 790eef86c204f0bff969ff822121317aa34eff0215dbd30ccf031e7b2f3f0cc1
(sha256d(preimage), displayed in big-endian)
</pre>

The proof becomes:

<pre>
HEX: 01000000010002473044022075b4fb40421d55c55462879cb352a85eeb3af2138d3f0290
2c9143f12870f5f70220119c2995c1661138142f3899c1fd6d1af7e790e0e081be72db9c
e7bf5b5b932901210290beccd02b73eca57467b2b6f1e47161a9b76a5e67586e7c1dee9e
a6e2dcd869

Base64: AQAAAAEAAkcwRAIgdbT7QEIdVcVUYoecs1KoXus68hONPwKQLJFD8Shw9fcCIBGcKZXBZhE4
FC84mcH9bRr355Dg4IG+ctuc579bW5MpASECkL7M0Ctz7KV0Z7K28eRxYam3al5nWG58He6e
puLc2Gk=
</pre>

Split into components:

{|class="wikitable" style="text-align: center;"
|-
!Type
!Length
!Name
!Value
!Comment
|-
|Uint32||4||flags||<code>01000000</code>||proof format version
|-
|Uint8||1||entries||<code>01</code>||1 entry
|-
|VarInt||1-8||scriptsiglen||<code>00</code>||0 byte scriptsig
|-
|VarInt||1-8||wit entries||<code>02</code>||2 witness stack entries
|-
|VarInt||1-8||entry1len||<code>47</code>||71 byte entry
|-
|Uint8[71]||71||entry1||<code>3044022075b4fb40421d55c55462879cb352a85eeb3af213
8d3f02902c9143f12870f5f70220119c2995c1661138142f
3899c1fd6d1af7e790e0e081be72db9ce7bf5b5b932901</code>||Witness stack item 1
|-
|VarInt||1-8||entry2len||<code>21</code>||33 byte entry
|-
|Uint8[33]||33||entry2||<code>0290beccd02b73eca57467b2b6f1e47161a9b76a5e67586e
7c1dee9ea6e2dcd869</code>||Witness stack item 2
|}

The above test vector is for a bech32 P2WPKH (native segwit) address.
(Once BIP solidifies, will add test vector for other types.)
```

On Wed, Mar 4, 2020 at 11:43 PM Greg Sanders <gsanders87 at gmail.com> wrote:
>
> OP_MESSAGEONLY would make "dumb" signers like HWW more difficult to support. They'd have to do script interpretation to make sure they're not signing something real with funds.
>
> Just FYI.
>
> On Wed, Mar 4, 2020 at 9:35 AM Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> In addition to starting with proof-of-funds instead of proof-of-receiver, it
>> would be nice to integrate with Taproot somehow or another. Perhaps
>> OP_MESSAGEONLY is the most straightforward way to do this? It might be a good
>> idea to have a message type after the opcode too.
>>
>> On Wednesday 04 March 2020 06:23:53 Karl-Johan Alm via bitcoin-dev wrote:
>> > Hello,
>> >
>> > I noticed recently that a PR to Bitcoin Core that pretty much touched
>> > everything my BIP-322 pull request touches (around the same
>> > complexity) was merged without a thought given to BIP-322
>> > compatibility, despite the BIP-322 PR being open for 2x the time. I
>> > can only conclude from this that people dislike BIP-322 in its current
>> > form, which the 9 month old pull request stagnating can probably
>> > attest to.
>> >
>> > There are several things that I can do to make this a bit more
>> > appealing to people, which would hopefully kick the progress on this
>> > forward. I have already put in a non-trivial amount of energy and
>> > effort into maintaining the pull request as is, so I'd prefer if
>> > people were harsh and unfiltered in their criticism rather than polite
>> > and buffered, so I can beat this thing into shape (or abandon it, in
>> > the worst case).
>> >
>> > =============
>> > 1. People use signmessage as a way to prove funds. This is misleading
>> > and should be discouraged; throw the sign message stuff out and
>> > replace it entirely with a prove funds system.
>> >
>> > I know in particular luke-jr is of this opinion, and Greg Maxwell in
>> > https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-568194168
>> > leans towards this opinion as well, it seems.
>> >
>> > =============
>> > 2. Use a transaction rather than a new format; make the first input's
>> > txid the message hash to ensure the tx cannot be broadcasted. This has
>> > the benefit of being able to provide to an existing hardware wallet
>> > without making any modifications to its firmware.
>> >
>> > I think Mark Friedenbach and Johnson Lau are of this opinion, except
>> > Johnson Lau also suggests that the signature hash is modified, see
>> > https://github.com/bitcoin/bips/pull/725#issuecomment-420040430 --
>> > which defeats the benefit above since now hw wallets can no longer
>> > sign.
>> >
>> > Prusnak (I think he works at Trezor; apologies if I am mistaken) is
>> > against this idea, and proposes (3) below:
>> > https://github.com/bitcoin/bips/pull/725#issuecomment-420210488
>> >
>> > =============
>> > 3. Use Trezor style
>> >
>> > See https://github.com/trezor/trezor-mcu/issues/169
>> >
>> > This has the benefit of already being adopted (which clearly BIP-322
>> > is failing hard at right now), but has the drawback that we can no
>> > longer do *generic* signing; we are stuck with the exact same
>> > limitations as in the legacy system, which we kinda wanted to fix in
>> > the updated version.
>> >
>> > =============
>> > 4. Introduce OP_MESSAGEONLY
>> >
>> > Quoting Johnson Lau at
>> > https://github.com/bitcoin/bips/pull/725#issuecomment-420421058 :
>> > """
>> > OP_MESSAGEONLY means the script following the code would never be
>> > valid. For example, a scriptPubKey:
>> >
>> > OP_IF OP_MESSAGEONLY <key_m> OP_ELSE <key_s> OP_ENDIF OP_CHECKSIG
>> >
>> > For messaging purpose, OP_MESSAGEONLY is considered as OP_NOP and is
>> > ignored. A message could be signed with either key_m or key_s.
>> >
>> > For spending, only key_s is valid.
>> >
>> > I don't think it is a big problem to consume a op_code. If this is a
>> > real concern, I could modify it as follow: in message system,
>> > OP_RETURN will pop the top stack. If top stack is msg in hex, it is
>> > ignored. Otherwise, the script fails.
>> > """
>> >
>> > =============
>> > 5. Some other solution
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From adam.back at gmail.com  Wed Mar 25 13:54:18 2020
From: adam.back at gmail.com (Adam Back)
Date: Wed, 25 Mar 2020 14:54:18 +0100
Subject: [bitcoin-dev] RFC: Deterministic Entropy From BIP32 Keychains
In-Reply-To: <c7b9bd243e7ae6a5a4e55f4b18d7d656c3690380.camel@timruffing.de>
References: <_CC9MLKCy5rmooAmR91_34tQxgDiXDJCdY4W6_X6xqDJUiAEuaWBVi8iBaFipx2KGt5_mf5XqFKMfoNgemTPCMgraWt5CVRifUM5iMolxto=@protonmail.com>
 <S90SB9DcluBjzhnWrbT1Urh61XgVcn6ynEU7EGsfR-UhGGMxPOXMuJdwM0BPtdAcIaL22B4zR0Pooe4Yaoi0zBPFnnwQ4WSSpL7FoW4OOBA=@protonmail.com>
 <c7b9bd243e7ae6a5a4e55f4b18d7d656c3690380.camel@timruffing.de>
Message-ID: <CALqxMTH4+WWKDzLh-6gC5GcaHvSMJjY9S8HNy-DwNgefdpuyUA@mail.gmail.com>

I think the point is to use this proposed extension/standard for a
kind of "seed management" function, set it up on an offline device (an
always offline laptop, or a modified hardware wallet) where you put
the master seed.  And then you use this as a kind of seed manager and
transcript the seeds for different sub-wallets into the respective
wallets as BIP39 mnemonics.

So I do not think it needs any changes from existing wallet authors,
as the interaction point is a bip 39 seed, which they mostly know how
to use.  Indeed if you were to modify an existing wallet to accept the
master seed from seed management scheme and derive the seed it needs
on each wallet, then that would create a weakest link in the chain
risk - if that wallet was insecure, or compromised then all other
derived seeds would be also and you want independence for each wallet.

I do think that this use case is a practical problem for people
managing multiple seeds for various wallets in a bitcoin business
setting or even power users - you lose the single backup design,
because it's too cumbersome to create fresh backups for each of
multiple wallets, especially distributed , fireproof cryptosteel etc
backups and so in practice for multi wallet scenarios probably they
are not all full backed up or not backed up as robustly (not as
geo-redundant, fireproof, secret-shared etc).

Adam

On Tue, 24 Mar 2020 at 09:32, Tim Ruffing via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> I think your proposal is simply to use BIP32 for all derivations and
> the observation that you can work with derived keys with the
> corresponding suffixes of the path. I believe that this is a good idea.
>
> But I don't think that simply writing a standard will help. It's just
> one step. If all your wallets support incompatible formats, we should
> work on fixing this because that's the root of the issue. Otherwise you
> end up converting keys back and forth manually (as Chris pointed out),
> and this can't be the goal.
>
> But then you need to reach out to wallet devs explicitly and get them
> involved in creating the standard. Otherwise they won't use it. That's
> a hard process, and it's even harder to make sure that the resulting
> proposal isn't way too complex because everyone brings their special
> case to the table.
>
> Tim
>
> On Sun, 2020-03-22 at 11:58 +0000, Ethan Kosakovsky via bitcoin-dev
> wrote:
> > I have completely revised the wording of this proposal I hope to be
> > clearer in explaining the motivation and methodology.
> >
> > https://gist.github.com/ethankosakovsky/268c52f018b94bea29a6e809381c05d6
> >
> > Ethan
> >
> > ??????? Original Message ???????
> > On Friday, March 20, 2020 4:44 PM, Ethan Kosakovsky via bitcoin-dev <
> > bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > I would like to present a proposal for discussion and peer review.
> > > It aims to solve the problem of "too many seeds and too many
> > > backups" due to the many reasons stipulated in the proposal text.
> > >
> > > https://gist.githubusercontent.com/ethankosakovsky/f7d148f588d14e0bb4f70bb6afc509d0/raw/6da51e837b0e1f1b2b21f3d4cbc2c5a87969ffd5/bip-entropy-from-bip32.mediawiki
> > >
> > > <pre>
> > > BIP:
> > > Title: Deterministic Entropy From BIP32 Keychains
> > > Author: Ethan Kosakovsky ethankosakovsky at protonmail.com
> > > Comments-Summary: No comments yet.
> > > Comments-URI:
> > > Status: Proposed
> > > Type: Standards Track
> > > Created: 2020-03-20
> > > License: BSD-2-Clause
> > > OPL
> > > </pre>
> > >
> > > ==Abstract==
> > >
> > > This proposal provides a way to derive entropy from a HD keychain
> > > path in order to deterministically derive the initial entropy used
> > > to create keychain mnemonics and seeds.
> > >
> > > ==Motivation==
> > >
> > > BIP32 uses some initial entropy as a seed to deterministically
> > > derive a BIP32 root for hierarchical deterministic keychains. BIP39
> > > introduced a method of encoding initial entropy into a mnemonic
> > > phrase which is used as input to a one way hash function in order
> > > to deterministically derive a BIP32 seed. The motivation behind
> > > mnemonic phrases was to make it easier for humans to backup and
> > > store offline. There are also other variations of this theme.
> > >
> > > The initial motivation of BIP32 was to make handling of large
> > > numbers of private keys easier to manage and backup, since you only
> > > need one BIP32 seed to cover all possible keys in the keychain. In
> > > practice however, due to various wallet implementations and
> > > security models, the average user may be faced with the need to
> > > handle an ever growing number of seeds/mnemonics. This is due to
> > > incompatible wallet standards, hardware wallets (HWW), seed formats
> > > and standards, as well as, the need to used a mix of hot and cold
> > > wallets depending on the application and environment.
> > >
> > > Examples would span wallets on mobile phones, online servers
> > > running protocols like Join Market or Lightning, and the difference
> > > between Electrum and BIP39 mnemonic seed formats. The reference
> > > implementation of Bitcoin Core uses BIP32, while other
> > > cryptocurrencies like Monero use different mnemonic encoding
> > > schemes.
> > >
> > > We must also consider the different variety of physical backups
> > > including paper, metal and other physical storage devices, as well
> > > as the potentially splitting backups across different geographical
> > > locations. This complexity may result in less care being taken with
> > > subsequently generated seeds for new wallets need to be stored and
> > > it ultimately results in less security. In reality, the idea of
> > > having "one seed for all" has proven to be more difficult in
> > > practice than originally thought.
> > >
> > > Since all these derivation schemes are deterministic based on some
> > > initial entropy, this proposal aims to solve the above problems by
> > > detailing a way to deterministically derive the initial entropy
> > > used for new root keychains using a single BIP32 style "master root
> > > key". This will allow one root key or mnemonic to derive any
> > > variety of different root keychains in whatever format is required
> > > (like BIP32 and BIP39 etc).
> > >
> > > ==Specification==
> > >
> > > Input starts with a BIP32 seed. Derivation scheme uses the format
> > > `m/83696968'/type'/index'` where `type` is the final seed type, and
> > > `index` in the key index of the hardened child private key.
> > >
> > > type
> > >
> > > bits
> > >
> > > output
> > >
> > > 0
> > >
> > > 128
> > >
> > > 12 word BIP39 mnemonic
> > >
> > > 1
> > >
> > > 256
> > >
> > > 24 word BIP39 mnemonic
> > >
> > > 2
> > >
> > > 128
> > >
> > > 12 word Electrum mnemonic
> > >
> > > 3
> > >
> > > 256
> > >
> > > 24 word Electrum mnemonic
> > >
> > > 4
> > >
> > > 256
> > >
> > > WIF for Bitcoin Core
> > >
> > > 5
> > >
> > > 256
> > >
> > > 25 word Monero mnemonic
> > >
> > > Entropy is calculated from the HMAC-SHA512(key=k, msg='bip-entropy-
> > > from-bip32') of the derived 32 byte private key (k). Entropy is
> > > taken from the result according to the number of bits required.
> > > This entropy can then be used as input to derive a mnemonic, wallet
> > > etc according to the`type` specified.
> > >
> > > ==Compatibility==
> > >
> > > In order to maintain the widest compatibility, the input to this
> > > function is a BIP32 seed, which may or may not have been derived
> > > from a BIP39 like mnemonic scheme. This maintains the original
> > > motivation that one backup can store any and all child derivation
> > > schemes depending on the user's preference or hardware signing
> > > devices. For example, devices that store the HD seed as a BIP39
> > > mnemonic, Electrum seed, or BIP32 root key would all be able to
> > > implement this standard.
> > >
> > > ==Discussion==
> > >
> > > This proposal could be split into multiple discrete BIPs in the
> > > same way that BIP32 described the derivation mechanics, BIP39 the
> > > input encoding with mnemonics, and the derivation paths like BIP44,
> > > BIP49 and BIP84. This has been avoided to reduce complexity. The
> > > resulting private key processed with HMAC-SHA512 and truncated as
> > > necessary. HMAC-SHA512 was chosen because it may have better
> > > compatibility in embedded devices as it's already required in
> > > devices supporting BIP32.
> > >
> > > ==Test Vectors==
> > >
> > > ===Test case 1===
> > >
> > > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind
> > > employ giant era attitude exit final oval one finger decorate pair
> > > useless super method float toddler dance
> > > MASTER BIP32 ROOT KEY:
> > > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG
> > > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> > > PATH: m/83696968'/0'/0'
> > > BITS REQUIRED: 128
> > >
> > > DERIVED CHILD
> > > WIF=L3cefeCHyo8jczVjckMxaiPBaPUunc3D8CsjRxYbYp3FhasGpsV3
> > > DERIVED CHILD
> > > k=bed343b04ba0216d9eeebff0366b61c4179d90d44b61c716ef6d568836ba4d23
> > > CHILD ENTROPY=6458698fae3578b48a64124ea3514e12
> > > CONVERT ENTROPY TO
> > > WIF=KwDiBf89QgGbjEhKnhXJuH7T2Vv72UKQA8KRkmNwVFS2znAS5xb9
> > > CHILD BIP39 MNEMONIC=gold select glue fragile fiscal fog civil
> > > liquid exchange box fatal caught
> > > CHILD BIP39
> > > SEED=2a2720e5590d4ec3140e51ba1b0b0a5183222c1668977c8a57572b0ea55d23
> > > 8cd8e899b3b1870e48894ca837e41e5d0db07554715efb21556fdde27f9f7ba153
> > > CHILD BIP32 ROOT
> > > KEY=xprv9s21ZrQH143K2ZH5qacptquLGvcYpHSNeyFVCU8Ur4u9kocajbBgcaCbHkG
> > > bwDsBR661H29F54j5mz14kwXbY9PZKdNRdjgRcGfshBK9XXb
> > >
> > > ===Test case 2===
> > >
> > > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind
> > > employ giant era attitude exit final oval one finger decorate pair
> > > useless super method float toddler dance
> > > MASTER BIP32 ROOT KEY:
> > > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG
> > > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> > > PATH: m/83696968'/1'/0'
> > > BITS REQUIRED: 256
> > >
> > > DERIVED CHILD
> > > WIF=L1zCbtnDWUN4vJA3De4sxmJnoRim57CQUuBb4KBoRNs2EMEq2Brg
> > > DERIVED CHILD
> > > k=8e3ca6054a6303f4a6a1bcbda6134c9802f4f0a0d76b0ee6b69b06b1e80b2192
> > > CHILD
> > > ENTROPY=ec4e2f7e2c3fca9a34fa29747bf8ba0ab7f05136f37e134e2457e9e5363
> > > 9670b
> > > CONVERT ENTROPY TO
> > > WIF=L594JSCygt2wBaB9mCpXjiLkkxkEojpBdNXG8UrrdLd2LvPBRMUs
> > > CHILD BIP39 MNEMONIC=unable imitate test flash witness escape
> > > stadium early inner thank company betray lecture chuckle swift hurt
> > > battle illness bicycle stable fat bronze order high
> > > CHILD BIP39
> > > SEED=73509b0e847ee66bddeb098a55063d73e8c6dd5f1c1db6969c668bb54c19bd
> > > e6eae8acc29a81118d1d9719fa1bc620fee7edd7c15a17bcaf70b0fdfc0c0c3803
> > > CHILD BIP32 ROOT
> > > KEY=xprv9s21ZrQH143K4PfLyyjYLVmKbnUTNFK6Y7jPKWfRZB3iSw1Gy9qowEzkYHf
> > > etVabfmjHEEPrcTJbh7chae33Sm9uAjuXzhSL6Li8dcwM9Bm
> > >
> > > ===Test case 3===
> > >
> > > MASTER BIP39 SEED INPUT: angle fabric town envelope music diet bind
> > > employ giant era attitude exit final oval one finger decorate pair
> > > useless super method float toddler dance
> > > MASTER BIP32 ROOT KEY:
> > > xprv9s21ZrQH143K2xNoceSiUtx8Wb8Fcrk9FUfzD3MLT4eFx5NbBuof9Mwrf7CCbfG
> > > JNehNRHvrXnWvy9FtWVaeNggsSKT57GNk7jpk1PRzZDp
> > > PATH: m/83696968'/4'/0'
> > > BITS REQUIRED: 256
> > >
> > > DERIVED CHILD
> > > WIF=KwdD5PYnCU3xQDfFJ6XBf6UDaLrTUxrKmBpdjRuuavWyqAQtpaA2
> > > DERIVED CHILD
> > > k=0c169ce2c17bea08512a7519769e365242a1562bd63c4c903daef516000efbf2
> > > CHILD
> > > ENTROPY=25573247f8a76799f7abc086b9286b5a7ccb03cb8d3550f48ac1e71d908
> > > 32974
> > > CONVERT ENTROPY TO
> > > WIF=KxUJ8VzMk7uWDEcwYjLRzRMGE6sSpwCfQxkE9GEwAvXhFSDNba9G
> > > CHILD BIP39 MNEMONIC=census ridge music vanish island smooth team
> > > job mammal sing bracket reject smile limit comfort pluck extend
> > > picture race soda suit dose place obtain
> > > CHILD BIP39
> > > SEED=4e5c82be6455ecf0884d9475435e29a9afb9acf70b07296d7e5039c866e4d5
> > > 4647706918b9d14909dfbd7071a4b7aee8a4ad0ac2bf48f0a09a8899dd28564418
> > > CHILD BIP32 ROOT
> > > KEY=xprv9s21ZrQH143K2kekJsK9V6t4ZKwHkY1Q3umxuaAhdZKGxCMpHiddLdYUQBo
> > > ynszpwnk5upoC788LiT5MZ5q1vUABXG7AMyZK5UjD9iyL7Am
> > >
> > > ==References==
> > >
> > > BIP32, BIP39
> > >
> > > ==Copyright==
> > >
> > > This BIP is dual-licensed under the Open Publication License and
> > > BSD 2-clause license.
> > >
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From tom at commerceblock.com  Wed Mar 25 13:52:10 2020
From: tom at commerceblock.com (Tom Trevethan)
Date: Wed, 25 Mar 2020 13:52:10 +0000
Subject: [bitcoin-dev] Statechain implementations
Message-ID: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>

Hi all,

We are starting to work on an implementation of the statechains concept (
https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),
with particular interest in using the protocol enable the change of
ownership (novation) of an individual position in an active discreet log
contract (DLC) without an on-chain transaction, and without needing the
cooperation of the counterparty. The protocol as outlined by Ruben requires
features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it
is uncertain when (or even if) this will be added. So we are looking at
variants that would work with current Bitcoin functionality, and it would
be good to get some feedback on them.

There are two main modifications we are looking at:
1. Instead of an eltoo-based backup/refund transaction (enabling the
current owner to claim the UTXO in case the statechain entity disappears)
we propose using a decrementing nLocktime for backup transactions as the
output changes hands. Here, the first owner gets a backup transaction with
an nLocktime at some future height (h0), then the next owner gets a backup
transaction with nLocktime (h0-c) where c is a confirmation window. This
approach has the downside of limiting the lifetime of the UTXO, but it also
doesn't require the current owner to be always online.

2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key
and transitory key) with a single P2(W)PKH output where the public key
shared between the SE and the current owner. The SE and the current owner
can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate
their own private key share, and the SE changes their key share at each
change of ownership (with the shared public key remaining the same). This
works as follows (.G is EC point multiplication, * is scalar
multiplication):

KeyGen:

a. Owner 1 generates private key share o1 then calculates the corresponding
public key of the share O1 and sends it to the SE: O1 = o1.G
b. The SE then generates a private key: s1 (the SE private key share),
calculates the corresponding public key and sends it to Owner 1: S1 = s1.G
c. Both SE and Owner 1 then multiply the public keys they receive by their
own private key shares to obtain the same shared public key P (which
corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)
d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the
address corresponding to P (but doesn't sign it).
e. Once Owner 1 and SE cooperatively sign the first backup transaction,
Owner 1 then signs and broadcasts the deposit transaction Tx0.

Transfer from Owner 1 to Owner 2:

a. Owner 2 generates two private keys: o2 (the new owner UTXO private key
share) and b2 (the new owner refund private key).
b. The SE generates a temporary blinding nonce x and calculates the value
x*s1 and sends this securely to Owner 2.
c. Owner 2 then multiplies this received value by the modular inverse of o2
(o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.
d. Owner 1 then multiplies this received value by the key share o1 and
sends the resulting value (x*s1*o2_inv*o1) to the SE.
e. The SE then multiplies this received value by the modular inverse of the
temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the
blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the
new owner key share o2 equals the original shared private key s1*o1.
f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1.
s2 and o2 are now the key shares of `P` and can be used to colaboritively
sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share
(o1) is of no use in deriving or co-signing with the full shared private
key, and is invalidated.
g. The shared public key P remains unchanged, but the corresponding private
key (which no individual party ever has knowledge of or can derive) can
only be determined from the key shares of the SE and Owner 2 (i.e. P =
s2*o2.G).
h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it
to the SE.
i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to
the address corresponding to B2 , with `nLockTime` set to a block height h0
- c0, where c0, is a confirmation time sufficient to guarantee that Tx2 can
be confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).
j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using
the 2P ECDSA protocol, which Owner 2 then saves.

The principle of the logic of the key transfer is that the two separate key
shares are updated, but the full shared private key (which no-one knows)
remains the same. The new owner chooses a new secret value for their
private key share, and this (along with the private key share of the
previous owner) is utilized by the SE to update their share. The use of the
nonce (x) prevents any of the participants from determining any information
about each others secret keys. In this way Owner 2 cannot determine s1 from
x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot
determine o1 or o2 from x*s1*o2_inv*o1.

This transfer protocol can be repeated to transfer the ownership to new
owners. Each time the SE key share sX is updated, the previous key shares
become invalid and are of no use even if the current key share is
subsequently revealed. The SE still needs to be trusted to delete the old
key share, but this protocol removes the risk the the SE can be hacked by a
previous owner to steal the funds.

Any comments on the above would be greatly appreciated.

Tom
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200325/d83a4cfd/attachment-0001.html>

From lloyd.fourn at gmail.com  Wed Mar 25 15:07:48 2020
From: lloyd.fourn at gmail.com (Lloyd Fournier)
Date: Thu, 26 Mar 2020 02:07:48 +1100
Subject: [bitcoin-dev] Mitigating Differential Power Analysis in BIP-340
In-Reply-To: <143g8W700TxSwkQM6rPf7NfRYcaVJoBqYLfR99gwtb-kBfL76EK556d4U8aNyEVRz5bp1eFzApLwPMSnhwAnK5m_htjqVREn5yZxXRCORiU=@wuille.net>
References: <CAH5Bsr3EtFpecXPG07so1KA0sre9Cy-XPv=BADBgUe4M7kuxFg@mail.gmail.com>
 <143g8W700TxSwkQM6rPf7NfRYcaVJoBqYLfR99gwtb-kBfL76EK556d4U8aNyEVRz5bp1eFzApLwPMSnhwAnK5m_htjqVREn5yZxXRCORiU=@wuille.net>
Message-ID: <CAH5Bsr2jgBHHTNEECC5OPZW6RjsEvto3mg0doTyWkrHCU-rdVw@mail.gmail.com>

Hi Pieter,

Thanks for the detailed response.


> /secret key/secret keyI'll try to summarize the discussion we had that led
> to this choice, but most of it is on
> https://github.com/sipa/bips/issues/195 if you want the details.


Ahh I can't believe I missed that github issue while searching. I guess I
started reading a paper on DPA and got carried away. I can see you got to
where I was and then went much further including some empirical analysis.
Nice. I agree with the conclusion that xor is more robust than just hashing
randomness in the same block as the secret key.


> Let me first try to address what I think you're overlooking: in a
> BIP32/Taproot like scenario, the private key that goes into the signing
> algorithm functions as *both* secret and known to the attacker. That is to
> say, there is a master secret s, and signing key x that goes into the hash
> is x=s+a (mod n) for some value a that the attacker knows, and can modify
> (he cannot control it directly, but he may be able to grind it to have a
> structure he likes). I believe that means that feeding x to a hash directly
> itself is already a problem, regardless of what else goes into the hash -
> interactions between bits inside the hash operation that all come from x
> itself can leak bit-level information of x.  XORing (or any other simple
> mix operation that does not expose bit-level information) into the private
> key before giving it to a hash function seems like it would address this.
>

This is an subtle point that I didn't cross my mind. My gut feeling is
there isn't even a computational argument to made that what I was
suggesting is secure against DPA in that setting. DPA seems to be a PITA. A
footnote in the BIP with a citation for DPA (the ed25519 one from the issue
is good) and a hint about why you should avoid hashing Bitcoin secret keys
altogether would be good. This brings us to the next point.

It also assumes that somehow the computation of x itself is immune from
> leaks (something you pointed out in a previous e-mail, I noticed).
>

>From my reading of the HMAC papers it seems you might be able to vary the
BIP32 child index derivation to do this attack. Just thinking about it now,
these attacks seem far fetched just because in order for it to be useful
you need to have physical access to the device and to be able to accurately
measure power consumption in high resolution (which I guess you can't do
from a typical USB bus from corrupted software). Then you also need to get
the user to do lots of signing or derivation with their device. I guess a
malicious cable with some way of exfiltrating power consumption could do it.


> I'm happy for any input you may have here. In particular, the recent
> discussions around the interactions between anti-covert channel protection,
> randomness, and the ability to spot check hardware devices may mean we
> should revise the advice to consider not adding randomness unless such a
> anti-covert channel scheme is used.
>

My only comment here is that there will end up being more than one way to
do it and I think what you and your collaborators have put forward is at a
local optimum of design (now that I understand it). Thanks and well done!
It won't be the right optimum for everyone. To me, it seems like a good
place to start. If you develop a decent nonce exfiltration protected
signing protocol later then I don't see why HW wallets wouldn't compete for
favour amongst the community by implementing and updating their devices to
conform to it.

LL
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/ef1f3213/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Mar 26 01:20:47 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 26 Mar 2020 01:20:47 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
Message-ID: <C9VNjBcLdS_tYiO3oZ-pwXjGV1ALjVxbLuS44u0Iscv0N4li1GTEjg0h63e9NBlTaG8iePiyhXhWlVkk1DzrRlPFvflF5sTIBipKu4L-oN0=@protonmail.com>

Good morning Tom,

>
> We are starting to work on an implementation of the statechains concept (https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with particular interest in using the protocol enable the change of ownership (novation) of an individual position in an active discreet log contract (DLC) without an on-chain transaction, and without needing the cooperation of the counterparty. The protocol as outlined by Ruben requires features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it is uncertain when (or even if) this will be added. So we are looking at variants that would work with current Bitcoin functionality, and it would be good to get some feedback on them.
>
> There are two main modifications we are looking at:
> 1. Instead of an eltoo-based backup/refund transaction (enabling the current owner to claim the UTXO in case the statechain entity disappears) we propose using a decrementing nLocktime for backup transactions as the output changes hands. Here, the first owner gets a backup transaction with an nLocktime at some future height (h0), then the next owner gets a backup transaction with nLocktime (h0-c) where c is a confirmation window. This approach has the downside of limiting the lifetime of the UTXO, but it also doesn't require the current owner to be always online.

I believe I suggested this to Ruben Somsen as well in the past, but you can replace the state update mechanism with, for example, Decker-Wattenhofer decrementing-`nSequence`, which while it has a limit on the number of updates, does not have a limit on the time that a UTXO is locked in this mechanism.

You can even use the Decker-Wattenhofer trick of having a chain of decrementing-`nSequence` mechanisms to effectively multiply the number of updates that the overall mechanism can have.

The drawback is that in a unilateral close condition, the time to completely resolve the unilateral close is very large.

For a quick reference for this technique:

* The funding transaction is anchored onchain, but all succeeding transactions are offchain.
  * This funding transaction has a particular funding transaction output.
* There is a kickoff transaction, which is a 1-input 1-output transaction without any `nLockTime` or `nSequence` limits.
  * This spends the funding tx out.
  * The signer set of the output is the same as the signer set of the funding transaction output.
    * You could tweak keys or script to give a modicum of privacy.
* There is one or more decrementing-`nSequence` transactions, which are 1-input 1-output transactions.
  * Each one has a particular `nSequence` with a relative-locktime constraint.
  * This spends the kickoff transaction output.
  * The signer set of the output is the same as the signer set of the funding transaction output.
* There is one or more decrementing-`nSequence` transactions, which are 1-input 1-output transactions.
  * Each one has a particular `nSequence` with a relative-locktime constraint.
  * This spends the previous stage decrementing-`nSequence` transaction output.
  * The signer set of the output is the same as the signer set of the funding transaction output.
* Repeat the above stage a few times.
* There is one or more decrementing-`nSequence` transactions, which are 1-input multi-output transactions.
  * Each one has a particular `nSequence` with a relative-locktime constraint.
  * This spends the previous stage decrementing-`nSequence` transaction output.
  * The outputs of this transaction represent the current state inside the statechain.

The `nSequence` use means there is no time-based lifetime limit.
The decrementing-`nSequence` stages mean that earlier states have higher `nSequence` limits, and newer states have lower `nSequence` limits.
Chaining multiple such mechanisms allows you to "reset" a stage by making a single update of the higher stage, which resets all further stages.

So for example, we could have a multi-stage mechanism as below:

    ***blockchain***
       [funding tx] -+
         _ _ _ _ _ _ | _ _ _ _ _ _ _
     offchain        |
                     +->[kickoff tx]->[[14] stage]->[[14] stage]->[[14] stage]-> state outputs

The number in the brackets is the relative-locktime `nSequence` constraint in that stage transaction.
Let us suppose that we agree to decrement `nSequence` by 7 blocks at each update.

Then the first update will have:

    ***blockchain***
       [funding tx] -+
         _ _ _ _ _ _ | _ _ _ _ _ _ _
     offchain        |
                     +->[kickoff tx]->[[14] stage]->[[14] stage]->[[ 7] stage]-> state outputs

The the second update:

    ***blockchain***
       [funding tx] -+
         _ _ _ _ _ _ | _ _ _ _ _ _ _
     offchain        |
                     +->[kickoff tx]->[[14] stage]->[[14] stage]->[[ 0] stage]-> state outputs

After this update, for the next update, we would also sign the second-to-the-last stage, and reset the last stage:

    ***blockchain***
       [funding tx] -+
         _ _ _ _ _ _ | _ _ _ _ _ _ _
     offchain        |
                     +->[kickoff tx]->[[14] stage]->[[ 7] stage]->[[14] stage]-> state outputs

And so on.
Effectively it becomes a large counter, with the "least significant digit" being the last stage.
This multiplies the total number of updates your statechain can have, so for example the above uses a total unilateral close delay of 42 blocks to allow creation of 27 updates, whereas if it were a single stage those 42 blocks would only allow 7 updates.

As the first stage decrements, you can actually add more stages dependent on it, keeping a total maximum time that a unilateral close will resolve, but increasing the number of transactions that would need to be published onchain in a unilateral close.
This allows you to further extend the number of updates, possibly allowing an indefinite number of updates (at the cost of greatly increased blockchain usage in the unilateral close, which might not be feasible).

The original Decker-Wattenhofer paper "Duplex Micropayment Channels" has prettier graphics.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Thu Mar 26 01:42:22 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 26 Mar 2020 01:42:22 +0000
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <20200325152302.GA3355@canndrew.org>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
 <20200323125922.GA29881@canndrew.org>
 <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>
 <C_qo1AhQuklVr4owEXVgLXsvJomb9Usd1NP2zf_D_23r6Cmz9-iB7ygSfNihJp3FIfAf4c1P41fT3qQP7SFiKdCfXxpogcstHsOnpgLgbok=@protonmail.com>
 <20200325152302.GA3355@canndrew.org>
Message-ID: <v1t2DhGSHFng23jy0XTRkoVJrhA_6x_QuHFWdrcxQnMS8Sdcbe7eksRtvjf6JCb8YLoHf2W5y29j3XbBIVfDALSBjoiMqxPUWKsQyGLOR_A=@protonmail.com>

Good morning Andrew,

>
> > Anyway, yes, your idea is fundamentally broken because a zero block reward
> > happens because creating even one more satoshi will push the amount of
> > bitcoin over 21,000,0000, breaking the meaning of "bitcoin," or, if you
> > like, creating a fundamental contradiction in our use of the term.
>
> I wouldn't really consider that fundamentally broken. It changes the meaning of
> "bitcoin", but so does every upgrade to the protocol. The worst problem I can
> see with this is that there's probably a lot of software out there which
> assumes a cap of 21M. But we'd have years to find and fix those bugs.

There are changes of meaning, and then there are changes of meaning.
Smaller changes that puny humans can understand are better than larger changes beyond the ken of mortal man.
To change the supply is far too big a change.

> > They already do so, via an implicit "field", known as the transaction fee.
> > This makes the vote for how much security is needed to be costly to the
> > voter, which is appropriate: you pay for your security.
>
> This isn't the same thing though, economically / game-theoretically speaking.
> Transaction fees are only paid when bitcoins get moved. There's no on-going
> cost for people holding bitcoins (assuming they're doing their day-to-day
> transactions almost entirely off-chain, which is something that's only going to
> become more common). More to the point, the transaction fee is only set by the
> current demand for block space. If transaction fees drop too low to maintain a
> secure hash rate then people could willingly pay more than they need to to
> get their transactions mined, but it's unlikely they will since it'd be cheaper
> to just pay the minimum and hope that everyone else covers the costs of keeping
> the network secure for them.
>
> With the voting idea everyone decides what everyone pays (via dilution) to keep
> the network secure. Choosing to signal a high inflation rate doesn't mean you
> pay more than everyone else, just that you might shift the median, so there's
> no tragedy-of-the-commons problem. Also, votes are weighted by the value of
> the utxo, so people both vote and pay in proportion to the amount of bitcoin
> they're holding.
>
> Does this make sense? Or is there some game-theoretic reason I'm not seeing for
> why transaction fees can never drop dangerously low in the first place?

What happens if I own a few million Bitcoin and then accidentally lose my private keys in a tragic ear-cleaning accident?

Then the vote of that UTXO containing a few million Bitcoins will remain forever fixed and unable to change according to whatever you believe would make us as a community decide to change the inflation rate.

If you enforce that only "recently-created" UTXOs get to vote, then in order for me to affect the vote (in the happy case where I do **not** lose all my privkeys in a tragic ear-cleaning accident), I would have to make a synthetic self-paying transaction.
How is it so different from me having to make up a synthetic transaction in order to pay fees and thus affect the current security of the blockchain?

--

It is helpful to remember that as a UTXO gets buried deeper, its security is inevitably better, and once I have a sufficient level of security in my ownership of the coin, I will not particularly care about any improved security and will not be interested in paying for more, hence why should I support any fork which makes me pay for my security continuously when I can simply support a fork that retains the current supply and does *not* make me pay for continued security?

--

If I want to *spend* my Bitcoins on something --- and nothing has value until I actually utilize it --- then I *will* pay transaction fees.
The receiver of the coin would want to ensure that the received UTXO is deeply buried to the point that it has sufficient security for the receiver, before releasing or providing me with whatever I am exchanging the coin for.

Thus, if I find that there are no miners at all, I could offer a high fee to get my transaction mined.
Of course, you might say that this only pays for one block.

But in most cases I will have more value remaining beyond what I spend to the receiver, i.e. I have a change output from that transaction.
In such a case, I can  pay for more blocks by re-spending the change output to myself, paying a transaction fee each time, until the original transaction that spends to the receiver is deeply buried and the receiver credits it and then releases the product or service I am exchanging *for*.
Alternately the receiver can do the same for its *own* UTXO, and will increase the payment it demands from me in order to perform this itself; thus I still end up paying for the security of the *transaction* and not the security of the *holding*.

So there is really no need for any mechanism beyond transaction fees.

Regards,
ZmnSCPxj

From bitcoin-dev at albert.sh  Thu Mar 26 03:55:50 2020
From: bitcoin-dev at albert.sh (Albert)
Date: Thu, 26 Mar 2020 11:55:50 +0800
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
Message-ID: <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>

Hi,

Great to see some work in this direction, here's some thoughts on your keygen scheme:

In the scenario where Owner1=Owner2, that is, one of the owners sends some coins to itself, that owner would get to know both x1*s1 and x2*s2=x2*s1*o2_inv*o1, and, because he already knows o1 and o2, that implies knowledge of both x1*s1 and x2*s1 where x1 and x2 are random numbers sampled from an uniform distribution. Once the owner has these two numbers, he can just sum these together to obtain s1*(x1+x2). 
Now, because of the central limit theorem, the distribution of x1+x2 should approximate a normal one, concretely an Irwin?Hall distribution, with that approximation getting better when more numbers are collected through iterations of the protocol. Once you've collected enough numbers to approximate a normal well enough (looking at Irwin Hall distribution graphs^[1] you can observe that with less than 10 samples the distribution is already pretty similar to a normal one), it should be possible to drastically reduce the search space and apply brute force to guess the value of \sum x and, consequently, s1.

Practically, it's possible that the search space is still too large for brute-force to be fruitful, so this attack might not work, but it shows that there is information leakage in every protocol iteration.

On another note, if you are not already aware of, something which might be worth looking into is the possibility of further trust-minimising the SE role by forcing it's code to be run inside an AWS oracle or a hardware isolated processor such as SGX.

Albert

[1] https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution

On Wed, Mar 25, 2020, at 9:52 PM, Tom Trevethan via bitcoin-dev wrote:
> Hi all,
> 
> We are starting to work on an implementation of the statechains concept (https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with particular interest in using the protocol enable the change of ownership (novation) of an individual position in an active discreet log contract (DLC) without an on-chain transaction, and without needing the cooperation of the counterparty. The protocol as outlined by Ruben requires features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it is uncertain when (or even if) this will be added. So we are looking at variants that would work with current Bitcoin functionality, and it would be good to get some feedback on them. 
> 
> There are two main modifications we are looking at: 
> 1. Instead of an eltoo-based backup/refund transaction (enabling the current owner to claim the UTXO in case the statechain entity disappears) we propose using a decrementing nLocktime for backup transactions as the output changes hands. Here, the first owner gets a backup transaction with an nLocktime at some future height (h0), then the next owner gets a backup transaction with nLocktime (h0-c) where c is a confirmation window. This approach has the downside of limiting the lifetime of the UTXO, but it also doesn't require the current owner to be always online. 
> 
> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key and transitory key) with a single P2(W)PKH output where the public key shared between the SE and the current owner. The SE and the current owner can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate their own private key share, and the SE changes their key share at each change of ownership (with the shared public key remaining the same). This works as follows (.G is EC point multiplication, * is scalar multiplication):
> 
> KeyGen:
> 
>  a. Owner 1 generates private key share o1 then calculates the corresponding public key of the share O1 and sends it to the SE: O1 = o1.G
>  b. The SE then generates a private key: s1 (the SE private key share), calculates the corresponding public key and sends it to Owner 1: S1 = s1.G
>  c. Both SE and Owner 1 then multiply the public keys they receive by their own private key shares to obtain the same shared public key P (which corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)
>  d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the address corresponding to P (but doesn't sign it). 
>  e. Once Owner 1 and SE cooperatively sign the first backup transaction, Owner 1 then signs and broadcasts the deposit transaction Tx0. 
> 
> Transfer from Owner 1 to Owner 2:
> 
>  a. Owner 2 generates two private keys: o2 (the new owner UTXO private key share) and b2 (the new owner refund private key).
>  b. The SE generates a temporary blinding nonce x and calculates the value x*s1 and sends this securely to Owner 2. 
>  c. Owner 2 then multiplies this received value by the modular inverse of o2 (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.
>  d. Owner 1 then multiplies this received value by the key share o1 and sends the resulting value (x*s1*o2_inv*o1) to the SE.
>  e. The SE then multiplies this received value by the modular inverse of the temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the new owner key share o2 equals the original shared private key s1*o1. 
>  f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1. s2 and o2 are now the key shares of `P` and can be used to colaboritively sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share (o1) is of no use in deriving or co-signing with the full shared private key, and is invalidated. 
>  g. The shared public key P remains unchanged, but the corresponding private key (which no individual party ever has knowledge of or can derive) can only be determined from the key shares of the SE and Owner 2 (i.e. P = s2*o2.G).
>  h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it to the SE.
>  i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to the address corresponding to B2 , with `nLockTime` set to a block height h0 - c0, where c0, is a confirmation time sufficient to guarantee that Tx2 can be confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).
>  j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using the 2P ECDSA protocol, which Owner 2 then saves. 
> 
> The principle of the logic of the key transfer is that the two separate key shares are updated, but the full shared private key (which no-one knows) remains the same. The new owner chooses a new secret value for their private key share, and this (along with the private key share of the previous owner) is utilized by the SE to update their share. The use of the nonce (x) prevents any of the participants from determining any information about each others secret keys. In this way Owner 2 cannot determine s1 from x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot determine o1 or o2 from x*s1*o2_inv*o1. 
> 
> This transfer protocol can be repeated to transfer the ownership to new owners. Each time the SE key share sX is updated, the previous key shares become invalid and are of no use even if the current key share is subsequently revealed. The SE still needs to be trusted to delete the old key share, but this protocol removes the risk the the SE can be hacked by a previous owner to steal the funds. 
> 
> Any comments on the above would be greatly appreciated. 
> 
> Tom
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/b32e6be2/attachment-0001.html>

From shum at canndrew.org  Mon Mar 23 12:59:22 2020
From: shum at canndrew.org (Andrew Cann)
Date: Mon, 23 Mar 2020 08:59:22 -0400
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
Message-ID: <20200323125922.GA29881@canndrew.org>

Hi, noob question here: Is there a long-term plan for if the block reward drops
too low to ensure the security of the network?

IIUC miners only make profit from block rewards and transaction fees, and once
the block reward drop to zero we're merely hoping that transaction fees will
keep mining expensive enough to stop a state actor or someone from buying
enough hash power to attack the network. If that's the case, should we start
making plans now to change the protocol to allow an adjustable block reward?

Here's a half-baked idea I had of how that could work: Since the block reward
dilutes the value of the currency bitcoin holders have an incentive to keep the
reward low. However, since the block reward is also (partly) what incentivizes
mining, bitcoin holders also have an incentive to keep the reward high enough
to keep the network secure. So if bitcoin holders were able to vote to decide
the block reward they "should", hypothetically, reliably choose a value that
balances these two concerns. You could implement this voting by adding an
optional extra field to every txout that signals what the holder thinks the
inflation rate should be. If the field is missing you just assume the default
value based on the current protocol. Then, whenever a new block is mined, you
take the median inflation rate of all the pre-existing utxos, weighted by the
utxo value, to calculate the block's reward.

Is this idea fundamentally broken somehow? Or are there already better ideas
for how to tackle this problem (I don't follow this list very closely)? Or is
this actually a non-issue to start with?

 - Andrew

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200323/fa0d5a7c/attachment.sig>

From shum at canndrew.org  Wed Mar 25 15:23:02 2020
From: shum at canndrew.org (Andrew Cann)
Date: Wed, 25 Mar 2020 11:23:02 -0400
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <C_qo1AhQuklVr4owEXVgLXsvJomb9Usd1NP2zf_D_23r6Cmz9-iB7ygSfNihJp3FIfAf4c1P41fT3qQP7SFiKdCfXxpogcstHsOnpgLgbok=@protonmail.com>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
 <20200323125922.GA29881@canndrew.org>
 <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>
 <C_qo1AhQuklVr4owEXVgLXsvJomb9Usd1NP2zf_D_23r6Cmz9-iB7ygSfNihJp3FIfAf4c1P41fT3qQP7SFiKdCfXxpogcstHsOnpgLgbok=@protonmail.com>
Message-ID: <20200325152302.GA3355@canndrew.org>

Hi, thanks for the replies.

> Anyway, yes, your idea is fundamentally broken because a zero block reward
> happens because creating even one more satoshi will push the amount of
> bitcoin over 21,000,0000, breaking the meaning of "bitcoin," or, if you
> like, creating a fundamental contradiction in our use of the term. 

I wouldn't really consider that fundamentally broken. It changes the meaning of
"bitcoin", but so does every upgrade to the protocol. The worst problem I can
see with this is that there's probably a lot of software out there which
assumes a cap of 21M. But we'd have years to find and fix those bugs.

> They already do so, via an implicit "field", known as the transaction fee.
> This makes the vote for how much security is needed to be costly to the
> voter, which is appropriate: you pay for your security.

This isn't the same thing though, economically / game-theoretically speaking.
Transaction fees are only paid when bitcoins get moved. There's no on-going
cost for people holding bitcoins (assuming they're doing their day-to-day
transactions almost entirely off-chain, which is something that's only going to
become more common). More to the point, the transaction fee is only set by the
current demand for block space. If transaction fees drop too low to maintain a
secure hash rate then people *could* willingly pay more than they need to to
get their transactions mined, but it's unlikely they will since it'd be cheaper
to just pay the minimum and hope that everyone else covers the costs of keeping
the network secure for them.

With the voting idea everyone decides what everyone pays (via dilution) to keep
the network secure. Choosing to signal a high inflation rate doesn't mean you
pay more than everyone else, just that you might shift the median, so there's
no tragedy-of-the-commons problem. Also, votes are weighted by the value of
the utxo, so people both vote and pay in proportion to the amount of bitcoin
they're holding.

Does this make sense? Or is there some game-theoretic reason I'm not seeing for
why transaction fees can never drop dangerously low in the first place?

 - Andrew

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200325/20997ba7/attachment.sig>

From rsomsen at gmail.com  Thu Mar 26 12:36:20 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Thu, 26 Mar 2020 13:36:20 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
Message-ID: <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>

Hi Tom,

Nice to see you working on this.

Regarding modification 1, I agree with ZmnSCPxj that Decker-Wattenhofer is
your next best option, given that eltoo is not yet available. But if you
are going to use a kickoff transaction, keep in mind that every previous
owner will have a copy of it. Because of this, you can't include a fee, and
will instead need to have a second output for CPFP. This way a previous
owner will at least have to pay the fee if they want to publish it. Note
that it's still an improvement, because even if the kickoff transaction
gets posted, it basically becomes no different than what it would have
been, had you not used a kickoff transaction at all.

Regarding modification 2, I like it a lot conceptually. It hadn't occurred
to me before, and it's a clear security improvement. The only question is
something Greg Sanders mentioned: whether it's enough to justify the added
complexity of using 2P ECDSA. The alternative would be to simply use a
regular 2-of-2 multisig (until Schnorr arrives, possibly).

I'm looking forward to seeing statechains become a reality.

Cheers,
Ruben

On Thu, Mar 26, 2020 at 5:20 AM Albert via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi,
>
> Great to see some work in this direction, here's some thoughts on your
> keygen scheme:
>
> In the scenario where Owner1=Owner2, that is, one of the owners sends some
> coins to itself, that owner would get to know both x1*s1 and
> x2*s2=x2*s1*o2_inv*o1, and, because he already knows o1 and o2, that
> implies knowledge of both x1*s1 and x2*s1 where x1 and x2 are random
> numbers sampled from an uniform distribution. Once the owner has these two
> numbers, he can just sum these together to obtain s1*(x1+x2).
> Now, because of the central limit theorem, the distribution of x1+x2
> should approximate a normal one, concretely an Irwin?Hall distribution,
> with that approximation getting better when more numbers are collected
> through iterations of the protocol. Once you've collected enough numbers to
> approximate a normal well enough (looking at Irwin Hall distribution
> graphs^[1] you can observe that with less than 10 samples the distribution
> is already pretty similar to a normal one), it should be possible to
> drastically reduce the search space and apply brute force to guess the
> value of \sum x and, consequently, s1.
>
> Practically, it's possible that the search space is still too large for
> brute-force to be fruitful, so this attack might not work, but it shows
> that there is information leakage in every protocol iteration.
>
> On another note, if you are not already aware of, something which might be
> worth looking into is the possibility of further trust-minimising the SE
> role by forcing it's code to be run inside an AWS oracle or a hardware
> isolated processor such as SGX.
>
> Albert
>
> [1] https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution
>
> On Wed, Mar 25, 2020, at 9:52 PM, Tom Trevethan via bitcoin-dev wrote:
>
> Hi all,
>
> We are starting to work on an implementation of the statechains concept (
> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),
> with particular interest in using the protocol enable the change of
> ownership (novation) of an individual position in an active discreet log
> contract (DLC) without an on-chain transaction, and without needing the
> cooperation of the counterparty. The protocol as outlined by Ruben requires
> features not currently available in Bitcoin (like SIGHASH_NOINPUT), and it
> is uncertain when (or even if) this will be added. So we are looking at
> variants that would work with current Bitcoin functionality, and it would
> be good to get some feedback on them.
>
> There are two main modifications we are looking at:
> 1. Instead of an eltoo-based backup/refund transaction (enabling the
> current owner to claim the UTXO in case the statechain entity disappears)
> we propose using a decrementing nLocktime for backup transactions as the
> output changes hands. Here, the first owner gets a backup transaction with
> an nLocktime at some future height (h0), then the next owner gets a backup
> transaction with nLocktime (h0-c) where c is a confirmation window. This
> approach has the downside of limiting the lifetime of the UTXO, but it also
> doesn't require the current owner to be always online.
>
> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE
> key and transitory key) with a single P2(W)PKH output where the public key
> shared between the SE and the current owner. The SE and the current owner
> can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate
> their own private key share, and the SE changes their key share at each
> change of ownership (with the shared public key remaining the same). This
> works as follows (.G is EC point multiplication, * is scalar
> multiplication):
>
> KeyGen:
>
> a. Owner 1 generates private key share o1 then calculates the
> corresponding public key of the share O1 and sends it to the SE: O1 = o1.G
> b. The SE then generates a private key: s1 (the SE private key share),
> calculates the corresponding public key and sends it to Owner 1: S1 = s1.G
> c. Both SE and Owner 1 then multiply the public keys they receive by their
> own private key shares to obtain the same shared public key P (which
> corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)
> d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the
> address corresponding to P (but doesn't sign it).
> e. Once Owner 1 and SE cooperatively sign the first backup transaction,
> Owner 1 then signs and broadcasts the deposit transaction Tx0.
>
> Transfer from Owner 1 to Owner 2:
>
> a. Owner 2 generates two private keys: o2 (the new owner UTXO private key
> share) and b2 (the new owner refund private key).
> b. The SE generates a temporary blinding nonce x and calculates the value
> x*s1 and sends this securely to Owner 2.
> c. Owner 2 then multiplies this received value by the modular inverse of
> o2 (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.
> d. Owner 1 then multiplies this received value by the key share o1 and
> sends the resulting value (x*s1*o2_inv*o1) to the SE.
> e. The SE then multiplies this received value by the modular inverse of
> the temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels
> the blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by
> the new owner key share o2 equals the original shared private key s1*o1.
> f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1.
> s2 and o2 are now the key shares of `P` and can be used to colaboritively
> sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share
> (o1) is of no use in deriving or co-signing with the full shared private
> key, and is invalidated.
> g. The shared public key P remains unchanged, but the corresponding
> private key (which no individual party ever has knowledge of or can derive)
> can only be determined from the key shares of the SE and Owner 2 (i.e. P =
> s2*o2.G).
> h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends
> it to the SE.
> i. The SE creates a backup transaction (Tx2) that pays the output of Tx0
> to the address corresponding to B2 , with `nLockTime` set to a block height
> h0 - c0, where c0, is a confirmation time sufficient to guarantee that Tx2
> can be confirmed in the blockchain before Tx1 (therefore making Tx1
> invalid).
> j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using
> the 2P ECDSA protocol, which Owner 2 then saves.
>
> The principle of the logic of the key transfer is that the two separate
> key shares are updated, but the full shared private key (which no-one
> knows) remains the same. The new owner chooses a new secret value for their
> private key share, and this (along with the private key share of the
> previous owner) is utilized by the SE to update their share. The use of the
> nonce (x) prevents any of the participants from determining any information
> about each others secret keys. In this way Owner 2 cannot determine s1 from
> x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot
> determine o1 or o2 from x*s1*o2_inv*o1.
>
> This transfer protocol can be repeated to transfer the ownership to new
> owners. Each time the SE key share sX is updated, the previous key shares
> become invalid and are of no use even if the current key share is
> subsequently revealed. The SE still needs to be trusted to delete the old
> key share, but this protocol removes the risk the the SE can be hacked by a
> previous owner to steal the funds.
>
> Any comments on the above would be greatly appreciated.
>
> Tom
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/0a5f4fef/attachment.html>

From bob at mcelrath.org  Thu Mar 26 14:52:36 2020
From: bob at mcelrath.org (Bob McElrath)
Date: Thu, 26 Mar 2020 14:52:36 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
Message-ID: <20200326145236.GK28113@mcelrath.org>

Very good point, but I think this is easy to fix.

It's not actually necessary that the quantity in (b) involve the SE's secret key
s1. It can be purely the blinding factor. This quantity gets relayed through the
SE anyway, after a round trip through owner 2, where the SE removes the blinding
nonce. The SE needs to determine the ratio of the two private keys o1*o2_inv.
There's no reason for the SE to send anything about s1 other than the public
keys S1=s1.G and S2=s2.G, keeping the secret keys s1 and s2 hidden behind ECDLP
and not sharing quantities involving them in Z_p.

Thus:
b. (SE) x -> (2)
c. (2) o2_inv*x -> (1) 
d. (1) o1*(o2_inv*x) -> (SE)
e. (SE) s2 = x_inv*(o1*o2_inv*x)*s1 = o1*o2_inv*s1
        s2.G -> (2)
f. (2) o2.s2.G = o1.s1.G = P

Now we could have had a different problem, in step (e) if the SE sends owner 2
the quantity o1*o2_inv*s1, a self-sending owner can determine a similar quantity
to what you described (x1+x2)*s1: (o1*o2_inv + o2*o3_inv)*s1 and we're back to
an Irwin-Hall distribution.

It's not necessary to send a quantity involving s1 in steps (b-e). Owner 2
already has his private key o2 and the SE has his new private key
s2=o1*o2_inv*s1. Since P=o1.s1.G=o2.s2.G we're set up for o2 to transfer the
funds, but it's necessary to prove to (2) that his o2 does in fact control the
UTXO. This can be done by sending (2) the public key S2=s2.G which he can
multiply by o2 to get P=o2.s2.G and verify that the SE does have the correct
private key corresponding to his o2 for the public key P recorded on-chain.

Thus in the self-send situation, the owner no longer has any algebraic relations
he can use as you describe.

Algebraic relations remain in step (d) that a self-sending owner could use, but
they all involve his own private keys, which he knows anyway. He has only one
relation from the previous owner and all subsequent relations do not involve
that owner. However if a pair of entities send funds back and forth, each owner
could collect a sum as you describe, if the counterparty (2) re-uses keys:
    o2_inv*(x1 + x2)
The SE has similar relations in step (e) if there's key reuse.  Therefore it's
important that on each transfer, you generate a new key and do not re-use keys.
A responsible SE could detect a key-reuse situation by e.g.  recording old
pubkeys P1, P2 even though he deleted s1 and s2, and inform the user of the
key-reuse error and abort.

Do you think that works?

P.S. SGX is not "trust minimization", it's "trust transfer" -- specifically to
the keys managing the SGX. If we thought processor manufacturers were better at
key management than the rest of us, we should just hand them the task. I don't
think that's the case, and I don't think anyone else does either. An SGX
attestation as an optional add-on I think is a worthwhile enhancement, as long
as it's not on the critical path of the protocol.

Albert via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:
> Hi,
> 
> Great to see some work in this direction, here's some thoughts on your keygen
> scheme:
> 
> In the scenario where Owner1=Owner2, that is, one of the owners sends some
> coins to itself, that owner would get to know both x1*s1 and x2*s2=
> x2*s1*o2_inv*o1, and, because he already knows o1 and o2, that implies
> knowledge of both x1*s1 and x2*s1 where x1 and x2 are random numbers sampled
> from an uniform distribution. Once the owner has these two numbers, he can just
> sum these together to obtain s1*(x1+x2).
> Now, because of the central limit theorem, the distribution of x1+x2 should
> approximate a normal one, concretely an Irwin?Hall distribution, with that
> approximation getting better when more numbers are collected through iterations
> of the protocol. Once you've collected enough numbers to approximate a normal
> well enough (looking at Irwin Hall distribution graphs^[1] you can observe that
> with less than 10 samples the distribution is already pretty similar to a
> normal one), it should be possible to drastically reduce the search space and
> apply brute force to guess the value of \sum x and, consequently, s1.
> 
> Practically, it's possible that the search space is still too large for
> brute-force to be fruitful, so this attack might not work, but it shows that
> there is information leakage in every protocol iteration.
> 
> On another note, if you are not already aware of, something which might be
> worth looking into is the possibility of further trust-minimising the SE role
> by forcing it's code to be run inside an AWS oracle or a hardware isolated
> processor such as SGX.
> 
> Albert
> 
> [1] https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution
> 
> On Wed, Mar 25, 2020, at 9:52 PM, Tom Trevethan via bitcoin-dev wrote:
> 
>     Hi all,
> 
>     We are starting to work on an implementation of the statechains concept (
>     https://medium.com/@RubenSomsen/
>     statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with
>     particular interest in using the protocol enable the change of ownership
>     (novation) of an individual position in an active discreet log contract
>     (DLC) without an on-chain transaction, and without needing the cooperation
>     of the counterparty. The protocol as outlined by Ruben requires features
>     not currently available in Bitcoin (like SIGHASH_NOINPUT), and it is
>     uncertain when (or even if) this will be added. So we are looking at
>     variants that would work with current Bitcoin functionality, and it would
>     be good to get some feedback on them.
> 
>     There are two main modifications we are looking at:
>     1. Instead of an eltoo-based backup/refund transaction (enabling the
>     current owner to claim the UTXO in case the statechain entity disappears)
>     we propose using a decrementing nLocktime for backup transactions as the
>     output changes hands. Here, the first owner gets a backup transaction with
>     an nLocktime at some future height (h0), then the next owner gets a backup
>     transaction with nLocktime (h0-c) where c is a confirmation window. This
>     approach has the downside of limiting the lifetime of the UTXO, but it also
>     doesn't require the current owner to be always online.
> 
>     2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key
>     and transitory key) with a single P2(W)PKH output where the public key
>     shared between the SE and the current owner. The SE and the current owner
>     can then sign with a 2-of-2 ECDSA MPC. This enables each owner to generate
>     their own private key share, and the SE changes their key share at each
>     change of ownership (with the shared public key remaining the same). This
>     works as follows (.G is EC point multiplication, * is scalar
>     multiplication):
> 
>     KeyGen:
> 
>     a. Owner 1 generates private key share o1 then calculates the corresponding
>     public key of the share O1 and sends it to the SE: O1 = o1.G
>     b. The SE then generates a private key: s1 (the SE private key share),
>     calculates the corresponding public key and sends it to Owner 1: S1 = s1.G
>     c. Both SE and Owner 1 then multiply the public keys they receive by their
>     own private key shares to obtain the same shared public key P (which
>     corresponds to a shared private key of p = o1*s1): P = o1.(s1.G) = s1.
>     (o1.G)
>     d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the
>     address corresponding to P (but doesn't sign it).
>     e. Once Owner 1 and SE cooperatively sign the first backup transaction,
>     Owner 1 then signs and broadcasts the deposit transaction Tx0.
> 
>     Transfer from Owner 1 to Owner 2:
> 
>     a. Owner 2 generates two private keys: o2 (the new owner UTXO private key
>     share) and b2 (the new owner refund private key).
>     b. The SE generates a temporary blinding nonce x and calculates the value
>     x*s1 and sends this securely to Owner 2.
>     c. Owner 2 then multiplies this received value by the modular inverse of o2
>     (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.
>     d. Owner 1 then multiplies this received value by the key share o1 and
>     sends the resulting value (x*s1*o2_inv*o1) to the SE.
>     e. The SE then multiplies this received value by the modular inverse of the
>     temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the
>     blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the
>     new owner key share o2 equals the original shared private key s1*o1.
>     f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1.
>     s2 and o2 are now the key shares of `P` and can be used to colaboritively
>     sign (with 2P ECDSA). So long as the SE delets s1, the old owner key share
>     (o1) is of no use in deriving or co-signing with the full shared private
>     key, and is invalidated.
>     g. The shared public key P remains unchanged, but the corresponding private
>     key (which no individual party ever has knowledge of or can derive) can
>     only be determined from the key shares of the SE and Owner 2 (i.e. P =
>     s2*o2.G).
>     h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it
>     to the SE.
>     i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to
>     the address corresponding to B2 , with `nLockTime` set to a block height h0
>     - c0, where c0, is a confirmation time sufficient to guarantee that Tx2 can
>     be confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).
>     j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using
>     the 2P ECDSA protocol, which Owner 2 then saves.
> 
>     The principle of the logic of the key transfer is that the two separate key
>     shares are updated, but the full shared private key (which no-one knows)
>     remains the same. The new owner chooses a new secret value for their
>     private key share, and this (along with the private key share of the
>     previous owner) is utilized by the SE to update their share. The use of the
>     nonce (x) prevents any of the participants from determining any information
>     about each others secret keys. In this way Owner 2 cannot determine s1 from
>     x*s1, Owner 1 cannot determine s1 or o2 from x*s1*o2_inv and the SE cannot
>     determine o1 or o2 from x*s1*o2_inv*o1.
> 
>     This transfer protocol can be repeated to transfer the ownership to new
>     owners. Each time the SE key share sX is updated, the previous key shares
>     become invalid and are of no use even if the current key share is
>     subsequently revealed. The SE still needs to be trusted to delete the old
>     key share, but this protocol removes the risk the the SE can be hacked by a
>     previous owner to steal the funds.
> 
>     Any comments on the above would be greatly appreciated.
> 
>     Tom
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> 
> !DSPAM:5e7c2da240641930319229!

> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> !DSPAM:5e7c2da240641930319229!

--
Cheers, Bob McElrath

"For every complex problem, there is a solution that is simple, neat, and wrong."
    -- H. L. Mencken 


From decker.christian at gmail.com  Thu Mar 26 17:12:44 2020
From: decker.christian at gmail.com (Christian Decker)
Date: Thu, 26 Mar 2020 18:12:44 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
Message-ID: <87369v6nw3.fsf@gmail.com>

Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:
> Regarding modification 1, I agree with ZmnSCPxj that
> Decker-Wattenhofer is your next best option, given that eltoo is not
> yet available. But if you are going to use a kickoff transaction, keep
> in mind that every previous owner will have a copy of it. Because of
> this, you can't include a fee, and will instead need to have a second
> output for CPFP. This way a previous owner will at least have to pay
> the fee if they want to publish it. Note that it's still an
> improvement, because even if the kickoff transaction gets posted, it
> basically becomes no different than what it would have been, had you
> not used a kickoff transaction at all.

It might be worth adopting the late fee binding we have in eltoo by
having the kickoff transaction input spending the funding tx signed with
sighash_single. This works because we only have 1 input and 1 output
that we really care about, and can allow others to attach fees at
will. That'd at least remove the need to guess the feerate days or
months in advance and thus having to overestimate.  

> Regarding modification 2, I like it a lot conceptually. It hadn't
> occurred to me before, and it's a clear security improvement. The only
> question is something Greg Sanders mentioned: whether it's enough to
> justify the added complexity of using 2P ECDSA. The alternative would
> be to simply use a regular 2-of-2 multisig (until Schnorr arrives,
> possibly).

Wouldn't that result in a changing pubkey at each update, and thus
require an onchain move to be committed?

> I'm looking forward to seeing statechains become a reality.

That'd indeed be great :-)

Cheers,
Christian

From gsanders87 at gmail.com  Thu Mar 26 17:17:13 2020
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 26 Mar 2020 13:17:13 -0400
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <87369v6nw3.fsf@gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
 <87369v6nw3.fsf@gmail.com>
Message-ID: <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>

> Wouldn't that result in a changing pubkey at each update, and thus
require an onchain move to be committed?

Suggestion was in line with original proposal where no keys are changing
ever, just not presupposing existence of MuSig.

On Thu, Mar 26, 2020 at 1:15 PM Christian Decker via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> writes:
> > Regarding modification 1, I agree with ZmnSCPxj that
> > Decker-Wattenhofer is your next best option, given that eltoo is not
> > yet available. But if you are going to use a kickoff transaction, keep
> > in mind that every previous owner will have a copy of it. Because of
> > this, you can't include a fee, and will instead need to have a second
> > output for CPFP. This way a previous owner will at least have to pay
> > the fee if they want to publish it. Note that it's still an
> > improvement, because even if the kickoff transaction gets posted, it
> > basically becomes no different than what it would have been, had you
> > not used a kickoff transaction at all.
>
> It might be worth adopting the late fee binding we have in eltoo by
> having the kickoff transaction input spending the funding tx signed with
> sighash_single. This works because we only have 1 input and 1 output
> that we really care about, and can allow others to attach fees at
> will. That'd at least remove the need to guess the feerate days or
> months in advance and thus having to overestimate.
>
> > Regarding modification 2, I like it a lot conceptually. It hadn't
> > occurred to me before, and it's a clear security improvement. The only
> > question is something Greg Sanders mentioned: whether it's enough to
> > justify the added complexity of using 2P ECDSA. The alternative would
> > be to simply use a regular 2-of-2 multisig (until Schnorr arrives,
> > possibly).
>
> Wouldn't that result in a changing pubkey at each update, and thus
> require an onchain move to be committed?
>
> > I'm looking forward to seeing statechains become a reality.
>
> That'd indeed be great :-)
>
> Cheers,
> Christian
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/7b38acf0/attachment.html>

From rsomsen at gmail.com  Thu Mar 26 18:53:13 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Thu, 26 Mar 2020 19:53:13 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
 <87369v6nw3.fsf@gmail.com>
 <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>
Message-ID: <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>

Hey Christian,

Thanks for chiming in :)

>It might be worth adopting the late fee binding we have in eltoo

That is where my thinking originally went as well, but then I remembered
that this alters the txid, causing the settlement tx to become invalid.
What I am suggesting should be functionally the same (albeit less
space-efficient): a secondary output that can be spent by anyone, which can
be used to fee bump the kickoff tx with CPFP. I believe this same idea was
considered for Lightning as well at some point. Do you happen to recall if
there was some kind of non-standardness issue with it?

>Wouldn't that result in a changing pubkey at each update, and thus require
an onchain move to be committed?

I have yet to take a closer look at the math, but my understanding is that
the same key (x) gets redistributed. First x = s1 + o1 and after the
transfer x = s2 + o2 (not the actual math, but it demonstrates how the
transitory key can change from o1 to o2). Assuming s1 is then thrown away
(trust assumption), o1 becomes harmless information.

Cheers,
Ruben

On Thu, Mar 26, 2020 at 6:17 PM Greg Sanders <gsanders87 at gmail.com> wrote:

> > Wouldn't that result in a changing pubkey at each update, and thus
> require an onchain move to be committed?
>
> Suggestion was in line with original proposal where no keys are changing
> ever, just not presupposing existence of MuSig.
>
> On Thu, Mar 26, 2020 at 1:15 PM Christian Decker via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Ruben Somsen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>> writes:
>> > Regarding modification 1, I agree with ZmnSCPxj that
>> > Decker-Wattenhofer is your next best option, given that eltoo is not
>> > yet available. But if you are going to use a kickoff transaction, keep
>> > in mind that every previous owner will have a copy of it. Because of
>> > this, you can't include a fee, and will instead need to have a second
>> > output for CPFP. This way a previous owner will at least have to pay
>> > the fee if they want to publish it. Note that it's still an
>> > improvement, because even if the kickoff transaction gets posted, it
>> > basically becomes no different than what it would have been, had you
>> > not used a kickoff transaction at all.
>>
>> It might be worth adopting the late fee binding we have in eltoo by
>> having the kickoff transaction input spending the funding tx signed with
>> sighash_single. This works because we only have 1 input and 1 output
>> that we really care about, and can allow others to attach fees at
>> will. That'd at least remove the need to guess the feerate days or
>> months in advance and thus having to overestimate.
>>
>> > Regarding modification 2, I like it a lot conceptually. It hadn't
>> > occurred to me before, and it's a clear security improvement. The only
>> > question is something Greg Sanders mentioned: whether it's enough to
>> > justify the added complexity of using 2P ECDSA. The alternative would
>> > be to simply use a regular 2-of-2 multisig (until Schnorr arrives,
>> > possibly).
>>
>> Wouldn't that result in a changing pubkey at each update, and thus
>> require an onchain move to be committed?
>>
>> > I'm looking forward to seeing statechains become a reality.
>>
>> That'd indeed be great :-)
>>
>> Cheers,
>> Christian
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200326/c5056e1f/attachment.html>

From ZmnSCPxj at protonmail.com  Fri Mar 27 01:46:15 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 27 Mar 2020 01:46:15 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
 <87369v6nw3.fsf@gmail.com>
 <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>
 <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>
Message-ID: <j37G_ywUw4UA7J2iEXurAk8Vq-QA3toUz3sakqEiYHqbpqF1DEK0riorbuZW_UkMCkNS-KKCDNPec7ogpchdg8hYPjPh_gzAGwfbY72e_p4=@protonmail.com>

Good morning Ruben,

> Hey Christian,
>
> Thanks for chiming in :)
>
> >It might be worth adopting the late fee binding we have in eltoo
>
> That is where my thinking originally went as well, but then I remembered that this alters the txid, causing the settlement tx to become invalid. What I am suggesting should be functionally the same (albeit less space-efficient): a secondary output that can be spent by anyone, which can be used to fee bump the kickoff tx with CPFP. I believe this same idea was considered for Lightning as well at some point. Do you happen to recall if there was some kind of non-standardness issue with it?

Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you can use an `OP_TRUE` `redeemScript`, for instance.

Using an `OP_TRUE` `redeemScript` would allow any third party to make you cry by opportunistically spending such an output.
For example your Bitcoin-network peer could notice you broadcasting such a transaction with an `OP_TRUE` output, see you spend that output with a CPFP-RBF-ed child transaction, then instead of further broadcasting the child transaction, instead broadcast a non-RBF child transaction with tiny fee, so that it and its parent transaction will be accepted into mempools but would not be replaceable with a higher-feerate child transaction (because not RBF-flagged).
Thus, some portion of mempools will contain this poisoned low-fee child transaction and prevent the parent from being confirmed (because the parent+child fees are not enough to justify being put in a block).
Which I suppose is an argument for Full RBF aka ignore-the-RBF-flag-and-always-RBF.

The solution that I remember being proposed for this in Lightning was to give each participant its own attach-your-fees output that only that participant can spend, which works for Lightning because the set of participants in a channel is permanently fixed, but probably not for statechains.

--

The broadcasting of the kickoff simply means that the first stage cannot be easily changed, and you might still be able to make further updates by updating only the later stages, until the last stage is confirmable, so the kickoff being broadcast simply creates a "dead man walking" statechain.
However, the implementation complexity would probably increase tremendously.


Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Fri Mar 27 01:46:15 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Fri, 27 Mar 2020 01:46:15 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
 <87369v6nw3.fsf@gmail.com>
 <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>
 <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>
Message-ID: <j37G_ywUw4UA7J2iEXurAk8Vq-QA3toUz3sakqEiYHqbpqF1DEK0riorbuZW_UkMCkNS-KKCDNPec7ogpchdg8hYPjPh_gzAGwfbY72e_p4=@protonmail.com>

Good morning Ruben,

> Hey Christian,
>
> Thanks for chiming in :)
>
> >It might be worth adopting the late fee binding we have in eltoo
>
> That is where my thinking originally went as well, but then I remembered that this alters the txid, causing the settlement tx to become invalid. What I am suggesting should be functionally the same (albeit less space-efficient): a secondary output that can be spent by anyone, which can be used to fee bump the kickoff tx with CPFP. I believe this same idea was considered for Lightning as well at some point. Do you happen to recall if there was some kind of non-standardness issue with it?

Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you can use an `OP_TRUE` `redeemScript`, for instance.

Using an `OP_TRUE` `redeemScript` would allow any third party to make you cry by opportunistically spending such an output.
For example your Bitcoin-network peer could notice you broadcasting such a transaction with an `OP_TRUE` output, see you spend that output with a CPFP-RBF-ed child transaction, then instead of further broadcasting the child transaction, instead broadcast a non-RBF child transaction with tiny fee, so that it and its parent transaction will be accepted into mempools but would not be replaceable with a higher-feerate child transaction (because not RBF-flagged).
Thus, some portion of mempools will contain this poisoned low-fee child transaction and prevent the parent from being confirmed (because the parent+child fees are not enough to justify being put in a block).
Which I suppose is an argument for Full RBF aka ignore-the-RBF-flag-and-always-RBF.

The solution that I remember being proposed for this in Lightning was to give each participant its own attach-your-fees output that only that participant can spend, which works for Lightning because the set of participants in a channel is permanently fixed, but probably not for statechains.

--

The broadcasting of the kickoff simply means that the first stage cannot be easily changed, and you might still be able to make further updates by updating only the later stages, until the last stage is confirmable, so the kickoff being broadcast simply creates a "dead man walking" statechain.
However, the implementation complexity would probably increase tremendously.


Regards,
ZmnSCPxj

From shum at canndrew.org  Fri Mar 27 09:17:34 2020
From: shum at canndrew.org (Andrew Cann)
Date: Fri, 27 Mar 2020 05:17:34 -0400
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <v1t2DhGSHFng23jy0XTRkoVJrhA_6x_QuHFWdrcxQnMS8Sdcbe7eksRtvjf6JCb8YLoHf2W5y29j3XbBIVfDALSBjoiMqxPUWKsQyGLOR_A=@protonmail.com>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
 <20200323125922.GA29881@canndrew.org>
 <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>
 <C_qo1AhQuklVr4owEXVgLXsvJomb9Usd1NP2zf_D_23r6Cmz9-iB7ygSfNihJp3FIfAf4c1P41fT3qQP7SFiKdCfXxpogcstHsOnpgLgbok=@protonmail.com>
 <20200325152302.GA3355@canndrew.org>
 <v1t2DhGSHFng23jy0XTRkoVJrhA_6x_QuHFWdrcxQnMS8Sdcbe7eksRtvjf6JCb8YLoHf2W5y29j3XbBIVfDALSBjoiMqxPUWKsQyGLOR_A=@protonmail.com>
Message-ID: <20200327091734.GA6531@canndrew.org>

> To change the supply is far too big a change.

It would also be a big change if bitcoin became unusable due to mining profits
dropping low enough for a state actor with a warehouse full of asics to mount a
51% attack and mine empty blocks all day.

> What happens if I own a few million Bitcoin and then accidentally lose my
> private keys in a tragic ear-cleaning accident?
> Then the vote of that UTXO containing a few million Bitcoins will remain
> forever fixed and unable to change according to whatever you believe would
> make us as a community decide to change the inflation rate.

All that matters is whether the long-term rate of deflation due to lost coins
is less or greater than the rate of inflation. This determines whether the
proportion of coins whose signaled inflation rate is fixed in time would tend
towards zero or one. I think it's /fairly/ safe to assume that it would remain
less. People obviously have a pretty strong incentive to not lose their coins -
particularly people who are holding massive amounts of bitcoin - and as bitcoin
becomes more mainstream, regular users will necessarily be using forms of
protection against losing their coins (whatever they might be). Contrast this
against the inflation rate which should remain high enough to prevent very
wealthy entities from being able to mount a 51% attack. What proportion of the
total market cap of bitcoin do you think your least favorite government could
plausibly be willing to spend to take down bitcoin for a month? And do you
think it's less or greater than the proportion of all bitcoins that get lost in
a month?

> It is helpful to remember that as a UTXO gets buried deeper, its security is
> inevitably better, and once I have a sufficient level of security in my
> ownership of the coin, I will not particularly care about any improved
> security and will not be interested in paying for more.

If we're talking about the possibility of your coin becoming worthless because
someone out there can unwind transactions at will and prevent you from spending
it then you should definitely be interested.

> If I want to *spend* my Bitcoins on something --- and nothing has value until
> I actually utilize it --- then I *will* pay transaction fees. The receiver of
> the coin would want to ensure that the received UTXO is deeply buried to the
> point that it has sufficient security for the receiver, before releasing or
> providing me with whatever I am exchanging the coin for.
>
> Thus, if I find that there are no miners at all, I could offer a high fee to
> get my transaction mined. Of course, you might say that this only pays for
> one block.
>
> But in most cases I will have more value remaining beyond what I spend to the
> receiver, i.e. I have a change output from that transaction.
>
> In such a case, I can  pay for more blocks by re-spending the change output
> to myself, paying a transaction fee each time, until the original transaction
> that spends to the receiver is deeply buried and the receiver credits it and
> then releases the product or service I am exchanging *for*. Alternately the
> receiver can do the same for its *own* UTXO, and will increase the payment it
> demands from me in order to perform this itself; thus I still end up paying
> for the security of the *transaction* and not the security of the *holding*.

In your example though it's just you or the receiver paying for blocks. In that
case you're only paying for your own security and so there's no tragedy of the
commons and the system works. But once you have a thousand people putting
transactions in every block and everyone is collectively paying for everyone's
collective security then, without some mechanism to force everyone to pay their
fair share, you're inviting Moloch to the party.

Here's a better explanation than I could write of the phenomenon I'm talking
about:

> As a thought experiment, let?s consider aquaculture (fish farming) in a lake.
> Imagine a lake with a thousand identical fish farms owned by a thousand
> competing companies. Each fish farm earns a profit of $1000/month. For a
> while, all is well.
> 
> But each fish farm produces waste, which fouls the water in the lake. Let?s
> say each fish farm produces enough pollution to lower productivity in the
> lake by $1/month.
> 
> A thousand fish farms produce enough waste to lower productivity by
> $1000/month, meaning none of the fish farms are making any money. Capitalism
> to the rescue: someone invents a complex filtering system that removes waste
> products. It costs $300/month to operate. All fish farms voluntarily install
> it, the pollution ends, and the fish farms are now making a profit of
> $700/month ? still a respectable sum.
> 
> But one farmer (let?s call him Steve) gets tired of spending the money to
> operate his filter. Now one fish farm worth of waste is polluting the lake,
> lowering productivity by $1. Steve earns $999 profit, and everyone else earns
> $699 profit.
> 
> Everyone else sees Steve is much more profitable than they are, because he?s
> not spending the maintenance costs on his filter. They disconnect their
> filters too.
> 
> Once four hundred people disconnect their filters, Steve is earning
> $600/month ? less than he would be if he and everyone else had kept their
> filters on! And the poor virtuous filter users are only making $300. Steve
> goes around to everyone, saying ?Wait! We all need to make a voluntary pact
> to use filters! Otherwise, everyone?s productivity goes down.?
> 
> Everyone agrees with him, and they all sign the Filter Pact, except one
> person who is sort of a jerk. Let?s call him Mike. Now everyone is back using
> filters again, except Mike. Mike earns $999/month, and everyone else earns
> $699/month. Slowly, people start thinking they too should be getting big
> bucks like Mike, and disconnect their filter for $300 extra profit?
> 
> A self-interested person never has any incentive to use a filter. A
> self-interested person has some incentive to sign a pact to make everyone use
> a filter, but in many cases has a stronger incentive to wait for everyone
> else to sign such a pact but opt out himself. This can lead to an undesirable
> equilibrium in which no one will sign such a pact.

Won't a thousand bitcoin-spenders, individually paying for their transactions
but collectively paying for their security, end up falling into the same
dynamic?

 - Andrew

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200327/e6afc842/attachment.sig>

From rsomsen at gmail.com  Fri Mar 27 15:12:33 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 27 Mar 2020 16:12:33 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <j37G_ywUw4UA7J2iEXurAk8Vq-QA3toUz3sakqEiYHqbpqF1DEK0riorbuZW_UkMCkNS-KKCDNPec7ogpchdg8hYPjPh_gzAGwfbY72e_p4=@protonmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
 <87369v6nw3.fsf@gmail.com>
 <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>
 <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>
 <j37G_ywUw4UA7J2iEXurAk8Vq-QA3toUz3sakqEiYHqbpqF1DEK0riorbuZW_UkMCkNS-KKCDNPec7ogpchdg8hYPjPh_gzAGwfbY72e_p4=@protonmail.com>
Message-ID: <CAPv7TjbQ1WLxDJdufTwYttXz0asdBjAcCTDiMcdvm8xfdUv6=g@mail.gmail.com>

Hi ZmnSCPxj,

I appreciate the input.

>Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you
can use an `OP_TRUE` `redeemScript`, for instance.

Good point. I guess the conversation I recall reading must have been about
avoiding p2sh in order to lower the tx size.

>broadcast a non-RBF child transaction with tiny fee, so that it and its
parent transaction will be accepted into mempools but would not be
replaceable

I believe this is solved by inherited signalling. As long as the kickoff tx
is RBF enabled (and unconfirmed), any transaction spending it automatically
inherits its RBF status. See:
https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki#Summary

>The broadcasting of the kickoff simply means that the first stage cannot
be easily changed

I see what you're saying. Yeah, it does ruin the stages. If the kickoff tx
hits the chain, you'd probably just want to "refresh" the UTXO by agreeing
with the statechain entity to spend it to a new statechain 2-of-2 UTXO
on-chain, thus removing all prior owners. Ideally you'd want it to be more
costly to CPFP the kickoff tx than it is to refresh the UTXO, so the
defender is at an advantage. The statechain entity should probably pay for
every refresh ("insurance"), since the actual owner isn't at fault.

Cheers,
Ruben


On Fri, Mar 27, 2020 at 2:46 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Ruben,
>
> > Hey Christian,
> >
> > Thanks for chiming in :)
> >
> > >It might be worth adopting the late fee binding we have in eltoo
> >
> > That is where my thinking originally went as well, but then I remembered
> that this alters the txid, causing the settlement tx to become invalid.
> What I am suggesting should be functionally the same (albeit less
> space-efficient): a secondary output that can be spent by anyone, which can
> be used to fee bump the kickoff tx with CPFP. I believe this same idea was
> considered for Lightning as well at some point. Do you happen to recall if
> there was some kind of non-standardness issue with it?
>
> Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you
> can use an `OP_TRUE` `redeemScript`, for instance.
>
> Using an `OP_TRUE` `redeemScript` would allow any third party to make you
> cry by opportunistically spending such an output.
> For example your Bitcoin-network peer could notice you broadcasting such a
> transaction with an `OP_TRUE` output, see you spend that output with a
> CPFP-RBF-ed child transaction, then instead of further broadcasting the
> child transaction, instead broadcast a non-RBF child transaction with tiny
> fee, so that it and its parent transaction will be accepted into mempools
> but would not be replaceable with a higher-feerate child transaction
> (because not RBF-flagged).
> Thus, some portion of mempools will contain this poisoned low-fee child
> transaction and prevent the parent from being confirmed (because the
> parent+child fees are not enough to justify being put in a block).
> Which I suppose is an argument for Full RBF aka
> ignore-the-RBF-flag-and-always-RBF.
>
> The solution that I remember being proposed for this in Lightning was to
> give each participant its own attach-your-fees output that only that
> participant can spend, which works for Lightning because the set of
> participants in a channel is permanently fixed, but probably not for
> statechains.
>
> --
>
> The broadcasting of the kickoff simply means that the first stage cannot
> be easily changed, and you might still be able to make further updates by
> updating only the later stages, until the last stage is confirmable, so the
> kickoff being broadcast simply creates a "dead man walking" statechain.
> However, the implementation complexity would probably increase
> tremendously.
>
>
> Regards,
> ZmnSCPxj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200327/c11adfcc/attachment.html>

From bob at mcelrath.org  Fri Mar 27 17:10:18 2020
From: bob at mcelrath.org (Bob McElrath)
Date: Fri, 27 Mar 2020 17:10:18 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
Message-ID: <20200327171017.GM28113@mcelrath.org>

Big picture, it seems to me this idea is workable and very interesting. I see
three likely enhancements that will be necessary or desirable:
    1. Atomic swap of multiple UTXOs, and binary decomposition of value in lots
    2. Key exchange ("addresses") to facilitate a secure comms path from 
        sender -> receiver
    3. (Optional) single-use seals to close old state

(1) It's unlikely that a party sending a UTXO to another party will have a UTXO
of exactly the right size that's needed, already locked into the statechain. If
he has to create the UTXO first and then lock it into the statechain, the
statechain solution is no better than an on-chain send. And once the receiver
has the UTXO, it's unlikely that he will want to send exactly that same amount
to another receiver later. This isn't a problem in Lightning where amounts can
be arbitrarily updated. As a consequence, I think Lightning is more valuable for
small-value payments, and statechains will be more valuable for larger values.

The natural solution is to decompose your outputs in a binary decomposition,
having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis, and so
on. Then when I want to send, I select the appropriate UTXOs as a binary
decomposition of the value I want to send, with a "lot size" of 1048576
satoshis, or the dust limit. The notion of "lots" like this is common in
traditional markets...many stocks are bought and sold in lots of 100, and forex
is traded in lots of $100,000. Users of a statechain therefore need log(V)
available UTXOs locked into the statechain, where V is their value in BTC.
Having fixed lot sizes like this also makes coinjoin-type uses more viable. The
statechain could also assist in dividing a UTXO into two utxos of the next lot
size down, so that I have the right UTXOs to hit the value I want to send.

This means that the statechain now has to *atomically* swap multiple UTXOs. In
principle, it should be possible for a statechain to circumvent the
Pagnia-G?rtner theorem[1] as it is a trusted third party, but guaranteed output
delivery will still be a problem. If a statechain can do this, it is also
capable of performing such swaps across two blockchains, creating the
execution/clearing element (but not order book) for a DEX. This same mechanism
can also be used to pay the SE for its service through a different UTXO than the
one being transferred.

Second (2), the steps in Tom's protocol presuppose a secure communications path
from the sender's wallet to the receiver's. This is probably not practical for a
myriad of reasons, but this data can be relayed through the SE if it is
encrypted for the target. This implies a new kind of "address" or "payment
request" that identifies the IP of the SE in use, pubkey of the
sender/recipient, and amount. If sender and receiver have each other's pubkeys
through another channel, as addresses/lightning payment requests are used today,
they can perform a Diffie-Hellman round mediated by the SE to establish a secure
communications path for the rounds of the protocol. Piggybacking on the
Lightning p2p network might be another option.

Third (3), a logical enhancement would be to use some kind of single-use seal,
which is "opened" when the UTXO is created or transferred, and "closed" when it
is transferred again. Thus a receiver can ensure that the sender is the holder
of current state and not some old state.  It's a good idea from Peter Todd, and
Tom's Mainstay[2] may be a way to do it. The SE itself can maintain a rolling
single-use seal Merkle root, periodically timestamped into Bitcoin for faster
time resolution than Bitcoin, if you trust the SE but not your counterparty
(which is the trust assumption present in the first place). Getting Bitcoin
itself to reject backout transactions from closed seals is another problem...but
having a single-use seal implementation involved is a start.

.. [1] https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.7863

.. [2] https://mainstay.xyz

Tom Trevethan via bitcoin-dev [bitcoin-dev at lists.linuxfoundation.org] wrote:
> Hi all,
> 
> We are starting to work on an implementation of the statechains concept (https:
> //medium.com/@RubenSomsen/
> statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39), with
> particular interest in using the protocol enable the change of ownership
> (novation) of an individual position in an active discreet log contract (DLC)
> without an on-chain transaction, and without needing the cooperation of the
> counterparty. The protocol as outlined by Ruben requires features not currently
> available in Bitcoin (like SIGHASH_NOINPUT), and it is uncertain when (or even
> if) this will be added. So we are looking at variants that would work with
> current Bitcoin functionality, and it would be good to get some feedback on
> them.
> 
> There are two main modifications we are looking at:
> 1. Instead of an eltoo-based backup/refund transaction (enabling the current
> owner to claim the UTXO in case the statechain entity disappears) we propose
> using a decrementing nLocktime for backup transactions as the output changes
> hands. Here, the first owner gets a backup transaction with an nLocktime at
> some future height (h0), then the next owner gets a backup transaction with
> nLocktime (h0-c) where c is a confirmation window. This approach has the
> downside of limiting the lifetime of the UTXO, but it also doesn't require the
> current owner to be always online.
> 
> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key and
> transitory key) with a single P2(W)PKH output where the public key shared
> between the SE and the current owner. The SE and the current owner can then
> sign with a 2-of-2 ECDSA MPC. This enables each owner to generate their own
> private key share, and the SE changes their key share at each change of
> ownership (with the shared public key remaining the same). This works as
> follows (.G is EC point multiplication, * is scalar multiplication):
> 
> KeyGen:
> 
> a. Owner 1 generates private key share o1 then calculates the corresponding
> public key of the share O1 and sends it to the SE: O1 = o1.G
> b. The SE then generates a private key: s1 (the SE private key share),
> calculates the corresponding public key and sends it to Owner 1: S1 = s1.G
> c. Both SE and Owner 1 then multiply the public keys they receive by their own
> private key shares to obtain the same shared public key P (which corresponds to
> a shared private key of p = o1*s1): P = o1.(s1.G) = s1.(o1.G)
> d. Owner 1 creates a funding transaction (Tx0) to pay an amount A to the
> address corresponding to P (but doesn't sign it).
> e. Once Owner 1 and SE cooperatively sign the first backup transaction, Owner 1
> then signs and broadcasts the deposit transaction Tx0.
> 
> Transfer from Owner 1 to Owner 2:
> 
> a. Owner 2 generates two private keys: o2 (the new owner UTXO private key
> share) and b2 (the new owner refund private key).
> b. The SE generates a temporary blinding nonce x and calculates the value x*s1
> and sends this securely to Owner 2.
> c. Owner 2 then multiplies this received value by the modular inverse of o2
> (o2_inv) and then sends this value (x*s1*o2_inv), to Owner 1.
> d. Owner 1 then multiplies this received value by the key share o1 and sends
> the resulting value (x*s1*o2_inv*o1) to the SE.
> e. The SE then multiplies this received value by the modular inverse of the
> temporary nonce (x_inv) to obtain x*s1*o2_inv*o1*x_inv. This cancels the
> blinding nonce x to give s1*o2_inv*o1. This value, when multiplied by the new
> owner key share o2 equals the original shared private key s1*o1.
> f. The SE then sets this value equal to s2 = s1*o2_inv*o1 and deletes s1. s2
> and o2 are now the key shares of `P` and can be used to colaboritively sign
> (with 2P ECDSA). So long as the SE delets s1, the old owner key share (o1) is
> of no use in deriving or co-signing with the full shared private key, and is
> invalidated.
> g. The shared public key P remains unchanged, but the corresponding private key
> (which no individual party ever has knowledge of or can derive) can only be
> determined from the key shares of the SE and Owner 2 (i.e. P = s2*o2.G).
> h. Owner 2 then calculates their backup public key (B2 = b2.G) and sends it to
> the SE.
> i. The SE creates a backup transaction (Tx2) that pays the output of Tx0 to the
> address corresponding to B2 , with `nLockTime` set to a block height h0 - c0,
> where c0, is a confirmation time sufficient to guarantee that Tx2 can be
> confirmed in the blockchain before Tx1 (therefore making Tx1 invalid).
> j. Owner 2 and the SE then cooperate to sign Tx2 with shared key (P) using the
> 2P ECDSA protocol, which Owner 2 then saves.
> 
> The principle of the logic of the key transfer is that the two separate key
> shares are updated, but the full shared private key (which no-one knows)
> remains the same. The new owner chooses a new secret value for their private
> key share, and this (along with the private key share of the previous owner) is
> utilized by the SE to update their share. The use of the nonce (x) prevents any
> of the participants from determining any information about each others secret
> keys. In this way Owner 2 cannot determine s1 from x*s1, Owner 1 cannot
> determine s1 or o2 from x*s1*o2_inv and the SE cannot determine o1 or o2 from
> x*s1*o2_inv*o1.
> 
> This transfer protocol can be repeated to transfer the ownership to new owners.
> Each time the SE key share sX is updated, the previous key shares become
> invalid and are of no use even if the current key share is subsequently
> revealed. The SE still needs to be trusted to delete the old key share, but
> this protocol removes the risk the the SE can be hacked by a previous owner to
> steal the funds.
> 
> Any comments on the above would be greatly appreciated.
> 
> Tom
> !DSPAM:5e7b7203210751402398759!

> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> !DSPAM:5e7b7203210751402398759!

--
Cheers, Bob McElrath

"For every complex problem, there is a solution that is simple, neat, and wrong."
    -- H. L. Mencken 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 181 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200327/72079e39/attachment-0001.sig>

From ZmnSCPxj at protonmail.com  Sat Mar 28 02:12:37 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 28 Mar 2020 02:12:37 +0000
Subject: [bitcoin-dev] Block solving slowdown question/poll
In-Reply-To: <20200327091734.GA6531@canndrew.org>
References: <PS2P216MB0179EC99BDE0E3388F2627F89DF30@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
 <F713CAAC-1997-4645-A166-57358E520594@voskuil.org>
 <CAGLBAhdTMbZPwqV9YLMyHdNzLbN2DLjiOe6cBUbkwR_x4cGRmQ@mail.gmail.com>
 <20200323125922.GA29881@canndrew.org>
 <CAGLBAhcUgTEWnraFem0YwODc61B4nwbzddHJtE0D7ZCjUNWfYg@mail.gmail.com>
 <C_qo1AhQuklVr4owEXVgLXsvJomb9Usd1NP2zf_D_23r6Cmz9-iB7ygSfNihJp3FIfAf4c1P41fT3qQP7SFiKdCfXxpogcstHsOnpgLgbok=@protonmail.com>
 <20200325152302.GA3355@canndrew.org>
 <v1t2DhGSHFng23jy0XTRkoVJrhA_6x_QuHFWdrcxQnMS8Sdcbe7eksRtvjf6JCb8YLoHf2W5y29j3XbBIVfDALSBjoiMqxPUWKsQyGLOR_A=@protonmail.com>
 <20200327091734.GA6531@canndrew.org>
Message-ID: <s3Ca4bxK08bu1hHG3byopx9GWrcrR57zKOtuXsT86eDoydG2UQWrVqphBAQ9BTVh3Yb3cF34d1lMD3iVHmEtb4PbX6wu2cCyeNvkEKA7NCY=@protonmail.com>

Good morning Andrew,

> Here's a better explanation than I could write of the phenomenon I'm talking
> about:
>
> > As a thought experiment, let?s consider aquaculture (fish farming) in a lake.
> > Imagine a lake with a thousand identical fish farms owned by a thousand
> > competing companies. Each fish farm earns a profit of $1000/month. For a
> > while, all is well.
> > But each fish farm produces waste, which fouls the water in the lake. Let?s
> > say each fish farm produces enough pollution to lower productivity in the
> > lake by $1/month.
> > A thousand fish farms produce enough waste to lower productivity by
> > $1000/month, meaning none of the fish farms are making any money. Capitalism
> > to the rescue: someone invents a complex filtering system that removes waste
> > products. It costs $300/month to operate. All fish farms voluntarily install
> > it, the pollution ends, and the fish farms are now making a profit of
> > $700/month ? still a respectable sum.
> > But one farmer (let?s call him Steve) gets tired of spending the money to
> > operate his filter. Now one fish farm worth of waste is polluting the lake,
> > lowering productivity by $1. Steve earns $999 profit, and everyone else earns
> > $699 profit.
> > Everyone else sees Steve is much more profitable than they are, because he?s
> > not spending the maintenance costs on his filter. They disconnect their
> > filters too.
> > Once four hundred people disconnect their filters, Steve is earning
> > $600/month ? less than he would be if he and everyone else had kept their
> > filters on! And the poor virtuous filter users are only making $300. Steve
> > goes around to everyone, saying ?Wait! We all need to make a voluntary pact
> > to use filters! Otherwise, everyone?s productivity goes down.?
> > Everyone agrees with him, and they all sign the Filter Pact, except one
> > person who is sort of a jerk. Let?s call him Mike. Now everyone is back using
> > filters again, except Mike. Mike earns $999/month, and everyone else earns
> > $699/month. Slowly, people start thinking they too should be getting big
> > bucks like Mike, and disconnect their filter for $300 extra profit?
> > A self-interested person never has any incentive to use a filter. A
> > self-interested person has some incentive to sign a pact to make everyone use
> > a filter, but in many cases has a stronger incentive to wait for everyone
> > else to sign such a pact but opt out himself. This can lead to an undesirable
> > equilibrium in which no one will sign such a pact.
>
> Won't a thousand bitcoin-spenders, individually paying for their transactions
> but collectively paying for their security, end up falling into the same
> dynamic?

Fortunately in our case, only the top 4,000,000 weight worth of transactions gets in a block.
Every bitcoin spender has an incentive to spend as little as possible to get into this top 4,000,000 weight and no more, but they still have to outbid every other user who wants the same security.
Some bitcoin spender will then decide that overpaying slightly to ensure that they do not drop out of the top 4,000,000 weight even in case of a "slow" block.

Thus, there will always be a need for *some* block weight limit, and that is what ensures that miners can get paid.

Now it was brought up earlier that people are moving transactions offchain, but that is perfectly fine, because every offchain mechanism first needs an onchain setup, and will at some point need an onchain teardown.
This allows increasing the effective capacity, while still ensuring that onchain fees remain at a level that will still ensure continued healthy operation of the blockchain layer.
Basically, the offchain mechanism does not remove onchain fees, it only amortizes the onchain fees to multiple logical transactions.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Sat Mar 28 02:20:33 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 28 Mar 2020 02:20:33 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAPv7TjbQ1WLxDJdufTwYttXz0asdBjAcCTDiMcdvm8xfdUv6=g@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <79753214-9d5e-40c7-97ac-1d4e9ea3c64e@www.fastmail.com>
 <CAPv7TjZ45VD_5sGSFiQxmt981uDodq28mHOW=2LYLofXams43w@mail.gmail.com>
 <87369v6nw3.fsf@gmail.com>
 <CAB3F3Dt0z5bDMpzRGGJxJV8KpCk_4XGF23MGmYVkLppRbG7Wnw@mail.gmail.com>
 <CAPv7TjbAfLHFZgSvCTSG2rS6oZinyd6VWrT3U8Y++PL=Jm6igA@mail.gmail.com>
 <j37G_ywUw4UA7J2iEXurAk8Vq-QA3toUz3sakqEiYHqbpqF1DEK0riorbuZW_UkMCkNS-KKCDNPec7ogpchdg8hYPjPh_gzAGwfbY72e_p4=@protonmail.com>
 <CAPv7TjbQ1WLxDJdufTwYttXz0asdBjAcCTDiMcdvm8xfdUv6=g@mail.gmail.com>
Message-ID: <YRSNEVWhWha9PJIxY-xCyNS8f85XWaD5Wk6EexcMpi_KFpm6QVr0VKO04m0qlhdE6JCVC0yFXL9dkemqz7L6QX-pJx2psJtyIzWO-9MAPC4=@protonmail.com>

Good morning Ruben,


> >The broadcasting of the kickoff simply means that the first stage cannot be easily changed
>
> I see what you're saying. Yeah, it does ruin the stages. If the kickoff tx hits the chain, you'd probably just want to "refresh" the UTXO by agreeing with the statechain entity to spend it to a new statechain 2-of-2 UTXO on-chain, thus removing all prior owners. Ideally you'd want it to be more costly to CPFP the kickoff tx than it is to refresh the UTXO, so the defender is at an advantage. The statechain entity should probably pay for every refresh ("insurance"), since the actual owner isn't at fault.

Actually, thinking a little more, it seems that you can try to ensure that the first stage never drops to 0 relative locktime.
Then if somebody broadcasts the kick-off, the current owner can ask the statechain entity to sign an alternative to the first stage, with 0 relative locktime, that can now be a new funding transaction to anchor a (actually new, but logically a continuation) statechain.

Regards,
ZmnSCPxj

>
> Cheers,
> Ruben
>
> On Fri, Mar 27, 2020 at 2:46 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
> > Good morning Ruben,
> >
> > > Hey Christian,
> > >
> > > Thanks for chiming in :)
> > >
> > > >It might be worth adopting the late fee binding we have in eltoo
> > >
> > > That is where my thinking originally went as well, but then I remembered that this alters the txid, causing the settlement tx to become invalid. What I am suggesting should be functionally the same (albeit less space-efficient): a secondary output that can be spent by anyone, which can be used to fee bump the kickoff tx with CPFP. I believe this same idea was considered for Lightning as well at some point. Do you happen to recall if there was some kind of non-standardness issue with it?
> >
> > Any standardness issue can be fixed by embedding it in a P2WSH / P2SH, you can use an `OP_TRUE` `redeemScript`, for instance.
> >
> > Using an `OP_TRUE` `redeemScript` would allow any third party to make you cry by opportunistically spending such an output.
> > For example your Bitcoin-network peer could notice you broadcasting such a transaction with an `OP_TRUE` output, see you spend that output with a CPFP-RBF-ed child transaction, then instead of further broadcasting the child transaction, instead broadcast a non-RBF child transaction with tiny fee, so that it and its parent transaction will be accepted into mempools but would not be replaceable with a higher-feerate child transaction (because not RBF-flagged).
> > Thus, some portion of mempools will contain this poisoned low-fee child transaction and prevent the parent from being confirmed (because the parent+child fees are not enough to justify being put in a block).
> > Which I suppose is an argument for Full RBF aka ignore-the-RBF-flag-and-always-RBF.
> >
> > The solution that I remember being proposed for this in Lightning was to give each participant its own attach-your-fees output that only that participant can spend, which works for Lightning because the set of participants in a channel is permanently fixed, but probably not for statechains.
> >
> > --
> >
> > The broadcasting of the kickoff simply means that the first stage cannot be easily changed, and you might still be able to make further updates by updating only the later stages, until the last stage is confirmable, so the kickoff being broadcast simply creates a "dead man walking" statechain.
> > However, the implementation complexity would probably increase tremendously.
> >
> > Regards,
> > ZmnSCPxj



From ZmnSCPxj at protonmail.com  Sat Mar 28 02:42:27 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Sat, 28 Mar 2020 02:42:27 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <20200327171017.GM28113@mcelrath.org>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <20200327171017.GM28113@mcelrath.org>
Message-ID: <6SFA-3YOsuEl4D3N5eA5G6q1B6ROWHmNefjCC5cRPpHg6iu9PVdG21PKjV28IMYXY_tOcmrSB60tnQRgm4pcHXB_MxOPaa9zZIbBeo0aHS4=@protonmail.com>

Good morning Bob,

> Big picture, it seems to me this idea is workable and very interesting. I see
> three likely enhancements that will be necessary or desirable:
> 1. Atomic swap of multiple UTXOs, and binary decomposition of value in lots
> 2. Key exchange ("addresses") to facilitate a secure comms path from
> sender -> receiver
>
>     3. (Optional) single-use seals to close old state
>
>
> (1) It's unlikely that a party sending a UTXO to another party will have a UTXO
> of exactly the right size that's needed, already locked into the statechain. If
> he has to create the UTXO first and then lock it into the statechain, the
> statechain solution is no better than an on-chain send. And once the receiver
> has the UTXO, it's unlikely that he will want to send exactly that same amount
> to another receiver later. This isn't a problem in Lightning where amounts can
> be arbitrarily updated. As a consequence, I think Lightning is more valuable for
> small-value payments, and statechains will be more valuable for larger values.
>
> The natural solution is to decompose your outputs in a binary decomposition,
> having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis, and so
> on. Then when I want to send, I select the appropriate UTXOs as a binary
> decomposition of the value I want to send, with a "lot size" of 1048576
> satoshis, or the dust limit. The notion of "lots" like this is common in
> traditional markets...many stocks are bought and sold in lots of 100, and forex
> is traded in lots of $100,000. Users of a statechain therefore need log(V)
> available UTXOs locked into the statechain, where V is their value in BTC.
> Having fixed lot sizes like this also makes coinjoin-type uses more viable. The
> statechain could also assist in dividing a UTXO into two utxos of the next lot
> size down, so that I have the right UTXOs to hit the value I want to send.

My understanding of statechains is that nothing prevents the statechain from internally having multiple UTXOs divided from a single large onchain UTXO.

Indeed, a statechain can act much like a federated blockchain, and the interface to the statechain could be for its clients to send a Bitcoin transaction to it spending 1 or more of the UTXOs currently instantiated inside the statechain.
Then the statechain validates the client Bitcoin transaction, updates its state and republishes it to its clients, removing the (internal-to-statechain-only) UTXOs spent, and inserting the new UTXOs of the incoming transaction.

For example, suppose I have a 1BTC onchain UTXO that I use to create a new statechain:

    [funding tx]->1BTC(SE)-+  (onchain)
    _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
              (statechain) |
                           +->[update mechanism]->1BTC(ZmnSCPxj)

Then I send to the statechain a transaction spending my 1BTC-on-statechain, giving you 0.11568768 BTC:

    [funding tx]->1BTC(SE)-+  (onchain)
    _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
              (statechain) |
                           +->[update mechanism]->1BTC(ZmnSCPxj)->[tx]-+->0.11568768BTC(bsm117532)
                                                                       +->0.88431232BTC(ZmnSCPxj)

The statechain verifies that the tx I sent is valid, then outputs the next state as below:

    [funding tx]->1BTC(SE)-+  (onchain)
    _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
              (statechain) |
                           +->[update mechanism]-+->0.11568768BTC(bsm117532)
                                                 +->0.88431232BTC(ZmnSCPxj)

In short, statechains can be implemented as a sort of super-transaction-cutthrough system.

This prevents the onchain UTXO from having a single logical owner, of course, so onchain it is the statechain entity that owns the entire fund, but if you are trusting the statechain entity anyway, the update mechanism is sufficient to ensure that nobody (other than the trusted statechain) can prevent the publication of the latest accepted state.

This is probably significantly more efficient than splitting up the 1BTC value to multiple lots.

I think this framework will work for all offchain mechanisms (CoinSwap, Lightning, statechains), by the way --- you can always view the offchain update mechanism as logically implementing a "new" cryptocurrency system that maintains UTXO sets and allows removal and insertion of UTXO sets according to the same rules (sans relative-locktime) as the hosting cryptocurrency system (i.e. the blockchain).
The same realization is what underlies channel factories as well --- the hosting cryptocurrency system need not be a blockchain, it can be just another cryptocurrency system (of which a blockchain is just one kind).

My understanding is that the original description, which describes transferring the entire value inside the statechain to a new owner, was only for exposition and that it was an exercise for the reader to consider how a statechain can internally split the total value among multiple UTXOs.

Regards,
ZmnSCPxj

From rsomsen at gmail.com  Sat Mar 28 17:38:47 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Sat, 28 Mar 2020 18:38:47 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <6SFA-3YOsuEl4D3N5eA5G6q1B6ROWHmNefjCC5cRPpHg6iu9PVdG21PKjV28IMYXY_tOcmrSB60tnQRgm4pcHXB_MxOPaa9zZIbBeo0aHS4=@protonmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <20200327171017.GM28113@mcelrath.org>
 <6SFA-3YOsuEl4D3N5eA5G6q1B6ROWHmNefjCC5cRPpHg6iu9PVdG21PKjV28IMYXY_tOcmrSB60tnQRgm4pcHXB_MxOPaa9zZIbBeo0aHS4=@protonmail.com>
Message-ID: <CAPv7TjYs8j=rKWPVzfFbtznjFQfpKTBGr4AnCXrDcU64Cb8S9Q@mail.gmail.com>

Hi Bob,

Looks like we're largely thinking along the same lines.

It's unlikely that a party sending a UTXO to another party will have a UTXO
> of exactly the right size that's needed


My original proposal uses adaptor signatures to ensure swapping UTXOs is
atomic. All parties choose a secret, then they all make adaptor signatures,
then they reveal their secret to the statechain entity. The SE then
publishes the signatures, causing everyone to learn the secret. And if the
SE doesn't publish, it simply means the transfer didn't occur.

But taking a step back and thinking about an MVP, it may be easier to make
it more like a fully audited transparent blockchain where multiple users
create a combined transaction of all the UTXOs they want to swap, which is
published together with all the corresponding Bitcoin transactions. Then
adaptor signatures aren't needed.

The downside of that method is that you lose the ability to only validate
the history of the coins you hold (scalability win). For this to be
possible, you need to keep the history of every individual UTXO completely
separate. I still think that is where we eventually want to end up (as well
as having blind signatures), but it adds a lot of complexity (adaptor
signatures, sparse merkle trees with non-inclusion proofs...).

The natural solution is to decompose your outputs in a binary decomposition


I fully agree, but on top of that I think we also need Lightning,
because....

This same mechanism can also be used to pay the SE for its service through
> a different UTXO than the one being transferred.


My conclusion was that opening a Lightning channel on top of a statechain
makes more sense for this (as ZmnSCPxj explained in his reply to you). If
we expect BTC fees to go up, we can't expect the statechain to hold UTXOs
that are small enough to be used to pay for statechain fees.

More on this in my Breaking Bitcoin 2019 talk (timestamped link):
https://youtu.be/09HcYRjDkMA?t=850

a logical enhancement would be to use some kind of single-use seal


Any kind of system where users transfer ownership through signatures will
resemble single-use seals, so I'd say that's inevitable! :)

Cheers,
Ruben


On Sat, Mar 28, 2020 at 3:42 AM ZmnSCPxj via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Good morning Bob,
>
> > Big picture, it seems to me this idea is workable and very interesting.
> I see
> > three likely enhancements that will be necessary or desirable:
> > 1. Atomic swap of multiple UTXOs, and binary decomposition of value in
> lots
> > 2. Key exchange ("addresses") to facilitate a secure comms path from
> > sender -> receiver
> >
> >     3. (Optional) single-use seals to close old state
> >
> >
> > (1) It's unlikely that a party sending a UTXO to another party will have
> a UTXO
> > of exactly the right size that's needed, already locked into the
> statechain. If
> > he has to create the UTXO first and then lock it into the statechain, the
> > statechain solution is no better than an on-chain send. And once the
> receiver
> > has the UTXO, it's unlikely that he will want to send exactly that same
> amount
> > to another receiver later. This isn't a problem in Lightning where
> amounts can
> > be arbitrarily updated. As a consequence, I think Lightning is more
> valuable for
> > small-value payments, and statechains will be more valuable for larger
> values.
> >
> > The natural solution is to decompose your outputs in a binary
> decomposition,
> > having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis,
> and so
> > on. Then when I want to send, I select the appropriate UTXOs as a binary
> > decomposition of the value I want to send, with a "lot size" of 1048576
> > satoshis, or the dust limit. The notion of "lots" like this is common in
> > traditional markets...many stocks are bought and sold in lots of 100,
> and forex
> > is traded in lots of $100,000. Users of a statechain therefore need
> log(V)
> > available UTXOs locked into the statechain, where V is their value in
> BTC.
> > Having fixed lot sizes like this also makes coinjoin-type uses more
> viable. The
> > statechain could also assist in dividing a UTXO into two utxos of the
> next lot
> > size down, so that I have the right UTXOs to hit the value I want to
> send.
>
> My understanding of statechains is that nothing prevents the statechain
> from internally having multiple UTXOs divided from a single large onchain
> UTXO.
>
> Indeed, a statechain can act much like a federated blockchain, and the
> interface to the statechain could be for its clients to send a Bitcoin
> transaction to it spending 1 or more of the UTXOs currently instantiated
> inside the statechain.
> Then the statechain validates the client Bitcoin transaction, updates its
> state and republishes it to its clients, removing the
> (internal-to-statechain-only) UTXOs spent, and inserting the new UTXOs of
> the incoming transaction.
>
> For example, suppose I have a 1BTC onchain UTXO that I use to create a new
> statechain:
>
>     [funding tx]->1BTC(SE)-+  (onchain)
>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
>               (statechain) |
>                            +->[update mechanism]->1BTC(ZmnSCPxj)
>
> Then I send to the statechain a transaction spending my
> 1BTC-on-statechain, giving you 0.11568768 BTC:
>
>     [funding tx]->1BTC(SE)-+  (onchain)
>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
>               (statechain) |
>                            +->[update
> mechanism]->1BTC(ZmnSCPxj)->[tx]-+->0.11568768BTC(bsm117532)
>
>  +->0.88431232BTC(ZmnSCPxj)
>
> The statechain verifies that the tx I sent is valid, then outputs the next
> state as below:
>
>     [funding tx]->1BTC(SE)-+  (onchain)
>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
>               (statechain) |
>                            +->[update
> mechanism]-+->0.11568768BTC(bsm117532)
>                                                  +->0.88431232BTC(ZmnSCPxj)
>
> In short, statechains can be implemented as a sort of
> super-transaction-cutthrough system.
>
> This prevents the onchain UTXO from having a single logical owner, of
> course, so onchain it is the statechain entity that owns the entire fund,
> but if you are trusting the statechain entity anyway, the update mechanism
> is sufficient to ensure that nobody (other than the trusted statechain) can
> prevent the publication of the latest accepted state.
>
> This is probably significantly more efficient than splitting up the 1BTC
> value to multiple lots.
>
> I think this framework will work for all offchain mechanisms (CoinSwap,
> Lightning, statechains), by the way --- you can always view the offchain
> update mechanism as logically implementing a "new" cryptocurrency system
> that maintains UTXO sets and allows removal and insertion of UTXO sets
> according to the same rules (sans relative-locktime) as the hosting
> cryptocurrency system (i.e. the blockchain).
> The same realization is what underlies channel factories as well --- the
> hosting cryptocurrency system need not be a blockchain, it can be just
> another cryptocurrency system (of which a blockchain is just one kind).
>
> My understanding is that the original description, which describes
> transferring the entire value inside the statechain to a new owner, was
> only for exposition and that it was an exercise for the reader to consider
> how a statechain can internally split the total value among multiple UTXOs.
>
> Regards,
> ZmnSCPxj
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200328/fa483e0f/attachment-0001.html>

From rsomsen at gmail.com  Sat Mar 28 17:42:58 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Sat, 28 Mar 2020 18:42:58 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAPv7TjYs8j=rKWPVzfFbtznjFQfpKTBGr4AnCXrDcU64Cb8S9Q@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <20200327171017.GM28113@mcelrath.org>
 <6SFA-3YOsuEl4D3N5eA5G6q1B6ROWHmNefjCC5cRPpHg6iu9PVdG21PKjV28IMYXY_tOcmrSB60tnQRgm4pcHXB_MxOPaa9zZIbBeo0aHS4=@protonmail.com>
 <CAPv7TjYs8j=rKWPVzfFbtznjFQfpKTBGr4AnCXrDcU64Cb8S9Q@mail.gmail.com>
Message-ID: <CAPv7Tjb5a5RbXH802m8qHoUKw-5rZV6nOw01z9+hx4yTJYV3Cw@mail.gmail.com>

Hi ZmnSCPxj,

the current owner can ask the statechain entity to sign an alternative to
> the first stage, with 0 relative locktime


Unless I am misunderstanding something, this seems to run into the problem
that the original first stage transaction is already out there (and its
relative timelock started ticking). There is no mechanism ensuring that the
new tx will have precedence. And even if it did work, I doubt it's cleaner
than doing a cooperative peg-out that simultaneously happens to peg back
in, creating a brand new statechain UTXO with no history.

Cheers,
Ruben

On Sat, Mar 28, 2020 at 6:38 PM Ruben Somsen <rsomsen at gmail.com> wrote:

> Hi Bob,
>
> Looks like we're largely thinking along the same lines.
>
> It's unlikely that a party sending a UTXO to another party will have a
>> UTXO of exactly the right size that's needed
>
>
> My original proposal uses adaptor signatures to ensure swapping UTXOs is
> atomic. All parties choose a secret, then they all make adaptor signatures,
> then they reveal their secret to the statechain entity. The SE then
> publishes the signatures, causing everyone to learn the secret. And if the
> SE doesn't publish, it simply means the transfer didn't occur.
>
> But taking a step back and thinking about an MVP, it may be easier to make
> it more like a fully audited transparent blockchain where multiple users
> create a combined transaction of all the UTXOs they want to swap, which is
> published together with all the corresponding Bitcoin transactions. Then
> adaptor signatures aren't needed.
>
> The downside of that method is that you lose the ability to only validate
> the history of the coins you hold (scalability win). For this to be
> possible, you need to keep the history of every individual UTXO completely
> separate. I still think that is where we eventually want to end up (as well
> as having blind signatures), but it adds a lot of complexity (adaptor
> signatures, sparse merkle trees with non-inclusion proofs...).
>
> The natural solution is to decompose your outputs in a binary decomposition
>
>
> I fully agree, but on top of that I think we also need Lightning,
> because....
>
> This same mechanism can also be used to pay the SE for its service through
>> a different UTXO than the one being transferred.
>
>
> My conclusion was that opening a Lightning channel on top of a statechain
> makes more sense for this (as ZmnSCPxj explained in his reply to you). If
> we expect BTC fees to go up, we can't expect the statechain to hold UTXOs
> that are small enough to be used to pay for statechain fees.
>
> More on this in my Breaking Bitcoin 2019 talk (timestamped link):
> https://youtu.be/09HcYRjDkMA?t=850
>
> a logical enhancement would be to use some kind of single-use seal
>
>
> Any kind of system where users transfer ownership through signatures will
> resemble single-use seals, so I'd say that's inevitable! :)
>
> Cheers,
> Ruben
>
>
> On Sat, Mar 28, 2020 at 3:42 AM ZmnSCPxj via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Good morning Bob,
>>
>> > Big picture, it seems to me this idea is workable and very interesting.
>> I see
>> > three likely enhancements that will be necessary or desirable:
>> > 1. Atomic swap of multiple UTXOs, and binary decomposition of value in
>> lots
>> > 2. Key exchange ("addresses") to facilitate a secure comms path from
>> > sender -> receiver
>> >
>> >     3. (Optional) single-use seals to close old state
>> >
>> >
>> > (1) It's unlikely that a party sending a UTXO to another party will
>> have a UTXO
>> > of exactly the right size that's needed, already locked into the
>> statechain. If
>> > he has to create the UTXO first and then lock it into the statechain,
>> the
>> > statechain solution is no better than an on-chain send. And once the
>> receiver
>> > has the UTXO, it's unlikely that he will want to send exactly that same
>> amount
>> > to another receiver later. This isn't a problem in Lightning where
>> amounts can
>> > be arbitrarily updated. As a consequence, I think Lightning is more
>> valuable for
>> > small-value payments, and statechains will be more valuable for larger
>> values.
>> >
>> > The natural solution is to decompose your outputs in a binary
>> decomposition,
>> > having e.g. UTXOs with 1048576 satoshis, another with 2097152 satoshis,
>> and so
>> > on. Then when I want to send, I select the appropriate UTXOs as a binary
>> > decomposition of the value I want to send, with a "lot size" of 1048576
>> > satoshis, or the dust limit. The notion of "lots" like this is common in
>> > traditional markets...many stocks are bought and sold in lots of 100,
>> and forex
>> > is traded in lots of $100,000. Users of a statechain therefore need
>> log(V)
>> > available UTXOs locked into the statechain, where V is their value in
>> BTC.
>> > Having fixed lot sizes like this also makes coinjoin-type uses more
>> viable. The
>> > statechain could also assist in dividing a UTXO into two utxos of the
>> next lot
>> > size down, so that I have the right UTXOs to hit the value I want to
>> send.
>>
>> My understanding of statechains is that nothing prevents the statechain
>> from internally having multiple UTXOs divided from a single large onchain
>> UTXO.
>>
>> Indeed, a statechain can act much like a federated blockchain, and the
>> interface to the statechain could be for its clients to send a Bitcoin
>> transaction to it spending 1 or more of the UTXOs currently instantiated
>> inside the statechain.
>> Then the statechain validates the client Bitcoin transaction, updates its
>> state and republishes it to its clients, removing the
>> (internal-to-statechain-only) UTXOs spent, and inserting the new UTXOs of
>> the incoming transaction.
>>
>> For example, suppose I have a 1BTC onchain UTXO that I use to create a
>> new statechain:
>>
>>     [funding tx]->1BTC(SE)-+  (onchain)
>>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
>>               (statechain) |
>>                            +->[update mechanism]->1BTC(ZmnSCPxj)
>>
>> Then I send to the statechain a transaction spending my
>> 1BTC-on-statechain, giving you 0.11568768 BTC:
>>
>>     [funding tx]->1BTC(SE)-+  (onchain)
>>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
>>               (statechain) |
>>                            +->[update
>> mechanism]->1BTC(ZmnSCPxj)->[tx]-+->0.11568768BTC(bsm117532)
>>
>>  +->0.88431232BTC(ZmnSCPxj)
>>
>> The statechain verifies that the tx I sent is valid, then outputs the
>> next state as below:
>>
>>     [funding tx]->1BTC(SE)-+  (onchain)
>>     _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _
>>               (statechain) |
>>                            +->[update
>> mechanism]-+->0.11568768BTC(bsm117532)
>>
>>  +->0.88431232BTC(ZmnSCPxj)
>>
>> In short, statechains can be implemented as a sort of
>> super-transaction-cutthrough system.
>>
>> This prevents the onchain UTXO from having a single logical owner, of
>> course, so onchain it is the statechain entity that owns the entire fund,
>> but if you are trusting the statechain entity anyway, the update mechanism
>> is sufficient to ensure that nobody (other than the trusted statechain) can
>> prevent the publication of the latest accepted state.
>>
>> This is probably significantly more efficient than splitting up the 1BTC
>> value to multiple lots.
>>
>> I think this framework will work for all offchain mechanisms (CoinSwap,
>> Lightning, statechains), by the way --- you can always view the offchain
>> update mechanism as logically implementing a "new" cryptocurrency system
>> that maintains UTXO sets and allows removal and insertion of UTXO sets
>> according to the same rules (sans relative-locktime) as the hosting
>> cryptocurrency system (i.e. the blockchain).
>> The same realization is what underlies channel factories as well --- the
>> hosting cryptocurrency system need not be a blockchain, it can be just
>> another cryptocurrency system (of which a blockchain is just one kind).
>>
>> My understanding is that the original description, which describes
>> transferring the entire value inside the statechain to a new owner, was
>> only for exposition and that it was an exercise for the reader to consider
>> how a statechain can internally split the total value among multiple UTXOs.
>>
>> Regards,
>> ZmnSCPxj
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200328/31e7991c/attachment-0001.html>

From shum at canndrew.org  Sun Mar 29 08:11:36 2020
From: shum at canndrew.org (Andrew Cann)
Date: Sun, 29 Mar 2020 04:11:36 -0400
Subject: [bitcoin-dev] Block solving slowdown
In-Reply-To: <s3Ca4bxK08bu1hHG3byopx9GWrcrR57zKOtuXsT86eDoydG2UQWrVqphBAQ9BTVh3Yb3cF34d1lMD3iVHmEtb4PbX6wu2cCyeNvkEKA7NCY=@protonmail.com>
Message-ID: <20200329081136.GA15016@canndrew.org>

> Fortunately in our case, only the top 4,000,000 weight worth of transactions
> gets in a block. Every bitcoin spender has an incentive to spend as little
> as possible to get into this top 4,000,000 weight and no more, but they still
> have to outbid every other user who wants the same security. Some bitcoin
> spender will then decide that overpaying slightly to ensure that they do not
> drop out of the top 4,000,000 weight even in case of a "slow" block.
>
> Thus, there will always be a need for *some* block weight limit, and that is
> what ensures that miners can get paid.

Yes, but how does this ensure that miners get paid *enough*? Every individual
making a transaction needs the miners to get paid enough for the transaction to
be meaningful, but they each individually only have the incentive to pay the
market rate for block space which is set purely by supply and demand.

It's the same as the fish farming analogy. Everyone making a transaction could
collectively decide how much miners need to get paid and agree to split the
costs. But then each individual has the incentive to renege on the agreement
and only pay the minimum they need to get their transaction included in the
block while everyone else pays for the transaction's security. My voting idea
is one potential way they could break the Nash equilibrium.

> Now it was brought up earlier that people are moving transactions offchain,
> but that is perfectly fine, because every offchain mechanism first needs an
> onchain setup, and will at some point need an onchain teardown. This
> allows increasing the effective capacity, while still ensuring that onchain
> fees remain at a level that will still ensure continued healthy operation of
> the blockchain layer. Basically, the offchain mechanism does not remove
> onchain fees, it only amortizes the onchain fees to multiple logical
> transactions.

I concede that every bitcoin user pays transaction fees, if not directly then
indirectly, so whether miners get paid through transaction fees or a block
reward is irrelevant. My concern is that moving things off-chain reduces the
transaction fees by reducing demand for block-space and that this could cause
miner revenue to drop lower than what's required to keep the network secure.

Is there any good reason to think this won't happen?

 - Andrew

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200329/5473ae9a/attachment.sig>

From ZmnSCPxj at protonmail.com  Mon Mar 30 01:25:36 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 30 Mar 2020 01:25:36 +0000
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAPv7Tjb5a5RbXH802m8qHoUKw-5rZV6nOw01z9+hx4yTJYV3Cw@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <20200327171017.GM28113@mcelrath.org>
 <6SFA-3YOsuEl4D3N5eA5G6q1B6ROWHmNefjCC5cRPpHg6iu9PVdG21PKjV28IMYXY_tOcmrSB60tnQRgm4pcHXB_MxOPaa9zZIbBeo0aHS4=@protonmail.com>
 <CAPv7TjYs8j=rKWPVzfFbtznjFQfpKTBGr4AnCXrDcU64Cb8S9Q@mail.gmail.com>
 <CAPv7Tjb5a5RbXH802m8qHoUKw-5rZV6nOw01z9+hx4yTJYV3Cw@mail.gmail.com>
Message-ID: <70epI8yeOu69uXQfxbyWEfrH7hYLzsx9CDIgA9gL_GlaqDEmshtP4Ogf6Dl7GH408GTPDveir1MKy1euEcPbOhJEtzjLbV9m506quXhnKOg=@protonmail.com>

Good morning Ruben,

> Hi ZmnSCPxj,
>
> > the current owner can ask the statechain entity to sign an alternative to the first stage, with 0 relative locktime
>
> Unless I am misunderstanding something, this seems to run into the problem that the original first stage transaction is already out there (and its relative timelock started ticking). There is no mechanism ensuring that the new tx will have precedence. And even if it did work, I doubt it's cleaner than doing a cooperative peg-out that simultaneously happens to peg back in, creating a brand new statechain UTXO with no history.


If:

* You are sure the old first stage tx has > 0 relative locktime.
* The replacement tx (which replaces the old first stage) has a 0 relative locktime.
  * The replacement tx redirects the funds to a new funding output for a (logically continuous, onchain new) statechain.

Then the replacement tx, having a smaller relative locktime than the old first stage, has precedence.
Indeed, having a *smaller* relative locktime is exactly the mechanism Decker-Wattenhofer uses.

So this is the state, with the kickoff having just been confirmed onchain:


    ***blockchain***
       [funding tx]->[kickoff tx]-+
         _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _
     offchain                     |
                                  +->[[ 7] stage]->[[ 0] stage]->[[14] stage]-> state outputs

Since the first stage is still "ticking" it is not yet confirmable onchain.

You ask the statechain to create an alternative, 0-relative-locktime, re-funding tx, and create a new mechanism:

    ***blockchain***
       [funding tx]->[kickoff tx]-+
         _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _
     offchain                     |
                                  +->[[ 7] stage]->[[ 0] stage]->[[14] stage]-> state outputs
                                 (OR)
                                  |
                                  +->[[ 0] funding tx]->[kickoff tx]->[[14] stage]->[[14] stage]->[[14] stage]->state outputs

Because it has a time advantage, this new re-funding tx has higher priority (and is the same mechanism Decker-Wattenhofer has anyway).

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Mon Mar 30 02:59:53 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 30 Mar 2020 02:59:53 +0000
Subject: [bitcoin-dev] Block solving slowdown
In-Reply-To: <20200329081136.GA15016@canndrew.org>
References: <20200329081136.GA15016@canndrew.org>
Message-ID: <dUt3gYGhyaMYXiz6ZoS0whlq57ImbjYO8-z4lw4uZkqzMUHjmPoLtRSuQnM3h26wTpVFUsZWM9wH2yGWRPd-bEx2HhvWYuxKRTXYojw5hT4=@protonmail.com>

Good morning Andrew,

> > Fortunately in our case, only the top 4,000,000 weight worth of transactions
> > gets in a block. Every bitcoin spender has an incentive to spend as little
> > as possible to get into this top 4,000,000 weight and no more, but they still
> > have to outbid every other user who wants the same security. Some bitcoin
> > spender will then decide that overpaying slightly to ensure that they do not
> > drop out of the top 4,000,000 weight even in case of a "slow" block.
> > Thus, there will always be a need for some block weight limit, and that is
> > what ensures that miners can get paid.
>
> Yes, but how does this ensure that miners get paidenough? Every individual
> making a transaction needs the miners to get paid enough for the transaction to
> be meaningful, but they each individually only have the incentive to pay the
> market rate for block space which is set purely by supply and demand.

If your coins have no security, you cannot use them safely.
If you assign value to something, you will want to ensure some amount of protection to that something, proportional to the value you assign the something

By forcing a competition for limited block space, Bitcoin forces users to honestly assess how much security they are willing to pay for.

> It's the same as the fish farming analogy. Everyone making a transaction could
> collectively decide how much miners need to get paid and agree to split the
> costs. But then each individual has the incentive to renege on the agreement
> and only pay the minimum they need to get their transaction included in the
> block while everyone else pays for the transaction's security. My voting idea
> is one potential way they could break the Nash equilibrium.

Suppose everybody "agrees" to a reasonable fee level.
They divide up the block space among themselves and assign a fee.

Then suddenly one of the participants realizes they actually have to have a transaction added, but the block space they already agreed to use is not sufficient to fit.
Since their agreement is just ink on a page, this participant spins up a new Bitcoin non-full node, connects to the Bitcoin network over TOR, then broadcasts the extra transaction with a higher feerate.
This evicts one of the transactions in the next block (which could also be one that this cheating participant wants, but let us say that this sudden new transaction is even more important than the others it currently has allocated for the next block).

The other participants now have a risk that their transaction does not get included in the block.
Each one then re-assesses their security and timeliness requirements, and can then decide to bump their fee using RBF, if that is necessary.

This competition will then stabilize when each participant decides that the added fee to ensure their inclusion in the next block is too high for their security and timeliness requirements, and the risk they do not get their transaction confirmed is acceptable to them given the cost of getting their transaction confirmed.

All of the above is already how Bitcoin works today.

That is the only mechanism necessary, or even possible.

Always remember that any voting scheme always implicitly has an extra option called "all the options suck so I will not vote".
In this context, this implies that people can just sell their coins and forget the whole system, rather than deal with a mechanism which ensures that coins they own are always devalued continuously by others voting for devaluation.
They can sell it for a coin where their held coins are not devalued by policy, i.e. your mechanism will never have widespread support necessary for reliably forking the chain.

>
> > Now it was brought up earlier that people are moving transactions offchain,
> > but that is perfectly fine, because every offchain mechanism first needs an
> > onchain setup, and will at some point need an onchain teardown. This
> > allows increasing the effective capacity, while still ensuring that onchain
> > fees remain at a level that will still ensure continued healthy operation of
> > the blockchain layer. Basically, the offchain mechanism does not remove
> > onchain fees, it only amortizes the onchain fees to multiple logical
> > transactions.
>
> I concede that every bitcoin user pays transaction fees, if not directly then
> indirectly, so whether miners get paid through transaction fees or a block
> reward is irrelevant. My concern is that moving things off-chain reduces the
> transaction fees by reducing demand for block-space and that this could cause
> miner revenue to drop lower than what's required to keep the network secure.
>
> Is there any good reason to think this won't happen?

Death.

No Lightning node will last forever, and its channels will be eventually be closed.
Than, any onchain funds will be in the slow expensive onchain domain, so the heirs of the dead Lightning node will want to put them back into Lightning as fast as possible.

Given the number of economic nodes we expect to eventually exist (and thus possibly die) in the future, we can expect some level of such activity in the long run.
It is helpful to remember as well that this is a long-run issue anyway.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Mon Mar 30 02:59:52 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 30 Mar 2020 02:59:52 +0000
Subject: [bitcoin-dev] Block solving slowdown
In-Reply-To: <20200329081136.GA15016@canndrew.org>
References: <20200329081136.GA15016@canndrew.org>
Message-ID: <dUt3gYGhyaMYXiz6ZoS0whlq57ImbjYO8-z4lw4uZkqzMUHjmPoLtRSuQnM3h26wTpVFUsZWM9wH2yGWRPd-bEx2HhvWYuxKRTXYojw5hT4=@protonmail.com>

Good morning Andrew,

> > Fortunately in our case, only the top 4,000,000 weight worth of transactions
> > gets in a block. Every bitcoin spender has an incentive to spend as little
> > as possible to get into this top 4,000,000 weight and no more, but they still
> > have to outbid every other user who wants the same security. Some bitcoin
> > spender will then decide that overpaying slightly to ensure that they do not
> > drop out of the top 4,000,000 weight even in case of a "slow" block.
> > Thus, there will always be a need for some block weight limit, and that is
> > what ensures that miners can get paid.
>
> Yes, but how does this ensure that miners get paidenough? Every individual
> making a transaction needs the miners to get paid enough for the transaction to
> be meaningful, but they each individually only have the incentive to pay the
> market rate for block space which is set purely by supply and demand.

If your coins have no security, you cannot use them safely.
If you assign value to something, you will want to ensure some amount of protection to that something, proportional to the value you assign the something

By forcing a competition for limited block space, Bitcoin forces users to honestly assess how much security they are willing to pay for.

> It's the same as the fish farming analogy. Everyone making a transaction could
> collectively decide how much miners need to get paid and agree to split the
> costs. But then each individual has the incentive to renege on the agreement
> and only pay the minimum they need to get their transaction included in the
> block while everyone else pays for the transaction's security. My voting idea
> is one potential way they could break the Nash equilibrium.

Suppose everybody "agrees" to a reasonable fee level.
They divide up the block space among themselves and assign a fee.

Then suddenly one of the participants realizes they actually have to have a transaction added, but the block space they already agreed to use is not sufficient to fit.
Since their agreement is just ink on a page, this participant spins up a new Bitcoin non-full node, connects to the Bitcoin network over TOR, then broadcasts the extra transaction with a higher feerate.
This evicts one of the transactions in the next block (which could also be one that this cheating participant wants, but let us say that this sudden new transaction is even more important than the others it currently has allocated for the next block).

The other participants now have a risk that their transaction does not get included in the block.
Each one then re-assesses their security and timeliness requirements, and can then decide to bump their fee using RBF, if that is necessary.

This competition will then stabilize when each participant decides that the added fee to ensure their inclusion in the next block is too high for their security and timeliness requirements, and the risk they do not get their transaction confirmed is acceptable to them given the cost of getting their transaction confirmed.

All of the above is already how Bitcoin works today.

That is the only mechanism necessary, or even possible.

Always remember that any voting scheme always implicitly has an extra option called "all the options suck so I will not vote".
In this context, this implies that people can just sell their coins and forget the whole system, rather than deal with a mechanism which ensures that coins they own are always devalued continuously by others voting for devaluation.
They can sell it for a coin where their held coins are not devalued by policy, i.e. your mechanism will never have widespread support necessary for reliably forking the chain.

>
> > Now it was brought up earlier that people are moving transactions offchain,
> > but that is perfectly fine, because every offchain mechanism first needs an
> > onchain setup, and will at some point need an onchain teardown. This
> > allows increasing the effective capacity, while still ensuring that onchain
> > fees remain at a level that will still ensure continued healthy operation of
> > the blockchain layer. Basically, the offchain mechanism does not remove
> > onchain fees, it only amortizes the onchain fees to multiple logical
> > transactions.
>
> I concede that every bitcoin user pays transaction fees, if not directly then
> indirectly, so whether miners get paid through transaction fees or a block
> reward is irrelevant. My concern is that moving things off-chain reduces the
> transaction fees by reducing demand for block-space and that this could cause
> miner revenue to drop lower than what's required to keep the network secure.
>
> Is there any good reason to think this won't happen?

Death.

No Lightning node will last forever, and its channels will be eventually be closed.
Than, any onchain funds will be in the slow expensive onchain domain, so the heirs of the dead Lightning node will want to put them back into Lightning as fast as possible.

Given the number of economic nodes we expect to eventually exist (and thus possibly die) in the future, we can expect some level of such activity in the long run.
It is helpful to remember as well that this is a long-run issue anyway.

Regards,
ZmnSCPxj

From ZmnSCPxj at protonmail.com  Tue Mar 31 02:06:32 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 31 Mar 2020 02:06:32 +0000
Subject: [bitcoin-dev] Block solving slowdown
In-Reply-To: <dUt3gYGhyaMYXiz6ZoS0whlq57ImbjYO8-z4lw4uZkqzMUHjmPoLtRSuQnM3h26wTpVFUsZWM9wH2yGWRPd-bEx2HhvWYuxKRTXYojw5hT4=@protonmail.com>
References: <20200329081136.GA15016@canndrew.org>
 <dUt3gYGhyaMYXiz6ZoS0whlq57ImbjYO8-z4lw4uZkqzMUHjmPoLtRSuQnM3h26wTpVFUsZWM9wH2yGWRPd-bEx2HhvWYuxKRTXYojw5hT4=@protonmail.com>
Message-ID: <3jzOExUBfhtM7U4lx3jMHsyHjx0Jb59CPNFso3I4zyT7S8JPRZ5-8PwlZ2Kax998mVj8xwPUB0Prdo7f0tvZnhru7xKofpsYtGJBHlmr9wQ=@protonmail.com>

Good morning Andrew,

Another thing I did not consider is how miners will actually behave under this ruleset.

Miners are the direct beneficiaries of any increased inflation rate voted in.

Miners are also ultimately the ones who decide which transactions get added into blocks, or put another way, which UTXOs are deleted and which UTXOs are created.

Thus, miners are likely to accept attempts to delete UTXOs that vote for lower inflation rates and create UTXOs that vote for higher inflation rates, and reject attempts to delete UTXOs that vote for higher inflation rates and create UTXOs that vote for lower inflation rates.

Thus, miners will end up strongly controlling the inflation rate of the coin.

Even worse, since the inflation gives increased coins to miners, more and more of the value of the coin, with which you vote for, will be in the hands of miners, who can then vote directly instead of censoring votes they dislike.

The entire point of Bitcoin having a fixed inflation rate schedule (that is ultimately disinflationary) is to avoid the moral hazard of having the beneficiaries of higher inflation rates also be the ones who decide what the inflation rate will be.

Regards,
ZmnSCPxj

From dave at dtrt.org  Tue Mar 31 10:35:08 2020
From: dave at dtrt.org (David A. Harding)
Date: Tue, 31 Mar 2020 06:35:08 -0400
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
Message-ID: <20200331103508.asvxujkhtifj6n7i@ganymede>

On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev wrote:
> Hi all,
> 
> We are starting to work on an implementation of the statechains concept (
> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39),
>
> [...]
> There are two main modifications we are looking at:
> [...]
> 
> 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE key
> and transitory key) with a single P2(W)PKH output where the public key
> shared between the SE and the current owner. The SE and the current owner
> can then sign with a 2-of-2 ECDSA MPC. 

Dr. Trevethan,

Would you be able to explain how your proposal to use statechains with
2P-ECDSA relates to your patent assigned to nChain Holdings for "Secure
off-chain blockchain transactions"?[1]  

    [1] https://patents.google.com/patent/US20200074464A1

Here are some excerpts from the application that caught my attention in
the context of statechains in general and your proposal to this list in
particular:

> an exchange platform that is trusted to implement and operate the
> transaction protocol, without requiring an on-chain transaction. The
> off-chain transactions enable one computer system to generate multiple
> transactions that are recordable to a blockchain in different
> circumstances
>
> [...]
>
> at least some of the off-chain transactions are valid for recording on
> the blockchain even in the event of a catastrophic failure of the
> exchange (e.g., exchange going permanently off-line or loosing key
> shares).
>
> [...]
>
> there may be provided a computer readable storage medium including a
> two-party elliptic curve digital signature algorithm (two-party ECDSA)
> script comprising computer executable instructions which, when
> executed, configure a processor to perform functions of a two-party
> elliptic curve digital signature algorithm described herein.
>
> [...]
>
> In this instance the malicious actor would then also have to collude
> with a previous owner of the funds to recreate the full key. Because
> an attack requires either the simultaneous theft of both exchange and
> depositor keys or collusion with previous legitimate owners of funds,
> the opportunities for a malicious attacker to compromise the exchange
> platform are limited.

Thank you,

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200331/8c3cf059/attachment.sig>

From tom at commerceblock.com  Tue Mar 31 11:41:46 2020
From: tom at commerceblock.com (Tom Trevethan)
Date: Tue, 31 Mar 2020 12:41:46 +0100
Subject: [bitcoin-dev] Statechain implementations
In-Reply-To: <20200331103508.asvxujkhtifj6n7i@ganymede>
References: <CAJvkSseW9OZ50yQiS7e0zt9tQt4v9aoikgGs_54_kMN-ORkQgw@mail.gmail.com>
 <20200331103508.asvxujkhtifj6n7i@ganymede>
Message-ID: <CAJvkSsfWoTTUOUYjQDrP-xrwB8FwAGUaDKSrYX3=-+wAE3yDLA@mail.gmail.com>

Hi David,

Just for clarity, I left nChain over 2 years ago (having worked there since
2016). While there, I (along with other researchers) were given free rein
to work on any ideas we wanted to. I had been interested in the scaling of
Bitcoin off-chain, and this was one of several things I spent time on
(including things like sidechains, pegs and threshold signatures). This
patent application came out of an idea I had to transfer ownership of UTXOs
off-chain that has some similarities to the statechains proposal, which has
shown there is interest and demand for this type of system.

Although I think the existence of this application is something to be
mindful of, there are several important things to note:

1. Although there are similarities, the current ideas are significantly
different to those in the application.
2. The key transfer protocol as described in the application is not secure
(for several reasons, including as discussed above, by Albert and Bob etc.)
- and a different mechanism is required.
3. Decrementing timelocks (as suggested in the application) are prior art
(Decker-Wattenhofer 2015), and in any case any implementation will most
likely use an 'invalidation tree' relative locktime backup mechanism for
open-ended UTXOs.
4. The patent application has not been granted (it was made in May 2017)
and the international search report rejected it on the grounds of prior
art.

Tom

On Tue, Mar 31, 2020 at 11:36 AM David A. Harding <dave at dtrt.org> wrote:

> On Wed, Mar 25, 2020 at 01:52:10PM +0000, Tom Trevethan via bitcoin-dev
> wrote:
> > Hi all,
> >
> > We are starting to work on an implementation of the statechains concept (
> >
> https://medium.com/@RubenSomsen/statechains-non-custodial-off-chain-bitcoin-transfer-1ae4845a4a39
> ),
> >
> > [...]
> > There are two main modifications we are looking at:
> > [...]
> >
> > 2. Replacing the 2-of-2 multisig output (paying to statechain entity SE
> key
> > and transitory key) with a single P2(W)PKH output where the public key
> > shared between the SE and the current owner. The SE and the current owner
> > can then sign with a 2-of-2 ECDSA MPC.
>
> Dr. Trevethan,
>
> Would you be able to explain how your proposal to use statechains with
> 2P-ECDSA relates to your patent assigned to nChain Holdings for "Secure
> off-chain blockchain transactions"?[1]
>
>     [1] https://patents.google.com/patent/US20200074464A1
>
> Here are some excerpts from the application that caught my attention in
> the context of statechains in general and your proposal to this list in
> particular:
>
> > an exchange platform that is trusted to implement and operate the
> > transaction protocol, without requiring an on-chain transaction. The
> > off-chain transactions enable one computer system to generate multiple
> > transactions that are recordable to a blockchain in different
> > circumstances
> >
> > [...]
> >
> > at least some of the off-chain transactions are valid for recording on
> > the blockchain even in the event of a catastrophic failure of the
> > exchange (e.g., exchange going permanently off-line or loosing key
> > shares).
> >
> > [...]
> >
> > there may be provided a computer readable storage medium including a
> > two-party elliptic curve digital signature algorithm (two-party ECDSA)
> > script comprising computer executable instructions which, when
> > executed, configure a processor to perform functions of a two-party
> > elliptic curve digital signature algorithm described herein.
> >
> > [...]
> >
> > In this instance the malicious actor would then also have to collude
> > with a previous owner of the funds to recreate the full key. Because
> > an attack requires either the simultaneous theft of both exchange and
> > depositor keys or collusion with previous legitimate owners of funds,
> > the opportunities for a malicious attacker to compromise the exchange
> > platform are limited.
>
> Thank you,
>
> -Dave
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20200331/5da4965d/attachment.html>

