From lf-lists at mattcorallo.com  Thu Sep  1 00:56:08 2016
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 1 Sep 2016 00:56:08 +0000
Subject: [bitcoin-dev] ScalingBitcoin 2015: Retarget - Call For
 Proposals Now Open
In-Reply-To: <CAM7BtUp79oApAPJXqDAvDrCM+4mVYumSGp1vm20dsEC=LpuZfQ@mail.gmail.com>
References: <CAM7BtUp79oApAPJXqDAvDrCM+4mVYumSGp1vm20dsEC=LpuZfQ@mail.gmail.com>
Message-ID: <57C77CA8.8090803@mattcorallo.com>

Hi all,

For those who missed it, the deadline for submissions has been extended
to Sept 9th so be sure to submit before then! We will be doing rolling
acceptance this time around to try to get most responses out before the
23rd.

Because a few folks seemed to have some confusion, the definition of
"scaling" here is pretty broad - while we definitely will have a lot of
talks on the usual tx-volume-throughput things, the topics of interest
also include things like fungibility. The full list from the site (for
inspiration purposes, this is by no means exhaustive) is:

Improving Bitcoin throughput
Layer 2 ideas (i.e. payment channels, etc.)
Security and privacy
Incentives and fee structures
Testing, simulation, and modeling
Network resilience and latency
Fungibility
Anti-spam measures
Block size proposals
Mining concerns

Thanks,
Matt

On 08/02/16 01:49, Pindar Wong via bitcoin-dev wrote:
> Dear All,
> 
> The Call for Proposals (CFP) for 'Scaling Bitcoin 2016: Retarget' is now
> open. 
> 
> Please see https://scalingbitcoin.org for details.
> 
> *Important Dates*
> 
> Sept 2nd - Deadline for submissions to the CFP
> Sept 23rd - Deadline for applicant acceptance notification
> 
> See you in Milan! (October 8th and 9th)
> 
> Ciao! :)
> 
> p.
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From jl2012 at xbt.hk  Thu Sep  1 11:29:29 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 1 Sep 2016 07:29:29 -0400 (EDT)
Subject: [bitcoin-dev] Attack by modifying non-segwit transactions after
 segwit is accepted ?
In-Reply-To: <CAKzdR-oMEe6rcusn5kajZHvWXEkneywsNEJpooss76o9WuhDxg@mail.gmail.com>
References: <CAKzdR-q4hagujzWxJxmwpxJUQFLe7SKukbDNs=_S_VKgJ9N_TA@mail.gmail.com>
	<339348690.148734.1472089774841@privateemail.com>
	<CAKzdR-oMEe6rcusn5kajZHvWXEkneywsNEJpooss76o9WuhDxg@mail.gmail.com>
Message-ID: <1348417205.55392.1472729369522@privateemail.com>

Thank you so much for taking time to actually review the codes. I hope you will keep raising questions when you feel something might be wrong. This is how things supposed to work and we should not be affected by some forum discussions.

> On August 26, 2016 at 9:16 AM Sergio Demian Lerner <sergio.d.lerner at gmail.com> wrote:
> 
>     Because there was a discussion on reddit about this topic, I want to clarify that Johnson Lau explained how a check in the code prevents this attack.
>     So there is no real attack.
> 
>     Also note that the subject of this thread has a question mark, which means that I'm asking the community for clarification, not asserting the existence of a vulnerability.
> 
>     The segwit code is complex, and some key parts of the consensus code are spread over the source files (such as state.CorruptionPossible() relation to DoS banning, IsNull() check in witness program serialization, etc.).
> 
>     Thanks again Johnson for your clarifications.
> 
> 
>     On Wed, Aug 24, 2016 at 10:49 PM, Johnson Lau <jl2012 at xbt.hk mailto:jl2012 at xbt.hk > wrote:
> 
>         > > 
> >         Adding witness data to a non-segwit script is invalid by consensus:
> > 
> >         https://github.com/bitcoin/bitcoin/blob/d612837814020ae832499d18e6ee5eb919a87907/src/script/interpreter.cpp#L1467 https://github.com/bitcoin/bitcoin/blob/d612837814020ae832499d18e6ee5eb919a87907/src/script/interpreter.cpp#L1467
> > 
> > 
> >         This PR will detect such violation early and ban the peer:
> > 
> >         https://github.com/bitcoin/bitcoin/pull/8499 https://github.com/bitcoin/bitcoin/pull/8499
> > 
> >          
> > 
> > 
> >         Another approach is to run the scripts of all incoming transactions. That's not too bad as you have already fetched the utxos which is a major part of validation.
> > 
> >     > 
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160901/9910d4f0/attachment.html>

From jl2012 at xbt.hk  Thu Sep  1 11:39:51 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Thu, 1 Sep 2016 07:39:51 -0400 (EDT)
Subject: [bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF
 malleability in P2WSH
In-Reply-To: <1736097121.90204.1471369988809@privateemail.com>
References: <1736097121.90204.1471369988809@privateemail.com>
Message-ID: <1060084086.55457.1472729991439@privateemail.com>

Restriction for segwit OP_IF argument as a policy has got a few concept ACK. I would like to have more people to ACK or NACK, especially the real users of OP_IF. I think Lightning network would use that at lot.

Pull request: https://github.com/bitcoin/bitcoin/pull/8526

more related discussion could be found at https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013036.html

It does have impact if your script uses the combination of "OP_SIZE OP_IF" or "OP_DEPTH OP_IF". With this policy/softfork, you need to use  "OP_SIZE OP_0NOTEQUAL OP_IF" or "OP_DEPTH OP_0NOTEQUAL OP_IF", or reconstruct your scripts.

> 
>     On August 16, 2016 at 1:53 PM Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
>     -----BEGIN PGP SIGNED MESSAGE-----
>     Hash: SHA512
> 
>     A new BIP is prepared to deal with OP_IF and OP_NOTIF malleability in P2WSH:
>     https://github.com/jl2012/bips/blob/minimalif/bip-minimalif.mediawiki
>     https://github.com/bitcoin/bitcoin/pull/8526
> 
>     BIP: x
>     Title: Dealing with OP_IF and OP_NOTIF malleability in P2WSH
>     Author: Johnson Lau <jl2012 at xbt.hk>
>     Status: Draft
>     Type: Standards Track
>     Created: 2016-08-17
> 
>     Abstract
> 
>     This document specifies proposed changes to the Bitcoin script validity rules in order to make transaction malleability related to OP_IF and OP_NOTIF impossible in pay-to-witness-script-hash (P2WSH) scripts.
> 
>     Motivation
> 
>     OP_IF and OP_NOTIF are flow control codes in the Bitcoin script system. The programme flow is decided by whether the top stake value is True or False. However, this behaviour opens a source of malleability as a third party may replace a True (False) stack item with any other True (False) value without invalidating the transaction.
> 
>     The proposed rules apply only to pay-to-witness-script-hash (P2WSH) scripts described in BIP141, which has not been activated on the Bitcoin mainnet as of writing. To ensure OP_IF and OP_NOTIF transactions created before the introduction of this BIP will still be accepted by the network, the new rules are not applied to non-segregated witness scripts.
> 
>     Specification
> 
>     In P2WSH, the argument for OP_IF and OP_NOTIF MUST be exactly an empty vector or 0x01, or the script evaluation fails immediately.
> 
>     This is deployed using BIP9 after segregated witness (BIP141) is activated. Details TBD.
> 
>     Compatibility
> 
>     This is a softfork on top of BIP141. The rules are enforced as a relay policy by the reference client since the first release of BIP141 (v0.13.1). To avoid risks of fund loss, users MUST NOT create P2WSH scripts that are incompatible with this BIP. An OP_0NOTEQUAL may be used before OP_IF or OP_NOTIF to imitate the original behaviour (which may also re-enable the malleability vector depending on the exact script).
> 
>     Implementation
> 
>     https://github.com/bitcoin/bitcoin/pull/8526
> 
>     Copyright
> 
>     This work is placed in the public domain.
>     -----BEGIN PGP SIGNATURE-----
>     Comment: GPGTools - https://gpgtools.org
> 
>     iQGcBAEBCgAGBQJXs1LgAAoJEO6eVSA0viTSrJQL/A/womJKgi4FuyBTL9oykCss
>     aBMNN9+SLtmuH7SBgEUGZ8TFxa2st+6RP6Imu+Vvn4O5sXQl3DIXV+X38X93sUYk
>     wrjdpvdpqFFYJezPDESz6pR/6bZ1ES0aO2QqX578/8sqr8GO6L388s66vJeIGj4n
>     0LWW8sdEypMuV3HUG/9FFdUNHgiVX1U0sS1rT3P4aN30JYtb7PQpd7r8KTMta7Rt
>     L1VOZB+W3m2m2YZ9gB7IRmMfzzNm2QXRTPIZXt2x3mYDBuMkp+zEd5+ogA4sBpgP
>     wp2+l/aos686v0w8QYiNUX2+9Qpe7+238qUpw75d2XJYmLzdotWFvmp4g1hP+awX
>     HEfwe4BUM+El17LjrHkNeMWNJXMlhTtXb2i0XMj8tU5lZVHep4WpQ+LEahrNlsUl
>     FdFsi3q8HeWh8JsGaNCL41Bgbg/rKb5hUXyF6hTRHa//E6llOrpXRnsloKgBLv8c
>     QezgKTAPwwgdjcS6Ek0AqgLp7bCFRijCduYH9i9uaQ==
>     =lLIZ
>     -----END PGP SIGNATURE-----
> 
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160901/8e47cd9f/attachment.html>

From jl2012 at xbt.hk  Fri Sep  2 04:40:58 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 2 Sep 2016 00:40:58 -0400 (EDT)
Subject: [bitcoin-dev] New BIP: Dealing with dummy stack element malleability
Message-ID: <1317364559.64256.1472791258452@privateemail.com>

https://github.com/bitcoin/bips/pull/440
https://github.com/bitcoin/bitcoin/pull/8636
This document specifies proposed changes to the Bitcoin transaction validity rules to fix the malleability of extra stack element for OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY.

The original plan was to do the LOW_S and NULLDUMMY (BIP146) together with segwit in 0.13.1. However, as we discovered some undocumented behavior in LOW_S, we may want to deploy the LOW_S softfork in a later release. https://github.com/bitcoin/bitcoin/pull/8533#issuecomment-243973512

I will edit the BIP146 later.

  BIP: ?
  Title: Dealing with dummy stack element malleability
  Author: Johnson Lau <jl2012 at xbt.hk>
  Status: Draft
  Type: Standards Track
  Created: 2016-09-02

Abstract

This document specifies proposed changes to the Bitcoin transaction validity rules to fix the malleability of extra stack element for OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY.

Motivation

Signature malleability refers to the ability of any relay node on the network to transform the signature in transactions, with no access to the relevant private keys required. For non-segregated witness transactions, signature malleability will change the txid and invalidate any unconfirmed child transactions. Although the txid of segregated witness (BIP141) transactions is not third party malleable, this malleability vector will change the wtxid and may reduce the efficiency of compact block relay (BIP152).

A design flaw in OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY makes them consuming an extra stack element ("dummy element") after signature validation. The dummy element is not inspected in any manner, and could be replaced by any value without invalidating the script. This document specifies a new rule to fix this signature malleability.

Specification

To fix the dummy element malleability, a new consensus rule ("NULLDUMMY") is deployed to require that the dummy element MUST be the empty byte array. Anything else makes the script evaluate to false immediately. The NULLDUMMY rule applies to OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY in pre-segregated scripts, and also pay-to-witness-script-hash scripts described in BIP141.

Deployment

This BIP will be deployed by "version bits" BIP9 using the same parameters for BIP141 and BIP143, with the name "segwit" and using bit 1.

For Bitcoin mainnet, the BIP9 starttime is midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout is midnight TBD UTC (Epoch timestamp TBD).

For Bitcoin testnet, the BIP9 starttime is midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout is midnight 1 May 2017 UTC (Epoch timestamp 1493596800).

Compatibility

The reference client has produced compatible signatures from the beginning, and the NULLDUMMY rule has been enforced as relay policy by the reference client since v0.10.0. There has been no transactions violating the requirement being added to the chain since at least August 2015. In addition, every non-compliant signature can trivially be converted into a compliant one, so there is no loss of functionality by this requirement.

Implementation

An implementation for the reference client is available at https://github.com/bitcoin/bitcoin/pull/8636

Acknowledgements

This document is extracted from the previous BIP62 proposal, which was composed by Pieter Wuille and had input from various people.

Copyright

This document is placed in the public domain.

From pete at petertodd.org  Fri Sep  2 05:47:14 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 2 Sep 2016 05:47:14 +0000
Subject: [bitcoin-dev] New BIP: Dealing with dummy stack element
 malleability
In-Reply-To: <1317364559.64256.1472791258452@privateemail.com>
References: <1317364559.64256.1472791258452@privateemail.com>
Message-ID: <20160902054714.GA1685@fedora-21-dvm>

On Fri, Sep 02, 2016 at 12:40:58AM -0400, Johnson Lau via bitcoin-dev wrote:
> Deployment
> 
> This BIP will be deployed by "version bits" BIP9 using the same parameters for BIP141 and BIP143, with the name "segwit" and using bit 1.
> 
> For Bitcoin mainnet, the BIP9 starttime is midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout is midnight TBD UTC (Epoch timestamp TBD).
> 
> For Bitcoin testnet, the BIP9 starttime is midnight 1 May 2016 UTC (Epoch timestamp 1462060800) and BIP9 timeout is midnight 1 May 2017 UTC (Epoch timestamp 1493596800).
> 
> Compatibility
> 
> The reference client has produced compatible signatures from the beginning, and the NULLDUMMY rule has been enforced as relay policy by the reference client since v0.10.0. There has been no transactions violating the requirement being added to the chain since at least August 2015. In addition, every non-compliant signature can trivially be converted into a compliant one, so there is no loss of functionality by this requirement.

This should say "for all scriptPubKey types in actual use, non-compliant
signatures can trivially be converted into compliant ones"

You can of course create a scriptPubKey where that's not possible, but
fortunately no-one appears to do that.


Also, as original author of NULLDUMMY, thanks for finally making it into a
soft-fork!

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160902/1a8b627a/attachment.sig>

From jl2012 at xbt.hk  Fri Sep  2 08:28:14 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 2 Sep 2016 04:28:14 -0400 (EDT)
Subject: [bitcoin-dev] New BIP: Low S values signatures
In-Reply-To: <212784600.96759.1471437827809@privateemail.com>
References: <835406850.86951.1471342201363@privateemail.com>
	<212784600.96759.1471437827809@privateemail.com>
Message-ID: <702023483.65145.1472804894528@privateemail.com>

https://github.com/bitcoin/bips/pull/441

The BIP146 is revised the second time:

1. NULLDUMMY is removed from BIP146 and becomes another softfork that will implement at the same time as segwit?https://github.com/bitcoin/bips/pull/440

2. A new rule, namely NULLFAIL, is added to require empty signature(s) when a CHECK(MULTI)SIG returns a FALSE

3. NULLFAIL will be implemented as a policy rule in 0.13.1. However, the softfork won't be deployed in 0.13.1.

As we discovered some undocumented behavior in LOW_S, we may want to deploy the LOW_S softfork in a later release.?The newly added NULLFAIL rules should cover all the special cases.?https://github.com/bitcoin/bitcoin/pull/8533#issuecomment-243973512

--------
BIP: 146
  Title: Dealing with signature encoding malleability
  Author: Johnson Lau <jl2012 at xbt.hk>
          Pieter Wuille <pieter.wuille at gmail.com>
  Status: Draft
  Type: Standards Track
  Created: 2016-08-16

Abstract

This document specifies proposed changes to the Bitcoin transaction validity rules to fix signature malleability related to ECDSA signature encoding.

Motivation

Signature malleability refers to the ability of any relay node on the network to transform the signature in transactions, with no access to the relevant private keys required. For non-segregated witness transactions, signature malleability will change the txid and invalidate any unconfirmed child transactions. Although the txid of segregated witness (BIP141) transactions is not third party malleable, this malleability vector will change the wtxid and may reduce the efficiency of compact block relay (BIP152).

Since the enforcement of Strict DER signatures (BIP66), there are 2 remaining known sources of malleability in ECDSA signatures:

Inherent ECDSA signature malleability: ECDSA signatures are inherently malleable as taking the negative of the number S inside (modulo the curve order) does not invalidate it.
Malleability of failing signature: If a signature failed to validate in OP_CHECKSIG or OP_CHECKMULTISIG, a FALSE would be returned to the stack and the script evaluation would continue. The failing signature may take any value, as long as it follows all the rules described in BIP66.
This document specifies new rules to fix the aforesaid signature malleability.
Specification

To fix signature malleability, the following new rules are applied:

LOW_S

We require that the S value inside ECDSA signatures is at most the curve order divided by 2 (essentially restricting this value to its lower half range). Every signature passed to OP_CHECKSIG[1], OP_CHECKSIGVERIFY, OP_CHECKMULTISIG, or OP_CHECKMULTISIGVERIFY, to which ECDSA verification is applied, MUST use a S value between 0x1 and 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0 (inclusive) with strict DER encoding (see BIP66).

If a signature passing to ECDSA verification does not pass the Low S value check and is not an empty byte array, the entire script evaluates to false immediately.

A high S value in signature could be trivially replaced by S' = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141 - S.

NULLFAIL

If an OP_CHECKSIG is trying to return a FALSE value to the stack, we require that the relevant signature must be an empty byte array.

If an OP_CHECKMULTISIG is trying to return a FALSE value to the stack, we require that all signatures passing to this OP_CHECKMULTISIG must be empty byte arrays, even the processing of some signatures might have been skipped due to early termination of the signature verification.

Otherwise, the entire script evaluates to false immediately.

Examples

The following examples combine the LOW_S and NULLFAIL rules.

Notation:

  CO       : curve order = 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141
  HCO      : half curve order = CO / 2 = 0x7FFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 5D576E73 57A4501D DFE92F46 681B20A0
  P1, P2   : valid, serialized, public keys
  S1L, S2L : valid low S value signatures using respective keys P1 and P2 (1 ? S ? HCO)
  S1H, S2H : signatures with high S value (otherwise valid) using respective keys P1 and P2 (HCO < S < CO)
  F        : any BIP66-compliant non-empty byte array but not a valid signature

These scripts will return a TRUE to the stack as before:

  S1L P1 CHECKSIG
  0 S1L S2L 2 P1 P2 2 CHECKMULTISIG

These scripts will return a FALSE to the stack as before:

  0 P1 CHECKSIG
  0 0 0 2 P1 P2 2 CHECKMULTISIG

These previously TRUE scripts will fail immediately under the new rules:

  S1H P1 CHECKSIG
  0 S1H S2L 2 P1 P2 2 CHECKMULTISIG
  0 S1L S2H 2 P1 P2 2 CHECKMULTISIG
  0 S1H S2H 2 P1 P2 2 CHECKMULTISIG
These previously FALSE scripts will fail immediately under the new rules:

  F P1 CHECKSIG
  0 S2L S1L 2 P1 P2 2 CHECKMULTISIG
  0 S1L F   2 P1 P2 2 CHECKMULTISIG
  0 F   S2L 2 P1 P2 2 CHECKMULTISIG
  0 S1L 0   2 P1 P2 2 CHECKMULTISIG
  0 0   S2L 2 P1 P2 2 CHECKMULTISIG
  0 F   0   2 P1 P2 2 CHECKMULTISIG
  0 0   F   2 P1 P2 2 CHECKMULTISIG

Deployment

This BIP will be deployed by "version bits" BIP9. Details TBD.

For Bitcoin mainnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).

For Bitcoin testnet, the BIP9 starttime will be midnight TBD UTC (Epoch timestamp TBD) and BIP9 timeout will be midnight TBD UTC (Epoch timestamp TBD).

Compatibility

The reference client has produced LOW_S compatible signatures since v0.9.0, and the LOW_S rule has been enforced as relay policy by the reference client since v0.11.1. As of August 2016, very few transactions violating the requirement are being added to the chain. For all scriptPubKey types in actual use, non-compliant signatures can trivially be converted into compliant ones, so there is no loss of functionality by these requirements.

Scripts with failing OP_CHECKSIG or OP_CHECKMULTISIG rarely happen on the chain. The NULLFAIL rule has been enforced as relay policy by the reference client since v0.13.1.

Users MUST pay extra attention to these new rules when designing exotic scripts.

Implementation

Implementations for the reference client is available at:

https://github.com/bitcoin/bitcoin/blob/35fe0393f216aa6020fc929272118eade5628636/src/script/interpreter.cpp#L185

and

https://github.com/bitcoin/bitcoin/pull/8634

Footnotes

^ Including pay-to-witness-public-key-hash (P2WPKH) described in BIP141
Acknowledgements

This document is extracted from the previous BIP62 proposal which had input from various people.

Copyright

This document is placed in the public domain.

--------

> On August 17, 2016 at 8:43 AM Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> The BIP146 has been updated to include NULLDUMMY* as part of the softfork:
> 
> https://github.com/bitcoin/bips/pull/435
> 
> NULLDUMMY is a trivial softfork to fix malleability related to the extra stack element consumed by CHECKMULTISIG(VERIFY). It?is probably more important than LOW_S since without that an attacker may replace the stack element with any value.

> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From tomh at thinlink.com  Fri Sep  2 17:10:40 2016
From: tomh at thinlink.com (Tom Harding)
Date: Fri, 2 Sep 2016 10:10:40 -0700
Subject: [bitcoin-dev] New BIP: Dealing with dummy stack element
 malleability
In-Reply-To: <1317364559.64256.1472791258452@privateemail.com>
References: <1317364559.64256.1472791258452@privateemail.com>
Message-ID: <198f7a5e-7912-dfb2-1b61-388a4f81b7b5@thinlink.com>

On 9/1/2016 9:40 PM, Johnson Lau via bitcoin-dev wrote:
> This BIP will be deployed by "version bits" BIP9 using the same parameters for BIP141 and BIP143, with the name "segwit" and using bit 1.
>

This fix has value outside of segwit.  Why bundle the two together? 
Shouldn't miners have to opportunity to vote on them independently?



From jl2012 at xbt.hk  Sun Sep  4 12:29:37 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sun, 4 Sep 2016 08:29:37 -0400 (EDT)
Subject: [bitcoin-dev] New BIP: Dealing with dummy stack element
 malleability
In-Reply-To: <198f7a5e-7912-dfb2-1b61-388a4f81b7b5@thinlink.com>
References: <1317364559.64256.1472791258452@privateemail.com>
	<198f7a5e-7912-dfb2-1b61-388a4f81b7b5@thinlink.com>
Message-ID: <1966185375.94265.1472992177565@privateemail.com>

Although it is technically possible to bundle 2 independent softforks in one release, it increases the burden of testing and maintenance. We need to test and prepare for 4 scenarios: both not activated, only NULLDUMMY activated, only SEGWIT activated, and both activated.

Also, as we learnt from BIP66, softfork activation could be risky. It is evident that today a non-negligible percentage of miners are hard-coding the block version number. This increases the risks of softfork transition as miners may not enforce what they are signaling (btw this is also happening on testnet) Making 2 independently softforks would double the risks, and I believe NULLDUMMY alone is not worth the risks.
 
> On September 2, 2016 at 1:10 PM Tom Harding via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
> On 9/1/2016 9:40 PM, Johnson Lau via bitcoin-dev wrote:
> > This BIP will be deployed by "version bits" BIP9 using the same parameters for BIP141 and BIP143, with the name "segwit" and using bit 1.
> >
> 
> This fix has value outside of segwit.  Why bundle the two together? 
> Shouldn't miners have to opportunity to vote on them independently?
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From roconnor at blockstream.io  Mon Sep  5 14:55:10 2016
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 5 Sep 2016 10:55:10 -0400
Subject: [bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF
 malleability in P2WSH
In-Reply-To: <CAPg+sBhykn8BU1LAr1izH0z6nFuOv0PzWjuqq7YJX5r35LDa9Q@mail.gmail.com>
References: <1736097121.90204.1471369988809@privateemail.com>
	<201608161937.20748.luke@dashjr.org>
	<20160816194332.GA5888@fedora-21-dvm>
	<CAMZUoKkAkGRFxpyGMxQMz76L7uW6fsQAYVxkrxi5MQCiBtNnqw@mail.gmail.com>
	<CAPg+sBi30SgHHXCyipbNpiMRHYWPCRYz6ejQYKrDg3MLJp39EQ@mail.gmail.com>
	<CAMZUoKktS=Ku4kpD0bocR4X__ZpWXrkPkdOyXBaYxjq+mr9Pmw@mail.gmail.com>
	<CAPg+sBhykn8BU1LAr1izH0z6nFuOv0PzWjuqq7YJX5r35LDa9Q@mail.gmail.com>
Message-ID: <CAMZUoKnNHkUtiwT=PKg25HmiEFZQfXxY8P2G=QZ+NJZBQDTTcg@mail.gmail.com>

For sake of example, suppose we have a marginal fee rate of 50 satoshis per
byte.  At that rate reducing the size of the witness data by 1 byte is
approximately equivalent from a miner and relayer's perspective as a
replace by fee that increases the fee by 50 satoshis.  In both cases miners
get an extra potential of 50 satoshis in revenue.

So in this sense replacing witness data with smaller witness data can pay
for its own relay cost as much as RBF can simply by requiring that the
smaller witness be smaller enough to cover the same RBF threshold.

On Tue, Aug 16, 2016 at 6:39 PM, Pieter Wuille <pieter.wuille at gmail.com>
wrote:

> On Aug 17, 2016 00:36, "Russell O'Connor" <roconnor at blockstream.io> wrote:
>
> > Can I already do something similar with replace by fee, or are there
> limits on that?
>
> BIP125 and mempool eviction both require the replacing transaction to have
> higher fee, to compensate for the cost of relaying the replaced
> transaction(s).
>
> --
> Pieter
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160905/27c7324f/attachment.html>

From rusty at rustcorp.com.au  Mon Sep  5 01:32:19 2016
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Mon, 05 Sep 2016 11:02:19 +0930
Subject: [bitcoin-dev] New BIP: Dealing with OP_IF and OP_NOTIF
	malleability in P2WSH
In-Reply-To: <1060084086.55457.1472729991439@privateemail.com>
References: <1736097121.90204.1471369988809@privateemail.com>
	<1060084086.55457.1472729991439@privateemail.com>
Message-ID: <871t0z8730.fsf@rustcorp.com.au>

Johnson Lau via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
writes:
> Restriction for segwit OP_IF argument as a policy has got a few concept ACK. I would like to have more people to ACK or NACK, especially the real users of OP_IF. I think Lightning network would use that at lot.

My current scripts use OP_IF and OP_NOTIF only after OP_EQUAL, except
for one place where they use OP_EQUAL ... OP_EQUAL... OP_ADD OP_IF
(where the two OP_EQUALs are comparing against different hashes, so only
0 or 1 of the two OP_EQUAL can return 1).

So there's no effect either way on the c-lightning implementation, at
least.

Thanks!
Rusty.

From Daniel.Weigl at mycelium.com  Wed Sep  7 09:42:24 2016
From: Daniel.Weigl at mycelium.com (Daniel Weigl)
Date: Wed, 7 Sep 2016 11:42:24 +0200
Subject: [bitcoin-dev] [cont'd] Derivation scheme for P2WPKH-nested-in-P2SH
	based accounts
In-Reply-To: <5760259B.7040409@mycelium.com>
References: <5760259B.7040409@mycelium.com>
Message-ID: <516ecb1e-d8a8-719d-629b-59af808c1b6b@mycelium.com>

Hello again,

sorry, got a bit derailed on that proposal.
But now I think its time to work on it again.

- Any objections to get a BIP-number for it? 
	If not, can I get one, so I can finish up the test vectors.
	Current version: https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki 

- I decided against extending it for future P2WPKH addresses
	I think that should be a separate account on its own, to reduce implementation work 
	for future wallets, that only want/need to implement P2WPKH accounts. And to keep it simple.
	Was someone working on the P2WPKH address format in the meantime? (ie. alternative for [2])

- We will also need a extension to the BIP32 serialization format[1]
	It should be possible to export/import a xPriv/xPub key across compatible wallets, and they
	should be able without guesswork, fuzzy checks or asking the user to import the correct account type.
	Thinking about some flexible tag-based backwards compatible extensions - but thats a different BIP in itself.


Cheers,
Daniel


[1] https://github.com/DanielWeigl/bips/blob/master/bip-0032.mediawiki#Serialization_format
[2] https://github.com/bitcoin/bips/blob/master/bip-0142.mediawiki

On 2016-06-14 17:41, Daniel Weigl via bitcoin-dev wrote:
> Hi List,
> 
> Following up to the discussion last month ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012695.html ), ive prepared a proposal for a BIP here:
> 	
> 	https://github.com/DanielWeigl/bips/blob/master/bip-p2sh-accounts.mediawiki
> 
> 
> Any comments on it? Does anyone working on a BIP44 compliant wallet implement something different?
> If there are no objection, id also like to request a number for it.
> 
> Thx,
> Daniel
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From greg at xiph.org  Sat Sep 10 00:42:30 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 10 Sep 2016 00:42:30 +0000
Subject: [bitcoin-dev] Completing the retirement of the alert system
Message-ID: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>

The alert system was a centralized facility to allow trusted parties
to send messages to be displayed in wallet software (and, very early
on, actually remotely trigger the software to stop transacting).

It has been removed completely in Bitcoin Core after being disabled for a while.

While the system had some potential uses, there were a number of
problems with it.

The alert system was a frequent source of misunderstanding about the
security model and 'effective governance', for example a years ago a
BitcoinJ developer wanted it to be used to control fee levels on the
network and few months back one of Bloq's staff was pushing for a
scheme where "the developers" would use it to remotely change the
difficulty-- apparently with no idea how abhorrent others would find
it.

The system also had a problem of not being scalable to different
software vendors-- it didn't really make sense that core would have
that facility but armory had to do something different (nor would it
really make sense to constantly have to maintain some list of keys in
the node software).

It also had the problem of being unaccountable. No one can tell which
of the key holders created a message. This creates a risk of misuse
with a false origin to attack someone's reputation.

Finally, there is good reason to believe that the key has been
compromised-- It was provided to MTGox by a developer and MTGox's
systems' were compromised and later their CEO's equipment taken by the
Japanese police.

In any case, it's gone now in Core and most other current software--
and I think it's time to fully deactivate it.

I've spent some time going around the internet looking for all
software that contains this key (which included a few altcoins) and
asked them to remove it. I will continue to do that.

One of the facilities in the alert system is that you can send a
maximum sequence alert which cannot be overridden and displays only a
static key compromise text message and blocks all other alerts. I plan
to send a triggering alert in the not-distant future (exact time to be
announced well in advance) feedback on timing would be welcome.

There are likely a few production systems that automatically shut down
when there is an alert, so this risks some small one-time disruption
of those services-- but none worse than if an alert were sent to
advise about a new system upgrade.

At some point after that, I would then plan to disclose this private
key in public, eliminating any further potential of reputation attacks
and diminishing the risk of misunderstanding the key as some special
trusted source of authority.

Cheers,

From pete at petertodd.org  Sat Sep 10 00:58:02 2016
From: pete at petertodd.org (Peter Todd)
Date: Sat, 10 Sep 2016 00:58:02 +0000
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
Message-ID: <20160910005802.GA24954@fedora-21-dvm>

On Sat, Sep 10, 2016 at 12:42:30AM +0000, Gregory Maxwell via bitcoin-dev wrote:
> The alert system was a centralized facility to allow trusted parties
> to send messages to be displayed in wallet software (and, very early
> on, actually remotely trigger the software to stop transacting).

<snip>

> One of the facilities in the alert system is that you can send a
> maximum sequence alert which cannot be overridden and displays only a
> static key compromise text message and blocks all other alerts. I plan
> to send a triggering alert in the not-distant future (exact time to be
> announced well in advance) feedback on timing would be welcome.
> 
> There are likely a few production systems that automatically shut down
> when there is an alert, so this risks some small one-time disruption
> of those services-- but none worse than if an alert were sent to
> advise about a new system upgrade.
> 
> At some point after that, I would then plan to disclose this private
> key in public, eliminating any further potential of reputation attacks
> and diminishing the risk of misunderstanding the key as some special
> trusted source of authority.

ACK

Good to do this sooner rather than later, as alert propagation on the P2P
network is going to continue to get less reliable as nodes upgrade to software
that has removed alert functionality; better that the final alert key
retirement message is reliably seen by the remaining software out there in a
predictable way than this be something that happens unpredictably.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160910/972d0258/attachment.sig>

From eric at voskuil.org  Sat Sep 10 00:54:28 2016
From: eric at voskuil.org (Eric Voskuil)
Date: Fri, 9 Sep 2016 17:54:28 -0700
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
Message-ID: <474CB187-0642-452C-AE1B-00D46FAE8BAF@voskuil.org>

ACK

libbitcoin defines the message and includes the public key but only for completeness and reference purposes. It has never been used in the node.

e

> On Sep 9, 2016, at 5:42 PM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> The alert system was a centralized facility to allow trusted parties
> to send messages to be displayed in wallet software (and, very early
> on, actually remotely trigger the software to stop transacting).
> 
> It has been removed completely in Bitcoin Core after being disabled for a while.
> 
> While the system had some potential uses, there were a number of
> problems with it.
> 
> The alert system was a frequent source of misunderstanding about the
> security model and 'effective governance', for example a years ago a
> BitcoinJ developer wanted it to be used to control fee levels on the
> network and few months back one of Bloq's staff was pushing for a
> scheme where "the developers" would use it to remotely change the
> difficulty-- apparently with no idea how abhorrent others would find
> it.
> 
> The system also had a problem of not being scalable to different
> software vendors-- it didn't really make sense that core would have
> that facility but armory had to do something different (nor would it
> really make sense to constantly have to maintain some list of keys in
> the node software).
> 
> It also had the problem of being unaccountable. No one can tell which
> of the key holders created a message. This creates a risk of misuse
> with a false origin to attack someone's reputation.
> 
> Finally, there is good reason to believe that the key has been
> compromised-- It was provided to MTGox by a developer and MTGox's
> systems' were compromised and later their CEO's equipment taken by the
> Japanese police.
> 
> In any case, it's gone now in Core and most other current software--
> and I think it's time to fully deactivate it.
> 
> I've spent some time going around the internet looking for all
> software that contains this key (which included a few altcoins) and
> asked them to remove it. I will continue to do that.
> 
> One of the facilities in the alert system is that you can send a
> maximum sequence alert which cannot be overridden and displays only a
> static key compromise text message and blocks all other alerts. I plan
> to send a triggering alert in the not-distant future (exact time to be
> announced well in advance) feedback on timing would be welcome.
> 
> There are likely a few production systems that automatically shut down
> when there is an alert, so this risks some small one-time disruption
> of those services-- but none worse than if an alert were sent to
> advise about a new system upgrade.
> 
> At some point after that, I would then plan to disclose this private
> key in public, eliminating any further potential of reputation attacks
> and diminishing the risk of misunderstanding the key as some special
> trusted source of authority.
> 
> Cheers,
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From achow101 at gmail.com  Sat Sep 10 01:31:16 2016
From: achow101 at gmail.com (Andrew C)
Date: Fri, 9 Sep 2016 21:31:16 -0400
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
Message-ID: <38df6d39-5c88-9f01-3457-77c882440d42@gmail.com>

ACK

Armory used to contain code for handling these alerts but that was
removed after the PR removing alerts from Bitcoin Core was merged.


On 9/9/2016 8:42 PM, Gregory Maxwell via bitcoin-dev wrote:
> The alert system was a centralized facility to allow trusted parties
> to send messages to be displayed in wallet software (and, very early
> on, actually remotely trigger the software to stop transacting).
>
> It has been removed completely in Bitcoin Core after being disabled for a while.
>
> While the system had some potential uses, there were a number of
> problems with it.
>
> The alert system was a frequent source of misunderstanding about the
> security model and 'effective governance', for example a years ago a
> BitcoinJ developer wanted it to be used to control fee levels on the
> network and few months back one of Bloq's staff was pushing for a
> scheme where "the developers" would use it to remotely change the
> difficulty-- apparently with no idea how abhorrent others would find
> it.
>
> The system also had a problem of not being scalable to different
> software vendors-- it didn't really make sense that core would have
> that facility but armory had to do something different (nor would it
> really make sense to constantly have to maintain some list of keys in
> the node software).
>
> It also had the problem of being unaccountable. No one can tell which
> of the key holders created a message. This creates a risk of misuse
> with a false origin to attack someone's reputation.
>
> Finally, there is good reason to believe that the key has been
> compromised-- It was provided to MTGox by a developer and MTGox's
> systems' were compromised and later their CEO's equipment taken by the
> Japanese police.
>
> In any case, it's gone now in Core and most other current software--
> and I think it's time to fully deactivate it.
>
> I've spent some time going around the internet looking for all
> software that contains this key (which included a few altcoins) and
> asked them to remove it. I will continue to do that.
>
> One of the facilities in the alert system is that you can send a
> maximum sequence alert which cannot be overridden and displays only a
> static key compromise text message and blocks all other alerts. I plan
> to send a triggering alert in the not-distant future (exact time to be
> announced well in advance) feedback on timing would be welcome.
>
> There are likely a few production systems that automatically shut down
> when there is an alert, so this risks some small one-time disruption
> of those services-- but none worse than if an alert were sent to
> advise about a new system upgrade.
>
> At some point after that, I would then plan to disclose this private
> key in public, eliminating any further potential of reputation attacks
> and diminishing the risk of misunderstanding the key as some special
> trusted source of authority.
>
> Cheers,
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From greg at xiph.org  Sat Sep 10 01:48:40 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 10 Sep 2016 01:48:40 +0000
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <20160910005802.GA24954@fedora-21-dvm>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
	<20160910005802.GA24954@fedora-21-dvm>
Message-ID: <CAAS2fgQSQMojm6srKD_enNYu=bw04JPgH1S6__920qjVGh5EFQ@mail.gmail.com>

On Sat, Sep 10, 2016 at 12:58 AM, Peter Todd <pete at petertodd.org> wrote:
> Good to do this sooner rather than later, as alert propagation on the P2P
> network is going to continue to get less reliable as nodes upgrade to software

Yes, this was one of my motivations for doing this soon.

It would only require about 2 LOC to have Bitcoin Core vomit out a
blob containing the final alert to any old protocol version peers that
connect.  I don't know how other people would feel about that, but I
wouldn't mind implementing it, and it would greatly improve the
likelihood that they continue to to get once propagation of it is
gone. This could be left in the codebase for a couple years or until
other changes made those old versions p2p incompatible for other
reasons.

From pete at petertodd.org  Sat Sep 10 02:19:06 2016
From: pete at petertodd.org (Peter Todd)
Date: Sat, 10 Sep 2016 02:19:06 +0000
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <CAAS2fgQSQMojm6srKD_enNYu=bw04JPgH1S6__920qjVGh5EFQ@mail.gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
	<20160910005802.GA24954@fedora-21-dvm>
	<CAAS2fgQSQMojm6srKD_enNYu=bw04JPgH1S6__920qjVGh5EFQ@mail.gmail.com>
Message-ID: <20160910021906.GA25516@fedora-21-dvm>

On Sat, Sep 10, 2016 at 01:48:40AM +0000, Gregory Maxwell wrote:
> On Sat, Sep 10, 2016 at 12:58 AM, Peter Todd <pete at petertodd.org> wrote:
> > Good to do this sooner rather than later, as alert propagation on the P2P
> > network is going to continue to get less reliable as nodes upgrade to software
> 
> Yes, this was one of my motivations for doing this soon.
> 
> It would only require about 2 LOC to have Bitcoin Core vomit out a
> blob containing the final alert to any old protocol version peers that
> connect.  I don't know how other people would feel about that, but I
> wouldn't mind implementing it, and it would greatly improve the
> likelihood that they continue to to get once propagation of it is
> gone. This could be left in the codebase for a couple years or until
> other changes made those old versions p2p incompatible for other
> reasons.

I think that's a good idea, and it's a simple way to document that final alert
as well.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160910/3071c2e5/attachment.sig>

From laanwj at gmail.com  Sat Sep 10 05:51:17 2016
From: laanwj at gmail.com (Wladimir J. van der Laan)
Date: Sat, 10 Sep 2016 07:51:17 +0200
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
Message-ID: <20160910055117.GA5726@amethyst.visucore.com>

On Sat, Sep 10, 2016 at 12:42:30AM +0000, Gregory Maxwell via bitcoin-dev wrote:
> The alert system was a centralized facility to allow trusted parties
> to send messages to be displayed in wallet software (and, very early
> on, actually remotely trigger the software to stop transacting).
> 
> It has been removed completely in Bitcoin Core after being disabled for a while.

As it has been disabled in relevant software I think it's mostly symbolic at
this point, but yes, it makes sense to 'officially' retire the key. Let's
pin the date and make it widely known.

Doing this in organized fashion is much better than the whodunit that would
undoubtly follow when the key would simply leak, which could happen at any
time, as no one can know who it has spread to over all those years.

Re: timing, I'd say leave three months grace time after this announcement for
altcoins and such that may have accidentally have copied it to remove it, then
at the beginning of 2017 broadcast the final alert.

After that it's neutered, it's up to each of us that has the key to reveal it
or not or when. It's a historical curiosity then.

Wladimir

From jl2012 at xbt.hk  Sat Sep 10 09:41:21 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 10 Sep 2016 17:41:21 +0800
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
Message-ID: <15713790962.be73b87e4580.3663496705131622210@xbt.hk>

Concept ACK.

For the details of executing the plan, I think the following is less disruptive:

1. Send a message with (max sequence - 1), notifying all nodes that the key will be retired on or before a date. People with systems relying on this key should either upgrade or ignore the revocation message. We don't know the actual date because the key is shared by many people.

With the max - 1 sequence, no message except the max sequence revocation message may override this message. 

2. Send the revocation message at the pre-announced time, if no one have done that before

3. After a few months or so, publish the private key.

 >  
 > One of the facilities in the alert system is that you can send a 
 > maximum sequence alert which cannot be overridden and displays only a 
 > static key compromise text message and blocks all other alerts. I plan 
 > to send a triggering alert in the not-distant future (exact time to be 
 > announced well in advance) feedback on timing would be welcome. 
 >  
 > There are likely a few production systems that automatically shut down 
 > when there is an alert, so this risks some small one-time disruption 
 > of those services-- but none worse than if an alert were sent to 
 > advise about a new system upgrade. 
 >  
 > At some point after that, I would then plan to disclose this private 
 > key in public, eliminating any further potential of reputation attacks 
 > and diminishing the risk of misunderstanding the key as some special 
 > trusted source of authority. 
 >  
 > Cheers, 
 > _______________________________________________ 
 > bitcoin-dev mailing list 
 > bitcoin-dev at lists.linuxfoundation.org 
 > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev 
 > 



From jl2012 at xbt.hk  Sat Sep 10 09:29:50 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 10 Sep 2016 17:29:50 +0800
Subject: [bitcoin-dev] Proposed segwit related consensus and policy rules in
 Bitcoin Core 0.13.1
Message-ID: <157136e7ad6.122f8dcad4225.6188604322226919947@xbt.hk>

There are several opening pull requests for segwit related consensus and policy rules. This email summarize and explain the rationale.

As a general warning, people must not assume that a script spendable in pre-segwit system would also be spendable as a segwit script. They share much similarity but there are also notable differences, such as BIP143 and those proposals listed below. In any case, test your segwit system on testnet with the standard rules turned on, and a small amount of money after segwit is activated on mainnet.

*******************
Script Malleability fixes: Segwit (BIP141) fixes the most nasty malleability in Bitcoin: transaction ID malleability. However, due to the flexibility of scripting system, it is still possible for a relay node to insert arbitrary data to the witness without invalidating the transaction. Although segwit makes such attacks much harmless, this could still be annoying as people may write data to the blockchain at others costs.

NULLDUMMY, MINIMALIF, NULLFAIL are fixing this type of problem. NULLDUMMY has been implemented as a policy for more than a year and a softfork is proposed in the upcoming 0.13.1. MINIMALIF and NULLFAIL are both new policy proposed for 0.13.1, and may become softforks in the future. Script designers must pay attention to these potential softforks to avoid creation of unspendable scripts.

Consensus:
BIP147 "NULLDUMMY" softfork (for both segwit and pre-segwit scripts)
PR: https://github.com/bitcoin/bitcoin/pull/8636
Related discussion: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013096.html

Policy:
"MINIMALIF" Minimal OP_IF/NOTIF argument (segwit scripts only)
PR: https://github.com/bitcoin/bitcoin/pull/8526
Related discussion: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html

Policy:
"NULLFAIL" Null signature for failed CHECK(MULTI)SIG (for both segwit and pre-segwit scripts)
PR: https://github.com/bitcoin/bitcoin/pull/8634
Related discussion: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-September/013098.html

*******************

Policy: Resources limit for P2WSH
PR: https://github.com/bitcoin/bitcoin/pull/8499

For P2WSH, a policy limit is proposed with witnessScript <= 3600 bytes, witness stack item size <= 80 bytes, and witness stack items <= 100

3600 bytes witnessScript and 100 stack items are adequate for a n-of-100 multisig using 100 OP_CHECKSIG, 99 OP_ADD, and 1 OP_EQUAL. Before segwit, the biggest standard mutlisig is n-of-15 with P2SH.

The max size for ECDSA signature is 73 bytes and nothing (except hashing opcodes) should use more than that with the current scripting language.

This is to prevent abuse of witness space, and reduce the risks of DoS attack with some unknown special and big scripts.

The consensus limits described in BIP141 are not changed, as witnessScript <= 10000 bytes and  witness stack item size <= 520 bytes. (There is also an implied limit for witness stack items of 412, see the inline comments in #8499)

*******************

Policy: Public key must be compressed (segwit only)
PR: https://github.com/bitcoin/bitcoin/pull/8499

It is proposed that only compressed keys (33 bytes starting with 0x02 or 0x03) are allowed in segwit scripts.

This is a policy only and non-compressed keys are still valid in a block. A softfork based on this may be proposed with further risks and benefits analysis

We can't have such policy or softfork in non-segwit scripts since there are many UTXOs being stored that way. Since segwit is a completely new script system, there is no strong reasons to support non-compressed keys.

Wallet developers must pay attention to this policy and must not assume that existing P2PKH hashes or P2SH scripts are spendable in segwit.

The RPC command addwitnessaddress will refuse to return a segwit address if the given key/multi-sig is unknown or is not compressed.

createwitnessaddress will return an address for whatever scripts given, without checking the validity at all. (even an OP_RETURN is provided, it will still return a P2WSH address). We may need to give a warning, or simply remove this command.

*******************

DoS protection: Banning peers for sending certain types of consensus invalid witness
PR: https://github.com/bitcoin/bitcoin/pull/8499

Peers sending certain types of invalid witness will be banned before fee and SigOp policy are checked. Those are all based on explicit or implicit consensus rules, and will protect P2WPKH and canonical multisigs against the DoS issues described in #8279. The rest of P2WSH scripts will be covered by #8525 by not storing witness txs in rejection cache.

*******************

DoS protection:  Mandatory softfork flags for segwit txs
PR: https://github.com/bitcoin/bitcoin/pull/8499

Since all segwit-aware nodes must be aware of all existing softforks, including BIP66, 65, 112, 141, and 143, the verification flags for these BIPs will be mandatory for transactions with non-empty witness.  Wallets relaying witness transactions violating these rules will be banned (even if the violation happens in a non-segwit input).





From achow101 at gmail.com  Sat Sep 10 13:23:44 2016
From: achow101 at gmail.com (Andrew C)
Date: Sat, 10 Sep 2016 09:23:44 -0400
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <15713790962.be73b87e4580.3663496705131622210@xbt.hk>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
	<15713790962.be73b87e4580.3663496705131622210@xbt.hk>
Message-ID: <bf57ea1e-87b6-52ae-3f92-23e62f936592@gmail.com>

On 9/10/2016 5:41 AM, Johnson Lau via bitcoin-dev wrote:
> 3. After a few months or so, publish the private key.
Why wait a few months? Why not just publish the key a few days after the
final alert?

From jl2012 at xbt.hk  Sat Sep 10 14:57:35 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Sat, 10 Sep 2016 22:57:35 +0800
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <bf57ea1e-87b6-52ae-3f92-23e62f936592@gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
	<15713790962.be73b87e4580.3663496705131622210@xbt.hk>
	<bf57ea1e-87b6-52ae-3f92-23e62f936592@gmail.com>
Message-ID: <157149a8c52.c9ee4f1614159.5615429506535064236@xbt.hk>

We need to make sure the revocation message is widely distributed before making the private key public


 ---- On Sat, 10 Sep 2016 21:23:37 +0800 Andrew C <achow101 at gmail.com> wrote ---- 
 > On 9/10/2016 5:41 AM, Johnson Lau via bitcoin-dev wrote: 
 > > 3. After a few months or so, publish the private key. 
 > Why wait a few months? Why not just publish the key a few days after the 
 > final alert? 
 > 



From greg at xiph.org  Sat Sep 10 15:36:38 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 10 Sep 2016 15:36:38 +0000
Subject: [bitcoin-dev] Completing the retirement of the alert system
In-Reply-To: <bf57ea1e-87b6-52ae-3f92-23e62f936592@gmail.com>
References: <CAAS2fgTYOUSm07N4NYDCsjjwSbAo_ye84UvbQF--3JzhLHkG0Q@mail.gmail.com>
	<15713790962.be73b87e4580.3663496705131622210@xbt.hk>
	<bf57ea1e-87b6-52ae-3f92-23e62f936592@gmail.com>
Message-ID: <CAAS2fgRECo8VGQXaQEhJwZMsYYiP=2Ck3b3f45mT62fofL316w@mail.gmail.com>

On Sat, Sep 10, 2016 at 1:23 PM, Andrew C via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On 9/10/2016 5:41 AM, Johnson Lau via bitcoin-dev wrote:
>> 3. After a few months or so, publish the private key.
> Why wait a few months? Why not just publish the key a few days after the
> final alert?

Because if you were offline at the time of the final alert, the alert
you may see instead is "Urgent security problem! Upgrade to
UltraBitcoin NOW! http://scamsite.info/", among other similar reasons.

From runesvend at gmail.com  Sat Sep 17 20:45:17 2016
From: runesvend at gmail.com (Rune K. Svendsen)
Date: Sat, 17 Sep 2016 22:45:17 +0200
Subject: [bitcoin-dev] Simple tx ID malleability fix,
	opcode proposal: OP_TXHASHVERIFY
Message-ID: <CAH2=CKzsHROCXQHRS25i5O8XUPkbwFMDAFC_CO9MD6RuJajA4g@mail.gmail.com>

I would really like to be able to create transactions that are immune to
transaction ID malleability now, so I have been thinking of the simplest
solution possible, in order to get a BIP through without too much trouble.

An opcode we could call OP_TXHASHVERIFY could be introduced. It would be
defined to work only if added to a scriptSig as the very first operation,
and would abort if the hash of the transaction **with all OP_TXHASHVERIFY
operations (including stack push) removed** does not match what has been
pushed on the stack.

So, in order to produce a transaction with one or more inputs protected
against tx ID malleability, one would:

1. Calculate tx ID of the tx: TX_HASH
2. For each input you wish to protect, add "0x32 $TX_HASH OP_TXHASHVERIFY"
to the beginning of the scriptSig

When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question, and
remove the "0x32 <32 bytes> OP_TXHASHVERIFY" sequence from the beginning of
all scriptSigs (if present), and abort if the tx copy hash does not match
the top stack item.

This is a very simple solution that only adds 34 bytes per input, and when
something better becomes available (eg. Segwit), we will stop using this.
But in the meantime it's very valuable to be able to not worry about tx ID
malleability.

Please let me know what you think.



            /Rune
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160917/3a30a98c/attachment.html>

From luke at dashjr.org  Sat Sep 17 21:10:26 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 17 Sep 2016 21:10:26 +0000
Subject: [bitcoin-dev] Simple tx ID malleability fix,
	opcode proposal: OP_TXHASHVERIFY
In-Reply-To: <CAH2=CKzsHROCXQHRS25i5O8XUPkbwFMDAFC_CO9MD6RuJajA4g@mail.gmail.com>
References: <CAH2=CKzsHROCXQHRS25i5O8XUPkbwFMDAFC_CO9MD6RuJajA4g@mail.gmail.com>
Message-ID: <201609172110.27782.luke@dashjr.org>

On Saturday, September 17, 2016 8:45:17 PM Rune K. Svendsen via bitcoin-dev 
wrote:
> I would really like to be able to create transactions that are immune to
> transaction ID malleability now, so I have been thinking of the simplest
> solution possible, in order to get a BIP through without too much trouble.
> 
> An opcode we could call OP_TXHASHVERIFY could be introduced. It would be
> defined to work only if added to a scriptSig as the very first operation,
> and would abort if the hash of the transaction **with all OP_TXHASHVERIFY
> operations (including stack push) removed** does not match what has been
> pushed on the stack.
> 
> So, in order to produce a transaction with one or more inputs protected
> against tx ID malleability, one would:
> 
> 1. Calculate tx ID of the tx: TX_HASH
> 2. For each input you wish to protect, add "0x32 $TX_HASH OP_TXHASHVERIFY"
> to the beginning of the scriptSig
> 
> When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question, and
> remove the "0x32 <32 bytes> OP_TXHASHVERIFY" sequence from the beginning of
> all scriptSigs (if present), and abort if the tx copy hash does not match
> the top stack item.
> 
> This is a very simple solution that only adds 34 bytes per input, and when
> something better becomes available (eg. Segwit), we will stop using this.
> But in the meantime it's very valuable to be able to not worry about tx ID
> malleability.
> 
> Please let me know what you think.

First of all, this is likely to be more trouble than segwit to deploy (mainly 
just because SegWit is already implemented and tested).

Secondly, it wouldn't fix your problem: anyone malleating the transaction 
would simply update the hash before this opcode...

Luke

From runesvend at gmail.com  Sat Sep 17 21:14:30 2016
From: runesvend at gmail.com (Rune K. Svendsen)
Date: Sat, 17 Sep 2016 23:14:30 +0200
Subject: [bitcoin-dev] Simple tx ID malleability fix,
	opcode proposal: OP_TXHASHVERIFY
In-Reply-To: <715F2390-221E-4646-A7F6-3FB937A08764@mattcorallo.com>
References: <CAH2=CKzsHROCXQHRS25i5O8XUPkbwFMDAFC_CO9MD6RuJajA4g@mail.gmail.com>
	<715F2390-221E-4646-A7F6-3FB937A08764@mattcorallo.com>
Message-ID: <CAH2=CKzcNu-jWPr3AKhpTN_cyGVO67oPCMQx2hUrp=Ax_+wvCw@mail.gmail.com>

I hadn't thought of that... There is a solution, I think, but it makes the
operation less simple.

If a transaction contains at least two OP_TXHASHVERIFY-protected inputs,
signed without ANYONECANPAY, their signatures would cover the other
input's OP_TXHASHVERIFY hash, right?


            /Rune


On Sat, Sep 17, 2016 at 10:56 PM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> (removing the list)
>
> Because the tx hash in your construction is not signed, someone wishing to
> maleate a transaction may do so by also updating the hash in the scriptSig.
>
> Matt
>
> On September 17, 2016 4:45:17 PM EDT, "Rune K. Svendsen via bitcoin-dev" <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I would really like to be able to create transactions that are immune to
>> transaction ID malleability now, so I have been thinking of the simplest
>> solution possible, in order to get a BIP through without too much trouble.
>>
>> An opcode we could call OP_TXHASHVERIFY could be introduced. It would be
>> defined to work only if added to a scriptSig as the very first operation,
>> and would abort if the hash of the transaction **with all OP_TXHASHVERIFY
>> operations (including stack push) removed** does not match what has been
>> pushed on the stack.
>>
>> So, in order to produce a transaction with one or more inputs protected
>> against tx ID malleability, one would:
>>
>> 1. Calculate tx ID of the tx: TX_HASH
>> 2. For each input you wish to protect, add "0x32 $TX_HASH
>> OP_TXHASHVERIFY" to the beginning of the scriptSig
>>
>> When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question,
>> and remove the "0x32 <32 bytes> OP_TXHASHVERIFY" sequence from the
>> beginning of all scriptSigs (if present), and abort if the tx copy hash
>> does not match the top stack item.
>>
>> This is a very simple solution that only adds 34 bytes per input, and
>> when something better becomes available (eg. Segwit), we will stop using
>> this. But in the meantime it's very valuable to be able to not worry about
>> tx ID malleability.
>>
>> Please let me know what you think.
>>
>>
>>
>>             /Rune
>>
>> ------------------------------
>>
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160917/c90dd12a/attachment.html>

From nickodell at gmail.com  Sat Sep 17 22:34:43 2016
From: nickodell at gmail.com (Nick ODell)
Date: Sat, 17 Sep 2016 16:34:43 -0600
Subject: [bitcoin-dev] Simple tx ID malleability fix,
	opcode proposal: OP_TXHASHVERIFY
In-Reply-To: <CAH2=CKzcNu-jWPr3AKhpTN_cyGVO67oPCMQx2hUrp=Ax_+wvCw@mail.gmail.com>
References: <CAH2=CKzsHROCXQHRS25i5O8XUPkbwFMDAFC_CO9MD6RuJajA4g@mail.gmail.com>
	<715F2390-221E-4646-A7F6-3FB937A08764@mattcorallo.com>
	<CAH2=CKzcNu-jWPr3AKhpTN_cyGVO67oPCMQx2hUrp=Ax_+wvCw@mail.gmail.com>
Message-ID: <CANN4kmd2N_iguM1KKWO8dgV_ZhO-qkk4bON6vfNySLdYQQjwGg@mail.gmail.com>

Then you have a new problem. Hash1 must contain Hash2 and the
transaction, but Hash2 must contain Hash1 and the transaction. A
circular dependency.

--Nick

On Sat, Sep 17, 2016 at 3:14 PM, Rune K. Svendsen via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I hadn't thought of that... There is a solution, I think, but it makes the
> operation less simple.
>
> If a transaction contains at least two OP_TXHASHVERIFY-protected inputs,
> signed without ANYONECANPAY, their signatures would cover the other input's
> OP_TXHASHVERIFY hash, right?
>
>
>             /Rune
>
>
> On Sat, Sep 17, 2016 at 10:56 PM, Matt Corallo <lf-lists at mattcorallo.com>
> wrote:
>>
>> (removing the list)
>>
>> Because the tx hash in your construction is not signed, someone wishing to
>> maleate a transaction may do so by also updating the hash in the scriptSig.
>>
>> Matt
>>
>> On September 17, 2016 4:45:17 PM EDT, "Rune K. Svendsen via bitcoin-dev"
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>> I would really like to be able to create transactions that are immune to
>>> transaction ID malleability now, so I have been thinking of the simplest
>>> solution possible, in order to get a BIP through without too much trouble.
>>>
>>> An opcode we could call OP_TXHASHVERIFY could be introduced. It would be
>>> defined to work only if added to a scriptSig as the very first operation,
>>> and would abort if the hash of the transaction **with all OP_TXHASHVERIFY
>>> operations (including stack push) removed** does not match what has been
>>> pushed on the stack.
>>>
>>> So, in order to produce a transaction with one or more inputs protected
>>> against tx ID malleability, one would:
>>>
>>> 1. Calculate tx ID of the tx: TX_HASH
>>> 2. For each input you wish to protect, add "0x32 $TX_HASH
>>> OP_TXHASHVERIFY" to the beginning of the scriptSig
>>>
>>> When evaluating OP_TXHASHVERIFY, we make a copy of the tx in question,
>>> and remove the "0x32 <32 bytes> OP_TXHASHVERIFY" sequence from the beginning
>>> of all scriptSigs (if present), and abort if the tx copy hash does not match
>>> the top stack item.
>>>
>>> This is a very simple solution that only adds 34 bytes per input, and
>>> when something better becomes available (eg. Segwit), we will stop using
>>> this. But in the meantime it's very valuable to be able to not worry about
>>> tx ID malleability.
>>>
>>> Please let me know what you think.
>>>
>>>
>>>
>>>             /Rune
>>>
>>> ________________________________
>>>
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From pete at petertodd.org  Sun Sep 18 04:20:01 2016
From: pete at petertodd.org (Peter Todd)
Date: Sun, 18 Sep 2016 00:20:01 -0400
Subject: [bitcoin-dev] Interpreting nTime for the purpose of
	Bitcoin-attested timestamps
Message-ID: <20160918042001.GA9076@fedora-21-dvm>

As part of my recent work(1) on OpenTimestamps I've been putting some thought
towards how to interpret the nTime fields in block headers, for the purpose of
timestamping. I'd like to get some peer review on the following scheme I've
come up with.


# Motivation

We want to use the Bitcoin blockchain to provide evidence (the "attestation")
that a message M existed prior to some point in time T. Exactly how we do this
is beyond the scope of this post, but suffice to say we show that some block
header b cryptographically commits to the message, e.g. via a commitment
operation path proof, as implemented by OpenTimestamps.

A valid timestamp is simply one where T is a point in time where the message
did in fact exist. Of course, if a timestamp for time T is valid, all
subsequent T+d are also valid; such timestamps are simply more conservative
versions of the same statement.

A naively approach - as is implemented by most (all?) existing Bitcoin
timestamping schemes - is to assume that the block header's nTime field was
perfectly accurate, and thus M exists prior to the block's nTime. But that
doesn't take into account malicious miners, who may backdate their blocks.


# Threat Model

We assume miners are divided into two categories:

1) Dishonest Miners --- These miners are actively conspiring to create invalid
timestamps for time's prior to when the message existed. A dishonest miner will
set the nTime field in blocks they create to the minimum possible value.

2) Honest Miners --- These miners set nTime in blocks they create to
approximately the current true time. An honest miner may use techniques such as
nTime-rolling. Additionally, all honest miners may be simultaneously affected
by systematic misconfigurations.


## nTime Rolling

Prior to BIP113, reducing a block's nTime from the work given by a pool by even
a second could easily render it invalid, as the pool may have included
nLockTime'd transactions in the block. Thus hashing software was designed to
only roll nTime in the forward direction, not reverse, even though rolling
could be done in the reverse direction, up to the limit of the median-time-past
+ 1.

The Stratum mining protocol doesn't even have a way to tell clients what the
minimum allowed time is, just a single field, nTime, which is defined as "the
current time". Thus Stratum hashers will only ever increase nTime, which can
never result in an invalid timestamp if the original, unrolled, nTime would
have been a valid timestamp.

The getblocktemplate protocol does support telling hashers the minimum time via
the mintime field, which Bitcoin Core sets to the median-time-past. Regardless,
it appears that the pools supporting GBT (Eligius) return a much tighter limit
on mintime than the median-time-past, just 180 seconds, and as of writing,
don't actually declare that the ntime field is mutable anyway.

From an implementation point of view, relying on being able to roll nTime
backwards is unwise anyway, as the amount you can roll it back may be minimal
(e.g. if multiple blocks were recently found).

Since all miners have an incentive for time to move forward to keep difficulty
down it's reasonable to assume that the above observed behavior will continue,
and nTime rolling in the reverse direction will be a minimal effect; we'll
assume no miner rolls nTime backwards more than 1 hour.


## Systematic Errors

1) Botched daylight savings time changes --- While internal clocks should be
unaffected by timezone changes, it's plausible that some kind of mistake
related to daylight savings could result in the time being set incorrectly +- 1
hour. For example, multiple large miners might manually set their clocks, based
on an incorrect understanding of what time it was.

2) Broken NTP servers --- It's reasonable to assume that many miners are using
NTP to set their clocks, and it's plausible that they're using the same NTP
servers. Of course, a broken NTP server could return any time at all! The
Bitcoin protocol considers blocks to be valid if nTime is set up to 2 hours in
the future (from the perspective of the local node) so we'll say instead that
we expect systematic NTP errors to be corrected with high probability if
they're more than 2 hours in magnitude - more than that and the Bitcoin network
is broken in a very visible way anyway.

Thus, we'll assume honest miners always create blocks with nTime greater than
the true time minus two hours, which accounts for both likely daylight savings
time misconfigurations, and likely NTP server misconfigurations. Additionally,
two hours is greater than any expected effects from nTime rolling.


# Proposed Algorithm

For a timestamp anchored at a block of height x we'll define the time T it
represents as:

    T = max(block[i].nTime for i in {x, ..., x + N-1}) + max_offset

In short, T is the maximum nTime out of the N blocks that confirmed the
timestamp, including first block that actually committed the timestamp;
max_offset is the maximum nTime offset we expect from a block created by an
honest miner, discussed above.

The dishonest miners can successfully create an invalid timestamp iff all N
blocks are found by them; if any block is found by an honest miner, the nTime
field will be set correctly. Of course T may not be the minimum possible value,
but the timestamp will be at least valid.

So how big should N be? Let q be the ratio of dishonest miners to total hashing
power. The probability that all N blocks are found by dishonest miners is q^N,
and thus the probability P that at least one block is found by an honest miner
is:

    P = 1 - q^N  =>  N = log(1 - P)/log(q)

If the dishonest miners have q>0.5, the situation is hopeless, as they can
reject blocks from honest miners entirely; the only limit on them setting nTime
is the median-time-past rule, which only requires blocks timestamps to
increment by one second per block (steady state). Thus we'll assume q=0.5, the
worst possible case where a Bitcoin timestamp can still be meaningful evidence:

    P = 97%      => N = 5
    P = 99%      => N = 7
    P = 99.9%    => N = 10
    P = 99.99%   => N = 14
    P = 99.999%  => N = 17
    P = 99.9999% => N = 20

The reliability for the higher N is higher than the actual reliability of
Bitcoin itself. On the other hand, there's no known instance where miners have
ever created blocks with nTime's significantly less than true time on a wide
scale; even in the well-known cases where the Bitcoin network has temporarily
failed due to forks, timestamps produced during those times would be valid, if
delayed by a few hours.

Similarly, if we assume a lower q, say a single "rogue" 20% mining pool, we
get:

    q = 0.20, P = 99.99% => N = 6

Another way to think about the choice of N is to compare its contribution to
how conservative the timestamp is - T as compared to the true time - to the
effect of the max-honest-miner-offset we choose earlier. For example, 98% of
the time at least 6 blocks will be found within 2 hours, which means that if we
pick N=7, 98% of the time the conservatism added by N will be less than the
contribution of the max offset.


# UI Considerations

One problem with the above algorithm is that it will frequently return
timestamps in the future, from the perspective of the user. A user who sees a
message like the following at 2:00 pm, immediately after their timestamp
confirms, is understandably going to be confused:

   Bitcoin: 99% chance that <f> existed prior to 4:00 pm, Jan 1st 2016

A reasonable approach to this problem might just to refrain from displaying
timestamps at all until the local time is after the timestamp; the UI could
describe the timestamp as "Not yet confirmed"

It may also be reasonable to round the timestamp up to the nearest day when
displaying it. However what timezone to use is a tricky issue; people rarely
expect to see timezones specified alongside dates.

Of course, in some cases a less conservative approach to interpreting the
timestamp is reasonable; those users however should be reading and
understanding the calculations in this post!


# References

1) https://petertodd.org/2016/opentimestamps-announcement

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160918/4552f035/attachment-0001.sig>

From pete at petertodd.org  Sun Sep 18 16:05:24 2016
From: pete at petertodd.org (Peter Todd)
Date: Sun, 18 Sep 2016 12:05:24 -0400
Subject: [bitcoin-dev] Interpreting nTime for the purpose of
 Bitcoin-attested timestamps
In-Reply-To: <CABeL=0jSQsdyRFAUheQ9XSi1krM=PLFAARLXE8Du55FFkX8vZg@mail.gmail.com>
References: <20160918042001.GA9076@fedora-21-dvm>
	<CABeL=0jSQsdyRFAUheQ9XSi1krM=PLFAARLXE8Du55FFkX8vZg@mail.gmail.com>
Message-ID: <20160918160524.GA13307@fedora-21-dvm>

On Sun, Sep 18, 2016 at 03:45:40PM +0200, Jannes Faber wrote:
> Would you not also have to consider (all) earlier blocks?
> 
> T = max(block[i].nTime for i in {x-100, ..., x, ..., x + N-1}) + max_offset
> 
> In case one or more previous blocks have an nTime considerably in the
> future and blocks>= x have honest nTimes (or before true time).
> 
> Maybe not strictly for the goal you were describing here (conservative
> estimate) but rather to prevent distinct timestamp events seeming to have
> happened in the wrong order?

Well that's the thing: timestamps are simply proofs that something existed
prior to some time, nothing more, nothing less.

So it doesn't make sense for there to be any notion of the "wrong order" in a
timestamp proof; the proof either is or is not valid, but that has nothing to
do with other proofs. Additionally, the architecture of OpenTimestamps doesn't
and can't make any 100% guarantees about the apparent order of timestamps,
because it's always possible for an earlier timestamp to end up committed in
the blockchain after a later timestamp gets committed. It's not all that likely
of an event, but it is possible.

If you don't want that to be possible, you're going to need a dedicated chain
of transactions for your particular purpose, which adds a lot of complexity,
cost, and makes it much harder to achieve the same level of availability for
the service as a whole.

Remember that for many use-cases the user experience is that there's two or
more claimed dates, and OpenTimestamps simply verifies that those dates are
plausible. Take for example, timestamped git commits:

    commit 536411e73b8c23dc2fdfd78052c893f578444926
    ots: Got 2 attestation(s) from cache
    ots: Success! Bitcoin attests data existed as of Thu Sep 15 01:07:08 2016 EDT
    ots: Good timestamp
    gpg: Signature made Thu 15 Sep 2016 12:10:25 AM EDT
    gpg:                using RSA key 6399011044E8AFB2
    gpg: Good signature from "Peter Todd <pete at petertodd.org>"
    gpg:                 aka "[jpeg image of size 5220]"
    Author: Peter Todd <pete at petertodd.org>
    Date:   Thu Sep 15 00:10:20 2016 -0400

        Release v0.2.0

Here we have the date on the git commit, another date a few seconds later for
the PGP signature, and a third date an hour later for the Bitcoin timestamp,
attesting to the fact that the two other dates for that one git commit are
plausible.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160918/c8314fe2/attachment.sig>

From tomh at thinlink.com  Mon Sep 19 16:13:40 2016
From: tomh at thinlink.com (Tom Harding)
Date: Mon, 19 Sep 2016 09:13:40 -0700
Subject: [bitcoin-dev] Interpreting nTime for the purpose of
 Bitcoin-attested timestamps
In-Reply-To: <20160918042001.GA9076@fedora-21-dvm>
References: <20160918042001.GA9076@fedora-21-dvm>
Message-ID: <7ff1a87d-2916-2024-ea05-d6413bd17767@thinlink.com>


-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
 
On 9/17/2016 9:20 PM, Peter Todd via bitcoin-dev wrote:
> The probability that all N blocks are found by dishonest miners is q^N,

That's the probability that dishonest miners find N blocks in a row
immediately.  What you want is the probability that they can build a
chain N blocks long, taking the random-walk into account.

So use Satoshi's formula from bitcoin.pdf, section 11.  The results are
remarkably different.  In particular, q=.5 is totally insecure, since
for any N, both factions are guaranteed to eventually possess a chain of
length N anchored at x at some point during the wild reorg melee.

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
 
iQIcBAEBAgAGBQJX4A60AAoJEG/AI00/Ca/qLmEP/0fg+XJQNexTTrS/aPqcIY00
KStPNIruJD4QA9zgyx4K3fCst85/L9rsmv/9Xo6tyn8oneAMjjVY57mTG3smhiXA
Qfu9/tG0AHneRxEpRNDA/x4IwCrr1xACOaO26gEqs9zVIszIVQq4z3Vc54gj39VD
9Jpc0653RVqHhJFT4ozZkAzg2CcPMHOxi45ufBtScaJO2AwtcLvtVYaC1BE9itDM
wDdAS175jq+LlV20Igaf/s4Cc9G3LWnrNqzVCPBr/ua4U60ZO+r3nLr9gYtYNR0H
37xgktNZA8D/YI8gjYZ5p11bIqCs4lRyI5LP3Rvh/+5zQu4hdi25HMoUMys/lw4c
ABuUVLaCa2r7pH7QczUx4jWJslaHlZ4M6tMUJ7bGZpVcPmA8FOk0j+DLTfUmYVYi
Eqc5cf2Z+PEc9kBmvsxQ351WjT7fq3OtZCcMH5dhpGv4NMuVBwQ38Dh3Pz8rhBPe
pIXMUPkmdWdczjoACpjOHbhYffCI7zCvsypydnImF7FReohWPFSKdaeoSHxotHzb
cy2EWZS2IM009qY3+jF1j3uj4bJfPSlgLgfUE23Bmvsp9PJi9W+FARbKJKxr6HaB
vvMg6rMfU8uWElQqz19ixI55PUDmtugwXccyWvhcr0ueN1P6fpNxF36Q9zwS6/+D
4orUC+rp1yNTeddvaYDv
=HS6r
-----END PGP SIGNATURE-----


From pete at petertodd.org  Mon Sep 19 17:56:15 2016
From: pete at petertodd.org (Peter Todd)
Date: Mon, 19 Sep 2016 13:56:15 -0400
Subject: [bitcoin-dev] Interpreting nTime for the purpose of
 Bitcoin-attested timestamps
In-Reply-To: <7ff1a87d-2916-2024-ea05-d6413bd17767@thinlink.com>
References: <20160918042001.GA9076@fedora-21-dvm>
	<7ff1a87d-2916-2024-ea05-d6413bd17767@thinlink.com>
Message-ID: <20160919175615.GA6360@fedora-21-dvm>

On Mon, Sep 19, 2016 at 09:13:40AM -0700, Tom Harding via bitcoin-dev wrote:
> 
> On 9/17/2016 9:20 PM, Peter Todd via bitcoin-dev wrote:
> > The probability that all N blocks are found by dishonest miners is q^N,
> 
> That's the probability that dishonest miners find N blocks in a row
> immediately.  What you want is the probability that they can build a
> chain N blocks long, taking the random-walk into account.
> 
> So use Satoshi's formula from bitcoin.pdf, section 11.  The results are
> remarkably different.  In particular, q=.5 is totally insecure, since
> for any N, both factions are guaranteed to eventually possess a chain of
> length N anchored at x at some point during the wild reorg melee.

Ah! That's a good point; my analysis only applies to the case where you're
assuming the dishonest miners aren't willing to lose revenue from the attack by
mining a less-work chain with blocks that won't end up in the main chain. I
should state that assumption more clearly.

If the dishonest miners are willing to spend money to create an invalid
timestamp the analysis is quite different. In OpenTimestamps a timestamp
doesn't contain the actual block headers - just a block height - so verifiers
are expected to have a working Bitcoin node. If that Bitcoin node is in sync
with the most-work work chain there's no risk: the blocks created by the
dishonest miners won't be part of the most-work chain, and validation of the
timestamp will fail.

In the case where the verifier is not in sync with the most-work chain, an
attacker can sybil attack the verifier's node and cause them to think that the
blocks committing the invalid timestamp are in fact the most-work chain. This
case is no different than a payee being sybil attacked, so we can use the same
analysis we would in that circumstance.

This also means that timestamps definitely shouldn't contain the block headers
of the blocks allegedly confirming them - that's an extremely weak proof given
the relative ease of creating a block, particularly when you take into account
that the same block could be used to create an unlimited number of fake
timestamps. OpenTimestamps doesn't do this, but it wouldn't hurt to make this
point 100% clear.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160919/13014793/attachment.sig>

From tomh at thinlink.com  Mon Sep 19 19:53:46 2016
From: tomh at thinlink.com (Tom Harding)
Date: Mon, 19 Sep 2016 12:53:46 -0700
Subject: [bitcoin-dev] Interpreting nTime for the purpose of
 Bitcoin-attested timestamps
In-Reply-To: <20160919175615.GA6360@fedora-21-dvm>
References: <20160918042001.GA9076@fedora-21-dvm>
	<7ff1a87d-2916-2024-ea05-d6413bd17767@thinlink.com>
	<20160919175615.GA6360@fedora-21-dvm>
Message-ID: <b70ab80f-2a9a-2d6e-00c7-6d281e514778@thinlink.com>

On 9/19/2016 10:56 AM, Peter Todd wrote:
> I should state that assumption more clearly.

Glad to get you thinking, and I need to change my suggestion.  The
catch-up formula is not applicable because it doesn't limit how long the
dishonest miners have to catch up.

Instead you want the probability that the honest miners can build a
chain N blocks long before the dishonest miners do the same, which is

CDF[Erlang(N, q) - Erlang(N, 1 - q), 0]

I have some apparatus for doing this numerically without simulation if
you're interested.


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160919/8277554b/attachment.sig>

From tomz at freedommail.ch  Tue Sep 20 17:15:45 2016
From: tomz at freedommail.ch (Tom)
Date: Tue, 20 Sep 2016 19:15:45 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
Message-ID: <7844645.RLYLWYmWtM@garp>

As the title suggests, I would like to formally request the assignment of a 
BIP number for my FT spec.

Thank you!


Source; 

https://github.com/zander/bips/blob/FlexTrans/bip-9999.mediawiki

<pre>
  BIP: ??
  Title: Flexible Transactions
  Author: Tom Zander <tomz at freedommail.ch>
  Status: Draft
  Type: Standards Track
  Created: 2016-07-27
</pre>

==Abstract==

This BIP describes the next step in making Bitcoin's most basic element,
the transaction, more flexible and easier to extend. At the same time this
fixes all known cases of malleability and resolves significant amounts of
technical debt.

==Summary==

Flexible Transactions uses the fact that the first 4 bytes in a transaction
determine the version and that the majority of the clients use a
non-consensus rule (a policy) to not accept transaction version numbers
other than those specifically defined by Bitcoin.
This BIP chooses a new version number, 4, and defines that the data
following the bytes for the version is in a format called Compact Message
Format (CMF). CMF is a flexible, token based format where each token is a
combination of a name, a format and a value. Because the name is added we
can skip unused tokens and we can freely add new tokens in a simple manner
in future. Soft fork upgrades will become much easier and cleaner this
way.

This protocol upgrade cleans up past soft fork changes like BIP68 which
reuse existing fields and do them in a much better to maintain and easier
to parse system. It creates the building blocks to allow new features to be
added much cleaner in the future.

It also shows to be possible to remove signatures from transactions with
minimal upgrades of software and still maintain a coherent transaction
history. Tests show that this can reduce space usage to about 75%.

==Motivation==

Token based file-formats are not new, systems like XML and HTMl use a
similar system to allow future growth and they have been quite successful
for decades in part because of this property.

Bitcoin needs a similar way of making the transaction future-proof because
re-purposing not used fields for new features is not good for creating
maintainable code.

Next to that this protocol upgrade will re-order the data-fields which
allows us to cleanly fix the malleability issue which means that future
technologies like Lightning Network will depend on this BIP being deployed.

At the same time, due to this re-ordering of data fields, it becomes very
easy to remove signatures from a transaction without breaking its tx-id,
which is great for future pruning features.


=== Tokens ===

In the compact message format we define tokens and in this specification we
define how these tokens are named, where they can be placed and which are
optional.  To refer to XML, this specification would be the schema of
a transaction.

CMF tokens are triplets of name, format (like PositiveInteger) and value.
Names in this scope are defined much like an enumeration where the actual
integer value (id, below) is equally important to the written name.
If any token found that is not covered in the next table will make the
transaction that contains it invalid.

{| class="wikitable"
|-
! Name !! id !! Format !! Default Value !! Description
|-
|TxEnd         ||  0 ||BoolTrue ||  Required    ||A marker that is the last 
byte in the txid calculation
|-
|TxInPrevHash  ||  1 ||ByteArray||  Required    ||TxId we are spending
|-
|TxPrevIndex   ||  2 ||Integer  ||      0       ||Index in prev tx we are 
spending (applied to previous TxInPrevHash)
|-
|TxInScript    ||  3 ||ByteArray||  Required    ||The 'input' part of the 
script
|-
|TxOutValue    ||  4 ||Integer  ||  Required    ||Amount of satoshi to 
transfer
|-
|TxOutScript   ||  5 ||ByteArray||  Required    ||The 'output' part of the 
script
|-
|LockByBlock   ||  6 ||Integer  ||  Optional    ||BIP68 replacement
|-
|LockByTime    ||  7 ||Integer  ||  Optional    ||BIP68 replacement
|-
|ScriptVersion ||  8 ||Integer  ||      2       ||Defines script version for 
outputs following
|-
|NOP_1x        || 1x || . ||  Optional    ||Values that will be ignored by 
anyone parsing the transaction
|}


=== Scripting changes ===

In the current version of Bitcoin-script, version 1, there are various
opcodes that are used to validate the cryptographic proofs that users have
to provide in order to spend outputs.

The OP_CHECKSIG is the most well known and, as its name implies, it
validates a signature.
In the new version of 'script' (version 2) the data that is signed is
changed to be equivalent to the transaction-id. This is a massive
simplification and also the only change between version 1 and version 2 of
script.

=== Serialization order===

The tokens defined above have to be serialized in a certain order for the
transaction to be well-formatted.  Not serializing transactions in the
order specified would allow multiple interpretations of the data which
can't be allowed.
There is still some flexibility and for that reason it is important for
implementors to remember that the actual serialized data is used for the
calculation of the transaction-id. Reading and writing it may give you a
different output and when the txid changes, the signatures will break.

At a macro-level the transaction has these segments. The order of the
segments can not be changed, but you can skip segments.

{| class="wikitable"
!Segment !! Description
|-
|   Inputs   || Details about inputs.
|-
|  Outputs   || Details and scripts for outputs
|-
| Additional || For future expansion
|-
| Signatures || The scripts for the inputs
|-
|   TxEnd    || End of the transaction
|}

The TxId is calculated by taking the serialized transaction without the
Signatures and the TxEnd and hashing that.


{| class="wikitable"
!Segment !! Tags !! Description
|-
|Inputs||TxInPrevHash and TxInPrevIndex||Index can be skipped, but in any 
input the PrevHash always has to come first
|-
|Outputs||TxOutScript, TxOutValue||Order is not relevant
|-
|Additional||LockByBlock  LockByTime NOP_1x
|-
|Signatures||TxInScript||Exactly the same amount as there are inputs
|-
|TxEnd||TxEnd
|}

TxEnd is there to allow a parser to know when one transaction in a stream
has ended, allowing the next to be parsed.

Notice that the token ScriptVersion is currently not allowed because we
don't have any valid value to give it. But if we introduce a new script
version it would be placed in the outputs segment.

=== Script v2 ===

The default value of ScriptVersion is number 2, as opposed to the version 1
of script that the is in use today.  The version 2 is mostly identical
to version one, including upgrades made to it over the years and in the 
future. The only exception is that the OP_CHECKSIG is made dramatically
simpler.  The input-type for OP_CHECKSIG is now no longer configurable, it is
always '1' and the content that will be signed is the txid.

TODO: does check-multisig need its own mention?


=== Block-malleability ===

The effect of leaving the signatures out of the calculation of the
transaction-id implies that the signatures are also not used for the
calculation of the merkle tree.  This means that changes in signatures
would not be detectable. Except naturally by the fact that missing or
broken signatures breaks full validation. But it is important to detect
modifications to such signatures outside of validating all transactions.

For this reason the merkle tree is extended to include (append) the hash of
the v4 transactions (and those alone) where the hash is taken over a
data-blob that is build up from:

1. the tx-id
2. the CMF-tokens 'TxInScript'


=== Future extensibility ===

The NOP_1x wildcard used in the table explaining tokens is actually a list
of 10 values that currently are specified as NOP (no-operation) tags.

Any implementation that supports the v4 transaction format should ignore
this field in a transaction. Interpreting and using the transaction as if
that field was not present at all.

Future software may use these fields to decorate a transaction with
additional data or features. Transaction generating software should not
trivially use these tokens for their own usage without cooperation and
communication with the rest of the Bitcoin ecosystem as miners certainly
have the option to reject transactions that use unknown-to-them tokens.


==Reference Implementation==

Bitcoin Classic includes this in its beta releases and a reference
implementation can be found at;

https://github.com/bitcoinclassic/bitcoinclassic/pull/186


==Deployment==

To be determined

==References==

[https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md] 
CMF


From luke at dashjr.org  Tue Sep 20 21:31:47 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 20 Sep 2016 21:31:47 +0000
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <7844645.RLYLWYmWtM@garp>
References: <7844645.RLYLWYmWtM@garp>
Message-ID: <201609202131.49881.luke@dashjr.org>

On Tuesday, September 20, 2016 5:15:45 PM Tom via bitcoin-dev wrote:
> As the title suggests, I would like to formally request the assignment of a
> BIP number for my FT spec.

Please open a pull request on the bitcoin/bips repo after this has been 
discussed a bit on the ML.

Note that at least a basic backwards compatibility section is required for 
assignment, especially since this appears to be a hard-fork proposal (if it is 
meant as a soft-fork, please explain how that would work).

> ==Motivation==
> 
> Token based file-formats are not new, systems like XML and HTMl use a
> similar system to allow future growth and they have been quite successful
> for decades in part because of this property.

There is already a binary-safe format called EBML. Why not use that as the 
basis for this BIP?

> Next to that this protocol upgrade will re-order the data-fields which
> allows us to cleanly fix the malleability issue which means that future
> technologies like Lightning Network will depend on this BIP being deployed.

Note this won't fix malleability entirely, only third-party malleability (much 
like segwit). The sender can always modify the transaction with more 
inputs/outputs.

> |TxEnd         ||  0 ||BoolTrue ||  Required    ||A marker that is the last
> byte in the txid calculation

The last byte in the txid calculation, or the last byte of the entire 
transaction?

It seems from the later comments, that it is the end of the transaction as a 
whole. Yet a separator between the txid and non-txid data would probably be 
valuable, rather than hard-coding txid to skip signature types (which may be 
unknown to old nodes, when extended).

> The OP_CHECKSIG is the most well known and, as its name implies, it
> validates a signature.
> In the new version of 'script' (version 2) the data that is signed is
> changed to be equivalent to the transaction-id. This is a massive
> simplification and also the only change between version 1 and version 2 of
> script.

This seems to be a major regression. What is the replacement for 
SIGHASH_SINGLE and SIGHASH_ANYONECANPAY?

When revising OP_CHECKSIG, it would also be nice to add the ability to use 
*only* a hash of the prevout's scriptPubKey in the input, so that *when* the 
prevtx is malleated, the spending one remains valid. (This use case is 
currently not supported.)

> === Serialization order===
> 
> The tokens defined above have to be serialized in a certain order for the
> transaction to be well-formatted.  Not serializing transactions in the
> order specified would allow multiple interpretations of the data which
> can't be allowed.

What happens if nodes encounter a different order in a block?

> Notice that the token ScriptVersion is currently not allowed because we
> don't have any valid value to give it. But if we introduce a new script
> version it would be placed in the outputs segment.

What happens if I put ScriptVersion=1 here?

> === Script v2 ===
> 
> TODO: does check-multisig need its own mention?

Does multisig still require a dummy item on the stack?

> === Block-malleability ===
> 
> For this reason the merkle tree is extended to include (append) the hash of
> the v4 transactions (and those alone) where the hash is taken over a
> data-blob that is build up from:

How should nodes know where in the merkle-tree the txids end, and the v4hashes 
begin?

Luke

From pete at petertodd.org  Tue Sep 20 21:56:44 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 20 Sep 2016 17:56:44 -0400
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <7844645.RLYLWYmWtM@garp>
References: <7844645.RLYLWYmWtM@garp>
Message-ID: <20160920215644.GA12030@fedora-21-dvm>

On Tue, Sep 20, 2016 at 07:15:45PM +0200, Tom via bitcoin-dev wrote:
> === Serialization order===
> 
> The tokens defined above have to be serialized in a certain order for the
> transaction to be well-formatted.  Not serializing transactions in the
> order specified would allow multiple interpretations of the data which
> can't be allowed.

If the order of the tokens is fixed, the tokens themselves are redundant
information when tokens are required; when tokens may be omitted, a simple
"Some/None" flag to mark whether or not the optional data has been omitted is
appropriate.


Also, if you're going to break compatibility with all existing software, it
makes sense to use a format that extends the merkle tree down into the
transaction inputs and outputs.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160920/04780272/attachment.sig>

From tomz at freedommail.ch  Wed Sep 21 09:32:30 2016
From: tomz at freedommail.ch (Tom)
Date: Wed, 21 Sep 2016 11:32:30 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <201609202131.49881.luke@dashjr.org>
References: <7844645.RLYLWYmWtM@garp> <201609202131.49881.luke@dashjr.org>
Message-ID: <2219026.Mlk68OiSLi@garp>

On Tuesday 20 Sep 2016 21:31:47 Luke Dashjr wrote:
> On Tuesday, September 20, 2016 5:15:45 PM Tom via bitcoin-dev wrote:
> > As the title suggests, I would like to formally request the assignment of
> > a
> > BIP number for my FT spec.
> 
> Please open a pull request on the bitcoin/bips repo after this has been
> discussed a bit on the ML.

> It seems from the later comments, that it is the end of the transaction as a
> whole. Yet a separator between the txid and non-txid data would probably be
> valuable, rather than hard-coding txid to skip signature types (which may
> be unknown to old nodes, when extended).
> 
> > The OP_CHECKSIG is the most well known and, as its name implies, it
> > validates a signature.
> > In the new version of 'script' (version 2) the data that is signed is
> > changed to be equivalent to the transaction-id. This is a massive
> > simplification and also the only change between version 1 and version 2 of
> > script.
> 
> This seems to be a major regression. What is the replacement for
> SIGHASH_SINGLE and SIGHASH_ANYONECANPAY?

How is this a regression? Can you explain what functionality is lost please?

> When revising OP_CHECKSIG, it would also be nice to add the ability to use
> *only* a hash of the prevout's scriptPubKey in the input, so that *when* the
> prevtx is malleated, the spending one remains valid. (This use case is
> currently not supported.)

Maybe for the next version of script :)
 
> > Notice that the token ScriptVersion is currently not allowed
> What happens if I put ScriptVersion=1 here?

The transaction is invalid...
 
> > === Block-malleability ===
> > 
> > For this reason the merkle tree is extended to include (append) the hash
> > of
> > the v4 transactions (and those alone) where the hash is taken over a
> 
> > data-blob that is build up from:
>
> How should nodes know where in the merkle-tree the txids end, and the
> v4hashes begin?

Because the txid based ones are not going away. So the number of transactions 
in the block can be used to determine when the pure tx-id segment stops and 
when the v4 hashes begin.  Then its up to the client to rebuild the tree from 
that list based on the larger input set to get the same root-node.

I clarified many little things on my clone of the bips, check there if you 
want to see the details.

From tomz at freedommail.ch  Wed Sep 21 09:32:33 2016
From: tomz at freedommail.ch (Tom)
Date: Wed, 21 Sep 2016 11:32:33 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <20160920215644.GA12030@fedora-21-dvm>
References: <7844645.RLYLWYmWtM@garp> <20160920215644.GA12030@fedora-21-dvm>
Message-ID: <5590176.JJpBoGr4Tc@garp>

Thanks for your email Peter!

On Tuesday 20 Sep 2016 17:56:44 Peter Todd wrote:
> On Tue, Sep 20, 2016 at 07:15:45PM +0200, Tom via bitcoin-dev wrote:
> > === Serialization order===
> > 
> > The tokens defined above have to be serialized in a certain order for the
> > transaction to be well-formatted.  Not serializing transactions in the
> > order specified would allow multiple interpretations of the data which
> > can't be allowed.
> 
> If the order of the tokens is fixed, the tokens themselves are redundant
> information when tokens are required; when tokens may be omitted, a simple
> "Some/None" flag to mark whether or not the optional data has been omitted
> is appropriate.

This is addressed in the spec; 
https://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md

?The way towards that flexibility is to use a generic concept made popular
various decades ago with the XML format. The idea is that we give each
field a name and this means that new fields can be added or optional fields
can be omitted from individual transactions?


> Also, if you're going to break compatibility with all existing software, it
> makes sense to use a format that extends the merkle tree down into the
> transaction inputs and outputs.

Please argue your case.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: This is a digitally signed message part.
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160921/613bee38/attachment-0001.sig>

From andreas at schildbach.de  Wed Sep 21 12:00:23 2016
From: andreas at schildbach.de (Andreas Schildbach)
Date: Wed, 21 Sep 2016 14:00:23 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <7844645.RLYLWYmWtM@garp>
References: <7844645.RLYLWYmWtM@garp>
Message-ID: <nrtsok$lp5$1@blaine.gmane.org>

Just glancing over your BIP, I wonder if we should use Protobuf. It uses
this "flexible" format already and is quite compact/binary. We use
Protobuf already for the payment protocol, and there is very good tool
support.


From murch at murch.one  Wed Sep 21 12:58:25 2016
From: murch at murch.one (Murch)
Date: Wed, 21 Sep 2016 14:58:25 +0200
Subject: [bitcoin-dev] On-going work: Coin Selection Simulation
Message-ID: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>

Hi,

I'm currently compiling my Master's thesis about Coin Selection and my
presentation proposal to Scaling Bitcoin has been accepted.

For my thesis, I have analyzed the Coin Selection problem, created a
framework to simulate wallet behavior on basis of a sequence of
payments, and have re-implemented multiple coin selection strategies of
prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and
Android Wallet for Bitcoin).

As the Scaling Bitcoin site suggests that research should be made
available to this mailing list, I would like to invite you to have a
look at:

http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf

The PDF (176 kB) contains a two page description of my on-going work,
including preliminary simulation results, and three figures showing the
simulated wallets' UTXO compositions at the end of the simulation.

I can provide further information as requested, and would welcome any
feedback.

?? If anyone has another sequence of incoming and outgoing payment
amounts at hand that I could run my simulation on, I'd love to hear
about it.

Regards

Murch


-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160921/56ec5d2a/attachment.sig>

From tomz at freedommail.ch  Wed Sep 21 12:58:02 2016
From: tomz at freedommail.ch (Tom)
Date: Wed, 21 Sep 2016 14:58:02 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <nrtsok$lp5$1@blaine.gmane.org>
References: <7844645.RLYLWYmWtM@garp> <nrtsok$lp5$1@blaine.gmane.org>
Message-ID: <58983644.DvMMf90VdX@garp>

On Wednesday 21 Sep 2016 14:00:23 Andreas Schildbach via bitcoin-dev wrote:
> Just glancing over your BIP, I wonder if we should use Protobuf. It uses
> this "flexible" format already and is quite compact/binary. We use
> Protobuf already for the payment protocol, and there is very good tool
> support.

There is a lot of overlap between different binary formats. Looking through 
the on-the-wire protocol you'll see that my spec is very similar. Practically 
all the advantages of protobuf are present in CMF. I can write you a java 
parser if you want, it should be easy to port from Qt/C++ code :)
https://github.com/bitcoinclassic/transactions

CMF: 
https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md

There is no tool support needed, just one or two classes. Which personally I 
think is an advantage.


Some advantages of CMF over protobuf from the top of my head;

* It reuses the var-int parsing that Bitcoin uses (which is itself slightly 
different from others).

* zero-copy support (not relevant for this bip, though).

* Additional values addition (i.e. adding new data) is .. tricky in protobuf.
https://developers.google.com/protocol-buffers/docs/proto#updating

* In my experience parsing a message manually (like a SOX parser) is much 
better in reporting errors and detecting wrong usages than auto-generated code 
(but personally I'm not much a fan of auto-generated APIs) at all...

* Generated parsing/writing code will not be as fast as we can make it.

* CMF is more compact (uses less bytes) for its messages.


Protobuf is something I've used before and I think we can do better. I think 
that CMF together with some support classes can do this better.

From andreas at schildbach.de  Wed Sep 21 15:02:56 2016
From: andreas at schildbach.de (Andreas Schildbach)
Date: Wed, 21 Sep 2016 17:02:56 +0200
Subject: [bitcoin-dev] On-going work: Coin Selection Simulation
In-Reply-To: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
References: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
Message-ID: <f8377b1b-05fd-ba1b-fb5f-f8d61d35c7d9@schildbach.de>

On 09/21/2016 02:58 PM, Murch via bitcoin-dev wrote:

> Android Wallet for Bitcoin

The correct name is Bitcoin Wallet, or Bitcoin Wallet for Android (if
you want to refer to the Android version).



From greg at xiph.org  Wed Sep 21 18:01:30 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 21 Sep 2016 18:01:30 +0000
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <CAAS2fgSpnshZhS7N5R3Qsw_8=NN8sjYGwrnUpdwGzu2TG0-Qgw@mail.gmail.com>
References: <7844645.RLYLWYmWtM@garp>
	<CAAS2fgSpnshZhS7N5R3Qsw_8=NN8sjYGwrnUpdwGzu2TG0-Qgw@mail.gmail.com>
Message-ID: <CAAS2fgT5izjzUVyd3-9sQEHx8rk8pEJWxT6-eDteuUkZdRokAg@mail.gmail.com>

On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> BIP number for my FT spec.

This document does not appear to be concretely specified enough to
review or implement from it.

For example, it does not specify the serialization of "integer" (is it
a 32 bit word in network byte order or?) nor does it specify how the
presence of the optional fields are signaled nor the cardinality of
the inputs or outputs. For clearly variable length elements
('bytearray') no mention is made of their length encoding. etc.

Without information like this, I don't see how someone could
realistically begin reviewing this proposal.

The motivation seems unclear to me as well: The scheme is described as
'flexible' but it appears to remove flexibility from the existing
system. The "schema" appears to be hardcoded and never communicated.
If the goal is to simply have a more compact on the wire
representation, this could be done without changing the serialization
used for hashing or the serialization used for costing.

From cp368202 at ohiou.edu  Wed Sep 21 22:40:57 2016
From: cp368202 at ohiou.edu (Chris Priest)
Date: Wed, 21 Sep 2016 15:40:57 -0700
Subject: [bitcoin-dev] On-going work: Coin Selection Simulation
In-Reply-To: <f8377b1b-05fd-ba1b-fb5f-f8d61d35c7d9@schildbach.de>
References: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
	<f8377b1b-05fd-ba1b-fb5f-f8d61d35c7d9@schildbach.de>
Message-ID: <CAAcC9ytNmGpAyd7YUQX=XtDXnsFjA65soSmCEqXyb7tQ0=cLJQ@mail.gmail.com>

>From my experience working with coin selection algorithms, there are
three "goals" to it:

1. Minimize cost
2. Maximize privacy
3. Minimize UTXO footprint

You can build a coin selection algorithm that achieves 1 and 3, but
will sacrifice 2. If you want coin selectin to maximize your privacy,
it will happen at the expense of UTXO footprint and fees. Minimizing
cost usually also minimizes UTXO footprint but not always. To
completely minimize UTXO footprint, you sacrifice a bit on cost, and a
lot on privacy.

On 9/21/16, Andreas Schildbach via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On 09/21/2016 02:58 PM, Murch via bitcoin-dev wrote:
>
>> Android Wallet for Bitcoin
>
> The correct name is Bitcoin Wallet, or Bitcoin Wallet for Android (if
> you want to refer to the Android version).
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From rx at awsomnet.org  Wed Sep 21 22:45:55 2016
From: rx at awsomnet.org (adiabat)
Date: Wed, 21 Sep 2016 18:45:55 -0400
Subject: [bitcoin-dev]  Requesting BIP assignment; Flexible Transactions.
Message-ID: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>

Hi-

One concern is that this doesn't seem compatible with Lightning as
currently written.  Most relevant is that non-cooperative channel close
transactions in Lightning use OP_CHECKSEQUENCEVERIFY, which references the
sequence field of the txin; if the txin doesn't have a sequence number,
OP_CHECKSEQUENCEVERIFY can't work.

LockByBlock and LockByTime aren't described and there doesn't seem to be
code for them in the PR (186).  If there's a way to make OP_CLTV and OP_CSV
work with this new format, please let us know, thanks!

-Tadge
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160921/48d7af14/attachment.html>

From tomz at freedommail.ch  Thu Sep 22 08:47:03 2016
From: tomz at freedommail.ch (Tom)
Date: Thu, 22 Sep 2016 10:47:03 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
Message-ID: <1530052.vkWv7VPOpL@garp>

On Wednesday 21 Sep 2016 18:45:55 adiabat via bitcoin-dev wrote:
> Hi-
> 
> One concern is that this doesn't seem compatible with Lightning as
> currently written.  Most relevant is that non-cooperative channel close
> transactions in Lightning use OP_CHECKSEQUENCEVERIFY, which references the
> sequence field of the txin; if the txin doesn't have a sequence number,
> OP_CHECKSEQUENCEVERIFY can't work.
> 
> LockByBlock and LockByTime aren't described and there doesn't seem to be
> code for them in the PR (186).  If there's a way to make OP_CLTV and OP_CSV
> work with this new format, please let us know, thanks!

LockByBlock and LockByTime are still TODOs because I didn't have time to go
in-dept into how BIP68 does the encoding.
The intent is that these tags, while loading, will set the sequence integer in 
the txin as the old version does. And while saving we do the reverse.

In other words; the lack of sequence number in the saved format doesn't affect 
the in-memory format of the transaction. The in-memory version is the one that 
script will operate on.

This means that there is no change in how CSV will work before and after on 
any level other than serialisation.

Flexible Transactions is definitely meant to support the Lightning Network, so 
any problems you find is something we should solve before it ships.

Thanks for your email!

From tomz at freedommail.ch  Thu Sep 22 08:56:31 2016
From: tomz at freedommail.ch (Tom)
Date: Thu, 22 Sep 2016 10:56:31 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <CAAS2fgT5izjzUVyd3-9sQEHx8rk8pEJWxT6-eDteuUkZdRokAg@mail.gmail.com>
References: <7844645.RLYLWYmWtM@garp>
	<CAAS2fgSpnshZhS7N5R3Qsw_8=NN8sjYGwrnUpdwGzu2TG0-Qgw@mail.gmail.com>
	<CAAS2fgT5izjzUVyd3-9sQEHx8rk8pEJWxT6-eDteuUkZdRokAg@mail.gmail.com>
Message-ID: <1988067.b5KirJFSKj@garp>

On Wednesday 21 Sep 2016 18:01:30 Gregory Maxwell via bitcoin-dev wrote:
> On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev
> 
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > BIP number for my FT spec.
> 
> This document does not appear to be concretely specified enough to
> review or implement from it.
> 
> For example, it does not specify the serialization of "integer"

It refers to the external specification which is linked at the bottom.
In that spec you'll see that "Integer" is the standard var-int that Bitcoin 
has used for years.

> nor does it specify how the
> presence of the optional fields are signaled 

How does one signals an optional field except of in the spec? Thats the job of 
a specification.

> nor the cardinality of
> the inputs or outputs. 

Did you miss this in the 3rd table ?  I suggest clicking on the github bips 
repo link as tables are not easy to read in mediawiki plain format that the 
email contained.

> For clearly variable length elements
> ('bytearray') no mention is made of their length encoding. etc.

Also in the external CMF spec.
 
> Without information like this, I don't see how someone could
> realistically begin reviewing this proposal.

I agree, that would be bad. Luckily that you just missed the link :)
Here it is;
https://github.com/bitcoinclassic/documentation/blob/master/spec/compactmessageformat.md

> The motivation seems unclear to me as well: The scheme is described as
> 'flexible' but it appears to remove flexibility from the existing
> system. The "schema" appears to be hardcoded and never communicated.

Being hardcoded and never communicated is what the current format does to. How 
does that "remove flexibility".

Also read my reply to Peter Todd on why this is flexible.

> If the goal is to simply have {snip}

It is not.

Thanks for asking, I understand that the CMF spec is useful to see as well. 
Hopefully you can now review it properly since I linked to it above.

Cheers!

From Daniel.Weigl at mycelium.com  Thu Sep 22 09:33:18 2016
From: Daniel.Weigl at mycelium.com (Daniel Weigl)
Date: Thu, 22 Sep 2016 11:33:18 +0200
Subject: [bitcoin-dev] On-going work: Coin Selection Simulation
In-Reply-To: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
References: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
Message-ID: <1aa41a90-2cc6-36c8-d9c5-67d52befabbe@mycelium.com>

Hi,

Is your simulation code available somewhere?

I was just wondering why mycelium generates a very big UTXO set for <1000sat, because change outputs will never be smaller than 
5460sat (=TransactionUtils.MINIMUM_OUTPUT_VALUE). If the change would be lower, it simply is skipped and added to the miner fee:
	-> https://github.com/mycelium-com/wallet/blob/master/public/bitlib/src/main/java/com/mrd/bitlib/StandardTransactionBuilder.java#L334

Does your simulation account for that?

It might also be that the small UTXO came from external tx and we never spend them, bec. of pruning/privacy. Not sure how we could optimize that.

Cheers,
Daniel

On 2016-09-21 14:58, Murch via bitcoin-dev wrote:
> Hi,
> 
> I'm currently compiling my Master's thesis about Coin Selection and my
> presentation proposal to Scaling Bitcoin has been accepted.
> 
> For my thesis, I have analyzed the Coin Selection problem, created a
> framework to simulate wallet behavior on basis of a sequence of
> payments, and have re-implemented multiple coin selection strategies of
> prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and
> Android Wallet for Bitcoin).
> 
> As the Scaling Bitcoin site suggests that research should be made
> available to this mailing list, I would like to invite you to have a
> look at:
> 
> http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf
> 
> The PDF (176 kB) contains a two page description of my on-going work,
> including preliminary simulation results, and three figures showing the
> simulated wallets' UTXO compositions at the end of the simulation.
> 
> I can provide further information as requested, and would welcome any
> feedback.
> 
> ?? If anyone has another sequence of incoming and outgoing payment
> amounts at hand that I could run my simulation on, I'd love to hear
> about it.
> 
> Regards
> 
> Murch
> 
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From decker.christian at gmail.com  Thu Sep 22 11:10:49 2016
From: decker.christian at gmail.com (Christian Decker)
Date: Thu, 22 Sep 2016 13:10:49 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <1988067.b5KirJFSKj@garp>
References: <7844645.RLYLWYmWtM@garp>
	<CAAS2fgSpnshZhS7N5R3Qsw_8=NN8sjYGwrnUpdwGzu2TG0-Qgw@mail.gmail.com>
	<CAAS2fgT5izjzUVyd3-9sQEHx8rk8pEJWxT6-eDteuUkZdRokAg@mail.gmail.com>
	<1988067.b5KirJFSKj@garp>
Message-ID: <20160922111049.GA592@nex>

On Thu, Sep 22, 2016 at 10:56:31AM +0200, Tom via bitcoin-dev wrote:
> On Wednesday 21 Sep 2016 18:01:30 Gregory Maxwell via bitcoin-dev wrote:
> > On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev
> > 
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > BIP number for my FT spec.
> > 
> > This document does not appear to be concretely specified enough to
> > review or implement from it.
> > 
> > For example, it does not specify the serialization of "integer"
> 
> It refers to the external specification which is linked at the bottom.
> In that spec you'll see that "Integer" is the standard var-int that Bitcoin 
> has used for years.

I think BIPs should be self-contained, or rely on previous BIPs,
whenever possible. Referencing an external formatting document should
be avoided and requiring readers to reverse engineer a reference
implementation doesn't seem too user friendly either. Publishing a BIP
with CMF would certainly help, and completing this spec with the
details that are missing, or only "defined" in the implementation,
would be better.

> > nor does it specify how the
> > presence of the optional fields are signaled 
> 
> How does one signals an optional field except of in the spec? Thats the job of 
> a specification.

So the presence is signaled by encountering the tag, which contains
both token type and name-reference. The encoder and decoder operations
could be described better.

> > nor the cardinality of
> > the inputs or outputs. 
> 
> Did you miss this in the 3rd table ?  I suggest clicking on the github bips 
> repo link as tables are not easy to read in mediawiki plain format that the 
> email contained.

Minor nit: that table is not well-formed. As was pointed out in the
normalized transaction ID BIP, your proposal only addresses
third-party malleability, since signers can simply change the
transaction and re-sign it. This is evident from the fact that inputs
and outputs do not have a canonical order and it would appear that
tokens can be re-ordered in segments. Dependencies of tokens inside a
segment are also rather alarming (TxInPrevHash <-> TxInPrevIndex,
TxOutScript <-> TxOutValue).

Finally, allowing miners to reject transactions with unknown fields
makes the OP_NOPs unusable since they'd result in forks: non-upgraded
nodes would reject blocks from upgraded nodes.

Regards,
Christian

From tomz at freedommail.ch  Thu Sep 22 12:09:38 2016
From: tomz at freedommail.ch (Tom)
Date: Thu, 22 Sep 2016 14:09:38 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <20160922111049.GA592@nex>
References: <7844645.RLYLWYmWtM@garp> <1988067.b5KirJFSKj@garp>
	<20160922111049.GA592@nex>
Message-ID: <6286144.BZfBM3Z3un@garp>

On Thursday 22 Sep 2016 13:10:49 Christian Decker via bitcoin-dev wrote:
> On Thu, Sep 22, 2016 at 10:56:31AM +0200, Tom via bitcoin-dev wrote:
> > On Wednesday 21 Sep 2016 18:01:30 Gregory Maxwell via bitcoin-dev wrote:
> > > On Tue, Sep 20, 2016 at 5:15 PM, Tom via bitcoin-dev
> > > 
> > > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > > BIP number for my FT spec.
> > > 
> > > This document does not appear to be concretely specified enough to
> > > review or implement from it.
> > > 
> > > For example, it does not specify the serialization of "integer"
> > 
> > It refers to the external specification which is linked at the bottom.
> > In that spec you'll see that "Integer" is the standard var-int that
> > Bitcoin
> > has used for years.
> 
> I think BIPs should be self-contained, or rely on previous BIPs,
> whenever possible. Referencing an external formatting document should
> be avoided 

If luke-jr thinks I should submit CMF as a BIP, I can certainly do that.
Luke, what do you think?

I don't have a preference either way.

> > > nor does it specify how the
> > > presence of the optional fields are signaled
> > 
> > How does one signals an optional field except of in the spec? Thats the
> > job of a specification.
> 
> So the presence is signaled by encountering the tag, which contains
> both token type and name-reference. The encoder and decoder operations
> could be described better.

I'm sorry, I'm not following you here. Is there a question?


> > > nor the cardinality of
> > > the inputs or outputs.
> > 
> > Did you miss this in the 3rd table ?  I suggest clicking on the github
> > bips
> > repo link as tables are not easy to read in mediawiki plain format that
> > the
> > email contained.
> 
> Minor nit: that table is not well-formed.

I am not very well versed in mediawiki tables, and I found github has some 
incompatibilities too.
The markdown one looks better;
https://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md

> As was pointed out in the
> normalized transaction ID BIP, your proposal only addresses
> third-party malleability, since signers can simply change the
> transaction and re-sign it.

I have to disagree. That is not malleability. Creating a new document and re-
signing it is not changing anything. Its re-creating. Something that the owner 
of the coin has every right to do.

> This is evident from the fact that inputs
> and outputs do not have a canonical order and it would appear that
> tokens can be re-ordered in segments. 

Sorry, what is evident? You seem to imply that it is uncommon that you can 
create two transactions of similar intent but using different bytes.
You would be wrong with this implication as this is very common. You can just 
alter the order of the inputs, for instance.

I am unable to see what the point is you are trying to make. Is there a 
question or a suggestion for improvement here?

> Dependencies of tokens inside a
> segment are also rather alarming (TxInPrevHash <-> TxInPrevIndex,
> TxOutScript <-> TxOutValue).

Maybe you missed this line; 
  ?TxInPrevHash and TxInPrevIndex
   Index can be skipped, but in any input the PrevHash always has
   to come first?

If you still see something alarming, let me know.
You can look at the code in Bitcoin Classic and notice that it really isn't 
anything complicated or worrying.


> Finally, allowing miners to reject transactions with unknown fields
> makes the OP_NOPs unusable 

Hmm, it looks like you are mixing terminology and abstraction-levels.  OP_NOP 
is a field from script and there is no discussion about any rejection based on 
script in this BIP at all.

Rejection of transactions is done on there being unrecognised tokens in the 
transaction formatting itself.

Thank you for your email to my BIP, I hope you got the answers you were 
looking for :)

From pete at petertodd.org  Thu Sep 22 18:26:18 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 22 Sep 2016 14:26:18 -0400
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <5590176.JJpBoGr4Tc@garp>
References: <7844645.RLYLWYmWtM@garp> <20160920215644.GA12030@fedora-21-dvm>
	<5590176.JJpBoGr4Tc@garp>
Message-ID: <20160922182618.GA19147@fedora-21-dvm>

On Wed, Sep 21, 2016 at 11:32:33AM +0200, Tom wrote:
> Thanks for your email Peter!
> 
> On Tuesday 20 Sep 2016 17:56:44 Peter Todd wrote:
> > On Tue, Sep 20, 2016 at 07:15:45PM +0200, Tom via bitcoin-dev wrote:
> > > === Serialization order===
> > > 
> > > The tokens defined above have to be serialized in a certain order for the
> > > transaction to be well-formatted.  Not serializing transactions in the
> > > order specified would allow multiple interpretations of the data which
> > > can't be allowed.
> > 
> > If the order of the tokens is fixed, the tokens themselves are redundant
> > information when tokens are required; when tokens may be omitted, a simple
> > "Some/None" flag to mark whether or not the optional data has been omitted
> > is appropriate.
> 
> This is addressed in the spec; 
> https://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md
> 
> ?The way towards that flexibility is to use a generic concept made popular
> various decades ago with the XML format. The idea is that we give each
> field a name and this means that new fields can be added or optional fields
> can be omitted from individual transactions?

That argument is not applicable to required fields: the code to get the fields
from the extensible format is every bit as complex as the very simple code
required to deserialize/serialize objects in the current system.

In any case your BIP needs to give some explicit examples of hypothetical
upgrades in the future, how they'd take advantage of this, and what the code to
do so would look like.

> > Also, if you're going to break compatibility with all existing software, it
> > makes sense to use a format that extends the merkle tree down into the
> > transaction inputs and outputs.
> 
> Please argue your case.

See my arguments re: segwit a few months ago, e.g. the hardware wallet txin
proof use-case.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160922/00bc0bdd/attachment.sig>

From pete at petertodd.org  Thu Sep 22 18:27:29 2016
From: pete at petertodd.org (Peter Todd)
Date: Thu, 22 Sep 2016 14:27:29 -0400
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <1530052.vkWv7VPOpL@garp>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
	<1530052.vkWv7VPOpL@garp>
Message-ID: <20160922182729.GA19254@fedora-21-dvm>

On Thu, Sep 22, 2016 at 10:47:03AM +0200, Tom via bitcoin-dev wrote:
> On Wednesday 21 Sep 2016 18:45:55 adiabat via bitcoin-dev wrote:
> > Hi-
> > 
> > One concern is that this doesn't seem compatible with Lightning as
> > currently written.  Most relevant is that non-cooperative channel close
> > transactions in Lightning use OP_CHECKSEQUENCEVERIFY, which references the
> > sequence field of the txin; if the txin doesn't have a sequence number,
> > OP_CHECKSEQUENCEVERIFY can't work.
> > 
> > LockByBlock and LockByTime aren't described and there doesn't seem to be
> > code for them in the PR (186).  If there's a way to make OP_CLTV and OP_CSV
> > work with this new format, please let us know, thanks!
> 
> LockByBlock and LockByTime are still TODOs because I didn't have time to go
> in-dept into how BIP68 does the encoding.
> The intent is that these tags, while loading, will set the sequence integer in 
> the txin as the old version does. And while saving we do the reverse.
> 
> In other words; the lack of sequence number in the saved format doesn't affect 
> the in-memory format of the transaction. The in-memory version is the one that 
> script will operate on.
> 
> This means that there is no change in how CSV will work before and after on 
> any level other than serialisation.

CSV uses per-input sequence numbers; you only have a per-tx equivalent.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160922/e0b97186/attachment.sig>

From tomz at freedommail.ch  Thu Sep 22 18:37:29 2016
From: tomz at freedommail.ch (Tom)
Date: Thu, 22 Sep 2016 20:37:29 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <20160922182729.GA19254@fedora-21-dvm>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
	<1530052.vkWv7VPOpL@garp> <20160922182729.GA19254@fedora-21-dvm>
Message-ID: <2232258.WNiT0kZN2f@kiwi>

On Thursday, 22 September 2016 14:27:29 CEST Peter Todd wrote:
> CSV uses per-input sequence numbers; you only have a per-tx equivalent.

I think you misunderstand tagged systems at a very basic level.  You think 
that html can only use a bold tag <b> once in a document? Thats equivalent 
to what you are saying.

Your comment is rather embarrassing, I have to point out. You may want to 
read a bit more before you comment more.

From tomz at freedommail.ch  Thu Sep 22 18:47:50 2016
From: tomz at freedommail.ch (Tom)
Date: Thu, 22 Sep 2016 20:47:50 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <20160922182618.GA19147@fedora-21-dvm>
References: <7844645.RLYLWYmWtM@garp> <5590176.JJpBoGr4Tc@garp>
	<20160922182618.GA19147@fedora-21-dvm>
Message-ID: <2619297.H12PQLatFI@kiwi>

On Thursday, 22 September 2016 14:26:18 CEST Peter Todd wrote:
> > ?The way towards that flexibility is to use a generic concept made
> > popular various decades ago with the XML format. The idea is that we
> > give each field a name and this means that new fields can be added or
> > optional fields can be omitted from individual transactions?
> 
> That argument is not applicable to required fields: 

The argument that optional fields can be omitted is not applicable to 
required fields, you are correct. That should be rather obvious because 
required fields are not optional fields.

> the code to get the
> fields from the extensible format is every bit as complex as the very
> simple code required to deserialize/serialize objects in the current
> system.

Probably a tiny bit more complex as the current format assumes a lot more.

You may have misread my email because there was no argument made towards 
complexity. The argument was towards flexibility.

> In any case your BIP needs to give some explicit examples of hypothetical
> upgrades in the future, how they'd take advantage of this, and what the
> code to do so would look like.

Why?

> > > Also, if you're going to break compatibility with all existing
> > > software, it makes sense to use a format that extends the merkle
> > > tree down into the transaction inputs and outputs.
> > 
> > Please argue your case.
> 
> See my arguments re: segwit a few months ago, e.g. the hardware wallet
> txin proof use-case.

Please consider that I'm not going to search for something based on a vague 
reference like that, if you want to convince me you could you at least 
provide a URL?
You want me to see the value of your idea, I think you should at least 
provide the argument. Isn't that fair?

Thanks for your email Peter, would love you to put a bit more time into 
understanding flexible transactions and we can have a proper discussion 
about it.

From dev at jonasschnelli.ch  Thu Sep 22 19:59:12 2016
From: dev at jonasschnelli.ch (Jonas Schnelli)
Date: Thu, 22 Sep 2016 21:59:12 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <2232258.WNiT0kZN2f@kiwi>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
	<1530052.vkWv7VPOpL@garp> <20160922182729.GA19254@fedora-21-dvm>
	<2232258.WNiT0kZN2f@kiwi>
Message-ID: <57E43810.3070905@jonasschnelli.ch>

Hi Tom

> I think you misunderstand tagged systems at a very basic level.  You think 
> that html can only use a bold tag <b> once in a document? Thats equivalent 
> to what you are saying.

Would the "additional" segment contain the same amount of
nSequence-equivalent token as the number of inputs in the "inputs" segment?
What if you only want to add a per-input-token in the additional segment
for a certain input (assume last input)?
I guess the fundamental difference to html is the possible nesting.

However, I think that should be mentioned/specified in the BIP.

</jonas>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160922/70a1092a/attachment-0001.sig>

From tomz at freedommail.ch  Thu Sep 22 20:07:33 2016
From: tomz at freedommail.ch (Tom)
Date: Thu, 22 Sep 2016 22:07:33 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <57E43810.3070905@jonasschnelli.ch>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
	<2232258.WNiT0kZN2f@kiwi> <57E43810.3070905@jonasschnelli.ch>
Message-ID: <6618657.bnLDbNbqGc@kiwi>

On Thursday, 22 September 2016 21:59:12 CEST Jonas Schnelli via bitcoin-dev 
wrote:
> Hi Tom
> 
> > I think you misunderstand tagged systems at a very basic level.  You
> > think that html can only use a bold tag <b> once in a document? Thats
> > equivalent to what you are saying.
> 
> Would the "additional" segment contain the same amount of
> nSequence-equivalent token as the number of inputs in the "inputs"
> segment?

At this point I don't know what it should look like, I have not had time to 
look deeply into BIP68.  Is this what you would suggest it to look like?
I rather figured spending limitations would be assigned to an output, not 
an input.

> However, I think that should be mentioned/specified in the BIP.

It can be, and likely should be.  This BIP doesn't pretend to be finished 
yet.

I welcome any and all discussion about this, it only serves to make the end 
result stronger!

From Daniel.Weigl at mycelium.com  Fri Sep 23 09:35:22 2016
From: Daniel.Weigl at mycelium.com (Daniel Weigl)
Date: Fri, 23 Sep 2016 11:35:22 +0200
Subject: [bitcoin-dev] On-going work: Coin Selection Simulation
In-Reply-To: <3b7ff5e7-9803-27ab-af26-df2c743f53d0@murch.one>
References: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
	<1aa41a90-2cc6-36c8-d9c5-67d52befabbe@mycelium.com>
	<3b7ff5e7-9803-27ab-af26-df2c743f53d0@murch.one>
Message-ID: <385cf934-931f-5035-738b-3d6f0e401436@mycelium.com>

Hello Murch,

> I've corrected the boundary in my simulation now and will update my
> simulation results before Scaling Bitcoin. Thank you very much for your
> correction.

Okay, if you already had included this logic I guess it wont change the
result that much if the cut off is 4440 or 5460sat. 
But Im curious to see the new results.


> It is my understanding that Mycelium doesn't create small change outputs
> but rather hardly ever spends them when received.
..
> so please correct me when I'm wrong:
> Mycelium appears to select UTXO in a FIFO approach, but, after the
> selection, prunes by removing the smallest selected UTXO until the
> excess beyond the spending target is minimized. This post-selection step
> seems the likely reason for Mycelium's small UTXO build-up. (Bitcoin
> Core intermittenly used post-selection pruning also, and apparently this
> did cause a similar increase in UTXO set size then.)

Yes, you are correct - we added this pruning step about 2y ago to
improve privacy for the user on average. Every transaction
only links only so much inputs together as really necessary to fund 
the transaction.

Our idea is to have the user the option (either global or per account or
per transaction) to choose between "maximize privacy" or "minimize fees"
(or even maybe "minimize UTXO", if the become more expensive in the future)
That will the change the behaviour of the coin selector.

Thx for your work, also looking forward to see the code and maybe play with 
it a bit to test for different payment behaviours and coin selections.

Cheers,
Daniel


On 2016-09-23 11:11, Murch wrote:
> Hi Daniel,
> 
> Thank you for your mail.
> My simulation of the Mycelium coin selection does add small change
> outputs to the fee, but I did get your boundary wrong.
> Instead of the 5460, I dropped at the dust boundary which calculates to
> 4440 in my simulation. Therefore, I think that the results in the table
> might be slightly too big, but likely indicative of the actual Mycelium
> behavior.
> I've corrected the boundary in my simulation now and will update my
> simulation results before Scaling Bitcoin. Thank you very much for your
> correction.
> 
> Sorry, the simulation code has not been published yet, I plan to do that
> around Scaling Bitcoin or after I turn in my thesis (End of October). I
> will let you know when I do.
> 
> It is my understanding that Mycelium doesn't create small change outputs
> but rather hardly ever spends them when received.
> 
> You're probably more familiar with the code base (I think you work for
> Mycelium?), so please correct me when I'm wrong:
> Mycelium appears to select UTXO in a FIFO approach, but, after the
> selection, prunes by removing the smallest selected UTXO until the
> excess beyond the spending target is minimized. This post-selection step
> seems the likely reason for Mycelium's small UTXO build-up. (Bitcoin
> Core intermittenly used post-selection pruning also, and apparently this
> did cause a similar increase in UTXO set size then.)
> 
> I assume that this will also cause Mycelium to create a huge transaction
> every once in a while when this build-up is enough to fund a transaction
> without a bigger UTXO being selected.
> 
> As to how it may be mitigated: BreadWallet uses a very similar FIFO
> approach, but doesn't prune. My simulation result indicates that their
> average UTXO set is much smaller. This has the downside that users could
> be spammed with small transaction outputs that they then would pay for
> spending.
> A balanced approach between these two approaches might be that instead
> of pruning all small inputs, a few of the small inputs could be allowed
> to be selected to slowly drain low-value UTXO out of the wallet by
> spending them over time. In order to avoid the privacy issues such as
> e.g. always spending the oldest UTXO, it would for example be possible
> to implement this as a 75% probability to prune an unnecessary output.
> 
> Regards
> Murch
> 
> Am 22.09.2016 um 11:33 schrieb Daniel Weigl via bitcoin-dev:
>> Hi,
>>
>> Is your simulation code available somewhere?
>>
>> I was just wondering why mycelium generates a very big UTXO set for <1000sat, because change outputs will never be smaller than 
>> 5460sat (=TransactionUtils.MINIMUM_OUTPUT_VALUE). If the change would be lower, it simply is skipped and added to the miner fee:
>> 	-> https://github.com/mycelium-com/wallet/blob/master/public/bitlib/src/main/java/com/mrd/bitlib/StandardTransactionBuilder.java#L334
>>
>> Does your simulation account for that?
>>
>> It might also be that the small UTXO came from external tx and we never spend them, bec. of pruning/privacy. Not sure how we could optimize that.
>>
>> Cheers,
>> Daniel
>>
>> On 2016-09-21 14:58, Murch via bitcoin-dev wrote:
>>> Hi,
>>>
>>> I'm currently compiling my Master's thesis about Coin Selection and my
>>> presentation proposal to Scaling Bitcoin has been accepted.
>>>
>>> For my thesis, I have analyzed the Coin Selection problem, created a
>>> framework to simulate wallet behavior on basis of a sequence of
>>> payments, and have re-implemented multiple coin selection strategies of
>>> prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and
>>> Android Wallet for Bitcoin).
>>>
>>> As the Scaling Bitcoin site suggests that research should be made
>>> available to this mailing list, I would like to invite you to have a
>>> look at:
>>>
>>> http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf
>>>
>>> The PDF (176 kB) contains a two page description of my on-going work,
>>> including preliminary simulation results, and three figures showing the
>>> simulated wallets' UTXO compositions at the end of the simulation.
>>>
>>> I can provide further information as requested, and would welcome any
>>> feedback.
>>>
>>> ?? If anyone has another sequence of incoming and outgoing payment
>>> amounts at hand that I could run my simulation on, I'd love to hear
>>> about it.
>>>
>>> Regards
>>>
>>> Murch
>>>
>>>
>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>

From luke at dashjr.org  Fri Sep 23 09:57:01 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 23 Sep 2016 09:57:01 +0000
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
Message-ID: <201609230957.03138.luke@dashjr.org>

This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin 
scripting system to address reissuing bitcoin transactions when the coins they 
spend have been conflicted/double-spent.

https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki

Does this seem like a good idea/approach?

Luke

From decker.christian at gmail.com  Fri Sep 23 11:42:36 2016
From: decker.christian at gmail.com (Christian Decker)
Date: Fri, 23 Sep 2016 13:42:36 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <6286144.BZfBM3Z3un@garp>
References: <7844645.RLYLWYmWtM@garp> <1988067.b5KirJFSKj@garp>
	<20160922111049.GA592@nex> <6286144.BZfBM3Z3un@garp>
Message-ID: <20160923114236.GA17871@nex>

On Thu, Sep 22, 2016 at 02:09:38PM +0200, Tom via bitcoin-dev wrote:
> On Thursday 22 Sep 2016 13:10:49 Christian Decker via bitcoin-dev wrote:
> > 
> > I think BIPs should be self-contained, or rely on previous BIPs,
> > whenever possible. Referencing an external formatting document should
> > be avoided 
> 
> If luke-jr thinks I should submit CMF as a BIP, I can certainly do that.
> Luke, what do you think?
> 
> I don't have a preference either way.
> 
> > 
> > So the presence is signaled by encountering the tag, which contains
> > both token type and name-reference. The encoder and decoder operations
> > could be described better.
> 
> I'm sorry, I'm not following you here. Is there a question?

Nope, just clarifying how presence or absence is indicated :-)

> > 
> > Minor nit: that table is not well-formed.
> 
> I am not very well versed in mediawiki tables, and I found github has some 
> incompatibilities too.
> The markdown one looks better;
> https://github.com/bitcoinclassic/documentation/blob/master/spec/transactionv4.md

It's just some rows have 3 columns, others have 2. It's a minor nit
really.

> > As was pointed out in the
> > normalized transaction ID BIP, your proposal only addresses
> > third-party malleability, since signers can simply change the
> > transaction and re-sign it.
> 
> I have to disagree. That is not malleability. Creating a new document and re-
> signing it is not changing anything. Its re-creating. Something that the owner 
> of the coin has every right to do.

Same thing I was arguing back then, however Luke pointed out that
malleability just refers to the possibility of modifying a transaction
after the fact. Always referring to "third-party malleability" avoids
this ambiguity.

> > This is evident from the fact that inputs
> > and outputs do not have a canonical order and it would appear that
> > tokens can be re-ordered in segments. 
> 
> Sorry, what is evident? You seem to imply that it is uncommon that you can 
> create two transactions of similar intent but using different bytes.
> You would be wrong with this implication as this is very common. You can just 
> alter the order of the inputs, for instance.
> 
> I am unable to see what the point is you are trying to make. Is there a 
> question or a suggestion for improvement here?
> 
> > Dependencies of tokens inside a
> > segment are also rather alarming (TxInPrevHash <-> TxInPrevIndex,
> > TxOutScript <-> TxOutValue).
> 
> Maybe you missed this line; 
>   ?TxInPrevHash and TxInPrevIndex
>    Index can be skipped, but in any input the PrevHash always has
>    to come first?

Nope, that is exactly the kind of dependency I was talking
about. Instead of nesting a construct like the current transactions
do, you rely on the order of tokens to imply that they belong
together.

> If you still see something alarming, let me know.
> You can look at the code in Bitcoin Classic and notice that it really isn't 
> anything complicated or worrying.
> 
> 
> > Finally, allowing miners to reject transactions with unknown fields
> > makes the OP_NOPs unusable 
> 
> Hmm, it looks like you are mixing terminology and abstraction-levels.  OP_NOP 
> is a field from script and there is no discussion about any rejection based on 
> script in this BIP at all.
> 
> Rejection of transactions is done on there being unrecognised tokens in the 
> transaction formatting itself.

Ah, thanks for clearing that up. However, the problem persists, if we
add new fields that a non-upgraded node doesn't know about and it
rejects transactions containing it, we'll have a hard-fork. It should
probably not reject transactions with unknown fields if the
transaction is included in a block.

> Thank you for your email to my BIP, I hope you got the answers you were 
> looking for :)

Cheers,
Christian

From decker.christian at gmail.com  Fri Sep 23 11:55:50 2016
From: decker.christian at gmail.com (Christian Decker)
Date: Fri, 23 Sep 2016 13:55:50 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <2232258.WNiT0kZN2f@kiwi>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
	<1530052.vkWv7VPOpL@garp> <20160922182729.GA19254@fedora-21-dvm>
	<2232258.WNiT0kZN2f@kiwi>
Message-ID: <20160923115550.GB17871@nex>

On Thu, Sep 22, 2016 at 08:37:29PM +0200, Tom via bitcoin-dev wrote:
> On Thursday, 22 September 2016 14:27:29 CEST Peter Todd wrote:
> > CSV uses per-input sequence numbers; you only have a per-tx equivalent.
> 
> I think you misunderstand tagged systems at a very basic level.  You think 
> that html can only use a bold tag <b> once in a document? Thats equivalent 
> to what you are saying.
> 
> Your comment is rather embarrassing, I have to point out. You may want to 
> read a bit more before you comment more.

Not sure if the comparison to XML and HTML holds: the lack of closing
tags makes the meaning of individual tokens ambiguous, like I pointed
out before. The use of segments gives at most two levels of nesting,
so any relationship among tokens in the same segment has to rely on
their relative position, which could result in ambiguities, like
whether a tag refers to a single input or the transaction as a whole.

Cheers,
Christian

From murch at murch.one  Fri Sep 23 09:11:58 2016
From: murch at murch.one (Murch)
Date: Fri, 23 Sep 2016 11:11:58 +0200
Subject: [bitcoin-dev] On-going work: Coin Selection Simulation
In-Reply-To: <1aa41a90-2cc6-36c8-d9c5-67d52befabbe@mycelium.com>
References: <358752cc-48f6-eef8-ae9a-e17a0651ed52@murch.one>
	<1aa41a90-2cc6-36c8-d9c5-67d52befabbe@mycelium.com>
Message-ID: <3b7ff5e7-9803-27ab-af26-df2c743f53d0@murch.one>

Hi Daniel,

Thank you for your mail.
My simulation of the Mycelium coin selection does add small change
outputs to the fee, but I did get your boundary wrong.
Instead of the 5460, I dropped at the dust boundary which calculates to
4440 in my simulation. Therefore, I think that the results in the table
might be slightly too big, but likely indicative of the actual Mycelium
behavior.
I've corrected the boundary in my simulation now and will update my
simulation results before Scaling Bitcoin. Thank you very much for your
correction.

Sorry, the simulation code has not been published yet, I plan to do that
around Scaling Bitcoin or after I turn in my thesis (End of October). I
will let you know when I do.

It is my understanding that Mycelium doesn't create small change outputs
but rather hardly ever spends them when received.

You're probably more familiar with the code base (I think you work for
Mycelium?), so please correct me when I'm wrong:
Mycelium appears to select UTXO in a FIFO approach, but, after the
selection, prunes by removing the smallest selected UTXO until the
excess beyond the spending target is minimized. This post-selection step
seems the likely reason for Mycelium's small UTXO build-up. (Bitcoin
Core intermittenly used post-selection pruning also, and apparently this
did cause a similar increase in UTXO set size then.)

I assume that this will also cause Mycelium to create a huge transaction
every once in a while when this build-up is enough to fund a transaction
without a bigger UTXO being selected.

As to how it may be mitigated: BreadWallet uses a very similar FIFO
approach, but doesn't prune. My simulation result indicates that their
average UTXO set is much smaller. This has the downside that users could
be spammed with small transaction outputs that they then would pay for
spending.
A balanced approach between these two approaches might be that instead
of pruning all small inputs, a few of the small inputs could be allowed
to be selected to slowly drain low-value UTXO out of the wallet by
spending them over time. In order to avoid the privacy issues such as
e.g. always spending the oldest UTXO, it would for example be possible
to implement this as a 75% probability to prune an unnecessary output.

Regards
Murch

Am 22.09.2016 um 11:33 schrieb Daniel Weigl via bitcoin-dev:
> Hi,
> 
> Is your simulation code available somewhere?
> 
> I was just wondering why mycelium generates a very big UTXO set for <1000sat, because change outputs will never be smaller than 
> 5460sat (=TransactionUtils.MINIMUM_OUTPUT_VALUE). If the change would be lower, it simply is skipped and added to the miner fee:
> 	-> https://github.com/mycelium-com/wallet/blob/master/public/bitlib/src/main/java/com/mrd/bitlib/StandardTransactionBuilder.java#L334
> 
> Does your simulation account for that?
> 
> It might also be that the small UTXO came from external tx and we never spend them, bec. of pruning/privacy. Not sure how we could optimize that.
> 
> Cheers,
> Daniel
> 
> On 2016-09-21 14:58, Murch via bitcoin-dev wrote:
>> Hi,
>>
>> I'm currently compiling my Master's thesis about Coin Selection and my
>> presentation proposal to Scaling Bitcoin has been accepted.
>>
>> For my thesis, I have analyzed the Coin Selection problem, created a
>> framework to simulate wallet behavior on basis of a sequence of
>> payments, and have re-implemented multiple coin selection strategies of
>> prominent Bitcoin wallets (Bitcoin Core, Mycelium, Breadwallet, and
>> Android Wallet for Bitcoin).
>>
>> As the Scaling Bitcoin site suggests that research should be made
>> available to this mailing list, I would like to invite you to have a
>> look at:
>>
>> http://murch.one/wp-content/uploads/2016/09/CoinSelection.pdf
>>
>> The PDF (176 kB) contains a two page description of my on-going work,
>> including preliminary simulation results, and three figures showing the
>> simulated wallets' UTXO compositions at the end of the simulation.
>>
>> I can provide further information as requested, and would welcome any
>> feedback.
>>
>> ?? If anyone has another sequence of incoming and outgoing payment
>> amounts at hand that I could run my simulation on, I'd love to hear
>> about it.
>>
>> Regards
>>
>> Murch
>>
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From tomz at freedommail.ch  Fri Sep 23 13:13:10 2016
From: tomz at freedommail.ch (Tom)
Date: Fri, 23 Sep 2016 15:13:10 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <20160923115550.GB17871@nex>
References: <CAKEeUhjisp8qdXDNz3C+pB1MUTfvmHZPmsE-f0DVTxnph6NmMQ@mail.gmail.com>
	<2232258.WNiT0kZN2f@kiwi> <20160923115550.GB17871@nex>
Message-ID: <2344192.PKYylsbkSL@kiwi>

On Friday, 23 September 2016 13:55:50 CEST Christian Decker via bitcoin-dev 
wrote: 
> Not sure if the comparison to XML and HTML holds: the lack of closing
> tags makes the meaning of individual tokens ambiguous, like I pointed
> out before. The use of segments gives at most two levels of nesting,
> so any relationship among tokens in the same segment has to rely on
> their relative position, which could result in ambiguities, like
> whether a tag refers to a single input or the transaction as a whole.


Practically all tagged formats make ordering a requirement, so indeed this 
is relevant, and not unique.

For instance if you write;
  <div> Some line </br>Another line</br>3rd line</div>
you can get a good idea of how ordering is relevant. You can reuse any item 
many times.

Whenever there is a possible confusion the specification specifically 
explains which order to use.

I'm not sure what you mean with the idea this;

>  The use of segments gives at most two levels of nesting

It looks like you assume there is some opening and closing tags, since 
otherwise there would be no nesting.
Such tags are not intended, nor documented.

> so any relationship among tokens in the same segment has to rely on
> their relative position, which could result in ambiguities, like
> whether a tag refers to a single input or the transaction as a whole.

I quoted parts of the spec in your previous email stating the same thing, 
but I'll repeat here.
Any place that has any sort of possibility to be ambiguous is specified 
specifically to have an order.  This makes writing and parsing easier.

Since you wrote two emails now with the same issue, and I addressed it 
twice, I would urge you to write out some examples which may be confusing 
and if you find that the spec is indeed missing requirements then please 
share it with us.  I did this some time ago and it helps understanding the 
ideas by having actual explicit examples.  I am not aware of any sort of 
ambiguities that the spec allows.

Cheers!

From tomz at freedommail.ch  Fri Sep 23 13:17:52 2016
From: tomz at freedommail.ch (Tom)
Date: Fri, 23 Sep 2016 15:17:52 +0200
Subject: [bitcoin-dev] Requesting BIP assignment; Flexible Transactions.
In-Reply-To: <20160923114236.GA17871@nex>
References: <7844645.RLYLWYmWtM@garp> <6286144.BZfBM3Z3un@garp>
	<20160923114236.GA17871@nex>
Message-ID: <34304783.iUnM6JERa9@kiwi>

On Friday, 23 September 2016 13:42:36 CEST Christian Decker via bitcoin-dev wrote:
> > I have to disagree. That is not malleability. Creating a new document
> > and re- signing it is not changing anything. Its re-creating.
> > Something that the owner of the coin has every right to do.
> Same thing I was arguing back then, however Luke pointed out that
> malleability just refers to the possibility of modifying a transaction
> after the fact.

I am not a fan of redefining dictionary words. I'll stick to the 
universally excepted one, thanks.

> Nope, that is exactly the kind of dependency I was talking
> about. Instead of nesting a construct like the current transactions
> do, you rely on the order of tokens to imply that they belong
> together.


> if we
> add new fields that a non-upgraded node doesn't know about and it
> rejects transactions containing it, we'll have a hard-fork. It should
> probably not reject transactions with unknown fields if the
> transaction is included in a block.

This is addressed here;
https://github.com/bitcoin/bips/blob/master/bip-0134.mediawiki#future-extensibility


From roconnor at blockstream.io  Fri Sep 23 13:43:15 2016
From: roconnor at blockstream.io (Russell O'Connor)
Date: Fri, 23 Sep 2016 09:43:15 -0400
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <201609230957.03138.luke@dashjr.org>
References: <201609230957.03138.luke@dashjr.org>
Message-ID: <CAMZUoKnY7s1b75Z_0QCb2hh-Q_hCE4-9dZ9tY58HaUQy6=aCbw@mail.gmail.com>

I believe Bitcoin currently enjoys the property that during an "innocent"
re-org, i.e. a reorg in which no affected transactions are being double
spent, all affected transactions can always eventually get replayed, so
long as the re-org depth is less than 100.

My concern with this proposed operation is that it would destroy this
property.

On Fri, Sep 23, 2016 at 5:57 AM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin
> scripting system to address reissuing bitcoin transactions when the coins
> they
> spend have been conflicted/double-spent.
>
> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki
>
> Does this seem like a good idea/approach?
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/21649e63/attachment.html>

From tomz at freedommail.ch  Fri Sep 23 14:37:39 2016
From: tomz at freedommail.ch (Tom)
Date: Fri, 23 Sep 2016 16:37:39 +0200
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <201609230957.03138.luke@dashjr.org>
References: <201609230957.03138.luke@dashjr.org>
Message-ID: <2403444.9CSRyRIcH2@garp>

On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:
> This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin
> scripting system to address reissuing bitcoin transactions when the coins
> they spend have been conflicted/double-spent.
> 
> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki


Can you walk us through a real live usecase which this solves?  I read it and 
I think I understand it, but I can't see the attack every giving the attacker 
any benefit (or the attacked losing anything).

From pete at petertodd.org  Fri Sep 23 16:18:17 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 23 Sep 2016 12:18:17 -0400
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <201609230957.03138.luke@dashjr.org>
References: <201609230957.03138.luke@dashjr.org>
Message-ID: <20160923161817.GA22926@fedora-21-dvm>

On Fri, Sep 23, 2016 at 09:57:01AM +0000, Luke Dashjr via bitcoin-dev wrote:
> This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin 
> scripting system to address reissuing bitcoin transactions when the coins they 
> spend have been conflicted/double-spent.
> 
> https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki
> 
> Does this seem like a good idea/approach?

Your BIP is a bit confusing: you say "In some circumstances, users may wish to
spend received bitcoins before they have confirmed on the blockchain", but what
you're really referring to isn't spending unconfirmed outputs - which
OP_CHECKBLOCKATHEIGHT can't protect - but rather spending outputs with a small
number of confirmations.

In the existing ecosystem, if multi-block reorgs were a regular event Bitcoin
would be in a lot of trouble; since they're rare, advising wallet authors to
simply refuse to make transactions for some time after such a reorg may be a
better solution. After all, a multi-block reorg is a strong indication that
there's somehting very wrong with the network, and it'd be safer to stop using
Bitcoin for awhile until things settle down.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/abc32eea/attachment.sig>

From greg at xiph.org  Fri Sep 23 18:57:57 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 23 Sep 2016 18:57:57 +0000
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <CAAS2fgQGC695mkyze+mVTZZoQN1mh+1y32u-D6Yv1R7nXWPDcg@mail.gmail.com>
References: <201609230957.03138.luke@dashjr.org>
	<CAMZUoKnY7s1b75Z_0QCb2hh-Q_hCE4-9dZ9tY58HaUQy6=aCbw@mail.gmail.com>
	<CAAS2fgQGC695mkyze+mVTZZoQN1mh+1y32u-D6Yv1R7nXWPDcg@mail.gmail.com>
Message-ID: <CAAS2fgTJ9iPoE6fvMBhFB8ruwy-6aTo4Ka5agK+LHjSqGa2-rw@mail.gmail.com>

On Fri, Sep 23, 2016 at 1:43 PM, Russell O'Connor via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I believe Bitcoin currently enjoys the property that during an "innocent"
> re-org, i.e. a reorg in which no affected transactions are being double
> spent, all affected transactions can always eventually get replayed, so long
> as the re-org depth is less than 100.

> My concern with this proposed operation is that it would destroy this
> property.

The reorg safety impact of this proposal could be eliminated and the
mempool handling complexity greatly reduced if the transaction was
required to be locktimed at least 100 blocks after the block its
referencing.

This would also resolve a rather severe DOS weakness that the spec has
with the suggestion that nodes would relay this rule without
validating it. With the depth restriction nodes could relay one (or a
couple) blocks early without creating a situation where someone can
consume relay resources with near zero odds of paying a fee for them.

Irritatingly, applications of this rule would really want to be
applied at signing time (like locktime is), not as part of a
scriptpubkey. With it part of a scriptpubkey two moves are required. I
think solving this is important.

FWIW, this scheme more has been proposed before for another reason--
effectively allowing users to 'vote against' long reorgs by making
sure their transactions can't be included in them. Though for that
application it was only needed to use 32 bits of the block hash.

From pete at petertodd.org  Fri Sep 23 20:02:23 2016
From: pete at petertodd.org (Peter Todd)
Date: Fri, 23 Sep 2016 16:02:23 -0400
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <CAAS2fgTJ9iPoE6fvMBhFB8ruwy-6aTo4Ka5agK+LHjSqGa2-rw@mail.gmail.com>
References: <201609230957.03138.luke@dashjr.org>
	<CAMZUoKnY7s1b75Z_0QCb2hh-Q_hCE4-9dZ9tY58HaUQy6=aCbw@mail.gmail.com>
	<CAAS2fgQGC695mkyze+mVTZZoQN1mh+1y32u-D6Yv1R7nXWPDcg@mail.gmail.com>
	<CAAS2fgTJ9iPoE6fvMBhFB8ruwy-6aTo4Ka5agK+LHjSqGa2-rw@mail.gmail.com>
Message-ID: <20160923200223.GA24227@fedora-21-dvm>

On Fri, Sep 23, 2016 at 06:57:57PM +0000, Gregory Maxwell via bitcoin-dev wrote:
> On Fri, Sep 23, 2016 at 1:43 PM, Russell O'Connor via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > I believe Bitcoin currently enjoys the property that during an "innocent"
> > re-org, i.e. a reorg in which no affected transactions are being double
> > spent, all affected transactions can always eventually get replayed, so long
> > as the re-org depth is less than 100.
> 
> > My concern with this proposed operation is that it would destroy this
> > property.
> 
> The reorg safety impact of this proposal could be eliminated and the
> mempool handling complexity greatly reduced if the transaction was
> required to be locktimed at least 100 blocks after the block its
> referencing.

However, by doing that we'd also make the functionality not all that useful for
this application; by the time you waited 100 blocks for the tx to be minable,
the chance of a reorg happening is low enough that I can't imagine many - if
any - wallets would bother using the opcode in the first place, and would
instead just rely on the fact that a reorg that deep which resulted in the
double-spent transaction ending up back in the chain is very unlikely.

Specifically I'm referring to the following scenario:

1) Alice pays Bob with tx1a
2) tx1a gets N confirmations, where N is some small number of confirmations.
2) Bob pays Charlie from tx1a's output in tx2a
3) A reorg eliminates the block that tx1a existed, and a conflicting tx1b is
   mined instead, making tx1a and tx2a invalid.
4) Bob pays Charlie again with tx2b, whose inputs do not conflict with tx2a
5) Another reorg eliminates tx1b, allowing tx1a, tx2a, and tx2b to all be
   mined.
6) Charlie has now been paid twice.

Since you need _two_ reorgs for this scenario to be applicable, it's much
easier to just wait for tx1b to be confirmed suffiently deeply in the chain
that a reorg undoing it - thus allowing tx1a and tx2a to exist - is
sufficiently unlikely; 100 blocks is a lot more than  most wallets are going to
consider "sufficiently unlikely", so the featureu just won't get used (assuming
wallets even bother to handle this case of course!).

Unfortunately I think this is an inherent catch-22 of the idea.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/db03fdfb/attachment.sig>

From luke at dashjr.org  Fri Sep 23 22:20:39 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 23 Sep 2016 22:20:39 +0000
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <CAMZUoKnY7s1b75Z_0QCb2hh-Q_hCE4-9dZ9tY58HaUQy6=aCbw@mail.gmail.com>
References: <201609230957.03138.luke@dashjr.org>
	<CAMZUoKnY7s1b75Z_0QCb2hh-Q_hCE4-9dZ9tY58HaUQy6=aCbw@mail.gmail.com>
Message-ID: <201609232220.41783.luke@dashjr.org>

In the innocent use case of this opcode, a double-spend has already occurred, 
and this should be a strict improvement. In the non-innocent abuse of this 
opcode, I don't see that it's any worse than simply double-spending.

Would this proposal be better or otherwise more acceptable, if a specified 
height more recent than 100 blocks deep causes the script to fail? This would 
increase delays in recovering the double-spend situation of course... but less 
than 24h.

Luke


On Friday, September 23, 2016 1:43:15 PM Russell O'Connor wrote:
> I believe Bitcoin currently enjoys the property that during an "innocent"
> re-org, i.e. a reorg in which no affected transactions are being double
> spent, all affected transactions can always eventually get replayed, so
> long as the re-org depth is less than 100.
> 
> My concern with this proposed operation is that it would destroy this
> property.
> 
> On Fri, Sep 23, 2016 at 5:57 AM, Luke Dashjr via bitcoin-dev <
> 
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin
> > scripting system to address reissuing bitcoin transactions when the coins
> > they
> > spend have been conflicted/double-spent.
> > 
> > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki
> > 
> > Does this seem like a good idea/approach?
> > 
> > Luke
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From luke at dashjr.org  Fri Sep 23 22:34:41 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 23 Sep 2016 22:34:41 +0000
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <2403444.9CSRyRIcH2@garp>
References: <201609230957.03138.luke@dashjr.org> <2403444.9CSRyRIcH2@garp>
Message-ID: <201609232234.43689.luke@dashjr.org>

Joe sends Alice 5 BTC (UTXO 0).
Fred sends Alice 4 BTC (UTXO 1).
Alice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).
Fred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's transfer to 
Bob.
Alice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so, it is 
possible that UTXO 0 could be mined, and then both UTXO 2 and UTXO 3 which 
would result in her giving Bob a total of 8 BTC rather than merely 4 BTC.
Even if Alice waits until Fred's UTXO 1-B confirms 10 blocks deep, it is not 
impossible for a reorganization to reverse those 10 blocks and confirm UTXO 1 
again.
Using OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that it is 
valid only in the blockchain where Fred's UTXO 1-B has confirmed. This way, if 
that block is reorganized out, UTXO 3 is invalid, and either Bob receives only 
the original UTXO 2, or Alice can create a UTXO 3-B which is valid in the 
reorganized blockchain if it again confirms the UTXO 1-B double-spend.

Luke

On Friday, September 23, 2016 2:37:39 PM Tom via bitcoin-dev wrote:
> On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:
> > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin
> > scripting system to address reissuing bitcoin transactions when the coins
> > they spend have been conflicted/double-spent.
> > 
> > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki
> 
> Can you walk us through a real live usecase which this solves?  I read it
> and I think I understand it, but I can't see the attack every giving the
> attacker any benefit (or the attacked losing anything).
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From greg at xiph.org  Fri Sep 23 23:43:49 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 23 Sep 2016 23:43:49 +0000
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <201609232220.41783.luke@dashjr.org>
References: <201609230957.03138.luke@dashjr.org>
	<CAMZUoKnY7s1b75Z_0QCb2hh-Q_hCE4-9dZ9tY58HaUQy6=aCbw@mail.gmail.com>
	<201609232220.41783.luke@dashjr.org>
Message-ID: <CAAS2fgTCOq1pHrPVbkNzCp_bYqbXh6Y6osF5_jFUZRy1rWPQCw@mail.gmail.com>

On Fri, Sep 23, 2016 at 10:20 PM, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> In the innocent use case of this opcode, a double-spend has already occurred,
> and this should be a strict improvement. In the non-innocent abuse of this
> opcode, I don't see that it's any worse than simply double-spending.

There is a fungibility hit... right now, absent double spends (and
privacy issues), every coin you might get paid is equal.

With this script feature as described, you could get paid a coin which
has one of these in its recent past, pinning the block immediately
before it. A reorg long enough to remove that block-- due to an
attack, or an ordinary block race, or some kind of consensus glitch
(like we had in March 2013 or around the activation of BIP65)-- is
_guaranteed_ to invalidate those coins, even without any double spend.

If the scheme doesn't do as I suggest and prevent over-eager usage
(perhaps 100 is too much, I just decided to match coinbases); then it
should probably have a consensus enforced explicit "maximum survivable
reorg" that is traced along with the outputs, so that someone who
received exposed coins could handle it sensibly.

Just for plain engineering reasons, I still think it is important to
now allow overly short back references. If the reference has to be a
few blocks back we don't need to worry about short forks breaking
propagation, and simple mempool handling like purging all CBAH
transactions on a large reorg would work fine.  It need not be so long
as to implicate Petertodd's concern that you could only use it where
it wouldn't matter.  (Though I also disagree that a depth of 100
achieves that, consider persistent chain forks).

From dscotese at litmocracy.com  Sat Sep 24 00:08:24 2016
From: dscotese at litmocracy.com (Dave Scotese)
Date: Fri, 23 Sep 2016 17:08:24 -0700
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <201609232234.43689.luke@dashjr.org>
References: <201609230957.03138.luke@dashjr.org> <2403444.9CSRyRIcH2@garp>
	<201609232234.43689.luke@dashjr.org>
Message-ID: <CAGLBAhc3cSuKS6mszE-ygETChdoS5MXO4YePkHx4-AC2wGgQ_A@mail.gmail.com>

If Alice knows enough to see that she needs CHECKBLOCKATHEIGHT to avoid
paying Bob twice, then she also knows that Fred owes her 4BTC.  If Bob
complains about getting paid faster, Alice can let him know that Fred
essentially stole his coins and that when she is certain he (and she) can't
get them back, she will send a different four coins to Bob.  If she can
establish trust with Bob (She'd trust Bob to pay her back if he gets back
the coins Fred stole), then she can pay him again.  Bob could also make a
transaction to send the first input from Alice back to her (since he
doesn't have those coins anyway), sign it, and send that to her.  She can
then keep it instead of having to use the new opcode.

Or she can let her wallet use the new opcode so that the logic is built in,
if we add this opcode.  Wallet makers who want to help solve this problem
can either implement the new opcode, or they can offer people like Bob the
ability to refund orphaned transactions so that they can be duplicated in
the valid chain without any risk to the original sender.

With the opcode, Alice can solve the problem by herself.  Without it, Bob
can solve it for Alice.

While the opcode adds complexity, it enables victims of double-spends to
pay untrusted creditors (Bob) without the risk that orphaned chains create
of paying them twice.  I'm not sure the added complexity is worth the
reward. The reward is to protect Bitcoiners (Alice) from people we'd call
"untrusted creditors" (Bob) and I think that might be a mistake.  Getting a
refund transaction signed and sent back to Alice is similar to how the LN
will work (where wallets hold transactions that they don't broadcast).

Am I understanding this correctly?

On Fri, Sep 23, 2016 at 3:34 PM, Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Joe sends Alice 5 BTC (UTXO 0).
> Fred sends Alice 4 BTC (UTXO 1).
> Alice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).
> Fred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's transfer
> to
> Bob.
> Alice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so,
> it is
> possible that UTXO 0 could be mined, and then both UTXO 2 and UTXO 3 which
> would result in her giving Bob a total of 8 BTC rather than merely 4 BTC.
> Even if Alice waits until Fred's UTXO 1-B confirms 10 blocks deep, it is
> not
> impossible for a reorganization to reverse those 10 blocks and confirm
> UTXO 1
> again.
> Using OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that it
> is
> valid only in the blockchain where Fred's UTXO 1-B has confirmed. This
> way, if
> that block is reorganized out, UTXO 3 is invalid, and either Bob receives
> only
> the original UTXO 2, or Alice can create a UTXO 3-B which is valid in the
> reorganized blockchain if it again confirms the UTXO 1-B double-spend.
>
> Luke
>
> On Friday, September 23, 2016 2:37:39 PM Tom via bitcoin-dev wrote:
> > On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:
> > > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the Bitcoin
> > > scripting system to address reissuing bitcoin transactions when the
> coins
> > > they spend have been conflicted/double-spent.
> > >
> > > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki
> >
> > Can you walk us through a real live usecase which this solves?  I read it
> > and I think I understand it, but I can't see the attack every giving the
> > attacker any benefit (or the attacked losing anything).
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
I like to provide some work at no charge to prove my value. Do you need a
techie?
I own Litmocracy <http://www.litmocracy.com> and Meme Racing
<http://www.memeracing.net> (in alpha).
I'm the webmaster for The Voluntaryist <http://www.voluntaryist.com> which
now accepts Bitcoin.
I also code for The Dollar Vigilante <http://dollarvigilante.com/>.
"He ought to find it more profitable to play by the rules" - Satoshi
Nakamoto
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160923/a0d9fa2b/attachment-0001.html>

From greg at xiph.org  Sat Sep 24 00:21:16 2016
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 24 Sep 2016 00:21:16 +0000
Subject: [bitcoin-dev] Proposed BIP-1 change removing OPL licensing option.
Message-ID: <CAAS2fgQ813Dfo3n9TKvoUMdhs+MGz=UABzRmY5UGJkoLGaFyZA@mail.gmail.com>

I've proposed a revision to BIP-1 that removes the option to license
the work under the OPL:  https://github.com/bitcoin/bips/pull/446

The OPL contains troublesome terms where the licensor can elect to
prohibit print publication of the work as well as the creation of
modified versions without their approval.

"Distribution of substantively modified versions of this document is
prohibited without the explicit permission of the copyright holder."
"Distribution of the work or derivative of the work in any standard
(paper) book form is prohibited unless prior permission is obtained
from the copyright holder."

Additionally, even without these optional clauses the specific
construction of this licenses' attribution requirements are
restrictive enough that Debian does not consider it acceptable for
works included in their distribution
(https://lists.debian.org/debian-legal/2004/03/msg00226.html).

I can't find any discussion that indicates anyone involved with the
project was aware of these clauses at the time this text was added...
and I believe they are strongly incompatible with having a
transparent, public, collaborative process for the development of
standard for interoperablity. I certainly wasn't aware of it, and
would have argued against it if I was.

Moreover, the project that created this license has recommended people
use creative commons licenses instead since 2007.

The only BIPs that have availed themselves of this are BIP145 (which
is dual licensed under the permissive 2-clause BSD, which I wouldn't
object to adding as an option-- and which doesn't active the
objectionable clauses) and the recently assigned BIP134.

From luke at dashjr.org  Sat Sep 24 06:36:00 2016
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 24 Sep 2016 06:36:00 +0000
Subject: [bitcoin-dev] BIP 2 revival and rework
Message-ID: <201609240636.01968.luke@dashjr.org>

I've revived BIP 2 (from Deferred Status) and given it some updates. Most 
notably, I have reworked it to be a *replacement* for BIP 1 rather than an 
addendum.

https://github.com/luke-jr/bips/blob/bip0002_squash/bip-0002.mediawiki

Please review it. If things go well, hopefully we can get this done by 
Christmas. ;)

Other recent changes include:
* OPL will no longer be an acceptable license. Many in the community feel that 
prohibiting publication is unacceptable for BIPs, and I haven't heard any 
arguments in favour of allowing it.
* Accepted Status has been renamed to Proposed. The name "Accepted" seems a 
constant source of confusion since it requires only action from the author.
* Non-image auxiliary files are permitted in the bip-XXXX subdirectory. This 
was already the norm despite BIP 1.
* Email addresses are now required for authors. The Travis script has been 
enforcing this for months now already.
* The Post-History header may be provided as a link instead of a simple date. 
A few BIPs were already doing this.
* Markdown format is no longer permitted for BIPs. I don't see the point in 
allowing multiple formats, and so far we've been fine with just MediaWiki.
* The Resolution header has been dropped, as it is not applicable to a 
decentralised system where no authority exists to make final decisions.

Other changes already in the previous draft of BIP 2:
* An implementation is now required (when applicable) before BIPs can proceed 
to Proposed Status.
* BIP Comments are newly introduced.
* The License preamble headers have been added.

Thanks,

Luke

From tomz at freedommail.ch  Sat Sep 24 09:41:57 2016
From: tomz at freedommail.ch (Tom)
Date: Sat, 24 Sep 2016 11:41:57 +0200
Subject: [bitcoin-dev] BIP 2 revival and rework
In-Reply-To: <201609240636.01968.luke@dashjr.org>
References: <201609240636.01968.luke@dashjr.org>
Message-ID: <2024168.qgaqMetGW1@kiwi>

On Saturday, 24 September 2016 06:36:00 CEST Luke Dashjr via bitcoin-dev 
wrote:
> * OPL will no longer be an acceptable license. Many in the community feel
> that prohibiting publication is unacceptable for BIPs, and I haven't
> heard any arguments in favour of allowing it.

My suggestion would be that we replace OPL as an allowed license with one 
or two Creative Commons licenses. Following the suggestion from the OPL 
creators themselves.
According to Wikipedia;

> Open Publication License was created by the Open Content Project in 1999 
> as public copyright license for documents. The license was superseded
> in 2003/2007 by the Creative commons licenses.

I'd suggest saying that "Share alike" is required and "Attribution" is 
optional.

Executive summary; give the user the choice (next to public domain) between 
CCO and BY-SA
see;
https://en.wikipedia.org/wiki/
Creative_Commons_license#Seven_regularly_used_licenses

From tomz at freedommail.ch  Sat Sep 24 09:37:52 2016
From: tomz at freedommail.ch (Tom)
Date: Sat, 24 Sep 2016 11:37:52 +0200
Subject: [bitcoin-dev] BIP draft: OP_CHECKBLOCKATHEIGHT
In-Reply-To: <201609232234.43689.luke@dashjr.org>
References: <201609230957.03138.luke@dashjr.org> <2403444.9CSRyRIcH2@garp>
	<201609232234.43689.luke@dashjr.org>
Message-ID: <4508352.RUQdqZv42T@kiwi>

Thank you Luke, this makes it clearer.

It doesn't change that this scenario is an attack that doesn't give the 
attacker any benefit and the attacked doesn't loose anything either (as 
Dave pointed out).

This is a completely academical problem that assumes so many stupid 
mistakes from software and from people that its very unlikely. On top of 
that it assumes a rather lengthy 51% attack in concert with this already 
extremely unlikely usecase.

In the scenario you assume stupid people and then you solve it by requiring 
the victim to suddenly be super smart and use a solution specifically 
designed for this super unlikely usecase that probably will never actually 
happen...

I don't buy it.

On Friday, 23 September 2016 22:34:41 CEST Luke Dashjr wrote:
> Joe sends Alice 5 BTC (UTXO 0).
> Fred sends Alice 4 BTC (UTXO 1).
> Alice sends Bob 4 BTC using UTXO 1 (creating UTXO 2).
> Fred double-spends UTXO 1 with UTXO 1-B. This invalidates Alice's
> transfer to Bob.
> Alice has UTXO 0 which she can send to Bob (UTXO 3), but if she does so,
> it is possible that UTXO 0 could be mined, and then both UTXO 2 and UTXO
> 3 which would result in her giving Bob a total of 8 BTC rather than
> merely 4 BTC. Even if Alice waits until Fred's UTXO 1-B confirms 10
> blocks deep, it is not impossible for a reorganization to reverse those
> 10 blocks and confirm UTXO 1 again.
> Using OP_CHECKBLOCKATHEIGHT, however, Alice can create UTXO 3 such that
> it is valid only in the blockchain where Fred's UTXO 1-B has confirmed.
> This way, if that block is reorganized out, UTXO 3 is invalid, and
> either Bob receives only the original UTXO 2, or Alice can create a UTXO
> 3-B which is valid in the reorganized blockchain if it again confirms
> the UTXO 1-B double-spend.
> 
> Luke
> 
> On Friday, September 23, 2016 2:37:39 PM Tom via bitcoin-dev wrote:
> > On Friday 23 Sep 2016 09:57:01 Luke Dashjr via bitcoin-dev wrote:
> > > This BIP describes a new opcode (OP_CHECKBLOCKATHEIGHT) for the
> > > Bitcoin
> > > scripting system to address reissuing bitcoin transactions when the
> > > coins they spend have been conflicted/double-spent.
> > > 
> > > https://github.com/luke-jr/bips/blob/bip-cbah/bip-cbah.mediawiki
> > 
> > Can you walk us through a real live usecase which this solves?  I read
> > it and I think I understand it, but I can't see the attack every
> > giving the attacker any benefit (or the attacked losing anything).
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From pete at petertodd.org  Mon Sep 26 18:41:36 2016
From: pete at petertodd.org (Peter Todd)
Date: Mon, 26 Sep 2016 14:41:36 -0400
Subject: [bitcoin-dev] Proposed BIP-1 change removing OPL licensing
 option.
In-Reply-To: <CAAS2fgQ813Dfo3n9TKvoUMdhs+MGz=UABzRmY5UGJkoLGaFyZA@mail.gmail.com>
References: <CAAS2fgQ813Dfo3n9TKvoUMdhs+MGz=UABzRmY5UGJkoLGaFyZA@mail.gmail.com>
Message-ID: <20160926184136.GA15752@fedora-21-dvm>

On Sat, Sep 24, 2016 at 12:21:16AM +0000, Gregory Maxwell via bitcoin-dev wrote:
> I've proposed a revision to BIP-1 that removes the option to license
> the work under the OPL:  https://github.com/bitcoin/bips/pull/446
> 
> The OPL contains troublesome terms where the licensor can elect to
> prohibit print publication of the work as well as the creation of
> modified versions without their approval.
> 
> "Distribution of substantively modified versions of this document is
> prohibited without the explicit permission of the copyright holder."
> "Distribution of the work or derivative of the work in any standard
> (paper) book form is prohibited unless prior permission is obtained
> from the copyright holder."
> 
> Additionally, even without these optional clauses the specific
> construction of this licenses' attribution requirements are
> restrictive enough that Debian does not consider it acceptable for
> works included in their distribution
> (https://lists.debian.org/debian-legal/2004/03/msg00226.html).
> 
> I can't find any discussion that indicates anyone involved with the
> project was aware of these clauses at the time this text was added...
> and I believe they are strongly incompatible with having a
> transparent, public, collaborative process for the development of
> standard for interoperablity. I certainly wasn't aware of it, and
> would have argued against it if I was.
> 
> Moreover, the project that created this license has recommended people
> use creative commons licenses instead since 2007.
> 
> The only BIPs that have availed themselves of this are BIP145 (which
> is dual licensed under the permissive 2-clause BSD, which I wouldn't
> object to adding as an option-- and which doesn't active the
> objectionable clauses) and the recently assigned BIP134.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

ACK

Note how the OPL is significantly more restrictive than the Bitcoin Core
license; not good if we can't ship documentation with the code.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160926/0d42c6b1/attachment.sig>

From tomz at freedommail.ch  Tue Sep 27 09:51:40 2016
From: tomz at freedommail.ch (Tom)
Date: Tue, 27 Sep 2016 11:51:40 +0200
Subject: [bitcoin-dev] Proposed BIP-1 change removing OPL licensing
	option.
In-Reply-To: <20160926184136.GA15752@fedora-21-dvm>
References: <CAAS2fgQ813Dfo3n9TKvoUMdhs+MGz=UABzRmY5UGJkoLGaFyZA@mail.gmail.com>
	<20160926184136.GA15752@fedora-21-dvm>
Message-ID: <2882300.70fluXe1Lh@garp>

On Monday 26 Sep 2016 14:41:36 Peter Todd via bitcoin-dev wrote:
> Note how the OPL is significantly more restrictive than the Bitcoin Core
> license; not good if we can't ship documentation with the code.

Documentation and code can have different licenses, the sole existence of 
various documentation licenses attests to that point.
Shipping your docs under a separate licence has never been a problem before, 
so you don't have to worry that you can't ship documentation with code.

That said, I wrote my suggestion in reply to Luke's BIP2 revival which is a 
more formal suggestion of a solution. Maybe you can ACK that one instead?

Last, in preparation of acceptance of BIP2 I changed the licence of my BIP to 
be dual-licensed.  Now its also available under a Creative Commons license.

Have a nice day!

From pete at petertodd.org  Tue Sep 27 19:17:07 2016
From: pete at petertodd.org (Peter Todd)
Date: Tue, 27 Sep 2016 15:17:07 -0400
Subject: [bitcoin-dev] Proposed BIP-1 change removing OPL licensing
 option.
In-Reply-To: <2882300.70fluXe1Lh@garp>
References: <CAAS2fgQ813Dfo3n9TKvoUMdhs+MGz=UABzRmY5UGJkoLGaFyZA@mail.gmail.com>
	<20160926184136.GA15752@fedora-21-dvm> <2882300.70fluXe1Lh@garp>
Message-ID: <20160927191707.GA22136@fedora-21-dvm>

On Tue, Sep 27, 2016 at 11:51:40AM +0200, Tom via bitcoin-dev wrote:
> On Monday 26 Sep 2016 14:41:36 Peter Todd via bitcoin-dev wrote:
> > Note how the OPL is significantly more restrictive than the Bitcoin Core
> > license; not good if we can't ship documentation with the code.
> 
> Documentation and code can have different licenses, the sole existence of 
> various documentation licenses attests to that point.
> Shipping your docs under a separate licence has never been a problem before, 
> so you don't have to worry that you can't ship documentation with code.

The issue isn't that the licenses are different, it's that the OPL is
significantly more restrictive (with the additional clauses that you opted
into).

Indeed, using a different license for documentation is common advise, although
if the documentation also includes example code you may want to dual-license
the documentation with a code-oriented license as well if the documentation
license isn't maximally permissive.

> That said, I wrote my suggestion in reply to Luke's BIP2 revival which is a 
> more formal suggestion of a solution. Maybe you can ACK that one instead?
>
> Last, in preparation of acceptance of BIP2 I changed the licence of my BIP to 
> be dual-licensed.  Now its also available under a Creative Commons license.

Thanks, CC-BY-SA is a perfectly good license for that purpose.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20160927/bcbb4c51/attachment.sig>

From jl2012 at xbt.hk  Fri Sep 30 10:57:53 2016
From: jl2012 at xbt.hk (Johnson Lau)
Date: Fri, 30 Sep 2016 18:57:53 +0800
Subject: [bitcoin-dev] New BIP: Limiting excessive SignatureHash operation
Message-ID: <1577abe4a84.e9b9c8da3882.6224549273767153798@xbt.hk>

 A new BIP is proposed to prevent excessive O(n^2) SignatureHash operation.

https://github.com/jl2012/bips/blob/sighash/bip-sighash.mediawiki
https://github.com/bitcoin/bitcoin/pull/8755 (Tight estimation)
https://github.com/bitcoin/bitcoin/pull/8756 (Loose estimation)

Two methods of sighash size estimation are proposed, with different tradeoff. The tight estimation is more permissive (disabling less txs) but require disabling of OP_CODESEPARATOR, FindAndDelete, and unusual nHashType. The loose estimation is less permissive (may disable more big and strange txs) but does not depend on further policy/consensus rules. With either type of estimation, normal standard txs (<100kB, P2PK, P2PKH, canonical bare or P2SH multisig) are totally unaffected by this BIP.

  BIP: ?
  Title: Limiting excessive SignatureHash operation
  Author: Johnson Lau <jl2012 at xbt.hk>
  Status: Draft
  Type: Standards Track
  Created: 2016-09-21


Abstract

This proposal defines a new type of block-level resources limit, with several (optional) script restrictions, to prevent excessive SignatureHash operation.

Introduction

There are 4 ECDSA signature verification codes in the Bitcoin script system: CHECKSIG, CHECKSIGVERIFY, CHECKMULTISIG, CHECKMULTISIGVERIFY (?sigops?). According to the SIGHASH type, a transaction digest (sighash) is generated with a double SHA256 of a serialized subset of the transaction, with a function called SignatureHash, and the signature is verified against this sighash with a given public key. Due to a design weakness, the amount of data hashing in SignatureHash is proportional to the size of the transaction. Therefore, data hashing grows in O(n2) as the number of sigops in a transaction increases. While a 1 MB block would normally take 2 seconds to verify with an average computer in 2015, a 1 MB transaction with 5569 sigops may take 25 seconds to verify. [1][2][3]

BIP143 fixes this problem by introducing a new SignatureHash algorithm in segregated witness transactions. However, it would not be able and is not intended to fix the problem of pre-segregated witness transactions. This document proposes a new type of block-level resources limit to prevent excessive SignatureHash operation. However, the calculation of sighash is a complicated process involving several consensus-critical procedures, including the use of OP_CODESEPARATOR, the FindAndDelete function, and the interpretation of nHashType. A correct limitation should be made based on the effects of these procedures.

Specification

Transaction hashable size

Transaction hashable size (TxHashableSize) is defined as the size of a transaction, which:

is serialized without witness data (BIP144), and
has scriptSig in all inputs replaced by zero-size script
TxHashableSize is an estimation of the amount of data hashed with a SIGHASH_ALL. Without counting the size of scriptCode and nHashType, it always underestimates the size. However, the difference is negligible since it grows linearly with the number of sigops.
int64_t GetTransactionHashableSize(const CTransaction& tx)
{
    int64_t size = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);
    for (unsigned int i = 0; i < tx.vin.size(); i++) {
        int64_t scriptSigSize = tx.vin[i].scriptSig.size();
        size -= scriptSigSize;
        // If the scriptSig size is larger than 252, 2 bytes compactSize encoding is deducted.
        if (scriptSigSize > 252)
            size -= 2;
        /*
         * Theoretically, 4 bytes should be deducted if the scriptSig is larger than 65535 bytes,
         * and 8 bytes should be deducted if it is larger than 4294967295 bytes.
         * However, scriptSig larger than 10000 bytes is invalid so it is not needed.
         */
    }
    return size;
}
SignatureHash equivalent operation

SignatureHash equivalent operation (SigHashOp) is defined as the maximum possible number of times which a sigop would perform SignatureHash at the TxHashableSize. Depends on whether some extra restrictions in script use are enforced, there are 2 ways to estimate the SigHashOp:

Loose estimation: A loose SigHashOp estimation does not depend on any extra script restrictions. It assumes that SignatureHash is performed not more than once for every ECDSA signature passing to a sigop. It looks for all sigops in a transaction (even in an unexecuted conditional branch), in scriptSig, in scriptPubKey of the outputs being spent, and in redeemScript of P2SH transactions. Each OP_CHECKSIG or CHECKSIGVERIFY is counted as 1 SigHashOp. Each OP_CHECKMULTISIG or CHECKMULTISIGVERIFY is counted as 20 SigHashOp, unless all the following conditions are satisfied:

The OP_CHECKMULTISIG or CHECKMULTISIGVERIFY is immediately preceded by a value push as OP_n (1 ? n ? 16), denoting the number of public keys (n).
The n opcodes preceding the OP_n must be push type (i.e. 0x00 ? opcode ? 0x60), as the public key(s)
The opcodes preceding the public key(s) is a OP_m, with 1 ? m ? 16 and m ? n, denoting the number of signatures (m)
If all these conditions are met, the OP_CHECKMULTISIG or CHECKMULTISIGVERIFY is counted as m SigHashOp.
SigHashOp of a transaction is the sum of SigHashOp of each of its inputs.

unsigned int CScript::GetSigHashOpCount() const
{
    unsigned int n = 0;
    const_iterator pc = begin();
    std::vector<opcodetype> pushOpcodes;
    while (pc < end())
    {
        opcodetype opcode;
        if (!GetOp(pc, opcode))
            break; // The script is invalid
        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)
            n++;
        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY) {
            unsigned int nKey = 0;
            unsigned int nSig = 0;
            // We assume a CHECKMULTISIG will hash the transaction for 20 times, unless it is in some canonical form.
            n += 20;
            // The number of keys must be k = 1 to 16 denoted by OP_k
            if (pushOpcodes.size() >= 3 && pushOpcodes.back() >= OP_1 && pushOpcodes.back() <= OP_16) {
                nKey = DecodeOP_N(pushOpcodes.back());
                // All the k + 2 opcodes before the CHECKMULTISIG must be push only
                if (pushOpcodes.size() >= nKey + 2) {
                    opcodetype nSigCode = pushOpcodes.at(pushOpcodes.size() - nKey - 2);
                    // The number of signatures must be k = 1 to 16 denoted by OP_k, and not larger than number of keys
                    if (nSigCode >= OP_1 && nSigCode <= OP_16) {
                        nSig = DecodeOP_N(nSigCode);
                        if (nSig <= nKey)
                            // We use the number of signatures as the SigOpCount of this CHECKMULTISIG
                            n = n - 20 + nSig;
                    }
                }
            }
        }

        if (opcode <= OP_16)
            pushOpcodes.push_back(opcode);
        else
            pushOpcodes.clear();
    }
    return n;
}
Tight estimation: An tight SigHashOp estimation depends on these extra consensus rules for pre-segregated witness scripts:

nHashType is confined to only 6 types: 0x01 for SIGHASH_ALL, 0x02 for SIGHASH_NONE, 0x03 for SIGHASH_SINGLE, 0x81 for SIGHASH_ALL|SIGHASH_ANYONECANPAY, 0x82 for SIGHASH_NONE|SIGHASH_ANYONECANPAY, and 0x83 for SIGHASH_SINGLE|SIGHASH_ANYONECANPAY. A signature with other nHashType is invalid.
Script with OP_CODESEPARATOR, even in an unexecuted conditional branch, is invalid.
Script that involves non-zero FindAndDelete results is invalid.
It also assumes that SignatureHash is performed not more than once in each script for each nHashType.
SigHashOp is counted in the same way as the loose estimation. However, if the SigHashOp for a script is found to be larger than 3, it is counted as only 3 SigHashOp.[4] The SigHashOp of a transaction is the sum of SigHashOp of each of its inputs.

SigHashOp of the generating transaction is defined to be 0.

SignatureHash size

SignatureHash size (SigHashSize) of a transaction is the product of TxHashableSize and SigHashOp.

SigHashSize of a block is the sum of SigHashSize of all transactions in the block.

Consensus and policy limits for SigHashSize

A new consensus rule is enforced to require that SigHashSize of a block MUST NOT be larger than 500,000,000 (500MB). Consequently, SigHashSize of a valid transaction MUST NOT be larger than 500MB.

A new relay and mempool policy is recommended to reject any unconfirmed transaction that has a SigHashSize to Transaction weight ratio larger than 90. This policy limit is equivalent to 36MB SigHashSize for a 100kB non-segregated witness transaction, or 360MB for a full block of such transactions.

Rationale

Static analysis

This proposal employs a static analysis approach to estimate SigHashSize of transactions and blocks. This allows early rejection of violating transactions and blocks without executing the scripts at all. Despite that the size of scriptCode and nHashType are not considered in the estimation, the difference is negligible comparing with size of the main transaction body, since the overheads grows linearly with the number of sigops, which is mostly restricted by the 80,000 sigop limit (BIP141). [5]

Loose SigHashOp estimation

The loose SigHashOp estimation assumes that SignatureHash is performed not more than once for every ECDSA signature passing to a sigop. This assumption is obviously correct for OP_CHECKSIG and CHECKSIGVERIFY since they would never perform SignatureHash more than once, while no SignatureHash would be performed if they happen in an unexecuted conditional branch, or if the signature is an empty vector. This assumption is also correct for OP_CHECKMULTISIG and CHECKMULTISIGVERIFY with appropriate code refactoring. While a signature may be verified against multiple public keys, the sighash for this signature must remain unchanged across the whole operation and therefore could be reused. Therefore, SigHashOp of a OP_CHECKMULTISIG and CHECKMULTISIGVERIFY is equal to the number of signatures.

Tight SigHashOp estimation with extra script restrictions

The tight SigHashOp estimation is based on more assumptions. It assumes that the scriptCode serialized within SignatureHash is a constant value for all sigops in an transaction input. For this assumption to be true, we must disable any process that may modify the scriptCode, which are OP_CODESEPARATOR and FindAndDelete. Transactions involving OP_CODESEPARATOR and FindAndDelete are extremely rare in the main network, and arguably all of those were performed for testing purpose. Removal of these operations would have next to no functional loss, significantly simply the consensus-critical logic, and reduce the risks of unintentional consensus forks. [6]

The tight SigHashOp estimation also assumes that only 6 nHashType are allowed. This is a relay policy in reference implementation since v0.?, and transactions with violating signatures are extremely rare in the main network. However, at consensus level, SigHashOp could be any value from 0 to 255, and a SIGHASH type could be encoded in multiple ways. For example, there are 116 ways to denote SIGHASH_ALL. Since nHashType is serialized inside SignatureHash, the sighash produced by different nHashType are not the same, even if all of them were SIGHASH_ALL.

With all these extra consensus rules implemented, we could be assured that SignatureHash is performed not more than once in each script for each nHashType, due to the invariability of scriptCode. The 6 nHashType limitation further guarantees that each script, with whatever number of sigops, would never perform SignatureHash for more than approximately 3 times of TxHashableSize (excluding some linearly growing overhead), as shown below:

TxHashableSize could be divided into 3 parts: size of inputs, size of outputs, and size of overhead including nVersion, nLockTime, and maybe some CompactSize encoding. The size of overhead grows linearly with the number of sigops, and is negligible.
SIGHASH_ALL would hash all inputs and outputs of the transaction.
SIGHASH_NONE would hash all inputs of the transaction, but no output is hashed.
SIGHASH_SINGLE would hash all inputs of the transaction. It also hashes the scriptPubKey of output with matching index, and all outputs with lower indexes with empty scriptPubKey. With the famous Gauss summation formula, it could be shown that if a transaction has the same number of inputs and outputs, and all inputs use a SIGHASH_SINGLE, the worst case would be hashing approximately 50% of all outputs of the transaction.
nHashType with SIGHASH_ANYONECANPAY would hash only one input, which scales linearly and is negligible. Therefore,
SIGHASH_ALL|SIGHASH_ANYONECANPAY would hash all outputs.
SIGHASH_NONE|SIGHASH_ANYONECANPAY is negligible.
SIGHASH_SINGLE|SIGHASH_ANYONECANPAY would hash approximately 50% of all outputs in the worst case.
By adding up the effects of 6 nHashType, it could be shown that the total amount of data hashed would be equal to 3 times of input size and 3 times of output size. Therefore, in the worst case, a script may perform SignatureHash for up to approximately 3 times of TxHashableSize.
SigHashSize policy limit

A policy limit for SigHashSize to Transaction weight ratio is recommended as 90, which is equivalent to 36MB SigHashSize for a 100kB non-segregated witness transaction. This limit is chosen based on the concept of normal transaction.

A transaction is normal if each SigHashOp consumes at least 70 bytes of space in scriptSig on average. According to BIP66, the maximum size of an ECDSA signature is 73 bytes, which should consume 74 bytes of scriptSig space including the push opcode. Using the low S value, the maximum signature size becomes 72 bytes. It could be shown that with 99.6% of chance, a randomly generated low S signature would be at least 69 bytes (consuming 70 bytes of space in scriptSig).

In actual use, the scriptSig size associated to a SigHashOp is often much more than 70 bytes. For example, pay-to-public-key-hash transactions and OP_CHECKMULTISIG inside P2SH would consume extra scriptSig space with their public keys. In such cases, more than 100 bytes of scriptSig would be consumed by a SigHashOp.

If a transaction is performing many SigHashOp with disproportionately small scriptSig, very likely it employed some strange scripts, such as using OP_DUP to copy a signature.

The size of scriptSig is important in determining the SigHashSize limit, since it is deducted from the transaction size for the TxHashableSize. Comparing 2 transactions of the same size, the one with more SigHashOp may have smaller SigHashSize due to the smaller TxHashableSize. With the 100kB standard transaction size limit, it could be shown that the maximum SigHashSize happens when there are 714 SigHashOp, consuming at least 714 * 70 = 49.98kB of scriptSig. With the resulting TxHashableSize = 100 - 49.98 = 50.02kB, the SigHashSize is 50.02kB * 714 = 35.7MB, which is just below the recommended policy limit.

Despite the limit is determined based on normal transactions, abnormal transactions may still be accepted as long as they are not too big. For example, if the transaction size is 10kB, a transaction may remain standard with the recommended policy limit even if each SigHashOp is associated with only 7 bytes of scriptSig.

SigHashSize consensus limit

The consensus limit of 500MB SigHashSize per block is based on the policy limit of SigHashSize to Transaction weight ratio. It is set above the policy limit, to make sure that a miner enforcing the policy limit would never produce a block violating the consensus rules. The 500MB limit is compromise between avoiding loss of functionality (as it may disable some very big transactions) and the harm of intentional or unintentional sighash attack initiated by a miner.

Deployment

This is a softfork to be deployed with BIP9.

Backward compatibility

Impact of the recommended policy limit

No matter the loose or the tight SigHashOp estimation is employed, this softfork with recommended policy limit should be completely transparent to users of normal standard transactions, including pay-to-public-key, pay-to-public-key-hash, and P2SH m-of-n OP_CHECKMULTISIG with 1 ? m ? n ? 15. A complete scan up to block 430368 showed that the transaction 7b587808a7f6b135ef91011be9b42fcbb0892da50963822e47a5827ced8653ce was the normal standard transaction with highest SigHashSize to weight ratio. With a ratio of 80.1, it is still well below the policy limit of 90. Should this policy had been deployed since genesis block, all normal standard transactions should still have been accepted.

If the loose estimation had been employed, a few abnormal standard transactions would have been rejected by policy, but were still valid by consensus. This is a full list of the affected transactions:

    bea1c2b87fee95a203c5b5d9f3e5d0f472385c34cb5af02d0560aab973169683
    24b16a13c972522241b65fbb83d09d4bc02ceb33487f41d1f2f620b047307179
    53666009e036171b1aee099bc9cd3cb551969a53315410d13ad5390b8b4f3bd0
    ffc178be118bc2f9eaf016d1c942aec18441a6c5ec17c9d92d1da7962f0479f6
    2f1654561297114e434c4aea5ca715e4e3f10be0be8c1c9db2b6f68ea76dae09
    62fc8d091a7c597783981f00b889d72d24ad5e3e224dbe1c2a317aabef89217e
    d939315b180d3d73b5e316eb57a18f8137a3f5943aef21a811660d25f1080a3f
    8a6bfaa78828a81147e4848372d491aa4e9048631982a670ad3a61402a4ec327
    02cc78789cc070125817189ec378daa750355c8b22bbce982ed96aa549facb1f
    b97a16ae2e8ae2a804ed7965373b42055f811653f4628e4bef999145d4b593bc
    c51ffaf08188859669571f897f119b6d39ea48a9334212f554bf4927401b71f3
    324456fe9ec97a380effba0a0205a226e380790b93e7366d39f2a416a44d2a34
These transactions all used a large number of sigops, and obviously were made for testing purpose. However, they would have gone through if the tight estimation had been used.

Impact of the block-level consensus limit

With the block-level consensus limit of 500MB SigHashSize, transactions with SigHashSize above 500MB would also become invalid. Up to block 430368, 49 transactions would have become invalid with this limit (with either loose or tight estimation):

    Transaction ID                                                       SigHashSize
    9c667c64fcbb484b44dcce638f69130bbf1a4dd0fbb4423f58ceff92af4219ec	 2,215,084,200
    9fdbcf0ef9d8d00f66e47917f67cc5d78aec1ac786e2abb8d2facb4e4790aad6	 2,215,076,850
    5d8875ed1707cfee2221741b3144e575aec4e0d6412eeffe1e0fa07335f61311	 1,271,892,772
    cb550c9a1c63498f7ecb7bafc6f915318f16bb54069ff6257b4e069b97b367c8	 1,271,892,772
    14dd70e399f1d88efdb1c1ed799da731e3250d318bfdadc18073092aa7fd02c2	 1,271,892,772
    a684223716324923178a55737db81383c28f055b844d8196c988c70ee7075a9a	 1,271,892,772
    bb41a757f405890fb0f5856228e23b715702d714d59bf2b1feb70d8b2b4e3e08	 1,271,820,375
    5b0a05f12f33d2dc1507e5c18ceea6bb368afc51f00890965efcc3cb4025997d	 1,091,954,040
    bb75a8d10cfbe88bb6aba7b28be497ea83f41767f4ee26217e311c615ea0132f	 1,025,295,000
    5e640a7861695fa660343abde52cfe10b5a97dd8fc6ad3c5e4b2b4bb1c8c3dd9	 1,025,295,000
    dd49dc50b54b4bc1232e4b68cfdd3d349e49d3d7fe817d1041fff6dd583a6eaf	 1,025,230,000
    3d724f03e8bcc9e2e3ea79ebe4c6cffca86d85e510742cd6d3ac29d420787a34	 1,025,210,000
    8bcf8e8d8265922956bda9b651d2a0e993072c9dca306f3a132dcdb95c7cee6e	 1,025,210,000
    54bf51be42ff45cdf8217b07bb233466e18d23fd66483b12449cd9b99c3a0545       995,042,075
    6bb39576292c69016d0e0c1fe7871640aab12dd95874d67c46cf3424822f8dfd	   988,589,147
    d38417fcc27d3422fe05f76f6e658202d7fa394d0c9f5b419fef97610c3c49f1	   923,884,836
    66b614e736c884c1a064f7b0d6a9b0abd97e7bb73ac7e4b1b92b493d558a0711	   902,501,490
    d985c42bcd704aac88b9152aede1cca9bbb6baee55c8577f84c42d600cfec8e4	   898,372,800
    e32477636e47e1da5fb49090a3a87a3b8ff637d069a70cd5b41595da225e65b4	   893,548,487
    bf40393fedc45a1b347957124ef9bb8ae6a44feecee10ef2cc78064fabf8125f	   891,859,369
    1d93bfe18bc05b13169837b6bc868a92da3c87938531d6f3b58eee4b8822ecbf	   888,420,676
    79e30d460594694231f163dd79a69808904819e2f39bf3e31b7ddc4baa030a04	   877,542,875
    4eba5deb2bbf3abf067f524484763287911e8d68fb54fa09e1287cf6cd6d1276	   874,353,609
    c3f2c2df5388b79949c01d66e83d8bc3b9ccd4f85dbd91465a16fb8e21bf8e1b	   869,060,209
    446c0a1d563c93285e93f085192340a82c9aef7a543d41a86b65e215794845ef	   833,655,283
    e0c5e2dc3a39e733cf1bdb1a55bbcb3c2469f283becf2f99a0de771ec48f6278	   802,433,929
    2e7c454cfc348aa220f53b5ba21a55efa3d36353265f085e34053c4efa575fda	   789,067,716
    01d23d32bccc04b8ca5a934be16da08ae6a760ccaad2f62dc2f337eee7643517	   785,833,449
    9f8cc4496cff3216608c2f2177ab360bd2d4f58cae6490d5bc23312cf30e72e0	   775,457,104
    1e700d8ce85b17d713cad1a8cae932d26740e7c8ab09d2201ddfe9d1acb4706c	   757,230,231
    9db4e0838c55ef20c5eff271fc3bf09a404fff68f9cdad7df8eae732500b983d	   756,319,396
    763e13f873afa5f24cd33fc570a178c65e0a79c05c88c147335834fc9e8f837b	   734,988,489
    b8ba939da1babf863746175b59cbfb3b967354f04db41bd13cb11da58e43d2a8	   732,906,849
    f62f2c6a16b5da61eaae36d30d43bb8dd8932cd89b40d83623fa185b671c67f9	   723,659,859
    6e278c0ca05bf8e0317f991dae8a9efa141b5a310a4c18838b4e082e356ef649	   703,394,401
    e3de81a5817a3c825cf44fbf8185e15d446393615568966a6e3fc22cba609c7d	   697,632,336
    b5ca68205e6d55e87bd6163b28467da737227c6cbcc91cb9f6dc7b400163a12b	   665,208,049
    9c972a02db30f9ee91cc02b30733d70d4e2d759b5d3c73b240e5026a8a2640c4	   653,370,601
    02313ac62ca8f03930cdc5d2e437fabc05aea60a31ace18a39678c90b45d32bd	   622,323,625
    e245f6c3c6b02dc81ea1b6694735565cc535f603708783be027d0e6a94ac3bd5	   609,926,656
    1cf52f9ef89fa43bb4f042cbd4f80e9f090061e466cbe14c6b7ba525df0e572e	   607,214,327
    461308024d89ea4231911df4ef24e65e60af2a9204c8282a6b67f4214c1714e7	   606,137,296
    fa5a58f787f569f5b8fab9dadb2447161fac45b36fb6c2c0f548ed0209b60663	   589,853,184
    905df97982a2904d6d1b3dfc272435a24d705f4c7e1fc4052798b9904ad5e597	   546,737,250
    d85ce71f583095a76fb17b5bb2a1cbf369e2a2867ca38103aa310cbb2aaf2921	   546,737,250
    1b604a075075197c82d33555ea48ae27e3d2724bc4c3f31650eff79692971fb7	   531,511,200
    ba31c8833b7417fec9a84536f32fcb52d432acb66d99b9be6f3899686a269b2b	   531,511,200
    92f217ec13ab309240adc0798804b3418666344a5cbfff73fb7be8192dad5261	   509,443,536
    22e861ee83c3d23a4823a3786460119425d8183783068f7ec519646592fac8c2	   506,268,969
Extra consensus rules required by tight SigHashOp estimation

Transactions in the main network, up to block 430368, that would have been affected by the extra consensus rules are listed below:

Transactions with OP_CODESEPARATOR:

    eb3b82c0884e3efa6d8b0be55b4915eb20be124c9766245bcc7f34fdac32bccb
    055707ce7fea7b9776fdc70413f65ceec413d46344424ab01acd5138767db137
    6d36bc17e947ce00bb6f12f8e7a56a1585c5a36188ffa2b05e10b4743273a74b
    bc179baab547b7d7c1d5d8d6f8b0cc6318eaa4b0dd0a093ad6ac7f5a1cb6b3ba
    4d932e00d5e20e31211136651f1665309a11908e438bb4c30799154d26812491
    0157f2eec7bf856d66714856182a146998910dc6fa576bec200a9fa8039459e7
    ddd070541bf2fddaa5e08a9d93126f73211fe15291beb897c762908949420ad9
    d4a27d10404d87ee0b8a05fb700e55f9f83f80a59ebf87af2fbf87e5c9546177
    492cdb3c95c1fe0c597d8dc847adb5459d403ea083f4b5e706300d437c84748f
    b3e977a2c48145255d84e1c82d4ea07522528991d50ead1cf3a783559d9733e3
Transactions with non-zero FindAndDelete results:

    5df1375ffe61ac35ca178ebb0cab9ea26dedbd0e96005dfcee7e379fa513232f
    ded7ff51d89a4e1ec48162aee5a96447214d93dfb3837946af2301a28f65dbea
    307b173ef009b970c1a0dd67166a8ce3e91fc5551b8950d2d17f1fe0eaa07358
Transactions with abnormal nHashType:

    c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73
    0ad07700151caa994c0bc3087ad79821adf071978b34b8b3f0838582e45ef305
    7c451f68e15303ab3e28450405cfa70f2c2cc9fa29e92cb2d8ed6ca6edb13645
    a6c116351836d9cc223321ba4b38d68c8f0db53661f8c2229acabbc269c1b2c8
    f5efee46ccfa4191ccd9d9f645e2f5d09bbe195f95ef5608e992d6794cd653cd
    904bda3a7d3e3b8402793334a75fb1ce5a6ff5cf1c2d3bcbd7bd25872d0e8c1e
    8ac76995ce4ac10dd02aa819e7e6535854a2271e44f908570f71bc418ffe3f02
    e218970e8f810be99d60aa66262a1d382bc4b1a26a69af07ac47d622885db1a7
    ba4f9786bb34571bd147448ab3c303ae4228b9c22c89e58cc50e26ff7538bf80
    38df010716e13254fb5fc16065c1cf62ee2aeaed2fad79973f8a76ba91da36da
Reference Implementation

Policy only:

https://github.com/bitcoin/bitcoin/pull/8755 (Tight estimation)
https://github.com/bitcoin/bitcoin/pull/8756 (Loose estimation)
References

^ CVE-2013-2292
^ New Bitcoin vulnerability: A transaction that takes at least 3 minutes to verify
^ The Megatransaction: Why Does It Take 25 Seconds?
^ It should be noted that since sigops may exist in both scriptSig (non-standard and extremely rare) and scriptPubKey, in theory an input may have up to 6 SigHashOp
^ Not totally, since it does not count the sigops inside the scriptPubKey of the outputs being spent, while inappropriately counting sigops in scriptPubKey of the current transaction.
^ https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-November/006878.html
Copyright

This document is placed in the public domain.





