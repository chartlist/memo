From gsanders87 at gmail.com  Wed Mar  1 15:05:47 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Wed, 1 Mar 2023 10:05:47 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
Message-ID: <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>

Hello James,

First off, thank you for crafting an interesting idea like this that is
aimed at solving a serious problem. I see a lot of excitement about the use
cases, and I think it's worth iterating on.

Attempting to keep the idealized functionality constant, I'd like to
explore a design detour. I'm attempting to decouple the 3 functionalities
of `OP_VAULT` and `OP_UNVAULT` into their constituent functions with names
I just made up.

The goals of this e-mail:

1) Removing variable number of arguments based on values of arguments for
the opcodes.
To me as a spec reader, I find it very difficult to parse what's precisely
happening when. I think the only/last opcode to support this behavior was
OP_CHECKMULTISIG(could be wrong), and now I know another reason why OP_CSA
construct is nicer going forward with taproot.

2) Remove the recursive evaluation functionality used for authentication,
without reducing the efficacy of the targeted solution. Recursive
evaluation has a fraught history in Bitcoin script, makes composing
functionality with tooling likely more difficult, and has a lot of
templated behavior. If we can rely on regular old tapscript to get us where
we need to go, I'd prefer that.

3) Increase legibility of the spec. There's a ton going on, breaking things
up and naming them based on the method rather than the goal may help here.

4) Not (greatly) increase the expressiveness of the proposal. It's a
targeted proposal, and I'd like to respect that. These covenant opcodes are
intended to be drop-in replacements for the OP_(UN)VAULT opcodes.

To recap, there are three things happen in idealized OP_VAULT scenario:
1) Money comes out, then has to wait (trigger transaction)
2) Money waits long enough, then withdrawals to dynamic set of outputs that
are declared at trigger time (withdrawal transaction)
3) Money to single specified output script picked up front, with no wait
(recovery)

Below is a sketch of a replacement for the two opcodes. Ignore my
inconsistency on VERIFY/non-VERIFY behavior, seeing if people agree with
this general direction:

`OP_TRIGGER_FORWARD`: Takes exactly three arguments:
1) output index to match against (provided at spend time normally)
2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1)
(provided at spend time normally)
3) spend-delay: value to be forwarded to output given at (1)

Fails script immediately if there aren't enough inputs or they're the wrong
format.

These last two arguments are "forwarded" to output at index declared in
first argument, resulting in:

`EXPR_WITHDRAW: <spend-delay> OP_CHECKSEQUENCEVERIFY OP_DROP
<target-outputs-hash> OP_FORWARD_OUTPUTS`

As the derived tapscript, embedded in a output scriptpubkey of the form:
`tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control block
from the spending input, swap the inner pubkey for `NUMS`, use
`EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output
scriptpubkey doesnt match, fail.

This TLUV-ish script/inner pubkey replacement is meant to allow arbitrary
other conditions, which is where the "recovery" path comes in for typical
usage.

If output at the target output index doesn't match the constructed script,
the evaluation fails.

`OP_FORWARD_DESTINATION`: Takes exactly two arguments:
1) `dest-vout-idx`: index of output that contains the so-called "recovery"
path
2) <recovery sPK tagged hash (32 bytes)>: the hash of the script destination

Fails immediately if the reconstructed output script doesn't match.

`OP_FORWARD_OUTPUTS` takes exactly one argument:
1) target-outputs-hash: commits to all outputs' scripts and values

Fails immediately if transaction's outputs(including value) hash doesn't
match.

**Typical usage**:
```
DEPOSITING TO VAULT SCRIPT:

EXPR_RECOVERY:   <recovery> <auth> <stuff> <recovery sPK tagged hash (32
bytes)> OP_FORWARD_DESTINATION
EXPR_TRIGGER:     <trigger> <auth> <stuff> <spend-delay> OP_TRIGGER_FORWARD

tr(KEY, {EXPR_RECOVERY, EXPR_TRIGGER})
```

```
EXPR_WITHDRAW: <spend-delay> OP_CHECKSEQUENCEVERIFY OP_DROP
<target-outputs-hash> OP_FORWARD_OUTPUTS
```

```
TRIGGERING WITHDRAWAL TIMER SCRIPT:

tr(NUMS, {EXPR_RECOVERY,EXPR_WITHDRAW}) <--- note EXPR_RECOVERY is forced
by the OP_TRIGGER_FORWARD TLUV action
```

Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly
as an argument, or keep it more general as I did.

Would love to know what you and others think about this direction. I
apologies for any misunderstandings I have about the current OP_VAULT BIP!

Cheers,
Greg

On Mon, Feb 13, 2023 at 4:09?PM James O'Beirne via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Since the last related correspondence on this list [0], a number of
> improvements have been made to the OP_VAULT draft [1]:
>
> * There is no longer a hard dependence on package relay/ephemeral
>   anchors for fee management. When using "authorized recovery," all
>   vault-related transactions can be bundled with unrelated inputs and
>   outputs, facilitating fee management that is self contained to the
>   transaction. Consequently, the contents of this proposal are in theory
>   usable today.
>
> * Specific output locations are no longer hardcoded in any of the
>   transaction validation algorithms. This means that the proposal is now
>   compatible with future changes like SIGHASH_GROUP, and
>   transaction shapes for vault operations are more flexible.
>
> ---
>
> I've written a BIP that fully describes the proposal here:
>
>
> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki
>
> The corresponding PR is here:
>
>   https://github.com/bitcoin/bips/pull/1421
>
> My next steps will be to try for a merge to the inquisition repo.
>
> Thanks to everyone who has participated so far, but especially to AJ and
> Greg for all the advice.
>
> James
>
> [0]:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
> [1]: https://github.com/bitcoin/bitcoin/pull/26857
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230301/067e5b0d/attachment.html>

From dave at dtrt.org  Wed Mar  1 17:17:58 2023
From: dave at dtrt.org (David A. Harding)
Date: Wed, 01 Mar 2023 07:17:58 -1000
Subject: [bitcoin-dev] BIP proposal: Fee-redistribution contracts
In-Reply-To: <CACVgDWbZKzmq+j0Hu-k5fW3J+ni-nasq74Ad+a0mkZJE_mPwSQ@mail.gmail.com>
References: <CACVgDWbZKzmq+j0Hu-k5fW3J+ni-nasq74Ad+a0mkZJE_mPwSQ@mail.gmail.com>
Message-ID: <ce27590b79ab63b632428cdf582335b0@dtrt.org>

On 2023-02-27 03:32, Rastislav Budinsky via bitcoin-dev wrote:
> When a miner mines a block he takes all the fees currently. However
> with the proposed solution he takes only fraction M and remaining
> fraction C is sent to one of more contracts. One contract at its
> simplest collects fees from the miner and at the same time
> redistributes it back to the miner.

Hi Rastislav,

I think you've incorrectly made the assumption that the only way a miner 
can profit from confirming a transaction is by collecting its 
transaction fees.  Miners can (and many have) accept payment through 
alternative means, which the Bitcoin technical community often calls 
"out-of-band fees".[1]  For example, some miners have provided a 
"transaction accelerator" service that accepts fiat-denominated credit 
cards to increase their prioritization of certain transactions and I'm 
personally aware of a large web wallet provider that would occasionally 
pay miners out of band to confirm hundreds or thousands of transactions 
rather than fix its broken fee estimation.

Out-of-band fees aren't frequently used in Bitcoin today because they 
have no advantage over correctly estimated in-band fees, and good fee 
estimation is very accessible to modern wallets.  However, if the 
consensus rules are changed to require each miner pay a percentage of 
its in-band fees to future miners, then there would be a strong 
incentive for them to prefer out-of-band fees that weren't subject to 
this redistribution scheme.

I think may have seen a variation on the scheme you propose play out in 
real life.  Here's how it works where I live: the government imposes 
taxes on goods, services, and income.  Ostensibly, it redistributes the 
collected funds back to citizens in the future by providing government 
services.  When I go to pay someone who trusts my discretion, they often 
offer me a discounted rate if I pay in a way that isn't reported to the 
government (e.g., I pay with cash); even with the discount provided to 
me, they get to keep more of their income than if they had reported the 
transaction to the government.

In the case of a government, tax evasion can be reduced by the 
deployment of investigators and enforcers.  In Bitcoin, we have no 
control over activity that happens outside of the protocol and so even a 
modest incentive to pay fees out of band might quickly lead to almost 
all fees being paid out of band.  This prevents the effective 
redistribution of fees as in your proposal.  Additionally, previous 
discussions on this mailing list about paying out-of-band fees have 
highlighted that larger miners have an advantage over smaller miners in 
collecting miner-specific fee payments, undermining the essential 
decentralization of Bitcoin's transaction confirmation mechanism (moreso 
than it is already weakened by fundamental economies of scale in 
mining).

In short, I think serious consideration of your proposal can only 
proceed if it adequately addresses the problem of out-of-band fees.

That said, thank you and your co-authors for putting serious thought 
into Bitcoin's long-term economic incentives.

-Dave

[1] https://bitcoinsearch.xyz/?q=out%20of%20band%20fees&size=n_50_n

From beppeben2030 at gmail.com  Wed Mar  1 20:18:22 2023
From: beppeben2030 at gmail.com (Giuseppe B)
Date: Wed, 1 Mar 2023 21:18:22 +0100
Subject: [bitcoin-dev] Minimum fees
Message-ID: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>

Hello everyone,

I'm relatively new here so what I'm proposing could have already been
discussed, or may be flawed or inapplicable. I apologize for that.

I was picturing a situation where block rewards are almost zero, and the
base layer is mainly used as a settlement layer for relatively few large
transactions, since the majority of smaller ones goes through LN.

In such a case it may very well be that even if transaction amounts are
very consistent, transaction fees end up being very small since there is
enough space for everyone in a block. Users wouldn't mind paying higher
fees as they know that that would increase the network security, however
nobody wants to be the only one doing that. Miners would of course like
being paid more. So everyone involved would prefer higher fees but they
just stay low because that's the only rational individual choice.

Therefore I was imagining the introduction of a new protocol rule,
min_fees, that would work like this:
- the miner that gets to mine a block appends a min_fee field to the block,
specifying the minimum fees that need to be contained in the following
block in order for it to be valid.
- one can also mine an empty block and reset the min_fee, to avoid the
chain getting stuck.

min_fees could either represent the total fees of the following block, or
the minimal fee for each single transaction, as a percentage of the value
transacted. Both seem to have some merits and some potential drawbacks. Of
course min_fees=0 would correspond to the current situation.

It looks to me that this could have the potential to bring the equilibrium
closer to a socially optimal one (as opposed to individually optimal), and
to benefit the network security in the long term. Of course it's just a
rough sketch and it would deserve a much deeper analysis. I was just
interested in knowing if you think that the principle has some merit or if
it's not even worth discussing it for some reason that I'm not considering.

Cheers,

Giuseppe.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230301/0e1bca3d/attachment-0001.html>

From nadav at shesek.info  Thu Mar  2 00:39:13 2023
From: nadav at shesek.info (Nadav Ivgi)
Date: Thu, 2 Mar 2023 02:39:13 +0200
Subject: [bitcoin-dev] Minimum fees
In-Reply-To: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
References: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
Message-ID: <CAGXD5f2zQcS6rCEraNG9_h5E-9ZhFVf3iK_0Mbq7cdn6o6C1jA@mail.gmail.com>

Hi Giuseppe,

One side-effect this has is that until enough fees accumulate in the
mempool to satisfy min_fees, the rational behaviour for miners would be to
try and fork the chain tip, competing for the fees in the latest block
(+whatever got into the mempool in the meanwhile and can fit in). This
could lead to increased reorgs/orphan rates and chain instability. It could
also lead to miners preferring to set their low_fee to zero, to avoid other
miners from forking their blocks off.

I'm also not sure that this would actually change much. If humanity is
willing to spend X BTC/day on mining fees, it doesn't really matter if it's
spread out through fewer or more blocks.

shesek

On Wed, Mar 1, 2023 at 10:25 PM Giuseppe B via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> I'm relatively new here so what I'm proposing could have already been
> discussed, or may be flawed or inapplicable. I apologize for that.
>
> I was picturing a situation where block rewards are almost zero, and the
> base layer is mainly used as a settlement layer for relatively few large
> transactions, since the majority of smaller ones goes through LN.
>
> In such a case it may very well be that even if transaction amounts are
> very consistent, transaction fees end up being very small since there is
> enough space for everyone in a block. Users wouldn't mind paying higher
> fees as they know that that would increase the network security, however
> nobody wants to be the only one doing that. Miners would of course like
> being paid more. So everyone involved would prefer higher fees but they
> just stay low because that's the only rational individual choice.
>
> Therefore I was imagining the introduction of a new protocol rule,
> min_fees, that would work like this:
> - the miner that gets to mine a block appends a min_fee field to the
> block, specifying the minimum fees that need to be contained in the
> following block in order for it to be valid.
> - one can also mine an empty block and reset the min_fee, to avoid the
> chain getting stuck.
>
> min_fees could either represent the total fees of the following block, or
> the minimal fee for each single transaction, as a percentage of the value
> transacted. Both seem to have some merits and some potential drawbacks. Of
> course min_fees=0 would correspond to the current situation.
>
> It looks to me that this could have the potential to bring the equilibrium
> closer to a socially optimal one (as opposed to individually optimal), and
> to benefit the network security in the long term. Of course it's just a
> rough sketch and it would deserve a much deeper analysis. I was just
> interested in knowing if you think that the principle has some merit or if
> it's not even worth discussing it for some reason that I'm not considering.
>
> Cheers,
>
> Giuseppe.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/72a05fa8/attachment.html>

From aj at erisian.com.au  Thu Mar  2 04:46:25 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Thu, 2 Mar 2023 14:46:25 +1000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
Message-ID: <ZAAqIZZO1KK32Th9@erisian.com.au>

On Wed, Mar 01, 2023 at 10:05:47AM -0500, Greg Sanders via bitcoin-dev wrote:
> Below is a sketch of a replacement for the two opcodes. 

I like this! I tried to come up with something along similar lines for
similar reasons, but I think I tried too hard to reduce it to two opcodes
or something and got myself confused.

> `OP_TRIGGER_FORWARD`: Takes exactly three arguments:
> 1) output index to match against (provided at spend time normally)
> 2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1)
> (provided at spend time normally)
> 3) spend-delay: value to be forwarded to output given at (1)

I think you could generalise this as follows:

   idx .. npush script OP_FORWARD_LEAF_UPDATE

(OP_FLU :) with the behaviour being:

   pop script from the stack
   pop npush from the stack (error if non-minimal or <0)
   pop npush entries from the stack,
     prefix script with a minimal push of that entry
   pop idx off the stack (error if idx is not a valid output)
   calculate the spk corresponding to taking the current
     input's spk and replacing the current leaf with the
     given script
   check the output at idx matches this spk, and the
     value from this input accumulates to that output

Then instead of `idx hash delay OP_TRIGGER_FORWARD` you
write `idx hash delay 2 "OP_CSV OP_DROP OP_FORWARD_OUTPUTS"
OP_FORWARD_LEAF_UPDATE`

That's an additional 5 witness bytes, but a much more generic/composable
opcode.

Being able to prefix a script with push opcodes avoids the possibility
of being able to add OP_SUCCESS instructions, so I think this is a fairly
safe way of allowing a TLUV-ish script to be modified, especially compared
to OP_CAT.

I do recognise that it makes it take a variable number of stack elements
though :)

> As the derived tapscript, embedded in a output scriptpubkey of the form:
> `tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control block
> from the spending input, swap the inner pubkey for `NUMS`, use
> `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output
> scriptpubkey doesnt match, fail.

I don't think replacing the internal-public-key makes sense -- if it
was immediately spendable via the keypath before there's no reason for
it not to be immediately spendable now.

> Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly
> as an argument, or keep it more general as I did.

Having OP_FORWARD_OUTPUTS not leave its input on the stack would let
you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.

> Would love to know what you and others think about this direction. I
> apologies for any misunderstandings I have about the current OP_VAULT BIP!

I think the existing OP_VAULT cleverness would work here, allowing you
to spend two inputs to the same output, accumulating their values.

I don't think it quite gives you a way to "refund" values though -- so
that you can take a vault with 3 BTC, start the <delay> wait to spend
1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on
something else, without the 0.8 BTC effectively having a doubled delay.

I think you could fix that with something as simple as an additional
"idx OP_FORWARD_REFUND" opcode, though -- then the restriction is just
that the output at the refund idx has the same sPK as this input, and
the total value of this input is accumulated amongst all the outputs
specified by OP_FORWARD opcodes. (Maybe you need to specify the refund
amount explicitly as well, to keep verification easy)

That would make maybe three new opcodes to cover the "accumulate value
from one or more inputs into specified outputs":

 - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk
 - OP_FORWARD_DESTINATION --> forward input value to given spk
 - OP_FORWARD_REFUND --> forward part of input value to same spk

along with OP_CTV:

 - OP_FORWARD_OUTPUTS --> pay to specific outputs

OP_VAULT's "accumulate value" behaviour here makes the OP_IN_OUT_AMOUNT
things from TLUV more implicit and automatic, which is nice. I think
doing TLUV payment pools wouldn't require much more than the ability to
combine OP_FLU and OP_FDEST in a single script, explicitly specifying
how much value is extracted via OP_FDEST with the rest assigned to OP_FLU.

Cheers,
aj

From calvin at kcalvinalvin.info  Thu Mar  2 06:55:19 2023
From: calvin at kcalvinalvin.info (kcalvinalvin)
Date: Thu, 02 Mar 2023 06:55:19 +0000
Subject: [bitcoin-dev] Using service bit 24 for utreexo signaling in testnet
	and signet
Message-ID: <vymiNsSrjFPbfpdd3z6BMnIqqJ2cC_3J224jD7Rv_7I7bPt0HHufyisjCe67tSGBiluouQoj5wuNVKA12KSmC3pS9Q6NjBSH4OmUbI8U7wQ=@kcalvinalvin.info>

Hello all,

Wanted to tell the mailing list that I'll be using service bit 24 (1 << 24) to signal that nodes are Utreexo capable nodes on testnet and signet as requested by the comment in protocol.h in bitcoind (https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.h#L295-L301). There are plans to release binaries for the utreexo node (github.com/utreexo/utreexod) in the next few months so that power users can try it out. I have no plans to release binaries for mainnet yet.

Do let me know if someone else is using the same bit to signal for something else and we can coordinate accordingly.

Best,
Calvin
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/7f4218b1/attachment.html>

From gsanders87 at gmail.com  Thu Mar  2 14:54:31 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 2 Mar 2023 09:54:31 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <ZAAqIZZO1KK32Th9@erisian.com.au>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
Message-ID: <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>

Greetings AJ,

Glad I could resurrect the idea!

> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you
write `idx hash delay 2 "OP_CSV OP_DROP OP_FORWARD_OUTPUTS"
OP_FORWARD_LEAF_UPDATE`

Interesting idea! (I'll let you be the one to scope creep the proposal :) )

To be pedantic, EXPR_TRIGGER would become:

<trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP
OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE

and at spend time the idx and hash are put into the witness stack.

To be clear, <spend-delay> could be embedded in the <script> too, right,
making <2> a <1> in the above? Any reason for one or the other?

Another bonus from this is that you can introduce withdrawal authorization
as well as part of the <script>. Current proposal has no withdrawal
authorization, from what I understand. So each transition in a vault
construct can have authorization, if it desires it.

> I do recognise that it makes it take a variable number of stack elements
though :)

Just when I thought I was out, they pulled me back in.

> I don't think replacing the internal-public-key makes sense -- if it
was immediately spendable via the keypath before there's no reason for
it not to be immediately spendable now.

Slavishly following the current proposal was the idea to make sure all
functionality was captured; I agree with this change.

> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let
you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.

Previously setting CSV timeout to 0 would result in it not being
satisfiable, if I'm understanding the suggestion correctly. I suppose this
was a side-effect of having OP_UNVAULT take this value directly. Indeed
with `OP_FORWARD_OUTPUTS` being split out there's not really a reason to
use a 0 value?

> I think the existing OP_VAULT cleverness would work here, allowing you
to spend two inputs to the same output, accumulating their values.

Yes I think batching story should be same hopefully. I am assuming all the
accounting OP_VAULT is doing is being done here. We match against the hash
passed in, and fits into the "deferred checks" IIUC.

> OP_FORWARD_REFUND

Again, to be pedantic EXPR_TRIGGER becomes:

<trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP
OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE OP_FORWARD_REFUND

Resulting in 2 more WU at spend time(for small idx). So *up front*
committing to a refund path, perhaps with value explicitly passed in.

Totally forgot about the refund path; will need to mull the issue over, see
how it interacts with BYOF schemes, etc.

Cheers,
Greg


On Wed, Mar 1, 2023 at 11:46?PM Anthony Towns <aj at erisian.com.au> wrote:

> On Wed, Mar 01, 2023 at 10:05:47AM -0500, Greg Sanders via bitcoin-dev
> wrote:
> > Below is a sketch of a replacement for the two opcodes.
>
> I like this! I tried to come up with something along similar lines for
> similar reasons, but I think I tried too hard to reduce it to two opcodes
> or something and got myself confused.
>
> > `OP_TRIGGER_FORWARD`: Takes exactly three arguments:
> > 1) output index to match against (provided at spend time normally)
> > 2) target-outputs-hash: 32 byte hash to be forwarded to output given at
> (1)
> > (provided at spend time normally)
> > 3) spend-delay: value to be forwarded to output given at (1)
>
> I think you could generalise this as follows:
>
>    idx .. npush script OP_FORWARD_LEAF_UPDATE
>
> (OP_FLU :) with the behaviour being:
>
>    pop script from the stack
>    pop npush from the stack (error if non-minimal or <0)
>    pop npush entries from the stack,
>      prefix script with a minimal push of that entry
>    pop idx off the stack (error if idx is not a valid output)
>    calculate the spk corresponding to taking the current
>      input's spk and replacing the current leaf with the
>      given script
>    check the output at idx matches this spk, and the
>      value from this input accumulates to that output
>
> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you
> write `idx hash delay 2 "OP_CSV OP_DROP OP_FORWARD_OUTPUTS"
> OP_FORWARD_LEAF_UPDATE`
>
> That's an additional 5 witness bytes, but a much more generic/composable
> opcode.
>
> Being able to prefix a script with push opcodes avoids the possibility
> of being able to add OP_SUCCESS instructions, so I think this is a fairly
> safe way of allowing a TLUV-ish script to be modified, especially compared
> to OP_CAT.
>
> I do recognise that it makes it take a variable number of stack elements
> though :)
>
> > As the derived tapscript, embedded in a output scriptpubkey of the form:
> > `tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control
> block
> > from the spending input, swap the inner pubkey for `NUMS`, use
> > `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the
> output
> > scriptpubkey doesnt match, fail.
>
> I don't think replacing the internal-public-key makes sense -- if it
> was immediately spendable via the keypath before there's no reason for
> it not to be immediately spendable now.
>
> > Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly
> > as an argument, or keep it more general as I did.
>
> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let
> you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.
>
> > Would love to know what you and others think about this direction. I
> > apologies for any misunderstandings I have about the current OP_VAULT
> BIP!
>
> I think the existing OP_VAULT cleverness would work here, allowing you
> to spend two inputs to the same output, accumulating their values.
>
> I don't think it quite gives you a way to "refund" values though -- so
> that you can take a vault with 3 BTC, start the <delay> wait to spend
> 1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on
> something else, without the 0.8 BTC effectively having a doubled delay.
>
> I think you could fix that with something as simple as an additional
> "idx OP_FORWARD_REFUND" opcode, though -- then the restriction is just
> that the output at the refund idx has the same sPK as this input, and
> the total value of this input is accumulated amongst all the outputs
> specified by OP_FORWARD opcodes. (Maybe you need to specify the refund
> amount explicitly as well, to keep verification easy)
>
> That would make maybe three new opcodes to cover the "accumulate value
> from one or more inputs into specified outputs":
>
>  - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk
>  - OP_FORWARD_DESTINATION --> forward input value to given spk
>  - OP_FORWARD_REFUND --> forward part of input value to same spk
>
> along with OP_CTV:
>
>  - OP_FORWARD_OUTPUTS --> pay to specific outputs
>
> OP_VAULT's "accumulate value" behaviour here makes the OP_IN_OUT_AMOUNT
> things from TLUV more implicit and automatic, which is nice. I think
> doing TLUV payment pools wouldn't require much more than the ability to
> combine OP_FLU and OP_FDEST in a single script, explicitly specifying
> how much value is extracted via OP_FDEST with the rest assigned to OP_FLU.
>
> Cheers,
> aj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/59e4f0f8/attachment.html>

From luke at dashjr.org  Thu Mar  2 18:20:35 2023
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 2 Mar 2023 13:20:35 -0500
Subject: [bitcoin-dev] Using service bit 24 for utreexo signaling in
 testnet and signet
In-Reply-To: <vymiNsSrjFPbfpdd3z6BMnIqqJ2cC_3J224jD7Rv_7I7bPt0HHufyisjCe67tSGBiluouQoj5wuNVKA12KSmC3pS9Q6NjBSH4OmUbI8U7wQ=@kcalvinalvin.info>
References: <vymiNsSrjFPbfpdd3z6BMnIqqJ2cC_3J224jD7Rv_7I7bPt0HHufyisjCe67tSGBiluouQoj5wuNVKA12KSmC3pS9Q6NjBSH4OmUbI8U7wQ=@kcalvinalvin.info>
Message-ID: <a9357869-2eb0-0e7d-f0c4-536404930e48@dashjr.org>

This sounds like something that should be written up as a BIP and use a 
normal service bit assignment...?

Luke


On 3/2/23 01:55, kcalvinalvin via bitcoin-dev wrote:
> Hello all,
>
> Wanted to tell the mailing list that I'll be using service bit 24 (1 
> << 24) to signal that nodes are Utreexo capable nodes on testnet and 
> signet as requested by the comment in protocol.h?in 
> bitcoind?(https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.h#L295-L301). 
> There are plans to release binaries for the utreexo node 
> (github.com/utreexo/utreexod)?in the next few months so that power 
> users can try it out.?I have no?plans to release binaries for mainnet 
> yet.
>
> Do let me know if someone else is using the same bit to signal for 
> something else and we can coordinate accordingly.
>
> Best,
> Calvin
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From amo.personal at protonmail.com  Thu Mar  2 19:51:17 2023
From: amo.personal at protonmail.com (Andrew Melnychuk Oseen)
Date: Thu, 02 Mar 2023 19:51:17 +0000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
Message-ID: <DL1xeVsB-q2KSJwQTDjU757F-sxDwGc81j4n3gu8U2zVNpuberuNI_i4EMCJHSifQhS9RoYI6OrBEeXa8KRIuDHUPS0DRIXzj8KnnfRzeos=@protonmail.com>

I read the draft and this seems to have some functionality that I am looking for. I'm pretty new to bitcoin-dev, but I'm persistent and have a lot of time on my hands.

I would like multiple tapleaves be restricted on the amount that they can spend.
Say an input of 1 BTC, has a locking script of a tapscript that has 1 of 3 pubkeys of Alice, Bob and Carol(participants). I want to restrict the outputs of their next transactions to .2, .3 and .5 BTC respectively.

In the event of Bob spending their output, they are restricted to make a transaction that has a change output that has at least Alice and Carol's Amount, and a 1 or 2 tapscript or a 1 of 3 tapscript if Bob didn't spend all of their funds.

In the event of two of the three participants separately broadcast their transactions, I'm hoping that the second sender, can combine the two transactions into a package where the outputs and witnesses would be adjusted where two participants share an output with their respective amounts, and the remainder participant still has their funds available.

Is this clear? I don't have a lot of experience communicating complex ideas in writing. I've been looking at some BIP's like OP_CHECKTEMPLATEVERIFY as well which had some idea's I really liked like OP_AMOUNTVERIFY. I'm not aware of the risks that the community previously discussed about the topic.

Andrew

Sent with [Proton Mail](https://proton.me/) secure email.

------- Original Message -------
On Thursday, March 2nd, 2023 at 6:54 AM, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Greetings AJ,
>
> Glad I could resurrect the idea!
>
>> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you
> write `idx hash delay 2 "OP_CSV OP_DROP OP_FORWARD_OUTPUTS"
> OP_FORWARD_LEAF_UPDATE`
>
> Interesting idea! (I'll let you be the one to scope creep the proposal :) )
>
> To be pedantic, EXPR_TRIGGER would become:
>
> <trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE
>
> and at spend time the idx and hash are put into the witness stack.
>
> To be clear, <spend-delay> could be embedded in the <script> too, right, making <2> a <1> in the above? Any reason for one or the other?
>
> Another bonus from this is that you can introduce withdrawal authorization as well as part of the <script>. Current proposal has no withdrawal authorization, from what I understand. So each transition in a vault construct can have authorization, if it desires it.
>
>> I do recognise that it makes it take a variable number of stack elements
> though :)
>
> Just when I thought I was out, they pulled me back in.
>
>> I don't think replacing the internal-public-key makes sense -- if it
> was immediately spendable via the keypath before there's no reason for
> it not to be immediately spendable now.
>
> Slavishly following the current proposal was the idea to make sure all functionality was captured; I agree with this change.
>
>> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let
> you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.
>
> Previously setting CSV timeout to 0 would result in it not being satisfiable, if I'm understanding the suggestion correctly. I suppose this was a side-effect of having OP_UNVAULT take this value directly. Indeed with `OP_FORWARD_OUTPUTS` being split out there's not really a reason to use a 0 value?
>
>> I think the existing OP_VAULT cleverness would work here, allowing you
> to spend two inputs to the same output, accumulating their values.
>
> Yes I think batching story should be same hopefully. I am assuming all the accounting OP_VAULT is doing is being done here. We match against the hash passed in, and fits into the "deferred checks" IIUC.
>
>> OP_FORWARD_REFUND
>
> Again, to be pedantic EXPR_TRIGGER becomes:
>
> <trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE OP_FORWARD_REFUND
>
> Resulting in 2 more WU at spend time(for small idx). So up front committing to a refund path, perhaps with value explicitly passed in.
>
> Totally forgot about the refund path; will need to mull the issue over, see how it interacts with BYOF schemes, etc.
>
> Cheers,
> Greg
>
> On Wed, Mar 1, 2023 at 11:46?PM Anthony Towns <aj at erisian.com.au> wrote:
>
>> On Wed, Mar 01, 2023 at 10:05:47AM -0500, Greg Sanders via bitcoin-dev wrote:
>>> Below is a sketch of a replacement for the two opcodes.
>>
>> I like this! I tried to come up with something along similar lines for
>> similar reasons, but I think I tried too hard to reduce it to two opcodes
>> or something and got myself confused.
>>
>>> `OP_TRIGGER_FORWARD`: Takes exactly three arguments:
>>> 1) output index to match against (provided at spend time normally)
>>> 2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1)
>>> (provided at spend time normally)
>>> 3) spend-delay: value to be forwarded to output given at (1)
>>
>> I think you could generalise this as follows:
>>
>> idx .. npush script OP_FORWARD_LEAF_UPDATE
>>
>> (OP_FLU :) with the behaviour being:
>>
>> pop script from the stack
>> pop npush from the stack (error if non-minimal or <0)
>> pop npush entries from the stack,
>> prefix script with a minimal push of that entry
>> pop idx off the stack (error if idx is not a valid output)
>> calculate the spk corresponding to taking the current
>> input's spk and replacing the current leaf with the
>> given script
>> check the output at idx matches this spk, and the
>> value from this input accumulates to that output
>>
>> Then instead of `idx hash delay OP_TRIGGER_FORWARD` you
>> write `idx hash delay 2 "OP_CSV OP_DROP OP_FORWARD_OUTPUTS"
>> OP_FORWARD_LEAF_UPDATE`
>>
>> That's an additional 5 witness bytes, but a much more generic/composable
>> opcode.
>>
>> Being able to prefix a script with push opcodes avoids the possibility
>> of being able to add OP_SUCCESS instructions, so I think this is a fairly
>> safe way of allowing a TLUV-ish script to be modified, especially compared
>> to OP_CAT.
>>
>> I do recognise that it makes it take a variable number of stack elements
>> though :)
>>
>>> As the derived tapscript, embedded in a output scriptpubkey of the form:
>>> `tr(NUMS,{...,EXPR_WITHDRAW})`, meaning we literally take the control block
>>> from the spending input, swap the inner pubkey for `NUMS`, use
>>> `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output
>>> scriptpubkey doesnt match, fail.
>>
>> I don't think replacing the internal-public-key makes sense -- if it
>> was immediately spendable via the keypath before there's no reason for
>> it not to be immediately spendable now.
>>
>>> Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly
>>> as an argument, or keep it more general as I did.
>>
>> Having OP_FORWARD_OUTPUTS not leave its input on the stack would let
>> you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU.
>>
>>> Would love to know what you and others think about this direction. I
>>> apologies for any misunderstandings I have about the current OP_VAULT BIP!
>>
>> I think the existing OP_VAULT cleverness would work here, allowing you
>> to spend two inputs to the same output, accumulating their values.
>>
>> I don't think it quite gives you a way to "refund" values though -- so
>> that you can take a vault with 3 BTC, start the <delay> wait to spend
>> 1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on
>> something else, without the 0.8 BTC effectively having a doubled delay.
>>
>> I think you could fix that with something as simple as an additional
>> "idx OP_FORWARD_REFUND" opcode, though -- then the restriction is just
>> that the output at the refund idx has the same sPK as this input, and
>> the total value of this input is accumulated amongst all the outputs
>> specified by OP_FORWARD opcodes. (Maybe you need to specify the refund
>> amount explicitly as well, to keep verification easy)
>>
>> That would make maybe three new opcodes to cover the "accumulate value
>> from one or more inputs into specified outputs":
>>
>> - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk
>> - OP_FORWARD_DESTINATION --> forward input value to given spk
>> - OP_FORWARD_REFUND --> forward part of input value to same spk
>>
>> along with OP_CTV:
>>
>> - OP_FORWARD_OUTPUTS --> pay to specific outputs
>>
>> OP_VAULT's "accumulate value" behaviour here makes the OP_IN_OUT_AMOUNT
>> things from TLUV more implicit and automatic, which is nice. I think
>> doing TLUV payment pools wouldn't require much more than the ability to
>> combine OP_FLU and OP_FDEST in a single script, explicitly specifying
>> how much value is extracted via OP_FDEST with the rest assigned to OP_FLU.
>>
>> Cheers,
>> aj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/738f7390/attachment-0001.html>

From pete at petertodd.org  Thu Mar  2 21:05:26 2023
From: pete at petertodd.org (Peter Todd)
Date: Thu, 02 Mar 2023 21:05:26 +0000
Subject: [bitcoin-dev] Using service bit 24 for utreexo signaling in
	testnet and signet
In-Reply-To: <a9357869-2eb0-0e7d-f0c4-536404930e48@dashjr.org>
References: <vymiNsSrjFPbfpdd3z6BMnIqqJ2cC_3J224jD7Rv_7I7bPt0HHufyisjCe67tSGBiluouQoj5wuNVKA12KSmC3pS9Q6NjBSH4OmUbI8U7wQ=@kcalvinalvin.info>
 <a9357869-2eb0-0e7d-f0c4-536404930e48@dashjr.org>
Message-ID: <121124D0-060B-4093-98A4-7D96E7A41E8D@petertodd.org>



On March 2, 2023 6:20:35 PM GMT, Luke Dashjr via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>This sounds like something that should be written up as a BIP and use a normal service bit assignment...?

The purpose of the experimental service bits is experiments. If the details of utreexo aren't nailed down and may change, an experimental service bit makes sense.

Bit 24 is fine and AFAIK unused at the moment; full-rbf is using bit 26: https://github.com/petertodd/bitcoin/commit/c15b8d70778238abfa751e4216a97140be6369af#diff-8e2ffc8fe0e0847a6aac311a93b2faeebd2d76ddb2c81741bb8cf7448287807eR297

>Luke
>
>
>On 3/2/23 01:55, kcalvinalvin via bitcoin-dev wrote:
>> Hello all,
>> 
>> Wanted to tell the mailing list that I'll be using service bit 24 (1 << 24) to signal that nodes are Utreexo capable nodes on testnet and signet as requested by the comment in protocol.h?in bitcoind?(https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.h#L295-L301). There are plans to release binaries for the utreexo node (github.com/utreexo/utreexod)?in the next few months so that power users can try it out.?I have no?plans to release binaries for mainnet yet.
>> 
>> Do let me know if someone else is using the same bit to signal for something else and we can coordinate accordingly.
>> 
>> Best,
>> Calvin
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From jk_14 at op.pl  Thu Mar  2 22:27:40 2023
From: jk_14 at op.pl (jk_14 at op.pl)
Date: Thu, 02 Mar 2023 23:27:40 +0100
Subject: [bitcoin-dev] Minimum fees
Message-ID: <178815707-0d716bbc84bb687bd2bf6f87ab557532@pmq3v.m5r2.onet>



> to bring the equilibrium

The important thing to highlight is that's not equilibrium between active users and miners.
This needed in the future equilibrium is between:

Active Users (transactional tax) vs Passive Users (i.e. stakeholders: inflation tax)

And miners will only earn as much as these two parties above will pay in "taxes".

> to benefit the network security in the long?term

The solution to benefit the network security in the long term should be simple enough to understand by Average Joe, in my opinion.

Delay of halving in case of network global hashrate regression - is simple enough mechanism that cannot be played.
(more here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021362.html )

Summarizing:

1. There are two parties in Bitcoin with opposite interests from network security point of view: passive stakeholders and active users.
2. There is (still) no mechanism of achieving equilibrium regarding costs of network security between these two parties.
3a. A system in which all users participate in ensuring its long-term security - is honest.
3b. A system in which only active of them participate, and passive stakeholders are de facto long-term dishonest free riders - is not honest.

Every statement above is unfortunately true.
There are only two serious issues in Bitcoin in fact: weak long-term security budget and quantum threat.
According to IBM roadmap regarding quantum computing - they may have 4k qubit system starting from 2025.

If quantum emergency fork (only several years ahead!) will require not soft, but hard version
- that's the one and only chance for fixing simultaneously this serious flaw of Bitcoin design, in simplest and most conservative way.
And we need to talk about it now - to be mentally prepared :)


Best Regards
Jaroslaw







W dniu 2023-03-01 21:25:08 u?ytkownik Giuseppe B via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> napisa?:
Hello everyone,


I'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that.


I was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN.


In such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice.


Therefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this:?
- the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid.
- one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck.


min_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation.


It looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long?term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth?discussing it for some reason that?I'm?not considering.


Cheers,


Giuseppe.




From alicexbt at protonmail.com  Fri Mar  3 01:44:03 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Fri, 03 Mar 2023 01:44:03 +0000
Subject: [bitcoin-dev] BIP: Trust minimized swaps using PSBT,
	SINGLE|ANYONECANPAY and nostr
Message-ID: <QubGl0eXGrvufb_878QU6FKQdIQ7T4t0kgs7KNraNBFKSAqF2z2gEET67pJFb3fTwOH8vx8iqBFuhNGZIzfAMS_SQIiRziqxJ6M_B0_mKuM=@protonmail.com>

Hi Bitcoin Developers,

I have written a BIP that describes the process to swap inscriptions however there can be other use cases for it as well: https://gist.github.com/1440000bytes/a7deeb3f1740bc533a61fbcc1fe58d77

Feel free to share your opinion or feedback to improve the usage of PSBTs in swaps.

    BIP: 2023-ordswap
    Layer: Applications
    Title: Trust minimized swaps using PSBTs
    Author: /dev/fd0
    Status: Draft
    Created: 2023-03-02
    License: Public Domain
  
  
### Introduction

This BIP describes a process for creating offers using PSBTs to swap inscriptions. It was originally shared by [Casey](https://github.com/casey/ord/issues/802). There are two other approaches (`joinpsbts` and coinswap) to swap inscriptions however they degrade the UX and use of SINGLE|ANYONECANPAY works better.

### Specification

[SINGLE|ANYONECANPAY](https://en.bitcoin.it/wiki/Contract#SIGHASH_flags) is used for creating a PSBT by the seller. It is signed and published as offer. Buyer updates the PSBT with appropriate inputs and outputs. Order of inputs and outputs in the PSBT is very important as wrong ordering can burn inscriptions. [Ordinal theory](https://docs.ordinals.com/faq.html?#how-does-ordinal-theory-work) uses an algorithm to determine how satoshis hop from the inputs of a transaction to its outputs.

### Protocol

Sequence diagram:

```mermaid
sequenceDiagram
    Note right of Seller: Create and Sign PSBT
    Seller->>+Nostr relays: Publish offer
    Buyer->>+Nostr relays: Accept offer
    Note left of Buyer: Add inputs, outputs, sign and broadcast PSBT
```

Seller:

- Create PSBT with inscription UTXO input and a new address with sell amount as output
- Sign PSBT
- Publish PSBT as defined in [NIP](https://github.com/orenyomtov/openordex/blob/main/NIP.md)

Buyer:

- Add new address as output in PSBT to receive inscription
- Create [dummy UTXO](https://i.imgur.com/8Rw3TFX.png) if not available in wallet (Less than 1000 sats)
- Add UTXO to pay seller and dummy UTXO as inputs in PSBT
- Sign and broadcast transaction. 

Example tx: https://mempool.space/signet/tx/ee7032f08ed18113c16ab8759d294c09f57492d8d255b5dbd16326df53bbdcac

This transaction has 3 inputs (dummy, inscription, UTXO used for paying seller) and 4 outputs (inscription, payment, new dummy for future, change)

Note: Openordex creates a dummy UTXO and reuses address if there is no dummy UTXO found for the address entered by buyer. Example: https://mempool.space/signet/tx/388942887f79358a1deba3aae86e97b982a923566b2ef2249eab42288efc5abf

Pseudocode or Implementation (2 functions used by openordex for creating PSBTs)

```js
	
async function generatePSBTListingInscriptionForSale(ordinalOutput, price, paymentAddress) {
    let psbt = new bitcoin.Psbt({ network });

    const [ordinalUtxoTxId, ordinalUtxoVout] = ordinalOutput.split(':')
    const tx = bitcoin.Transaction.fromHex(await getTxHexById(ordinalUtxoTxId))
    for (const output in tx.outs) {
        try { tx.setWitness(output, []) } catch { }
    }

    psbt.addInput({
        hash: ordinalUtxoTxId,
        index: parseInt(ordinalUtxoVout),
        nonWitnessUtxo: tx.toBuffer(),
        // witnessUtxo: tx.outs[ordinalUtxoVout],
        sighashType: bitcoin.Transaction.SIGHASH_SINGLE | bitcoin.Transaction.SIGHASH_ANYONECANPAY,
    });

    psbt.addOutput({
        address: paymentAddress,
        value: price,
    });

    return psbt.toBase64();
}

```

```js

    generatePSBTBuyingInscription = async (payerAddress, receiverAddress, price, paymentUtxos, dummyUtxo) => {
        const psbt = new bitcoin.Psbt({ network });
        let totalValue = 0
        let totalPaymentValue = 0

        // Add dummy utxo input
        const tx = bitcoin.Transaction.fromHex(await getTxHexById(dummyUtxo.txid))
        for (const output in tx.outs) {
            try { tx.setWitness(output, []) } catch { }
        }
        psbt.addInput({
            hash: dummyUtxo.txid,
            index: dummyUtxo.vout,
            nonWitnessUtxo: tx.toBuffer(),
            // witnessUtxo: tx.outs[dummyUtxo.vout],
        });

        // Add inscription output
        psbt.addOutput({
            address: receiverAddress,
            value: dummyUtxo.value + Number(inscription['output value']),
        });

        // Add payer signed input
        psbt.addInput({
            ...sellerSignedPsbt.data.globalMap.unsignedTx.tx.ins[0],
            ...sellerSignedPsbt.data.inputs[0]
        })
        // Add payer output
        psbt.addOutput({
            ...sellerSignedPsbt.data.globalMap.unsignedTx.tx.outs[0],
        })

        // Add payment utxo inputs
        for (const utxo of paymentUtxos) {
            const tx = bitcoin.Transaction.fromHex(await getTxHexById(utxo.txid))
            for (const output in tx.outs) {
                try { tx.setWitness(output, []) } catch { }
            }

            psbt.addInput({
                hash: utxo.txid,
                index: utxo.vout,
                nonWitnessUtxo: tx.toBuffer(),
                // witnessUtxo: tx.outs[utxo.vout],
            });

            totalValue += utxo.value
            totalPaymentValue += utxo.value
        }

        // Create a new dummy utxo output for the next purchase
        psbt.addOutput({
            address: payerAddress,
            value: dummyUtxoValue,
        })

        const fee = calculateFee(psbt.txInputs.length, psbt.txOutputs.length, await recommendedFeeRate)

        const changeValue = totalValue - dummyUtxo.value - price - fee

        if (changeValue < 0) {
            throw `Your wallet address doesn't have enough funds to buy this inscription.
Price:          ${satToBtc(price)} BTC
Fees:       ${satToBtc(fee + dummyUtxoValue)} BTC
You have:   ${satToBtc(totalPaymentValue)} BTC
Required:   ${satToBtc(totalValue - changeValue)} BTC
Missing:     ${satToBtc(-changeValue)} BTC`
        }

        // Change utxo
        psbt.addOutput({
            address: payerAddress,
            value: changeValue,
        });

        return psbt.toBase64();
    }
	
```

Note: Openordex reuses address for change, however this can be avoided.

### Acknowledgements

- Casey Rodarmor
- Oren Yomtov
- Rijndael

/dev/fd0
floppy disk guy


Sent with Proton Mail secure email.

From beppeben2030 at gmail.com  Fri Mar  3 05:07:29 2023
From: beppeben2030 at gmail.com (Giuseppe B)
Date: Fri, 3 Mar 2023 06:07:29 +0100
Subject: [bitcoin-dev] Minimum fees
In-Reply-To: <CAGXD5f2zQcS6rCEraNG9_h5E-9ZhFVf3iK_0Mbq7cdn6o6C1jA@mail.gmail.com>
References: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
 <CAGXD5f2zQcS6rCEraNG9_h5E-9ZhFVf3iK_0Mbq7cdn6o6C1jA@mail.gmail.com>
Message-ID: <CABrXkXrM-DG4RrqPnMMJTt4UD73hRso5exGMf-vxT2gx0VFpgQ@mail.gmail.com>

Hi shesek,

Minimum fees may not be the right mechanism. However I disagree with the
general idea that "if it's optimal for society to do X then they'll do X".
There's plenty of examples where people fail to coordinate in the absence
of a suitable framework, see the "free rider" problem with public goods or
even the simple prisoner's dilemma.

On Thu, Mar 2, 2023, 1:39 AM Nadav Ivgi <nadav at shesek.info> wrote:

> Hi Giuseppe,
>
> One side-effect this has is that until enough fees accumulate in the
> mempool to satisfy min_fees, the rational behaviour for miners would be to
> try and fork the chain tip, competing for the fees in the latest block
> (+whatever got into the mempool in the meanwhile and can fit in). This
> could lead to increased reorgs/orphan rates and chain instability. It could
> also lead to miners preferring to set their low_fee to zero, to avoid other
> miners from forking their blocks off.
>
> I'm also not sure that this would actually change much. If humanity is
> willing to spend X BTC/day on mining fees, it doesn't really matter if it's
> spread out through fewer or more blocks.
>
> shesek
>
> On Wed, Mar 1, 2023 at 10:25 PM Giuseppe B via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Hello everyone,
>>
>> I'm relatively new here so what I'm proposing could have already been
>> discussed, or may be flawed or inapplicable. I apologize for that.
>>
>> I was picturing a situation where block rewards are almost zero, and the
>> base layer is mainly used as a settlement layer for relatively few large
>> transactions, since the majority of smaller ones goes through LN.
>>
>> In such a case it may very well be that even if transaction amounts are
>> very consistent, transaction fees end up being very small since there is
>> enough space for everyone in a block. Users wouldn't mind paying higher
>> fees as they know that that would increase the network security, however
>> nobody wants to be the only one doing that. Miners would of course like
>> being paid more. So everyone involved would prefer higher fees but they
>> just stay low because that's the only rational individual choice.
>>
>> Therefore I was imagining the introduction of a new protocol rule,
>> min_fees, that would work like this:
>> - the miner that gets to mine a block appends a min_fee field to the
>> block, specifying the minimum fees that need to be contained in the
>> following block in order for it to be valid.
>> - one can also mine an empty block and reset the min_fee, to avoid the
>> chain getting stuck.
>>
>> min_fees could either represent the total fees of the following block, or
>> the minimal fee for each single transaction, as a percentage of the value
>> transacted. Both seem to have some merits and some potential drawbacks. Of
>> course min_fees=0 would correspond to the current situation.
>>
>> It looks to me that this could have the potential to bring the
>> equilibrium closer to a socially optimal one (as opposed to individually
>> optimal), and to benefit the network security in the long term. Of course
>> it's just a rough sketch and it would deserve a much deeper analysis. I was
>> just interested in knowing if you think that the principle has some merit
>> or if it's not even worth discussing it for some reason that I'm not
>> considering.
>>
>> Cheers,
>>
>> Giuseppe.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230303/e25eabe3/attachment-0001.html>

From beppeben2030 at gmail.com  Fri Mar  3 05:19:44 2023
From: beppeben2030 at gmail.com (Giuseppe B)
Date: Fri, 3 Mar 2023 06:19:44 +0100
Subject: [bitcoin-dev] Minimum fees
In-Reply-To: <CAJ12oL1UmUJjRhircdxWH7znSCH5bmnqsgabUS74Ns4EU_VLzA@mail.gmail.com>
References: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
 <CAJ12oL1UmUJjRhircdxWH7znSCH5bmnqsgabUS74Ns4EU_VLzA@mail.gmail.com>
Message-ID: <CABrXkXo+j3e9fRS_3MPWVYk83WRJVnC2bv1OSBaY-Dek5W8y0g@mail.gmail.com>

This will indeed give some power to the miners. But they have no incentives
in posting super high numbers as that means they won't get paid or they
will with a lot of delay.
This is not simply like setting the price for a product that has a fixed
quality. In the case of the mining services, setting the price also means
setting the quality of the product you offer (as higher price = higher
security). This is simply a way to let miners have have a say about the
quality of the product that they offer. They can always set 0 min fees and
settle for the lowest quality/ low price service, or maybe find out that
offering a better product for a higher price actually makes them more
money.



On Fri, Mar 3, 2023, 3:45 AM WMOURA <neo.m.revolutions at gmail.com> wrote:

> Hello,
>
> In my amateur opinion, I imagine that this would give excessive power to the miner, introducing a bug in the system, because if the miner put an absurdly high minimum rate intentionally or not, this would cause a serious problem, or not.
>
>
> Em qua., 1 de mar. de 2023 ?s 17:25, Giuseppe B via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> escreveu:
>
>> Hello everyone,
>>
>> I'm relatively new here so what I'm proposing could have already been
>> discussed, or may be flawed or inapplicable. I apologize for that.
>>
>> I was picturing a situation where block rewards are almost zero, and the
>> base layer is mainly used as a settlement layer for relatively few large
>> transactions, since the majority of smaller ones goes through LN.
>>
>> In such a case it may very well be that even if transaction amounts are
>> very consistent, transaction fees end up being very small since there is
>> enough space for everyone in a block. Users wouldn't mind paying higher
>> fees as they know that that would increase the network security, however
>> nobody wants to be the only one doing that. Miners would of course like
>> being paid more. So everyone involved would prefer higher fees but they
>> just stay low because that's the only rational individual choice.
>>
>> Therefore I was imagining the introduction of a new protocol rule,
>> min_fees, that would work like this:
>> - the miner that gets to mine a block appends a min_fee field to the
>> block, specifying the minimum fees that need to be contained in the
>> following block in order for it to be valid.
>> - one can also mine an empty block and reset the min_fee, to avoid the
>> chain getting stuck.
>>
>> min_fees could either represent the total fees of the following block, or
>> the minimal fee for each single transaction, as a percentage of the value
>> transacted. Both seem to have some merits and some potential drawbacks. Of
>> course min_fees=0 would correspond to the current situation.
>>
>> It looks to me that this could have the potential to bring the
>> equilibrium closer to a socially optimal one (as opposed to individually
>> optimal), and to benefit the network security in the long term. Of course
>> it's just a rough sketch and it would deserve a much deeper analysis. I was
>> just interested in knowing if you think that the principle has some merit
>> or if it's not even worth discussing it for some reason that I'm not
>> considering.
>>
>> Cheers,
>>
>> Giuseppe.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230303/62aece2e/attachment-0001.html>

From neo.m.revolutions at gmail.com  Fri Mar  3 02:45:02 2023
From: neo.m.revolutions at gmail.com (WMOURA)
Date: Thu, 2 Mar 2023 23:45:02 -0300
Subject: [bitcoin-dev] Minimum fees
In-Reply-To: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
References: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
Message-ID: <CAJ12oL1UmUJjRhircdxWH7znSCH5bmnqsgabUS74Ns4EU_VLzA@mail.gmail.com>

Hello,

In my amateur opinion, I imagine that this would give excessive power
to the miner, introducing a bug in the system, because if the miner
put an absurdly high minimum rate intentionally or not, this would
cause a serious problem, or not.


Em qua., 1 de mar. de 2023 ?s 17:25, Giuseppe B via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> escreveu:

> Hello everyone,
>
> I'm relatively new here so what I'm proposing could have already been
> discussed, or may be flawed or inapplicable. I apologize for that.
>
> I was picturing a situation where block rewards are almost zero, and the
> base layer is mainly used as a settlement layer for relatively few large
> transactions, since the majority of smaller ones goes through LN.
>
> In such a case it may very well be that even if transaction amounts are
> very consistent, transaction fees end up being very small since there is
> enough space for everyone in a block. Users wouldn't mind paying higher
> fees as they know that that would increase the network security, however
> nobody wants to be the only one doing that. Miners would of course like
> being paid more. So everyone involved would prefer higher fees but they
> just stay low because that's the only rational individual choice.
>
> Therefore I was imagining the introduction of a new protocol rule,
> min_fees, that would work like this:
> - the miner that gets to mine a block appends a min_fee field to the
> block, specifying the minimum fees that need to be contained in the
> following block in order for it to be valid.
> - one can also mine an empty block and reset the min_fee, to avoid the
> chain getting stuck.
>
> min_fees could either represent the total fees of the following block, or
> the minimal fee for each single transaction, as a percentage of the value
> transacted. Both seem to have some merits and some potential drawbacks. Of
> course min_fees=0 would correspond to the current situation.
>
> It looks to me that this could have the potential to bring the equilibrium
> closer to a socially optimal one (as opposed to individually optimal), and
> to benefit the network security in the long term. Of course it's just a
> rough sketch and it would deserve a much deeper analysis. I was just
> interested in knowing if you think that the principle has some merit or if
> it's not even worth discussing it for some reason that I'm not considering.
>
> Cheers,
>
> Giuseppe.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230302/64195ad5/attachment.html>

From amo.personal at protonmail.com  Sat Mar  4 06:21:44 2023
From: amo.personal at protonmail.com (Andrew Melnychuk Oseen)
Date: Sat, 04 Mar 2023 06:21:44 +0000
Subject: [bitcoin-dev] Minimum fees
In-Reply-To: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
References: <CABrXkXoq4x9aRuk0ZnfPmqE-TXZfROMuAMTwCO9VCcTnJ+snNA@mail.gmail.com>
Message-ID: <LwVUuu83ndd7MUq-j3Rn-WFJgyLMHUtMnBw4GZY6zgryOcJ_ieZG7HQefZ003xltOrngAOMnG03fAWt3yeqdFcaV-5dN3er2CigtAQKmAMA=@protonmail.com>

From my limited knowledge in the space, and I've taken opinions of people I respect that are far more knowledgeable than me.

I don't know of any data of what happens at the point where the coinbase drops to below the fees on any chain. I don't think there has been one where that has happened. Perhaps there is a chain out there where it is fee's only? Perhaps that can provide insight.

Opinion: I think as bitcoin's capabilities grow, demand for it will as well. There are a lot of efforts to increase the amount of transactions that can fit into a block. I think the combination of limited block space and a reduced amount of bitcoin's entering the market is the right combination for the system to self sustain. I'm looking forward to seeing the result!

Sent with [Proton Mail](https://proton.me/) secure email.

------- Original Message -------
On Wednesday, March 1st, 2023 at 12:18 PM, Giuseppe B via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello everyone,
>
> I'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that.
>
> I was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN.
>
> In such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice.
>
> Therefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this:
> - the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid.
> - one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck.
>
> min_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation.
>
> It looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth discussing it for some reason that I'm not considering.
>
> Cheers,
>
> Giuseppe.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230304/6a34ff0c/attachment.html>

From james.obeirne at gmail.com  Mon Mar  6 15:25:38 2023
From: james.obeirne at gmail.com (James O'Beirne)
Date: Mon, 6 Mar 2023 10:25:38 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
Message-ID: <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>

I'm glad to see that Greg and AJ are forming a habit of hammering
this proposal into shape. Nice work fellas.

To summarize:

What Greg is proposing above is to in essence TLUV-ify this proposal.

I.e. instead of relying on hashed commitments and recursive script
execution (e.g. <trigger-sPK-hash> + later presentation of preimage
script for execution), OP_VAULT would instead move through its
withdrawal process by swapping out tapleaf contents according to
specialized rules. If this is opaque (as it was to me), don't fret -
I'll describe it below in the "mechanics" section.


The benefits of this TLUVification are

- we can avoid any nested/recursive script execution. I know the
  recursive stuff rankles some greybeards even in spite of it being
  bounded to a single call. I'm not sure I share the concern but
  maintaining the status quo seems good.

- the spec is easier to reason about, more or less. The opcodes
  introduced don't have variadic witness requirements, and each opcode
  is only consumed in a single way.

- there's less general indirection. Instead of saying "okay, here's the
  hash of the script I'm going to use to authorize trigger
  transactions," we're just outright including the trigger auth script
  in the tapleaf at the birth of the vault as regular 'ol script that is
  evaluated before execution of the OP_VAULT instruction.

  Similarly, instead of relying on an implicit rule that an OP_VAULT can
  be claimed by a recovery flow, we're relying on a specific tapleaf that
  facilitates that recovery with OP_VAULT_RECOVER, described below.

Basically, OP_VAULT would just be implemented in a way that feels
more native to Taproot primitives.

Greg also introduces different opcodes to facilitate consistent
witness structure, rather than the variable ones we have now
since OP_VAULT and OP_UNVAULT can each be spent in two different
contexts. I've changed those a little here; instead of the three general
ones Greg gave, we whittled it down to two: OP_VAULT and
OP_VAULT_RECOVER.


So I think that, barring significant implementation complexity - which
I'll find out about soon and don't expect - this is a good change to the
proposal. As Greg noted, it doesn't really change anything about the
usage or expressiveness... other than the fact that, as a bonus, it
might allow an optional withdrawal authorization script (i.e. trigger
output => final target), which could be useful if e.g. some kind of
size-limiting opcode (e.g. OP_TX_MAXSIZE or something) came around in
the future as a kind of pinning fix.

If that last bit lost you, don't worry - that is speculative, but the
point is that this rework composes well with other stuff.


# CTV use

Another thing that has dawned on us is that we might as well just reuse
OP_CHECKTEMPLATEVERIFY for withdrawal target spends. Ben Carmen and
others realized early on that you can synthesize CTV-like behavior by
spending to a 0-delay OP_UNVAULT output, so something CTVish has always
implicitly been a part of the proposal. But CTV is better studied and
basically as simple as the OP_UNVAULT spend semantics, so the thought is
that we might as well reuse all the existing work (and scrutiny) from
CTV.

As a concrete example, an issue with the existing proposal is that the
existing CTVish OP_UNVAULT behavior has txid malleability, since it
doesn't commit to nVersion or nLockTime or the input sequences. Using
CTV solves this issue. Otherwise we'd basically reinvent it - "something
something convergent evolution."

I think this is a satisfying development, because there's clearly demand
for CTV use in other contexts (DLC efficiency, e.g.), and if it's
required behavior for practical vaults, I think pulling in the existing
BIP-119 that's been worked over for years reduces the conceptual
surface area added by OP_VAULT.


# New mechanics of the proposal

So here I'm going to describe my rendering of Greg and AJ's suggestions.


## Required opcodes

- OP_VAULT: spent to trigger withdrawal
- OP_VAULT_RECOVER: spent to recover
- OP_CHECKTEMPLATEVERIFY: spent into final withdrawal target


Creating an initial deposit
---------------------------

For each vault, vaulted coins are spent to an output with the taproot
structure

  taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})

where

  internal_key =
    unchanged from original proposal (some very safe recovery key)

  $recovery_leaf =
    [<opt.> <recovery> <auth>] <recovery sPK hash> OP_VAULT_RECOVER

  $trigger_leaf =
    <trigger> <auth> <script> <spend-delay> OP_VAULT

  ... =
    other (optional) leaves in the taptree


Triggering a withdrawal request
-------------------------------

To trigger the start of the withdrawal process, an output of the above
form is spent with a witness that contains

  - Taproot control block pointing to $trigger_leaf.
  - <trigger-vout-idx>, indicating the trigger output which must abide
    by the rules given below.


## Output structure

  taproot(internal_key, {$recovery_leaf, $expr_withdraw, ...})

where

  $recovery_leaf is preserved exactly
  $expr_withdraw =
    <spend-delay> OP_CSV OP_DROP <target-ctv-hash> OP_CTV
  ... is preserved exactly


(Spoiler: note here that the only thing that is changing is
s/expr_trigger/expr_withdrawl/ from the initial vault ouput.)

Of course $expr_withdraw *could* be prefixed by an optional "withdrawal
authorization" script, if some sensible use for that is found.

The validation rules are essentially unchanged from the existing
proposal:

- The total amount of all OP_VAULT inputs with matching $recovery_leaf
  values must be reflected in output <trigger-vout-idx>

- <trigger-vout-idx> must correspond to an output that is identical to
  the input taptree but with the spent tapleaf (OP_VAULT) swapped out
  for the timelocked CTV constructed using <target-ctv-hash> and
  <spend-delay> as extracted from the spent tapleaf
  - internal_key is preserved
  - the whole rest of the taptree is preserved
  - (this is what ensures the parameters of the vault are forwarded)

All batching, fee management characteristics are the same.


Finalizing withdrawal
---------------------

Happens via script-path spend to $expr_withdraw, i.e. a timelocked
OP_CTV.


Recovery
--------

Can happen from any of the above outputs using the $recovery_leaf
script path in a way very similar to the existing OP_VAULT proposal.


---

To reiterate, all aspects of the existing OP_VAULT proposal are either
preserved or improved upon in terms of malleability reduction,
composability, and flexibility. So big thanks to AJ and Greg.

I'll undertake implementing these changes in the coming days to verify
that they are, as expected, workable.

James
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230306/0762c458/attachment.html>

From gsanders87 at gmail.com  Mon Mar  6 16:07:38 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 6 Mar 2023 11:07:38 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
Message-ID: <CAB3F3DvXon1tawj6tdLiHY-kkDSXn5P7yn3Wjwz6Z=UZYXxLTQ@mail.gmail.com>

Hi James,

I think everything except the hinted "withdrawal authorization" is spot on.

For withdrawal authorization, I think we'll have to go deeper into the TLUV
direction
as AJ suggested for at least a couple reasons:

1) You need the withdrawal authorization committed at deposit time
2) You need to make sure cheeky opcodes cannot be prepended to the script
at spend time

OP_FORWARD_LEAF_UPDATE(OP_FLU) seems to fit the bill, at the cost of maybe
adding another opcode for "refunds" as he notes.

Cheers,
Greg

On Mon, Mar 6, 2023 at 10:25?AM James O'Beirne <james.obeirne at gmail.com>
wrote:

> I'm glad to see that Greg and AJ are forming a habit of hammering
> this proposal into shape. Nice work fellas.
>
> To summarize:
>
> What Greg is proposing above is to in essence TLUV-ify this proposal.
>
> I.e. instead of relying on hashed commitments and recursive script
> execution (e.g. <trigger-sPK-hash> + later presentation of preimage
> script for execution), OP_VAULT would instead move through its
> withdrawal process by swapping out tapleaf contents according to
> specialized rules. If this is opaque (as it was to me), don't fret -
> I'll describe it below in the "mechanics" section.
>
>
> The benefits of this TLUVification are
>
> - we can avoid any nested/recursive script execution. I know the
>   recursive stuff rankles some greybeards even in spite of it being
>   bounded to a single call. I'm not sure I share the concern but
>   maintaining the status quo seems good.
>
> - the spec is easier to reason about, more or less. The opcodes
>   introduced don't have variadic witness requirements, and each opcode
>   is only consumed in a single way.
>
> - there's less general indirection. Instead of saying "okay, here's the
>   hash of the script I'm going to use to authorize trigger
>   transactions," we're just outright including the trigger auth script
>   in the tapleaf at the birth of the vault as regular 'ol script that is
>   evaluated before execution of the OP_VAULT instruction.
>
>   Similarly, instead of relying on an implicit rule that an OP_VAULT can
>   be claimed by a recovery flow, we're relying on a specific tapleaf that
>   facilitates that recovery with OP_VAULT_RECOVER, described below.
>
> Basically, OP_VAULT would just be implemented in a way that feels
> more native to Taproot primitives.
>
> Greg also introduces different opcodes to facilitate consistent
> witness structure, rather than the variable ones we have now
> since OP_VAULT and OP_UNVAULT can each be spent in two different
> contexts. I've changed those a little here; instead of the three general
> ones Greg gave, we whittled it down to two: OP_VAULT and
> OP_VAULT_RECOVER.
>
>
> So I think that, barring significant implementation complexity - which
> I'll find out about soon and don't expect - this is a good change to the
> proposal. As Greg noted, it doesn't really change anything about the
> usage or expressiveness... other than the fact that, as a bonus, it
> might allow an optional withdrawal authorization script (i.e. trigger
> output => final target), which could be useful if e.g. some kind of
> size-limiting opcode (e.g. OP_TX_MAXSIZE or something) came around in
> the future as a kind of pinning fix.
>
> If that last bit lost you, don't worry - that is speculative, but the
> point is that this rework composes well with other stuff.
>
>
> # CTV use
>
> Another thing that has dawned on us is that we might as well just reuse
> OP_CHECKTEMPLATEVERIFY for withdrawal target spends. Ben Carmen and
> others realized early on that you can synthesize CTV-like behavior by
> spending to a 0-delay OP_UNVAULT output, so something CTVish has always
> implicitly been a part of the proposal. But CTV is better studied and
> basically as simple as the OP_UNVAULT spend semantics, so the thought is
> that we might as well reuse all the existing work (and scrutiny) from
> CTV.
>
> As a concrete example, an issue with the existing proposal is that the
> existing CTVish OP_UNVAULT behavior has txid malleability, since it
> doesn't commit to nVersion or nLockTime or the input sequences. Using
> CTV solves this issue. Otherwise we'd basically reinvent it - "something
> something convergent evolution."
>
> I think this is a satisfying development, because there's clearly demand
> for CTV use in other contexts (DLC efficiency, e.g.), and if it's
> required behavior for practical vaults, I think pulling in the existing
> BIP-119 that's been worked over for years reduces the conceptual
> surface area added by OP_VAULT.
>
>
> # New mechanics of the proposal
>
> So here I'm going to describe my rendering of Greg and AJ's suggestions.
>
>
> ## Required opcodes
>
> - OP_VAULT: spent to trigger withdrawal
> - OP_VAULT_RECOVER: spent to recover
> - OP_CHECKTEMPLATEVERIFY: spent into final withdrawal target
>
>
> Creating an initial deposit
> ---------------------------
>
> For each vault, vaulted coins are spent to an output with the taproot
> structure
>
>   taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})
>
> where
>
>   internal_key =
>     unchanged from original proposal (some very safe recovery key)
>
>   $recovery_leaf =
>     [<opt.> <recovery> <auth>] <recovery sPK hash> OP_VAULT_RECOVER
>
>   $trigger_leaf =
>     <trigger> <auth> <script> <spend-delay> OP_VAULT
>
>   ... =
>     other (optional) leaves in the taptree
>
>
> Triggering a withdrawal request
> -------------------------------
>
> To trigger the start of the withdrawal process, an output of the above
> form is spent with a witness that contains
>
>   - Taproot control block pointing to $trigger_leaf.
>   - <trigger-vout-idx>, indicating the trigger output which must abide
>     by the rules given below.
>
>
> ## Output structure
>
>   taproot(internal_key, {$recovery_leaf, $expr_withdraw, ...})
>
> where
>
>   $recovery_leaf is preserved exactly
>   $expr_withdraw =
>     <spend-delay> OP_CSV OP_DROP <target-ctv-hash> OP_CTV
>   ... is preserved exactly
>
>
> (Spoiler: note here that the only thing that is changing is
> s/expr_trigger/expr_withdrawl/ from the initial vault ouput.)
>
> Of course $expr_withdraw *could* be prefixed by an optional "withdrawal
> authorization" script, if some sensible use for that is found.
>
> The validation rules are essentially unchanged from the existing
> proposal:
>
> - The total amount of all OP_VAULT inputs with matching $recovery_leaf
>   values must be reflected in output <trigger-vout-idx>
>
> - <trigger-vout-idx> must correspond to an output that is identical to
>   the input taptree but with the spent tapleaf (OP_VAULT) swapped out
>   for the timelocked CTV constructed using <target-ctv-hash> and
>   <spend-delay> as extracted from the spent tapleaf
>   - internal_key is preserved
>   - the whole rest of the taptree is preserved
>   - (this is what ensures the parameters of the vault are forwarded)
>
> All batching, fee management characteristics are the same.
>
>
> Finalizing withdrawal
> ---------------------
>
> Happens via script-path spend to $expr_withdraw, i.e. a timelocked
> OP_CTV.
>
>
> Recovery
> --------
>
> Can happen from any of the above outputs using the $recovery_leaf
> script path in a way very similar to the existing OP_VAULT proposal.
>
>
> ---
>
> To reiterate, all aspects of the existing OP_VAULT proposal are either
> preserved or improved upon in terms of malleability reduction,
> composability, and flexibility. So big thanks to AJ and Greg.
>
> I'll undertake implementing these changes in the coming days to verify
> that they are, as expected, workable.
>
> James
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230306/3e92a245/attachment-0001.html>

From aj at erisian.com.au  Tue Mar  7 12:45:34 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 7 Mar 2023 22:45:34 +1000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
Message-ID: <ZAcx7oEZxC9BiWvg@erisian.com.au>

On Mon, Mar 06, 2023 at 10:25:38AM -0500, James O'Beirne via bitcoin-dev wrote:
> What Greg is proposing above is to in essence TLUV-ify this proposal.

FWIW, the way I'm thinking about this is that the "OP_VAULT" concept is
introducing two things:

 a) the concept of "forwarding" the input amount to specified
    outputs in a way that elegantly allows merging/splitting

 b) various restrictions on the form of the output scripts

These concepts go together well, because restricting an output script is
only an interesting thing to do if you're moving value from this input
into it. And then it's just a matter of figuring out a nice way to pick
opcodes that combine those two concepts in interesting ways.

This is different from TLUV, in that TLUV only did part (b), and
assumed you'd do part (a) manually somehow, eg via "OP_IN_OUT_AMOUNT"
and arithmetic opcodes. The advantage of this new approach over that
one is that it makes it really easy to get the logic right (I often
forgot to include the IN_OUT_AMOUNT checks at all, for instance), and
also makes spending multiple inputs to a single output really simple,
something that would otherwise require kind-of gnarly logic.

I think there are perhaps four opcodes that are interesting in this class:

   idx sPK OP_FORWARD_TARGET
     -- sends the value to a particular output (given by idx), and
        requires that output have a particular scriptPubKey (given
        by sPK).

   idx [...] n script OP_FORWARD_LEAF_UPDATE
     -- sends the value to a particular output (given by idx), and
	requires that output to have almost the same scriptPubKey as this
	input, _except_ that the current leaf is replaced by "script",
	with that script prefixed by "n" pushes (of values given by [...])

   idx OP_FORWARD_SELF
     -- sends the value to a particular output (given by idx), and
        requires that output to have the same scriptPubKey as this input

   amt OP_FORWARD_PARTIAL
     -- modifies the next OP_FORWARD_* opcode to only affect "amt",
        rather than the entire balance. opcodes after that affect the
	remaining balance, after "amt" has been subtracted. if "amt" is
	0, the next OP_FORWARD_* becomes a no-op.

Then each time you see OP_FORWARD_TARGET or OP_FORWARD_LEAF_UPDATE, you
accumulate the value that's expected to be forwarded to the output by
each input, and verify that the amount for that output is greater-or-equal
to the accumulated value.

> ## Required opcodes
> - OP_VAULT: spent to trigger withdrawal
> - OP_VAULT_RECOVER: spent to recover

Naming here is OP_VAULT ~= OP_FORWARD_LEAF_UPDATE; OP_VAULT_RECOVER ~=
OP_FORWARD_TARGET.

> For each vault, vaulted coins are spent to an output with the taproot
> structure
> 
>   taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})
> 
> where
> 
>   $trigger_leaf =
>     <trigger> <auth> <script> <spend-delay> OP_VAULT

With the opcodes above, the trigger_leaf (for spending some of the
vaulted funds via your hot wallet) script might look like:

   OP_FORWARD_PARTIAL OP_FORWARD_SELF
   1 "288 OP_CSV OP_DROP OP_CTV" OP_FORWARD_LEAF_UPDATE
   key CHECKSIG

So if you have 2.0 BTC in a vault utxo, you might spend 0.4 BTC by
supplying the witness data:

  160000000  (1.6BTC in sats)
  0 (output 0 puts 1.6BTC goes back into the vault)
  <ctvhash> (the outputs where you want the remaining 0.4 BTC to end up)
  1 (the output idx that will be spend via the CTV path once the CSV
     delay is done)
  <sig> (a signature of this transaction via the hot wallet "key")

That is, the script becomes:

  160000000 FORWARD_PARTIAL
  0 FORWARD_SELF
  1 <ctvhash> 1 "288 CSV DROP CTV" FORWARD_LEAF_UPDATE
  sig key CHECKSIG

Output 1 would then have a tapscript of "<ctvhash> 288 OP_CSV OP_DROP
OP_CTV", satisfied with an empty witness stack (along with the recovery
path, etc).

Output 0 is just 1.6BTC back in your vault, and immediately available 
for use.

Other inputs/outputs (for fees etc) would still be committed to by <sig>,
so nothing here is malleable. The script here is about 45 bytes (compared
to 34 for a simple "key CHECKSIG") and the witness data is about 105 bytes
(compared to 65 bytes for just a signature), which seems pretty nice.

>   ... =
>     other (optional) leaves in the taptree

This would allow you to have multiple hot wallets (if any of them are
compromised you can still use the recovery path to avoid loss of funds;
but if some hot wallet becomes temporarily *inaccessible* you can still
easily spend the funds via one of the alternative hot wallets), or,
if you have multiple watchtowers validating your spends and recovering
funds to your cold wallet on a violation, you could have multiple recovery
paths to provide some auditability for who triggered the recovery.

> Happens via script-path spend to $expr_withdraw, i.e. a timelocked
> OP_CTV.

Note that if you calculated the OP_CTV incorrectly (eg, you don't set a
correct nSequence timelock, so that any tx that passes OP_CTV won't pass
the OP_CSV check, and vice-versa) then this spend path becomes invalid,
and the funds can only be reclaimed via some other path (key path spend,
recovery tapscript, potentially an alternative hotwallet script path).

OP_FORWARD_LEAF_UPDATE is equivalent to a very specific form of TLUV,
namely "FALSE <h> 2 TLUV", where "<h>" is calculated by building the
script, prefixing the pushes, then doing the Hash_TapLeaf calculation.

Not being able to tweak the internal public key ("FALSE" rather than
"<x>") means this can't be used to build a coinpool with unilateral
exit -- you can't remove your key from the key path, which screws over
everyone who's still in the coinpool.

On the other hand, not tweaking the internal public key avoids introducing
all the x-only pubkey complications, and keeps it relatively simple,
which is nice, and keeping things simple and targeted now means there's
still plenty of OP_SUCCESS opcodes available later for something more
general, if that turns out to be desirable.

Cheers,
aj

From vjudeu at gazeta.pl  Sun Mar  5 21:58:51 2023
From: vjudeu at gazeta.pl (vjudeu at gazeta.pl)
Date: Sun, 05 Mar 2023 22:58:51 +0100
Subject: [bitcoin-dev] Minimum fees
Message-ID: <179086234-135a72949cf38fda9b4e75be5889fe02@pmq1v.m5r2.onet>

> I don't know of any data of what happens at the point where the coinbase drops to below the fees on any chain. I don't think there has been one where that has happened. Perhaps there is a chain out there where it is fee's only? Perhaps that can provide insight.

I think federations like RSK or additional layers like LN can be a good example of what happens if there are no additional coins. In RSK, all coins are backed by BTC, so all you have is what users deposited, or what was Merge Mined, there are no more coins than that. In LN, there are nodes, and channels are formed only with existing coins, by default there is no mining, so all fees collected by nodes are based only on LN transaction fees (there are ways to reward small miners with LN coins, for example by enabling free LN transactions for those miners, or create channels directly by using outputs of the coinbase transaction, but it is not widely used).

Also note that when it comes to other chains, we still have testnet3, where there were more halvings than on the mainnet, because of blockstorms. So, if that network will not be resetted, then I guess we will see, how that network will behave, when there will be no other coins. For now, you can see some users complaining that it is hard to get enough test coins, and with each halving you can see, how that network is getting closer and closer to the case you want to observe. So, if we want to check, how potential solutions can solve that problem, using testnet3 will give better results than signet, simply because of more halvings. Also, as testnet3 has blockstorms, it is possible to also test extreme cases with huge reorgs, and see if taking fees from other blocks will still be profitable after introducing proposed changes.

Another important thing to note is that even if coins are worthless, then still, if there are some minimal fees (like one satoshi per virtual byte), then on-chain amounts simply represents, how many data can be sent by each user. It means that users can simply send zero satoshis (if there is a need to create any additional UTXOs), and place as many coins as they can in their change addresses, and then the whole game is about having any coins, to have the right to broadcast any transaction to the network. Because then, an interesting thing to note is that if there is no coins, then the chain is not going to be halted. It is still possible to create a coinbase transaction with zero coins, and it is still used in all block-based calculations, so mining such blocks can prevent other miners from reorging older blocks, and taking those fees. And then, if you look at the last miners that had some blocks with fees, then you notice that reaching 100 confirmations can encourage them to mine blocks with zero coinbase amount, just to spend their rewards.

On 2023-03-04 18:32:01 user Andrew Melnychuk Oseen via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>From my limited knowledge in the space, and I've taken opinions of people I respect that are far more knowledgeable than me.


I don't know of any data of what happens at the point where the coinbase drops to below the fees on any chain. I don't think there has been one where that has happened. Perhaps there is a chain out there where it is fee's only? Perhaps that can provide insight.


Opinion: I think as bitcoin's capabilities grow, demand for it will as well. There are a lot of efforts to increase the amount of transactions that can fit into a block. I think the combination of limited block space and a reduced amount of bitcoin's entering the market is the right combination for the system to self sustain. I'm looking forward to seeing the result!
?
?




Sent with Proton Mail secure email.


------- Original Message -------
On Wednesday, March 1st, 2023 at 12:18 PM, Giuseppe B via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


Hello everyone,


I'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that.


I was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN.


In such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice.


Therefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this:
- the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid.
- one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck.


min_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation.


It looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth discussing it for some reason that I'm not considering.


Cheers,


Giuseppe.




From gsanders87 at gmail.com  Thu Mar  9 18:45:15 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 9 Mar 2023 13:45:15 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <ZAcx7oEZxC9BiWvg@erisian.com.au>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au>
Message-ID: <CAB3F3Dt_0JB1W-JEEFs5j3HHNGfmXd9uU6civ7Ue8go=+z79Eg@mail.gmail.com>

AJ,

Interesting stuff! Just a couple thoughts on these proposed opcodes, at
least one we discussed elsewhere:

1) OP_FORWARD_SELF is a JET of OP_FLU in the revaulting common case. Maybe
obvious but I missed this initially and thought it was useful to be pointed
out.

2)  Using these extended primitives, you can do rate-limiting of the two
step unvaulting, or just a single step vault by committing to the partial
values. For the single stage case it's something like:

$recovery = Same As Before

$withdrawal = <deposit-delay> OP_CSV OP_DROP <pubkey> OP_CHECKSIG OP_DUP
<V> OP_LESSTHANOREQUAL OP_VERIFY OP_FORWARD_PARTIAL OP_FORWARD_TARGET
OP_FORWARD_SELF

$withdrawal is spent by:

<self-idx> <target-idx> <spk> <0<=v<=V> <signature>

where "V"  is the max allowed withdrawal value, and "deposit-delay" the
required gap in withdrawals

Due to the OP_LEQ, you are bound to ~21 BTC in value for this operation,
but for larger vaults it's pretty trivial to add larder fixed denominations
to "peel out" value until you get to your final ~21 BTC.

This rate-limiting(in either the two-stage or one-stage scheme) can limit
the risk of theft during a watchtower outage to a constant value per utxo
per time period of watchtower failure. As we've seen in the past with LN
infrastructure, software risks are often correlated, so it's a good idea to
build in belt and suspenders where we can or at least have them available
when possible.

Cheers,
Greg


On Tue, Mar 7, 2023 at 7:45?AM Anthony Towns <aj at erisian.com.au> wrote:

> On Mon, Mar 06, 2023 at 10:25:38AM -0500, James O'Beirne via bitcoin-dev
> wrote:
> > What Greg is proposing above is to in essence TLUV-ify this proposal.
>
> FWIW, the way I'm thinking about this is that the "OP_VAULT" concept is
> introducing two things:
>
>  a) the concept of "forwarding" the input amount to specified
>     outputs in a way that elegantly allows merging/splitting
>
>  b) various restrictions on the form of the output scripts
>
> These concepts go together well, because restricting an output script is
> only an interesting thing to do if you're moving value from this input
> into it. And then it's just a matter of figuring out a nice way to pick
> opcodes that combine those two concepts in interesting ways.
>
> This is different from TLUV, in that TLUV only did part (b), and
> assumed you'd do part (a) manually somehow, eg via "OP_IN_OUT_AMOUNT"
> and arithmetic opcodes. The advantage of this new approach over that
> one is that it makes it really easy to get the logic right (I often
> forgot to include the IN_OUT_AMOUNT checks at all, for instance), and
> also makes spending multiple inputs to a single output really simple,
> something that would otherwise require kind-of gnarly logic.
>
> I think there are perhaps four opcodes that are interesting in this class:
>
>    idx sPK OP_FORWARD_TARGET
>      -- sends the value to a particular output (given by idx), and
>         requires that output have a particular scriptPubKey (given
>         by sPK).
>
>    idx [...] n script OP_FORWARD_LEAF_UPDATE
>      -- sends the value to a particular output (given by idx), and
>         requires that output to have almost the same scriptPubKey as this
>         input, _except_ that the current leaf is replaced by "script",
>         with that script prefixed by "n" pushes (of values given by [...])
>
>    idx OP_FORWARD_SELF
>      -- sends the value to a particular output (given by idx), and
>         requires that output to have the same scriptPubKey as this input
>
>    amt OP_FORWARD_PARTIAL
>      -- modifies the next OP_FORWARD_* opcode to only affect "amt",
>         rather than the entire balance. opcodes after that affect the
>         remaining balance, after "amt" has been subtracted. if "amt" is
>         0, the next OP_FORWARD_* becomes a no-op.
>
> Then each time you see OP_FORWARD_TARGET or OP_FORWARD_LEAF_UPDATE, you
> accumulate the value that's expected to be forwarded to the output by
> each input, and verify that the amount for that output is greater-or-equal
> to the accumulated value.
>
> > ## Required opcodes
> > - OP_VAULT: spent to trigger withdrawal
> > - OP_VAULT_RECOVER: spent to recover
>
> Naming here is OP_VAULT ~= OP_FORWARD_LEAF_UPDATE; OP_VAULT_RECOVER ~=
> OP_FORWARD_TARGET.
>
> > For each vault, vaulted coins are spent to an output with the taproot
> > structure
> >
> >   taproot(internal_key, {$recovery_leaf, $trigger_leaf, ...})
> >
> > where
> >
> >   $trigger_leaf =
> >     <trigger> <auth> <script> <spend-delay> OP_VAULT
>
> With the opcodes above, the trigger_leaf (for spending some of the
> vaulted funds via your hot wallet) script might look like:
>
>    OP_FORWARD_PARTIAL OP_FORWARD_SELF
>    1 "288 OP_CSV OP_DROP OP_CTV" OP_FORWARD_LEAF_UPDATE
>    key CHECKSIG
>
> So if you have 2.0 BTC in a vault utxo, you might spend 0.4 BTC by
> supplying the witness data:
>
>   160000000  (1.6BTC in sats)
>   0 (output 0 puts 1.6BTC goes back into the vault)
>   <ctvhash> (the outputs where you want the remaining 0.4 BTC to end up)
>   1 (the output idx that will be spend via the CTV path once the CSV
>      delay is done)
>   <sig> (a signature of this transaction via the hot wallet "key")
>
> That is, the script becomes:
>
>   160000000 FORWARD_PARTIAL
>   0 FORWARD_SELF
>   1 <ctvhash> 1 "288 CSV DROP CTV" FORWARD_LEAF_UPDATE
>   sig key CHECKSIG
>
> Output 1 would then have a tapscript of "<ctvhash> 288 OP_CSV OP_DROP
> OP_CTV", satisfied with an empty witness stack (along with the recovery
> path, etc).
>
> Output 0 is just 1.6BTC back in your vault, and immediately available
> for use.
>
> Other inputs/outputs (for fees etc) would still be committed to by <sig>,
> so nothing here is malleable. The script here is about 45 bytes (compared
> to 34 for a simple "key CHECKSIG") and the witness data is about 105 bytes
> (compared to 65 bytes for just a signature), which seems pretty nice.
>
> >   ... =
> >     other (optional) leaves in the taptree
>
> This would allow you to have multiple hot wallets (if any of them are
> compromised you can still use the recovery path to avoid loss of funds;
> but if some hot wallet becomes temporarily *inaccessible* you can still
> easily spend the funds via one of the alternative hot wallets), or,
> if you have multiple watchtowers validating your spends and recovering
> funds to your cold wallet on a violation, you could have multiple recovery
> paths to provide some auditability for who triggered the recovery.
>
> > Happens via script-path spend to $expr_withdraw, i.e. a timelocked
> > OP_CTV.
>
> Note that if you calculated the OP_CTV incorrectly (eg, you don't set a
> correct nSequence timelock, so that any tx that passes OP_CTV won't pass
> the OP_CSV check, and vice-versa) then this spend path becomes invalid,
> and the funds can only be reclaimed via some other path (key path spend,
> recovery tapscript, potentially an alternative hotwallet script path).
>
> OP_FORWARD_LEAF_UPDATE is equivalent to a very specific form of TLUV,
> namely "FALSE <h> 2 TLUV", where "<h>" is calculated by building the
> script, prefixing the pushes, then doing the Hash_TapLeaf calculation.
>
> Not being able to tweak the internal public key ("FALSE" rather than
> "<x>") means this can't be used to build a coinpool with unilateral
> exit -- you can't remove your key from the key path, which screws over
> everyone who's still in the coinpool.
>
> On the other hand, not tweaking the internal public key avoids introducing
> all the x-only pubkey complications, and keeps it relatively simple,
> which is nice, and keeping things simple and targeted now means there's
> still plenty of OP_SUCCESS opcodes available later for something more
> general, if that turns out to be desirable.
>
> Cheers,
> aj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230309/7c5a5e29/attachment.html>

From aj at erisian.com.au  Fri Mar 10 01:08:55 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 10 Mar 2023 11:08:55 +1000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3Dt_0JB1W-JEEFs5j3HHNGfmXd9uU6civ7Ue8go=+z79Eg@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au>
 <CAB3F3Dt_0JB1W-JEEFs5j3HHNGfmXd9uU6civ7Ue8go=+z79Eg@mail.gmail.com>
Message-ID: <AFEB05FC-5C97-472F-87C3-95F12954711A@erisian.com.au>

On 10 March 2023 4:45:15 am AEST, Greg Sanders via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>1) OP_FORWARD_SELF is a JET of OP_FLU in the revaulting common case. Maybe
>obvious but I missed this initially and thought it was useful to be pointed
>out.

That was true for TLUV - iirc "FALSE FALSE 0 TLUV" would preserve the spk - but I don't think it's true for OP_FLU: you can't commit to preserving the current script without a way to observe the current script; trying to include a copy of the script in the script makes the script size infinite, and trying to include a hash of the script inside the script is cryptographically infeasible.

You could just special case "0 0 OP_FLU" to result in the same script rather than an empty one though, which would avoid the need for a dedicated FWD_SELF opcode.

(Not convinced calling things Jets when they're unrelated to simplicity makes sense)

Cheers,
aj

-- 
Sent from my phone.

From luke at dashjr.org  Sat Mar 11 20:53:21 2023
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 11 Mar 2023 15:53:21 -0500
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
Message-ID: <4652dbe8-6647-20f2-358e-be0ef2e52c47@dashjr.org>

I started reviewing the BIP, but stopped part way through, as it seems 
to have a number of conceptual issues.

I left several comments on the PR 
(https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575), 
but ultimately I think it isn't simplified enough for day-to-day use, 
and would harm privacy quite a bit.

Instead, I would suggest a new approach where:

1) Joe receives funds with a taproot output like normal.
2) Joe sends funds to Fred, but Fred cannot spend them until N blocks 
later (covenant-enforced relative locktime). Ideally, this should 
use/support a taproot keypath spend somehow. It would be nice to blind 
the particular relative locktime somehow too, but that may be too expensive.
2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N 
block window to a recovery output.

Unfortunately, the implementation details for this kind of setup are 
non-obvious and will likely require yet another address format (or at 
least recipient-wallet changes), but certainly seems within the scope of 
possibility.

Thoughts?

Luke


On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:
> Since the last related correspondence on this list [0], a number of
> improvements have been made to the OP_VAULT draft [1]:
>
> * There is no longer a hard dependence on package relay/ephemeral
> ? anchors for fee management. When using "authorized recovery," all
> ? vault-related transactions can be bundled with unrelated inputs and
> ? outputs, facilitating fee management that is self contained to the
> ? transaction. Consequently, the contents of this proposal are in theory
> ? usable today.
>
> * Specific output locations are no longer hardcoded in any of the
> ? transaction validation algorithms. This means that the proposal is now
> ? compatible with future changes like SIGHASH_GROUP, and
> ? transaction shapes for vault operations are more flexible.
>
> ---
>
> I've written a BIP that fully describes the proposal here:
>
> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki
>
> The corresponding PR is here:
>
> https://github.com/bitcoin/bips/pull/1421
>
> My next steps will be to try for a merge to the inquisition repo.
>
> Thanks to everyone who has participated so far, but especially to AJ and
> Greg for all the advice.
>
> James
>
> [0]: 
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
> [1]: https://github.com/bitcoin/bitcoin/pull/26857
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From antoine.riard at gmail.com  Sun Mar 12 16:46:36 2023
From: antoine.riard at gmail.com (Antoine Riard)
Date: Sun, 12 Mar 2023 16:46:36 +0000
Subject: [bitcoin-dev] Bitcoin Contracting Primitives WG 5th Meeting,
	Tuesday 21 Mar. 18:00 UTC
Message-ID: <CALZpt+F50AUSqgQKG9_37GZ=E6FGmYRA+yRKz5CdT91SOaFFHw@mail.gmail.com>

Hi list,

I'm proposing Tuesday 21st March at 18:00, i.e one week and half from now
for the 5th Bitcoin contracting primitives WG (the third Tuesday of March
month, as done previously).

There is an issue if anyone would like to propose an agenda topic in
advance in an open fashion:
https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/38

For now, there is only pinned ANYPREVOUT / "Eltoo" as a discussion subject.
Feel free to add more!

Beyond that, if you would like to host the meeting, don't hesitate to
comment on the issue. Good to rotate if we can.

Communication venue is #bitcoin-contracting-primitives-wg on Libera Chat
IRC. Logs of the previous session are available here [0].

If you have any questions or feedback, I'm staying responsive.

Cheers,
Antoine

[0]
https://github.com/ariard/bitcoin-contracting-primitives-wg/blob/main/meetings/meetings-21-02.md
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230312/41a820b9/attachment.html>

From gsanders87 at gmail.com  Mon Mar 13 14:55:05 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 13 Mar 2023 10:55:05 -0400
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <4652dbe8-6647-20f2-358e-be0ef2e52c47@dashjr.org>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <4652dbe8-6647-20f2-358e-be0ef2e52c47@dashjr.org>
Message-ID: <CAB3F3DtitOkV=KGGJjtet=YHJYbfj0KWVYRNKDWwyecRCBC=2w@mail.gmail.com>

Hi Luke,

Can you elaborate why the current idealized functionality of deposit ->
trigger -> withdrawal is too complicated for
everyday use but the above deposit -> withdrawal ->
resolve(claim/clawback)  wouldn't be? I admit at a high level
it's a fine paradigm, but in practice would end

Let's ignore implementation for the discussion, since that's in flux.

Cheers,
Greg

On Sat, Mar 11, 2023 at 3:53?PM Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> I started reviewing the BIP, but stopped part way through, as it seems
> to have a number of conceptual issues.
>
> I left several comments on the PR
> (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),
> but ultimately I think it isn't simplified enough for day-to-day use,
> and would harm privacy quite a bit.
>
> Instead, I would suggest a new approach where:
>
> 1) Joe receives funds with a taproot output like normal.
> 2) Joe sends funds to Fred, but Fred cannot spend them until N blocks
> later (covenant-enforced relative locktime). Ideally, this should
> use/support a taproot keypath spend somehow. It would be nice to blind
> the particular relative locktime somehow too, but that may be too
> expensive.
> 2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N
> block window to a recovery output.
>
> Unfortunately, the implementation details for this kind of setup are
> non-obvious and will likely require yet another address format (or at
> least recipient-wallet changes), but certainly seems within the scope of
> possibility.
>
> Thoughts?
>
> Luke
>
>
> On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:
> > Since the last related correspondence on this list [0], a number of
> > improvements have been made to the OP_VAULT draft [1]:
> >
> > * There is no longer a hard dependence on package relay/ephemeral
> >   anchors for fee management. When using "authorized recovery," all
> >   vault-related transactions can be bundled with unrelated inputs and
> >   outputs, facilitating fee management that is self contained to the
> >   transaction. Consequently, the contents of this proposal are in theory
> >   usable today.
> >
> > * Specific output locations are no longer hardcoded in any of the
> >   transaction validation algorithms. This means that the proposal is now
> >   compatible with future changes like SIGHASH_GROUP, and
> >   transaction shapes for vault operations are more flexible.
> >
> > ---
> >
> > I've written a BIP that fully describes the proposal here:
> >
> >
> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki
> >
> > The corresponding PR is here:
> >
> > https://github.com/bitcoin/bips/pull/1421
> >
> > My next steps will be to try for a merge to the inquisition repo.
> >
> > Thanks to everyone who has participated so far, but especially to AJ and
> > Greg for all the advice.
> >
> > James
> >
> > [0]:
> >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
> > [1]: https://github.com/bitcoin/bitcoin/pull/26857
> >
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/922ebcb6/attachment.html>

From gsanders87 at gmail.com  Mon Mar 13 14:56:15 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 13 Mar 2023 10:56:15 -0400
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3DtitOkV=KGGJjtet=YHJYbfj0KWVYRNKDWwyecRCBC=2w@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <4652dbe8-6647-20f2-358e-be0ef2e52c47@dashjr.org>
 <CAB3F3DtitOkV=KGGJjtet=YHJYbfj0KWVYRNKDWwyecRCBC=2w@mail.gmail.com>
Message-ID: <CAB3F3DtTD4DeY33UCArRq-iNEt7D8tuT+daA5H-8aCVHz9FP4g@mail.gmail.com>

Didn't finish sentence: but in practice would end up with pretty similar
usage flows imho, and as noted in PR, would take a different wallet
paradigm,
among other technical challenges.

On Mon, Mar 13, 2023 at 10:55?AM Greg Sanders <gsanders87 at gmail.com> wrote:

> Hi Luke,
>
> Can you elaborate why the current idealized functionality of deposit ->
> trigger -> withdrawal is too complicated for
> everyday use but the above deposit -> withdrawal ->
> resolve(claim/clawback)  wouldn't be? I admit at a high level
> it's a fine paradigm, but in practice would end
>
> Let's ignore implementation for the discussion, since that's in flux.
>
> Cheers,
> Greg
>
> On Sat, Mar 11, 2023 at 3:53?PM Luke Dashjr via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> I started reviewing the BIP, but stopped part way through, as it seems
>> to have a number of conceptual issues.
>>
>> I left several comments on the PR
>> (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),
>>
>> but ultimately I think it isn't simplified enough for day-to-day use,
>> and would harm privacy quite a bit.
>>
>> Instead, I would suggest a new approach where:
>>
>> 1) Joe receives funds with a taproot output like normal.
>> 2) Joe sends funds to Fred, but Fred cannot spend them until N blocks
>> later (covenant-enforced relative locktime). Ideally, this should
>> use/support a taproot keypath spend somehow. It would be nice to blind
>> the particular relative locktime somehow too, but that may be too
>> expensive.
>> 2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N
>> block window to a recovery output.
>>
>> Unfortunately, the implementation details for this kind of setup are
>> non-obvious and will likely require yet another address format (or at
>> least recipient-wallet changes), but certainly seems within the scope of
>> possibility.
>>
>> Thoughts?
>>
>> Luke
>>
>>
>> On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:
>> > Since the last related correspondence on this list [0], a number of
>> > improvements have been made to the OP_VAULT draft [1]:
>> >
>> > * There is no longer a hard dependence on package relay/ephemeral
>> >   anchors for fee management. When using "authorized recovery," all
>> >   vault-related transactions can be bundled with unrelated inputs and
>> >   outputs, facilitating fee management that is self contained to the
>> >   transaction. Consequently, the contents of this proposal are in theory
>> >   usable today.
>> >
>> > * Specific output locations are no longer hardcoded in any of the
>> >   transaction validation algorithms. This means that the proposal is now
>> >   compatible with future changes like SIGHASH_GROUP, and
>> >   transaction shapes for vault operations are more flexible.
>> >
>> > ---
>> >
>> > I've written a BIP that fully describes the proposal here:
>> >
>> >
>> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki
>> >
>> > The corresponding PR is here:
>> >
>> > https://github.com/bitcoin/bips/pull/1421
>> >
>> > My next steps will be to try for a merge to the inquisition repo.
>> >
>> > Thanks to everyone who has participated so far, but especially to AJ and
>> > Greg for all the advice.
>> >
>> > James
>> >
>> > [0]:
>> >
>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
>> > [1]: https://github.com/bitcoin/bitcoin/pull/26857
>> >
>> > _______________________________________________
>> > bitcoin-dev mailing list
>> > bitcoin-dev at lists.linuxfoundation.org
>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/263bfcdc/attachment.html>

From gsanders87 at gmail.com  Mon Mar 13 16:38:25 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 13 Mar 2023 12:38:25 -0400
Subject: [bitcoin-dev] Ephemeral Anchors: Fixing V3 Package RBF
 againstpackage limit pinning
In-Reply-To: <Y96BpabeyHyWphp5@petertodd.org>
References: <CAB3F3DtrSFPmperGJJAUDZj7vt9aHgvkc0b5Pts3+mq5fTuWXA@mail.gmail.com>
 <CAB3F3DvToF_fia+X5SQi-L=BDYGLpzr8nNHqjtFBUjLMbyPE9Q@mail.gmail.com>
 <Y9vOGVMJx1b9CPYq@petertodd.org>
 <CAB3F3Du2XsHCh5o5S84XKKizTkrTFJJ-j42-qunyuSRkwX7H_Q@mail.gmail.com>
 <Y9vRjQVnZzA8Bx/s@petertodd.org>
 <CAB3F3DvumE-r+LGm8ivooPD9qfzFs-NK9Ve06Ew1EMAifSx8dw@mail.gmail.com>
 <Y9wbjsmPO+nyM267@petertodd.org>
 <CAB3F3Ds7Ux8MWnY-9Agehpk0hZx_xgeFmZG7hUjMkfe48T5GPA@mail.gmail.com>
 <Y92GY7s1U4P9fC/f@petertodd.org>
 <CAB3F3Dtuxu8m6+pU_xBwh=35MyPF90OSnB4vhaNbKpr_ap2shw@mail.gmail.com>
 <Y96BpabeyHyWphp5@petertodd.org>
Message-ID: <CAB3F3DsdT27RxyV-X=QPmyRfECUnysN3zriG_Ru=t3ZQzfM+aA@mail.gmail.com>

After getting neutral to negative feedback on the choice, I have switched
to OP_TRUE on the BIP and implementation.

Cheers,
Greg

On Sat, Feb 4, 2023 at 11:03?AM Peter Todd <pete at petertodd.org> wrote:

> On Fri, Feb 03, 2023 at 09:07:29PM -0500, Greg Sanders wrote:
> > I'm not particularly persuaded, but also not wedded to either idea.
> >
> > Fixed up tests for the OP_TRUE case here:
> > https://github.com/instagibbs/bitcoin/tree/ephemeral-anchors-true
>
> Thanks.
>
> Looking through that, I think a lot of those test cases don't actually
> need to
> be changed to OP_2, as they aren't trying to test anything related to
> standardness.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/d322b383/attachment-0001.html>

From luke at dashjr.org  Mon Mar 13 20:55:00 2023
From: luke at dashjr.org (Luke Dashjr)
Date: Mon, 13 Mar 2023 16:55:00 -0400
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3DtTD4DeY33UCArRq-iNEt7D8tuT+daA5H-8aCVHz9FP4g@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <4652dbe8-6647-20f2-358e-be0ef2e52c47@dashjr.org>
 <CAB3F3DtitOkV=KGGJjtet=YHJYbfj0KWVYRNKDWwyecRCBC=2w@mail.gmail.com>
 <CAB3F3DtTD4DeY33UCArRq-iNEt7D8tuT+daA5H-8aCVHz9FP4g@mail.gmail.com>
Message-ID: <f2dba06f-6230-1093-32a5-8a426821ed8e@dashjr.org>

In ordinary use cases, you wouldn't clawback; that would only be in the 
extreme case of the wallet being compromised. So typical usage would 
just be receive -> send, like wallets currently do.

Luke


On 3/13/23 10:56, Greg Sanders wrote:
> Didn't finish sentence: but in practice would end up with pretty 
> similar usage flows imho, and as noted in PR, would take a different 
> wallet paradigm,
> among other technical challenges.
>
> On Mon, Mar 13, 2023 at 10:55?AM Greg Sanders <gsanders87 at gmail.com> 
> wrote:
>
>     Hi Luke,
>
>     Can you elaborate why the current idealized functionality of
>     deposit?-> trigger -> withdrawal is too complicated for
>     everyday use but the above deposit -> withdrawal ->
>     resolve(claim/clawback)? wouldn't be? I admit at a high level
>     it's a fine paradigm, but in practice would end
>
>     Let's ignore implementation for the discussion, since that's in flux.
>
>     Cheers,
>     Greg
>
>     On Sat, Mar 11, 2023 at 3:53?PM Luke Dashjr via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>         I started reviewing the BIP, but stopped part way through, as
>         it seems
>         to have a number of conceptual issues.
>
>         I left several comments on the PR
>         (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),
>
>         but ultimately I think it isn't simplified enough for
>         day-to-day use,
>         and would harm privacy quite a bit.
>
>         Instead, I would suggest a new approach where:
>
>         1) Joe receives funds with a taproot output like normal.
>         2) Joe sends funds to Fred, but Fred cannot spend them until N
>         blocks
>         later (covenant-enforced relative locktime). Ideally, this should
>         use/support a taproot keypath spend somehow. It would be nice
>         to blind
>         the particular relative locktime somehow too, but that may be
>         too expensive.
>         2b) If Joe's funds were stolen, Joe can spend Fred's UTXO
>         within the N
>         block window to a recovery output.
>
>         Unfortunately, the implementation details for this kind of
>         setup are
>         non-obvious and will likely require yet another address format
>         (or at
>         least recipient-wallet changes), but certainly seems within
>         the scope of
>         possibility.
>
>         Thoughts?
>
>         Luke
>
>
>         On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:
>         > Since the last related correspondence on this list [0], a
>         number of
>         > improvements have been made to the OP_VAULT draft [1]:
>         >
>         > * There is no longer a hard dependence on package
>         relay/ephemeral
>         > ? anchors for fee management. When using "authorized
>         recovery," all
>         > ? vault-related transactions can be bundled with unrelated
>         inputs and
>         > ? outputs, facilitating fee management that is self
>         contained to the
>         > ? transaction. Consequently, the contents of this proposal
>         are in theory
>         > ? usable today.
>         >
>         > * Specific output locations are no longer hardcoded in any
>         of the
>         > ? transaction validation algorithms. This means that the
>         proposal is now
>         > ? compatible with future changes like SIGHASH_GROUP, and
>         > ? transaction shapes for vault operations are more flexible.
>         >
>         > ---
>         >
>         > I've written a BIP that fully describes the proposal here:
>         >
>         >
>         https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki
>         >
>         > The corresponding PR is here:
>         >
>         > https://github.com/bitcoin/bips/pull/1421
>         >
>         > My next steps will be to try for a merge to the inquisition
>         repo.
>         >
>         > Thanks to everyone who has participated so far, but
>         especially to AJ and
>         > Greg for all the advice.
>         >
>         > James
>         >
>         > [0]:
>         >
>         https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
>         > [1]: https://github.com/bitcoin/bitcoin/pull/26857
>         >
>         > _______________________________________________
>         > bitcoin-dev mailing list
>         > bitcoin-dev at lists.linuxfoundation.org
>         > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>         _______________________________________________
>         bitcoin-dev mailing list
>         bitcoin-dev at lists.linuxfoundation.org
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230313/1ee9a035/attachment.html>

From freedom at reardencode.com  Mon Mar 13 19:03:30 2023
From: freedom at reardencode.com (Brandon Black)
Date: Mon, 13 Mar 2023 12:03:30 -0700
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
Message-ID: <ZA9zgqeNiCBfBGUz@console>

Hi Gents,

> > I don't think replacing the internal-public-key makes sense -- if it
> was immediately spendable via the keypath before there's no reason for
> it not to be immediately spendable now.
> 
> Slavishly following the current proposal was the idea to make sure all
> functionality was captured; I agree with this change.

I think we do need to replace the internal key with a hardcoded NUMS
point to allow us to batch multiple vault inputs which might have
different internal keys but the same OP_FLU/OP_VAULT_TRIGGER script to
the same time+template-restricted output.

I like that in James' current PR proposal we can explicitly batch via
the implied input/output summation rules while avoiding address reuse.
If we can retain some or all of that, I think it would be good for on
chain efficiency and potentially privacy.

My thoughts on batching:

Many inputs with different internal keys can be combined to satisfy the
total output value for a single output, as long as their scriptpubkeys
with FLU and NUMS internal key are equal This enables avoiding address
reuse within the vault.

Many inputs with the same scriptpubkey can be combined to satisfy a
single CTV output template. This allows a user to unfsck themselves if
they initiate a withdrawal that cannot be satisfied because they didn't
send enough sats to satisfy their template.

Best,

--Brandon

From gsanders87 at gmail.com  Tue Mar 14 14:40:53 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Tue, 14 Mar 2023 10:40:53 -0400
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <ZA9zgqeNiCBfBGUz@console>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <ZA9zgqeNiCBfBGUz@console>
Message-ID: <CAB3F3Dsu8OWJfrEAUB=5rDtrmAm=N9zL1tN_r153v01k9F4LGA@mail.gmail.com>

Hi Brandon,

Thank you for chiming in, causing me to think a bit more deeply on the
privacy issues
and what seems possible.

> I like that in James' current PR proposal we can explicitly batch via
the implied input/output summation rules while avoiding address reuse.
If we can retain some or all of that, I think it would be good for on
chain efficiency and potentially privacy.

Rotating trigger authorization keys maintains batchability and stops
address reuse.
Remember that anytime you share any path, like recovery path, for batching,
it becomes
obvious at spend-time. Rotating inner pubkeys only doesn't seem to help
much.

Coinjoins being the other batching scenario which could benefit perhaps are
quite a heavy
lift. You'd need the recovery policy(every other branch) to be agreed upon,
have everyone unvault
to this new joint vault, then mix, and withdrawal back to the original
vault. If someone is going through
all that effort, I suspect they'll just use a NUMS to reduce fingerprinting.

> Many inputs with different internal keys can be combined to satisfy the
total output value for a single output, as long as their scriptpubkeys
with FLU and NUMS internal key are equal This enables avoiding address
reuse within the vault.

To reiterate, we can just cycle any key in the $trigger branch with OP_FLU,
which accomplishes the same thing.
Or in authorization-less $trigger, add a random number which is dropped.

> Many inputs with the same scriptpubkey can be combined to satisfy a
single CTV output template. This allows a user to unfsck themselves if
they initiate a withdrawal that cannot be satisfied because they didn't
send enough sats to satisfy their template.

I think that would fit the deprecated OP_FORWARD_OUTPUTS, but OP_CTV
commits to total
number of inputs to remove txid malleability. I think the real solution to
this mistake would be to hit
the big red RECOVERY button that you're relying on for vault security
anyways.

Cheers,
Greg

On Mon, Mar 13, 2023 at 3:04?PM Brandon Black <freedom at reardencode.com>
wrote:

> Hi Gents,
>
> > > I don't think replacing the internal-public-key makes sense -- if it
> > was immediately spendable via the keypath before there's no reason for
> > it not to be immediately spendable now.
> >
> > Slavishly following the current proposal was the idea to make sure all
> > functionality was captured; I agree with this change.
>
> I think we do need to replace the internal key with a hardcoded NUMS
> point to allow us to batch multiple vault inputs which might have
> different internal keys but the same OP_FLU/OP_VAULT_TRIGGER script to
> the same time+template-restricted output.
>
> I like that in James' current PR proposal we can explicitly batch via
> the implied input/output summation rules while avoiding address reuse.
> If we can retain some or all of that, I think it would be good for on
> chain efficiency and potentially privacy.
>
> My thoughts on batching:
>
> Many inputs with different internal keys can be combined to satisfy the
> total output value for a single output, as long as their scriptpubkeys
> with FLU and NUMS internal key are equal This enables avoiding address
> reuse within the vault.
>
> Many inputs with the same scriptpubkey can be combined to satisfy a
> single CTV output template. This allows a user to unfsck themselves if
> they initiate a withdrawal that cannot be satisfied because they didn't
> send enough sats to satisfy their template.
>
> Best,
>
> --Brandon
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230314/b2e848e8/attachment.html>

From gsanders87 at gmail.com  Thu Mar 16 14:44:33 2023
From: gsanders87 at gmail.com (Greg Sanders)
Date: Thu, 16 Mar 2023 10:44:33 -0400
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <f2dba06f-6230-1093-32a5-8a426821ed8e@dashjr.org>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <4652dbe8-6647-20f2-358e-be0ef2e52c47@dashjr.org>
 <CAB3F3DtitOkV=KGGJjtet=YHJYbfj0KWVYRNKDWwyecRCBC=2w@mail.gmail.com>
 <CAB3F3DtTD4DeY33UCArRq-iNEt7D8tuT+daA5H-8aCVHz9FP4g@mail.gmail.com>
 <f2dba06f-6230-1093-32a5-8a426821ed8e@dashjr.org>
Message-ID: <CAB3F3DsDefXiHsGxOsqHQHPEgHcjVi6QrvUVenCW2HwQJBr9Ng@mail.gmail.com>

Hi Luke,

I think this works as with OP_FLU based construct, for the simplest single
key case.

e.g., single key hot wallet(or MuSig2/FROST wallet)

<hot_pubkey> 1 "<time-delay> OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG"
OP_FORWARD_LEAF_UPDATE

The <hot_pubkey> is appended at spending time.

This allows the utxo to go to $recover cold storage at any point like
before, otherwise the time matures and the funds can be spent by a single
key. Rate-limiting like usual can be bolted on as well using OP_FORWARD_*
opcodes, I'm pretty sure. This would as you note require wallet support,
where the hot wallet would have to be aware of the vault, or be scanning
inputs looking for this type of leaf.

Unfortunately this doesn't extend to things like OP_CHECKSIGADD, since the
pubkeys are all pushed first, then the opcodes run. OP_CHECKMULTISIG would
have worked probably.

To generalize I think you'd need recursive taproot, or a proper replacement
for Bitcoin script :)

Cheers,
Greg

On Mon, Mar 13, 2023 at 4:55?PM Luke Dashjr <luke at dashjr.org> wrote:

> In ordinary use cases, you wouldn't clawback; that would only be in the
> extreme case of the wallet being compromised. So typical usage would just
> be receive -> send, like wallets currently do.
>
> Luke
>
>
> On 3/13/23 10:56, Greg Sanders wrote:
>
> Didn't finish sentence: but in practice would end up with pretty similar
> usage flows imho, and as noted in PR, would take a different wallet
> paradigm,
> among other technical challenges.
>
> On Mon, Mar 13, 2023 at 10:55?AM Greg Sanders <gsanders87 at gmail.com>
> wrote:
>
>> Hi Luke,
>>
>> Can you elaborate why the current idealized functionality of deposit ->
>> trigger -> withdrawal is too complicated for
>> everyday use but the above deposit -> withdrawal ->
>> resolve(claim/clawback)  wouldn't be? I admit at a high level
>> it's a fine paradigm, but in practice would end
>>
>> Let's ignore implementation for the discussion, since that's in flux.
>>
>> Cheers,
>> Greg
>>
>> On Sat, Mar 11, 2023 at 3:53?PM Luke Dashjr via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> I started reviewing the BIP, but stopped part way through, as it seems
>>> to have a number of conceptual issues.
>>>
>>> I left several comments on the PR
>>> (https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575),
>>>
>>> but ultimately I think it isn't simplified enough for day-to-day use,
>>> and would harm privacy quite a bit.
>>>
>>> Instead, I would suggest a new approach where:
>>>
>>> 1) Joe receives funds with a taproot output like normal.
>>> 2) Joe sends funds to Fred, but Fred cannot spend them until N blocks
>>> later (covenant-enforced relative locktime). Ideally, this should
>>> use/support a taproot keypath spend somehow. It would be nice to blind
>>> the particular relative locktime somehow too, but that may be too
>>> expensive.
>>> 2b) If Joe's funds were stolen, Joe can spend Fred's UTXO within the N
>>> block window to a recovery output.
>>>
>>> Unfortunately, the implementation details for this kind of setup are
>>> non-obvious and will likely require yet another address format (or at
>>> least recipient-wallet changes), but certainly seems within the scope of
>>> possibility.
>>>
>>> Thoughts?
>>>
>>> Luke
>>>
>>>
>>> On 2/13/23 16:09, James O'Beirne via bitcoin-dev wrote:
>>> > Since the last related correspondence on this list [0], a number of
>>> > improvements have been made to the OP_VAULT draft [1]:
>>> >
>>> > * There is no longer a hard dependence on package relay/ephemeral
>>> >   anchors for fee management. When using "authorized recovery," all
>>> >   vault-related transactions can be bundled with unrelated inputs and
>>> >   outputs, facilitating fee management that is self contained to the
>>> >   transaction. Consequently, the contents of this proposal are in
>>> theory
>>> >   usable today.
>>> >
>>> > * Specific output locations are no longer hardcoded in any of the
>>> >   transaction validation algorithms. This means that the proposal is
>>> now
>>> >   compatible with future changes like SIGHASH_GROUP, and
>>> >   transaction shapes for vault operations are more flexible.
>>> >
>>> > ---
>>> >
>>> > I've written a BIP that fully describes the proposal here:
>>> >
>>> >
>>> https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-vaults.mediawiki
>>> >
>>> > The corresponding PR is here:
>>> >
>>> > https://github.com/bitcoin/bips/pull/1421
>>> >
>>> > My next steps will be to try for a merge to the inquisition repo.
>>> >
>>> > Thanks to everyone who has participated so far, but especially to AJ
>>> and
>>> > Greg for all the advice.
>>> >
>>> > James
>>> >
>>> > [0]:
>>> >
>>> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html
>>> > [1]: https://github.com/bitcoin/bitcoin/pull/26857
>>> >
>>> > _______________________________________________
>>> > bitcoin-dev mailing list
>>> > bitcoin-dev at lists.linuxfoundation.org
>>> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230316/89c8d041/attachment.html>

From jlspc at protonmail.com  Fri Mar 17 20:54:51 2023
From: jlspc at protonmail.com (jlspc)
Date: Fri, 17 Mar 2023 20:54:51 +0000
Subject: [bitcoin-dev] Conjectures on solving the high interactivity
	issue in payment pools and channel factories
In-Reply-To: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
References: <CALZpt+GNoRdbtfeBtpnitiAZ4jGwSsRpSRXOyX7mzrhwewmBcw@mail.gmail.com>
Message-ID: <HJ2_OH4FKFmPnfms-7QajxORYiNw-Fo8p72auDWL1n_ES6kyw1WYedxKYrZOHQL3DbY6yRb6XvNeneZbd6ZjwgNjtHPST4Fe_bmc0MRWA7Q=@protonmail.com>

Hi Antoine,

Thanks for your insightful post on the interactivity issue.

Some thoughts are inline below.

> However, those constructions require all the users to be online and
> exchange rounds of signatures to update the balance distribution. Those
> liveliness/interactivity requirements are increasing with the number of
> users, as there are higher odds of *one* lazzy/buggy/offline user stalling
> the pool/factory updates.

> In echo, the design of LN was envisioned for a network of
> always-online/self-hosted participants, the early deployment of LN showed
> the resort to delegated channel hosting solutions, relieving users from the
> liveliness requirement. While the trust trade-offs of those solutions are
> significant, they answer the reality of a world made of unreliable networks
> and mobile devices.

Agreed that signing updates and monitoring the blockchain both create always-online requirements that are not compatible with casual users' desires.
I think it's helpful to separate these two cases, as they affect different parties and their solutions differ.
In particular, limited availability to sign updates affects one's partners and can be addressed by having fewer partners, not partnering with casual users, evicting unresponsive users, etc.
Limited availability to monitor the blockchain affects the security of one's own funds and can be addressed by increasing one's safety parameters (such as the to_self_delay parameter in Lightning).

> Ideally, I think we would like a trust-minimized solution enabling
> non-interactive, off-chain updates of the pool/factory, with no or minimal
> consumption of blockspace.

I would argue that we want a completely trust-free solution, if at all possible, while respecting users' actual availability.
We should only consider solutions that require trust if we can't find a trust-free solution that meets all other requirements.

> For the remainder of this post, only the pool use-case will be mentioned.
> Though, I think the observations/implications can be extended to factories
> as well.

> Of course, the double-spend issue is already addressed on the Bitcoin
> base-layer due to nodes consensus convergence on the most-proof-of-work
> accumulated valid chain of blocks. While reorg can happen, a UTXO cannot be
> spent twice on the same chain. This security model can be said to be
> prophylactic, i.e an invalid block cannot be applied to a node's state and
> should be rejected.

> The double-spend issue is also solved in its own way in payment channels.
> If a transaction is published, of which the correctness has been revoked
> w.r.t negotiated, private channel state, the wronged channel users must
> react in consequence. This security model can be said to be corrective,
> states updates are applied first on the global ledger then eventually
> corrected.

> A solution to the pool partition equivocation issue appears as either based
> on a prophylactic one or a corrective security model.

Actually, there's a third class of solutions that are possible, namely ones that use separate control transactions and value transactions (where the value transactions "spend", and therefore depend on, the control transactions).
If an invalid control transaction is put on-chain, it can be blocked by another user by spending its output(s) before the output(s) can affect the value transaction.
Thus, control transactions can be viewed as proposals for state updates, and those proposals are blocked if they aren't valid.

These solutions differ from prophylactic solutions, as they allow incorrect transactions to be put on-chain and require another user to block them.
They also differ from your definition of a corrective security model, as they never allow the state update to be applied to the value in the channel or pool, so there's nothing to be corrected.
An example of this third class of solutions is the Tunable-Penalty Factory protocol [1].
Of course, this example was not available when you noted that solutions are either prophylactic or corrective.

> E.g, let's say you have Alice, Bob, Caroll and Dave as pool participants.
> Alice contacts Bob to form a first partition, then Caroll to form a second
> one, then Dave to form a last one. If she is successful in that
> equivocation trick, she can *triple*-spend her balance against any goods or
> out-of-pool payments.

> However, correction can only
> be limited to the equivocated balance. Therefore, it appears that
> corrective security models in the context of multi-party are always
> producing an economic disequilibrium.

On the other hand, protocols that use separate control and value transactions do not have this limitation.
For example, the Tunable-Penalty Factory protocol is a multi-party protocol in which every dishonest party is penalized and there is no economic disequilibrium.

> I think that leveraging covenants a revocation mechanism could be attached
> on any equivocating branch of transactions, allowing in the above case a
> single honest user to punish the publication. While a revocation mechanism
> does not work in case of multiple defrauded users, I believe the existence
> of a revocation mechanism makes the formation of malicious coalitions
> unsafe for their conjurers.

> Indeed, any user entering in the coalition is not guaranteed to be blinded
> to other equivocating branches generated by the partition initiator.
> Therefore, the publication of a partition statement by everyone is
> holistically optimal to discover any equivocating candidate among the pool
> users.

If I understand this correctly, I think a penalty mechanism that allows a "wronged" user to take some or all of a dishonest user's funds could be exploited by a malicious coalition.
Consider the case where Alice is an honest user who joins a partition with Bob, where Bob and Carol are in a malicious coalition.
Alice believes she has pooled her funds with Bob's and so she is able to work with Bob to implement an off-line update of their balances, with Alice believing that she has gained ownership over some of Bob's funds.
However, when the partitioning Update transaction that joins Alice's and Bob's funds is put on-chain, Carol pretends to have been "wronged" by Bob and uses the penalty mechanism to seize Bob's funds.
In this case, Alice won't be able to get the funds that she thought she had obtained from Bob.

Does that make sense?

Regards,
John

[1] Law, "Efficient Factories For Lightning Channels", available at https://github.com/JohnLaw2/ln-efficient-factories.

Sent with [Proton Mail](https://proton.me/) secure email.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230317/04bc8655/attachment.html>

From aj at erisian.com.au  Fri Mar 24 12:10:05 2023
From: aj at erisian.com.au (Anthony Towns)
Date: Fri, 24 Mar 2023 22:10:05 +1000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <ZAcx7oEZxC9BiWvg@erisian.com.au>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au>
Message-ID: <ZB2THW3WT2wiU7Ni@erisian.com.au>

On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev wrote:
> I think there are perhaps four opcodes that are interesting in this class:
> 
>    idx sPK OP_FORWARD_TARGET
>      -- sends the value to a particular output (given by idx), and
>         requires that output have a particular scriptPubKey (given
>         by sPK).
> 
>    idx [...] n script OP_FORWARD_LEAF_UPDATE
>      -- sends the value to a particular output (given by idx), and
> 	requires that output to have almost the same scriptPubKey as this
> 	input, _except_ that the current leaf is replaced by "script",
> 	with that script prefixed by "n" pushes (of values given by [...])
> 
>    idx OP_FORWARD_SELF
>      -- sends the value to a particular output (given by idx), and
>         requires that output to have the same scriptPubKey as this input
> 
>    amt OP_FORWARD_PARTIAL
>      -- modifies the next OP_FORWARD_* opcode to only affect "amt",
>         rather than the entire balance. opcodes after that affect the
> 	remaining balance, after "amt" has been subtracted. if "amt" is
> 	0, the next OP_FORWARD_* becomes a no-op.

The BIP 345 draft has been updated [0] [1] and now pretty much defines
OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,
and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite
that, for this email I'm going to continue using the OP_FORWARD_*
naming convention.

Given the recent controversy over the Yuga labs ordinal auction [2],
perhaps it's interesting to consider that these proposed opcodes come
close to making it possible to do a fair, non-custodial, on-chain auction
of ordinals [3].

The idea here is that you create a utxo on chain that contains the ordinal
in question, which commits to the address of the current leading bidder,
and can be spent in two ways:

  1) it can be updated to a new bidder, if the bid is raised by at least
     K satoshis, in which case the previous bidder is refunded their
     bid; or,

  2) if there have been no new bids for a day, the current high bidder
     wins, and the ordinal is moved to their address, while the funds
     from their winning bid are sent to the original vendor's address.

I believe this can be implemented in script as follows,
assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),
OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),
and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])
are all available.

First, figure out the parameters:

 * Set VENDOR to the scriptPubKey corresponding to the vendor's address.
 * Set K to the minimum bid increment [5].
 * Initially, set X equal to VENDOR.
 * Initially, set V to just below the reserve price (V+K is the
   minimum initial bid).

Then construct the following script:

 [X] [V] [SSS] TOALT TOALT TOALT
 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
 DEPTH NOT IF
   0 10000 FORWARD_PARTIAL
   0 FROMALT FORWARD_TARGET
   1 [VENDOR] FWD_TARGET
   144
 ELSE
   FROMALT SWAP TUCK FROMALT
   [K] ADD GREATERTHANOREQUAL VERIFY
   1 SWAP FORWARD_TARGET
   DUP FORWARD_PARTIAL
   0 ROT ROT
   FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
   0
 ENDIF
 CSV
 1ADD

where "SSS" is a pushdata of the rest of the script ("TOALT TOALT TOALT
.. 1ADD").

Finally, make that script the sole tapleaf, accompanied by a NUMS point
as the internal public key, calculate the taproot address corresponding
to that, and send the ordinal to that address as the first satoshi.

There are two ways to spend that script. With an empty witness stack,
the following will be executed:

 [X] [V] [SSS] TOALT TOALT TOALT
   -- altstack now contains [SSS V X]
 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
   -- this input is the first, so the ordinal will move to the first
      output
 DEPTH NOT IF
   -- take this branch: the auction is over!
   1 [VENDOR] FWD_TARGET
   -- output 1 gets the entire value of this input, and pays to
      the vendor's hardcoded scriptPubKey
   0 10000 FORWARD_PARTIAL
   0 FROMALT FORWARD_TARGET
   -- we forward at least 10k sats to output 0 (if there were 0 sats,
      the ordinal would end up in output 1 instead, which would be a
      bug), and output 0 pays to scriptPubKey "X"
   144
 ELSE .. ENDIF
   -- skip over the other branch
 CSV
   -- check that this input has baked for 144 blocks (~1 day)
 1ADD
   -- leave 145 on the stack, which is true. success!

Alternatively, if you want to increase the bid you provide a stack with
two items: your scriptPubKey and the new bid [X' V']. Execution this
time looks like:

 [X] [V] [SSS] TOALT TOALT TOALT
   -- stack contains [X' V'], altstack now contains [SSS V X]
 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
   -- this input is the first, so the ordinal will move to the first
      output
 DEPTH NOT IF ... ELSE
   -- skip over the other branch (without violating minimalif rules)
   FROMALT SWAP TUCK FROMALT
   -- stack contains [X' V' X V' V], altstack contains [SSS]
   [K] ADD GREATERTHANOREQUAL VERIFY
   -- check V' >= V+K, stack contains [X' V' X]
   1 SWAP FORWARD_TARGET
   -- output 1 pays to X (previous bidder's scriptPubKey), and the
      entire value of this input goes there; stack contains [X' V']
   DUP FORWARD_PARTIAL
   -- execute "V' FORWARD_PARTIAL", stack contains [X' V']
   0 ROT ROT
   -- stack contains [0 X' V']
   FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
   -- execute "0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE" which checks
      that output 0 spends at least V' satoshis back to the same
      script (because that's how we defined SSS), except the first
      three pushes (previously X V SSS) are replaced by X' V' SSS.
   0
 ENDIF
 CSV
   -- "0 CSV" requires nSequnce to be set, which makes the tx rbf'able,
      which hopefully makes it harder to pin
 1ADD
   -- ends with 1 on the stack; success!

(The "SSS n SSS FORWARD_LEAF_UPDATE" construct is more or less a quine,
ie a program that outputs its own source code)

I think that script is about 211 witness bytes, with an additional 40
witness bytes for X'/V', so when making a bid, your tx would be
something like:

   tx header, 10vb
   input 0: 103vb for the old bid including witness and control block
   input 1: 58vb for a taproot key path spend
   output 0: 43vb for the new bid
   output 1: 43vb for your change

for a total of about 257vb -- slightly larger than a regular 2-in-2-out
transaction, but not terribly much. Mostly because input 0 doesn't require
a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,
and the script code twice, along with a little extra to encode the
various numbers (10000, 144, K, V, V').

This approach seems pretty "MEV" resistant: you pay fees via input 1 if
your bid succeeds; if it doesn't, you don't pay any fees. A potential
scalper might want to put in an early low ball bid, then prevent
higher bidders from winning the auction, take control of the ordinal,
and resell it later, but unless they can prevent another miner from
mining alternative bids for 144 blocks, they will fail at that. The bid
is fixed by the bidder and committed to by the signature on input 1, so
frontrunning a bid can't do anything beyond invalidate the bid entirely.

Obviously, this is a pretty limited auction mechanism in various ways;
eg maybe you'd rather specify K as a percentage than an absoute increment;
maybe you'd like to have the auction definitely finish by some particular
time; maybe you'd like to be able to have the auction be able to continue
above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction
rather than an english auction. I think you can probably do all those
things with this set of opcodes and clever scripting, though it probably
gets ugly.

I don't think this is easily extensible to taro or rgb style assets,
as rather than being able to ensure the asset is transferred by
controlling the input/output positions, I think you'd need to build
up merkle trees and do point tweaks beyond what's supported by
OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like
OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals
either.

Cheers,
aj

[0] https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki

[1] https://twitter.com/jamesob/status/1639019107432513537

[2] https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism

[3] Inscriptions remain a wasteful way of publishing/committing
    to content, however!

[4] https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md

[5] Setting K too low probably invites griefing, where a bidder may be
    able to use rbf pinning vectors to prevent people who would be willing
    to bid substantially higher from getting their bid confirmed on
    chain.

From zachgrw at gmail.com  Wed Mar 29 07:10:19 2023
From: zachgrw at gmail.com (Zac Greenwood)
Date: Wed, 29 Mar 2023 15:10:19 +0800
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <ZB2THW3WT2wiU7Ni@erisian.com.au>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au> <ZB2THW3WT2wiU7Ni@erisian.com.au>
Message-ID: <CAJ4-pEAyuHi-1iBzYWbpUNi2-YkxFLVBKAWTV=TyP1TVTFYMfA@mail.gmail.com>

I?m not sure why any effort should be spent on theorizing how new opcodes
might be used to facilitate parasitical use cases of the blockchain.

If anything, business models relying on the ability to abuse the blockchain
as a data store must be made less feasible, not more.

Zac


On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev
> wrote:
> > I think there are perhaps four opcodes that are interesting in this
> class:
> >
> >    idx sPK OP_FORWARD_TARGET
> >      -- sends the value to a particular output (given by idx), and
> >         requires that output have a particular scriptPubKey (given
> >         by sPK).
> >
> >    idx [...] n script OP_FORWARD_LEAF_UPDATE
> >      -- sends the value to a particular output (given by idx), and
> >       requires that output to have almost the same scriptPubKey as this
> >       input, _except_ that the current leaf is replaced by "script",
> >       with that script prefixed by "n" pushes (of values given by [...])
> >
> >    idx OP_FORWARD_SELF
> >      -- sends the value to a particular output (given by idx), and
> >         requires that output to have the same scriptPubKey as this input
> >
> >    amt OP_FORWARD_PARTIAL
> >      -- modifies the next OP_FORWARD_* opcode to only affect "amt",
> >         rather than the entire balance. opcodes after that affect the
> >       remaining balance, after "amt" has been subtracted. if "amt" is
> >       0, the next OP_FORWARD_* becomes a no-op.
>
> The BIP 345 draft has been updated [0] [1] and now pretty much defines
> OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,
> and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite
> that, for this email I'm going to continue using the OP_FORWARD_*
> naming convention.
>
> Given the recent controversy over the Yuga labs ordinal auction [2],
> perhaps it's interesting to consider that these proposed opcodes come
> close to making it possible to do a fair, non-custodial, on-chain auction
> of ordinals [3].
>
> The idea here is that you create a utxo on chain that contains the ordinal
> in question, which commits to the address of the current leading bidder,
> and can be spent in two ways:
>
>   1) it can be updated to a new bidder, if the bid is raised by at least
>      K satoshis, in which case the previous bidder is refunded their
>      bid; or,
>
>   2) if there have been no new bids for a day, the current high bidder
>      wins, and the ordinal is moved to their address, while the funds
>      from their winning bid are sent to the original vendor's address.
>
> I believe this can be implemented in script as follows,
> assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),
> OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),
> and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])
> are all available.
>
> First, figure out the parameters:
>
>  * Set VENDOR to the scriptPubKey corresponding to the vendor's address.
>  * Set K to the minimum bid increment [5].
>  * Initially, set X equal to VENDOR.
>  * Initially, set V to just below the reserve price (V+K is the
>    minimum initial bid).
>
> Then construct the following script:
>
>  [X] [V] [SSS] TOALT TOALT TOALT
>  0 PUSHCURRENTINPUTINDEX EQUALVERIFY
>  DEPTH NOT IF
>    0 10000 FORWARD_PARTIAL
>    0 FROMALT FORWARD_TARGET
>    1 [VENDOR] FWD_TARGET
>    144
>  ELSE
>    FROMALT SWAP TUCK FROMALT
>    [K] ADD GREATERTHANOREQUAL VERIFY
>    1 SWAP FORWARD_TARGET
>    DUP FORWARD_PARTIAL
>    0 ROT ROT
>    FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
>    0
>  ENDIF
>  CSV
>  1ADD
>
> where "SSS" is a pushdata of the rest of the script ("TOALT TOALT TOALT
> .. 1ADD").
>
> Finally, make that script the sole tapleaf, accompanied by a NUMS point
> as the internal public key, calculate the taproot address corresponding
> to that, and send the ordinal to that address as the first satoshi.
>
> There are two ways to spend that script. With an empty witness stack,
> the following will be executed:
>
>  [X] [V] [SSS] TOALT TOALT TOALT
>    -- altstack now contains [SSS V X]
>  0 PUSHCURRENTINPUTINDEX EQUALVERIFY
>    -- this input is the first, so the ordinal will move to the first
>       output
>  DEPTH NOT IF
>    -- take this branch: the auction is over!
>    1 [VENDOR] FWD_TARGET
>    -- output 1 gets the entire value of this input, and pays to
>       the vendor's hardcoded scriptPubKey
>    0 10000 FORWARD_PARTIAL
>    0 FROMALT FORWARD_TARGET
>    -- we forward at least 10k sats to output 0 (if there were 0 sats,
>       the ordinal would end up in output 1 instead, which would be a
>       bug), and output 0 pays to scriptPubKey "X"
>    144
>  ELSE .. ENDIF
>    -- skip over the other branch
>  CSV
>    -- check that this input has baked for 144 blocks (~1 day)
>  1ADD
>    -- leave 145 on the stack, which is true. success!
>
> Alternatively, if you want to increase the bid you provide a stack with
> two items: your scriptPubKey and the new bid [X' V']. Execution this
> time looks like:
>
>  [X] [V] [SSS] TOALT TOALT TOALT
>    -- stack contains [X' V'], altstack now contains [SSS V X]
>  0 PUSHCURRENTINPUTINDEX EQUALVERIFY
>    -- this input is the first, so the ordinal will move to the first
>       output
>  DEPTH NOT IF ... ELSE
>    -- skip over the other branch (without violating minimalif rules)
>    FROMALT SWAP TUCK FROMALT
>    -- stack contains [X' V' X V' V], altstack contains [SSS]
>    [K] ADD GREATERTHANOREQUAL VERIFY
>    -- check V' >= V+K, stack contains [X' V' X]
>    1 SWAP FORWARD_TARGET
>    -- output 1 pays to X (previous bidder's scriptPubKey), and the
>       entire value of this input goes there; stack contains [X' V']
>    DUP FORWARD_PARTIAL
>    -- execute "V' FORWARD_PARTIAL", stack contains [X' V']
>    0 ROT ROT
>    -- stack contains [0 X' V']
>    FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
>    -- execute "0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE" which checks
>       that output 0 spends at least V' satoshis back to the same
>       script (because that's how we defined SSS), except the first
>       three pushes (previously X V SSS) are replaced by X' V' SSS.
>    0
>  ENDIF
>  CSV
>    -- "0 CSV" requires nSequnce to be set, which makes the tx rbf'able,
>       which hopefully makes it harder to pin
>  1ADD
>    -- ends with 1 on the stack; success!
>
> (The "SSS n SSS FORWARD_LEAF_UPDATE" construct is more or less a quine,
> ie a program that outputs its own source code)
>
> I think that script is about 211 witness bytes, with an additional 40
> witness bytes for X'/V', so when making a bid, your tx would be
> something like:
>
>    tx header, 10vb
>    input 0: 103vb for the old bid including witness and control block
>    input 1: 58vb for a taproot key path spend
>    output 0: 43vb for the new bid
>    output 1: 43vb for your change
>
> for a total of about 257vb -- slightly larger than a regular 2-in-2-out
> transaction, but not terribly much. Mostly because input 0 doesn't require
> a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,
> and the script code twice, along with a little extra to encode the
> various numbers (10000, 144, K, V, V').
>
> This approach seems pretty "MEV" resistant: you pay fees via input 1 if
> your bid succeeds; if it doesn't, you don't pay any fees. A potential
> scalper might want to put in an early low ball bid, then prevent
> higher bidders from winning the auction, take control of the ordinal,
> and resell it later, but unless they can prevent another miner from
> mining alternative bids for 144 blocks, they will fail at that. The bid
> is fixed by the bidder and committed to by the signature on input 1, so
> frontrunning a bid can't do anything beyond invalidate the bid entirely.
>
> Obviously, this is a pretty limited auction mechanism in various ways;
> eg maybe you'd rather specify K as a percentage than an absoute increment;
> maybe you'd like to have the auction definitely finish by some particular
> time; maybe you'd like to be able to have the auction be able to continue
> above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction
> rather than an english auction. I think you can probably do all those
> things with this set of opcodes and clever scripting, though it probably
> gets ugly.
>
> I don't think this is easily extensible to taro or rgb style assets,
> as rather than being able to ensure the asset is transferred by
> controlling the input/output positions, I think you'd need to build
> up merkle trees and do point tweaks beyond what's supported by
> OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like
> OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals
> either.
>
> Cheers,
> aj
>
> [0]
> https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki
>
> [1] https://twitter.com/jamesob/status/1639019107432513537
>
> [2]
> https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism
>
> [3] Inscriptions remain a wasteful way of publishing/committing
>     to content, however!
>
> [4]
> https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md
>
> [5] Setting K too low probably invites griefing, where a bidder may be
>     able to use rbf pinning vectors to prevent people who would be willing
>     to bid substantially higher from getting their bid confirmed on
>     chain.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230329/66e43c91/attachment.html>

From alicexbt at protonmail.com  Wed Mar 29 19:57:08 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Wed, 29 Mar 2023 19:57:08 +0000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAJ4-pEAyuHi-1iBzYWbpUNi2-YkxFLVBKAWTV=TyP1TVTFYMfA@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au> <ZB2THW3WT2wiU7Ni@erisian.com.au>
 <CAJ4-pEAyuHi-1iBzYWbpUNi2-YkxFLVBKAWTV=TyP1TVTFYMfA@mail.gmail.com>
Message-ID: <C4SV8-jdNABNgVA8aE8Du6WITwynrcq9st7wkSN4k6Px4zhWKWZdSlAvYhTLRXe3yDMC5uNhRNoMGAdMqKReVYUjr-0dGGv9H2u2L9v7gtY=@protonmail.com>

Hi Zac,

Let me share what those parasites achieved:

- Fees paid: 150 BTC
- Lot of users and developers trying bitcoin that either never tried or gave up early in 2013-15
- Mempools of nodes of being busy on weekends and got lots of transactions
- PSBT became cool and application devs are trying their best to use it in different ways
- Some developers exploring taproot and multisig
- AJ shared things how covenants could help in fair, non-custodial, on-chain auction of ordinals that is MEV resistant although I had shared it earlier which involves more steps: https://twitter.com/1440000bytes/status/1634368411760476161
- Investors exploring about funding projects
- Bitcoin more than Bitcoin and people excited about it 

We can have difference of opinion, however I want bitcoin to be money and money means different things for people in this world. Please respect that else it will become like Linux, something used by 1% of world. 

/dev/fd0
floppy disk guy

Sent with Proton Mail secure email.

------- Original Message -------
On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:


> I?m not sure why any effort should be spent on theorizing how new opcodes might be used to facilitate parasitical use cases of the blockchain.
>
> If anything, business models relying on the ability to abuse the blockchain as a data store must be made less feasible, not more.
>
> Zac
>
>
> On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev wrote:
> > > I think there are perhaps four opcodes that are interesting in this class:
> > >
> > > idx sPK OP_FORWARD_TARGET
> > > -- sends the value to a particular output (given by idx), and
> > > requires that output have a particular scriptPubKey (given
> > > by sPK).
> > >
> > > idx [...] n script OP_FORWARD_LEAF_UPDATE
> > > -- sends the value to a particular output (given by idx), and
> > > requires that output to have almost the same scriptPubKey as this
> > > input, _except_ that the current leaf is replaced by "script",
> > > with that script prefixed by "n" pushes (of values given by [...])
> > >
> > > idx OP_FORWARD_SELF
> > > -- sends the value to a particular output (given by idx), and
> > > requires that output to have the same scriptPubKey as this input
> > >
> > > amt OP_FORWARD_PARTIAL
> > > -- modifies the next OP_FORWARD_* opcode to only affect "amt",
> > > rather than the entire balance. opcodes after that affect the
> > > remaining balance, after "amt" has been subtracted. if "amt" is
> > > 0, the next OP_FORWARD_* becomes a no-op.
> >
> > The BIP 345 draft has been updated [0] [1] and now pretty much defines
> > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,
> > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite
> > that, for this email I'm going to continue using the OP_FORWARD_*
> > naming convention.
> >
> > Given the recent controversy over the Yuga labs ordinal auction [2],
> > perhaps it's interesting to consider that these proposed opcodes come
> > close to making it possible to do a fair, non-custodial, on-chain auction
> > of ordinals [3].
> >
> > The idea here is that you create a utxo on chain that contains the ordinal
> > in question, which commits to the address of the current leading bidder,
> > and can be spent in two ways:
> >
> > 1) it can be updated to a new bidder, if the bid is raised by at least
> > K satoshis, in which case the previous bidder is refunded their
> > bid; or,
> >
> > 2) if there have been no new bids for a day, the current high bidder
> > wins, and the ordinal is moved to their address, while the funds
> > from their winning bid are sent to the original vendor's address.
> >
> > I believe this can be implemented in script as follows,
> > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),
> > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),
> > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])
> > are all available.
> >
> > First, figure out the parameters:
> >
> > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.
> > * Set K to the minimum bid increment [5].
> > * Initially, set X equal to VENDOR.
> > * Initially, set V to just below the reserve price (V+K is the
> > minimum initial bid).
> >
> > Then construct the following script:
> >
> > [X] [V] [SSS] TOALT TOALT TOALT
> > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > DEPTH NOT IF
> > 0 10000 FORWARD_PARTIAL
> > 0 FROMALT FORWARD_TARGET
> > 1 [VENDOR] FWD_TARGET
> > 144
> > ELSE
> > FROMALT SWAP TUCK FROMALT
> > [K] ADD GREATERTHANOREQUAL VERIFY
> > 1 SWAP FORWARD_TARGET
> > DUP FORWARD_PARTIAL
> > 0 ROT ROT
> > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > 0
> > ENDIF
> > CSV
> > 1ADD
> >
> > where "SSS" is a pushdata of the rest of the script ("TOALT TOALT TOALT
> > .. 1ADD").
> >
> > Finally, make that script the sole tapleaf, accompanied by a NUMS point
> > as the internal public key, calculate the taproot address corresponding
> > to that, and send the ordinal to that address as the first satoshi.
> >
> > There are two ways to spend that script. With an empty witness stack,
> > the following will be executed:
> >
> > [X] [V] [SSS] TOALT TOALT TOALT
> > -- altstack now contains [SSS V X]
> > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > -- this input is the first, so the ordinal will move to the first
> > output
> > DEPTH NOT IF
> > -- take this branch: the auction is over!
> > 1 [VENDOR] FWD_TARGET
> > -- output 1 gets the entire value of this input, and pays to
> > the vendor's hardcoded scriptPubKey
> > 0 10000 FORWARD_PARTIAL
> > 0 FROMALT FORWARD_TARGET
> > -- we forward at least 10k sats to output 0 (if there were 0 sats,
> > the ordinal would end up in output 1 instead, which would be a
> > bug), and output 0 pays to scriptPubKey "X"
> > 144
> > ELSE .. ENDIF
> > -- skip over the other branch
> > CSV
> > -- check that this input has baked for 144 blocks (~1 day)
> > 1ADD
> > -- leave 145 on the stack, which is true. success!
> >
> > Alternatively, if you want to increase the bid you provide a stack with
> > two items: your scriptPubKey and the new bid [X' V']. Execution this
> > time looks like:
> >
> > [X] [V] [SSS] TOALT TOALT TOALT
> > -- stack contains [X' V'], altstack now contains [SSS V X]
> > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > -- this input is the first, so the ordinal will move to the first
> > output
> > DEPTH NOT IF ... ELSE
> > -- skip over the other branch (without violating minimalif rules)
> > FROMALT SWAP TUCK FROMALT
> > -- stack contains [X' V' X V' V], altstack contains [SSS]
> > [K] ADD GREATERTHANOREQUAL VERIFY
> > -- check V' >= V+K, stack contains [X' V' X]
> > 1 SWAP FORWARD_TARGET
> > -- output 1 pays to X (previous bidder's scriptPubKey), and the
> > entire value of this input goes there; stack contains [X' V']
> > DUP FORWARD_PARTIAL
> > -- execute "V' FORWARD_PARTIAL", stack contains [X' V']
> > 0 ROT ROT
> > -- stack contains [0 X' V']
> > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > -- execute "0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE" which checks
> > that output 0 spends at least V' satoshis back to the same
> > script (because that's how we defined SSS), except the first
> > three pushes (previously X V SSS) are replaced by X' V' SSS.
> > 0
> > ENDIF
> > CSV
> > -- "0 CSV" requires nSequnce to be set, which makes the tx rbf'able,
> > which hopefully makes it harder to pin
> > 1ADD
> > -- ends with 1 on the stack; success!
> >
> > (The "SSS n SSS FORWARD_LEAF_UPDATE" construct is more or less a quine,
> > ie a program that outputs its own source code)
> >
> > I think that script is about 211 witness bytes, with an additional 40
> > witness bytes for X'/V', so when making a bid, your tx would be
> > something like:
> >
> > tx header, 10vb
> > input 0: 103vb for the old bid including witness and control block
> > input 1: 58vb for a taproot key path spend
> > output 0: 43vb for the new bid
> > output 1: 43vb for your change
> >
> > for a total of about 257vb -- slightly larger than a regular 2-in-2-out
> > transaction, but not terribly much. Mostly because input 0 doesn't require
> > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,
> > and the script code twice, along with a little extra to encode the
> > various numbers (10000, 144, K, V, V').
> >
> > This approach seems pretty "MEV" resistant: you pay fees via input 1 if
> > your bid succeeds; if it doesn't, you don't pay any fees. A potential
> > scalper might want to put in an early low ball bid, then prevent
> > higher bidders from winning the auction, take control of the ordinal,
> > and resell it later, but unless they can prevent another miner from
> > mining alternative bids for 144 blocks, they will fail at that. The bid
> > is fixed by the bidder and committed to by the signature on input 1, so
> > frontrunning a bid can't do anything beyond invalidate the bid entirely.
> >
> > Obviously, this is a pretty limited auction mechanism in various ways;
> > eg maybe you'd rather specify K as a percentage than an absoute increment;
> > maybe you'd like to have the auction definitely finish by some particular
> > time; maybe you'd like to be able to have the auction be able to continue
> > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction
> > rather than an english auction. I think you can probably do all those
> > things with this set of opcodes and clever scripting, though it probably
> > gets ugly.
> >
> > I don't think this is easily extensible to taro or rgb style assets,
> > as rather than being able to ensure the asset is transferred by
> > controlling the input/output positions, I think you'd need to build
> > up merkle trees and do point tweaks beyond what's supported by
> > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like
> > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals
> > either.
> >
> > Cheers,
> > aj
> >
> > [0] https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki
> >
> > [1] https://twitter.com/jamesob/status/1639019107432513537
> >
> > [2] https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism
> >
> > [3] Inscriptions remain a wasteful way of publishing/committing
> > to content, however!
> >
> > [4] https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md
> >
> > [5] Setting K too low probably invites griefing, where a bidder may be
> > able to use rbf pinning vectors to prevent people who would be willing
> > to bid substantially higher from getting their bid confirmed on
> > chain.
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From steven.j.lee at gmail.com  Thu Mar 30 00:16:43 2023
From: steven.j.lee at gmail.com (Steve Lee)
Date: Wed, 29 Mar 2023 17:16:43 -0700
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <C4SV8-jdNABNgVA8aE8Du6WITwynrcq9st7wkSN4k6Px4zhWKWZdSlAvYhTLRXe3yDMC5uNhRNoMGAdMqKReVYUjr-0dGGv9H2u2L9v7gtY=@protonmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au> <ZB2THW3WT2wiU7Ni@erisian.com.au>
 <CAJ4-pEAyuHi-1iBzYWbpUNi2-YkxFLVBKAWTV=TyP1TVTFYMfA@mail.gmail.com>
 <C4SV8-jdNABNgVA8aE8Du6WITwynrcq9st7wkSN4k6Px4zhWKWZdSlAvYhTLRXe3yDMC5uNhRNoMGAdMqKReVYUjr-0dGGv9H2u2L9v7gtY=@protonmail.com>
Message-ID: <CABu3BAdL-FRMkfqVY+y=JUX7VGSL4RZt8hP_LhE9hYytaS8rmw@mail.gmail.com>

"want bitcoin to be money and money means different things for people in
this world"

I think we can all agree that a property of money is fungibility, and by
its very definition NFTs are not fungible and thus not money.

On Wed, Mar 29, 2023 at 4:56?PM alicexbt via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi Zac,
>
> Let me share what those parasites achieved:
>
> - Fees paid: 150 BTC
> - Lot of users and developers trying bitcoin that either never tried or
> gave up early in 2013-15
> - Mempools of nodes of being busy on weekends and got lots of transactions
> - PSBT became cool and application devs are trying their best to use it in
> different ways
> - Some developers exploring taproot and multisig
> - AJ shared things how covenants could help in fair, non-custodial,
> on-chain auction of ordinals that is MEV resistant although I had shared it
> earlier which involves more steps:
> https://twitter.com/1440000bytes/status/1634368411760476161
> - Investors exploring about funding projects
> - Bitcoin more than Bitcoin and people excited about it
>
> We can have difference of opinion, however I want bitcoin to be money and
> money means different things for people in this world. Please respect that
> else it will become like Linux, something used by 1% of world.
>
> /dev/fd0
> floppy disk guy
>
> Sent with Proton Mail secure email.
>
> ------- Original Message -------
> On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
> > I?m not sure why any effort should be spent on theorizing how new
> opcodes might be used to facilitate parasitical use cases of the blockchain.
> >
> > If anything, business models relying on the ability to abuse the
> blockchain as a data store must be made less feasible, not more.
> >
> > Zac
> >
> >
> > On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via
> bitcoin-dev wrote:
> > > > I think there are perhaps four opcodes that are interesting in this
> class:
> > > >
> > > > idx sPK OP_FORWARD_TARGET
> > > > -- sends the value to a particular output (given by idx), and
> > > > requires that output have a particular scriptPubKey (given
> > > > by sPK).
> > > >
> > > > idx [...] n script OP_FORWARD_LEAF_UPDATE
> > > > -- sends the value to a particular output (given by idx), and
> > > > requires that output to have almost the same scriptPubKey as this
> > > > input, _except_ that the current leaf is replaced by "script",
> > > > with that script prefixed by "n" pushes (of values given by [...])
> > > >
> > > > idx OP_FORWARD_SELF
> > > > -- sends the value to a particular output (given by idx), and
> > > > requires that output to have the same scriptPubKey as this input
> > > >
> > > > amt OP_FORWARD_PARTIAL
> > > > -- modifies the next OP_FORWARD_* opcode to only affect "amt",
> > > > rather than the entire balance. opcodes after that affect the
> > > > remaining balance, after "amt" has been subtracted. if "amt" is
> > > > 0, the next OP_FORWARD_* becomes a no-op.
> > >
> > > The BIP 345 draft has been updated [0] [1] and now pretty much defines
> > > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE
> above,
> > > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite
> > > that, for this email I'm going to continue using the OP_FORWARD_*
> > > naming convention.
> > >
> > > Given the recent controversy over the Yuga labs ordinal auction [2],
> > > perhaps it's interesting to consider that these proposed opcodes come
> > > close to making it possible to do a fair, non-custodial, on-chain
> auction
> > > of ordinals [3].
> > >
> > > The idea here is that you create a utxo on chain that contains the
> ordinal
> > > in question, which commits to the address of the current leading
> bidder,
> > > and can be spent in two ways:
> > >
> > > 1) it can be updated to a new bidder, if the bid is raised by at least
> > > K satoshis, in which case the previous bidder is refunded their
> > > bid; or,
> > >
> > > 2) if there have been no new bids for a day, the current high bidder
> > > wins, and the ordinal is moved to their address, while the funds
> > > from their winning bid are sent to the original vendor's address.
> > >
> > > I believe this can be implemented in script as follows,
> > > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),
> > > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced
> above),
> > > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])
> > > are all available.
> > >
> > > First, figure out the parameters:
> > >
> > > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.
> > > * Set K to the minimum bid increment [5].
> > > * Initially, set X equal to VENDOR.
> > > * Initially, set V to just below the reserve price (V+K is the
> > > minimum initial bid).
> > >
> > > Then construct the following script:
> > >
> > > [X] [V] [SSS] TOALT TOALT TOALT
> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > DEPTH NOT IF
> > > 0 10000 FORWARD_PARTIAL
> > > 0 FROMALT FORWARD_TARGET
> > > 1 [VENDOR] FWD_TARGET
> > > 144
> > > ELSE
> > > FROMALT SWAP TUCK FROMALT
> > > [K] ADD GREATERTHANOREQUAL VERIFY
> > > 1 SWAP FORWARD_TARGET
> > > DUP FORWARD_PARTIAL
> > > 0 ROT ROT
> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > > 0
> > > ENDIF
> > > CSV
> > > 1ADD
> > >
> > > where "SSS" is a pushdata of the rest of the script ("TOALT TOALT TOALT
> > > .. 1ADD").
> > >
> > > Finally, make that script the sole tapleaf, accompanied by a NUMS point
> > > as the internal public key, calculate the taproot address corresponding
> > > to that, and send the ordinal to that address as the first satoshi.
> > >
> > > There are two ways to spend that script. With an empty witness stack,
> > > the following will be executed:
> > >
> > > [X] [V] [SSS] TOALT TOALT TOALT
> > > -- altstack now contains [SSS V X]
> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > -- this input is the first, so the ordinal will move to the first
> > > output
> > > DEPTH NOT IF
> > > -- take this branch: the auction is over!
> > > 1 [VENDOR] FWD_TARGET
> > > -- output 1 gets the entire value of this input, and pays to
> > > the vendor's hardcoded scriptPubKey
> > > 0 10000 FORWARD_PARTIAL
> > > 0 FROMALT FORWARD_TARGET
> > > -- we forward at least 10k sats to output 0 (if there were 0 sats,
> > > the ordinal would end up in output 1 instead, which would be a
> > > bug), and output 0 pays to scriptPubKey "X"
> > > 144
> > > ELSE .. ENDIF
> > > -- skip over the other branch
> > > CSV
> > > -- check that this input has baked for 144 blocks (~1 day)
> > > 1ADD
> > > -- leave 145 on the stack, which is true. success!
> > >
> > > Alternatively, if you want to increase the bid you provide a stack with
> > > two items: your scriptPubKey and the new bid [X' V']. Execution this
> > > time looks like:
> > >
> > > [X] [V] [SSS] TOALT TOALT TOALT
> > > -- stack contains [X' V'], altstack now contains [SSS V X]
> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > -- this input is the first, so the ordinal will move to the first
> > > output
> > > DEPTH NOT IF ... ELSE
> > > -- skip over the other branch (without violating minimalif rules)
> > > FROMALT SWAP TUCK FROMALT
> > > -- stack contains [X' V' X V' V], altstack contains [SSS]
> > > [K] ADD GREATERTHANOREQUAL VERIFY
> > > -- check V' >= V+K, stack contains [X' V' X]
> > > 1 SWAP FORWARD_TARGET
> > > -- output 1 pays to X (previous bidder's scriptPubKey), and the
> > > entire value of this input goes there; stack contains [X' V']
> > > DUP FORWARD_PARTIAL
> > > -- execute "V' FORWARD_PARTIAL", stack contains [X' V']
> > > 0 ROT ROT
> > > -- stack contains [0 X' V']
> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > > -- execute "0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE" which checks
> > > that output 0 spends at least V' satoshis back to the same
> > > script (because that's how we defined SSS), except the first
> > > three pushes (previously X V SSS) are replaced by X' V' SSS.
> > > 0
> > > ENDIF
> > > CSV
> > > -- "0 CSV" requires nSequnce to be set, which makes the tx rbf'able,
> > > which hopefully makes it harder to pin
> > > 1ADD
> > > -- ends with 1 on the stack; success!
> > >
> > > (The "SSS n SSS FORWARD_LEAF_UPDATE" construct is more or less a quine,
> > > ie a program that outputs its own source code)
> > >
> > > I think that script is about 211 witness bytes, with an additional 40
> > > witness bytes for X'/V', so when making a bid, your tx would be
> > > something like:
> > >
> > > tx header, 10vb
> > > input 0: 103vb for the old bid including witness and control block
> > > input 1: 58vb for a taproot key path spend
> > > output 0: 43vb for the new bid
> > > output 1: 43vb for your change
> > >
> > > for a total of about 257vb -- slightly larger than a regular 2-in-2-out
> > > transaction, but not terribly much. Mostly because input 0 doesn't
> require
> > > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,
> > > and the script code twice, along with a little extra to encode the
> > > various numbers (10000, 144, K, V, V').
> > >
> > > This approach seems pretty "MEV" resistant: you pay fees via input 1 if
> > > your bid succeeds; if it doesn't, you don't pay any fees. A potential
> > > scalper might want to put in an early low ball bid, then prevent
> > > higher bidders from winning the auction, take control of the ordinal,
> > > and resell it later, but unless they can prevent another miner from
> > > mining alternative bids for 144 blocks, they will fail at that. The bid
> > > is fixed by the bidder and committed to by the signature on input 1, so
> > > frontrunning a bid can't do anything beyond invalidate the bid
> entirely.
> > >
> > > Obviously, this is a pretty limited auction mechanism in various ways;
> > > eg maybe you'd rather specify K as a percentage than an absoute
> increment;
> > > maybe you'd like to have the auction definitely finish by some
> particular
> > > time; maybe you'd like to be able to have the auction be able to
> continue
> > > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction
> > > rather than an english auction. I think you can probably do all those
> > > things with this set of opcodes and clever scripting, though it
> probably
> > > gets ugly.
> > >
> > > I don't think this is easily extensible to taro or rgb style assets,
> > > as rather than being able to ensure the asset is transferred by
> > > controlling the input/output positions, I think you'd need to build
> > > up merkle trees and do point tweaks beyond what's supported by
> > > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like
> > > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals
> > > either.
> > >
> > > Cheers,
> > > aj
> > >
> > > [0]
> https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki
> > >
> > > [1] https://twitter.com/jamesob/status/1639019107432513537
> > >
> > > [2]
> https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism
> > >
> > > [3] Inscriptions remain a wasteful way of publishing/committing
> > > to content, however!
> > >
> > > [4]
> https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md
> > >
> > > [5] Setting K too low probably invites griefing, where a bidder may be
> > > able to use rbf pinning vectors to prevent people who would be willing
> > > to bid substantially higher from getting their bid confirmed on
> > > chain.
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230329/6f8c48f0/attachment-0001.html>

From zachgrw at gmail.com  Thu Mar 30 10:39:40 2023
From: zachgrw at gmail.com (Zac Greenwood)
Date: Thu, 30 Mar 2023 18:39:40 +0800
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <C4SV8-jdNABNgVA8aE8Du6WITwynrcq9st7wkSN4k6Px4zhWKWZdSlAvYhTLRXe3yDMC5uNhRNoMGAdMqKReVYUjr-0dGGv9H2u2L9v7gtY=@protonmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au> <ZB2THW3WT2wiU7Ni@erisian.com.au>
 <CAJ4-pEAyuHi-1iBzYWbpUNi2-YkxFLVBKAWTV=TyP1TVTFYMfA@mail.gmail.com>
 <C4SV8-jdNABNgVA8aE8Du6WITwynrcq9st7wkSN4k6Px4zhWKWZdSlAvYhTLRXe3yDMC5uNhRNoMGAdMqKReVYUjr-0dGGv9H2u2L9v7gtY=@protonmail.com>
Message-ID: <CAJ4-pEDq7kqLR9bAguShazdH6H92Y-pgNsOdEuqj=HaTWom88w@mail.gmail.com>

Hi alicexbtc,

Under no circumstance should Bitcoin add any functionality intended to
support private businesses that rely on on-chain storage for their business
model.

Regarding ?Fees paid: 150 BTC? (uh, *citation needed*):

To optimize for profitability a business would generally attempt to operate
using zero- or low-fee transactions. Therefore they tend to contribute
 comparatively little fees but are depriving public use of these cheap
transactions. Worse, they exert a constant upward pressure on fee levels,
making it more expensive for everyone else to transact.

Unlike miners, node operators do not receive any compensation. They however
incur additional cost for bandwidth, electricity and processing time to not
only support some current business but all businesses in the past that ever
tried to turn a profit at their expense, so also after such business failed
and has been long gone. They foot the bill.

Lastly, I don?t believe there is any value in having for instance Ordinals
spam the blockchain with images of wojaks, bored apes and other crap but
perhaps you wish to clarify why this might be something to be ?excited
about?.

Your other arguments are nonsensical so excuse me for ignoring them.


Zac


On Thu, 30 Mar 2023 at 03:57, alicexbt <alicexbt at protonmail.com> wrote:

> Hi Zac,
>
> Let me share what those parasites achieved:
>
> - Fees paid: 150 BTC
> - Lot of users and developers trying bitcoin that either never tried or
> gave up early in 2013-15
> - Mempools of nodes of being busy on weekends and got lots of transactions
> - PSBT became cool and application devs are trying their best to use it in
> different ways
> - Some developers exploring taproot and multisig
> - AJ shared things how covenants could help in fair, non-custodial,
> on-chain auction of ordinals that is MEV resistant although I had shared it
> earlier which involves more steps:
> https://twitter.com/1440000bytes/status/1634368411760476161
> - Investors exploring about funding projects
> - Bitcoin more than Bitcoin and people excited about it
>
> We can have difference of opinion, however I want bitcoin to be money and
> money means different things for people in this world. Please respect that
> else it will become like Linux, something used by 1% of world.
>
> /dev/fd0
> floppy disk guy
>
> Sent with Proton Mail secure email.
>
> ------- Original Message -------
> On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
> > I?m not sure why any effort should be spent on theorizing how new
> opcodes might be used to facilitate parasitical use cases of the blockchain.
> >
> > If anything, business models relying on the ability to abuse the
> blockchain as a data store must be made less feasible, not more.
> >
> > Zac
> >
> >
> > On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
> >
> > > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via
> bitcoin-dev wrote:
> > > > I think there are perhaps four opcodes that are interesting in this
> class:
> > > >
> > > > idx sPK OP_FORWARD_TARGET
> > > > -- sends the value to a particular output (given by idx), and
> > > > requires that output have a particular scriptPubKey (given
> > > > by sPK).
> > > >
> > > > idx [...] n script OP_FORWARD_LEAF_UPDATE
> > > > -- sends the value to a particular output (given by idx), and
> > > > requires that output to have almost the same scriptPubKey as this
> > > > input, _except_ that the current leaf is replaced by "script",
> > > > with that script prefixed by "n" pushes (of values given by [...])
> > > >
> > > > idx OP_FORWARD_SELF
> > > > -- sends the value to a particular output (given by idx), and
> > > > requires that output to have the same scriptPubKey as this input
> > > >
> > > > amt OP_FORWARD_PARTIAL
> > > > -- modifies the next OP_FORWARD_* opcode to only affect "amt",
> > > > rather than the entire balance. opcodes after that affect the
> > > > remaining balance, after "amt" has been subtracted. if "amt" is
> > > > 0, the next OP_FORWARD_* becomes a no-op.
> > >
> > > The BIP 345 draft has been updated [0] [1] and now pretty much defines
> > > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE
> above,
> > > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite
> > > that, for this email I'm going to continue using the OP_FORWARD_*
> > > naming convention.
> > >
> > > Given the recent controversy over the Yuga labs ordinal auction [2],
> > > perhaps it's interesting to consider that these proposed opcodes come
> > > close to making it possible to do a fair, non-custodial, on-chain
> auction
> > > of ordinals [3].
> > >
> > > The idea here is that you create a utxo on chain that contains the
> ordinal
> > > in question, which commits to the address of the current leading
> bidder,
> > > and can be spent in two ways:
> > >
> > > 1) it can be updated to a new bidder, if the bid is raised by at least
> > > K satoshis, in which case the previous bidder is refunded their
> > > bid; or,
> > >
> > > 2) if there have been no new bids for a day, the current high bidder
> > > wins, and the ordinal is moved to their address, while the funds
> > > from their winning bid are sent to the original vendor's address.
> > >
> > > I believe this can be implemented in script as follows,
> > > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),
> > > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced
> above),
> > > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])
> > > are all available.
> > >
> > > First, figure out the parameters:
> > >
> > > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.
> > > * Set K to the minimum bid increment [5].
> > > * Initially, set X equal to VENDOR.
> > > * Initially, set V to just below the reserve price (V+K is the
> > > minimum initial bid).
> > >
> > > Then construct the following script:
> > >
> > > [X] [V] [SSS] TOALT TOALT TOALT
> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > DEPTH NOT IF
> > > 0 10000 FORWARD_PARTIAL
> > > 0 FROMALT FORWARD_TARGET
> > > 1 [VENDOR] FWD_TARGET
> > > 144
> > > ELSE
> > > FROMALT SWAP TUCK FROMALT
> > > [K] ADD GREATERTHANOREQUAL VERIFY
> > > 1 SWAP FORWARD_TARGET
> > > DUP FORWARD_PARTIAL
> > > 0 ROT ROT
> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > > 0
> > > ENDIF
> > > CSV
> > > 1ADD
> > >
> > > where "SSS" is a pushdata of the rest of the script ("TOALT TOALT TOALT
> > > .. 1ADD").
> > >
> > > Finally, make that script the sole tapleaf, accompanied by a NUMS point
> > > as the internal public key, calculate the taproot address corresponding
> > > to that, and send the ordinal to that address as the first satoshi.
> > >
> > > There are two ways to spend that script. With an empty witness stack,
> > > the following will be executed:
> > >
> > > [X] [V] [SSS] TOALT TOALT TOALT
> > > -- altstack now contains [SSS V X]
> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > -- this input is the first, so the ordinal will move to the first
> > > output
> > > DEPTH NOT IF
> > > -- take this branch: the auction is over!
> > > 1 [VENDOR] FWD_TARGET
> > > -- output 1 gets the entire value of this input, and pays to
> > > the vendor's hardcoded scriptPubKey
> > > 0 10000 FORWARD_PARTIAL
> > > 0 FROMALT FORWARD_TARGET
> > > -- we forward at least 10k sats to output 0 (if there were 0 sats,
> > > the ordinal would end up in output 1 instead, which would be a
> > > bug), and output 0 pays to scriptPubKey "X"
> > > 144
> > > ELSE .. ENDIF
> > > -- skip over the other branch
> > > CSV
> > > -- check that this input has baked for 144 blocks (~1 day)
> > > 1ADD
> > > -- leave 145 on the stack, which is true. success!
> > >
> > > Alternatively, if you want to increase the bid you provide a stack with
> > > two items: your scriptPubKey and the new bid [X' V']. Execution this
> > > time looks like:
> > >
> > > [X] [V] [SSS] TOALT TOALT TOALT
> > > -- stack contains [X' V'], altstack now contains [SSS V X]
> > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > -- this input is the first, so the ordinal will move to the first
> > > output
> > > DEPTH NOT IF ... ELSE
> > > -- skip over the other branch (without violating minimalif rules)
> > > FROMALT SWAP TUCK FROMALT
> > > -- stack contains [X' V' X V' V], altstack contains [SSS]
> > > [K] ADD GREATERTHANOREQUAL VERIFY
> > > -- check V' >= V+K, stack contains [X' V' X]
> > > 1 SWAP FORWARD_TARGET
> > > -- output 1 pays to X (previous bidder's scriptPubKey), and the
> > > entire value of this input goes there; stack contains [X' V']
> > > DUP FORWARD_PARTIAL
> > > -- execute "V' FORWARD_PARTIAL", stack contains [X' V']
> > > 0 ROT ROT
> > > -- stack contains [0 X' V']
> > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > > -- execute "0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE" which checks
> > > that output 0 spends at least V' satoshis back to the same
> > > script (because that's how we defined SSS), except the first
> > > three pushes (previously X V SSS) are replaced by X' V' SSS.
> > > 0
> > > ENDIF
> > > CSV
> > > -- "0 CSV" requires nSequnce to be set, which makes the tx rbf'able,
> > > which hopefully makes it harder to pin
> > > 1ADD
> > > -- ends with 1 on the stack; success!
> > >
> > > (The "SSS n SSS FORWARD_LEAF_UPDATE" construct is more or less a quine,
> > > ie a program that outputs its own source code)
> > >
> > > I think that script is about 211 witness bytes, with an additional 40
> > > witness bytes for X'/V', so when making a bid, your tx would be
> > > something like:
> > >
> > > tx header, 10vb
> > > input 0: 103vb for the old bid including witness and control block
> > > input 1: 58vb for a taproot key path spend
> > > output 0: 43vb for the new bid
> > > output 1: 43vb for your change
> > >
> > > for a total of about 257vb -- slightly larger than a regular 2-in-2-out
> > > transaction, but not terribly much. Mostly because input 0 doesn't
> require
> > > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,
> > > and the script code twice, along with a little extra to encode the
> > > various numbers (10000, 144, K, V, V').
> > >
> > > This approach seems pretty "MEV" resistant: you pay fees via input 1 if
> > > your bid succeeds; if it doesn't, you don't pay any fees. A potential
> > > scalper might want to put in an early low ball bid, then prevent
> > > higher bidders from winning the auction, take control of the ordinal,
> > > and resell it later, but unless they can prevent another miner from
> > > mining alternative bids for 144 blocks, they will fail at that. The bid
> > > is fixed by the bidder and committed to by the signature on input 1, so
> > > frontrunning a bid can't do anything beyond invalidate the bid
> entirely.
> > >
> > > Obviously, this is a pretty limited auction mechanism in various ways;
> > > eg maybe you'd rather specify K as a percentage than an absoute
> increment;
> > > maybe you'd like to have the auction definitely finish by some
> particular
> > > time; maybe you'd like to be able to have the auction be able to
> continue
> > > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction
> > > rather than an english auction. I think you can probably do all those
> > > things with this set of opcodes and clever scripting, though it
> probably
> > > gets ugly.
> > >
> > > I don't think this is easily extensible to taro or rgb style assets,
> > > as rather than being able to ensure the asset is transferred by
> > > controlling the input/output positions, I think you'd need to build
> > > up merkle trees and do point tweaks beyond what's supported by
> > > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like
> > > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals
> > > either.
> > >
> > > Cheers,
> > > aj
> > >
> > > [0]
> https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki
> > >
> > > [1] https://twitter.com/jamesob/status/1639019107432513537
> > >
> > > [2]
> https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism
> > >
> > > [3] Inscriptions remain a wasteful way of publishing/committing
> > > to content, however!
> > >
> > > [4]
> https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md
> > >
> > > [5] Setting K too low probably invites griefing, where a bidder may be
> > > able to use rbf pinning vectors to prevent people who would be willing
> > > to bid substantially higher from getting their bid confirmed on
> > > chain.
> > > _______________________________________________
> > > bitcoin-dev mailing list
> > > bitcoin-dev at lists.linuxfoundation.org
> > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20230330/00fa836d/attachment-0001.html>

From alicexbt at protonmail.com  Thu Mar 30 18:12:46 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Thu, 30 Mar 2023 18:12:46 +0000
Subject: [bitcoin-dev] BIP for OP_VAULT
In-Reply-To: <CAJ4-pEDq7kqLR9bAguShazdH6H92Y-pgNsOdEuqj=HaTWom88w@mail.gmail.com>
References: <CAPfvXfJQKb7i8GBvTEvTTz-3dU_5mH8jOv8Nm4Q8gPt=KxrqLQ@mail.gmail.com>
 <CAB3F3DveCDz6yy-rd3ttV8+4sMufsvB+9J-qVK95yh9aLYX+Mw@mail.gmail.com>
 <ZAAqIZZO1KK32Th9@erisian.com.au>
 <CAB3F3DtGpVHkyT_=KLS42rvdP=dgnMvChhR1Rs0BHO5yOEabmw@mail.gmail.com>
 <CAPfvXf+4iX0h-nSuyTai_VvJHkDvAyKtgSk6DsaEwE8N3wnYEg@mail.gmail.com>
 <ZAcx7oEZxC9BiWvg@erisian.com.au> <ZB2THW3WT2wiU7Ni@erisian.com.au>
 <CAJ4-pEAyuHi-1iBzYWbpUNi2-YkxFLVBKAWTV=TyP1TVTFYMfA@mail.gmail.com>
 <C4SV8-jdNABNgVA8aE8Du6WITwynrcq9st7wkSN4k6Px4zhWKWZdSlAvYhTLRXe3yDMC5uNhRNoMGAdMqKReVYUjr-0dGGv9H2u2L9v7gtY=@protonmail.com>
 <CAJ4-pEDq7kqLR9bAguShazdH6H92Y-pgNsOdEuqj=HaTWom88w@mail.gmail.com>
Message-ID: <v7l8qpYTrt0POXPCeN4FJIDtZnItd8u7Gs9qd3FKiVoduEXfisATmmRA0SfYAKFR0mzZFY8-4zgzA0R2dJqIW4p_gXchZMECoY9I_-6fX6w=@protonmail.com>

Hi Zac,

> Regarding ?Fees paid: 150 BTC? (uh, *citation needed*):

https://dune.com/queries/2008613/3326984

> Your other arguments are nonsensical so excuse me for ignoring them.

There were zero browser extensions that could sign PSBT to be used in different bitcoin projects that have web interface earlier. Now there are several open source extensions that could be used to sign PSBT. If such development and interest by developers from other chains to build things on bitcoin makes no sense to you that there is nothing much to debate here.

Humans have inscribed things on money since thousands of years when bitcoin didn't even exist. Trying to fight this and going against market wont work.

I do not agree with other things mentioned in your email.

/dev/fd0
floppy disk guy

Sent with Proton Mail secure email.

------- Original Message -------
On Thursday, March 30th, 2023 at 4:09 PM, Zac Greenwood <zachgrw at gmail.com> wrote:


> Hi alicexbtc,
> 
> Under no circumstance should Bitcoin add any functionality intended to support private businesses that rely on on-chain storage for their business model.
> 
> Regarding ?Fees paid: 150 BTC? (uh, *citation needed*):
> 
> To optimize for profitability a business would generally attempt to operate using zero- or low-fee transactions. Therefore they tend to contribute comparatively little fees but are depriving public use of these cheap transactions. Worse, they exert a constant upward pressure on fee levels, making it more expensive for everyone else to transact.
> 
> Unlike miners, node operators do not receive any compensation. They however incur additional cost for bandwidth, electricity and processing time to not only support some current business but all businesses in the past that ever tried to turn a profit at their expense, so also after such business failed and has been long gone. They foot the bill.
> 
> Lastly, I don?t believe there is any value in having for instance Ordinals spam the blockchain with images of wojaks, bored apes and other crap but perhaps you wish to clarify why this might be something to be ?excited about?.
> 
> Your other arguments are nonsensical so excuse me for ignoring them.
> 
> 
> Zac
> 
> 
> On Thu, 30 Mar 2023 at 03:57, alicexbt <alicexbt at protonmail.com> wrote:
> 
> > Hi Zac,
> > 
> > Let me share what those parasites achieved:
> > 
> > - Fees paid: 150 BTC
> > - Lot of users and developers trying bitcoin that either never tried or gave up early in 2013-15
> > - Mempools of nodes of being busy on weekends and got lots of transactions
> > - PSBT became cool and application devs are trying their best to use it in different ways
> > - Some developers exploring taproot and multisig
> > - AJ shared things how covenants could help in fair, non-custodial, on-chain auction of ordinals that is MEV resistant although I had shared it earlier which involves more steps: https://twitter.com/1440000bytes/status/1634368411760476161
> > - Investors exploring about funding projects
> > - Bitcoin more than Bitcoin and people excited about it
> > 
> > We can have difference of opinion, however I want bitcoin to be money and money means different things for people in this world. Please respect that else it will become like Linux, something used by 1% of world.
> > 
> > /dev/fd0
> > floppy disk guy
> > 
> > Sent with Proton Mail secure email.
> > 
> > ------- Original Message -------
> > On Wednesday, March 29th, 2023 at 12:40 PM, Zac Greenwood via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > 
> > 
> > > I?m not sure why any effort should be spent on theorizing how new opcodes might be used to facilitate parasitical use cases of the blockchain.
> > >
> > > If anything, business models relying on the ability to abuse the blockchain as a data store must be made less feasible, not more.
> > >
> > > Zac
> > >
> > >
> > > On Fri, 24 Mar 2023 at 20:10, Anthony Towns via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > >
> > > > On Tue, Mar 07, 2023 at 10:45:34PM +1000, Anthony Towns via bitcoin-dev wrote:
> > > > > I think there are perhaps four opcodes that are interesting in this class:
> > > > >
> > > > > idx sPK OP_FORWARD_TARGET
> > > > > -- sends the value to a particular output (given by idx), and
> > > > > requires that output have a particular scriptPubKey (given
> > > > > by sPK).
> > > > >
> > > > > idx [...] n script OP_FORWARD_LEAF_UPDATE
> > > > > -- sends the value to a particular output (given by idx), and
> > > > > requires that output to have almost the same scriptPubKey as this
> > > > > input, _except_ that the current leaf is replaced by "script",
> > > > > with that script prefixed by "n" pushes (of values given by [...])
> > > > >
> > > > > idx OP_FORWARD_SELF
> > > > > -- sends the value to a particular output (given by idx), and
> > > > > requires that output to have the same scriptPubKey as this input
> > > > >
> > > > > amt OP_FORWARD_PARTIAL
> > > > > -- modifies the next OP_FORWARD_* opcode to only affect "amt",
> > > > > rather than the entire balance. opcodes after that affect the
> > > > > remaining balance, after "amt" has been subtracted. if "amt" is
> > > > > 0, the next OP_FORWARD_* becomes a no-op.
> > > >
> > > > The BIP 345 draft has been updated [0] [1] and now pretty much defines
> > > > OP_VAULT to have the behaviour specced for OP_FORWARD_LEAF_UPDATE above,
> > > > and OP_VAULT_RECOVER to behave as OP_FORWARD_TARGET above. Despite
> > > > that, for this email I'm going to continue using the OP_FORWARD_*
> > > > naming convention.
> > > >
> > > > Given the recent controversy over the Yuga labs ordinal auction [2],
> > > > perhaps it's interesting to consider that these proposed opcodes come
> > > > close to making it possible to do a fair, non-custodial, on-chain auction
> > > > of ordinals [3].
> > > >
> > > > The idea here is that you create a utxo on chain that contains the ordinal
> > > > in question, which commits to the address of the current leading bidder,
> > > > and can be spent in two ways:
> > > >
> > > > 1) it can be updated to a new bidder, if the bid is raised by at least
> > > > K satoshis, in which case the previous bidder is refunded their
> > > > bid; or,
> > > >
> > > > 2) if there have been no new bids for a day, the current high bidder
> > > > wins, and the ordinal is moved to their address, while the funds
> > > > from their winning bid are sent to the original vendor's address.
> > > >
> > > > I believe this can be implemented in script as follows,
> > > > assuming the opcodes OP_FORWARD_TARGET(OP_VAULT_RECOVER),
> > > > OP_FORWARD_LEAF_UPDATE(OP_VAULT), OP_FORWARD_PARTIAL (as specced above),
> > > > and OP_PUSHCURRENTINPUTINDEX (as implemented in liquid/elements [4])
> > > > are all available.
> > > >
> > > > First, figure out the parameters:
> > > >
> > > > * Set VENDOR to the scriptPubKey corresponding to the vendor's address.
> > > > * Set K to the minimum bid increment [5].
> > > > * Initially, set X equal to VENDOR.
> > > > * Initially, set V to just below the reserve price (V+K is the
> > > > minimum initial bid).
> > > >
> > > > Then construct the following script:
> > > >
> > > > [X] [V] [SSS] TOALT TOALT TOALT
> > > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > > DEPTH NOT IF
> > > > 0 10000 FORWARD_PARTIAL
> > > > 0 FROMALT FORWARD_TARGET
> > > > 1 [VENDOR] FWD_TARGET
> > > > 144
> > > > ELSE
> > > > FROMALT SWAP TUCK FROMALT
> > > > [K] ADD GREATERTHANOREQUAL VERIFY
> > > > 1 SWAP FORWARD_TARGET
> > > > DUP FORWARD_PARTIAL
> > > > 0 ROT ROT
> > > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > > > 0
> > > > ENDIF
> > > > CSV
> > > > 1ADD
> > > >
> > > > where "SSS" is a pushdata of the rest of the script ("TOALT TOALT TOALT
> > > > .. 1ADD").
> > > >
> > > > Finally, make that script the sole tapleaf, accompanied by a NUMS point
> > > > as the internal public key, calculate the taproot address corresponding
> > > > to that, and send the ordinal to that address as the first satoshi.
> > > >
> > > > There are two ways to spend that script. With an empty witness stack,
> > > > the following will be executed:
> > > >
> > > > [X] [V] [SSS] TOALT TOALT TOALT
> > > > -- altstack now contains [SSS V X]
> > > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > > -- this input is the first, so the ordinal will move to the first
> > > > output
> > > > DEPTH NOT IF
> > > > -- take this branch: the auction is over!
> > > > 1 [VENDOR] FWD_TARGET
> > > > -- output 1 gets the entire value of this input, and pays to
> > > > the vendor's hardcoded scriptPubKey
> > > > 0 10000 FORWARD_PARTIAL
> > > > 0 FROMALT FORWARD_TARGET
> > > > -- we forward at least 10k sats to output 0 (if there were 0 sats,
> > > > the ordinal would end up in output 1 instead, which would be a
> > > > bug), and output 0 pays to scriptPubKey "X"
> > > > 144
> > > > ELSE .. ENDIF
> > > > -- skip over the other branch
> > > > CSV
> > > > -- check that this input has baked for 144 blocks (~1 day)
> > > > 1ADD
> > > > -- leave 145 on the stack, which is true. success!
> > > >
> > > > Alternatively, if you want to increase the bid you provide a stack with
> > > > two items: your scriptPubKey and the new bid [X' V']. Execution this
> > > > time looks like:
> > > >
> > > > [X] [V] [SSS] TOALT TOALT TOALT
> > > > -- stack contains [X' V'], altstack now contains [SSS V X]
> > > > 0 PUSHCURRENTINPUTINDEX EQUALVERIFY
> > > > -- this input is the first, so the ordinal will move to the first
> > > > output
> > > > DEPTH NOT IF ... ELSE
> > > > -- skip over the other branch (without violating minimalif rules)
> > > > FROMALT SWAP TUCK FROMALT
> > > > -- stack contains [X' V' X V' V], altstack contains [SSS]
> > > > [K] ADD GREATERTHANOREQUAL VERIFY
> > > > -- check V' >= V+K, stack contains [X' V' X]
> > > > 1 SWAP FORWARD_TARGET
> > > > -- output 1 pays to X (previous bidder's scriptPubKey), and the
> > > > entire value of this input goes there; stack contains [X' V']
> > > > DUP FORWARD_PARTIAL
> > > > -- execute "V' FORWARD_PARTIAL", stack contains [X' V']
> > > > 0 ROT ROT
> > > > -- stack contains [0 X' V']
> > > > FROMALT DUP 3 SWAP FORWARD_LEAF_UPDATE
> > > > -- execute "0 X' V' SSS 3 SSS FORWARD_LEAF_UPDATE" which checks
> > > > that output 0 spends at least V' satoshis back to the same
> > > > script (because that's how we defined SSS), except the first
> > > > three pushes (previously X V SSS) are replaced by X' V' SSS.
> > > > 0
> > > > ENDIF
> > > > CSV
> > > > -- "0 CSV" requires nSequnce to be set, which makes the tx rbf'able,
> > > > which hopefully makes it harder to pin
> > > > 1ADD
> > > > -- ends with 1 on the stack; success!
> > > >
> > > > (The "SSS n SSS FORWARD_LEAF_UPDATE" construct is more or less a quine,
> > > > ie a program that outputs its own source code)
> > > >
> > > > I think that script is about 211 witness bytes, with an additional 40
> > > > witness bytes for X'/V', so when making a bid, your tx would be
> > > > something like:
> > > >
> > > > tx header, 10vb
> > > > input 0: 103vb for the old bid including witness and control block
> > > > input 1: 58vb for a taproot key path spend
> > > > output 0: 43vb for the new bid
> > > > output 1: 43vb for your change
> > > >
> > > > for a total of about 257vb -- slightly larger than a regular 2-in-2-out
> > > > transaction, but not terribly much. Mostly because input 0 doesn't require
> > > > a signature -- it's size is effectively 6 pubkeys: X, X' VENDOR twice,
> > > > and the script code twice, along with a little extra to encode the
> > > > various numbers (10000, 144, K, V, V').
> > > >
> > > > This approach seems pretty "MEV" resistant: you pay fees via input 1 if
> > > > your bid succeeds; if it doesn't, you don't pay any fees. A potential
> > > > scalper might want to put in an early low ball bid, then prevent
> > > > higher bidders from winning the auction, take control of the ordinal,
> > > > and resell it later, but unless they can prevent another miner from
> > > > mining alternative bids for 144 blocks, they will fail at that. The bid
> > > > is fixed by the bidder and committed to by the signature on input 1, so
> > > > frontrunning a bid can't do anything beyond invalidate the bid entirely.
> > > >
> > > > Obviously, this is a pretty limited auction mechanism in various ways;
> > > > eg maybe you'd rather specify K as a percentage than an absoute increment;
> > > > maybe you'd like to have the auction definitely finish by some particular
> > > > time; maybe you'd like to be able to have the auction be able to continue
> > > > above 21.47 BTC (2**31 sats); maybe you'd like to do a dutch auction
> > > > rather than an english auction. I think you can probably do all those
> > > > things with this set of opcodes and clever scripting, though it probably
> > > > gets ugly.
> > > >
> > > > I don't think this is easily extensible to taro or rgb style assets,
> > > > as rather than being able to ensure the asset is transferred by
> > > > controlling the input/output positions, I think you'd need to build
> > > > up merkle trees and do point tweaks beyond what's supported by
> > > > OP_FORWARD_LEAF_UPDATE/OP_VAULT. Of course, without something like
> > > > OP_PUSHCURRENTINPUTINDEX I don't think you could do it for ordinals
> > > > either.
> > > >
> > > > Cheers,
> > > > aj
> > > >
> > > > [0] https://github.com/bitcoin/bips/blob/7f747fba82675f28c239df690a07b75529bd0960/bip-0345.mediawiki
> > > >
> > > > [1] https://twitter.com/jamesob/status/1639019107432513537
> > > >
> > > > [2] https://cointelegraph.com/news/scammers-dream-yuga-s-auction-model-for-bitcoin-nfts-sees-criticism
> > > >
> > > > [3] Inscriptions remain a wasteful way of publishing/committing
> > > > to content, however!
> > > >
> > > > [4] https://github.com/ElementsProject/elements/blob/master/doc/tapscript_opcodes.md
> > > >
> > > > [5] Setting K too low probably invites griefing, where a bidder may be
> > > > able to use rbf pinning vectors to prevent people who would be willing
> > > > to bid substantially higher from getting their bid confirmed on
> > > > chain.
> > > > _______________________________________________
> > > > bitcoin-dev mailing list
> > > > bitcoin-dev at lists.linuxfoundation.org
> > > > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From alicexbt at protonmail.com  Fri Mar 31 16:30:30 2023
From: alicexbt at protonmail.com (alicexbt)
Date: Fri, 31 Mar 2023 16:30:30 +0000
Subject: [bitcoin-dev] Bitcoin fungibility and inscribed sats
Message-ID: <wyXXD1BZceMCXR615QrExupwRaoFETSfIu2Vq63XjlNDVJ20P7fo-HI8wr9rDrGqaZXox-0NCQUZm7voK4TZ0aV2ujY43faxcsb0Rcjy_Dg=@protonmail.com>

Hi Steve and Bitcoin Developers,

I have created a new thread as requested by one of the developers. I respect him and the readers of this list.

> "want bitcoin to be money and money means different things for people in
this world"

> I think we can all agree that a property of money is fungibility, and by
its very definition NFTs are not fungible and thus not money.

Inscriptions do not affect fungibility of bitcoin:

- There is no token standard being used. These are just sats being considered as inscription in an external protocol or explorer. Bitcoin nodes do not consider them as something special.
- Users can always sell those inscribed sats or UTXO as normal bitcoin on bisq or any exchange.
- They can use different amounts for it using tools like https://raritygarden.inscribetheplanet.com/ which is created by super testnet who is active dev in bitcoin and ln.
- Inscribed sats are different from Ethereum tokens because they will never go to zero and you can always consolidate lot of them to use as normal bitcoin.

Bitcoin fungibility is anyways debatable and I cannot change anything about it even though working on a coinjoin implmentation as some post mix UTXOs are censored on some exchanges and its easy to identify them. Some coinjoin implementation themselves work with chain analysis companies to censor inputs used for rounds.

Ordinals theory is a parallel universe in which some users believe in and they have been trying to learn how bitcoin works. Example: I did call with someone this evening to explain how PSBT and multisig works who never used bitcoin before

Developers are interested to build things and they have tried to create BIP, DEX, look for libraries, ask questions, projects implementing PSBT etc.

I do not live in first world country and do not attend bitdevs but always wanted bitcoin to be here. I have tried my best but failed. Please let people do what they want with bitcoin without changing consensus rules. It will help Bitcoin.

/dev/fd0
floppy disk guy


Sent with Proton Mail secure email.

