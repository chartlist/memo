From eric at voskuil.org  Tue Dec  1 01:06:13 2020
From: eric at voskuil.org (eric at voskuil.org)
Date: Mon, 30 Nov 2020 17:06:13 -0800
Subject: [bitcoin-dev] Out-of-band transaction fees
In-Reply-To: <9a068476-855e-0dd7-4c9c-264d5d8bf60a@gnet.me>
References: <9a068476-855e-0dd7-4c9c-264d5d8bf60a@gnet.me>
Message-ID: <00e301d6c77e$2a4eeab0$7eecc010$@voskuil.org>

Hi Sebastian,

It's important to consider here that anonymity is the reason fees are incorporated into transactions. One must generally trust the party with whom one transacts. But since integral fees are paid to any miner, this does not apply to fees. In paying fees externally one must find another way to associate a fee with its transaction. This of course increases the possibility of taint, as you describe in part here:

> Miners that included a transaction need a way to authenticate when claiming the bounty.

It is also the case that the "bounty" must be associated with the transaction. Even with miner and payer mutual anonymity, the fee inputs and outputs will be associated with the transaction inputs and outputs by the miner, rendering the proposal counterproductive.

Total transaction sizing is not reduced by paying fees externally, in fact it would be increased. The only possible reduction would come from aggregation of fees. Yet it is not clear how that aggregation would occur privately in less overall block space. At least with integral fees, it's *possible* to spend and pay a fee with a single input and output. That is not the case with externalized fees.

e

-----Original Message-----
From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On Behalf Of Sebastian Geisler via bitcoin-dev
Sent: Monday, November 30, 2020 3:03 PM
To: bitcoin-dev at lists.linuxfoundation.org
Subject: [bitcoin-dev] Out-of-band transaction fees

Hi all,

the possibility of out of band transaction fee payments is a well known fact. Yet it has been mostly discussed as an annoying inevitability that can be problematic if on-chain fees are to be used as a consensus parameter. The potential use cases have seen little interest though (please correct me if I'm wrong).

One such use case is sending UTXOs "intact". Let's assume we get to a point where Bitcoin is primarily a settlement layer for L2 systems.
These L2 systems might want to protect their privacy and keep UTXOs of a common sizes (e.g. 1 BTC, 10 BTC, ?). For certain settlement applications these can be transferred as a whole, but currently fee requirements force the system to add another input for fees which will introduce taint (because it's used repeatedly). If instead a fee could be paid out of band in a privacy preserving way the TXO chain would leak little about the intermediate holders.

Taking this concept even further CoinJoin-like protocols could also be used to introduce further ambiguity without leaking that a certain entity took part in the CJ (which fee inputs/reused "toxic waste"
inevitably do afaik). Such a mechanism would probably also make CJ transactions much smaller as _no_ fee inputs had to be provided (assuming the inputs already have the right size).

Out-of-band transaction "accelerators" already exist and taking fee payment out-of-band can not be effectively prevented. So even though any such proposal will probably have slight centralizing effects I believe that having a standard for it is preferable to having every pool implement their own API making it harder for small pools to get into the market.

Imo the central questions are:
 * how to build such a out-of-band "transaction bounty" system
 * how to standardized it
 * how can the centralizing effects from it be mitigated

Imo fees are small enough to not really care about counter party risk that much. It's more important that it is easy to run so that there is some choice for users and miners. In that sense I consider single-operator services providing both standardized user and miner APIs as well as an optional UI suitable. I would still take into account that this could change and might consider the needs of federated services in the protocol.

Each such service would need to announce which means of payment it supports and allow users and miners to choose when paying/redeeming fees. Users should be able to submit transactions and either be presented with a single payment method dependent "invoice" or one per input (for the CoinJoin use case). As soon as all invoices are paid the bounty goes live and is visible to miners through an API.

Miners that included a transaction need a way to authenticate when claiming the bounty. One possibility would be to optionally include a unique public key e.g. in the coinbase scriptsig after the height push (is this feasible?). This could be used to claim any bounties after 100, 120, or even a user-defined confirmation threshold is met. If the key is unique for every block there won't be a problem with pool accountability which might become a risk down the road (so this should also be enforced at least in the bounty protocol to avoid lazy implementations leading to dangerous precedents).

Any feedback is welcome :)

tl;dr Out-of-band fee payment services are inevitable and useful, so we should at least standardize them and mitigate negative effects as much as possible.

Best,
Sebastian

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From sebastian at gnet.me  Tue Dec  1 14:19:56 2020
From: sebastian at gnet.me (Sebastian Geisler)
Date: Tue, 01 Dec 2020 14:19:56 +0000
Subject: [bitcoin-dev] Out-of-band transaction fees
In-Reply-To: <00e301d6c77e$2a4eeab0$7eecc010$@voskuil.org>
References: <9a068476-855e-0dd7-4c9c-264d5d8bf60a@gnet.me>
 <00e301d6c77e$2a4eeab0$7eecc010$@voskuil.org>
Message-ID: <3f172428-fb03-755f-3020-43817fdb1897@gnet.me>

Hi Eric,

> In paying fees externally one must find another way to associate a fee with its transaction. This of course increases the possibility of taint, as you describe in part here:

I'm not sure I follow, do you see a problem beyond the facts that miners
would need to authenticate somehow? This can be done in a privacy
preserving way per block. I don't think transactions would need to
change in any way. The bounty-transaction link is upheld by a third
party service which the miners have to trust that it will pay out if the
transaction is included (not perfect, but a business decision they can
make).

> It is also the case that the "bounty" must be associated with the transaction. Even with miner and payer mutual anonymity, the fee inputs and outputs will be associated with the transaction inputs and outputs by the miner, rendering the proposal counterproductive.
> Total transaction sizing is not reduced by paying fees externally, in fact it would be increased. The only possible reduction would come from aggregation of fees. Yet it is not clear how that aggregation would occur privately in less overall block space. At least with integral fees, it's *possible* to spend and pay a fee with a single input and output. That is not the case with externalized fees.

I should have made this more clear, I don't imagine anyone to pay these
fees with L1 transactions, but rather some L2 system like Lightning or a
BTC backed chaumian token issued for that purpose by the bounty service
provider. Even Lightning would be far more private for the use cases I
described that don't allow fee deduction from inputs. But if one accepts
more counter party risk with e.g. some centrally pegged chaumian token
it can be anonymous.

I see that this might not be very useful today, but I imagine a future
in which Bitcoin is mostly a settlement and reserve layer. This would
make it feasible to keep most UTXOs in common sizes. Only large, round
transactions happen on-chain, the rest can happen on L2. This would
allow tumbling these already evenly-sized UTXOs on spend without toxic
waste if we can somehow tackle the fee payment problem. I know of the
following solutions:

 * everyone has to add a second UTXO per input
 * Someone is chosen fairly at random to pay the total fee
 * pay a service on L2 to add an input/output for fee payment
 * out-of-band L2 fee payments

Only L2 fee payments can hide who is involved in such a tumbling
operation as additional fee inputs that get reused would indicate the
same entity was present in two tumbling operations. The out-of-band
approach saves one input and one output and appears more general (e.g.
could be used like rbf).

This is also not a general solution for fee payments. In many cases it
will still be preferable to pay on-chain fees. But having the option to
avoid that in a standardized way could help some protocols imo.

Best,
Sebastian


> -----Original Message-----
> From: bitcoin-dev <bitcoin-dev-bounces at lists.linuxfoundation.org> On Behalf Of Sebastian Geisler via bitcoin-dev
> Sent: Monday, November 30, 2020 3:03 PM
> To: bitcoin-dev at lists.linuxfoundation.org
> Subject: [bitcoin-dev] Out-of-band transaction fees
> 
> Hi all,
> 
> the possibility of out of band transaction fee payments is a well known fact. Yet it has been mostly discussed as an annoying inevitability that can be problematic if on-chain fees are to be used as a consensus parameter. The potential use cases have seen little interest though (please correct me if I'm wrong).
> 
> One such use case is sending UTXOs "intact". Let's assume we get to a point where Bitcoin is primarily a settlement layer for L2 systems.
> These L2 systems might want to protect their privacy and keep UTXOs of a common sizes (e.g. 1 BTC, 10 BTC, ?). For certain settlement applications these can be transferred as a whole, but currently fee requirements force the system to add another input for fees which will introduce taint (because it's used repeatedly). If instead a fee could be paid out of band in a privacy preserving way the TXO chain would leak little about the intermediate holders.
> 
> Taking this concept even further CoinJoin-like protocols could also be used to introduce further ambiguity without leaking that a certain entity took part in the CJ (which fee inputs/reused "toxic waste"
> inevitably do afaik). Such a mechanism would probably also make CJ transactions much smaller as _no_ fee inputs had to be provided (assuming the inputs already have the right size).
> 
> Out-of-band transaction "accelerators" already exist and taking fee payment out-of-band can not be effectively prevented. So even though any such proposal will probably have slight centralizing effects I believe that having a standard for it is preferable to having every pool implement their own API making it harder for small pools to get into the market.
> 
> Imo the central questions are:
>  * how to build such a out-of-band "transaction bounty" system
>  * how to standardized it
>  * how can the centralizing effects from it be mitigated
> 
> Imo fees are small enough to not really care about counter party risk that much. It's more important that it is easy to run so that there is some choice for users and miners. In that sense I consider single-operator services providing both standardized user and miner APIs as well as an optional UI suitable. I would still take into account that this could change and might consider the needs of federated services in the protocol.
> 
> Each such service would need to announce which means of payment it supports and allow users and miners to choose when paying/redeeming fees. Users should be able to submit transactions and either be presented with a single payment method dependent "invoice" or one per input (for the CoinJoin use case). As soon as all invoices are paid the bounty goes live and is visible to miners through an API.
> 
> Miners that included a transaction need a way to authenticate when claiming the bounty. One possibility would be to optionally include a unique public key e.g. in the coinbase scriptsig after the height push (is this feasible?). This could be used to claim any bounties after 100, 120, or even a user-defined confirmation threshold is met. If the key is unique for every block there won't be a problem with pool accountability which might become a risk down the road (so this should also be enforced at least in the bounty protocol to avoid lazy implementations leading to dangerous precedents).
> 
> Any feedback is welcome :)
> 
> tl;dr Out-of-band fee payment services are inevitable and useful, so we should at least standardize them and mitigate negative effects as much as possible.
> 
> Best,
> Sebastian
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 


From ZmnSCPxj at protonmail.com  Tue Dec  1 15:49:49 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 01 Dec 2020 15:49:49 +0000
Subject: [bitcoin-dev] Out-of-band transaction fees
In-Reply-To: <3f172428-fb03-755f-3020-43817fdb1897@gnet.me>
References: <9a068476-855e-0dd7-4c9c-264d5d8bf60a@gnet.me>
 <00e301d6c77e$2a4eeab0$7eecc010$@voskuil.org>
 <3f172428-fb03-755f-3020-43817fdb1897@gnet.me>
Message-ID: <a_ytmG7wahHYE15SU_JER_s2dLFVpI8fRLBZTuV32QuXVOoOq2r7Dyof1tugJUFoE1bDAbYMffJ21HGNPVhh2dLGIWPkIPfEryT2Jk_sg3Y=@protonmail.com>

Good morning Sebastian and e,

> Hi Eric,
>
> > In paying fees externally one must find another way to associate a fee with its transaction. This of course increases the possibility of taint, as you describe in part here:
>
> I'm not sure I follow, do you see a problem beyond the facts that miners
> would need to authenticate somehow? This can be done in a privacy
> preserving way per block. I don't think transactions would need to
> change in any way. The bounty-transaction link is upheld by a third
> party service which the miners have to trust that it will pay out if the
> transaction is included (not perfect, but a business decision they can
> make).

There has to be an association of "how much do I get if I include *this* particular transaction" to "*this* particular transaction", so that the miners have an informed decision of how much they stand to earn.
Unless fees are also standardized, this can be used to leak the same information ("sombody offered this specific amount of money to the bounty server, and the bounty server associated this particular amount to this particular transaction").


More concerningly, [a trusted third party is hard to get out of](https://nakamotoinstitute.org/trusted-third-parties/).
If there are only a few of them, it becomes easy to co-opt, and then a part of the mining infrastructure is now controllable from central points of failure.
If there are many of them, then evaluating which ones cheat and which ones do not will take a lot of effort, and the system as a whole may not provide benefits commensurate to the overall system cost in finding good third parties.


> > It is also the case that the "bounty" must be associated with the transaction. Even with miner and payer mutual anonymity, the fee inputs and outputs will be associated with the transaction inputs and outputs by the miner, rendering the proposal counterproductive.
> > Total transaction sizing is not reduced by paying fees externally, in fact it would be increased. The only possible reduction would come from aggregation of fees. Yet it is not clear how that aggregation would occur privately in less overall block space. At least with integral fees, it's possible to spend and pay a fee with a single input and output. That is not the case with externalized fees.
>
> I should have made this more clear, I don't imagine anyone to pay these
> fees with L1 transactions, but rather some L2 system like Lightning or a
> BTC backed chaumian token issued for that purpose by the bounty service
> provider. Even Lightning would be far more private for the use cases I
> described that don't allow fee deduction from inputs. But if one accepts
> more counter party risk with e.g. some centrally pegged chaumian token
> it can be anonymous.

Since such L2 mechanisms themselves are dependent on L1 and require a facility to bump up fees for e.g. commitment transactions in Lightning Network, this brings up the possibility of getting into a bootstrapping problem, where the security of L2 is dependent on the existence of a reliable fee-bumping mechanism at L1, but the fee-bumping mechanism at L1 is dependent on the security of L2.
Not impossible, but such strange loops give me pause; I am uncertain if we have the tools to properly analyze such.

>
> I see that this might not be very useful today, but I imagine a future
> in which Bitcoin is mostly a settlement and reserve layer. This would
> make it feasible to keep most UTXOs in common sizes. Only large, round
> transactions happen on-chain, the rest can happen on L2. This would
> allow tumbling these already evenly-sized UTXOs on spend without toxic
> waste if we can somehow tackle the fee payment problem. I know of the
> following solutions:
>
> -   everyone has to add a second UTXO per input
> -   Someone is chosen fairly at random to pay the total fee
> -   pay a service on L2 to add an input/output for fee payment
> -   out-of-band L2 fee payments
>
>     Only L2 fee payments can hide who is involved in such a tumbling
>     operation as additional fee inputs that get reused would indicate the
>     same entity was present in two tumbling operations. The out-of-band
>     approach saves one input and one output and appears more general (e.g.
>     could be used like rbf).
>
>     This is also not a general solution for fee payments. In many cases it
>     will still be preferable to pay on-chain fees. But having the option to
>     avoid that in a standardized way could help some protocols imo.
>
>     Best,
>     Sebastian
>
>
> > -----Original Message-----
> > From: bitcoin-dev bitcoin-dev-bounces at lists.linuxfoundation.org On Behalf Of Sebastian Geisler via bitcoin-dev
> > Sent: Monday, November 30, 2020 3:03 PM
> > To: bitcoin-dev at lists.linuxfoundation.org
> > Subject: [bitcoin-dev] Out-of-band transaction fees
> > Hi all,
> > the possibility of out of band transaction fee payments is a well known fact. Yet it has been mostly discussed as an annoying inevitability that can be problematic if on-chain fees are to be used as a consensus parameter. The potential use cases have seen little interest though (please correct me if I'm wrong).
> > One such use case is sending UTXOs "intact". Let's assume we get to a point where Bitcoin is primarily a settlement layer for L2 systems.
> > These L2 systems might want to protect their privacy and keep UTXOs of a common sizes (e.g. 1 BTC, 10 BTC, ?). For certain settlement applications these can be transferred as a whole, but currently fee requirements force the system to add another input for fees which will introduce taint (because it's used repeatedly). If instead a fee could be paid out of band in a privacy preserving way the TXO chain would leak little about the intermediate holders.
> > Taking this concept even further CoinJoin-like protocols could also be used to introduce further ambiguity without leaking that a certain entity took part in the CJ (which fee inputs/reused "toxic waste"
> > inevitably do afaik). Such a mechanism would probably also make CJ transactions much smaller as no fee inputs had to be provided (assuming the inputs already have the right size).
> > Out-of-band transaction "accelerators" already exist and taking fee payment out-of-band can not be effectively prevented. So even though any such proposal will probably have slight centralizing effects I believe that having a standard for it is preferable to having every pool implement their own API making it harder for small pools to get into the market.
> > Imo the central questions are:
> >
> > -   how to build such a out-of-band "transaction bounty" system
> > -   how to standardized it
> > -   how can the centralizing effects from it be mitigated
> >
> > Imo fees are small enough to not really care about counter party risk that much. It's more important that it is easy to run so that there is some choice for users and miners. In that sense I consider single-operator services providing both standardized user and miner APIs as well as an optional UI suitable. I would still take into account that this could change and might consider the needs of federated services in the protocol.
> > Each such service would need to announce which means of payment it supports and allow users and miners to choose when paying/redeeming fees. Users should be able to submit transactions and either be presented with a single payment method dependent "invoice" or one per input (for the CoinJoin use case). As soon as all invoices are paid the bounty goes live and is visible to miners through an API.
> > Miners that included a transaction need a way to authenticate when claiming the bounty. One possibility would be to optionally include a unique public key e.g. in the coinbase scriptsig after the height push (is this feasible?). This could be used to claim any bounties after 100, 120, or even a user-defined confirmation threshold is met. If the key is unique for every block there won't be a problem with pool accountability which might become a risk down the road (so this should also be enforced at least in the bounty protocol to avoid lazy implementations leading to dangerous precedents).
> > Any feedback is welcome :)
> > tl;dr Out-of-band fee payment services are inevitable and useful, so we should at least standardize them and mitigate negative effects as much as possible.
> > Best,
> > Sebastian
> >
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev



From ZmnSCPxj at protonmail.com  Tue Dec  1 16:24:11 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 01 Dec 2020 16:24:11 +0000
Subject: [bitcoin-dev] Out-of-band transaction fees
In-Reply-To: <a_ytmG7wahHYE15SU_JER_s2dLFVpI8fRLBZTuV32QuXVOoOq2r7Dyof1tugJUFoE1bDAbYMffJ21HGNPVhh2dLGIWPkIPfEryT2Jk_sg3Y=@protonmail.com>
References: <9a068476-855e-0dd7-4c9c-264d5d8bf60a@gnet.me>
 <00e301d6c77e$2a4eeab0$7eecc010$@voskuil.org>
 <3f172428-fb03-755f-3020-43817fdb1897@gnet.me>
 <a_ytmG7wahHYE15SU_JER_s2dLFVpI8fRLBZTuV32QuXVOoOq2r7Dyof1tugJUFoE1bDAbYMffJ21HGNPVhh2dLGIWPkIPfEryT2Jk_sg3Y=@protonmail.com>
Message-ID: <OM9jyMUsRukofhHIun9Ij-pmypjN1OjySaKgDjlkDvUleZ13aXRxjltx8nxh_GHQbYmlp2toHhUyANMEbrk1Xp2NVOp_1a2HQcLz27oFlJA=@protonmail.com>

Good morning e, and Sebastian,

So it seems, the goals are the below:

* Someone wants to pay a fee to get a transaction confirmed.
* Miners want to know how much they earn if they confirm a transaction.
* The one paying for the fee does not want to link its other coins to the transaction it wants confirmed.

Would that be a fair restatement of the goal?

If so, it seems to me we can make a CoinJoin-like approach using only L1, and combine fees by a kind of FeeJoin.

The issue with linking is that if for example the one paying a fee to get a transaction confirmed wants to CPFP the transaction, it may need to take another UTXO it controls into the child transaction, thereby linking its "another UTXO" with the "transaction it wants confirmed".

However, if multiple such individuals were to CoinJoin their transactions, the linking becomes much harder to trace.

So a possible mechanism, with a third-party that is trusted only to keep the service running (and cannot cheat the system and abscond with the fees and leave miners without money) would be:

* The third-party service divides its service into fixed-feerate bins.
* Clients select a preferred feerate bin they want to use.
* For each client:
  * Connects to the service by Tor to register a transaction it wants to have CPFPed.
  * Connects to the service by a different Tor circuit to register a UTXO it will use to spend fees.
* The server passes through the CPFPed outputs in the whole value.
* The server deducts the fee from the fee-paying UTXO and creates an output with all the fees (CPFP output spend, UTXO input spend, CPFP output re-creation, UTXO output re-creation) deducted from the UTXO.
* The server gives the resulting transaction to the clients.
* The clients sign the transaction after checking that its interested CPFPed outputs and fee-paying UTXOs are present.

This results in a transaction with many CPFPed inputs and fee-paying UTXOs, and no easy way to link the latter with the former.

* Miners and chain analysis cannot link them, as they see only the resulting tx.
* The service cannot link them, as clients talk to them on two separate Tor connections.

The above is blatantly the Wasabi way of CoinJoining; using the JoinMarket way of CoinJoining should be possible as well, and is left as an exercise to the reader.

Now, you have mentioned a number of times that you believe Bitcoin will eventually be a settlement layer, and somehow link this with standardized UTXO sizes.
But I think the end goal should be:

* To improve Bitcoin blockchain layer privacy.

It should not matter how we achieve this, whether it involves standardized UTXO sizes or not; if you want to use this solution, you need to present a good reason why this is the best solution for Bitcoin privacy, and better than other solutions.

For example, the JoinMarket way of CoinJoining does not require any particular standardized UTXO size.
The upcoming SwapMarket that Chris Belcher is working on, also does not require such a standardized UTXO size, as it is based as well on the JoinMarket technique, where the client can select whatever sizes it wants.
Why should the Bitcoin ecosystem adopt a strict schedule of UTXO sizes for privacy, if apparently JoinMarket and SwapMarket can improve privacy without this?

Regards,
ZmnSCPxj


From sebastian at gnet.me  Tue Dec  1 19:14:26 2020
From: sebastian at gnet.me (Sebastian Geisler)
Date: Tue, 01 Dec 2020 19:14:26 +0000
Subject: [bitcoin-dev] Out-of-band transaction fees
In-Reply-To: <OM9jyMUsRukofhHIun9Ij-pmypjN1OjySaKgDjlkDvUleZ13aXRxjltx8nxh_GHQbYmlp2toHhUyANMEbrk1Xp2NVOp_1a2HQcLz27oFlJA=@protonmail.com>
References: <9a068476-855e-0dd7-4c9c-264d5d8bf60a@gnet.me>
 <00e301d6c77e$2a4eeab0$7eecc010$@voskuil.org>
 <3f172428-fb03-755f-3020-43817fdb1897@gnet.me>
 <a_ytmG7wahHYE15SU_JER_s2dLFVpI8fRLBZTuV32QuXVOoOq2r7Dyof1tugJUFoE1bDAbYMffJ21HGNPVhh2dLGIWPkIPfEryT2Jk_sg3Y=@protonmail.com>
 <OM9jyMUsRukofhHIun9Ij-pmypjN1OjySaKgDjlkDvUleZ13aXRxjltx8nxh_GHQbYmlp2toHhUyANMEbrk1Xp2NVOp_1a2HQcLz27oFlJA=@protonmail.com>
Message-ID: <d7f827f2-b56d-f439-6c27-f22b46306e36@gnet.me>

Hi ZmnSCPxj,

thank you for your detailed comments. I agree that the centralization
risk is a big problem. I didn't fully take into account how hard it
might be to distinguish honest service providers, which makes that
problem so much worse. I think I'll not pursue this approach for that
reason. While such a system can't be prevented I don't need to encourage it.

I might look into the "pay someone to add their UTXO to a tx for fees
and give them back the remainder" approach though, it doesn't seem as
hazardous and might even be possible to do in a decentralized fashion.

> Now, you have mentioned a number of times that you believe Bitcoin will eventually be a settlement layer, and somehow link this with standardized UTXO sizes.
> But I think the end goal should be:
> 
> * To improve Bitcoin blockchain layer privacy.
> 
> It should not matter how we achieve this, whether it involves standardized UTXO sizes or not; if you want to use this solution, you need to present a good reason why this is the best solution for Bitcoin privacy, and better than other solutions.

I completely agree.

> For example, the JoinMarket way of CoinJoining does not require any particular standardized UTXO size.
> The upcoming SwapMarket that Chris Belcher is working on, also does not require such a standardized UTXO size, as it is based as well on the JoinMarket technique, where the client can select whatever sizes it wants.
> Why should the Bitcoin ecosystem adopt a strict schedule of UTXO sizes for privacy, if apparently JoinMarket and SwapMarket can improve privacy without this?

These efforts are great! Yet all CoinJoin based protocols I have seen
(mostly academic ones tbh, that provide strong guarantees) have some
amount of overhead in the form of creating more UTXOs and bigger
transactions than minimally possible or even "toxic waste" we don't know
what to do with. As far as I understand it there's now way around that
without relaxing anonymity guarantees. Maybe I'm not up to date in that
regard.

I also think that the privacy properties/the actual anonymity set of
unequal output size CoinJoins (i.e. knapsack mixing) is not as well
understood as for evenly-sized output CoinJoins. If we are only talking
about user-defined CoinJoin output sizes it comes down to efficiency
again. This will nearly always lead to change and not many parties will
be interested in the particular output size so you even need to pay them
to participate.

Please bear with me as the following part is _very_ speculative:

I believe that if Bitcoin becomes mainstream (I take no stance whether
this is good or not, but consider it a possibility) transaction prices
are bound to increase dramatically, which would make such protocols
uneconomical. This also means most people will rely on some L2
technology. But the fees might even make Lightning nodes uneconomical
for the majority of people. So if we are lucky federated L2 systems, or
if we are unlucky centralized ones, will play an important role imo.

In such an environment, where on-chain transactions are mostly used as
settlements between somewhat big players, having (multiple tiers of)
evenly sized UTXOs makes a lot of sense. You don't need exact valued
transfers and get free/cheaper than free and effective mixing on spends
if you just combine your transactions.

So imo the pros of this technique are:
 * as simple as possible (easy to assess exact anonymity set)
 * cheap, so it could be made a default, leading to a large anon set

while the cons are:
 * only makes sense when exact values aren't important (e.g. L2 funding)
 * needs fee hacks

I don't want to derail this any further. I agree that my initial idea
bears too great risks of regulatory capture. While I find the
evenly-sized UTXO idea intriguing I'd be even happier about a
arbitrary-amount scheme that gives the same strong assurances in an
_efficient_ manner, I just haven't seen a way to achieve this so far.

Best,
Sebastian


From bitcoin-dev at wuille.net  Sat Dec  5 22:59:17 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Sat, 05 Dec 2020 22:59:17 +0000
Subject: [bitcoin-dev] Progress on bech32 for future Segwit Versions
	(BIP-173)
In-Reply-To: <p6i6YqXjOBastpss12gNUcJGGqomgPiLXOIyob71VptqVwJwcFwrd4m8Mad4RDnAhSyFXAZqsD67fW0kS3NayQ6k6dB-h2_V7vl7RBxmvvA=@wuille.net>
References: <87imblmutl.fsf@rustcorp.com.au>
 <p6i6YqXjOBastpss12gNUcJGGqomgPiLXOIyob71VptqVwJwcFwrd4m8Mad4RDnAhSyFXAZqsD67fW0kS3NayQ6k6dB-h2_V7vl7RBxmvvA=@wuille.net>
Message-ID: <Txf3NOgbjhU0PtTMxTd9AWNuR8WpOwramvcClf5D-vqxKbE7MT4fi1YLY-xcbC9MBr3c1AqgmHETSMhNnbu4-fZ8Lcoe23etgo05P34b0v4=@wuille.net>

> On Wednesday, October 7, 2020 5:21 PM, Rusty Russell via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > I propose an alternative to length restrictions suggested by
> > Russell in https://github.com/bitcoin/bips/pull/945: use the
> > https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb variant,
> > unless the first byte is 0.
>
> Hi all,
>
> starting a slight side-thread here.

Another update, and a longer write-up.


Introduction
------------

Bech32's checksum algorithm was designed to be strong against substitution
errors, but it also provides some protection against more general classes of
errors. The final constant M that is XOR'ed into the checksum influences that
protection. BIP173 today uses M=1, but it is now known that this has a
weakness: if the final character is a "p", any number of "q" characters can be
inserted or erased right before it, without invalidating the checksum.

As it was recognized that other constants do not have this issue, the obvious
question is whether this is the only possible type of weakness, and if not, if
there is an optimal constant to use that minimizes the largest number of
weaknesses.

Since my last mail I've realized that it is actually possible to analyse the
behavior of these final constants under a wide variety of error classes
(substitutions, deletions, insertions, swaps, duplications) programatically.
Greg Maxwell and I have used this to perform an exhaustive analysis of certain
error patterns for all 2^30 possible M values, selected a number of criteria
to optimize for, and conclude that we should use as constant:

  M = 0x2bc830a3

The code used to do this analysis, as well as the code used to verify some
expected properties of the final result, and more, can be found on
https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e

See results_final.txt to see how this constant compares with the previously
suggested constants 1, 0x3fffffff, and 0x3fefffff.

Properties
----------

If we define an error as a deletion of one position, a swap of adjacent
positions, a substitution in a specific position with a random character, an
insertion of one random character in a specific position, or a duplication of
the character in a specific position, then this M constant above gives us the
following properties:

* For generic HRPs and errors that don't affect the first 6 data characters,
  or alternatively averaged over all HRPs (see details futher):
  * Always detected:
    * (P) Up to 4 substitution errors (true for any constant).
    * (Q) Any valid code with the new constant, fed without modification to
          software that uses the old constant 1 (true for any constant).
  * Any error pattern has failure to detect probability <= 2^-30:
    * (L) Any number of errors restricted to a single window of up to 4
          characters.
    * (B) Up to two errors restricted to a window of up to 68 characters.
    * (D) Any one error made to a valid code with the new constant, and fed to
          software that uses the old constant 1
  * Most error patterns have probability <= 2^-30:
    * (C) Up to two errors in general: out of 23926796 such error patterns,
          0.0040% have probability 2^-25.
    * (N) Up to three errors restricted to a window of up to 69 characters:
          out of 284708444 such patterns, 0.033% have probability 2^-25.
    * (O) Up to three errors in general: out of 295744442 such error patterns,
          0.034% have probability 2^-25; 0.000065% have probability 2^-20.
    * (G) Up to two errors made to a valid code with the new constant, and fed
          to software that uses the old constant 1: out of 2831622 such error
          patterns, 0.048% have probability 2^-25.

* Specifically for the bc1 HRP, with the BIP173 length restrictions:
  * Always detected:
    * (R) Up to 4 substitution errors (true for any constant).
    * (A) Up to 3 substitution errors made to a valid code with the new
          constant, and fed to software that uses the old constant 1.
  * Any error pattern has failure to detect probability <= 2^-30:
    * (E) Any one error.
    * (F) Any one error made to a valid code with the new constant, and fed to
          software that uses the old constant 1.
    * (H) Up to two errors restricted to a window of 28 characters.
  * Most error patterns have probability <= 2^-30:
    * (J) Up to two errors in general: out of 455916 such error patterns,
          0.039% have probability 2^-25; 0.0053% have 2^-20.
    * (K) Any number of errors restricted to a window of 4 characters: out of
          5813139 such error patterns, 0.0016% have probability 2^-25.
    * (M) Up to three errors: out of 50713466 such error patterns, 0.078% have
          probability 2^-25; 0.00063% have 2^-20.
    * (I) Up to two errors made to a valid code with the new constant, and fed
          to software that uses the old constant 1: out of 610683 such error
          patterns, 0.092% have probability 2^-25; 0.00049% have probability
          2^-20.

To give an idea of what these probabilities mean, consider the known BIP173
insertion issue. It admits an error pattern of 1 error (insertion in
penultimate position) that has a failure to detect probability of 2^-10:
it requires the final character to be 'p', and the inserted character to be
'q'. Assuming those are both random, we have a chance of 1 in 32*32 to hit it.
Note that the choice of *what* the error pattern is (whether it's insertion,
and where) isn't part of our probabilities: we try to make sure that *every*
pattern behaves well, not just randomly chosen ones, because presumably humans
make some kinds of errors more than others, and we don't know which ones.

All the analyzed patterns above are guaranteed to be detected with probability
2^-20 or better (and most are 2^-30). Of course, if we'd search for even
larger classes of errors, say any 4 independent errors of any type, we would
probably discover patterns with worse probabilities, but at that point the
probability of the pattern itself being hit should be taken into account.

The selection was made based on these same properties:
* Start with the set of all 2^30 constants.
* The generic properties (L), (B), (D), (C), (N), (O), and (G) were selected
  for by rejecting all constants that left any worse error patterns (e.g.
  all codes for which patterns matching (N) existed with failure probability
  above 2^-25 were removed). All these restrictions are as strong as they
  can be: making them over longer strings, wider windows, or more errors with
  the same restrictions removes all remaining constants. This leaves us with
  just 12054 acceptable constants.
* The same was then done for the bc1/BIP173 specific properties (A), (E), (J),
  (F), (H), (K), (M), and (I). This reduces the set further to 79 acceptable
  constants. The full analysis output for all of these can be found in
  output.txt.
* Finally, the constant with the minimal number of worst-probability patterns
  was chosen for the generic property (N). The single constant 0x2bc830a3
  remains.
* This solution and a few of its expected properties were then validated using
  a simple program that makes random errors (see the monte_carlo.py file).


Technical details
-----------------

For the purpose of this analysis, define an "error pattern" as a starting
length (of a valid string consisting of otherwise randomly chosen characters)
combined with a sequence of the following (in this order):
* 0 or more deletions of characters at specific positions (without
  constraining what those characters are)
* 0 or more swaps of characters at specific positions with the character
  following it
* 0 or more substitutions of characters at specific positions with a uniformly
  randomly selected character
* 0 or more insertions of uniformly randomly selected characters at specific
  positions
* 0 or more duplications of characters at specific positions (including
  duplications of characters inserted/substituted in the previous steps)

Examples:
* "Start with a random valid 58 character string, remove the 17th character,
  swap the 11th character with the 12th character, and insert a random
  character in the 24th position" is an error pattern.
* "Replace the 17th through 24th characters in a 78 character string with
  'aardvark'" is not an error pattern, because substituted characters have to
  be random, and can't be specific values.

Given such a pattern, assign variable names to every input character, and to
every inserted/substituted character. For example, the pattern "Start with
a 6 character string, delete the 1st character, swap the 2nd and 3rd
character, and insert a random character between those" would be represented
as [v0 v1 v2 v3 v4 v5] and [v1 v3 v6 v2 v4 v5]. Treat these variables as
elements of GF(32), and write out the equations that both the first and second
list have a valid checksum. Due to the fact that BCH codes are linear, this is
just a linear set of equations over GF(32), and we can use Gaussian
elimination to find the size of the solution space. If the input and output
are the same length, we need to subtract the number of solutions for which the
input and output are exactly the same, which is easy to find with another set
of equations. Now compute the ratio of this number divided by (32^numvars /
32^6), where the 32^6 is due to the precondition that the input string is
valid. This gives us the probability of failure, assuming input and output are
random, apart from the known relation between the two, and the fact that both
are valid.

This technique has an important limitation: it can only reason about randomly-
chosen input strings, and the presence of the HRP and version numbers at the
start violates that assumption. These are not random, and we're forced to
make one of these concessions:
1) Ignore the problem, and treat the HRP as random. This lets us derive
   properties that hold over all potential HRPs on average, but will thus fail
   to account for the possibility that for a small numbers of potential HRPs
   some error patterns may exist that behave worse. For technical reasons,
   this averaging makes all constants behave identically for error patterns
   that don't change the length of the string. Given that substitution/swap
   only errors are already dealt with well due to the BCH design this is
   perhaps not too important. One exception is frame-shifting errors (a
   deletion in one place compensated with an insertion in another place).
2) Restrict analysis to error patterns that don't affect the first 6 actual
   characters. Doing so "masks" the effect of the HRP completely.
3) Do analysis for specific HRPs only, allowing much more accurate statements,
   but HRP-specific ones that may not hold for every HRP.

Our final selection primarily optimizes for 1) and 2) as those benefit all
potential uses of the encoding, but do optimize for 3) the "bc1" prefix
specifically (and the BIP173 length restriction) as a tiebreaker.

The code for this can be found under the link above, in const_analysis.cpp.

Cheers,

--
Pieter


From bitcoin-dev at wuille.net  Sat Dec  5 23:10:51 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Sat, 05 Dec 2020 23:10:51 +0000
Subject: [bitcoin-dev] Progress on bech32 for future Segwit Versions
	(BIP-173)
In-Reply-To: <CAMeZzJdQuS1-0qPvY+0-yqRfVXgZV_2hmHB5hZwykm5WxjUkgg@mail.gmail.com>
References: <87imblmutl.fsf@rustcorp.com.au>
 <sYf9B0e3UaSdMfdBfChon1Vr7BRFdH_6mgzuXIt_xbtlKtdqns9JJp90dRlNfvwBoRq57YEVrKbKX-dHDWz7TE0gobU4u8dGGJTcFFz2n60=@wuille.net>
 <877drn2g6q.fsf@rustcorp.com.au>
 <S6FCoLsmwaQUhrtSURemcTcG8tUWTXYkBf-0Q0hxCpObfJQ0TXNcmJrQhoqy7ttWwtGnvyS-bJ5RSXJoPizAgjuMognzVnu3SM3wMujKy88=@wuille.net>
 <878sc120f5.fsf@rustcorp.com.au> <20201020102952.4iwpugi5dxawufgo@ganymede>
 <Kw_jwhASjriebJpsuUyi0u9EQmIVR1pQ3Jocqd9VeVDlmoH9s36bFAwr3PXu_pJd-Xly-hKun_yenLwbJvVIYWmlAiF5lMxuquLO2pTmlLo=@wuille.net>
 <CAMeZzJeG00q9DPQacidto5H16Ryb6ou6tnMDK1jnAuncnVXnsA@mail.gmail.com>
 <CAMeZzJdQuS1-0qPvY+0-yqRfVXgZV_2hmHB5hZwykm5WxjUkgg@mail.gmail.com>
Message-ID: <5Zb8Vf0nq7_rg04OTJwVIY565lDZowEfBXX9IBVLIuG7lTa_sIe4BL3YbpBK2NUAZV7QasZTPHVo5J2uJoRgjj3TveBC12QEp9oTdnLis0k=@wuille.net>

On Friday, November 6, 2020 11:49 AM, Mike Schmidt via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Well I sure picked a bad couple weeks to volunteer to send a bunch of Bitcoin test transactions...
>
> While I tested less than I would have liked, there are some notable results:

I think these results really show there is no reason to try to maintain the old-software-can-send-to-future-segwit-versions property, given that more than one not just didn't support it, but actually sent coins into a black hole.

Thus, I agree with Rusty that we should change the checksum for v1+ unconditionally. That also means that old senders are protected from the insertion issue (by failing, as we can guarantee that new-checksum addresses, even after a few errors, are invalid to old software).

I've sent another mail in this thread with details, but the TL;DR is that we should use the constant M=0x2bc830a3 rather than 0x3fffffff as previous suggested. More information on https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e.

Absent objections, I'll write up a BIP soon.

Cheers,

--
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201205/32d286a4/attachment.html>

From dave at dtrt.org  Sun Dec  6 13:04:53 2020
From: dave at dtrt.org (David A. Harding)
Date: Sun, 6 Dec 2020 08:04:53 -0500
Subject: [bitcoin-dev] Progress on bech32 for future Segwit Versions
 (BIP-173)
In-Reply-To: <5Zb8Vf0nq7_rg04OTJwVIY565lDZowEfBXX9IBVLIuG7lTa_sIe4BL3YbpBK2NUAZV7QasZTPHVo5J2uJoRgjj3TveBC12QEp9oTdnLis0k=@wuille.net>
References: <87imblmutl.fsf@rustcorp.com.au>
 <sYf9B0e3UaSdMfdBfChon1Vr7BRFdH_6mgzuXIt_xbtlKtdqns9JJp90dRlNfvwBoRq57YEVrKbKX-dHDWz7TE0gobU4u8dGGJTcFFz2n60=@wuille.net>
 <877drn2g6q.fsf@rustcorp.com.au>
 <S6FCoLsmwaQUhrtSURemcTcG8tUWTXYkBf-0Q0hxCpObfJQ0TXNcmJrQhoqy7ttWwtGnvyS-bJ5RSXJoPizAgjuMognzVnu3SM3wMujKy88=@wuille.net>
 <878sc120f5.fsf@rustcorp.com.au>
 <20201020102952.4iwpugi5dxawufgo@ganymede>
 <Kw_jwhASjriebJpsuUyi0u9EQmIVR1pQ3Jocqd9VeVDlmoH9s36bFAwr3PXu_pJd-Xly-hKun_yenLwbJvVIYWmlAiF5lMxuquLO2pTmlLo=@wuille.net>
 <CAMeZzJeG00q9DPQacidto5H16Ryb6ou6tnMDK1jnAuncnVXnsA@mail.gmail.com>
 <CAMeZzJdQuS1-0qPvY+0-yqRfVXgZV_2hmHB5hZwykm5WxjUkgg@mail.gmail.com>
 <5Zb8Vf0nq7_rg04OTJwVIY565lDZowEfBXX9IBVLIuG7lTa_sIe4BL3YbpBK2NUAZV7QasZTPHVo5J2uJoRgjj3TveBC12QEp9oTdnLis0k=@wuille.net>
Message-ID: <20201206130453.tiu36iigva2jj5qn@ganymede>

On Sat, Dec 05, 2020 at 11:10:51PM +0000, Pieter Wuille via bitcoin-dev wrote:
> I think these results really show there is no reason to try to
> maintain the old-software-can-send-to-future-segwit-versions property,
> given that more than one not just didn't support it, but actually sent
> coins into a black hole.

I don't think this is a good criteria to use for making a decision.  We
shouldn't deny users of working implementations the benefit of a feature
because some other developers didn't implement it correctly.

> Thus, I agree with Rusty that we should change the checksum for v1+
> unconditionally. 

I disagreed with Rusty previously and he proposed we check to see how
disruptive an address format change would be by seeing how many wallets
already provide forward compatibility and how many would need to be
updated for taproot no matter what address format is used.  I think that
instead is a good criteria for making a decision.

I understand the results of that survey to be that only two wallets
correctly handled v1+ BIP173 addresses.  One of those wallets is Bitcoin
Core, which I personally believe will unhesitatingly update to a new
address format that's technically sound and which has widespread support
(doubly so if it's just a tweak to an already-implemented checksum
algorithm).

Given that, I also now agree with changing the checksum for v1+.

Thanks,

-Dave

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201206/415223da/attachment.sig>

From prayank at tutanota.de  Sun Dec  6 18:20:02 2020
From: prayank at tutanota.de (Prayank)
Date: Sun, 6 Dec 2020 19:20:02 +0100 (CET)
Subject: [bitcoin-dev] BIP - Automated and Secure Communication
Message-ID: <MNtH225--3-2@tutanota.de>

Hello Everyone,

I know there have been lot of controversial and heated discussions involving Samourai in past. Ignoring everything including the tweets in which Samourai team mentioned no interest in proposing a BIP related to automated and secure communication used in Soroban, I wanted to know if enough people would be interested in a BIP because it may help other bitcoin projects in future.

Tweets:?https://twitter.com/SamouraiWallet/status/1334977957157367810 <https://twitter.com/SamouraiWallet/status/1334977957157367810?s=19>

https://twitter.com/SamouraiDev/status/1335103101188104194 <https://twitter.com/SamouraiDev/status/1335103101188104194?s=19>

Ben also tweeted that a BIP would make sense:?https://twitter.com/benthecarman/status/1334977096079306753 <https://twitter.com/benthecarman/status/1334977096079306753?s=19>

I think we should keep all the controversial things aside and do everything that helps Bitcoin. It's mentioned in the medium article that it can help other projects like joinmarket, coinswap, snickr etc.

https://link.medium.com/uBvIJUSLQbb

The source code for a client library in Java is available here https://code.samourai.io/wallet/soroban-client-java and the source code for the Go based server component is available here https://code.samourai.io/wallet/samourai-soroban

Let me know if a BIP for such implementation to be used by other bitcoin projects makes sense and if anyone willing to help me in creating a BIP.

Thanks.

-- Prayank
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201206/64b59e21/attachment.html>

From yanmaani at cock.li  Sun Dec  6 19:14:13 2020
From: yanmaani at cock.li (yanmaani at cock.li)
Date: Sun, 06 Dec 2020 19:14:13 +0000
Subject: [bitcoin-dev] BIP - Automated and Secure Communication
In-Reply-To: <MNtH225--3-2@tutanota.de>
References: <MNtH225--3-2@tutanota.de>
Message-ID: <23794877f2c4b7eb69aff1fe83e41da1@cock.li>

The reason Samourai did not propose a BIP is that that was not a 
proposal to improve the Bitcoin protocol.

You could write a specification for it, but this mailing list is 
probably the wrong venue.

On 2020-12-06 18:20, Prayank via bitcoin-dev wrote:
> Hello Everyone,
> 
> I know there have been lot of controversial and heated discussions
> involving Samourai in past. Ignoring everything including the tweets
> in which Samourai team mentioned no interest in proposing a BIP
> related to automated and secure communication used in Soroban, I
> wanted to know if enough people would be interested in a BIP because
> it may help other bitcoin projects in future.
> 
> Tweets: https://twitter.com/SamouraiWallet/status/1334977957157367810
> [1]
> 
> https://twitter.com/SamouraiDev/status/1335103101188104194 [2]
> 
> Ben also tweeted that a BIP would make sense:
> https://twitter.com/benthecarman/status/1334977096079306753 [3]
> 
> I think we should keep all the controversial things aside and do
> everything that helps Bitcoin. It's mentioned in the medium article
> that it can help other projects like joinmarket, coinswap, snickr etc.
> 
> https://link.medium.com/uBvIJUSLQbb
> 
> The source code for a client library in Java is available here
> https://code.samourai.io/wallet/soroban-client-java and the source
> code for the Go based server component is available here
> https://code.samourai.io/wallet/samourai-soroban
> 
> Let me know if a BIP for such implementation to be used by other
> bitcoin projects makes sense and if anyone willing to help me in
> creating a BIP.
> 
> Thanks.
> 
> -- Prayank
> 
> Links:
> ------
> [1] https://twitter.com/SamouraiWallet/status/1334977957157367810?s=19
> [2] https://twitter.com/SamouraiDev/status/1335103101188104194?s=19
> [3] https://twitter.com/benthecarman/status/1334977096079306753?s=19
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From luke at dashjr.org  Sun Dec  6 19:36:48 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Sun, 6 Dec 2020 19:36:48 +0000
Subject: [bitcoin-dev] BIP - Automated and Secure Communication
In-Reply-To: <23794877f2c4b7eb69aff1fe83e41da1@cock.li>
References: <MNtH225--3-2@tutanota.de>
 <23794877f2c4b7eb69aff1fe83e41da1@cock.li>
Message-ID: <202012061936.49822.luke@dashjr.org>

Anything that makes sense to coordinate between different programs is BIP 
material, not just core Bitcoin protocol...


On Sunday 06 December 2020 19:14:13 yanmaani--- via bitcoin-dev wrote:
> The reason Samourai did not propose a BIP is that that was not a
> proposal to improve the Bitcoin protocol.
>
> You could write a specification for it, but this mailing list is
> probably the wrong venue.
>
> On 2020-12-06 18:20, Prayank via bitcoin-dev wrote:
> > Hello Everyone,
> >
> > I know there have been lot of controversial and heated discussions
> > involving Samourai in past. Ignoring everything including the tweets
> > in which Samourai team mentioned no interest in proposing a BIP
> > related to automated and secure communication used in Soroban, I
> > wanted to know if enough people would be interested in a BIP because
> > it may help other bitcoin projects in future.
> >
> > Tweets: https://twitter.com/SamouraiWallet/status/1334977957157367810
> > [1]
> >
> > https://twitter.com/SamouraiDev/status/1335103101188104194 [2]
> >
> > Ben also tweeted that a BIP would make sense:
> > https://twitter.com/benthecarman/status/1334977096079306753 [3]
> >
> > I think we should keep all the controversial things aside and do
> > everything that helps Bitcoin. It's mentioned in the medium article
> > that it can help other projects like joinmarket, coinswap, snickr etc.
> >
> > https://link.medium.com/uBvIJUSLQbb
> >
> > The source code for a client library in Java is available here
> > https://code.samourai.io/wallet/soroban-client-java and the source
> > code for the Go based server component is available here
> > https://code.samourai.io/wallet/samourai-soroban
> >
> > Let me know if a BIP for such implementation to be used by other
> > bitcoin projects makes sense and if anyone willing to help me in
> > creating a BIP.
> >
> > Thanks.
> >
> > -- Prayank
> >
> > Links:
> > ------
> > [1] https://twitter.com/SamouraiWallet/status/1334977957157367810?s=19
> > [2] https://twitter.com/SamouraiDev/status/1335103101188104194?s=19
> > [3] https://twitter.com/benthecarman/status/1334977096079306753?s=19
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From bitcoin-dev at wuille.net  Sun Dec  6 20:43:49 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Sun, 06 Dec 2020 20:43:49 +0000
Subject: [bitcoin-dev] Progress on bech32 for future Segwit Versions
	(BIP-173)
In-Reply-To: <20201206130453.tiu36iigva2jj5qn@ganymede>
References: <87imblmutl.fsf@rustcorp.com.au>
 <S6FCoLsmwaQUhrtSURemcTcG8tUWTXYkBf-0Q0hxCpObfJQ0TXNcmJrQhoqy7ttWwtGnvyS-bJ5RSXJoPizAgjuMognzVnu3SM3wMujKy88=@wuille.net>
 <878sc120f5.fsf@rustcorp.com.au> <20201020102952.4iwpugi5dxawufgo@ganymede>
 <Kw_jwhASjriebJpsuUyi0u9EQmIVR1pQ3Jocqd9VeVDlmoH9s36bFAwr3PXu_pJd-Xly-hKun_yenLwbJvVIYWmlAiF5lMxuquLO2pTmlLo=@wuille.net>
 <CAMeZzJeG00q9DPQacidto5H16Ryb6ou6tnMDK1jnAuncnVXnsA@mail.gmail.com>
 <CAMeZzJdQuS1-0qPvY+0-yqRfVXgZV_2hmHB5hZwykm5WxjUkgg@mail.gmail.com>
 <5Zb8Vf0nq7_rg04OTJwVIY565lDZowEfBXX9IBVLIuG7lTa_sIe4BL3YbpBK2NUAZV7QasZTPHVo5J2uJoRgjj3TveBC12QEp9oTdnLis0k=@wuille.net>
 <20201206130453.tiu36iigva2jj5qn@ganymede>
Message-ID: <vLjiyu9VKGMXcCP2wNvFG1OuYl0IBHm5DQd1WncpKgaxJFZrwdD5JKvRfT5m9Cyrf4YPvmTPbHdREZmS-msdTBlf2RMwlr2mEgZ9TFYaVRg=@wuille.net>






??????? Original Message ???????
On Sunday, December 6, 2020 5:04 AM, David A. Harding <dave at dtrt.org> wrote:

> On Sat, Dec 05, 2020 at 11:10:51PM +0000, Pieter Wuille via bitcoin-dev wrote:
>
> > I think these results really show there is no reason to try to
> > maintain the old-software-can-send-to-future-segwit-versions property,
> > given that more than one not just didn't support it, but actually sent
> > coins into a black hole.
>
> I don't think this is a good criteria to use for making a decision. We
> shouldn't deny users of working implementations the benefit of a feature
> because some other developers didn't implement it correctly.
>
> > Thus, I agree with Rusty that we should change the checksum for v1+
> > unconditionally.
>
> I disagreed with Rusty previously and he proposed we check to see how
> disruptive an address format change would be by seeing how many wallets
> already provide forward compatibility and how many would need to be
> updated for taproot no matter what address format is used. I think that
> instead is a good criteria for making a decision.
>
> I understand the results of that survey to be that only two wallets
> correctly handled v1+ BIP173 addresses. One of those wallets is Bitcoin
> Core, which I personally believe will unhesitatingly update to a new
> address format that's technically sound and which has widespread support
> (doubly so if it's just a tweak to an already-implemented checksum
> algorithm).

Hi Dave,

You're right to point out there is nuance I skipped over.

Let's look at the behavior of different classes of software/services that exist today when trying to send to v1+ addresses:

(A) Supports sending to v1+ today
  * Old proposal: works, but subject to bech32 insertion issue
  * New proposal: fails
(B) Fails to send to v1+ today
  * Old proposal: fails
  * New proposal: fails
(C) Incorrectly sends to v1+ today
  * Old proposal: lost funds
  * New proposal: fails

So the question is how the support for sending to v1+ in (a) software weighs up against protecting both (a) from the insertion issue, and (c) from lost funds. I do think (c) matters in this equation - people may choose to avoid adopting v1+ witnesses if it were to be known that some senders out there would misdirect funds. But the fact that (a) is small also means there is very little to gain from the old proposal.

So perhaps I should have formulated it as: the small number of v1+ compatible senders today (regardless of the reasons for that) shows how futile the attempt to have one address type for all witness versions was, and the fact that there are even some who misdirect(ed) funds is the final nail in the coffin. Changing the checksum unconditionally gives us a new attempt at that.

> Given that, I also now agree with changing the checksum for v1+.

Great.

Cheers,

--
Pieter


From bitcoin-dev at rgrant.org  Tue Dec  8 17:39:23 2020
From: bitcoin-dev at rgrant.org (Ryan Grant)
Date: Tue, 8 Dec 2020 17:39:23 +0000
Subject: [bitcoin-dev] Progress on bech32 for future Segwit Versions
	(BIP-173)
In-Reply-To: <20201206130453.tiu36iigva2jj5qn@ganymede>
References: <87imblmutl.fsf@rustcorp.com.au>
 <sYf9B0e3UaSdMfdBfChon1Vr7BRFdH_6mgzuXIt_xbtlKtdqns9JJp90dRlNfvwBoRq57YEVrKbKX-dHDWz7TE0gobU4u8dGGJTcFFz2n60=@wuille.net>
 <877drn2g6q.fsf@rustcorp.com.au>
 <S6FCoLsmwaQUhrtSURemcTcG8tUWTXYkBf-0Q0hxCpObfJQ0TXNcmJrQhoqy7ttWwtGnvyS-bJ5RSXJoPizAgjuMognzVnu3SM3wMujKy88=@wuille.net>
 <878sc120f5.fsf@rustcorp.com.au> <20201020102952.4iwpugi5dxawufgo@ganymede>
 <Kw_jwhASjriebJpsuUyi0u9EQmIVR1pQ3Jocqd9VeVDlmoH9s36bFAwr3PXu_pJd-Xly-hKun_yenLwbJvVIYWmlAiF5lMxuquLO2pTmlLo=@wuille.net>
 <CAMeZzJeG00q9DPQacidto5H16Ryb6ou6tnMDK1jnAuncnVXnsA@mail.gmail.com>
 <CAMeZzJdQuS1-0qPvY+0-yqRfVXgZV_2hmHB5hZwykm5WxjUkgg@mail.gmail.com>
 <5Zb8Vf0nq7_rg04OTJwVIY565lDZowEfBXX9IBVLIuG7lTa_sIe4BL3YbpBK2NUAZV7QasZTPHVo5J2uJoRgjj3TveBC12QEp9oTdnLis0k=@wuille.net>
 <20201206130453.tiu36iigva2jj5qn@ganymede>
Message-ID: <CAMnpzfqy-=65gZ_Nj1EjhLV3ExZhnJQ=9o+nAqf11VjxXP3L+Q@mail.gmail.com>

It looks like a good strategy for a bech32 library that is external to
Bitcoin Core would be:

  - Default to the new M, under the same bech32 brand.

  - Provide an interface to explicitly use both M=1 and M=0x2bc830a3.

  - If decoding fails, throw an error; but in constructing that error
    inform whether the other M would have succeeded.

  - Provide an interface for a BIP173 implementation to peek at the
    witness version byte of the data part, which may also involve
    sanity-checking that byte for errors using a BIP173-specific
    understanding of the appropriate checksum.

    Return values for this special interface might currently be:
      "it's version zero, based on a clean decoding",
      "it's version one,  based on a clean decoding",
      "it's version zero, based on an auto-corrected byte",
      "it's version one,  based on an auto-corrected byte",
      "no result, due to a decoding error on this byte", and
      "too many errors to say anything more about decoding".

Although the reasoning is clear for doing so, looking into the data
that is supposed to be checksummed to determine which checksum to use
is not very elegant.  There are two trips into a bech32 library for a
BIP173 decoding, and an indeterminate result on the version byte would
require heuristics for deciding what to do with the rest of the data
part to even advise the user on the error.  Because of this, as a
library writer I would be tempted to auto-correct the witness version
byte (against the "SHOULD NOT" advice of BIP173's current version), if
it were the only one corrupted, as per the example return values
above.  Please advise.

Some of the libraries that will be contemplating these steps include:
  https://github.com/topics/bech32?o=desc&s=stars

Here are three existing uses of bech32 that are external to Bitcoin Core:

  https://github.com/lightningnetwork/lightning-rfc/blob/master/11-payment-encoding.md
  https://github.com/btcontract/lnurl-rfc
  https://github.com/bitcoin/bips/blob/master/bip-0136.mediawiki

Of the above, I think BIP136 can be unconditionally moved to
M=0x2bc830a3 due to having little legacy burden.

From achow101-lists at achow101.com  Wed Dec  9 22:25:37 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Wed, 09 Dec 2020 22:25:37 +0000
Subject: [bitcoin-dev] New PSBT version proposal
Message-ID: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>

Hi All,

I would like to propose a new PSBT version that addresses a few 
deficiencies in the current PSBT v0. As this will be backwards 
incompatible, a new PSBT version will be used, v1.

The primary change is to truly have all input and output data for each 
in their respective maps. Instead of having to parse an unsigned 
transaction and lookup some data from there, and other data from the 
correct map, all of the data for an input will be contained in its map. 
Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version. 
Thus I propose that the following fields be added:

Global:
* PSBT_GLOBAL_TX_VERSION = 0x02
 ? * Key: empty
 ? * Value: 32-bit little endian unsigned integer for the transaction 
version number. Must be provided in PSBT v1 and omitted in v0.
* PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
 ? * Key: empty
 ? * Value: 32 bit little endian unsigned integer for the preferred 
transaction lock time. Must be omitted in PSBT v0. May be provided in 
PSBT v1, assumed to be 0 if not provided.
* PSBT_GLOBAL_INPUT_COUNT = 0x04
 ? * Key: empty
 ? * Value: Compact size unsigned integer. Number of inputs in this 
PSBT. Must be provided in PSBT v1 and omitted in v0.
* PSBT_GLOBAL_OUTPUT_COUNT = 0x05
 ? * Key: empty
 ? * Value: Compact size unsigned integer. Number of outputs in this 
PSBT. Must be provided in PSBT v1 and omitted in v0.

Input:
* PSBT_IN_PREVIOUS_TXID = 0x0e
 ? * Key: empty
 ? * Value: 32 byte txid of the previous transaction whose output at 
PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and 
omitted in v0.
* PSBT_IN_OUTPUT_INDEX = 0x0f
 ? * Key: empty
 ? * Value: 32 bit little endian integer for the index of the output 
being spent. Must be provided in PSBT v1 and omitted in v0.
* PSBT_IN_SEQUENCE = 0x0f
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer for the sequence 
number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed 
to be max sequence (0xffffffff) if not provided.
* PSBT_IN_REQUIRED_LOCKTIME = 0x10
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer for the lock time that 
this input requires. Must be omitted in PSBT v0. May be provided in PSBT 
v1, assumed to be 0 if not provided.

Output:
* PSBT_OUT_VALUE = 0x03
 ? * Key: empty
 ? * Value: 64-bit unsigned little endian integer for the output's 
amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
* PSBT_OUT_OUTPUT_SCRIPT = 0x04
 ? * Key: empty
 ? * Value: The script for this output. Otherwise known as the 
scriptPubKey. Must be provided in PSBT v1 and omitted in v0.

This change allows for PSBT to be used in the construction of 
transactions. With these new fields, inputs and outputs can be added as 
needed. One caveat is that there is no longer a unique transaction 
identifier so more care must be taken when combining PSBTs. 
Additionally, adding new inputs and outputs must be done such that 
signatures are not invalidated. This may be harder to specify.

An important thing to note in this proposal are the fields 
PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin 
transaction only has a single locktime yet a PSBT may have multiple 
locktimes. To choose the locktime for the transaction, finalizers must 
choose the maximum of all of the *_LOCKTIME fields. 
PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those 
involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to 
be set. This field allows finalizers to choose a locktime that is high 
enough for all inputs without needing to understand the scripts 
involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if 
no inputs require a particular locktime.

As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1 
needs the version number bump to enforce backwards incompatibility. 
However once the inputs and outputs of a PSBT are decided, a PSBT could 
be "downgraded" back to v0 by creating the unsigned transaction from the 
above fields, and then dropping these new fields.

If the list finds that these changes are reasonable, I will write a PR 
to modify BIP 174 to incorporate them.

Thanks,
Andrew Chow


From john at johnnewbery.com  Thu Dec 10 09:47:54 2020
From: john at johnnewbery.com (John Newbery)
Date: Thu, 10 Dec 2020 09:47:54 +0000
Subject: [bitcoin-dev] BIP 155 (addrv2) update - spec and Bitcoin Core v0.21
	implementation
Message-ID: <CAFmfg2sSV=F0c1UXu5pi-6YxvvkG4n1BpGbR2Ysz89cA8=HkVw@mail.gmail.com>

Hi folks,

BIP 155 was proposed[1] in Feb 2019 by Wladimir van der Laan as a way of
gossipping longer node addresses over the Bitcoin P2P network, primarily
to support torv3 and other networks.

In the time since that initial mailing list post, several changes have
been made to the proposal. Discussion has been held on the BIPs repo[2],
and (for implementation issues) the Bitcoin Core repo[3].

This email summarizes the changes. Readers should refer to BIP 155[4]
for the full specification.

### Specification changes

1. The `time` field in the `addrv2` message is now stored as a fixed
   length uint32 instead of a variable-length compact size.

2. The `addr` field may be up to a maximum of 512 bytes (4096 bits)
   instead of 32 bytes (256 bits) for compatibility with future address
   formats.

3. Clients now SHOULD gossip addresses for known networks (even if they
   can't connect to those networks). They SHOULD NOT gossip addresses
   for unknown networks. They SHOULD also ignore addresses for known
   networks that are different from the address length for that network
   specified in BIP 155.

4. New network IDs MUST be reserved in a BIP document.

5. Support for `addrv2` is not dependent on a p2p protocol version.
   A new message type `sendaddrv2` is introduced to signal support
   for addrv2. To signal support for addrv2, this message MUST be sent
   after the initial version message is sent and before the verack
   message is sent.

### Implementation detail

During testing of the Bitcoin Core implementation, it was found that
another Bitcoin implementation would disconnect from peers on receipt of
an unknown message[5]. I believe that to be an incorrect interpretation
of the Bitcoin p2p protocol. The original v0.1 Satoshi client (and all
Bitcoin Core versions derived from it) have always explicitly ignored
unknown message types as a mechanism to extend the p2p protocol[6]. This
property allows p2p implementions to permissionlessly deploy opt-in
extensions to the protocol.

As a pragmatic step to prevent those implementations from being
disconnected from v0.21 Bitcoin Core nodes, this initial version will
_only_ send sendaddrv2 messages to peers on p2p protocol version 70016
and higher. This behaviour may be reverted in future, at which point
Bitcoin Core would send sendaddrv2 messages to all peers during the
version/verack handshake.

Thanks to everyone who has contributed to the addrv2
spec/implementation.

John

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-February/016687.html
[2] https://github.com/bitcoin/bips/search?q=addrv2+is%3Apr&type=Issues
[3] https://github.com/bitcoin/bitcoin/pull/20564
[4] https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki
[5] https://github.com/btcsuite/btcd/issues/1661
[6] https://github.com/benjyz/bitcoinArchive/blob/master/bitcoin0.1/src/main.cpp#L2035-L2039
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201210/b6445a1c/attachment.html>

From sanket1729 at gmail.com  Thu Dec 10 11:28:23 2020
From: sanket1729 at gmail.com (Sanket Kanjalkar)
Date: Thu, 10 Dec 2020 05:28:23 -0600
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
Message-ID: <CAExE9c8o21sptsckNjk9mTPi8p7WAr_6cUynfnjjG1gNoYDDvQ@mail.gmail.com>

>
> The primary change is to truly have all input and output data for each  in
> their respective maps

1) +1. It would be really great to have a complete map per input/output
that does not require an annoying lookup to a global field.

A Bitcoin transaction only has a single locktime yet a PSBT may have
> multiple lock times.

2) One other thing, the per input timelock also helps in detecting whether
the transaction contains a mix of block-based
timelocks and height based timelocks. Recall that such inputs can't be
spent together under the same nLocktime.

3) Finally, one last thing which I noted while implementing a generic
finalizer for Miniscript is the restriction on sighashType.
>From the BIP

> Signatures for this input must use the sighash type, finalizers must fail
> to finalize inputs which have signatures that do not match the specified
> sighash type. Signers who cannot produce signatures with the sighash type
> must not provide a signature.

Is such a restriction necessary? If the purpose is to only suggest signer
which sighashType to use, then I think the finalizer
should not reject those. Along those lines, we can also mark with
suggestions for the type of nlockTime(block vs height) that
should be used. With such suggestions, input parties can decide which
branches in the satisfaction they should prefer and
sign with the corresponding signatures. Note that this purpose is different
from the stated purpose of
PSBT_GLOBAL_PREFERRED_LOCKTIME.

Cheers,
Sanket

On Wed, Dec 9, 2020 at 4:33 PM Andrew Chow via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi All,
>
> I would like to propose a new PSBT version that addresses a few
> deficiencies in the current PSBT v0. As this will be backwards
> incompatible, a new PSBT version will be used, v1.
>
> The primary change is to truly have all input and output data for each
> in their respective maps. Instead of having to parse an unsigned
> transaction and lookup some data from there, and other data from the
> correct map, all of the data for an input will be contained in its map.
> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
> Thus I propose that the following fields be added:
>
> Global:
> * PSBT_GLOBAL_TX_VERSION = 0x02
>    * Key: empty
>    * Value: 32-bit little endian unsigned integer for the transaction
> version number. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
>    * Key: empty
>    * Value: 32 bit little endian unsigned integer for the preferred
> transaction lock time. Must be omitted in PSBT v0. May be provided in
> PSBT v1, assumed to be 0 if not provided.
> * PSBT_GLOBAL_INPUT_COUNT = 0x04
>    * Key: empty
>    * Value: Compact size unsigned integer. Number of inputs in this
> PSBT. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
>    * Key: empty
>    * Value: Compact size unsigned integer. Number of outputs in this
> PSBT. Must be provided in PSBT v1 and omitted in v0.
>
> Input:
> * PSBT_IN_PREVIOUS_TXID = 0x0e
>    * Key: empty
>    * Value: 32 byte txid of the previous transaction whose output at
> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
> omitted in v0.
> * PSBT_IN_OUTPUT_INDEX = 0x0f
>    * Key: empty
>    * Value: 32 bit little endian integer for the index of the output
> being spent. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_IN_SEQUENCE = 0x0f
>    * Key: empty
>    * Value: 32 bit unsigned little endian integer for the sequence
> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
> to be max sequence (0xffffffff) if not provided.
> * PSBT_IN_REQUIRED_LOCKTIME = 0x10
>    * Key: empty
>    * Value: 32 bit unsigned little endian integer for the lock time that
> this input requires. Must be omitted in PSBT v0. May be provided in PSBT
> v1, assumed to be 0 if not provided.
>
> Output:
> * PSBT_OUT_VALUE = 0x03
>    * Key: empty
>    * Value: 64-bit unsigned little endian integer for the output's
> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_OUT_OUTPUT_SCRIPT = 0x04
>    * Key: empty
>    * Value: The script for this output. Otherwise known as the
> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
>
> This change allows for PSBT to be used in the construction of
> transactions. With these new fields, inputs and outputs can be added as
> needed. One caveat is that there is no longer a unique transaction
> identifier so more care must be taken when combining PSBTs.
> Additionally, adding new inputs and outputs must be done such that
> signatures are not invalidated. This may be harder to specify.
>
> An important thing to note in this proposal are the fields
> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
> transaction only has a single locktime yet a PSBT may have multiple
> locktimes. To choose the locktime for the transaction, finalizers must
> choose the maximum of all of the *_LOCKTIME fields.
> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
> be set. This field allows finalizers to choose a locktime that is high
> enough for all inputs without needing to understand the scripts
> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
> no inputs require a particular locktime.
>
> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
> needs the version number bump to enforce backwards incompatibility.
> However once the inputs and outputs of a PSBT are decided, a PSBT could
> be "downgraded" back to v0 by creating the unsigned transaction from the
> above fields, and then dropping these new fields.
>
> If the list finds that these changes are reasonable, I will write a PR
> to modify BIP 174 to incorporate them.
>
> Thanks,
> Andrew Chow
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201210/8d157a07/attachment-0001.html>

From dentondevelopment at protonmail.com  Wed Dec 16 12:43:58 2020
From: dentondevelopment at protonmail.com (dentondevelopment)
Date: Wed, 16 Dec 2020 12:43:58 +0000
Subject: [bitcoin-dev] bip48 proposal
Message-ID: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>

Hello,

I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.

Please see a rough draft of the proposed bip attached, comments/input welcome.

Regards,
Fontaine
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/d7e0c7d2/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bip-0048.mediawiki
Type: application/octet-stream
Size: 6667 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/d7e0c7d2/attachment.obj>

From dentondevelopment at protonmail.com  Wed Dec 16 14:10:28 2020
From: dentondevelopment at protonmail.com (dentondevelopment)
Date: Wed, 16 Dec 2020 14:10:28 +0000
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
Message-ID: <1_mYgDaVRKZIADl9fWVzTYGNBr0Z43Fp-Gcoz2ibhKY4VKAk1Vbs9XSZ3rlzyGEwvE2YEOn2C0IxAVKkr_rr6KX0YxMiNTiTtQVBL4vgyd8=@protonmail.com>

Here is the repo instead of a static link: https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki

Fontaine

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hello,
>
> I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.
>
> Please see a rough draft of the proposed bip attached, comments/input welcome.
>
> Regards,
> Fontaine
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/40281a60/attachment.html>

From luke at dashjr.org  Wed Dec 16 17:16:54 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 16 Dec 2020 17:16:54 +0000
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <1_mYgDaVRKZIADl9fWVzTYGNBr0Z43Fp-Gcoz2ibhKY4VKAk1Vbs9XSZ3rlzyGEwvE2YEOn2C0IxAVKkr_rr6KX0YxMiNTiTtQVBL4vgyd8=@protonmail.com>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
 <1_mYgDaVRKZIADl9fWVzTYGNBr0Z43Fp-Gcoz2ibhKY4VKAk1Vbs9XSZ3rlzyGEwvE2YEOn2C0IxAVKkr_rr6KX0YxMiNTiTtQVBL4vgyd8=@protonmail.com>
Message-ID: <202012161716.54878.luke@dashjr.org>

BIP number 48 has not been assigned. Do not self-assign BIP numbers.

Is this intended to be compatible with 
https://github.com/bitcoin/bips/pull/253 ?

Luke



On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev 
wrote:
> Here is the repo instead of a static link:
> https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki
>
> Fontaine
>
> Sent with [ProtonMail](https://protonmail.com) Secure Email.
>
> ??????? Original Message ???????
>
> On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via bitcoin-dev 
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Hello,
> >
> > I would like to propose bip48 (taking bip44 as inspiration), with the
> > purpose of documenting modern multi-sig derivations.
> >
> > Please see a rough draft of the proposed bip attached, comments/input
> > welcome.
> >
> > Regards,
> > Fontaine


From apoelstra at wpsoftware.net  Wed Dec 16 17:44:11 2020
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 16 Dec 2020 17:44:11 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
Message-ID: <20201216174411.GR106279@boulet>

On Wed, Dec 09, 2020 at 10:25:37PM +0000, Andrew Chow via bitcoin-dev wrote:
> Hi All,
> 
> I would like to propose a new PSBT version that addresses a few 
> deficiencies in the current PSBT v0. As this will be backwards 
> incompatible, a new PSBT version will be used, v1.
> 
> The primary change is to truly have all input and output data for each 
> in their respective maps. Instead of having to parse an unsigned 
> transaction and lookup some data from there, and other data from the 
> correct map, all of the data for an input will be contained in its map. 
> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version. 
> Thus I propose that the following fields be added:
> 
> Global:
> * PSBT_GLOBAL_TX_VERSION = 0x02
>  ?? * Key: empty
>  ?? * Value: 32-bit little endian unsigned integer for the transaction 
> version number. Must be provided in PSBT v1 and omitted in v0.

All of these changes sound great. It would definitely make working with
PSBTs easier if all data was accessible in the same format, rather than
being split between the global unsigned tx and the main body.

One minor quibble is the version numbering -- you mention "v1" in this
post but set GLOBAL_TX_VERSION to 2. I think we should consistently use
2 everywhere; probably nobody thinks of the existing PSBT as "version 0".

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/244f8942/attachment.sig>

From keagan.mcclelland at gmail.com  Wed Dec 16 18:48:30 2020
From: keagan.mcclelland at gmail.com (Keagan McClelland)
Date: Wed, 16 Dec 2020 11:48:30 -0700
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <202012161716.54878.luke@dashjr.org>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
 <1_mYgDaVRKZIADl9fWVzTYGNBr0Z43Fp-Gcoz2ibhKY4VKAk1Vbs9XSZ3rlzyGEwvE2YEOn2C0IxAVKkr_rr6KX0YxMiNTiTtQVBL4vgyd8=@protonmail.com>
 <202012161716.54878.luke@dashjr.org>
Message-ID: <CALeFGL0XJhdyfx+dbvFyD1xZUkzfVAAyNyv276Cj+Z5T+OgQSw@mail.gmail.com>

I was just looking into the conventions around this yesterday! It seems
like this proposal is mostly just formalizing stuff that is already a tacit
standard. I'm glad to see that someone is documenting it somewhere more
"official".

It appears consistent with https://github.com/bitcoin/bips/pull/253, However,
due to historical timing, the PR you linked doesn't include any standards
around segwit conventions.

In the review thread you had mentioned that you needed an ACK from prusnak,
but he explicitly gave a NACK in favor of a separate proposal for BIP 48,
which seems like it could be something like the OP. Reading the proposal it
seems consistent with the pull request that you linked, as well. At the end
of the thread the author of PR#253 said they would open a separate
proposal, but it appears that it never materialized. Was there a reason for
this?

Keagan

On Wed, Dec 16, 2020 at 10:17 AM Luke Dashjr via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> BIP number 48 has not been assigned. Do not self-assign BIP numbers.
>
> Is this intended to be compatible with
> https://github.com/bitcoin/bips/pull/253 ?
>
> Luke
>
>
>
> On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev
> wrote:
> > Here is the repo instead of a static link:
> > https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki
> >
> > Fontaine
> >
> > Sent with [ProtonMail](https://protonmail.com) Secure Email.
> >
> > ??????? Original Message ???????
> >
> > On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via
> bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > Hello,
> > >
> > > I would like to propose bip48 (taking bip44 as inspiration), with the
> > > purpose of documenting modern multi-sig derivations.
> > >
> > > Please see a rough draft of the proposed bip attached, comments/input
> > > welcome.
> > >
> > > Regards,
> > > Fontaine
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201216/034a2dfd/attachment-0001.html>

From stick at satoshilabs.com  Thu Dec 17 10:58:08 2020
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 17 Dec 2020 11:58:08 +0100
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
Message-ID: <cb219d10-64d1-415d-87a0-7b91f3a0af47@Canary>

I applaud this effort!

We tried to document the 48 path usage in this document:

https://github.com/trezor/trezor-firmware/blob/master/docs/misc/purpose48.md

The only difference I can spot is that our document also documents script_type=0 which is for the raw BIP-11 multisig. While almost not used in the wild, it could be imho documented in this proposed BIP as well.

?
Best Regards / S pozdravom,

Pavol ?stick? Rusnak
Co-founder and CTO, SatoshiLabs

> On Wednesday, Dec 16, 2020 at 2:48 PM, dentondevelopment via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org (mailto:bitcoin-dev at lists.linuxfoundation.org)> wrote:
> Hello,
>
> I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.
>
> Please see a rough draft of the proposed bip attached, comments/input welcome.
>
> Regards,
> Fontaine
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201217/b47648bc/attachment.html>

From dentondevelopment at protonmail.com  Fri Dec 18 01:44:27 2020
From: dentondevelopment at protonmail.com (dentondevelopment)
Date: Fri, 18 Dec 2020 01:44:27 +0000
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <202012161716.54878.luke@dashjr.org>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
 <1_mYgDaVRKZIADl9fWVzTYGNBr0Z43Fp-Gcoz2ibhKY4VKAk1Vbs9XSZ3rlzyGEwvE2YEOn2C0IxAVKkr_rr6KX0YxMiNTiTtQVBL4vgyd8=@protonmail.com>
 <202012161716.54878.luke@dashjr.org>
Message-ID: <MMFMtQ1lNQcLBIv8haKSpykMjFISWeyYWbFZC7dkzliEZrf2vZYw6ThqFWSYzIntVT3bXvTUol_l-P9wxUIFhwL38lKSGHBFsRG-ukRirP4=@protonmail.com>

Hi Luke,

It looks to have the same motivations and be compatible with https://github.com/bitcoin/bips/pull/253 (if I am reading it correctly).

The only guidance I have on proposing a bip is what is on the readme https://github.com/bitcoin/bips/blob/master/README.mediawiki

48 would be fitting if it is unused.

This is still very much a work in progress and there does seem to be community support.

Pavol and others have shared relevant info/suggestions which I will be using to update the proposal.

Will share again here when the next draft is ready.

Many thanks,
Fontaine


Sent with ProtonMail Secure Email.

??????? Original Message ???????
On Thursday, December 17, 2020 1:16 AM, Luke Dashjr <luke at dashjr.org> wrote:

> BIP number 48 has not been assigned. Do not self-assign BIP numbers.
>
> Is this intended to be compatible with
> https://github.com/bitcoin/bips/pull/253 ?
>
> Luke
>
> On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev
> wrote:
>
> > Here is the repo instead of a static link:
> > https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki
> > Fontaine
> > Sent with ProtonMail Secure Email.
> > ??????? Original Message ???????
> > On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via bitcoin-dev
>
> bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > > Hello,
> > > I would like to propose bip48 (taking bip44 as inspiration), with the
> > > purpose of documenting modern multi-sig derivations.
> > > Please see a rough draft of the proposed bip attached, comments/input
> > > welcome.
> > > Regards,
> > > Fontaine



From dentondevelopment at protonmail.com  Fri Dec 18 01:49:07 2020
From: dentondevelopment at protonmail.com (dentondevelopment)
Date: Fri, 18 Dec 2020 01:49:07 +0000
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <cb219d10-64d1-415d-87a0-7b91f3a0af47@Canary>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
 <cb219d10-64d1-415d-87a0-7b91f3a0af47@Canary>
Message-ID: <NGCRT8G5h7uuryz6sQvJd--aNOWJrrCSvKQvjlpHUJOdJlimd72FZAP_kcBa3N7AJpB4DxgldmWD20eUa3iirrRxsebWT0DlFD3ERlaShrM=@protonmail.com>

Thanks for the link, will certainly be using the provided info as a reference and updating soon.

Regards,
Fontaine

Sent with [ProtonMail](https://protonmail.com) Secure Email.

??????? Original Message ???????
On Thursday, December 17, 2020 6:58 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:

> I applaud this effort!
>
> We tried to document the 48 path usage in this document:
>
> https://github.com/trezor/trezor-firmware/blob/master/docs/misc/purpose48.md
>
> The only difference I can spot is that our document also documents script_type=0 which is for the raw BIP-11 multisig. While almost not used in the wild, it could be imho documented in this proposed BIP as well.
>
> ?
> Best Regards / S pozdravom,
>
> Pavol ?stick? Rusnak
> Co-founder and CTO, SatoshiLabs
>
>> On Wednesday, Dec 16, 2020 at 2:48 PM, dentondevelopment via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Hello,
>>
>> I would like to propose bip48 (taking bip44 as inspiration), with the purpose of documenting modern multi-sig derivations.
>>
>> Please see a rough draft of the proposed bip attached, comments/input welcome.
>>
>> Regards,
>> Fontaine
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201218/3e20a405/attachment.html>

From bitcoin-dev at wuille.net  Fri Dec 18 02:02:04 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Fri, 18 Dec 2020 02:02:04 +0000
Subject: [bitcoin-dev] Progress on bech32 for future Segwit Versions
	(BIP-173)
In-Reply-To: <CAMnpzfqy-=65gZ_Nj1EjhLV3ExZhnJQ=9o+nAqf11VjxXP3L+Q@mail.gmail.com>
References: <87imblmutl.fsf@rustcorp.com.au> <878sc120f5.fsf@rustcorp.com.au>
 <20201020102952.4iwpugi5dxawufgo@ganymede>
 <Kw_jwhASjriebJpsuUyi0u9EQmIVR1pQ3Jocqd9VeVDlmoH9s36bFAwr3PXu_pJd-Xly-hKun_yenLwbJvVIYWmlAiF5lMxuquLO2pTmlLo=@wuille.net>
 <CAMeZzJeG00q9DPQacidto5H16Ryb6ou6tnMDK1jnAuncnVXnsA@mail.gmail.com>
 <CAMeZzJdQuS1-0qPvY+0-yqRfVXgZV_2hmHB5hZwykm5WxjUkgg@mail.gmail.com>
 <5Zb8Vf0nq7_rg04OTJwVIY565lDZowEfBXX9IBVLIuG7lTa_sIe4BL3YbpBK2NUAZV7QasZTPHVo5J2uJoRgjj3TveBC12QEp9oTdnLis0k=@wuille.net>
 <20201206130453.tiu36iigva2jj5qn@ganymede>
 <CAMnpzfqy-=65gZ_Nj1EjhLV3ExZhnJQ=9o+nAqf11VjxXP3L+Q@mail.gmail.com>
Message-ID: <lSjNGJjlvNIs7NxyAsWiS-HC6D2a4mabZDn_wAS7PvvQC8KePAACZ8BcihgWRfsEwJZqrTXfzzOxVXfZhxDm8SKHzN8lJ9TCVQ7e28to8Ko=@wuille.net>

On Tuesday, December 8, 2020 9:39 AM, Ryan Grant <bitcoin-dev at rgrant.org> wrote:

> It looks like a good strategy for a bech32 library that is external to
> Bitcoin Core would be:
>
> -   Default to the new M, under the same bech32 brand.
> -   Provide an interface to explicitly use both M=1 and M=0x2bc830a3.
> -   If decoding fails, throw an error; but in constructing that error
>     inform whether the other M would have succeeded.
>
> -   Provide an interface for a BIP173 implementation to peek at the
>     witness version byte of the data part, which may also involve
>     sanity-checking that byte for errors using a BIP173-specific
>     understanding of the appropriate checksum.

I think there are two possible interfaces that make sense:

- Have the caller explicitly specify whether they want bech32 or bech32m (which someone - I think Rusty? - started using in reference to this new code and I'm going to adopt now).

- Have the bech32 decoding function return a tristate (failed, valid as bech32, valid as bech32m). No string is ever valid as both, so there is no loss of information here.

The former is a bit cleaner, and also the only real choice if error location hinting is desired. The second is more efficient if decoding twice is a performance concern.

Cheers,

--
Pieter


From luke at dashjr.org  Fri Dec 18 04:08:30 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Fri, 18 Dec 2020 04:08:30 +0000
Subject: [bitcoin-dev] bip48 proposal
In-Reply-To: <MMFMtQ1lNQcLBIv8haKSpykMjFISWeyYWbFZC7dkzliEZrf2vZYw6ThqFWSYzIntVT3bXvTUol_l-P9wxUIFhwL38lKSGHBFsRG-ukRirP4=@protonmail.com>
References: <cLqW9ZphcaV5hoVNYHjHk_DsdVw_0_hdFxOFwtFkVT9_N_E1IF7ZvtQq745wbqMnny4xzHe8Xdd9TTi2MLyLhB51cI_PJc4fIjLRSpZpGwk=@protonmail.com>
 <202012161716.54878.luke@dashjr.org>
 <MMFMtQ1lNQcLBIv8haKSpykMjFISWeyYWbFZC7dkzliEZrf2vZYw6ThqFWSYzIntVT3bXvTUol_l-P9wxUIFhwL38lKSGHBFsRG-ukRirP4=@protonmail.com>
Message-ID: <202012180408.31441.luke@dashjr.org>

Thanks for explaining where instructions are lacking.

How does this look?
https://github.com/bitcoin/bips/pull/1046/files

On Friday 18 December 2020 01:44:27 dentondevelopment wrote:
> Hi Luke,
>
> It looks to have the same motivations and be compatible with
> https://github.com/bitcoin/bips/pull/253 (if I am reading it correctly).
>
> The only guidance I have on proposing a bip is what is on the readme
> https://github.com/bitcoin/bips/blob/master/README.mediawiki
>
> 48 would be fitting if it is unused.
>
> This is still very much a work in progress and there does seem to be
> community support.
>
> Pavol and others have shared relevant info/suggestions which I will be
> using to update the proposal.
>
> Will share again here when the next draft is ready.
>
> Many thanks,
> Fontaine
>
>
> Sent with ProtonMail Secure Email.
>
> ??????? Original Message ???????
>
> On Thursday, December 17, 2020 1:16 AM, Luke Dashjr <luke at dashjr.org> wrote:
> > BIP number 48 has not been assigned. Do not self-assign BIP numbers.
> >
> > Is this intended to be compatible with
> > https://github.com/bitcoin/bips/pull/253 ?
> >
> > Luke
> >
> > On Wednesday 16 December 2020 14:10:28 dentondevelopment via bitcoin-dev
> >
> > wrote:
> > > Here is the repo instead of a static link:
> > > https://github.com/Fonta1n3/bips/blob/master/bip-0048.mediawiki
> > > Fontaine
> > > Sent with ProtonMail Secure Email.
> > > ??????? Original Message ???????
> > > On Wednesday, December 16, 2020 8:43 PM, dentondevelopment via
> > > bitcoin-dev
> >
> > bitcoin-dev at lists.linuxfoundation.org wrote:
> > > > Hello,
> > > > I would like to propose bip48 (taking bip44 as inspiration), with the
> > > > purpose of documenting modern multi-sig derivations.
> > > > Please see a rough draft of the proposed bip attached, comments/input
> > > > welcome.
> > > > Regards,
> > > > Fontaine


From apoelstra at wpsoftware.net  Fri Dec 18 15:27:20 2020
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Fri, 18 Dec 2020 15:27:20 +0000
Subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements
Message-ID: <20201218152720.GW106279@boulet>

I have gone over BIP-0322 and substantially rewritten the text.
Everything I did is (I think) simply clarifying the existing
protocol, which felt like it was written by committee and wasn't
easy to follow, EXCEPT:

1. I rewrote the motivation section, which I believe originally
   was a paraphrase of Luke-jr's general objections to having any
   signmessage functionality. I hope Luke in particular can take
   a look at what I wrote under "Motivation" and see if it
   captures his concerns.

2. I merged the "consensus" and "upgradeable" rules to simply be
   one set of rules, consisting of consensus checks plus additional
   restrictions, all of which must be included. The new "Extensions"
   section allows validators to output the state "consensus-valid"
   if they really don't want to check the additional restrictions.

3. The "inconclusive" state, which was originally used for what I've
   called "consensus-valid", now indicates that a validator does not
   understand the script that it is checking (also described in the
   new "Extensions" section). The goal is that implementors are able
   to be meaningfully BIP-0322 while only supporting a subset of
   Script, e.g. the templates that their own software supports, or
   Miniscript, or the non-raw non-address set of output descriptors,
   or whatever.

   We have seen opposition to supporting BIP-322, e.g. [1] because
   of the requirement that you either have a full script interpreter
   (plus an open-ended list of Core's standardness flags, which is
   not even available through libbitcoinconsensus) or nothing. On
   the other hand, the vast majority of outputs are single-key p2pkh,
   p2pkwh or p2sh-wpkh.

The new text is here (and for posterity I will also include it
inline below, though unless Github deletes it it will be easier
to read in rendered form):

https://github.com/apoelstra/bips/blob/2020-12--bip322-overhaul/bip-0322.mediawiki

I'll also PR this to the BIPs repo in the next day or two, and
comments on Github are then welcome.


[1] https://bitcointalk.org/index.php?topic=5261605.0



* * * * * Full text of the above link * * * * *

<pre>
  BIP: 322
  Layer: Applications
  Title: Generic Signed Message Format
  Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322
  Status: Draft
  Type: Standards Track
  Created: 2018-09-10
  License: CC0-1.0
</pre>

== Abstract ==

A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as the intended recipient of funds sent to the invoice address.

== Motivation ==

The current message signing standard only works for P2PKH (1...) invoice addresses. We propose to extend and generalize the standard by using a Bitcoin Script based approach. This ensures that any coins, no matter what script they are controlled by, can in-principle be signed for. For easy interoperability with existing signing hardware, we also define a signature message format which resembles a Bitcoin transaction (except that it contains an invalid input, so it cannot be spent on any real network).

Additionally, the current message signature format uses ECDSA signatures which do not commit to the public key, meaning that they do not actually prove knowledge of any secret keys. (Indeed, valid signatures can be tweaked by 3rd parties to become valid signatures on certain related keys.)

Ultimately no message signing protocol can actually prove control of funds, both because a signature is obsolete as soon as it is created, and because the possessor of a secret key may be willing to sign messages on others' behalf even if it would not sign actual transactions. No signmessage protocol can fix these limitations.

== Types of Signatures ==

This BIP specifies three formats for signing messages: ''legacy'', ''simple'' and ''full''. Additionally, a variant of the ''full'' format can be used to demonstrate control over a set of UTXOs.

=== Legacy ===

New proofs should use the new format for all invoice address formats, including P2PKH.

The legacy format MAY be used, but must be restricted to the legacy P2PKH invoice address format.

=== Simple ===

A ''simple'' signature consists of a witness stack, consensus encoded as a vector of vectors of bytes, and base64-encoded. Validators should construct <code>to_spend</code> and <code>to_sign</code> as defined below, with default values for all fields except that

* <code>message_hash</code> is a BIP340-tagged hash of the message, as specified below
* <code>message_challenge</code> in <code>to_spend</code> is set to the scriptPubKey being signed with
* <code>message_signature</code> in <code>to_sign</code> is set to the provided simple signature.

and then proceed as they would for a full signature.

=== Full ===

Full signatures follow an analogous specification to the BIP-325 challenges and solutions used by Signet.

Let there be two virtual transactions to_spend and to_sign.

The "to_spend" transaction is:

    nVersion = 0
    nLockTime = 0
    vin[0].prevout.hash = 0000...000
    vin[0].prevout.n = 0xFFFFFFFF
    vin[0].nSequence = 0
    vin[0].scriptSig = OP_0 PUSH32[ message_hash ]
    vin[0].scriptWitness = []
    vout[0].nValue = 0
    vout[0].scriptPubKey = message_challenge

where <code>message_hash</code> is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = <code>BIP0322-signed-message</code>, and <code>message_challenge</code> is the to be proven (public) key script.

The "to_sign" transaction is:

    nVersion = 0 or as appropriate (e.g. 2, for time locks)
    nLockTime = 0 or as appropriate (for time locks)
    vin[0].prevout.hash = to_spend.txid
    vin[0].prevout.n = 0
    vin[0].nSequence = 0 or as appropriate (for time locks)
    vin[0].scriptWitness = message_signature
    vout[0].nValue = 0
    vout[0].scriptPubKey = OP_RETURN

A full signature consists of the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation.

=== Full (Proof of Funds) ===

A signer may construct a proof of funds, demonstrating control of a set of UTXOs, by constructing a full signature as above, with the following modifications.

* <code>message_challenge</code> is unused and shall be set to <code>OP_TRUE</code>
* Similarly, <code>message_signature</code> is then empty.
* All outputs that the signer wishes to demonstrate control of are included as additional outputs to <code>to_sign</code>, and their witness and scriptSig data should be set as though these outputs were actually being spent.

Unlike an ordinary signature, validators of a proof of funds need access to the current UTXO set, to learn that the claimed inputs exist on the blockchain, and to learn their scriptPubKeys.

== Detailed Specification ==

For all signature types, except legacy, the <code>to_spend</code> and <code>to_sign</code> transactions must be valid transactions which pass all consensus checks, except of course that the output with prevout <code>000...000:FFFFFFFF</code> does not exist.

We additionally require the following restrictions be met.

* All signatures must use the SIGHASH_ALL flag.
* The use of <code>CODESEPARATOR</code> or <code>FindAndDelete</code> is forbidden.
* The use of NOPs reserved for upgrades is forbidden.
* The use of segwit versions greater than 1 are forbidden.
* <code>LOW_S</code>, <code>STRICTENC</code> and <code>NULLFAIL</code>: valid ECDSA signatures must be strictly DER-encoded and have a low-S value; invalid ECDSA signature must be the empty push
* <code>MINIMALDATA</code>: all pushes must be minimally encoded
* <code>CLEANSTACK</code>: require that only a single stack element remains after evaluation
* <code>MINIMALIF</code>: the argument of <code>IF</code>/<code>NOTIF</code> must be exactly 0x01 or empty push

Future versions of this BIP may relax these rules, in particular those around NOPs and future Segwit versions, as they are deployed on Bitcoin.

=== Verification ===

Validation consists of the following steps. A validator is given as input an address ''A'' (which may be omitted in a proof-of-funds), signature ''s'' and message ''m'', and outputs one of four states (although validators are only required to be able to output the first and last):
* ''valid'' indicates that the signature passed all checks described below
* ''valid at time t and age s'' indicates that the signature has set timelocks but is otherwise valid (see "Extensions" below)
* ''consensus-valid'' indicates that the signature passed validation except for the additonal restrictions in the above section (see "Extensions" below)
* ''inconclusive'' means the validator was unable to check the scripts (see "Extensions" below)
* ''invalid'' means none of the other states

# Decode ''s'' as the transactions <code>to_sign</code> and <code>to_spend</code>
# Confirm that <code>message_hash</code> is the correct hash of ''m''
# Confirm that <code>message_challenge</code> is the scriptPubKey corresponding to ''A'' if ''A'' is present, and otherwise must be <code>OP_TRUE</code>
# Confirm that all other fields are set as specified above; in particular that
** <code>to_spend</code> has exactly one input and one output
** <code>to_sign</code> has at least one input and its first input spends the output of </code>to_spend</code>
** <code>to_sign</code> has exactly one output, as specified above
# Confirm that the two transactions together satisfy all consensus rules, except for <code>to_spend</code>'s missing input, and except that ''nSequence'' of <code>to_sign</code>'s first input and ''nLockTime'' of <code>to_sign</code> are not checked.
# Confirm that all of the above restrictions are met.

If the above conditions are met, the signature is considered ''valid''. Otherwise the signature is ''invalid''.

=== Signing ===

Signers who control an address ''A'' who wish to sign a message ''m'' act as follows:

# They construct <code>to_spend</code> and <code>to_sign</code> as specified above, using the scriptPubKey of ''A'' for <code>message_challenge</code> and tagged hash of ''m'' as <code>message_hash</code>.
# Optionally, they may set nLockTime of <code>to_sign</code> or nSequence of its first input.
# Optionally, they may add any additional outputs to <code>to_sign</code> that they wish to prove control of.
# They satisfy <code>to_sign</code> as they would any other transaction.

They then encode their signature, choosing either ''simple'' or ''full'' as follows:

* If they added no inputs to <code>to_sign</code>, left nSequence and nLockTime at 0, and ''A'' is a Segwit address (either pure or P2SH-wrapped), then they may base64-encode <code>message_signature</code>
* Otherwise they must base64-encode the concatenation of <code>to_spend</code> followed by <code>to_sign</code>.

== Extensions ==

To ease implementation, we allow some additional states to be output rather than ''valid'' or ''invalid''. Users who do not understand or who do not wish to deal with these states may treat them as ''invalid''.

=== Timelocks === 

If the nLockTime of <code>to_sign</code> is set to ''t'', and the nSequence of the first input of <code>to_sign</code> is set to ''s'', the validator may output the state ''valid at time t and age s''.

If both ''t'' and ''s'' are 0, the validator must instead output ''valid''.

Users may then wish to interpret this state as ''valid'' or ''invalid'' relative to the state of the current blockchain, but the rules for doing so are out of scope of this BIP.

=== Incomplete Validation ===

Some validators may not wish to implement a full script interpreter, choosing instead to support only specific script templates, or only Miniscript, for example. In this case, if they are unable to execute the scripts used by <code>to_sign</code>, they should output the state ''inconclusive''.

Users should interpret this state as the same thing as ''invalid'', although take it as a sign that they should find more capable software.

=== Consensus-Only Validation ===

Validators which are only able to check consensus-correctness of witnesses, but not the additional restrictions imposed by this BIP, may output the state ''consensus-valid'' to indicate that a signature has passed all consensus and structural checks.

Users should interpret this state as the same thing as ''valid'' but be aware that other software may fail to validate the same signature.

== Compatibility ==

This specification is backwards compatible with the legacy signmessage/verifymessage specification through the special case as described above.

== Reference implementation ==

TODO

== Acknowledgements ==

Thanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille, Andrew Poelstra, and many others for their feedback on the specification.

== References ==

# Original mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html

== Copyright ==

This document is licensed under the Creative Commons CC0 1.0 Universal license.

== Test vectors ==

TODO

* * * * * End full text * * * * *

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201218/f7228b77/attachment.sig>

From karljohan-alm at garage.co.jp  Mon Dec 21 05:37:38 2020
From: karljohan-alm at garage.co.jp (Karl-Johan Alm)
Date: Mon, 21 Dec 2020 14:37:38 +0900
Subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements
In-Reply-To: <20201218152720.GW106279@boulet>
References: <20201218152720.GW106279@boulet>
Message-ID: <CALJw2w4bFp8qcxNzz7hn_ZeGG8WWTPu-mRv6A4cPt66EHimyeg@mail.gmail.com>

Thanks a lot for taking the time to brush up the BIP. For what it's
worth, I am all for these changes, and I see them as clear
improvements all around.

IIRC Pieter was the one who originally suggested the two-checks
approach (invalid, inconclusive, valid) which is being modified here,
so would be good if you chimed in (or not -- which I'll assume means
you don't mind).

On Sat, Dec 19, 2020 at 12:27 AM Andrew Poelstra via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> I have gone over BIP-0322 and substantially rewritten the text.
> Everything I did is (I think) simply clarifying the existing
> protocol, which felt like it was written by committee and wasn't
> easy to follow, EXCEPT:
>
> 1. I rewrote the motivation section, which I believe originally
>    was a paraphrase of Luke-jr's general objections to having any
>    signmessage functionality. I hope Luke in particular can take
>    a look at what I wrote under "Motivation" and see if it
>    captures his concerns.
>
> 2. I merged the "consensus" and "upgradeable" rules to simply be
>    one set of rules, consisting of consensus checks plus additional
>    restrictions, all of which must be included. The new "Extensions"
>    section allows validators to output the state "consensus-valid"
>    if they really don't want to check the additional restrictions.
>
> 3. The "inconclusive" state, which was originally used for what I've
>    called "consensus-valid", now indicates that a validator does not
>    understand the script that it is checking (also described in the
>    new "Extensions" section). The goal is that implementors are able
>    to be meaningfully BIP-0322 while only supporting a subset of
>    Script, e.g. the templates that their own software supports, or
>    Miniscript, or the non-raw non-address set of output descriptors,
>    or whatever.
>
>    We have seen opposition to supporting BIP-322, e.g. [1] because
>    of the requirement that you either have a full script interpreter
>    (plus an open-ended list of Core's standardness flags, which is
>    not even available through libbitcoinconsensus) or nothing. On
>    the other hand, the vast majority of outputs are single-key p2pkh,
>    p2pkwh or p2sh-wpkh.
>
> The new text is here (and for posterity I will also include it
> inline below, though unless Github deletes it it will be easier
> to read in rendered form):
>
> https://github.com/apoelstra/bips/blob/2020-12--bip322-overhaul/bip-0322.mediawiki
>
> I'll also PR this to the BIPs repo in the next day or two, and
> comments on Github are then welcome.
>
>
> [1] https://bitcointalk.org/index.php?topic=5261605.0
>
>
>
> * * * * * Full text of the above link * * * * *
>
> <pre>
>   BIP: 322
>   Layer: Applications
>   Title: Generic Signed Message Format
>   Author: Karl-Johan Alm <karljohan-alm at garage.co.jp>
>   Comments-Summary: No comments yet.
>   Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0322
>   Status: Draft
>   Type: Standards Track
>   Created: 2018-09-10
>   License: CC0-1.0
> </pre>
>
> == Abstract ==
>
> A standard for interoperable signed messages based on the Bitcoin Script format, either for proving fund availability, or committing to a message as the intended recipient of funds sent to the invoice address.
>
> == Motivation ==
>
> The current message signing standard only works for P2PKH (1...) invoice addresses. We propose to extend and generalize the standard by using a Bitcoin Script based approach. This ensures that any coins, no matter what script they are controlled by, can in-principle be signed for. For easy interoperability with existing signing hardware, we also define a signature message format which resembles a Bitcoin transaction (except that it contains an invalid input, so it cannot be spent on any real network).
>
> Additionally, the current message signature format uses ECDSA signatures which do not commit to the public key, meaning that they do not actually prove knowledge of any secret keys. (Indeed, valid signatures can be tweaked by 3rd parties to become valid signatures on certain related keys.)
>
> Ultimately no message signing protocol can actually prove control of funds, both because a signature is obsolete as soon as it is created, and because the possessor of a secret key may be willing to sign messages on others' behalf even if it would not sign actual transactions. No signmessage protocol can fix these limitations.
>
> == Types of Signatures ==
>
> This BIP specifies three formats for signing messages: ''legacy'', ''simple'' and ''full''. Additionally, a variant of the ''full'' format can be used to demonstrate control over a set of UTXOs.
>
> === Legacy ===
>
> New proofs should use the new format for all invoice address formats, including P2PKH.
>
> The legacy format MAY be used, but must be restricted to the legacy P2PKH invoice address format.
>
> === Simple ===
>
> A ''simple'' signature consists of a witness stack, consensus encoded as a vector of vectors of bytes, and base64-encoded. Validators should construct <code>to_spend</code> and <code>to_sign</code> as defined below, with default values for all fields except that
>
> * <code>message_hash</code> is a BIP340-tagged hash of the message, as specified below
> * <code>message_challenge</code> in <code>to_spend</code> is set to the scriptPubKey being signed with
> * <code>message_signature</code> in <code>to_sign</code> is set to the provided simple signature.
>
> and then proceed as they would for a full signature.
>
> === Full ===
>
> Full signatures follow an analogous specification to the BIP-325 challenges and solutions used by Signet.
>
> Let there be two virtual transactions to_spend and to_sign.
>
> The "to_spend" transaction is:
>
>     nVersion = 0
>     nLockTime = 0
>     vin[0].prevout.hash = 0000...000
>     vin[0].prevout.n = 0xFFFFFFFF
>     vin[0].nSequence = 0
>     vin[0].scriptSig = OP_0 PUSH32[ message_hash ]
>     vin[0].scriptWitness = []
>     vout[0].nValue = 0
>     vout[0].scriptPubKey = message_challenge
>
> where <code>message_hash</code> is a BIP340-tagged hash of the message, i.e. sha256_tag(m), where tag = <code>BIP0322-signed-message</code>, and <code>message_challenge</code> is the to be proven (public) key script.
>
> The "to_sign" transaction is:
>
>     nVersion = 0 or as appropriate (e.g. 2, for time locks)
>     nLockTime = 0 or as appropriate (for time locks)
>     vin[0].prevout.hash = to_spend.txid
>     vin[0].prevout.n = 0
>     vin[0].nSequence = 0 or as appropriate (for time locks)
>     vin[0].scriptWitness = message_signature
>     vout[0].nValue = 0
>     vout[0].scriptPubKey = OP_RETURN
>
> A full signature consists of the base64-encoding of the to_spend and to_sign transactions concatenated in standard network serialisation.
>
> === Full (Proof of Funds) ===
>
> A signer may construct a proof of funds, demonstrating control of a set of UTXOs, by constructing a full signature as above, with the following modifications.
>
> * <code>message_challenge</code> is unused and shall be set to <code>OP_TRUE</code>
> * Similarly, <code>message_signature</code> is then empty.
> * All outputs that the signer wishes to demonstrate control of are included as additional outputs to <code>to_sign</code>, and their witness and scriptSig data should be set as though these outputs were actually being spent.
>
> Unlike an ordinary signature, validators of a proof of funds need access to the current UTXO set, to learn that the claimed inputs exist on the blockchain, and to learn their scriptPubKeys.
>
> == Detailed Specification ==
>
> For all signature types, except legacy, the <code>to_spend</code> and <code>to_sign</code> transactions must be valid transactions which pass all consensus checks, except of course that the output with prevout <code>000...000:FFFFFFFF</code> does not exist.
>
> We additionally require the following restrictions be met.
>
> * All signatures must use the SIGHASH_ALL flag.
> * The use of <code>CODESEPARATOR</code> or <code>FindAndDelete</code> is forbidden.
> * The use of NOPs reserved for upgrades is forbidden.
> * The use of segwit versions greater than 1 are forbidden.
> * <code>LOW_S</code>, <code>STRICTENC</code> and <code>NULLFAIL</code>: valid ECDSA signatures must be strictly DER-encoded and have a low-S value; invalid ECDSA signature must be the empty push
> * <code>MINIMALDATA</code>: all pushes must be minimally encoded
> * <code>CLEANSTACK</code>: require that only a single stack element remains after evaluation
> * <code>MINIMALIF</code>: the argument of <code>IF</code>/<code>NOTIF</code> must be exactly 0x01 or empty push
>
> Future versions of this BIP may relax these rules, in particular those around NOPs and future Segwit versions, as they are deployed on Bitcoin.
>
> === Verification ===
>
> Validation consists of the following steps. A validator is given as input an address ''A'' (which may be omitted in a proof-of-funds), signature ''s'' and message ''m'', and outputs one of four states (although validators are only required to be able to output the first and last):
> * ''valid'' indicates that the signature passed all checks described below
> * ''valid at time t and age s'' indicates that the signature has set timelocks but is otherwise valid (see "Extensions" below)
> * ''consensus-valid'' indicates that the signature passed validation except for the additonal restrictions in the above section (see "Extensions" below)
> * ''inconclusive'' means the validator was unable to check the scripts (see "Extensions" below)
> * ''invalid'' means none of the other states
>
> # Decode ''s'' as the transactions <code>to_sign</code> and <code>to_spend</code>
> # Confirm that <code>message_hash</code> is the correct hash of ''m''
> # Confirm that <code>message_challenge</code> is the scriptPubKey corresponding to ''A'' if ''A'' is present, and otherwise must be <code>OP_TRUE</code>
> # Confirm that all other fields are set as specified above; in particular that
> ** <code>to_spend</code> has exactly one input and one output
> ** <code>to_sign</code> has at least one input and its first input spends the output of </code>to_spend</code>
> ** <code>to_sign</code> has exactly one output, as specified above
> # Confirm that the two transactions together satisfy all consensus rules, except for <code>to_spend</code>'s missing input, and except that ''nSequence'' of <code>to_sign</code>'s first input and ''nLockTime'' of <code>to_sign</code> are not checked.
> # Confirm that all of the above restrictions are met.
>
> If the above conditions are met, the signature is considered ''valid''. Otherwise the signature is ''invalid''.
>
> === Signing ===
>
> Signers who control an address ''A'' who wish to sign a message ''m'' act as follows:
>
> # They construct <code>to_spend</code> and <code>to_sign</code> as specified above, using the scriptPubKey of ''A'' for <code>message_challenge</code> and tagged hash of ''m'' as <code>message_hash</code>.
> # Optionally, they may set nLockTime of <code>to_sign</code> or nSequence of its first input.
> # Optionally, they may add any additional outputs to <code>to_sign</code> that they wish to prove control of.
> # They satisfy <code>to_sign</code> as they would any other transaction.
>
> They then encode their signature, choosing either ''simple'' or ''full'' as follows:
>
> * If they added no inputs to <code>to_sign</code>, left nSequence and nLockTime at 0, and ''A'' is a Segwit address (either pure or P2SH-wrapped), then they may base64-encode <code>message_signature</code>
> * Otherwise they must base64-encode the concatenation of <code>to_spend</code> followed by <code>to_sign</code>.
>
> == Extensions ==
>
> To ease implementation, we allow some additional states to be output rather than ''valid'' or ''invalid''. Users who do not understand or who do not wish to deal with these states may treat them as ''invalid''.
>
> === Timelocks ===
>
> If the nLockTime of <code>to_sign</code> is set to ''t'', and the nSequence of the first input of <code>to_sign</code> is set to ''s'', the validator may output the state ''valid at time t and age s''.
>
> If both ''t'' and ''s'' are 0, the validator must instead output ''valid''.
>
> Users may then wish to interpret this state as ''valid'' or ''invalid'' relative to the state of the current blockchain, but the rules for doing so are out of scope of this BIP.
>
> === Incomplete Validation ===
>
> Some validators may not wish to implement a full script interpreter, choosing instead to support only specific script templates, or only Miniscript, for example. In this case, if they are unable to execute the scripts used by <code>to_sign</code>, they should output the state ''inconclusive''.
>
> Users should interpret this state as the same thing as ''invalid'', although take it as a sign that they should find more capable software.
>
> === Consensus-Only Validation ===
>
> Validators which are only able to check consensus-correctness of witnesses, but not the additional restrictions imposed by this BIP, may output the state ''consensus-valid'' to indicate that a signature has passed all consensus and structural checks.
>
> Users should interpret this state as the same thing as ''valid'' but be aware that other software may fail to validate the same signature.
>
> == Compatibility ==
>
> This specification is backwards compatible with the legacy signmessage/verifymessage specification through the special case as described above.
>
> == Reference implementation ==
>
> TODO
>
> == Acknowledgements ==
>
> Thanks to David Harding, Jim Posen, Kalle Rosenbaum, Pieter Wuille, Andrew Poelstra, and many others for their feedback on the specification.
>
> == References ==
>
> # Original mailing list thread: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015818.html
>
> == Copyright ==
>
> This document is licensed under the Creative Commons CC0 1.0 Universal license.
>
> == Test vectors ==
>
> TODO
>
> * * * * * End full text * * * * *
>
> --
> Andrew Poelstra
> Director of Research, Blockstream
> Email: apoelstra at wpsoftware.net
> Web:   https://www.wpsoftware.net/andrew
>
> The sun is always shining in space
>     -Justin Lewis-Webster
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From bitcoin-dev at wuille.net  Mon Dec 21 22:57:15 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Mon, 21 Dec 2020 22:57:15 +0000
Subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements
In-Reply-To: <CALJw2w4bFp8qcxNzz7hn_ZeGG8WWTPu-mRv6A4cPt66EHimyeg@mail.gmail.com>
References: <20201218152720.GW106279@boulet>
 <CALJw2w4bFp8qcxNzz7hn_ZeGG8WWTPu-mRv6A4cPt66EHimyeg@mail.gmail.com>
Message-ID: <Xpjf4qIbUPHa_K-yS1GRlsG4rVXBR9OHgzsxjgABhw0hg7jPFn4l4wwgVH_1iRVR5jFDK2cUb0qsbA1FQKiQZRTFPh77MGibgaVUaVbB_Ng=@wuille.net>

On Sunday, December 20, 2020 9:37 PM, Karl-Johan Alm via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks a lot for taking the time to brush up the BIP. For what it's
> worth, I am all for these changes, and I see them as clear
> improvements all around.
>
> IIRC Pieter was the one who originally suggested the two-checks
> approach (invalid, inconclusive, valid) which is being modified here,
> so would be good if you chimed in (or not -- which I'll assume means
> you don't mind).

I agree with the idea of permitting incomplete validators to return inconclusive as well. That doesn't really reduce the functionality (given that "inconclusive" was already a potential result), and it obviously makes it much more accessible to a variety of software.

This suggestion breaks the original use of inconclusive though: the ability to detect that future features are used in the signature. The idea was to use divergence between "consensus valid" and "standardness valid" as a proxy for future extensions to be detected (e.g. OP_NOPn, future witness versions, ...). I think it's undesirable that these things now become unconditionally invalid (until the BIP is updated, but once that happens old validators will give a different result than new ones).

Since the BIP no longer relies on a nebulous concept of standardness, and instead specifically defines which standardness features are to be considered, this seems easy to fix: whenever validation fails due to any of those, require reporting inconclusive instead of invalid (unless of course something actually invalid also happens). In practice I guess you'd implement that (in capable validators) by still doing validation twice, once with all features enabled that distinguish between valid/invalid, and if valid, again but now with the features enabled that distinguish between valid and (invalid or inconclusive).

Cheers,

--
Pieter


From bitcoin-dev at wuille.net  Tue Dec 22 00:22:37 2020
From: bitcoin-dev at wuille.net (Pieter Wuille)
Date: Tue, 22 Dec 2020 00:22:37 +0000
Subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements
In-Reply-To: <Xpjf4qIbUPHa_K-yS1GRlsG4rVXBR9OHgzsxjgABhw0hg7jPFn4l4wwgVH_1iRVR5jFDK2cUb0qsbA1FQKiQZRTFPh77MGibgaVUaVbB_Ng=@wuille.net>
References: <20201218152720.GW106279@boulet>
 <CALJw2w4bFp8qcxNzz7hn_ZeGG8WWTPu-mRv6A4cPt66EHimyeg@mail.gmail.com>
 <Xpjf4qIbUPHa_K-yS1GRlsG4rVXBR9OHgzsxjgABhw0hg7jPFn4l4wwgVH_1iRVR5jFDK2cUb0qsbA1FQKiQZRTFPh77MGibgaVUaVbB_Ng=@wuille.net>
Message-ID: <pa8YeCM--QSIGM9vegsiOzaxoLyXm55KTGQBZJk2Waw6blIz3l_RxY-rgKRQ40LmJupOmL-orWwfY7tVpDVboXd4BCCpZZEbC30l8HDum2k=@wuille.net>

On Monday, December 21, 2020 2:57 PM, Pieter Wuille via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sunday, December 20, 2020 9:37 PM, Karl-Johan Alm via bitcoin-dev bitcoin-dev at lists.linuxfoundation.org wrote:
>
> > Thanks a lot for taking the time to brush up the BIP. For what it's
> > worth, I am all for these changes, and I see them as clear
> > improvements all around.
> > IIRC Pieter was the one who originally suggested the two-checks
> > approach (invalid, inconclusive, valid) which is being modified here,
> > so would be good if you chimed in (or not -- which I'll assume means
> > you don't mind).
>
> I agree with the idea of permitting incomplete validators to return inconclusive as well. That doesn't really reduce the functionality (given that "inconclusive" was already a potential result), and it obviously makes it much more accessible to a variety of software.
>
> This suggestion breaks the original use of inconclusive though: the ability to detect that future features are used in the signature. The idea was to use divergence between "consensus valid" and "standardness valid" as a proxy for future extensions to be detected (e.g. OP_NOPn, future witness versions, ...). I think it's undesirable that these things now become unconditionally invalid (until the BIP is updated, but once that happens old validators will give a different result than new ones).
>
> Since the BIP no longer relies on a nebulous concept of standardness, and instead specifically defines which standardness features are to be considered, this seems easy to fix: whenever validation fails due to any of those, require reporting inconclusive instead of invalid (unless of course something actually invalid also happens). In practice I guess you'd implement that (in capable validators) by still doing validation twice, once with all features enabled that distinguish between valid/invalid, and if valid, again but now with the features enabled that distinguish between valid and (invalid or inconclusive).

Re-reading your proposed text, I'm wondering if the "consensus-only validation" extension is intended to replace the inconclusive-due-to-consensus-and-standardness-differ state. If so, I don't think it does, and regardless it doesn't seem very useful.

What I'm suggestion could be specified this way:
* If validator understands the script:
  * If signature is consensus valid (as far as the validator knows):
    * If signature is not known to trigger standardness rules intended for future extension (well-defined set of rules listed in BIP, and revisable): return valid
    * Otherwise: return inconclusive
  * Otherwise: return invalid
* Otherwise: return inconclusive

Or in other words: every signature has a well-defined result (valid, invalid, inconclusive) + validators may choose to report inconclusive for anything they don't understand.

This has the property that as long as new consensus rules only change things that were covered under for-future-extension standardness rules, no two validators will ever claim valid and invalid for the same signature. Only valid+inconclusive or invalid+inconclusive.

Cheers,

--
Pieter


From apoelstra at wpsoftware.net  Tue Dec 22 01:11:42 2020
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Tue, 22 Dec 2020 01:11:42 +0000
Subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements
In-Reply-To: <pa8YeCM--QSIGM9vegsiOzaxoLyXm55KTGQBZJk2Waw6blIz3l_RxY-rgKRQ40LmJupOmL-orWwfY7tVpDVboXd4BCCpZZEbC30l8HDum2k=@wuille.net>
References: <20201218152720.GW106279@boulet>
 <CALJw2w4bFp8qcxNzz7hn_ZeGG8WWTPu-mRv6A4cPt66EHimyeg@mail.gmail.com>
 <Xpjf4qIbUPHa_K-yS1GRlsG4rVXBR9OHgzsxjgABhw0hg7jPFn4l4wwgVH_1iRVR5jFDK2cUb0qsbA1FQKiQZRTFPh77MGibgaVUaVbB_Ng=@wuille.net>
 <pa8YeCM--QSIGM9vegsiOzaxoLyXm55KTGQBZJk2Waw6blIz3l_RxY-rgKRQ40LmJupOmL-orWwfY7tVpDVboXd4BCCpZZEbC30l8HDum2k=@wuille.net>
Message-ID: <20201222011142.GF106279@boulet>

On Tue, Dec 22, 2020 at 12:22:37AM +0000, Pieter Wuille via bitcoin-dev wrote:
> 
> Re-reading your proposed text, I'm wondering if the "consensus-only validation" extension is intended to replace the inconclusive-due-to-consensus-and-standardness-differ state. If so, I don't think it does, and regardless it doesn't seem very useful.
> 
> What I'm suggestion could be specified this way:
> * If validator understands the script:
>   * If signature is consensus valid (as far as the validator knows):
>     * If signature is not known to trigger standardness rules intended for future extension (well-defined set of rules listed in BIP, and revisable): return valid
>     * Otherwise: return inconclusive
>   * Otherwise: return invalid
> * Otherwise: return inconclusive
> 
> Or in other words: every signature has a well-defined result (valid, invalid, inconclusive) + validators may choose to report inconclusive for anything they don't understand.
> 
> This has the property that as long as new consensus rules only change things that were covered under for-future-extension standardness rules, no two validators will ever claim valid and invalid for the same signature. Only valid+inconclusive or invalid+inconclusive.
>

I like it!

My thinking regarding standardness vs consensus rules was essentially that
I wanted to enforce the included standardness rules for anti-malleability
reasons, i.e. the hope that for "normal scripts" we would get strong signatures,
which may be important for anti-DoS reasons. (What I mean by this is that
if you can easily create mutations of signatures, it may confuse software
in similar ways to the Gox-era malleability attacks on wallet software of
the time.) But conversely, it is hard to enforce these rules as an
implementor, because libbitcoinconsensus does not expose them. So allowing
both forms of validation, to me, was an attempt to encourage adoption
rather than anything principled.

I didn't even consider the idea that validators should be able to signal "this
signature appears to use future consensus rules", although I should have been
clued in by your "upgradeable rules" language that this was your goal. Now that
you say this, it's obvious that this is desireable, and also obvious that using
the "inconclusive" state is an elegant way to achieve this.

I also agree that "confirming validators should never disagree on valid vs
invalid" is a good design goal and we should make that explicit.


I'll add a commit to my PR at https://github.com/bitcoin/bips/pull/1048 which
adds these thoughts.

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201222/0486ba26/attachment.sig>

From mnokhb at gmail.com  Tue Dec 22 14:43:11 2020
From: mnokhb at gmail.com (monokh)
Date: Tue, 22 Dec 2020 14:43:11 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
Message-ID: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>

Hi

This is a first draft of a BIP we intend to submit. The main intention is
to define a simple interface that wallets and applications can agree on
that would cover the vast majority of use cases. This can enable writing
bitcoin applications (e.g. time lock, multi sig) on the web that can be
seamlessly used with any compatible wallets. We have implementations of
such examples but I don't want to turn this thread into a promotion and
rather focus on the spec.

Appreciate input from the list. Please share if there are existing efforts,
relevant specs or use cases.

------------------------------

A wallet interface specification for bitcoin applications

## Abstract

This BIP describes an API for Bitcoin wallets and applications as a
standard.

## Summary

Bitcoin wallets should expose their address derivation and signing
functions to external applications. The interface would be expressed as
follows in javascript:

```
{
// Wallet Metadata
wallet: {
name: 'Bitcoin Core'
},

// Request access to the wallet for the current host
async enable: (),

// Request addresses and signatures from wallet
async request ({ method, params })
}
```

In the web context the interface could be exposed at the top level of a
webpage, for example under `window.bitcoin`. However this spec does not
intend to define any standards for how and where the interfaces should be
exposed.

## Motivation

Due to the seldom available APIs exposed by wallets, applications (web or
otherwise) are limited in how they are able to interact. Generally only
simple sends have been available. A more robust API that introduces other
requests will promote richer Bitcoin applications.

Additionally, wallet APIs have frequently included inconsistencies in their
interfaces and behaviour. This has required applications to build and
maintain a separate client for each wallet, increasing the risk of bugs and
unintended behaviour as well as being a limiting factor for the adoption of
usable bitcoin applications.

With a standardised wallet API:

- Wallets have a clear API to implement
- Applications have a clear expectation of wallet interface and behaviour
- Applications become agnostic to the wallet specifics, increasing choice
for users

If more wallets implement the specification, applications will be developed
more confidently by benefiting from the wallet interoperability. This
creates a positive feedback loop.

## Specification

For simplicity, the interface is defined in the context of web applications
running in the browser (JS) however, they are simple enough to be easily
implemented in other contexts.

### General Rules

- For sensitive functions (e.g. signing), wallet software should always
prompt the user for confirmation

### Types

**UserDeniedError**
An error type indicating that the application's request has been denied by
the user
Type: Error

**Hex**
Type: String
Example:
`"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`

**Address**
Address details
Type: Object
Example:

```
{
"address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
"publicKey":
"02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
"derivationPath": "84'/1'/0'/0/0"
}
```

### API

The wallet must implement the following methods.

**enable**

The enable call prompts the user for access to the wallet.

If successful, it resolves to an address (`**Address**` type) of the
wallet. Typically the first external address to be used as an identity.

**`UserDeniedError`** will be thrown if the request is rejected.

**request**

The request method must take one parameter in the following format:

```
{
"method": "wallet_methodName",
"params": ["foo", "bar", "baz"]
}
```

For a list of mandatory methods see Table

The wallet should reject request calls unless `enable` has been resolved.

Sensitive requests that involve signing should always prompt the user for
confirmation

On success the request should resolve to the response as defined in the
method table.

**`UserDeniedError`** will be thrown if the request is rejected.

**Mandatory methods**

method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change
= false`]
return: `[ Address ]`
error: UserDeniedError

method: `wallet_signMessage` params: `[ message, address ]`
return: Signature `Hex`
error: UserDeniedError

method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`
return: `psbtBase64`
error: UserDeniedError

method: `wallet_getConnectedNetwork` params: `[]`
return: Network object `mainnet` | `testnet` | `regetst`
error: UserDeniedError

## Rationale

The purpose of the API is to expose a set of commonly used wallet
operations. In addition, it should be flexible enough to serve for other
requests such as node RPC calls.

**Why is there a singular request call instead of named methods?**
The transport layer for the requests cannot be assumed, therefore it is
much more flexible to instead define an abstract format.

**Why are the mandatory methods so primitive? Where is getBalance,
getUtxos, ... ?**
A wallet need not worry about providing every possible scenario for usage.
The primitives of keys and signing can expose enough to applications to do
the rest. Applications should have flexibility in how they implement these
functions. It is the role of a library rather than the wallet.

## Security Implications

Great care should be taken when exposing wallet functionality externally as
the security and privacy of the user is at risk.

### Signing

Operations that trigger signing using private keys should be guarded behind
confirmation screens where the user is fully aware of the nature of the
transaction. In the example of a PSBT signature request, the outputs, the
inputs and which key is being used should be clearly marked.

### Privacy

Some api methods expose metadata about the user, such as public keys.
Depending on how privacy focused the wallet intends to be, the wallet could
protect these behind a confirmation. Commonly the wallet just needs to give
the origin access to all of its public keys, however it could also allow
the option to expose only selected derivation paths.

-monokh
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201222/23f9734a/attachment.html>

From achow101-lists at achow101.com  Tue Dec 22 20:12:22 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Tue, 22 Dec 2020 20:12:22 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
Message-ID: <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>

Hi All,

I have some updates on this after speaking with some people off-list.

Firstly, the version number will be set to 2. In most discussions, this 
proposal was being referred to as PSBT version 2, so it'll be easier and 
clearer to set the version number to 2.

For lock times, instead of a single? PSBT_IN_REQUIRED_LOCKTIME field, 
there will be 2 of them, one for a time based lock time, and the other 
for height based. These will be:
* PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer greater than or equal 
to 500000000 representing the minimum Unix timestamp that this input 
requires to be set as the transaction's lock time. Must be omitted in 
PSBTv0, and may be omitted in PSBTv2
* PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
 ? * Key: empty
 ? * Value: 32 bit unsigned little endian integer less than 500000000 
representing the minimum block height that this input requires to be set 
as the transaction's lock time. Must be omitted in PSBTv0, and may be 
omitted in PSBTv2.

Having two lock time fields is necessary due to the behavior where all 
inputs must use the same type of lock time (height or time). Thus if an 
input requires a particular type of lock time, it must set the requisite 
field. Any new inputs being added must be able to accommodate all 
existing inputs' lock time type. This means they either must not have a 
lock time specified (i.e. no OP_CLTV involved), or have branches that 
allow the acceptance of either type. If an input has a lock time type 
that is incompatible with the rest of the transaction, it must not be added.

PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback 
option if no input lock time fields are present. If there are input lock 
times, all lock time calculations must ignore it.

Any role which does lock time calculation will first check if there are 
input lock time fields. If there are not, it must then check for a 
PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the 
transaction's lock time. If it does not, the lock time is 0. If there 
are input lock time fields, it must choose the type which does not 
invalidate any inputs. The lock time is then determined to be the 
maximum value of all of the lock time fields for the chosen type.


Additionally, I would like to add a new global field:
* PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
 ? * Key: empty
 ? * Value: A single byte as a boolean. 0 for False, 1 for True. All 
other values ore prohibited. Must be omitted for PSBTv0, may be omitted 
in PSBTv2.

PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and 
outputs can be added to the PSBT. This flag may be set to True when 
inputs and outputs are being updated, signed, and finalized. However 
care must be taken when there are existing signatures. If this field is 
omitted or set to False, no further inputs and outputs may be added to 
the PSBT.

Several rules must be followed to ensure that adding additional inputs 
and outputs will not invalidate existing signatures. First, an input or 
output adder must check for any existing signatures in all of the other 
inputs. If there are none, the input or output may be added in any 
position. If there are one or more signatures, each signature's sighash 
type must be examined. Inputs may only be added if all existing 
signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all 
existing signatures use SIGHASH_NONE. If an input has a signature using 
SIGHASH_SINGLE, the same number of inputs and outputs must be added 
before that input and it's corresponding output. For all other sighash 
types (i.e. SIGHASH_ALL and any future sighash types), no inputs or 
outputs may be added to the PSBT. Specific exceptions can be made in the 
future for additional sighash types.

Furthermore, these newly added inputs must follow additional lock time 
rules. Because all signatures, regardless of sighash type, sign the 
transaction lock time, newly added inputs when there are existing 
signatures must have the same type of lock time used in the transaction, 
and must be less than or equal to the transaction lock time. It must not 
cause the transaction lock time to change, otherwise the signatures will 
be invalidated.


Lastly, to uniquely identify transactions for combiners, a txid can be 
computed from the information present in the PSBT. Internally, combiners 
can create an unsigned transaction given the transaction version, the 
input prevouts, the outputs, and the computed locktime. This can then be 
used to calculate a txid and thus used as a way to identify PSBTs. 
Combiners will need to do this for all version 2 PSBTs in order to avoid 
combining distinct transactions.


Andrew Chow

On 12/9/20 5:25 PM, Andrew Chow wrote:
> Hi All,
>
> I would like to propose a new PSBT version that addresses a few
> deficiencies in the current PSBT v0. As this will be backwards
> incompatible, a new PSBT version will be used, v1.
>
> The primary change is to truly have all input and output data for each
> in their respective maps. Instead of having to parse an unsigned
> transaction and lookup some data from there, and other data from the
> correct map, all of the data for an input will be contained in its map.
> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
> Thus I propose that the following fields be added:
>
> Global:
> * PSBT_GLOBAL_TX_VERSION = 0x02
>   ? * Key: empty
>   ? * Value: 32-bit little endian unsigned integer for the transaction
> version number. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
>   ? * Key: empty
>   ? * Value: 32 bit little endian unsigned integer for the preferred
> transaction lock time. Must be omitted in PSBT v0. May be provided in
> PSBT v1, assumed to be 0 if not provided.
> * PSBT_GLOBAL_INPUT_COUNT = 0x04
>   ? * Key: empty
>   ? * Value: Compact size unsigned integer. Number of inputs in this
> PSBT. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
>   ? * Key: empty
>   ? * Value: Compact size unsigned integer. Number of outputs in this
> PSBT. Must be provided in PSBT v1 and omitted in v0.
>
> Input:
> * PSBT_IN_PREVIOUS_TXID = 0x0e
>   ? * Key: empty
>   ? * Value: 32 byte txid of the previous transaction whose output at
> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
> omitted in v0.
> * PSBT_IN_OUTPUT_INDEX = 0x0f
>   ? * Key: empty
>   ? * Value: 32 bit little endian integer for the index of the output
> being spent. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_IN_SEQUENCE = 0x0f
>   ? * Key: empty
>   ? * Value: 32 bit unsigned little endian integer for the sequence
> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
> to be max sequence (0xffffffff) if not provided.
> * PSBT_IN_REQUIRED_LOCKTIME = 0x10
>   ? * Key: empty
>   ? * Value: 32 bit unsigned little endian integer for the lock time that
> this input requires. Must be omitted in PSBT v0. May be provided in PSBT
> v1, assumed to be 0 if not provided.
>
> Output:
> * PSBT_OUT_VALUE = 0x03
>   ? * Key: empty
>   ? * Value: 64-bit unsigned little endian integer for the output's
> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
> * PSBT_OUT_OUTPUT_SCRIPT = 0x04
>   ? * Key: empty
>   ? * Value: The script for this output. Otherwise known as the
> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
>
> This change allows for PSBT to be used in the construction of
> transactions. With these new fields, inputs and outputs can be added as
> needed. One caveat is that there is no longer a unique transaction
> identifier so more care must be taken when combining PSBTs.
> Additionally, adding new inputs and outputs must be done such that
> signatures are not invalidated. This may be harder to specify.
>
> An important thing to note in this proposal are the fields
> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
> transaction only has a single locktime yet a PSBT may have multiple
> locktimes. To choose the locktime for the transaction, finalizers must
> choose the maximum of all of the *_LOCKTIME fields.
> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
> be set. This field allows finalizers to choose a locktime that is high
> enough for all inputs without needing to understand the scripts
> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
> no inputs require a particular locktime.
>
> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
> needs the version number bump to enforce backwards incompatibility.
> However once the inputs and outputs of a PSBT are decided, a PSBT could
> be "downgraded" back to v0 by creating the unsigned transaction from the
> above fields, and then dropping these new fields.
>
> If the list finds that these changes are reasonable, I will write a PR
> to modify BIP 174 to incorporate them.
>
> Thanks,
> Andrew Chow



From luke at dashjr.org  Wed Dec 23 02:15:45 2020
From: luke at dashjr.org (Luke Dashjr)
Date: Wed, 23 Dec 2020 02:15:45 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
In-Reply-To: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
References: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
Message-ID: <202012230215.46394.luke@dashjr.org>

1) People should not be encouraged to write or use web browsers for their 
wallet.
2) You may want to look over earlier work in this area.

On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:
> Hi
>
> This is a first draft of a BIP we intend to submit. The main intention is
> to define a simple interface that wallets and applications can agree on
> that would cover the vast majority of use cases. This can enable writing
> bitcoin applications (e.g. time lock, multi sig) on the web that can be
> seamlessly used with any compatible wallets. We have implementations of
> such examples but I don't want to turn this thread into a promotion and
> rather focus on the spec.
>
> Appreciate input from the list. Please share if there are existing efforts,
> relevant specs or use cases.
>
> ------------------------------
>
> A wallet interface specification for bitcoin applications
>
> ## Abstract
>
> This BIP describes an API for Bitcoin wallets and applications as a
> standard.
>
> ## Summary
>
> Bitcoin wallets should expose their address derivation and signing
> functions to external applications. The interface would be expressed as
> follows in javascript:
>
> ```
> {
> // Wallet Metadata
> wallet: {
> name: 'Bitcoin Core'
> },
>
> // Request access to the wallet for the current host
> async enable: (),
>
> // Request addresses and signatures from wallet
> async request ({ method, params })
> }
> ```
>
> In the web context the interface could be exposed at the top level of a
> webpage, for example under `window.bitcoin`. However this spec does not
> intend to define any standards for how and where the interfaces should be
> exposed.
>
> ## Motivation
>
> Due to the seldom available APIs exposed by wallets, applications (web or
> otherwise) are limited in how they are able to interact. Generally only
> simple sends have been available. A more robust API that introduces other
> requests will promote richer Bitcoin applications.
>
> Additionally, wallet APIs have frequently included inconsistencies in their
> interfaces and behaviour. This has required applications to build and
> maintain a separate client for each wallet, increasing the risk of bugs and
> unintended behaviour as well as being a limiting factor for the adoption of
> usable bitcoin applications.
>
> With a standardised wallet API:
>
> - Wallets have a clear API to implement
> - Applications have a clear expectation of wallet interface and behaviour
> - Applications become agnostic to the wallet specifics, increasing choice
> for users
>
> If more wallets implement the specification, applications will be developed
> more confidently by benefiting from the wallet interoperability. This
> creates a positive feedback loop.
>
> ## Specification
>
> For simplicity, the interface is defined in the context of web applications
> running in the browser (JS) however, they are simple enough to be easily
> implemented in other contexts.
>
> ### General Rules
>
> - For sensitive functions (e.g. signing), wallet software should always
> prompt the user for confirmation
>
> ### Types
>
> **UserDeniedError**
> An error type indicating that the application's request has been denied by
> the user
> Type: Error
>
> **Hex**
> Type: String
> Example:
> `"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`
>
> **Address**
> Address details
> Type: Object
> Example:
>
> ```
> {
> "address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
> "publicKey":
> "02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
> "derivationPath": "84'/1'/0'/0/0"
> }
> ```
>
> ### API
>
> The wallet must implement the following methods.
>
> **enable**
>
> The enable call prompts the user for access to the wallet.
>
> If successful, it resolves to an address (`**Address**` type) of the
> wallet. Typically the first external address to be used as an identity.
>
> **`UserDeniedError`** will be thrown if the request is rejected.
>
> **request**
>
> The request method must take one parameter in the following format:
>
> ```
> {
> "method": "wallet_methodName",
> "params": ["foo", "bar", "baz"]
> }
> ```
>
> For a list of mandatory methods see Table
>
> The wallet should reject request calls unless `enable` has been resolved.
>
> Sensitive requests that involve signing should always prompt the user for
> confirmation
>
> On success the request should resolve to the response as defined in the
> method table.
>
> **`UserDeniedError`** will be thrown if the request is rejected.
>
> **Mandatory methods**
>
> method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change
> = false`]
> return: `[ Address ]`
> error: UserDeniedError
>
> method: `wallet_signMessage` params: `[ message, address ]`
> return: Signature `Hex`
> error: UserDeniedError
>
> method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`
> return: `psbtBase64`
> error: UserDeniedError
>
> method: `wallet_getConnectedNetwork` params: `[]`
> return: Network object `mainnet` | `testnet` | `regetst`
> error: UserDeniedError
>
> ## Rationale
>
> The purpose of the API is to expose a set of commonly used wallet
> operations. In addition, it should be flexible enough to serve for other
> requests such as node RPC calls.
>
> **Why is there a singular request call instead of named methods?**
> The transport layer for the requests cannot be assumed, therefore it is
> much more flexible to instead define an abstract format.
>
> **Why are the mandatory methods so primitive? Where is getBalance,
> getUtxos, ... ?**
> A wallet need not worry about providing every possible scenario for usage.
> The primitives of keys and signing can expose enough to applications to do
> the rest. Applications should have flexibility in how they implement these
> functions. It is the role of a library rather than the wallet.
>
> ## Security Implications
>
> Great care should be taken when exposing wallet functionality externally as
> the security and privacy of the user is at risk.
>
> ### Signing
>
> Operations that trigger signing using private keys should be guarded behind
> confirmation screens where the user is fully aware of the nature of the
> transaction. In the example of a PSBT signature request, the outputs, the
> inputs and which key is being used should be clearly marked.
>
> ### Privacy
>
> Some api methods expose metadata about the user, such as public keys.
> Depending on how privacy focused the wallet intends to be, the wallet could
> protect these behind a confirmation. Commonly the wallet just needs to give
> the origin access to all of its public keys, however it could also allow
> the option to expose only selected derivation paths.
>
> -monokh


From fiatjaf at alhur.es  Wed Dec 23 03:30:20 2020
From: fiatjaf at alhur.es (fiatjaf)
Date: Wed, 23 Dec 2020 00:30:20 -0300
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
Message-ID: <1768da5c6f0.f63a34dc413157.2741477427673569054@alhur.es>

Hi Andrew.

I'm just a lurker here and I have not much experience with PSBTs, but still let me pose this very obvious question and concern: isn't this change going to create a compatibility nightmare, with some software supporting version 1, others supporting version 2, and the ones that care enough about UX and are still maintained being forced to support both versions -- and for no very important reason except some improvements in the way data is structured?

Ultimately I don't think it should matter if some data is structured in not-the-best-possible way, as long as it is clear enough for the computer and for the libraries already written to deal with it. Backwards-compatibility and general interoperability is worth much more than anything else in these cases.

Also let me leave this article here, which I find very important (even if for some reason it ends up not being relevant to this specific case): http://scripting.com/2017/05/09/rulesForStandardsmakers.html

 ---- On Tue, 22 Dec 2020 17:12:22 -0300 Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote ----
 > Hi All,
 > 
 > I have some updates on this after speaking with some people off-list.
 > 
 > Firstly, the version number will be set to 2. In most discussions, this 
 > proposal was being referred to as PSBT version 2, so it'll be easier and 
 > clearer to set the version number to 2.
 > 
 > For lock times, instead of a single  PSBT_IN_REQUIRED_LOCKTIME field, 
 > there will be 2 of them, one for a time based lock time, and the other 
 > for height based. These will be:
 > * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
 >    * Key: empty
 >    * Value: 32 bit unsigned little endian integer greater than or equal 
 > to 500000000 representing the minimum Unix timestamp that this input 
 > requires to be set as the transaction's lock time. Must be omitted in 
 > PSBTv0, and may be omitted in PSBTv2
 > * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
 >    * Key: empty
 >    * Value: 32 bit unsigned little endian integer less than 500000000 
 > representing the minimum block height that this input requires to be set 
 > as the transaction's lock time. Must be omitted in PSBTv0, and may be 
 > omitted in PSBTv2.
 > 
 > Having two lock time fields is necessary due to the behavior where all 
 > inputs must use the same type of lock time (height or time). Thus if an 
 > input requires a particular type of lock time, it must set the requisite 
 > field. Any new inputs being added must be able to accommodate all 
 > existing inputs' lock time type. This means they either must not have a 
 > lock time specified (i.e. no OP_CLTV involved), or have branches that 
 > allow the acceptance of either type. If an input has a lock time type 
 > that is incompatible with the rest of the transaction, it must not be added.
 > 
 > PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback 
 > option if no input lock time fields are present. If there are input lock 
 > times, all lock time calculations must ignore it.
 > 
 > Any role which does lock time calculation will first check if there are 
 > input lock time fields. If there are not, it must then check for a 
 > PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the 
 > transaction's lock time. If it does not, the lock time is 0. If there 
 > are input lock time fields, it must choose the type which does not 
 > invalidate any inputs. The lock time is then determined to be the 
 > maximum value of all of the lock time fields for the chosen type.
 > 
 > 
 > Additionally, I would like to add a new global field:
 > * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
 >    * Key: empty
 >    * Value: A single byte as a boolean. 0 for False, 1 for True. All 
 > other values ore prohibited. Must be omitted for PSBTv0, may be omitted 
 > in PSBTv2.
 > 
 > PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and 
 > outputs can be added to the PSBT. This flag may be set to True when 
 > inputs and outputs are being updated, signed, and finalized. However 
 > care must be taken when there are existing signatures. If this field is 
 > omitted or set to False, no further inputs and outputs may be added to 
 > the PSBT.
 > 
 > Several rules must be followed to ensure that adding additional inputs 
 > and outputs will not invalidate existing signatures. First, an input or 
 > output adder must check for any existing signatures in all of the other 
 > inputs. If there are none, the input or output may be added in any 
 > position. If there are one or more signatures, each signature's sighash 
 > type must be examined. Inputs may only be added if all existing 
 > signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all 
 > existing signatures use SIGHASH_NONE. If an input has a signature using 
 > SIGHASH_SINGLE, the same number of inputs and outputs must be added 
 > before that input and it's corresponding output. For all other sighash 
 > types (i.e. SIGHASH_ALL and any future sighash types), no inputs or 
 > outputs may be added to the PSBT. Specific exceptions can be made in the 
 > future for additional sighash types.
 > 
 > Furthermore, these newly added inputs must follow additional lock time 
 > rules. Because all signatures, regardless of sighash type, sign the 
 > transaction lock time, newly added inputs when there are existing 
 > signatures must have the same type of lock time used in the transaction, 
 > and must be less than or equal to the transaction lock time. It must not 
 > cause the transaction lock time to change, otherwise the signatures will 
 > be invalidated.
 > 
 > 
 > Lastly, to uniquely identify transactions for combiners, a txid can be 
 > computed from the information present in the PSBT. Internally, combiners 
 > can create an unsigned transaction given the transaction version, the 
 > input prevouts, the outputs, and the computed locktime. This can then be 
 > used to calculate a txid and thus used as a way to identify PSBTs. 
 > Combiners will need to do this for all version 2 PSBTs in order to avoid 
 > combining distinct transactions.
 > 
 > 
 > Andrew Chow
 > 
 > On 12/9/20 5:25 PM, Andrew Chow wrote:
 > > Hi All,
 > >
 > > I would like to propose a new PSBT version that addresses a few
 > > deficiencies in the current PSBT v0. As this will be backwards
 > > incompatible, a new PSBT version will be used, v1.
 > >
 > > The primary change is to truly have all input and output data for each
 > > in their respective maps. Instead of having to parse an unsigned
 > > transaction and lookup some data from there, and other data from the
 > > correct map, all of the data for an input will be contained in its map.
 > > Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
 > > Thus I propose that the following fields be added:
 > >
 > > Global:
 > > * PSBT_GLOBAL_TX_VERSION = 0x02
 > >     * Key: empty
 > >     * Value: 32-bit little endian unsigned integer for the transaction
 > > version number. Must be provided in PSBT v1 and omitted in v0.
 > > * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
 > >     * Key: empty
 > >     * Value: 32 bit little endian unsigned integer for the preferred
 > > transaction lock time. Must be omitted in PSBT v0. May be provided in
 > > PSBT v1, assumed to be 0 if not provided.
 > > * PSBT_GLOBAL_INPUT_COUNT = 0x04
 > >     * Key: empty
 > >     * Value: Compact size unsigned integer. Number of inputs in this
 > > PSBT. Must be provided in PSBT v1 and omitted in v0.
 > > * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
 > >     * Key: empty
 > >     * Value: Compact size unsigned integer. Number of outputs in this
 > > PSBT. Must be provided in PSBT v1 and omitted in v0.
 > >
 > > Input:
 > > * PSBT_IN_PREVIOUS_TXID = 0x0e
 > >     * Key: empty
 > >     * Value: 32 byte txid of the previous transaction whose output at
 > > PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
 > > omitted in v0.
 > > * PSBT_IN_OUTPUT_INDEX = 0x0f
 > >     * Key: empty
 > >     * Value: 32 bit little endian integer for the index of the output
 > > being spent. Must be provided in PSBT v1 and omitted in v0.
 > > * PSBT_IN_SEQUENCE = 0x0f
 > >     * Key: empty
 > >     * Value: 32 bit unsigned little endian integer for the sequence
 > > number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
 > > to be max sequence (0xffffffff) if not provided.
 > > * PSBT_IN_REQUIRED_LOCKTIME = 0x10
 > >     * Key: empty
 > >     * Value: 32 bit unsigned little endian integer for the lock time that
 > > this input requires. Must be omitted in PSBT v0. May be provided in PSBT
 > > v1, assumed to be 0 if not provided.
 > >
 > > Output:
 > > * PSBT_OUT_VALUE = 0x03
 > >     * Key: empty
 > >     * Value: 64-bit unsigned little endian integer for the output's
 > > amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
 > > * PSBT_OUT_OUTPUT_SCRIPT = 0x04
 > >     * Key: empty
 > >     * Value: The script for this output. Otherwise known as the
 > > scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
 > >
 > > This change allows for PSBT to be used in the construction of
 > > transactions. With these new fields, inputs and outputs can be added as
 > > needed. One caveat is that there is no longer a unique transaction
 > > identifier so more care must be taken when combining PSBTs.
 > > Additionally, adding new inputs and outputs must be done such that
 > > signatures are not invalidated. This may be harder to specify.
 > >
 > > An important thing to note in this proposal are the fields
 > > PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
 > > transaction only has a single locktime yet a PSBT may have multiple
 > > locktimes. To choose the locktime for the transaction, finalizers must
 > > choose the maximum of all of the *_LOCKTIME fields.
 > > PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
 > > involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
 > > be set. This field allows finalizers to choose a locktime that is high
 > > enough for all inputs without needing to understand the scripts
 > > involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
 > > no inputs require a particular locktime.
 > >
 > > As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
 > > needs the version number bump to enforce backwards incompatibility.
 > > However once the inputs and outputs of a PSBT are decided, a PSBT could
 > > be "downgraded" back to v0 by creating the unsigned transaction from the
 > > above fields, and then dropping these new fields.
 > >
 > > If the list finds that these changes are reasonable, I will write a PR
 > > to modify BIP 174 to incorporate them.
 > >
 > > Thanks,
 > > Andrew Chow
 > 
 > 
 > _______________________________________________
 > bitcoin-dev mailing list
 > bitcoin-dev at lists.linuxfoundation.org
 > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
 > 

From mnokhb at gmail.com  Wed Dec 23 07:29:23 2020
From: mnokhb at gmail.com (monokh)
Date: Wed, 23 Dec 2020 07:29:23 +0000
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
In-Reply-To: <202012230215.46394.luke@dashjr.org>
References: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
 <202012230215.46394.luke@dashjr.org>
Message-ID: <CAPvWj7E3S9HxZgpw0bdDmso+3sXc-h0u15_528r11EZ3LY-wYA@mail.gmail.com>

Thanks for the input Luke.

> 1) People should not be encouraged to write or use web browsers for their
wallet.

Indeed. Holding keys in the browser can be very insecure, however the spec
is not limited to this. I will amend to make this clear. The same interface
can be used to communicate from a web context or even desktop application
with hardware wallets where keys are segregated safely. The prominent
hardware wallets already have such an interface. Unfortunately as there has
been no standardisation, an application must specifically provide an
implementation for each wallet to be compatible.

> 2) You may want to look over earlier work in this area.

Please share if you have specifics in mind. What has been considered were
mainly hardware wallet apis. The requests have been defined such that they
would be compatible. I will make references to such considerations in the
text. I welcome any feedback on what may be missing or problematic for
these providers - something I will also pursue outwith the thread.

-monokh

On Wed, Dec 23, 2020 at 2:15 AM Luke Dashjr <luke at dashjr.org> wrote:

> 1) People should not be encouraged to write or use web browsers for their
> wallet.
> 2) You may want to look over earlier work in this area.
>
> On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:
> > Hi
> >
> > This is a first draft of a BIP we intend to submit. The main intention is
> > to define a simple interface that wallets and applications can agree on
> > that would cover the vast majority of use cases. This can enable writing
> > bitcoin applications (e.g. time lock, multi sig) on the web that can be
> > seamlessly used with any compatible wallets. We have implementations of
> > such examples but I don't want to turn this thread into a promotion and
> > rather focus on the spec.
> >
> > Appreciate input from the list. Please share if there are existing
> efforts,
> > relevant specs or use cases.
> >
> > ------------------------------
> >
> > A wallet interface specification for bitcoin applications
> >
> > ## Abstract
> >
> > This BIP describes an API for Bitcoin wallets and applications as a
> > standard.
> >
> > ## Summary
> >
> > Bitcoin wallets should expose their address derivation and signing
> > functions to external applications. The interface would be expressed as
> > follows in javascript:
> >
> > ```
> > {
> > // Wallet Metadata
> > wallet: {
> > name: 'Bitcoin Core'
> > },
> >
> > // Request access to the wallet for the current host
> > async enable: (),
> >
> > // Request addresses and signatures from wallet
> > async request ({ method, params })
> > }
> > ```
> >
> > In the web context the interface could be exposed at the top level of a
> > webpage, for example under `window.bitcoin`. However this spec does not
> > intend to define any standards for how and where the interfaces should be
> > exposed.
> >
> > ## Motivation
> >
> > Due to the seldom available APIs exposed by wallets, applications (web or
> > otherwise) are limited in how they are able to interact. Generally only
> > simple sends have been available. A more robust API that introduces other
> > requests will promote richer Bitcoin applications.
> >
> > Additionally, wallet APIs have frequently included inconsistencies in
> their
> > interfaces and behaviour. This has required applications to build and
> > maintain a separate client for each wallet, increasing the risk of bugs
> and
> > unintended behaviour as well as being a limiting factor for the adoption
> of
> > usable bitcoin applications.
> >
> > With a standardised wallet API:
> >
> > - Wallets have a clear API to implement
> > - Applications have a clear expectation of wallet interface and behaviour
> > - Applications become agnostic to the wallet specifics, increasing choice
> > for users
> >
> > If more wallets implement the specification, applications will be
> developed
> > more confidently by benefiting from the wallet interoperability. This
> > creates a positive feedback loop.
> >
> > ## Specification
> >
> > For simplicity, the interface is defined in the context of web
> applications
> > running in the browser (JS) however, they are simple enough to be easily
> > implemented in other contexts.
> >
> > ### General Rules
> >
> > - For sensitive functions (e.g. signing), wallet software should always
> > prompt the user for confirmation
> >
> > ### Types
> >
> > **UserDeniedError**
> > An error type indicating that the application's request has been denied
> by
> > the user
> > Type: Error
> >
> > **Hex**
> > Type: String
> > Example:
> > `"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`
> >
> > **Address**
> > Address details
> > Type: Object
> > Example:
> >
> > ```
> > {
> > "address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
> > "publicKey":
> > "02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
> > "derivationPath": "84'/1'/0'/0/0"
> > }
> > ```
> >
> > ### API
> >
> > The wallet must implement the following methods.
> >
> > **enable**
> >
> > The enable call prompts the user for access to the wallet.
> >
> > If successful, it resolves to an address (`**Address**` type) of the
> > wallet. Typically the first external address to be used as an identity.
> >
> > **`UserDeniedError`** will be thrown if the request is rejected.
> >
> > **request**
> >
> > The request method must take one parameter in the following format:
> >
> > ```
> > {
> > "method": "wallet_methodName",
> > "params": ["foo", "bar", "baz"]
> > }
> > ```
> >
> > For a list of mandatory methods see Table
> >
> > The wallet should reject request calls unless `enable` has been resolved.
> >
> > Sensitive requests that involve signing should always prompt the user for
> > confirmation
> >
> > On success the request should resolve to the response as defined in the
> > method table.
> >
> > **`UserDeniedError`** will be thrown if the request is rejected.
> >
> > **Mandatory methods**
> >
> > method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1,
> change
> > = false`]
> > return: `[ Address ]`
> > error: UserDeniedError
> >
> > method: `wallet_signMessage` params: `[ message, address ]`
> > return: Signature `Hex`
> > error: UserDeniedError
> >
> > method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`
> > return: `psbtBase64`
> > error: UserDeniedError
> >
> > method: `wallet_getConnectedNetwork` params: `[]`
> > return: Network object `mainnet` | `testnet` | `regetst`
> > error: UserDeniedError
> >
> > ## Rationale
> >
> > The purpose of the API is to expose a set of commonly used wallet
> > operations. In addition, it should be flexible enough to serve for other
> > requests such as node RPC calls.
> >
> > **Why is there a singular request call instead of named methods?**
> > The transport layer for the requests cannot be assumed, therefore it is
> > much more flexible to instead define an abstract format.
> >
> > **Why are the mandatory methods so primitive? Where is getBalance,
> > getUtxos, ... ?**
> > A wallet need not worry about providing every possible scenario for
> usage.
> > The primitives of keys and signing can expose enough to applications to
> do
> > the rest. Applications should have flexibility in how they implement
> these
> > functions. It is the role of a library rather than the wallet.
> >
> > ## Security Implications
> >
> > Great care should be taken when exposing wallet functionality externally
> as
> > the security and privacy of the user is at risk.
> >
> > ### Signing
> >
> > Operations that trigger signing using private keys should be guarded
> behind
> > confirmation screens where the user is fully aware of the nature of the
> > transaction. In the example of a PSBT signature request, the outputs, the
> > inputs and which key is being used should be clearly marked.
> >
> > ### Privacy
> >
> > Some api methods expose metadata about the user, such as public keys.
> > Depending on how privacy focused the wallet intends to be, the wallet
> could
> > protect these behind a confirmation. Commonly the wallet just needs to
> give
> > the origin access to all of its public keys, however it could also allow
> > the option to expose only selected derivation paths.
> >
> > -monokh
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/d52102d4/attachment-0001.html>

From apoelstra at wpsoftware.net  Wed Dec 23 15:22:01 2020
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 23 Dec 2020 15:22:01 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <1768da5c6f0.f63a34dc413157.2741477427673569054@alhur.es>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <1768da5c6f0.f63a34dc413157.2741477427673569054@alhur.es>
Message-ID: <20201223152201.GM106279@boulet>

On Wed, Dec 23, 2020 at 12:30:20AM -0300, fiatjaf via bitcoin-dev wrote:
> Hi Andrew.
> 
> I'm just a lurker here and I have not much experience with PSBTs, but still let me pose this very obvious question and concern: isn't this change going to create a compatibility nightmare, with some software supporting version 1, others supporting version 2, and the ones that care enough about UX and are still maintained being forced to support both versions -- and for no very important reason except some improvements in the way data is structured?
>

Yes, software will have to support both versions for a long time (likely
forever, at least in the case of Core). But I think this is okay, for a
couple of reasons:

1. it is very easy to convert from the old to new format, and from new to
   old (unless the new one uses features unsupported by the old). Indeed,
   the conversion logic is essentially the same as the logic that the
   Extractor role uses, so there isn't even that much redundant code.

2. There actually isn't a lot of software using PSBT out there, and most
   of that that does use PSBT is under rapid development. The obvious
   exception to this deployed hardware wallets, but as far as "software
   developers supporting old things for the sake of old hardware wallets"
   I think this transition is an order of magnitude simpler to handle
   than many of the ad-hoc protocol changes that individual vendors have
   done. In other words this is a "fact of life", and not even one of
   the grosser ones.

3. PSBT is pretty-much a dumb pure data format, and the diff between the
   new format and the old is pretty small.

> Ultimately I don't think it should matter if some data is structured in not-the-best-possible way, as long as it is clear enough for the computer and for the libraries already written to deal with it. Backwards-compatibility and general interoperability is worth much more than anything else in these cases.
>

The reasons for switching to PSBT 2 are actually more than just structuring
the data in a cleaner way. I agree that if the point of this upgrade were
just elegance, it would not be worth the compatibility loss. But there are
practical limitations that this proposal eliminates:

1. PSBT provides no way to modify the set of inputs or outputs after the
   Creator role is done.

2. Because of this, it forces certain things (e.g. locktimes and sequence
   numbers) to be chosen by the Creator, who may not have all the relevant
   information, and who certainly might not have it before any Updaters
   have done their part.

as well, of course, as elegance reasons:

3. Parsers of the existing PSBT need to understand the Bitcoin transaction
   format just to learn e.g. how many inputs and outputs there are. It is
   impossible to parse a PSBT without also parsing (almost) the whole
   transaction.

4. Similarly to cross-check fields like 'non_witness_utxo' which are
   committed to in the transaction, you have to parse the whole transaction
   just to make sure that the purely-redundant data is correctly redundant.

5. If you put a 0-input transaction into a PSBT (which would be pointless
   because there's no way to add inputs, but it's not forbidden so your
   software still has to deal with this somehow..), you need a different
   transaction parser than the normal one, because there is an ambiguity
   related to segwit that PSBT resolves differently.

It's also worth considering that PSBT is a young protocol, and future
extensions will be easier starting from PSBT 2 than starting from the
original version.

 
> Also let me leave this article here, which I find very important (even if for some reason it ends up not being relevant to this specific case): http://scripting.com/2017/05/09/rulesForStandardsmakers.html
> 

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/05050b70/attachment.sig>

From apoelstra at wpsoftware.net  Wed Dec 23 15:55:42 2020
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 23 Dec 2020 15:55:42 +0000
Subject: [bitcoin-dev] BIP-0322 (generic signmessage) improvements
In-Reply-To: <pa8YeCM--QSIGM9vegsiOzaxoLyXm55KTGQBZJk2Waw6blIz3l_RxY-rgKRQ40LmJupOmL-orWwfY7tVpDVboXd4BCCpZZEbC30l8HDum2k=@wuille.net>
References: <20201218152720.GW106279@boulet>
 <CALJw2w4bFp8qcxNzz7hn_ZeGG8WWTPu-mRv6A4cPt66EHimyeg@mail.gmail.com>
 <Xpjf4qIbUPHa_K-yS1GRlsG4rVXBR9OHgzsxjgABhw0hg7jPFn4l4wwgVH_1iRVR5jFDK2cUb0qsbA1FQKiQZRTFPh77MGibgaVUaVbB_Ng=@wuille.net>
 <pa8YeCM--QSIGM9vegsiOzaxoLyXm55KTGQBZJk2Waw6blIz3l_RxY-rgKRQ40LmJupOmL-orWwfY7tVpDVboXd4BCCpZZEbC30l8HDum2k=@wuille.net>
Message-ID: <20201223155542.GN106279@boulet>

On Tue, Dec 22, 2020 at 12:22:37AM +0000, Pieter Wuille via bitcoin-dev wrote:
> 
> Re-reading your proposed text, I'm wondering if the "consensus-only validation" extension is intended to replace the inconclusive-due-to-consensus-and-standardness-differ state. If so, I don't think it does, and regardless it doesn't seem very useful.
> 
> What I'm suggestion could be specified this way:
> * If validator understands the script:
>   * If signature is consensus valid (as far as the validator knows):
>     * If signature is not known to trigger standardness rules intended for future extension (well-defined set of rules listed in BIP, and revisable): return valid
>     * Otherwise: return inconclusive
>   * Otherwise: return invalid
> * Otherwise: return inconclusive
> 
> Or in other words: every signature has a well-defined result (valid, invalid, inconclusive) + validators may choose to report inconclusive for anything they don't understand.
> 
> This has the property that as long as new consensus rules only change things that were covered under for-future-extension standardness rules, no two validators will ever claim valid and invalid for the same signature. Only valid+inconclusive or invalid+inconclusive.
>

I've updated my PR at https://github.com/bitcoin/bips/pull/1048

Differences:

1. I compacted all the validation states into three: valid at time/age T/S, invalid,
   and inconclusive.

2. "Inconclusive" means either an "upgradeable rule" failed, e.g. use of a NOP or a
   bad network version, or the validator just didn't understand the scripts.

3. I removed the "Extensions" sections now everything is in the main protocol.

4. I removed the "to_sign" transaction from the wire serialization, since after all
   this, it can always be inferred from the message and address. (This does mean,
   however, that there is no way to sign for scriptPubKeys that don't have addresses,
   e.g. bare public keys or multisigs. I don't think it's worth complicated the
   protocol for such obscure things.)

-- 
Andrew Poelstra
Director of Research, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

The sun is always shining in space
    -Justin Lewis-Webster

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/858f723b/attachment.sig>

From omarshib at gmail.com  Wed Dec 23 11:44:52 2020
From: omarshib at gmail.com (Omar Shibli)
Date: Wed, 23 Dec 2020 13:44:52 +0200
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
In-Reply-To: <CAPvWj7E3S9HxZgpw0bdDmso+3sXc-h0u15_528r11EZ3LY-wYA@mail.gmail.com>
References: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
 <202012230215.46394.luke@dashjr.org>
 <CAPvWj7E3S9HxZgpw0bdDmso+3sXc-h0u15_528r11EZ3LY-wYA@mail.gmail.com>
Message-ID: <CAE3EOfh4zh5WubMF-QzWA6g3mKvpz7TLtc45usfU92xbmpn-qw@mail.gmail.com>

That's a great idea, in traditional banking there are wide initiatives to
standardize components between different actors, most widely used is Open
Banking , i think regardless of the usage, it could be hardware or
software, there is a big value in standrizating communications between
different components.

Here is more info about Open Banking:
https://fin.plaid.com/articles/what-is-the-open-banking-standard/#:~:text=The%20Open%20Banking%20Standard%20relies,data%20through%20their%20bank%20accounts

On Wed, Dec 23, 2020 at 10:42 AM monokh via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Thanks for the input Luke.
>
> > 1) People should not be encouraged to write or use web browsers for
> their wallet.
>
> Indeed. Holding keys in the browser can be very insecure, however the spec
> is not limited to this. I will amend to make this clear. The same interface
> can be used to communicate from a web context or even desktop application
> with hardware wallets where keys are segregated safely. The prominent
> hardware wallets already have such an interface. Unfortunately as there has
> been no standardisation, an application must specifically provide an
> implementation for each wallet to be compatible.
>
> > 2) You may want to look over earlier work in this area.
>
> Please share if you have specifics in mind. What has been considered were
> mainly hardware wallet apis. The requests have been defined such that they
> would be compatible. I will make references to such considerations in the
> text. I welcome any feedback on what may be missing or problematic for
> these providers - something I will also pursue outwith the thread.
>
> -monokh
>
> On Wed, Dec 23, 2020 at 2:15 AM Luke Dashjr <luke at dashjr.org> wrote:
>
>> 1) People should not be encouraged to write or use web browsers for their
>> wallet.
>> 2) You may want to look over earlier work in this area.
>>
>> On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:
>> > Hi
>> >
>> > This is a first draft of a BIP we intend to submit. The main intention
>> is
>> > to define a simple interface that wallets and applications can agree on
>> > that would cover the vast majority of use cases. This can enable writing
>> > bitcoin applications (e.g. time lock, multi sig) on the web that can be
>> > seamlessly used with any compatible wallets. We have implementations of
>> > such examples but I don't want to turn this thread into a promotion and
>> > rather focus on the spec.
>> >
>> > Appreciate input from the list. Please share if there are existing
>> efforts,
>> > relevant specs or use cases.
>> >
>> > ------------------------------
>> >
>> > A wallet interface specification for bitcoin applications
>> >
>> > ## Abstract
>> >
>> > This BIP describes an API for Bitcoin wallets and applications as a
>> > standard.
>> >
>> > ## Summary
>> >
>> > Bitcoin wallets should expose their address derivation and signing
>> > functions to external applications. The interface would be expressed as
>> > follows in javascript:
>> >
>> > ```
>> > {
>> > // Wallet Metadata
>> > wallet: {
>> > name: 'Bitcoin Core'
>> > },
>> >
>> > // Request access to the wallet for the current host
>> > async enable: (),
>> >
>> > // Request addresses and signatures from wallet
>> > async request ({ method, params })
>> > }
>> > ```
>> >
>> > In the web context the interface could be exposed at the top level of a
>> > webpage, for example under `window.bitcoin`. However this spec does not
>> > intend to define any standards for how and where the interfaces should
>> be
>> > exposed.
>> >
>> > ## Motivation
>> >
>> > Due to the seldom available APIs exposed by wallets, applications (web
>> or
>> > otherwise) are limited in how they are able to interact. Generally only
>> > simple sends have been available. A more robust API that introduces
>> other
>> > requests will promote richer Bitcoin applications.
>> >
>> > Additionally, wallet APIs have frequently included inconsistencies in
>> their
>> > interfaces and behaviour. This has required applications to build and
>> > maintain a separate client for each wallet, increasing the risk of bugs
>> and
>> > unintended behaviour as well as being a limiting factor for the
>> adoption of
>> > usable bitcoin applications.
>> >
>> > With a standardised wallet API:
>> >
>> > - Wallets have a clear API to implement
>> > - Applications have a clear expectation of wallet interface and
>> behaviour
>> > - Applications become agnostic to the wallet specifics, increasing
>> choice
>> > for users
>> >
>> > If more wallets implement the specification, applications will be
>> developed
>> > more confidently by benefiting from the wallet interoperability. This
>> > creates a positive feedback loop.
>> >
>> > ## Specification
>> >
>> > For simplicity, the interface is defined in the context of web
>> applications
>> > running in the browser (JS) however, they are simple enough to be easily
>> > implemented in other contexts.
>> >
>> > ### General Rules
>> >
>> > - For sensitive functions (e.g. signing), wallet software should always
>> > prompt the user for confirmation
>> >
>> > ### Types
>> >
>> > **UserDeniedError**
>> > An error type indicating that the application's request has been denied
>> by
>> > the user
>> > Type: Error
>> >
>> > **Hex**
>> > Type: String
>> > Example:
>> > `"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`
>> >
>> > **Address**
>> > Address details
>> > Type: Object
>> > Example:
>> >
>> > ```
>> > {
>> > "address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
>> > "publicKey":
>> > "02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
>> > "derivationPath": "84'/1'/0'/0/0"
>> > }
>> > ```
>> >
>> > ### API
>> >
>> > The wallet must implement the following methods.
>> >
>> > **enable**
>> >
>> > The enable call prompts the user for access to the wallet.
>> >
>> > If successful, it resolves to an address (`**Address**` type) of the
>> > wallet. Typically the first external address to be used as an identity.
>> >
>> > **`UserDeniedError`** will be thrown if the request is rejected.
>> >
>> > **request**
>> >
>> > The request method must take one parameter in the following format:
>> >
>> > ```
>> > {
>> > "method": "wallet_methodName",
>> > "params": ["foo", "bar", "baz"]
>> > }
>> > ```
>> >
>> > For a list of mandatory methods see Table
>> >
>> > The wallet should reject request calls unless `enable` has been
>> resolved.
>> >
>> > Sensitive requests that involve signing should always prompt the user
>> for
>> > confirmation
>> >
>> > On success the request should resolve to the response as defined in the
>> > method table.
>> >
>> > **`UserDeniedError`** will be thrown if the request is rejected.
>> >
>> > **Mandatory methods**
>> >
>> > method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1,
>> change
>> > = false`]
>> > return: `[ Address ]`
>> > error: UserDeniedError
>> >
>> > method: `wallet_signMessage` params: `[ message, address ]`
>> > return: Signature `Hex`
>> > error: UserDeniedError
>> >
>> > method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address]
>> ]`
>> > return: `psbtBase64`
>> > error: UserDeniedError
>> >
>> > method: `wallet_getConnectedNetwork` params: `[]`
>> > return: Network object `mainnet` | `testnet` | `regetst`
>> > error: UserDeniedError
>> >
>> > ## Rationale
>> >
>> > The purpose of the API is to expose a set of commonly used wallet
>> > operations. In addition, it should be flexible enough to serve for other
>> > requests such as node RPC calls.
>> >
>> > **Why is there a singular request call instead of named methods?**
>> > The transport layer for the requests cannot be assumed, therefore it is
>> > much more flexible to instead define an abstract format.
>> >
>> > **Why are the mandatory methods so primitive? Where is getBalance,
>> > getUtxos, ... ?**
>> > A wallet need not worry about providing every possible scenario for
>> usage.
>> > The primitives of keys and signing can expose enough to applications to
>> do
>> > the rest. Applications should have flexibility in how they implement
>> these
>> > functions. It is the role of a library rather than the wallet.
>> >
>> > ## Security Implications
>> >
>> > Great care should be taken when exposing wallet functionality
>> externally as
>> > the security and privacy of the user is at risk.
>> >
>> > ### Signing
>> >
>> > Operations that trigger signing using private keys should be guarded
>> behind
>> > confirmation screens where the user is fully aware of the nature of the
>> > transaction. In the example of a PSBT signature request, the outputs,
>> the
>> > inputs and which key is being used should be clearly marked.
>> >
>> > ### Privacy
>> >
>> > Some api methods expose metadata about the user, such as public keys.
>> > Depending on how privacy focused the wallet intends to be, the wallet
>> could
>> > protect these behind a confirmation. Commonly the wallet just needs to
>> give
>> > the origin access to all of its public keys, however it could also allow
>> > the option to expose only selected derivation paths.
>> >
>> > -monokh
>>
>> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201223/3dbdb744/attachment-0001.html>

From achow101-lists at achow101.com  Wed Dec 23 21:30:04 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Wed, 23 Dec 2020 21:30:04 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <1768da5c6f0.f63a34dc413157.2741477427673569054@alhur.es>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
 <1768da5c6f0.f63a34dc413157.2741477427673569054@alhur.es>
Message-ID: <a0b996d1-049c-1c7a-e8c1-a6bc3834b0bd@achow101.com>

Hi,

On 12/22/20 10:30 PM, fiatjaf wrote:
> Hi Andrew.
>
> I'm just a lurker here and I have not much experience with PSBTs, but still let me pose this very obvious question and concern: isn't this change going to create a compatibility nightmare, with some software supporting version 1, others supporting version 2, and the ones that care enough about UX and are still maintained being forced to support both versions -- and for no very important reason except some improvements in the way data is structured?
No, it is not just "improvements in the way data is structured."

The primary reason for these changes is to allow PSBT to properly 
support adding inputs and outputs. This is a feature that many people 
have requested, and the ways that people have been doing it are honestly 
just hacks and not really the right way to be doing that. These changes 
allow for that feature to be supported well.

Furthermore, it is possible to downgrade and upgrade PSBTs between the 
two versions, once all inputs and outputs have been decided. Since 
PSBTv2 is essentially just taking all of the normal transaction fields 
and grouping them all with the rest of the data for those inputs and 
outputs, it is easy to reconstruct a global unsigned transaction and 
turn a PSBTv2 into a PSBTv0. It is likewise just as easy to go the other 
way and break apart the global unsigned tx to turn a PSBTv0 into a 
PSBTv2. Originally, I had considered requiring that once a transaction 
was fully constructed it must be downgraded to a PSBTv0, but the 
structure changes that were made do make it easier to work with PSBT so 
I decided not to add this requirement.

Perhaps to maintain compatibility PSBT_GLOBAL_UNSIGNED_TX shouldn't be 
disallowed in PSBTv2 once the transaction is constructed? It would make 
things much more confusing though as it would no longer be a clean break.


Andrew Chow

> Ultimately I don't think it should matter if some data is structured in not-the-best-possible way, as long as it is clear enough for the computer and for the libraries already written to deal with it. Backwards-compatibility and general interoperability is worth much more than anything else in these cases.
>
> Also let me leave this article here, which I find very important (even if for some reason it ends up not being relevant to this specific case): http://scripting.com/2017/05/09/rulesForStandardsmakers.html
>
>   ---- On Tue, 22 Dec 2020 17:12:22 -0300 Andrew Chow via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote ----
>   > Hi All,
>   >
>   > I have some updates on this after speaking with some people off-list.
>   >
>   > Firstly, the version number will be set to 2. In most discussions, this
>   > proposal was being referred to as PSBT version 2, so it'll be easier and
>   > clearer to set the version number to 2.
>   >
>   > For lock times, instead of a single  PSBT_IN_REQUIRED_LOCKTIME field,
>   > there will be 2 of them, one for a time based lock time, and the other
>   > for height based. These will be:
>   > * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
>   >    * Key: empty
>   >    * Value: 32 bit unsigned little endian integer greater than or equal
>   > to 500000000 representing the minimum Unix timestamp that this input
>   > requires to be set as the transaction's lock time. Must be omitted in
>   > PSBTv0, and may be omitted in PSBTv2
>   > * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
>   >    * Key: empty
>   >    * Value: 32 bit unsigned little endian integer less than 500000000
>   > representing the minimum block height that this input requires to be set
>   > as the transaction's lock time. Must be omitted in PSBTv0, and may be
>   > omitted in PSBTv2.
>   >
>   > Having two lock time fields is necessary due to the behavior where all
>   > inputs must use the same type of lock time (height or time). Thus if an
>   > input requires a particular type of lock time, it must set the requisite
>   > field. Any new inputs being added must be able to accommodate all
>   > existing inputs' lock time type. This means they either must not have a
>   > lock time specified (i.e. no OP_CLTV involved), or have branches that
>   > allow the acceptance of either type. If an input has a lock time type
>   > that is incompatible with the rest of the transaction, it must not be added.
>   >
>   > PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback
>   > option if no input lock time fields are present. If there are input lock
>   > times, all lock time calculations must ignore it.
>   >
>   > Any role which does lock time calculation will first check if there are
>   > input lock time fields. If there are not, it must then check for a
>   > PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the
>   > transaction's lock time. If it does not, the lock time is 0. If there
>   > are input lock time fields, it must choose the type which does not
>   > invalidate any inputs. The lock time is then determined to be the
>   > maximum value of all of the lock time fields for the chosen type.
>   >
>   >
>   > Additionally, I would like to add a new global field:
>   > * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>   >    * Key: empty
>   >    * Value: A single byte as a boolean. 0 for False, 1 for True. All
>   > other values ore prohibited. Must be omitted for PSBTv0, may be omitted
>   > in PSBTv2.
>   >
>   > PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
>   > outputs can be added to the PSBT. This flag may be set to True when
>   > inputs and outputs are being updated, signed, and finalized. However
>   > care must be taken when there are existing signatures. If this field is
>   > omitted or set to False, no further inputs and outputs may be added to
>   > the PSBT.
>   >
>   > Several rules must be followed to ensure that adding additional inputs
>   > and outputs will not invalidate existing signatures. First, an input or
>   > output adder must check for any existing signatures in all of the other
>   > inputs. If there are none, the input or output may be added in any
>   > position. If there are one or more signatures, each signature's sighash
>   > type must be examined. Inputs may only be added if all existing
>   > signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all
>   > existing signatures use SIGHASH_NONE. If an input has a signature using
>   > SIGHASH_SINGLE, the same number of inputs and outputs must be added
>   > before that input and it's corresponding output. For all other sighash
>   > types (i.e. SIGHASH_ALL and any future sighash types), no inputs or
>   > outputs may be added to the PSBT. Specific exceptions can be made in the
>   > future for additional sighash types.
>   >
>   > Furthermore, these newly added inputs must follow additional lock time
>   > rules. Because all signatures, regardless of sighash type, sign the
>   > transaction lock time, newly added inputs when there are existing
>   > signatures must have the same type of lock time used in the transaction,
>   > and must be less than or equal to the transaction lock time. It must not
>   > cause the transaction lock time to change, otherwise the signatures will
>   > be invalidated.
>   >
>   >
>   > Lastly, to uniquely identify transactions for combiners, a txid can be
>   > computed from the information present in the PSBT. Internally, combiners
>   > can create an unsigned transaction given the transaction version, the
>   > input prevouts, the outputs, and the computed locktime. This can then be
>   > used to calculate a txid and thus used as a way to identify PSBTs.
>   > Combiners will need to do this for all version 2 PSBTs in order to avoid
>   > combining distinct transactions.
>   >
>   >
>   > Andrew Chow
>   >
>   > On 12/9/20 5:25 PM, Andrew Chow wrote:
>   > > Hi All,
>   > >
>   > > I would like to propose a new PSBT version that addresses a few
>   > > deficiencies in the current PSBT v0. As this will be backwards
>   > > incompatible, a new PSBT version will be used, v1.
>   > >
>   > > The primary change is to truly have all input and output data for each
>   > > in their respective maps. Instead of having to parse an unsigned
>   > > transaction and lookup some data from there, and other data from the
>   > > correct map, all of the data for an input will be contained in its map.
>   > > Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
>   > > Thus I propose that the following fields be added:
>   > >
>   > > Global:
>   > > * PSBT_GLOBAL_TX_VERSION = 0x02
>   > >     * Key: empty
>   > >     * Value: 32-bit little endian unsigned integer for the transaction
>   > > version number. Must be provided in PSBT v1 and omitted in v0.
>   > > * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
>   > >     * Key: empty
>   > >     * Value: 32 bit little endian unsigned integer for the preferred
>   > > transaction lock time. Must be omitted in PSBT v0. May be provided in
>   > > PSBT v1, assumed to be 0 if not provided.
>   > > * PSBT_GLOBAL_INPUT_COUNT = 0x04
>   > >     * Key: empty
>   > >     * Value: Compact size unsigned integer. Number of inputs in this
>   > > PSBT. Must be provided in PSBT v1 and omitted in v0.
>   > > * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
>   > >     * Key: empty
>   > >     * Value: Compact size unsigned integer. Number of outputs in this
>   > > PSBT. Must be provided in PSBT v1 and omitted in v0.
>   > >
>   > > Input:
>   > > * PSBT_IN_PREVIOUS_TXID = 0x0e
>   > >     * Key: empty
>   > >     * Value: 32 byte txid of the previous transaction whose output at
>   > > PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
>   > > omitted in v0.
>   > > * PSBT_IN_OUTPUT_INDEX = 0x0f
>   > >     * Key: empty
>   > >     * Value: 32 bit little endian integer for the index of the output
>   > > being spent. Must be provided in PSBT v1 and omitted in v0.
>   > > * PSBT_IN_SEQUENCE = 0x0f
>   > >     * Key: empty
>   > >     * Value: 32 bit unsigned little endian integer for the sequence
>   > > number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
>   > > to be max sequence (0xffffffff) if not provided.
>   > > * PSBT_IN_REQUIRED_LOCKTIME = 0x10
>   > >     * Key: empty
>   > >     * Value: 32 bit unsigned little endian integer for the lock time that
>   > > this input requires. Must be omitted in PSBT v0. May be provided in PSBT
>   > > v1, assumed to be 0 if not provided.
>   > >
>   > > Output:
>   > > * PSBT_OUT_VALUE = 0x03
>   > >     * Key: empty
>   > >     * Value: 64-bit unsigned little endian integer for the output's
>   > > amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
>   > > * PSBT_OUT_OUTPUT_SCRIPT = 0x04
>   > >     * Key: empty
>   > >     * Value: The script for this output. Otherwise known as the
>   > > scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
>   > >
>   > > This change allows for PSBT to be used in the construction of
>   > > transactions. With these new fields, inputs and outputs can be added as
>   > > needed. One caveat is that there is no longer a unique transaction
>   > > identifier so more care must be taken when combining PSBTs.
>   > > Additionally, adding new inputs and outputs must be done such that
>   > > signatures are not invalidated. This may be harder to specify.
>   > >
>   > > An important thing to note in this proposal are the fields
>   > > PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
>   > > transaction only has a single locktime yet a PSBT may have multiple
>   > > locktimes. To choose the locktime for the transaction, finalizers must
>   > > choose the maximum of all of the *_LOCKTIME fields.
>   > > PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
>   > > involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
>   > > be set. This field allows finalizers to choose a locktime that is high
>   > > enough for all inputs without needing to understand the scripts
>   > > involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
>   > > no inputs require a particular locktime.
>   > >
>   > > As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
>   > > needs the version number bump to enforce backwards incompatibility.
>   > > However once the inputs and outputs of a PSBT are decided, a PSBT could
>   > > be "downgraded" back to v0 by creating the unsigned transaction from the
>   > > above fields, and then dropping these new fields.
>   > >
>   > > If the list finds that these changes are reasonable, I will write a PR
>   > > to modify BIP 174 to incorporate them.
>   > >
>   > > Thanks,
>   > > Andrew Chow
>   >
>   >
>   > _______________________________________________
>   > bitcoin-dev mailing list
>   > bitcoin-dev at lists.linuxfoundation.org
>   > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>   >



From achow101-lists at achow101.com  Wed Dec 23 21:32:33 2020
From: achow101-lists at achow101.com (Andrew Chow)
Date: Wed, 23 Dec 2020 21:32:33 +0000
Subject: [bitcoin-dev] New PSBT version proposal
In-Reply-To: <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
References: <1dd8c285-e3f4-4f03-d608-103a5026146d@achow101.com>
 <5a4697cb-b9cb-b925-e78f-d5b53f025704@achow101.com>
Message-ID: <40089cb5-8d68-1868-c87b-241f2bd747fb@achow101.com>

Hi All,

The full modified BIP can be read at 
https://github.com/achow101/bips/blob/psbt2/bip-0174.mediawiki.

I will open a PR to the BIPs repo soon after further discussion on this.


Andrew

On 12/22/20 3:12 PM, Andrew Chow wrote:
> Hi All,
>
> I have some updates on this after speaking with some people off-list.
>
> Firstly, the version number will be set to 2. In most discussions, this
> proposal was being referred to as PSBT version 2, so it'll be easier and
> clearer to set the version number to 2.
>
> For lock times, instead of a single? PSBT_IN_REQUIRED_LOCKTIME field,
> there will be 2 of them, one for a time based lock time, and the other
> for height based. These will be:
> * PSBT_IN_REQUIRED_TIME_LOCKTIME = 0x10
>   ? * Key: empty
>   ? * Value: 32 bit unsigned little endian integer greater than or equal
> to 500000000 representing the minimum Unix timestamp that this input
> requires to be set as the transaction's lock time. Must be omitted in
> PSBTv0, and may be omitted in PSBTv2
> * PSBT_IN_REQUIRED_HEIGHT_LOCKTIME = 0x11
>   ? * Key: empty
>   ? * Value: 32 bit unsigned little endian integer less than 500000000
> representing the minimum block height that this input requires to be set
> as the transaction's lock time. Must be omitted in PSBTv0, and may be
> omitted in PSBTv2.
>
> Having two lock time fields is necessary due to the behavior where all
> inputs must use the same type of lock time (height or time). Thus if an
> input requires a particular type of lock time, it must set the requisite
> field. Any new inputs being added must be able to accommodate all
> existing inputs' lock time type. This means they either must not have a
> lock time specified (i.e. no OP_CLTV involved), or have branches that
> allow the acceptance of either type. If an input has a lock time type
> that is incompatible with the rest of the transaction, it must not be added.
>
> PSBT_GLOBAL_PREFERRED_LOCKTIME is changed to purely be the fallback
> option if no input lock time fields are present. If there are input lock
> times, all lock time calculations must ignore it.
>
> Any role which does lock time calculation will first check if there are
> input lock time fields. If there are not, it must then check for a
> PSBT_GLOBAL_PREFERRED_LOCKTIME. If this field exists, its value is the
> transaction's lock time. If it does not, the lock time is 0. If there
> are input lock time fields, it must choose the type which does not
> invalidate any inputs. The lock time is then determined to be the
> maximum value of all of the lock time fields for the chosen type.
>
>
> Additionally, I would like to add a new global field:
> * PSBT_GLOBAL_UNDER_CONSTRUCTION = 0x05
>   ? * Key: empty
>   ? * Value: A single byte as a boolean. 0 for False, 1 for True. All
> other values ore prohibited. Must be omitted for PSBTv0, may be omitted
> in PSBTv2.
>
> PSBT_GLOBAL_UNDER_CONSTRUCTION is used to signal whether inputs and
> outputs can be added to the PSBT. This flag may be set to True when
> inputs and outputs are being updated, signed, and finalized. However
> care must be taken when there are existing signatures. If this field is
> omitted or set to False, no further inputs and outputs may be added to
> the PSBT.
>
> Several rules must be followed to ensure that adding additional inputs
> and outputs will not invalidate existing signatures. First, an input or
> output adder must check for any existing signatures in all of the other
> inputs. If there are none, the input or output may be added in any
> position. If there are one or more signatures, each signature's sighash
> type must be examined. Inputs may only be added if all existing
> signatures use SIGHASH_ANYONECANPAY. Outputs may only be added if all
> existing signatures use SIGHASH_NONE. If an input has a signature using
> SIGHASH_SINGLE, the same number of inputs and outputs must be added
> before that input and it's corresponding output. For all other sighash
> types (i.e. SIGHASH_ALL and any future sighash types), no inputs or
> outputs may be added to the PSBT. Specific exceptions can be made in the
> future for additional sighash types.
>
> Furthermore, these newly added inputs must follow additional lock time
> rules. Because all signatures, regardless of sighash type, sign the
> transaction lock time, newly added inputs when there are existing
> signatures must have the same type of lock time used in the transaction,
> and must be less than or equal to the transaction lock time. It must not
> cause the transaction lock time to change, otherwise the signatures will
> be invalidated.
>
>
> Lastly, to uniquely identify transactions for combiners, a txid can be
> computed from the information present in the PSBT. Internally, combiners
> can create an unsigned transaction given the transaction version, the
> input prevouts, the outputs, and the computed locktime. This can then be
> used to calculate a txid and thus used as a way to identify PSBTs.
> Combiners will need to do this for all version 2 PSBTs in order to avoid
> combining distinct transactions.
>
>
> Andrew Chow
>
> On 12/9/20 5:25 PM, Andrew Chow wrote:
>> Hi All,
>>
>> I would like to propose a new PSBT version that addresses a few
>> deficiencies in the current PSBT v0. As this will be backwards
>> incompatible, a new PSBT version will be used, v1.
>>
>> The primary change is to truly have all input and output data for each
>> in their respective maps. Instead of having to parse an unsigned
>> transaction and lookup some data from there, and other data from the
>> correct map, all of the data for an input will be contained in its map.
>> Doing so also disallows PSBT_GLOBAL_UNSIGNED_TX in this new version.
>> Thus I propose that the following fields be added:
>>
>> Global:
>> * PSBT_GLOBAL_TX_VERSION = 0x02
>>    ? * Key: empty
>>    ? * Value: 32-bit little endian unsigned integer for the transaction
>> version number. Must be provided in PSBT v1 and omitted in v0.
>> * PSBT_GLOBAL_PREFERRED_LOCKTIME = 0x03
>>    ? * Key: empty
>>    ? * Value: 32 bit little endian unsigned integer for the preferred
>> transaction lock time. Must be omitted in PSBT v0. May be provided in
>> PSBT v1, assumed to be 0 if not provided.
>> * PSBT_GLOBAL_INPUT_COUNT = 0x04
>>    ? * Key: empty
>>    ? * Value: Compact size unsigned integer. Number of inputs in this
>> PSBT. Must be provided in PSBT v1 and omitted in v0.
>> * PSBT_GLOBAL_OUTPUT_COUNT = 0x05
>>    ? * Key: empty
>>    ? * Value: Compact size unsigned integer. Number of outputs in this
>> PSBT. Must be provided in PSBT v1 and omitted in v0.
>>
>> Input:
>> * PSBT_IN_PREVIOUS_TXID = 0x0e
>>    ? * Key: empty
>>    ? * Value: 32 byte txid of the previous transaction whose output at
>> PSBT_IN_OUTPUT_INDEX is being spent. Must be provided in PSBT v1 and
>> omitted in v0.
>> * PSBT_IN_OUTPUT_INDEX = 0x0f
>>    ? * Key: empty
>>    ? * Value: 32 bit little endian integer for the index of the output
>> being spent. Must be provided in PSBT v1 and omitted in v0.
>> * PSBT_IN_SEQUENCE = 0x0f
>>    ? * Key: empty
>>    ? * Value: 32 bit unsigned little endian integer for the sequence
>> number. Must be omitted in PSBT v0. May be provided in PSBT v1 assumed
>> to be max sequence (0xffffffff) if not provided.
>> * PSBT_IN_REQUIRED_LOCKTIME = 0x10
>>    ? * Key: empty
>>    ? * Value: 32 bit unsigned little endian integer for the lock time that
>> this input requires. Must be omitted in PSBT v0. May be provided in PSBT
>> v1, assumed to be 0 if not provided.
>>
>> Output:
>> * PSBT_OUT_VALUE = 0x03
>>    ? * Key: empty
>>    ? * Value: 64-bit unsigned little endian integer for the output's
>> amount in satoshis. Must be provided in PSBT v1 and omitted in v0.
>> * PSBT_OUT_OUTPUT_SCRIPT = 0x04
>>    ? * Key: empty
>>    ? * Value: The script for this output. Otherwise known as the
>> scriptPubKey. Must be provided in PSBT v1 and omitted in v0.
>>
>> This change allows for PSBT to be used in the construction of
>> transactions. With these new fields, inputs and outputs can be added as
>> needed. One caveat is that there is no longer a unique transaction
>> identifier so more care must be taken when combining PSBTs.
>> Additionally, adding new inputs and outputs must be done such that
>> signatures are not invalidated. This may be harder to specify.
>>
>> An important thing to note in this proposal are the fields
>> PSBT_GLOBAL_PREFERRED_LOCKTIME and PSBT_IN_REQUIRED_LOCKTIME. A Bitcoin
>> transaction only has a single locktime yet a PSBT may have multiple
>> locktimes. To choose the locktime for the transaction, finalizers must
>> choose the maximum of all of the *_LOCKTIME fields.
>> PSBT_IN_REQUIRED_LOCKTIME is added because some inputs, such as those
>> involving OP_CHECKLOCKTIMEVERIFY, require a specific minimum locktime to
>> be set. This field allows finalizers to choose a locktime that is high
>> enough for all inputs without needing to understand the scripts
>> involved. The PSBT_GLOBAL_PREFERRED_LOCKTIME is the locktime to use if
>> no inputs require a particular locktime.
>>
>> As these changes disallow the PSBT_GLOBAL_UNSIGNED_TX field, PSBT v1
>> needs the version number bump to enforce backwards incompatibility.
>> However once the inputs and outputs of a PSBT are decided, a PSBT could
>> be "downgraded" back to v0 by creating the unsigned transaction from the
>> above fields, and then dropping these new fields.
>>
>> If the list finds that these changes are reasonable, I will write a PR
>> to modify BIP 174 to incorporate them.
>>
>> Thanks,
>> Andrew Chow



From erik at q32.com  Wed Dec 23 21:13:29 2020
From: erik at q32.com (Erik Aronesty)
Date: Wed, 23 Dec 2020 16:13:29 -0500
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
In-Reply-To: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
References: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
Message-ID: <CAJowKg+wE2SO5hcSbcNzPCtjetgBxXo5ejkFUV=mQrxxUh1-5w@mail.gmail.com>

Obviously Bitcoin has a wallet api, intermingled with other protocol APIs:

https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list

For security, a standard wallet API should write a token/port to a
local file where the user can grab that token and use it (that's
basically how the existing bitcoind does it, with a username/password
living in a file... not as nice as a token/port, IMO)

Probably any such standards document should do its best to be
compatible with the existing APIs that so many are already familiar
with.   Or maybe I misunderstand the proposal.

- Erik

On Tue, Dec 22, 2020 at 9:48 AM monokh via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> Hi
>
> This is a first draft of a BIP we intend to submit. The main intention is to define a simple interface that wallets and applications can agree on that would cover the vast majority of use cases. This can enable writing bitcoin applications (e.g. time lock, multi sig) on the web that can be seamlessly used with any compatible wallets. We have implementations of such examples but I don't want to turn this thread into a promotion and rather focus on the spec.
>
> Appreciate input from the list. Please share if there are existing efforts, relevant specs or use cases.
>
> ------------------------------
>
> A wallet interface specification for bitcoin applications
>
> ## Abstract
>
> This BIP describes an API for Bitcoin wallets and applications as a standard.
>
> ## Summary
>
> Bitcoin wallets should expose their address derivation and signing functions to external applications. The interface would be expressed as follows in javascript:
>
> ```
> {
> // Wallet Metadata
> wallet: {
> name: 'Bitcoin Core'
> },
>
> // Request access to the wallet for the current host
> async enable: (),
>
> // Request addresses and signatures from wallet
> async request ({ method, params })
> }
> ```
>
> In the web context the interface could be exposed at the top level of a webpage, for example under `window.bitcoin`. However this spec does not intend to define any standards for how and where the interfaces should be exposed.
>
> ## Motivation
>
> Due to the seldom available APIs exposed by wallets, applications (web or otherwise) are limited in how they are able to interact. Generally only simple sends have been available. A more robust API that introduces other requests will promote richer Bitcoin applications.
>
> Additionally, wallet APIs have frequently included inconsistencies in their interfaces and behaviour. This has required applications to build and maintain a separate client for each wallet, increasing the risk of bugs and unintended behaviour as well as being a limiting factor for the adoption of usable bitcoin applications.
>
> With a standardised wallet API:
>
> - Wallets have a clear API to implement
> - Applications have a clear expectation of wallet interface and behaviour
> - Applications become agnostic to the wallet specifics, increasing choice for users
>
> If more wallets implement the specification, applications will be developed more confidently by benefiting from the wallet interoperability. This creates a positive feedback loop.
>
> ## Specification
>
> For simplicity, the interface is defined in the context of web applications running in the browser (JS) however, they are simple enough to be easily implemented in other contexts.
>
> ### General Rules
>
> - For sensitive functions (e.g. signing), wallet software should always prompt the user for confirmation
>
> ### Types
>
> **UserDeniedError**
> An error type indicating that the application's request has been denied by the user
> Type: Error
>
> **Hex**
> Type: String
> Example: `"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`
>
> **Address**
> Address details
> Type: Object
> Example:
>
> ```
> {
> "address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
> "publicKey": "02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
> "derivationPath": "84'/1'/0'/0/0"
> }
> ```
>
> ### API
>
> The wallet must implement the following methods.
>
> **enable**
>
> The enable call prompts the user for access to the wallet.
>
> If successful, it resolves to an address (`**Address**` type) of the wallet. Typically the first external address to be used as an identity.
>
> **`UserDeniedError`** will be thrown if the request is rejected.
>
> **request**
>
> The request method must take one parameter in the following format:
>
> ```
> {
> "method": "wallet_methodName",
> "params": ["foo", "bar", "baz"]
> }
> ```
>
> For a list of mandatory methods see Table
>
> The wallet should reject request calls unless `enable` has been resolved.
>
> Sensitive requests that involve signing should always prompt the user for confirmation
>
> On success the request should resolve to the response as defined in the method table.
>
> **`UserDeniedError`** will be thrown if the request is rejected.
>
> **Mandatory methods**
>
> method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change = false`]
> return: `[ Address ]`
> error: UserDeniedError
>
> method: `wallet_signMessage` params: `[ message, address ]`
> return: Signature `Hex`
> error: UserDeniedError
>
> method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`
> return: `psbtBase64`
> error: UserDeniedError
>
> method: `wallet_getConnectedNetwork` params: `[]`
> return: Network object `mainnet` | `testnet` | `regetst`
> error: UserDeniedError
>
> ## Rationale
>
> The purpose of the API is to expose a set of commonly used wallet operations. In addition, it should be flexible enough to serve for other requests such as node RPC calls.
>
> **Why is there a singular request call instead of named methods?**
> The transport layer for the requests cannot be assumed, therefore it is much more flexible to instead define an abstract format.
>
> **Why are the mandatory methods so primitive? Where is getBalance, getUtxos, ... ?**
> A wallet need not worry about providing every possible scenario for usage. The primitives of keys and signing can expose enough to applications to do the rest. Applications should have flexibility in how they implement these functions. It is the role of a library rather than the wallet.
>
> ## Security Implications
>
> Great care should be taken when exposing wallet functionality externally as the security and privacy of the user is at risk.
>
> ### Signing
>
> Operations that trigger signing using private keys should be guarded behind confirmation screens where the user is fully aware of the nature of the transaction. In the example of a PSBT signature request, the outputs, the inputs and which key is being used should be clearly marked.
>
> ### Privacy
>
> Some api methods expose metadata about the user, such as public keys. Depending on how privacy focused the wallet intends to be, the wallet could protect these behind a confirmation. Commonly the wallet just needs to give the origin access to all of its public keys, however it could also allow the option to expose only selected derivation paths.
>
> -monokh
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From aymeric at peersm.com  Fri Dec 25 11:49:11 2020
From: aymeric at peersm.com (Aymeric Vitte)
Date: Fri, 25 Dec 2020 12:49:11 +0100
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
In-Reply-To: <96a93692-b564-91df-9194-1373d805c434@peersm.com>
References: <CAPvWj7H9hg8EMCvDzWiq=f59KojHEGCm_iAP+FBaB+25=CLt0A@mail.gmail.com>
 <202012230215.46394.luke@dashjr.org>
 <CAPvWj7E3S9HxZgpw0bdDmso+3sXc-h0u15_528r11EZ3LY-wYA@mail.gmail.com>
 <96a93692-b564-91df-9194-1373d805c434@peersm.com>
Message-ID: <466af0d2-c1ac-04c5-83b9-ce6d44a4958e@peersm.com>

Resending to the list since I am using a different email

Complement: if anonymity is required from the browser (or elsewhere) you
might consider looking at https://github.com/Ayms/node-Tor too


Le 24/12/2020 ? 20:40, Aymeric Vitte a ?crit :
>
> You might want to take a look at: https://peersm.com/wallet
>
> And https://github.com/Ayms/bitcoin-transactions
>
> "wallet" is not the very correct word, it's more bitcoin cli outside
> of bitcoin core but for now not linked to an explorer/tx system which
> makes it probably still not so easy to use for the transactions part
> (which can be extended to lightning, etc)
>
> The idea is to propose to people most of the tools they need to manage
> their coins by themselves, or at least understand better what they are
> doing
>
> "People should not be encouraged to write or use web browsers for
> their wallet." --> yes and no, please crack the standalone webapp
> above, so it's finally a no when things are done correctly, of course
> there is no story of keys storage inside browsers or online stuff with
> keys
>
> Maybe this can be turned one day into a w3c api like webcrypto
> (window.bitcoin as you sketch)
>
> Le 23/12/2020 ? 08:29, monokh via bitcoin-dev a ?crit :
>> Thanks for the input Luke.
>>
>> > 1) People should not be encouraged to write or use web browsers for
>> their wallet.
>>
>> Indeed. Holding keys in the browser can be very insecure, however the
>> spec is not limited to this. I will amend to make this clear. The
>> same interface can be used to communicate from a web context or even
>> desktop application with hardware wallets where keys are segregated
>> safely. The prominent hardware wallets already have such an
>> interface. Unfortunately as there has been no standardisation, an
>> application must specifically provide an implementation for each
>> wallet to be compatible.
>>
>> > 2) You may want to look over earlier work in this area.
>>
>> Please share if you have specifics in mind. What has been considered
>> were mainly hardware wallet apis. The requests have been defined such
>> that they would be compatible. I will make references to such
>> considerations in the text. I welcome any feedback on what may be
>> missing or problematic for these providers - something I will also
>> pursue outwith the thread.
>>
>> -monokh 
>>
>> On Wed, Dec 23, 2020 at 2:15 AM Luke Dashjr <luke at dashjr.org
>> <mailto:luke at dashjr.org>> wrote:
>>
>>     1) People should not be encouraged to write or use web browsers
>>     for their
>>     wallet.
>>     2) You may want to look over earlier work in this area.
>>
>>     On Tuesday 22 December 2020 14:43:11 monokh via bitcoin-dev wrote:
>>     > Hi
>>     >
>>     > This is a first draft of a BIP we intend to submit. The main
>>     intention is
>>     > to define a simple interface that wallets and applications can
>>     agree on
>>     > that would cover the vast majority of use cases. This can
>>     enable writing
>>     > bitcoin applications (e.g. time lock, multi sig) on the web
>>     that can be
>>     > seamlessly used with any compatible wallets. We have
>>     implementations of
>>     > such examples but I don't want to turn this thread into a
>>     promotion and
>>     > rather focus on the spec.
>>     >
>>     > Appreciate input from the list. Please share if there are
>>     existing efforts,
>>     > relevant specs or use cases.
>>     >
>>     > ------------------------------
>>     >
>>     > A wallet interface specification for bitcoin applications
>>     >
>>     > ## Abstract
>>     >
>>     > This BIP describes an API for Bitcoin wallets and applications as a
>>     > standard.
>>     >
>>     > ## Summary
>>     >
>>     > Bitcoin wallets should expose their address derivation and signing
>>     > functions to external applications. The interface would be
>>     expressed as
>>     > follows in javascript:
>>     >
>>     > ```
>>     > {
>>     > // Wallet Metadata
>>     > wallet: {
>>     > name: 'Bitcoin Core'
>>     > },
>>     >
>>     > // Request access to the wallet for the current host
>>     > async enable: (),
>>     >
>>     > // Request addresses and signatures from wallet
>>     > async request ({ method, params })
>>     > }
>>     > ```
>>     >
>>     > In the web context the interface could be exposed at the top
>>     level of a
>>     > webpage, for example under `window.bitcoin`. However this spec
>>     does not
>>     > intend to define any standards for how and where the interfaces
>>     should be
>>     > exposed.
>>     >
>>     > ## Motivation
>>     >
>>     > Due to the seldom available APIs exposed by wallets,
>>     applications (web or
>>     > otherwise) are limited in how they are able to interact.
>>     Generally only
>>     > simple sends have been available. A more robust API that
>>     introduces other
>>     > requests will promote richer Bitcoin applications.
>>     >
>>     > Additionally, wallet APIs have frequently included
>>     inconsistencies in their
>>     > interfaces and behaviour. This has required applications to
>>     build and
>>     > maintain a separate client for each wallet, increasing the risk
>>     of bugs and
>>     > unintended behaviour as well as being a limiting factor for the
>>     adoption of
>>     > usable bitcoin applications.
>>     >
>>     > With a standardised wallet API:
>>     >
>>     > - Wallets have a clear API to implement
>>     > - Applications have a clear expectation of wallet interface and
>>     behaviour
>>     > - Applications become agnostic to the wallet specifics,
>>     increasing choice
>>     > for users
>>     >
>>     > If more wallets implement the specification, applications will
>>     be developed
>>     > more confidently by benefiting from the wallet
>>     interoperability. This
>>     > creates a positive feedback loop.
>>     >
>>     > ## Specification
>>     >
>>     > For simplicity, the interface is defined in the context of web
>>     applications
>>     > running in the browser (JS) however, they are simple enough to
>>     be easily
>>     > implemented in other contexts.
>>     >
>>     > ### General Rules
>>     >
>>     > - For sensitive functions (e.g. signing), wallet software
>>     should always
>>     > prompt the user for confirmation
>>     >
>>     > ### Types
>>     >
>>     > **UserDeniedError**
>>     > An error type indicating that the application's request has
>>     been denied by
>>     > the user
>>     > Type: Error
>>     >
>>     > **Hex**
>>     > Type: String
>>     > Example:
>>     >
>>     `"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`
>>     >
>>     > **Address**
>>     > Address details
>>     > Type: Object
>>     > Example:
>>     >
>>     > ```
>>     > {
>>     > "address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
>>     > "publicKey":
>>     >
>>     "02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
>>     > "derivationPath": "84'/1'/0'/0/0"
>>     > }
>>     > ```
>>     >
>>     > ### API
>>     >
>>     > The wallet must implement the following methods.
>>     >
>>     > **enable**
>>     >
>>     > The enable call prompts the user for access to the wallet.
>>     >
>>     > If successful, it resolves to an address (`**Address**` type)
>>     of the
>>     > wallet. Typically the first external address to be used as an
>>     identity.
>>     >
>>     > **`UserDeniedError`** will be thrown if the request is rejected.
>>     >
>>     > **request**
>>     >
>>     > The request method must take one parameter in the following format:
>>     >
>>     > ```
>>     > {
>>     > "method": "wallet_methodName",
>>     > "params": ["foo", "bar", "baz"]
>>     > }
>>     > ```
>>     >
>>     > For a list of mandatory methods see Table
>>     >
>>     > The wallet should reject request calls unless `enable` has been
>>     resolved.
>>     >
>>     > Sensitive requests that involve signing should always prompt
>>     the user for
>>     > confirmation
>>     >
>>     > On success the request should resolve to the response as
>>     defined in the
>>     > method table.
>>     >
>>     > **`UserDeniedError`** will be thrown if the request is rejected.
>>     >
>>     > **Mandatory methods**
>>     >
>>     > method: `wallet_getAddresses` params: [`index = 0, numAddresses
>>     = 1, change
>>     > = false`]
>>     > return: `[ Address ]`
>>     > error: UserDeniedError
>>     >
>>     > method: `wallet_signMessage` params: `[ message, address ]`
>>     > return: Signature `Hex`
>>     > error: UserDeniedError
>>     >
>>     > method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex,
>>     address] ]`
>>     > return: `psbtBase64`
>>     > error: UserDeniedError
>>     >
>>     > method: `wallet_getConnectedNetwork` params: `[]`
>>     > return: Network object `mainnet` | `testnet` | `regetst`
>>     > error: UserDeniedError
>>     >
>>     > ## Rationale
>>     >
>>     > The purpose of the API is to expose a set of commonly used wallet
>>     > operations. In addition, it should be flexible enough to serve
>>     for other
>>     > requests such as node RPC calls.
>>     >
>>     > **Why is there a singular request call instead of named methods?**
>>     > The transport layer for the requests cannot be assumed,
>>     therefore it is
>>     > much more flexible to instead define an abstract format.
>>     >
>>     > **Why are the mandatory methods so primitive? Where is getBalance,
>>     > getUtxos, ... ?**
>>     > A wallet need not worry about providing every possible scenario
>>     for usage.
>>     > The primitives of keys and signing can expose enough to
>>     applications to do
>>     > the rest. Applications should have flexibility in how they
>>     implement these
>>     > functions. It is the role of a library rather than the wallet.
>>     >
>>     > ## Security Implications
>>     >
>>     > Great care should be taken when exposing wallet functionality
>>     externally as
>>     > the security and privacy of the user is at risk.
>>     >
>>     > ### Signing
>>     >
>>     > Operations that trigger signing using private keys should be
>>     guarded behind
>>     > confirmation screens where the user is fully aware of the
>>     nature of the
>>     > transaction. In the example of a PSBT signature request, the
>>     outputs, the
>>     > inputs and which key is being used should be clearly marked.
>>     >
>>     > ### Privacy
>>     >
>>     > Some api methods expose metadata about the user, such as public
>>     keys.
>>     > Depending on how privacy focused the wallet intends to be, the
>>     wallet could
>>     > protect these behind a confirmation. Commonly the wallet just
>>     needs to give
>>     > the origin access to all of its public keys, however it could
>>     also allow
>>     > the option to expose only selected derivation paths.
>>     >
>>     > -monokh
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> -- 
> Sophia-Antipolis, France
> LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
> Move your coins by yourself (browser version): https://peersm.com/wallet
> Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
> Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
> Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
> Get the torrent dynamic blocklist: http://peersm.com/getblocklist
> Check the 10 M passwords list: http://peersm.com/findmyass
> Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
> Peersm : http://www.peersm.com
> torrent-live: https://github.com/Ayms/torrent-live
> node-Tor : https://www.github.com/Ayms/node-Tor
> GitHub : https://www.github.com/Ayms

-- 
Sophia-Antipolis, France
LinkedIn: https://fr.linkedin.com/in/aymeric-vitte-05855b26
Move your coins by yourself (browser version): https://peersm.com/wallet
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201225/4362e66c/attachment-0001.html>

From jonas.shane at gmail.com  Fri Dec 25 18:11:23 2020
From: jonas.shane at gmail.com (Shane Jonas)
Date: Fri, 25 Dec 2020 10:11:23 -0800
Subject: [bitcoin-dev] BIP Proposal: Wallet Interface
In-Reply-To: <CAJowKg+wE2SO5hcSbcNzPCtjetgBxXo5ejkFUV=mQrxxUh1-5w@mail.gmail.com>
References: <CAJowKg+wE2SO5hcSbcNzPCtjetgBxXo5ejkFUV=mQrxxUh1-5w@mail.gmail.com>
Message-ID: <F606A87C-1480-4F2D-95D0-03D951C85AFA@gmail.com>

There?s a BIP to create a standard API document for the Bitcoin JSON-RPC API 
https://github.com/bitcoin/bips/pull/776

here?s an example of the generic ethereum api https://github.com/etclabscore/ethereum-json-rpc-specification/blob/master/openrpc.json

and another example of just the wallet interface https://github.com/etclabscore/signatory/blob/master/openrpc.json

here?s a live demo with interactive documentation:

https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/etclabscore/ethereum-json-rpc-specification/master/openrpc.json

Creating a standard api document like this makes it a lot easier to build dev tools and documentation.

I?d love to help document the bitcoin JSON-RPC API, let me know how I can help.

> On Dec 23, 2020, at 6:15 PM, Erik Aronesty via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> ?Obviously Bitcoin has a wallet api, intermingled with other protocol APIs:
> 
> https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list
> 
> For security, a standard wallet API should write a token/port to a
> local file where the user can grab that token and use it (that's
> basically how the existing bitcoind does it, with a username/password
> living in a file... not as nice as a token/port, IMO)
> 
> Probably any such standards document should do its best to be
> compatible with the existing APIs that so many are already familiar
> with.   Or maybe I misunderstand the proposal.
> 
> - Erik
> 
>> On Tue, Dec 22, 2020 at 9:48 AM monokh via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Hi
>> 
>> This is a first draft of a BIP we intend to submit. The main intention is to define a simple interface that wallets and applications can agree on that would cover the vast majority of use cases. This can enable writing bitcoin applications (e.g. time lock, multi sig) on the web that can be seamlessly used with any compatible wallets. We have implementations of such examples but I don't want to turn this thread into a promotion and rather focus on the spec.
>> 
>> Appreciate input from the list. Please share if there are existing efforts, relevant specs or use cases.
>> 
>> ------------------------------
>> 
>> A wallet interface specification for bitcoin applications
>> 
>> ## Abstract
>> 
>> This BIP describes an API for Bitcoin wallets and applications as a standard.
>> 
>> ## Summary
>> 
>> Bitcoin wallets should expose their address derivation and signing functions to external applications. The interface would be expressed as follows in javascript:
>> 
>> ```
>> {
>> // Wallet Metadata
>> wallet: {
>> name: 'Bitcoin Core'
>> },
>> 
>> // Request access to the wallet for the current host
>> async enable: (),
>> 
>> // Request addresses and signatures from wallet
>> async request ({ method, params })
>> }
>> ```
>> 
>> In the web context the interface could be exposed at the top level of a webpage, for example under `window.bitcoin`. However this spec does not intend to define any standards for how and where the interfaces should be exposed.
>> 
>> ## Motivation
>> 
>> Due to the seldom available APIs exposed by wallets, applications (web or otherwise) are limited in how they are able to interact. Generally only simple sends have been available. A more robust API that introduces other requests will promote richer Bitcoin applications.
>> 
>> Additionally, wallet APIs have frequently included inconsistencies in their interfaces and behaviour. This has required applications to build and maintain a separate client for each wallet, increasing the risk of bugs and unintended behaviour as well as being a limiting factor for the adoption of usable bitcoin applications.
>> 
>> With a standardised wallet API:
>> 
>> - Wallets have a clear API to implement
>> - Applications have a clear expectation of wallet interface and behaviour
>> - Applications become agnostic to the wallet specifics, increasing choice for users
>> 
>> If more wallets implement the specification, applications will be developed more confidently by benefiting from the wallet interoperability. This creates a positive feedback loop.
>> 
>> ## Specification
>> 
>> For simplicity, the interface is defined in the context of web applications running in the browser (JS) however, they are simple enough to be easily implemented in other contexts.
>> 
>> ### General Rules
>> 
>> - For sensitive functions (e.g. signing), wallet software should always prompt the user for confirmation
>> 
>> ### Types
>> 
>> **UserDeniedError**
>> An error type indicating that the application's request has been denied by the user
>> Type: Error
>> 
>> **Hex**
>> Type: String
>> Example: `"0000000000000000000a24677957d1e50d70e67c513d220dbe8868c4c3aefc08"`
>> 
>> **Address**
>> Address details
>> Type: Object
>> Example:
>> 
>> ```
>> {
>> "address": "bc1qn0fqlzamcfuahq6xuujrq08ex7e26agt20gexs",
>> "publicKey": "02ad58c0dced71a236f4073c3b6f0ee27dde6fe96978e9a9c9500172e3f1886e5a",
>> "derivationPath": "84'/1'/0'/0/0"
>> }
>> ```
>> 
>> ### API
>> 
>> The wallet must implement the following methods.
>> 
>> **enable**
>> 
>> The enable call prompts the user for access to the wallet.
>> 
>> If successful, it resolves to an address (`**Address**` type) of the wallet. Typically the first external address to be used as an identity.
>> 
>> **`UserDeniedError`** will be thrown if the request is rejected.
>> 
>> **request**
>> 
>> The request method must take one parameter in the following format:
>> 
>> ```
>> {
>> "method": "wallet_methodName",
>> "params": ["foo", "bar", "baz"]
>> }
>> ```
>> 
>> For a list of mandatory methods see Table
>> 
>> The wallet should reject request calls unless `enable` has been resolved.
>> 
>> Sensitive requests that involve signing should always prompt the user for confirmation
>> 
>> On success the request should resolve to the response as defined in the method table.
>> 
>> **`UserDeniedError`** will be thrown if the request is rejected.
>> 
>> **Mandatory methods**
>> 
>> method: `wallet_getAddresses` params: [`index = 0, numAddresses = 1, change = false`]
>> return: `[ Address ]`
>> error: UserDeniedError
>> 
>> method: `wallet_signMessage` params: `[ message, address ]`
>> return: Signature `Hex`
>> error: UserDeniedError
>> 
>> method: `wallet_signPSBT` params: `[ [psbtBase64, inputIndex, address] ]`
>> return: `psbtBase64`
>> error: UserDeniedError
>> 
>> method: `wallet_getConnectedNetwork` params: `[]`
>> return: Network object `mainnet` | `testnet` | `regetst`
>> error: UserDeniedError
>> 
>> ## Rationale
>> 
>> The purpose of the API is to expose a set of commonly used wallet operations. In addition, it should be flexible enough to serve for other requests such as node RPC calls.
>> 
>> **Why is there a singular request call instead of named methods?**
>> The transport layer for the requests cannot be assumed, therefore it is much more flexible to instead define an abstract format.
>> 
>> **Why are the mandatory methods so primitive? Where is getBalance, getUtxos, ... ?**
>> A wallet need not worry about providing every possible scenario for usage. The primitives of keys and signing can expose enough to applications to do the rest. Applications should have flexibility in how they implement these functions. It is the role of a library rather than the wallet.
>> 
>> ## Security Implications
>> 
>> Great care should be taken when exposing wallet functionality externally as the security and privacy of the user is at risk.
>> 
>> ### Signing
>> 
>> Operations that trigger signing using private keys should be guarded behind confirmation screens where the user is fully aware of the nature of the transaction. In the example of a PSBT signature request, the outputs, the inputs and which key is being used should be clearly marked.
>> 
>> ### Privacy
>> 
>> Some api methods expose metadata about the user, such as public keys. Depending on how privacy focused the wallet intends to be, the wallet could protect these behind a confirmation. Commonly the wallet just needs to give the origin access to all of its public keys, however it could also allow the option to expose only selected derivation paths.
>> 
>> -monokh
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201225/26428a28/attachment-0001.html>

From rsomsen at gmail.com  Thu Dec 31 22:00:17 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Thu, 31 Dec 2020 23:00:17 +0100
Subject: [bitcoin-dev] Softchains: Sidechains as a Soft Fork via
	Proof-of-Work Fraud Proofs
Message-ID: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>

Hi everyone,

This post describes a fully decentralized two-way peg sidechain design.
Activating new sidechains requires a soft fork, hence the name softchains.
The key aspect is that all softchains are validated by everyone via
Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus
mechanism that only requires the validation of disputed blocks. This does
increase the validation burden of mainchain full nodes, but only by a
minimal amount (~100MB per chain per year). It's similar to drivechains[0],
but without the major downside of having to rely on miners, since all
Bitcoin full node users can efficiently validate each sidechain.


Proof-of-Work Fraud Proofs

Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].
The idea is that we can use the existence of a fork in Bitcoin's PoW as
evidence that a block might be invalid (i.e. a proof of potential fraud).
Whenever this occurs, we download the block in question to verify whether
it was valid (and available), and reject it if it was not. We forego the
need for maintaining a UTXO set with UTXO set commitments (such as
utreexo[3]), by assuming that the commitment inside the last block to exist
in both forks is valid. As a result, we only need to download as many
blocks (and their corresponding UTXO set proofs) as there are orphans,
which lowers the validation costs considerably compared to running a full
node.

In the past 4 months, Forkmonitor has registered 11 stale and invalid
blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin
consensus would have to download and verify a little over 100MB per year in
order to have consensus guarantees that come close to that of a full node:
- All PoW headers (~4MB per year)
- 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)
- UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)

The reason consensus is considered slow, is because we need to allow time
for a honest PoW minority to fork away from an invalid chain. If we assume
only 1% of all miners are honest, this means consensus slows down by 100x.
If you are normally satisfied waiting for 6 confirmations, you now need to
wait 600 confirmations. The longer you wait, the less honest miners you
need.


Softchains

In order to have two-way pegged sidechains, you need a succinct method for
proving to the mainchain that a peg-out is valid. PoW FP provides exactly
that -- a low-bandwidth way of determining if a chain, and thus a peg-out,
is valid. The slowness of PoW FP consensus is not an issue, as peg-outs can
be made arbitrarily slow (e.g. one year).

The safest design would be a set of softchains that shares its consensus
code with Bitcoin Core, with the addition of UTXO set commitments, and
disabling non-taproot address types to minimize certain resource usage
issues[5]. All users validate the mainchain as usual with their full node,
and all softchains are validated with PoW FP consensus. If a user is
interested in directly using a specific softchain, they should run it as a
full node in order to get fast consensus.

Peg-ins occur by freezing coins on the mainchain and assigning them to a
softchain. Peg-outs occur by creating a mainchain transaction that points
to a peg-out transaction on a softchain and waiting for a sufficient number
of mainchain confirmations. If the peg-out transaction remains part of the
softchain according to PoW FP consensus, the coins become spendable.

The peg-in/peg-out mechanism itself would require a soft fork (the exact
design is an open question), and subsequently every softchain that gets
activated will also require a soft fork.


Potential dangers

Softchain consensus still requires a form of validation from mainchain
users, which means that consensus bugs can have an adverse effect. In
particular, if a softchain suffers from a non-deterministic consensus bug,
it may be the case that a majority accepts a peg-in, while a minority
rejects it. This specific scenario could cause a chain split in mainchain
consensus. This is why it would be safest to base softchain designs on
Bitcoin Core.

Similarly, it can theoretically be possible that a softchain gets a major
reorg, invalidating a peg-out right as it would have become accepted on the
mainchain, thus splitting consensus. The slow peg-out process makes this
increasingly unlikely, but not impossible. One thing that might help (or
perhaps only make it worse) is introducing a consensus rule that disallows
reorgs that are bigger than half the peg-out time (e.g. half a year, if the
peg-out is one year). This kind of rule does not actually solve this
consensus problem, but instead pushes the problem forward so it plays out
first on the softchain, giving time to take action before the problem
affects the mainchain.

It is also important that each softchain produces a non-trivial amount of
PoW, because if the difficulty is too low, the cost of creating forks and
increasing the resource usage of PoW FP consensus goes down. It may
therefore make sense to have a minimum accepted difficulty for softchain
blocks (slowing down the chain when fees are not sufficient). Merged Mining
could also help here, since that would allow the softchains to potentially
receive the same hashrate as Bitcoin (assuming all miners participate), but
of course this would also put an additional validation burden on miners.


In closing

It may turn out that the consensus risks outlined above make this
prohibitively risky, but at the very least it seems worth exploring the
possibilities. At a minimum it would provide more opt-in block space, and
it could potentially open the door to chains with entirely different
consensus rules.

Thank you for taking the time to read and comprehend my work. I will
happily answer any questions and I look forward to any feedback on issues
that I might have overlooked, and ideas on mitigating problems to ensure
maximum safety.

Hopefully this will bring decentralized two-way peg sidechains one step
closer to becoming a reality.

Happy new year, everyone.


-- Ruben Somsen



This post is mirrored and kept up-to-date here:
https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1


[0] Drivechains
https://www.drivechain.info/

[1] PoW FP
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html

[2] PoW FP without a soft fork
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html

[3]: utreexo
https://eprint.iacr.org/2019/611.pdf

[4]: Forkmonitor
https://forkmonitor.info/notifications

[5]: Harding on worst-case utreexo
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201231/c6319a5b/attachment.html>

From ZmnSCPxj at protonmail.com  Thu Dec 31 23:26:24 2020
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Thu, 31 Dec 2020 23:26:24 +0000
Subject: [bitcoin-dev] Softchains: Sidechains as a Soft Fork via
	Proof-of-Work Fraud Proofs
In-Reply-To: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
References: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
Message-ID: <6eK97Mb_R3DEEsCsBa7_t2qi8dEiChCRNWFowyTY-hrpDcKcR_lrb8tfWh6jMpzS5tz1GL8odiXRNig5W9F83ryZD2WQ7vjOFxoJatFhhSo=@protonmail.com>

Good morning Ruben, and list,

First and foremost --- what is the point of sidechains, in the first place?

If sidechains are for experimental new features, then softforking in a new sidechain with novel untested new features would be additionally risky --- as you note, a bug in the sidechain consensus may cause non-deterministic consensus in the sidechain which would propagate into mainchain.
Federated sidechains, which already are enabled on current Bitcoin, are safer here, as mainchain will only care about the k-of-n signature that the federation agrees on, and if the federation is unable to come to consensus due to a sidechain consensus bug, "fails safe" in that it effectively disables the peg-out back to mainchain and restricts the consensus problem to the sidechain.

If sidechains are for scaling, then I would like to remind anyone reading this that ***blockchains do not scale***, and adding more blockchains for the purpose of scaling is *questionable*.
"I have a scaling problem.
I know, I will add a sidechain!
Now I have two scaling problems."

Ultimately, proof-of-work is about energy expenditure, and you would be splitting the global energy budget for blockchain security among multiple blockchains, thus making each blockchain easier to 51%.

Regards,
ZmnSCPxj

> Hi everyone,
>
> This post describes a fully decentralized two-way peg sidechain design. Activating new sidechains requires a soft fork, hence the name softchains. The key aspect is that all softchains are validated by everyone via Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus mechanism that only requires the validation of disputed blocks. This does increase the validation burden of mainchain full nodes, but only by a minimal amount (~100MB per chain per year). It's similar to drivechains[0], but without the major downside of having to rely on miners, since all Bitcoin full node users can efficiently validate each sidechain.
>
> Proof-of-Work Fraud Proofs
>
> Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2]. The idea is that we can use the existence of a fork in Bitcoin's PoW as evidence that a block might be invalid (i.e. a proof of potential fraud). Whenever this occurs, we download the block in question to verify whether it was valid (and available), and reject it if it was not. We forego the need for maintaining a UTXO set with UTXO set commitments (such as utreexo[3]), by assuming that the commitment inside the last block to exist in both forks is valid. As a result, we only need to download as many blocks (and their corresponding UTXO set proofs) as there are orphans, which lowers the validation costs considerably compared to running a full node.
>
> In the past 4 months, Forkmonitor has registered 11 stale and invalid blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin consensus would have to download and verify a little over 100MB per year in order to have consensus guarantees that come close to that of a full node:
> - All PoW headers (~4MB per year)
> - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)
> - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)
>
> The reason consensus is considered slow, is because we need to allow time for a honest PoW minority to fork away from an invalid chain. If we assume only 1% of all miners are honest, this means consensus slows down by 100x. If you are normally satisfied waiting for 6 confirmations, you now need to wait 600 confirmations. The longer you wait, the less honest miners you need.
>
> Softchains
>
> In order to have two-way pegged sidechains, you need a succinct method for proving to the mainchain that a peg-out is valid. PoW FP provides exactly that -- a low-bandwidth way of determining if a chain, and thus a peg-out, is valid. The slowness of PoW FP consensus is not an issue, as peg-outs can be made arbitrarily slow (e.g. one year).
>
> The safest design would be a set of softchains that shares its consensus code with Bitcoin Core, with the addition of UTXO set commitments, and disabling non-taproot address types to minimize certain resource usage issues[5]. All users validate the mainchain as usual with their full node, and all softchains are validated with PoW FP consensus. If a user is interested in directly using a specific softchain, they should run it as a full node in order to get fast consensus.
>
> Peg-ins occur by freezing coins on the mainchain and assigning them to a softchain. Peg-outs occur by creating a mainchain transaction that points to a peg-out transaction on a softchain and waiting for a sufficient number of mainchain confirmations. If the peg-out transaction remains part of the softchain according to PoW FP consensus, the coins become spendable.
>
> The peg-in/peg-out mechanism itself would require a soft fork (the exact design is an open question), and subsequently every softchain that gets activated will also require a soft fork.
>
> Potential dangers
>
> Softchain consensus still requires a form of validation from mainchain users, which means that consensus bugs can have an adverse effect. In particular, if a softchain suffers from a non-deterministic consensus bug, it may be the case that a majority accepts a peg-in, while a minority rejects it. This specific scenario could cause a chain split in mainchain consensus. This is why it would be safest to base softchain designs on Bitcoin Core.
>
> Similarly, it can theoretically be possible that a softchain gets a major reorg, invalidating a peg-out right as it would have become accepted on the mainchain, thus splitting consensus. The slow peg-out process makes this increasingly unlikely, but not impossible. One thing that might help (or perhaps only make it worse) is introducing a consensus rule that disallows reorgs that are bigger than half the peg-out time (e.g. half a year, if the peg-out is one year). This kind of rule does not actually solve this consensus problem, but instead pushes the problem forward so it plays out first on the softchain, giving time to take action before the problem affects the mainchain.
>
> It is also important that each softchain produces a non-trivial amount of PoW, because if the difficulty is too low, the cost of creating forks and increasing the resource usage of PoW FP consensus goes down. It may therefore make sense to have a minimum accepted difficulty for softchain blocks (slowing down the chain when fees are not sufficient). Merged Mining could also help here, since that would allow the softchains to potentially receive the same hashrate as Bitcoin (assuming all miners participate), but of course this would also put an additional validation burden on miners.
>
> In closing
>
> It may turn out that the consensus risks outlined above make this prohibitively risky, but at the very least it seems worth exploring the possibilities. At a minimum it would provide more opt-in block space, and it could potentially open the door to chains with entirely different consensus rules.
>
> Thank you for taking the time to read and comprehend my work. I will happily answer any questions and I look forward to any feedback on issues that I might have overlooked, and ideas on mitigating problems to ensure maximum safety.
>
> Hopefully this will bring decentralized two-way peg sidechains one step closer to becoming a reality.
>
> Happy new year, everyone.
>
> -- Ruben Somsen
>
> This post is mirrored and kept up-to-date here:
> https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1
>
> [0] Drivechains
> https://www.drivechain.info/
>
> [1] PoW FP
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html
>
> [2] PoW FP without a soft fork
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html
>
> [3]: utreexo
> https://eprint.iacr.org/2019/611.pdf
>
> [4]: Forkmonitor
> https://forkmonitor.info/notifications
>
> [5]: Harding on worst-case utreexo
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html



From sergio.d.lerner at gmail.com  Thu Dec 31 23:37:58 2020
From: sergio.d.lerner at gmail.com (Sergio Demian Lerner)
Date: Thu, 31 Dec 2020 20:37:58 -0300
Subject: [bitcoin-dev] Softchains: Sidechains as a Soft Fork via
 Proof-of-Work Fraud Proofs
In-Reply-To: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
References: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
Message-ID: <CAKzdR-rWe6ecFV6AjxEzBKnH=+PYdfkuuo0-Su8-SPj=SQrS9A@mail.gmail.com>

Hi Roben,
 It's an interesting proposal, but I have two issues with it, one technical
and one philosophical.

On the technical side, I don't understand how your proposal prevents miners
proposing a peg-out for an invalid sidechain fork which is not made
available to the nodes (there are missing blocks). It seems that the system
would need to allow users to challenge miners to make available full
sidechain blocks that are missing, which really complicates the protocol.

On the philosophical side, as you mentioned, it is very limited in the
types of sidechains it can verify. I won't be able to verify RSK
(merge-mined with Bitcoin, but with different block format and different
functionality). It cannot verify a zCash-like sidechain for the same
reasons. Therefore it is strictly a payment scalability solution.
Drivechains, on the other hand, enable many new use cases apart from
scaling, which have a much lower level of complexity (if implemented
correctly).

Since the inception of RSK sidechain, I suggested in its white-paper that
sidechains should be designed to support an hybrid peg-out system, based on
both a large multisig AND a drivechain, where both groups need to agree for
the peg-out to occur.  It's a censorship/security trade-off that most users
would be willing to accept until a trusted-setup-free SNARK-like based
solution is finally available.
Until we have a sidechain-selectable SNARK-like succinct verification of
any block state transition function, having a single succint proof to cover
the whole sidechain validity, as in Coda (now renamed Mina), drivechains
are the low-hanging-fruit.

regards

On Thu, Dec 31, 2020 at 7:01 PM Ruben Somsen via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi everyone,
>
> This post describes a fully decentralized two-way peg sidechain design.
> Activating new sidechains requires a soft fork, hence the name softchains.
> The key aspect is that all softchains are validated by everyone via
> Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus
> mechanism that only requires the validation of disputed blocks. This does
> increase the validation burden of mainchain full nodes, but only by a
> minimal amount (~100MB per chain per year). It's similar to drivechains[0],
> but without the major downside of having to rely on miners, since all
> Bitcoin full node users can efficiently validate each sidechain.
>
>
> Proof-of-Work Fraud Proofs
>
> Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].
> The idea is that we can use the existence of a fork in Bitcoin's PoW as
> evidence that a block might be invalid (i.e. a proof of potential fraud).
> Whenever this occurs, we download the block in question to verify whether
> it was valid (and available), and reject it if it was not. We forego the
> need for maintaining a UTXO set with UTXO set commitments (such as
> utreexo[3]), by assuming that the commitment inside the last block to exist
> in both forks is valid. As a result, we only need to download as many
> blocks (and their corresponding UTXO set proofs) as there are orphans,
> which lowers the validation costs considerably compared to running a full
> node.
>
> In the past 4 months, Forkmonitor has registered 11 stale and invalid
> blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin
> consensus would have to download and verify a little over 100MB per year in
> order to have consensus guarantees that come close to that of a full node:
> - All PoW headers (~4MB per year)
> - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)
> - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)
>
> The reason consensus is considered slow, is because we need to allow time
> for a honest PoW minority to fork away from an invalid chain. If we assume
> only 1% of all miners are honest, this means consensus slows down by 100x.
> If you are normally satisfied waiting for 6 confirmations, you now need to
> wait 600 confirmations. The longer you wait, the less honest miners you
> need.
>
>
> Softchains
>
> In order to have two-way pegged sidechains, you need a succinct method for
> proving to the mainchain that a peg-out is valid. PoW FP provides exactly
> that -- a low-bandwidth way of determining if a chain, and thus a peg-out,
> is valid. The slowness of PoW FP consensus is not an issue, as peg-outs can
> be made arbitrarily slow (e.g. one year).
>
> The safest design would be a set of softchains that shares its consensus
> code with Bitcoin Core, with the addition of UTXO set commitments, and
> disabling non-taproot address types to minimize certain resource usage
> issues[5]. All users validate the mainchain as usual with their full node,
> and all softchains are validated with PoW FP consensus. If a user is
> interested in directly using a specific softchain, they should run it as a
> full node in order to get fast consensus.
>
> Peg-ins occur by freezing coins on the mainchain and assigning them to a
> softchain. Peg-outs occur by creating a mainchain transaction that points
> to a peg-out transaction on a softchain and waiting for a sufficient number
> of mainchain confirmations. If the peg-out transaction remains part of the
> softchain according to PoW FP consensus, the coins become spendable.
>
> The peg-in/peg-out mechanism itself would require a soft fork (the exact
> design is an open question), and subsequently every softchain that gets
> activated will also require a soft fork.
>
>
> Potential dangers
>
> Softchain consensus still requires a form of validation from mainchain
> users, which means that consensus bugs can have an adverse effect. In
> particular, if a softchain suffers from a non-deterministic consensus bug,
> it may be the case that a majority accepts a peg-in, while a minority
> rejects it. This specific scenario could cause a chain split in mainchain
> consensus. This is why it would be safest to base softchain designs on
> Bitcoin Core.
>
> Similarly, it can theoretically be possible that a softchain gets a major
> reorg, invalidating a peg-out right as it would have become accepted on the
> mainchain, thus splitting consensus. The slow peg-out process makes this
> increasingly unlikely, but not impossible. One thing that might help (or
> perhaps only make it worse) is introducing a consensus rule that disallows
> reorgs that are bigger than half the peg-out time (e.g. half a year, if the
> peg-out is one year). This kind of rule does not actually solve this
> consensus problem, but instead pushes the problem forward so it plays out
> first on the softchain, giving time to take action before the problem
> affects the mainchain.
>
> It is also important that each softchain produces a non-trivial amount of
> PoW, because if the difficulty is too low, the cost of creating forks and
> increasing the resource usage of PoW FP consensus goes down. It may
> therefore make sense to have a minimum accepted difficulty for softchain
> blocks (slowing down the chain when fees are not sufficient). Merged Mining
> could also help here, since that would allow the softchains to potentially
> receive the same hashrate as Bitcoin (assuming all miners participate), but
> of course this would also put an additional validation burden on miners.
>
>
> In closing
>
> It may turn out that the consensus risks outlined above make this
> prohibitively risky, but at the very least it seems worth exploring the
> possibilities. At a minimum it would provide more opt-in block space, and
> it could potentially open the door to chains with entirely different
> consensus rules.
>
> Thank you for taking the time to read and comprehend my work. I will
> happily answer any questions and I look forward to any feedback on issues
> that I might have overlooked, and ideas on mitigating problems to ensure
> maximum safety.
>
> Hopefully this will bring decentralized two-way peg sidechains one step
> closer to becoming a reality.
>
> Happy new year, everyone.
>
>
> -- Ruben Somsen
>
>
>
> This post is mirrored and kept up-to-date here:
> https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1
>
>
> [0] Drivechains
> https://www.drivechain.info/
>
> [1] PoW FP
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html
>
> [2] PoW FP without a soft fork
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html
>
> [3]: utreexo
> https://eprint.iacr.org/2019/611.pdf
>
> [4]: Forkmonitor
> https://forkmonitor.info/notifications
>
> [5]: Harding on worst-case utreexo
>
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20201231/3ee7d3df/attachment-0001.html>

From rsomsen at gmail.com  Thu Dec 31 23:39:10 2020
From: rsomsen at gmail.com (Ruben Somsen)
Date: Fri, 1 Jan 2021 00:39:10 +0100
Subject: [bitcoin-dev] Softchains: Sidechains as a Soft Fork via
 Proof-of-Work Fraud Proofs
In-Reply-To: <6eK97Mb_R3DEEsCsBa7_t2qi8dEiChCRNWFowyTY-hrpDcKcR_lrb8tfWh6jMpzS5tz1GL8odiXRNig5W9F83ryZD2WQ7vjOFxoJatFhhSo=@protonmail.com>
References: <CAPv7TjaZEPviBw=tAk7eZ1Wc_FCdRuyHB0xK+Wr3QREB75BwHw@mail.gmail.com>
 <6eK97Mb_R3DEEsCsBa7_t2qi8dEiChCRNWFowyTY-hrpDcKcR_lrb8tfWh6jMpzS5tz1GL8odiXRNig5W9F83ryZD2WQ7vjOFxoJatFhhSo=@protonmail.com>
Message-ID: <CAPv7TjaZ2zPH33yPrW8hO=M7X8R3rDN+O8-R-JuUs6vRUH1Ovg@mail.gmail.com>

Happy new morning ZmnSCPxj,

Thanks for taking a look :)

>If sidechains are for experimental new features, then softforking in a new
sidechain with novel untested new features would be additionally risky

There is definitely a risk, but it's one that can be minimized. For
instance, a softchain with Confidential Transactions could be introduced,
which allows for appealing privacy features without introducing a
completely new code base.

>If sidechains are for scaling, then I would like to remind anyone reading
this that ***blockchains do not scale***

I agree, you will still run into limitations, but you do get some scaling
gains from not having to verify each chain, but only the subset that
interests you.

>you would be splitting the global energy budget for blockchain security
among multiple blockchains

Not necessarily if you incorporate Merged Mining, but of course that comes
with the tradeoff of requiring miners to do more validation.

Cheers,
Ruben

On Fri, Jan 1, 2021 at 12:26 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Ruben, and list,
>
> First and foremost --- what is the point of sidechains, in the first place?
>
> If sidechains are for experimental new features, then softforking in a new
> sidechain with novel untested new features would be additionally risky ---
> as you note, a bug in the sidechain consensus may cause non-deterministic
> consensus in the sidechain which would propagate into mainchain.
> Federated sidechains, which already are enabled on current Bitcoin, are
> safer here, as mainchain will only care about the k-of-n signature that the
> federation agrees on, and if the federation is unable to come to consensus
> due to a sidechain consensus bug, "fails safe" in that it effectively
> disables the peg-out back to mainchain and restricts the consensus problem
> to the sidechain.
>
> If sidechains are for scaling, then I would like to remind anyone reading
> this that ***blockchains do not scale***, and adding more blockchains for
> the purpose of scaling is *questionable*.
> "I have a scaling problem.
> I know, I will add a sidechain!
> Now I have two scaling problems."
>
> Ultimately, proof-of-work is about energy expenditure, and you would be
> splitting the global energy budget for blockchain security among multiple
> blockchains, thus making each blockchain easier to 51%.
>
> Regards,
> ZmnSCPxj
>
> > Hi everyone,
> >
> > This post describes a fully decentralized two-way peg sidechain design.
> Activating new sidechains requires a soft fork, hence the name softchains.
> The key aspect is that all softchains are validated by everyone via
> Proof-of-Work Fraud Proofs (PoW FP) -- a slow but very efficient consensus
> mechanism that only requires the validation of disputed blocks. This does
> increase the validation burden of mainchain full nodes, but only by a
> minimal amount (~100MB per chain per year). It's similar to drivechains[0],
> but without the major downside of having to rely on miners, since all
> Bitcoin full node users can efficiently validate each sidechain.
> >
> > Proof-of-Work Fraud Proofs
> >
> > Last year I posted the idea of PoW FP to the Bitcoin mailing list[1][2].
> The idea is that we can use the existence of a fork in Bitcoin's PoW as
> evidence that a block might be invalid (i.e. a proof of potential fraud).
> Whenever this occurs, we download the block in question to verify whether
> it was valid (and available), and reject it if it was not. We forego the
> need for maintaining a UTXO set with UTXO set commitments (such as
> utreexo[3]), by assuming that the commitment inside the last block to exist
> in both forks is valid. As a result, we only need to download as many
> blocks (and their corresponding UTXO set proofs) as there are orphans,
> which lowers the validation costs considerably compared to running a full
> node.
> >
> > In the past 4 months, Forkmonitor has registered 11 stale and invalid
> blocks[4]. Extrapolating from that data, a PoW FP node verifying Bitcoin
> consensus would have to download and verify a little over 100MB per year in
> order to have consensus guarantees that come close to that of a full node:
> > - All PoW headers (~4MB per year)
> > - 3 x 11 = 33 full blocks (~2MB x 33 = 66MB)
> > - UTXO merkle proofs (~1MB x 33 = 33MB with utreexo)
> >
> > The reason consensus is considered slow, is because we need to allow
> time for a honest PoW minority to fork away from an invalid chain. If we
> assume only 1% of all miners are honest, this means consensus slows down by
> 100x. If you are normally satisfied waiting for 6 confirmations, you now
> need to wait 600 confirmations. The longer you wait, the less honest miners
> you need.
> >
> > Softchains
> >
> > In order to have two-way pegged sidechains, you need a succinct method
> for proving to the mainchain that a peg-out is valid. PoW FP provides
> exactly that -- a low-bandwidth way of determining if a chain, and thus a
> peg-out, is valid. The slowness of PoW FP consensus is not an issue, as
> peg-outs can be made arbitrarily slow (e.g. one year).
> >
> > The safest design would be a set of softchains that shares its consensus
> code with Bitcoin Core, with the addition of UTXO set commitments, and
> disabling non-taproot address types to minimize certain resource usage
> issues[5]. All users validate the mainchain as usual with their full node,
> and all softchains are validated with PoW FP consensus. If a user is
> interested in directly using a specific softchain, they should run it as a
> full node in order to get fast consensus.
> >
> > Peg-ins occur by freezing coins on the mainchain and assigning them to a
> softchain. Peg-outs occur by creating a mainchain transaction that points
> to a peg-out transaction on a softchain and waiting for a sufficient number
> of mainchain confirmations. If the peg-out transaction remains part of the
> softchain according to PoW FP consensus, the coins become spendable.
> >
> > The peg-in/peg-out mechanism itself would require a soft fork (the exact
> design is an open question), and subsequently every softchain that gets
> activated will also require a soft fork.
> >
> > Potential dangers
> >
> > Softchain consensus still requires a form of validation from mainchain
> users, which means that consensus bugs can have an adverse effect. In
> particular, if a softchain suffers from a non-deterministic consensus bug,
> it may be the case that a majority accepts a peg-in, while a minority
> rejects it. This specific scenario could cause a chain split in mainchain
> consensus. This is why it would be safest to base softchain designs on
> Bitcoin Core.
> >
> > Similarly, it can theoretically be possible that a softchain gets a
> major reorg, invalidating a peg-out right as it would have become accepted
> on the mainchain, thus splitting consensus. The slow peg-out process makes
> this increasingly unlikely, but not impossible. One thing that might help
> (or perhaps only make it worse) is introducing a consensus rule that
> disallows reorgs that are bigger than half the peg-out time (e.g. half a
> year, if the peg-out is one year). This kind of rule does not actually
> solve this consensus problem, but instead pushes the problem forward so it
> plays out first on the softchain, giving time to take action before the
> problem affects the mainchain.
> >
> > It is also important that each softchain produces a non-trivial amount
> of PoW, because if the difficulty is too low, the cost of creating forks
> and increasing the resource usage of PoW FP consensus goes down. It may
> therefore make sense to have a minimum accepted difficulty for softchain
> blocks (slowing down the chain when fees are not sufficient). Merged Mining
> could also help here, since that would allow the softchains to potentially
> receive the same hashrate as Bitcoin (assuming all miners participate), but
> of course this would also put an additional validation burden on miners.
> >
> > In closing
> >
> > It may turn out that the consensus risks outlined above make this
> prohibitively risky, but at the very least it seems worth exploring the
> possibilities. At a minimum it would provide more opt-in block space, and
> it could potentially open the door to chains with entirely different
> consensus rules.
> >
> > Thank you for taking the time to read and comprehend my work. I will
> happily answer any questions and I look forward to any feedback on issues
> that I might have overlooked, and ideas on mitigating problems to ensure
> maximum safety.
> >
> > Hopefully this will bring decentralized two-way peg sidechains one step
> closer to becoming a reality.
> >
> > Happy new year, everyone.
> >
> > -- Ruben Somsen
> >
> > This post is mirrored and kept up-to-date here:
> > https://gist.github.com/RubenSomsen/7ecf7f13dc2496aa7eed8815a02f13d1
> >
> > [0] Drivechains
> > https://www.drivechain.info/
> >
> > [1] PoW FP
> >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-April/016873.html
> >
> > [2] PoW FP without a soft fork
> >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017287.html
> >
> > [3]: utreexo
> > https://eprint.iacr.org/2019/611.pdf
> >
> > [4]: Forkmonitor
> > https://forkmonitor.info/notifications
> >
> > [5]: Harding on worst-case utreexo
> >
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-September/017298.html
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20210101/6aa5944d/attachment-0001.html>

