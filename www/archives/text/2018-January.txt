From willtech at live.com.au  Mon Jan  1 11:04:57 2018
From: willtech at live.com.au (Damian Williamson)
Date: Mon, 1 Jan 2018 11:04:57 +0000
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction
 Priority For Ordering Transactions In Blocks
Message-ID: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

Happy New Year all.

This proposal has been further amended with several minor changes and a
few additions.

I believe that all known issues raised so far have been sufficiently
addressed. Either that or, I still have more work to do.

## BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks

Schema: ?
########## ?
Document: BIP Proposal ?
Title: UTPFOTIB - Use Transaction Priority For Ordering Transactions In
Blocks ?
Published: 26-12-2017 ?
Revised: 01-01-2018 ?
Author: Damian Williamson <willtech at live.com.au>??
Licence: Creative Commons Attribution-ShareAlike 4.0 International
License. ?
URL: http://thekingjameshrmh.tumblr.com/post/168948530950/bip-proposal-
utpfotib-use-transaction-priority-for-order??
##########

### 1. Abstract

This document proposes to address the issue of transactional
reliability in Bitcoin, where valid transactions may be stuck in the
transaction pool for extended periods or never confirm.

There are two key issues to be resolved to achieve this:

1.??The current transaction bandwidth limit.
2.??The current ad-hoc methods of including transactions in blocks
resulting in variable and confusing confirmation times for valid
transactions, including transactions with a valid fee that may never
confirm.

It is important with any change to protect the value of fees as these
will eventually be the only payment that miners receive. Rather than an
auction model for limited bandwidth, the proposal results in a fee for
priority service auction model.

It would not be true to suggest that all feedback received so far has
been entirely positive although, most of it has been constructive.

The previous threads for this proposal are available here: ?
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/s
ubject.html

In all parts of this proposal, references to a transaction, a valid
transaction, a transaction with a valid fee, a valid fee, etc. is
defined as any transaction that is otherwise valid with a fee of at
least 0.00001000 BTC/KB as defined as the dust level, interpreting from
Bitcoin Core GUI. Transactions with a fee lower than this rate are
considered dust.

In all parts of this proposal, dust and zero-fee transactions are
always ignored and/or excluded unless specifically mentioned.

It is generally assumed that miners currently prefer to include
transactions with higher fees.

### 2. The need for this proposal

We all must learn to admit that transaction bandwidth is still lurking
as a serious issue for the operation, reliability, safety, consumer
acceptance, uptake and, for the value of Bitcoin.

I recently sent a payment which was not urgent so; I chose three-day
target confirmation from the fee recommendation. That transaction has
still not confirmed after now more than six days - even waiting twice
as long seems quite reasonable to me (note for accuracy: it did
eventually confirm). That transaction is a valid transaction; it is not
rubbish, junk or, spam. Under the current model with transaction
bandwidth limitation, the longer a transaction waits, the less likely
it is ever to confirm due to rising transaction numbers and being
pushed back by transactions with rising fees.

I argue that no transactions with fees above the dust level are rubbish
or junk, only some zero fee transactions might be spam. Having an ever-
increasing number of valid transactions that do not confirm as more new
transactions with higher fees are created is the opposite of operating
a robust, reliable transaction system.

While the miners have discovered a gold mine, it is the service they
provide that is valuable. If the service is unreliable they are not
worth the gold that they mine. This is reflected in the value of
Bitcoin.

Business cannot operate with a model where transactions may or may not
confirm. Even a business choosing a modest fee has no guarantee that
their valid transaction will not be shuffled down by new transactions
to the realm of never confirming after it is created. Consumers also
will not accept this model as Bitcoin expands. If Bitcoin cannot be a
reliable payment system for confirmed transactions then consumers, by
and large, will simply not accept the model once they understand.
Bitcoin will be a dirty payment system, and this will kill the value of
Bitcoin.

Under the current system, a minority of transactions will eventually be
the lucky few who have fees high enough to escape being pushed down the
list.

Once there are more than x transactions (transaction bandwidth limit)
every ten minutes, only those choosing twenty-minute confirmation (2
blocks) from the fee recommendations will have initially at most a
fifty percent chance of ever having their payment confirm by the time
2x transactions is reached. Presently, not even using fee
recommendations can ensure a sufficiently high fee is paid to ensure
transaction confirmation.

I also argue that the current auction model for limited transaction
bandwidth is wrong, is not suitable for a reliable transaction system
and, is wrong for Bitcoin. All transactions with valid fees must
confirm in due time. Currently, Bitcoin is not a safe way to send
payments.

I do not believe that consumers and business are against paying fees,
even high fees. What is required is operational reliability.

This great issue needs to be resolved for the safety and reliability of
Bitcoin. The time to resolve issues in commerce is before they become
great big issues. The time to resolve this issue is now. We must have
the foresight to identify and resolve problems before they trip us
over.??Simply doubling block sizes every so often is reactionary and is
not a reliable permanent solution.

I have written this proposal for a technical solution but, need your
help to write it up to an acceptable standard to be a full BIP.

### 3. The problem

Everybody wants value. Miners want to maximise revenue from fees (and
we presume, to minimise block size). Consumers need transaction
reliability and, (we presume) want low fees.

The current transaction bandwidth limit is a limiting factor for both.
As the operational safety of transactions is limited, so is consumer
confidence as they realise the issue and, accordingly, uptake is
limited. Fees are artificially inflated due to bandwidth limitations
while failing to provide a full confirmation service for all valid
transactions.

Current fee recommendations provide no satisfaction for transaction
reliability and, as Bitcoin scales, this will worsen.

Transactions are included in blocks by miners using whatever basis they
prefer. We expect that this is usually a fee-based priority. However,
even transactions with a valid fee may be left in the transaction pool
for some time. As transaction bandwidth becomes an issue, not even
extreme fees can ensure a transaction is processed in a timely manner
or at all.

Bitcoin must be a fully scalable and reliable service, providing full
transaction confirmation for every valid transaction.

The possibility to send a transaction with a fee lower than one that is
acceptable to allow eventual transaction confirmation should be removed
from the protocol and also from the user interface.

Bitcoin should be capable of reliably and inexpensively processing
casual transactions, and also priority processing of fee paying at
auction for priority transactions in the shortest possible timeframe.

### 4. Solution summary

#### Main solution

Provide each valid transaction in the mempool with an individual
transaction priority each time before choosing transactions to include
in the current block. The priority being a function of the fee (on a
curve), and the time waiting in the transaction pool (also on a curve)
out to n days (n = 60 days ?), and extending past n days. The value for
fee on a curve may need an upper limit. The transaction priority to
serve as the likelihood of a transaction being included in the current
block, and for determining the order in which transactions are tried to
see if they will be included.

Nodes will need to keep track of when a transaction is first seen. It
is satisfactory for each node to do this independently provided the
full mempool and information survives node restart. If there is a more
reliable way to determine when a transaction was first seen on the
network then it should be utilised.

> My current default installation of Bitcoin Core v0.15.1 does not
currently seem to save and load the mempool on restart, despite the
notes in the command line options panel that the default for
persistmempool is 1. In the debug panel, some 90,000 transactions
before restart, some 200 odd shortly after. Manually setting
persistmempool=1 in the conf file does not seem to make any difference.
Perhaps it is operating as expected and I am not sure what to observe,
but does not seem to be observably saving and loading the mempool on
restart. This will need to be resolved.

Use a dynamic target block size to make the current block. This marks a
shift from using block size or weight to a count of transactions.
Determine the target block size using; pre-rollout(current average
valid transaction pool size) x ( 1 / (144 x n days ) ) = number of
transactions to be included in the current block. The block created
should be a minimum 1MB in size regardless if the target block size is
lower.

If the created block size consistently contains too few transactions
and the number of new transactions created is continuously greater than
the block size will accommodate then I expect eventually ageing
transactions will be over-represented as a portion of the block
contents. Once another new node conforming to the proposal makes a
block, the block size will be proportionately larger as the transaction
pool has grown.??If block size is too large on average then this will
shrink the transaction pool.

Miners will likely want to conform to the proposal, since making blocks
larger than necessary makes more room in each block potentially
lowering the highest fees paid for priority service. Always making
blocks smaller than the proposal requires will in time lower the
utility value of Bitcoin, a different situation but akin to the
current. Transactions will still always confirm but with longer and
longer wait periods. The auction at the front of the queue for priority
will be destroyed as there will be eventually no room in blocks besides
ageing transations and, there will be little value paying higher than
the minimum fee. Obviously, neither of these scenarios are in a miner's
interests.

Without a consensus as to what size dynamic block to create,
enforcement of dynamic block size is not currently possible. It may be
possible for a consensus to be formed in the future but here I cannot
speculate. I can only suggest that it is in the interest of Bitcoin as
a whole and, in the interest of each node to conform to the proposal.
Some nodes failing to conform to the proposed requirements of dynamic
size or transaction priority in this proposal will not be destructive
to the operation of the proposal.

If necessary, nodes that have not yet adopted the proposal will just
continue to create standard fixed size unordered blocks, although, if
the current mechanisms of block validation include the fixed block size
then it is unlikely that these nodes will be able to validate the
blockchain going forward. In this case a hard fork and a full transfer
to the new method should be required. If dynamic blocks with ordered
transactions will be valid to existing nodes then only a soft fork is
required. There is no proposed change to the internal construction of
blocks, only to the block size and using an ordered method of
transaction selection.

> The default value for mempoolexpiry in Bitcoin Core may in future
need to be adjusted to match something more than n days or, perhaps
using less than n = 14 days may be a more sensible approach?

All block created with dynamic size should be verified to ensure
conformity to a probability distribution curve resulting from the
priority method. Since the input is a probability, the output should
conform to a probability distribution.

The curves used for the priority of transactions would have to be
appropriate. Perhaps a mathematician with experience in probability can
develop the right formulae. My thinking is a steep curve. I suppose
that the probability of all transactions should probably account for a
sufficient number of inclusions that the target block size is met on
average although, it may not always be. As a suggestion, consider
including some dust or zero-fee transactions to pad if each valid
transaction is tried and the target block size is not yet met, highest
BTC transaction value first?

**Explanation of the operation of priority:**

> If transaction priority is, for example, a number between one (low)
and one-hundred (high) it can be directly understood as the percentage
chance in one-hundred of a transaction being included in the block.
Using probability or likelihood infers that there is some function of
random. Try the transactions in priority order from highest to lowest,
if random (100) < transaction priority then the transaction is included
until the target block size is met.?

> To break it down further, if both the fee on a curve value and the
time waiting on a curve value are each a number between one and one-
hundred, a rudimentary method may be to simply multiply those two
numbers, to find the priority number. For example, a middle fee
transaction waiting thirty days (if n = 60 days) may have a value of
five for each part??(yes, just five, the values are on a curve). When
multiplied that will give a priority value of twenty-five, or, a
twenty-five percent chance at that moment of being included in the
block; it will likely be included in one of the next four blocks,
getting more likely each chance. If it is still not included then the
value of time waiting will be higher, making for more probability. A
very low fee transaction would have a value for the fee of one. It
would not be until near sixty-days that the particular low fee
transaction has a high likelihood of being included in the block.

In practice it may be more useful to use numbers representative of one-
hundred for the highest fee priority curve down to a small fraction of
one for the lowest fee and, from one for a newly seen transaction up to
a proportionately high number above one-hundred for the time waiting
curve. It is truely beyond my level of math to resolve probability
curves accurately without much trial and error.

The primary reason for addressing the issue is to ensure transactional
reliability and scalability while having each valid transaction confirm
in due time.

#### Pros

*???Maximizes transaction reliability.
*???Overcomes transaction bandwidth limit.
*???Fully scalable.
*???Maximizes possibility for consumer and business uptake.
*???Maximizes total fees paid per block without reducing reliability;
because of reliability, in time confidence and overall uptake are
greater; therefore, more transactions.
*???Market determines fee paid for transaction priority.
*???Fee recommendations work all the way out to 30 days or greater.
*???Provides additional block entropy; greater security since there is
less probability of predicting the next block. _Although this is not
necessary it is a product of the operation of this proposal._

#### Cons

*???Could initially lower total transaction fees per block.
*???Must be first be programmed.

#### Pre-rollout

Nodes need to have at a minimum a loose understanding of the average
(since there is no consensus) size of the transaction pool as a
requirement to enable future changes to the way blocks are constructed.

A new network service should be constructed to meet this need. This
service makes no changes to any existing operation or function of the
node. Initially, Bitcoin Core is a suitable candidate.

For all operations we count only valid transactions.

**The service must:**

*???Have an individual temporary (runtime permanent only) Serial Node
ID.
*???Accept communication of the number of valid transactions in the
mempool of another valid Bitcoin node along with the Serial Node ID of
the node whose value is provided.
*???Disconnect the service from any non-Bitcoin node. Bitcoin Core may
handle this already?
*???Expire any value not updated for k minutes (k = 30 minutes?).
*???Broadcast all mempool information the node has every m minutes (m =
10 minutes?), including its own.
*???Nodes own mempool information should not be broadcast or used in
calculation until the node has been up long enough for the mempool to
normalise for at least o minutes (o = 300 minutes ?)
*???Alternatively, if loading nodes own full mempool from disk on node
restart (o = 30 minutes ?)
*???Only new or updated mempool values should be transmitted to the
same node. Updated includes updated with no change.
*???All known mempool information must survive node restart.
*???If the nodes own mempool is not normalised and network information
is not available to calculate an average just display zero.
*???Internally, the average transaction pool size must return the
calculated average if an average is available or, if none is available
just the number of valid transactions in the node's own mempool
regardless if it is normalised.

Bitcoin Core must use all collated information on mempool size to
calculate a figure for the average mempool size.

The calculated figure should be displayed in the appropriate place in
the Debug window alongside the text Network average transactions.

Consideration must be given before development of the network bandwidth
this would require. All programming must be consistent with the current
operation and conventions of Bitcoin Core. Methods must work on all
platforms.

As this new service does not affect any existing service or feature of
Bitcoin or Bitcoin Core, this can technically be programmed now and
included in Bitcoin Core at any time.

### 5. Solution operation

This is a simplistic view of the operation. The actual operation will
need to be determined accurately in a spec for the programmer.

1.??Determine the target block size for the current block.
2.??Assign a transaction priority to each valid transaction in the
mempool.
3.??Select transactions to include in the current block using
probability in transaction priority order until the target block size
is met. If target block size is not met, include dust and zero-fee
transactions to pad.
4.??Solve block.
5.??Broadcast the current block when it is solved.
6.??Block is received.
7.??Block verification process.
8.??Accept/reject block based on verification result.
9.??Repeat.

### 6. Closing comments

It may be possible to verify blocks conform to the proposal by showing
that the probability for all transactions included in the block
statistically conforms to a probability distribution curve, *if* the
individual transaction priority can be recreated. I am not that deep
into the mathematics; however, it may also be possible to use a similar
method to do this just based on the fee, that statistically, the block
conforms to a fee distribution. Any dust and zero-fee transactions
would have to be ignored. This solution needs a competent mathematician
with experience in probability and statistical distribution.

It is trivial to this proposal to offer that a node provides the next
block size with a block when it is solved. I am not sure that this
creates any actual benefit since the provided next block size is only
one node's view, as it is the node may seemingly just as well use its
own view and create the block. Providing a next block size only adds
additional complexity to the required operation, however, perhaps
providing the next block size is not trivial in what is accomplished
and the feature can be included in the operation.

Instead of the pre-rollout network service providing data as to valid
transactions in mempool, it could directly provide data as to the
suggested next block size if that is preferred, using a similar
operation as is suggested now and averaging all received suggested next
block sizes.

It may be foreseeable in the future for Bitcoin to operate with a
network of dedicated full blockchain & mempool servers. This would not
be without challenges to overcome but would offer several benefits,
including to the operation of this proposal, and especially as the RAM
and storage requirements of a full node grows. It is easy to foresee
that in just another seven years of operation a Bitcoin Full Node will
require at least 300GB of storage and, if the mempool only doubles in
size, over 1GB of RAM.

There has been some concern expressed over spam and very low fee
transactions, and an infinite block size resulting. I hope that for
those concerned using the dust level addresses the issue, especially as
the value of Bitcoin grows.

Notwithstanding this proposal, all blocks including those with dynamic
size each have limited transaction space per block. This proposal
results in a fee for priority service auction, where the probability of
a transaction to be included in limited space in the next available
block is auctioned to the highest bidders and all other transactions
must wait until they reach priority by ageing to gain significant
probability. Under this proposal the mempool can grow quite large while
the confirmation service continues in a stable and reliable manner.
Several incentives for attackers are removed, where there is no longer
multiple potential incentives for unnecessarily filling blocks or
flooding the mempool with transactions, whether such transactions are
fraudulent, valid or, otherwise. Adoption of this proposal and
adherence results in a reliable, stable fee paying transaction
confirmation service and a beneficial auction.

This proposal is necessary. I implore, at the very least, that we use
some method that validates full transaction reliability and enables
scalability of Bitcoin. If not this proposal, an alternative.

I have done as much with this proposal as I feel that I am able so far
but continue to take your feedback.

Regards, ?
Damian Williamson

[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/
88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/) ?
<span xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text" property="dct:title"
rel="dct:type">BIP Proposal: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks</span> by [Damian Williamson
&lt;willtech at live.com.au&gt;](http://thekingjameshrmh.tumblr.com/post/1
68948530950/bip-proposal-utpfotib-use-transaction-priority-for-order)
is licensed under a [Creative Commons Attribution-ShareAlike 4.0
International License](http://creativecommons.org/licenses/by-sa/4.0/).
Based on a work at https://lists.linuxfoundation.org/pipermail/bitcoin-
dev/2017-
December/015371.html](https://lists.linuxfoundation.org/pipermail/bitco
in-dev/2017-December/015371.html).
Permissions beyond the scope of this license may be available at [https
://opensource.org/licenses/BSD-3-
Clause](https://opensource.org/licenses/BSD-3-Clause).



From james.hilliard1 at gmail.com  Mon Jan  1 18:50:04 2018
From: james.hilliard1 at gmail.com (James Hilliard)
Date: Mon, 1 Jan 2018 12:50:04 -0600
Subject: [bitcoin-dev] Decoupling BIP70 Payment Protocol from Wallets
Message-ID: <CADvTj4q04dS0pv2rUD9qw30K6++5OjHPwgjpqJ=+MBqaZdropA@mail.gmail.com>

Recently a large merchant payment processor has decided to drop
support for BIP21 payment URI's in favor of accepting exclusively
BIP70 payments which has brought to light a number of problems with
BIP70:

1. Many wallets do not support BIP70 and have no near term intention
of doing so.
2. BIP70 requires large complex PKI dependencies such as X.509 and TLS
support(usually via openssl) which have a large attack surface and
poor track record when it comes to vulnerabilities.
3. Signing transactions with keys resident in the same application as
that which handles TLS greatly increases the possibility of keys being
leaked due to vulnerabilities in TLS libraries such as
openssl(heartbleed etc).
4. Sending payments first to a BIP70 compatible wallet before sending
to the merchant increases fees and uses more block space than sending
directly since it is often not feasible for users to fully migrate
funds to a BIP70 compatible wallet.
5. Paying a BIP70 invoice with an incompatible wallet currently
requires manual non-user-friendly workarounds such as
https://github.com/achow101/payment-proto-interface

I propose that we move the BIP70 protocol implementation into a
browser extension that can communicate with wallets over a simple IPC
mechanism such as
https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Native_messaging
in addition to acting as a translation layer that can convert BIP70
URL's into standard BIP21 URI's for wallets that do not wish to
support BIP70 or other custom schemes.

This will provide a number of advantages over the current method of
implementing BIP70 directly within wallets:

1. It removes complex/risky dependencies from wallets and moves them
into the browser which already has to implement full PKI support.
2. It re-enables payment support for wallets that only support
BIP21/normal addresses.
3. It makes offline/custom signing schemes easier to use with BIP70.

From bitcoin-dev at rgrant.org  Tue Jan  2 11:31:51 2018
From: bitcoin-dev at rgrant.org (Ryan Grant)
Date: Tue, 2 Jan 2018 06:31:51 -0500
Subject: [bitcoin-dev] Decoupling BIP70 Payment Protocol from Wallets
In-Reply-To: <CADvTj4q04dS0pv2rUD9qw30K6++5OjHPwgjpqJ=+MBqaZdropA@mail.gmail.com>
References: <CADvTj4q04dS0pv2rUD9qw30K6++5OjHPwgjpqJ=+MBqaZdropA@mail.gmail.com>
Message-ID: <CAMnpzfrQ0OKoCGQ5yBiku54dKk6ppj8HO0ZmochzJb_rm2WtjQ@mail.gmail.com>

On Mon, Jan 1, 2018 at 1:50 PM, James Hilliard via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I propose that we move the BIP70 protocol implementation into a
> browser extension that can communicate with wallets over a simple IPC
> mechanism [...]

As a reminder, there is a W3C Payments API, currently proceeding along
the W3C Recommendation track, which registers "payment handlers" in
the browser, and selects one to complete a transaction:

  https://w3c.github.io/payment-handler/

The purpose of the payments API is to automate all data entry and
handle choices related to common transactions on the Web.  Payment
requests will often ask for information that Bitcoin wallets have no
current need to provide, such as a shipping address.  If shipping
options or other personally identifying information (such as an email
address and a return payment address) are involved, then it is the
chosen payment type's *handler* that is tasked with negotiating with
the user how to reveal the supposedly necessary information.

  https://www.w3.org/TR/payment-request/#the-options-argument

Although it may seem early for wallet makers to consider integration
with a mere W3C Recommendation, it would not be early to choose the
right architecture to build code on, given that this is in the works
for the major browsers.  Development can proceed even in browsers that
have not implemented anything, through an HTML5 Javascript polyfill.
A demonstration which includes payment in bitcoins is already
available, although it leaves as an exercise for the reader exactly
how the txid would be made known to the handler (whether manually
input by paste buffer after copying from an external app, or returned
through IPC):

  https://web-payments.io/
  https://github.com/digitalbazaar/payment-handler-polyfill

>From my brief inspection: not bad.  I don't see anything in this spec
that would preclude the workflow of a Bitcoin transaction, whether
on-chain (with the seller's backend marking off confirmations) or
using the Lightning Network.  It even allows the seller to offer a
discount on certain payment methods:

  https://www.w3.org/TR/payment-request/#dom-paymentdetailsmodifier

From willtech at live.com.au  Thu Jan  4 09:01:10 2018
From: willtech at live.com.au (Damian Williamson)
Date: Thu, 4 Jan 2018 09:01:10 +0000
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction
 Priority For Ordering Transactions In Blocks
In-Reply-To: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <PS2P216MB0179F13FF364666D92E6B2F89D1F0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

This proposal has a new update, mostly minor edits. Additionally, I had a logic flaw in the hard fork / soft fork declaration statement. The specific terms of the CC-BY-SA-4.0 licence the document is published under have now been updated to include additional permissions available under the MIT licence.


Recently, on Twitter:

I am looking for a capable analyst/programmer to work on a BIP proposal as co-author. Will need to format several Full BIP's per these BIP process requirements: ( https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki ) from a BIP Proposal, being two initially for non-consensus full-interoperable pre-rollout on peer service layer & API/RPC layer and, a reference implementation for Bitcoin Core per: ( https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md ). Interested parties please reply via this list thread: ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015485.html ) #Bitcoin #BIP


Regards,

Damian Williamson


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, 1 January 2018 10:04 PM
To: bitcoin-dev at lists.linuxfoundation.org
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks

Happy New Year all.

This proposal has been further amended with several minor changes and a
few additions.

I believe that all known issues raised so far have been sufficiently
addressed. Either that or, I still have more work to do.

## BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks

Schema:
##########
Document: BIP Proposal
Title: UTPFOTIB - Use Transaction Priority For Ordering Transactions In
Blocks
Published: 26-12-2017
Revised: 01-01-2018
Author: Damian Williamson <willtech at live.com.au>
Licence: Creative Commons Attribution-ShareAlike 4.0 International
License.
URL: http://thekingjameshrmh.tumblr.com/post/168948530950/bip-proposal-
utpfotib-use-transaction-priority-for-order
##########

### 1. Abstract

This document proposes to address the issue of transactional
reliability in Bitcoin, where valid transactions may be stuck in the
transaction pool for extended periods or never confirm.

There are two key issues to be resolved to achieve this:

1.  The current transaction bandwidth limit.
2.  The current ad-hoc methods of including transactions in blocks
resulting in variable and confusing confirmation times for valid
transactions, including transactions with a valid fee that may never
confirm.

It is important with any change to protect the value of fees as these
will eventually be the only payment that miners receive. Rather than an
auction model for limited bandwidth, the proposal results in a fee for
priority service auction model.

It would not be true to suggest that all feedback received so far has
been entirely positive although, most of it has been constructive.

The previous threads for this proposal are available here:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/s
ubject.html

In all parts of this proposal, references to a transaction, a valid
transaction, a transaction with a valid fee, a valid fee, etc. is
defined as any transaction that is otherwise valid with a fee of at
least 0.00001000 BTC/KB as defined as the dust level, interpreting from
Bitcoin Core GUI. Transactions with a fee lower than this rate are
considered dust.

In all parts of this proposal, dust and zero-fee transactions are
always ignored and/or excluded unless specifically mentioned.

It is generally assumed that miners currently prefer to include
transactions with higher fees.

### 2. The need for this proposal

We all must learn to admit that transaction bandwidth is still lurking
as a serious issue for the operation, reliability, safety, consumer
acceptance, uptake and, for the value of Bitcoin.

I recently sent a payment which was not urgent so; I chose three-day
target confirmation from the fee recommendation. That transaction has
still not confirmed after now more than six days - even waiting twice
as long seems quite reasonable to me (note for accuracy: it did
eventually confirm). That transaction is a valid transaction; it is not
rubbish, junk or, spam. Under the current model with transaction
bandwidth limitation, the longer a transaction waits, the less likely
it is ever to confirm due to rising transaction numbers and being
pushed back by transactions with rising fees.

I argue that no transactions with fees above the dust level are rubbish
or junk, only some zero fee transactions might be spam. Having an ever-
increasing number of valid transactions that do not confirm as more new
transactions with higher fees are created is the opposite of operating
a robust, reliable transaction system.

While the miners have discovered a gold mine, it is the service they
provide that is valuable. If the service is unreliable they are not
worth the gold that they mine. This is reflected in the value of
Bitcoin.

Business cannot operate with a model where transactions may or may not
confirm. Even a business choosing a modest fee has no guarantee that
their valid transaction will not be shuffled down by new transactions
to the realm of never confirming after it is created. Consumers also
will not accept this model as Bitcoin expands. If Bitcoin cannot be a
reliable payment system for confirmed transactions then consumers, by
and large, will simply not accept the model once they understand.
Bitcoin will be a dirty payment system, and this will kill the value of
Bitcoin.

Under the current system, a minority of transactions will eventually be
the lucky few who have fees high enough to escape being pushed down the
list.

Once there are more than x transactions (transaction bandwidth limit)
every ten minutes, only those choosing twenty-minute confirmation (2
blocks) from the fee recommendations will have initially at most a
fifty percent chance of ever having their payment confirm by the time
2x transactions is reached. Presently, not even using fee
recommendations can ensure a sufficiently high fee is paid to ensure
transaction confirmation.

I also argue that the current auction model for limited transaction
bandwidth is wrong, is not suitable for a reliable transaction system
and, is wrong for Bitcoin. All transactions with valid fees must
confirm in due time. Currently, Bitcoin is not a safe way to send
payments.

I do not believe that consumers and business are against paying fees,
even high fees. What is required is operational reliability.

This great issue needs to be resolved for the safety and reliability of
Bitcoin. The time to resolve issues in commerce is before they become
great big issues. The time to resolve this issue is now. We must have
the foresight to identify and resolve problems before they trip us
over.  Simply doubling block sizes every so often is reactionary and is
not a reliable permanent solution.

I have written this proposal for a technical solution but, need your
help to write it up to an acceptable standard to be a full BIP.

### 3. The problem

Everybody wants value. Miners want to maximise revenue from fees (and
we presume, to minimise block size). Consumers need transaction
reliability and, (we presume) want low fees.

The current transaction bandwidth limit is a limiting factor for both.
As the operational safety of transactions is limited, so is consumer
confidence as they realise the issue and, accordingly, uptake is
limited. Fees are artificially inflated due to bandwidth limitations
while failing to provide a full confirmation service for all valid
transactions.

Current fee recommendations provide no satisfaction for transaction
reliability and, as Bitcoin scales, this will worsen.

Transactions are included in blocks by miners using whatever basis they
prefer. We expect that this is usually a fee-based priority. However,
even transactions with a valid fee may be left in the transaction pool
for some time. As transaction bandwidth becomes an issue, not even
extreme fees can ensure a transaction is processed in a timely manner
or at all.

Bitcoin must be a fully scalable and reliable service, providing full
transaction confirmation for every valid transaction.

The possibility to send a transaction with a fee lower than one that is
acceptable to allow eventual transaction confirmation should be removed
from the protocol and also from the user interface.

Bitcoin should be capable of reliably and inexpensively processing
casual transactions, and also priority processing of fee paying at
auction for priority transactions in the shortest possible timeframe.

### 4. Solution summary

#### Main solution

Provide each valid transaction in the mempool with an individual
transaction priority each time before choosing transactions to include
in the current block. The priority being a function of the fee (on a
curve), and the time waiting in the transaction pool (also on a curve)
out to n days (n = 60 days ?), and extending past n days. The value for
fee on a curve may need an upper limit. The transaction priority to
serve as the likelihood of a transaction being included in the current
block, and for determining the order in which transactions are tried to
see if they will be included.

Nodes will need to keep track of when a transaction is first seen. It
is satisfactory for each node to do this independently provided the
full mempool and information survives node restart. If there is a more
reliable way to determine when a transaction was first seen on the
network then it should be utilised.

> My current default installation of Bitcoin Core v0.15.1 does not
currently seem to save and load the mempool on restart, despite the
notes in the command line options panel that the default for
persistmempool is 1. In the debug panel, some 90,000 transactions
before restart, some 200 odd shortly after. Manually setting
persistmempool=1 in the conf file does not seem to make any difference.
Perhaps it is operating as expected and I am not sure what to observe,
but does not seem to be observably saving and loading the mempool on
restart. This will need to be resolved.

Use a dynamic target block size to make the current block. This marks a
shift from using block size or weight to a count of transactions.
Determine the target block size using; pre-rollout(current average
valid transaction pool size) x ( 1 / (144 x n days ) ) = number of
transactions to be included in the current block. The block created
should be a minimum 1MB in size regardless if the target block size is
lower.

If the created block size consistently contains too few transactions
and the number of new transactions created is continuously greater than
the block size will accommodate then I expect eventually ageing
transactions will be over-represented as a portion of the block
contents. Once another new node conforming to the proposal makes a
block, the block size will be proportionately larger as the transaction
pool has grown.  If block size is too large on average then this will
shrink the transaction pool.

Miners will likely want to conform to the proposal, since making blocks
larger than necessary makes more room in each block potentially
lowering the highest fees paid for priority service. Always making
blocks smaller than the proposal requires will in time lower the
utility value of Bitcoin, a different situation but akin to the
current. Transactions will still always confirm but with longer and
longer wait periods. The auction at the front of the queue for priority
will be destroyed as there will be eventually no room in blocks besides
ageing transations and, there will be little value paying higher than
the minimum fee. Obviously, neither of these scenarios are in a miner's
interests.

Without a consensus as to what size dynamic block to create,
enforcement of dynamic block size is not currently possible. It may be
possible for a consensus to be formed in the future but here I cannot
speculate. I can only suggest that it is in the interest of Bitcoin as
a whole and, in the interest of each node to conform to the proposal.
Some nodes failing to conform to the proposed requirements of dynamic
size or transaction priority in this proposal will not be destructive
to the operation of the proposal.

If necessary, nodes that have not yet adopted the proposal will just
continue to create standard fixed size unordered blocks, although, if
the current mechanisms of block validation include the fixed block size
then it is unlikely that these nodes will be able to validate the
blockchain going forward. In this case a hard fork and a full transfer
to the new method should be required. If dynamic blocks with ordered
transactions will be valid to existing nodes then only a soft fork is
required. There is no proposed change to the internal construction of
blocks, only to the block size and using an ordered method of
transaction selection.

> The default value for mempoolexpiry in Bitcoin Core may in future
need to be adjusted to match something more than n days or, perhaps
using less than n = 14 days may be a more sensible approach?

All block created with dynamic size should be verified to ensure
conformity to a probability distribution curve resulting from the
priority method. Since the input is a probability, the output should
conform to a probability distribution.

The curves used for the priority of transactions would have to be
appropriate. Perhaps a mathematician with experience in probability can
develop the right formulae. My thinking is a steep curve. I suppose
that the probability of all transactions should probably account for a
sufficient number of inclusions that the target block size is met on
average although, it may not always be. As a suggestion, consider
including some dust or zero-fee transactions to pad if each valid
transaction is tried and the target block size is not yet met, highest
BTC transaction value first?

**Explanation of the operation of priority:**

> If transaction priority is, for example, a number between one (low)
and one-hundred (high) it can be directly understood as the percentage
chance in one-hundred of a transaction being included in the block.
Using probability or likelihood infers that there is some function of
random. Try the transactions in priority order from highest to lowest,
if random (100) < transaction priority then the transaction is included
until the target block size is met.

> To break it down further, if both the fee on a curve value and the
time waiting on a curve value are each a number between one and one-
hundred, a rudimentary method may be to simply multiply those two
numbers, to find the priority number. For example, a middle fee
transaction waiting thirty days (if n = 60 days) may have a value of
five for each part  (yes, just five, the values are on a curve). When
multiplied that will give a priority value of twenty-five, or, a
twenty-five percent chance at that moment of being included in the
block; it will likely be included in one of the next four blocks,
getting more likely each chance. If it is still not included then the
value of time waiting will be higher, making for more probability. A
very low fee transaction would have a value for the fee of one. It
would not be until near sixty-days that the particular low fee
transaction has a high likelihood of being included in the block.

In practice it may be more useful to use numbers representative of one-
hundred for the highest fee priority curve down to a small fraction of
one for the lowest fee and, from one for a newly seen transaction up to
a proportionately high number above one-hundred for the time waiting
curve. It is truely beyond my level of math to resolve probability
curves accurately without much trial and error.

The primary reason for addressing the issue is to ensure transactional
reliability and scalability while having each valid transaction confirm
in due time.

#### Pros

*   Maximizes transaction reliability.
*   Overcomes transaction bandwidth limit.
*   Fully scalable.
*   Maximizes possibility for consumer and business uptake.
*   Maximizes total fees paid per block without reducing reliability;
because of reliability, in time confidence and overall uptake are
greater; therefore, more transactions.
*   Market determines fee paid for transaction priority.
*   Fee recommendations work all the way out to 30 days or greater.
*   Provides additional block entropy; greater security since there is
less probability of predicting the next block. _Although this is not
necessary it is a product of the operation of this proposal._

#### Cons

*   Could initially lower total transaction fees per block.
*   Must be first be programmed.

#### Pre-rollout

Nodes need to have at a minimum a loose understanding of the average
(since there is no consensus) size of the transaction pool as a
requirement to enable future changes to the way blocks are constructed.

A new network service should be constructed to meet this need. This
service makes no changes to any existing operation or function of the
node. Initially, Bitcoin Core is a suitable candidate.

For all operations we count only valid transactions.

**The service must:**

*   Have an individual temporary (runtime permanent only) Serial Node
ID.
*   Accept communication of the number of valid transactions in the
mempool of another valid Bitcoin node along with the Serial Node ID of
the node whose value is provided.
*   Disconnect the service from any non-Bitcoin node. Bitcoin Core may
handle this already?
*   Expire any value not updated for k minutes (k = 30 minutes?).
*   Broadcast all mempool information the node has every m minutes (m =
10 minutes?), including its own.
*   Nodes own mempool information should not be broadcast or used in
calculation until the node has been up long enough for the mempool to
normalise for at least o minutes (o = 300 minutes ?)
*   Alternatively, if loading nodes own full mempool from disk on node
restart (o = 30 minutes ?)
*   Only new or updated mempool values should be transmitted to the
same node. Updated includes updated with no change.
*   All known mempool information must survive node restart.
*   If the nodes own mempool is not normalised and network information
is not available to calculate an average just display zero.
*   Internally, the average transaction pool size must return the
calculated average if an average is available or, if none is available
just the number of valid transactions in the node's own mempool
regardless if it is normalised.

Bitcoin Core must use all collated information on mempool size to
calculate a figure for the average mempool size.

The calculated figure should be displayed in the appropriate place in
the Debug window alongside the text Network average transactions.

Consideration must be given before development of the network bandwidth
this would require. All programming must be consistent with the current
operation and conventions of Bitcoin Core. Methods must work on all
platforms.

As this new service does not affect any existing service or feature of
Bitcoin or Bitcoin Core, this can technically be programmed now and
included in Bitcoin Core at any time.

### 5. Solution operation

This is a simplistic view of the operation. The actual operation will
need to be determined accurately in a spec for the programmer.

1.  Determine the target block size for the current block.
2.  Assign a transaction priority to each valid transaction in the
mempool.
3.  Select transactions to include in the current block using
probability in transaction priority order until the target block size
is met. If target block size is not met, include dust and zero-fee
transactions to pad.
4.  Solve block.
5.  Broadcast the current block when it is solved.
6.  Block is received.
7.  Block verification process.
8.  Accept/reject block based on verification result.
9.  Repeat.

### 6. Closing comments

It may be possible to verify blocks conform to the proposal by showing
that the probability for all transactions included in the block
statistically conforms to a probability distribution curve, *if* the
individual transaction priority can be recreated. I am not that deep
into the mathematics; however, it may also be possible to use a similar
method to do this just based on the fee, that statistically, the block
conforms to a fee distribution. Any dust and zero-fee transactions
would have to be ignored. This solution needs a competent mathematician
with experience in probability and statistical distribution.

It is trivial to this proposal to offer that a node provides the next
block size with a block when it is solved. I am not sure that this
creates any actual benefit since the provided next block size is only
one node's view, as it is the node may seemingly just as well use its
own view and create the block. Providing a next block size only adds
additional complexity to the required operation, however, perhaps
providing the next block size is not trivial in what is accomplished
and the feature can be included in the operation.

Instead of the pre-rollout network service providing data as to valid
transactions in mempool, it could directly provide data as to the
suggested next block size if that is preferred, using a similar
operation as is suggested now and averaging all received suggested next
block sizes.

It may be foreseeable in the future for Bitcoin to operate with a
network of dedicated full blockchain & mempool servers. This would not
be without challenges to overcome but would offer several benefits,
including to the operation of this proposal, and especially as the RAM
and storage requirements of a full node grows. It is easy to foresee
that in just another seven years of operation a Bitcoin Full Node will
require at least 300GB of storage and, if the mempool only doubles in
size, over 1GB of RAM.

There has been some concern expressed over spam and very low fee
transactions, and an infinite block size resulting. I hope that for
those concerned using the dust level addresses the issue, especially as
the value of Bitcoin grows.

Notwithstanding this proposal, all blocks including those with dynamic
size each have limited transaction space per block. This proposal
results in a fee for priority service auction, where the probability of
a transaction to be included in limited space in the next available
block is auctioned to the highest bidders and all other transactions
must wait until they reach priority by ageing to gain significant
probability. Under this proposal the mempool can grow quite large while
the confirmation service continues in a stable and reliable manner.
Several incentives for attackers are removed, where there is no longer
multiple potential incentives for unnecessarily filling blocks or
flooding the mempool with transactions, whether such transactions are
fraudulent, valid or, otherwise. Adoption of this proposal and
adherence results in a reliable, stable fee paying transaction
confirmation service and a beneficial auction.

This proposal is necessary. I implore, at the very least, that we use
some method that validates full transaction reliability and enables
scalability of Bitcoin. If not this proposal, an alternative.

I have done as much with this proposal as I feel that I am able so far
but continue to take your feedback.

Regards,
Damian Williamson

[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/
88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)
<span xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text" property="dct:title"
rel="dct:type">BIP Proposal: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks</span> by [Damian Williamson
&lt;willtech at live.com.au&gt;](http://thekingjameshrmh.tumblr.com/post/1
68948530950/bip-proposal-utpfotib-use-transaction-priority-for-order)
is licensed under a [Creative Commons Attribution-ShareAlike 4.0
International License](http://creativecommons.org/licenses/by-sa/4.0/).
Based on a work at https://lists.linuxfoundation.org/pipermail/bitcoin-
dev/2017-
December/015371.html](https://lists.linuxfoundation.org/pipermail/bitco
in-dev/2017-December/015371.html).
Permissions beyond the scope of this license may be available at [https
://opensource.org/licenses/BSD-3-
Clause](https://opensource.org/licenses/BSD-3-Clause).


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180104/fd3232c0/attachment-0001.html>

From mirelo at deugh-ausgam-valis.com  Thu Jan  4 10:54:31 2018
From: mirelo at deugh-ausgam-valis.com (Mirelo)
Date: Thu, 04 Jan 2018 05:54:31 -0500
Subject: [bitcoin-dev] Proof-of-Loss
Message-ID: <d2M8re5KLKa7Q6XjnSyQycNfg6_CRu80RnzfMyw9omswk5A_wYa0ijnoamSsG1PMIjuHc6c7RQhW1aOK9zqxGO3zqmzf5kuTkANt4ImS9hY=@deugh-ausgam-valis.com>

Hi,

The paper now includes the pseudocode for block validation:

https://proof-of-loss.money/

Again, please direct any feedback to my email.

Regards,

Mirelo
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180104/823d03d1/attachment.html>

From mbde at bitwatch.co  Thu Jan  4 09:37:42 2018
From: mbde at bitwatch.co (mbde at bitwatch.co)
Date: Thu, 4 Jan 2018 10:37:42 +0100
Subject: [bitcoin-dev] Raise default datacarriersize to 220 byte or higher
Message-ID: <567cdb19-f5b3-6058-9b5b-8a891558d9d5@bitwatch.co>

Hi guys,

there are several ways to embed arbitrary data into the blockchain, and
this is used by several meta-protocols. Most protocols at this point use
OP_RETURN scripts for this.

To disincentivize the use of other and more harmful methods to embed
data into the chain, in particular via P2SH, I propose to raise the
default datacarriersize to 220 byte, so it becomes the "cheapest" way of
embedding data into the chain.

The following graph shows the relation between transaction sizes and
payload sizes: http://i.imgur.com/VAGZWBK.png

Embedding data with bare-multisig and P2SH can be cheaper in terms of
effective transaction size, compared to OP_RETURN with a payload limit
of 80 byte. Both methods of embedding data, via bare-multisig and P2SH,
were heavily used by the major two meta-protocols on top of Bitcoin:
Omni and Counterparty, but both protocols started to use OP_RETRUN data
embedding a long time ago.

However, currently token sends are usually done one by one, each with a
single transaction, and this is a heavy burden for the whole network,
e.g. when an exchange sends out withdrawals.

We have solutions for "multi-sends with multi-inputs" and also
considered moving destinations into the payload for token sends, but we
need more space, otherwise this solution is limited to very few recipients.

I therefore propose to raise the default datacarriersize to 220 byte or
higher and I'd be happy to provide a pull request doing so, if this gets
positive feedback.

- dexx

From felix.wolfsteller at gmail.com  Thu Jan  4 10:08:08 2018
From: felix.wolfsteller at gmail.com (Felix Wolfsteller)
Date: Thu, 4 Jan 2018 11:08:08 +0100
Subject: [bitcoin-dev] Update links (use ssl-variant) to
	opensource.org/[..x..]MIT ?
Message-ID: <CALHCSvOn8YxFqGu4yXDPnFunNzmy=cmdwKBNmAL45Ymta3REig@mail.gmail.com>

Hey there
Most source files contain the "default" copyright-header (also build by a
script in devtools/copyright_header.py), which points out that the MIT
license can be found in the COPYING file or at
http://www.opensource.org/licenses/mit-license.php.

However, the provided link is 1) using http where it could use https, 2)
resulting in a redirect (https://opensource.org/licenses/mit-license.php)
anyway.
I am strongly in favor of using https where possible (I guess there are
many other non-ssl links in the code base, but lets tackle the easier ones
first).

I propose that I
1) create a issue on github,
2) `sed -i` the relevant links,
3) create a PR on github,
4) come back to the mailing list.

This change would affect a few hundred files I guess.

A question remaining is this change would require a
copyright-year-extension (to 2018), too.

An example header can be seen e.g. here
https://github.com/bitcoin/bitcoin/blob/a9a49e6e7e8df13d80a6dc3245ce7ef041942e9b/src/consensus/merkle.cpp#L3

I'd be happy about quick feedback - do not know the culture here, yet.

Have fun
Felix
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180104/e83674fd/attachment.html>

From luke at dashjr.org  Thu Jan  4 14:23:05 2018
From: luke at dashjr.org (Luke Dashjr)
Date: Thu, 4 Jan 2018 14:23:05 +0000
Subject: [bitcoin-dev] =?iso-8859-1?q?Bech32_and_P2SH=B2?=
Message-ID: <201801041423.05959.luke@dashjr.org>

I know I'm super-late to bring this up, but was there a reason Bech32 omitted 
the previously-discussed P2SH? improvements? Since deployment isn't too 
widespread yet, maybe it'd be worth a quick revision to add this?

For those unfamiliar with the concept, the idea is to have the address include 
the *single* SHA256 hash of the public key or script, rather than 
RIPEMD160(SHA256(pubkey)) or SHA256(SHA256(script)). The sender would then 
perform the second hash to produce the output. Doing this would in the future 
enable relaying the "middle-hash" as a way to prove the final hash is in fact 
a hash itself, thereby proving it is not embedded data spam.

Bech32 seems like a huge missed opportunity to add this, since everyone will 
probably be upgrading to it at some point.

Luke

From mbde at bitwatch.co  Thu Jan  4 19:38:23 2018
From: mbde at bitwatch.co (mbde at bitwatch.co)
Date: Thu, 4 Jan 2018 20:38:23 +0100
Subject: [bitcoin-dev] Raise default datacarriersize to 220 byte or
	higher
In-Reply-To: <567cdb19-f5b3-6058-9b5b-8a891558d9d5@bitwatch.co>
References: <567cdb19-f5b3-6058-9b5b-8a891558d9d5@bitwatch.co>
Message-ID: <10fe1a88-af34-4c4e-a0f2-8d618ca04f5a@bitwatch.co>

To add some information about the relevance of this:

During December 2017 there were roughly 210.000 Omni Layer transactions,
with more than 12.000 transactions on peak days, and the numbers are
growing.

I assume there is a similar number of Counterparty transactions, which
most likely benefit from additional payload space, too.

mbde--- via bitcoin-dev wrote:
> Hi guys,
> 
> there are several ways to embed arbitrary data into the blockchain, and
> this is used by several meta-protocols. Most protocols at this point use
> OP_RETURN scripts for this.
> 
> To disincentivize the use of other and more harmful methods to embed
> data into the chain, in particular via P2SH, I propose to raise the
> default datacarriersize to 220 byte, so it becomes the "cheapest" way of
> embedding data into the chain.
> 
> The following graph shows the relation between transaction sizes and
> payload sizes: http://i.imgur.com/VAGZWBK.png
> 
> Embedding data with bare-multisig and P2SH can be cheaper in terms of
> effective transaction size, compared to OP_RETURN with a payload limit
> of 80 byte. Both methods of embedding data, via bare-multisig and P2SH,
> were heavily used by the major two meta-protocols on top of Bitcoin:
> Omni and Counterparty, but both protocols started to use OP_RETRUN data
> embedding a long time ago.
> 
> However, currently token sends are usually done one by one, each with a
> single transaction, and this is a heavy burden for the whole network,
> e.g. when an exchange sends out withdrawals.
> 
> We have solutions for "multi-sends with multi-inputs" and also
> considered moving destinations into the payload for token sends, but we
> need more space, otherwise this solution is limited to very few recipients.
> 
> I therefore propose to raise the default datacarriersize to 220 byte or
> higher and I'd be happy to provide a pull request doing so, if this gets
> positive feedback.
> 
> - dexx
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From nullius at nym.zone  Fri Jan  5 13:58:37 2018
From: nullius at nym.zone (nullius)
Date: Fri, 5 Jan 2018 13:58:37 +0000
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for wordlists
Message-ID: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>

I propose and request as an enhancement that the BIP 39 wordlist set 
should specify canonical native language strings to identify each 
wordlist, as well as short ASCII language codes.  At present, the 
languages are identified only by their names in English.

Strings properly vetted and recommended by native speakers should 
facilitate language identification in user interface options or menus.  
Specification of language identifier strings would also promote 
interface consistency between implementations; this may be important if 
a user creates a mnemonic in Implementation A, then restores a wallet 
using that mnemonic in Implementation B.

As an independent implementer who does not know *all* these different 
languages, I monkey-pasted language-native strings from a popular wiki 
site.  I cannot guarantee that they be all accurate, sensible, or even 
non-embarrassing.

https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
```
	LANG(english,			u8"English",	"en",	ascii_space ),
	LANG(chinese_simplified,	u8"??",	"zh-CN",ascii_space ),
	LANG(chinese_traditional,	u8"??",	"zh-TW",ascii_space ),
	LANG(french,			u8"Fran?ais",	"fr",	ascii_space ),
	LANG(italian,			u8"Italiano",	"it",	ascii_space ),
	LANG(japanese,			u8"???",	"ja",	u8"\u3000"  ),
	LANG(korean,			u8"???",	"ko",	ascii_space ),
	LANG(spanish,			u8"Espa?ol",	"es",	ascii_space )
```

Per the comment at #L85 of the quoted file, I also know that for my 
short identifiers for Chinese, ?zh-CN? and ?zh-TW?, are imprecise at 
best?insofar as Hong Kong uses Traditional; and overseas Chinese may use 
either.  For differentiating the two Chinese writing variants, are there 
any appropriate standardized or customary short ASCII language IDs 
similar to ISO 3166-1 alpha-2 which are purely linguistic, and not fit 
to present-day political boundaries?

My general suggestion is that the specification of appropriate strings 
in bitcoin:bips/bip-0039/bip-0039-wordlists.md be made part of the 
process for accepting new wordlists.  My specific request is that such 
strings be ascertained for the wordlists already existing, preferably 
from the persons involved in the original pull requests therefor.

Should this proposal be ?concept ACKed? by appropriate parties, then I 
may open a pull request suggesting an appropriate format for specifying 
this information in the repository.  However, I will must needs leave 
the vetting of appropriate strings to native speakers or experts in the 
respective languages.

Prior references:  The wordlist additions at PRs #92, #130 (Japanese); 
#100 (Spanish); #114 (Chinese, both variants); #152 (French); #306 
(Italian); #570 (Korean); #621 (Indonesian, *proposed*, open).
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180105/c0a9128b/attachment.sig>

From sjors at sprovoost.nl  Fri Jan  5 16:04:10 2018
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Fri, 5 Jan 2018 17:04:10 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
Message-ID: <BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>

I?m not a fan of language specific word lists within the current BIP-39 standard. Very few wallets support anything other than English, which can lead to vendor lock-in and long term loss of funds if a rare non-English wallet disappears.

However, because people can memorize things better in their native tongue, supporting multiple languages seems quite useful.

I would prefer a new standard where words are mapped to integers rather than to a literal string. For each language a mapping from words to integers would be published. In addition to that, there would be a mapping from original language words to matching (in terms of integer value, not meaning) English words that people can print on an A4 paper. This would allow them to enter a mnemonic into e.g. a hardware wallet that only support English. Such lists are more likely to be around 100 years from now than some ancient piece of software.

This would not work with the current BIP-39 (duress) password, but this feature could be replaced by appending words (with or without a checksum for that addition).

A replacement for BIP-39 would be a good opportunity to produce a better English dictionary as Nic Johnson suggested a while ago:
	? all words are 4-8 characters
	? all 4-character prefixes are unique (very useful for hardware wallets)
	? no two words have edit distance < 2

Wallets need to be able to distinguish between the old and new standard, so un-upgraded BIP 39 wallets should consider all new mnemonics invalid. At the same time, some new wallets may not wish to support BIP39. They shouldn't be burdened with storing the old word list.

A solution is to sort the new word list such that reused words appear first. When generating a mnemonic, at least one word unique to the new list must be present. A wallet only needs to know the index of the last BIP39 overlapping word. They reject a proposed mnemonic if none of the elements use a word with a higher index.

For my above point and some related ideas, see: https://github.com/satoshilabs/slips/issues/103

Sjors

> Op 5 jan. 2018, om 14:58 heeft nullius via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> I propose and request as an enhancement that the BIP 39 wordlist set should specify canonical native language strings to identify each wordlist, as well as short ASCII language codes.  At present, the languages are identified only by their names in English.
> 
> Strings properly vetted and recommended by native speakers should facilitate language identification in user interface options or menus.  Specification of language identifier strings would also promote interface consistency between implementations; this may be important if a user creates a mnemonic in Implementation A, then restores a wallet using that mnemonic in Implementation B.
> 
> As an independent implementer who does not know *all* these different languages, I monkey-pasted language-native strings from a popular wiki site.  I cannot guarantee that they be all accurate, sensible, or even non-embarrassing.
> 
> https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
> ```
> 	LANG(english,			u8"English",	"en",	ascii_space ),
> 	LANG(chinese_simplified,	u8"??",	"zh-CN",ascii_space ),
> 	LANG(chinese_traditional,	u8"??",	"zh-TW",ascii_space ),
> 	LANG(french,			u8"Fran?ais",	"fr",	ascii_space ),
> 	LANG(italian,			u8"Italiano",	"it",	ascii_space ),
> 	LANG(japanese,			u8"???",	"ja",	u8"\u3000"  ),
> 	LANG(korean,			u8"???",	"ko",	ascii_space ),
> 	LANG(spanish,			u8"Espa?ol",	"es",	ascii_space )
> ```
> 
> Per the comment at #L85 of the quoted file, I also know that for my short identifiers for Chinese, ?zh-CN? and ?zh-TW?, are imprecise at best?insofar as Hong Kong uses Traditional; and overseas Chinese may use either.  For differentiating the two Chinese writing variants, are there any appropriate standardized or customary short ASCII language IDs similar to ISO 3166-1 alpha-2 which are purely linguistic, and not fit to present-day political boundaries?
> 
> My general suggestion is that the specification of appropriate strings in bitcoin:bips/bip-0039/bip-0039-wordlists.md be made part of the process for accepting new wordlists.  My specific request is that such strings be ascertained for the wordlists already existing, preferably from the persons involved in the original pull requests therefor.
> 
> Should this proposal be ?concept ACKed? by appropriate parties, then I may open a pull request suggesting an appropriate format for specifying this information in the repository.  However, I will must needs leave the vetting of appropriate strings to native speakers or experts in the respective languages.
> 
> Prior references:  The wordlist additions at PRs #92, #130 (Japanese); #100 (Spanish); #114 (Chinese, both variants); #152 (French); #306 (Italian); #570 (Korean); #621 (Indonesian, *proposed*, open).
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180105/988669cf/attachment.sig>

From sjors at sprovoost.nl  Fri Jan  5 17:13:23 2018
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Fri, 5 Jan 2018 18:13:23 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <CALPhJax=53dLL9+JDKJC7NdEFFRB2kgKiECSh8PUMzrr2KxWuQ@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
	<CALPhJax=53dLL9+JDKJC7NdEFFRB2kgKiECSh8PUMzrr2KxWuQ@mail.gmail.com>
Message-ID: <2A39F6D7-CDF9-4624-BE0A-22C809C8B68C@sprovoost.nl>

I don?t know about Electrum but many wallets validate the English words, which helps in catching typos.

Hardware wallets without a full keyboard, like the Ledger Nano S, won?t even let you freely type characters; you have to select words from a list.

So although the standard technically allows what you say, if you use anything other than 12, 16 or 24 English words, you?ll have fewer wallets to choose from.

I think it?s better to come up with a new standard than trying to patch BIP-39 at this point, which is why I brought it up.

Sjors

> Op 5 jan. 2018, om 17:27 heeft Alan Evans <thealanevans at gmail.com> het volgende geschreven:
> 
> "Very few wallets support anything other than English"
> 
> By support do you mean allow recovery, validation or generation or all three? For if you can freely type a phrase in (such as Electrum), or even word by word, then the likely-hood is it is supported if they remembered to normalize.
> 
> Seed generation in BIP0039 requires no dictionary what-so-ever! So there is no word list to lose in the first place. Your funds are accessible with just the characters and the algorithm as described in BIP0039.
> 
> But your proposal is a million miles away from simply adding some standard in-language names to some word lists feels like it's derailing the OP's simple proposal. Maybe start own email chain about it.
> 
> Alan
> 
> On Fri, Jan 5, 2018 at 12:04 PM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> I?m not a fan of language specific word lists within the current BIP-39 standard. Very few wallets support anything other than English, which can lead to vendor lock-in and long term loss of funds if a rare non-English wallet disappears.
> 
> However, because people can memorize things better in their native tongue, supporting multiple languages seems quite useful.
> 
> I would prefer a new standard where words are mapped to integers rather than to a literal string. For each language a mapping from words to integers would be published. In addition to that, there would be a mapping from original language words to matching (in terms of integer value, not meaning) English words that people can print on an A4 paper. This would allow them to enter a mnemonic into e.g. a hardware wallet that only support English. Such lists are more likely to be around 100 years from now than some ancient piece of software.
> 
> This would not work with the current BIP-39 (duress) password, but this feature could be replaced by appending words (with or without a checksum for that addition).
> 
> A replacement for BIP-39 would be a good opportunity to produce a better English dictionary as Nic Johnson suggested a while ago:
>         ? all words are 4-8 characters
>         ? all 4-character prefixes are unique (very useful for hardware wallets)
>         ? no two words have edit distance < 2
> 
> Wallets need to be able to distinguish between the old and new standard, so un-upgraded BIP 39 wallets should consider all new mnemonics invalid. At the same time, some new wallets may not wish to support BIP39. They shouldn't be burdened with storing the old word list.
> 
> A solution is to sort the new word list such that reused words appear first. When generating a mnemonic, at least one word unique to the new list must be present. A wallet only needs to know the index of the last BIP39 overlapping word. They reject a proposed mnemonic if none of the elements use a word with a higher index.
> 
> For my above point and some related ideas, see: https://github.com/satoshilabs/slips/issues/103
> 
> Sjors
> 
> > Op 5 jan. 2018, om 14:58 heeft nullius via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> >
> > I propose and request as an enhancement that the BIP 39 wordlist set should specify canonical native language strings to identify each wordlist, as well as short ASCII language codes.  At present, the languages are identified only by their names in English.
> >
> > Strings properly vetted and recommended by native speakers should facilitate language identification in user interface options or menus.  Specification of language identifier strings would also promote interface consistency between implementations; this may be important if a user creates a mnemonic in Implementation A, then restores a wallet using that mnemonic in Implementation B.
> >
> > As an independent implementer who does not know *all* these different languages, I monkey-pasted language-native strings from a popular wiki site.  I cannot guarantee that they be all accurate, sensible, or even non-embarrassing.
> >
> > https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
> > ```
> >       LANG(english,                   u8"English",    "en",   ascii_space ),
> >       LANG(chinese_simplified,        u8"??", "zh-CN",ascii_space ),
> >       LANG(chinese_traditional,       u8"??", "zh-TW",ascii_space ),
> >       LANG(french,                    u8"Fran?ais",   "fr",   ascii_space ),
> >       LANG(italian,                   u8"Italiano",   "it",   ascii_space ),
> >       LANG(japanese,                  u8"???",        "ja",   u8"\u3000"  ),
> >       LANG(korean,                    u8"???",        "ko",   ascii_space ),
> >       LANG(spanish,                   u8"Espa?ol",    "es",   ascii_space )
> > ```
> >
> > Per the comment at #L85 of the quoted file, I also know that for my short identifiers for Chinese, ?zh-CN? and ?zh-TW?, are imprecise at best?insofar as Hong Kong uses Traditional; and overseas Chinese may use either.  For differentiating the two Chinese writing variants, are there any appropriate standardized or customary short ASCII language IDs similar to ISO 3166-1 alpha-2 which are purely linguistic, and not fit to present-day political boundaries?
> >
> > My general suggestion is that the specification of appropriate strings in bitcoin:bips/bip-0039/bip-0039-wordlists.md be made part of the process for accepting new wordlists.  My specific request is that such strings be ascertained for the wordlists already existing, preferably from the persons involved in the original pull requests therefor.
> >
> > Should this proposal be ?concept ACKed? by appropriate parties, then I may open a pull request suggesting an appropriate format for specifying this information in the repository.  However, I will must needs leave the vetting of appropriate strings to native speakers or experts in the respective languages.
> >
> > Prior references:  The wordlist additions at PRs #92, #130 (Japanese); #100 (Spanish); #114 (Chinese, both variants); #152 (French); #306 (Italian); #570 (Korean); #621 (Indonesian, *proposed*, open).
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 
> 
> <signature.asc>

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180105/b4e144f7/attachment.sig>

From vitteaymeric at gmail.com  Fri Jan  5 18:08:29 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 5 Jan 2018 19:08:29 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <2A39F6D7-CDF9-4624-BE0A-22C809C8B68C@sprovoost.nl>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
	<CALPhJax=53dLL9+JDKJC7NdEFFRB2kgKiECSh8PUMzrr2KxWuQ@mail.gmail.com>
	<2A39F6D7-CDF9-4624-BE0A-22C809C8B68C@sprovoost.nl>
Message-ID: <af76eb48-8ef9-59b5-f7cd-dd3e45277deb@gmail.com>

See: https://github.com/Ayms/bitcoin-transactions/issues/3

OK, maybe it's my fault, I did not foresee this case, and now it's
working for p2sh (non segwit)

From my standpoint this just means that BIP39/44 stuff should be
eradicated (not BIP141 but see what happened...), this is of no use,
confusing people, doing dangerous things to recover

Really is it easier to save x words instead of a seed? Knowing that
people are creating several wallets not understanding that this is not
the purpose of BIP32?

Multisig wallets (like Electrum) have created a big mess too, on purpose
or no, I don't know, but multisig is for different parties involved, not
just one


Le 05/01/2018 ? 18:13, Sjors Provoost via bitcoin-dev a ?crit?:
> I don?t know about Electrum but many wallets validate the English words, which helps in catching typos.
>
> Hardware wallets without a full keyboard, like the Ledger Nano S, won?t even let you freely type characters; you have to select words from a list.
>
> So although the standard technically allows what you say, if you use anything other than 12, 16 or 24 English words, you?ll have fewer wallets to choose from.
>
> I think it?s better to come up with a new standard than trying to patch BIP-39 at this point, which is why I brought it up.
>
> Sjors
>
>> Op 5 jan. 2018, om 17:27 heeft Alan Evans <thealanevans at gmail.com> het volgende geschreven:
>>
>> "Very few wallets support anything other than English"
>>
>> By support do you mean allow recovery, validation or generation or all three? For if you can freely type a phrase in (such as Electrum), or even word by word, then the likely-hood is it is supported if they remembered to normalize.
>>
>> Seed generation in BIP0039 requires no dictionary what-so-ever! So there is no word list to lose in the first place. Your funds are accessible with just the characters and the algorithm as described in BIP0039.
>>
>> But your proposal is a million miles away from simply adding some standard in-language names to some word lists feels like it's derailing the OP's simple proposal. Maybe start own email chain about it.
>>
>> Alan
>>
>> On Fri, Jan 5, 2018 at 12:04 PM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> I?m not a fan of language specific word lists within the current BIP-39 standard. Very few wallets support anything other than English, which can lead to vendor lock-in and long term loss of funds if a rare non-English wallet disappears.
>>
>> However, because people can memorize things better in their native tongue, supporting multiple languages seems quite useful.
>>
>> I would prefer a new standard where words are mapped to integers rather than to a literal string. For each language a mapping from words to integers would be published. In addition to that, there would be a mapping from original language words to matching (in terms of integer value, not meaning) English words that people can print on an A4 paper. This would allow them to enter a mnemonic into e.g. a hardware wallet that only support English. Such lists are more likely to be around 100 years from now than some ancient piece of software.
>>
>> This would not work with the current BIP-39 (duress) password, but this feature could be replaced by appending words (with or without a checksum for that addition).
>>
>> A replacement for BIP-39 would be a good opportunity to produce a better English dictionary as Nic Johnson suggested a while ago:
>>         ? all words are 4-8 characters
>>         ? all 4-character prefixes are unique (very useful for hardware wallets)
>>         ? no two words have edit distance < 2
>>
>> Wallets need to be able to distinguish between the old and new standard, so un-upgraded BIP 39 wallets should consider all new mnemonics invalid. At the same time, some new wallets may not wish to support BIP39. They shouldn't be burdened with storing the old word list.
>>
>> A solution is to sort the new word list such that reused words appear first. When generating a mnemonic, at least one word unique to the new list must be present. A wallet only needs to know the index of the last BIP39 overlapping word. They reject a proposed mnemonic if none of the elements use a word with a higher index.
>>
>> For my above point and some related ideas, see: https://github.com/satoshilabs/slips/issues/103
>>
>> Sjors
>>
>>> Op 5 jan. 2018, om 14:58 heeft nullius via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
>>>
>>> I propose and request as an enhancement that the BIP 39 wordlist set should specify canonical native language strings to identify each wordlist, as well as short ASCII language codes.  At present, the languages are identified only by their names in English.
>>>
>>> Strings properly vetted and recommended by native speakers should facilitate language identification in user interface options or menus.  Specification of language identifier strings would also promote interface consistency between implementations; this may be important if a user creates a mnemonic in Implementation A, then restores a wallet using that mnemonic in Implementation B.
>>>
>>> As an independent implementer who does not know *all* these different languages, I monkey-pasted language-native strings from a popular wiki site.  I cannot guarantee that they be all accurate, sensible, or even non-embarrassing.
>>>
>>> https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
>>> ```
>>>       LANG(english,                   u8"English",    "en",   ascii_space ),
>>>       LANG(chinese_simplified,        u8"??", "zh-CN",ascii_space ),
>>>       LANG(chinese_traditional,       u8"??", "zh-TW",ascii_space ),
>>>       LANG(french,                    u8"Fran?ais",   "fr",   ascii_space ),
>>>       LANG(italian,                   u8"Italiano",   "it",   ascii_space ),
>>>       LANG(japanese,                  u8"???",        "ja",   u8"\u3000"  ),
>>>       LANG(korean,                    u8"???",        "ko",   ascii_space ),
>>>       LANG(spanish,                   u8"Espa?ol",    "es",   ascii_space )
>>> ```
>>>
>>> Per the comment at #L85 of the quoted file, I also know that for my short identifiers for Chinese, ?zh-CN? and ?zh-TW?, are imprecise at best?insofar as Hong Kong uses Traditional; and overseas Chinese may use either.  For differentiating the two Chinese writing variants, are there any appropriate standardized or customary short ASCII language IDs similar to ISO 3166-1 alpha-2 which are purely linguistic, and not fit to present-day political boundaries?
>>>
>>> My general suggestion is that the specification of appropriate strings in bitcoin:bips/bip-0039/bip-0039-wordlists.md be made part of the process for accepting new wordlists.  My specific request is that such strings be ascertained for the wordlists already existing, preferably from the persons involved in the original pull requests therefor.
>>>
>>> Should this proposal be ?concept ACKed? by appropriate parties, then I may open a pull request suggesting an appropriate format for specifying this information in the repository.  However, I will must needs leave the vetting of appropriate strings to native speakers or experts in the respective languages.
>>>
>>> Prior references:  The wordlist additions at PRs #92, #130 (Japanese); #100 (Spanish); #114 (Chinese, both variants); #152 (French); #306 (Italian); #570 (Korean); #621 (Indonesian, *proposed*, open).
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>> <signature.asc>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180105/82eb1beb/attachment-0001.html>

From nullius at nym.zone  Fri Jan  5 18:08:50 2018
From: nullius at nym.zone (nullius)
Date: Fri, 5 Jan 2018 18:08:50 +0000
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
Message-ID: <55374d9210feebf2f758d4e7b21849ee@nym.zone>

On 2018-01-05 at 16:04:10 +0000, Sjors Provoost <sjors at sprovoost.nl> 
wrote:
>I?m not a fan of language specific word lists within the current BIP-39 
>standard. Very few wallets support anything other than English, which 
>can lead to vendor lock-in and long term loss of funds if a rare 
>non-English wallet disappears.
>
>However, because people can memorize things better in their native 
>tongue, supporting multiple languages seems quite useful.
>
>I would prefer a new standard [...] A replacement for BIP-39 [...]
>
>[snip]
>For my above point and some related ideas, see: 
>https://github.com/satoshilabs/slips/issues/103

You present some interesting ideas; and I will be much interested in the 
Github issue you referenced?thanks for that.  However, this discussion 
is *far* beyond the scope of my simple proposal and request to add 
standardized native language and short-ASCII identifier strings to the 
BIP repository.  I suggest that readers solely interested in the 
existing BIP 39 standard and its direct application to Bitcoin should 
stop reading right here.

----

That being said, I should briefly address some of the issues you raise 
(with further discussion best continued elsewhere):

I *strongly* urge the importance of language-specific standardized 
wordlists.  Even an individual who has secondarily acquired reasonable 
fluency in English will most likely have the least difficulty 
memorizing, transcribing, and otherwise handling a ?mother-tongue? 
mnemonic.  Such an advantage is important in applications whereby even 
slight errors can be fatal, and every bit counts.  This is to say 
nothing of persons who have limited or no English-language knowledge.

Yet for multiple reasons, multilanguage support is only feasible with 
standardization.  Wordlist creation is a highly specialized task.  
Independent implementation of standards is imperative for avoiding 
implementation lock-in; and independent implementors (such as I) would 
be unable to create sets multi-language wordlists on their own, anyway.  
For a view of the language-specific process involved in creating a 
wordlist, I invite everybody following this discussion to review BIP 
repository PRs #92, #130 (Japanese); #100 (Spanish); #114 (Chinese, both 
variants); #152 (French); #306 (Italian); #544 (Korean, rejected); and 
#570 (Korean).  The rejection of #544 for Korean, and its superseding 
with #570 is particularly instructive.

With standardized wordlists, independent implementation is easy.  In my 
own implementation, the language switching backend (excluding the UI[1]) 
for multilingual mnemonic generation required only relatively small C 
code changes, as seen here[0]:

[0] https://github.com/nym-zone/easyseed/commit/5b6a6668458d96d6ccc4bf19e4fd40fe6ea72fec#diff-20dcf1782b7568b85ea01ed695abeb02

[1] https://github.com/nym-zone/easyseed/commit/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6#diff-20dcf1782b7568b85ea01ed695abeb02

Admittedly, the multilingual requirements for seed generation will take 
a bit more; and my nonstandard, non-BIP39 ideas which require decoding 
words directly back to bits will take yet more.  But it is still not 
problematic.

I only began writing this tool one week ago, as of today; and it has 
been a side project requiring small amounts of time, not a full-time 
dedicated task.  When I fully complete all aspects of seed generation, 
then users will have the option of another simple open-source tool which 
*will* be able to output a binary or BIP-32-formatted (?xprv?) 512-bit 
seed, given input of an existing mnemonic in any language supported by 
official BIP 39 wordlists.  Output can then be imported to any wallet 
software which supports BIP 32, regardless of the wallet?s langauge 
support (and whether or not the wallet supports BIP 39 at all).

**The ease of creating such tools squarely answers your concerns about 
vendor lock-in.**  And yes, it?s easy.  I can attest as a lone coder, 
it?s easy for me to create ?easyseed? as a side project!

Finally, aside:  In the discussion at SLIP repository issue #103, I see 
mention of m-of-n SSSS.  I have been mentally whiteboarding just such an 
application involving mnemonics.  Watch for it.  <g>  It is likely that 
I will crib the BIP 39 wordlists, given the impossibility that I could 
create my own set of wordlists in many languages.  I only wish that the 
BIP repository had support for more languages.  More!  Adding each new 
language to my implementation(s) will require approximately one-line 
code changes for me.

(Aside further:  Why is there not a Dutch wordlist?  I should like to 
add that, please?meneer Provoost.  More wordlists!)

Aside still yet further:  Should you be interested in more general 
applications of mnemonic phrases for pseudorandom strings, I think you 
will like this future feature which currently exists only as an Easter 
egg, (un)documented in my commit log:

https://github.com/nym-zone/easyseed/commit/ba77be1b1a1f0c6af50ceba5c89f4adece7e5dff

Further discussion is invited by private mail, in an appropriate public 
venue, or otherwise not on a bitcoin-dev thread which makes a simple 
request and proposal as to the existing BIP 39 standard?thanks.

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180105/7673c033/attachment.sig>

From vitteaymeric at gmail.com  Fri Jan  5 19:56:19 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Fri, 5 Jan 2018 20:56:19 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <CALPhJaxzayykMMxaa421kfu6QQ77JD7bZJk8+dXT4qSqK_eABg@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
	<CALPhJax=53dLL9+JDKJC7NdEFFRB2kgKiECSh8PUMzrr2KxWuQ@mail.gmail.com>
	<2A39F6D7-CDF9-4624-BE0A-22C809C8B68C@sprovoost.nl>
	<af76eb48-8ef9-59b5-f7cd-dd3e45277deb@gmail.com>
	<CALPhJaxzayykMMxaa421kfu6QQ77JD7bZJk8+dXT4qSqK_eABg@mail.gmail.com>
Message-ID: <258487be-0b5b-f5fc-e63c-4de7c0e1c874@gmail.com>

No that's not, some parts of the answer might be but this related, this
just shows how people use wrongly BIP39 and subsequent BIPs (and
globally other things), misleading them, while the advantage of using it
is quite dubious compared to backing up a seed, unless you can convince
me of the contrary


Le 05/01/2018 ? 19:16, Alan Evans a ?crit?:
> Sjors, well in Electrum, validation is optional, but English only. As
> for the Ledger-S, that sounds like a Ledger problem.
>
> Aymeric, that is way off topic, did you reply to wrong email?
>
> On Fri, Jan 5, 2018 at 2:08 PM, Aymeric Vitte <vitteaymeric at gmail.com
> <mailto:vitteaymeric at gmail.com>> wrote:
>
>     See: https://github.com/Ayms/bitcoin-transactions/issues/3
>     <https://github.com/Ayms/bitcoin-transactions/issues/3>
>
>     OK, maybe it's my fault, I did not foresee this case, and now it's
>     working for p2sh (non segwit)
>
>     From my standpoint this just means that BIP39/44 stuff should be
>     eradicated (not BIP141 but see what happened...), this is of no
>     use, confusing people, doing dangerous things to recover
>
>     Really is it easier to save x words instead of a seed? Knowing
>     that people are creating several wallets not understanding that
>     this is not the purpose of BIP32?
>
>     Multisig wallets (like Electrum) have created a big mess too, on
>     purpose or no, I don't know, but multisig is for different parties
>     involved, not just one
>
>
>     Le 05/01/2018 ? 18:13, Sjors Provoost via bitcoin-dev a ?crit?:
>>     I don?t know about Electrum but many wallets validate the English words, which helps in catching typos.
>>
>>     Hardware wallets without a full keyboard, like the Ledger Nano S, won?t even let you freely type characters; you have to select words from a list.
>>
>>     So although the standard technically allows what you say, if you use anything other than 12, 16 or 24 English words, you?ll have fewer wallets to choose from.
>>
>>     I think it?s better to come up with a new standard than trying to patch BIP-39 at this point, which is why I brought it up.
>>
>>     Sjors
>>
>>>     Op 5 jan. 2018, om 17:27 heeft Alan Evans <thealanevans at gmail.com> <mailto:thealanevans at gmail.com> het volgende geschreven:
>>>
>>>     "Very few wallets support anything other than English"
>>>
>>>     By support do you mean allow recovery, validation or generation or all three? For if you can freely type a phrase in (such as Electrum), or even word by word, then the likely-hood is it is supported if they remembered to normalize.
>>>
>>>     Seed generation in BIP0039 requires no dictionary what-so-ever! So there is no word list to lose in the first place. Your funds are accessible with just the characters and the algorithm as described in BIP0039.
>>>
>>>     But your proposal is a million miles away from simply adding some standard in-language names to some word lists feels like it's derailing the OP's simple proposal. Maybe start own email chain about it.
>>>
>>>     Alan
>>>
>>>     On Fri, Jan 5, 2018 at 12:04 PM, Sjors Provoost via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>     I?m not a fan of language specific word lists within the current BIP-39 standard. Very few wallets support anything other than English, which can lead to vendor lock-in and long term loss of funds if a rare non-English wallet disappears.
>>>
>>>     However, because people can memorize things better in their native tongue, supporting multiple languages seems quite useful.
>>>
>>>     I would prefer a new standard where words are mapped to integers rather than to a literal string. For each language a mapping from words to integers would be published. In addition to that, there would be a mapping from original language words to matching (in terms of integer value, not meaning) English words that people can print on an A4 paper. This would allow them to enter a mnemonic into e.g. a hardware wallet that only support English. Such lists are more likely to be around 100 years from now than some ancient piece of software.
>>>
>>>     This would not work with the current BIP-39 (duress) password, but this feature could be replaced by appending words (with or without a checksum for that addition).
>>>
>>>     A replacement for BIP-39 would be a good opportunity to produce a better English dictionary as Nic Johnson suggested a while ago:
>>>             ? all words are 4-8 characters
>>>             ? all 4-character prefixes are unique (very useful for hardware wallets)
>>>             ? no two words have edit distance < 2
>>>
>>>     Wallets need to be able to distinguish between the old and new standard, so un-upgraded BIP 39 wallets should consider all new mnemonics invalid. At the same time, some new wallets may not wish to support BIP39. They shouldn't be burdened with storing the old word list.
>>>
>>>     A solution is to sort the new word list such that reused words appear first. When generating a mnemonic, at least one word unique to the new list must be present. A wallet only needs to know the index of the last BIP39 overlapping word. They reject a proposed mnemonic if none of the elements use a word with a higher index.
>>>
>>>     For my above point and some related ideas, see: https://github.com/satoshilabs/slips/issues/103
>>>     <https://github.com/satoshilabs/slips/issues/103>
>>>
>>>     Sjors
>>>
>>>>     Op 5 jan. 2018, om 14:58 heeft nullius via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
>>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
>>>>
>>>>     I propose and request as an enhancement that the BIP 39 wordlist set should specify canonical native language strings to identify each wordlist, as well as short ASCII language codes.  At present, the languages are identified only by their names in English.
>>>>
>>>>     Strings properly vetted and recommended by native speakers should facilitate language identification in user interface options or menus.  Specification of language identifier strings would also promote interface consistency between implementations; this may be important if a user creates a mnemonic in Implementation A, then restores a wallet using that mnemonic in Implementation B.
>>>>
>>>>     As an independent implementer who does not know *all* these different languages, I monkey-pasted language-native strings from a popular wiki site.  I cannot guarantee that they be all accurate, sensible, or even non-embarrassing.
>>>>
>>>>     https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
>>>>     <https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99>
>>>>     ```
>>>>           LANG(english,                   u8"English",    "en",   ascii_space ),
>>>>           LANG(chinese_simplified,        u8"??", "zh-CN",ascii_space ),
>>>>           LANG(chinese_traditional,       u8"??", "zh-TW",ascii_space ),
>>>>           LANG(french,                    u8"Fran?ais",   "fr",   ascii_space ),
>>>>           LANG(italian,                   u8"Italiano",   "it",   ascii_space ),
>>>>           LANG(japanese,                  u8"???",        "ja",   u8"\u3000"  ),
>>>>           LANG(korean,                    u8"???",        "ko",   ascii_space ),
>>>>           LANG(spanish,                   u8"Espa?ol",    "es",   ascii_space )
>>>>     ```
>>>>
>>>>     Per the comment at #L85 of the quoted file, I also know that for my short identifiers for Chinese, ?zh-CN? and ?zh-TW?, are imprecise at best?insofar as Hong Kong uses Traditional; and overseas Chinese may use either.  For differentiating the two Chinese writing variants, are there any appropriate standardized or customary short ASCII language IDs similar to ISO 3166-1 alpha-2 which are purely linguistic, and not fit to present-day political boundaries?
>>>>
>>>>     My general suggestion is that the specification of appropriate strings in bitcoin:bips/bip-0039/bip-0039-wordlists.md be made part of the process for accepting new wordlists.  My specific request is that such strings be ascertained for the wordlists already existing, preferably from the persons involved in the original pull requests therefor.
>>>>
>>>>     Should this proposal be ?concept ACKed? by appropriate parties, then I may open a pull request suggesting an appropriate format for specifying this information in the repository.  However, I will must needs leave the vetting of appropriate strings to native speakers or experts in the respective languages.
>>>>
>>>>     Prior references:  The wordlist additions at PRs #92, #130 (Japanese); #100 (Spanish); #114 (Chinese, both variants); #152 (French); #306 (Italian); #570 (Korean); #621 (Indonesian, *proposed*, open).
>>>>     _______________________________________________
>>>>     bitcoin-dev mailing list
>>>>     bitcoin-dev at lists.linuxfoundation.org
>>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>>>     _______________________________________________
>>>     bitcoin-dev mailing list
>>>     bitcoin-dev at lists.linuxfoundation.org
>>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>>>
>>>
>>>     <signature.asc>
>>
>>
>>     _______________________________________________
>>     bitcoin-dev mailing list
>>     bitcoin-dev at lists.linuxfoundation.org
>>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>
>     -- 
>     Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
>     <https://github.com/Ayms/bitcoin-transactions>
>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
>     <https://github.com/Ayms/zcash-wallets>
>     Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
>     <https://github.com/Ayms/bitcoin-wallets>
>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist
>     Check the 10 M passwords list: http://peersm.com/findmyass
>     Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
>     Peersm : http://www.peersm.com
>     torrent-live: https://github.com/Ayms/torrent-live
>     <https://github.com/Ayms/torrent-live>
>     node-Tor : https://www.github.com/Ayms/node-Tor
>     <https://www.github.com/Ayms/node-Tor>
>     GitHub : https://www.github.com/Ayms
>
>

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180105/1c88fd57/attachment-0001.html>

From luke at dashjr.org  Sat Jan  6 00:26:51 2018
From: luke at dashjr.org (Luke Dashjr)
Date: Sat, 6 Jan 2018 00:26:51 +0000
Subject: [bitcoin-dev] =?iso-8859-1?q?Bech32_and_P2SH=B2?=
In-Reply-To: <201801041423.05959.luke@dashjr.org>
References: <201801041423.05959.luke@dashjr.org>
Message-ID: <201801060026.51676.luke@dashjr.org>

I've posted an initial draft of a possible Bech32 revision/replacement here:

https://github.com/luke-jr/bips/blob/new_bech32_p2sh2/bip-bech32-p2sh2.mediawiki

On Thursday 04 January 2018 2:23:05 PM Luke Dashjr via bitcoin-dev wrote:
> I know I'm super-late to bring this up, but was there a reason Bech32
> omitted the previously-discussed P2SH? improvements? Since deployment
> isn't too widespread yet, maybe it'd be worth a quick revision to add
> this?
> 
> For those unfamiliar with the concept, the idea is to have the address
> include the *single* SHA256 hash of the public key or script, rather than
> RIPEMD160(SHA256(pubkey)) or SHA256(SHA256(script)). The sender would then
> perform the second hash to produce the output. Doing this would in the
> future enable relaying the "middle-hash" as a way to prove the final hash
> is in fact a hash itself, thereby proving it is not embedded data spam.
> 
> Bech32 seems like a huge missed opportunity to add this, since everyone
> will probably be upgrading to it at some point.
> 
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From greg at xiph.org  Sat Jan  6 00:44:20 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 6 Jan 2018 00:44:20 +0000
Subject: [bitcoin-dev] =?utf-8?q?Bech32_and_P2SH=C2=B2?=
In-Reply-To: <201801041423.05959.luke@dashjr.org>
References: <201801041423.05959.luke@dashjr.org>
Message-ID: <CAAS2fgQT33QhZrSoGvi=_i0pREuqU+A82zSekFkC1M8av+ufRA@mail.gmail.com>

P2SH^2 wasn't a serious proposal-- I just suggested it as a thought
experiment. I don't think it offers much useful in the context of
Bitcoin today. Particularly since weight calculations have made output
space relatively more expensive and fees are at quite non-negligible
rates interest in "storing data" in outputs should at least not be
increasing.

Moreover, unfortunately, people already rushed bech32 to market in
advance of practically any public review-- regrettable but it is what
it is... I don't think adding more address diversity at this time
wouldn't be good for the ecosystem.

What we might want to do is consider working on an address-next
proposal that has an explicit timeframe of N years out, and very loud
don't deploy this--- layered hashing is just one very minor slightly
nice to have... things like coded expiration times, abilities to have
amounts under checksum, etc. are probably more worth consideration.



On Thu, Jan 4, 2018 at 2:23 PM, Luke Dashjr via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I know I'm super-late to bring this up, but was there a reason Bech32 omitted
> the previously-discussed P2SH? improvements? Since deployment isn't too
> widespread yet, maybe it'd be worth a quick revision to add this?
>
> For those unfamiliar with the concept, the idea is to have the address include
> the *single* SHA256 hash of the public key or script, rather than
> RIPEMD160(SHA256(pubkey)) or SHA256(SHA256(script)). The sender would then
> perform the second hash to produce the output. Doing this would in the future
> enable relaying the "middle-hash" as a way to prove the final hash is in fact
> a hash itself, thereby proving it is not embedded data spam.
>
> Bech32 seems like a huge missed opportunity to add this, since everyone will
> probably be upgrading to it at some point.
>
> Luke
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From aritter at gmail.com  Sat Jan  6 10:05:11 2018
From: aritter at gmail.com (Adam Ritter)
Date: Sat, 6 Jan 2018 08:05:11 -0200
Subject: [bitcoin-dev] =?utf-8?q?Bech32_and_P2SH=C2=B2?=
In-Reply-To: <CAAS2fgQT33QhZrSoGvi=_i0pREuqU+A82zSekFkC1M8av+ufRA@mail.gmail.com>
References: <201801041423.05959.luke@dashjr.org>
	<CAAS2fgQT33QhZrSoGvi=_i0pREuqU+A82zSekFkC1M8av+ufRA@mail.gmail.com>
Message-ID: <CAKuKjyV9aFzVY0__N=P1U4+_zbidZruRFsnD1H9W0aAZhOwsQg@mail.gmail.com>

The question that I didn't see answered in the Bech32 proposal is why
something like the BIP39 mnemoic format is not used for addresses as well.
There was a lot of math involved in creating it, but I'm not sure how much
user experience testing.

I realized how much harder it is to copy random letters and numbers than
simple words only when I copied an addresses and a private keys by hand,
and even after I knew that I made a mistake, it took significant effort to
find the place of the mistake.

In contrast with BIP39 seeds I never made a mistake when writing down
(although I have seen a case where somebody made a mistake because a word
was twice in the same seed, but this is something that could be fixed).


On Fri, Jan 5, 2018 at 10:44 PM, Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> P2SH^2 wasn't a serious proposal-- I just suggested it as a thought
> experiment. I don't think it offers much useful in the context of
> Bitcoin today. Particularly since weight calculations have made output
> space relatively more expensive and fees are at quite non-negligible
> rates interest in "storing data" in outputs should at least not be
> increasing.
>
> Moreover, unfortunately, people already rushed bech32 to market in
> advance of practically any public review-- regrettable but it is what
> it is... I don't think adding more address diversity at this time
> wouldn't be good for the ecosystem.
>
> What we might want to do is consider working on an address-next
> proposal that has an explicit timeframe of N years out, and very loud
> don't deploy this--- layered hashing is just one very minor slightly
> nice to have... things like coded expiration times, abilities to have
> amounts under checksum, etc. are probably more worth consideration.
>
>
>
> On Thu, Jan 4, 2018 at 2:23 PM, Luke Dashjr via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > I know I'm super-late to bring this up, but was there a reason Bech32
> omitted
> > the previously-discussed P2SH? improvements? Since deployment isn't too
> > widespread yet, maybe it'd be worth a quick revision to add this?
> >
> > For those unfamiliar with the concept, the idea is to have the address
> include
> > the *single* SHA256 hash of the public key or script, rather than
> > RIPEMD160(SHA256(pubkey)) or SHA256(SHA256(script)). The sender would
> then
> > perform the second hash to produce the output. Doing this would in the
> future
> > enable relaying the "middle-hash" as a way to prove the final hash is in
> fact
> > a hash itself, thereby proving it is not embedded data spam.
> >
> > Bech32 seems like a huge missed opportunity to add this, since everyone
> will
> > probably be upgrading to it at some point.
> >
> > Luke
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180106/db3386a6/attachment.html>

From stick at satoshilabs.com  Sun Jan  7 15:16:47 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Sun, 7 Jan 2018 16:16:47 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
Message-ID: <d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>

On 05/01/18 14:58, nullius via bitcoin-dev wrote:
> I propose and request as an enhancement that the BIP 39 wordlist set
> should specify canonical native language strings to identify each
> wordlist, as well as short ASCII language codes.? At present, the
> languages are identified only by their names in English.

I am advising not to use any other language than English for BIP39. I
got persuaded to allow more languages when writing BIP39 spec, but I
learned that it was something I should've been more persistently against.

I am currently drafting a new standard[1] which will allow also Shamir
Secret Scheme Splitting and there we disallow usage of a custom wordlist
in order to eradicate this mess. Will try to push this as BIP too once
we get it to the point we are OK with the contents.

https://github.com/satoshilabs/slips/blob/master/slip-0039.md

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180107/8eef9b25/attachment.sig>

From vitteaymeric at gmail.com  Sat Jan  6 17:40:40 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sat, 6 Jan 2018 18:40:40 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <CALPhJaz1wU8y6KxZipREjus8WbHpwpyYjyMwgj5x-tTodxpjCQ@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
	<CALPhJax=53dLL9+JDKJC7NdEFFRB2kgKiECSh8PUMzrr2KxWuQ@mail.gmail.com>
	<2A39F6D7-CDF9-4624-BE0A-22C809C8B68C@sprovoost.nl>
	<af76eb48-8ef9-59b5-f7cd-dd3e45277deb@gmail.com>
	<CALPhJaxzayykMMxaa421kfu6QQ77JD7bZJk8+dXT4qSqK_eABg@mail.gmail.com>
	<258487be-0b5b-f5fc-e63c-4de7c0e1c874@gmail.com>
	<CALPhJawP7hjucR6X3gpTxCxK+awMT9iArELZYFy_zffCGgVMEw@mail.gmail.com>
	<58C8F1BA-B9A1-4525-BCC9-BF4CEDC87E1B@sprovoost.nl>
	<a3e10fe7-ed9c-bb58-bf12-d0aeda2827e4@gmail.com>
	<a2e8b3e2-b444-039c-c51e-43294a3437c9@gmail.com>
	<CALPhJaz1wU8y6KxZipREjus8WbHpwpyYjyMwgj5x-tTodxpjCQ@mail.gmail.com>
Message-ID: <122d7820-3968-0c53-0156-23bf94a54ce2@gmail.com>

Unfortunately, even "yourself" seems not to know what he is talking
about (so imagine for other people, 256 bits is advised --> 32B),
probably that's why you brought this discussion off the list, then
making recommendations to improve something that is misleading and messy
is quite dubious

And maybe you should take a look at what people you are talking to are
doing before arguing stuff that you apparently don't know very well (ie
"the length of the *derived *key", not the seed), cf
https://github.com/Ayms/bitcoin-wallets
<https://github.com/Ayms/bitcoin-wallets> and even
https://github.com/Ayms/zcash-wallets (not official but
https://github.com/zcash/zips/issues/95)
<https://github.com/Ayms/zcash-wallets>

But as you can notice there is a missing feature, ie to derive the
wallets from xpriv, there is a comment in the repo why I don't like some
things "Surprisingly from ~32 bytes keys BIP32 ends up with a 78 bytes
format to describe them with all the necessary information like indexes,
parent to possibly allow to revert the tree"

That's another thing I completely dislike with BIP39, it ends up with
xpriv, not the 32B seed, there are many, many, many posts in forums of
people fighting to figure out their private keys derived from bip39/44/etc

"No offence too" but please keep your advises for yourself, I indeed
don't read closely inept BIPs, and never said I did not like BIP32,
that's the contrary, I really like it

Before firing plenty of BIPs that do not fit together people maybe
should take a break and see what people are doing today (this is quite
amazing) and why they got stolen

And you seem to know very little about security, if you suspect you home
printer, then suspect you OS, your hw, etc, (you really envision to
generate a seed from a mobile device ???) writing 64 characters is not
very difficult for a human being, even easier than writing x words of y
length

See this too
https://bitcointalk.org/index.php?topic=2550529.msg26133887#msg26133887,
the tutorial was corrected, but basic things are still missing, an
offline version is when you disconnect from the internet, not when you
use the "offline version"? (assuming that the browser storage or other
stuff are not used...)

Re-ccing the list because again at a certain point of time the theory
should look at the reality and adapt accordingly, part of the example I
gave is off topic for this thread but globally (which could become
another thread) the message is: the bitcoin community should stop making
things complicate for people, releasing BIPs of no use just ends up with
complicating things more than it helps, people deserve to understand
what they are doing, manage their keys by their own and stop syncing
useless full nodes for every coin to sync their wallets, that's why I
made the tool, the first people that used it made some outstanding
mistakes that I did not envision now it's not possible any longer,
except if they give wrong destination addresses and nobody can't do
anything about this (btw the primary intent of the tool was for myself
and you are right for once, I did not know that people could do so big
mistakes, that's not their fault, I see it now, my mistake for
underestimating this)

Le 06/01/2018 ? 16:00, Alan Evans a ?crit?:
> You're mistaken. BIP32 does not require a particular?length. It
> recommends:
>
>   * Generate a seed byte sequence S of a chosen length (between 128
>     and 512 bits; 256 bits is advised) from a (P)RNG
>
> But BIP39 produces a?64 byte?seed:
>
> The length of the derived key is 512 bits (= 64 bytes).
>
> If you don't believe me, why don't you just try it? That seed will
> derive the same keys as that mnemonic, it's a real example.
>
> ---------
>
> About printing, there is a huge security risk involved in printing
> anything. Networks, printers may have memory. People will print to PDF
> when they don't have a printer on hand. Mobile users often can't print.
>
> I wrote mine down, by hand, generated from an offline computer booted
> with a?readonly?OS.?
>
> Feel free to produce a recommendation to replace BIP39/32/44 if you
> like, but it's not broken just because someone had trouble using your
> tool/following your instructions. And no offence but I'd be wary using
> a tool from someone who doesn't read the BIPs closely yet is so
> confident about how other people are wrong.
>
>
> On Sat, Jan 6, 2018 at 6:57 AM, Aymeric Vitte <vitteaymeric at gmail.com
> <mailto:vitteaymeric at gmail.com>> wrote:
>
>     And Alan, btw, a BIP32 seed is 32 bytes, then 64 characters, not 64
>     bytes as your wrote below, which probably corresponds to xprv,
>     which is
>     another misleading element of BIP39
>
>
>     Le 06/01/2018 ? 02:56, Aymeric Vitte a ?crit?:
>     > The fact is indeed that "we should really find a way to overhaul
>     this
>     > whole BIP 39 / 43/ 44 etc ad hoc mess"
>     >
>     > Because the git example I provided is about someone that knows (to a
>     > certain extent) what he is doing, then made a mistake for the
>     > destination address, which is not related to this discussion
>     >
>     > This just shows how complicate it can become even for people knowing
>     > this to retrieve their wallet and how wallets made it "the easy
>     way" (ie
>     > bip39, 44, multisig...)
>     >
>     > If people prefer to store mnemonics, why not, but "writing down"
>     in both
>     > messages above is not accurate, you would better print it and
>     cut it in
>     > n pieces if you like, then the point of using mnemonics that you
>     can't
>     > remember more than an hex string still remains useless from my
>     standpoint
>     >
>     > Beside the theory we should look now if BIP39 & all brought more
>     good
>     > than the contrary in practice, I think that the later wins
>     >
>     >
>     > Le 05/01/2018 ? 21:38, Sjors Provoost a ?crit?:
>     >> Hi Alan,
>     >>
>     >> The Github issue is arguably unrelated, which is why I put it
>     at the end and said ?some related?.
>     >>
>     >> However it does all tie together; we should really find a way
>     to overhaul this whole BIP 39 / 43/ 44 etc ad hoc mess, ideally in
>     a way that even Bitcoin Core would be willing to use it. When you
>     change the word list, it?s best to change everything else at the
>     same time. Otherwise you?d have too many different standards,
>     which is a pain for wallets to implement.
>     >>
>     >> I share your view than a mnemonic is better than a bunch of hex
>     numbers. It?s easier to memorize and easier to write down. Some
>     people don?t like it when users write down phrases, but they?re
>     much, much more likely to lose their coins than some burglar to
>     find the piece of paper. My issue is only with the way derivation
>     currently works.
>     >>
>     >> Sjors
>     >>
>     >>> Op 5 jan. 2018, om 21:05 heeft Alan Evans
>     <thealanevans at gmail.com <mailto:thealanevans at gmail.com>> het
>     volgende geschreven:
>     >>>
>     >>> Taking it off the board. I can't read all of that issue.
>     BIP0039 mnemonic generates a seed. Everything past there to do
>     with addresses (BIP32/44/49/141 whatever) is the same as if you
>     started with the seed. So you can't blaim BIP0039 for that
>     person's misunderstanding, and the way different wallets use
>     different derivation paths.
>     >>>
>     >>> If someone has a BIP0039 mnemonic and would rather back up the
>     seed, they can go ahead. But one tiny mistake in writing it down
>     and you may have a hell of a time finding out what's wrong as
>     every seed is valid. A mistake in writing down words is far harder
>     to make. You can also memorize a mnemonic (hence the name), the
>     average person cannot memorize a seed.
>     >>>
>     >>> fork canal mad beyond spike pool expire fuel region impose
>     ceiling video
>     >>>
>     >>> vs:
>     >>>
>     >>>
>     f54b80812b3a6f1834095370df82a2123aece2d6089da67d7871477c004684fbc399a6155e53de0b783a9be6388354846e51f59e4869984f0c554e6469788c64
>     >>>
>     >>> But they lead to the same addresses.
>     >>>
>     >>> Need I say more?
>     >>>
>     >>>
>     >>> On Fri, Jan 5, 2018 at 3:56 PM, Aymeric Vitte
>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>     >>> No that's not, some parts of the answer might be but this
>     related, this just shows how people use wrongly BIP39 and
>     subsequent BIPs (and globally other things), misleading them,
>     while the advantage of using it is quite dubious compared to
>     backing up a seed, unless you can convince me of the contrary
>     >>>
>     >>> Le 05/01/2018 ? 19:16, Alan Evans a ?crit :
>     >>>> Sjors, well in Electrum, validation is optional, but English
>     only. As for the Ledger-S, that sounds like a Ledger problem.
>     >>>>
>     >>>> Aymeric, that is way off topic, did you reply to wrong email?
>     >>>>
>     >>>> On Fri, Jan 5, 2018 at 2:08 PM, Aymeric Vitte
>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>     >>>> See: https://github.com/Ayms/bitcoin-transactions/issues/3
>     <https://github.com/Ayms/bitcoin-transactions/issues/3>
>     >>>>
>     >>>> OK, maybe it's my fault, I did not foresee this case, and now
>     it's working for p2sh (non segwit)
>     >>>> From my standpoint this just means that BIP39/44 stuff should
>     be eradicated (not BIP141 but see what happened...), this is of no
>     use, confusing people, doing dangerous things to recover
>     >>>> Really is it easier to save x words instead of a seed?
>     Knowing that people are creating several wallets not understanding
>     that this is not the purpose of BIP32?
>     >>>>
>     >>>> Multisig wallets (like Electrum) have created a big mess too,
>     on purpose or no, I don't know, but multisig is for different
>     parties involved, not just one
>     >>>>
>     >>>> Le 05/01/2018 ? 18:13, Sjors Provoost via bitcoin-dev a ?crit :
>     >>>>> I don?t know about Electrum but many wallets validate the
>     English words, which helps in catching typos.
>     >>>>>
>     >>>>> Hardware wallets without a full keyboard, like the Ledger
>     Nano S, won?t even let you freely type characters; you have to
>     select words from a list.
>     >>>>>
>     >>>>> So although the standard technically allows what you say, if
>     you use anything other than 12, 16 or 24 English words, you?ll
>     have fewer wallets to choose from.
>     >>>>>
>     >>>>> I think it?s better to come up with a new standard than
>     trying to patch BIP-39 at this point, which is why I brought it up.
>     >>>>>
>     >>>>> Sjors
>     >>>>>
>     >>>>>
>     >>>>>> Op 5 jan. 2018, om 17:27 heeft Alan Evans
>     <thealanevans at gmail.com <mailto:thealanevans at gmail.com>>
>     >>>>>>? het volgende geschreven:
>     >>>>>>
>     >>>>>> "Very few wallets support anything other than English"
>     >>>>>>
>     >>>>>> By support do you mean allow recovery, validation or
>     generation or all three? For if you can freely type a phrase in
>     (such as Electrum), or even word by word, then the likely-hood is
>     it is supported if they remembered to normalize.
>     >>>>>>
>     >>>>>> Seed generation in BIP0039 requires no dictionary
>     what-so-ever! So there is no word list to lose in the first place.
>     Your funds are accessible with just the characters and the
>     algorithm as described in BIP0039.
>     >>>>>>
>     >>>>>> But your proposal is a million miles away from simply
>     adding some standard in-language names to some word lists feels
>     like it's derailing the OP's simple proposal. Maybe start own
>     email chain about it.
>     >>>>>>
>     >>>>>> Alan
>     >>>>>>
>     >>>>>> On Fri, Jan 5, 2018 at 12:04 PM, Sjors Provoost via bitcoin-dev
>     >>>>>> <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>>
>     >>>>>>? wrote:
>     >>>>>> I?m not a fan of language specific word lists within the
>     current BIP-39 standard. Very few wallets support anything other
>     than English, which can lead to vendor lock-in and long term loss
>     of funds if a rare non-English wallet disappears.
>     >>>>>>
>     >>>>>> However, because people can memorize things better in their
>     native tongue, supporting multiple languages seems quite useful.
>     >>>>>>
>     >>>>>> I would prefer a new standard where words are mapped to
>     integers rather than to a literal string. For each language a
>     mapping from words to integers would be published. In addition to
>     that, there would be a mapping from original language words to
>     matching (in terms of integer value, not meaning) English words
>     that people can print on an A4 paper. This would allow them to
>     enter a mnemonic into e.g. a hardware wallet that only support
>     English. Such lists are more likely to be around 100 years from
>     now than some ancient piece of software.
>     >>>>>>
>     >>>>>> This would not work with the current BIP-39 (duress)
>     password, but this feature could be replaced by appending words
>     (with or without a checksum for that addition).
>     >>>>>>
>     >>>>>> A replacement for BIP-39 would be a good opportunity to
>     produce a better English dictionary as Nic Johnson suggested a
>     while ago:
>     >>>>>>? ? ? ? ?? all words are 4-8 characters
>     >>>>>>? ? ? ? ?? all 4-character prefixes are unique (very useful
>     for hardware wallets)
>     >>>>>>? ? ? ? ?? no two words have edit distance < 2
>     >>>>>>
>     >>>>>> Wallets need to be able to distinguish between the old and
>     new standard, so un-upgraded BIP 39 wallets should consider all
>     new mnemonics invalid. At the same time, some new wallets may not
>     wish to support BIP39. They shouldn't be burdened with storing the
>     old word list.
>     >>>>>>
>     >>>>>> A solution is to sort the new word list such that reused
>     words appear first. When generating a mnemonic, at least one word
>     unique to the new list must be present. A wallet only needs to
>     know the index of the last BIP39 overlapping word. They reject a
>     proposed mnemonic if none of the elements use a word with a higher
>     index.
>     >>>>>>
>     >>>>>> For my above point and some related ideas, see:
>     >>>>>> https://github.com/satoshilabs/slips/issues/103
>     <https://github.com/satoshilabs/slips/issues/103>
>     >>>>>>
>     >>>>>>
>     >>>>>> Sjors
>     >>>>>>
>     >>>>>>
>     >>>>>>> Op 5 jan. 2018, om 14:58 heeft nullius via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>>
>     >>>>>>>? het volgende geschreven:
>     >>>>>>>
>     >>>>>>> I propose and request as an enhancement that the BIP 39
>     wordlist set should specify canonical native language strings to
>     identify each wordlist, as well as short ASCII language codes.? At
>     present, the languages are identified only by their names in English.
>     >>>>>>>
>     >>>>>>> Strings properly vetted and recommended by native speakers
>     should facilitate language identification in user interface
>     options or menus.? Specification of language identifier strings
>     would also promote interface consistency between implementations;
>     this may be important if a user creates a mnemonic in
>     Implementation A, then restores a wallet using that mnemonic in
>     Implementation B.
>     >>>>>>>
>     >>>>>>> As an independent implementer who does not know *all*
>     these different languages, I monkey-pasted language-native strings
>     from a popular wiki site.? I cannot guarantee that they be all
>     accurate, sensible, or even non-embarrassing.
>     >>>>>>>
>     >>>>>>>
>     >>>>>>>
>     https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
>     <https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99>
>     >>>>>>>
>     >>>>>>> ```
>     >>>>>>>? ? ? ?LANG(english,? ? ? ? ? ? ? ? ? ?u8"English",? ?
>     "en",? ?ascii_space ),
>     >>>>>>>? ? ? ?LANG(chinese_simplified,? ? ? ? u8"??",
>     "zh-CN",ascii_space ),
>     >>>>>>>? ? ? ?LANG(chinese_traditional,? ? ? ?u8"??",
>     "zh-TW",ascii_space ),
>     >>>>>>>? ? ? ?LANG(french,? ? ? ? ? ? ? ? ? ? u8"Fran?ais",?
>     ?"fr",? ?ascii_space ),
>     >>>>>>>? ? ? ?LANG(italian,? ? ? ? ? ? ? ? ? ?u8"Italiano",?
>     ?"it",? ?ascii_space ),
>     >>>>>>>? ? ? ?LANG(japanese,? ? ? ? ? ? ? ? ? u8"???",? ? ? ?
>     "ja",? ?u8"\u3000"? ),
>     >>>>>>>? ? ? ?LANG(korean,? ? ? ? ? ? ? ? ? ? u8"???",? ? ? ?
>     "ko",? ?ascii_space ),
>     >>>>>>>? ? ? ?LANG(spanish,? ? ? ? ? ? ? ? ? ?u8"Espa?ol",? ?
>     "es",? ?ascii_space )
>     >>>>>>> ```
>     >>>>>>>
>     >>>>>>> Per the comment at #L85 of the quoted file, I also know
>     that for my short identifiers for Chinese, ?zh-CN? and ?zh-TW?,
>     are imprecise at best?insofar as Hong Kong uses Traditional; and
>     overseas Chinese may use either.? For differentiating the two
>     Chinese writing variants, are there any appropriate standardized
>     or customary short ASCII language IDs similar to ISO 3166-1
>     alpha-2 which are purely linguistic, and not fit to present-day
>     political boundaries?
>     >>>>>>>
>     >>>>>>> My general suggestion is that the specification of
>     appropriate strings in
>     >>>>>>> bitcoin:bips/bip-0039/bip-0039-wordlists.md
>     <http://bip-0039-wordlists.md>
>     >>>>>>>? be made part of the process for accepting new wordlists.?
>     My specific request is that such strings be ascertained for the
>     wordlists already existing, preferably from the persons involved
>     in the original pull requests therefor.
>     >>>>>>>
>     >>>>>>> Should this proposal be ?concept ACKed? by appropriate
>     parties, then I may open a pull request suggesting an appropriate
>     format for specifying this information in the repository.?
>     However, I will must needs leave the vetting of appropriate
>     strings to native speakers or experts in the respective languages.
>     >>>>>>>
>     >>>>>>> Prior references:? The wordlist additions at PRs #92, #130
>     (Japanese); #100 (Spanish); #114 (Chinese, both variants); #152
>     (French); #306 (Italian); #570 (Korean); #621 (Indonesian,
>     *proposed*, open).
>     >>>>>>> ______________________________
>     >>>>>>> _________________
>     >>>>>>> bitcoin-dev mailing list
>     >>>>>>>
>     >>>>>>> bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     >>>>>>>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>     >>>>>> ______________________________
>     >>>>>> _________________
>     >>>>>> bitcoin-dev mailing list
>     >>>>>>
>     >>>>>> bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     >>>>>>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>     >>>>>>
>     >>>>>>
>     >>>>>>
>     >>>>>> <signature.asc>
>     >>>>>>
>     >>>>> ______________________________
>     >>>>> _________________
>     >>>>> bitcoin-dev mailing list
>     >>>>>
>     >>>>> bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     >>>>>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>     >>>> --
>     >>>> Bitcoin transactions made simple:
>     >>>> https://github.com/Ayms/bitcoin-transactions
>     <https://github.com/Ayms/bitcoin-transactions>
>     >>>>
>     >>>> Zcash wallets made simple:
>     >>>> https://github.com/Ayms/zcash-wallets
>     <https://github.com/Ayms/zcash-wallets>
>     >>>>
>     >>>> Bitcoin wallets made simple:
>     >>>> https://github.com/Ayms/bitcoin-wallets
>     <https://github.com/Ayms/bitcoin-wallets>
>     >>>>
>     >>>> Get the torrent dynamic blocklist:
>     >>>> http://peersm.com/getblocklist
>     >>>>
>     >>>> Check the 10 M passwords list:
>     >>>> http://peersm.com/findmyass
>     >>>>
>     >>>> Anti-spies and private torrents, dynamic blocklist:
>     >>>> http://torrent-live.org
>     >>>>
>     >>>> Peersm :
>     >>>> http://www.peersm.com
>     >>>>
>     >>>> torrent-live:
>     >>>> https://github.com/Ayms/torrent-live
>     <https://github.com/Ayms/torrent-live>
>     >>>>
>     >>>> node-Tor :
>     >>>> https://www.github.com/Ayms/node-Tor
>     <https://www.github.com/Ayms/node-Tor>
>     >>>>
>     >>>> GitHub :
>     >>>> https://www.github.com/Ayms
>     >>>>
>     >>> --
>     >>> Bitcoin transactions made simple:
>     >>> https://github.com/Ayms/bitcoin-transactions
>     <https://github.com/Ayms/bitcoin-transactions>
>     >>>
>     >>> Zcash wallets made simple:
>     >>> https://github.com/Ayms/zcash-wallets
>     <https://github.com/Ayms/zcash-wallets>
>     >>>
>     >>> Bitcoin wallets made simple:
>     >>> https://github.com/Ayms/bitcoin-wallets
>     <https://github.com/Ayms/bitcoin-wallets>
>     >>>
>     >>> Get the torrent dynamic blocklist:
>     >>> http://peersm.com/getblocklist
>     >>>
>     >>> Check the 10 M passwords list:
>     >>> http://peersm.com/findmyass
>     >>>
>     >>> Anti-spies and private torrents, dynamic blocklist:
>     >>> http://torrent-live.org
>     >>>
>     >>> Peersm :
>     >>> http://www.peersm.com
>     >>>
>     >>> torrent-live:
>     >>> https://github.com/Ayms/torrent-live
>     <https://github.com/Ayms/torrent-live>
>     >>>
>     >>> node-Tor :
>     >>> https://www.github.com/Ayms/node-Tor
>     <https://www.github.com/Ayms/node-Tor>
>     >>>
>     >>> GitHub :
>     >>> https://www.github.com/Ayms
>     >>>
>
>     --
>     Bitcoin transactions made simple:
>     https://github.com/Ayms/bitcoin-transactions
>     <https://github.com/Ayms/bitcoin-transactions>
>     Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
>     <https://github.com/Ayms/zcash-wallets>
>     Bitcoin wallets made simple:
>     https://github.com/Ayms/bitcoin-wallets
>     <https://github.com/Ayms/bitcoin-wallets>
>     Get the torrent dynamic blocklist: http://peersm.com/getblocklist
>     Check the 10 M passwords list: http://peersm.com/findmyass
>     Anti-spies and private torrents, dynamic blocklist:
>     http://torrent-live.org
>     Peersm : http://www.peersm.com
>     torrent-live: https://github.com/Ayms/torrent-live
>     node-Tor <https://github.com/Ayms/torrent-live%0Anode-Tor> :
>     https://www.github.com/Ayms/node-Tor
>     <https://www.github.com/Ayms/node-Tor>
>     GitHub : https://www.github.com/Ayms
>
>

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180106/74d8e042/attachment-0001.html>

From vitteaymeric at gmail.com  Sat Jan  6 19:46:43 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Sat, 6 Jan 2018 20:46:43 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <CALPhJaw8_wpPCRj58JcZqLnEvOtLoo=U_VBYRLSKTCeN7TFB6A@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<BB3FA46E-AA09-4A60-9D0F-8E350015E107@sprovoost.nl>
	<CALPhJax=53dLL9+JDKJC7NdEFFRB2kgKiECSh8PUMzrr2KxWuQ@mail.gmail.com>
	<2A39F6D7-CDF9-4624-BE0A-22C809C8B68C@sprovoost.nl>
	<af76eb48-8ef9-59b5-f7cd-dd3e45277deb@gmail.com>
	<CALPhJaxzayykMMxaa421kfu6QQ77JD7bZJk8+dXT4qSqK_eABg@mail.gmail.com>
	<258487be-0b5b-f5fc-e63c-4de7c0e1c874@gmail.com>
	<CALPhJawP7hjucR6X3gpTxCxK+awMT9iArELZYFy_zffCGgVMEw@mail.gmail.com>
	<58C8F1BA-B9A1-4525-BCC9-BF4CEDC87E1B@sprovoost.nl>
	<a3e10fe7-ed9c-bb58-bf12-d0aeda2827e4@gmail.com>
	<a2e8b3e2-b444-039c-c51e-43294a3437c9@gmail.com>
	<CALPhJaz1wU8y6KxZipREjus8WbHpwpyYjyMwgj5x-tTodxpjCQ@mail.gmail.com>
	<122d7820-3968-0c53-0156-23bf94a54ce2@gmail.com>
	<CALPhJaw8_wpPCRj58JcZqLnEvOtLoo=U_VBYRLSKTCeN7TFB6A@mail.gmail.com>
Message-ID: <44d2accb-b0c6-069b-f8ac-421977ea792d@gmail.com>

Calm down now and stop your "do you want a" or "link" stupid comments,
whether you are really willing to propose some improvements, whether you
are just posting for nothing

BIP39:

"The length of the derived key is 512 bits (= 64 bytes).

This seed can be later used to generate deterministic wallets using
BIP-0032 or similar methods."

So the derived key is the seed? (derived key... this seed, really?
"similar methods",funny) That's not clear, then why everybody is using
xpriv which corresponds to the first step of the derivation (ie the
derived key)? And why BIP39 does not follow BIP32 recommendation (32B seed)?

Anyway, I don't really care about this stuff in fact, the only
interesting thing in this discussion beside arguing around unclear specs
misleading many people would be if you can convince that BIP39 & co are
really usefull for people (and easier than writing a seed): what
feedback do you have, don't you see how it's a pain in the xss for
everybody?

And if the answer is positive how can you can make it easier for people
(I am amazed too that people know about BIPXYZ, they should not),
probably this discussion will bore people and get moderated, but as
mentioned below, even maybe off topic, the subject is wider

Le 06/01/2018 ? 19:28, Alan Evans a ?crit?:
> >?Unfortunately, even "yourself" seems not to know what he is talking
> about (so imagine for other people, 256 bits is advised --> 32B),
> probably that's why you brought this discussion off the list, then
> making recommendations to improve something that is misleading and
> messy is quite dubious
>
> And yet you still fail to read the BIP, do you want a
> link??https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki I
> repeat it says:
>
> between 128 and 512 bits
>
> So, that's between 16 and 64 bytes, the advisory of 256 is clearly a
> minimum.
>
> >?That's another thing I completely dislike with BIP39, it ends up
> with xpriv, not the 32B seed
>
> Please also read
> BIP0039?https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki,
> it generates *a BIP32 seed only*, no xpriv,?that's completely?false,
> then you use BIP0032 as normal with the seed. Because BIP0039 produces
> a seed, your whole argument goes out of the window, you can write the
> seed if that's what you want to do, and throw away the mnemonic.
>
>
>
> On Sat, Jan 6, 2018 at 1:40 PM, Aymeric Vitte <vitteaymeric at gmail.com
> <mailto:vitteaymeric at gmail.com>> wrote:
>
>     Unfortunately, even "yourself" seems not to know what he is
>     talking about (so imagine for other people, 256 bits is advised
>     --> 32B), probably that's why you brought this discussion off the
>     list, then making recommendations to improve something that is
>     misleading and messy is quite dubious
>
>     And maybe you should take a look at what people you are talking to
>     are doing before arguing stuff that you apparently don't know very
>     well (ie "the length of the *derived *key", not the seed), cf
>     https://github.com/Ayms/bitcoin-wallets
>     <https://github.com/Ayms/bitcoin-wallets> and even
>     https://github.com/Ayms/zcash-wallets (not official but
>     https://github.com/zcash/zips/issues/95)
>     <https://github.com/Ayms/zcash-wallets>
>
>     But as you can notice there is a missing feature, ie to derive the
>     wallets from xpriv, there is a comment in the repo why I don't
>     like some things "Surprisingly from ~32 bytes keys BIP32 ends up
>     with a 78 bytes format to describe them with all the necessary
>     information like indexes, parent to possibly allow to revert the tree"
>
>     That's another thing I completely dislike with BIP39, it ends up
>     with xpriv, not the 32B seed, there are many, many, many posts in
>     forums of people fighting to figure out their private keys derived
>     from bip39/44/etc
>
>     "No offence too" but please keep your advises for yourself, I
>     indeed don't read closely inept BIPs, and never said I did not
>     like BIP32, that's the contrary, I really like it
>
>     Before firing plenty of BIPs that do not fit together people maybe
>     should take a break and see what people are doing today (this is
>     quite amazing) and why they got stolen
>
>     And you seem to know very little about security, if you suspect
>     you home printer, then suspect you OS, your hw, etc, (you really
>     envision to generate a seed from a mobile device ???) writing 64
>     characters is not very difficult for a human being, even easier
>     than writing x words of y length
>
>     See this too
>     https://bitcointalk.org/index.php?topic=2550529.msg26133887#msg26133887
>     <https://bitcointalk.org/index.php?topic=2550529.msg26133887#msg26133887>,
>     the tutorial was corrected, but basic things are still missing, an
>     offline version is when you disconnect from the internet, not when
>     you use the "offline version"? (assuming that the browser storage
>     or other stuff are not used...)
>
>     Re-ccing the list because again at a certain point of time the
>     theory should look at the reality and adapt accordingly, part of
>     the example I gave is off topic for this thread but globally
>     (which could become another thread) the message is: the bitcoin
>     community should stop making things complicate for people,
>     releasing BIPs of no use just ends up with complicating things
>     more than it helps, people deserve to understand what they are
>     doing, manage their keys by their own and stop syncing useless
>     full nodes for every coin to sync their wallets, that's why I made
>     the tool, the first people that used it made some outstanding
>     mistakes that I did not envision now it's not possible any longer,
>     except if they give wrong destination addresses and nobody can't
>     do anything about this (btw the primary intent of the tool was for
>     myself and you are right for once, I did not know that people
>     could do so big mistakes, that's not their fault, I see it now, my
>     mistake for underestimating this)
>
>
>     Le 06/01/2018 ? 16:00, Alan Evans a ?crit?:
>>     You're mistaken. BIP32 does not require a particular?length. It
>>     recommends:
>>
>>       * Generate a seed byte sequence S of a chosen length (between
>>         128 and 512 bits; 256 bits is advised) from a (P)RNG
>>
>>     But BIP39 produces a?64 byte?seed:
>>
>>     The length of the derived key is 512 bits (= 64 bytes).
>>
>>     If you don't believe me, why don't you just try it? That seed
>>     will derive the same keys as that mnemonic, it's a real example.
>>
>>     ---------
>>
>>     About printing, there is a huge security risk involved in
>>     printing anything. Networks, printers may have memory. People
>>     will print to PDF when they don't have a printer on hand. Mobile
>>     users often can't print.
>>
>>     I wrote mine down, by hand, generated from an offline computer
>>     booted with a?readonly?OS.?
>>
>>     Feel free to produce a recommendation to replace BIP39/32/44 if
>>     you like, but it's not broken just because someone had trouble
>>     using your tool/following your instructions. And no offence but
>>     I'd be wary using a tool from someone who doesn't read the BIPs
>>     closely yet is so confident about how other people are wrong.
>>
>>
>>     On Sat, Jan 6, 2018 at 6:57 AM, Aymeric Vitte
>>     <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>>
>>         And Alan, btw, a BIP32 seed is 32 bytes, then 64 characters,
>>         not 64
>>         bytes as your wrote below, which probably corresponds to
>>         xprv, which is
>>         another misleading element of BIP39
>>
>>
>>         Le 06/01/2018 ? 02:56, Aymeric Vitte a ?crit?:
>>         > The fact is indeed that "we should really find a way to
>>         overhaul this
>>         > whole BIP 39 / 43/ 44 etc ad hoc mess"
>>         >
>>         > Because the git example I provided is about someone that
>>         knows (to a
>>         > certain extent) what he is doing, then made a mistake for the
>>         > destination address, which is not related to this discussion
>>         >
>>         > This just shows how complicate it can become even for
>>         people knowing
>>         > this to retrieve their wallet and how wallets made it "the
>>         easy way" (ie
>>         > bip39, 44, multisig...)
>>         >
>>         > If people prefer to store mnemonics, why not, but "writing
>>         down" in both
>>         > messages above is not accurate, you would better print it
>>         and cut it in
>>         > n pieces if you like, then the point of using mnemonics
>>         that you can't
>>         > remember more than an hex string still remains useless from
>>         my standpoint
>>         >
>>         > Beside the theory we should look now if BIP39 & all brought
>>         more good
>>         > than the contrary in practice, I think that the later wins
>>         >
>>         >
>>         > Le 05/01/2018 ? 21:38, Sjors Provoost a ?crit?:
>>         >> Hi Alan,
>>         >>
>>         >> The Github issue is arguably unrelated, which is why I put
>>         it at the end and said ?some related?.
>>         >>
>>         >> However it does all tie together; we should really find a
>>         way to overhaul this whole BIP 39 / 43/ 44 etc ad hoc mess,
>>         ideally in a way that even Bitcoin Core would be willing to
>>         use it. When you change the word list, it?s best to change
>>         everything else at the same time. Otherwise you?d have too
>>         many different standards, which is a pain for wallets to
>>         implement.
>>         >>
>>         >> I share your view than a mnemonic is better than a bunch
>>         of hex numbers. It?s easier to memorize and easier to write
>>         down. Some people don?t like it when users write down
>>         phrases, but they?re much, much more likely to lose their
>>         coins than some burglar to find the piece of paper. My issue
>>         is only with the way derivation currently works.
>>         >>
>>         >> Sjors
>>         >>
>>         >>> Op 5 jan. 2018, om 21:05 heeft Alan Evans
>>         <thealanevans at gmail.com <mailto:thealanevans at gmail.com>> het
>>         volgende geschreven:
>>         >>>
>>         >>> Taking it off the board. I can't read all of that issue.
>>         BIP0039 mnemonic generates a seed. Everything past there to
>>         do with addresses (BIP32/44/49/141 whatever) is the same as
>>         if you started with the seed. So you can't blaim BIP0039 for
>>         that person's misunderstanding, and the way different wallets
>>         use different derivation paths.
>>         >>>
>>         >>> If someone has a BIP0039 mnemonic and would rather back
>>         up the seed, they can go ahead. But one tiny mistake in
>>         writing it down and you may have a hell of a time finding out
>>         what's wrong as every seed is valid. A mistake in writing
>>         down words is far harder to make. You can also memorize a
>>         mnemonic (hence the name), the average person cannot memorize
>>         a seed.
>>         >>>
>>         >>> fork canal mad beyond spike pool expire fuel region
>>         impose ceiling video
>>         >>>
>>         >>> vs:
>>         >>>
>>         >>>
>>         f54b80812b3a6f1834095370df82a2123aece2d6089da67d7871477c004684fbc399a6155e53de0b783a9be6388354846e51f59e4869984f0c554e6469788c64
>>         >>>
>>         >>> But they lead to the same addresses.
>>         >>>
>>         >>> Need I say more?
>>         >>>
>>         >>>
>>         >>> On Fri, Jan 5, 2018 at 3:56 PM, Aymeric Vitte
>>         <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>>         >>> No that's not, some parts of the answer might be but this
>>         related, this just shows how people use wrongly BIP39 and
>>         subsequent BIPs (and globally other things), misleading them,
>>         while the advantage of using it is quite dubious compared to
>>         backing up a seed, unless you can convince me of the contrary
>>         >>>
>>         >>> Le 05/01/2018 ? 19:16, Alan Evans a ?crit :
>>         >>>> Sjors, well in Electrum, validation is optional, but
>>         English only. As for the Ledger-S, that sounds like a Ledger
>>         problem.
>>         >>>>
>>         >>>> Aymeric, that is way off topic, did you reply to wrong
>>         email?
>>         >>>>
>>         >>>> On Fri, Jan 5, 2018 at 2:08 PM, Aymeric Vitte
>>         <vitteaymeric at gmail.com <mailto:vitteaymeric at gmail.com>> wrote:
>>         >>>> See:
>>         https://github.com/Ayms/bitcoin-transactions/issues/3
>>         <https://github.com/Ayms/bitcoin-transactions/issues/3>
>>         >>>>
>>         >>>> OK, maybe it's my fault, I did not foresee this case,
>>         and now it's working for p2sh (non segwit)
>>         >>>> From my standpoint this just means that BIP39/44 stuff
>>         should be eradicated (not BIP141 but see what happened...),
>>         this is of no use, confusing people, doing dangerous things
>>         to recover
>>         >>>> Really is it easier to save x words instead of a seed?
>>         Knowing that people are creating several wallets not
>>         understanding that this is not the purpose of BIP32?
>>         >>>>
>>         >>>> Multisig wallets (like Electrum) have created a big mess
>>         too, on purpose or no, I don't know, but multisig is for
>>         different parties involved, not just one
>>         >>>>
>>         >>>> Le 05/01/2018 ? 18:13, Sjors Provoost via bitcoin-dev a
>>         ?crit :
>>         >>>>> I don?t know about Electrum but many wallets validate
>>         the English words, which helps in catching typos.
>>         >>>>>
>>         >>>>> Hardware wallets without a full keyboard, like the
>>         Ledger Nano S, won?t even let you freely type characters; you
>>         have to select words from a list.
>>         >>>>>
>>         >>>>> So although the standard technically allows what you
>>         say, if you use anything other than 12, 16 or 24 English
>>         words, you?ll have fewer wallets to choose from.
>>         >>>>>
>>         >>>>> I think it?s better to come up with a new standard than
>>         trying to patch BIP-39 at this point, which is why I brought
>>         it up.
>>         >>>>>
>>         >>>>> Sjors
>>         >>>>>
>>         >>>>>
>>         >>>>>> Op 5 jan. 2018, om 17:27 heeft Alan Evans
>>         <thealanevans at gmail.com <mailto:thealanevans at gmail.com>>
>>         >>>>>>? het volgende geschreven:
>>         >>>>>>
>>         >>>>>> "Very few wallets support anything other than English"
>>         >>>>>>
>>         >>>>>> By support do you mean allow recovery, validation or
>>         generation or all three? For if you can freely type a phrase
>>         in (such as Electrum), or even word by word, then the
>>         likely-hood is it is supported if they remembered to normalize.
>>         >>>>>>
>>         >>>>>> Seed generation in BIP0039 requires no dictionary
>>         what-so-ever! So there is no word list to lose in the first
>>         place. Your funds are accessible with just the characters and
>>         the algorithm as described in BIP0039.
>>         >>>>>>
>>         >>>>>> But your proposal is a million miles away from simply
>>         adding some standard in-language names to some word lists
>>         feels like it's derailing the OP's simple proposal. Maybe
>>         start own email chain about it.
>>         >>>>>>
>>         >>>>>> Alan
>>         >>>>>>
>>         >>>>>> On Fri, Jan 5, 2018 at 12:04 PM, Sjors Provoost via
>>         bitcoin-dev
>>         >>>>>> <bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>>
>>         >>>>>>? wrote:
>>         >>>>>> I?m not a fan of language specific word lists within
>>         the current BIP-39 standard. Very few wallets support
>>         anything other than English, which can lead to vendor lock-in
>>         and long term loss of funds if a rare non-English wallet
>>         disappears.
>>         >>>>>>
>>         >>>>>> However, because people can memorize things better in
>>         their native tongue, supporting multiple languages seems
>>         quite useful.
>>         >>>>>>
>>         >>>>>> I would prefer a new standard where words are mapped
>>         to integers rather than to a literal string. For each
>>         language a mapping from words to integers would be published.
>>         In addition to that, there would be a mapping from original
>>         language words to matching (in terms of integer value, not
>>         meaning) English words that people can print on an A4 paper.
>>         This would allow them to enter a mnemonic into e.g. a
>>         hardware wallet that only support English. Such lists are
>>         more likely to be around 100 years from now than some ancient
>>         piece of software.
>>         >>>>>>
>>         >>>>>> This would not work with the current BIP-39 (duress)
>>         password, but this feature could be replaced by appending
>>         words (with or without a checksum for that addition).
>>         >>>>>>
>>         >>>>>> A replacement for BIP-39 would be a good opportunity
>>         to produce a better English dictionary as Nic Johnson
>>         suggested a while ago:
>>         >>>>>>? ? ? ? ?? all words are 4-8 characters
>>         >>>>>>? ? ? ? ?? all 4-character prefixes are unique (very
>>         useful for hardware wallets)
>>         >>>>>>? ? ? ? ?? no two words have edit distance < 2
>>         >>>>>>
>>         >>>>>> Wallets need to be able to distinguish between the old
>>         and new standard, so un-upgraded BIP 39 wallets should
>>         consider all new mnemonics invalid. At the same time, some
>>         new wallets may not wish to support BIP39. They shouldn't be
>>         burdened with storing the old word list.
>>         >>>>>>
>>         >>>>>> A solution is to sort the new word list such that
>>         reused words appear first. When generating a mnemonic, at
>>         least one word unique to the new list must be present. A
>>         wallet only needs to know the index of the last BIP39
>>         overlapping word. They reject a proposed mnemonic if none of
>>         the elements use a word with a higher index.
>>         >>>>>>
>>         >>>>>> For my above point and some related ideas, see:
>>         >>>>>> https://github.com/satoshilabs/slips/issues/103
>>         <https://github.com/satoshilabs/slips/issues/103>
>>         >>>>>>
>>         >>>>>>
>>         >>>>>> Sjors
>>         >>>>>>
>>         >>>>>>
>>         >>>>>>> Op 5 jan. 2018, om 14:58 heeft nullius via
>>         bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org
>>         <mailto:bitcoin-dev at lists.linuxfoundation.org>>
>>         >>>>>>>? het volgende geschreven:
>>         >>>>>>>
>>         >>>>>>> I propose and request as an enhancement that the BIP
>>         39 wordlist set should specify canonical native language
>>         strings to identify each wordlist, as well as short ASCII
>>         language codes.? At present, the languages are identified
>>         only by their names in English.
>>         >>>>>>>
>>         >>>>>>> Strings properly vetted and recommended by native
>>         speakers should facilitate language identification in user
>>         interface options or menus.? Specification of language
>>         identifier strings would also promote interface consistency
>>         between implementations; this may be important if a user
>>         creates a mnemonic in Implementation A, then restores a
>>         wallet using that mnemonic in Implementation B.
>>         >>>>>>>
>>         >>>>>>> As an independent implementer who does not know *all*
>>         these different languages, I monkey-pasted language-native
>>         strings from a popular wiki site.? I cannot guarantee that
>>         they be all accurate, sensible, or even non-embarrassing.
>>         >>>>>>>
>>         >>>>>>>
>>         >>>>>>>
>>         https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99
>>         <https://github.com/nym-zone/easyseed/blob/1a6e48bbdac9366d9d5d1912dc062dfc3f0db2c6/easyseed.c#L99>
>>         >>>>>>>
>>         >>>>>>> ```
>>         >>>>>>>? ? ? ?LANG(english,? ? ? ? ? ? ? ? ? ?u8"English",? ?
>>         "en",? ?ascii_space ),
>>         >>>>>>>? ? ? ?LANG(chinese_simplified,? ? ? ? u8"??",
>>         "zh-CN",ascii_space ),
>>         >>>>>>>? ? ? ?LANG(chinese_traditional,? ? ? ?u8"??",
>>         "zh-TW",ascii_space ),
>>         >>>>>>>? ? ? ?LANG(french,? ? ? ? ? ? ? ? ? ? u8"Fran?ais",?
>>         ?"fr",? ?ascii_space ),
>>         >>>>>>>? ? ? ?LANG(italian,? ? ? ? ? ? ? ? ? ?u8"Italiano",?
>>         ?"it",? ?ascii_space ),
>>         >>>>>>>? ? ? ?LANG(japanese,? ? ? ? ? ? ? ? ? u8"???",? ? ? ?
>>         "ja",? ?u8"\u3000"? ),
>>         >>>>>>>? ? ? ?LANG(korean,? ? ? ? ? ? ? ? ? ? u8"???",? ? ? ?
>>         "ko",? ?ascii_space ),
>>         >>>>>>>? ? ? ?LANG(spanish,? ? ? ? ? ? ? ? ? ?u8"Espa?ol",? ?
>>         "es",? ?ascii_space )
>>         >>>>>>> ```
>>         >>>>>>>
>>         >>>>>>> Per the comment at #L85 of the quoted file, I also
>>         know that for my short identifiers for Chinese, ?zh-CN? and
>>         ?zh-TW?, are imprecise at best?insofar as Hong Kong uses
>>         Traditional; and overseas Chinese may use either.? For
>>         differentiating the two Chinese writing variants, are there
>>         any appropriate standardized or customary short ASCII
>>         language IDs similar to ISO 3166-1 alpha-2 which are purely
>>         linguistic, and not fit to present-day political boundaries?
>>         >>>>>>>
>>         >>>>>>> My general suggestion is that the specification of
>>         appropriate strings in
>>         >>>>>>> bitcoin:bips/bip-0039/bip-0039-wordlists.md
>>         <http://bip-0039-wordlists.md>
>>         >>>>>>>? be made part of the process for accepting new
>>         wordlists.? My specific request is that such strings be
>>         ascertained for the wordlists already existing, preferably
>>         from the persons involved in the original pull requests therefor.
>>         >>>>>>>
>>         >>>>>>> Should this proposal be ?concept ACKed? by
>>         appropriate parties, then I may open a pull request
>>         suggesting an appropriate format for specifying this
>>         information in the repository.? However, I will must needs
>>         leave the vetting of appropriate strings to native speakers
>>         or experts in the respective languages.
>>         >>>>>>>
>>         >>>>>>> Prior references:? The wordlist additions at PRs #92,
>>         #130 (Japanese); #100 (Spanish); #114 (Chinese, both
>>         variants); #152 (French); #306 (Italian); #570 (Korean); #621
>>         (Indonesian, *proposed*, open).
>>         >>>>>>> ______________________________
>>
>

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180106/54801027/attachment-0001.html>

From greg at xiph.org  Mon Jan  8 04:22:43 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 8 Jan 2018 04:22:43 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
Message-ID: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>

On Sun, Jan 7, 2018 at 3:16 PM, Pavol Rusnak via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> On 05/01/18 14:58, nullius via bitcoin-dev wrote:
> I am currently drafting a new standard[1] which will allow also Shamir
> Secret Scheme Splitting and there we disallow usage of a custom wordlist
> in order to eradicate this mess. Will try to push this as BIP too once
> we get it to the point we are OK with the contents.
>
> https://github.com/satoshilabs/slips/blob/master/slip-0039.md

This specification forces the key being used through a one way
function, -- so you cannot take a pre-existing key and encode it with
this scheme.  The KDF it specifies is unconfigurable and fairly weak
(20000xhmac-sha2-- which can be cracked at about 0.7M passwords a
second on a single motherboard GPU cracker).  The construction also
will silently result in the user getting a different private key if
they enter the wrong passphrase-- which could lead to funds loss. It
is again, unversioned-- so it kinda of seems like it is intentionally
constructed in a way that will prevent interoperable use, since the
lack of versioning was a primary complaint from other perspective
users.  Of course, it fine if you want to make a trezor only thing,
but why bother BIPing something that was not intended for
interoperability?  Even for a single vendor spec the lack of
versioning seems to make things harder to support new key-related
features such as segwit.

The 16-bit "checksum" based on sha2 seems pretty poor since basing
small checksums on a cryptographic hash results in a fairly poor
checksum that is surprisingly likely to accept an errored string. Your
wordlist is 10 bits and you have much less than 1023*10 bits of input,
so you could easily have a 20 bit code (two words) which guaranteed
that up to two errored words would always be detected, and probably
could choose one which catches three words much more often 1:2^20
(sipa's crc tools can help find codes like this).

The metadata seems to make fairly little affordance to help users
avoid accidentally mixing shares from distinct sharings of the same
key. Is it the idea that this is the only likely cause of a checksum
error? (1:2^16 chance of silently returning the wrong key seems kinda
bad). -- I'm not sure much could be done here, though, since
additional payload is precious.

As an aside, your specification might want to give some better advice
about the SSS since my experience virtually everyone gets it wrong in
ways that degrade or destroy its properties e.g. many fail to generate
the additional coefficients of the polynominal randomly which results
in insecurity (see armory for an example).   Oh, also, I believe it is
normally refereed to as "SSS" (three S)-- four S is the name of a
linux program for secret sharing.

I'm happy to see that there is no obvious way to abuse this one as a
brainwallet scheme!

From kinoshitajona at gmail.com  Mon Jan  8 07:35:52 2018
From: kinoshitajona at gmail.com (=?UTF-8?B?5pyo44OO5LiL44GY44KH44Gq?=)
Date: Mon, 8 Jan 2018 16:35:52 +0900
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
Message-ID: <CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>

This is very sad.

The number one problem in Japan with BIP39 seeds is with English words.

I have seen a 60 year old Japanese man writing down his phrase (because he
kept on failing recovery), and watched him write down "aneter" for
"amateur"...
So instead I had him use Copay which generates Japanese words, wrote it
down 20x faster, and perfectly. Was able to recovery on the first try.
Imagine if I didn't tell him to try recovery before using it? (iirc Trezor
doesn't say to wipe and recover before using???)

If you understand English and can spell, you read a word, your brain
processes the word, and you can spell it on your own when writing down.
Not many Japanese people can do that, so they need to copy letter for
letter, taking a long time, and still messing up on occasion.
Even native English speakers who can't spell can mess it up badly too.

To be honest, a key storage format that doesn't support multiple languages
is much more dangerous than any doomsday situation you can think of for
supporting them.

BIP39 states that seed derivation is INDEPENDENT of wordlists, and that
failure to verify checksum (not knowing the wordlist falls under this)
should "WARN" the user and not fail, continuing to derive the seed anyways.
Currently the only wallet I know of following this part of the BIP is,
ironically Electrum. I can recover any BIP39 phrase from any wordlist even
if Electrum doesn't know it.

I really hope you reconsider multi-language support for everything moving
forward.

I understand it's a nightmare to plan for and support, which is fine if you
were just developing a piece of software sold by a company based in a
western country... but you are trying to make a standard for an
international currency. Defining "everyone should only use English, because
ASCII is easier to plan for" is not a good way to move forward as a
currency.

I am just thinking of all the users I will have to help out down the road
when they come crying to me saying they can't recover, and it turns out
they wrote down some non-English gibberish in roman characters claiming "I
wrote the English just as it was on the screen!" and I have to write a
brute force script to try all the word combinations for the mystery words.
(I have done this before)

Just my two cents. Not to be accusatory or anything.
Please reconsider. Thanks.

2018-01-08 0:16 GMT+09:00 Pavol Rusnak via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> On 05/01/18 14:58, nullius via bitcoin-dev wrote:
> > I propose and request as an enhancement that the BIP 39 wordlist set
> > should specify canonical native language strings to identify each
> > wordlist, as well as short ASCII language codes.  At present, the
> > languages are identified only by their names in English.
>
> I am advising not to use any other language than English for BIP39. I
> got persuaded to allow more languages when writing BIP39 spec, but I
> learned that it was something I should've been more persistently against.
>
> I am currently drafting a new standard[1] which will allow also Shamir
> Secret Scheme Splitting and there we disallow usage of a custom wordlist
> in order to eradicate this mess. Will try to push this as BIP too once
> we get it to the point we are OK with the contents.
>
> https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>
> --
> Best Regards / S pozdravom,
>
> Pavol "stick" Rusnak
> CTO, SatoshiLabs
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
-----BEGIN PGP PUBLIC KEY BLOCK-----
Comment: http://openpgpjs.org

xsBNBFTmJ8oBB/9rd+7XLxZG/x/KnhkVK2WBG8ySx91fs+qQfHIK1JrakSV3
x6x0cK3XLClASLLDomm7Od3Q/fMFzdwCEqj6z60T8wgKxsjWYSGL3mq8ucdv
iBjC3wGauk5dQKtT7tkCFyQQbX/uMsBM4ccGBICoDmIJlwJIj7fAZVqGxGOM
bO1RhYb4dbQA2qxYP7wSsHJ6/ZNAXyEphOj6blUzdqO0exAbCOZWWF+E/1SC
EuKO4RmL7Imdep7uc2Qze1UpJCZx7ASHl2IZ4UD0G3Qr3pI6/jvNlaqCTa3U
3/YeJwEubFsd0AVy0zs809RcKKgX3W1q+hVDTeWinem9RiOG/vT+Eec/ABEB
AAHNI2tpbm9zaGl0YSA8a2lub3NoaXRham9uYUBnbWFpbC5jb20+wsByBBAB
CAAmBQJU5ifRBgsJCAcDAgkQRB9iZ30dlisEFQgCCgMWAgECGwMCHgEAAC6Z
B/9otobf0ASHYdlUBeIPXdDopyjQhR2RiZGYaS0VZ5zzHYLDDMW6ZIYm5CjO
Fc09ETLGKFxH2RcCOK2dzwz+KRU4xqOrt/l5gyd50cFE1nOhUN9+/XaPgrou
WhyT9xLeGit7Xqhht93z2+VanTtJAG6lWbAZLIZAMGMuLX6sJDCO0GiO5zxa
02Q2D3kh5GL57A5+oVOna12JBRaIA5eBGKVCp3KToT/z48pxBe3WAmLo0zXr
hEgTSzssfb2zTwtB3Ogoedj+cU2bHJvJ8upS/jMr3TcdguySmxJlGpocVC/e
qxq12Njv+LiETOrD8atGmXCnA+nFNljBkz+l6ADl93jHzsBNBFTmJ9EBCACu
Qq9ZnP+aLU/Rt6clAfiHfTFBsJvLKsdIKeE6qHzsU1E7A7bGQKTtLEnhCCQE
W+OQP+sgbOWowIdH9PpwLJ3Op+NhvLlMxRvbT36LwCmBL0yD7bMqxxmmVj8n
vlMMRSe4wDSIG19Oy7701imnHZPm/pnPlneg/Meu/UffpcDWYBbAFX8nrXPY
vkVULcI/qTcCxW/+S9fwoXjQhWHaiJJ6y3cYOSitN31W9zgcMvLwLX3JgDxE
flkwq/M+ZkfCYnS3GAPEt8GkVKy2eHtCJuNkGFlCAmKMX0yWzHRAkqOMN5KP
LFbkKY2GQl13ztWp82QYJZpj5af6dmyUosurn6AZABEBAAHCwF8EGAEIABMF
AlTmJ9QJEEQfYmd9HZYrAhsMAABKbgf/Ulu5JAk4fXgH0DtkMmdkFiKEFdkW
0Wkw7Vhd5eZ4NzeP9kOkD01OGweT9hqzwhfT2CNXCGxh4UnvEM1ZMFypIKdq
0XpLLJMrDOQO021UjAa56vHZPAVmAM01z5VzHJ7ekjgwrgMLmVkm0jWKEKaO
n/MW7CyphG7QcZ6cJX2f6uJcekBlZRw9TNYRnojMjkutlOVhYJ3J78nc/k0p
kcgV63GB6D7wHRF4TVe4xIBqKpbBhhN+ISwFN1z+gx3lfyRMSmiTSrGdKEQe
XSIQKG8XZQZUDhLNkqPS+7EMV1g7+lOfT4GhLL68dUXDa1e9YxGH6zkpVECw
Spe3vsHZr6CqFg==
=/vUJ
-----END PGP PUBLIC KEY BLOCK-----
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/af0471be/attachment.html>

From stick at satoshilabs.com  Mon Jan  8 12:39:20 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Mon, 8 Jan 2018 13:39:20 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
Message-ID: <ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>

On 08/01/18 05:22, Gregory Maxwell wrote:
>> https://github.com/satoshilabs/slips/blob/master/slip-0039.md

Hey Gregory!

Thanks for looking into the scheme. I appreciate your time!

> This specification forces the key being used through a one way
> function, -- so you cannot take a pre-existing key and encode it with
> this scheme.

Originally, we used a bi-directional function to be able to encode and
decode the key in both directions using the passphrase. We stretched the
passphrase using KDF and then applied AES or other symmetric cipher

We found the following (theoretical) problem:

If an attacker has knowledge of few words from the beginning of shares,
they are able to reconstruct the beginning of the master secret and if
the size of the reconstruced master secret is bigger then the cipher
blocksize (for block ciphers; for stream ciphers 1 bit is enough), then
they can reconstruct the beginning of the seed.

Can you find a scheme which does not have this problem? Or you think
this problem is not worth solving?

> The KDF it specifies is unconfigurable and fairly weak
> (20000xhmac-sha2-- which can be cracked at about 0.7M passwords a
> second on a single motherboard GPU cracker).

Yes. We want this to be possible to be computed on TREZOR-like devices
on boot, similarly how we compute BIP39 on boot right now.

> The construction also
> will silently result in the user getting a different private key if
> they enter the wrong passphrase-- which could lead to funds loss.

Again, this is by design and it is main point why plausible deniability
is achieved both in BIP39 and SLIP39. If we used a different
construction we'd loose plausible deniability.

> It
> is again, unversioned-- so it kinda of seems like it is intentionally
> constructed in a way that will prevent interoperable use, since the
> lack of versioning was a primary complaint from other perspective
> users.  Of course, it fine if you want to make a trezor only thing,
> but why bother BIPing something that was not intended for
> interoperability?  Even for a single vendor spec the lack of
> versioning seems to make things harder to support new key-related
> features such as segwit.

This is argument I keep having all the time.

Suppose we'd introduce a version to encode PBKDF2 rounds or even
different KDFs. We'll end up with different SLIP39 mnemonics, but they
will not be compatible among implementations (because TREZOR can only up
to 100.000 rounds of PBKDF2 and does not support Argon2 at all, while
other desktop implementation would rather use memory-hard Argon2).

My gut feeling is that this would lead to WORSE interoperability, not
better. Look at BIP32 for example. There are lots of wallet that claim
they are BIP32 compatible, but in reality they use different paths, so
they are not compatible. BIP32 is a good standard, but in reality
"BIP32-compatible" does not mean anything, whereas when you say the
wallet is "BIP44-compatible" you can be sure the migration path works.

> The 16-bit "checksum" based on sha2 seems pretty poor since basing
> small checksums on a cryptographic hash results in a fairly poor
> checksum that is surprisingly likely to accept an errored string. Your
> wordlist is 10 bits and you have much less than 1023*10 bits of input,
> so you could easily have a 20 bit code (two words) which guaranteed
> that up to two errored words would always be detected, and probably
> could choose one which catches three words much more often 1:2^20
> (sipa's crc tools can help find codes like this).

Originally, we wanted to use 16-bit of CRC32 for checksum, but after the
discussion with Daan Sprenkels we were suggested to change this for
cryptographically strong function. The argument was that CRC32 contains
less entropy and mixing high-entropy data (secret) with low-entropy data
(checksum) is not a good idea.

Also, there is an argument between a checksum and ECC. We discussed that
ECC might not be a good idea, because it helps the attacker to compute
missing information, while we only want to check for integrity. Also the
word mnemonic is itself a ECC, because if you see the word "acadornic"
it is probably the word "academic".

> The metadata seems to make fairly little affordance to help users
> avoid accidentally mixing shares from distinct sharings of the same
> key. Is it the idea that this is the only likely cause of a checksum
> error? (1:2^16 chance of silently returning the wrong key seems kinda
> bad). -- I'm not sure much could be done here, though, since
> additional payload is precious.

Yes, checksum is supposed to prevent that.

> As an aside, your specification might want to give some better advice
> about the SSS since my experience virtually everyone gets it wrong in
> ways that degrade or destroy its properties e.g. many fail to generate
> the additional coefficients of the polynominal randomly which results
> in insecurity (see armory for an example).   Oh, also, I believe it is
> normally refereed to as "SSS" (three S)-- four S is the name of a
> linux program for secret sharing.

Will fix the spelling. About the generic advice about SSS, anyone is
welcome to contribute to the text.

> I'm happy to see that there is no obvious way to abuse this one as a
> brainwallet scheme!

Agreed!

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From pete at petertodd.org  Mon Jan  8 12:45:06 2018
From: pete at petertodd.org (Peter Todd)
Date: Mon, 8 Jan 2018 07:45:06 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
Message-ID: <20180108124506.GA13858@savin.petertodd.org>

On Mon, Jan 08, 2018 at 01:39:20PM +0100, Pavol Rusnak via bitcoin-dev wrote:
> > The construction also
> > will silently result in the user getting a different private key if
> > they enter the wrong passphrase-- which could lead to funds loss.
> 
> Again, this is by design and it is main point why plausible deniability
> is achieved both in BIP39 and SLIP39. If we used a different
> construction we'd loose plausible deniability.

Can you explain _exactly_ what scenario the "plausible deniability" feature
refers to?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/a83273e6/attachment.sig>

From stick at satoshilabs.com  Mon Jan  8 13:00:17 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Mon, 8 Jan 2018 14:00:17 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <20180108124506.GA13858@savin.petertodd.org>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<20180108124506.GA13858@savin.petertodd.org>
Message-ID: <5c229def-760a-69eb-e646-bd3c77482b00@satoshilabs.com>

On 08/01/18 13:45, Peter Todd wrote:
> Can you explain _exactly_ what scenario the "plausible deniability" feature
> refers to?


https://doc.satoshilabs.com/trezor-user/advanced_settings.html#multi-passphrase-encryption-hidden-wallets


-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/41cd23c4/attachment.sig>

From nullius at nym.zone  Mon Jan  8 11:13:28 2018
From: nullius at nym.zone (nullius)
Date: Mon, 8 Jan 2018 11:13:28 +0000
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
Message-ID: <eb643e5734bceeb918d116fb75c0d4b3@nym.zone>

On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com> 
wrote:
>This is very sad.
>
>The number one problem in Japan with BIP39 seeds is with English words.
>
>I have seen a 60 year old Japanese man writing down his phrase (because 
>he kept on failing recovery), and watched him write down "aneter" for 
>"amateur"...
>
>[...]
>
>If you understand English and can spell, you read a word, your brain 
>processes the word, and you can spell it on your own when writing down.  
>Not many Japanese people can do that, so they need to copy letter for 
>letter, taking a long time, and still messing up on occasion.
>
>[...]
>
>Defining "everyone should only use English, because ASCII is easier to 
>plan for" is not a good way to move forward as a currency.

Well said.  Thank you for telling of these experiences.  Now please, 
let?s put the shoe on the other foot.

I ask everybody who wants an English-only mnemonic standard to entrust 
*their own money* to their abilities to very, very carefully write this 
down?then later, type it back in:

????????????????????????
??????????????????????????

(Approximate translation:  ?Whatever would you do if Bitcoin had been 
invented by somebody named Satoshi Nakamoto??)

No, wait:  That is only a 12-word mnemonic.  We are probably talking 
about a Trezor; so now, hey you there, stake the backup of your life?s 
savings on your ability to handwrite *this*:

???????????????????????????????????????
???????????????????????????????????????
????????????????????????????????

Ready to bet your money on *that* as a backup phrase in your own hands?  
No?  Then please, stop demanding that others risk *their* money on the 
inverse case.

----

If you cheat here by having studied Japanese, then remember that many 
Japanese people know English and other European languages, too.  Then 
think of how much money would be lost by your non-Japanese-literate 
family and friends?if BIP 39 had only Japanese wordlists, and your folks 
needed to wrestle with the above phrases as their ?mnemonics?.

In such cases, the phrases cannot be called ?mnemonics? at all.  A 
?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing 
system is much worse even than transcribing pseudorandom hex strings.  
The Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, 
was not dealing with a *mnemonic*:  He was using the world?s most 
inefficient means of making cryptic bitstrings *less* userfriendly.

----

I began this thread with a quite simple request:  Is ????? an 
appropriate string for identifying the Japanese language to Japanese 
users?  And what of the other strings I posted for other languages?

I asked this as an implementer working on my own instance of the 
greatest guard against vendor lock-in and stale software:  Independent 
implementations.  ?  I asked, because obviously, I myself do not speak 
all these different languages; and I want to implement them all.  *All.*

Some replies have been interesting in their own right; but thus far, 
nobody has squarely addressed the substance of my question.

Most worrisome is that much of the discussion has veered into criticism 
of multi-language support.  I opened with a question about other 
languages, and I am getting replies which raise a hue and cry of 
?English only!?

Though I am fluent and literate in English, I am uninterested in ever 
implementing any standard of this nature which is artificially 
restricted to English.  I am fortunate; for as of this moment, we have a 
standard called ?BIP 39? which has seven non-English wordlists, and four 
more pending in open pull requests (#432, #442, #493, #621).

I request discussion of language identification strings appropriate for 
use with that standard.

(P.S., I hope that my system did not mangle anything in the foregoing.  
I have seen weird copypaste behaviour mess up decomposed characters.  I 
thought of this after I searched for and collected some visually 
fascinating phrases; so I tried to normalize these to NFC...  It should 
go without saying, easyseed output the Japanese perfectly!)

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/8bba0a34/attachment.sig>

From nullius at nym.zone  Mon Jan  8 06:33:44 2018
From: nullius at nym.zone (nullius)
Date: Mon, 8 Jan 2018 06:33:44 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
Message-ID: <6dbb7b72d167cfe2ee5ad5aedbbfa12f@nym.zone>

On 2018-01-08 at 04:22:43 +0000 Gregory Maxwell <greg at xiph.org> wrote:
>I'm happy to see that there is no obvious way to abuse this one as a 
>brainwallet scheme!

BIP 39 was designed to make brainwallets secure!  If a user generates a 
weakling 12-word mnemonic from 16 tiny octets of entropy drawn off the 
non-artistic /dev/urandom, then protects its seed with a creative 
passphrase haiku about the power of human stupidity, then the result 
will have a 128-bit security level.  PROVE ME WRONG.

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
BIP 39 tool in progress, currently growing brainw^H^H^H^H^Hpassphrase 
support to help poor /dev/urandom: https://github.com/nym-zone/easyseed
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/1992463a/attachment-0001.sig>

From gsanders87 at gmail.com  Mon Jan  8 14:34:39 2018
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 8 Jan 2018 09:34:39 -0500
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
Message-ID: <CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>

Has anyone actually used the multilingual support in bip39?

If a feature of the standard has not been(widely?) used in years, and isn't
supported in any major wallet(?), it seems indicative it was a mistake to
add it in the first place, since it's a footgun in the making for some poor
sap who can't even read English letters when almost all documentation is
written in English.

On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com> wrote:
>
>> This is very sad.
>>
>> The number one problem in Japan with BIP39 seeds is with English words.
>>
>> I have seen a 60 year old Japanese man writing down his phrase (because
>> he kept on failing recovery), and watched him write down "aneter" for
>> "amateur"...
>>
>> [...]
>>
>> If you understand English and can spell, you read a word, your brain
>> processes the word, and you can spell it on your own when writing down.
>> Not many Japanese people can do that, so they need to copy letter for
>> letter, taking a long time, and still messing up on occasion.
>>
>> [...]
>>
>> Defining "everyone should only use English, because ASCII is easier to
>> plan for" is not a good way to move forward as a currency.
>>
>
> Well said.  Thank you for telling of these experiences.  Now please, let?s
> put the shoe on the other foot.
>
> I ask everybody who wants an English-only mnemonic standard to entrust
> *their own money* to their abilities to very, very carefully write this
> down?then later, type it back in:
>
> ??? ??? ??? ??? ???? ???
> ??? ??? ???? ??? ????? ???
>
> (Approximate translation:  ?Whatever would you do if Bitcoin had been
> invented by somebody named Satoshi Nakamoto??)
>
> No, wait:  That is only a 12-word mnemonic.  We are probably talking about
> a Trezor; so now, hey you there, stake the backup of your life?s savings on
> your ability to handwrite *this*:
>
> ??? ???? ???? ??? ???? ??? ??? ???? ???
> ??? ????? ??? ???? ??????? ??? ???? ???
> ??? ???? ???? ??? ??? ????? ????
>
> Ready to bet your money on *that* as a backup phrase in your own hands?
> No?  Then please, stop demanding that others risk *their* money on the
> inverse case.
>
> ----
>
> If you cheat here by having studied Japanese, then remember that many
> Japanese people know English and other European languages, too.  Then think
> of how much money would be lost by your non-Japanese-literate family and
> friends?if BIP 39 had only Japanese wordlists, and your folks needed to
> wrestle with the above phrases as their ?mnemonics?.
>
> In such cases, the phrases cannot be called ?mnemonics? at all.  A
> ?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing
> system is much worse even than transcribing pseudorandom hex strings.  The
> Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, was not
> dealing with a *mnemonic*:  He was using the world?s most inefficient means
> of making cryptic bitstrings *less* userfriendly.
>
> ----
>
> I began this thread with a quite simple request:  Is ????? an appropriate
> string for identifying the Japanese language to Japanese users?  And what
> of the other strings I posted for other languages?
>
> I asked this as an implementer working on my own instance of the greatest
> guard against vendor lock-in and stale software:  Independent
> implementations.  ?  I asked, because obviously, I myself do not speak all
> these different languages; and I want to implement them all.  *All.*
>
> Some replies have been interesting in their own right; but thus far,
> nobody has squarely addressed the substance of my question.
>
> Most worrisome is that much of the discussion has veered into criticism of
> multi-language support.  I opened with a question about other languages,
> and I am getting replies which raise a hue and cry of ?English only!?
>
> Though I am fluent and literate in English, I am uninterested in ever
> implementing any standard of this nature which is artificially restricted
> to English.  I am fortunate; for as of this moment, we have a standard
> called ?BIP 39? which has seven non-English wordlists, and four more
> pending in open pull requests (#432, #442, #493, #621).
>
> I request discussion of language identification strings appropriate for
> use with that standard.
>
> (P.S., I hope that my system did not mangle anything in the foregoing.  I
> have seen weird copypaste behaviour mess up decomposed characters.  I
> thought of this after I searched for and collected some visually
> fascinating phrases; so I tried to normalize these to NFC...  It should go
> without saying, easyseed output the Japanese perfectly!)
>
>
> --
> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
> ??If you?re not doing anything wrong, you have nothing to hide.?
> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/b348f42f/attachment.html>

From gsanders87 at gmail.com  Mon Jan  8 14:54:38 2018
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 8 Jan 2018 09:54:38 -0500
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
	<CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
	<CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>
Message-ID: <CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>

Let me re-phrase: Is it a known thing for users to actually use it?

On Mon, Jan 8, 2018 at 9:52 AM, Matias Alejo Garcia <ematiu at gmail.com>
wrote:

>
>
> On Mon, Jan 8, 2018 at 11:34 AM, Greg Sanders via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Has anyone actually used the multilingual support in bip39?
>>
>
>
> Copay (and all its clones) use it.
>
>
>
>
>
>>
>> If a feature of the standard has not been(widely?) used in years, and
>> isn't supported in any major wallet(?), it seems indicative it was a
>> mistake to add it in the first place, since it's a footgun in the making
>> for some poor sap who can't even read English letters when almost all
>> documentation is written in English.
>>
>> On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com> wrote:
>>>
>>>> This is very sad.
>>>>
>>>> The number one problem in Japan with BIP39 seeds is with English words.
>>>>
>>>> I have seen a 60 year old Japanese man writing down his phrase (because
>>>> he kept on failing recovery), and watched him write down "aneter" for
>>>> "amateur"...
>>>>
>>>> [...]
>>>>
>>>> If you understand English and can spell, you read a word, your brain
>>>> processes the word, and you can spell it on your own when writing down.
>>>> Not many Japanese people can do that, so they need to copy letter for
>>>> letter, taking a long time, and still messing up on occasion.
>>>>
>>>> [...]
>>>>
>>>> Defining "everyone should only use English, because ASCII is easier to
>>>> plan for" is not a good way to move forward as a currency.
>>>>
>>>
>>> Well said.  Thank you for telling of these experiences.  Now please,
>>> let?s put the shoe on the other foot.
>>>
>>> I ask everybody who wants an English-only mnemonic standard to entrust
>>> *their own money* to their abilities to very, very carefully write this
>>> down?then later, type it back in:
>>>
>>> ??? ??? ??? ??? ???? ???
>>> ??? ??? ???? ??? ????? ???
>>>
>>> (Approximate translation:  ?Whatever would you do if Bitcoin had been
>>> invented by somebody named Satoshi Nakamoto??)
>>>
>>> No, wait:  That is only a 12-word mnemonic.  We are probably talking
>>> about a Trezor; so now, hey you there, stake the backup of your life?s
>>> savings on your ability to handwrite *this*:
>>>
>>> ??? ???? ???? ??? ???? ??? ??? ???? ???
>>> ??? ????? ??? ???? ??????? ??? ???? ???
>>> ??? ???? ???? ??? ??? ????? ????
>>>
>>> Ready to bet your money on *that* as a backup phrase in your own hands?
>>> No?  Then please, stop demanding that others risk *their* money on the
>>> inverse case.
>>>
>>> ----
>>>
>>> If you cheat here by having studied Japanese, then remember that many
>>> Japanese people know English and other European languages, too.  Then think
>>> of how much money would be lost by your non-Japanese-literate family and
>>> friends?if BIP 39 had only Japanese wordlists, and your folks needed to
>>> wrestle with the above phrases as their ?mnemonics?.
>>>
>>> In such cases, the phrases cannot be called ?mnemonics? at all.  A
>>> ?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing
>>> system is much worse even than transcribing pseudorandom hex strings.  The
>>> Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, was not
>>> dealing with a *mnemonic*:  He was using the world?s most inefficient means
>>> of making cryptic bitstrings *less* userfriendly.
>>>
>>> ----
>>>
>>> I began this thread with a quite simple request:  Is ????? an
>>> appropriate string for identifying the Japanese language to Japanese
>>> users?  And what of the other strings I posted for other languages?
>>>
>>> I asked this as an implementer working on my own instance of the
>>> greatest guard against vendor lock-in and stale software:  Independent
>>> implementations.  ?  I asked, because obviously, I myself do not speak all
>>> these different languages; and I want to implement them all.  *All.*
>>>
>>> Some replies have been interesting in their own right; but thus far,
>>> nobody has squarely addressed the substance of my question.
>>>
>>> Most worrisome is that much of the discussion has veered into criticism
>>> of multi-language support.  I opened with a question about other languages,
>>> and I am getting replies which raise a hue and cry of ?English only!?
>>>
>>> Though I am fluent and literate in English, I am uninterested in ever
>>> implementing any standard of this nature which is artificially restricted
>>> to English.  I am fortunate; for as of this moment, we have a standard
>>> called ?BIP 39? which has seven non-English wordlists, and four more
>>> pending in open pull requests (#432, #442, #493, #621).
>>>
>>> I request discussion of language identification strings appropriate for
>>> use with that standard.
>>>
>>> (P.S., I hope that my system did not mangle anything in the foregoing.
>>> I have seen weird copypaste behaviour mess up decomposed characters.  I
>>> thought of this after I searched for and collected some visually
>>> fascinating phrases; so I tried to normalize these to NFC...  It should go
>>> without saying, easyseed output the Japanese perfectly!)
>>>
>>>
>>> --
>>> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
>>> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
>>> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
>>> ??If you?re not doing anything wrong, you have nothing to hide.?
>>> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> --
> Mat?as Alejo Garcia
> @ematiu
> Roads? Where we're going, we don't need roads!
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/a95eac7a/attachment-0001.html>

From ematiu at gmail.com  Mon Jan  8 14:52:20 2018
From: ematiu at gmail.com (Matias Alejo Garcia)
Date: Mon, 8 Jan 2018 11:52:20 -0300
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
	<CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
Message-ID: <CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>

On Mon, Jan 8, 2018 at 11:34 AM, Greg Sanders via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Has anyone actually used the multilingual support in bip39?
>


Copay (and all its clones) use it.





>
> If a feature of the standard has not been(widely?) used in years, and
> isn't supported in any major wallet(?), it seems indicative it was a
> mistake to add it in the first place, since it's a footgun in the making
> for some poor sap who can't even read English letters when almost all
> documentation is written in English.
>
> On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com> wrote:
>>
>>> This is very sad.
>>>
>>> The number one problem in Japan with BIP39 seeds is with English words.
>>>
>>> I have seen a 60 year old Japanese man writing down his phrase (because
>>> he kept on failing recovery), and watched him write down "aneter" for
>>> "amateur"...
>>>
>>> [...]
>>>
>>> If you understand English and can spell, you read a word, your brain
>>> processes the word, and you can spell it on your own when writing down.
>>> Not many Japanese people can do that, so they need to copy letter for
>>> letter, taking a long time, and still messing up on occasion.
>>>
>>> [...]
>>>
>>> Defining "everyone should only use English, because ASCII is easier to
>>> plan for" is not a good way to move forward as a currency.
>>>
>>
>> Well said.  Thank you for telling of these experiences.  Now please,
>> let?s put the shoe on the other foot.
>>
>> I ask everybody who wants an English-only mnemonic standard to entrust
>> *their own money* to their abilities to very, very carefully write this
>> down?then later, type it back in:
>>
>> ??? ??? ??? ??? ???? ???
>> ??? ??? ???? ??? ????? ???
>>
>> (Approximate translation:  ?Whatever would you do if Bitcoin had been
>> invented by somebody named Satoshi Nakamoto??)
>>
>> No, wait:  That is only a 12-word mnemonic.  We are probably talking
>> about a Trezor; so now, hey you there, stake the backup of your life?s
>> savings on your ability to handwrite *this*:
>>
>> ??? ???? ???? ??? ???? ??? ??? ???? ???
>> ??? ????? ??? ???? ??????? ??? ???? ???
>> ??? ???? ???? ??? ??? ????? ????
>>
>> Ready to bet your money on *that* as a backup phrase in your own hands?
>> No?  Then please, stop demanding that others risk *their* money on the
>> inverse case.
>>
>> ----
>>
>> If you cheat here by having studied Japanese, then remember that many
>> Japanese people know English and other European languages, too.  Then think
>> of how much money would be lost by your non-Japanese-literate family and
>> friends?if BIP 39 had only Japanese wordlists, and your folks needed to
>> wrestle with the above phrases as their ?mnemonics?.
>>
>> In such cases, the phrases cannot be called ?mnemonics? at all.  A
>> ?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing
>> system is much worse even than transcribing pseudorandom hex strings.  The
>> Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, was not
>> dealing with a *mnemonic*:  He was using the world?s most inefficient means
>> of making cryptic bitstrings *less* userfriendly.
>>
>> ----
>>
>> I began this thread with a quite simple request:  Is ????? an appropriate
>> string for identifying the Japanese language to Japanese users?  And what
>> of the other strings I posted for other languages?
>>
>> I asked this as an implementer working on my own instance of the greatest
>> guard against vendor lock-in and stale software:  Independent
>> implementations.  ?  I asked, because obviously, I myself do not speak all
>> these different languages; and I want to implement them all.  *All.*
>>
>> Some replies have been interesting in their own right; but thus far,
>> nobody has squarely addressed the substance of my question.
>>
>> Most worrisome is that much of the discussion has veered into criticism
>> of multi-language support.  I opened with a question about other languages,
>> and I am getting replies which raise a hue and cry of ?English only!?
>>
>> Though I am fluent and literate in English, I am uninterested in ever
>> implementing any standard of this nature which is artificially restricted
>> to English.  I am fortunate; for as of this moment, we have a standard
>> called ?BIP 39? which has seven non-English wordlists, and four more
>> pending in open pull requests (#432, #442, #493, #621).
>>
>> I request discussion of language identification strings appropriate for
>> use with that standard.
>>
>> (P.S., I hope that my system did not mangle anything in the foregoing.  I
>> have seen weird copypaste behaviour mess up decomposed characters.  I
>> thought of this after I searched for and collected some visually
>> fascinating phrases; so I tried to normalize these to NFC...  It should go
>> without saying, easyseed output the Japanese perfectly!)
>>
>>
>> --
>> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
>> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
>> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
>> ??If you?re not doing anything wrong, you have nothing to hide.?
>> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Mat?as Alejo Garcia
@ematiu
Roads? Where we're going, we don't need roads!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/eaa842ab/attachment.html>

From ematiu at gmail.com  Mon Jan  8 15:23:53 2018
From: ematiu at gmail.com (Matias Alejo Garcia)
Date: Mon, 8 Jan 2018 12:23:53 -0300
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
	<CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
	<CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>
	<CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>
Message-ID: <CA+vKqYckHe-8dfZw0ktxNvqQP4XYHHKUJwfwsYhvYyj3BfOCkg@mail.gmail.com>

> Let me re-phrase: Is it a known thing for users to actually use it?

yes. Based on language stats from the app stores, roughly 30% to 40% of
Copay users have their backup on a language
other than English, and we constantly get requests to support new languages
in BIP39.

On Mon, Jan 8, 2018 at 11:54 AM, Greg Sanders <gsanders87 at gmail.com> wrote:

> Let me re-phrase: Is it a known thing for users to actually use it?
>
> On Mon, Jan 8, 2018 at 9:52 AM, Matias Alejo Garcia <ematiu at gmail.com>
> wrote:
>
>>
>>
>> On Mon, Jan 8, 2018 at 11:34 AM, Greg Sanders via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> Has anyone actually used the multilingual support in bip39?
>>>
>>
>>
>> Copay (and all its clones) use it.
>>
>>
>>
>>
>>
>>>
>>> If a feature of the standard has not been(widely?) used in years, and
>>> isn't supported in any major wallet(?), it seems indicative it was a
>>> mistake to add it in the first place, since it's a footgun in the making
>>> for some poor sap who can't even read English letters when almost all
>>> documentation is written in English.
>>>
>>> On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com>
>>>> wrote:
>>>>
>>>>> This is very sad.
>>>>>
>>>>> The number one problem in Japan with BIP39 seeds is with English words.
>>>>>
>>>>> I have seen a 60 year old Japanese man writing down his phrase
>>>>> (because he kept on failing recovery), and watched him write down "aneter"
>>>>> for "amateur"...
>>>>>
>>>>> [...]
>>>>>
>>>>> If you understand English and can spell, you read a word, your brain
>>>>> processes the word, and you can spell it on your own when writing down.
>>>>> Not many Japanese people can do that, so they need to copy letter for
>>>>> letter, taking a long time, and still messing up on occasion.
>>>>>
>>>>> [...]
>>>>>
>>>>> Defining "everyone should only use English, because ASCII is easier to
>>>>> plan for" is not a good way to move forward as a currency.
>>>>>
>>>>
>>>> Well said.  Thank you for telling of these experiences.  Now please,
>>>> let?s put the shoe on the other foot.
>>>>
>>>> I ask everybody who wants an English-only mnemonic standard to entrust
>>>> *their own money* to their abilities to very, very carefully write this
>>>> down?then later, type it back in:
>>>>
>>>> ??? ??? ??? ??? ???? ???
>>>> ??? ??? ???? ??? ????? ???
>>>>
>>>> (Approximate translation:  ?Whatever would you do if Bitcoin had been
>>>> invented by somebody named Satoshi Nakamoto??)
>>>>
>>>> No, wait:  That is only a 12-word mnemonic.  We are probably talking
>>>> about a Trezor; so now, hey you there, stake the backup of your life?s
>>>> savings on your ability to handwrite *this*:
>>>>
>>>> ??? ???? ???? ??? ???? ??? ??? ???? ???
>>>> ??? ????? ??? ???? ??????? ??? ???? ???
>>>> ??? ???? ???? ??? ??? ????? ????
>>>>
>>>> Ready to bet your money on *that* as a backup phrase in your own
>>>> hands?  No?  Then please, stop demanding that others risk *their* money on
>>>> the inverse case.
>>>>
>>>> ----
>>>>
>>>> If you cheat here by having studied Japanese, then remember that many
>>>> Japanese people know English and other European languages, too.  Then think
>>>> of how much money would be lost by your non-Japanese-literate family and
>>>> friends?if BIP 39 had only Japanese wordlists, and your folks needed to
>>>> wrestle with the above phrases as their ?mnemonics?.
>>>>
>>>> In such cases, the phrases cannot be called ?mnemonics? at all.  A
>>>> ?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing
>>>> system is much worse even than transcribing pseudorandom hex strings.  The
>>>> Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, was not
>>>> dealing with a *mnemonic*:  He was using the world?s most inefficient means
>>>> of making cryptic bitstrings *less* userfriendly.
>>>>
>>>> ----
>>>>
>>>> I began this thread with a quite simple request:  Is ????? an
>>>> appropriate string for identifying the Japanese language to Japanese
>>>> users?  And what of the other strings I posted for other languages?
>>>>
>>>> I asked this as an implementer working on my own instance of the
>>>> greatest guard against vendor lock-in and stale software:  Independent
>>>> implementations.  ?  I asked, because obviously, I myself do not speak all
>>>> these different languages; and I want to implement them all.  *All.*
>>>>
>>>> Some replies have been interesting in their own right; but thus far,
>>>> nobody has squarely addressed the substance of my question.
>>>>
>>>> Most worrisome is that much of the discussion has veered into criticism
>>>> of multi-language support.  I opened with a question about other languages,
>>>> and I am getting replies which raise a hue and cry of ?English only!?
>>>>
>>>> Though I am fluent and literate in English, I am uninterested in ever
>>>> implementing any standard of this nature which is artificially restricted
>>>> to English.  I am fortunate; for as of this moment, we have a standard
>>>> called ?BIP 39? which has seven non-English wordlists, and four more
>>>> pending in open pull requests (#432, #442, #493, #621).
>>>>
>>>> I request discussion of language identification strings appropriate for
>>>> use with that standard.
>>>>
>>>> (P.S., I hope that my system did not mangle anything in the foregoing.
>>>> I have seen weird copypaste behaviour mess up decomposed characters.  I
>>>> thought of this after I searched for and collected some visually
>>>> fascinating phrases; so I tried to normalize these to NFC...  It should go
>>>> without saying, easyseed output the Japanese perfectly!)
>>>>
>>>>
>>>> --
>>>> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
>>>> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
>>>> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
>>>> ??If you?re not doing anything wrong, you have nothing to hide.?
>>>> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>>
>>>
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>>
>>
>>
>> --
>> Mat?as Alejo Garcia
>> @ematiu
>> Roads? Where we're going, we don't need roads!
>>
>
>


-- 
Mat?as Alejo Garcia
@ematiu
Roads? Where we're going, we don't need roads!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/6928a411/attachment-0001.html>

From ajwest at gmail.com  Mon Jan  8 15:26:38 2018
From: ajwest at gmail.com (AJ West)
Date: Mon, 8 Jan 2018 10:26:38 -0500
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <CA+vKqYckHe-8dfZw0ktxNvqQP4XYHHKUJwfwsYhvYyj3BfOCkg@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
	<CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
	<CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>
	<CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>
	<CA+vKqYckHe-8dfZw0ktxNvqQP4XYHHKUJwfwsYhvYyj3BfOCkg@mail.gmail.com>
Message-ID: <CABXVU6aa-CHzyWOgefzz5XgTS8vNUOUPbo4aWH4i0FZH=xFr9w@mail.gmail.com>

Greg yes, there were already examples in this very thread of people
explaining how they use languages other than English. I'm shocked that so
many people are resisting the idea that just *maybe* there could be people
in other parts of the world who do not want to use or cannot use the strict
set of latin characters and words from the English language.

I agree with Sjors and maybe I'm simplifying too much, but can't we just
map an existing ISO/UTF language character standard to the seeds? Why is
there a word list at all? Choose a flexible encoding standard, create a
clever map to the bytes, make sure to include a checksum.

As an aside, I know there are some conventions which add space for error
correction but I personally don't love the idea of somebody inputting what
they think is the proper seed, only to have it auto-corrected and thus
reinforcing their erroneously saved/written seed backup.

Pavol, why do you say "I learned that it was something I should've been
more persistently against?" I still can't see any good arguments as to why
we should limit this to English other than "It's easier to support a single
language" which comes at the cost of "It's hard for me to backup my seed"
for those who don't speak English.

On Mon, Jan 8, 2018 at 10:23 AM, Matias Alejo Garcia via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> > Let me re-phrase: Is it a known thing for users to actually use it?
>
> yes. Based on language stats from the app stores, roughly 30% to 40% of
> Copay users have their backup on a language
> other than English, and we constantly get requests to support new
> languages in BIP39.
>
> On Mon, Jan 8, 2018 at 11:54 AM, Greg Sanders <gsanders87 at gmail.com>
> wrote:
>
>> Let me re-phrase: Is it a known thing for users to actually use it?
>>
>> On Mon, Jan 8, 2018 at 9:52 AM, Matias Alejo Garcia <ematiu at gmail.com>
>> wrote:
>>
>>>
>>>
>>> On Mon, Jan 8, 2018 at 11:34 AM, Greg Sanders via bitcoin-dev <
>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> Has anyone actually used the multilingual support in bip39?
>>>>
>>>
>>>
>>> Copay (and all its clones) use it.
>>>
>>>
>>>
>>>
>>>
>>>>
>>>> If a feature of the standard has not been(widely?) used in years, and
>>>> isn't supported in any major wallet(?), it seems indicative it was a
>>>> mistake to add it in the first place, since it's a footgun in the making
>>>> for some poor sap who can't even read English letters when almost all
>>>> documentation is written in English.
>>>>
>>>> On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com>
>>>>> wrote:
>>>>>
>>>>>> This is very sad.
>>>>>>
>>>>>> The number one problem in Japan with BIP39 seeds is with English
>>>>>> words.
>>>>>>
>>>>>> I have seen a 60 year old Japanese man writing down his phrase
>>>>>> (because he kept on failing recovery), and watched him write down "aneter"
>>>>>> for "amateur"...
>>>>>>
>>>>>> [...]
>>>>>>
>>>>>> If you understand English and can spell, you read a word, your brain
>>>>>> processes the word, and you can spell it on your own when writing down.
>>>>>> Not many Japanese people can do that, so they need to copy letter for
>>>>>> letter, taking a long time, and still messing up on occasion.
>>>>>>
>>>>>> [...]
>>>>>>
>>>>>> Defining "everyone should only use English, because ASCII is easier
>>>>>> to plan for" is not a good way to move forward as a currency.
>>>>>>
>>>>>
>>>>> Well said.  Thank you for telling of these experiences.  Now please,
>>>>> let?s put the shoe on the other foot.
>>>>>
>>>>> I ask everybody who wants an English-only mnemonic standard to entrust
>>>>> *their own money* to their abilities to very, very carefully write this
>>>>> down?then later, type it back in:
>>>>>
>>>>> ??? ??? ??? ??? ???? ???
>>>>> ??? ??? ???? ??? ????? ???
>>>>>
>>>>> (Approximate translation:  ?Whatever would you do if Bitcoin had been
>>>>> invented by somebody named Satoshi Nakamoto??)
>>>>>
>>>>> No, wait:  That is only a 12-word mnemonic.  We are probably talking
>>>>> about a Trezor; so now, hey you there, stake the backup of your life?s
>>>>> savings on your ability to handwrite *this*:
>>>>>
>>>>> ??? ???? ???? ??? ???? ??? ??? ???? ???
>>>>> ??? ????? ??? ???? ??????? ??? ???? ???
>>>>> ??? ???? ???? ??? ??? ????? ????
>>>>>
>>>>> Ready to bet your money on *that* as a backup phrase in your own
>>>>> hands?  No?  Then please, stop demanding that others risk *their* money on
>>>>> the inverse case.
>>>>>
>>>>> ----
>>>>>
>>>>> If you cheat here by having studied Japanese, then remember that many
>>>>> Japanese people know English and other European languages, too.  Then think
>>>>> of how much money would be lost by your non-Japanese-literate family and
>>>>> friends?if BIP 39 had only Japanese wordlists, and your folks needed to
>>>>> wrestle with the above phrases as their ?mnemonics?.
>>>>>
>>>>> In such cases, the phrases cannot be called ?mnemonics? at all.  A
>>>>> ?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing
>>>>> system is much worse even than transcribing pseudorandom hex strings.  The
>>>>> Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, was not
>>>>> dealing with a *mnemonic*:  He was using the world?s most inefficient means
>>>>> of making cryptic bitstrings *less* userfriendly.
>>>>>
>>>>> ----
>>>>>
>>>>> I began this thread with a quite simple request:  Is ????? an
>>>>> appropriate string for identifying the Japanese language to Japanese
>>>>> users?  And what of the other strings I posted for other languages?
>>>>>
>>>>> I asked this as an implementer working on my own instance of the
>>>>> greatest guard against vendor lock-in and stale software:  Independent
>>>>> implementations.  ?  I asked, because obviously, I myself do not speak all
>>>>> these different languages; and I want to implement them all.  *All.*
>>>>>
>>>>> Some replies have been interesting in their own right; but thus far,
>>>>> nobody has squarely addressed the substance of my question.
>>>>>
>>>>> Most worrisome is that much of the discussion has veered into
>>>>> criticism of multi-language support.  I opened with a question about other
>>>>> languages, and I am getting replies which raise a hue and cry of ?English
>>>>> only!?
>>>>>
>>>>> Though I am fluent and literate in English, I am uninterested in ever
>>>>> implementing any standard of this nature which is artificially restricted
>>>>> to English.  I am fortunate; for as of this moment, we have a standard
>>>>> called ?BIP 39? which has seven non-English wordlists, and four more
>>>>> pending in open pull requests (#432, #442, #493, #621).
>>>>>
>>>>> I request discussion of language identification strings appropriate
>>>>> for use with that standard.
>>>>>
>>>>> (P.S., I hope that my system did not mangle anything in the
>>>>> foregoing.  I have seen weird copypaste behaviour mess up decomposed
>>>>> characters.  I thought of this after I searched for and collected some
>>>>> visually fascinating phrases; so I tried to normalize these to NFC...  It
>>>>> should go without saying, easyseed output the Japanese perfectly!)
>>>>>
>>>>>
>>>>> --
>>>>> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
>>>>> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
>>>>> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
>>>>> ??If you?re not doing anything wrong, you have nothing to hide.?
>>>>> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>>>>>
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>>>>
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>
>>>>
>>>
>>>
>>> --
>>> Mat?as Alejo Garcia
>>> @ematiu
>>> Roads? Where we're going, we don't need roads!
>>>
>>
>>
>
>
> --
> Mat?as Alejo Garcia
> @ematiu
> Roads? Where we're going, we don't need roads!
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/67000d6f/attachment.html>

From gsanders87 at gmail.com  Mon Jan  8 15:32:58 2018
From: gsanders87 at gmail.com (Greg Sanders)
Date: Mon, 8 Jan 2018 10:32:58 -0500
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
	wordlists
In-Reply-To: <CABXVU6aa-CHzyWOgefzz5XgTS8vNUOUPbo4aWH4i0FZH=xFr9w@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
	<CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
	<CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>
	<CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>
	<CA+vKqYckHe-8dfZw0ktxNvqQP4XYHHKUJwfwsYhvYyj3BfOCkg@mail.gmail.com>
	<CABXVU6aa-CHzyWOgefzz5XgTS8vNUOUPbo4aWH4i0FZH=xFr9w@mail.gmail.com>
Message-ID: <CAB3F3DskrNYLBrq58saQD1++Tad3JS11vCrXdJcpgqyNwfu8pg@mail.gmail.com>

>I'm shocked that so many people are resisting the idea that just *maybe* there
could be people in other parts of the world who do not want to use or
cannot use the strict set of latin characters and words from the English
language.


You're mistaking concern for users potentially losing money with disdain
for them. I can read a few languages, yet I would not advise users to use a
wordlist that might not have support across multiple wallet
implementations, resulting in lock-in or worse.

If I'm wrong, great, more people can use software strictly in their native
language in a safe manner!

On Mon, Jan 8, 2018 at 10:26 AM, AJ West <ajwest at gmail.com> wrote:

> Greg yes, there were already examples in this very thread of people
> explaining how they use languages other than English. I'm shocked that so
> many people are resisting the idea that just *maybe* there could be
> people in other parts of the world who do not want to use or cannot use the
> strict set of latin characters and words from the English language.
>
> I agree with Sjors and maybe I'm simplifying too much, but can't we just
> map an existing ISO/UTF language character standard to the seeds? Why is
> there a word list at all? Choose a flexible encoding standard, create a
> clever map to the bytes, make sure to include a checksum.
>
> As an aside, I know there are some conventions which add space for error
> correction but I personally don't love the idea of somebody inputting what
> they think is the proper seed, only to have it auto-corrected and thus
> reinforcing their erroneously saved/written seed backup.
>
> Pavol, why do you say "I learned that it was something I should've been
> more persistently against?" I still can't see any good arguments as to why
> we should limit this to English other than "It's easier to support a single
> language" which comes at the cost of "It's hard for me to backup my seed"
> for those who don't speak English.
>
> On Mon, Jan 8, 2018 at 10:23 AM, Matias Alejo Garcia via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> > Let me re-phrase: Is it a known thing for users to actually use it?
>>
>> yes. Based on language stats from the app stores, roughly 30% to 40% of
>> Copay users have their backup on a language
>> other than English, and we constantly get requests to support new
>> languages in BIP39.
>>
>> On Mon, Jan 8, 2018 at 11:54 AM, Greg Sanders <gsanders87 at gmail.com>
>> wrote:
>>
>>> Let me re-phrase: Is it a known thing for users to actually use it?
>>>
>>> On Mon, Jan 8, 2018 at 9:52 AM, Matias Alejo Garcia <ematiu at gmail.com>
>>> wrote:
>>>
>>>>
>>>>
>>>> On Mon, Jan 8, 2018 at 11:34 AM, Greg Sanders via bitcoin-dev <
>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>
>>>>> Has anyone actually used the multilingual support in bip39?
>>>>>
>>>>
>>>>
>>>> Copay (and all its clones) use it.
>>>>
>>>>
>>>>
>>>>
>>>>
>>>>>
>>>>> If a feature of the standard has not been(widely?) used in years, and
>>>>> isn't supported in any major wallet(?), it seems indicative it was a
>>>>> mistake to add it in the first place, since it's a footgun in the making
>>>>> for some poor sap who can't even read English letters when almost all
>>>>> documentation is written in English.
>>>>>
>>>>> On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev <
>>>>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>>
>>>>>> On 2018-01-08 at 07:35:52 +0000, ?????? <kinoshitajona at gmail.com>
>>>>>> wrote:
>>>>>>
>>>>>>> This is very sad.
>>>>>>>
>>>>>>> The number one problem in Japan with BIP39 seeds is with English
>>>>>>> words.
>>>>>>>
>>>>>>> I have seen a 60 year old Japanese man writing down his phrase
>>>>>>> (because he kept on failing recovery), and watched him write down "aneter"
>>>>>>> for "amateur"...
>>>>>>>
>>>>>>> [...]
>>>>>>>
>>>>>>> If you understand English and can spell, you read a word, your brain
>>>>>>> processes the word, and you can spell it on your own when writing down.
>>>>>>> Not many Japanese people can do that, so they need to copy letter for
>>>>>>> letter, taking a long time, and still messing up on occasion.
>>>>>>>
>>>>>>> [...]
>>>>>>>
>>>>>>> Defining "everyone should only use English, because ASCII is easier
>>>>>>> to plan for" is not a good way to move forward as a currency.
>>>>>>>
>>>>>>
>>>>>> Well said.  Thank you for telling of these experiences.  Now please,
>>>>>> let?s put the shoe on the other foot.
>>>>>>
>>>>>> I ask everybody who wants an English-only mnemonic standard to
>>>>>> entrust *their own money* to their abilities to very, very carefully write
>>>>>> this down?then later, type it back in:
>>>>>>
>>>>>> ??? ??? ??? ??? ???? ???
>>>>>> ??? ??? ???? ??? ????? ???
>>>>>>
>>>>>> (Approximate translation:  ?Whatever would you do if Bitcoin had been
>>>>>> invented by somebody named Satoshi Nakamoto??)
>>>>>>
>>>>>> No, wait:  That is only a 12-word mnemonic.  We are probably talking
>>>>>> about a Trezor; so now, hey you there, stake the backup of your life?s
>>>>>> savings on your ability to handwrite *this*:
>>>>>>
>>>>>> ??? ???? ???? ??? ???? ??? ??? ???? ???
>>>>>> ??? ????? ??? ???? ??????? ??? ???? ???
>>>>>> ??? ???? ???? ??? ??? ????? ????
>>>>>>
>>>>>> Ready to bet your money on *that* as a backup phrase in your own
>>>>>> hands?  No?  Then please, stop demanding that others risk *their* money on
>>>>>> the inverse case.
>>>>>>
>>>>>> ----
>>>>>>
>>>>>> If you cheat here by having studied Japanese, then remember that many
>>>>>> Japanese people know English and other European languages, too.  Then think
>>>>>> of how much money would be lost by your non-Japanese-literate family and
>>>>>> friends?if BIP 39 had only Japanese wordlists, and your folks needed to
>>>>>> wrestle with the above phrases as their ?mnemonics?.
>>>>>>
>>>>>> In such cases, the phrases cannot be called ?mnemonics? at all.  A
>>>>>> ?mnemonic? implies aid to memory.  Gibberish in a wholly alien writing
>>>>>> system is much worse even than transcribing pseudorandom hex strings.  The
>>>>>> Japanese man in the quoted story, who wrote ?aneter? for ?amateur?, was not
>>>>>> dealing with a *mnemonic*:  He was using the world?s most inefficient means
>>>>>> of making cryptic bitstrings *less* userfriendly.
>>>>>>
>>>>>> ----
>>>>>>
>>>>>> I began this thread with a quite simple request:  Is ????? an
>>>>>> appropriate string for identifying the Japanese language to Japanese
>>>>>> users?  And what of the other strings I posted for other languages?
>>>>>>
>>>>>> I asked this as an implementer working on my own instance of the
>>>>>> greatest guard against vendor lock-in and stale software:  Independent
>>>>>> implementations.  ?  I asked, because obviously, I myself do not speak all
>>>>>> these different languages; and I want to implement them all.  *All.*
>>>>>>
>>>>>> Some replies have been interesting in their own right; but thus far,
>>>>>> nobody has squarely addressed the substance of my question.
>>>>>>
>>>>>> Most worrisome is that much of the discussion has veered into
>>>>>> criticism of multi-language support.  I opened with a question about other
>>>>>> languages, and I am getting replies which raise a hue and cry of ?English
>>>>>> only!?
>>>>>>
>>>>>> Though I am fluent and literate in English, I am uninterested in ever
>>>>>> implementing any standard of this nature which is artificially restricted
>>>>>> to English.  I am fortunate; for as of this moment, we have a standard
>>>>>> called ?BIP 39? which has seven non-English wordlists, and four more
>>>>>> pending in open pull requests (#432, #442, #493, #621).
>>>>>>
>>>>>> I request discussion of language identification strings appropriate
>>>>>> for use with that standard.
>>>>>>
>>>>>> (P.S., I hope that my system did not mangle anything in the
>>>>>> foregoing.  I have seen weird copypaste behaviour mess up decomposed
>>>>>> characters.  I thought of this after I searched for and collected some
>>>>>> visually fascinating phrases; so I tried to normalize these to NFC...  It
>>>>>> should go without saying, easyseed output the Japanese perfectly!)
>>>>>>
>>>>>>
>>>>>> --
>>>>>> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00
>>>>>> 591B2F307E0C
>>>>>> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
>>>>>> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
>>>>>> ??If you?re not doing anything wrong, you have nothing to hide.?
>>>>>> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>>>>>>
>>>>>> _______________________________________________
>>>>>> bitcoin-dev mailing list
>>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>>
>>>>>>
>>>>>
>>>>> _______________________________________________
>>>>> bitcoin-dev mailing list
>>>>> bitcoin-dev at lists.linuxfoundation.org
>>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>>>
>>>>>
>>>>
>>>>
>>>> --
>>>> Mat?as Alejo Garcia
>>>> @ematiu
>>>> Roads? Where we're going, we don't need roads!
>>>>
>>>
>>>
>>
>>
>> --
>> Mat?as Alejo Garcia
>> @ematiu
>> Roads? Where we're going, we don't need roads!
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/97965c8c/attachment-0001.html>

From vitteaymeric at gmail.com  Mon Jan  8 16:02:02 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Mon, 8 Jan 2018 17:02:02 +0100
Subject: [bitcoin-dev] BIP 39: Add language identifier strings for
 wordlists
In-Reply-To: <CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>
References: <57f5fcd8644c6f6472cd6a91144a6152@nym.zone>
	<d05bfa26-4f3d-77d1-5801-9ad59497f334@satoshilabs.com>
	<CACvEmnGcN+VtgK0MeRPBevRoMkyJrMOBQKLZP4NnLBc5+q8Cyg@mail.gmail.com>
	<eb643e5734bceeb918d116fb75c0d4b3@nym.zone>
	<CAB3F3DvcjSRHLYv16SsSb22TxyfdMrsKW-Z4pChEiuTmhG3KYQ@mail.gmail.com>
	<CA+vKqYfo-G4oS4jZpL1_7sx9aTVKcje9NdjCs3Pu9JwW5-GTMQ@mail.gmail.com>
	<CAB3F3DsifkaCVE1xFvvn8+b-ixpq-NqmGd1vAS8V8niB9YLQsA@mail.gmail.com>
Message-ID: <a1572b86-a7ea-8c4e-21ec-f31c25614cde@gmail.com>

That's the point indeed and the scope is wider than XYZIP-39, even if
what I mean is the very contrary of your point (really bitcoin is
reserved to an elite understanding english/ascii letters?)

This proposal is tailor made for Trezor and does not simplify anything
for people, that's the contrary again

As I suggested in another response to this thread (which was moderated
due probably to some uninteresting parts of the discussion) it's time to
take a break and really make a survey worldwide of what people need,
what they understand and what they need to secure their coins, nobody
has any feedback about this (and maybe does not even care)

Wallets created a big mess implementing non standard things (or things
they thought standard but that are not), or things not intended for the
final use, or things that people can't understand, it's time to correct
this, unless wallets want to keep people tied forever to them (when I
read Trezor or other wallets docs, it's quite misleading, "sending coins
to your wallet", what does it mean? Nothing, and people think it means
something, this should stop now)

And again, I don't see the point of wordlist (in addition in a language
that they don't understand) compared to backing up a 32B hex string
(that you can encrypt different ways at different places), assuming that
the hex format can be made available in all languages

"yet I would not advise users to use a wordlist that might not have
support across multiple wallet implementations, resulting in lock-in or
worse"--> this single sentence shows how the whole model is wrong and
how you think that you can lock people

Le 08/01/2018 ? 15:54, Greg Sanders via bitcoin-dev a ?crit?:
> Let me re-phrase: Is it a known thing for users to actually use it?
>
> On Mon, Jan 8, 2018 at 9:52 AM, Matias Alejo Garcia <ematiu at gmail.com
> <mailto:ematiu at gmail.com>> wrote:
>
>
>
>     On Mon, Jan 8, 2018 at 11:34 AM, Greg Sanders via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>         Has anyone actually used the multilingual support in bip39?
>
>
>
>     Copay (and all its clones) use it.?
>
>
>
>     ?
>
>
>         If a feature of the standard has not been(widely?) used in
>         years, and isn't supported in any major wallet(?), it seems
>         indicative it was a mistake to add it in the first place,
>         since it's a footgun in the making for some poor sap who can't
>         even read English letters when almost all documentation is
>         written in English.
>
>         On Mon, Jan 8, 2018 at 6:13 AM, nullius via bitcoin-dev
>         <bitcoin-dev at lists.linuxfoundation.org
>         <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
>
>             On 2018-01-08 at 07:35:52 +0000, ??????
>             <kinoshitajona at gmail.com <mailto:kinoshitajona at gmail.com>>
>             wrote:
>
>                 This is very sad.
>
>                 The number one problem in Japan with BIP39 seeds is
>                 with English words.
>
>                 I have seen a 60 year old Japanese man writing down
>                 his phrase (because he kept on failing recovery), and
>                 watched him write down "aneter" for "amateur"...
>
>                 [...]
>
>                 If you understand English and can spell, you read a
>                 word, your brain processes the word, and you can spell
>                 it on your own when writing down.? Not many Japanese
>                 people can do that, so they need to copy letter for
>                 letter, taking a long time, and still messing up on
>                 occasion.
>
>                 [...]
>
>                 Defining "everyone should only use English, because
>                 ASCII is easier to plan for" is not a good way to move
>                 forward as a currency.
>
>
>             Well said.? Thank you for telling of these experiences.?
>             Now please, let?s put the shoe on the other foot.
>
>             I ask everybody who wants an English-only mnemonic
>             standard to entrust *their own money* to their abilities
>             to very, very carefully write this down?then later, type
>             it back in:
>
>             ????????????????????????
>             ??????????????????????????
>
>             (Approximate translation:? ?Whatever would you do if
>             Bitcoin had been invented by somebody named Satoshi
>             Nakamoto??)
>
>             No, wait:? That is only a 12-word mnemonic.? We are
>             probably talking about a Trezor; so now, hey you there,
>             stake the backup of your life?s savings on your ability to
>             handwrite *this*:
>
>             ???????????????????????????????????????
>             ???????????????????????????????????????
>             ????????????????????????????????
>
>             Ready to bet your money on *that* as a backup phrase in
>             your own hands?? No?? Then please, stop demanding that
>             others risk *their* money on the inverse case.
>
>             ----
>
>             If you cheat here by having studied Japanese, then
>             remember that many Japanese people know English and other
>             European languages, too.? Then think of how much money
>             would be lost by your non-Japanese-literate family and
>             friends?if BIP 39 had only Japanese wordlists, and your
>             folks needed to wrestle with the above phrases as their
>             ?mnemonics?.
>
>             In such cases, the phrases cannot be called ?mnemonics? at
>             all.? A ?mnemonic? implies aid to memory.? Gibberish in a
>             wholly alien writing system is much worse even than
>             transcribing pseudorandom hex strings.? The Japanese man
>             in the quoted story, who wrote ?aneter? for ?amateur?, was
>             not dealing with a *mnemonic*:? He was using the world?s
>             most inefficient means of making cryptic bitstrings *less*
>             userfriendly.
>
>             ----
>
>             I began this thread with a quite simple request:? Is ?????
>             an appropriate string for identifying the Japanese
>             language to Japanese users?? And what of the other strings
>             I posted for other languages?
>
>             I asked this as an implementer working on my own instance
>             of the greatest guard against vendor lock-in and stale
>             software:? Independent implementations.? ?? I asked,
>             because obviously, I myself do not speak all these
>             different languages; and I want to implement them all.? *All.*
>
>             Some replies have been interesting in their own right; but
>             thus far, nobody has squarely addressed the substance of
>             my question.
>
>             Most worrisome is that much of the discussion has veered
>             into criticism of multi-language support.? I opened with a
>             question about other languages, and I am getting replies
>             which raise a hue and cry of ?English only!?
>
>             Though I am fluent and literate in English, I am
>             uninterested in ever implementing any standard of this
>             nature which is artificially restricted to English.? I am
>             fortunate; for as of this moment, we have a standard
>             called ?BIP 39? which has seven non-English wordlists, and
>             four more pending in open pull requests (#432, #442, #493,
>             #621).
>
>             I request discussion of language identification strings
>             appropriate for use with that standard.
>
>             (P.S., I hope that my system did not mangle anything in
>             the foregoing.? I have seen weird copypaste behaviour mess
>             up decomposed characters.? I thought of this after I
>             searched for and collected some visually fascinating
>             phrases; so I tried to normalize these to NFC...? It
>             should go without saying, easyseed output the Japanese
>             perfectly!)
>
>
>             -- 
>             nullius at nym.zone | PGP ECC:
>             0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
>             Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h |
>             (Segwit nested:
>             3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)? (PGP RSA:
>             0x36EBB4AB699A10EE)
>             ??If you?re not doing anything wrong, you have nothing to
>             hide.?
>             No!? Because I do nothing wrong, I have nothing to show.?
>             ? nullius
>
>             _______________________________________________
>             bitcoin-dev mailing list
>             bitcoin-dev at lists.linuxfoundation.org
>             <mailto:bitcoin-dev at lists.linuxfoundation.org>
>             https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>             <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>
>
>
>         _______________________________________________
>         bitcoin-dev mailing list
>         bitcoin-dev at lists.linuxfoundation.org
>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>
>
>
>
>     -- 
>     Mat?as Alejo Garcia
>     @ematiu
>     Roads? Where we're going, we don't need roads!
>
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/605d1ef0/attachment-0001.html>

From pete at petertodd.org  Mon Jan  8 19:37:14 2018
From: pete at petertodd.org (Peter Todd)
Date: Mon, 8 Jan 2018 14:37:14 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <5c229def-760a-69eb-e646-bd3c77482b00@satoshilabs.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<20180108124506.GA13858@savin.petertodd.org>
	<5c229def-760a-69eb-e646-bd3c77482b00@satoshilabs.com>
Message-ID: <20180108193714.GA15359@savin.petertodd.org>

On Mon, Jan 08, 2018 at 02:00:17PM +0100, Pavol Rusnak wrote:
> On 08/01/18 13:45, Peter Todd wrote:
> > Can you explain _exactly_ what scenario the "plausible deniability" feature
> > refers to?
> 
> 
> https://doc.satoshilabs.com/trezor-user/advanced_settings.html#multi-passphrase-encryption-hidden-wallets

This sounds very dangerous. As Gregory Maxwell pointed out, the key derivation
function is weak enough that passphrases could be easily brute forced, at which
point the bad guys have cryptographic proof that you tried to lie to them and
cover up funds.


What model of human memory are you assuming here? What specifically are you
assuming is easy to remember, and hard to remember? What psychology research
backs up your assumptions?

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/d27b5300/attachment.sig>

From benkloester at gmail.com  Mon Jan  8 22:26:17 2018
From: benkloester at gmail.com (Ben Kloester)
Date: Tue, 9 Jan 2018 09:26:17 +1100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <20180108193714.GA15359@savin.petertodd.org>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<20180108124506.GA13858@savin.petertodd.org>
	<5c229def-760a-69eb-e646-bd3c77482b00@satoshilabs.com>
	<20180108193714.GA15359@savin.petertodd.org>
Message-ID: <CANgJ=T-CNrzLCtS2PdjCXNq+6LzQ=aM9_Fxw-yF5t3vARXwcuQ@mail.gmail.com>

> This sounds very dangerous. As Gregory Maxwell pointed out, the key
derivation
> function is weak enough that passphrases could be easily brute forced

So you are essentially imagining that a perpetrator will combine the
crypto-nerd fantasy (brute forcing the passphrase) *with* the 5-dollar
wrench attack, merging both panes of Randall Munroe's comic? Seems
vanishingly unlikely to me - attackers are generally either the wrench
type, or the crypto-nerd type.

This thread started by you asking Pavol to give an example of a real-life
scenario in which this functionality would be used, and your rebuttal is a
scenario that is even less likely to occur. "Very dangerous" is a huge
stretch.

When living in Brazil I often carried two (IRL) wallets - one a decoy to
give to muggers, the other with more value stored in it. I heard of plenty
of people getting mugged, but I never heard of anyone who gave a decoy
wallet getting more thoroughly searched and the second wallet found,
despite the relative ease with which a mugger could do this. I'm sure it
has happened, probably many times, but point is there is rarely time for
contemplation in a shakedown, and most perpetrators will take things at
face value and be satisfied with getting something. And searching a
physical person's body is a hell of a lot simpler than cracking a
passphrase.

Moreover, there's no limit to the number of passphrases you can use. If you
were an atttacker, at what point would you stop, satisfied? After the
first, second, third, fourth wallet that you find/they admit to owning?
Going beyond two is already Bond-supervillain level implausible.

*Ben Kloester*

On 9 January 2018 at 06:37, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Jan 08, 2018 at 02:00:17PM +0100, Pavol Rusnak wrote:
> > On 08/01/18 13:45, Peter Todd wrote:
> > > Can you explain _exactly_ what scenario the "plausible deniability"
> feature
> > > refers to?
> >
> >
> > https://doc.satoshilabs.com/trezor-user/advanced_settings.
> html#multi-passphrase-encryption-hidden-wallets
>
> This sounds very dangerous. As Gregory Maxwell pointed out, the key
> derivation
> function is weak enough that passphrases could be easily brute forced, at
> which
> point the bad guys have cryptographic proof that you tried to lie to them
> and
> cover up funds.
>
>
> What model of human memory are you assuming here? What specifically are you
> assuming is easy to remember, and hard to remember? What psychology
> research
> backs up your assumptions?
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180109/4701a311/attachment.html>

From greg at xiph.org  Mon Jan  8 23:47:02 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 8 Jan 2018 23:47:02 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
Message-ID: <CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>

On Mon, Jan 8, 2018 at 12:39 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:
> On 08/01/18 05:22, Gregory Maxwell wrote:
>>> https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>
> Hey Gregory!
>
> Thanks for looking into the scheme. I appreciate your time!
>
>> This specification forces the key being used through a one way
>> function, -- so you cannot take a pre-existing key and encode it with
>> this scheme.
>
> Originally, we used a bi-directional function to be able to encode and
> decode the key in both directions using the passphrase. We stretched the
> passphrase using KDF and then applied AES or other symmetric cipher
>
> We found the following (theoretical) problem:
>
> If an attacker has knowledge of few words from the beginning of shares,
> they are able to reconstruct the beginning of the master secret and if
> the size of the reconstruced master secret is bigger then the cipher
> blocksize (for block ciphers; for stream ciphers 1 bit is enough), then
> they can reconstruct the beginning of the seed.
>
> Can you find a scheme which does not have this problem? Or you think
> this problem is not worth solving?

You can use a large block cipher. E.g. CMC cipher mode.

Though I am doubtful that this is a very relevant concern: What
consequence is it if someone with partial access to more than a
threshold of the shares can recover part of the seed?  This doesn't
seem like a very interesting threat.   A large block mode would be
more complete, but this isn't something that would keep me up at night
in the slightest.

Perhaps I'm missing something, -- but the only real attack I see here
is that a enduser mistakenly shows the first or couple words of all
their shares on national television or what not... but doing so would
not really harm their security unless they showed almost all of them,
and in that case an attacker could simply search the remaining couple
words.

Also, if we are going to assume that users will leak parts, the
mnemonic encoding ends up being pretty bad... since just leaking a
letter or two of each word would quite likely give the whole thing
away.

In any case, to whatever extent partial leaks are a concern, using a
large block cipher would be the obvious approach.

> Yes. We want this to be possible to be computed on TREZOR-like devices
> on boot, similarly how we compute BIP39 on boot right now.

Under this constraint it might be arguably to just eliminate the KDF.
I think it provides false security and makes the implementation much
more complicated.

Have you considered using blind host-delegated KDFs, where the KDF
runs on the user's computer instead of the hardware wallet, but the
computer doesn't learn anything about they keys?

> Again, this is by design and it is main point why plausible deniability
> is achieved both in BIP39 and SLIP39. If we used a different
> construction we'd loose plausible deniability.

I don't believe you can justify this design decision with any kind of
rigorous threat model.

The probability that a user loses funds because they have at some
point recovered with the wrong key and don't know it would almost
certainly dwarf the probability that the user face some kind of
movie-plot threat where someone is attempting to forcibly extract a
key and yet somehow has no information about the user's actual
wallet-- through, for example, leaked data on the users computers, the
users past payments to online accounts, or through a compromise or
lawful order to satoshilab's web service which the users send private
information to-- which would allow them to determine the key they were
given was not correct.

But even there, given the weak level of false input rejection that you
have used (16 bits), it would be fairly straight forward to grind out
an alternative passphrase that also passed the test.  Might that not
make for a better compromise?

Another thing to consider is that the main advantage of SSS over
ordinary computational secret sharing is that it's possible to
generate alternative shares to an sub-threshold set of primary shares
that decodes to arbitrarily selected alternative data-- but it seems
the proposal makes no use of this fact.

>> It
>> is again, unversioned-- so it kinda of seems like it is intentionally
>> constructed in a way that will prevent interoperable use, since the
>> lack of versioning was a primary complaint from other perspective
>> users.  Of course, it fine if you want to make a trezor only thing,
>> but why bother BIPing something that was not intended for
>> interoperability?  Even for a single vendor spec the lack of
>> versioning seems to make things harder to support new key-related
>> features such as segwit.
>
> This is argument I keep having all the time.
>
> Suppose we'd introduce a version to encode PBKDF2 rounds or even
> different KDFs. We'll end up with different SLIP39 mnemonics, but they
> will not be compatible among implementations (because TREZOR can only up
> to 100.000 rounds of PBKDF2 and does not support Argon2 at all, while
> other desktop implementation would rather use memory-hard Argon2).
>
> My gut feeling is that this would lead to WORSE interoperability, not
> better. Look at BIP32 for example. There are lots of wallet that claim
> they are BIP32 compatible, but in reality they use different paths, so
> they are not compatible. BIP32 is a good standard, but in reality
> "BIP32-compatible" does not mean anything, whereas when you say the
> wallet is "BIP44-compatible" you can be sure the migration path works.

The end result is no better-- I think.  If you compromise
functionality or security (e.g. pretextual KDF) because your product
doesn't yet support -- say, aggregate signatures-- or won't ever
support a strong KDF; then other software will just not be
interoperable.  In cases were you won't ever support it, that doesn't
matter-- but presumably you would later support new signature styles
and the loss of interoperability would potentially be gratitious.

That said, I'm generally skeptical of key interoperability to begin
with. Wallets can't share keys unless their functionality is
identical, half-interoperability can lead to funds loss. Identical
functionality would mean constraining to the least common denominator.

But even if we exclude cross vendor interoperability entirely,
wouldn't you want your next version of your firmware to be able to
support new and old key styles (e.g. aggregate signatures vs plain
segwit) without having to define a whole new encoding?

> Originally, we wanted to use 16-bit of CRC32 for checksum, but after the
> discussion with Daan Sprenkels we were suggested to change this for
> cryptographically strong function. The argument was that CRC32 contains
> less entropy and mixing high-entropy data (secret) with low-entropy data
> (checksum) is not a good idea.

That sounds like a kind of hand-wave and cargo cult argument-- pleas
be more specific, because that just sounds like amateur block cipher
design.

There isn't any difference in "entropy" in either of these cases.

As an aside, using "n bits of a longer CRC" usually results in a low
quality code for error detection similar to using a cryptographic
hash.

> Also, there is an argument between a checksum and ECC. We discussed that
> ECC might not be a good idea, because it helps the attacker to compute
> missing information, while we only want to check for integrity. Also the

Not meaningfully more than the truncated cryptographic hash.

The best possible code of that length would allow you to list decode
to around two errors with a lot of computation.
With the cryptographic hash the attacker need only check the 2^28
two-error candidates to do exactly the same thing.

So the attacker there is no real difference-- he can brute force
search to the same radius as correction would allow, but for the
honest users and software the probability of undetected error is
greater.  Similarly, while 2^28 operations is nothing to an attacker,
if user software wants to use the correction for error hinting,
running a hash 2^28 times would lead to a somewhat unfriendly user
experience so non-attack tools would be pretty unlikely to implement
it.

From pete at petertodd.org  Tue Jan  9 00:37:25 2018
From: pete at petertodd.org (Peter Todd)
Date: Mon, 8 Jan 2018 19:37:25 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CANgJ=T-CNrzLCtS2PdjCXNq+6LzQ=aM9_Fxw-yF5t3vARXwcuQ@mail.gmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<20180108124506.GA13858@savin.petertodd.org>
	<5c229def-760a-69eb-e646-bd3c77482b00@satoshilabs.com>
	<20180108193714.GA15359@savin.petertodd.org>
	<CANgJ=T-CNrzLCtS2PdjCXNq+6LzQ=aM9_Fxw-yF5t3vARXwcuQ@mail.gmail.com>
Message-ID: <20180109003725.GA21800@savin.petertodd.org>

On Tue, Jan 09, 2018 at 09:26:17AM +1100, Ben Kloester wrote:
> > This sounds very dangerous. As Gregory Maxwell pointed out, the key
> derivation
> > function is weak enough that passphrases could be easily brute forced
> 
> So you are essentially imagining that a perpetrator will combine the
> crypto-nerd fantasy (brute forcing the passphrase) *with* the 5-dollar
> wrench attack, merging both panes of Randall Munroe's comic? Seems
> vanishingly unlikely to me - attackers are generally either the wrench
> type, or the crypto-nerd type.

We're talking about seeds here, not hardware wallets.

For a hardware wallet theft scenario, if you're worried about muggers you can
make the hardware have secret accounts with different seeds, *without* risking
user funds getting lost - a much more likely scenario - due to mistyped
passwords.

In any case, even if you were to do this type of design, a much better idea is
to use a checksum by default to reject invalid passwords, while having an
advanced-use-only option to override that checksum. The virtual file encryption
filesystem encfs does exactly this with its --anykey flag. This allows advanced
users to do their thing, while protecting the majority of users for whome this
feature is dangerous.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/32a295b0/attachment-0001.sig>

From rhavar at protonmail.com  Tue Jan  9 00:40:38 2018
From: rhavar at protonmail.com (Rhavar)
Date: Mon, 08 Jan 2018 19:40:38 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
Message-ID: <vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>

I think you're under-appreciating how useful the "plausible deniability". Someone I know was (solo) traveling to the United States when a border agent asked her to unlocked her phone; thumbed through her apps, ended up finding tinder and went through all her recent conversations to make sure she wasn't involved in any "pay for sex things".

In the same light, I travel frequently and constantly have my trezor on me. If I am asked to unlock it, I will have no problems doing so (as refusal will no doubt lead to deportation) and showing my personal wallet (which sadly hasn't had much use since fees became ridiculous).

And by doing so, I won't be revealing the half a dozen other accounts I keep. Which is the other big of such "plausible deniability" schemes, they make it trivial to create multiple wallets that are all firewalled away from each other.

I will hypothesize that if one of my wallets was for something like buying stuff on dark markets there's simply no way anyone is going to ever know way you're going to be to tell short of some movie-plot level police effort. 



?-Ryan

?

>-------- Original Message --------
>Subject: Re: [bitcoin-dev] Satoshilabs secret shared private key scheme
>Local Time: January 8, 2018 5:47 PM
>UTC Time: January 8, 2018 11:47 PM
>From: bitcoin-dev at lists.linuxfoundation.org
>To: Pavol Rusnak <stick at satoshilabs.com>
>Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
>
>On Mon, Jan 8, 2018 at 12:39 PM, Pavol Rusnak stick at satoshilabs.com wrote:
>>On 08/01/18 05:22, Gregory Maxwell wrote:
>>>>https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>>>>Hey Gregory!
>>Thanks for looking into the scheme. I appreciate your time!
>>>This specification forces the key being used through a one way
>>> function, -- so you cannot take a pre-existing key and encode it with
>>> this scheme.
>>>Originally, we used a bi-directional function to be able to encode and
>> decode the key in both directions using the passphrase. We stretched the
>> passphrase using KDF and then applied AES or other symmetric cipher
>>We found the following (theoretical) problem:
>>If an attacker has knowledge of few words from the beginning of shares,
>> they are able to reconstruct the beginning of the master secret and if
>> the size of the reconstruced master secret is bigger then the cipher
>> blocksize (for block ciphers; for stream ciphers 1 bit is enough), then
>> they can reconstruct the beginning of the seed.
>>Can you find a scheme which does not have this problem? Or you think
>> this problem is not worth solving?
>>
> You can use a large block cipher. E.g. CMC cipher mode.
>
> Though I am doubtful that this is a very relevant concern: What
> consequence is it if someone with partial access to more than a
> threshold of the shares can recover part of the seed?  This doesn't
> seem like a very interesting threat.   A large block mode would be
> more complete, but this isn't something that would keep me up at night
> in the slightest.
>
> Perhaps I'm missing something, -- but the only real attack I see here
> is that a enduser mistakenly shows the first or couple words of all
> their shares on national television or what not... but doing so would
> not really harm their security unless they showed almost all of them,
> and in that case an attacker could simply search the remaining couple
> words.
>
> Also, if we are going to assume that users will leak parts, the
> mnemonic encoding ends up being pretty bad... since just leaking a
> letter or two of each word would quite likely give the whole thing
> away.
>
> In any case, to whatever extent partial leaks are a concern, using a
> large block cipher would be the obvious approach.
>
>>Yes. We want this to be possible to be computed on TREZOR-like devices
>> on boot, similarly how we compute BIP39 on boot right now.
>>
> Under this constraint it might be arguably to just eliminate the KDF.
> I think it provides false security and makes the implementation much
> more complicated.
>
> Have you considered using blind host-delegated KDFs, where the KDF
> runs on the user's computer instead of the hardware wallet, but the
> computer doesn't learn anything about they keys?
>
>>Again, this is by design and it is main point why plausible deniability
>> is achieved both in BIP39 and SLIP39. If we used a different
>> construction we'd loose plausible deniability.
>>
> I don't believe you can justify this design decision with any kind of
> rigorous threat model.
>
> The probability that a user loses funds because they have at some
> point recovered with the wrong key and don't know it would almost
> certainly dwarf the probability that the user face some kind of
> movie-plot threat where someone is attempting to forcibly extract a
> key and yet somehow has no information about the user's actual
> wallet-- through, for example, leaked data on the users computers, the
> users past payments to online accounts, or through a compromise or
> lawful order to satoshilab's web service which the users send private
> information to-- which would allow them to determine the key they were
> given was not correct.
>
> But even there, given the weak level of false input rejection that you
> have used (16 bits), it would be fairly straight forward to grind out
> an alternative passphrase that also passed the test.  Might that not
> make for a better compromise?
>
> Another thing to consider is that the main advantage of SSS over
> ordinary computational secret sharing is that it's possible to
> generate alternative shares to an sub-threshold set of primary shares
> that decodes to arbitrarily selected alternative data-- but it seems
> the proposal makes no use of this fact.
>
>>>It
>>> is again, unversioned-- so it kinda of seems like it is intentionally
>>> constructed in a way that will prevent interoperable use, since the
>>> lack of versioning was a primary complaint from other perspective
>>> users.  Of course, it fine if you want to make a trezor only thing,
>>> but why bother BIPing something that was not intended for
>>> interoperability?  Even for a single vendor spec the lack of
>>> versioning seems to make things harder to support new key-related
>>> features such as segwit.
>>>This is argument I keep having all the time.
>>Suppose we'd introduce a version to encode PBKDF2 rounds or even
>> different KDFs. We'll end up with different SLIP39 mnemonics, but they
>> will not be compatible among implementations (because TREZOR can only up
>> to 100.000 rounds of PBKDF2 and does not support Argon2 at all, while
>> other desktop implementation would rather use memory-hard Argon2).
>>My gut feeling is that this would lead to WORSE interoperability, not
>> better. Look at BIP32 for example. There are lots of wallet that claim
>> they are BIP32 compatible, but in reality they use different paths, so
>> they are not compatible. BIP32 is a good standard, but in reality
>> "BIP32-compatible" does not mean anything, whereas when you say the
>> wallet is "BIP44-compatible" you can be sure the migration path works.
>>
> The end result is no better-- I think.  If you compromise
> functionality or security (e.g. pretextual KDF) because your product
> doesn't yet support -- say, aggregate signatures-- or won't ever
> support a strong KDF; then other software will just not be
> interoperable.  In cases were you won't ever support it, that doesn't
> matter-- but presumably you would later support new signature styles
> and the loss of interoperability would potentially be gratitious.
>
> That said, I'm generally skeptical of key interoperability to begin
> with. Wallets can't share keys unless their functionality is
> identical, half-interoperability can lead to funds loss. Identical
> functionality would mean constraining to the least common denominator.
>
> But even if we exclude cross vendor interoperability entirely,
> wouldn't you want your next version of your firmware to be able to
> support new and old key styles (e.g. aggregate signatures vs plain
> segwit) without having to define a whole new encoding?
>
>>Originally, we wanted to use 16-bit of CRC32 for checksum, but after the
>> discussion with Daan Sprenkels we were suggested to change this for
>> cryptographically strong function. The argument was that CRC32 contains
>> less entropy and mixing high-entropy data (secret) with low-entropy data
>> (checksum) is not a good idea.
>>
> That sounds like a kind of hand-wave and cargo cult argument-- pleas
> be more specific, because that just sounds like amateur block cipher
> design.
>
> There isn't any difference in "entropy" in either of these cases.
>
> As an aside, using "n bits of a longer CRC" usually results in a low
> quality code for error detection similar to using a cryptographic
> hash.
>
>>Also, there is an argument between a checksum and ECC. We discussed that
>> ECC might not be a good idea, because it helps the attacker to compute
>> missing information, while we only want to check for integrity. Also the
>>
> Not meaningfully more than the truncated cryptographic hash.
>
> The best possible code of that length would allow you to list decode
> to around two errors with a lot of computation.
> With the cryptographic hash the attacker need only check the 2^28
> two-error candidates to do exactly the same thing.
>
> So the attacker there is no real difference-- he can brute force
> search to the same radius as correction would allow, but for the
> honest users and software the probability of undetected error is
> greater.  Similarly, while 2^28 operations is nothing to an attacker,
> if user software wants to use the correction for error hinting,
> running a hash 2^28 times would lead to a somewhat unfriendly user
> experience so non-attack tools would be pretty unlikely to implement
> it.
>
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From pete at petertodd.org  Tue Jan  9 01:13:35 2018
From: pete at petertodd.org (Peter Todd)
Date: Mon, 8 Jan 2018 20:13:35 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
Message-ID: <20180109011335.GA22039@savin.petertodd.org>

On Mon, Jan 08, 2018 at 07:40:38PM -0500, Rhavar via bitcoin-dev wrote:
> I think you're under-appreciating how useful the "plausible deniability". Someone I know was (solo) traveling to the United States when a border agent asked her to unlocked her phone; thumbed through her apps, ended up finding tinder and went through all her recent conversations to make sure she wasn't involved in any "pay for sex things".
> 
> In the same light, I travel frequently and constantly have my trezor on me. If I am asked to unlock it, I will have no problems doing so (as refusal will no doubt lead to deportation) and showing my personal wallet (which sadly hasn't had much use since fees became ridiculous).

Trezor's "plausible deniability" scheme could very well result in you going to
jail for lying to border security, because it's so easy for them to simply
brute force alternate passwords based on your seeds. With that, they have proof
that you lied to customs, a serious offense.

I would strongly advise you not to use it in that situation.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180108/8bcd1aad/attachment.sig>

From rusty at rustcorp.com.au  Tue Jan  9 11:22:18 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 09 Jan 2018 21:52:18 +1030
Subject: [bitcoin-dev] BIP 117 Feedback
Message-ID: <87608btgyd.fsf@rustcorp.com.au>

I've just re-read BIP 117, and I'm concerned about its flexibility.  It
seems to be doing too much.

The use of altstack is awkward, and makes me query this entire approach.
I understand that CLEANSTACK painted us into a corner here :(

The simplest implementation of tail recursion would be a single blob: if
a single element is left on the altstack, pop and execute it.  That
seems trivial to specify.  The treatment of concatenation seems like
trying to run before we can walk.

Note that if we restrict this for a specific tx version, we can gain
experience first and get fancier later.

BIP 117 also drops SIGOP and opcode limits.  This requires more
justification, in particular, measurements and bounds on execution
times.  If this analysis has been done, I'm not aware of it.

We could restore statically analyzability by rules like so:
1.  Only applied for tx version 3 segwit txs.
2.  For version 3, top element of stack is counted for limits (perhaps
    with discount).
3.  The blob popped off for tail recursion must be identical to that top
    element of the stack (ie. the one counted above).

Again, future tx versions could drop such restrictions.

Cheers,
Rusty.

From mark at friedenbach.org  Tue Jan  9 12:40:30 2018
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 9 Jan 2018 21:40:30 +0900
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <87608btgyd.fsf@rustcorp.com.au>
References: <87608btgyd.fsf@rustcorp.com.au>
Message-ID: <DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>

The use of the alt stack is a hack for segwit script version 0 which has the clean stack rule. Anticipated future improvements here are to switch to a witness script version, and a new segwit output version which supports native MAST to save an additional 40 or so witness bytes. Either approach would allow getting rid of the alt stack hack. They are not part of the proposal now because it is better to do things incrementally, and because we anticipate usage of MAST to better inform these less generic changes.

Your suggestion of ?single blob on the stack? seems to be exactly this proposal afaict? Note the witness data needs to be passed separately because signatures can?t be included in that single blob if that blob is hashed and compared against something in the scriptPubKey.

The sigop and opcode limit drop can be justified with some back of the envelope calculations. Non-scriptPubKey scripts are fundamentally limited by blocksize/weight and the most damage you can do, as an adversary, is limited by space. The most expensive thing you can do check a signature. Our assumptions about block size safety are basically due to how much computation you can stuff in a block with checksigs ? all the analysis there applies.

My suggestion is to limit the number of checksigs allowed in a script to size(script+witness)/64, but I wanted this to come up in review rather than complicate the code right off the bat.

I will make a strong assertion: static analyzing the number of opcodes and sigops gets us absolutely nothing. It is cargo cult safety engineering. No need to perpetuate it when it is now in the way.

Sent from my iPhone

> On Jan 9, 2018, at 8:22 PM, Rusty Russell <rusty at rustcorp.com.au> wrote:
> 
> I've just re-read BIP 117, and I'm concerned about its flexibility.  It
> seems to be doing too much.
> 
> The use of altstack is awkward, and makes me query this entire approach.
> I understand that CLEANSTACK painted us into a corner here :(
> 
> The simplest implementation of tail recursion would be a single blob: if
> a single element is left on the altstack, pop and execute it.  That
> seems trivial to specify.  The treatment of concatenation seems like
> trying to run before we can walk.
> 
> Note that if we restrict this for a specific tx version, we can gain
> experience first and get fancier later.
> 
> BIP 117 also drops SIGOP and opcode limits.  This requires more
> justification, in particular, measurements and bounds on execution
> times.  If this analysis has been done, I'm not aware of it.
> 
> We could restore statically analyzability by rules like so:
> 1.  Only applied for tx version 3 segwit txs.
> 2.  For version 3, top element of stack is counted for limits (perhaps
>    with discount).
> 3.  The blob popped off for tail recursion must be identical to that top
>    element of the stack (ie. the one counted above).
> 
> Again, future tx versions could drop such restrictions.
> 
> Cheers,
> Rusty.

From pieter.wuille at gmail.com  Tue Jan  9 14:21:08 2018
From: pieter.wuille at gmail.com (Pieter Wuille)
Date: Tue, 9 Jan 2018 06:21:08 -0800
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>
References: <87608btgyd.fsf@rustcorp.com.au>
	<DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>
Message-ID: <CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>

On Jan 9, 2018 13:41, "Mark Friedenbach via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

The use of the alt stack is a hack for segwit script version 0 which has
the clean stack rule. Anticipated future improvements here are to switch to
a witness script version, and a new segwit output version which supports
native MAST to save an additional 40 or so witness bytes. Either approach
would allow getting rid of the alt stack hack. They are not part of the
proposal now because it is better to do things incrementally, and because
we anticipate usage of MAST to better inform these less generic changes.


If the goal is to introduce a native MAST output type later, what is gained
by first having the tailcall semantics?

As far as I can see, this proposal does not have any benefits over Johnson
Lau's MAST idea [1]:
* It is more compact, already giving us the space savings a native MAST
version of the tail call semantics would bring.
* It does not need to work around limitations of push size limits or
cleanstack rules.
* The implementation (of code I've seen) is easier to reason about, as it's
just another case in VerifyScript (which you'd need for a native MAST
output later too) without introducing jumps or loops inside EvalScript.
* It can express the same, as even though the MBV opcode supports proving
multiple elements simultaneously, I don't see a way to use that in the tail
call. Every scenario that consists of some logic before deciding what the
tail call is going to be can be rewritten to have that logic inside each of
the branches, I believe.
* It does not interfere with static analysis (see further).
* Tail call semantics may be easier to extend in the future to enable
semantics that are not compactly representable in either proposal right
now, by allowing a single top-level script may invoke multiple subscripts,
or recursion. However, those sound even riskier and harder to analyse to
me, and I don't think there is sufficient evidence they're needed.

Native MAST outputs would need a new witness script version, which your
current proposal does indeed not need. However, I believe a new script
version will be desirable for other reasons regardless (returning invalid
opcodes to the pool of NOPs available for softforks, for example).

I will make a strong assertion: static analyzing the number of opcodes and
sigops gets us absolutely nothing. It is cargo cult safety engineering. No
need to perpetuate it when it is now in the way.


I'm not sure I agree here. While I'd like to see the separate execution
limits go away, removing them entirely and complicating future ability to
introduce unified costing towards weight of execution cost seems the wrong
way to go.

My reasoning is this: perhaps you can currently make an argument that the
current weight limit is sufficient in preventing overly expensive block
validation costs, due to a minimal ratio between script sizes and their
execution cost. But such an argument needs to rely on assumptions about
sighash caching and low per-opcode CPU time, which may change in the
future. In my view, tail call semantics gratuitously remove or complicate
the ability to reason about the executed code.

One suggestion to reduce the impact of this is limiting the per-script
execution to something proportional to the script size. However, I don't
think that addresses all potential concerns about static analysis (for
example, it doesn't easily let you prove all possible execution paths to a
participant in a smart contract).

Another idea that has been suggested on this list is to mark pushes of
potentially executable code on the stack/witness explicitly. This would
retain all ability to analyse, while still leaving the flexibility of
future extensions to tail call execution. If tail call semantics are
adopted, I strongly prefer an approach like that to blindly throwing out
all limits and analysis.

  [1] https://github.com/jl2012/bips/blob/mast/bip-mast.mediawiki

Cheers,

-- 
Pieter
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180109/6c862414/attachment.html>

From ronald at vandermeer.frl  Tue Jan  9 11:20:55 2018
From: ronald at vandermeer.frl (Ronald van der Meer)
Date: Tue, 9 Jan 2018 11:20:55 +0000
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English wordlist
Message-ID: <31430A55-57AD-4648-8D6D-DE2A45CC013C@vandermeer.frl>

Hello guys,

After reviewing some bitcoin improvement proposals, I noticed that one of the words that can be found on the BIP39 English wordlist is ?satoshi?. 
I suggest removing this word from the list so it?s less obvious that it?s a bitcoin seed when found by a malicious third party.

Regards, 
Ronald van der Meer
 
E: ronald at vandermeer.frl | W: https://www.vandermeer.frl
S: https://twitter.com/truly_secure
 
GPG: 8203 CE3E 064D C462 1D22 F635 A1EC 45F9 645F 878D


From jenslewis0xfffaaa at gmail.com  Tue Jan  9 12:44:56 2018
From: jenslewis0xfffaaa at gmail.com (jens)
Date: Tue, 9 Jan 2018 12:44:56 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <20180109011335.GA22039@savin.petertodd.org>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
	<20180109011335.GA22039@savin.petertodd.org>
Message-ID: <29ef320d-e758-e00b-1be2-c1eae43de167@gmail.com>


> Trezor's "plausible deniability" scheme could very well result in you going to
> jail for lying to border security, because it's so easy for them to simply
> brute force alternate passwords based on your seeds. With that, they have proof
> that you lied to customs, a serious offense.
The passphrase scheme as I understand it allows a maximum of 50 
characters to be used.? Surely even with the HD seed, that search space 
is too large to brute force.? Or is there a weakness in the scheme I 
haven't clocked?

On 09/01/18 01:13, Peter Todd via bitcoin-dev wrote:
> On Mon, Jan 08, 2018 at 07:40:38PM -0500, Rhavar via bitcoin-dev wrote:
>> I think you're under-appreciating how useful the "plausible deniability". Someone I know was (solo) traveling to the United States when a border agent asked her to unlocked her phone; thumbed through her apps, ended up finding tinder and went through all her recent conversations to make sure she wasn't involved in any "pay for sex things".
>>
>> In the same light, I travel frequently and constantly have my trezor on me. If I am asked to unlock it, I will have no problems doing so (as refusal will no doubt lead to deportation) and showing my personal wallet (which sadly hasn't had much use since fees became ridiculous).
> Trezor's "plausible deniability" scheme could very well result in you going to
> jail for lying to border security, because it's so easy for them to simply
> brute force alternate passwords based on your seeds. With that, they have proof
> that you lied to customs, a serious offense.
>
> I would strongly advise you not to use it in that situation.
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180109/10f78fce/attachment-0001.html>

From stick at satoshilabs.com  Tue Jan  9 15:12:58 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Tue, 9 Jan 2018 16:12:58 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
Message-ID: <f2fbb0ec-0c18-f866-29fe-41de882f4706@satoshilabs.com>

On 09/01/18 00:47, Gregory Maxwell wrote:
> Have you considered using blind host-delegated KDFs, where the KDF
> runs on the user's computer instead of the hardware wallet, but the
> computer doesn't learn anything about they keys?

Any examples of these?


-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From roconnor at blockstream.io  Tue Jan  9 16:20:20 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 9 Jan 2018 11:20:20 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
Message-ID: <CAMZUoKnWbAF3LHOWcYsbkyfH93HwWWVHzQFz52V1jUKXgEBgZw@mail.gmail.com>

On Mon, Jan 8, 2018 at 7:39 AM, Pavol Rusnak via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On 08/01/18 05:22, Gregory Maxwell wrote:
> >> https://github.com/satoshilabs/slips/blob/master/slip-0039.md
>
>
> > The 16-bit "checksum" based on sha2 seems pretty poor since basing
> > small checksums on a cryptographic hash results in a fairly poor
> > checksum that is surprisingly likely to accept an errored string. Your
> > wordlist is 10 bits and you have much less than 1023*10 bits of input,
> > so you could easily have a 20 bit code (two words) which guaranteed
> > that up to two errored words would always be detected, and probably
> > could choose one which catches three words much more often 1:2^20
> > (sipa's crc tools can help find codes like this).
>
> Originally, we wanted to use 16-bit of CRC32 for checksum, but after the
> discussion with Daan Sprenkels we were suggested to change this for
> cryptographically strong function. The argument was that CRC32 contains
> less entropy and mixing high-entropy data (secret) with low-entropy data
> (checksum) is not a good idea.
>

This entropy argument seems confused.  Ignoring constant factors, the
entropy of a checksum is the sum over all possible checksums, i, of
-n_i*log(n_i), where n_i is the number of times the ith checksum occurs
over the space of all possible data being checksummed.  In this application
the checksum is being applied to a fixed m-bit blob of uniformly random
data.

The entropy is maximized when every possible checksum occurs equally as
frequently, that is we achieve maximum entropy when all the n_i values are
equal to each other.  Any error correcting code worth it's salt will try to
achieve this property because the designers want every checksum value to
have as much error correcting power as every other checksum value.  I'm
almost certain that the algebraic properties of your typical error
correcting codes allow you to prove that maximum entropy is perfectly
achieved whenever the data-blob size is at least as large as the checksum
size.

Meanwhile the truncated value of a cryptographic hash function is expected
to be slightly under the maximum entropy value, under the assumption that
the hash function it behaves like a random function.

The main properties of a "strong cryptographic hash function" is that it is
infeasible to find collisions and preimages.  However these properties are
lost when you truncate the hash down to 16-bits.  At this point is it
entirely feasible to find collisions and preimages.

So using a truncated cryptographic hash function doesn't provide you with
more entropy (and, in fact, probably a sliver less entropy), and doesn't
provide you with any of the befits of strong cryptographic hash function.


> Also, there is an argument between a checksum and ECC. We discussed that
> ECC might not be a good idea, because it helps the attacker to compute
> missing information, while we only want to check for integrity. Also the
> word mnemonic is itself a ECC, because if you see the word "acadornic"
> it is probably the word "academic".
>

Every checksum is error correcting.  Given an failed checksum, all you have
to do is search around the space of edits to find the smallest set edits
that yield a valid checksum.  With a 2^16 bit checksum one will expect to
find a nearby checksum within 2^16 trails, even when using a truncated hash
function.

What an error-correcting codes gives you isn't the ability to correct
errors, which we have seen is something that all short checksums provide,
rather they provide *guarantees* about the ability to detect (and correct)
certain common classes of errors.  For example we can have an ECC that
guarantees to find the error where are word is accidentally written down
twice (see
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015506.html
).

The advice you have been given will only result in losing any guarantees
about detecting common classes or errors; it won't stop attackers from
recovering missing information, and it won't provide a cryptographically
strong function.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180109/5f03431f/attachment.html>

From mark at friedenbach.org  Tue Jan  9 22:57:34 2018
From: mark at friedenbach.org (Mark Friedenbach)
Date: Wed, 10 Jan 2018 07:57:34 +0900
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>
References: <87608btgyd.fsf@rustcorp.com.au>
	<DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>
	<CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>
Message-ID: <6C568F3A-0CCD-41BE-B785-C58932F47C58@friedenbach.org>

I havent the hubris to suggest that we know exactly what a templated MAST *should* look like. It's not used in production anywhere. Even if we did have the foresight, the tail-call semantics allow for other constructions besides MAST and for the sake of the future we should allow such permission-less innovation. The proper sequence of events should be to enable features in a generic way, and then to create specialized templates to save space for common constructions. Not the other way around.

We've been down the route of templating new features, and have made mistakes. P2SH is a canonical example, which BIP 117 is fixing. P2SH only provides 80 bits of security to a multi-party construction. Had we been designing BIP 16 now we probably would have used double-SHA256 instead of RIPEMD160. I will also assert that had we been using single-use tail-call semantics *instead* of BIP 16, recognition of this limitation would have resulted in us immediately defining a longer '3...' address which used HASH256 instead, and we would have immediately benefited from the fix. Instead we had to wait years until segwit gave us the opportunity to fix it at the same time.

To take another example, in some ideal sense we probably shouldn't even be developing a programmable signature script framework. We should instead template a generic lightning-derived layer-2 protocol and use that for everything, including both payments (supporting cut-through) and payment channels for smart contracts. This may not be the majority technical opinion yet, but as someone working in this space I believe that's where we are headed: a single layer-2 protocol that's generic enough to use for all payment caching and smart contracts, while achieving a full anonymity set for all contracts, as closures look identical on the wire. Even if that's where things are headed, I hope it is clear that we are not yet at such a stage to standardize what that looks like. We still need many years of use of specialized lightning protocols and work to be done to make them more generic and applicable to other protocols.

I believe the situation to be similar with MAST. Even if we have a better idea of what the MAST constructions will look like, *nobody* uses MAST in production yet, and there are bound to be implementation issues in rolling it out, or unique variants we do not have the foresight to see now. As a concrete example, BIP 116 has been modified since the initial proposal to allow multiple branches to be proven at once from a single Merkle tree root. To be honest, I don't know exactly how this will be used. We were able to come up with a couple of examples to justify inclusion of the feature, but I anticipate that someone down the line will come up with an even more creative use. Maybe a payment channel that uses a single tree to simultaneously commit to both the policy script and a sequence number. Or something like that. If we provide a templated, special-cased MAST now before it sees wide use then we will be locking in the protocol that we anticipate people using without having any production experience or ecosystem-wide review. Frankly that strikes me as a poor engineering decision.

Finally, even if we had perfect foresight into how a feature will be used, which we don't, it is still the case that we would want to enable permission-less innovation with the generic construct, even if using it comes with a 40-byte or so witness hit. I make the argument for this in the "intuitive explanation of MAST" email I sent to this list back in September of last year. I will reproduce the argument below:

https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015028.html

The driving motivation for the tail-call and MBV proposals, and the reason they are presented and considered together is to enable Merklized Abstract Syntax Trees. However neither BIP actually defines a MAST template, except as an example use case of the primitive features. This is very much on purpose: it is the opinion of this author that new bitcoin consensus features should follow the UNIX philosophy as expressed by Peter Salus and Mike Gancarz and paraphrased by yours truly:

  * Write features that do one thing and do it well.
  * Write features to work together.
  * Simple is beautiful.

By using modularity and composition of powerful but simple tools like MERKLEBRANCHVERIFY and single tail-call recursion to construct MAST we enable a complex and desirable feature while minimizing changes to the consensus code, review burden, and acquired technical debt.

The reusability of the underlying primitives also means that they can be combined with other modular features to support use cases other than vanilla MAST, or reused in series to work around various limits that might otherwise be imposed on a templated form of MAST. At the moment the chief utility of these proposals is the straightforward MAST script written above, but as primitives they do allow a few other use cases and also combine well with features in the pipeline or on
the drawing board. For example, in addition to MAST you can:

1. Use MERKLEBRANCHVERIFY alone to support honeypot bounties, as
   discussed in the BIP.

2. Use a series of MERKLEBRANCHVERIFY opcodes to verify a branch with
   split proofs to stay under script and witness push limitations.

3. Combine MERKLEBRANCHVERIFY with key aggregation to get
   Wuille-Maxwell tree signatures which support arbitrary signing
   policies using a single, aggregatable signature.

4. Combine tail-call execution semantics with CHECKSIGFROMSTACK to get
   delegation and signature-time commitment to subscript policy.

5. Combine MERKLEBRANCHVERIFY with a Merkle proof prefix check opcode
   and Lamport signature support to get reusable Lamport keys.

I believe these benefits and possible future expansions to be strong arguments in favor of extending bitcoin in the form of small, modular, incremental, and reusable changes that can be combined and used even in ways unforeseen even by their creators, creating a platform for unrestricted innovation.

The alternative approach of rigid templates achieves the stated goals, perhaps even with slightly better encoding efficiency, but at the cost of requiring workaround for each future innovation. P2SH is just such an example -- we couldn't even upgrade to 128-bit security without designing an entirely different implementation because of the limitations of template pattern matching.


> On Jan 9, 2018, at 11:21 PM, Pieter Wuille <pieter.wuille at gmail.com> wrote:
> 
> On Jan 9, 2018 13:41, "Mark Friedenbach via bitcoin-dev" <bitcoin-dev at lists.linuxfoundation.org <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> The use of the alt stack is a hack for segwit script version 0 which has the clean stack rule. Anticipated future improvements here are to switch to a witness script version, and a new segwit output version which supports native MAST to save an additional 40 or so witness bytes. Either approach would allow getting rid of the alt stack hack. They are not part of the proposal now because it is better to do things incrementally, and because we anticipate usage of MAST to better inform these less generic changes.
> 
> If the goal is to introduce a native MAST output type later, what is gained by first having the tailcall semantics?
> 
> As far as I can see, this proposal does not have any benefits over Johnson Lau's MAST idea [1]:
> * It is more compact, already giving us the space savings a native MAST version of the tail call semantics would bring.
> * It does not need to work around limitations of push size limits or cleanstack rules.
> * The implementation (of code I've seen) is easier to reason about, as it's just another case in VerifyScript (which you'd need for a native MAST output later too) without introducing jumps or loops inside EvalScript.
> * It can express the same, as even though the MBV opcode supports proving multiple elements simultaneously, I don't see a way to use that in the tail call. Every scenario that consists of some logic before deciding what the tail call is going to be can be rewritten to have that logic inside each of the branches, I believe.
> * It does not interfere with static analysis (see further).
> * Tail call semantics may be easier to extend in the future to enable semantics that are not compactly representable in either proposal right now, by allowing a single top-level script may invoke multiple subscripts, or recursion. However, those sound even riskier and harder to analyse to me, and I don't think there is sufficient evidence they're needed.
> 
> Native MAST outputs would need a new witness script version, which your current proposal does indeed not need. However, I believe a new script version will be desirable for other reasons regardless (returning invalid opcodes to the pool of NOPs available for softforks, for example).
> 
> I will make a strong assertion: static analyzing the number of opcodes and sigops gets us absolutely nothing. It is cargo cult safety engineering. No need to perpetuate it when it is now in the way.
> 
> I'm not sure I agree here. While I'd like to see the separate execution limits go away, removing them entirely and complicating future ability to introduce unified costing towards weight of execution cost seems the wrong way to go.
> 
> My reasoning is this: perhaps you can currently make an argument that the current weight limit is sufficient in preventing overly expensive block validation costs, due to a minimal ratio between script sizes and their execution cost. But such an argument needs to rely on assumptions about sighash caching and low per-opcode CPU time, which may change in the future. In my view, tail call semantics gratuitously remove or complicate the ability to reason about the executed code.
> 
> One suggestion to reduce the impact of this is limiting the per-script execution to something proportional to the script size. However, I don't think that addresses all potential concerns about static analysis (for example, it doesn't easily let you prove all possible execution paths to a participant in a smart contract).
> 
> Another idea that has been suggested on this list is to mark pushes of potentially executable code on the stack/witness explicitly. This would retain all ability to analyse, while still leaving the flexibility of future extensions to tail call execution. If tail call semantics are adopted, I strongly prefer an approach like that to blindly throwing out all limits and analysis.
> 
>   [1] https://github.com/jl2012/bips/blob/mast/bip-mast.mediawiki <https://github.com/jl2012/bips/blob/mast/bip-mast.mediawiki>
> 
> Cheers,
> 
> -- 
> Pieter
> 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180110/030d4279/attachment-0001.html>

From thomasv at electrum.org  Wed Jan 10 17:44:02 2018
From: thomasv at electrum.org (Thomas Voegtlin)
Date: Wed, 10 Jan 2018 18:44:02 +0100
Subject: [bitcoin-dev] JSONRPC vulnerability in Electrum 2.6 to 3.0.4
Message-ID: <630b0d12-6334-ba13-a839-68198838744f@electrum.org>

A vulnerability has been found in Electrum, and patched in version
3.0.5. Please update your software if you are running an earlier version.

The following is a copy of the summary and guidelines we posted on our
website: https://github.com/spesmilo/electrum-docs/blob/master/cve.rst

A CVE number for the issue has been requested 2 days ago, and has not
been attributed yet.



JSONRPC vulnerability in Electrum 2.6 to 3.0.4
==============================================

On January 6th, a vulnerability was disclosed in the Electrum wallet
software, that allows malicious websites to execute wallet commands
through JSONRPC executed in a web browser. The bug affects versions
2.6 to 3.0.4 of Electrum, on all platforms. It also affects clones of
Electrum such as Electron Cash.


Can funds be stolen?
--------------------

Wallets that are not password protected are at risk of theft, if they
are opened with a version of Electrum older than 3.0.5 while a web
browser is active.

In addition, the vulnerability allows an attacker to modify user
settings, the list of contacts in a wallet, and the "payto" and
"amount" fields of the user interface while Electrum is running.

Although there is no known occurrence of Bitcoin theft occurring
because of this vulnerability, the risk increases substantially now
that the vulnerability has been made public.


Can wallet data be leaked?
--------------------------

Yes, an attacker can obtain private data, such as: Bitcoin addresses,
transaction labels, address labels, wallet contacts and master public
keys.


Can a password-protected wallet be bruteforced?
-----------------------------------------------

Not realistically. The vulnerability does not allow an attacker to
access encrypted seed or private keys, which would be needed in order
to perform an efficient brute force attack. Without the encrypted
seed, an attacker must try passwords using the JSONRPC interface,
while the user is visiting a malicious page. This is several orders of
magnitude slower than an attack with the encrypted seed, and
restricted in time. Even a weak password will protect against that.


What should users do?
---------------------

All users should upgrade their Electrum software, and stop using old
versions.

Users who did not protect their wallet with a password should create a
new wallet, and move their funds to that wallet. Even if it never
received any funds, a wallet without password should not be used
anymore, because its seed might have been compromised.

In addition, users should review their settings, and delete all
contacts from their contacts list, because the Bitcoin addresses of
their contacts might have been modified.


How to upgrade Electrum
-----------------------

Stop running any version of Electrum older than 3.0.5, and install
Electrum the most recent version. On desktop, make sure you download
Electrum from https://electrum.org and no other website. On Android,
the most recent version is available in Google Play.

If Electrum 3.0.5 (or any later version) cannot be installed or does
not work on your computer, stop using Electrum on that computer, and
access your funds from a device that can run Electrum 3.0.5. If you
really need to use an older version of Electrum, for example in order
to access wallet seed, make sure that your computer is offline, and
that no web browser is running on the computer at the same time.


Should all users move their funds to a new address?
---------------------------------------------------

We do not recommend moving funds from password protected wallets. For
wallets that were not password protected, moving funds is an extreme
precaution, that might not be necessary; indeed, if a wallet was
compromised, it is very likely that the attacker would have stolen the
funds immediately.


When was the issue reported and fixed?
--------------------------------------

The absence of password protection in the JSONRPC interface was
reported on November 25th, 2017 by user jsmad:
https://github.com/spesmilo/electrum/issues/3374

jsmad's report was about the Electrum daemon, a piece of software that
runs on web servers and is used by merchants in order to receive
Bitcoin payments. In that context, connections to the daemon from the
outside world must be explicitly authorized, by setting 'rpchost' and
'rpcport' in the Electrum configuration.

On January 6th, 2018, Tavis Ormandy demonstrated that the JSONRPC
interface could be exploited against the Electrum GUI, and that the
attack could be carried out by a web browser running locally, visiting
a webpage with specially crafted JavaScript.

We released a new version (3.0.4) in the hours following Tavis' post,
with a patch written by mithrandi (Debian packager), that addressed
the attack demonstrated by Tavis. In addition, the Github issue
remained open, because mithrandi's patch was not adding password
protection to the JSONRPC interface.

Shortly after the 3.0.4 release we started to work on adding proper
password protection to the JSONRPC interface of the daemon, and that
part was ready on Sunday, January 7th. We also learned on Sunday
afternoon that the first patch was not effective against another,
similar attack, using POST. This is why we did not delay the 3.0.5
release, which includes password protection, and completely disables
JSONRPC in the GUI.






-- 
Electrum Technologies GmbH / Waldemarstr 37a / 10999 Berlin / Germany
Sitz, Registergericht: Berlin, Amtsgericht Charlottenburg, HRB 164636
Gesch?ftsf?hrer: Thomas Voegtlin

From stick at satoshilabs.com  Wed Jan 10 20:28:10 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Wed, 10 Jan 2018 21:28:10 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <f2fbb0ec-0c18-f866-29fe-41de882f4706@satoshilabs.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<f2fbb0ec-0c18-f866-29fe-41de882f4706@satoshilabs.com>
Message-ID: <bb3ea695-f1f6-3f92-267d-281aedb850ed@satoshilabs.com>

On 09/01/18 16:12, Pavol Rusnak via bitcoin-dev wrote:
> On 09/01/18 00:47, Gregory Maxwell wrote:
>> Have you considered using blind host-delegated KDFs, where the KDF
>> runs on the user's computer instead of the hardware wallet, but the
>> computer doesn't learn anything about they keys?
> 
> Any examples of these?

Actually, scratch that. HW wallet would not know whether the host
computer is lying or not. The computer would not learn about the keys,
but still could be malicious and provide invalid result. Is that correct?

-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From greg at xiph.org  Wed Jan 10 23:47:23 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 10 Jan 2018 23:47:23 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <bb3ea695-f1f6-3f92-267d-281aedb850ed@satoshilabs.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<f2fbb0ec-0c18-f866-29fe-41de882f4706@satoshilabs.com>
	<bb3ea695-f1f6-3f92-267d-281aedb850ed@satoshilabs.com>
Message-ID: <CAAS2fgSn7kYoKi2cBRUP39G6LLZZgG1B6Sc47U+ba8H22rTQ6Q@mail.gmail.com>

On Wed, Jan 10, 2018 at 8:28 PM, Pavol Rusnak <stick at satoshilabs.com> wrote:
> On 09/01/18 16:12, Pavol Rusnak via bitcoin-dev wrote:
>> On 09/01/18 00:47, Gregory Maxwell wrote:
>>> Have you considered using blind host-delegated KDFs, where the KDF
>>> runs on the user's computer instead of the hardware wallet, but the
>>> computer doesn't learn anything about they keys?
>>
>> Any examples of these?

Yes, this scheme.
https://bitcointalk.org/index.php?topic=311000.msg3342217#msg3342217

> Actually, scratch that. HW wallet would not know whether the host
> computer is lying or not. The computer would not learn about the keys,
> but still could be malicious and provide invalid result. Is that correct?


I believe that can be avoided by having the computer do somewhat more
work and checking the consistency after the fact.

(or for decode time, having a check value under the encryption...)

From stick at satoshilabs.com  Thu Jan 11 09:55:08 2018
From: stick at satoshilabs.com (Pavol Rusnak)
Date: Thu, 11 Jan 2018 10:55:08 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgSn7kYoKi2cBRUP39G6LLZZgG1B6Sc47U+ba8H22rTQ6Q@mail.gmail.com>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<f2fbb0ec-0c18-f866-29fe-41de882f4706@satoshilabs.com>
	<bb3ea695-f1f6-3f92-267d-281aedb850ed@satoshilabs.com>
	<CAAS2fgSn7kYoKi2cBRUP39G6LLZZgG1B6Sc47U+ba8H22rTQ6Q@mail.gmail.com>
Message-ID: <37d6a598-461c-f720-ac59-f775872fac06@satoshilabs.com>

On 11/01/18 00:47, Gregory Maxwell wrote:
> I believe that can be avoided by having the computer do somewhat more
> work and checking the consistency after the fact.
>
> (or for decode time, having a check value under the encryption...)

Can you describe these two methods more in detail? How exactly would
they work? What crypto primitives would you use and how?


-- 
Best Regards / S pozdravom,

Pavol "stick" Rusnak
CTO, SatoshiLabs

From lists at coryfields.com  Fri Jan 12 05:04:44 2018
From: lists at coryfields.com (Cory Fields)
Date: Fri, 12 Jan 2018 00:04:44 -0500
Subject: [bitcoin-dev] New Bitcoin Core macOS signing key
Message-ID: <CAApLimjGy6TCd7kg8RKkuGqAZTfcuNSfsrDowEsEcbEnM_0rzg@mail.gmail.com>

Hi all

As discussed in a few of the last weekly meetings, Bitcoin Core's
macOS code signing certificate expired today.

We are (Greg is ;) in the process of establishing a new threshold
signing scheme that will allow us to handle code signing without any
single point of failure. But until then, releases will be signed as
before, just with a new certificate.

As a matter of record, I used the old code-signing key/certificate to
sign a message containing the pubkey that matches the new
key/certificate. It's attached at the end of this message.

The pkcs7 format is rather clunky, but I wanted to include the current
signing certificate to make verification easier. I'll leave it to the
reader to extract the certificate from a previous release in order to
make sure that they match. It was also in the Core git repo until it
was removed recently.

To verify, you can use something like:
openssl smime -verify -in sig.pkcs7 -inform pem -ignore_critical -purpose any

- "ignore_critical" setting tells openssl to ignore the Apple-specific
critical extensions that it doesn't understand.
- "-purpose any" allows the "purpose == smimesign" check to be
skipped. This would otherwise fail because this certificate is only
authorized to sign code, not arbitrary messages.

By now, the signature will probably fail to validate because the
certificate has expired.

The signed message below is timestamped on the Bitcoin blockchain
using OpenTimestamps. See the attached ots file containing the
timestamp proof. If the attachment gets scrubbed and doesn't make it
to the list, don't be afraid to nag Peter Todd about a mail-friendly
format for these proofs :)

Regards,
Cory

expire.txt.sig:
-----BEGIN PKCS7-----
MIILTwYJKoZIhvcNAQcCoIILQDCCCzwCAQExCzAJBgUrDgMCGgUAMIIDNAYJKoZI
hvcNAQcBoIIDJQSCAyFUaGUgY3VycmVudCBCaXRjb2luIENvcmUgbWFjT1MgY29k
ZSBzaWduaW5nIGNlcnRpZmljYXRlIGV4cGlyZXMNCmxhdGVyIHRvZGF5LCBKYW51
YXJ5IDExLCAyMDE4Lg0KDQpJbiB0aGUgZnV0dXJlLCBhIHRocmVzaG9sZCBzaWdu
YXR1cmUgd2lsbCBiZSB1c2VkIHRvIHNpZ24gbWFjT1MNCnJlbGVhc2VzLCBidXQg
c2luY2UgdGhpcyB3YXMgbm90IHJlYWR5IGluIHRpbWUsIGEgdGVtcG9yYXJ5DQpj
ZXJ0aWZpY2F0ZSB3aWxsIGxpa2VseSBiZSB1c2VkIGZvciB0aGUgMC4xNiByZWxl
YXNlLg0KDQpUaGUgcHVibGljIGtleSB0byBiZSB1c2VkIHdpdGggdGhpcyBuZXcg
Y2VydGlmaWNhdGUgaXM6DQoNCi0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tDQpN
SUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQXF4aWJE
Z2pBT09WVXBTY3pVMnBqDQp0UEVpQ0lZeXl2V21EN2VidGhQbzI5WG9xMUJqYWJG
NDlCZ3diNkZFaU1haFN5UTY4ZklMSUhDanJ5SUo4RUN1DQpROFJWbVF3cGdhKzV0
OTZiMEM5emN5WTFhcSsrRzIyMVNqNmFpUmVveXZwcHIrZ2poNmNPbktEc1B0Z2pU
cGdiDQovOUhuMmtwYzFmZ000ZkRFMlQ2VXZHVHMwd3d5dWNvL21ya0s1LzEySCtq
ZUE3QXVNcjBLQTBVSktSS1VOenFhDQo4QjlLalFFektaRGVVVHRYak9vSmIyNkRQ
U3hCbXBGd25zWSs2aHBjeFZSSmphNG1FYzRFYnIyb2gxSmVORU5uDQp4WXR3MHRW
VWczTUwvWlI2WU9qQVpMY0V0cW5IR2ZOZXVRazJXVm1pYy9JY3d4VEM0cUk4MnFR
OGgxQnFpY3pRDQo4UUlEQVFBQg0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tDQqg
ggWLMIIFhzCCBG+gAwIBAgIIJ0r1rumyfZAwDQYJKoZIhvcNAQELBQAweTEtMCsG
A1UEAwwkRGV2ZWxvcGVyIElEIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSYwJAYD
VQQLDB1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UECgwKQXBw
bGUgSW5jLjELMAkGA1UEBhMCVVMwHhcNMTMwMTEwMjIzOTAxWhcNMTgwMTExMjIz
OTAxWjCBqDEaMBgGCgmSJomT8ixkAQEMClBCVjRHTFM5SjQxQDA+BgNVBAMMN0Rl
dmVsb3BlciBJRCBBcHBsaWNhdGlvbjogQklUQ09JTiBGT1VOREFUSU9OLCBJTkMu
LCBUSEUxEzARBgNVBAsMClBCVjRHTFM5SjQxJjAkBgNVBAoMHUJJVENPSU4gRk9V
TkRBVElPTiwgSU5DLiwgVEhFMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEB
BQADggEPADCCAQoCggEBALTd5zURuZVoJviusr119aktXksenb9IN9vq6kBbq38v
xEk79wkKMES2XfBRh0HxcEizGzhMNy5OCXuTLMaNMihYdfwYSoBoR2foEU+6kjPU
nyJ4dQBFLJZJr5/QeQmALmYHEgZ6lwXFD2lU8t92340zeJ4y5LZw5pcEHtH9Iumm
YDutOGCkCGXDcjL+5nHhNScJiXHhswM+62o6XXsQiP6EWbM1CsgrGTNLtaa0U/Uv
VDwE79YKklSC5Bog2LD0jBcTuveI66mFzqu++L9X9u+ZArtebwCl7BPNQ+uboYy5
uV2dzf8lpNNZLfXCFjoLe9bLICKfZ7ub9V5aC8+GhckCAwEAAaOCAeEwggHdMD4G
CCsGAQUFBwEBBDIwMDAuBggrBgEFBQcwAYYiaHR0cDovL29jc3AuYXBwbGUuY29t
L29jc3AtZGV2aWQwMTAdBgNVHQ4EFgQUa5xsqKVzcHDiV6NJ2GL7l8elXV4wDAYD
VR0TAQH/BAIwADAfBgNVHSMEGDAWgBRXF+2iz9x8mKEQ4Py+hy0s8uMXVDCCAQ4G
A1UdIASCAQUwggEBMIH+BgkqhkiG92NkBQEwgfAwKAYIKwYBBQUHAgEWHGh0dHA6
Ly93d3cuYXBwbGUuY29tL2FwcGxlY2EwgcMGCCsGAQUFBwICMIG2DIGzUmVsaWFu
Y2Ugb24gdGhpcyBjZXJ0aWZpY2F0ZSBieSBhbnkgcGFydHkgYXNzdW1lcyBhY2Nl
cHRhbmNlIG9mIHRoZSB0aGVuIGFwcGxpY2FibGUgc3RhbmRhcmQgdGVybXMgYW5k
IGNvbmRpdGlvbnMgb2YgdXNlLCBjZXJ0aWZpY2F0ZSBwb2xpY3kgYW5kIGNlcnRp
ZmljYXRpb24gcHJhY3RpY2Ugc3RhdGVtZW50cy4wDgYDVR0PAQH/BAQDAgeAMBYG
A1UdJQEB/wQMMAoGCCsGAQUFBwMDMBMGCiqGSIb3Y2QGAQ0BAf8EAgUAMA0GCSqG
SIb3DQEBCwUAA4IBAQAfJ0BjID/1dS2aEeVyhAzPzCBjG8vm0gDf+/qfwRn3+yWe
L9vSnMdbilwM48IyQWTagjGGcojbsAd/vE4N7NhQyHInoCllNoeor1I5xx+blTaG
RBK+dDhJbbdlGCjsLnH/BczGZi5fyEJds9lUIrp1hJidRcUKO76qb/9gc6qNZpl1
vH5klDUuJYt7YhAs+L6rTXDyqcK9maeQr0gaOPsRRAQLLwiQCorPeMTUNsbVMdMw
ZYJsR+PxiAnk+nyi7rfiFvPoASAYUuI6OzYL/Fa6QU4/gYyPgic944QYVkaQBnc0
vEP1nXq6LGKwgVGcqJnkr/E2kui5gJoV5C3qll3eMYICYTCCAl0CAQEwgYUweTEt
MCsGA1UEAwwkRGV2ZWxvcGVyIElEIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MSYw
JAYDVQQLDB1BcHBsZSBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTETMBEGA1UECgwK
QXBwbGUgSW5jLjELMAkGA1UEBhMCVVMCCCdK9a7psn2QMAkGBSsOAwIaBQCggbEw
GAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTgwMTEx
MTgxMDUwWjAjBgkqhkiG9w0BCQQxFgQUvqCmkSFwZTLWSNhIddUfdxBPQSswUgYJ
KoZIhvcNAQkPMUUwQzAKBggqhkiG9w0DBzAOBggqhkiG9w0DAgICAIAwDQYIKoZI
hvcNAwICAUAwBwYFKw4DAgcwDQYIKoZIhvcNAwICASgwDQYJKoZIhvcNAQEBBQAE
ggEAQadtQ5qePkjvB3xqLeSvN3e6SpoGQGn6Oo57IiUs/9zP3LAziS2pLbOxSlrS
WWJ5byt7qHdxg9Hi+8IRK5ppps3TxX49ZtN9xHR0BQECspHhbad++JnLuCVjoW88
tgX6NylWb16xekpKA9D1xsLOaVlxFJry4S9k3wz53ajg7J83jlA5K1j9rcS8dVhZ
WjIl12I2AalQ//PXVyu1soF7ieKgyFKeOefGaAOT3ybji1ibYoPfsS/IdnBz7hbn
EmHUHDdl2R+TWDf0ADXMqV3qjMuG5osFRUJbeWm5CUne1/w2BdcIkmkvfmzU+Bmh
jixGT1Xg83O4e3LL4Bww0rRY6w==
-----END PKCS7-----
-------------- next part --------------
A non-text attachment was scrubbed...
Name: expire.txt.sig.ots
Type: application/vnd.oasis.opendocument.spreadsheet-template
Size: 1740 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180112/6cf33db9/attachment.ots>

From pete at petertodd.org  Fri Jan 12 08:54:12 2018
From: pete at petertodd.org (Peter Todd)
Date: Fri, 12 Jan 2018 03:54:12 -0500
Subject: [bitcoin-dev] New Bitcoin Core macOS signing key
In-Reply-To: <CAApLimjGy6TCd7kg8RKkuGqAZTfcuNSfsrDowEsEcbEnM_0rzg@mail.gmail.com>
References: <CAApLimjGy6TCd7kg8RKkuGqAZTfcuNSfsrDowEsEcbEnM_0rzg@mail.gmail.com>
Message-ID: <20180112085412.GA8088@savin.petertodd.org>

On Fri, Jan 12, 2018 at 12:04:44AM -0500, Cory Fields via bitcoin-dev wrote:
> To verify, you can use something like:
> openssl smime -verify -in sig.pkcs7 -inform pem -ignore_critical -purpose any
> 
> - "ignore_critical" setting tells openssl to ignore the Apple-specific
> critical extensions that it doesn't understand.
> - "-purpose any" allows the "purpose == smimesign" check to be
> skipped. This would otherwise fail because this certificate is only
> authorized to sign code, not arbitrary messages.
> 
> By now, the signature will probably fail to validate because the
> certificate has expired.

Note that you may need to add -noverify as well if your openssl doesn't have
the Apple Certificate Authority in the CA list.

While a clunky way to do it, you can use the `-signer` option to tell OpenSSL
to write the signer's certificate to a file. That certificate can then be
compared to the one from the repo, which was still in the repo as of the
(signed!) v0.15.1 tag.


Fun fact: OpenTimestamps has git integration, which means you can extract a OTS
proof from 2016 for that certificate from the repo:

    $ git checkout v0.15.1
    $ ots git-extract share/certs/BitcoinFoundation_Apple_Cert.pem share/certs/BitcoinFoundation_Apple_Cert.pem.ots 36f60a5d5b1bc9a12b87d6475e3245b8236775e4
    $ ots verify share/certs/BitcoinFoundation_Apple_Cert.pem.ots
    Assuming target filename is 'share/certs/BitcoinFoundation_Apple_Cert.pem'
    Success! Bitcoin attests data existed as of Thu Oct 13 14:08:59 2016 EDT

Homework problem: write a paragraph explaining how the proof generated by the
above three commands are crypto snakeoil that proved little. :)

> The signed message below is timestamped on the Bitcoin blockchain
> using OpenTimestamps. See the attached ots file containing the
> timestamp proof. If the attachment gets scrubbed and doesn't make it
> to the list, don't be afraid to nag Peter Todd about a mail-friendly
> format for these proofs :)

Ha! Fortunately even the mailing list archives at lists.linuxfoundation.org
seem to contain the attachment just fine.

But anyway, I'd suggest using base64:

AE9wZW5UaW1lc3RhbXBzAABQcm9vZgC/ieLohOiSlAEITeD8FWBXd613LkHPt3JyrZBKamczrmmf
NLwSJohkYfDwEB35DezwYGb4KePty9TSWRcI//AQjTiBNRdo5I7oIeLjkGhQuAjxBFpXqSbwCN+N
8xIdwxQG/wCD3+MNLvkMji4taHR0cHM6Ly9hbGljZS5idGMuY2FsZW5kYXIub3BlbnRpbWVzdGFt
cHMub3JnCPEgijKAmyu82BuY9WL4Ags9TuzOph/XJBC6zUYZNW2Kv14I8SDyd3rD94qsLgkTPUlF
nA3SbabHilzJcHkrlGbYL+MaBgjxINCDuse4CSogHVUKQ9WaRrYkExs8PMx8O11OoVhj5ydJCPAg
y3ZstDNn/6b32WO12ZprF9zhb6VfGUl9spxU5k5eirgI8SBwa20AdPHR6oLcSdnogmPmUpWEd+n1
ky2dhWKvqZwJ/AjwIBYprQWyepSdvr1Ber0DD1eP66d4l1+138SZw7/fIflPCPAgTXOIKaeMbmNj
oO6Q/6SoX7ksCKOjkt284KYyI/ELaVgI8VkBAAAAAc1gOrgz+6mCizItuiE8bQ4foKYwCz0sB9lG
7gj/kK9fAAAAAAD9////Ag9aLAAAAAAAFgAU4gDd5F6wUprr6G4WBg+5sQkAi1YAAAAAAAAAACJq
IPAEuq8HAAgI8SAQbNEWckYQhxlLHC1aYxnyzHgxatOXQCOkQGgXe7CV7wgI8SDvEAaFSJ6unpLU
CvJzUpe2ISKMquT7kvQlvOam3SbgdggI8SBKKOTuNlh0TqP0wxy+BvCN8HgXFj/CQvJm/r9061dC
XggI8CBjdeDoADpZAb6CHjryDthP/BPcKVcMNiu+KAHIfgdDfAgI8CBuq4+F9RGpuGjFp7YU0WyH
mohtNWCv1oiDAvm6TAZeXAgI8CCI0tiLN7YMP2HtPKIm72bDi6OoFduzG0TQ1n7hEjEvvQgI8CBm
oIe62AVnwyFp6mZ37TuP0JsBHuazibGEgBKgB2xSTAgI8CDbi0srCkqentfGfk+HgBPLllDWN/mU
p4HsOQBoiDB3HwgI8SBpOitFwKhqpvNNL2SzSAxmCDIRpIpq+Kp5x774ovXexggI8SAtBMNMgP/r
L2MztJ9H43LYDRM3jGt8mbbG4Ji2+5z1rQgI8CAoVuz4NodKzCGU5c0hdBWon6T7TuMN5lA1IIOB
UF+5+QgIAAWIlg1z1xkBA7vfHvAQ5vjVlfmkli0Jsy9r6Zl5EAjxBFpXqSXwCGWEIRA/ovvQ/wCD
3+MNLvkMjiwraHR0cHM6Ly9ib2IuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZwjxIPEX
gnzr8J36EGTnlaF/N3bvWi0cmhlkt1b/TVIBZuCHCPEgKqjwAWBXRj1MC6oVZK6P7MBuaB5VnC+S
CpN4pfoQNJcI8CB166rXsYFaNJvQD0b6PvcK02KauHQ0G6h3dyO5NoLE1QjwIOXfM7LRnV2CFLYU
AC6uWB3K28jnM7chsxQiPXQvOmE/CPEgWmgM4iyrpd8Ip/Vs0bPeC1mdH/fgEOO+fLCR0Ae8OH0I
8CAebOJrI00jNjqWLJNxFLZaO4tY69kEKHx6AvrjoQqNzgjxWQEAAAABqY/4nDzgexnxwERsA6RG
QKS4pzagJAciBvkAbejv8mwAAAAAAP3///8CGrg4AAAAAAAWABQNuE08uA4/5oWDRYPWIW0HNrwS
ZgAAAAAAAAAAImog8AS2rwcACAjwIGQuGBXXZjCZPN527NmlDPNE7DY5jznNp8UauCoSRe3UCAjx
IPnKxEUG7HPVIm2RehYqhROpmLrZuPtr4MuMKoX+xTT1CAjwID9qxx7kHhzJrzDeZPXsvaCdQCX3
mVqkyBzlIG/Rz0TPCAjxIFHQruGgLpotZScpYu9Ou9EUmeqmizOmW77hqP04oN5/CAjwIKqKpmbK
V3weRNXWLDAWVcr0bXZndaq6th6b8dy5mjoeCAjwIA2RHHGChLN8t1f7rJJRowlLp1F3XLGD2kqK
k5M3K4c3CAjxIBwP3futX+WjxgkAS0d2TGxiyUoKMFT6bmG2o4zwmz/4CAjwIJmhwnqv64SuTiSQ
atRL1udPduUsJ6qevzrJiiuYaRuSCAjxINEU34ZeVioiqA4bBJJU8HMVlWdyYYXFnZRZ0lsKCJvc
CAjxIPjnINA1faJ/WYxuV0KSUceoHWd4EltavqltfDjTjQhcCAjwIOJixScSNRwwkg68C4HSMeRM
K5YKNh1phfaY3Du/0i68CAgABYiWDXPXGQEDt98e

On Linux, the `base64 -d` command will decode the above just fine.

The _real_ issue is that asking the user to cut-n-paste that PKCS7-encoded
message is problematic, as differences in whitespace and line endings will make
the verification fail. Works fine on Linux, but would probably have failed on
Windows.

What's nice about OpenPGP's "clearsigned" format is how it ignores whitespace;
a replica of that might be a nice thing for OTS to be able to do too. Though
that's on low priority, as there's some tricky design choices(1) to be made about
how to nicely nest clearsigned PGP within OTS.


1) For example, I recently found a security hole related to clearsigned PGP
recently. Basically the issue was that gpg --verify will return true on a file
that looks like the following:

    1d7a363ce12430881ec56c9cf1409c49c491043618e598c356e2959040872f5a  foo-v2.0.tar.gz
    -----BEGIN PGP SIGNED MESSAGE-----
    Hash: SHA256

    e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  foo-v1.0.tar.gz
    -----BEGIN PGP SIGNATURE-----

    <snip pgp stuff>
    -----END PGP SIGNATURE-----

The system I was auditing then did something like this to verify that the file
was signed:

    set -e # exit immediately on error
    gpg --verify SHA256SUMS.asc
    cat SHA256SUMS.asc | grep foo-v2.0.tar.gz
    <do installation>

While it makes it a bit less user friendly, the fact that PKCS7's encoding made
it impossible to see the message you signed until it's been properly verified
is a good thing re: security.

And yes, I checked: Bitcoin Core's contrib/verifybinaries/verify.sh isn't
vulnerable to this mistake. :)

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180112/bfd7c512/attachment.sig>

From pete at petertodd.org  Fri Jan 12 09:50:58 2018
From: pete at petertodd.org (Peter Todd)
Date: Fri, 12 Jan 2018 04:50:58 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <274aad5c-4573-2fdd-f8b0-c6c2d662ab7c@gibsonic.org>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
	<20180109011335.GA22039@savin.petertodd.org>
	<274aad5c-4573-2fdd-f8b0-c6c2d662ab7c@gibsonic.org>
Message-ID: <20180112095058.GA9175@savin.petertodd.org>

On Tue, Jan 09, 2018 at 12:43:48PM +0000, Perry Gibson wrote:
> >Trezor's "plausible deniability" scheme could very well result in you going to
> >jail for lying to border security, because it's so easy for them to simply
> >brute force alternate passwords based on your seeds. With that, they have proof
> >that you lied to customs, a serious offense.
> The passphrase scheme as I understand it allows a maximum of 50 characters
> to be used.? Surely even with the HD seed, that search space is too large to
> brute force.? Or is there a weakness in the scheme I haven't clocked?

While passphrases *can* be long, most user's aren't going to understand the
risk. For example, Trezors blog(1) doesn't make it clear that the passphrases
could be bruteforced and used as evidence against you, and even suggests the
contrary:

    Since the passphrase is never saved on the device, this means that there is no
    wrong passphrase. The device does not know which one you have chosen, and
    therefore all of them are correct! Given the same seed, for each and every
    letter combination used as a passphrase, a different wallet will be generated.

and:

    Since there is no way to prove that there is any wallet beyond the ones
    that you have admitted to, the ?attacker? will have to be satisfied with
    the revealed ones.


Also note how this blog doesn't mention anti-forensics: the wallet software
itself may leave traces of the other wallets on the computer. Have they really
audited it sufficiently to be sure this isn't the case?

1) https://blog.trezor.io/hide-your-trezor-wallets-with-multiple-passphrases-f2e0834026eb

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180112/a6ee71b2/attachment.sig>

From nullius at nym.zone  Fri Jan 12 10:14:11 2018
From: nullius at nym.zone (nullius)
Date: Fri, 12 Jan 2018 10:14:11 +0000
Subject: [bitcoin-dev] New Bitcoin Core macOS signing key
In-Reply-To: <20180112085412.GA8088@savin.petertodd.org>
References: <CAApLimjGy6TCd7kg8RKkuGqAZTfcuNSfsrDowEsEcbEnM_0rzg@mail.gmail.com>
	<20180112085412.GA8088@savin.petertodd.org>
Message-ID: <23bf1f30b85d0f23d6c9eab93f1d8e06@nym.zone>

On 2018-01-12 at 08:54:12 +0000, Peter Todd <pete at petertodd.org> wrote:
>While a clunky way to do it, you can use the `-signer` option to tell 
>OpenSSL to write the signer's certificate to a file. That certificate 
>can then be compared to the one from the repo, which was still in the 
>repo as of the (signed!) v0.15.1 tag.
>
>
>Fun fact: OpenTimestamps has git integration, which means you can 
>extract a OTS proof from 2016 for that certificate from the repo:
>
>    $ git checkout v0.15.1
>    $ ots git-extract share/certs/BitcoinFoundation_Apple_Cert.pem share/certs/BitcoinFoundation_Apple_Cert.pem.ots 36f60a5d5b1bc9a12b87d6475e3245b8236775e4
>    $ ots verify share/certs/BitcoinFoundation_Apple_Cert.pem.ots
>    Assuming target filename is 'share/certs/BitcoinFoundation_Apple_Cert.pem'
>    Success! Bitcoin attests data existed as of Thu Oct 13 14:08:59 2016 EDT
>
>Homework problem: write a paragraph explaining how the proof generated 
>by the above three commands are crypto snakeoil that proved little. :)

It says, ?Bitcoin attests data existed?.  Within the scope of those 
three commands, I don?t see any proof of who put it there.  Does OTS 
check the PGP signatures on *commits* when it does that `git-extract`?  
The signature on the v0.15.1 tag is irrelevant to that question; and 
FWIW, I don?t see *that* signature being verified here, either.  

Second paragraph:  Moreover, with the breaking of SHA-1, it *may* be 
feasible for some scenario to play out involving two different PEMs with 
the same hash, but different public keys (and thus different 
corresponding private keys).  I don?t know off the top of my head if 
somewhere could be found to stash the magic bits; and the overall 
scenario would need to be a bit convoluted.  I think a malicious 
committer who lacked access to the signing key *may* be able to create a 
collision between the real certificate, and a certificate as for which 
he has the private key?then switch them, later.  Maybe.  I would not 
discount the possibility off-hand.  OTS would prove nothing, if he had 
the foresight to obtain timestamps proving that both certificates 
existed at the appropriate time (which they would need to anyway; it is 
not a post facto preimage attack).

>[...]
>
>What's nice about OpenPGP's "clearsigned" format is how it ignores 
>whitespace; a replica of that might be a nice thing for OTS to be able 
>to do too. Though that's on low priority, as there's some tricky design 
>choices(1) to be made about how to nicely nest clearsigned PGP within 
>OTS.
>
>
>1) For example, I recently found a security hole related to clearsigned 
>PGP recently. Basically the issue was that gpg --verify will return 
>true on a file that looks like the following:
>
>    1d7a363ce12430881ec56c9cf1409c49c491043618e598c356e2959040872f5a  foo-v2.0.tar.gz
>    -----BEGIN PGP SIGNED MESSAGE-----
>    Hash: SHA256
>
>    e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  foo-v1.0.tar.gz
>    -----BEGIN PGP SIGNATURE-----
>
>    <snip pgp stuff>
>    -----END PGP SIGNATURE-----
>
>The system I was auditing then did something like this to verify that 
>the file was signed:
>
>    set -e # exit immediately on error
>    gpg --verify SHA256SUMS.asc
>    cat SHA256SUMS.asc | grep foo-v2.0.tar.gz
>    <do installation>
>
>While it makes it a bit less user friendly, the fact that PKCS7's 
>encoding made it impossible to see the message you signed until it's 
>been properly verified is a good thing re: security.

Potential solutions using PGP:

0. Don?t use clearsigning.

1. Use a detached signature.

2. Use `gpg --verify -o -` and pipe that to `grep`, rather than 
illogically separating verification from use of data.  (By the way, 
where is the *hash* verified?  Was `grep` piped to `sha256sum -c`?)

3. Have shell scripts written by somebody who knows how to think about 
security, and/or who knows how to RTFM; quoting gpg(1):

>Note: When verifying a cleartext signature, gpg verifies only what  
>makes up the cleartext signed data and not any extra data outside of 
>the cleartext signature or the header lines directly following the dash 
>marker line.  The option --output may be used to write out the actual 
>signed data, but there are other pitfalls with this format as well.  It 
>is suggested to avoid cleartext signatures in favor of detached 
>signatures.

4. Obtain an audit from Peter Todd.

>And yes, I checked: Bitcoin Core's contrib/verifybinaries/verify.sh 
>isn't vulnerable to this mistake. :)

P.S., oh my!  *Unsigned data:*

>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180112/54009101/attachment-0001.sig>

From roconnor at blockstream.io  Fri Jan 12 10:48:33 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Fri, 12 Jan 2018 05:48:33 -0500
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>
References: <87608btgyd.fsf@rustcorp.com.au>
	<DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>
	<CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>
Message-ID: <CAMZUoKn4noCEQR6eqf9hiZSMdk-3b8UHR1NrEFrKNoLSMzVjGQ@mail.gmail.com>

Putting aside for the moment the concerns that Pieter and Rusty have raised
about BIP 117 (concerns which I agree with), is BIP 117 even a viable soft
fork to begin with?

When it comes to soft forks of Script, in the past there have been two
kinds.

The first kind is soft-forking new script semantics into NOPn codes.  In
this case, everyone ought to know that these op codes are reserved for
future extensions and no one should be writing script that depends on NOPn
having NOP behavior (For users who want real nop behaviour, there does
exist a real NOP opcode).

The second kind of soft-forking new script semantics is the
reinterpretation of various wholesale scripts (historically via
templates).  Examples of this are Segwit and P2SH.  In the case of Segwit,
the scripts gaining new semantics were applied to a form of completely
unsecured "anyone-can-spend" programs.  Anyone who created such output
prior to the activation of Segwit would know that anyone could claim
ownership of those outputs, and therefore the possibility of losing the
ability to spend legacy forms of these segwit-style outputs is arguably not
harmful as no one in particular had ownership of such funds.  The story for
P2SH is somewhat similar: Prior to the activation of P2SH the creator of of
P2SH style outputs would know that anyone could claim ownership of that
style of output as soon as the hash preimage is published (in the mempool,
for example).

However, if I understand correctly, the situation for BIP 117 is entirely
different.  As far as I understand there is currently no restrictions about
terminating a v0 witness program with a non-empty alt-stack, and there are
no restrictions on leaving non-canonical boolean values on the main stack.
There could already be commitments to V0 witness programs that, when
executed in some reasonable context, leave a non-empty alt-stack and/or
leave a non-canonical true value on the main stack.  Unlike the P2SH or
Segwit soft-forks, these existing commitments could be real outputs that
currently confer non-trivial ownership over their associated funds.  If BIP
117 were activated, these commitments would be subject to a new set of
rules that didn't exist when the commitments were made.  In particular,
these funds could be rendered unspendable.  Because segwit commitments are
hashes of segwit programs, there is no way to even analyze the blockchain
to determine if these commitments currently exist (and even if we could it
probably woudln't be adequate protection).

Naturally we shouldn't be making new rules that could, in principle,
retroactively remove ownership of existing user's funds.


>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180112/c5442637/attachment.html>

From nullius at nym.zone  Fri Jan 12 11:06:33 2018
From: nullius at nym.zone (nullius)
Date: Fri, 12 Jan 2018 11:06:33 +0000
Subject: [bitcoin-dev] Plausible Deniability (Re: Satoshilabs secret shared
 private key scheme)
In-Reply-To: <20180112095058.GA9175@savin.petertodd.org>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
	<20180109011335.GA22039@savin.petertodd.org>
	<274aad5c-4573-2fdd-f8b0-c6c2d662ab7c@gibsonic.org>
	<20180112095058.GA9175@savin.petertodd.org>
Message-ID: <3b45c17a256326b6b183587d9d15690c@nym.zone>

On 2018-01-12 at 09:50:58 +0000, Peter Todd <pete at petertodd.org> wrote:
>On Tue, Jan 09, 2018 at 12:43:48PM +0000, Perry Gibson wrote:
>>>Trezor's "plausible deniability" scheme could very well result in you 
>>>going to jail for lying to border security, because it's so easy for 
>>>them to simply brute force alternate passwords based on your seeds.  
>>>With that, they have proof that you lied to customs, a serious 
>>>offense.
>>The passphrase scheme as I understand it allows a maximum of 50 
>>characters to be used.? Surely even with the HD seed, that search 
>>space is too large to brute force.? Or is there a weakness in the 
>>scheme I haven't clocked?
>
>While passphrases *can* be long, most user's aren't going to understand 
>the risk. For example, Trezors blog(1) doesn't make it clear that the 
>passphrases could be bruteforced and used as evidence against you, and 
>even suggests the contrary:  [...quote...]

I despise the term ?plausible deniability?; and that?s really the wrong 
term to use in this discussion.

?Plausible deniability? is a transparent excuse for explaining away an 
indisputable fact which arouses suspicion?when you got some serious 
?splain? to do.  This is usually used in the context of some pseudolegal 
argument about introducing ?reasonable doubt?, or even making ?probable 
cause? a wee bit less probable.

?Why yes, officer:  I was seen carrying an axe down the street near the 
site of an axe murder, at approximately the time of said axe murder.  
But I do have a fireplace; so it is plausible that I was simply out 
gathering wood.?

I rather suspect the concept of ?plausible deniability? of having been 
invented by a detective or agent provocateur.  There are few concepts 
more useful for helping suspects shoot themselves in the foot, or 
frankly, for entrapping people.

One of the worst examples I have seen is in discussions of Monero, 
whereby I?ve seen proponents claim that even under the worst known 
active attacks, their mix scheme reduces transaction linking to a 
maximum of 20?40% probability.  ?That?s not good enough to convince a 
jury!?  No, but it is certainly adequate for investigators to identify 
you as a person of interest.  Then, your (mis)deeds can be subjected to 
powerful confirmation attacks based on other data; blockchains do not 
exist in isolation.  I usually stay out of such discussions; for I have 
no interest in helping the sorts of people whose greatest concern in 
life is what story to foist on a jury.

In the context of devices such as Trezor, what is needed is not 
?plausible deniability?, but rather the ability to obviate any need to 
deny anything at all.  I must repeat, information does not exist in 
isolation.

If you are publicly known to be deepy involved in Bitcoin, then nobody 
will believe that your one-and-only wallet contains only 0.01 BTC.  
That?s not even ?plausible?.  But if you have overall privacy practices 
which leave nobody knowing or suspecting that you have any Bitcoin at 
all, then there is nothing to ?deny?; and should a Trezor with 
(supposedly) 0.01 BTC be found in your possession, that?s much better 
than ?plausible?.  It?s completely unremarkable.

Whereas if you are known or believed to own large amounts of BTC, a 
realistic bad guy?s response to your ?decoy? wallet could be, ?I don?t 
believe you; and it costs me nothing to keep beating you with rubber 
hose until you tell me the *real* password.?

It could be worse, too.  In a kidnapping scenario, the bad guys could 
say, ?I don?t believe you.  Hey, I also read Trezor?s website about 
?plausible deniability?.  Now, I will maim your kid for life just to 
test whether you told me the *real* password.  And if you still don?t 
tell me the real password after you see that little Johnny can no longer 
walk, then I will kill him.?

The worst part is that you have no means of proving that you really 
*did* give the real password.  Indeed, it can be proved if you?re lying 
by finding a password which reveals a hidden wallet?but *you* have no 
means of affirmatively proving that you are telling the truth!  If the 
bad guys overestimated your riches (or if they?re in a bad mood), then 
little Johnny is dead either way.

In a legalistic scenario, if ?authorities? believe you have 1000 BTC and 
you only reveal a password for 0.01 BTC, the likely response will not be 
to let you go.  Rather, ?You will now sit in jail until you tell the 
*real* password.?  And again:  You have no means of proving that you did 
give the real password!

?Plausible deniability? schemes can backfire quite badly.

>Also note how this blog doesn't mention anti-forensics: the wallet 
>software itself may leave traces of the other wallets on the computer.  
>Have they really audited it sufficiently to be sure this isn't the 
>case?

What about data obtained via the network?  I don?t *only* refer to 
dragnet surveillance.  See for but one e.g., Goldfelder, et al., ?When 
the cookie meets the blockchain:  Privacy risks of web payments via 
cryptocurrencies? https://arxiv.org/abs/1708.04748  Your identity can be 
tied to your wallet all sorts of ways, any of which could be used to 
prove that you have more Bitcoin than you?re revealing.  Do you know 
what databases of cross-correlated analysis data customs agents have 
immediate access to nowadays?or will, tomorrow?  I don?t.

In the scenario under discussion, that may not immediately prove ?beyond 
a reasonable doubt? that you lied specifically about your Trezor.  But 
it could give plenty of cause to keep you locked up in a small room 
while your hard drive is examined for evidence that Trezor apps handled 
*addresses already known to be linked to you*.  Why even bother with 
bruteforce?  Low-hanging fruit abound.

>1) https://blog.trezor.io/hide-your-trezor-wallets-with-multiple-passphrases-f2e0834026eb

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180112/862e70b3/attachment.sig>

From nullius at nym.zone  Sat Jan 13 03:44:03 2018
From: nullius at nym.zone (nullius)
Date: Sat, 13 Jan 2018 03:44:03 +0000
Subject: [bitcoin-dev] Plausible Deniability (Re: Satoshilabs secret
 shared private key scheme)
In-Reply-To: <PS2P216MB01793245561CC130C6FEEC9A9D140@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
	<20180109011335.GA22039@savin.petertodd.org>
	<274aad5c-4573-2fdd-f8b0-c6c2d662ab7c@gibsonic.org>
	<20180112095058.GA9175@savin.petertodd.org>
	<3b45c17a256326b6b183587d9d15690c@nym.zone>
	<PS2P216MB01793245561CC130C6FEEC9A9D140@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <bd9283ec34396d769a84664ac5ae9206@nym.zone>

Preface:  As a longstanding policy, whenever I buy a new hard disk or 
decommission an old one, I immediately `dd` it from start to end with a 
pseudorandom byte stream.  The result is indistinguishable from my disk 
encryption setup, which leaves no apparent on-disk headers.  I don?t do 
this for ?plausibility? reasons, but rather, 0. to assure that 
immediately upon use, any sectors written with disk encryption cannot be 
distinguished from unwritten sectors, and 1. to make things overall more 
fun for potential cryptanalysts.  I do realize the small problem that I 
can?t affirmatively prove any particular disk in my possession to *not* 
contain decryptable data; and many of them don?t!

(I think that next, I may start writing my disks with headers for LUKS, 
which I do not use...)

Whereupon, I challenge plausible deniability designers to `dd` a 6TB 
disk with pseudorandom bytes, then try walking it across the U.S. border 
until it gets searched.  What could possibly go wrong?  Should you be 
ordered to decrypt it, the disk *could* be *plausibly* filled with 
pseudorandom bytes; and you would not be committing the crime of lying 
to an officer, when you truly state that in fact, it *is* filled with 
pseudorandom bytes.

Please, I want to see this ?plausible deniability? theory in action.  
You owe it to your users to test the theory empirically, in 
circumstances in which users have here reported applying it.

Now, in reply:

On 2018-01-13 at 02:11:08 +0000, Damian Williamson 
<willtech at live.com.au> wrote:
>The same problems exist for users of whole disk encrypted operating 
>systems. Once the device (or, the initial password authentication) is 
>found, the adversary knows that there is something to see.

Or PGP.  Or in a broader sense, Tor.  Or in the physical world, a 
high-security safe bolted to your floor.  Security systems attract 
attention.  Smart people develop appropriate threat models, keep their 
security systems confidential where it is practical to do so (don?t brag 
about your high-security safe), and work to increase the popularity of 
network security systems (PGP, HTTPS, Tor...) to reduce how much they 
stand out.

In the context of this discussion, it does help that Bitcoin is becoming 
popular.  It would help much more if Trezors and similar devices were as 
commonplace as iGadgets.  But when considering the potential threats to 
any specific individual, the only ?plausibility? shield is to not seem 
like someone who is likely to have *much*.  Of course, this is not a 
problem specific to Bitcoin.  Depending on the threat, the same danger 
applies to owning a substantial amount of gold, cash, or even money in a 
bank.

>The objective of plausible deniability is to present some acceptable 
>(plausible) alternative while keeping the actual hidden (denied).
>
>If the adversary does not believe you, you do indeed risk everything.

And therein lies the trick.  Unsophisticated adversaries such as common 
criminals may be fooled, or may not care if they can quickly grab 
*something* of value and run away.  But if your threat model may 
potentially include any adversaries possessed of both brains and 
patience, ?plausible deniability? solves nothing.  Such an adversary 
will not likely be satisfied with the standard of ?plausibility?.  More 
likely, the prevailing standard will be:  ?I wasn?t born yesterday, and 
I *know* that you are hiding something.?

>[snip extended prior quotations]

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180113/31b7f887/attachment.sig>

From willtech at live.com.au  Sat Jan 13 02:11:08 2018
From: willtech at live.com.au (Damian Williamson)
Date: Sat, 13 Jan 2018 02:11:08 +0000
Subject: [bitcoin-dev] Plausible Deniability (Re: Satoshilabs secret
 shared private key scheme)
In-Reply-To: <3b45c17a256326b6b183587d9d15690c@nym.zone>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
	<20180109011335.GA22039@savin.petertodd.org>
	<274aad5c-4573-2fdd-f8b0-c6c2d662ab7c@gibsonic.org>
	<20180112095058.GA9175@savin.petertodd.org>,
	<3b45c17a256326b6b183587d9d15690c@nym.zone>
Message-ID: <PS2P216MB01793245561CC130C6FEEC9A9D140@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

The same problems exist for users of whole disk encrypted operating systems. Once the device (or, the initial password authentication) is found, the adversary knows that there is something to see. The objective of plausible deniability is to present some acceptable (plausible) alternative while keeping the actual hidden (denied).


If the adversary does not believe you, you do indeed risk everything.


Regards,

Damian Williamson

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of nullius via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Friday, 12 January 2018 10:06:33 PM
To: Peter Todd; Bitcoin Protocol Discussion
Subject: [bitcoin-dev] Plausible Deniability (Re: Satoshilabs secret shared private key scheme)

On 2018-01-12 at 09:50:58 +0000, Peter Todd <pete at petertodd.org> wrote:
>On Tue, Jan 09, 2018 at 12:43:48PM +0000, Perry Gibson wrote:
>>>Trezor's "plausible deniability" scheme could very well result in you
>>>going to jail for lying to border security, because it's so easy for
>>>them to simply brute force alternate passwords based on your seeds.
>>>With that, they have proof that you lied to customs, a serious
>>>offense.
>>The passphrase scheme as I understand it allows a maximum of 50
>>characters to be used.  Surely even with the HD seed, that search
>>space is too large to brute force.  Or is there a weakness in the
>>scheme I haven't clocked?
>
>While passphrases *can* be long, most user's aren't going to understand
>the risk. For example, Trezors blog(1) doesn't make it clear that the
>passphrases could be bruteforced and used as evidence against you, and
>even suggests the contrary:  [...quote...]

I despise the term ?plausible deniability?; and that?s really the wrong
term to use in this discussion.

?Plausible deniability? is a transparent excuse for explaining away an
indisputable fact which arouses suspicion?when you got some serious
?splain? to do.  This is usually used in the context of some pseudolegal
argument about introducing ?reasonable doubt?, or even making ?probable
cause? a wee bit less probable.

?Why yes, officer:  I was seen carrying an axe down the street near the
site of an axe murder, at approximately the time of said axe murder.
But I do have a fireplace; so it is plausible that I was simply out
gathering wood.?

I rather suspect the concept of ?plausible deniability? of having been
invented by a detective or agent provocateur.  There are few concepts
more useful for helping suspects shoot themselves in the foot, or
frankly, for entrapping people.

One of the worst examples I have seen is in discussions of Monero,
whereby I?ve seen proponents claim that even under the worst known
active attacks, their mix scheme reduces transaction linking to a
maximum of 20?40% probability.  ?That?s not good enough to convince a
jury!?  No, but it is certainly adequate for investigators to identify
you as a person of interest.  Then, your (mis)deeds can be subjected to
powerful confirmation attacks based on other data; blockchains do not
exist in isolation.  I usually stay out of such discussions; for I have
no interest in helping the sorts of people whose greatest concern in
life is what story to foist on a jury.

In the context of devices such as Trezor, what is needed is not
?plausible deniability?, but rather the ability to obviate any need to
deny anything at all.  I must repeat, information does not exist in
isolation.

If you are publicly known to be deepy involved in Bitcoin, then nobody
will believe that your one-and-only wallet contains only 0.01 BTC.
That?s not even ?plausible?.  But if you have overall privacy practices
which leave nobody knowing or suspecting that you have any Bitcoin at
all, then there is nothing to ?deny?; and should a Trezor with
(supposedly) 0.01 BTC be found in your possession, that?s much better
than ?plausible?.  It?s completely unremarkable.

Whereas if you are known or believed to own large amounts of BTC, a
realistic bad guy?s response to your ?decoy? wallet could be, ?I don?t
believe you; and it costs me nothing to keep beating you with rubber
hose until you tell me the *real* password.?

It could be worse, too.  In a kidnapping scenario, the bad guys could
say, ?I don?t believe you.  Hey, I also read Trezor?s website about
?plausible deniability?.  Now, I will maim your kid for life just to
test whether you told me the *real* password.  And if you still don?t
tell me the real password after you see that little Johnny can no longer
walk, then I will kill him.?

The worst part is that you have no means of proving that you really
*did* give the real password.  Indeed, it can be proved if you?re lying
by finding a password which reveals a hidden wallet?but *you* have no
means of affirmatively proving that you are telling the truth!  If the
bad guys overestimated your riches (or if they?re in a bad mood), then
little Johnny is dead either way.

In a legalistic scenario, if ?authorities? believe you have 1000 BTC and
you only reveal a password for 0.01 BTC, the likely response will not be
to let you go.  Rather, ?You will now sit in jail until you tell the
*real* password.?  And again:  You have no means of proving that you did
give the real password!

?Plausible deniability? schemes can backfire quite badly.

>Also note how this blog doesn't mention anti-forensics: the wallet
>software itself may leave traces of the other wallets on the computer.
>Have they really audited it sufficiently to be sure this isn't the
>case?

What about data obtained via the network?  I don?t *only* refer to
dragnet surveillance.  See for but one e.g., Goldfelder, et al., ?When
the cookie meets the blockchain:  Privacy risks of web payments via
cryptocurrencies? https://arxiv.org/abs/1708.04748  Your identity can be
tied to your wallet all sorts of ways, any of which could be used to
prove that you have more Bitcoin than you?re revealing.  Do you know
what databases of cross-correlated analysis data customs agents have
immediate access to nowadays?or will, tomorrow?  I don?t.

In the scenario under discussion, that may not immediately prove ?beyond
a reasonable doubt? that you lied specifically about your Trezor.  But
it could give plenty of cause to keep you locked up in a small room
while your hard drive is examined for evidence that Trezor apps handled
*addresses already known to be linked to you*.  Why even bother with
bruteforce?  Low-hanging fruit abound.

>1) https://blog.trezor.io/hide-your-trezor-wallets-with-multiple-passphrases-f2e0834026eb

--
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180113/f8efb9d9/attachment-0001.html>

From pete at petertodd.org  Sat Jan 13 06:11:12 2018
From: pete at petertodd.org (Peter Todd)
Date: Sat, 13 Jan 2018 01:11:12 -0500
Subject: [bitcoin-dev] Plausible Deniability (Re: Satoshilabs secret
 shared private key scheme)
In-Reply-To: <bd9283ec34396d769a84664ac5ae9206@nym.zone>
References: <CAAS2fgR-or=zksQ929Muvgr=sgzNSugGp669ZWYC6YkvEG=H5w@mail.gmail.com>
	<ae570ccf-3a2c-a11c-57fa-6dad78cfb1a5@satoshilabs.com>
	<CAAS2fgRQvpa8VXE8YAYSfugDvCu=1+5ANsGk1V_OXtHPGD=Ltw@mail.gmail.com>
	<vJsDz9YdeNQQ_PZRf5HP1W0FmcWyKHIuwN9QeNgN-WXCdQcRmXLtkQ3wfTO7YUCgG6AFgOkKeU6fdsGTKkGcnk-_OOY_jyNlfWkFQ31d2ZU=@protonmail.com>
	<20180109011335.GA22039@savin.petertodd.org>
	<274aad5c-4573-2fdd-f8b0-c6c2d662ab7c@gibsonic.org>
	<20180112095058.GA9175@savin.petertodd.org>
	<3b45c17a256326b6b183587d9d15690c@nym.zone>
	<PS2P216MB01793245561CC130C6FEEC9A9D140@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<bd9283ec34396d769a84664ac5ae9206@nym.zone>
Message-ID: <20180113061112.GA14217@savin.petertodd.org>

On Sat, Jan 13, 2018 at 03:44:03AM +0000, nullius via bitcoin-dev wrote:
> (I think that next, I may start writing my disks with headers for LUKS,
> which I do not use...)
> 
> Whereupon, I challenge plausible deniability designers to `dd` a 6TB disk
> with pseudorandom bytes, then try walking it across the U.S. border until it
> gets searched.  What could possibly go wrong?  Should you be ordered to
> decrypt it, the disk *could* be *plausibly* filled with pseudorandom bytes;
> and you would not be committing the crime of lying to an officer, when you
> truly state that in fact, it *is* filled with pseudorandom bytes.

It's very common for disks to be filled with pseudorandom data; this is not
suspicious at all. For example:

1) An encrypted partition that is filled, and later reformatted, will be left
full of random bytes. Even if you give border security your passphrase, the
unused space in the encrypted partition will be random data. (an exception
being most - but not all! - SSD's where TRIM has been used)

2) Modern drives (SSD and HD) often implement fast secure erasure with
encryption, which means that the actual data stored to disk or FLASH is
*always* encrypted. If such a drive is wiped, the encryption keys are replaced,
which means whatever data was stored becomes random noise (the encrypted data
is usually not authenticated). This also means that such drives can arrive from
the factory filled with random noise.

3) Software disk encryption schemes have the same property: reformatting
results in a drive filled with random noise.

The latter is particularly interesting with LUKS, as you can do all kinds of
things like erase the drive with luksErase, while keeping a backup of the LUKS
header elsewhere.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180113/d38b1f89/attachment.sig>

From lf-lists at mattcorallo.com  Sun Jan 14 22:41:55 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Sun, 14 Jan 2018 22:41:55 +0000
Subject: [bitcoin-dev] Ivy: a higher-level language targeting Bitcoin
	Script
In-Reply-To: <CAD438HvzYAMVTU8A0OiNnj2nvYgMApdS8NNfzE86Ae_OsTfuaA@mail.gmail.com>
References: <CAD438HvzYAMVTU8A0OiNnj2nvYgMApdS8NNfzE86Ae_OsTfuaA@mail.gmail.com>
Message-ID: <1CCF3C59-64DB-462F-AC62-AEA77FA01571@mattcorallo.com>

I'm curious if you've considered adding some form of compiler-time enforcement to prevent witness malleability? With that, Ivy could help to resolve for it's users one of the things that can make Bitcoin scripts more complicated to write, instead of simply type-checking and providing a high-level language mapped 1-to-1 with Bitcoin script.

On December 18, 2017 8:32:17 PM UTC, Daniel Robinson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Today, we?re releasing Ivy, a prototype higher-level language and
>development environment for creating custom Bitcoin Script programs.
>You
>can see the full announcement here
><https://blog.chain.com/ivy-for-bitcoin-a-smart-contract-language-that-compiles-to-bitcoin-script-bec06377141a>,
>or check out the docs <https://docs.ivy-lang.org/bitcoin/> and source
>code
><https://github.com/ivy-lang/ivy-bitcoin>.
>
>Ivy is a simple smart contract language that can compile to Bitcoin
>Script.
>It aims to improve on the useability of Bitcoin Script by adding
>affordances like named variables and clauses, static (and
>domain-specific)
>types, and familiar syntax for function calls.
>
>To try out Ivy, you can use the Ivy Playground for Bitcoin
><https://ivy-lang.org/bitcoin/>, which allows you to create and test
>simulated contracts in a sandboxed environment.
>
>This is prototype software intended for educational and research
>purposes
>only. Please don't try to use Ivy to control real or testnet Bitcoins.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180114/530b8a17/attachment.html>

From danrobinson010 at gmail.com  Mon Jan 15 22:39:05 2018
From: danrobinson010 at gmail.com (Daniel Robinson)
Date: Mon, 15 Jan 2018 22:39:05 +0000
Subject: [bitcoin-dev] Ivy: a higher-level language targeting Bitcoin
	Script
In-Reply-To: <1CCF3C59-64DB-462F-AC62-AEA77FA01571@mattcorallo.com>
References: <CAD438HvzYAMVTU8A0OiNnj2nvYgMApdS8NNfzE86Ae_OsTfuaA@mail.gmail.com>
	<1CCF3C59-64DB-462F-AC62-AEA77FA01571@mattcorallo.com>
Message-ID: <CAD438Ht8x5-v8NsC7O=D7Oo5EZ56q5E3LKuVt033as-8iqtd=Q@mail.gmail.com>

Hi Matt,

Thanks for raising this. Since the compiler only produces SegWit addresses,
I hadn't worried at all about malleability, but as you pointed out
out-of-band, malleability in the length of an argument can allow an
attacker to deflate the feerate of a transaction.

There was in fact a minor witness malleability problem with how the
compiler was handling clause selection. It's now been fixed in version
0.0.7 of the compiler.

As far as I can tell (and I haven't looked all that carefully), any
sensible Ivy contract won't have any witness malleability problem. (A funny
exception is the RevealCollision contract, since you can length-extend the
arguments to get another collision. But without a signature check, that one
has a more serious transaction malleability problem anyway.) But the
compiler currently doesn't prevent you from doing dumb unconstrained stuff
like:

```
clause spend(a: Bytes, b: Bytes, sig: Signature) {
  verify a == b
  verify checkSig(publicKey, sig)
  unlock val
}
```

Maybe it should, particularly since there's no reason to include a trivial
condition like that anyway. But I think it would probably be about as easy
(and more generally useful) to build a static analyzer that solved this
problem for low-level Bitcoin Script.

On Sun, Jan 14, 2018 at 5:42 PM Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> I'm curious if you've considered adding some form of compiler-time
> enforcement to prevent witness malleability? With that, Ivy could help to
> resolve for it's users one of the things that can make Bitcoin scripts more
> complicated to write, instead of simply type-checking and providing a
> high-level language mapped 1-to-1 with Bitcoin script.
>
>
> On December 18, 2017 8:32:17 PM UTC, Daniel Robinson via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Today, we?re releasing Ivy, a prototype higher-level language and
>> development environment for creating custom Bitcoin Script programs. You
>> can see the full announcement here
>> <https://blog.chain.com/ivy-for-bitcoin-a-smart-contract-language-that-compiles-to-bitcoin-script-bec06377141a>,
>> or check out the docs <https://docs.ivy-lang.org/bitcoin/> and source
>> code <https://github.com/ivy-lang/ivy-bitcoin>.
>>
>> Ivy is a simple smart contract language that can compile to Bitcoin
>> Script. It aims to improve on the useability of Bitcoin Script by adding
>> affordances like named variables and clauses, static (and domain-specific)
>> types, and familiar syntax for function calls.
>>
>> To try out Ivy, you can use the Ivy Playground for Bitcoin
>> <https://ivy-lang.org/bitcoin/>, which allows you to create and test
>> simulated contracts in a sandboxed environment.
>>
>> This is prototype software intended for educational and research purposes
>> only. Please don't try to use Ivy to control real or testnet Bitcoins.
>>
>>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180115/ee189ac5/attachment.html>

From felix.wolfsteller at gmail.com  Mon Jan 15 14:33:28 2018
From: felix.wolfsteller at gmail.com (Felix Wolfsteller)
Date: Mon, 15 Jan 2018 15:33:28 +0100
Subject: [bitcoin-dev] Update links (use ssl-variant) to
	opensource.org/[..x..]MIT ?
In-Reply-To: <CALHCSvOn8YxFqGu4yXDPnFunNzmy=cmdwKBNmAL45Ymta3REig@mail.gmail.com>
References: <CALHCSvOn8YxFqGu4yXDPnFunNzmy=cmdwKBNmAL45Ymta3REig@mail.gmail.com>
Message-ID: <CALHCSvMFro4v8g0f1yFT6jUdry7wKpJZyYgFU0NTbm2LG-5GRw@mail.gmail.com>

I am a bit disappointed about the feedback (just received one off-list ;)
), but understand now that this mailing list is protocol-only discussions.
So - sorry for that. Anybody interested can follow progress here:
https://github.com/bitcoin/bitcoin/issues/12190
Thanks, Felix

On Thu, Jan 4, 2018 at 11:08 AM, Felix Wolfsteller <
felix.wolfsteller at gmail.com> wrote:

> Hey there
> Most source files contain the "default" copyright-header (also build by a
> script in devtools/copyright_header.py), which points out that the MIT
> license can be found in the COPYING file or at http://www.opensource.org/
> licenses/mit-license.php.
>
> However, the provided link is 1) using http where it could use https, 2)
> resulting in a redirect (https://opensource.org/licenses/mit-license.php)
> anyway.
> I am strongly in favor of using https where possible (I guess there are
> many other non-ssl links in the code base, but lets tackle the easier ones
> first).
>
> I propose that I
> 1) create a issue on github,
> 2) `sed -i` the relevant links,
> 3) create a PR on github,
> 4) come back to the mailing list.
>
> This change would affect a few hundred files I guess.
>
> A question remaining is this change would require a
> copyright-year-extension (to 2018), too.
>
> An example header can be seen e.g. here
> https://github.com/bitcoin/bitcoin/blob/a9a49e6e7e8df13d80a6dc3245ce7e
> f041942e9b/src/consensus/merkle.cpp#L3
>
> I'd be happy about quick feedback - do not know the culture here, yet.
>
> Have fun
> Felix
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180115/9d29b778/attachment.html>

From enrique.arizonbenito at gmail.com  Mon Jan 15 22:47:54 2018
From: enrique.arizonbenito at gmail.com (=?UTF-8?Q?Enrique_Ariz=C3=B3n_Benito?=)
Date: Mon, 15 Jan 2018 23:47:54 +0100
Subject: [bitcoin-dev] Proposal to reduce mining power bill
Message-ID: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>

Hi all,

just new to the list and curious to know if next proposal (or similar) for
reducing mining-power consumption has already been discussed.

The objective is to reduce the power consumption required while keeping the
network safe and the miners "motivated" and cooperative to continue mining:

The global idea is to introduce the concept of "next-coinbase" for miners.
This will work something like as follow:

- Any miner submitting a block will submit the "next-coinbase" for any new
block mined by itself. (This address can be the same one or different from
the just mined block). The miner keeps the private key associated with the
"next-coinbase" secret.

- The consensus algorithm will add next checks:
 A hash from, for example, the just mined block and the previous one, will
have to match up to N bits for the next "next-coinbase" from the next block
to be valid.

 That means that for the next block only 1/2^N bitcoin addresses will be
accepted from the previously submitted "next-coinbase" list.

Since the last previous block hash can be considered random, miners know in
advance whether they will be able to participate or not in the next block
depending on the just submited "next-coinbase". And since the "punishment"
is distributed uniformely random to all miners no one has any advantage
over the other. But the global miner netwok will consume much less power.

A detail rest: New miners are not allowed in such scheme so next addition
is needed:

- A miner with no previous "next-coinbase" will need to first mine an
special block, "new-miner-block", that instead of normal transactions will
register the new miner and submit a "next-coinbase". This special block
will not be rewarded with new bitcoins. The only reward will be the
permission to mine in following blocks. No reward is applied so only new
miners wanting to "enter" the mining network are expected to create such
block.

Best Regards,

E. Ariz?n Benito
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180115/c70463fc/attachment.html>

From nullius at nym.zone  Tue Jan 16 00:10:38 2018
From: nullius at nym.zone (nullius)
Date: Tue, 16 Jan 2018 00:10:38 +0000
Subject: [bitcoin-dev] Proposal to reduce mining power bill
In-Reply-To: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>
References: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>
Message-ID: <5e93f4b0e82ddf4eba5f1f54923e153f@nym.zone>

On 2018-01-15 at 22:47:54 +0000, Enrique Ariz?n Benito 
<enrique.arizonbenito at gmail.com> wrote:
>Hi all,
>
>just new to the list and curious to know if next proposal (or similar) 
>for reducing mining-power consumption has already been discussed.
>
>The objective is to reduce the power consumption required while keeping 
>the network safe and the miners "motivated" and cooperative to continue 
>mining:
>
>The global idea is to introduce the concept of "next-coinbase" for 
>miners. This will work something like as follow:
>
>- Any miner submitting a block will submit the "next-coinbase" for any 
>new block mined by itself. (This address can be the same one or 
>different from the just mined block). The miner keeps the private key 
>associated with the "next-coinbase" secret.
>
>- The consensus algorithm will add next checks:
> A hash from, for example, the just mined block and the previous one, 
>will have to match up to N bits for the next "next-coinbase" from the 
>next block to be valid.
>
> That means that for the next block only 1/2^N bitcoin addresses will 
>be accepted from the previously submitted "next-coinbase" list.
>
>Since the last previous block hash can be considered random, miners 
>know in advance whether they will be able to participate or not in the 
>next block depending on the just submited "next-coinbase". And since 
>the "punishment" is distributed uniformely random to all miners no one 
>has any advantage over the other. But the global miner netwok will 
>consume much less power.
>
>A detail rest: New miners are not allowed in such scheme so next 
>addition is needed:
>
>- A miner with no previous "next-coinbase" will need to first mine an 
>special block, "new-miner-block", that instead of normal transactions 
>will register the new miner and submit a "next-coinbase". This special 
>block will not be rewarded with new bitcoins. The only reward will be 
>the permission to mine in following blocks. No reward is applied so 
>only new miners wanting to "enter" the mining network are expected to 
>create such block.

Observation:  This totally destroys Bitcoin?s transaction-ordering 
security.  A ?51% attack? could be executed by any miner who has >50% of 
the hashpower *proportionate to miners who are allowed to mine a 
particular block*, rather than >50% of *global* hashpower.  (I infer 
that this could be done retroactively, and wave my hands over some of 
the details since you did not talk about reorgs.)  The same applies as 
for attacks requiring 33% or 25% of total hashpower.

Potential attack, assuming that N *must* be based partly or wholly on 
the existing set of ?next-coinbase? addresses:  A large miner could 
gradually push N higher, by progressively committing new ?next-coinbase? 
addresses which differ in the next bit for all previously seen 
combinations of bits.  Large miners would have a vast advantage over 
small miners, insofar as deliberately incrementing N by one more bit 
could only be done by a miner who creates 2^(N+1) blocks (= 2 * 2^N).  
By such means, it may be possible for a very large miner to eventually 
lock out all other miners altogether, and monopolize all Bitcoin mining.

Now, questions:

How is N determined?  By a wave of the hands?

What part of which block hash is matched against N bits?  You were quite 
unclear about this, and other important details.  (Much of what I say 
here is based on assumptions and inferences necessary to fill in the 
blanks.)

How, exactly, are reorgs handled?

How does this interact with the difficulty adjustment algorithm?  
Indeed, how is difficulty determined at all under your scheme?

What happens to coinbase fees from a ?new-miner-block??  The way I read 
your scheme, the ?new-miner-block? must necessarily have no payout 
whatsoever.  But you discuss only ?new bitcoins?, which are a 
diminishing portion of the block reward, and will eventually reach zero.  
Coinbase from fees must go somewhere; but under your scheme, a ?new 
miner? has no payable address.

What if no existing ?next-coinbase? address matches?  Is N constrained 
to be sufficiently short that a match is guaranteed from the existing 
set, then that makes it trivial for large mining farms to collect 
addresses and further dominate (or even monopolize) the network in the 
attack described above.  If it isn?t, then the network could suddenly 
halt when nobody is allowed to mine the next block; and that would 
enable *this* attack:

What stops a malicious miner (including a ?new miner? creating a 
?new-miner block?) from deliberately working to create a block with a 
hash which does not have N bits matching any of the existing 
?next-coinbase? addresses?  Contra what you say, block hashes can?t be 
?considered random?.  Indeed, partial preimage bruteforcing of block 
hashes is the entire basis of mining POW.

Asking here more generally than as for the attack described above, what 
stops mining farms with large hashpower from submitting many different 
?next-coinbase? addresses in many different blocks?  If N be small, then 
it should be feasible for a large mining farm to eventually register a 
set of ?next-coinbase? addresses which match any N.  **This increases 
mining centralization.**  If N be large, then this creates the 
possibility (or raises the probability) that no address will match, and 
nobody will be allowed to mine the next block.

How could miner anonymity be preserved under a scheme whereby each 
?next-coinbase? address can be linked to a previous ?next-coinbase? 
address?  The only way to start fresh would be with a prohibitively 
expensive no-payout block.  Mining can be totally anonymous at present, 
and must so remain.  Miners are only identified by certain information 
they choose to put in a block header, which they could choose to change 
or omit?or by IP address, which is trivially changed and is never a 
reliable identifier.

How does this even save electricity, when there is much mining equipment 
(especially on large mining farms) which cannot be easily shut down and 
restarted?  (Allegedly, this is one reason why some big miners 
occasionally mine empty blocks.)  Though I suppose that difficulty would 
drop by unspecified means.

Further observations:

This scheme drastically increases the upfront investment required for a 
new miner to start mining.  To mine even one new block all by oneself, 
without a pool, already requires a huge investment.  Add to that the 
uncompensated energy cost of mining that first block with *no* payout, 
and I expect that the bar would be prohibitive to almost all new 
entrants.  Mining costs and incentives are delicately balanced by the 
design of the network.  Whereas incumbents are much favoured by your 
scheme, further increasing miner centralization.  Large incumbents could 
also use this to produce a mining permissions market, by selling the 
private keys to committed ?next-coinbase? addresses.

I have not even tried to imagine what oddball attacks might be possible 
for any miner with sufficient hashpower to deliberately cause a small 
reorg.

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180116/7325d4d4/attachment-0001.sig>

From rusty at rustcorp.com.au  Tue Jan 16 01:06:14 2018
From: rusty at rustcorp.com.au (Rusty Russell)
Date: Tue, 16 Jan 2018 11:36:14 +1030
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <CAMZUoKn4noCEQR6eqf9hiZSMdk-3b8UHR1NrEFrKNoLSMzVjGQ@mail.gmail.com>
References: <87608btgyd.fsf@rustcorp.com.au>
	<DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>
	<CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>
	<CAMZUoKn4noCEQR6eqf9hiZSMdk-3b8UHR1NrEFrKNoLSMzVjGQ@mail.gmail.com>
Message-ID: <87zi5ehat5.fsf@rustcorp.com.au>

"Russell O'Connor" <roconnor at blockstream.io> writes:
> However, if I understand correctly, the situation for BIP 117 is entirely
> different.  As far as I understand there is currently no restrictions about
> terminating a v0 witness program with a non-empty alt-stack, and there are
> no restrictions on leaving non-canonical boolean values on the main stack.

BIP-141: "The script must not fail, and result in exactly a single TRUE
on the stack."  And it has long been non-standard for P2SH scripts to
not do the same (don't know exactly when).

> There could already be commitments to V0 witness programs that, when
> executed in some reasonable context, leave a non-empty alt-stack and/or
> leave a non-canonical true value on the main stack.  Unlike the P2SH or
> Segwit soft-forks, these existing commitments could be real outputs that
> currently confer non-trivial ownership over their associated funds.  If BIP
> 117 were activated, these commitments would be subject to a new set of
> rules that didn't exist when the commitments were made.  In particular,
> these funds could be rendered unspendable.  Because segwit commitments are
> hashes of segwit programs, there is no way to even analyze the blockchain
> to determine if these commitments currently exist (and even if we could it
> probably woudln't be adequate protection).

The rule AFAICT is "standard transactions must still work".  This was
violated with low-S, but the transformation was arguably trivial.  

OTOH, use of altstack is completely standard, though in practice it's
unused and so only a theoretical concern.

My concern remains unanswered: I want hard numbers on the worst-case
time taken by sigops with the limit removed.  It's about 120 usec per
sigop (from [1]), so how bad could it be?  I think Russell had an
estimate like 1 in 3 ops, so 160 seconds to validate a block?

Thanks,
Rusty.
[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015346.html

From greg at xiph.org  Tue Jan 16 03:27:26 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 16 Jan 2018 03:27:26 +0000
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <87zi5ehat5.fsf@rustcorp.com.au>
References: <87608btgyd.fsf@rustcorp.com.au>
	<DB7E57AC-5588-4BBA-9ABC-B9B4F6BAECE2@friedenbach.org>
	<CAPg+sBgRrqZryiETZYCWiqHNOmN2bCfsvr30znjN-gKiU5Vfjg@mail.gmail.com>
	<CAMZUoKn4noCEQR6eqf9hiZSMdk-3b8UHR1NrEFrKNoLSMzVjGQ@mail.gmail.com>
	<87zi5ehat5.fsf@rustcorp.com.au>
Message-ID: <CAAS2fgTPjAeSK_EeVabtsnBFZe6OEG=2wb+FKeAzaXYWsCHVxw@mail.gmail.com>

On Tue, Jan 16, 2018 at 1:06 AM, Rusty Russell via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The rule AFAICT is "standard transactions must still work".  This was
> violated with low-S, but the transformation was arguably trivial.

That is my view, generally.  Like any other principle, its
applicability is modulated by the specific facts.

For low-s the most critical mitigating specific facts were (in order
of importance):  Any third party could malleate non-conforming
transactions to make them conform and that code to do this was written
and run,  that S-value malleation was being actively attacked at the
time, and that the intention to eventually enforce lowS had been made
clear a long time ahead and the vast majority of transactions were
already conforming.

In particular these facts meant that the change could not result in
the confiscation of funds except in the case of a key-destroyed
unconfirmed chain of timelock transactions which was already highly
vulnerable due to the malleation attacks -- and even there, the
non-standardness step itself wouldn't destroy the funds esp. given the
malleation risk redemption of that sort of chain would probably be
best accomplished with the collaboration of a miner.

From luke at dashjr.org  Tue Jan 16 04:15:54 2018
From: luke at dashjr.org (Luke Dashjr)
Date: Tue, 16 Jan 2018 04:15:54 +0000
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <87zi5ehat5.fsf@rustcorp.com.au>
References: <87608btgyd.fsf@rustcorp.com.au>
	<CAMZUoKn4noCEQR6eqf9hiZSMdk-3b8UHR1NrEFrKNoLSMzVjGQ@mail.gmail.com>
	<87zi5ehat5.fsf@rustcorp.com.au>
Message-ID: <201801160415.55197.luke@dashjr.org>

On Tuesday 16 January 2018 1:06:14 AM Rusty Russell via bitcoin-dev wrote:
> "Russell O'Connor" <roconnor at blockstream.io> writes:
> > However, if I understand correctly, the situation for BIP 117 is entirely
> > different.  As far as I understand there is currently no restrictions
> > about terminating a v0 witness program with a non-empty alt-stack, and
> > there are no restrictions on leaving non-canonical boolean values on the
> > main stack.
> 
> BIP-141: "The script must not fail, and result in exactly a single TRUE
> on the stack."  And it has long been non-standard for P2SH scripts to
> not do the same (don't know exactly when).

This doesn't affect the alt-stack (it's a completely separate stack).

> The rule AFAICT is "standard transactions must still work".  This was
> violated with low-S, but the transformation was arguably trivial.
> 
> OTOH, use of altstack is completely standard, though in practice it's
> unused and so only a theoretical concern.

I'm not aware of a single standard/BIP that uses the altstack at all.

Luke

From roconnor at blockstream.io  Tue Jan 16 08:39:28 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 16 Jan 2018 03:39:28 -0500
Subject: [bitcoin-dev] BIP 117 Feedback
In-Reply-To: <201801160415.55197.luke@dashjr.org>
References: <87608btgyd.fsf@rustcorp.com.au>
	<CAMZUoKn4noCEQR6eqf9hiZSMdk-3b8UHR1NrEFrKNoLSMzVjGQ@mail.gmail.com>
	<87zi5ehat5.fsf@rustcorp.com.au> <201801160415.55197.luke@dashjr.org>
Message-ID: <CAMZUoKkb1zcw7N=_Gn3_0miuNVP_LKSYkbeA-U2Yt8+b2G+b7w@mail.gmail.com>

On Mon, Jan 15, 2018 at 11:15 PM, Luke Dashjr <luke at dashjr.org> wrote:

> On Tuesday 16 January 2018 1:06:14 AM Rusty Russell via bitcoin-dev wrote:
> > The rule AFAICT is "standard transactions must still work".  This was
> > violated with low-S, but the transformation was arguably trivial.
> >
> > OTOH, use of altstack is completely standard, though in practice it's
> > unused and so only a theoretical concern.
>
> I'm not aware of a single standard/BIP that uses the altstack at all.
>

By "standard transaction" here, Rusty means that (P2SH or Segwit) scripts
that use the alt-stack pass the standardness checks and will be relayed by
recent Bitcoin Core software.

----

Regarding lowS:  I think the more severe standardness change was the added
requirement that (some of the) pubkeys in a multisig must be parsable.  I
have talked with people who cannot retrieve their funds now, when before
they could.  However, like lowS, this was only a change to the standardness
rules and not a consensus change, so these funds are not necessarily
permanently lost.  They can be retrieved with miner help.

I don't see how BIP 117, which is a change in consensus rules that could
cause permanent loss of otherwise well-secured funds (in addition to the
other issues raised about BIP 117), is even comparable to the previous
changes in only the standardness rules.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180116/ac9e85b8/attachment.html>

From contact at taoeffect.com  Tue Jan 16 18:15:16 2018
From: contact at taoeffect.com (Tao Effect)
Date: Tue, 16 Jan 2018 10:15:16 -0800
Subject: [bitcoin-dev] The DCS Theorem - theory for understanding blockchain
	scalability
Message-ID: <E9C2F990-BAFA-4FA5-A6D2-AB1327B7E078@taoeffect.com>

The DCS Triangle was independently discovered by myself and Trent McConaghy.

It is a useful tool for clearing confusion about blockchain scalability and blocksize-related debates.

The DCS Theorem is a probability proof of the triangle, and it's now on arXiv:

https://arxiv.org/abs/1801.04335 <https://arxiv.org/abs/1801.04335>

Cheers,
Greg

--
Please do not email me anything that you are not comfortable also sharing with the NSA.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180116/e3a21433/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 833 bytes
Desc: Message signed with OpenPGP
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180116/e3a21433/attachment.sig>

From li3939108 at gmail.com  Wed Jan 17 07:55:54 2018
From: li3939108 at gmail.com (Chaofan Li)
Date: Wed, 17 Jan 2018 01:55:54 -0600
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
Message-ID: <CANZDnNomrpBTJU4=J1QqJpDePJ6RXyYsrwa=b9ZZOjyf1utQBw@mail.gmail.com>

Here I propose a simple method to solve the scalability issue of blockchain.
It is more like a financial trick rather than a technical solution.

The technical part is very simple:
Split ( hard fork ) the blockchain into two or more blockchains (e.g. two
blockchain A and B), voluntarily.
The two blockchains are the same except for some identifiers to distinguish
the two blockchains.
The coins on one blockchains cannot be sent to the other one or interfered
by the other blockchain (  considering so many hard forks in the last year,
the replay protection should work in this situation)
Everyone get double bitcoins. Each has half  value of original one bitcoin.
Then, we have two almost same blockchains and the capacity of the original
blockchain is doubled theoretically.
When sending coin, the wallet should select one blockchain randomly and try
to send through only  one blockchain (If there is enough bitcoins)
I think it is a  possible solution, if the community realize  no previously
owned asset value  is lost.

The method is inspired by the stock split
<https://en.wikipedia.org/wiki/Stock_split>.
When a stock share is split, for example into two shares, the price halves.
The market capitalization remains the same.
There is no dilution of every shareholders' total assets.

The bitcoin often emphasizes that the total coin supply should not be
changed.
If the total supply increases, the value of a single coin will be diluted.
That is true.
However, the bad part of inflation of fiat money is not  diluted value of
every unit of fiat money caused by total supply increase.
The problem is the increased supply is not delivered to everyone
proportional to their previously owned money.
The increased supply is released through debt expansion.
The people that can borrow more money with low interest ratio (during QE,
it was nearly 0) can invest  and get profit.
Or they don't even need to pay back the debt. The debt is left to
government, which might never pay back the debt, and some  get more money
from government.
Others' money are diluted.

With voluntary split of bitcoin, dilution of anyone's bitcoin assets won't
happen.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180117/914227fe/attachment.html>

From ondrej.vejpustek at satoshilabs.com  Wed Jan 17 11:39:42 2018
From: ondrej.vejpustek at satoshilabs.com (=?UTF-8?Q?Ond=c5=99ej_Vejpustek?=)
Date: Wed, 17 Jan 2018 12:39:42 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
Message-ID: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>

The entropy argument is as follows:

There is a rule of thumb which says it is safer plaintext to have low
redundancy, see
https://en.wikipedia.org/wiki/Redundancy_(information_theory), i. e.
it's better to encrypt random or compressed data than natural language.
This rule is based on Shannon's information theory which means that a
breach of the rule usually doesn't induce a vulnerability (there is no
known generic attack). This rule is application of a precautionary
principle.

Nevertheless, here are some examples of cryptographic attacks which may
be considered as a consequence of the breach of the rule:
  * Related Message Attack by Coppersmith, Franklin, Patarin, Reiter
(https://pdfs.semanticscholar.org/899a/4fdc048102471875e24f7fecb3fb8998d754.pdf)
- given RSA ciphertext of two plaintexts x and a*x + b, where a, b are
known, it's possible to effectively compute x provided public exponent
is three. From the informaton-theoretic point of view the second message
is redundant, because it's determined by the first one. Which means that
relative redundancy of both messages is at least one half.
  * Stereotyped Messages by Coppersmith
(https://www.di.ens.fr/~fouque/ens-rennes/coppersmith.pdf, section 7) -
given RSA ciphertext and (1-1/e) fraction of plaintext (where e is
public exponent), it's possible to effectively compute x. Message is
highly redundant, because only 1/e of the message is unknown. Relative
redundancy of the message is at least (1-1/e).

Consider a few notes:
  * Nowadays there exists more complicated variants of mentioned attacks
which have weaker premisses.
  * There is a considerable similarity between RSA and SSS. Both schemes
are algebraically-based (rather than boolean function based).
  * CRCs (and error-correcting codes generally) introduce redundancy
into the message. Moreover the redundancy is induced by a linear
relationship among message (compare with the premise of the Related
Message Attack).
  * Related Message Attack wouldn't be possible if you had two
plaintexts x and hash(x). The relationship between messages has to be
(algebraically) uncomplicated. From the information-theoretic point of
view the situation is the same, but from the practical point of view it
is completely different.

To sum it up, there is a precautionary principle which tells us not to
increase redundancy of a message unless it is introduced in a
complicated way (for example by a hash function). That's why we use SHA
rather than CRC. One more reason why we stick to the principle is that
there's no randomisation in our scheme (such as padding or
initialisation vector). We understood advantages of error-correctings
codes over hash functions (minimal codewords distance property,
performance) and we considered it thoroughly.

Ond?ej Vejpustek

From roconnor at blockstream.io  Wed Jan 17 15:28:15 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Wed, 17 Jan 2018 10:28:15 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
Message-ID: <CAMZUoKnJM+U0QrVgD1VP4Q=krYDHmCn-poydVrz79r-w-89+yw@mail.gmail.com>

Hi Ond?ej,

1. There is no similarity between SSS and RSA or any other public-key or
symmetric crypto.  SSS is effectively a one-time pad and is
information-theoretically secure.

2. Even if there were a problem (which there cannot be, due to (1)), using
error correcting codes and truncated hash functions create identical
amounts of information theoretic redundancy.

Let me repeat that SSS is "information-theoretically secure"!  It isn't
only computationally infeasible to break SSS; it is impossible to break
SSS.  If you have all but one necessary share of SSS, there is no
information leaked about the the hidden data, because for every possible
message that could be encoded, there exists some final share that would
decode to that message.  Any of the possibilities for the missing final
share are equally as likely.

It is of no use to apply the precautionary principle against impossible
attacks, especially at the cost of losing the useful properties of a real
error correcting codes that would provide actual guarantees against likely
errors.

On Wed, Jan 17, 2018 at 6:39 AM, Ond?ej Vejpustek via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> The entropy argument is as follows:
>
> There is a rule of thumb which says it is safer plaintext to have low
> redundancy, see
> https://en.wikipedia.org/wiki/Redundancy_(information_theory), i. e.
> it's better to encrypt random or compressed data than natural language.
> This rule is based on Shannon's information theory which means that a
> breach of the rule usually doesn't induce a vulnerability (there is no
> known generic attack). This rule is application of a precautionary
> principle.
>
> Nevertheless, here are some examples of cryptographic attacks which may
> be considered as a consequence of the breach of the rule:
>   * Related Message Attack by Coppersmith, Franklin, Patarin, Reiter
> (https://pdfs.semanticscholar.org/899a/4fdc048102471875e24f7fecb3fb89
> 98d754.pdf)
> - given RSA ciphertext of two plaintexts x and a*x + b, where a, b are
> known, it's possible to effectively compute x provided public exponent
> is three. From the informaton-theoretic point of view the second message
> is redundant, because it's determined by the first one. Which means that
> relative redundancy of both messages is at least one half.
>   * Stereotyped Messages by Coppersmith
> (https://www.di.ens.fr/~fouque/ens-rennes/coppersmith.pdf, section 7) -
> given RSA ciphertext and (1-1/e) fraction of plaintext (where e is
> public exponent), it's possible to effectively compute x. Message is
> highly redundant, because only 1/e of the message is unknown. Relative
> redundancy of the message is at least (1-1/e).
>
> Consider a few notes:
>   * Nowadays there exists more complicated variants of mentioned attacks
> which have weaker premisses.
>   * There is a considerable similarity between RSA and SSS. Both schemes
> are algebraically-based (rather than boolean function based).
>   * CRCs (and error-correcting codes generally) introduce redundancy
> into the message. Moreover the redundancy is induced by a linear
> relationship among message (compare with the premise of the Related
> Message Attack).
>   * Related Message Attack wouldn't be possible if you had two
> plaintexts x and hash(x). The relationship between messages has to be
> (algebraically) uncomplicated. From the information-theoretic point of
> view the situation is the same, but from the practical point of view it
> is completely different.
>
> To sum it up, there is a precautionary principle which tells us not to
> increase redundancy of a message unless it is introduced in a
> complicated way (for example by a hash function). That's why we use SHA
> rather than CRC. One more reason why we stick to the principle is that
> there's no randomisation in our scheme (such as padding or
> initialisation vector). We understood advantages of error-correctings
> codes over hash functions (minimal codewords distance property,
> performance) and we considered it thoroughly.
>
> Ond?ej Vejpustek
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180117/4ce36a81/attachment.html>

From greg at xiph.org  Wed Jan 17 15:31:44 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 17 Jan 2018 15:31:44 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
Message-ID: <CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>

On Wed, Jan 17, 2018 at 11:39 AM, Ond?ej Vejpustek via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Consider a few notes:
>   * Nowadays there exists more complicated variants of mentioned attacks
> which have weaker premisses.
>   * There is a considerable similarity between RSA and SSS. Both schemes
> are algebraically-based (rather than boolean function based).

I'm sorry but I must not be following your message. I read the above
as "these are similar because they are based on math"...

Shamir secret sharing, correctly implemented (which indeed seems to be
many parties problem...) achieves information theoretic security. In
this critical sense it is utterly unrelated to RSA.

In fact this applies generally given any fixed threashold-1 set of
shares there is an value of the final remaining share which decodes to
every possible message. So without knowing of an extra share you know
nothing of the message.

The simplest demonstration is the 2 of 2 case, which can most simply
be constructed over GF(2) as in the traditional "one time pad":
message = share1 xor share2.  For any given share1 or given share2
there exist a value of share2 or share1 respectively which yields
every possible message.

If the generalization isn't obvious, it might be helpful to make a
little test utility that tries all possible one byte messages with all
possible share values using the GF(256) sharing scheme proposed in the
draft-- in this case information theory is why we can know SSS (and
similar) have (within their limited scope) _perfect_ security, rather
than it being a reason to speculate that they might not turn out to be
secure at all. (or, instead of a test utility just work through some
examples on paper in a small field).

This doesn't change when you add additional conditionals on it-- e.g.
Say you a 2-of-3 sharing where you have your choice of any of the
three shares but do not know the others and assume you know every bit
of the plaintext save one bit or any linear or non-linear relationship
between plaintext bits (excepting for actually knowing the secret)...

In these case there can still be no attack arising out of this
charitably bad plaintext structure because-- as pointed out above--
all possible plaintexts are equal-probable you know nothing of which
of the two possible solutions is correct without knowing about the
other shares because for each possible value there exists a value for
the unknown shares which would cause that decoding-- there is no
leakage at all, the share doesn't teach you anything you didn't
already know.

In my view any SSS tool should also include a forgery utility which
demonstrates this property, both as a critical test-- but also because
being able to forge an alternative answer to deceive an attacker which
has compromised some of your shares is one of the (at least
theoretical) arguments for using SSS over computational secret
sharing.

> unless it is introduced in a complicated way

Complicated does not mean secure. And from an information theoretic
perspective the hash does almost nothing (other then some small
destruction of entropy due to its lack of perfect uniformity which is
information theoretically equivalent to using a smaller perfect code).
There are many cases where I too am more comfortable using a hash --
where it may destroy some structure which I cannot _prove_ would be
safe to retain, but this is not one of those cases.

>   * CRCs (and error-correcting codes generally) introduce redundancy
into the message

The discussion of using a proper code was primarily related to the
outer check value which protects the shares themselves and is sitting
unprotected in plaintext; not so much the one inside the sharing in
any case; since its the outer one which could be structured to provide
perfect detection of errors that align with words (e.g. transposing
two words).

From greg at xiph.org  Wed Jan 17 15:36:25 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 17 Jan 2018 15:36:25 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAMZUoKnJM+U0QrVgD1VP4Q=krYDHmCn-poydVrz79r-w-89+yw@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAMZUoKnJM+U0QrVgD1VP4Q=krYDHmCn-poydVrz79r-w-89+yw@mail.gmail.com>
Message-ID: <CAAS2fgQx_PdNCqLvUjrWJOAtik1UeLn_U=JHszq=RveoRRpzag@mail.gmail.com>

On Wed, Jan 17, 2018 at 3:28 PM, Russell O'Connor via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> it is impossible to break SSS.

Obligatory repeated point: if the scheme being used actually is SSS
and not a Shamir-Shaped-Sharing instead. This should go without
mention by my experience is that a great many things which claim to be
SSS aren't. Sometimes precisely because they stuck in some hashes in
arbitrary places and destroyed the properties (in fact, the really old
broken armory implementation effectively did that, and in fact
resulted in a real weakness not just a theoretical one).

From jeffersoncarpenter2 at gmail.com  Wed Jan 17 22:31:52 2018
From: jeffersoncarpenter2 at gmail.com (Jefferson Carpenter)
Date: Wed, 17 Jan 2018 16:31:52 -0600
Subject: [bitcoin-dev] Upgrading PoW algorithm
Message-ID: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>

Bitcoin's difficulty will be maxed out within about 400 years, by 
Moore's law.  (After that - supposing the software does not crash when 
difficulty overflows - block time will start decreasing, and it will not 
take long before blocks are mined faster than photons can be sent across 
the planet).

Bitcoin is the dominant cryptocurrency today, as the first mover: the 
perfectly fair worldwide game of inventing the cryptocurrency has been 
played and won.  However, unfortunately, it has a built-in end date: 
about 400 years from now.  After that, it won't necessarily be clear 
what the dominant cryptocurrency is.  It might be a lot like VHS vs 
Betamax, and a lot of people could lose a lot of money.  It seems to me, 
this could be mitigated by planning today for what we are going to do 
when Bitcoin finally breaks 400 years from now.

Are there any distinct plans today for migrating to a PoW supporting an 
even higher difficulty?

From enrique.arizonbenito at gmail.com  Wed Jan 17 22:34:11 2018
From: enrique.arizonbenito at gmail.com (=?UTF-8?Q?Enrique_Ariz=C3=B3n_Benito?=)
Date: Wed, 17 Jan 2018 23:34:11 +0100
Subject: [bitcoin-dev] Proposal to reduce mining power bill
In-Reply-To: <5e93f4b0e82ddf4eba5f1f54923e153f@nym.zone>
References: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>
	<5e93f4b0e82ddf4eba5f1f54923e153f@nym.zone>
Message-ID: <CAD-msxGPsAR=SVzScE1dVsFaN4kBKySSP6U5Q0P7vXxBMcEiqQ@mail.gmail.com>

Thanks "nullius" for your remarks. Notice my first post was not an RFC but
just a blur idea to inspect if something similar had already been discussed
in the group. In fact your post has helped me a lot to improve my first
mail.

> Observation:  This totally destroys Bitcoin?s transaction-ordering
security.  A ?51% attack? could be executed by any miner who has >50% of
the hashpower *proportionate to miners who are allowed to mine a particular
block*, rather than >50% of *global* hashpower.  (I infer that this could
be done retroactively, and wave my hands over some of the details since you
did not talk about reorgs.)  The same applies as for attacks requiring 33%
or 25% of total hashpower.

I'm not sure what you are referring to in this paragraph. Imagine for
example that there are a total of, let's say, 2^10 available
next-coinbase/miners and the algorithm just allow 50% or 2^9 of them to
mine, ?how could it be possible that one among them could have 51% of power
by chance? (Please, read comments bellow before replying)

> Potential attack, assuming that N *must* be based partly or wholly on the
existing set of ?next-coinbase? addresses:  A large miner could gradually
push N higher, by progressively committing new ?next-coinbase? addresses
which differ in the next bit for all previously seen combinations of bits.
Large miners would have a vast advantage over small miners, insofar as
deliberately incrementing N by one more bit could only be done by a miner
who creates 2^(N+1) blocks (= 2 * 2^N).  By such means, it may be possible
for a very large miner to eventually lock out all other miners altogether,
and monopolize all Bitcoin mining.

I do not think it would be easy even for a large miner but that made me
think for an alternative algorithm. Let's introduce the concept of "spent"
next-coinbase versus "un-spent" one, something like similarly to UTXO. A
next-coinbase would only be valid if it has not been previously used to
mine a block. Simplifying, with the spent vs unspent a large miner is
restricted to a single next-coinbase as anyone else. Being more precise
it's allowed a single next-coinbase for each mined new-miner-block mined
creating a "thread" of mining blocks for each new new-miner-block.
Schematically a thread would look like:
new-miner-block:next-coinbase_1 -> mined-block:next-coinbase_2 ->  ... ->
(thread expired - see comment below about expiration)

In this case a large miner A with T times more power than another one B
could potentially spent mining power to create T parallel threads for each
thread created by miner B. A solution that could fix this issue is to allow
a maximum life time for each thread expressed in number of blocks. After a
given number of blocks have being mined the miner is forced to create new
new-miner-block to continue participating. The algorithm to choose the
life-time must be such that if a miner tries to create many parallel
threads (many new-miner-block), by the time it start mining transaction
blocks the first new-miner-block will start to expire, so he will be
punished.

If the famous phrase "a degree of indirection solve all programming
problems" I think this is an example applied to blockchain. First the
consensus chooses who can participate in the next round, then selected
miners participate in the round.


> Now, questions:
>
> How is N determined?  By a wave of the hands?
>

Great question. I left it unspecified in the first mail. An algorithm comes
to my mind (You are welcome to propose others). Let's imagine the list of
registered non-expired next-coinbase addresses  is 2^10. The consensus
checks that for N=1 there is *about* 1/2^N == 1/2 of unspent next-coinbase
addresses that match (it must be close to 1/2 of the total 2^10 addresses
with maybe an small +/- 1% statistical deviation). Then N=1 will be
accepted. Check now for N=2. If there are 1/(2^N) = 1/4 next-coinbase
addresses matching then N=2 is accepted. The algorithm continues until some
"++N" fails. Initially N=0 and so all miners are welcome to the game. They
all will start producing next-coinbase addresses and when there are enough
different ones N will become 1, then 2, ... This system will will keep an
equilibrium naturally. If new miners stop producing new new-miner-blocks,
eventually the threads will expire and N will be automatically be
decreased. Miners will act rationally to keep enough threads open in their
own interest since that will decrease the electricity bill.

> What part of which block hash is matched against N bits?  You were quite
unclear about this, and other important details.  (Much of what I say here
is based on assumptions and inferences necessary to fill in the blanks.)

Thinking about it, the hash must run over "many" different blocks and it
must include the next next-coinbase (to force calculating the hash after
choosing a next-coinbase). Since it's not expected that many blocks are
mined by the same miner in a row (maybe no more than 2 o 3) the "many"
number must be for example twice as much as the expected maximum numbers of
blocks that a large miner can mine in average.

> How, exactly, are reorgs handled?
I think reorgs are not affected by this algorithm. The next-coinbase
objective is just to randomly choose which miner will be allowed for the
next round.

> How does this interact with the difficulty adjustment algorithm?  Indeed,
how is difficulty determined at all under your scheme?
As I see it, if the network wants to keep the same pace of new blocks each
N seconds, and N=1 (only half of the miners are allowed to mine)  then
difficulty/power-bill is lowered by two, for N=2 by 4, ...

> What happens to coinbase fees from a ?new-miner-block??  The way I read
your scheme, the ?new-miner-block? must necessarily have no payout
whatsoever.  But you discuss only ?new bitcoins?,which are a diminishing
portion of the block reward, and will eventually reach zero.  Coinbase from
fees must go somewhere; but under your scheme, a ?new miner? has no payable
address.

This new-miner-block will have NO transactions inside.

> What if no existing ?next-coinbase? address matches?  Is N constrained to
be sufficiently short that a match is guaranteed from the existing set,
then that makes it trivial for large mining farms to collect addresses and
further dominate (or even monopolize) the network in the attack described
above.  If it isn?t, then the network could suddenly halt when nobody is
allowed to mine the next block; and that would enable *this* attack:

I think the previous algorithm I mention to replace the "wave of hands"
(test N=1, then N=2,... ) plus the "expiring threads" would suffice to fix
it.

>  What stops a malicious miner (including a ?new miner? creating a
?new-miner block?) from deliberately working to create a block with a hash
which does not have N bits matching any of the existing ?next-coinbase?
addresses?  Contra what you say, block hashes can?t be ?considered
random?.  Indeed, partial preimage bruteforcing of block hashes is the
entire basis of mining POW.

Again, that is fixed by the previous algorithm


> Asking here more generally than as for the attack described above, what
stops mining farms with large hashpower from submitting many different
?next-coinbase? addresses in many different blocks?  If N be small, then it
should be feasible for a large mining farm to eventually register a set of
?next-coinbase? addresses which match any N.  **This increases mining
centralization.**  If N be large, then this creates the possibility (or
raises the probability) that no address will match, and nobody will be
allowed to mine the next block.

Fixed by the expiring thread model?


> How could miner anonymity be preserved under a scheme whereby each
> ?next-coinbase? address can be linked to a previous ?next-coinbase?
> address?  The only way to start fresh would be with a prohibitively
> expensive no-payout block.  Mining can be totally anonymous at present, and
> must so remain.  Miners are only identified by certain information they
> choose to put in a block header, which they could choose to change or
> omit?or by IP address, which is trivially changed and is never a reliable
> identifier.
>
> The anonymity decreases in the sense that if you know a next-coinbase
address owner you know all its related next-coinbase for the expiring
(physical-time-limited) thread. The anonymity increases in the sense that
miner will consume fewer energy. Electricity bill is the easiest way today
to trace miners.

 > How does this even save electricity, when there is much mining equipment
(especially on large mining farms) which cannot be easily shut down and
restarted?  (Allegedly, this is one reason why some big miners occasionally
mine empty blocks.)  Though I suppose that difficulty would drop by
unspecified means.

As explained above, the difficulty is reduced by 1/2^N for each round. And
of course, miners that want to save more energy will have to adapt to put
their systems on stand-by while they  are not chosen for the next round. I
think based on my limited experience with ASIC mining that just by not
sending new orders to the miner the power comsumption will decrease
dramatically even if the equipment is still on.

>
> Further observations:
>
> This scheme drastically increases the upfront investment required for a
> new miner to start mining.  To mine even one new block all by oneself,
> without a pool, already requires a huge investment.


Once introduced the concept of "expiring" thread I think he will be pretty
much in the same condition. To obtain bitcoins he will first need to mine a
new-miner-block to enter the game and then an standard block before the
thread expires. Notice the expire time/block-length start just after the
new-miner-block has been mined so the probabilities to mine before the
expiration time will be proportional to its mining power, as for everyone
else.

> Add to that the uncompensated energy cost of mining that first block with
*no* payout,

I think it could be clearly compensated by the save in energy for standards
blocks.

>and I expect that the bar would be prohibitive to almost all new
entrants.Mining costs and incentives are delicately balanced by the design
of the network.  Whereas incumbents are much favoured by your scheme,
further increasing miner centralization.

I don't think so after the new fixes. What do you think? My opinion is
that, based on the "theory of games", miners acting in their own interest
will try to maximize "N".

> Large incumbents could also use this to produce a mining permissions
market, by selling the private keys to committed ?next-coinbase?
addresses.

With the addition of thread expiration, nobody will be really motivated to
shell/buy "next-coinbase" addresses since their utility is limited.

Just a remark: Notice this algorithm reduces the electricity bill, but the
hardware needed stays the same, since for each round the miner participates
in, it will try to mine as fast as possible and so use as much hardware as
possible. No reduction costs are expected in hardware.


Best Regards,

Enrique Ariz?n Benito



I have not even tried to imagine what oddball attacks might be possible for
> any miner with sufficient hashpower to deliberately cause a small reorg.


> --
> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
> ??If you?re not doing anything wrong, you have nothing to hide.?
> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180117/134c366d/attachment-0001.html>

From a at colourful.land  Thu Jan 18 01:07:53 2018
From: a at colourful.land (Weiwu Zhang)
Date: Thu, 18 Jan 2018 09:07:53 +0800
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English
	wordlist
In-Reply-To: <31430A55-57AD-4648-8D6D-DE2A45CC013C@vandermeer.frl>
References: <31430A55-57AD-4648-8D6D-DE2A45CC013C@vandermeer.frl>
Message-ID: <CAEvpD62pd_s17VoGw8B+=3_cmMq2cWneAR0MZ_CT_7DqooBnLQ@mail.gmail.com>

2018-01-09 19:20 GMT+08:00 Ronald van der Meer via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org>:
> After reviewing some bitcoin improvement proposals, I noticed that one of the words that can be found on the BIP39 English wordlist is ?satoshi?.
> I suggest removing this word from the list so it?s less obvious that it?s a bitcoin seed when found by a malicious third party.

If a malicious third party discovers a word list that look like a
seed, they would try using it as Bitcoin seed first anyway, with or
without finding the word 'satoshi' in it. The security threat is that
a malicious third party may index what they found and test every
occurrence of 'satoshi' for a lead to a seed.

For example, a hard-disk recycling service would add this word to
their salvage tools. Any successfully hacked gmail account will be
'satoshi' tested too.

So I see this as a reasonable improvement:)

From cryptaxe at gmail.com  Thu Jan 18 01:14:51 2018
From: cryptaxe at gmail.com (CryptAxe)
Date: Wed, 17 Jan 2018 17:14:51 -0800
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English
	wordlist
In-Reply-To: <CAEvpD62pd_s17VoGw8B+=3_cmMq2cWneAR0MZ_CT_7DqooBnLQ@mail.gmail.com>
References: <31430A55-57AD-4648-8D6D-DE2A45CC013C@vandermeer.frl>
	<CAEvpD62pd_s17VoGw8B+=3_cmMq2cWneAR0MZ_CT_7DqooBnLQ@mail.gmail.com>
Message-ID: <CAF5CFkgO4SEBxTH93-L_d=JBgAmDNFTJa-LrnyjcvY-Esop9EA@mail.gmail.com>

Why wouldn't they just test the frequency of words from the wordlist in
entirety?

On Jan 17, 2018 5:10 PM, "Weiwu Zhang via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> 2018-01-09 19:20 GMT+08:00 Ronald van der Meer via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org>:
> > After reviewing some bitcoin improvement proposals, I noticed that one
> of the words that can be found on the BIP39 English wordlist is ?satoshi?.
> > I suggest removing this word from the list so it?s less obvious that
> it?s a bitcoin seed when found by a malicious third party.
>
> If a malicious third party discovers a word list that look like a
> seed, they would try using it as Bitcoin seed first anyway, with or
> without finding the word 'satoshi' in it. The security threat is that
> a malicious third party may index what they found and test every
> occurrence of 'satoshi' for a lead to a seed.
>
> For example, a hard-disk recycling service would add this word to
> their salvage tools. Any successfully hacked gmail account will be
> 'satoshi' tested too.
>
> So I see this as a reasonable improvement:)
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180117/ae8bb6fa/attachment.html>

From lf-lists at mattcorallo.com  Thu Jan 18 05:00:28 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Thu, 18 Jan 2018 05:00:28 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
Message-ID: <08E5B040-973B-4089-9DA6-CE8AE6CF3D3B@mattcorallo.com>

Or make it a part of your secret-split logic... Gotta love how fast GF(2^8) is:
https://github.com/TheBlueMatt/shamirs/blob/master/main.c#L57

On January 17, 2018 3:31:44 PM UTC, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>If the generalization isn't obvious, it might be helpful to make a
>little test utility that tries all possible one byte messages with all
>possible share values using the GF(256) sharing scheme proposed in the
>draft-- in this case information theory is why we can know SSS (and
>similar) have (within their limited scope) _perfect_ security, rather
>than it being a reason to speculate that they might not turn out to be
>secure at all. (or, instead of a test utility just work through some
>examples on paper in a small field).
>

From greg at xiph.org  Thu Jan 18 14:34:24 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 18 Jan 2018 14:34:24 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
Message-ID: <CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>

On Thu, Jan 18, 2018 at 1:50 PM, Ond?ej Vejpustek
<ondrej.vejpustek at satoshilabs.com> wrote:
>   (1) Our proposal doesn't use SSS for the whole secret, but it divides
> the secret into bytes and uses SSS for every byte separately. This
> scheme is weaker because to reconstruct n-th byte it suffices to have
> n-th bytes from k shares.

If being secure against partial share leakage is really part of your
threat model the current proposal is gratuitously insecure against it.
And the choice of check algorithm really doesn't matter for that.

For example,  in a 2-of-3 share  say I have the first half of shares
1,2 and the second half of shares 2,3  with the current proposal the
secret is directly revealed, even though I didn't have any single
complete share.

If partial share disclosure were an actual concern, I would recommend
that after sharing and before encoding for transmission (e.g. before
applying check values and word encoding to the share) the individual
shares be passed through a large block unkeyed cryptographic
permutation.  Under reasonable-ish assumptions about the difficulty of
inverting the permutation with partial knowledge, this transformation
would prevent attacks from leaks of partial share information.

From ondrej.vejpustek at satoshilabs.com  Thu Jan 18 13:50:41 2018
From: ondrej.vejpustek at satoshilabs.com (=?UTF-8?Q?Ond=c5=99ej_Vejpustek?=)
Date: Thu, 18 Jan 2018 14:50:41 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
Message-ID: <4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>

Thank you for your comments, Gregory and Russell!

Gregory, thank you for you explanation of perfect secrecy, there is no
need for that, however. I'm professional mathematician and cryptographer.

> I read the above
> as "these are similar because they are based on math"...
They are based on algebra (group and commutative ring theory), which is
a great similarity. RSA and SHA, for example, are based on completely
distinct parts of mathematics.

> Complicated does not mean secure. And from an information theoretic
> perspective the hash does almost nothing (other then some small
> destruction of entropy due to its lack of perfect uniformity which is
> information theoretically equivalent to using a smaller perfect code).
> using error correcting codes and truncated hash functions create
identical amounts of information theoretic redundancy
I agree, see my last note in the previous mail. Adding redundancy by a
hash function is more secure than adding redundancy by a linear
relations. Just my opinion.

I see the difference between RSA and SSS you mentioned and I understand
your arguments about perfect secrecy. Just two comments:
  (1) Our proposal doesn't use SSS for the whole secret, but it divides
the secret into bytes and uses SSS for every byte separately. This
scheme is weaker because to reconstruct n-th byte it suffices to have
n-th bytes from k shares.
  (2) SSS is information-theoretic secure if you know k-1 or less
shares, where k is the threshold. But the proof doesn't hold if you know
for example a small part of every share.

> It is of no use to apply the precautionary principle against
impossible attacks, especially at the cost of losing the useful
properties of a real error correcting codes that would provide actual
guarantees against likely errors.
The discussion isn't about mathematics or about security proofs but
about cryptographic scheme design. In our use case you cannot assume
that all premises of security proof theorems (including SSS's perfect
secrecy) hold true (see the comment above).

In my opinion, to make a cryptographic scheme more robust it's better to
stick to general "intuitive" principles. Of course you have to consider
the advantages and disadvantages of this approach. That's why we
disclosed our draft and welcome all comments.

> The discussion of using a proper code was primarily related to the
> outer check value which protects the shares themselves and is sitting
> unprotected in plaintext
OK then. I was defending the hash in the inner check value.

From jon at thancodes.com  Thu Jan 18 06:55:28 2018
From: jon at thancodes.com (Jonathan Sterling)
Date: Thu, 18 Jan 2018 13:55:28 +0700
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English
	wordlist
In-Reply-To: <CAF5CFkgO4SEBxTH93-L_d=JBgAmDNFTJa-LrnyjcvY-Esop9EA@mail.gmail.com>
References: <31430A55-57AD-4648-8D6D-DE2A45CC013C@vandermeer.frl>
	<CAEvpD62pd_s17VoGw8B+=3_cmMq2cWneAR0MZ_CT_7DqooBnLQ@mail.gmail.com>
	<CAF5CFkgO4SEBxTH93-L_d=JBgAmDNFTJa-LrnyjcvY-Esop9EA@mail.gmail.com>
Message-ID: <CAH01uEu5gu_4z-6r3MbqsjboHuZ87yOxAZq6QxtA-3iUZvoXZw@mail.gmail.com>

All the more reason to only use the most common words that meet the other
criteria:
https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#Wordlist

I agree - keeping "satoshi" in there is an unnecessary security risk.

Kind Regards,

Jonathan Sterling

On Thu, Jan 18, 2018 at 8:14 AM, CryptAxe via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Why wouldn't they just test the frequency of words from the wordlist in
> entirety?
>
> On Jan 17, 2018 5:10 PM, "Weiwu Zhang via bitcoin-dev" <bitcoin-dev at lists.
> linuxfoundation.org> wrote:
>
>> 2018-01-09 19:20 GMT+08:00 Ronald van der Meer via bitcoin-dev
>> <bitcoin-dev at lists.linuxfoundation.org>:
>> > After reviewing some bitcoin improvement proposals, I noticed that one
>> of the words that can be found on the BIP39 English wordlist is ?satoshi?.
>> > I suggest removing this word from the list so it?s less obvious that
>> it?s a bitcoin seed when found by a malicious third party.
>>
>> If a malicious third party discovers a word list that look like a
>> seed, they would try using it as Bitcoin seed first anyway, with or
>> without finding the word 'satoshi' in it. The security threat is that
>> a malicious third party may index what they found and test every
>> occurrence of 'satoshi' for a lead to a seed.
>>
>> For example, a hard-disk recycling service would add this word to
>> their salvage tools. Any successfully hacked gmail account will be
>> 'satoshi' tested too.
>>
>> So I see this as a reasonable improvement:)
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Kind Regards,

Jonathan Sterling
+44 (0)7415 512691
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/de50dfb5/attachment.html>

From eric at voskuil.org  Thu Jan 18 05:22:47 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Thu, 18 Jan 2018 13:22:47 +0800
Subject: [bitcoin-dev] Proposal to reduce mining power bill
In-Reply-To: <CAD-msxGPsAR=SVzScE1dVsFaN4kBKySSP6U5Q0P7vXxBMcEiqQ@mail.gmail.com>
References: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>
	<5e93f4b0e82ddf4eba5f1f54923e153f@nym.zone>
	<CAD-msxGPsAR=SVzScE1dVsFaN4kBKySSP6U5Q0P7vXxBMcEiqQ@mail.gmail.com>
Message-ID: <2C70E809-0657-4FBE-9E12-008E2A7C4207@voskuil.org>

The energy cost of mining cannot be reduced, nor is it rational to consider it ?too high?.

e

> On Jan 18, 2018, at 06:34, Enrique Ariz?n Benito via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Thanks "nullius" for your remarks. Notice my first post was not an RFC but just a blur idea to inspect if something similar had already been discussed in the group. In fact your post has helped me a lot to improve my first mail.
> 
> > Observation:  This totally destroys Bitcoin?s transaction-ordering security.  A ?51% attack? could be executed by any miner who has >50% of the hashpower *proportionate to miners who are allowed to mine a particular block*, rather than >50% of *global* hashpower.  (I infer that this could be done retroactively, and wave my hands over some of the details since you did not talk about reorgs.)  The same applies as for attacks requiring 33% or 25% of total hashpower. 
> 
> I'm not sure what you are referring to in this paragraph. Imagine for example that there are a total of, let's say, 2^10 available next-coinbase/miners and the algorithm just allow 50% or 2^9 of them to mine, ?how could it be possible that one among them could have 51% of power by chance? (Please, read comments bellow before replying)
> 
> > Potential attack, assuming that N *must* be based partly or wholly on the existing set of ?next-coinbase? addresses:  A large miner could gradually push N higher, by progressively committing new ?next-coinbase? addresses which differ in the next bit for all previously seen combinations of bits. Large miners would have a vast advantage over small miners, insofar as deliberately incrementing N by one more bit could only be done by a miner who creates 2^(N+1) blocks (= 2 * 2^N).  By such means, it may be possible for a very large miner to eventually lock out all other miners altogether, and monopolize all Bitcoin mining.
> 
> I do not think it would be easy even for a large miner but that made me think for an alternative algorithm. Let's introduce the concept of "spent" next-coinbase versus "un-spent" one, something like similarly to UTXO. A next-coinbase would only be valid if it has not been previously used to mine a block. Simplifying, with the spent vs unspent a large miner is restricted to a single next-coinbase as anyone else. Being more precise it's allowed a single next-coinbase for each mined new-miner-block mined creating a "thread" of mining blocks for each new new-miner-block. Schematically a thread would look like: 
> new-miner-block:next-coinbase_1 -> mined-block:next-coinbase_2 ->  ... -> (thread expired - see comment below about expiration)
> 
> In this case a large miner A with T times more power than another one B could potentially spent mining power to create T parallel threads for each thread created by miner B. A solution that could fix this issue is to allow a maximum life time for each thread expressed in number of blocks. After a given number of blocks have being mined the miner is forced to create new new-miner-block to continue participating. The algorithm to choose the life-time must be such that if a miner tries to create many parallel threads (many new-miner-block), by the time it start mining transaction blocks the first new-miner-block will start to expire, so he will be punished.
> 
> If the famous phrase "a degree of indirection solve all programming problems" I think this is an example applied to blockchain. First the consensus chooses who can participate in the next round, then selected miners participate in the round.
>  
>> Now, questions:
>> 
>> How is N determined?  By a wave of the hands?
> 
> Great question. I left it unspecified in the first mail. An algorithm comes to my mind (You are welcome to propose others). Let's imagine the list of registered non-expired next-coinbase addresses  is 2^10. The consensus checks that for N=1 there is *about* 1/2^N == 1/2 of unspent next-coinbase addresses that match (it must be close to 1/2 of the total 2^10 addresses with maybe an small +/- 1% statistical deviation). Then N=1 will be accepted. Check now for N=2. If there are 1/(2^N) = 1/4 next-coinbase addresses matching then N=2 is accepted. The algorithm continues until some "++N" fails. Initially N=0 and so all miners are welcome to the game. They all will start producing next-coinbase addresses and when there are enough different ones N will become 1, then 2, ... This system will will keep an equilibrium naturally. If new miners stop producing new new-miner-blocks, eventually the threads will expire and N will be automatically be decreased. Miners will act rationally to keep enough threads open in their own interest since that will decrease the electricity bill.
> 
> > What part of which block hash is matched against N bits?  You were quite unclear about this, and other important details.  (Much of what I say here is based on assumptions and inferences necessary to fill in the blanks.)
> 
> Thinking about it, the hash must run over "many" different blocks and it must include the next next-coinbase (to force calculating the hash after choosing a next-coinbase). Since it's not expected that many blocks are mined by the same miner in a row (maybe no more than 2 o 3) the "many" number must be for example twice as much as the expected maximum numbers of blocks that a large miner can mine in average.
>  
> > How, exactly, are reorgs handled?
> I think reorgs are not affected by this algorithm. The next-coinbase objective is just to randomly choose which miner will be allowed for the next round.
>  
> > How does this interact with the difficulty adjustment algorithm?  Indeed, how is difficulty determined at all under your scheme?
> As I see it, if the network wants to keep the same pace of new blocks each N seconds, and N=1 (only half of the miners are allowed to mine)  then difficulty/power-bill is lowered by two, for N=2 by 4, ...
> 
> > What happens to coinbase fees from a ?new-miner-block??  The way I read your scheme, the ?new-miner-block? must necessarily have no payout whatsoever.  But you discuss only ?new bitcoins?,which are a diminishing portion of the block reward, and will eventually reach zero.  Coinbase from fees must go somewhere; but under your scheme, a ?new miner? has no payable address.
> 
> This new-miner-block will have NO transactions inside.
> 
> > What if no existing ?next-coinbase? address matches?  Is N constrained to be sufficiently short that a match is guaranteed from the existing set, then that makes it trivial for large mining farms to collect addresses and further dominate (or even monopolize) the network in the attack described above.  If it isn?t, then the network could suddenly halt when nobody is allowed to mine the next block; and that would enable *this* attack:
> 
> I think the previous algorithm I mention to replace the "wave of hands" (test N=1, then N=2,... ) plus the "expiring threads" would suffice to fix it.
> 
> >  What stops a malicious miner (including a ?new miner? creating a ?new-miner block?) from deliberately working to create a block with a hash which does not have N bits matching any of the existing ?next-coinbase? addresses?  Contra what you say, block hashes can?t be ?considered random?.  Indeed, partial preimage bruteforcing of block hashes is the entire basis of mining POW.
> 
> Again, that is fixed by the previous algorithm
> 
> 
> > Asking here more generally than as for the attack described above, what stops mining farms with large hashpower from submitting many different ?next-coinbase? addresses in many different blocks?  If N be small, then it should be feasible for a large mining farm to eventually register a set of ?next-coinbase? addresses which match any N.  **This increases mining centralization.**  If N be large, then this creates the possibility (or raises the probability) that no address will match, and nobody will be allowed to mine the next block.
> 
> Fixed by the expiring thread model?
>  
>> How could miner anonymity be preserved under a scheme whereby each ?next-coinbase? address can be linked to a previous ?next-coinbase? address?  The only way to start fresh would be with a prohibitively expensive no-payout block.  Mining can be totally anonymous at present, and must so remain.  Miners are only identified by certain information they choose to put in a block header, which they could choose to change or omit?or by IP address, which is trivially changed and is never a reliable identifier.
>> 
> The anonymity decreases in the sense that if you know a next-coinbase address owner you know all its related next-coinbase for the expiring (physical-time-limited) thread. The anonymity increases in the sense that miner will consume fewer energy. Electricity bill is the easiest way today to trace miners.
> 
>  > How does this even save electricity, when there is much mining equipment (especially on large mining farms) which cannot be easily shut down and restarted?  (Allegedly, this is one reason why some big miners occasionally mine empty blocks.)  Though I suppose that difficulty would drop by unspecified means.
> 
> As explained above, the difficulty is reduced by 1/2^N for each round. And of course, miners that want to save more energy will have to adapt to put their systems on stand-by while they  are not chosen for the next round. I think based on my limited experience with ASIC mining that just by not sending new orders to the miner the power comsumption will decrease dramatically even if the equipment is still on.
>> 
>> Further observations:
>> 
>> This scheme drastically increases the upfront investment required for a new miner to start mining.  To mine even one new block all by oneself, without a pool, already requires a huge investment. 
>  
> Once introduced the concept of "expiring" thread I think he will be pretty much in the same condition. To obtain bitcoins he will first need to mine a new-miner-block to enter the game and then an standard block before the thread expires. Notice the expire time/block-length start just after the new-miner-block has been mined so the probabilities to mine before the expiration time will be proportional to its mining power, as for everyone else.  
>  
> > Add to that the uncompensated energy cost of mining that first block with *no* payout,
> 
> I think it could be clearly compensated by the save in energy for standards blocks.
> 
> >and I expect that the bar would be prohibitive to almost all new entrants.Mining costs and incentives are delicately balanced by the design of the network.  Whereas incumbents are much favoured by your scheme, further increasing miner centralization.
> 
> I don't think so after the new fixes.  What do you think? My opinion is that, based on the "theory of games", miners acting in their own interest will try to maximize "N". 
>   
> > Large incumbents could also use this to produce a mining permissions market, by selling the  private keys to committed ?next-coinbase? addresses.  
> 
> With the addition of thread expiration, nobody will be really motivated to shell/buy "next-coinbase" addresses since their utility is limited.
> 
> Just a remark: Notice this algorithm reduces the electricity bill, but the hardware needed stays the same, since for each round the miner participates in, it will try to mine as fast as possible and so use as much hardware as possible. No reduction costs are expected in hardware.
> 
> 
> Best Regards,
> 
> Enrique Ariz?n Benito
> 
> 
> 
>> I have not even tried to imagine what oddball attacks might be possible for any miner with sufficient hashpower to deliberately cause a small reorg. 
>> 
>> -- 
>> nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
>> Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
>> 3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
>> ??If you?re not doing anything wrong, you have nothing to hide.?
>> No!  Because I do nothing wrong, I have nothing to show.? ? nullius
> 
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/d2a32353/attachment-0001.html>

From willtech at live.com.au  Thu Jan 18 08:24:40 2018
From: willtech at live.com.au (Damian Williamson)
Date: Thu, 18 Jan 2018 08:24:40 +0000
Subject: [bitcoin-dev] Proposal to reduce mining power bill
In-Reply-To: <CAD-msxGPsAR=SVzScE1dVsFaN4kBKySSP6U5Q0P7vXxBMcEiqQ@mail.gmail.com>
References: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>
	<5e93f4b0e82ddf4eba5f1f54923e153f@nym.zone>,
	<CAD-msxGPsAR=SVzScE1dVsFaN4kBKySSP6U5Q0P7vXxBMcEiqQ@mail.gmail.com>
Message-ID: <PS2P216MB017917D3FD62AB944098971C9DE80@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

It probably could be noted, although it is well known, pools, in some views, act as one large individual miner, not just when separately considering the actions of pools.


Given the operation of pools, would a pool be required to mine the new-miner-blocks, or would you propose operation in a pool be restricted individually? How would this operate?


Regards,

Damian Williamson

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Enrique Ariz?n Benito via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Thursday, 18 January 2018 9:34:11 AM
To: nullius at nym.zone; bitcoin-dev at lists.linuxfoundation.org
Subject: Re: [bitcoin-dev] Proposal to reduce mining power bill

Thanks "nullius" for your remarks. Notice my first post was not an RFC but just a blur idea to inspect if something similar had already been discussed in the group. In fact your post has helped me a lot to improve my first mail.

> Observation:  This totally destroys Bitcoin?s transaction-ordering security.  A ?51% attack? could be executed by any miner who has >50% of the hashpower *proportionate to miners who are allowed to mine a particular block*, rather than >50% of *global* hashpower.  (I infer that this could be done retroactively, and wave my hands over some of the details since you did not talk about reorgs.)  The same applies as for attacks requiring 33% or 25% of total hashpower.

I'm not sure what you are referring to in this paragraph. Imagine for example that there are a total of, let's say, 2^10 available next-coinbase/miners and the algorithm just allow 50% or 2^9 of them to mine, ?how could it be possible that one among them could have 51% of power by chance? (Please, read comments bellow before replying)

> Potential attack, assuming that N *must* be based partly or wholly on the existing set of ?next-coinbase? addresses:  A large miner could gradually push N higher, by progressively committing new ?next-coinbase? addresses which differ in the next bit for all previously seen combinations of bits. Large miners would have a vast advantage over small miners, insofar as deliberately incrementing N by one more bit could only be done by a miner who creates 2^(N+1) blocks (= 2 * 2^N).  By such means, it may be possible for a very large miner to eventually lock out all other miners altogether, and monopolize all Bitcoin mining.

I do not think it would be easy even for a large miner but that made me think for an alternative algorithm. Let's introduce the concept of "spent" next-coinbase versus "un-spent" one, something like similarly to UTXO. A next-coinbase would only be valid if it has not been previously used to mine a block. Simplifying, with the spent vs unspent a large miner is restricted to a single next-coinbase as anyone else. Being more precise it's allowed a single next-coinbase for each mined new-miner-block mined creating a "thread" of mining blocks for each new new-miner-block. Schematically a thread would look like:
new-miner-block:next-coinbase_1 -> mined-block:next-coinbase_2 ->  ... -> (thread expired - see comment below about expiration)

In this case a large miner A with T times more power than another one B could potentially spent mining power to create T parallel threads for each thread created by miner B. A solution that could fix this issue is to allow a maximum life time for each thread expressed in number of blocks. After a given number of blocks have being mined the miner is forced to create new new-miner-block to continue participating. The algorithm to choose the life-time must be such that if a miner tries to create many parallel threads (many new-miner-block), by the time it start mining transaction blocks the first new-miner-block will start to expire, so he will be punished.

If the famous phrase "a degree of indirection solve all programming problems" I think this is an example applied to blockchain. First the consensus chooses who can participate in the next round, then selected miners participate in the round.

Now, questions:

How is N determined?  By a wave of the hands?

Great question. I left it unspecified in the first mail. An algorithm comes to my mind (You are welcome to propose others). Let's imagine the list of registered non-expired next-coinbase addresses  is 2^10. The consensus checks that for N=1 there is *about* 1/2^N == 1/2 of unspent next-coinbase addresses that match (it must be close to 1/2 of the total 2^10 addresses with maybe an small +/- 1% statistical deviation). Then N=1 will be accepted. Check now for N=2. If there are 1/(2^N) = 1/4 next-coinbase addresses matching then N=2 is accepted. The algorithm continues until some "++N" fails. Initially N=0 and so all miners are welcome to the game. They all will start producing next-coinbase addresses and when there are enough different ones N will become 1, then 2, ... This system will will keep an equilibrium naturally. If new miners stop producing new new-miner-blocks, eventually the threads will expire and N will be automatically be decreased. Miners will act rationally to keep enough threads open in their own interest since that will decrease the electricity bill.

> What part of which block hash is matched against N bits?  You were quite unclear about this, and other important details.  (Much of what I say here is based on assumptions and inferences necessary to fill in the blanks.)

Thinking about it, the hash must run over "many" different blocks and it must include the next next-coinbase (to force calculating the hash after choosing a next-coinbase). Since it's not expected that many blocks are mined by the same miner in a row (maybe no more than 2 o 3) the "many" number must be for example twice as much as the expected maximum numbers of blocks that a large miner can mine in average.

> How, exactly, are reorgs handled?
I think reorgs are not affected by this algorithm. The next-coinbase objective is just to randomly choose which miner will be allowed for the next round.

> How does this interact with the difficulty adjustment algorithm?  Indeed, how is difficulty determined at all under your scheme?
As I see it, if the network wants to keep the same pace of new blocks each N seconds, and N=1 (only half of the miners are allowed to mine)  then difficulty/power-bill is lowered by two, for N=2 by 4, ...

> What happens to coinbase fees from a ?new-miner-block??  The way I read your scheme, the ?new-miner-block? must necessarily have no payout whatsoever.  But you discuss only ?new bitcoins?,which are a diminishing portion of the block reward, and will eventually reach zero.  Coinbase from fees must go somewhere; but under your scheme, a ?new miner? has no payable address.

This new-miner-block will have NO transactions inside.

> What if no existing ?next-coinbase? address matches?  Is N constrained to be sufficiently short that a match is guaranteed from the existing set, then that makes it trivial for large mining farms to collect addresses and further dominate (or even monopolize) the network in the attack described above.  If it isn?t, then the network could suddenly halt when nobody is allowed to mine the next block; and that would enable *this* attack:

I think the previous algorithm I mention to replace the "wave of hands" (test N=1, then N=2,... ) plus the "expiring threads" would suffice to fix it.

>  What stops a malicious miner (including a ?new miner? creating a ?new-miner block?) from deliberately working to create a block with a hash which does not have N bits matching any of the existing ?next-coinbase? addresses?  Contra what you say, block hashes can?t be ?considered random?.  Indeed, partial preimage bruteforcing of block hashes is the entire basis of mining POW.

Again, that is fixed by the previous algorithm


> Asking here more generally than as for the attack described above, what stops mining farms with large hashpower from submitting many different ?next-coinbase? addresses in many different blocks?  If N be small, then it should be feasible for a large mining farm to eventually register a set of ?next-coinbase? addresses which match any N.  **This increases mining centralization.**  If N be large, then this creates the possibility (or raises the probability) that no address will match, and nobody will be allowed to mine the next block.

Fixed by the expiring thread model?

How could miner anonymity be preserved under a scheme whereby each ?next-coinbase? address can be linked to a previous ?next-coinbase? address?  The only way to start fresh would be with a prohibitively expensive no-payout block.  Mining can be totally anonymous at present, and must so remain.  Miners are only identified by certain information they choose to put in a block header, which they could choose to change or omit?or by IP address, which is trivially changed and is never a reliable identifier.

The anonymity decreases in the sense that if you know a next-coinbase address owner you know all its related next-coinbase for the expiring (physical-time-limited) thread. The anonymity increases in the sense that miner will consume fewer energy. Electricity bill is the easiest way today to trace miners.

 > How does this even save electricity, when there is much mining equipment (especially on large mining farms) which cannot be easily shut down and restarted?  (Allegedly, this is one reason why some big miners occasionally mine empty blocks.)  Though I suppose that difficulty would drop by unspecified means.

As explained above, the difficulty is reduced by 1/2^N for each round. And of course, miners that want to save more energy will have to adapt to put their systems on stand-by while they  are not chosen for the next round. I think based on my limited experience with ASIC mining that just by not sending new orders to the miner the power comsumption will decrease dramatically even if the equipment is still on.

Further observations:

This scheme drastically increases the upfront investment required for a new miner to start mining.  To mine even one new block all by oneself, without a pool, already requires a huge investment.

Once introduced the concept of "expiring" thread I think he will be pretty much in the same condition. To obtain bitcoins he will first need to mine a new-miner-block to enter the game and then an standard block before the thread expires. Notice the expire time/block-length start just after the new-miner-block has been mined so the probabilities to mine before the expiration time will be proportional to its mining power, as for everyone else.

> Add to that the uncompensated energy cost of mining that first block with *no* payout,

I think it could be clearly compensated by the save in energy for standards blocks.

>and I expect that the bar would be prohibitive to almost all new entrants.Mining costs and incentives are delicately balanced by the design of the network.  Whereas incumbents are much favoured by your scheme, further increasing miner centralization.

I don't think so after the new fixes. What do you think? My opinion is that, based on the "theory of games", miners acting in their own interest will try to maximize "N".

> Large incumbents could also use this to produce a mining permissions market, by selling the private keys to committed ?next-coinbase? addresses.

With the addition of thread expiration, nobody will be really motivated to shell/buy "next-coinbase" addresses since their utility is limited.

Just a remark: Notice this algorithm reduces the electricity bill, but the hardware needed stays the same, since for each round the miner participates in, it will try to mine as fast as possible and so use as much hardware as possible. No reduction costs are expected in hardware.


Best Regards,

Enrique Ariz?n Benito



I have not even tried to imagine what oddball attacks might be possible for any miner with sufficient hashpower to deliberately cause a small reorg.

--
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/80187788/attachment-0001.html>

From natanael.l at gmail.com  Thu Jan 18 16:25:16 2018
From: natanael.l at gmail.com (Natanael)
Date: Thu, 18 Jan 2018 17:25:16 +0100
Subject: [bitcoin-dev] Proposal to reduce mining power bill
In-Reply-To: <CAAt2M1-KTyGPkwaRY=krAfMPUv797JaZyhF1e5g8e8yjjGWhmQ@mail.gmail.com>
References: <CAD-msxHyN+psv5p94_pUzNMFfZjMX4Jie2=PCt0CeO1cuuCz2A@mail.gmail.com>
	<CAAt2M1-KTyGPkwaRY=krAfMPUv797JaZyhF1e5g8e8yjjGWhmQ@mail.gmail.com>
Message-ID: <CAAt2M1_L=CbXb6O-=dG+wAtVA1MSMd8H8EKddGT2MpXH_q2yjA@mail.gmail.com>

A large miner would only need to divide his hardware setup into clusters
that pretend to be different independent miners to create these "miner
tokens", as explained before, to significantly raise his chances that he on
nearly every single round would be able to mine.

Once each individual token is about the expire, the number just dedicates a
fraction of his  mining power to renew it. At the same time he can even
create multiple new tokens given enough hardware.

This does not reduce energy use. The only notable effect is to delay income
for new miners. This makes profitability calculations more annoying.

Long term, it only behaves like an artificially raised difficulty target.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/fde019fe/attachment.html>

From pete at petertodd.org  Thu Jan 18 16:36:44 2018
From: pete at petertodd.org (Peter Todd)
Date: Thu, 18 Jan 2018 11:36:44 -0500
Subject: [bitcoin-dev] Upgrading PoW algorithm
In-Reply-To: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
References: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
Message-ID: <20180118163644.GA11829@fedora-23-dvm>

On Wed, Jan 17, 2018 at 04:31:52PM -0600, Jefferson Carpenter via bitcoin-dev wrote:
> Bitcoin's difficulty will be maxed out within about 400 years, by Moore's
> law.  (After that - supposing the software does not crash when difficulty

There's no reason to think Moore's law will last for 400 years; if it did
mining Bitcoin blocks would require astronomical energy levels. I haven't
actually done the math, but having to convert a mass-energy equivalance of a
planet or two per block is probably an accurate lower-bound even with quantum
computers. Once we're at that point, the problem is the speed of light: we'll
run out of energy in our 10 minute light radius, and thus need to get it from
farther away, at which point the 10 minute block interval forces a hard fork
anyway because mining no longer is in consensus.

tl;dr: This is a topic for sci-fi writers, not bitcoin-dev

Also: https://xkcd.com/605/

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/487217e6/attachment.sig>

From ondrej.vejpustek at satoshilabs.com  Thu Jan 18 16:59:09 2018
From: ondrej.vejpustek at satoshilabs.com (=?UTF-8?Q?Ond=c5=99ej_Vejpustek?=)
Date: Thu, 18 Jan 2018 17:59:09 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
Message-ID: <d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>

> If being secure against partial share leakage is really part of your
> threat model the current proposal is gratuitously insecure against it.

I don't think that is true. Shared secret is an input of KDF which
should prevent this kind of attack.

> If partial share disclosure were an actual concern, I would recommend
> that after sharing and before encoding for transmission (e.g. before
> applying check values and word encoding to the share) the individual
> shares be passed through a large block unkeyed cryptographic
> permutation.  Under reasonable-ish assumptions about the difficulty of
> inverting the permutation with partial knowledge, this transformation
> would prevent attacks from leaks of partial share information.

Actually, we've been considering something like that. We concluded that
it is to much "rolling your own crypto". Instead of diffusion layer we
decided to apply KDF on the shared secret.

From greg at xiph.org  Thu Jan 18 18:58:14 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 18 Jan 2018 18:58:14 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
	<d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
Message-ID: <CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>

On Thu, Jan 18, 2018 at 4:59 PM, Ond?ej Vejpustek
<ondrej.vejpustek at satoshilabs.com> wrote:
>> If being secure against partial share leakage is really part of your
>> threat model the current proposal is gratuitously insecure against it.
>
> I don't think that is true. Shared secret is an input of KDF which
> should prevent this kind of attack.

My post provided a concrete example. I'd be happy to answer any
questions about it, but otherwise I'm not sure how to make it more
clear.

> Actually, we've been considering something like that. We concluded that it is to much "rolling your own crypto". Instead of diffusion layer we decided to apply KDF on the shared secret.


Quite the opposite-- a large block cipher is a standard
construction... and the off-label application of a KDF that you've
used here doesn't provide any protection against the example I gave.

From greg at xiph.org  Thu Jan 18 19:30:09 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Thu, 18 Jan 2018 19:30:09 +0000
Subject: [bitcoin-dev] ScriptPubkey consensus translation
Message-ID: <CAAS2fgQa8hXO1VsXUnUGnfu17dM0B-Jtfa7TNW=O3M8Mt=t2eQ@mail.gmail.com>

A common question when discussing newer more efficient pubkey types--
like signature aggregation or even just segwit-- is "will this thing
make the spending of already existing outputs more efficient", which
unfortunately gets an answer of No because the redemption instructions
for existing outputs have already been set, and don't incorporate
these new features.

This is good news in that no one ends up being forced to expose their
own funds to new cryptosystems whos security they may not trust.  When
sigagg is deployed, for example, any cryptographic risk in it is borne
by people who opted into using it.

Lets imagine though that segwit-with-sigagg has been long deployed,
widely used, and is more or less universally accepted as at least as
good as an old P2PKH.

In that case, it might be plausible to include in a hardfork a
consensus rule that lets someone spend scriptPubkey's matching
specific templates as though they were an alternative template.  So
then an idiomatic P2PKH or perhaps even a P2SH-multisig could be spent
as though it used the analogous p2w-sigagg script.

The main limitation is that there is some risk of breaking the
security assumptions of some complicated external protocol e.g. that
assumed that having a schnorr oracle for a key wouldn't let you spend
coins connected to that key.  This seems like a pretty contrived
concern to me however, and it's one that can largely be addressed by
ample communication in advance.  (E.g. discouraging the creation of
excessively fragile things like that, and finding out if any exist so
they can be worked around).

Am I missing any other arguments?

From thealanevans at gmail.com  Thu Jan 18 19:50:24 2018
From: thealanevans at gmail.com (Alan Evans)
Date: Thu, 18 Jan 2018 15:50:24 -0400
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English
	wordlist
In-Reply-To: <CAH01uEu5gu_4z-6r3MbqsjboHuZ87yOxAZq6QxtA-3iUZvoXZw@mail.gmail.com>
References: <31430A55-57AD-4648-8D6D-DE2A45CC013C@vandermeer.frl>
	<CAEvpD62pd_s17VoGw8B+=3_cmMq2cWneAR0MZ_CT_7DqooBnLQ@mail.gmail.com>
	<CAF5CFkgO4SEBxTH93-L_d=JBgAmDNFTJa-LrnyjcvY-Esop9EA@mail.gmail.com>
	<CAH01uEu5gu_4z-6r3MbqsjboHuZ87yOxAZq6QxtA-3iUZvoXZw@mail.gmail.com>
Message-ID: <CALPhJaxVOyxjXQUj5oMrrsXH94H4Qkw7GL24TCoZ6HoE6fa=+Q@mail.gmail.com>

> so it?s less obvious that it?s a bitcoin seed when found by a malicious
third party
1. The same words are used for wallets of all kinds of coins, so it's not
obvious it's for bitcoin.

2. Anyone recognising the word "satoshi" as related to cryptocurrency in
general, would also recognise any mnemonic.

3. You could elect to skip a mnemonic that includes the word if it was a
personal concern (but I would discourage selecting a mnemonic base on
personal preference, as could get dangerously close to being a brain wallet
in effect).

4. You could choose to record just the first 4 characters of each word,
"sato" is enough.

5. Where do we stop? the words "coin", "cash", "rich" are in there too.

6. About automated data-recovery, if you are storing mnemonics on HDDs or
other digial media, then you have larger security concerns than it just
being found during HDD recycling.

But most of all:

7. Removing a word or changing a list *is impossible* as verification of an
existing mnemonic requires the list. To change one word, you would need to
provide an alternative to BIP0039 to cope with alternative words, or change
all the words to a completely new set of 2048 English words so that it is
clear which wordlist is in use.

Regards,

Alan

On Thu, Jan 18, 2018 at 2:55 AM, Jonathan Sterling via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> All the more reason to only use the most common words that meet the other
> criteria:  https://github.com/bitcoin/bips/blob/master/bip-
> 0039.mediawiki#Wordlist
>
> I agree - keeping "satoshi" in there is an unnecessary security risk.
>
> Kind Regards,
>
> Jonathan Sterling
>
> On Thu, Jan 18, 2018 at 8:14 AM, CryptAxe via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Why wouldn't they just test the frequency of words from the wordlist in
>> entirety?
>>
>> On Jan 17, 2018 5:10 PM, "Weiwu Zhang via bitcoin-dev" <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>> 2018-01-09 19:20 GMT+08:00 Ronald van der Meer via bitcoin-dev
>>> <bitcoin-dev at lists.linuxfoundation.org>:
>>> > After reviewing some bitcoin improvement proposals, I noticed that one
>>> of the words that can be found on the BIP39 English wordlist is ?satoshi?.
>>> > I suggest removing this word from the list so it?s less obvious that
>>> it?s a bitcoin seed when found by a malicious third party.
>>>
>>> If a malicious third party discovers a word list that look like a
>>> seed, they would try using it as Bitcoin seed first anyway, with or
>>> without finding the word 'satoshi' in it. The security threat is that
>>> a malicious third party may index what they found and test every
>>> occurrence of 'satoshi' for a lead to a seed.
>>>
>>> For example, a hard-disk recycling service would add this word to
>>> their salvage tools. Any successfully hacked gmail account will be
>>> 'satoshi' tested too.
>>>
>>> So I see this as a reasonable improvement:)
>>> _______________________________________________
>>> bitcoin-dev mailing list
>>> bitcoin-dev at lists.linuxfoundation.org
>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> --
> Kind Regards,
>
> Jonathan Sterling
> +44 (0)7415 512691 <+44%207415%20512691>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/418a49c6/attachment-0001.html>

From cryptaxe at gmail.com  Thu Jan 18 19:56:41 2018
From: cryptaxe at gmail.com (CryptAxe)
Date: Thu, 18 Jan 2018 11:56:41 -0800
Subject: [bitcoin-dev] ScriptPubkey consensus translation
In-Reply-To: <CAAS2fgQa8hXO1VsXUnUGnfu17dM0B-Jtfa7TNW=O3M8Mt=t2eQ@mail.gmail.com>
References: <CAAS2fgQa8hXO1VsXUnUGnfu17dM0B-Jtfa7TNW=O3M8Mt=t2eQ@mail.gmail.com>
Message-ID: <CAF5CFkiXAt-xc8g9FLtEuRz1vSu78wMnabjVzKE=Qubb0wU5fA@mail.gmail.com>

Technically the change would be an improvement. People should be allowed to
opt-in to systems and big changes like that though, not have developers
change what their outputs mean or open them up to new security risks on
their behalf.

On Jan 18, 2018 11:30 AM, "Gregory Maxwell via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> A common question when discussing newer more efficient pubkey types--
> like signature aggregation or even just segwit-- is "will this thing
> make the spending of already existing outputs more efficient", which
> unfortunately gets an answer of No because the redemption instructions
> for existing outputs have already been set, and don't incorporate
> these new features.
>
> This is good news in that no one ends up being forced to expose their
> own funds to new cryptosystems whos security they may not trust.  When
> sigagg is deployed, for example, any cryptographic risk in it is borne
> by people who opted into using it.
>
> Lets imagine though that segwit-with-sigagg has been long deployed,
> widely used, and is more or less universally accepted as at least as
> good as an old P2PKH.
>
> In that case, it might be plausible to include in a hardfork a
> consensus rule that lets someone spend scriptPubkey's matching
> specific templates as though they were an alternative template.  So
> then an idiomatic P2PKH or perhaps even a P2SH-multisig could be spent
> as though it used the analogous p2w-sigagg script.
>
> The main limitation is that there is some risk of breaking the
> security assumptions of some complicated external protocol e.g. that
> assumed that having a schnorr oracle for a key wouldn't let you spend
> coins connected to that key.  This seems like a pretty contrived
> concern to me however, and it's one that can largely be addressed by
> ample communication in advance.  (E.g. discouraging the creation of
> excessively fragile things like that, and finding out if any exist so
> they can be worked around).
>
> Am I missing any other arguments?
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/938ee169/attachment.html>

From matthewpclancy at gmail.com  Thu Jan 18 20:49:35 2018
From: matthewpclancy at gmail.com (Matthew Clancy)
Date: Thu, 18 Jan 2018 15:49:35 -0500
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English
	wordlist
Message-ID: <CAJoTrhbeVFdW+-zhVYi3vQqmsmi0aFNmcvvcJk7WYnWNYg4UTQ@mail.gmail.com>

I would disagree here:

>But most of all:
>7. Removing a word or changing a list *is impossible* as verification of an
>existing mnemonic requires the list. To change one word, you would need to
>provide an alternative to BIP0039 to cope with alternative words, or change
>all the words to a completely new set of 2048 English words so that it is
>clear which wordlist is in use.

All that really would need to be done is select another word that is not on
the 2048 list, and then agree that by convention,  the words 'satoshi' or
the alternative word will represent the same number on the list. It seems
to be to be a fairly simple thing to implement.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/4e7d95ab/attachment.html>

From thealanevans at gmail.com  Thu Jan 18 21:29:27 2018
From: thealanevans at gmail.com (Alan Evans)
Date: Thu, 18 Jan 2018 17:29:27 -0400
Subject: [bitcoin-dev] Suggestion to remove word from BIP39 English
	wordlist
In-Reply-To: <CAJoTrhbeVFdW+-zhVYi3vQqmsmi0aFNmcvvcJk7WYnWNYg4UTQ@mail.gmail.com>
References: <CAJoTrhbeVFdW+-zhVYi3vQqmsmi0aFNmcvvcJk7WYnWNYg4UTQ@mail.gmail.com>
Message-ID: <CALPhJayvtBra2GhAXAJkrCBtQeXu-+jj-uUtQB4zWYmbcuS4gA@mail.gmail.com>

> and then agree that by convention,  the words 'satoshi' or the
alternative word will represent the same number on the list

That convention would be the alternative to BIP0039 I am referring to.


On Thu, Jan 18, 2018 at 4:49 PM, Matthew Clancy <matthewpclancy at gmail.com>
wrote:

> I would disagree here:
>
> >But most of all:
> >7. Removing a word or changing a list *is impossible* as verification of
> an
> >existing mnemonic requires the list. To change one word, you would need to
> >provide an alternative to BIP0039 to cope with alternative words, or
> change
> >all the words to a completely new set of 2048 English words so that it is
> >clear which wordlist is in use.
>
> All that really would need to be done is select another word that is not
> on the 2048 list, and then agree that by convention,  the words 'satoshi'
> or the alternative word will represent the same number on the list. It
> seems to be to be a fairly simple thing to implement.
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180118/3c429223/attachment.html>

From mark at friedenbach.org  Thu Jan 18 21:00:03 2018
From: mark at friedenbach.org (Mark Friedenbach)
Date: Thu, 18 Jan 2018 13:00:03 -0800
Subject: [bitcoin-dev] ScriptPubkey consensus translation
In-Reply-To: <CAAS2fgQa8hXO1VsXUnUGnfu17dM0B-Jtfa7TNW=O3M8Mt=t2eQ@mail.gmail.com>
References: <CAAS2fgQa8hXO1VsXUnUGnfu17dM0B-Jtfa7TNW=O3M8Mt=t2eQ@mail.gmail.com>
Message-ID: <D41C805A-726C-40E6-8760-44D411E9E47F@friedenbach.org>

The downsides could be mitigated somewhat by only making the dual interpretation apply to outputs older than a cutoff time after the activation of the new feature. For example, five years after the initial activation of the sigagg soft-fork, the sigagg rules will apply to pre-activation UTXOs as well. That would allow old UTXOs to be spent more cheaply, perhaps making some dust usable again, but anyone who purposefully sent funds to old-style outputs after the cutoff are not opened up to the dual interpretation.

> On Jan 18, 2018, at 11:30 AM, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> A common question when discussing newer more efficient pubkey types--
> like signature aggregation or even just segwit-- is "will this thing
> make the spending of already existing outputs more efficient", which
> unfortunately gets an answer of No because the redemption instructions
> for existing outputs have already been set, and don't incorporate
> these new features.
> 
> This is good news in that no one ends up being forced to expose their
> own funds to new cryptosystems whos security they may not trust.  When
> sigagg is deployed, for example, any cryptographic risk in it is borne
> by people who opted into using it.
> 
> Lets imagine though that segwit-with-sigagg has been long deployed,
> widely used, and is more or less universally accepted as at least as
> good as an old P2PKH.
> 
> In that case, it might be plausible to include in a hardfork a
> consensus rule that lets someone spend scriptPubkey's matching
> specific templates as though they were an alternative template.  So
> then an idiomatic P2PKH or perhaps even a P2SH-multisig could be spent
> as though it used the analogous p2w-sigagg script.
> 
> The main limitation is that there is some risk of breaking the
> security assumptions of some complicated external protocol e.g. that
> assumed that having a schnorr oracle for a key wouldn't let you spend
> coins connected to that key.  This seems like a pretty contrived
> concern to me however, and it's one that can largely be addressed by
> ample communication in advance.  (E.g. discouraging the creation of
> excessively fragile things like that, and finding out if any exist so
> they can be worked around).
> 
> Am I missing any other arguments?
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


From greg at xiph.org  Fri Jan 19 02:59:17 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 19 Jan 2018 02:59:17 +0000
Subject: [bitcoin-dev] Change in contact info
Message-ID: <CAAS2fgQtYJ+9tnYBXBP9xTTw4j-qW1bU3Xp31e1N2f142YMJrA@mail.gmail.com>

Not really all that on-topic, but since it was suggested to me that
this would be an efficient venue to reach others who might care to
know:

In order to spend more time working independently on deep protocol
work, especially new cryptographic privacy and security technology for
Bitcoin, I resigned from Blockstream last November. It took until the
end of December to wind down my involvement there.

Back when we founded the company I was concerned that there was
significant underinvestment in Bitcoin technology: Bitcoin had a
healthy technical community just as it does today, but lacked the kind
of industry support that projects like Linux have. Without sustained
financial support, some kinds of bigger projects seemed really hard to
pull off with developers needing to share time between non-bitcoin
employment, their families, and their other interests. For the most
part, back then early Bitcoin companies weren't investing in public
technology, at least not effectively.

We hoped that Blockstream could help act as an anchor of support for
technology development, and in doing so help grow the community. I
think that has been a big success. The Bitcoin industry has matured a
lot and today Bitcoin Core gets significant regular contributions from
many organizations (including Chaincode, DCI, Blockstream, Coinbase,
Bitmain, Blockchain, and probably others that I am forgetting or not
even aware of) and a volunteer community much larger and more active
than it has ever been before.  From what I've been told Blockstream
plans to continue to contribute to awesome technology in Bitcoin--as
demonstrated by their Lightning webstore this week--but if they
didn't, that wouldn't be a problem for Bitcoin.

So for me this means that I can go back to working on the things I
find most exciting ... without the overhead of managing staff or
dealing with the many non-Bitcoin blockchain applications which are
important to Blockstream's business. The maturing Bitcoin industry
means I don't need to worry that Bitcoin development could be left
with inadequate financial support.

I'm very excited about all the new and interesting technology that is
coming to production--Bulletproofs / CT, signature aggregation,
improved propagation and synchronization--as well as the continuing
maturation of Bitcoin as a viable subject matter for academic
researchers. I'll be spending more time helping with these and other
things, and will no longer have insight into Blockstream's activities
or a Blockstream email address (I can continue to be reached at my
xiph.org and gmail email addresses as I've used here in the past), but
otherwise this shouldn't change anything for anyone here.


Cheers,

From jeffersoncarpenter2 at gmail.com  Fri Jan 19 20:54:52 2018
From: jeffersoncarpenter2 at gmail.com (Jefferson Carpenter)
Date: Fri, 19 Jan 2018 14:54:52 -0600
Subject: [bitcoin-dev] Upgrading PoW algorithm
In-Reply-To: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
References: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
Message-ID: <374ee97c-dae9-786f-5fc6-6fb6920360cb@gmail.com>

Actually here's something we could possibly do:

Fork off a blockchain that accepts Bitcoin blocks with strictly less 
than max difficulty.  Because it does not accept max-difficulty blocks, 
it is a soft fork.  Additionally, if difficulty of a block is set to 
max, then the difficulty field is extended so that it represents a 
higher max difficulty under a different hashing function, maybe SHA512. 
Because this blockchain also accepts differently-formatted blocks, it is 
also a hard fork.

The idea is that this blockchain is identical to Bitcoin until the 
difficulty goes too high, at which point it diverges.

Transitioning from the current SHA256 to a higher-difficulty hashing 
function could be difficult, since they might be solvable at 
proportionally different hashrates.  In other words, max difficulty for 
SHA256 might be significantly faster than forcing the first 256 bits of 
a SHA512 hash...

On 1/17/2018 4:31 PM, Jefferson Carpenter wrote:
> Bitcoin's difficulty will be maxed out within about 400 years, by 
> Moore's law.? (After that - supposing the software does not crash when 
> difficulty overflows - block time will start decreasing, and it will not 
> take long before blocks are mined faster than photons can be sent across 
> the planet).
> 
> Bitcoin is the dominant cryptocurrency today, as the first mover: the 
> perfectly fair worldwide game of inventing the cryptocurrency has been 
> played and won.? However, unfortunately, it has a built-in end date: 
> about 400 years from now.? After that, it won't necessarily be clear 
> what the dominant cryptocurrency is.? It might be a lot like VHS vs 
> Betamax, and a lot of people could lose a lot of money.? It seems to me, 
> this could be mitigated by planning today for what we are going to do 
> when Bitcoin finally breaks 400 years from now.
> 
> Are there any distinct plans today for migrating to a PoW supporting an 
> even higher difficulty?

From sdaftuar at gmail.com  Fri Jan 19 20:38:34 2018
From: sdaftuar at gmail.com (Suhas Daftuar)
Date: Fri, 19 Jan 2018 15:38:34 -0500
Subject: [bitcoin-dev] [BIP Proposal] P2SH and Version 0 Segwit Script
	enforcement from genesis
Message-ID: <CAFp6fsF_QS4OMgjYqLw+u2jsOoRn0+3jgHws8Bo7WFkR5E1+Og@mail.gmail.com>

Hi,

I propose backdating the P2SH and Segwit version 0 script rules back to the
genesis block, as a way to simplify these consensus rules.  Here's the
abstract from a draft BIP I wrote up to explain this change:

The Pay to Script Hash (P2SH, BIP 16) script rules and the Version 0
Witness Program script rules (BIP 143/141) can be enforced from the genesis
block with only one historical exception. Doing so simplifies consensus
rules and allows protocol implementers to avoid writing and testing code
paths that are no longer relevant.

The full BIP draft can be found here:
https://github.com/sdaftuar/bips/blob/p2sh-v0segwit-from-genesis/bip-sdaftuar-p2sh-v0segwit-from-genesis.mediawiki

And the currently open pull request to Bitcoin Core which implements this
change can be found here: https://github.com/bitcoin/bitcoin/pull/11739
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180119/9e6d1bb7/attachment.html>

From willtech at live.com.au  Fri Jan 19 23:25:43 2018
From: willtech at live.com.au (Damian Williamson)
Date: Fri, 19 Jan 2018 23:25:43 +0000
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction
 Priority For Ordering Transactions In Blocks
In-Reply-To: <PS2P216MB0179F13FF364666D92E6B2F89D1F0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>,
	<PS2P216MB0179F13FF364666D92E6B2F89D1F0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <PS2P216MB0179436AF3183A14D79869D39DEF0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

An example curve:

The curve curently described here is ineffective at acheiving the requirements. It seems to be not nearly steep enough resulting in too many inclusions (as it happens, this may not metter - needs further evaluation) and, the lower end values seem problematically small but, results in a number between 100 for the highest fee BTC/KB and a small fraction of 1 for the lowest. This math needs to be improved.


pf(tx) = sin2((fx-(fl-0.00000001))/(fh-(fl-0.00000001))*1.570796326795)*100


pf is the calculated priority number for the fee for tx the specifc valid transaction.
fx is the fee in BTC/KB for the specific transaction.
fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
fh is the highest valid fee in BTC/KB currently in the nodes mempool.

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Thursday, 4 January 2018 8:01:10 PM
To: Bitcoin Protocol Discussion
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks


This proposal has a new update, mostly minor edits. Additionally, I had a logic flaw in the hard fork / soft fork declaration statement. The specific terms of the CC-BY-SA-4.0 licence the document is published under have now been updated to include additional permissions available under the MIT licence.


Recently, on Twitter:

I am looking for a capable analyst/programmer to work on a BIP proposal as co-author. Will need to format several Full BIP's per these BIP process requirements: ( https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki ) from a BIP Proposal, being two initially for non-consensus full-interoperable pre-rollout on peer service layer & API/RPC layer and, a reference implementation for Bitcoin Core per: ( https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md ). Interested parties please reply via this list thread: ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015485.html ) #Bitcoin #BIP


Regards,

Damian Williamson


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, 1 January 2018 10:04 PM
To: bitcoin-dev at lists.linuxfoundation.org
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks

Happy New Year all.

This proposal has been further amended with several minor changes and a
few additions.

I believe that all known issues raised so far have been sufficiently
addressed. Either that or, I still have more work to do.

## BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks

Schema:
##########
Document: BIP Proposal
Title: UTPFOTIB - Use Transaction Priority For Ordering Transactions In
Blocks
Published: 26-12-2017
Revised: 01-01-2018
Author: Damian Williamson <willtech at live.com.au>
Licence: Creative Commons Attribution-ShareAlike 4.0 International
License.
URL: http://thekingjameshrmh.tumblr.com/post/168948530950/bip-proposal-
utpfotib-use-transaction-priority-for-order
##########

### 1. Abstract

This document proposes to address the issue of transactional
reliability in Bitcoin, where valid transactions may be stuck in the
transaction pool for extended periods or never confirm.

There are two key issues to be resolved to achieve this:

1.  The current transaction bandwidth limit.
2.  The current ad-hoc methods of including transactions in blocks
resulting in variable and confusing confirmation times for valid
transactions, including transactions with a valid fee that may never
confirm.

It is important with any change to protect the value of fees as these
will eventually be the only payment that miners receive. Rather than an
auction model for limited bandwidth, the proposal results in a fee for
priority service auction model.

It would not be true to suggest that all feedback received so far has
been entirely positive although, most of it has been constructive.

The previous threads for this proposal are available here:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/s
ubject.html

In all parts of this proposal, references to a transaction, a valid
transaction, a transaction with a valid fee, a valid fee, etc. is
defined as any transaction that is otherwise valid with a fee of at
least 0.00001000 BTC/KB as defined as the dust level, interpreting from
Bitcoin Core GUI. Transactions with a fee lower than this rate are
considered dust.

In all parts of this proposal, dust and zero-fee transactions are
always ignored and/or excluded unless specifically mentioned.

It is generally assumed that miners currently prefer to include
transactions with higher fees.

### 2. The need for this proposal

We all must learn to admit that transaction bandwidth is still lurking
as a serious issue for the operation, reliability, safety, consumer
acceptance, uptake and, for the value of Bitcoin.

I recently sent a payment which was not urgent so; I chose three-day
target confirmation from the fee recommendation. That transaction has
still not confirmed after now more than six days - even waiting twice
as long seems quite reasonable to me (note for accuracy: it did
eventually confirm). That transaction is a valid transaction; it is not
rubbish, junk or, spam. Under the current model with transaction
bandwidth limitation, the longer a transaction waits, the less likely
it is ever to confirm due to rising transaction numbers and being
pushed back by transactions with rising fees.

I argue that no transactions with fees above the dust level are rubbish
or junk, only some zero fee transactions might be spam. Having an ever-
increasing number of valid transactions that do not confirm as more new
transactions with higher fees are created is the opposite of operating
a robust, reliable transaction system.

While the miners have discovered a gold mine, it is the service they
provide that is valuable. If the service is unreliable they are not
worth the gold that they mine. This is reflected in the value of
Bitcoin.

Business cannot operate with a model where transactions may or may not
confirm. Even a business choosing a modest fee has no guarantee that
their valid transaction will not be shuffled down by new transactions
to the realm of never confirming after it is created. Consumers also
will not accept this model as Bitcoin expands. If Bitcoin cannot be a
reliable payment system for confirmed transactions then consumers, by
and large, will simply not accept the model once they understand.
Bitcoin will be a dirty payment system, and this will kill the value of
Bitcoin.

Under the current system, a minority of transactions will eventually be
the lucky few who have fees high enough to escape being pushed down the
list.

Once there are more than x transactions (transaction bandwidth limit)
every ten minutes, only those choosing twenty-minute confirmation (2
blocks) from the fee recommendations will have initially at most a
fifty percent chance of ever having their payment confirm by the time
2x transactions is reached. Presently, not even using fee
recommendations can ensure a sufficiently high fee is paid to ensure
transaction confirmation.

I also argue that the current auction model for limited transaction
bandwidth is wrong, is not suitable for a reliable transaction system
and, is wrong for Bitcoin. All transactions with valid fees must
confirm in due time. Currently, Bitcoin is not a safe way to send
payments.

I do not believe that consumers and business are against paying fees,
even high fees. What is required is operational reliability.

This great issue needs to be resolved for the safety and reliability of
Bitcoin. The time to resolve issues in commerce is before they become
great big issues. The time to resolve this issue is now. We must have
the foresight to identify and resolve problems before they trip us
over.  Simply doubling block sizes every so often is reactionary and is
not a reliable permanent solution.

I have written this proposal for a technical solution but, need your
help to write it up to an acceptable standard to be a full BIP.

### 3. The problem

Everybody wants value. Miners want to maximise revenue from fees (and
we presume, to minimise block size). Consumers need transaction
reliability and, (we presume) want low fees.

The current transaction bandwidth limit is a limiting factor for both.
As the operational safety of transactions is limited, so is consumer
confidence as they realise the issue and, accordingly, uptake is
limited. Fees are artificially inflated due to bandwidth limitations
while failing to provide a full confirmation service for all valid
transactions.

Current fee recommendations provide no satisfaction for transaction
reliability and, as Bitcoin scales, this will worsen.

Transactions are included in blocks by miners using whatever basis they
prefer. We expect that this is usually a fee-based priority. However,
even transactions with a valid fee may be left in the transaction pool
for some time. As transaction bandwidth becomes an issue, not even
extreme fees can ensure a transaction is processed in a timely manner
or at all.

Bitcoin must be a fully scalable and reliable service, providing full
transaction confirmation for every valid transaction.

The possibility to send a transaction with a fee lower than one that is
acceptable to allow eventual transaction confirmation should be removed
from the protocol and also from the user interface.

Bitcoin should be capable of reliably and inexpensively processing
casual transactions, and also priority processing of fee paying at
auction for priority transactions in the shortest possible timeframe.

### 4. Solution summary

#### Main solution

Provide each valid transaction in the mempool with an individual
transaction priority each time before choosing transactions to include
in the current block. The priority being a function of the fee (on a
curve), and the time waiting in the transaction pool (also on a curve)
out to n days (n = 60 days ?), and extending past n days. The value for
fee on a curve may need an upper limit. The transaction priority to
serve as the likelihood of a transaction being included in the current
block, and for determining the order in which transactions are tried to
see if they will be included.

Nodes will need to keep track of when a transaction is first seen. It
is satisfactory for each node to do this independently provided the
full mempool and information survives node restart. If there is a more
reliable way to determine when a transaction was first seen on the
network then it should be utilised.

> My current default installation of Bitcoin Core v0.15.1 does not
currently seem to save and load the mempool on restart, despite the
notes in the command line options panel that the default for
persistmempool is 1. In the debug panel, some 90,000 transactions
before restart, some 200 odd shortly after. Manually setting
persistmempool=1 in the conf file does not seem to make any difference.
Perhaps it is operating as expected and I am not sure what to observe,
but does not seem to be observably saving and loading the mempool on
restart. This will need to be resolved.

Use a dynamic target block size to make the current block. This marks a
shift from using block size or weight to a count of transactions.
Determine the target block size using; pre-rollout(current average
valid transaction pool size) x ( 1 / (144 x n days ) ) = number of
transactions to be included in the current block. The block created
should be a minimum 1MB in size regardless if the target block size is
lower.

If the created block size consistently contains too few transactions
and the number of new transactions created is continuously greater than
the block size will accommodate then I expect eventually ageing
transactions will be over-represented as a portion of the block
contents. Once another new node conforming to the proposal makes a
block, the block size will be proportionately larger as the transaction
pool has grown.  If block size is too large on average then this will
shrink the transaction pool.

Miners will likely want to conform to the proposal, since making blocks
larger than necessary makes more room in each block potentially
lowering the highest fees paid for priority service. Always making
blocks smaller than the proposal requires will in time lower the
utility value of Bitcoin, a different situation but akin to the
current. Transactions will still always confirm but with longer and
longer wait periods. The auction at the front of the queue for priority
will be destroyed as there will be eventually no room in blocks besides
ageing transations and, there will be little value paying higher than
the minimum fee. Obviously, neither of these scenarios are in a miner's
interests.

Without a consensus as to what size dynamic block to create,
enforcement of dynamic block size is not currently possible. It may be
possible for a consensus to be formed in the future but here I cannot
speculate. I can only suggest that it is in the interest of Bitcoin as
a whole and, in the interest of each node to conform to the proposal.
Some nodes failing to conform to the proposed requirements of dynamic
size or transaction priority in this proposal will not be destructive
to the operation of the proposal.

If necessary, nodes that have not yet adopted the proposal will just
continue to create standard fixed size unordered blocks, although, if
the current mechanisms of block validation include the fixed block size
then it is unlikely that these nodes will be able to validate the
blockchain going forward. In this case a hard fork and a full transfer
to the new method should be required. If dynamic blocks with ordered
transactions will be valid to existing nodes then only a soft fork is
required. There is no proposed change to the internal construction of
blocks, only to the block size and using an ordered method of
transaction selection.

> The default value for mempoolexpiry in Bitcoin Core may in future
need to be adjusted to match something more than n days or, perhaps
using less than n = 14 days may be a more sensible approach?

All block created with dynamic size should be verified to ensure
conformity to a probability distribution curve resulting from the
priority method. Since the input is a probability, the output should
conform to a probability distribution.

The curves used for the priority of transactions would have to be
appropriate. Perhaps a mathematician with experience in probability can
develop the right formulae. My thinking is a steep curve. I suppose
that the probability of all transactions should probably account for a
sufficient number of inclusions that the target block size is met on
average although, it may not always be. As a suggestion, consider
including some dust or zero-fee transactions to pad if each valid
transaction is tried and the target block size is not yet met, highest
BTC transaction value first?

**Explanation of the operation of priority:**

> If transaction priority is, for example, a number between one (low)
and one-hundred (high) it can be directly understood as the percentage
chance in one-hundred of a transaction being included in the block.
Using probability or likelihood infers that there is some function of
random. Try the transactions in priority order from highest to lowest,
if random (100) < transaction priority then the transaction is included
until the target block size is met.

> To break it down further, if both the fee on a curve value and the
time waiting on a curve value are each a number between one and one-
hundred, a rudimentary method may be to simply multiply those two
numbers, to find the priority number. For example, a middle fee
transaction waiting thirty days (if n = 60 days) may have a value of
five for each part  (yes, just five, the values are on a curve). When
multiplied that will give a priority value of twenty-five, or, a
twenty-five percent chance at that moment of being included in the
block; it will likely be included in one of the next four blocks,
getting more likely each chance. If it is still not included then the
value of time waiting will be higher, making for more probability. A
very low fee transaction would have a value for the fee of one. It
would not be until near sixty-days that the particular low fee
transaction has a high likelihood of being included in the block.

In practice it may be more useful to use numbers representative of one-
hundred for the highest fee priority curve down to a small fraction of
one for the lowest fee and, from one for a newly seen transaction up to
a proportionately high number above one-hundred for the time waiting
curve. It is truely beyond my level of math to resolve probability
curves accurately without much trial and error.

The primary reason for addressing the issue is to ensure transactional
reliability and scalability while having each valid transaction confirm
in due time.

#### Pros

*   Maximizes transaction reliability.
*   Overcomes transaction bandwidth limit.
*   Fully scalable.
*   Maximizes possibility for consumer and business uptake.
*   Maximizes total fees paid per block without reducing reliability;
because of reliability, in time confidence and overall uptake are
greater; therefore, more transactions.
*   Market determines fee paid for transaction priority.
*   Fee recommendations work all the way out to 30 days or greater.
*   Provides additional block entropy; greater security since there is
less probability of predicting the next block. _Although this is not
necessary it is a product of the operation of this proposal._

#### Cons

*   Could initially lower total transaction fees per block.
*   Must be first be programmed.

#### Pre-rollout

Nodes need to have at a minimum a loose understanding of the average
(since there is no consensus) size of the transaction pool as a
requirement to enable future changes to the way blocks are constructed.

A new network service should be constructed to meet this need. This
service makes no changes to any existing operation or function of the
node. Initially, Bitcoin Core is a suitable candidate.

For all operations we count only valid transactions.

**The service must:**

*   Have an individual temporary (runtime permanent only) Serial Node
ID.
*   Accept communication of the number of valid transactions in the
mempool of another valid Bitcoin node along with the Serial Node ID of
the node whose value is provided.
*   Disconnect the service from any non-Bitcoin node. Bitcoin Core may
handle this already?
*   Expire any value not updated for k minutes (k = 30 minutes?).
*   Broadcast all mempool information the node has every m minutes (m =
10 minutes?), including its own.
*   Nodes own mempool information should not be broadcast or used in
calculation until the node has been up long enough for the mempool to
normalise for at least o minutes (o = 300 minutes ?)
*   Alternatively, if loading nodes own full mempool from disk on node
restart (o = 30 minutes ?)
*   Only new or updated mempool values should be transmitted to the
same node. Updated includes updated with no change.
*   All known mempool information must survive node restart.
*   If the nodes own mempool is not normalised and network information
is not available to calculate an average just display zero.
*   Internally, the average transaction pool size must return the
calculated average if an average is available or, if none is available
just the number of valid transactions in the node's own mempool
regardless if it is normalised.

Bitcoin Core must use all collated information on mempool size to
calculate a figure for the average mempool size.

The calculated figure should be displayed in the appropriate place in
the Debug window alongside the text Network average transactions.

Consideration must be given before development of the network bandwidth
this would require. All programming must be consistent with the current
operation and conventions of Bitcoin Core. Methods must work on all
platforms.

As this new service does not affect any existing service or feature of
Bitcoin or Bitcoin Core, this can technically be programmed now and
included in Bitcoin Core at any time.

### 5. Solution operation

This is a simplistic view of the operation. The actual operation will
need to be determined accurately in a spec for the programmer.

1.  Determine the target block size for the current block.
2.  Assign a transaction priority to each valid transaction in the
mempool.
3.  Select transactions to include in the current block using
probability in transaction priority order until the target block size
is met. If target block size is not met, include dust and zero-fee
transactions to pad.
4.  Solve block.
5.  Broadcast the current block when it is solved.
6.  Block is received.
7.  Block verification process.
8.  Accept/reject block based on verification result.
9.  Repeat.

### 6. Closing comments

It may be possible to verify blocks conform to the proposal by showing
that the probability for all transactions included in the block
statistically conforms to a probability distribution curve, *if* the
individual transaction priority can be recreated. I am not that deep
into the mathematics; however, it may also be possible to use a similar
method to do this just based on the fee, that statistically, the block
conforms to a fee distribution. Any dust and zero-fee transactions
would have to be ignored. This solution needs a competent mathematician
with experience in probability and statistical distribution.

It is trivial to this proposal to offer that a node provides the next
block size with a block when it is solved. I am not sure that this
creates any actual benefit since the provided next block size is only
one node's view, as it is the node may seemingly just as well use its
own view and create the block. Providing a next block size only adds
additional complexity to the required operation, however, perhaps
providing the next block size is not trivial in what is accomplished
and the feature can be included in the operation.

Instead of the pre-rollout network service providing data as to valid
transactions in mempool, it could directly provide data as to the
suggested next block size if that is preferred, using a similar
operation as is suggested now and averaging all received suggested next
block sizes.

It may be foreseeable in the future for Bitcoin to operate with a
network of dedicated full blockchain & mempool servers. This would not
be without challenges to overcome but would offer several benefits,
including to the operation of this proposal, and especially as the RAM
and storage requirements of a full node grows. It is easy to foresee
that in just another seven years of operation a Bitcoin Full Node will
require at least 300GB of storage and, if the mempool only doubles in
size, over 1GB of RAM.

There has been some concern expressed over spam and very low fee
transactions, and an infinite block size resulting. I hope that for
those concerned using the dust level addresses the issue, especially as
the value of Bitcoin grows.

Notwithstanding this proposal, all blocks including those with dynamic
size each have limited transaction space per block. This proposal
results in a fee for priority service auction, where the probability of
a transaction to be included in limited space in the next available
block is auctioned to the highest bidders and all other transactions
must wait until they reach priority by ageing to gain significant
probability. Under this proposal the mempool can grow quite large while
the confirmation service continues in a stable and reliable manner.
Several incentives for attackers are removed, where there is no longer
multiple potential incentives for unnecessarily filling blocks or
flooding the mempool with transactions, whether such transactions are
fraudulent, valid or, otherwise. Adoption of this proposal and
adherence results in a reliable, stable fee paying transaction
confirmation service and a beneficial auction.

This proposal is necessary. I implore, at the very least, that we use
some method that validates full transaction reliability and enables
scalability of Bitcoin. If not this proposal, an alternative.

I have done as much with this proposal as I feel that I am able so far
but continue to take your feedback.

Regards,
Damian Williamson

[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/
88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)
<span xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text" property="dct:title"
rel="dct:type">BIP Proposal: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks</span> by [Damian Williamson
&lt;willtech at live.com.au&gt;](http://thekingjameshrmh.tumblr.com/post/1
68948530950/bip-proposal-utpfotib-use-transaction-priority-for-order)
is licensed under a [Creative Commons Attribution-ShareAlike 4.0
International License](http://creativecommons.org/licenses/by-sa/4.0/).
Based on a work at https://lists.linuxfoundation.org/pipermail/bitcoin-
dev/2017-
December/015371.html](https://lists.linuxfoundation.org/pipermail/bitco
in-dev/2017-December/015371.html).
Permissions beyond the scope of this license may be available at [https
://opensource.org/licenses/BSD-3-
Clause](https://opensource.org/licenses/BSD-3-Clause).


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180119/bfea8a86/attachment-0001.html>

From willtech at live.com.au  Sat Jan 20 12:04:20 2018
From: willtech at live.com.au (Damian Williamson)
Date: Sat, 20 Jan 2018 12:04:20 +0000
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction
 Priority For Ordering Transactions In Blocks
In-Reply-To: <PS2P216MB0179436AF3183A14D79869D39DEF0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>,
	<PS2P216MB0179F13FF364666D92E6B2F89D1F0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>,
	<PS2P216MB0179436AF3183A14D79869D39DEF0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <PS2P216MB0179B7D7EDAE4704836A91F09DEE0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

Tried a different approach for the curves, would appreciate it if someone has the energy to work on this and help me to resolve it a bit more scientifically:


p(tx) = (((((fx - (fl - 0.00000001)) / (fh - (fl - 0.00000001))) * 100) + 1) ^ y) + (((((wx - 0.9) / ((86400 * n) - 0.9)) * 100) + 1) ^ y)

p is the calculated priority number for tx the specific valid transaction.
fx is the fee in BTC/KB for the specific transaction.
fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
fh is the highest valid fee in BTC/KB currently in the nodes mempool.
wx is the current wait in seconds for tx the specific valid transaction.
n is the number of days maximum wait consensus value.
y can be 10 or, y can be a further developed to be a formula based on the number of required inclusions to vary the steepness of the curve as the mempool size varies.

In the next step, the random value must be:
if random(101^y) < p then transaction is included;

Regards,
Damian Williamson


________________________________
From: Damian Williamson <willtech at live.com.au>
Sent: Saturday, 20 January 2018 10:25:43 AM
To: Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks


An example curve:

The curve curently described here is ineffective at acheiving the requirements. It seems to be not nearly steep enough resulting in too many inclusions (as it happens, this may not metter - needs further evaluation) and, the lower end values seem problematically small but, results in a number between 100 for the highest fee BTC/KB and a small fraction of 1 for the lowest. This math needs to be improved.


pf(tx) = sin2((fx-(fl-0.00000001))/(fh-(fl-0.00000001))*1.570796326795)*100


pf is the calculated priority number for the fee for tx the specifc valid transaction.
fx is the fee in BTC/KB for the specific transaction.
fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
fh is the highest valid fee in BTC/KB currently in the nodes mempool.

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Thursday, 4 January 2018 8:01:10 PM
To: Bitcoin Protocol Discussion
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks


This proposal has a new update, mostly minor edits. Additionally, I had a logic flaw in the hard fork / soft fork declaration statement. The specific terms of the CC-BY-SA-4.0 licence the document is published under have now been updated to include additional permissions available under the MIT licence.


Recently, on Twitter:

I am looking for a capable analyst/programmer to work on a BIP proposal as co-author. Will need to format several Full BIP's per these BIP process requirements: ( https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki ) from a BIP Proposal, being two initially for non-consensus full-interoperable pre-rollout on peer service layer & API/RPC layer and, a reference implementation for Bitcoin Core per: ( https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md ). Interested parties please reply via this list thread: ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015485.html ) #Bitcoin #BIP


Regards,

Damian Williamson


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org <bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
Sent: Monday, 1 January 2018 10:04 PM
To: bitcoin-dev at lists.linuxfoundation.org
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks

Happy New Year all.

This proposal has been further amended with several minor changes and a
few additions.

I believe that all known issues raised so far have been sufficiently
addressed. Either that or, I still have more work to do.

## BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks

Schema:
##########
Document: BIP Proposal
Title: UTPFOTIB - Use Transaction Priority For Ordering Transactions In
Blocks
Published: 26-12-2017
Revised: 01-01-2018
Author: Damian Williamson <willtech at live.com.au>
Licence: Creative Commons Attribution-ShareAlike 4.0 International
License.
URL: http://thekingjameshrmh.tumblr.com/post/168948530950/bip-proposal-
utpfotib-use-transaction-priority-for-order
##########

### 1. Abstract

This document proposes to address the issue of transactional
reliability in Bitcoin, where valid transactions may be stuck in the
transaction pool for extended periods or never confirm.

There are two key issues to be resolved to achieve this:

1.  The current transaction bandwidth limit.
2.  The current ad-hoc methods of including transactions in blocks
resulting in variable and confusing confirmation times for valid
transactions, including transactions with a valid fee that may never
confirm.

It is important with any change to protect the value of fees as these
will eventually be the only payment that miners receive. Rather than an
auction model for limited bandwidth, the proposal results in a fee for
priority service auction model.

It would not be true to suggest that all feedback received so far has
been entirely positive although, most of it has been constructive.

The previous threads for this proposal are available here:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/s
ubject.html

In all parts of this proposal, references to a transaction, a valid
transaction, a transaction with a valid fee, a valid fee, etc. is
defined as any transaction that is otherwise valid with a fee of at
least 0.00001000 BTC/KB as defined as the dust level, interpreting from
Bitcoin Core GUI. Transactions with a fee lower than this rate are
considered dust.

In all parts of this proposal, dust and zero-fee transactions are
always ignored and/or excluded unless specifically mentioned.

It is generally assumed that miners currently prefer to include
transactions with higher fees.

### 2. The need for this proposal

We all must learn to admit that transaction bandwidth is still lurking
as a serious issue for the operation, reliability, safety, consumer
acceptance, uptake and, for the value of Bitcoin.

I recently sent a payment which was not urgent so; I chose three-day
target confirmation from the fee recommendation. That transaction has
still not confirmed after now more than six days - even waiting twice
as long seems quite reasonable to me (note for accuracy: it did
eventually confirm). That transaction is a valid transaction; it is not
rubbish, junk or, spam. Under the current model with transaction
bandwidth limitation, the longer a transaction waits, the less likely
it is ever to confirm due to rising transaction numbers and being
pushed back by transactions with rising fees.

I argue that no transactions with fees above the dust level are rubbish
or junk, only some zero fee transactions might be spam. Having an ever-
increasing number of valid transactions that do not confirm as more new
transactions with higher fees are created is the opposite of operating
a robust, reliable transaction system.

While the miners have discovered a gold mine, it is the service they
provide that is valuable. If the service is unreliable they are not
worth the gold that they mine. This is reflected in the value of
Bitcoin.

Business cannot operate with a model where transactions may or may not
confirm. Even a business choosing a modest fee has no guarantee that
their valid transaction will not be shuffled down by new transactions
to the realm of never confirming after it is created. Consumers also
will not accept this model as Bitcoin expands. If Bitcoin cannot be a
reliable payment system for confirmed transactions then consumers, by
and large, will simply not accept the model once they understand.
Bitcoin will be a dirty payment system, and this will kill the value of
Bitcoin.

Under the current system, a minority of transactions will eventually be
the lucky few who have fees high enough to escape being pushed down the
list.

Once there are more than x transactions (transaction bandwidth limit)
every ten minutes, only those choosing twenty-minute confirmation (2
blocks) from the fee recommendations will have initially at most a
fifty percent chance of ever having their payment confirm by the time
2x transactions is reached. Presently, not even using fee
recommendations can ensure a sufficiently high fee is paid to ensure
transaction confirmation.

I also argue that the current auction model for limited transaction
bandwidth is wrong, is not suitable for a reliable transaction system
and, is wrong for Bitcoin. All transactions with valid fees must
confirm in due time. Currently, Bitcoin is not a safe way to send
payments.

I do not believe that consumers and business are against paying fees,
even high fees. What is required is operational reliability.

This great issue needs to be resolved for the safety and reliability of
Bitcoin. The time to resolve issues in commerce is before they become
great big issues. The time to resolve this issue is now. We must have
the foresight to identify and resolve problems before they trip us
over.  Simply doubling block sizes every so often is reactionary and is
not a reliable permanent solution.

I have written this proposal for a technical solution but, need your
help to write it up to an acceptable standard to be a full BIP.

### 3. The problem

Everybody wants value. Miners want to maximise revenue from fees (and
we presume, to minimise block size). Consumers need transaction
reliability and, (we presume) want low fees.

The current transaction bandwidth limit is a limiting factor for both.
As the operational safety of transactions is limited, so is consumer
confidence as they realise the issue and, accordingly, uptake is
limited. Fees are artificially inflated due to bandwidth limitations
while failing to provide a full confirmation service for all valid
transactions.

Current fee recommendations provide no satisfaction for transaction
reliability and, as Bitcoin scales, this will worsen.

Transactions are included in blocks by miners using whatever basis they
prefer. We expect that this is usually a fee-based priority. However,
even transactions with a valid fee may be left in the transaction pool
for some time. As transaction bandwidth becomes an issue, not even
extreme fees can ensure a transaction is processed in a timely manner
or at all.

Bitcoin must be a fully scalable and reliable service, providing full
transaction confirmation for every valid transaction.

The possibility to send a transaction with a fee lower than one that is
acceptable to allow eventual transaction confirmation should be removed
from the protocol and also from the user interface.

Bitcoin should be capable of reliably and inexpensively processing
casual transactions, and also priority processing of fee paying at
auction for priority transactions in the shortest possible timeframe.

### 4. Solution summary

#### Main solution

Provide each valid transaction in the mempool with an individual
transaction priority each time before choosing transactions to include
in the current block. The priority being a function of the fee (on a
curve), and the time waiting in the transaction pool (also on a curve)
out to n days (n = 60 days ?), and extending past n days. The value for
fee on a curve may need an upper limit. The transaction priority to
serve as the likelihood of a transaction being included in the current
block, and for determining the order in which transactions are tried to
see if they will be included.

Nodes will need to keep track of when a transaction is first seen. It
is satisfactory for each node to do this independently provided the
full mempool and information survives node restart. If there is a more
reliable way to determine when a transaction was first seen on the
network then it should be utilised.

> My current default installation of Bitcoin Core v0.15.1 does not
currently seem to save and load the mempool on restart, despite the
notes in the command line options panel that the default for
persistmempool is 1. In the debug panel, some 90,000 transactions
before restart, some 200 odd shortly after. Manually setting
persistmempool=1 in the conf file does not seem to make any difference.
Perhaps it is operating as expected and I am not sure what to observe,
but does not seem to be observably saving and loading the mempool on
restart. This will need to be resolved.

Use a dynamic target block size to make the current block. This marks a
shift from using block size or weight to a count of transactions.
Determine the target block size using; pre-rollout(current average
valid transaction pool size) x ( 1 / (144 x n days ) ) = number of
transactions to be included in the current block. The block created
should be a minimum 1MB in size regardless if the target block size is
lower.

If the created block size consistently contains too few transactions
and the number of new transactions created is continuously greater than
the block size will accommodate then I expect eventually ageing
transactions will be over-represented as a portion of the block
contents. Once another new node conforming to the proposal makes a
block, the block size will be proportionately larger as the transaction
pool has grown.  If block size is too large on average then this will
shrink the transaction pool.

Miners will likely want to conform to the proposal, since making blocks
larger than necessary makes more room in each block potentially
lowering the highest fees paid for priority service. Always making
blocks smaller than the proposal requires will in time lower the
utility value of Bitcoin, a different situation but akin to the
current. Transactions will still always confirm but with longer and
longer wait periods. The auction at the front of the queue for priority
will be destroyed as there will be eventually no room in blocks besides
ageing transations and, there will be little value paying higher than
the minimum fee. Obviously, neither of these scenarios are in a miner's
interests.

Without a consensus as to what size dynamic block to create,
enforcement of dynamic block size is not currently possible. It may be
possible for a consensus to be formed in the future but here I cannot
speculate. I can only suggest that it is in the interest of Bitcoin as
a whole and, in the interest of each node to conform to the proposal.
Some nodes failing to conform to the proposed requirements of dynamic
size or transaction priority in this proposal will not be destructive
to the operation of the proposal.

If necessary, nodes that have not yet adopted the proposal will just
continue to create standard fixed size unordered blocks, although, if
the current mechanisms of block validation include the fixed block size
then it is unlikely that these nodes will be able to validate the
blockchain going forward. In this case a hard fork and a full transfer
to the new method should be required. If dynamic blocks with ordered
transactions will be valid to existing nodes then only a soft fork is
required. There is no proposed change to the internal construction of
blocks, only to the block size and using an ordered method of
transaction selection.

> The default value for mempoolexpiry in Bitcoin Core may in future
need to be adjusted to match something more than n days or, perhaps
using less than n = 14 days may be a more sensible approach?

All block created with dynamic size should be verified to ensure
conformity to a probability distribution curve resulting from the
priority method. Since the input is a probability, the output should
conform to a probability distribution.

The curves used for the priority of transactions would have to be
appropriate. Perhaps a mathematician with experience in probability can
develop the right formulae. My thinking is a steep curve. I suppose
that the probability of all transactions should probably account for a
sufficient number of inclusions that the target block size is met on
average although, it may not always be. As a suggestion, consider
including some dust or zero-fee transactions to pad if each valid
transaction is tried and the target block size is not yet met, highest
BTC transaction value first?

**Explanation of the operation of priority:**

> If transaction priority is, for example, a number between one (low)
and one-hundred (high) it can be directly understood as the percentage
chance in one-hundred of a transaction being included in the block.
Using probability or likelihood infers that there is some function of
random. Try the transactions in priority order from highest to lowest,
if random (100) < transaction priority then the transaction is included
until the target block size is met.

> To break it down further, if both the fee on a curve value and the
time waiting on a curve value are each a number between one and one-
hundred, a rudimentary method may be to simply multiply those two
numbers, to find the priority number. For example, a middle fee
transaction waiting thirty days (if n = 60 days) may have a value of
five for each part  (yes, just five, the values are on a curve). When
multiplied that will give a priority value of twenty-five, or, a
twenty-five percent chance at that moment of being included in the
block; it will likely be included in one of the next four blocks,
getting more likely each chance. If it is still not included then the
value of time waiting will be higher, making for more probability. A
very low fee transaction would have a value for the fee of one. It
would not be until near sixty-days that the particular low fee
transaction has a high likelihood of being included in the block.

In practice it may be more useful to use numbers representative of one-
hundred for the highest fee priority curve down to a small fraction of
one for the lowest fee and, from one for a newly seen transaction up to
a proportionately high number above one-hundred for the time waiting
curve. It is truely beyond my level of math to resolve probability
curves accurately without much trial and error.

The primary reason for addressing the issue is to ensure transactional
reliability and scalability while having each valid transaction confirm
in due time.

#### Pros

*   Maximizes transaction reliability.
*   Overcomes transaction bandwidth limit.
*   Fully scalable.
*   Maximizes possibility for consumer and business uptake.
*   Maximizes total fees paid per block without reducing reliability;
because of reliability, in time confidence and overall uptake are
greater; therefore, more transactions.
*   Market determines fee paid for transaction priority.
*   Fee recommendations work all the way out to 30 days or greater.
*   Provides additional block entropy; greater security since there is
less probability of predicting the next block. _Although this is not
necessary it is a product of the operation of this proposal._

#### Cons

*   Could initially lower total transaction fees per block.
*   Must be first be programmed.

#### Pre-rollout

Nodes need to have at a minimum a loose understanding of the average
(since there is no consensus) size of the transaction pool as a
requirement to enable future changes to the way blocks are constructed.

A new network service should be constructed to meet this need. This
service makes no changes to any existing operation or function of the
node. Initially, Bitcoin Core is a suitable candidate.

For all operations we count only valid transactions.

**The service must:**

*   Have an individual temporary (runtime permanent only) Serial Node
ID.
*   Accept communication of the number of valid transactions in the
mempool of another valid Bitcoin node along with the Serial Node ID of
the node whose value is provided.
*   Disconnect the service from any non-Bitcoin node. Bitcoin Core may
handle this already?
*   Expire any value not updated for k minutes (k = 30 minutes?).
*   Broadcast all mempool information the node has every m minutes (m =
10 minutes?), including its own.
*   Nodes own mempool information should not be broadcast or used in
calculation until the node has been up long enough for the mempool to
normalise for at least o minutes (o = 300 minutes ?)
*   Alternatively, if loading nodes own full mempool from disk on node
restart (o = 30 minutes ?)
*   Only new or updated mempool values should be transmitted to the
same node. Updated includes updated with no change.
*   All known mempool information must survive node restart.
*   If the nodes own mempool is not normalised and network information
is not available to calculate an average just display zero.
*   Internally, the average transaction pool size must return the
calculated average if an average is available or, if none is available
just the number of valid transactions in the node's own mempool
regardless if it is normalised.

Bitcoin Core must use all collated information on mempool size to
calculate a figure for the average mempool size.

The calculated figure should be displayed in the appropriate place in
the Debug window alongside the text Network average transactions.

Consideration must be given before development of the network bandwidth
this would require. All programming must be consistent with the current
operation and conventions of Bitcoin Core. Methods must work on all
platforms.

As this new service does not affect any existing service or feature of
Bitcoin or Bitcoin Core, this can technically be programmed now and
included in Bitcoin Core at any time.

### 5. Solution operation

This is a simplistic view of the operation. The actual operation will
need to be determined accurately in a spec for the programmer.

1.  Determine the target block size for the current block.
2.  Assign a transaction priority to each valid transaction in the
mempool.
3.  Select transactions to include in the current block using
probability in transaction priority order until the target block size
is met. If target block size is not met, include dust and zero-fee
transactions to pad.
4.  Solve block.
5.  Broadcast the current block when it is solved.
6.  Block is received.
7.  Block verification process.
8.  Accept/reject block based on verification result.
9.  Repeat.

### 6. Closing comments

It may be possible to verify blocks conform to the proposal by showing
that the probability for all transactions included in the block
statistically conforms to a probability distribution curve, *if* the
individual transaction priority can be recreated. I am not that deep
into the mathematics; however, it may also be possible to use a similar
method to do this just based on the fee, that statistically, the block
conforms to a fee distribution. Any dust and zero-fee transactions
would have to be ignored. This solution needs a competent mathematician
with experience in probability and statistical distribution.

It is trivial to this proposal to offer that a node provides the next
block size with a block when it is solved. I am not sure that this
creates any actual benefit since the provided next block size is only
one node's view, as it is the node may seemingly just as well use its
own view and create the block. Providing a next block size only adds
additional complexity to the required operation, however, perhaps
providing the next block size is not trivial in what is accomplished
and the feature can be included in the operation.

Instead of the pre-rollout network service providing data as to valid
transactions in mempool, it could directly provide data as to the
suggested next block size if that is preferred, using a similar
operation as is suggested now and averaging all received suggested next
block sizes.

It may be foreseeable in the future for Bitcoin to operate with a
network of dedicated full blockchain & mempool servers. This would not
be without challenges to overcome but would offer several benefits,
including to the operation of this proposal, and especially as the RAM
and storage requirements of a full node grows. It is easy to foresee
that in just another seven years of operation a Bitcoin Full Node will
require at least 300GB of storage and, if the mempool only doubles in
size, over 1GB of RAM.

There has been some concern expressed over spam and very low fee
transactions, and an infinite block size resulting. I hope that for
those concerned using the dust level addresses the issue, especially as
the value of Bitcoin grows.

Notwithstanding this proposal, all blocks including those with dynamic
size each have limited transaction space per block. This proposal
results in a fee for priority service auction, where the probability of
a transaction to be included in limited space in the next available
block is auctioned to the highest bidders and all other transactions
must wait until they reach priority by ageing to gain significant
probability. Under this proposal the mempool can grow quite large while
the confirmation service continues in a stable and reliable manner.
Several incentives for attackers are removed, where there is no longer
multiple potential incentives for unnecessarily filling blocks or
flooding the mempool with transactions, whether such transactions are
fraudulent, valid or, otherwise. Adoption of this proposal and
adherence results in a reliable, stable fee paying transaction
confirmation service and a beneficial auction.

This proposal is necessary. I implore, at the very least, that we use
some method that validates full transaction reliability and enables
scalability of Bitcoin. If not this proposal, an alternative.

I have done as much with this proposal as I feel that I am able so far
but continue to take your feedback.

Regards,
Damian Williamson

[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/
88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)
<span xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text" property="dct:title"
rel="dct:type">BIP Proposal: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks</span> by [Damian Williamson
&lt;willtech at live.com.au&gt;](http://thekingjameshrmh.tumblr.com/post/1
68948530950/bip-proposal-utpfotib-use-transaction-priority-for-order)
is licensed under a [Creative Commons Attribution-ShareAlike 4.0
International License](http://creativecommons.org/licenses/by-sa/4.0/).
Based on a work at https://lists.linuxfoundation.org/pipermail/bitcoin-
dev/2017-
December/015371.html](https://lists.linuxfoundation.org/pipermail/bitco
in-dev/2017-December/015371.html).
Permissions beyond the scope of this license may be available at [https
://opensource.org/licenses/BSD-3-
Clause](https://opensource.org/licenses/BSD-3-Clause).


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180120/4ce97afd/attachment-0001.html>

From nullius at nym.zone  Sat Jan 20 06:30:37 2018
From: nullius at nym.zone (nullius)
Date: Sat, 20 Jan 2018 06:30:37 +0000
Subject: [bitcoin-dev] Upgrading PoW algorithm
In-Reply-To: <374ee97c-dae9-786f-5fc6-6fb6920360cb@gmail.com>
References: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
	<374ee97c-dae9-786f-5fc6-6fb6920360cb@gmail.com>
Message-ID: <9bb96f6f0d4a9956def943ee3111d51b@nym.zone>

On 2018-01-17 at 22:31:52 +0000, Jefferson Carpenter 
<jeffersoncarpenter2 at gmail.com> wrote:
>Bitcoin's difficulty will be maxed out within about 400 years, by 
>Moore's law.

On 2018-01-19 at 20:54:52 +0000, Jefferson Carpenter 
<jeffersoncarpenter2 at gmail.com> wrote:
>In other words, max difficulty for SHA256 might be significantly faster 
>than forcing the first 256 bits of a SHA512 hash...

?Moore?s law? is not a law of nature.  Indeed, chipmakers began bumping 
up against the limitations of *actual* natural laws about 15?20 years 
ago.  That is why instead of increasing core clock, they play the tricks 
which opened the way for Meltdown and Spectre.  Feature size, and thus 
transistor counts, will soon enough run into physical limitations, too.

But the scenario you describe does not even require such a discussion.

2^256 work for brute force is on the order of 10^77 hashes.  For the 
number of atoms in the observable universe, I?ve seen estimates ranging 
from 10^78 to 10^82.  Thus, you are suggesting that within 400 years, 
computers will be able to compute one hash for every myriad of atoms in 
the observable universe?perhaps one hash for every *ten* atoms.  
Moreover, you suggest that twenty-fourth century computers will do this 
fast enough to meet Bitcoin?s ten-minute target rate.

Such a proposition bypasses science, leaps over science fiction, and 
lands in the realm of religion.  Perhaps a deity could do this?using a 
computer made of other than matter, powered by other than energy.  
Humans will *never* be capable of such a feat:  Not now, and not in a 
billion years.  Certainly not a mere four centuries hence!

(I do not here positively exclude the possibility, however slim, that 
mathematical breakthroughs may yield a preimage attack on SHA-256 which 
is significantly better than bruteforce.  I *do* positively declare it 
impossible that Earth-beings will ever be capable of performing 2^256 
work.  Or even 2^128 work, for that matter.)

-- 
nullius at nym.zone | PGP ECC: 0xC2E91CD74A4C57A105F6C21B5A00591B2F307E0C
Bitcoin: bc1qcash96s5jqppzsp8hy8swkggf7f6agex98an7h | (Segwit nested:
3NULL3ZCUXr7RDLxXeLPDMZDZYxuaYkCnG)  (PGP RSA: 0x36EBB4AB699A10EE)
??If you?re not doing anything wrong, you have nothing to hide.?
No!  Because I do nothing wrong, I have nothing to show.? ? nullius
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 228 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180120/a113bafd/attachment.sig>

From thealanevans at gmail.com  Sat Jan 20 14:46:41 2018
From: thealanevans at gmail.com (Alan Evans)
Date: Sat, 20 Jan 2018 10:46:41 -0400
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction
 Priority For Ordering Transactions In Blocks
In-Reply-To: <PS2P216MB0179B7D7EDAE4704836A91F09DEE0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
References: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<PS2P216MB0179F13FF364666D92E6B2F89D1F0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<PS2P216MB0179436AF3183A14D79869D39DEF0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<PS2P216MB0179B7D7EDAE4704836A91F09DEE0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
Message-ID: <CALPhJaw_kMp=M5ACi4DPVAXjR0ra9988ccMNPg3Zh9=f9EDBxA@mail.gmail.com>

I don't see any modifications to the proposal that addresses the issue that
miners will always be free to choose their own priority that a few people
brought up before.

I understand you think it's in the miners best long-term interest to follow
these rules, but even if a miner agrees with you, if that miner thinks the
other miners are following the fee curve, they will know it makes no
overall difference if they cheat (you can't prove how long a miner has had
a transaction in their mempool).

The opportunity to cheat, the anonymity of mining, the low negative effect
of a single cheating instance, all combined with a financial incentive to
cheat means that cheating will be rife.


On Sat, Jan 20, 2018 at 8:04 AM, Damian Williamson via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Tried a different approach for the curves, would appreciate it if someone
> has the energy to work on this and help me to resolve it a bit more
> scientifically:
>
>
> p(tx) = (((((fx - (fl - 0.00000001)) / (fh - (fl - 0.00000001))) * 100) +
> 1) ^ y) + (((((wx - 0.9) / ((86400 * n) - 0.9)) * 100) + 1) ^ y)
>
> p is the calculated priority number for tx the specific valid transaction.
> fx is the fee in BTC/KB for the specific transaction.
> fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
> fh is the highest valid fee in BTC/KB currently in the nodes mempool.
> wx is the current wait in seconds for tx the specific valid transaction.
> n is the number of days maximum wait consensus value.
> y can be 10 or, y can be a further developed to be a formula based on the
> number of required inclusions to vary the steepness of the curve as the
> mempool size varies.
>
> In the next step, the random value must be:
> if random(101^y) < p then transaction is included;
>
> Regards,
> Damian Williamson
>
> ------------------------------
> *From:* Damian Williamson <willtech at live.com.au>
> *Sent:* Saturday, 20 January 2018 10:25:43 AM
> *To:* Bitcoin Protocol Discussion
> *Subject:* Re: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use
> Transaction Priority For Ordering Transactions In Blocks
>
>
> An example curve:
>
> The curve curently described here is ineffective at acheiving the
> requirements. It seems to be not nearly steep enough resulting in too many
> inclusions (as it happens, this may not metter - needs further evaluation)
> and, the lower end values seem problematically small but, results in a
> number between 100 for the highest fee BTC/KB and a small fraction of 1 for
> the lowest. This math needs to be improved.
>
>
> pf(tx) = sin2((fx-(fl-0.00000001))/(fh-(fl-0.00000001))*1.
> 570796326795)*100
>
>
> pf is the calculated priority number for the fee for tx the specifc valid
> transaction.
> fx is the fee in BTC/KB for the specific transaction.
> fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
> fh is the highest valid fee in BTC/KB currently in the nodes mempool.
>
> ------------------------------
> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org <
> bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian
> Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> *Sent:* Thursday, 4 January 2018 8:01:10 PM
> *To:* Bitcoin Protocol Discussion
> *Subject:* [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use
> Transaction Priority For Ordering Transactions In Blocks
>
>
> This proposal has a new update, mostly minor edits. Additionally, I had a
> logic flaw in the hard fork / soft fork declaration statement. The specific
> terms of the CC-BY-SA-4.0 licence the document is published under have
> now been updated to include additional permissions available under the MIT
> licence.
>
>
> Recently, on Twitter:
>
> I am looking for a capable analyst/programmer to work on a BIP proposal as
> co-author. Will need to format several Full BIP's per these BIP process
> requirements: ( https://github.com/bitcoin/bips/blob/master/bip-0002.
> mediawiki ) from a BIP Proposal, being two initially for non-consensus
> full-interoperable pre-rollout on peer service layer & API/RPC layer and, a
> reference implementation for Bitcoin Core per: (
> https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md ).
> Interested parties please reply via this list thread: (
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/
> 2017-December/015485.html ) #Bitcoin #BIP
>
>
> Regards,
>
> Damian Williamson
>
>
> ------------------------------
> *From:* bitcoin-dev-bounces at lists.linuxfoundation.org <
> bitcoin-dev-bounces at lists.linuxfoundation.org> on behalf of Damian
> Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org>
> *Sent:* Monday, 1 January 2018 10:04 PM
> *To:* bitcoin-dev at lists.linuxfoundation.org
> *Subject:* [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use
> Transaction Priority For Ordering Transactions In Blocks
>
> Happy New Year all.
>
> This proposal has been further amended with several minor changes and a
> few additions.
>
> I believe that all known issues raised so far have been sufficiently
> addressed. Either that or, I still have more work to do.
>
> ## BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For
> Ordering Transactions In Blocks
>
> Schema:
> ##########
> Document: BIP Proposal
> Title: UTPFOTIB - Use Transaction Priority For Ordering Transactions In
> Blocks
> Published: 26-12-2017
> Revised: 01-01-2018
> Author: Damian Williamson <willtech at live.com.au>
> Licence: Creative Commons Attribution-ShareAlike 4.0 International
> License.
> URL: http://thekingjameshrmh.tumblr.com/post/168948530950/bip-proposal-
> utpfotib-use-transaction-priority-for-order
> ##########
>
> ### 1. Abstract
>
> This document proposes to address the issue of transactional
> reliability in Bitcoin, where valid transactions may be stuck in the
> transaction pool for extended periods or never confirm.
>
> There are two key issues to be resolved to achieve this:
>
> 1.  The current transaction bandwidth limit.
> 2.  The current ad-hoc methods of including transactions in blocks
> resulting in variable and confusing confirmation times for valid
> transactions, including transactions with a valid fee that may never
> confirm.
>
> It is important with any change to protect the value of fees as these
> will eventually be the only payment that miners receive. Rather than an
> auction model for limited bandwidth, the proposal results in a fee for
> priority service auction model.
>
> It would not be true to suggest that all feedback received so far has
> been entirely positive although, most of it has been constructive.
>
> The previous threads for this proposal are available here:
> https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/s
> ubject.html
>
> In all parts of this proposal, references to a transaction, a valid
> transaction, a transaction with a valid fee, a valid fee, etc. is
> defined as any transaction that is otherwise valid with a fee of at
> least 0.00001000 BTC/KB as defined as the dust level, interpreting from
> Bitcoin Core GUI. Transactions with a fee lower than this rate are
> considered dust.
>
> In all parts of this proposal, dust and zero-fee transactions are
> always ignored and/or excluded unless specifically mentioned.
>
> It is generally assumed that miners currently prefer to include
> transactions with higher fees.
>
> ### 2. The need for this proposal
>
> We all must learn to admit that transaction bandwidth is still lurking
> as a serious issue for the operation, reliability, safety, consumer
> acceptance, uptake and, for the value of Bitcoin.
>
> I recently sent a payment which was not urgent so; I chose three-day
> target confirmation from the fee recommendation. That transaction has
> still not confirmed after now more than six days - even waiting twice
> as long seems quite reasonable to me (note for accuracy: it did
> eventually confirm). That transaction is a valid transaction; it is not
> rubbish, junk or, spam. Under the current model with transaction
> bandwidth limitation, the longer a transaction waits, the less likely
> it is ever to confirm due to rising transaction numbers and being
> pushed back by transactions with rising fees.
>
> I argue that no transactions with fees above the dust level are rubbish
> or junk, only some zero fee transactions might be spam. Having an ever-
> increasing number of valid transactions that do not confirm as more new
> transactions with higher fees are created is the opposite of operating
> a robust, reliable transaction system.
>
> While the miners have discovered a gold mine, it is the service they
> provide that is valuable. If the service is unreliable they are not
> worth the gold that they mine. This is reflected in the value of
> Bitcoin.
>
> Business cannot operate with a model where transactions may or may not
> confirm. Even a business choosing a modest fee has no guarantee that
> their valid transaction will not be shuffled down by new transactions
> to the realm of never confirming after it is created. Consumers also
> will not accept this model as Bitcoin expands. If Bitcoin cannot be a
> reliable payment system for confirmed transactions then consumers, by
> and large, will simply not accept the model once they understand.
> Bitcoin will be a dirty payment system, and this will kill the value of
> Bitcoin.
>
> Under the current system, a minority of transactions will eventually be
> the lucky few who have fees high enough to escape being pushed down the
> list.
>
> Once there are more than x transactions (transaction bandwidth limit)
> every ten minutes, only those choosing twenty-minute confirmation (2
> blocks) from the fee recommendations will have initially at most a
> fifty percent chance of ever having their payment confirm by the time
> 2x transactions is reached. Presently, not even using fee
> recommendations can ensure a sufficiently high fee is paid to ensure
> transaction confirmation.
>
> I also argue that the current auction model for limited transaction
> bandwidth is wrong, is not suitable for a reliable transaction system
> and, is wrong for Bitcoin. All transactions with valid fees must
> confirm in due time. Currently, Bitcoin is not a safe way to send
> payments.
>
> I do not believe that consumers and business are against paying fees,
> even high fees. What is required is operational reliability.
>
> This great issue needs to be resolved for the safety and reliability of
> Bitcoin. The time to resolve issues in commerce is before they become
> great big issues. The time to resolve this issue is now. We must have
> the foresight to identify and resolve problems before they trip us
> over.  Simply doubling block sizes every so often is reactionary and is
> not a reliable permanent solution.
>
> I have written this proposal for a technical solution but, need your
> help to write it up to an acceptable standard to be a full BIP.
>
> ### 3. The problem
>
> Everybody wants value. Miners want to maximise revenue from fees (and
> we presume, to minimise block size). Consumers need transaction
> reliability and, (we presume) want low fees.
>
> The current transaction bandwidth limit is a limiting factor for both.
> As the operational safety of transactions is limited, so is consumer
> confidence as they realise the issue and, accordingly, uptake is
> limited. Fees are artificially inflated due to bandwidth limitations
> while failing to provide a full confirmation service for all valid
> transactions.
>
> Current fee recommendations provide no satisfaction for transaction
> reliability and, as Bitcoin scales, this will worsen.
>
> Transactions are included in blocks by miners using whatever basis they
> prefer. We expect that this is usually a fee-based priority. However,
> even transactions with a valid fee may be left in the transaction pool
> for some time. As transaction bandwidth becomes an issue, not even
> extreme fees can ensure a transaction is processed in a timely manner
> or at all.
>
> Bitcoin must be a fully scalable and reliable service, providing full
> transaction confirmation for every valid transaction.
>
> The possibility to send a transaction with a fee lower than one that is
> acceptable to allow eventual transaction confirmation should be removed
> from the protocol and also from the user interface.
>
> Bitcoin should be capable of reliably and inexpensively processing
> casual transactions, and also priority processing of fee paying at
> auction for priority transactions in the shortest possible timeframe.
>
> ### 4. Solution summary
>
> #### Main solution
>
> Provide each valid transaction in the mempool with an individual
> transaction priority each time before choosing transactions to include
> in the current block. The priority being a function of the fee (on a
> curve), and the time waiting in the transaction pool (also on a curve)
> out to n days (n = 60 days ?), and extending past n days. The value for
> fee on a curve may need an upper limit. The transaction priority to
> serve as the likelihood of a transaction being included in the current
> block, and for determining the order in which transactions are tried to
> see if they will be included.
>
> Nodes will need to keep track of when a transaction is first seen. It
> is satisfactory for each node to do this independently provided the
> full mempool and information survives node restart. If there is a more
> reliable way to determine when a transaction was first seen on the
> network then it should be utilised.
>
> > My current default installation of Bitcoin Core v0.15.1 does not
> currently seem to save and load the mempool on restart, despite the
> notes in the command line options panel that the default for
> persistmempool is 1. In the debug panel, some 90,000 transactions
> before restart, some 200 odd shortly after. Manually setting
> persistmempool=1 in the conf file does not seem to make any difference.
> Perhaps it is operating as expected and I am not sure what to observe,
> but does not seem to be observably saving and loading the mempool on
> restart. This will need to be resolved.
>
> Use a dynamic target block size to make the current block. This marks a
> shift from using block size or weight to a count of transactions.
> Determine the target block size using; pre-rollout(current average
> valid transaction pool size) x ( 1 / (144 x n days ) ) = number of
> transactions to be included in the current block. The block created
> should be a minimum 1MB in size regardless if the target block size is
> lower.
>
> If the created block size consistently contains too few transactions
> and the number of new transactions created is continuously greater than
> the block size will accommodate then I expect eventually ageing
> transactions will be over-represented as a portion of the block
> contents. Once another new node conforming to the proposal makes a
> block, the block size will be proportionately larger as the transaction
> pool has grown.  If block size is too large on average then this will
> shrink the transaction pool.
>
> Miners will likely want to conform to the proposal, since making blocks
> larger than necessary makes more room in each block potentially
> lowering the highest fees paid for priority service. Always making
> blocks smaller than the proposal requires will in time lower the
> utility value of Bitcoin, a different situation but akin to the
> current. Transactions will still always confirm but with longer and
> longer wait periods. The auction at the front of the queue for priority
> will be destroyed as there will be eventually no room in blocks besides
> ageing transations and, there will be little value paying higher than
> the minimum fee. Obviously, neither of these scenarios are in a miner's
> interests.
>
> Without a consensus as to what size dynamic block to create,
> enforcement of dynamic block size is not currently possible. It may be
> possible for a consensus to be formed in the future but here I cannot
> speculate. I can only suggest that it is in the interest of Bitcoin as
> a whole and, in the interest of each node to conform to the proposal.
> Some nodes failing to conform to the proposed requirements of dynamic
> size or transaction priority in this proposal will not be destructive
> to the operation of the proposal.
>
> If necessary, nodes that have not yet adopted the proposal will just
> continue to create standard fixed size unordered blocks, although, if
> the current mechanisms of block validation include the fixed block size
> then it is unlikely that these nodes will be able to validate the
> blockchain going forward. In this case a hard fork and a full transfer
> to the new method should be required. If dynamic blocks with ordered
> transactions will be valid to existing nodes then only a soft fork is
> required. There is no proposed change to the internal construction of
> blocks, only to the block size and using an ordered method of
> transaction selection.
>
> > The default value for mempoolexpiry in Bitcoin Core may in future
> need to be adjusted to match something more than n days or, perhaps
> using less than n = 14 days may be a more sensible approach?
>
> All block created with dynamic size should be verified to ensure
> conformity to a probability distribution curve resulting from the
> priority method. Since the input is a probability, the output should
> conform to a probability distribution.
>
> The curves used for the priority of transactions would have to be
> appropriate. Perhaps a mathematician with experience in probability can
> develop the right formulae. My thinking is a steep curve. I suppose
> that the probability of all transactions should probably account for a
> sufficient number of inclusions that the target block size is met on
> average although, it may not always be. As a suggestion, consider
> including some dust or zero-fee transactions to pad if each valid
> transaction is tried and the target block size is not yet met, highest
> BTC transaction value first?
>
> **Explanation of the operation of priority:**
>
> > If transaction priority is, for example, a number between one (low)
> and one-hundred (high) it can be directly understood as the percentage
> chance in one-hundred of a transaction being included in the block.
> Using probability or likelihood infers that there is some function of
> random. Try the transactions in priority order from highest to lowest,
> if random (100) < transaction priority then the transaction is included
> until the target block size is met.
>
> > To break it down further, if both the fee on a curve value and the
> time waiting on a curve value are each a number between one and one-
> hundred, a rudimentary method may be to simply multiply those two
> numbers, to find the priority number. For example, a middle fee
> transaction waiting thirty days (if n = 60 days) may have a value of
> five for each part  (yes, just five, the values are on a curve). When
> multiplied that will give a priority value of twenty-five, or, a
> twenty-five percent chance at that moment of being included in the
> block; it will likely be included in one of the next four blocks,
> getting more likely each chance. If it is still not included then the
> value of time waiting will be higher, making for more probability. A
> very low fee transaction would have a value for the fee of one. It
> would not be until near sixty-days that the particular low fee
> transaction has a high likelihood of being included in the block.
>
> In practice it may be more useful to use numbers representative of one-
> hundred for the highest fee priority curve down to a small fraction of
> one for the lowest fee and, from one for a newly seen transaction up to
> a proportionately high number above one-hundred for the time waiting
> curve. It is truely beyond my level of math to resolve probability
> curves accurately without much trial and error.
>
> The primary reason for addressing the issue is to ensure transactional
> reliability and scalability while having each valid transaction confirm
> in due time.
>
> #### Pros
>
> *   Maximizes transaction reliability.
> *   Overcomes transaction bandwidth limit.
> *   Fully scalable.
> *   Maximizes possibility for consumer and business uptake.
> *   Maximizes total fees paid per block without reducing reliability;
> because of reliability, in time confidence and overall uptake are
> greater; therefore, more transactions.
> *   Market determines fee paid for transaction priority.
> *   Fee recommendations work all the way out to 30 days or greater.
> *   Provides additional block entropy; greater security since there is
> less probability of predicting the next block. _Although this is not
> necessary it is a product of the operation of this proposal._
>
> #### Cons
>
> *   Could initially lower total transaction fees per block.
> *   Must be first be programmed.
>
> #### Pre-rollout
>
> Nodes need to have at a minimum a loose understanding of the average
> (since there is no consensus) size of the transaction pool as a
> requirement to enable future changes to the way blocks are constructed.
>
> A new network service should be constructed to meet this need. This
> service makes no changes to any existing operation or function of the
> node. Initially, Bitcoin Core is a suitable candidate.
>
> For all operations we count only valid transactions.
>
> **The service must:**
>
> *   Have an individual temporary (runtime permanent only) Serial Node
> ID.
> *   Accept communication of the number of valid transactions in the
> mempool of another valid Bitcoin node along with the Serial Node ID of
> the node whose value is provided.
> *   Disconnect the service from any non-Bitcoin node. Bitcoin Core may
> handle this already?
> *   Expire any value not updated for k minutes (k = 30 minutes?).
> *   Broadcast all mempool information the node has every m minutes (m =
> 10 minutes?), including its own.
> *   Nodes own mempool information should not be broadcast or used in
> calculation until the node has been up long enough for the mempool to
> normalise for at least o minutes (o = 300 minutes ?)
> *   Alternatively, if loading nodes own full mempool from disk on node
> restart (o = 30 minutes ?)
> *   Only new or updated mempool values should be transmitted to the
> same node. Updated includes updated with no change.
> *   All known mempool information must survive node restart.
> *   If the nodes own mempool is not normalised and network information
> is not available to calculate an average just display zero.
> *   Internally, the average transaction pool size must return the
> calculated average if an average is available or, if none is available
> just the number of valid transactions in the node's own mempool
> regardless if it is normalised.
>
> Bitcoin Core must use all collated information on mempool size to
> calculate a figure for the average mempool size.
>
> The calculated figure should be displayed in the appropriate place in
> the Debug window alongside the text Network average transactions.
>
> Consideration must be given before development of the network bandwidth
> this would require. All programming must be consistent with the current
> operation and conventions of Bitcoin Core. Methods must work on all
> platforms.
>
> As this new service does not affect any existing service or feature of
> Bitcoin or Bitcoin Core, this can technically be programmed now and
> included in Bitcoin Core at any time.
>
> ### 5. Solution operation
>
> This is a simplistic view of the operation. The actual operation will
> need to be determined accurately in a spec for the programmer.
>
> 1.  Determine the target block size for the current block.
> 2.  Assign a transaction priority to each valid transaction in the
> mempool.
> 3.  Select transactions to include in the current block using
> probability in transaction priority order until the target block size
> is met. If target block size is not met, include dust and zero-fee
> transactions to pad.
> 4.  Solve block.
> 5.  Broadcast the current block when it is solved.
> 6.  Block is received.
> 7.  Block verification process.
> 8.  Accept/reject block based on verification result.
> 9.  Repeat.
>
> ### 6. Closing comments
>
> It may be possible to verify blocks conform to the proposal by showing
> that the probability for all transactions included in the block
> statistically conforms to a probability distribution curve, *if* the
> individual transaction priority can be recreated. I am not that deep
> into the mathematics; however, it may also be possible to use a similar
> method to do this just based on the fee, that statistically, the block
> conforms to a fee distribution. Any dust and zero-fee transactions
> would have to be ignored. This solution needs a competent mathematician
> with experience in probability and statistical distribution.
>
> It is trivial to this proposal to offer that a node provides the next
> block size with a block when it is solved. I am not sure that this
> creates any actual benefit since the provided next block size is only
> one node's view, as it is the node may seemingly just as well use its
> own view and create the block. Providing a next block size only adds
> additional complexity to the required operation, however, perhaps
> providing the next block size is not trivial in what is accomplished
> and the feature can be included in the operation.
>
> Instead of the pre-rollout network service providing data as to valid
> transactions in mempool, it could directly provide data as to the
> suggested next block size if that is preferred, using a similar
> operation as is suggested now and averaging all received suggested next
> block sizes.
>
> It may be foreseeable in the future for Bitcoin to operate with a
> network of dedicated full blockchain & mempool servers. This would not
> be without challenges to overcome but would offer several benefits,
> including to the operation of this proposal, and especially as the RAM
> and storage requirements of a full node grows. It is easy to foresee
> that in just another seven years of operation a Bitcoin Full Node will
> require at least 300GB of storage and, if the mempool only doubles in
> size, over 1GB of RAM.
>
> There has been some concern expressed over spam and very low fee
> transactions, and an infinite block size resulting. I hope that for
> those concerned using the dust level addresses the issue, especially as
> the value of Bitcoin grows.
>
> Notwithstanding this proposal, all blocks including those with dynamic
> size each have limited transaction space per block. This proposal
> results in a fee for priority service auction, where the probability of
> a transaction to be included in limited space in the next available
> block is auctioned to the highest bidders and all other transactions
> must wait until they reach priority by ageing to gain significant
> probability. Under this proposal the mempool can grow quite large while
> the confirmation service continues in a stable and reliable manner.
> Several incentives for attackers are removed, where there is no longer
> multiple potential incentives for unnecessarily filling blocks or
> flooding the mempool with transactions, whether such transactions are
> fraudulent, valid or, otherwise. Adoption of this proposal and
> adherence results in a reliable, stable fee paying transaction
> confirmation service and a beneficial auction.
>
> This proposal is necessary. I implore, at the very least, that we use
> some method that validates full transaction reliability and enables
> scalability of Bitcoin. If not this proposal, an alternative.
>
> I have done as much with this proposal as I feel that I am able so far
> but continue to take your feedback.
>
> Regards,
> Damian Williamson
>
> [![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/
> 88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)
> <span xmlns:dct="http://purl.org/dc/terms/"
> href="http://purl.org/dc/dcmitype/Text" property="dct:title"
> rel="dct:type">BIP Proposal: UTPFOTIB - Use Transaction Priority For
> Ordering Transactions In Blocks</span> by [Damian Williamson
> &lt;willtech at live.com.au&gt;](http://thekingjameshrmh.tumblr.com/post/1
> 68948530950/bip-proposal-utpfotib-use-transaction-priority-for-order)
> is licensed under a [Creative Commons Attribution-ShareAlike 4.0
> International License](http://creativecommons.org/licenses/by-sa/4.0/).
> Based on a work at https://lists.linuxfoundation.org/pipermail/bitcoin-
> dev/2017-
> December/015371.html](https://lists.linuxfoundation.org/pipermail/bitco
> in-dev/2017-December/015371.html).
> Permissions beyond the scope of this license may be available at [https
> ://opensource.org/licenses/BSD-3-
> Clause](https://opensource.org/licenses/BSD-3-Clause).
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180120/e17640ac/attachment-0001.html>

From melvincarvalho at gmail.com  Sat Jan 20 18:36:09 2018
From: melvincarvalho at gmail.com (Melvin Carvalho)
Date: Sat, 20 Jan 2018 19:36:09 +0100
Subject: [bitcoin-dev] Upgrading PoW algorithm
In-Reply-To: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
References: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
Message-ID: <CAKaEYhJHZ_CFeqRN_QXP-SLX+AHmbRPTx+w=D3920Fc-WPq_1A@mail.gmail.com>

On 17 January 2018 at 23:31, Jefferson Carpenter via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Bitcoin's difficulty will be maxed out within about 400 years, by Moore's
> law.  (After that - supposing the software does not crash when difficulty
> overflows - block time will start decreasing, and it will not take long
> before blocks are mined faster than photons can be sent across the planet).
>
> Bitcoin is the dominant cryptocurrency today, as the first mover: the
> perfectly fair worldwide game of inventing the cryptocurrency has been
> played and won.  However, unfortunately, it has a built-in end date: about
> 400 years from now.  After that, it won't necessarily be clear what the
> dominant cryptocurrency is.  It might be a lot like VHS vs Betamax, and a
> lot of people could lose a lot of money.  It seems to me, this could be
> mitigated by planning today for what we are going to do when Bitcoin
> finally breaks 400 years from now.
>
> Are there any distinct plans today for migrating to a PoW supporting an
> even higher difficulty?
>

Crypto algorithms have a lifetime, and consensus is no different.

Is it likely to be more than a few years?  Yes.

Is likely to be less than a few hundred years.  Yes.

Every algorithm involves trade offs and it's the job of a thoughtful dev
team to examine those trade offs and come to a consensus optimal solution.

This field is only 9 years old, and there is a large amount of R & D in
this area.  So we can evaluate what seems to working better and what seems
to be working worse, transfer that to BIPs, create code, test it, try to
achieve consensus.  The normal path that has served free software projects
well.


> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180120/5007b1f4/attachment.html>

From glen at organicdesign.org  Sun Jan 21 15:29:26 2018
From: glen at organicdesign.org (Glen Peterson)
Date: Sun, 21 Jan 2018 10:29:26 -0500
Subject: [bitcoin-dev] Upgrading PoW algorithm
In-Reply-To: <CAKaEYhJHZ_CFeqRN_QXP-SLX+AHmbRPTx+w=D3920Fc-WPq_1A@mail.gmail.com>
References: <58fa85b8-cba3-ee34-8c96-41c6c7bfbf9c@gmail.com>
	<CAKaEYhJHZ_CFeqRN_QXP-SLX+AHmbRPTx+w=D3920Fc-WPq_1A@mail.gmail.com>
Message-ID: <CA+LnoU=OoUaCwV_HrLdZUx4yHY4M0TDE45tefhF08b8PrO5VBw@mail.gmail.com>

Popular hashing algorithms have historically managed 10-15 years of
intense use before flaws are found in the algorithm.  This chart
suggests SHA-256 is already aging:
http://valerieaurora.org/hash.html
If history is any guide, any long-term cryptocurrency/blockchain will
need the cryptography updated every decade or so.

On Sat, Jan 20, 2018 at 1:36 PM, Melvin Carvalho via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
> On 17 January 2018 at 23:31, Jefferson Carpenter via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>> Bitcoin's difficulty will be maxed out within about 400 years, by Moore's
>> law.  (After that - supposing the software does not crash when difficulty
>> overflows - block time will start decreasing, and it will not take long
>> before blocks are mined faster than photons can be sent across the planet).
>>
>> Bitcoin is the dominant cryptocurrency today, as the first mover: the
>> perfectly fair worldwide game of inventing the cryptocurrency has been
>> played and won.  However, unfortunately, it has a built-in end date: about
>> 400 years from now.  After that, it won't necessarily be clear what the
>> dominant cryptocurrency is.  It might be a lot like VHS vs Betamax, and a
>> lot of people could lose a lot of money.  It seems to me, this could be
>> mitigated by planning today for what we are going to do when Bitcoin finally
>> breaks 400 years from now.
>>
>> Are there any distinct plans today for migrating to a PoW supporting an
>> even higher difficulty?
>
>
> Crypto algorithms have a lifetime, and consensus is no different.
>
> Is it likely to be more than a few years?  Yes.
>
> Is likely to be less than a few hundred years.  Yes.
>
> Every algorithm involves trade offs and it's the job of a thoughtful dev
> team to examine those trade offs and come to a consensus optimal solution.
>
> This field is only 9 years old, and there is a large amount of R & D in this
> area.  So we can evaluate what seems to working better and what seems to be
> working worse, transfer that to BIPs, create code, test it, try to achieve
> consensus.  The normal path that has served free software projects well.
>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>



-- 
Glen K. Peterson
(828) 393-0081

From willtech at live.com.au  Sun Jan 21 05:49:25 2018
From: willtech at live.com.au (Damian Williamson)
Date: Sun, 21 Jan 2018 05:49:25 +0000
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction
 Priority For Ordering Transactions In Blocks
In-Reply-To: <CALPhJaw_kMp=M5ACi4DPVAXjR0ra9988ccMNPg3Zh9=f9EDBxA@mail.gmail.com>
References: <PS2P216MB0179D103B5D93555D166E74F9D180@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<PS2P216MB0179F13FF364666D92E6B2F89D1F0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<PS2P216MB0179436AF3183A14D79869D39DEF0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>
	<PS2P216MB0179B7D7EDAE4704836A91F09DEE0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>,
	<CALPhJaw_kMp=M5ACi4DPVAXjR0ra9988ccMNPg3Zh9=f9EDBxA@mail.gmail.com>
Message-ID: <PS2P216MB0179D1D9BBD720A93A7F2E739DED0@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

Good afternoon Alan,


It is stated in the proposal that it is intended for blocks to be validated as the output of the priority method, to ensure that they conform. Unfortunately, the math necessary for this sort of statistical function is outside the scope of my formal education and I will need to rely on someone to develop what is necessary. If it does turn out that this is not ultimately possible then I suppose at that stage the proposal would need to be abandoned since I agree - validation must be necessary. Blocks created with cheating should be too unlikely.


>All block created with dynamic size should be verified to ensure
conformity to a probability distribution curve resulting from the
priority method. Since the input is a probability, the output should
conform to a probability distribution.


Regards,

Damian Williamson

________________________________
From: Alan Evans <thealanevans at gmail.com>
Sent: Sunday, 21 January 2018 1:46:41 AM
To: Damian Williamson; Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks

I don't see any modifications to the proposal that addresses the issue that miners will always be free to choose their own priority that a few people brought up before.

I understand you think it's in the miners best long-term interest to follow these rules, but even if a miner agrees with you, if that miner thinks the other miners are following the fee curve, they will know it makes no overall difference if they cheat (you can't prove how long a miner has had a transaction in their mempool).

The opportunity to cheat, the anonymity of mining, the low negative effect of a single cheating instance, all combined with a financial incentive to cheat means that cheating will be rife.


On Sat, Jan 20, 2018 at 8:04 AM, Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:

Tried a different approach for the curves, would appreciate it if someone has the energy to work on this and help me to resolve it a bit more scientifically:


p(tx) = (((((fx - (fl - 0.00000001)) / (fh - (fl - 0.00000001))) * 100) + 1) ^ y) + (((((wx - 0.9) / ((86400 * n) - 0.9)) * 100) + 1) ^ y)

p is the calculated priority number for tx the specific valid transaction.
fx is the fee in BTC/KB for the specific transaction.
fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
fh is the highest valid fee in BTC/KB currently in the nodes mempool.
wx is the current wait in seconds for tx the specific valid transaction.
n is the number of days maximum wait consensus value.
y can be 10 or, y can be a further developed to be a formula based on the number of required inclusions to vary the steepness of the curve as the mempool size varies.

In the next step, the random value must be:
if random(101^y) < p then transaction is included;

Regards,
Damian Williamson


________________________________
From: Damian Williamson <willtech at live.com.au<mailto:willtech at live.com.au>>
Sent: Saturday, 20 January 2018 10:25:43 AM
To: Bitcoin Protocol Discussion
Subject: Re: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks


An example curve:

The curve curently described here is ineffective at acheiving the requirements. It seems to be not nearly steep enough resulting in too many inclusions (as it happens, this may not metter - needs further evaluation) and, the lower end values seem problematically small but, results in a number between 100 for the highest fee BTC/KB and a small fraction of 1 for the lowest. This math needs to be improved.


pf(tx) = sin2((fx-(fl-0.00000001))/(fh-(fl-0.00000001))*1.570796326795)*100


pf is the calculated priority number for the fee for tx the specifc valid transaction.
fx is the fee in BTC/KB for the specific transaction.
fl is the lowest valid fee in BTC/KB currently in the nodes mempool.
fh is the highest valid fee in BTC/KB currently in the nodes mempool.

________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org<mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> <bitcoin-dev-bounces at lists.linuxfoundation.org<mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Sent: Thursday, 4 January 2018 8:01:10 PM
To: Bitcoin Protocol Discussion
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks


This proposal has a new update, mostly minor edits. Additionally, I had a logic flaw in the hard fork / soft fork declaration statement. The specific terms of the CC-BY-SA-4.0 licence the document is published under have now been updated to include additional permissions available under the MIT licence.


Recently, on Twitter:

I am looking for a capable analyst/programmer to work on a BIP proposal as co-author. Will need to format several Full BIP's per these BIP process requirements: ( https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki ) from a BIP Proposal, being two initially for non-consensus full-interoperable pre-rollout on peer service layer & API/RPC layer and, a reference implementation for Bitcoin Core per: ( https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md ). Interested parties please reply via this list thread: ( https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/015485.html ) #Bitcoin #BIP


Regards,

Damian Williamson


________________________________
From: bitcoin-dev-bounces at lists.linuxfoundation.org<mailto:bitcoin-dev-bounces at lists.linuxfoundation.org> <bitcoin-dev-bounces at lists.linuxfoundation.org<mailto:bitcoin-dev-bounces at lists.linuxfoundation.org>> on behalf of Damian Williamson via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>>
Sent: Monday, 1 January 2018 10:04 PM
To: bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
Subject: [bitcoin-dev] BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For Ordering Transactions In Blocks

Happy New Year all.

This proposal has been further amended with several minor changes and a
few additions.

I believe that all known issues raised so far have been sufficiently
addressed. Either that or, I still have more work to do.

## BIP Proposal: Revised: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks

Schema:
##########
Document: BIP Proposal
Title: UTPFOTIB - Use Transaction Priority For Ordering Transactions In
Blocks
Published: 26-12-2017
Revised: 01-01-2018
Author: Damian Williamson <willtech at live.com.au<mailto:willtech at live.com.au>>
Licence: Creative Commons Attribution-ShareAlike 4.0 International
License.
URL: http://thekingjameshrmh.tumblr.com/post/168948530950/bip-proposal-
utpfotib-use-transaction-priority-for-order
##########

### 1. Abstract

This document proposes to address the issue of transactional
reliability in Bitcoin, where valid transactions may be stuck in the
transaction pool for extended periods or never confirm.

There are two key issues to be resolved to achieve this:

1.  The current transaction bandwidth limit.
2.  The current ad-hoc methods of including transactions in blocks
resulting in variable and confusing confirmation times for valid
transactions, including transactions with a valid fee that may never
confirm.

It is important with any change to protect the value of fees as these
will eventually be the only payment that miners receive. Rather than an
auction model for limited bandwidth, the proposal results in a fee for
priority service auction model.

It would not be true to suggest that all feedback received so far has
been entirely positive although, most of it has been constructive.

The previous threads for this proposal are available here:
https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-December/s
ubject.html

In all parts of this proposal, references to a transaction, a valid
transaction, a transaction with a valid fee, a valid fee, etc. is
defined as any transaction that is otherwise valid with a fee of at
least 0.00001000 BTC/KB as defined as the dust level, interpreting from
Bitcoin Core GUI. Transactions with a fee lower than this rate are
considered dust.

In all parts of this proposal, dust and zero-fee transactions are
always ignored and/or excluded unless specifically mentioned.

It is generally assumed that miners currently prefer to include
transactions with higher fees.

### 2. The need for this proposal

We all must learn to admit that transaction bandwidth is still lurking
as a serious issue for the operation, reliability, safety, consumer
acceptance, uptake and, for the value of Bitcoin.

I recently sent a payment which was not urgent so; I chose three-day
target confirmation from the fee recommendation. That transaction has
still not confirmed after now more than six days - even waiting twice
as long seems quite reasonable to me (note for accuracy: it did
eventually confirm). That transaction is a valid transaction; it is not
rubbish, junk or, spam. Under the current model with transaction
bandwidth limitation, the longer a transaction waits, the less likely
it is ever to confirm due to rising transaction numbers and being
pushed back by transactions with rising fees.

I argue that no transactions with fees above the dust level are rubbish
or junk, only some zero fee transactions might be spam. Having an ever-
increasing number of valid transactions that do not confirm as more new
transactions with higher fees are created is the opposite of operating
a robust, reliable transaction system.

While the miners have discovered a gold mine, it is the service they
provide that is valuable. If the service is unreliable they are not
worth the gold that they mine. This is reflected in the value of
Bitcoin.

Business cannot operate with a model where transactions may or may not
confirm. Even a business choosing a modest fee has no guarantee that
their valid transaction will not be shuffled down by new transactions
to the realm of never confirming after it is created. Consumers also
will not accept this model as Bitcoin expands. If Bitcoin cannot be a
reliable payment system for confirmed transactions then consumers, by
and large, will simply not accept the model once they understand.
Bitcoin will be a dirty payment system, and this will kill the value of
Bitcoin.

Under the current system, a minority of transactions will eventually be
the lucky few who have fees high enough to escape being pushed down the
list.

Once there are more than x transactions (transaction bandwidth limit)
every ten minutes, only those choosing twenty-minute confirmation (2
blocks) from the fee recommendations will have initially at most a
fifty percent chance of ever having their payment confirm by the time
2x transactions is reached. Presently, not even using fee
recommendations can ensure a sufficiently high fee is paid to ensure
transaction confirmation.

I also argue that the current auction model for limited transaction
bandwidth is wrong, is not suitable for a reliable transaction system
and, is wrong for Bitcoin. All transactions with valid fees must
confirm in due time. Currently, Bitcoin is not a safe way to send
payments.

I do not believe that consumers and business are against paying fees,
even high fees. What is required is operational reliability.

This great issue needs to be resolved for the safety and reliability of
Bitcoin. The time to resolve issues in commerce is before they become
great big issues. The time to resolve this issue is now. We must have
the foresight to identify and resolve problems before they trip us
over.  Simply doubling block sizes every so often is reactionary and is
not a reliable permanent solution.

I have written this proposal for a technical solution but, need your
help to write it up to an acceptable standard to be a full BIP.

### 3. The problem

Everybody wants value. Miners want to maximise revenue from fees (and
we presume, to minimise block size). Consumers need transaction
reliability and, (we presume) want low fees.

The current transaction bandwidth limit is a limiting factor for both.
As the operational safety of transactions is limited, so is consumer
confidence as they realise the issue and, accordingly, uptake is
limited. Fees are artificially inflated due to bandwidth limitations
while failing to provide a full confirmation service for all valid
transactions.

Current fee recommendations provide no satisfaction for transaction
reliability and, as Bitcoin scales, this will worsen.

Transactions are included in blocks by miners using whatever basis they
prefer. We expect that this is usually a fee-based priority. However,
even transactions with a valid fee may be left in the transaction pool
for some time. As transaction bandwidth becomes an issue, not even
extreme fees can ensure a transaction is processed in a timely manner
or at all.

Bitcoin must be a fully scalable and reliable service, providing full
transaction confirmation for every valid transaction.

The possibility to send a transaction with a fee lower than one that is
acceptable to allow eventual transaction confirmation should be removed
from the protocol and also from the user interface.

Bitcoin should be capable of reliably and inexpensively processing
casual transactions, and also priority processing of fee paying at
auction for priority transactions in the shortest possible timeframe.

### 4. Solution summary

#### Main solution

Provide each valid transaction in the mempool with an individual
transaction priority each time before choosing transactions to include
in the current block. The priority being a function of the fee (on a
curve), and the time waiting in the transaction pool (also on a curve)
out to n days (n = 60 days ?), and extending past n days. The value for
fee on a curve may need an upper limit. The transaction priority to
serve as the likelihood of a transaction being included in the current
block, and for determining the order in which transactions are tried to
see if they will be included.

Nodes will need to keep track of when a transaction is first seen. It
is satisfactory for each node to do this independently provided the
full mempool and information survives node restart. If there is a more
reliable way to determine when a transaction was first seen on the
network then it should be utilised.

> My current default installation of Bitcoin Core v0.15.1 does not
currently seem to save and load the mempool on restart, despite the
notes in the command line options panel that the default for
persistmempool is 1. In the debug panel, some 90,000 transactions
before restart, some 200 odd shortly after. Manually setting
persistmempool=1 in the conf file does not seem to make any difference.
Perhaps it is operating as expected and I am not sure what to observe,
but does not seem to be observably saving and loading the mempool on
restart. This will need to be resolved.

Use a dynamic target block size to make the current block. This marks a
shift from using block size or weight to a count of transactions.
Determine the target block size using; pre-rollout(current average
valid transaction pool size) x ( 1 / (144 x n days ) ) = number of
transactions to be included in the current block. The block created
should be a minimum 1MB in size regardless if the target block size is
lower.

If the created block size consistently contains too few transactions
and the number of new transactions created is continuously greater than
the block size will accommodate then I expect eventually ageing
transactions will be over-represented as a portion of the block
contents. Once another new node conforming to the proposal makes a
block, the block size will be proportionately larger as the transaction
pool has grown.  If block size is too large on average then this will
shrink the transaction pool.

Miners will likely want to conform to the proposal, since making blocks
larger than necessary makes more room in each block potentially
lowering the highest fees paid for priority service. Always making
blocks smaller than the proposal requires will in time lower the
utility value of Bitcoin, a different situation but akin to the
current. Transactions will still always confirm but with longer and
longer wait periods. The auction at the front of the queue for priority
will be destroyed as there will be eventually no room in blocks besides
ageing transations and, there will be little value paying higher than
the minimum fee. Obviously, neither of these scenarios are in a miner's
interests.

Without a consensus as to what size dynamic block to create,
enforcement of dynamic block size is not currently possible. It may be
possible for a consensus to be formed in the future but here I cannot
speculate. I can only suggest that it is in the interest of Bitcoin as
a whole and, in the interest of each node to conform to the proposal.
Some nodes failing to conform to the proposed requirements of dynamic
size or transaction priority in this proposal will not be destructive
to the operation of the proposal.

If necessary, nodes that have not yet adopted the proposal will just
continue to create standard fixed size unordered blocks, although, if
the current mechanisms of block validation include the fixed block size
then it is unlikely that these nodes will be able to validate the
blockchain going forward. In this case a hard fork and a full transfer
to the new method should be required. If dynamic blocks with ordered
transactions will be valid to existing nodes then only a soft fork is
required. There is no proposed change to the internal construction of
blocks, only to the block size and using an ordered method of
transaction selection.

> The default value for mempoolexpiry in Bitcoin Core may in future
need to be adjusted to match something more than n days or, perhaps
using less than n = 14 days may be a more sensible approach?

All block created with dynamic size should be verified to ensure
conformity to a probability distribution curve resulting from the
priority method. Since the input is a probability, the output should
conform to a probability distribution.

The curves used for the priority of transactions would have to be
appropriate. Perhaps a mathematician with experience in probability can
develop the right formulae. My thinking is a steep curve. I suppose
that the probability of all transactions should probably account for a
sufficient number of inclusions that the target block size is met on
average although, it may not always be. As a suggestion, consider
including some dust or zero-fee transactions to pad if each valid
transaction is tried and the target block size is not yet met, highest
BTC transaction value first?

**Explanation of the operation of priority:**

> If transaction priority is, for example, a number between one (low)
and one-hundred (high) it can be directly understood as the percentage
chance in one-hundred of a transaction being included in the block.
Using probability or likelihood infers that there is some function of
random. Try the transactions in priority order from highest to lowest,
if random (100) < transaction priority then the transaction is included
until the target block size is met.

> To break it down further, if both the fee on a curve value and the
time waiting on a curve value are each a number between one and one-
hundred, a rudimentary method may be to simply multiply those two
numbers, to find the priority number. For example, a middle fee
transaction waiting thirty days (if n = 60 days) may have a value of
five for each part  (yes, just five, the values are on a curve). When
multiplied that will give a priority value of twenty-five, or, a
twenty-five percent chance at that moment of being included in the
block; it will likely be included in one of the next four blocks,
getting more likely each chance. If it is still not included then the
value of time waiting will be higher, making for more probability. A
very low fee transaction would have a value for the fee of one. It
would not be until near sixty-days that the particular low fee
transaction has a high likelihood of being included in the block.

In practice it may be more useful to use numbers representative of one-
hundred for the highest fee priority curve down to a small fraction of
one for the lowest fee and, from one for a newly seen transaction up to
a proportionately high number above one-hundred for the time waiting
curve. It is truely beyond my level of math to resolve probability
curves accurately without much trial and error.

The primary reason for addressing the issue is to ensure transactional
reliability and scalability while having each valid transaction confirm
in due time.

#### Pros

*   Maximizes transaction reliability.
*   Overcomes transaction bandwidth limit.
*   Fully scalable.
*   Maximizes possibility for consumer and business uptake.
*   Maximizes total fees paid per block without reducing reliability;
because of reliability, in time confidence and overall uptake are
greater; therefore, more transactions.
*   Market determines fee paid for transaction priority.
*   Fee recommendations work all the way out to 30 days or greater.
*   Provides additional block entropy; greater security since there is
less probability of predicting the next block. _Although this is not
necessary it is a product of the operation of this proposal._

#### Cons

*   Could initially lower total transaction fees per block.
*   Must be first be programmed.

#### Pre-rollout

Nodes need to have at a minimum a loose understanding of the average
(since there is no consensus) size of the transaction pool as a
requirement to enable future changes to the way blocks are constructed.

A new network service should be constructed to meet this need. This
service makes no changes to any existing operation or function of the
node. Initially, Bitcoin Core is a suitable candidate.

For all operations we count only valid transactions.

**The service must:**

*   Have an individual temporary (runtime permanent only) Serial Node
ID.
*   Accept communication of the number of valid transactions in the
mempool of another valid Bitcoin node along with the Serial Node ID of
the node whose value is provided.
*   Disconnect the service from any non-Bitcoin node. Bitcoin Core may
handle this already?
*   Expire any value not updated for k minutes (k = 30 minutes?).
*   Broadcast all mempool information the node has every m minutes (m =
10 minutes?), including its own.
*   Nodes own mempool information should not be broadcast or used in
calculation until the node has been up long enough for the mempool to
normalise for at least o minutes (o = 300 minutes ?)
*   Alternatively, if loading nodes own full mempool from disk on node
restart (o = 30 minutes ?)
*   Only new or updated mempool values should be transmitted to the
same node. Updated includes updated with no change.
*   All known mempool information must survive node restart.
*   If the nodes own mempool is not normalised and network information
is not available to calculate an average just display zero.
*   Internally, the average transaction pool size must return the
calculated average if an average is available or, if none is available
just the number of valid transactions in the node's own mempool
regardless if it is normalised.

Bitcoin Core must use all collated information on mempool size to
calculate a figure for the average mempool size.

The calculated figure should be displayed in the appropriate place in
the Debug window alongside the text Network average transactions.

Consideration must be given before development of the network bandwidth
this would require. All programming must be consistent with the current
operation and conventions of Bitcoin Core. Methods must work on all
platforms.

As this new service does not affect any existing service or feature of
Bitcoin or Bitcoin Core, this can technically be programmed now and
included in Bitcoin Core at any time.

### 5. Solution operation

This is a simplistic view of the operation. The actual operation will
need to be determined accurately in a spec for the programmer.

1.  Determine the target block size for the current block.
2.  Assign a transaction priority to each valid transaction in the
mempool.
3.  Select transactions to include in the current block using
probability in transaction priority order until the target block size
is met. If target block size is not met, include dust and zero-fee
transactions to pad.
4.  Solve block.
5.  Broadcast the current block when it is solved.
6.  Block is received.
7.  Block verification process.
8.  Accept/reject block based on verification result.
9.  Repeat.

### 6. Closing comments

It may be possible to verify blocks conform to the proposal by showing
that the probability for all transactions included in the block
statistically conforms to a probability distribution curve, *if* the
individual transaction priority can be recreated. I am not that deep
into the mathematics; however, it may also be possible to use a similar
method to do this just based on the fee, that statistically, the block
conforms to a fee distribution. Any dust and zero-fee transactions
would have to be ignored. This solution needs a competent mathematician
with experience in probability and statistical distribution.

It is trivial to this proposal to offer that a node provides the next
block size with a block when it is solved. I am not sure that this
creates any actual benefit since the provided next block size is only
one node's view, as it is the node may seemingly just as well use its
own view and create the block. Providing a next block size only adds
additional complexity to the required operation, however, perhaps
providing the next block size is not trivial in what is accomplished
and the feature can be included in the operation.

Instead of the pre-rollout network service providing data as to valid
transactions in mempool, it could directly provide data as to the
suggested next block size if that is preferred, using a similar
operation as is suggested now and averaging all received suggested next
block sizes.

It may be foreseeable in the future for Bitcoin to operate with a
network of dedicated full blockchain & mempool servers. This would not
be without challenges to overcome but would offer several benefits,
including to the operation of this proposal, and especially as the RAM
and storage requirements of a full node grows. It is easy to foresee
that in just another seven years of operation a Bitcoin Full Node will
require at least 300GB of storage and, if the mempool only doubles in
size, over 1GB of RAM.

There has been some concern expressed over spam and very low fee
transactions, and an infinite block size resulting. I hope that for
those concerned using the dust level addresses the issue, especially as
the value of Bitcoin grows.

Notwithstanding this proposal, all blocks including those with dynamic
size each have limited transaction space per block. This proposal
results in a fee for priority service auction, where the probability of
a transaction to be included in limited space in the next available
block is auctioned to the highest bidders and all other transactions
must wait until they reach priority by ageing to gain significant
probability. Under this proposal the mempool can grow quite large while
the confirmation service continues in a stable and reliable manner.
Several incentives for attackers are removed, where there is no longer
multiple potential incentives for unnecessarily filling blocks or
flooding the mempool with transactions, whether such transactions are
fraudulent, valid or, otherwise. Adoption of this proposal and
adherence results in a reliable, stable fee paying transaction
confirmation service and a beneficial auction.

This proposal is necessary. I implore, at the very least, that we use
some method that validates full transaction reliability and enables
scalability of Bitcoin. If not this proposal, an alternative.

I have done as much with this proposal as I feel that I am able so far
but continue to take your feedback.

Regards,
Damian Williamson

[![Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/
88x31.png)](http://creativecommons.org/licenses/by-sa/4.0/)
<span xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text" property="dct:title"
rel="dct:type">BIP Proposal: UTPFOTIB - Use Transaction Priority For
Ordering Transactions In Blocks</span> by [Damian Williamson
&lt;willtech at live.com.au<mailto:lt%3Bwilltech at live.com.au>&gt;](http://thekingjameshrmh.tumblr.com/post/1
68948530950/bip-proposal-utpfotib-use-transaction-priority-for-order)
is licensed under a [Creative Commons Attribution-ShareAlike 4.0
International License](http://creativecommons.org/licenses/by-sa/4.0/).
Based on a work at https://lists.linuxfoundation.org/pipermail/bitcoin-
dev/2017-
December/015371.html](https://lists.linuxfoundation.org/pipermail/bitco
in-dev/2017-December/015371.html).
Permissions beyond the scope of this license may be available at [https
://opensource.org/licenses/BSD-3-<http://opensource.org/licenses/BSD-3->
Clause](https://opensource.org/licenses/BSD-3-Clause).


_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

_______________________________________________
bitcoin-dev mailing list
bitcoin-dev at lists.linuxfoundation.org<mailto:bitcoin-dev at lists.linuxfoundation.org>
https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180121/20f0a541/attachment-0001.html>

From ZmnSCPxj at protonmail.com  Mon Jan 22 11:12:51 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Mon, 22 Jan 2018 06:12:51 -0500
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
In-Reply-To: <CANZDnNomrpBTJU4=J1QqJpDePJ6RXyYsrwa=b9ZZOjyf1utQBw@mail.gmail.com>
References: <CANZDnNomrpBTJU4=J1QqJpDePJ6RXyYsrwa=b9ZZOjyf1utQBw@mail.gmail.com>
Message-ID: <ijnCMrLMjj4_aUv1BO5NiTk9jtMBL6aaN0yg4hwbF6JNms3MmlpNww0-smKeaqqT0dhsfmxlaX-tKoZ6s06g2ZNmgqY4uWnuuFul8e9on6g=@protonmail.com>

Good morning Chaofan Li,

What enforces that bitcoin A is worth the same as bitcoin B?  Or are they allowed to eventually diverge in price?  If they diverge in price, how is that different from the current situation with Bitcoin, BCash, Bitcoin Gold, Bitcoin Hardfork-of-the-week, and so on?

Regards,
ZmnSCPxj

Sent with [ProtonMail](https://protonmail.com) Secure Email.

-------- Original Message --------
On January 17, 2018 3:55 PM, Chaofan Li via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> Here I propose a simple method to solve the scalability issue of blockchain.
> It is more like a financial trick rather than a technical solution.
>
> The technical part is very simple:
> Split ( hard fork ) the blockchain into two or more blockchains (e.g. two blockchain A and B), voluntarily.
> The two blockchains are the same except for some identifiers to distinguish the two blockchains.
> The coins on one blockchains cannot be sent to the other one or interfered by the other blockchain (  considering so many hard forks in the last year, the replay protection should work in this situation)
> Everyone get double bitcoins. Each has half  value of original one bitcoin.
> Then, we have two almost same blockchains and the capacity of the original blockchain is doubled theoretically.
> When sending coin, the wallet should select one blockchain randomly and try to send through only  one blockchain (If there is enough bitcoins)
> I think it is a  possible solution, if the community realize  no previously owned asset value  is lost.
>
> The method is inspired by the [stock split](https://en.wikipedia.org/wiki/Stock_split).
> When a stock share is split, for example into two shares, the price halves.
> The market capitalization remains the same.
> There is no dilution of every shareholders' total assets.
>
> The bitcoin often emphasizes that the total coin supply should not be changed.
> If the total supply increases, the value of a single coin will be diluted.
> That is true.
> However, the bad part of inflation of fiat money is not  diluted value of every unit of fiat money caused by total supply increase.
> The problem is the increased supply is not delivered to everyone proportional to their previously owned money.
> The increased supply is released through debt expansion.
> The people that can borrow more money with low interest ratio (during QE, it was nearly 0) can invest  and get profit.
> Or they don't even need to pay back the debt. The debt is left to government, which might never pay back the debt, and some  get more money from government.
> Others' money are diluted.
>
> With voluntary split of bitcoin, dilution of anyone's bitcoin assets won't happen.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/7dd38f6f/attachment.html>

From ondrej.vejpustek at satoshilabs.com  Mon Jan 22 15:00:25 2018
From: ondrej.vejpustek at satoshilabs.com (=?UTF-8?Q?Ond=c5=99ej_Vejpustek?=)
Date: Mon, 22 Jan 2018 16:00:25 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
	<d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
	<CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
Message-ID: <eacc2887-196d-6ed3-dafa-6f67181eb27f@satoshilabs.com>

> 
> My post provided a concrete example. I'd be happy to answer any
> questions about it, but otherwise I'm not sure how to make it more
> clear.

My apologies, I didn't read it carefully. You are absolutely right. Our
scheme doesn't protect against the scenario.

> Quite the opposite-- a large block cipher is a standard
> construction

I'm happy to hear it. Nevertheless, I didn't find any standartisation or
implementation of the CMC mode (excluding the paper).

Do you have some experience with other modes (such as HCTR, HEH)?

From rhavar at protonmail.com  Mon Jan 22 17:40:31 2018
From: rhavar at protonmail.com (Rhavar)
Date: Mon, 22 Jan 2018 12:40:31 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
Message-ID: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>

So my half-baked idea is very simple:

Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.

This is currently not possible because of the bip125 rule:
"The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."

Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.

I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?

---
Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.

From a "coin selection" point of view, this was significantly easier than
I had anticipated. I was able to encode the rules in my linear model and
feed in all my unspent and in-flight transactions and it can solve it without difficulty.

However, the real problem is tracking the mess. Consider this sequence of events:
1) I have unconfirmed transaction A
2) I replace it with B, which pays John 1 BTC
3) Transaction A gets confirmed

So now I still owe John 1 BTC, however it's not immediately clear if
it's safe to send to him without waiting $n transactions. However even
for a small $n, this breaks my promise to pay him immediately.

One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.

However, this will only work <50% of the time for me (most transactions
don't have change) and opens a pandora's box of complexity.

There's a few other hacks you can do to make it work in a few more cases, but nothing that is realistic to expect anyone to implement any time soon.

However, if there was a straight foward way to merge N unconfirmed transactions, it would be easy get into production, and potentially offer some pretty nice savings for everyone.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/75c4190e/attachment.html>

From rhavar at protonmail.com  Mon Jan 22 18:18:14 2018
From: rhavar at protonmail.com (Rhavar)
Date: Mon, 22 Jan 2018 13:18:14 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <CALPhJazXpUAsd9qeHPZdwK6eeoEfsM7i3FouMifkKNv9YFzQ9w@mail.gmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<CALPhJazXpUAsd9qeHPZdwK6eeoEfsM7i3FouMifkKNv9YFzQ9w@mail.gmail.com>
Message-ID: <vdr3w_poTPTx_YFFvEdLugS0a_wbKTRx00npKupZqVNWPO0lwxIEMxMaC9xyPSGNmtuRn2behoLMq4iR0YTwDoQxR6AZds8HA-RccVr_ZPw=@protonmail.com>

> If you spent your change from transaction A, that would be safe. There'd be no way you John could end up with 2 BTC from you then.

Yes, that's what the following paragraph says -- along with it's limitations =)

-Ryan

-------- Original Message --------
On January 22, 2018 1:16 PM, Alan Evans <thealanevans at gmail.com> wrote:

>> So now I still owe John 1 BTC, however it's not immediately clear if it's safe to send to him
>
> If you spent your change from transaction A, that would be safe. There'd be no way you John could end up with 2 BTC from you then.
>
> On Mon, Jan 22, 2018 at 1:40 PM, Rhavar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> So my half-baked idea is very simple:
>>
>> Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.
>>
>> This is currently not possible because of the bip125 rule:
>> "The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."
>>
>> Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.
>>
>> I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?
>>
>> ---
>> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.
>>
>> From a "coin selection" point of view, this was significantly easier than
>> I had anticipated. I was able to encode the rules in my linear model and
>> feed in all my unspent and in-flight transactions and it can solve it without difficulty.
>>
>> However, the real problem is tracking the mess. Consider this sequence of events:
>> 1) I have unconfirmed transaction A
>> 2) I replace it with B, which pays John 1 BTC
>> 3) Transaction A gets confirmed
>>
>> So now I still owe John 1 BTC, however it's not immediately clear if
>> it's safe to send to him without waiting $n transactions. However even
>> for a small $n, this breaks my promise to pay him immediately.
>>
>> One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.
>>
>> However, this will only work <50% of the time for me (most transactions
>> don't have change) and opens a pandora's box of complexity.
>>
>> There's a few other hacks you can do to make it work in a few more cases, but nothing that is realistic to expect anyone to implement any time soon.
>>
>> However, if there was a straight foward way to merge N unconfirmed transactions, it would be easy get into production, and potentially offer some pretty nice savings for everyone.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/f0b58cf0/attachment-0001.html>

From thealanevans at gmail.com  Mon Jan 22 18:16:13 2018
From: thealanevans at gmail.com (Alan Evans)
Date: Mon, 22 Jan 2018 14:16:13 -0400
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
Message-ID: <CALPhJazXpUAsd9qeHPZdwK6eeoEfsM7i3FouMifkKNv9YFzQ9w@mail.gmail.com>

> So now I still owe John 1 BTC, however it's not immediately clear if it's
safe to send to him

If you spent your change from transaction A, that would be safe. There'd be
no way you John could end up with 2 BTC from you then.

On Mon, Jan 22, 2018 at 1:40 PM, Rhavar via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> So my half-baked idea is very simple:
>
> Allow users to merge multiple unconfirmed transactions, stripping
> extraneous inputs and change as they go.
>
> This is currently not possible because of the bip125 rule:
> "The replacement transaction pays an absolute fee of at least the sum paid
> by the original transactions."
>
> Because the size of the merged transaction is smaller than the original
> transactions, unless there is a considerable feerate bump, this rule isn't
> possible to observe.
>
>
> I my question is: is it possible or reasonable to relax this rule? If this
> rule was removed in its entirety, does it introduce any DoS vectors? Or can
> it be changed to allow my use-case?
>
>
> ---
> Full backstory: I have been trying to use bip125 (Opt-in Full
> Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I
> owe John 1 bitcoin, and have promised to pay him immediately: Instead of
> creating a whole new transaction if I have an in-flight (unconfirmed)
> transaction, I can follow the rules of bip125 to create a replacement that
> accomplishes this goal.
>
> From a "coin selection" point of view, this was significantly easier than
> I had anticipated. I was able to encode the rules in my linear model and
> feed in all my unspent and in-flight transactions and it can solve it
> without difficulty.
>
> However, the real problem is tracking the mess. Consider this sequence of
> events:
> 1) I have unconfirmed transaction A
> 2) I replace it with B, which pays John 1 BTC
> 3) Transaction A gets confirmed
>
> So now I still owe John 1 BTC, however it's not immediately clear if
> it's safe to send to him without waiting $n transactions. However even
> for a small $n, this breaks my promise to pay him immediately.
>
> One possible solution is to only consider a transaction "replaceable" if
> it has change, so if the original transaction confirms -- payments can
> immediately be made that source the change, and provide safety in a reorg.
>
> However, this will only work <50% of the time for me (most transactions
> don't have change) and opens a pandora's box of complexity.
>
> There's a few other hacks you can do to make it work in a few more cases,
> but nothing that is realistic to expect anyone to implement any time soon.
>
> However, if there was a straight foward way to merge N unconfirmed
> transactions, it would be easy get into production, and potentially offer
> some pretty nice savings for everyone.
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/b5749d54/attachment.html>

From ethan.scruples at gmail.com  Mon Jan 22 18:50:31 2018
From: ethan.scruples at gmail.com (Moral Agent)
Date: Mon, 22 Jan 2018 13:50:31 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <vdr3w_poTPTx_YFFvEdLugS0a_wbKTRx00npKupZqVNWPO0lwxIEMxMaC9xyPSGNmtuRn2behoLMq4iR0YTwDoQxR6AZds8HA-RccVr_ZPw=@protonmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<CALPhJazXpUAsd9qeHPZdwK6eeoEfsM7i3FouMifkKNv9YFzQ9w@mail.gmail.com>
	<vdr3w_poTPTx_YFFvEdLugS0a_wbKTRx00npKupZqVNWPO0lwxIEMxMaC9xyPSGNmtuRn2behoLMq4iR0YTwDoQxR6AZds8HA-RccVr_ZPw=@protonmail.com>
Message-ID: <CACiOHGwdy3BAgJJx1kjU8jLxmt+QZx-OBDxdHB0L2+D=ix7zYw@mail.gmail.com>

Along the same lines, I wonder if unrelated people with tx that are not
confirming could cooperate to merge their disparate tx into a CoinJoin tx
with a higher fee rate?

Perhaps they could even replace old tx with economically equivalent summary
transactions?

The mempool seems like nature's accumulator for pre-mining compression
opportunities.

On Mon, Jan 22, 2018 at 1:18 PM, Rhavar via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> > If you spent your change from transaction A, that would be safe. There'd
> be no way you John could end up with 2 BTC from you then.
>
> Yes, that's what the following paragraph says -- along with it's
> limitations =)
>
> -Ryan
>
>
> -------- Original Message --------
> On January 22, 2018 1:16 PM, Alan Evans <thealanevans at gmail.com> wrote:
>
> > So now I still owe John 1 BTC, however it's not immediately clear if it's
> safe to send to him
>
> If you spent your change from transaction A, that would be safe. There'd
> be no way you John could end up with 2 BTC from you then.
>
> On Mon, Jan 22, 2018 at 1:40 PM, Rhavar via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> So my half-baked idea is very simple:
>>
>> Allow users to merge multiple unconfirmed transactions, stripping
>> extraneous inputs and change as they go.
>>
>> This is currently not possible because of the bip125 rule:
>> "The replacement transaction pays an absolute fee of at least the sum
>> paid by the original transactions."
>>
>> Because the size of the merged transaction is smaller than the original
>> transactions, unless there is a considerable feerate bump, this rule isn't
>> possible to observe.
>>
>>
>> I my question is: is it possible or reasonable to relax this rule? If
>> this rule was removed in its entirety, does it introduce any DoS vectors?
>> Or can it be changed to allow my use-case?
>>
>>
>> ---
>> Full backstory: I have been trying to use bip125 (Opt-in Full
>> Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I
>> owe John 1 bitcoin, and have promised to pay him immediately: Instead of
>> creating a whole new transaction if I have an in-flight (unconfirmed)
>> transaction, I can follow the rules of bip125 to create a replacement that
>> accomplishes this goal.
>>
>> From a "coin selection" point of view, this was significantly easier than
>> I had anticipated. I was able to encode the rules in my linear model and
>> feed in all my unspent and in-flight transactions and it can solve it
>> without difficulty.
>>
>> However, the real problem is tracking the mess. Consider this sequence of
>> events:
>> 1) I have unconfirmed transaction A
>> 2) I replace it with B, which pays John 1 BTC
>> 3) Transaction A gets confirmed
>>
>> So now I still owe John 1 BTC, however it's not immediately clear if
>> it's safe to send to him without waiting $n transactions. However even
>> for a small $n, this breaks my promise to pay him immediately.
>>
>> One possible solution is to only consider a transaction "replaceable" if
>> it has change, so if the original transaction confirms -- payments can
>> immediately be made that source the change, and provide safety in a reorg.
>>
>> However, this will only work <50% of the time for me (most transactions
>> don't have change) and opens a pandora's box of complexity.
>>
>> There's a few other hacks you can do to make it work in a few more cases,
>> but nothing that is realistic to expect anyone to implement any time soon.
>>
>> However, if there was a straight foward way to merge N unconfirmed
>> transactions, it would be easy get into production, and potentially offer
>> some pretty nice savings for everyone.
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/8273b051/attachment.html>

From li3939108 at gmail.com  Mon Jan 22 18:46:06 2018
From: li3939108 at gmail.com (Chaofan Li)
Date: Mon, 22 Jan 2018 18:46:06 +0000
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
In-Reply-To: <ijnCMrLMjj4_aUv1BO5NiTk9jtMBL6aaN0yg4hwbF6JNms3MmlpNww0-smKeaqqT0dhsfmxlaX-tKoZ6s06g2ZNmgqY4uWnuuFul8e9on6g=@protonmail.com>
References: <CANZDnNomrpBTJU4=J1QqJpDePJ6RXyYsrwa=b9ZZOjyf1utQBw@mail.gmail.com>
	<ijnCMrLMjj4_aUv1BO5NiTk9jtMBL6aaN0yg4hwbF6JNms3MmlpNww0-smKeaqqT0dhsfmxlaX-tKoZ6s06g2ZNmgqY4uWnuuFul8e9on6g=@protonmail.com>
Message-ID: <CANZDnNo2HMWGOZ4torXvpqjbq6SE=NLBLwysJzetrpurWBu+yw@mail.gmail.com>

Hi ZmnSCPxj

I dont think they need to be ENFORCED to be worth the same.
If the two chains? algorithms are the same , except some identifiers (eg.
btc.0 btc.1?, they have no reason to have different value. If so, the
market will adjust the value.

Also, the total supply can be the same. The amount in blockchains  is just
some numbers. The  wallet can display correct amount, according to the
identifiers.

The voluntary split is also backward compatible with old version
transactions, they can be treated as tx for both chains and included in
both chains later. For new version Tx after fork, some identifiers must be
added , to mark the tx is for that chain only. The miners need to choose
one chain to mine.

After several voluntary splits , the Blockchain basically become a
blocktree, new blocks are added to the leaves(eg. btc.00 btc.01 btc.10
btc.11 ), providing even more capacity.

Chaofan


On Mon, Jan 22, 2018 at 5:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:

> Good morning Chaofan Li,
>
> What enforces that bitcoin A is worth the same as bitcoin B?  Or are they
> allowed to eventually diverge in price?  If they diverge in price, how is
> that different from the current situation with Bitcoin, BCash, Bitcoin
> Gold, Bitcoin Hardfork-of-the-week, and so on?
>
> Regards,
> ZmnSCPxj
>
>
> Sent with ProtonMail <https://protonmail.com> Secure Email.
>
> -------- Original Message --------
> On January 17, 2018 3:55 PM, Chaofan Li via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>
>
> Here I propose a simple method to solve the scalability issue of
> blockchain.
> It is more like a financial trick rather than a technical solution.
>
> The technical part is very simple:
> Split ( hard fork ) the blockchain into two or more blockchains (e.g. two
> blockchain A and B), voluntarily.
> The two blockchains are the same except for some identifiers to
> distinguish the two blockchains.
> The coins on one blockchains cannot be sent to the other one or interfered
> by the other blockchain (  considering so many hard forks in the last year,
> the replay protection should work in this situation)
> Everyone get double bitcoins. Each has half  value of original one
> bitcoin.
> Then, we have two almost same blockchains and the capacity of the original
> blockchain is doubled theoretically.
> When sending coin, the wallet should select one blockchain randomly and
> try to send through only  one blockchain (If there is enough bitcoins)
> I think it is a  possible solution, if the community realize  no
> previously owned asset value  is lost.
>
> The method is inspired by the stock split
> <https://en.wikipedia.org/wiki/Stock_split>.
> When a stock share is split, for example into two shares, the price halves.
> The market capitalization remains the same.
> There is no dilution of every shareholders' total assets.
>
> The bitcoin often emphasizes that the total coin supply should not be
> changed.
> If the total supply increases, the value of a single coin will be diluted.
> That is true.
> However, the bad part of inflation of fiat money is not  diluted value of
> every unit of fiat money caused by total supply increase.
> The problem is the increased supply is not delivered to everyone
> proportional to their previously owned money.
> The increased supply is released through debt expansion.
> The people that can borrow more money with low interest ratio (during QE,
> it was nearly 0) can invest  and get profit.
> Or they don't even need to pay back the debt. The debt is left to
> government, which might never pay back the debt, and some  get more money
> from government.
> Others' money are diluted.
>
> With voluntary split of bitcoin, dilution of anyone's bitcoin assets won't
> happen.
>
>
>
>
>
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/46d6ce13/attachment-0001.html>

From rhavar at protonmail.com  Mon Jan 22 18:59:34 2018
From: rhavar at protonmail.com (Rhavar)
Date: Mon, 22 Jan 2018 13:59:34 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <CACiOHGwdy3BAgJJx1kjU8jLxmt+QZx-OBDxdHB0L2+D=ix7zYw@mail.gmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<CALPhJazXpUAsd9qeHPZdwK6eeoEfsM7i3FouMifkKNv9YFzQ9w@mail.gmail.com>
	<vdr3w_poTPTx_YFFvEdLugS0a_wbKTRx00npKupZqVNWPO0lwxIEMxMaC9xyPSGNmtuRn2behoLMq4iR0YTwDoQxR6AZds8HA-RccVr_ZPw=@protonmail.com>
	<CACiOHGwdy3BAgJJx1kjU8jLxmt+QZx-OBDxdHB0L2+D=ix7zYw@mail.gmail.com>
Message-ID: <PC8akZHeMMX6DRimbLFLF5wPH4KUknv-JAyN0lnrHqvraOMhIGa2eaczieRlG6mcDsOmEMxhmqvSP5WACmrfbaQ1n5MDRd_am0IQ43aqGzk=@protonmail.com>

> Perhaps they could even replace old tx with economically equivalent summary transactions?

I imagine with schnorr signatures, the incentives will emerge for that to make sense. But right now if I want to merge my transaction with an untrusted party in general we're only really going to be saving like 12 bytes of overhead or something. But if I'm merging my own transactions, I can get that fixed overhead, strip extraneous inputs and merge my change outputs (which also means in the future it's cheaper to spend).

Although it's obviously a lot worse for privacy, I do like the pattern of broadcast the transaction standalone and then merge it for savings. It helps keep the more or less fire-and-forget style, without a ridiculous amount of complexity "if this happens, do this, if this, then this, ..."

-Ryan

-Ryan

-------- Original Message --------
On January 22, 2018 1:50 PM, Moral Agent <ethan.scruples at gmail.com> wrote:

> Along the same lines, I wonder if unrelated people with tx that are not confirming could cooperate to merge their disparate tx into a CoinJoin tx with a higher fee rate?
>
> Perhaps they could even replace old tx with economically equivalent summary transactions?
>
> The mempool seems like nature's accumulator for pre-mining compression opportunities.
>
> On Mon, Jan 22, 2018 at 1:18 PM, Rhavar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>>> If you spent your change from transaction A, that would be safe. There'd be no way you John could end up with 2 BTC from you then.
>>
>> Yes, that's what the following paragraph says -- along with it's limitations =)
>>
>> -Ryan
>>
>> -------- Original Message --------
>> On January 22, 2018 1:16 PM, Alan Evans <thealanevans at gmail.com> wrote:
>>
>>>> So now I still owe John 1 BTC, however it's not immediately clear if it's safe to send to him
>>>
>>> If you spent your change from transaction A, that would be safe. There'd be no way you John could end up with 2 BTC from you then.
>>>
>>> On Mon, Jan 22, 2018 at 1:40 PM, Rhavar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>
>>>> So my half-baked idea is very simple:
>>>>
>>>> Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.
>>>>
>>>> This is currently not possible because of the bip125 rule:
>>>> "The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."
>>>>
>>>> Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.
>>>>
>>>> I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?
>>>>
>>>> ---
>>>> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.
>>>>
>>>> From a "coin selection" point of view, this was significantly easier than
>>>> I had anticipated. I was able to encode the rules in my linear model and
>>>> feed in all my unspent and in-flight transactions and it can solve it without difficulty.
>>>>
>>>> However, the real problem is tracking the mess. Consider this sequence of events:
>>>> 1) I have unconfirmed transaction A
>>>> 2) I replace it with B, which pays John 1 BTC
>>>> 3) Transaction A gets confirmed
>>>>
>>>> So now I still owe John 1 BTC, however it's not immediately clear if
>>>> it's safe to send to him without waiting $n transactions. However even
>>>> for a small $n, this breaks my promise to pay him immediately.
>>>>
>>>> One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.
>>>>
>>>> However, this will only work <50% of the time for me (most transactions
>>>> don't have change) and opens a pandora's box of complexity.
>>>>
>>>> There's a few other hacks you can do to make it work in a few more cases, but nothing that is realistic to expect anyone to implement any time soon.
>>>>
>>>> However, if there was a straight foward way to merge N unconfirmed transactions, it would be easy get into production, and potentially offer some pretty nice savings for everyone.
>>>>
>>>> _______________________________________________
>>>> bitcoin-dev mailing list
>>>> bitcoin-dev at lists.linuxfoundation.org
>>>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/074be1a4/attachment.html>

From ilansky.sharkson at gmail.com  Mon Jan 22 19:01:02 2018
From: ilansky.sharkson at gmail.com (Ilan Oh)
Date: Mon, 22 Jan 2018 20:01:02 +0100
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
	(Chaofan Li)
In-Reply-To: <CALTsm7gQC8RejAhmobzejEoU4T7xLf77Ykk2m0p=Z2=oM2p0Uw@mail.gmail.com>
References: <CALTsm7iyJjQa5rkddZj2jL_BTdGxH+6Xz78Rt0wOqW1OveecHw@mail.gmail.com>
	<CALTsm7gQC8RejAhmobzejEoU4T7xLf77Ykk2m0p=Z2=oM2p0Uw@mail.gmail.com>
Message-ID: <CALTsm7irVCPE0_JE28NviEUdvVoE1bVcQ37w13VX2bKKb_RnVg@mail.gmail.com>

How do you handle the mining on each chain ?

The chain with the most mining power will tend to have more value.

Also blocks are not mined equally and 1 chain will be longer than the other
thus faster thus more valuable.

It seems to be a sidechain proposal with the exact same protocol.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/17485223/attachment.html>

From pete at petertodd.org  Mon Jan 22 20:00:23 2018
From: pete at petertodd.org (Peter Todd)
Date: Mon, 22 Jan 2018 15:00:23 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
Message-ID: <20180122200023.GA1055@savin.petertodd.org>

On Mon, Jan 22, 2018 at 12:40:31PM -0500, Rhavar via bitcoin-dev wrote:
> So my half-baked idea is very simple:
> 
> Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.
> 
> This is currently not possible because of the bip125 rule:
> "The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."
> 
> Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.
> 
> I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?

It would definitely introduce DoS vectors by making it much cheaper to use
relay bandwidth. You'd also be able to push others' txs out of the mempool.

> ---
> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.
> 
> From a "coin selection" point of view, this was significantly easier than
> I had anticipated. I was able to encode the rules in my linear model and
> feed in all my unspent and in-flight transactions and it can solve it without difficulty.
> 
> However, the real problem is tracking the mess. Consider this sequence of events:
> 1) I have unconfirmed transaction A
> 2) I replace it with B, which pays John 1 BTC
> 3) Transaction A gets confirmed
> 
> So now I still owe John 1 BTC, however it's not immediately clear if
> it's safe to send to him without waiting $n transactions. However even
> for a small $n, this breaks my promise to pay him immediately.
>
> One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.
> 
> However, this will only work <50% of the time for me (most transactions
> don't have change) and opens a pandora's box of complexity.

Most transactions don't have change?! Under what circumstance? For most
use-cases the reverse is true: almost all all transactions have change, because
it's rare for the inputs to exactly math the requested payment.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/84f99d15/attachment-0001.sig>

From rhavar at protonmail.com  Mon Jan 22 20:09:20 2018
From: rhavar at protonmail.com (Rhavar)
Date: Mon, 22 Jan 2018 15:09:20 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <20180122200023.GA1055@savin.petertodd.org>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
Message-ID: <tSFdDDXQYpeVlmLo43wABP1gQfqSflgWxl5xKnVErxHDet9hzqFNI2MXU4BWbi-iGK2gIjENeqHxu_9ni0g_BJZX9trx7o_1T_0AV62Ph90=@protonmail.com>

> Most transactions don't have change?! Under what circumstance? For most
> use-cases the reverse is true: almost all all transactions have change, because
> it's rare for the inputs to exactly math the requested payment.

It's actually a common misconception. With good coin selection, I am able to avoid change about ~75% of the time in my simulations (on my real world data). In practice it's a bit lower, probably about 40-50% of the time because of the need to keep the majority of my funds offline where they can't be used for coin selection, and I have not been able to accurate simulate how I consolidate.

Also the other misconception is that inputs don't need to match exactly the requested payment, it's totally fine to do something I call a "miner sacrifice" where you overpay txfees up to the amount that that would otherwise be the total cost (immediate + consolidation) of creating change.

Also another trick I use, is something I call "output selection". If I have N queued non-time sensitive payments, I don't really need to send them all at the same time. So I can pick the best combination of inputs+outputs.

Obviously none of this applies to consumer wallets, who typically have less than a handful of options. But for a service, avoiding change can be the norm with good coin selection.

---

-Ryan

-------- Original Message --------
On January 22, 2018 3:00 PM, Peter Todd <pete at petertodd.org> wrote:

> On Mon, Jan 22, 2018 at 12:40:31PM -0500, Rhavar via bitcoin-dev wrote:
>
>> So my half-baked idea is very simple:
>> Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.
>> This is currently not possible because of the bip125 rule:
>> "The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."
>> Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.
>> I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?
>
> It would definitely introduce DoS vectors by making it much cheaper to use
> relay bandwidth. You'd also be able to push others' txs out of the mempool.
>
>> ---------------------------------------------------------------
>>
>> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.
>> From a "coin selection" point of view, this was significantly easier than
>> I had anticipated. I was able to encode the rules in my linear model and
>> feed in all my unspent and in-flight transactions and it can solve it without difficulty.
>> However, the real problem is tracking the mess. Consider this sequence of events:
>>
>> - I have unconfirmed transaction A
>> - I replace it with B, which pays John 1 BTC
>> - Transaction A gets confirmed
>>
>> So now I still owe John 1 BTC, however it's not immediately clear if
>> it's safe to send to him without waiting $n transactions. However even
>> for a small $n, this breaks my promise to pay him immediately.
>> One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.
>> However, this will only work <50% of the time for me (most transactions
>> don't have change) and opens a pandora's box of complexity.
>
> Most transactions don't have change?! Under what circumstance? For most
> use-cases the reverse is true: almost all all transactions have change, because
> it's rare for the inputs to exactly math the requested payment.
>
> https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/1abc39e2/attachment.html>

From mark at friedenbach.org  Mon Jan 22 19:59:39 2018
From: mark at friedenbach.org (Mark Friedenbach)
Date: Mon, 22 Jan 2018 11:59:39 -0800
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
 (Chaofan Li)
In-Reply-To: <CALTsm7irVCPE0_JE28NviEUdvVoE1bVcQ37w13VX2bKKb_RnVg@mail.gmail.com>
References: <CALTsm7iyJjQa5rkddZj2jL_BTdGxH+6Xz78Rt0wOqW1OveecHw@mail.gmail.com>
	<CALTsm7gQC8RejAhmobzejEoU4T7xLf77Ykk2m0p=Z2=oM2p0Uw@mail.gmail.com>
	<CALTsm7irVCPE0_JE28NviEUdvVoE1bVcQ37w13VX2bKKb_RnVg@mail.gmail.com>
Message-ID: <091F89E0-FBA0-42F9-9166-CF121A84319F@friedenbach.org>


> On Jan 22, 2018, at 11:01 AM, Ilan Oh via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> The chain with the most mining power will tend to have more value.

I believe you have the causality on that backwards. The tokens which are worth more value will attract more mining hash rate. Miners respond to cash-out value, they don?t set it.


From roconnor at blockstream.io  Mon Jan 22 19:21:14 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Mon, 22 Jan 2018 14:21:14 -0500
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
	<d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
	<CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
Message-ID: <CAMZUoK=ffKHM9WN=zrSME5y904u6ZYsfnCpeT_BYT=5Z+NxYsw@mail.gmail.com>

On Thu, Jan 18, 2018 at 1:58 PM, Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Thu, Jan 18, 2018 at 4:59 PM, Ond?ej Vejpustek
> <ondrej.vejpustek at satoshilabs.com> wrote:
> >> If being secure against partial share leakage is really part of your
> >> threat model the current proposal is gratuitously insecure against it.
> >
> > I don't think that is true. Shared secret is an input of KDF which
> > should prevent this kind of attack.
>
> My post provided a concrete example. I'd be happy to answer any
> questions about it, but otherwise I'm not sure how to make it more
> clear.
>
> > Actually, we've been considering something like that. We concluded that
> it is to much "rolling your own crypto". Instead of diffusion layer we
> decided to apply KDF on the shared secret.
>
>
> Quite the opposite-- a large block cipher is a standard
> construction... and the off-label application of a KDF that you've
> used here doesn't provide any protection against the example I gave.
>

At this point, is it better just to use GF(2^256+n)?  Is GF(2^256+n) going
to be that much slower than GF(2^8) that we care to make things this
complicated?  (I honestly don't know the answer.)
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/c8799a13/attachment.html>

From erik at q32.com  Mon Jan 22 20:40:58 2018
From: erik at q32.com (Erik Aronesty)
Date: Mon, 22 Jan 2018 15:40:58 -0500
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
In-Reply-To: <CANZDnNo2HMWGOZ4torXvpqjbq6SE=NLBLwysJzetrpurWBu+yw@mail.gmail.com>
References: <CANZDnNomrpBTJU4=J1QqJpDePJ6RXyYsrwa=b9ZZOjyf1utQBw@mail.gmail.com>
	<ijnCMrLMjj4_aUv1BO5NiTk9jtMBL6aaN0yg4hwbF6JNms3MmlpNww0-smKeaqqT0dhsfmxlaX-tKoZ6s06g2ZNmgqY4uWnuuFul8e9on6g=@protonmail.com>
	<CANZDnNo2HMWGOZ4torXvpqjbq6SE=NLBLwysJzetrpurWBu+yw@mail.gmail.com>
Message-ID: <CAJowKgLJ2QmCGAwhUgW8foy-=8FK4FwzMxXYCNZoLaS=DXMCTg@mail.gmail.com>

Without enforcement liquidity will diverge.

On Mon, Jan 22, 2018 at 1:46 PM, Chaofan Li via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Hi ZmnSCPxj
>
> I dont think they need to be ENFORCED to be worth the same.
> If the two chains? algorithms are the same , except some identifiers (eg.
> btc.0 btc.1?, they have no reason to have different value. If so, the
> market will adjust the value.
>
> Also, the total supply can be the same. The amount in blockchains  is just
> some numbers. The  wallet can display correct amount, according to the
> identifiers.
>
> The voluntary split is also backward compatible with old version
> transactions, they can be treated as tx for both chains and included in
> both chains later. For new version Tx after fork, some identifiers must be
> added , to mark the tx is for that chain only. The miners need to choose
> one chain to mine.
>
> After several voluntary splits , the Blockchain basically become a
> blocktree, new blocks are added to the leaves(eg. btc.00 btc.01 btc.10
> btc.11 ), providing even more capacity.
>
> Chaofan
>
>
> On Mon, Jan 22, 2018 at 5:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>
>> Good morning Chaofan Li,
>>
>> What enforces that bitcoin A is worth the same as bitcoin B?  Or are they
>> allowed to eventually diverge in price?  If they diverge in price, how is
>> that different from the current situation with Bitcoin, BCash, Bitcoin
>> Gold, Bitcoin Hardfork-of-the-week, and so on?
>>
>> Regards,
>> ZmnSCPxj
>>
>>
>> Sent with ProtonMail <https://protonmail.com> Secure Email.
>>
>> -------- Original Message --------
>> On January 17, 2018 3:55 PM, Chaofan Li via bitcoin-dev <
>> bitcoin-dev at lists.linuxfoundation.org> wrote:
>>
>>
>>
>> Here I propose a simple method to solve the scalability issue of
>> blockchain.
>> It is more like a financial trick rather than a technical solution.
>>
>> The technical part is very simple:
>> Split ( hard fork ) the blockchain into two or more blockchains (e.g. two
>> blockchain A and B), voluntarily.
>> The two blockchains are the same except for some identifiers to
>> distinguish the two blockchains.
>> The coins on one blockchains cannot be sent to the other one or
>> interfered by the other blockchain (  considering so many hard forks in the
>> last year, the replay protection should work in this situation)
>> Everyone get double bitcoins. Each has half  value of original one
>> bitcoin.
>> Then, we have two almost same blockchains and the capacity of the
>> original blockchain is doubled theoretically.
>> When sending coin, the wallet should select one blockchain randomly and
>> try to send through only  one blockchain (If there is enough bitcoins)
>> I think it is a  possible solution, if the community realize  no
>> previously owned asset value  is lost.
>>
>> The method is inspired by the stock split
>> <https://en.wikipedia.org/wiki/Stock_split>.
>> When a stock share is split, for example into two shares, the price
>> halves.
>> The market capitalization remains the same.
>> There is no dilution of every shareholders' total assets.
>>
>> The bitcoin often emphasizes that the total coin supply should not be
>> changed.
>> If the total supply increases, the value of a single coin will be diluted.
>> That is true.
>> However, the bad part of inflation of fiat money is not  diluted value of
>> every unit of fiat money caused by total supply increase.
>> The problem is the increased supply is not delivered to everyone
>> proportional to their previously owned money.
>> The increased supply is released through debt expansion.
>> The people that can borrow more money with low interest ratio (during QE,
>> it was nearly 0) can invest  and get profit.
>> Or they don't even need to pay back the debt. The debt is left to
>> government, which might never pay back the debt, and some  get more money
>> from government.
>> Others' money are diluted.
>>
>> With voluntary split of bitcoin, dilution of anyone's bitcoin assets
>> won't happen.
>>
>>
>>
>>
>>
>>
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/f781f466/attachment-0001.html>

From eric at voskuil.org  Mon Jan 22 22:43:22 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 22 Jan 2018 14:43:22 -0800
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
In-Reply-To: <CAJowKgLJ2QmCGAwhUgW8foy-=8FK4FwzMxXYCNZoLaS=DXMCTg@mail.gmail.com>
References: <CANZDnNomrpBTJU4=J1QqJpDePJ6RXyYsrwa=b9ZZOjyf1utQBw@mail.gmail.com>
	<ijnCMrLMjj4_aUv1BO5NiTk9jtMBL6aaN0yg4hwbF6JNms3MmlpNww0-smKeaqqT0dhsfmxlaX-tKoZ6s06g2ZNmgqY4uWnuuFul8e9on6g=@protonmail.com>
	<CANZDnNo2HMWGOZ4torXvpqjbq6SE=NLBLwysJzetrpurWBu+yw@mail.gmail.com>
	<CAJowKgLJ2QmCGAwhUgW8foy-=8FK4FwzMxXYCNZoLaS=DXMCTg@mail.gmail.com>
Message-ID: <DFE3C3DB-1DFE-44B4-8A42-2F11AEFE3A02@voskuil.org>

All other things being equal, the money with the larger network is more useful due to the cost of exchange between them, which can only be eliminated by one absorbing the network of the other. According the Thiers? law (i.e. in the absence of currency controls), the more useful money will get used. It is not the case that they will just become the same value.

However, all other things are not equal. As a Bitcoin becomes more useful its use rises. Rising use implies rising fees, which in turn reduces usefulness (stability property). While the better money prices out certain scenarios, they remain viable in the lesser money. But eventually this will happen there as well, and the better money will absorb the lesser.

The perpetual creation of new monies with exchange between them and the best money (largest network) could certainly exist, but layering proposes an approach that doesn?t require all merchants to perpetually be accepting different monies. It has a similar security trade-off (lower security for transacting off of the better money), which is the source of decreased transaction cost. But without the exchange and overhead cost the layered money can be better than multiple monies.

Also, all splits are voluntary.

e

> On Jan 22, 2018, at 12:40, Erik Aronesty via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Without enforcement liquidity will diverge.   
> 
>> On Mon, Jan 22, 2018 at 1:46 PM, Chaofan Li via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Hi ZmnSCPxj
>> 
>> I dont think they need to be ENFORCED to be worth the same. 
>> If the two chains? algorithms are the same , except some identifiers (eg. btc.0 btc.1?, they have no reason to have different value. If so, the market will adjust the value.
>> 
>> Also, the total supply can be the same. The amount in blockchains  is just some numbers. The  wallet can display correct amount, according to the identifiers.
>> 
>> The voluntary split is also backward compatible with old version transactions, they can be treated as tx for both chains and included in both chains later. For new version Tx after fork, some identifiers must be added , to mark the tx is for that chain only. The miners need to choose one chain to mine.
>> 
>> After several voluntary splits , the Blockchain basically become a blocktree, new blocks are added to the leaves(eg. btc.00 btc.01 btc.10 btc.11 ), providing even more capacity. 
>> 
>> Chaofan
>> 
>> 
>>> On Mon, Jan 22, 2018 at 5:13 AM ZmnSCPxj <ZmnSCPxj at protonmail.com> wrote:
>>> Good morning Chaofan Li,
>>> 
>>> What enforces that bitcoin A is worth the same as bitcoin B?  Or are they allowed to eventually diverge in price?  If they diverge in price, how is that different from the current situation with Bitcoin, BCash, Bitcoin Gold, Bitcoin Hardfork-of-the-week, and so on?
>>> 
>>> Regards,
>>> ZmnSCPxj
>>> 
>>> 
>>> Sent with ProtonMail Secure Email.
>>> 
>>> -------- Original Message --------
>>>> On January 17, 2018 3:55 PM, Chaofan Li via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>> 
>>>> 
>>>> 
>>>> Here I propose a simple method to solve the scalability issue of blockchain.
>>>> It is more like a financial trick rather than a technical solution. 
>>>> 
>>>> The technical part is very simple: 
>>>> Split ( hard fork ) the blockchain into two or more blockchains (e.g. two blockchain A and B), voluntarily. 
>>>> The two blockchains are the same except for some identifiers to distinguish the two blockchains.
>>>> The coins on one blockchains cannot be sent to the other one or interfered by the other blockchain (  considering so many hard forks in the last year, the replay protection should work in this situation)
>>>> Everyone get double bitcoins. Each has half  value of original one bitcoin. 
>>>> Then, we have two almost same blockchains and the capacity of the original blockchain is doubled theoretically.
>>>> When sending coin, the wallet should select one blockchain randomly and try to send through only  one blockchain (If there is enough bitcoins)
>>>> I think it is a  possible solution, if the community realize  no previously owned asset value  is lost.
>>>> 
>>>> The method is inspired by the stock split.
>>>> When a stock share is split, for example into two shares, the price halves.
>>>> The market capitalization remains the same.
>>>> There is no dilution of every shareholders' total assets.
>>>> 
>>>> The bitcoin often emphasizes that the total coin supply should not be changed.
>>>> If the total supply increases, the value of a single coin will be diluted.
>>>> That is true.
>>>> However, the bad part of inflation of fiat money is not  diluted value of every unit of fiat money caused by total supply increase.
>>>> The problem is the increased supply is not delivered to everyone proportional to their previously owned money.
>>>> The increased supply is released through debt expansion.
>>>> The people that can borrow more money with low interest ratio (during QE, it was nearly 0) can invest  and get profit.
>>>> Or they don't even need to pay back the debt. The debt is left to government, which might never pay back the debt, and some  get more money from government.
>>>> Others' money are diluted.
>>>> 
>>>> With voluntary split of bitcoin, dilution of anyone's bitcoin assets won't happen.
>>>> 
>>>> 
>>>> 
>>>> 
>>>> 
>>> 
>> 
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/952b355a/attachment.html>

From eric at voskuil.org  Mon Jan 22 22:52:23 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 22 Jan 2018 14:52:23 -0800
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
	(Chaofan Li)
In-Reply-To: <091F89E0-FBA0-42F9-9166-CF121A84319F@friedenbach.org>
References: <CALTsm7iyJjQa5rkddZj2jL_BTdGxH+6Xz78Rt0wOqW1OveecHw@mail.gmail.com>
	<CALTsm7gQC8RejAhmobzejEoU4T7xLf77Ykk2m0p=Z2=oM2p0Uw@mail.gmail.com>
	<CALTsm7irVCPE0_JE28NviEUdvVoE1bVcQ37w13VX2bKKb_RnVg@mail.gmail.com>
	<091F89E0-FBA0-42F9-9166-CF121A84319F@friedenbach.org>
Message-ID: <E39CFE95-1A0D-413B-8AC1-7A9BE20737BC@voskuil.org>

This is true but confuses people because obviously miners must commit capital to mining before any block space can exist to have value. The reason for the misunderstanding is that miners don?t simply respond, they anticipate. All production, and therefore capital investment, is the result of anticipation of future returns, not an attempt to chase past returns.

The first miner anticipated that the then-worthless ?tokens? he was mining would have a future value. Turns out he was right. Others have been wrong, which is the nature of betting on future prices. But if nobody does it, there are no products.

e

> On Jan 22, 2018, at 11:59, Mark Friedenbach via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> 
>> On Jan 22, 2018, at 11:01 AM, Ilan Oh via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> The chain with the most mining power will tend to have more value.
> 
> I believe you have the causality on that backwards. The tokens which are worth more value will attract more mining hash rate. Miners respond to cash-out value, they don?t set it.
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From li3939108 at gmail.com  Tue Jan 23 00:38:10 2018
From: li3939108 at gmail.com (Chaofan Li)
Date: Mon, 22 Jan 2018 18:38:10 -0600
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
	(Chaofan Li)
Message-ID: <CANZDnNoGnab6HYESA0oOL-8Q8HtR1Ns0AfP3KNEmwU6KN5W5pA@mail.gmail.com>

Miners are most likely to be  equally distributed between the two almost
same chains.
If one chain is faster, according to the difficulty adjustment scheme, it
will become more difficult to mine.
The two chain should have similar chain generation rates with similar
difficulty and similar length.
or the miners will be attracted to the chain easier to mine,
and more miners will make the chain generation rate increase and then,
after difficulty adjustment, harder to mine.
Equilibrium will be achieved.

All the above are based on one assumption: the two chains have the same
value initially or miners believe they will  have  the same value finally.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/7828930b/attachment-0001.html>

From greg at xiph.org  Tue Jan 23 01:05:44 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 01:05:44 +0000
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAMZUoK=ffKHM9WN=zrSME5y904u6ZYsfnCpeT_BYT=5Z+NxYsw@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
	<d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
	<CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
	<CAMZUoK=ffKHM9WN=zrSME5y904u6ZYsfnCpeT_BYT=5Z+NxYsw@mail.gmail.com>
Message-ID: <CAAS2fgQFu3FW+zE+bHOKQT0jFCWk+9LncPfQw+5uvMXZAYahiQ@mail.gmail.com>

On Mon, Jan 22, 2018 at 7:21 PM, Russell O'Connor
<roconnor at blockstream.io> wrote:
> At this point, is it better just to use GF(2^256+n)?  Is GF(2^256+n) going
> to be that much slower than GF(2^8) that we care to make things this
> complicated?  (I honestly don't know the answer.)

I expect it would be especially since operations must be implemented
in sidechannel resistant manners.

Also, binary extension fields are doing to have linear subgroup
properties where leaking part of elements wouldn't be good. Not as
obviously broken as the example I gave above, but still in the domain
of "get chunks of a lot of a supra threshold set of shares, and setup
a latices basis problem that can provide an efficient subspace to
search".

From greg at xiph.org  Tue Jan 23 00:30:06 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 00:30:06 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
Message-ID: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>

Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two main
areas: efficiency and privacy. Efficiency because unexecuted forks of
a script can avoid ever hitting the chain, and privacy because hiding
unexecuted code leaves scripts indistinguishable to the extent that
their only differences are in the unexecuted parts.

As Mark Friedenbach and others have pointed out before it is almost
always the case that interesting scripts have a logical top level
branch which allows satisfaction of the contract with nothing other
than a signature by all parties.  Other branches would only be used
where some participant is failing to cooperate. More strongly stated,
I believe that _any_ contract with a fixed finite participant set
upfront can be and should be represented as an OR between an N-of-N
and whatever more complex contract you might want to represent.

One point that comes up while talking about merkelized scripts is can
we go about making fancier contract use cases as indistinguishable as
possible from the most common and boring payments. Otherwise, if the
anonymity set of fancy usage is only other fancy usage it may not be
very large in practice. One suggestion has been that ordinary
checksig-only scripts should include a dummy branch for the rest of
the tree (e.g. a random value hash), making it look like there are
potentially alternative rules when there aren't really.  The negative
side of this is an additional 32-byte overhead for the overwhelmingly
common case which doesn't need it.  I think the privacy gains are
worth doing such a thing, but different people reason differently
about these trade-offs.

It turns out, however, that there is no need to make a trade-off.  The
special case of a top level "threshold-signature OR
arbitrary-conditions" can be made indistinguishable from a normal
one-party signature, with no overhead at all, with a special
delegating CHECKSIG which I call Taproot.

Let's say we want to create a coin that can be redeemed by either
Alice && Bob   or by CSV-timelock && Bob.

Alice has public A, Bob has pubkey B.

We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to
protect against rogue key attacks you may want to use the MuSig key
aggregation function [1])

We form our timelock script S =  "<timeout> OP_CSV OP_DROP B OP_CHECKSIGVERIFY"

Now we tweak C to produce P which is the key we'll publish: P = C + H(C||S)G.

(This is the attack hardened pay-to-contract construction described in [2])

Then we pay to a scriptPubKey of [Taproot supporting version] [EC point P].

Now Alice and Bob-- assuming they are both online and agree about the
resolution of their contract-- can jointly form a 2 of 2 signature for
P, and spend as if it were a payment to a single party (one of them
just needs to add H(C||S) to their private key).

Alternatively, the Taproot consensus rules would allow this script to
be satisfied by someone who provides the network with C (the original
combined pubkey), S, and does whatever S requires-- e.g. passes the
CSV check and provides Bob's signature. With this information the
network can verify that C + H(C||S) == P.

So in the all-sign case there is zero overhead; and no one can tell
that the contract alternative exists. In the alternative redemption
branch the only overhead is revealing the original combined pubkey
and, of course, the existence of the contract is made public.

This composes just fine with whatever other merkelized script system
we might care to use, as the S can be whatever kind of data we want,
including the root of some tree.

My example shows 2-of-2 but it works the same for any number of
participants (and with setup interaction any threshold of
participants, so long as you don't mind an inability to tell which
members signed off).

The verification computational complexity of signature path is
obviously the same as any other plain signature (since its
indistinguishable). Verification of the branch redemption requires a
hash and a multiplication with a constant point which is strictly more
efficient than a signature verification and could be efficiently fused
into batch signature validation.

The nearest competitor to this idea that I can come up with would
supporting a simple delegation where the output can be spent by the
named key, or a spending transaction could provide a script along with
a signature of that script by the named key, delegating control to the
signed script. Before paying into that escrow Alice/Bob would
construct this signature. This idea is equally efficient in the common
case, but larger and slower to verify in the alternative spend case.
Setting up the signature requires additional interaction between
participants and the resulting signature must be durably stored and
couldn't just be recomputed using single-party information.

I believe this construction will allow the largest possible anonymity
set for fixed party smart contracts by making them look like the
simplest possible payments. It accomplishes this without any overhead
in the common case, invoking any sketchy or impractical techniques,
requiring extra rounds of interaction between contract participants,
and without requiring the durable storage of other data.


[1] https://eprint.iacr.org/2018/068
[2] https://blockstream.com/sidechains.pdf Appendix A

From belcher at riseup.net  Tue Jan 23 01:55:07 2018
From: belcher at riseup.net (Chris Belcher)
Date: Tue, 23 Jan 2018 01:55:07 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
Message-ID: <95bca986-2251-8216-31b3-0bf123369fd8@riseup.net>

This sounds like a useful idea for improving the privacy of coinswap.
Traditionally coinswap mixing had an anonymity set related to the number
of multisig transactions being used on the blockchain. With the new tech
of Schnorr, MAST and now this Taproot, with sufficient adoption
coinswap's anonymity set could be much higher, potentially including
almost every other on-chain transaction.

[1] https://bitcointalk.org/index.php?topic=321228.0
[2] https://github.com/AdamISZ/CoinSwapCS

On 23/01/18 00:30, Gregory Maxwell via bitcoin-dev wrote:
> Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two main
> areas: efficiency and privacy. Efficiency because unexecuted forks of
> a script can avoid ever hitting the chain, and privacy because hiding
> unexecuted code leaves scripts indistinguishable to the extent that
> their only differences are in the unexecuted parts.
> 
> As Mark Friedenbach and others have pointed out before it is almost
> always the case that interesting scripts have a logical top level
> branch which allows satisfaction of the contract with nothing other
> than a signature by all parties.  Other branches would only be used
> where some participant is failing to cooperate. More strongly stated,
> I believe that _any_ contract with a fixed finite participant set
> upfront can be and should be represented as an OR between an N-of-N
> and whatever more complex contract you might want to represent.
> 
> One point that comes up while talking about merkelized scripts is can
> we go about making fancier contract use cases as indistinguishable as
> possible from the most common and boring payments. Otherwise, if the
> anonymity set of fancy usage is only other fancy usage it may not be
> very large in practice. One suggestion has been that ordinary
> checksig-only scripts should include a dummy branch for the rest of
> the tree (e.g. a random value hash), making it look like there are
> potentially alternative rules when there aren't really.  The negative
> side of this is an additional 32-byte overhead for the overwhelmingly
> common case which doesn't need it.  I think the privacy gains are
> worth doing such a thing, but different people reason differently
> about these trade-offs.
> 
> It turns out, however, that there is no need to make a trade-off.  The
> special case of a top level "threshold-signature OR
> arbitrary-conditions" can be made indistinguishable from a normal
> one-party signature, with no overhead at all, with a special
> delegating CHECKSIG which I call Taproot.
> 
> Let's say we want to create a coin that can be redeemed by either
> Alice && Bob   or by CSV-timelock && Bob.
> 
> Alice has public A, Bob has pubkey B.
> 
> We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to
> protect against rogue key attacks you may want to use the MuSig key
> aggregation function [1])
> 
> We form our timelock script S =  "<timeout> OP_CSV OP_DROP B OP_CHECKSIGVERIFY"
> 
> Now we tweak C to produce P which is the key we'll publish: P = C + H(C||S)G.
> 
> (This is the attack hardened pay-to-contract construction described in [2])
> 
> Then we pay to a scriptPubKey of [Taproot supporting version] [EC point P].
> 
> Now Alice and Bob-- assuming they are both online and agree about the
> resolution of their contract-- can jointly form a 2 of 2 signature for
> P, and spend as if it were a payment to a single party (one of them
> just needs to add H(C||S) to their private key).
> 
> Alternatively, the Taproot consensus rules would allow this script to
> be satisfied by someone who provides the network with C (the original
> combined pubkey), S, and does whatever S requires-- e.g. passes the
> CSV check and provides Bob's signature. With this information the
> network can verify that C + H(C||S) == P.
> 
> So in the all-sign case there is zero overhead; and no one can tell
> that the contract alternative exists. In the alternative redemption
> branch the only overhead is revealing the original combined pubkey
> and, of course, the existence of the contract is made public.
> 
> This composes just fine with whatever other merkelized script system
> we might care to use, as the S can be whatever kind of data we want,
> including the root of some tree.
> 
> My example shows 2-of-2 but it works the same for any number of
> participants (and with setup interaction any threshold of
> participants, so long as you don't mind an inability to tell which
> members signed off).
> 
> The verification computational complexity of signature path is
> obviously the same as any other plain signature (since its
> indistinguishable). Verification of the branch redemption requires a
> hash and a multiplication with a constant point which is strictly more
> efficient than a signature verification and could be efficiently fused
> into batch signature validation.
> 
> The nearest competitor to this idea that I can come up with would
> supporting a simple delegation where the output can be spent by the
> named key, or a spending transaction could provide a script along with
> a signature of that script by the named key, delegating control to the
> signed script. Before paying into that escrow Alice/Bob would
> construct this signature. This idea is equally efficient in the common
> case, but larger and slower to verify in the alternative spend case.
> Setting up the signature requires additional interaction between
> participants and the resulting signature must be durably stored and
> couldn't just be recomputed using single-party information.
> 
> I believe this construction will allow the largest possible anonymity
> set for fixed party smart contracts by making them look like the
> simplest possible payments. It accomplishes this without any overhead
> in the common case, invoking any sketchy or impractical techniques,
> requiring extra rounds of interaction between contract participants,
> and without requiring the durable storage of other data.
> 
> 
> [1] https://eprint.iacr.org/2018/068
> [2] https://blockstream.com/sidechains.pdf Appendix A
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

From lf-lists at mattcorallo.com  Tue Jan 23 02:51:51 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 23 Jan 2018 02:51:51 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
Message-ID: <61C1114D-A4E3-4628-AB7E-17C09EDDC2DE@mattcorallo.com>

Thanks Greg!

I'd be hesitant to deploy a MAST proposal without this clever application of pay-to-contract-hash now! Looks like the overhead over a more-naive MAST construction is rather trivial, too!

Matt

On January 23, 2018 12:30:06 AM UTC, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two main
>areas: efficiency and privacy. Efficiency because unexecuted forks of
>a script can avoid ever hitting the chain, and privacy because hiding
>unexecuted code leaves scripts indistinguishable to the extent that
>their only differences are in the unexecuted parts.
>
>As Mark Friedenbach and others have pointed out before it is almost
>always the case that interesting scripts have a logical top level
>branch which allows satisfaction of the contract with nothing other
>than a signature by all parties.  Other branches would only be used
>where some participant is failing to cooperate. More strongly stated,
>I believe that _any_ contract with a fixed finite participant set
>upfront can be and should be represented as an OR between an N-of-N
>and whatever more complex contract you might want to represent.
>
>One point that comes up while talking about merkelized scripts is can
>we go about making fancier contract use cases as indistinguishable as
>possible from the most common and boring payments. Otherwise, if the
>anonymity set of fancy usage is only other fancy usage it may not be
>very large in practice. One suggestion has been that ordinary
>checksig-only scripts should include a dummy branch for the rest of
>the tree (e.g. a random value hash), making it look like there are
>potentially alternative rules when there aren't really.  The negative
>side of this is an additional 32-byte overhead for the overwhelmingly
>common case which doesn't need it.  I think the privacy gains are
>worth doing such a thing, but different people reason differently
>about these trade-offs.
>
>It turns out, however, that there is no need to make a trade-off.  The
>special case of a top level "threshold-signature OR
>arbitrary-conditions" can be made indistinguishable from a normal
>one-party signature, with no overhead at all, with a special
>delegating CHECKSIG which I call Taproot.
>
>Let's say we want to create a coin that can be redeemed by either
>Alice && Bob   or by CSV-timelock && Bob.
>
>Alice has public A, Bob has pubkey B.
>
>We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to
>protect against rogue key attacks you may want to use the MuSig key
>aggregation function [1])
>
>We form our timelock script S =  "<timeout> OP_CSV OP_DROP B
>OP_CHECKSIGVERIFY"
>
>Now we tweak C to produce P which is the key we'll publish: P = C +
>H(C||S)G.
>
>(This is the attack hardened pay-to-contract construction described in
>[2])
>
>Then we pay to a scriptPubKey of [Taproot supporting version] [EC point
>P].
>
>Now Alice and Bob-- assuming they are both online and agree about the
>resolution of their contract-- can jointly form a 2 of 2 signature for
>P, and spend as if it were a payment to a single party (one of them
>just needs to add H(C||S) to their private key).
>
>Alternatively, the Taproot consensus rules would allow this script to
>be satisfied by someone who provides the network with C (the original
>combined pubkey), S, and does whatever S requires-- e.g. passes the
>CSV check and provides Bob's signature. With this information the
>network can verify that C + H(C||S) == P.
>
>So in the all-sign case there is zero overhead; and no one can tell
>that the contract alternative exists. In the alternative redemption
>branch the only overhead is revealing the original combined pubkey
>and, of course, the existence of the contract is made public.
>
>This composes just fine with whatever other merkelized script system
>we might care to use, as the S can be whatever kind of data we want,
>including the root of some tree.
>
>My example shows 2-of-2 but it works the same for any number of
>participants (and with setup interaction any threshold of
>participants, so long as you don't mind an inability to tell which
>members signed off).
>
>The verification computational complexity of signature path is
>obviously the same as any other plain signature (since its
>indistinguishable). Verification of the branch redemption requires a
>hash and a multiplication with a constant point which is strictly more
>efficient than a signature verification and could be efficiently fused
>into batch signature validation.
>
>The nearest competitor to this idea that I can come up with would
>supporting a simple delegation where the output can be spent by the
>named key, or a spending transaction could provide a script along with
>a signature of that script by the named key, delegating control to the
>signed script. Before paying into that escrow Alice/Bob would
>construct this signature. This idea is equally efficient in the common
>case, but larger and slower to verify in the alternative spend case.
>Setting up the signature requires additional interaction between
>participants and the resulting signature must be durably stored and
>couldn't just be recomputed using single-party information.
>
>I believe this construction will allow the largest possible anonymity
>set for fixed party smart contracts by making them look like the
>simplest possible payments. It accomplishes this without any overhead
>in the common case, invoking any sketchy or impractical techniques,
>requiring extra rounds of interaction between contract participants,
>and without requiring the durable storage of other data.
>
>
>[1] https://eprint.iacr.org/2018/068
>[2] https://blockstream.com/sidechains.pdf Appendix A
>_______________________________________________
>bitcoin-dev mailing list
>bitcoin-dev at lists.linuxfoundation.org
>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/2ff10ec6/attachment-0001.html>

From eric at voskuil.org  Tue Jan 23 04:57:46 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 22 Jan 2018 20:57:46 -0800
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
 (Chaofan Li)
In-Reply-To: <CANZDnNoGnab6HYESA0oOL-8Q8HtR1Ns0AfP3KNEmwU6KN5W5pA@mail.gmail.com>
References: <CANZDnNoGnab6HYESA0oOL-8Q8HtR1Ns0AfP3KNEmwU6KN5W5pA@mail.gmail.com>
Message-ID: <16b2ea77-3ff5-81b1-d3d7-a7107f4b37fc@voskuil.org>

On 01/22/2018 04:38 PM, Chaofan Li via bitcoin-dev wrote:
> Miners are most likely to be? equally distributed between the two almost
> same chains.

This is irrelevant as miners don't determine the utility of a money,
they anticipate it. However you don't have to accept this to recognize
the error of the argument below...

> If one chain is faster, according to the difficulty adjustment scheme,
> it will become more difficult to mine.

Mining difficulty controls the block period, not miner return on capital.

> The two chain should have similar chain generation rates with similar
> difficulty and similar length.

This is the consequence of the presumed common regulation of the block
period. It matters not how useful are either of the monies.

> or the miners will be attracted to the chain easier to mine,?
> and more miners will make the chain generation rate increase and then,
> after difficulty adjustment, harder to mine.

You are conflating difficulty with profitability. These are not the same
thing. A chain can be more difficult and less profitable and the
reverse. Profitability is controlled by competition, as it is in all
markets. Competition is controlled by the cost of capital, which is in
turn controlled by time preference. Mining seeks the same level of
profitability for any coin, regardless of how difficultly. This applies
to all industry - difficulty does not regulate profit, it's just a cost.

> Equilibrium will be achieved.> All the above are based on one assumption: the two chains have the same
> value initially or miners believe they will? have? the same value finally.

Actually the opposite is the case. Even if we could start at a point of
perfect equality, the smallest change in the number of merchants or
human perception of the money (as examples), would lead one to be
slightly better. All things being equal that alone would lead to
elimination of one money in favor of the other.

One money is inherently better than two, as there is an exchange cost
between them. In the absence of exchange controls the better money gets
used, and in this case that can simply be the result of a slightly
larger network (or perception of it).

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180122/ed6da88f/attachment.sig>

From li3939108 at gmail.com  Tue Jan 23 05:47:27 2018
From: li3939108 at gmail.com (Chaofan Li)
Date: Tue, 23 Jan 2018 05:47:27 +0000
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
	(Chaofan Li)
In-Reply-To: <16b2ea77-3ff5-81b1-d3d7-a7107f4b37fc@voskuil.org>
References: <CANZDnNoGnab6HYESA0oOL-8Q8HtR1Ns0AfP3KNEmwU6KN5W5pA@mail.gmail.com>
	<16b2ea77-3ff5-81b1-d3d7-a7107f4b37fc@voskuil.org>
Message-ID: <CANZDnNo29+9jezspt8sRaq8WpUjLghkQ0Ubvxb6=_2nuOs-frw@mail.gmail.com>

The human perception of difference will be eliminated.
Will your bank tell you whether your balance means coins or paper money?
If wallets and exchanges only show the total amount of btc rather than
btc.0 and btc.1, there is no human perception difference.

Also note that one valid address is automatically valid on the other chain,
which means you can send money through any one chain. As long as one has
the private key, he/she can get the money anyway. So there is no difference
between number of merchants. The merchant ?s address is valid on both
chains.

The exchange cost would be trivial. People don?t need to exchange two same
thing.

Chaofan



On Mon, Jan 22, 2018 at 10:57 PM Eric Voskuil <eric at voskuil.org> wrote:

> On 01/22/2018 04:38 PM, Chaofan Li via bitcoin-dev wrote:
> > Miners are most likely to be  equally distributed between the two almost
> > same chains.
>
> This is irrelevant as miners don't determine the utility of a money,
> they anticipate it. However you don't have to accept this to recognize
> the error of the argument below...
>
> > If one chain is faster, according to the difficulty adjustment scheme,
> > it will become more difficult to mine.
>
> Mining difficulty controls the block period, not miner return on capital.
>
> > The two chain should have similar chain generation rates with similar
> > difficulty and similar length.
>
> This is the consequence of the presumed common regulation of the block
> period. It matters not how useful are either of the monies.
>
> > or the miners will be attracted to the chain easier to mine,
> > and more miners will make the chain generation rate increase and then,
> > after difficulty adjustment, harder to mine.
>
> You are conflating difficulty with profitability. These are not the same
> thing. A chain can be more difficult and less profitable and the
> reverse. Profitability is controlled by competition, as it is in all
> markets. Competition is controlled by the cost of capital, which is in
> turn controlled by time preference. Mining seeks the same level of
> profitability for any coin, regardless of how difficultly. This applies
> to all industry - difficulty does not regulate profit, it's just a cost.
>
> > Equilibrium will be achieved.> All the above are based on one
> assumption: the two chains have the same
> > value initially or miners believe they will  have  the same value
> finally.
>
> Actually the opposite is the case. Even if we could start at a point of
> perfect equality, the smallest change in the number of merchants or
> human perception of the money (as examples), would lead one to be
> slightly better. All things being equal that alone would lead to
> elimination of one money in favor of the other.
>
> One money is inherently better than two, as there is an exchange cost
> between them. In the absence of exchange controls the better money gets
> used, and in this case that can simply be the result of a slightly
> larger network (or perception of it).
>
> e
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/16978647/attachment.html>

From aj at erisian.com.au  Tue Jan 23 06:44:19 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Tue, 23 Jan 2018 16:44:19 +1000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
Message-ID: <20180123064419.GA1296@erisian.com.au>

On Tue, Jan 23, 2018 at 12:30:06AM +0000, Gregory Maxwell via bitcoin-dev wrote:
> One point that comes up while talking about merkelized scripts is can
> we go about making fancier contract use cases as indistinguishable as
> possible from the most common and boring payments.

> Now we tweak C to produce P which is the key we'll publish: P = C + H(C||S)G.
> (This is the attack hardened pay-to-contract construction described in [2])
> Then we pay to a scriptPubKey of [Taproot supporting version] [EC point P].

Is this really intended as paying directly to a pubkey, instead of a
pubkey hash?

If so, isn't that a step backwards with regard to resistance to quantum
attacks against ECC?

Paying direct to pubkey doesn't seem quite enough to make pay-to-taproot
cheaper than p2wpkh: the extra 12 bytes in the scriptPubKey would need
you to reduce the witness by 48 bytes to maintain the weight, but I think
you'd only be saving 33 bytes by not having to reveal the pubkey, and
another 6-7 bytes by having a tighter signature encoding than DER. Still,
that's pretty close with a difference of only a couple of vbytes per
input by my count.

If it were "pay-to-taproot-hash", then presuming taproot hashes were 256
bit, then p2wpkh would be a full 12 vbytes cheaper due to the shorter
hash. That might make it hard to maximise the anonymity set. I suppose
a small penalty/discount could be added to align the economic incentives
though.

I wonder how this interacts with segwit versioning. I think you'd want
to have taproot be versioned overall so that you could cope with moving
to a new signing method (different curve, or something non-ECC based)
eventually, and segwit versioning will handle that already; but maybe
it would also be a good idea to also have "S" include a version, that
could be bumped to add new features to script, but left hidden within
the hash so that the fact you're using new (or old) features is only
revealed when it has to be.

Those nits aside, this seems great.

Cheers,
aj


From greg at xiph.org  Tue Jan 23 13:15:38 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 13:15:38 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <20180123064419.GA1296@erisian.com.au>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
Message-ID: <CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>

On Tue, Jan 23, 2018 at 6:44 AM, Anthony Towns <aj at erisian.com.au> wrote:
> Is this really intended as paying directly to a pubkey, instead of a
> pubkey hash?
>
> If so, isn't that a step backwards with regard to resistance to quantum
> attacks against ECC?

You're reading too much into a description of the idea. It's not a BIP
or a spec; I tried to provide enough details to make the general idea
concrete. I didn't dive into details or optimizations (for example,
you can use this with a "no EC redemption path" by special casing
empty C as the point at infinity, and you'd have an output that was
indistinguishable until spend... yadda yadda).

Considering the considerable level of address reuse -- I recall prior
stats that a majority of circulating funds are on addresses that had
previously been used, on top of the general race limitations-- I am
now dubious to the idea that hashing provides any kind of meaningful
quantum resistance and somewhat regret introducing that meme to the
space in the first place. If we considered quantum resistance a
meaningful concern we should address that specifically.  --- so I
don't think that should be a factor that drives a decision here.

When collision resistance is needed (as I think it clearly is for
taproot) you don't get a space savings in the txout from hashing, so
there is an argument to use the public key directly at least... but
it's worth considering.  Direct SPK use is also adventitious for being
able to efficiently ZKP over the UTXO set, e.g. for private solvency
proofs, but it isn't absolutely mandatory for that (one can hash
inside the proof, but it's slower).

From ondrej.vejpustek at satoshilabs.com  Tue Jan 23 13:54:48 2018
From: ondrej.vejpustek at satoshilabs.com (=?UTF-8?Q?Ond=c5=99ej_Vejpustek?=)
Date: Tue, 23 Jan 2018 14:54:48 +0100
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
	<d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
	<CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
Message-ID: <bf402c77-cfdd-f38d-43a9-23f1c3273b9d@satoshilabs.com>

> Yes, this scheme.
> https://bitcointalk.org/index.php?topic=311000.msg3342217#msg3342217

In addition to the scheme, I found out, that Makwa
(https://www.bolet.org/makwa/), a hashing function which received a
special recognition in the Password Hashing Competition, supports a
delegation. In fact, Makwa is similar to the suggested scheme.

Unfortunately, both schemes have two drawbacks:
  (1) There is no proof that the host computes what he's suppose to do.
  (2) The delegation is far more slower than the normal computation.
According to the Makwa paper
(https://www.bolet.org/makwa/makwa-spec-20150422.pdf) the delegation is
typically 100 to 1000 slower. So I see little advantage in delegating.

I doubt there is a scheme that suits our needs.

From adam.back at gmail.com  Tue Jan 23 14:16:22 2018
From: adam.back at gmail.com (Adam Back)
Date: Tue, 23 Jan 2018 06:16:22 -0800
Subject: [bitcoin-dev] Satoshilabs secret shared private key scheme
In-Reply-To: <bf402c77-cfdd-f38d-43a9-23f1c3273b9d@satoshilabs.com>
References: <51280a45-f86b-3191-d55e-f34e880c1da8@satoshilabs.com>
	<CAAS2fgRQk4EUp6FO2f+RkJpDTyZX0N4=uGp7ZF=0aUchZX8hSA@mail.gmail.com>
	<4003eed1-584f-9773-8cf9-6300ebd1eac6@satoshilabs.com>
	<CAAS2fgSw0mAQPJ-ai-3kFr7pWXd7pjbrEoXN4r6Ak3o4c8_vjw@mail.gmail.com>
	<d6eb0fc3-d729-30cb-986b-b1d7b8aacbd6@satoshilabs.com>
	<CAAS2fgQtf_LDDcWDmvM+kjPCSqaQVwVd2rKWVtho4-XSAHpJZQ@mail.gmail.com>
	<bf402c77-cfdd-f38d-43a9-23f1c3273b9d@satoshilabs.com>
Message-ID: <CALqxMTGq6Z6sh0oTuJrU=toCj0c+WJbSQQxhJkNtZuthRUtPog@mail.gmail.com>

Makwa sites [1] https://bitcointalk.org/index.php?topic=311000.0

Seems like they independently rediscovered it.

Adam


On 23 January 2018 at 05:54, Ond?ej Vejpustek via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Yes, this scheme.
>> https://bitcointalk.org/index.php?topic=311000.msg3342217#msg3342217
>
> In addition to the scheme, I found out, that Makwa
> (https://www.bolet.org/makwa/), a hashing function which received a
> special recognition in the Password Hashing Competition, supports a
> delegation. In fact, Makwa is similar to the suggested scheme.
>
> Unfortunately, both schemes have two drawbacks:
>   (1) There is no proof that the host computes what he's suppose to do.
>   (2) The delegation is far more slower than the normal computation.
> According to the Makwa paper
> (https://www.bolet.org/makwa/makwa-spec-20150422.pdf) the delegation is
> typically 100 to 1000 slower. So I see little advantage in delegating.
>
> I doubt there is a scheme that suits our needs.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

From mark at friedenbach.org  Tue Jan 23 14:39:37 2018
From: mark at friedenbach.org (Mark Friedenbach)
Date: Tue, 23 Jan 2018 06:39:37 -0800
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <61C1114D-A4E3-4628-AB7E-17C09EDDC2DE@mattcorallo.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<61C1114D-A4E3-4628-AB7E-17C09EDDC2DE@mattcorallo.com>
Message-ID: <285E52DF-04E8-4E03-85A0-764F54B3EED9@friedenbach.org>

I had the opposite response in private, which I will share here. As recently as Jan 9th feedback on BIP 117 was shared on this list by Pieter Wuille and others suggesting we adopt native MAST template instead of the user programmable combination of BIPs 116 and 117. Part of my response then was, I quote:

I havent the hubris to suggest that we know exactly what a templated MAST *should* look like. It's not used in production anywhere. Even if we did have the foresight, the tail-call semantics allow for other constructions besides MAST and for the sake of the future we should allow such permission-less innovation. The proper sequence of events should be to enable features in a generic way, and then to create specialized templates to save space for common constructions. Not the other way around. [1]

I take this advance as further evidence in favor of this view. As recently as 24 hours ago if you had asked what a native-MAST template would have looked like, the answer would have been something like Johnson Lau?s BIP 114, with some quibbling over details. Taproot is a clearly superior approach. But is it optimal? I don?t think we can claim that now. Optimality of these constructs isn?t something easily proven, with the nearest substitute being unchanging consensus over extended periods of time.

Every time we add an output type specialization, we introduce a new codepath in the core of the script consensus that must be maintained forever. Take P2SH: from this point forward there is no reason to use it in new applications, ever. But it must be forever supported. In an alternate universe we could have deployed a native MAST proposal, like BIP 114, only to have Taproot-like schemes discovered after activation. That would have been a sucky outcome. It is still the case that we could go for Taproot right now, and then in six months or a year?s time we find an important tweak or a different approach entirely that is even better, but the activation process had already started. That would be a sucky outcome we haven?t avoided yet.

This is not an argument against template specialization for common code paths, especially those which increase fungibility of coins. I do think we should have a native MAST template eventually, using Taproot or something better. However if I may be allowed I will make an educated guess about the origin of Taproot: I think it?s no coincidence that Greg had this insight and/or wrote it up simultaneous with a push by myself and others for getting MAST features into bitcoin via BIPs 98, 116, and 117, or 114. Cryptographers tend to only think up solutions to problems that are on their minds. And the problems on most people?s minds are primarily those that are deployable today, or otherwise near-term applicable.

BIPS 116 and 117 each provide a reusable component that together happens to enable a generic form of MAST. Even without the workarounds required to avoid CLEANSTACK violations, the resulting MAST template is larger than what is possible with specialization. However let?s not forget that (1) they also enable other applications like honeypots, key trees, and script delegation; and relevant to this conversation (2) they get the MAST feature available for use in production by the wider community. I don?t think I?d personally be willing to bet that we found the optimal MAST structure in Greg?s Taproot until we have people doing interesting production work like multisig wallets, lightning protocol, and the next set of consensus features start putting it into production and exploring edge cases. We may find ways Taproot can be tweaked to enable other applications (like encoding a hash preimage as well) or simplify obscure corner cases.

I feel quite strongly that the correct approach is to add support for generic features to accomplish the underlying goal in a user programmable way, and THEN after activation and some usage consider ways in which common use cases can be made more efficient through output specialization. To take a more obvious example, lightning protocol is still an active area or research and I think it is abundantly clear that we don?t know yet what the globally optimal layer-2 caching protocol will be, even if we have educated guesses as to its broad structure. A proposal right now to standardize a more compact lightning script type would be rightly rejected. It is less obvious but just as true that the same should hold for MAST.

I have argued these points before in favor of permission less innovation first, then application specialization later, in [1] and at the end of the rather long email [2]. I hope you can take the time to read those if you still feel we should take a specialized template approach instead of the user programmable BIPSs 116 and 117.

[1] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015537.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015537.html>
[2] https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015029.html <https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015029.html>

> On Jan 22, 2018, at 6:51 PM, Matt Corallo via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> 
> Thanks Greg!
> 
> I'd be hesitant to deploy a MAST proposal without this clever application of pay-to-contract-hash now! Looks like the overhead over a more-naive MAST construction is rather trivial, too!
> 
> Matt
> 
> On January 23, 2018 12:30:06 AM UTC, Gregory Maxwell via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
> Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two main
> areas: efficiency and privacy. Efficiency because unexecuted forks of
> a script can avoid ever hitting the chain, and privacy because hiding
> unexecuted code leaves scripts indistinguishable to the extent that
> their only differences are in the unexecuted parts.
> 
> As Mark Friedenbach and others have pointed out before it is almost
> always the case that interesting scripts have a logical top level
> branch which allows satisfaction of the contract with nothing other
> than a signature by all parties.  Other branches would only be used
> where some participant is failing to cooperate. More strongly stated,
> I believe that _any_ contract with a fixed finite participant set
> upfront can be and should be represented as an OR between an N-of-N
> and whatever more complex contract you might want to represent.
> 
> One point that comes up while talking about merkelized scripts is can
> we go about making fancier contract use cases as indistinguishable as
> possible from the most common and boring payments. Otherwise, if the
> anonymity set of fancy usage is only other fancy usage it may not be
> very large in practice. One suggestion has been that ordinary
> checksig-only scripts should include a dummy branch for the rest of
> the tree (e.g. a random value hash), making it look like there are
> potentially alternative rules when there aren't really.  The negative
> side of this is an additional 32-byte overhead for the overwhelmingly
> common case which doesn't need it.  I think the privacy gains are
> worth doing such a thing, but different people reason differently
> about these trade-offs.
> 
> It turns out, however, that there is no need to make a trade-off.  The
> special case of a top level "threshold-signature OR
> arbitrary-conditions" can be made indistinguishable from a normal
> one-party signature, with no overhead at all, with a special
> delegating CHECKSIG which I call Taproot.
> 
> Let's say we want to create a coin that can be redeemed by either
> Alice && Bob   or by CSV-timelock && Bob.
> 
> Alice has public A, Bob has pubkey B.
> 
> We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to
> protect against rogue key attacks you may want to use the MuSig key
> aggregation function [1])
> 
> We form our timelock script S =  "<timeout> OP_CSV OP_DROP B OP_CHECKSIGVERIFY"
> 
> Now we tweak C to produce P which is the key we'll publish: P = C + H(C||S)G.
> 
> (This is the attack hardened pay-to-contract construction described in [2])
> 
> Then we pay to a scriptPubKey of [Taproot supporting version] [EC point P].
> 
> Now Alice and Bob-- assuming they are both online and agree about the
> resolution of their contract-- can jointly form a 2 of 2 signature for
> P, and spend as if it were a payment to a single party (one of them
> just needs to add H(C||S) to their private key).
> 
> Alternatively, the Taproot consensus rules would allow this script to
> be satisfied by someone who provides the network with C (the original
> combined pubkey), S, and does whatever S requires-- e.g. passes the
> CSV check and provides Bob's signature. With this information the
> network can verify that C + H(C||S) == P.
> 
> So in the all-sign case there is zero overhead; and no one can tell
> that the contract alternative exists. In the alternative redemption
> branch the only overhead is revealing the original combined pubkey
> and, of course, the existence of the contract is made public.
> 
> This composes just fine with whatever other merkelized script system
> we might care to use, as the S can be whatever kind of data we want,
> including the root of some tree.
> 
> My example shows 2-of-2 but it works the same for any number of
> participants (and with setup interaction any threshold of
> participants, so long as you don't mind an inability to tell which
> members signed off).
> 
> The verification computational complexity of signature path is
> obviously the same as any other plain signature (since its
> indistinguishable). Verification of the branch redemption requires a
> hash and a multiplication with a constant point which is strictly more
> efficient than a signature verification and could be efficiently fused
> into batch signature validation.
> 
> The nearest competitor to this idea that I can come up with would
> supporting a simple delegation where the output can be spent by the
> named key, or a spending transaction could provide a script along with
> a signature of that script by the named key, delegating control to the
> signed script. Before paying into that escrow Alice/Bob would
> construct this signature. This idea is equally efficient in the common
> case, but larger and slower to verify in the alternative spend case.
> Setting up the signature requires additional interaction between
> participants and the resulting signature must be durably stored and
> couldn't just be recomputed using single-party information.
> 
> I believe this construction will allow the largest possible anonymity
> set for fixed party smart contracts by making them look like the
> simplest possible payments. It accomplishes this without any overhead
> in the common case, invoking any sketchy or impractical techniques,
> requiring extra rounds of interaction between contract participants,
> and without requiring the durable storage of other data.
> 
> 
> [1] https://eprint.iacr.org/2018/068 <https://eprint.iacr.org/2018/068>
> [2] https://blockstream.com/sidechains.pdf <https://blockstream.com/sidechains.pdf> Appendix A
> 
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/3b3b7dd0/attachment-0001.html>

From gsanders87 at gmail.com  Tue Jan 23 15:43:59 2018
From: gsanders87 at gmail.com (Greg Sanders)
Date: Tue, 23 Jan 2018 10:43:59 -0500
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
Message-ID: <CAB3F3DuzJv3COKHP2q3o9zSViRU08wRd+9MQ6vB0qLMzSQNPTw@mail.gmail.com>

Interesting parallels to current Elements sidechain peg-in functionality.
User tweaks the watchmen(BTC holder) pubkey using P2CH, committing to a
script that is used on the *sidechain side* as spending authorization for
that bitcoin output rather than mainnet.

I think composing the two can be done as:

P = C' + H(C'||S')G + H(C||S)G

where C is redefined as `C' + H(C'||S')G`, which for Bitcoin consensus
purposes is just a single pubkey.



On Mon, Jan 22, 2018 at 7:30 PM, Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two main
> areas: efficiency and privacy. Efficiency because unexecuted forks of
> a script can avoid ever hitting the chain, and privacy because hiding
> unexecuted code leaves scripts indistinguishable to the extent that
> their only differences are in the unexecuted parts.
>
> As Mark Friedenbach and others have pointed out before it is almost
> always the case that interesting scripts have a logical top level
> branch which allows satisfaction of the contract with nothing other
> than a signature by all parties.  Other branches would only be used
> where some participant is failing to cooperate. More strongly stated,
> I believe that _any_ contract with a fixed finite participant set
> upfront can be and should be represented as an OR between an N-of-N
> and whatever more complex contract you might want to represent.
>
> One point that comes up while talking about merkelized scripts is can
> we go about making fancier contract use cases as indistinguishable as
> possible from the most common and boring payments. Otherwise, if the
> anonymity set of fancy usage is only other fancy usage it may not be
> very large in practice. One suggestion has been that ordinary
> checksig-only scripts should include a dummy branch for the rest of
> the tree (e.g. a random value hash), making it look like there are
> potentially alternative rules when there aren't really.  The negative
> side of this is an additional 32-byte overhead for the overwhelmingly
> common case which doesn't need it.  I think the privacy gains are
> worth doing such a thing, but different people reason differently
> about these trade-offs.
>
> It turns out, however, that there is no need to make a trade-off.  The
> special case of a top level "threshold-signature OR
> arbitrary-conditions" can be made indistinguishable from a normal
> one-party signature, with no overhead at all, with a special
> delegating CHECKSIG which I call Taproot.
>
> Let's say we want to create a coin that can be redeemed by either
> Alice && Bob   or by CSV-timelock && Bob.
>
> Alice has public A, Bob has pubkey B.
>
> We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to
> protect against rogue key attacks you may want to use the MuSig key
> aggregation function [1])
>
> We form our timelock script S =  "<timeout> OP_CSV OP_DROP B
> OP_CHECKSIGVERIFY"
>
> Now we tweak C to produce P which is the key we'll publish: P = C +
> H(C||S)G.
>
> (This is the attack hardened pay-to-contract construction described in [2])
>
> Then we pay to a scriptPubKey of [Taproot supporting version] [EC point P].
>
> Now Alice and Bob-- assuming they are both online and agree about the
> resolution of their contract-- can jointly form a 2 of 2 signature for
> P, and spend as if it were a payment to a single party (one of them
> just needs to add H(C||S) to their private key).
>
> Alternatively, the Taproot consensus rules would allow this script to
> be satisfied by someone who provides the network with C (the original
> combined pubkey), S, and does whatever S requires-- e.g. passes the
> CSV check and provides Bob's signature. With this information the
> network can verify that C + H(C||S) == P.
>
> So in the all-sign case there is zero overhead; and no one can tell
> that the contract alternative exists. In the alternative redemption
> branch the only overhead is revealing the original combined pubkey
> and, of course, the existence of the contract is made public.
>
> This composes just fine with whatever other merkelized script system
> we might care to use, as the S can be whatever kind of data we want,
> including the root of some tree.
>
> My example shows 2-of-2 but it works the same for any number of
> participants (and with setup interaction any threshold of
> participants, so long as you don't mind an inability to tell which
> members signed off).
>
> The verification computational complexity of signature path is
> obviously the same as any other plain signature (since its
> indistinguishable). Verification of the branch redemption requires a
> hash and a multiplication with a constant point which is strictly more
> efficient than a signature verification and could be efficiently fused
> into batch signature validation.
>
> The nearest competitor to this idea that I can come up with would
> supporting a simple delegation where the output can be spent by the
> named key, or a spending transaction could provide a script along with
> a signature of that script by the named key, delegating control to the
> signed script. Before paying into that escrow Alice/Bob would
> construct this signature. This idea is equally efficient in the common
> case, but larger and slower to verify in the alternative spend case.
> Setting up the signature requires additional interaction between
> participants and the resulting signature must be durably stored and
> couldn't just be recomputed using single-party information.
>
> I believe this construction will allow the largest possible anonymity
> set for fixed party smart contracts by making them look like the
> simplest possible payments. It accomplishes this without any overhead
> in the common case, invoking any sketchy or impractical techniques,
> requiring extra rounds of interaction between contract participants,
> and without requiring the durable storage of other data.
>
>
> [1] https://eprint.iacr.org/2018/068
> [2] https://blockstream.com/sidechains.pdf Appendix A
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/ded288f9/attachment.html>

From ronald at vandermeer.frl  Tue Jan 23 19:40:42 2018
From: ronald at vandermeer.frl (Ronald van der Meer)
Date: Tue, 23 Jan 2018 19:40:42 +0000
Subject: [bitcoin-dev] Suggestion to remove word from BIP39
	English	wordlist
In-Reply-To: <CALPhJayvtBra2GhAXAJkrCBtQeXu-+jj-uUtQB4zWYmbcuS4gA@mail.gmail.com>
References: <CAJoTrhbeVFdW+-zhVYi3vQqmsmi0aFNmcvvcJk7WYnWNYg4UTQ@mail.gmail.com>
	<CALPhJayvtBra2GhAXAJkrCBtQeXu-+jj-uUtQB4zWYmbcuS4gA@mail.gmail.com>
Message-ID: <HE1PR0301MB1915391234785F1963D11A49A3E30@HE1PR0301MB1915.eurprd03.prod.outlook.com>

I?m new to this so what is the next step?

--
Ronald van der Meer

E: ronald at vandermeer.frl<mailto:ronald at vandermeer.frl> | W: https://www.vandermeer.frl
S: https://twitter.com/truly_secure

GPG: 8203 CE3E 064D C462 1D22 F635 A1EC 45F9 645F 878D



From: bitcoin-dev-bounces at lists.linuxfoundation.org [mailto:bitcoin-dev-bounces at lists.linuxfoundation.org] On Behalf Of Alan Evans via bitcoin-dev
Sent: donderdag 18 januari 2018 22:29
To: Matthew Clancy <matthewpclancy at gmail.com>
Cc: Bitcoin Protocol Discussion <bitcoin-dev at lists.linuxfoundation.org>
Subject: Re: [bitcoin-dev] Suggestion to remove word from BIP39 English wordlist


> and then agree that by convention,  the words 'satoshi' or the alternative word will represent the same number on the list

That convention would be the alternative to BIP0039 I am referring to.


On Thu, Jan 18, 2018 at 4:49 PM, Matthew Clancy <matthewpclancy at gmail.com<mailto:matthewpclancy at gmail.com>> wrote:
I would disagree here:

>But most of all:
>7. Removing a word or changing a list *is impossible* as verification of an
>existing mnemonic requires the list. To change one word, you would need to
>provide an alternative to BIP0039 to cope with alternative words, or change
>all the words to a completely new set of 2048 English words so that it is
>clear which wordlist is in use.

All that really would need to be done is select another word that is not on the 2048 list, and then agree that by convention,  the words 'satoshi' or the alternative word will represent the same number on the list. It seems to be to be a fairly simple thing to implement.



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/2d79c60f/attachment-0001.html>

From rhavar at protonmail.com  Tue Jan 23 16:31:36 2018
From: rhavar at protonmail.com (Rhavar)
Date: Tue, 23 Jan 2018 11:31:36 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <20180122200023.GA1055@savin.petertodd.org>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
Message-ID: <7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>

Getting back on topic:

> It would definitely introduce DoS vectors by making it much cheaper to use
> relay bandwidth.

I think I'm missing something, as I don't really understand this DoS vector. Relay bandwidth is already very cheap and easy to use by repeatedly fee bumping. And it's not obvious to me that requiring an absolute higher fee actually makes such an attack more expensive.

I can see that my "proposed" change would make it cheaper to evict low-fee transactions from other node's mempool. Maybe I'm being naive, but I don't really see why this would be such a big deal.

But what about a compromise, and require that the absolute fee must be >= half the original fees. I know everyone hates magic values, but I think in practice it will allow legitimate and useful use of "retroactive transaction merging" without much downside.

And really the great thing about "retroactive transaction merging" is just how easy it is to implement. In fact, right now it's quite possible to do -- but because of the "higher absolute fee" rule the benefits are pretty muted (although if you can compress 2 change into 1, that's still likely worthwhile)

-Ryan

-------- Original Message --------
On January 22, 2018 3:00 PM, Peter Todd <pete at petertodd.org> wrote:

> On Mon, Jan 22, 2018 at 12:40:31PM -0500, Rhavar via bitcoin-dev wrote:
>
>> So my half-baked idea is very simple:
>> Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.
>> This is currently not possible because of the bip125 rule:
>> "The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."
>> Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.
>> I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?
>
> It would definitely introduce DoS vectors by making it much cheaper to use
> relay bandwidth. You'd also be able to push others' txs out of the mempool.
>
>> ---------------------------------------------------------------
>>
>> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.
>> From a "coin selection" point of view, this was significantly easier than
>> I had anticipated. I was able to encode the rules in my linear model and
>> feed in all my unspent and in-flight transactions and it can solve it without difficulty.
>> However, the real problem is tracking the mess. Consider this sequence of events:
>>
>> - I have unconfirmed transaction A
>> - I replace it with B, which pays John 1 BTC
>> - Transaction A gets confirmed
>>
>> So now I still owe John 1 BTC, however it's not immediately clear if
>> it's safe to send to him without waiting $n transactions. However even
>> for a small $n, this breaks my promise to pay him immediately.
>> One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.
>> However, this will only work <50% of the time for me (most transactions
>> don't have change) and opens a pandora's box of complexity.
>
> Most transactions don't have change?! Under what circumstance? For most
> use-cases the reverse is true: almost all all transactions have change, because
> it's rare for the inputs to exactly math the requested payment.
>
> https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/aada91c2/attachment.html>

From lf-lists at mattcorallo.com  Tue Jan 23 21:23:21 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Tue, 23 Jan 2018 21:23:21 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <285E52DF-04E8-4E03-85A0-764F54B3EED9@friedenbach.org>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<61C1114D-A4E3-4628-AB7E-17C09EDDC2DE@mattcorallo.com>
	<285E52DF-04E8-4E03-85A0-764F54B3EED9@friedenbach.org>
Message-ID: <EC722F53-3D41-4309-8942-7B27E4DA6EAA@mattcorallo.com>

The issue with that approach without support for the privacy-encouraging wrapper proposed by Greg here is that it encourages adoption halfway and destroys a lot of the value of the apparent-script monoculture for privacy preservation. Greg's proposal here doesn't change the format of any specific MAST implementation, but instead adds the privacy wrapper that I always felt was missing in existing proposals, without any real additional overhead in many use-cases!

Indeed, permissionless innovation is important, but the huge advantage of providing the privacy wrapper by default here is absolutely massive to the ecosystem and should not be handwaved away for vague possibly-advantages.

Matt

On January 23, 2018 2:39:37 PM UTC, Mark Friedenbach <mark at friedenbach.org> wrote:
>I had the opposite response in private, which I will share here. As
>recently as Jan 9th feedback on BIP 117 was shared on this list by
>Pieter Wuille and others suggesting we adopt native MAST template
>instead of the user programmable combination of BIPs 116 and 117. Part
>of my response then was, I quote:
>
>I havent the hubris to suggest that we know exactly what a templated
>MAST *should* look like. It's not used in production anywhere. Even if
>we did have the foresight, the tail-call semantics allow for other
>constructions besides MAST and for the sake of the future we should
>allow such permission-less innovation. The proper sequence of events
>should be to enable features in a generic way, and then to create
>specialized templates to save space for common constructions. Not the
>other way around. [1]
>
>I take this advance as further evidence in favor of this view. As
>recently as 24 hours ago if you had asked what a native-MAST template
>would have looked like, the answer would have been something like
>Johnson Lau?s BIP 114, with some quibbling over details. Taproot is a
>clearly superior approach. But is it optimal? I don?t think we can
>claim that now. Optimality of these constructs isn?t something easily
>proven, with the nearest substitute being unchanging consensus over
>extended periods of time.
>
>Every time we add an output type specialization, we introduce a new
>codepath in the core of the script consensus that must be maintained
>forever. Take P2SH: from this point forward there is no reason to use
>it in new applications, ever. But it must be forever supported. In an
>alternate universe we could have deployed a native MAST proposal, like
>BIP 114, only to have Taproot-like schemes discovered after activation.
>That would have been a sucky outcome. It is still the case that we
>could go for Taproot right now, and then in six months or a year?s time
>we find an important tweak or a different approach entirely that is
>even better, but the activation process had already started. That would
>be a sucky outcome we haven?t avoided yet.
>
>This is not an argument against template specialization for common code
>paths, especially those which increase fungibility of coins. I do think
>we should have a native MAST template eventually, using Taproot or
>something better. However if I may be allowed I will make an educated
>guess about the origin of Taproot: I think it?s no coincidence that
>Greg had this insight and/or wrote it up simultaneous with a push by
>myself and others for getting MAST features into bitcoin via BIPs 98,
>116, and 117, or 114. Cryptographers tend to only think up solutions to
>problems that are on their minds. And the problems on most people?s
>minds are primarily those that are deployable today, or otherwise
>near-term applicable.
>
>BIPS 116 and 117 each provide a reusable component that together
>happens to enable a generic form of MAST. Even without the workarounds
>required to avoid CLEANSTACK violations, the resulting MAST template is
>larger than what is possible with specialization. However let?s not
>forget that (1) they also enable other applications like honeypots, key
>trees, and script delegation; and relevant to this conversation (2)
>they get the MAST feature available for use in production by the wider
>community. I don?t think I?d personally be willing to bet that we found
>the optimal MAST structure in Greg?s Taproot until we have people doing
>interesting production work like multisig wallets, lightning protocol,
>and the next set of consensus features start putting it into production
>and exploring edge cases. We may find ways Taproot can be tweaked to
>enable other applications (like encoding a hash preimage as well) or
>simplify obscure corner cases.
>
>I feel quite strongly that the correct approach is to add support for
>generic features to accomplish the underlying goal in a user
>programmable way, and THEN after activation and some usage consider
>ways in which common use cases can be made more efficient through
>output specialization. To take a more obvious example, lightning
>protocol is still an active area or research and I think it is
>abundantly clear that we don?t know yet what the globally optimal
>layer-2 caching protocol will be, even if we have educated guesses as
>to its broad structure. A proposal right now to standardize a more
>compact lightning script type would be rightly rejected. It is less
>obvious but just as true that the same should hold for MAST.
>
>I have argued these points before in favor of permission less
>innovation first, then application specialization later, in [1] and at
>the end of the rather long email [2]. I hope you can take the time to
>read those if you still feel we should take a specialized template
>approach instead of the user programmable BIPSs 116 and 117.
>
>[1]
>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015537.html
><https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015537.html>
>[2]
>https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015029.html
><https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015029.html>
>
>> On Jan 22, 2018, at 6:51 PM, Matt Corallo via bitcoin-dev
><bitcoin-dev at lists.linuxfoundation.org> wrote:
>> 
>> Thanks Greg!
>> 
>> I'd be hesitant to deploy a MAST proposal without this clever
>application of pay-to-contract-hash now! Looks like the overhead over a
>more-naive MAST construction is rather trivial, too!
>> 
>> Matt
>> 
>> On January 23, 2018 12:30:06 AM UTC, Gregory Maxwell via bitcoin-dev
><bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Interest in merkelized scriptPubKeys (e.g. MAST) is driven by two
>main
>> areas: efficiency and privacy. Efficiency because unexecuted forks of
>> a script can avoid ever hitting the chain, and privacy because hiding
>> unexecuted code leaves scripts indistinguishable to the extent that
>> their only differences are in the unexecuted parts.
>> 
>> As Mark Friedenbach and others have pointed out before it is almost
>> always the case that interesting scripts have a logical top level
>> branch which allows satisfaction of the contract with nothing other
>> than a signature by all parties.  Other branches would only be used
>> where some participant is failing to cooperate. More strongly stated,
>> I believe that _any_ contract with a fixed finite participant set
>> upfront can be and should be represented as an OR between an N-of-N
>> and whatever more complex contract you might want to represent.
>> 
>> One point that comes up while talking about merkelized scripts is can
>> we go about making fancier contract use cases as indistinguishable as
>> possible from the most common and boring payments. Otherwise, if the
>> anonymity set of fancy usage is only other fancy usage it may not be
>> very large in practice. One suggestion has been that ordinary
>> checksig-only scripts should include a dummy branch for the rest of
>> the tree (e.g. a random value hash), making it look like there are
>> potentially alternative rules when there aren't really.  The negative
>> side of this is an additional 32-byte overhead for the overwhelmingly
>> common case which doesn't need it.  I think the privacy gains are
>> worth doing such a thing, but different people reason differently
>> about these trade-offs.
>> 
>> It turns out, however, that there is no need to make a trade-off. 
>The
>> special case of a top level "threshold-signature OR
>> arbitrary-conditions" can be made indistinguishable from a normal
>> one-party signature, with no overhead at all, with a special
>> delegating CHECKSIG which I call Taproot.
>> 
>> Let's say we want to create a coin that can be redeemed by either
>> Alice && Bob   or by CSV-timelock && Bob.
>> 
>> Alice has public A, Bob has pubkey B.
>> 
>> We compute the 2-of-2 aggregate key C = A + B.  (Simplified; to
>> protect against rogue key attacks you may want to use the MuSig key
>> aggregation function [1])
>> 
>> We form our timelock script S =  "<timeout> OP_CSV OP_DROP B
>OP_CHECKSIGVERIFY"
>> 
>> Now we tweak C to produce P which is the key we'll publish: P = C +
>H(C||S)G.
>> 
>> (This is the attack hardened pay-to-contract construction described
>in [2])
>> 
>> Then we pay to a scriptPubKey of [Taproot supporting version] [EC
>point P].
>> 
>> Now Alice and Bob-- assuming they are both online and agree about the
>> resolution of their contract-- can jointly form a 2 of 2 signature
>for
>> P, and spend as if it were a payment to a single party (one of them
>> just needs to add H(C||S) to their private key).
>> 
>> Alternatively, the Taproot consensus rules would allow this script to
>> be satisfied by someone who provides the network with C (the original
>> combined pubkey), S, and does whatever S requires-- e.g. passes the
>> CSV check and provides Bob's signature. With this information the
>> network can verify that C + H(C||S) == P.
>> 
>> So in the all-sign case there is zero overhead; and no one can tell
>> that the contract alternative exists. In the alternative redemption
>> branch the only overhead is revealing the original combined pubkey
>> and, of course, the existence of the contract is made public.
>> 
>> This composes just fine with whatever other merkelized script system
>> we might care to use, as the S can be whatever kind of data we want,
>> including the root of some tree.
>> 
>> My example shows 2-of-2 but it works the same for any number of
>> participants (and with setup interaction any threshold of
>> participants, so long as you don't mind an inability to tell which
>> members signed off).
>> 
>> The verification computational complexity of signature path is
>> obviously the same as any other plain signature (since its
>> indistinguishable). Verification of the branch redemption requires a
>> hash and a multiplication with a constant point which is strictly
>more
>> efficient than a signature verification and could be efficiently
>fused
>> into batch signature validation.
>> 
>> The nearest competitor to this idea that I can come up with would
>> supporting a simple delegation where the output can be spent by the
>> named key, or a spending transaction could provide a script along
>with
>> a signature of that script by the named key, delegating control to
>the
>> signed script. Before paying into that escrow Alice/Bob would
>> construct this signature. This idea is equally efficient in the
>common
>> case, but larger and slower to verify in the alternative spend case.
>> Setting up the signature requires additional interaction between
>> participants and the resulting signature must be durably stored and
>> couldn't just be recomputed using single-party information.
>> 
>> I believe this construction will allow the largest possible anonymity
>> set for fixed party smart contracts by making them look like the
>> simplest possible payments. It accomplishes this without any overhead
>> in the common case, invoking any sketchy or impractical techniques,
>> requiring extra rounds of interaction between contract participants,
>> and without requiring the durable storage of other data.
>> 
>> 
>> [1] https://eprint.iacr.org/2018/068
><https://eprint.iacr.org/2018/068>
>> [2] https://blockstream.com/sidechains.pdf
><https://blockstream.com/sidechains.pdf> Appendix A
>> 
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
><https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/d1e58bc1/attachment-0001.html>

From greg at xiph.org  Tue Jan 23 21:31:00 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 21:31:00 +0000
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <20180122200023.GA1055@savin.petertodd.org>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
Message-ID: <CAAS2fgSJ=2GaX-fNRyZhwD=g6=v524hnD-dCqJicC-ak+La4PA@mail.gmail.com>

On Mon, Jan 22, 2018 at 8:00 PM, Peter Todd via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Most transactions don't have change?! Under what circumstance? For most
> use-cases the reverse is true: almost all all transactions have change, because
> it's rare for the inputs to exactly math the requested payment.

It's quite easy to get no change with a not-dumb algorithm selecting
coins if you have a decent number of outputs well under the value
you're paying.

The number of ways n choose m combines grows exponentially, and you
only need to get close enough over the right value so that you're
paying excess fees equal or less than the cost of the change (which
should include the current cost output itself as well as estimated
cost of the future signature to spend it).

Achow101 and Murch have code to implement an efficient algorithm for
finding these solutions for Bitcoin core which will hopefully get in
soon.

From greg at xiph.org  Tue Jan 23 21:38:13 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 21:38:13 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <EC722F53-3D41-4309-8942-7B27E4DA6EAA@mattcorallo.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<61C1114D-A4E3-4628-AB7E-17C09EDDC2DE@mattcorallo.com>
	<285E52DF-04E8-4E03-85A0-764F54B3EED9@friedenbach.org>
	<EC722F53-3D41-4309-8942-7B27E4DA6EAA@mattcorallo.com>
Message-ID: <CAAS2fgSBQCov3YUSHXO6b8RX54382AH2_u_hAAZgivDqH3SHTA@mail.gmail.com>

On Tue, Jan 23, 2018 at 9:23 PM, Matt Corallo via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> The issue with that approach without support for the privacy-encouraging
> wrapper proposed by Greg here is that it encourages adoption halfway and
> destroys a lot of the value of the apparent-script monoculture for privacy
> preservation. Greg's proposal here doesn't change the format of any specific
> MAST implementation, but instead adds the privacy wrapper that I always felt
> was missing in existing proposals, without any real additional overhead in
> many use-cases!
>
> Indeed, permissionless innovation is important, but the huge advantage of
> providing the privacy wrapper by default here is absolutely massive to the
> ecosystem and should not be handwaved away for vague possibly-advantages.

Even if to someone who didn't care about anyone's privacy at all,
non-taproot is simply inefficient.  In the (I argue) overwhelmingly
common case of everyone-agrees simple hash based branching requires a
30% overhead to communicate the commitment to the untaken branch (and
worse in the case of extensive aggregation).  I don't think an
argument can be sustained in favor of that kind of communications
overhead.

From ethan.scruples at gmail.com  Tue Jan 23 21:56:41 2018
From: ethan.scruples at gmail.com (Moral Agent)
Date: Tue, 23 Jan 2018 16:56:41 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
Message-ID: <CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>

Another way to limit abuse would be to have the fee *rate* be required to
increase, which is kind of the spirit of RBF, applied to this situation.

That is to say, if you wished to replace transactions A and B with C which
spends the same inputs as A and B, then the following must be true before C
will be relayed:

(Fee_A + Fee_B) / (Weight_A + Weight_B) < Fee_C / Weight_C

On Tue, Jan 23, 2018 at 11:31 AM, Rhavar via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> Getting back on topic:
>
>
> It would definitely introduce DoS vectors by making it much cheaper to use
> relay bandwidth.
>
>
> I think I'm missing something, as I don't really understand this DoS
> vector. Relay bandwidth is already very cheap and easy to use by repeatedly
> fee bumping. And it's not obvious to me that requiring an absolute higher
> fee actually makes such an attack more expensive.
>
> I can see that my "proposed" change would make it cheaper to evict low-fee
> transactions from other node's mempool. Maybe I'm being naive, but I don't
> really see why this would be such a big deal.
>
> But what about a compromise, and require that the absolute fee must be >=
> half the original fees. I know everyone hates magic values, but I think in
> practice it will allow legitimate and useful use of "retroactive
> transaction merging" without much downside.
>
> And really the great thing about "retroactive transaction merging" is just
> how easy it is to implement. In fact, right now it's quite possible to do
> -- but because of the "higher absolute fee" rule the benefits are pretty
> muted (although if you can compress 2 change into 1, that's still likely
> worthwhile)
>
>
>
> -Ryan
>
>
> -------- Original Message --------
> On January 22, 2018 3:00 PM, Peter Todd <pete at petertodd.org> wrote:
>
> On Mon, Jan 22, 2018 at 12:40:31PM -0500, Rhavar via bitcoin-dev wrote:
>
> So my half-baked idea is very simple:
> Allow users to merge multiple unconfirmed transactions, stripping
> extraneous inputs and change as they go.
> This is currently not possible because of the bip125 rule:
> "The replacement transaction pays an absolute fee of at least the sum paid
> by the original transactions."
> Because the size of the merged transaction is smaller than the original
> transactions, unless there is a considerable feerate bump, this rule isn't
> possible to observe.
> I my question is: is it possible or reasonable to relax this rule? If this
> rule was removed in its entirety, does it introduce any DoS vectors? Or can
> it be changed to allow my use-case?
>
>
> It would definitely introduce DoS vectors by making it much cheaper to use
> relay bandwidth. You'd also be able to push others' txs out of the mempool.
>
>
> ------------------------------
>
> Full backstory: I have been trying to use bip125 (Opt-in Full
> Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I
> owe John 1 bitcoin, and have promised to pay him immediately: Instead of
> creating a whole new transaction if I have an in-flight (unconfirmed)
> transaction, I can follow the rules of bip125 to create a replacement that
> accomplishes this goal.
> From a "coin selection" point of view, this was significantly easier than
> I had anticipated. I was able to encode the rules in my linear model and
> feed in all my unspent and in-flight transactions and it can solve it
> without difficulty.
> However, the real problem is tracking the mess. Consider this sequence of
> events:
>
>    1. I have unconfirmed transaction A
>    2. I replace it with B, which pays John 1 BTC
>    3. Transaction A gets confirmed
>
> So now I still owe John 1 BTC, however it's not immediately clear if
> it's safe to send to him without waiting $n transactions. However even
> for a small $n, this breaks my promise to pay him immediately.
> One possible solution is to only consider a transaction "replaceable" if
> it has change, so if the original transaction confirms -- payments can
> immediately be made that source the change, and provide safety in a reorg.
> However, this will only work <50% of the time for me (most transactions
> don't have change) and opens a pandora's box of complexity.
>
>
> Most transactions don't have change?! Under what circumstance? For most
> use-cases the reverse is true: almost all all transactions have change,
> because
> it's rare for the inputs to exactly math the requested payment.
>
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/bded9fb7/attachment.html>

From john at chaincode.com  Tue Jan 23 21:56:50 2018
From: john at chaincode.com (John Newbery)
Date: Tue, 23 Jan 2018 16:56:50 -0500
Subject: [bitcoin-dev] BIP16 enforcement change in V0.16
Message-ID: <CAMPtzUdcQxOktwhHe602Y7xDTsAYT0LoSY1iLBYSTnb=k8Y08A@mail.gmail.com>

The upcoming v0.16 release contains a slight change to the way that BIP16
is enforced, by basing activation on block height instead of block time.
This brings BIP 16 enforcement in line with BIP 34, BIP 66 and BIP 65.

This has no impact on consensus since BIP 16 was activated before the last
checkpoint and is buried under >300,000 blocks.

I've written up the changes in the BIP style below, although I don't think
this necessarily requires a full BIP. BIP 16 enforcement will likely change
again with https://github.com/bitcoin/bitcoin/pull/11739 in the next
bitcoin core release, so a formal proposal for this as a BIP will quickly
be superseded.

<pre>
  BIP: ??
  Layer: Consensus
  Title: Buried Deployments (P2SH)
  Author: John Newbery <john at chaincode.com>
  Comments-Summary: No comments yet
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????
  Status: Draft
  Type: Informational
  Created: 2018-01-22
  License: CC-0
</pre>


==Abstract==

Enforce BIP 16 consensus rules based on block height rather than block time.

==Background==

BIP 16 was deployed via a hardcoded flag day consensus rule change. Prior
to the date of the consensus rule change being fixed, the miners signaled
readiness for the change by placing the string "/P2SH/" in the scriptSig of
the coinbase transaction txIn. The rule change was originally intended to
come into effect on 15 Feb 2012, but due to lack of miner signaling, the
activation date was pushed back to April 1st 2012. See [
https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki The BIP 16
specification] for full details on the deployment method. The final
activation method was via a hardcoded block time of 1333238400 (April 1st
2012).

Now that the chain has long since passed the block at which the P2SH
consensus rule was activated, we can (as a simplification) replace the
trigger mechanism by caching the block height at which those consensus
rules became enforced.

==Motivation==

Activating the BIP 16 consensus change based on block time has several
disadvantages:

* The consensus change can be activated and later deactivated in the same
chain (since block time is not necessarily monotonically increasing).
* It is less flexible for constructing test chains for testing P2SH and
other soft fork activation

The flag day activation mechanism for code deployments was deprecated in
favor of [https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki
IsSuperMajority] deployments, and later by [
https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki version
bits] deployments.

BIP 34, BIP 65, and BIP 66 deployments were later 'buried' by [
https://github.com/bitcoin/bips/blob/master/bip-0090.mediawiki BIP 90] with
simple height checks. This simplification of the consensus rules reduced
the technical debt associated with deployment of those consensus changes.

This BIP changes the BIP 16 activation method to also be a 'buried'
deployment, activating at the block height that BIP 16 actually activated.
For the mainnet chain, this is block height 173805.

==Considerations==

Just as for the buried BIP 34, BIP 65 and BIP 66 deployments, it is
technically possible for this to be a non-backwards compatible change. For
example, if an alternate chain were created in which block height 173805
was reached after April 1st 2012, and a block with height <173805 but block
time after April 1st 2012 included an invalid P2SH spend, older software
would see that chain as invalid, but newer software implementing this
change would not.

See [https://github.com/bitcoin/bips/blob/master/bip-0090.mediawiki BIP 90]
for justification of why this class of change is acceptable. As of January
2018, BIP 16 is buried by over 300,000 blocks. BIP 16 activation is also
protected by checkpoints (the most recent of which is at height 295000).

==Specification==

The BIP 16 activation height is set to 173805.

To determine whether to enforce BIP 16 on a given block, we just compare
the height of the block being validated with the stored activation height:

    // Start enforcing P2SH (BIP16)
    if (pindex->nHeight >= consensusparams.BIP16Height) {
        flags |= SCRIPT_VERIFY_P2SH;
    }

See the implementation for additional details.

==Implementation==

https://github.com/bitcoin/bitcoin/commit/18e071841e83044b47aa45c3e98c0796a407d445

==Acknowledgements==

Thanks to Russ Yanofsky, Marco Falke and Suhas Daftuar for suggestions and
feedback.

==Copyright==

This document is placed in the public domain.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/79e117ee/attachment-0001.html>

From aj at erisian.com.au  Tue Jan 23 22:22:29 2018
From: aj at erisian.com.au (Anthony Towns)
Date: Wed, 24 Jan 2018 08:22:29 +1000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
Message-ID: <20180123222229.GA3801@erisian.com.au>

On Tue, Jan 23, 2018 at 01:15:38PM +0000, Gregory Maxwell wrote:
> On Tue, Jan 23, 2018 at 6:44 AM, Anthony Towns <aj at erisian.com.au> wrote:
> > Is this really intended as paying directly to a pubkey, instead of a
> > pubkey hash?
> > If so, isn't that a step backwards with regard to resistance to quantum
> > attacks against ECC?
> Considering the considerable level of address reuse -- I recall prior
> stats that a majority of circulating funds are on addresses that had
> previously been used, on top of the general race limitations-- I am
> now dubious to the idea that hashing provides any kind of meaningful
> quantum resistance and somewhat regret introducing that meme to the
> space in the first place. If we considered quantum resistance a
> meaningful concern we should address that specifically.  --- so I
> don't think that should be a factor that drives a decision here.

Hmm, at least people can choose not to reuse addresses currently --
if everyone were using taproot and that didn't involve hashing the key,
there would be no way for individuals to hedge against quantum attacks
in case they're ever feasible, at least that I can see (well, without
moving their funds out of bitcoin anyway)?

Even "X + H(X|script)g" with X being a random point would end up
attackable, since that would almost always end up corresponding with a
valid public key that a successful attack could then find a private key
for.

(It seems like using the point at infinity wouldn't work because 
P = 0+H(0||S)g = H(0||S)g, so as soon as you tried to spend it via S,
someone watching the mempool would know H(0||S), which is the secret key
for P, and be able to spend it via the pubkey path -- no quantum crypto
needed. Or am I missing something?)

Also, if the people currently reusing addresses tend to cycle the funds
through fairly quickly anyway, they might be able to simply stop doing
that when quantum attacks start approaching feasibility. If funds are
being held in reused addresses over the long term, that would be more
of a problem though...

> When collision resistance is needed (as I think it clearly is for
> taproot) you don't get a space savings in the txout from hashing, so
> there is an argument to use the public key directly at least... but
> it's worth considering.  Direct SPK use is also adventitious for being
> able to efficiently ZKP over the UTXO set, e.g. for private solvency
> proofs, but it isn't absolutely mandatory for that (one can hash
> inside the proof, but it's slower).

Yeah, that was one of the assumptions for
http://www.jbonneau.com/doc/DBBCB15-CCS-provisions.pdf iirc. 

(Also, pretty sure you mean "advantageous", but at least I learnt a new
word today)

Cheers,
aj


From rhavar at protonmail.com  Tue Jan 23 22:19:59 2018
From: rhavar at protonmail.com (Rhavar)
Date: Tue, 23 Jan 2018 17:19:59 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
Message-ID: <oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>

Interesting. I didn't think about this before, but it seems like bip125 is rather incentive incompatible right now? If we're assuming a competitive mempool, it really doesn't seem generally rational to accept a replacement transaction of a lower fee rate.

So how about if we change the fee requirement to bet at least:

MIN(
         $ORIGINAL_FEE_RATE * $REPLACEMENT_TX_SIZE + $RELAY_FEE * ( REPLACEMENT_TX_SIZE + $ORIGINAL_SIZE),
        $ORIGINAL_ABS_FEE  / 3
)  in fees

This could make it:
* More incentive compatible
* Support more use-cases (my transaction merging example)
* Be resistant to any attacks (that I can see, there's no doubt cases I haven't thought about)

-Ryan

-------- Original Message --------
On January 23, 2018 4:56 PM, Moral Agent <ethan.scruples at gmail.com> wrote:

> Another way to limit abuse would be to have the fee *rate* be required to increase, which is kind of the spirit of RBF, applied to this situation.
>
> That is to say, if you wished to replace transactions A and B with C which spends the same inputs as A and B, then the following must be true before C will be relayed:
>
> (Fee_A + Fee_B) / (Weight_A + Weight_B) < Fee_C / Weight_C
>
> On Tue, Jan 23, 2018 at 11:31 AM, Rhavar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>> Getting back on topic:
>>
>>> It would definitely introduce DoS vectors by making it much cheaper to use
>>> relay bandwidth.
>>
>> I think I'm missing something, as I don't really understand this DoS vector. Relay bandwidth is already very cheap and easy to use by repeatedly fee bumping. And it's not obvious to me that requiring an absolute higher fee actually makes such an attack more expensive.
>>
>> I can see that my "proposed" change would make it cheaper to evict low-fee transactions from other node's mempool. Maybe I'm being naive, but I don't really see why this would be such a big deal.
>>
>> But what about a compromise, and require that the absolute fee must be >= half the original fees. I know everyone hates magic values, but I think in practice it will allow legitimate and useful use of "retroactive transaction merging" without much downside.
>>
>> And really the great thing about "retroactive transaction merging" is just how easy it is to implement. In fact, right now it's quite possible to do -- but because of the "higher absolute fee" rule the benefits are pretty muted (although if you can compress 2 change into 1, that's still likely worthwhile)
>>
>> -Ryan
>>
>> -------- Original Message --------
>> On January 22, 2018 3:00 PM, Peter Todd <pete at petertodd.org> wrote:
>>
>>> On Mon, Jan 22, 2018 at 12:40:31PM -0500, Rhavar via bitcoin-dev wrote:
>>>
>>>> So my half-baked idea is very simple:
>>>> Allow users to merge multiple unconfirmed transactions, stripping extraneous inputs and change as they go.
>>>> This is currently not possible because of the bip125 rule:
>>>> "The replacement transaction pays an absolute fee of at least the sum paid by the original transactions."
>>>> Because the size of the merged transaction is smaller than the original transactions, unless there is a considerable feerate bump, this rule isn't possible to observe.
>>>> I my question is: is it possible or reasonable to relax this rule? If this rule was removed in its entirety, does it introduce any DoS vectors? Or can it be changed to allow my use-case?
>>>
>>> It would definitely introduce DoS vectors by making it much cheaper to use
>>> relay bandwidth. You'd also be able to push others' txs out of the mempool.
>>>
>>>> ---------------------------------------------------------------
>>>> Full backstory: I have been trying to use bip125 (Opt-in Full Replace-by-Fee) to do "transaction merging" on the fly. Let's say that I owe John 1 bitcoin, and have promised to pay him immediately: Instead of creating a whole new transaction if I have an in-flight (unconfirmed) transaction, I can follow the rules of bip125 to create a replacement that accomplishes this goal.
>>>> From a "coin selection" point of view, this was significantly easier than
>>>> I had anticipated. I was able to encode the rules in my linear model and
>>>> feed in all my unspent and in-flight transactions and it can solve it without difficulty.
>>>> However, the real problem is tracking the mess. Consider this sequence of events:
>>>>
>>>> - I have unconfirmed transaction A
>>>> - I replace it with B, which pays John 1 BTC
>>>> - Transaction A gets confirmed
>>>> So now I still owe John 1 BTC, however it's not immediately clear if
>>>> it's safe to send to him without waiting $n transactions. However even
>>>> for a small $n, this breaks my promise to pay him immediately.
>>>> One possible solution is to only consider a transaction "replaceable" if it has change, so if the original transaction confirms -- payments can immediately be made that source the change, and provide safety in a reorg.
>>>> However, this will only work <50% of the time for me (most transactions
>>>> don't have change) and opens a pandora's box of complexity.
>>>
>>> Most transactions don't have change?! Under what circumstance? For most
>>> use-cases the reverse is true: almost all all transactions have change, because
>>> it's rare for the inputs to exactly math the requested payment.
>>>
>>> https://petertodd.org 'peter'[:-1]@petertodd.org
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/42431dec/attachment.html>

From greg at xiph.org  Tue Jan 23 22:45:06 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 22:45:06 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <20180123222229.GA3801@erisian.com.au>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
Message-ID: <CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>

On Tue, Jan 23, 2018 at 10:22 PM, Anthony Towns <aj at erisian.com.au> wrote:
> Hmm, at least people can choose not to reuse addresses currently --
> if everyone were using taproot and that didn't involve hashing the key,

Can you show me a model of quantum computation that is conjectured to
be able to solve the discrete log problem but which would take longer
than fractions of a second to do so? Quantum computation has to occur
within the coherence lifetime of the system.

> way for individuals to hedge against quantum attacks in case they're ever feasible, at least that I can see (well, without moving their funds out of bitcoin anyway)?

By using scriptpubkeys with actual security against quantum computers
instead of snake-oil.

> (It seems like using the point at infinity wouldn't work because

Indeed, that doesn't work.

> that when quantum attacks start approaching feasibility. If funds are
> being held in reused addresses over the long term, that would be more

They are. But I don't believe that is relevant; the attacker would
simply steal the coins on spend.

From greg at xiph.org  Tue Jan 23 22:49:34 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 23 Jan 2018 22:49:34 +0000
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
Message-ID: <CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>

On Tue, Jan 23, 2018 at 10:19 PM, Rhavar via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Interesting. I didn't think about this before, but it seems like bip125 is
> rather incentive incompatible right now? If we're assuming a competitive
> mempool, it really doesn't seem generally rational to accept a replacement
> transaction of a lower fee rate.

BIP125 replacement requires that the fee rate increases.  The text of
the BIP document is written in a confusing way that doesn't make this
clear.

From adam.ficsor73 at gmail.com  Tue Jan 23 23:31:59 2018
From: adam.ficsor73 at gmail.com (Adam Ficsor)
Date: Wed, 24 Jan 2018 00:31:59 +0100
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
Message-ID: <CAEPKjge5unQPES09Bp1ApbLmVXhD+yyCj7J7Z8Djajb3ZQtX_A@mail.gmail.com>

> It's quite easy to get no change with a not-dumb algorithm selecting
coins if you have a decent number of outputs well under the value
you're paying.

I have been playing around quite a lot these lines, too and created some
content that is worth to look at:
https://github.com/nopara73/ZeroLink/#coin-selection
Also, you can try a simpler privacy oriented coin control implementation
with HiddenWallet:
https://medium.com/@nopara73/coin-control-is-must-learn-if-you-care-about-your-privacy-in-bitcoin-33b9a5f224a2

-- 
Best,
?d?m
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/7ad7b524/attachment.html>

From rmcc4444 at gmail.com  Wed Jan 24 00:42:56 2018
From: rmcc4444 at gmail.com (rmcc4444)
Date: Wed, 24 Jan 2018 00:42:56 +0000
Subject: [bitcoin-dev] 2 step confirmation system
Message-ID: <CAMZHxzofEfKyTEYYwjWVCWcJoE-K_skRTTFZ9XGb-WsnUQA6rQ@mail.gmail.com>

I know from speaking to my friends not involved with Bitcoin that two of
their major concerns are as follows:

1. They are afraid if they fat finger the address there is nothing they can
do about it and not get their Bitcoin back.

and/or

2. They would like to at least have the option to use some sort of 2 step
confirmation system when dealing ith people they do not know. For example,
after sending the Bitcoin to a seller they would like to be able to do a
final approval of the tm transaction. If the 2 people involved in the
transaction approve of it within X hours, the coin returns to the original
person. This system would basically act as an escrow.

This 2 step system could work with both of these.

I apologize if this is the incorrect place to post this. I did not know
where else to share these thoughts.

Thanks for your time.



-- 


** This message was likely sent using voice to text. Please ignore any
typos.**
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/8e5ad367/attachment.html>

From apoelstra at wpsoftware.net  Wed Jan 24 01:52:57 2018
From: apoelstra at wpsoftware.net (Andrew Poelstra)
Date: Wed, 24 Jan 2018 01:52:57 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
Message-ID: <20180124015256.GR9082@boulet.lan>

On Tue, Jan 23, 2018 at 10:45:06PM +0000, Gregory Maxwell via bitcoin-dev wrote:
> On Tue, Jan 23, 2018 at 10:22 PM, Anthony Towns <aj at erisian.com.au> wrote:
> > Hmm, at least people can choose not to reuse addresses currently --
> > if everyone were using taproot and that didn't involve hashing the key,
> 
> Can you show me a model of quantum computation that is conjectured to
> be able to solve the discrete log problem but which would take longer
> than fractions of a second to do so? Quantum computation has to occur
> within the coherence lifetime of the system.
> 
> > way for individuals to hedge against quantum attacks in case they're ever feasible, at least that I can see (well, without moving their funds out of bitcoin anyway)?
> 
> By using scriptpubkeys with actual security against quantum computers
> instead of snake-oil.
> 
> > (It seems like using the point at infinity wouldn't work because
> 
> Indeed, that doesn't work.
> 
> > that when quantum attacks start approaching feasibility. If funds are
> > being held in reused addresses over the long term, that would be more
> 
> They are. But I don't believe that is relevant; the attacker would
> simply steal the coins on spend.


Then the system would need to be hardforked to allow spending through a
quantum-resistant ZKP of knowledge of the hashed public key. I expect
that in a post-quantum world there will be demand for such a fork,
especially if we came into such a world through surprise evidence of
a discrete log break.

-- 
Andrew Poelstra
Mathematics Department, Blockstream
Email: apoelstra at wpsoftware.net
Web:   https://www.wpsoftware.net/andrew

"A goose alone, I suppose, can know the loneliness of geese
 who can never find their peace,
 whether north or south or west or east"
       --Joanna Newsom

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/73e08261/attachment.sig>

From rhavar at protonmail.com  Wed Jan 24 02:05:00 2018
From: rhavar at protonmail.com (Rhavar)
Date: Tue, 23 Jan 2018 21:05:00 -0500
Subject: [bitcoin-dev] 2 step confirmation system
In-Reply-To: <CAMZHxzofEfKyTEYYwjWVCWcJoE-K_skRTTFZ9XGb-WsnUQA6rQ@mail.gmail.com>
References: <CAMZHxzofEfKyTEYYwjWVCWcJoE-K_skRTTFZ9XGb-WsnUQA6rQ@mail.gmail.com>
Message-ID: <HPVd4qJfHhnJ-WB8ylitNNd36yCzeg2p1Fh2PqXIapiz_FWUz8FigmXE8iecUqME_Zy0_uSPhQrXjBGBYK8bwrGEPaNQN-UjHVFAav_Dvhw=@protonmail.com>

1. Bitcoin addresses contain a "checksum", which means it's pretty much impossible to fat finger any address. (Note: most altcoins don't seem to do this, so fat-fingering is very much a risk). If you can send to an address, you can be sure there is no mistake.

However, there is a real risk of malware. I see on a daily basis people who send to the *wrong* address, because for example they have malware on their computer which replaces a the intended address with one controlled by the malware author. So verifying you are sending to the correct address is very much still a concern, but there's no risk you type a 2 instead of 3 and send to the wrong place.

2.  Google "bitcoin multisig" and "bitcoin escrow". In the core bitcoin protocol there's a lot of support that enables stuff like that -- but nothing that is really commonly used. I've done some very large deals with bitcoin, with the use of "2 of 3 multisig" (basically 2 of: me, counter-party, arbitrator)  need to sign off on it. However it's a big pain in the ass, with poor tooling and expensive transactions. Unless you're dealing with 100+ bitcoin, it's a lot easier for everyone to just use a trusted (single party) escrow.

-Ryan

-------- Original Message --------
On January 23, 2018 7:42 PM, rmcc4444 via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:

> I know from speaking to my friends not involved with Bitcoin that two of their major concerns are as follows:
>
> 1. They are afraid if they fat finger the address there is nothing they can do about it and not get their Bitcoin back.
>
> and/or
>
> 2. They would like to at least have the option to use some sort of 2 step confirmation system when dealing ith people they do not know. For example, after sending the Bitcoin to a seller they would like to be able to do a final approval of the tm transaction. If the 2 people involved in the transaction approve of it within X hours, the coin returns to the original person. This system would basically act as an escrow.
>
> This 2 step system could work with both of these.
>
> I apologize if this is the incorrect place to post this. I did not know where else to share these thoughts.
>
> Thanks for your time.
>
> --
>
> ** This message was likely sent using voice to text. Please ignore any typos.**
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180123/a3a02516/attachment-0001.html>

From theartlav at gmail.com  Wed Jan 24 03:50:10 2018
From: theartlav at gmail.com (=?UTF-8?B?0JDRgNGC0ZHQvCDQm9C40YLQstC40L3QvtCy0LjRhw==?=)
Date: Wed, 24 Jan 2018 06:50:10 +0300
Subject: [bitcoin-dev] Why is deriving public key from the signature not
	used in Segwit?
Message-ID: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>

Greetings.

I wanted to ask what was the rationale behind still having both public
key and signature in Segwit witness?

As is known for a while, the public key can be derived from the
signature and a quadrant byte, a trick that is successfully used both
in Bitcoin message signing algorithm and in Ethereum transaction
signatures. The later in particular suggests that this is a perfectly
functional and secure alternative.
Leaving out the public key would have saved 33 bytes per signature,
which is quite a lot.

So, the question is - was there a good reason to do it the old way
(security, performance, privacy, something else?), or was it something
that haven't been thought of/considered at the time?

From greg at xiph.org  Wed Jan 24 04:25:28 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 24 Jan 2018 04:25:28 +0000
Subject: [bitcoin-dev] Why is deriving public key from the signature not
 used in Segwit?
In-Reply-To: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
References: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
Message-ID: <CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>

On Wed, Jan 24, 2018 at 3:50 AM, ????? ?????????? via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Greetings.
>
> I wanted to ask what was the rationale behind still having both public
> key and signature in Segwit witness?
>
> As is known for a while, the public key can be derived from the
> signature and a quadrant byte, a trick that is successfully used both
> in Bitcoin message signing algorithm and in Ethereum transaction
> signatures. The later in particular suggests that this is a perfectly
> functional and secure alternative.
> Leaving out the public key would have saved 33 bytes per signature,
> which is quite a lot.
>
> So, the question is - was there a good reason to do it the old way
> (security, performance, privacy, something else?), or was it something
> that haven't been thought of/considered at the time?

It is slow to verify, incompatible with batch validation, doesn't save
space if hashing isn't used, and is potentially patent encumbered.

From pete at petertodd.org  Wed Jan 24 07:28:35 2018
From: pete at petertodd.org (Peter Todd)
Date: Wed, 24 Jan 2018 02:28:35 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <CAAS2fgSJ=2GaX-fNRyZhwD=g6=v524hnD-dCqJicC-ak+La4PA@mail.gmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<CAAS2fgSJ=2GaX-fNRyZhwD=g6=v524hnD-dCqJicC-ak+La4PA@mail.gmail.com>
Message-ID: <20180124072835.GB12767@savin.petertodd.org>

On Tue, Jan 23, 2018 at 09:31:00PM +0000, Gregory Maxwell wrote:
> On Mon, Jan 22, 2018 at 8:00 PM, Peter Todd via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Most transactions don't have change?! Under what circumstance? For most
> > use-cases the reverse is true: almost all all transactions have change, because
> > it's rare for the inputs to exactly math the requested payment.
> 
> It's quite easy to get no change with a not-dumb algorithm selecting
> coins if you have a decent number of outputs well under the value
> you're paying.
> 
> The number of ways n choose m combines grows exponentially, and you
> only need to get close enough over the right value so that you're
> paying excess fees equal or less than the cost of the change (which
> should include the current cost output itself as well as estimated
> cost of the future signature to spend it).
> 
> Achow101 and Murch have code to implement an efficient algorithm for
> finding these solutions for Bitcoin core which will hopefully get in
> soon.

Oh, Bitcoin Core doesn't already do that? I though that was what the (rather
complex) knapsack code was supposed to be doing.

In any case, you're assuming that there actually are a large number of outputs.
That's not likely to be the case in most "consumer-like" use-cases where the
number of deposits into the wallet is relatively low compared to the number of
withdrawls as coins are spent in smaller amounts; that's the pattern most of my
Bitcoin usage follows, particularly as I keep the amount of funds in my hot
wallets low.

Having said that, Rhavar's usage patterns could easily be different; I'd be
completely wrong in the case of a payment service for instance where a large
number of deposits are aggregated into a smaller number of payments; that
use-case happens to be a particularly interesting one for using tx replacement
to add outputs, so my criticism was definitely premature.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/e656471f/attachment.sig>

From pete at petertodd.org  Wed Jan 24 07:44:53 2018
From: pete at petertodd.org (Peter Todd)
Date: Wed, 24 Jan 2018 02:44:53 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
Message-ID: <20180124074453.GC12767@savin.petertodd.org>

On Tue, Jan 23, 2018 at 10:49:34PM +0000, Gregory Maxwell via bitcoin-dev wrote:
> On Tue, Jan 23, 2018 at 10:19 PM, Rhavar via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > Interesting. I didn't think about this before, but it seems like bip125 is
> > rather incentive incompatible right now? If we're assuming a competitive
> > mempool, it really doesn't seem generally rational to accept a replacement
> > transaction of a lower fee rate.
> 
> BIP125 replacement requires that the fee rate increases.  The text of
> the BIP document is written in a confusing way that doesn't make this
> clear.

In fact I considered only requiring an increase in fee rate, based on the
theory that if absolute fee went down, the transaction must be smaller and thus
miners could overall earn more from the additional transactions they could fit
into their block. But to do that properly requires considering whether or not
that's actually true in the particular state the mempool as a whole happens to
be in, so I ditched that idea early on for the much simpler criteria of both a
feerate and absolute fee increase.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 455 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/473f7652/attachment.sig>

From tim.ruffing at mmci.uni-saarland.de  Wed Jan 24 09:28:20 2018
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Wed, 24 Jan 2018 10:28:20 +0100
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <20180124015256.GR9082@boulet.lan>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
	<20180124015256.GR9082@boulet.lan>
Message-ID: <1516786100.2567.18.camel@mmci.uni-saarland.de>

On Wed, 2018-01-24 at 01:52 +0000, Andrew Poelstra via bitcoin-dev
wrote:
> 
> > They are. But I don't believe that is relevant; the attacker would
> > simply steal the coins on spend.
> 
> 
> Then the system would need to be hardforked to allow spending through
> a
> quantum-resistant ZKP of knowledge of the hashed public key. I expect
> that in a post-quantum world there will be demand for such a fork,
> especially if we came into such a world through surprise evidence of
> a discrete log break.
> 

There are simpler ways using consensus / waiting instead of zero-
knowledge, e.g., 

1. Include H(classic_pk, tx) to blockchain, wait until confirmed.
2. Reveal classic_pk, tx

This is taken from my tweet [1] but now I realize that these are
basically Guy Fawkes "signatures" [2]. Joseph Bonneau and Andrew Miller
 [3] had the idea to use this for cryptocurrency without asymmetric
cryptography.

Best,
Tim

[1] https://twitter.com/real_or_random/status/948226830166786048
[2] https://www.cl.cam.ac.uk/~rja14/Papers/fawkes.pdf
[3] http://www.jbonneau.com/doc/BM14-SPW-fawkescoin.pdf


From vitteaymeric at gmail.com  Wed Jan 24 10:24:55 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Wed, 24 Jan 2018 11:24:55 +0100
Subject: [bitcoin-dev] Why is deriving public key from the signature not
 used in Segwit?
In-Reply-To: <CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>
References: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
	<CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>
Message-ID: <41d8ff42-106f-45b9-cc70-507982c7336b@gmail.com>

34 bytes in fact

I have asked already the question at least twice on this list pointing
out the fact that pubkey is there now even for standard p2pkh
transactions and it was not the case some time ago

But I never got any answer regarding what motivated this change
(compared to the previous behavior) and when, so whether I am missing
something obvious, whether nobody wants to answer

Txs without pubkey are now rejected then what is the element in the code
(protocol, version, etc) that "decided" this?


Le 24/01/2018 ? 05:25, Gregory Maxwell via bitcoin-dev a ?crit?:
> On Wed, Jan 24, 2018 at 3:50 AM, ????? ?????????? via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Greetings.
>>
>> I wanted to ask what was the rationale behind still having both public
>> key and signature in Segwit witness?
>>
>> As is known for a while, the public key can be derived from the
>> signature and a quadrant byte, a trick that is successfully used both
>> in Bitcoin message signing algorithm and in Ethereum transaction
>> signatures. The later in particular suggests that this is a perfectly
>> functional and secure alternative.
>> Leaving out the public key would have saved 33 bytes per signature,
>> which is quite a lot.
>>
>> So, the question is - was there a good reason to do it the old way
>> (security, performance, privacy, something else?), or was it something
>> that haven't been thought of/considered at the time?
> It is slow to verify, incompatible with batch validation, doesn't save
> space if hashing isn't used, and is potentially patent encumbered.
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From greg at xiph.org  Wed Jan 24 10:31:35 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 24 Jan 2018 10:31:35 +0000
Subject: [bitcoin-dev] Why is deriving public key from the signature not
 used in Segwit?
In-Reply-To: <41d8ff42-106f-45b9-cc70-507982c7336b@gmail.com>
References: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
	<CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>
	<41d8ff42-106f-45b9-cc70-507982c7336b@gmail.com>
Message-ID: <CAAS2fgTT+9DydafDfA3S1_KSDO+hDkA4sNiBmUn+2kHpf5cFag@mail.gmail.com>

On Wed, Jan 24, 2018 at 10:24 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
> out the fact that pubkey is there now even for standard p2pkh
> transactions and it was not the case some time ago
>
> But I never got any answer regarding what motivated this change
> (compared to the previous behavior) and when, so whether I am missing
> something obvious, whether nobody wants to answer

No such behaviour ever existed, you are simply mistaken.

From vitteaymeric at gmail.com  Wed Jan 24 11:16:30 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Wed, 24 Jan 2018 12:16:30 +0100
Subject: [bitcoin-dev] Why is deriving public key from the signature not
 used in Segwit?
In-Reply-To: <CAAS2fgTT+9DydafDfA3S1_KSDO+hDkA4sNiBmUn+2kHpf5cFag@mail.gmail.com>
References: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
	<CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>
	<41d8ff42-106f-45b9-cc70-507982c7336b@gmail.com>
	<CAAS2fgTT+9DydafDfA3S1_KSDO+hDkA4sNiBmUn+2kHpf5cFag@mail.gmail.com>
Message-ID: <d3c5d24d-f3bb-c5fc-cc27-cfb932fc3048@gmail.com>

Then what about
https://blockchain.info/tx/226a8b08dc46a00e9ecec5567a303a0b354bef3c1674476eb5e4b627b2ace493?format=hex
?

Scriptsig:

473044022057a1234709270325e7215200f982546304cf465971cbd55d54231ead54ef1a7802207a82e93ef2b0f87188abe87bccb67ee9d5c650b1b58948e5b1c80ba1b4c43dc301

No pubkey...


Le 24/01/2018 ? 11:31, Gregory Maxwell a ?crit?:
> On Wed, Jan 24, 2018 at 10:24 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>> out the fact that pubkey is there now even for standard p2pkh
>> transactions and it was not the case some time ago
>>
>> But I never got any answer regarding what motivated this change
>> (compared to the previous behavior) and when, so whether I am missing
>> something obvious, whether nobody wants to answer
> No such behaviour ever existed, you are simply mistaken.

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From greg at xiph.org  Wed Jan 24 11:35:49 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Wed, 24 Jan 2018 11:35:49 +0000
Subject: [bitcoin-dev] Why is deriving public key from the signature not
 used in Segwit?
In-Reply-To: <d3c5d24d-f3bb-c5fc-cc27-cfb932fc3048@gmail.com>
References: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
	<CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>
	<41d8ff42-106f-45b9-cc70-507982c7336b@gmail.com>
	<CAAS2fgTT+9DydafDfA3S1_KSDO+hDkA4sNiBmUn+2kHpf5cFag@mail.gmail.com>
	<d3c5d24d-f3bb-c5fc-cc27-cfb932fc3048@gmail.com>
Message-ID: <CAAS2fgQcPZW0yKwDAL=8D5UrF4-3OLVJ2W3bDXJoXK28kOD9hg@mail.gmail.com>

On Wed, Jan 24, 2018 at 11:16 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
> Then what about
> https://blockchain.info/tx/226a8b08dc46a00e9ecec5567a303a0b354bef3c1674476eb5e4b627b2ace493?format=hex
> ?
>
> Scriptsig:
>
> 473044022057a1234709270325e7215200f982546304cf465971cbd55d54231ead54ef1a7802207a82e93ef2b0f87188abe87bccb67ee9d5c650b1b58948e5b1c80ba1b4c43dc301
>
> No pubkey...

Because the pubkey is in the scriptPubKey of vout 0 of
40872a376e98a1f8b285827c2ad8c5b3eec7d779d752dc3a4adda5d9bb70f3b5 which
it is spending.

From vitteaymeric at gmail.com  Wed Jan 24 12:03:55 2018
From: vitteaymeric at gmail.com (Aymeric Vitte)
Date: Wed, 24 Jan 2018 13:03:55 +0100
Subject: [bitcoin-dev] Why is deriving public key from the signature not
 used in Segwit?
In-Reply-To: <CAAS2fgQcPZW0yKwDAL=8D5UrF4-3OLVJ2W3bDXJoXK28kOD9hg@mail.gmail.com>
References: <CAJRVQkBPQR3Gz3AtWFgK_Z_9vDVZvR4Ws=f+tUZ3Y0mdswuk_g@mail.gmail.com>
	<CAAS2fgQmKY5206-ko9ttV4K_4aPfoWh7Jrx=XYetXLeknU30iw@mail.gmail.com>
	<41d8ff42-106f-45b9-cc70-507982c7336b@gmail.com>
	<CAAS2fgTT+9DydafDfA3S1_KSDO+hDkA4sNiBmUn+2kHpf5cFag@mail.gmail.com>
	<d3c5d24d-f3bb-c5fc-cc27-cfb932fc3048@gmail.com>
	<CAAS2fgQcPZW0yKwDAL=8D5UrF4-3OLVJ2W3bDXJoXK28kOD9hg@mail.gmail.com>
Message-ID: <7343aaf3-6e48-df3f-122a-52345ff2d715@gmail.com>

Indeed... I would have bet that I had other examples with p2pkh this
time but apparently I imagined it


Le 24/01/2018 ? 12:35, Gregory Maxwell a ?crit?:
> On Wed, Jan 24, 2018 at 11:16 AM, Aymeric Vitte <vitteaymeric at gmail.com> wrote:
>> Then what about
>> https://blockchain.info/tx/226a8b08dc46a00e9ecec5567a303a0b354bef3c1674476eb5e4b627b2ace493?format=hex
>> ?
>>
>> Scriptsig:
>>
>> 473044022057a1234709270325e7215200f982546304cf465971cbd55d54231ead54ef1a7802207a82e93ef2b0f87188abe87bccb67ee9d5c650b1b58948e5b1c80ba1b4c43dc301
>>
>> No pubkey...
> Because the pubkey is in the scriptPubKey of vout 0 of
> 40872a376e98a1f8b285827c2ad8c5b3eec7d779d752dc3a4adda5d9bb70f3b5 which
> it is spending.

-- 
Bitcoin transactions made simple: https://github.com/Ayms/bitcoin-transactions
Zcash wallets made simple: https://github.com/Ayms/zcash-wallets
Bitcoin wallets made simple: https://github.com/Ayms/bitcoin-wallets
Get the torrent dynamic blocklist: http://peersm.com/getblocklist
Check the 10 M passwords list: http://peersm.com/findmyass
Anti-spies and private torrents, dynamic blocklist: http://torrent-live.org
Peersm : http://www.peersm.com
torrent-live: https://github.com/Ayms/torrent-live
node-Tor : https://www.github.com/Ayms/node-Tor
GitHub : https://www.github.com/Ayms


From natanael.l at gmail.com  Wed Jan 24 12:51:45 2018
From: natanael.l at gmail.com (Natanael)
Date: Wed, 24 Jan 2018 13:51:45 +0100
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
Message-ID: <CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>

Den 23 jan. 2018 23:45 skrev "Gregory Maxwell via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:

On Tue, Jan 23, 2018 at 10:22 PM, Anthony Towns <aj at erisian.com.au> wrote:
> Hmm, at least people can choose not to reuse addresses currently --
> if everyone were using taproot and that didn't involve hashing the key,

Can you show me a model of quantum computation that is conjectured to
be able to solve the discrete log problem but which would take longer
than fractions of a second to do so? Quantum computation has to occur
within the coherence lifetime of the system.


Quantum computers works like randomized black boxes, you run them in many
cycles with a certain probability of getting the right answer.

The trick to them is that they bias the probabilities of their qubits to
read out the correct answer *more often than at random*, for many classes
of problems. You (likely) won't get the correct answer immediately.

https://en.wikipedia.org/wiki/Quantum_computing

Quoting Wikipedia:

> An algorithm is composed of a fixed sequence of quantum logic gates and a
problem is encoded by setting the initial values of the qubits, similar to
how a classical computer works. The calculation usually ends with a
measurement, collapsing the system of qubits into one of the 2 n
{\displaystyle 2^{n}} 2^{n} pure states, where each qubit is zero or one,
decomposing into a classical state. The outcome can therefore be at most n
{\displaystyle n} n classical bits of information (or, if the algorithm did
not end with a measurement, the result is an unobserved quantum state).
Quantum algorithms are often probabilistic, in that they provide the
correct solution only with a certain known probability.

A non programmed QC is essentially an RNG driven by quantum effects. You
just get random bits.

A programmed one will need to run the and program over and over until you
can derive the correct answer from one of its outputs. How fast this goes
depends on the problem and the algorithm.

Most people here have heard of Grover's algorithm, it would crack a
symmetric 256 bit key in approximately 2^128 QC cycles - completely
impractical. Shor's algorithm is the dangerous one for ECC since it cracks
current keys at "practical" speeds.

https://eprint.iacr.org/2017/598 - resource estimates, in terms of size of
the QC. Does not address implementation speed.

I can't seem to find specific details, but I remember having seen estimates
of around 2^40 cycles in practical implementations for 256 bit ECC (this
assumes use error correction schemes, QC machines with small some
imperfections, and more). Unfortunately I can't find a source for this
estimate. I've seen lower estimates too, but they seem entirely
theoretical.

Read-out time for QC:s is indeed insignificant, in terms of measuring the
state of the qubits after a complete cycle.

Programming time, time to prepared for readout, reset, reprogramming, etc,
that will all take a little longer. In particular with more qubits
involved, since they all need to be in superposition and be coherent at
some point. Also, you still have to parse all the different outputs (on a
classical computer) to find your answer among them.
Very very optimistic cycle speeds are in the GHz range, and then that's
still on the order of ~15 minutes for 2^40 cycles. Since we don't even have
a proper general purpose QC yet, nor one with usable amounts of qubits, we
don't even know if we can make them run at a cycle per second, or per
minute...

However if somebody *does* build a fast QC that's nearly ideal, then
Bitcoin's typical use of ECC would be in immediate danger. The most
optimistic QC plausible would indeed be able to crack keys in under a
minute. But my own wild guess is that for the next few decades none will be
faster than a runtime measured in weeks for cracking keys.

---

Sidenote, I'm strongly in favor of implementing early support for the
Fawkes scheme mentioned previously.

We could even patch it on top of classical transactions - you can only
break ECC with a known public key, so just commit to the signed transaction
into the blockchain before publishing it. Then afterwards you publish the
transaction itself, with a reference to the commitment. That transaction
can then be assumed legit simply because there was no room to crack the key
before the commitment, and the transaction matches the commitment.

Never reuse keys, and you're safe against QC:s.

Sidenote: There's a risk here with interception, insertion of a new
commitment and getting the new transaction into the blockchain first.
However, I would suggest a mining policy here were two known conflicting
transactions with commitments are resolved such that the one with the
oldest commitment wins. How to address detection of conflicting
transactions with commitments older than confirmed transactions isn't
obvious. Some of these may be fully intentional by the original owner, such
as a regretted transaction.

Another sidenote: HD wallets with hash based hardened derivation should
also be safe in various circumstances, near completely safe in the case
where they're defined such that knowing an individual private key, which is
not the root key,  is not enough to derive any other in your wallet.
HD schemes that only prevent derivation of parent keypairs in the tree
would require that you never use a key derived from another already used or
published public key.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/10b6b113/attachment-0001.html>

From ilansky.sharkson at gmail.com  Wed Jan 24 11:56:04 2018
From: ilansky.sharkson at gmail.com (Ilan Oh)
Date: Wed, 24 Jan 2018 12:56:04 +0100
Subject: [bitcoin-dev] Merge of protocol
In-Reply-To: <CALTsm7ijaK+fWk9jKUMD0MGqwAeSYwc3XOyGOs8AYZ9AYL_uGA@mail.gmail.com>
References: <CALTsm7gG6bWJd=HQ5XJTYxWbxNPwZDC6Xefsh_zSAQhk89A4VQ@mail.gmail.com>
	<CALTsm7ir61RCfGSf8r71+soDJH+W9n_dPORS+2+ARKEzhpnXWw@mail.gmail.com>
	<CALTsm7ii4PZ_of=YPpB2x_nMGGTFrDW8OGOx6LehfyQD22JMYw@mail.gmail.com>
	<CALTsm7jOPr17d1syFZ9wsYAntcUss+tcrHU_vQKC2TEZ1ong9g@mail.gmail.com>
	<CALTsm7i=ThDfv2uquHAxvLgQ497oVkYhYF5gNFcv3RxEkDVr5A@mail.gmail.com>
	<CALTsm7ijaK+fWk9jKUMD0MGqwAeSYwc3XOyGOs8AYZ9AYL_uGA@mail.gmail.com>
Message-ID: <CALTsm7jeqQUhL+REvzBQNUtSMd9i9oVeXEkdCuUuGOpz_V=b8Q@mail.gmail.com>

2017 was fork year,

Is it technically possible to merge two protocoles ? And thus bringing the
strength of both into one resulting coin.

I would not be surprized to see a lot of altcoin wanting to merge with
bitcoin or between them, especially with LN current development, if it is
possible,

If anyone has ideas or ressources on this,

Thanks
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/729c342b/attachment.html>

From thealanevans at gmail.com  Wed Jan 24 13:43:29 2018
From: thealanevans at gmail.com (Alan Evans)
Date: Wed, 24 Jan 2018 09:43:29 -0400
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <20180124074453.GC12767@savin.petertodd.org>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
	<20180124074453.GC12767@savin.petertodd.org>
Message-ID: <CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>

So, OP, in your scenario, you have 1 transaction in the mempool, A, then
you want to spend the change before confirmation, so you broadcast a new
transaction, B, which replaces A.

> Because the size of the merged transaction is smaller than the original
transactions, unless there is a considerable feerate bump, this rule isn't
possible to observe.

I'm confused, the mempool only sees 1 transaction at a time, first A, then
later B. " the original transactions", plural, should not exist in the
mempool.

B's fee and rate needs to be larger than A's, but B will be greater than or
equal to A anyway. So, just increasing the fee rate will cause a larger fee
anyway.

Am I missing something?


On Wed, Jan 24, 2018 at 3:44 AM, Peter Todd via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Jan 23, 2018 at 10:49:34PM +0000, Gregory Maxwell via bitcoin-dev
> wrote:
> > On Tue, Jan 23, 2018 at 10:19 PM, Rhavar via bitcoin-dev
> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
> > > Interesting. I didn't think about this before, but it seems like
> bip125 is
> > > rather incentive incompatible right now? If we're assuming a
> competitive
> > > mempool, it really doesn't seem generally rational to accept a
> replacement
> > > transaction of a lower fee rate.
> >
> > BIP125 replacement requires that the fee rate increases.  The text of
> > the BIP document is written in a confusing way that doesn't make this
> > clear.
>
> In fact I considered only requiring an increase in fee rate, based on the
> theory that if absolute fee went down, the transaction must be smaller and
> thus
> miners could overall earn more from the additional transactions they could
> fit
> into their block. But to do that properly requires considering whether or
> not
> that's actually true in the particular state the mempool as a whole
> happens to
> be in, so I ditched that idea early on for the much simpler criteria of
> both a
> feerate and absolute fee increase.
>
> --
> https://petertodd.org 'peter'[:-1]@petertodd.org
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/398e0de6/attachment.html>

From tier.nolan at gmail.com  Wed Jan 24 15:02:38 2018
From: tier.nolan at gmail.com (Tier Nolan)
Date: Wed, 24 Jan 2018 15:02:38 +0000
Subject: [bitcoin-dev] Merge of protocol
In-Reply-To: <CALTsm7jeqQUhL+REvzBQNUtSMd9i9oVeXEkdCuUuGOpz_V=b8Q@mail.gmail.com>
References: <CALTsm7gG6bWJd=HQ5XJTYxWbxNPwZDC6Xefsh_zSAQhk89A4VQ@mail.gmail.com>
	<CALTsm7ir61RCfGSf8r71+soDJH+W9n_dPORS+2+ARKEzhpnXWw@mail.gmail.com>
	<CALTsm7ii4PZ_of=YPpB2x_nMGGTFrDW8OGOx6LehfyQD22JMYw@mail.gmail.com>
	<CALTsm7jOPr17d1syFZ9wsYAntcUss+tcrHU_vQKC2TEZ1ong9g@mail.gmail.com>
	<CALTsm7i=ThDfv2uquHAxvLgQ497oVkYhYF5gNFcv3RxEkDVr5A@mail.gmail.com>
	<CALTsm7ijaK+fWk9jKUMD0MGqwAeSYwc3XOyGOs8AYZ9AYL_uGA@mail.gmail.com>
	<CALTsm7jeqQUhL+REvzBQNUtSMd9i9oVeXEkdCuUuGOpz_V=b8Q@mail.gmail.com>
Message-ID: <CAE-z3OXJJ=BQhYmjLyq2x8xSwAi5j0cBOvqe3um8_QjV9fSLDA@mail.gmail.com>

If the communities behind two coins wanted to merge, it would be possible,
but difficulty and risky.

It represents a hard fork on both chains.  Not only does each coin's
community need to agree, the two communities need to agree with each other.

They would both have to agree the join point.  The merge block would have 2
parents.


A <- B <- C <- D
                 \
                    J1 <- J2 <- J3 <- J4
                 /
w <- x <- y <- z


In the above example, A, B, C, D is one chain and w, x, y, z is the other.
They combine and then J1, J2, J3, J4 is the combined chain.

Since block "J1" has 2 parents, it commits to the state of the 2 legacy
chains.  If you have coins in each chain at D or z, then you get coins in
the joint chain.

They would both need to agree on what the rules are for their new chain.
Since it is a (double) hard fork, they can do pretty much anything they
want.

The combined chain could continue as before.  It would be a combined chain
and each user's coin total would be unaffected.  The advantage of doing
that is that it causes minimum economic disruption to users.  The mining
power for both chains would be applied to the joint chain, so they combine
their security.

Alternatively, they could agree on an exchange rate.  Users would be given
joint-coins in exchange for their coins on the 2 legacy chains.

For something like Bitcoin Cash and Bitcoin, they could have a
re-combination rule.  1 Bitcoin-Recombined = 1 BTC + 1 BCH.  That doesn't
seem very likely though and also there are more BCH coins than BTC coins.

It might be worth moving this to bitcoin-discuss, since it isn't really
Bitcoin protocol discussion.


Wed, Jan 24, 2018 at 11:56 AM, Ilan Oh via bitcoin-dev <bitcoin-dev at lists.
linuxfoundation.org> wrote:

> 2017 was fork year,
>
> Is it technically possible to merge two protocoles ? And thus bringing the
> strength of both into one resulting coin.
>
> I would not be surprized to see a lot of altcoin wanting to merge with
> bitcoin or between them, especially with LN current development, if it is
> possible,
>
> If anyone has ideas or ressources on this,
>
> Thanks
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/beca5030/attachment.html>

From tim.ruffing at mmci.uni-saarland.de  Wed Jan 24 15:38:11 2018
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Wed, 24 Jan 2018 16:38:11 +0100
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
	<CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>
Message-ID: <1516808291.4277.25.camel@mmci.uni-saarland.de>

On Wed, 2018-01-24 at 13:51 +0100, Natanael via bitcoin-dev wrote:
> Sidenote: There's a risk here with interception, insertion of a new
> commitment and getting the new transaction into the blockchain first.
> However, I would suggest a mining policy here were two known
> conflicting transactions with commitments are resolved such that the
> one with the oldest commitment wins. How to address detection of
> conflicting transactions with commitments older than confirmed
> transactions isn't obvious. Some of these may be fully intentional by
> the original owner, such as a regretted transaction.

Okay, I think my proposal was wrong...

This looks better (feel free to break again):
1. Commit (H(classic_pk, tx), tx) to the blockchain, wait until confirmed
2. Reveal classic_pk in the blockchain

Then the tx in the first valid commitment wins. If the attacker
intercepts classic_pk, it won't help him. He cannot create the first
valid commitment, because it is created already. (The reason is that
the decommitment is canonical now; for all commitments, the
decommitment is just classic_pk.)

By the way, maybe I'm stating the obvious but Taproot (or similar) is
indeed very nice for outputs generated in the future: You can have a
path for a classical signature scheme and a path for a quantum-secure
scheme.

Best,
Tim

From natanael.l at gmail.com  Wed Jan 24 18:51:27 2018
From: natanael.l at gmail.com (Natanael)
Date: Wed, 24 Jan 2018 19:51:27 +0100
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <1516808291.4277.25.camel@mmci.uni-saarland.de>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
	<CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>
	<1516808291.4277.25.camel@mmci.uni-saarland.de>
Message-ID: <CAAt2M19csW3eTW_rrS+8+OuaG18EhqajWgLFotCrcVfSeVmrrQ@mail.gmail.com>

Den 24 jan. 2018 16:38 skrev "Tim Ruffing via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:

Okay, I think my proposal was wrong...

This looks better (feel free to break again):
1. Commit (H(classic_pk, tx), tx) to the blockchain, wait until confirmed
2. Reveal classic_pk in the blockchain

Then the tx in the first valid commitment wins. If the attacker
intercepts classic_pk, it won't help him. He cannot create the first
valid commitment, because it is created already. (The reason is that
the decommitment is canonical now; for all commitments, the
decommitment is just classic_pk.)


That's not the type of attack I'm imagining. Both versions of your scheme
are essentially equivalent in terms of this attack.

Intended steps:
1: You publish a hash commitment.
2: The hash ends up in the blockchain.
3: You publish the transaction itself, and it matches the hash commitment.
4: Because it matches, miners includes it. It's now in the blockchain.

Attack:
1: You publish a hash commitment.
2: The hash ends up the blockchain.
3: You publish the transaction itself, it matches the hash commitment.
4: The attacker mess with the network somehow to prevent your transaction
from reaching the miners.
5: The attacker cracks your keypair, and makes his own commitment hash for
his own theft transaction.
6: Once that commitment is in the blockchain, he publishes his own theft
transaction.
7: The attacker's theft transaction gets into the blockchain.
8 (optionally): The miners finally see your original transaction with the
older commitment, but now the theft transaction can't be undone. There's
nothing to do about it, nor a way to know if it's intentional or not.
Anybody not verifying commitments only sees a doublespend attempt.

---

More speculation, not really a serious proposal:

I can imagine one way to reduce the probability of success for the attack
by publishing encrypted transactions as the commitment, to then publish the
key - the effect of this is that the key is easier to propagate quickly
across the network than a full transaction, making it harder to succeed
with a network based attack. This naive version by itself is however a
major DoS vector against the network.

You could, in some kind of fork, redefine how blocks are processed such
that you can prune all encrypted transactions that have not had the key
published within X blocks. The validation rules would work such that to
publish the key for an encrypted transaction in a new block, that
transaction must both be recent enough, be valid by itself, and also not
conflict with any other existing plaintext / decrypted transactions in the
blockchain.

Blocks wouldn't necessarily even need to include the encrypted transactions
during propagation. This works because encrypted transactions have zero
effect until the key is published. In this case you'd effectively be
required to publish your encrypted transaction twice to ensure the raw data
isn't lost, once to get into a block and again together with the key to get
it settled.

Since miners will likely keep at least the most recent encrypted
transactions cached to speed up validation, this is faster to settle than
to publish the committed transaction as mentioned in the beginning. This
increases your chances to get your key into the blockchain to settle your
transaction before the attacker completes his attack, versus pushing a full
transaction that miners haven't seen before.

This version would still allow DoS against miners caching all encrypted
transactions. However, if efficient Zero-knowledge proofs became practical
then you can use one to prove your encrypted transaction valid, even
against the UTXO set and in terms of not colliding with existing
commitments - in this case the DoS attack properties are nearly identical
to standard transactions.
If you want to change a committed transaction, you'd need to let the
commitment expire.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180124/c42ae892/attachment.html>

From tim.ruffing at mmci.uni-saarland.de  Wed Jan 24 23:22:05 2018
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Thu, 25 Jan 2018 00:22:05 +0100
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAt2M19csW3eTW_rrS+8+OuaG18EhqajWgLFotCrcVfSeVmrrQ@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
	<CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>
	<1516808291.4277.25.camel@mmci.uni-saarland.de>
	<CAAt2M19csW3eTW_rrS+8+OuaG18EhqajWgLFotCrcVfSeVmrrQ@mail.gmail.com>
Message-ID: <1516836125.5969.11.camel@mmci.uni-saarland.de>

On Wed, 2018-01-24 at 19:51 +0100, Natanael wrote:
> 
> That's not the type of attack I'm imagining. Both versions of your
> scheme are essentially equivalent in terms of this attack. 
> 
> Intended steps: 
> 1: You publish a hash commitment. 
> 2: The hash ends up in the blockchain. 
> 3: You publish the transaction itself, and it matches the hash
> commitment. 
> 4: Because it matches, miners includes it. It's now in the
> blockchain. 

I think you misread my second proposal. The first step is not only to
publish the hash but to publish a *pair* consisting of the hash and the
transaction.

If the attacker changes the transaction on the wire, the user does not
care and will try again.

By the way: As described here, everybody could do this first step and
flood the blockchain with it. We cannot immediately subtract a fee,
because it's not clear that some transaction will take place at all. So
we need to take the fee from somewhere else or do something else to
prevent spam. But that's entirely different issue...

From natanael.l at gmail.com  Thu Jan 25 00:09:31 2018
From: natanael.l at gmail.com (Natanael)
Date: Thu, 25 Jan 2018 01:09:31 +0100
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <1516836125.5969.11.camel@mmci.uni-saarland.de>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
	<CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>
	<1516808291.4277.25.camel@mmci.uni-saarland.de>
	<CAAt2M19csW3eTW_rrS+8+OuaG18EhqajWgLFotCrcVfSeVmrrQ@mail.gmail.com>
	<1516836125.5969.11.camel@mmci.uni-saarland.de>
Message-ID: <CAAt2M19UObuaaODHXb+iW9bWMj53wGHAdjVzZgWBi-ZCCUi4Mg@mail.gmail.com>

Den 25 jan. 2018 00:22 skrev "Tim Ruffing via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org>:


I think you misread my second proposal. The first step is not only to
publish the hash but to publish a *pair* consisting of the hash and the
transaction.

If the attacker changes the transaction on the wire, the user does not
care and will try again.


I guess I assumed you meant it otherwise because I didn't assume you
intended a commitment to the full transaction just without the asymmetric
key material.

You could treat it the same way as in my suggestion, let it expire and
prune it if the key material isn't published in time.

However... A sufficiently powerful attacker can deploy as soon as he sees
your published signature and key, delay its propagation to the miners,
force expiration and then *still* repeat the attack with his own forgery.

Honestly, as long as we need to allow any form of expiry + relying on
publication of the vulnerable algorithms result for verification, I think
the weakness will remain.

No expiration hurts in multiple ways like via DoS, or by locking in
potentially wrong (or straight up malicious) transactions.

---

There's one way out, I believe, which is quantum safe Zero-knowledge
proofs. Currently STARK:s are one variant presumed quantum safe. It would
be used to completely substitute the publication of the public key and
signatures, and this way we don't even need two-step commitments.

It does however likely require a hardfork to apply to old transactions. (I
can imagine an extension block type softfork method, in which case old
UTXO:s get locked on the mainchain to create equivalent valued extension
block funds.)

Without practical ZKP,  and presuming no powerful QC attackers with the
ability to control the network (basically NSA level attackers), I do think
the Fawkes signature scheme is sufficient. Quantum attacks are likely to be
very expensive anyway, for the foreseeable future.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180125/45fe3cec/attachment.html>

From rhavar at protonmail.com  Wed Jan 24 16:05:01 2018
From: rhavar at protonmail.com (Rhavar)
Date: Wed, 24 Jan 2018 11:05:01 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
	<20180124074453.GC12767@savin.petertodd.org>
	<CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>
Message-ID: <PdUSy7mO1QTH-sAU_gBRjZOhLi1FoZRPUhNZt80kPL8d0lOgsCfMeNzf52Ae7_wrcTBy7d-tROvRLqBuHMMtmduzAskGuzPlwxI2yG4yY64=@protonmail.com>


>I'm confused, the mempool?only sees 1 transaction at a time, first A, then later B. "the original transactions", plural, should not exist in the mempool.
>
>B's fee and rate needs to be larger than A's, but B will be greater than or equal to A anyway. So, just increasing the fee rate will cause a larger fee anyway.
>
>Am I missing something?

Kind of. The first case is that you do the "smarter" type of merging, where you get an original transaction and then say add an additional output(s) to it.

The issue with this, is from a practical perspective is _very_ complex. Because you really need to do a lot of tracking to see which of the two transactions actually confirm. And if you are promising fast payments, you can be stuck in a weird limbo state where you're waiting for the original one to "safely" confirm before it's safe to make a re-payment (even a non-malicious will likely contain the replacement).

bip125 already supports this use-case, but I will suggest that the logic to deploy this is sufficiently complex that no one is going to attempt any time in the near future.


But "retroactive transaction merging" is actually pretty approachable problem for a service to implement. You just get N valid transactions you've made, merge them into one. Strip extraneous inputs[1], and combine and alter the change amount.

The reason this is so appealing to implement, is there is very little complexity. If the "retroactive transaction merge" fails, or doesn't get confirmed, it actually has no impact. If it does get confirmed, that's just pure cost-savings.

However, the rules of bip125 currently make it (unnecessarily?) unappealing, because I can never lower the absolute amount of fees I pay. Hence I think it'd be pretty sweet if they could be relaxed to support this if it can be done in a pretty risk free way.



[1] Need to be very careful with that, if you're ever merging a merged transaction.


>
>
>On Wed, Jan 24, 2018 at 3:44 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>On Tue, Jan 23, 2018 at 10:49:34PM +0000, Gregory Maxwell via bitcoin-dev wrote:
>> > On Tue, Jan 23, 2018 at 10:19 PM, Rhavar via bitcoin-dev
>> > <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> > > Interesting. I didn't think about this before, but it seems like bip125 is
>> > > rather incentive incompatible right now? If we're assuming a competitive
>> > > mempool, it really doesn't seem generally rational to accept a replacement
>> > > transaction of a lower fee rate.
>> >
>> > BIP125 replacement requires that the fee rate increases.? The text of
>> > the BIP document is written in a confusing way that doesn't make this
>> > clear.
>>
>>In fact I considered only requiring an increase in fee rate, based on the
>> theory that if absolute fee went down, the transaction must be smaller and thus
>> miners could overall earn more from the additional transactions they could fit
>> into their block. But to do that properly requires considering whether or not
>> that's actually true in the particular state the mempool as a whole happens to
>> be in, so I ditched that idea early on for the much simpler criteria of both a
>> feerate and absolute fee increase.
>>
>> --
>>https://petertodd.org 'peter'[:-1]@petertodd.org
>>
>>_______________________________________________
>> bitcoin-dev mailing list
>>bitcoin-dev at lists.linuxfoundation.org
>>https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>


From tim.ruffing at mmci.uni-saarland.de  Fri Jan 26 13:14:14 2018
From: tim.ruffing at mmci.uni-saarland.de (Tim Ruffing)
Date: Fri, 26 Jan 2018 14:14:14 +0100
Subject: [bitcoin-dev]  Recovery of old UTXOs in a post-quantum world
In-Reply-To: <CAAt2M19UObuaaODHXb+iW9bWMj53wGHAdjVzZgWBi-ZCCUi4Mg@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAAS2fgSy8qg71M6ZOr=xj=W6y2Jbz8hwygZOUYv-Brkt0JwVaQ@mail.gmail.com>
	<20180123222229.GA3801@erisian.com.au>
	<CAAS2fgTNcCB2mfvCBhC_AhgxX=g8feYguGHN_VPWW0EoOOxMyA@mail.gmail.com>
	<CAAt2M1-oh=_Ro6+Srit0XYburK_abQgJiW0Jx=nmNyeToA2rSA@mail.gmail.com>
	<1516808291.4277.25.camel@mmci.uni-saarland.de>
	<CAAt2M19csW3eTW_rrS+8+OuaG18EhqajWgLFotCrcVfSeVmrrQ@mail.gmail.com>
	<1516836125.5969.11.camel@mmci.uni-saarland.de>
	<CAAt2M19UObuaaODHXb+iW9bWMj53wGHAdjVzZgWBi-ZCCUi4Mg@mail.gmail.com>
Message-ID: <1516972454.3107.67.camel@mmci.uni-saarland.de>

(changing the subject... ;))

My proposal does not include any form of expiration, so I don't see how
it should be vulnerable to the described attack.

To make this a little bit more detailed:

The user has one or more single standard UTXOs all with ECDSA public
key classic_pk and thus address SHA256(RIPEMD160((classic_pk)). The
corresponding secret key is classic_sk. Let MAC be a quantum-secure
message-authentication code, e.g., MAC(k,x)=H(k||x) for a suitable hash
function, e.g, BLAKE2 or SHA3.

The idea is to (ab)use the public key classic_pk as a key for the MAC. 

To spend an UTXO with a transaction tx, the user does the following:
   1. Create and publish a "transaction" c that references the address
      SHA256(RIPEMD160((classic_pk)) and contains the following data: 
      MAC(classic_pk,tx))||tx
   2. Wait until c is confirmed. (If it does not confirm, send it again as
      usual).
   3. Create and publish a "transaction" d with the following data:
      classic_pk||Sign(classic_sk, tx)

Consensus rules:
A transaction d=classic_pk||sig spends all UTXOs with
address SHA256(RIPEMD160(classic_pk)), applying the effects of tx, if
there exists a transaction c=mac||tx in the blockchain such that 
   1. c is the first transaction (among all referencing the address) in
      the blockchain where mac is a valid MAC for message tx under correct
      key classic_pk
   2. sig is valid ECDSA signature over tx under public key classic_pk

c-transactions never expire. 

If the user has not published classic_pk before, this should be secure
against quantum attackers:
Before step 2, the MAC key k=classic_pk is only known to the user. So
the only valid c that the attacker can produce has the real transaction
tx, because a different transaction tx' requires the attacker to forge
the MAC. Since the user waits for confirmation, the first c in the
blockchain fulfilling conditions 1 and 2 has been created by the user.

Even if classic_pk is known, this is no less secure than "classic
spending", because we require an ECDSA signature on tx.

I'm pretty confident that I'm not overlooking an obvious attack. If I'm
wrong then please describe exactly the steps of the user and the
attacker. 

Best,
Tim 


On Thu, 2018-01-25 at 01:09 +0100, Natanael wrote:
> 
> Den 25 jan. 2018 00:22 skrev "Tim Ruffing via bitcoin-dev" <bitcoin-d
> ev at lists.linuxfoundation.org>:
> > I think you misread my second proposal. The first step is not only
> > to
> > publish the hash but to publish a *pair* consisting of the hash and
> > the
> > transaction.
> > 
> > If the attacker changes the transaction on the wire, the user does
> > not
> > care and will try again.
> 
> I guess I assumed you meant it otherwise because I didn't assume you
> intended a commitment to the full transaction just without the
> asymmetric key material. 
> 
> You could treat it the same way as in my suggestion, let it expire
> and prune it if the key material isn't published in time. 
> 
> However... A sufficiently powerful attacker can deploy as soon as he
> sees your published signature and key, delay its propagation to the
> miners, force expiration and then *still* repeat the attack with his
> own forgery. 
> 
> Honestly, as long as we need to allow any form of expiry + relying on
> publication of the vulnerable algorithms result for verification, I
> think the weakness will remain. 
> 
> No expiration hurts in multiple ways like via DoS, or by locking in
> potentially wrong (or straight up malicious) transactions.
> 
> ---
> 
> There's one way out, I believe, which is quantum safe Zero-knowledge
> proofs. Currently STARK:s are one variant presumed quantum safe. It
> would be used to completely substitute the publication of the public
> key and signatures, and this way we don't even need two-step
> commitments. 
> 
> It does however likely require a hardfork to apply to old
> transactions. (I can imagine an extension block type softfork method,
> in which case old UTXO:s get locked on the mainchain to create
> equivalent valued extension block funds.)
> 
> Without practical ZKP,  and presuming no powerful QC attackers with
> the ability to control the network (basically NSA level attackers), I
> do think the Fawkes signature scheme is sufficient. Quantum attacks
> are likely to be very expensive anyway, for the foreseeable future. 

From kalle at rosenbaum.se  Fri Jan 26 15:52:10 2018
From: kalle at rosenbaum.se (Kalle Rosenbaum)
Date: Fri, 26 Jan 2018 16:52:10 +0100
Subject: [bitcoin-dev] Fix or withdraw BIP120/121?
Message-ID: <CAPswA9zXRhw6j-88VDuHtUT_vk0-biUq=FyAQEWshVvNmQ_5HQ@mail.gmail.com>

Hi

There is an inherent problem with BIP120, Proof of Payment: If there
is a soft fork, a server that verifies PoPs will accept a PoP as valid
without checking any of the new Bitcoin rules.

For example, a server will be fooled by a segwit transaction, because
the server doesn't have a witness to verify and consequently will
accept any PoP with an empty scriptSig.

Besides this problem, on-chain payments are not hot anymore and
interest, or need, for PoP as a concept seems low.

I have no good solution for the soft fork problem. Requiring all
software that uses PoP to upgrade to a new PoP specification on each
soft-fork is not good enough. Do you have any ideas on how to fix it?

If there is no good solution to the soft-fork issue, I suggest that I
withdraw BIP120 and BIP121.

As for current implementations: I know that Mycelium implements
BIP120, but I'm not sure if there is any other software, besides my
own, implementing it. If you know of any, please let me know so I can
discuss it with them.

Regards,
/Kalle

From greg at xiph.org  Fri Jan 26 21:34:39 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Fri, 26 Jan 2018 21:34:39 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
Message-ID: <CAAS2fgSApdSYUWZx+_G7tMPPQm5bC4xjYzZ_mQZv=w-FD-4jWw@mail.gmail.com>

On Tue, Jan 23, 2018 at 12:30 AM, Gregory Maxwell <greg at xiph.org> wrote:
> It turns out, however, that there is no need to make a trade-off.  The
> special case of a top level "threshold-signature OR
> arbitrary-conditions" can be made indistinguishable from a normal
> one-party signature, with no overhead at all, with a special
> delegating CHECKSIG which I call Taproot.

Keeping in mind that a single public point can stand in for any
monotone function of public keys, a taproot branch is only needed for
accountability (being able to tell from public data which branches
were used) or when conditions other than public keys are required e.g.
CSV + a monotone function of keys.

I believe that with scriptless-scripts most of hash preimages can be
accomplished without an actual hash pre-image condition.

Are there other simple and very useful/general preconditions that
would be useful ANDed with a monotone function of public keys like is
the case for CSV?

I ask because recursive taproot by itself isn't very interesting,
since (other than accountability) there is no gain to not just merging
the alternative, but if there are additional conditions then it can be
useful. E.g.

[pubkey]
      \-[pubkey]&&CSV
             \-[fancy script]

So it might make sense to support a taproot construction that can
nest, where interior nested keys have a CSV/CLTV predicate. But are
there other simple predicates that cover a lot of cases?


[Aside: _please_ change the subject lines for further discussion about
quantum computers;]

From roconnor at blockstream.io  Sat Jan 27 17:07:25 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Sat, 27 Jan 2018 12:07:25 -0500
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <20180123064419.GA1296@erisian.com.au>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
Message-ID: <CAMZUoKmfcmfgErhvAZUQgi8R7bzYCMotT7MMpqQrePej09NBmw@mail.gmail.com>

On Tue, Jan 23, 2018 at 1:44 AM, Anthony Towns via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Tue, Jan 23, 2018 at 12:30:06AM +0000, Gregory Maxwell via bitcoin-dev
> wrote:
> > One point that comes up while talking about merkelized scripts is can
> > we go about making fancier contract use cases as indistinguishable as
> > possible from the most common and boring payments.
>
> > Now we tweak C to produce P which is the key we'll publish: P = C +
> H(C||S)G.
> > (This is the attack hardened pay-to-contract construction described in
> [2])
> > Then we pay to a scriptPubKey of [Taproot supporting version] [EC point
> P].
>
> Is this really intended as paying directly to a pubkey, instead of a
> pubkey hash?
>
> If so, isn't that a step backwards with regard to resistance to quantum
> attacks against ECC?
>
> Paying direct to pubkey doesn't seem quite enough to make pay-to-taproot
> cheaper than p2wpkh: the extra 12 bytes in the scriptPubKey would need
> you to reduce the witness by 48 bytes to maintain the weight, but I think
> you'd only be saving 33 bytes by not having to reveal the pubkey, and
> another 6-7 bytes by having a tighter signature encoding than DER. Still,
> that's pretty close with a difference of only a couple of vbytes per
> input by my count.
>

I've been thinking about your comment, and I think your concern can be
addressed.  Taproot would almost certainly be deployed in conjunction with
cross-input signature aggregation.  Because aggregation doesn't work with
ECDSA, only those signatures using Taproot and other Schnorr signatures
would be available for aggregation.  Just having the ability to support
cross-input signature aggregation may be motivation enough for ordinary
pub-key users to switch to Taproot.  However, there is more.

Cross-input signature aggregation probably requires a new field to be added
to the P2P transaction structure to hold the aggregated signature, since
there isn't really a good place to put it in the existing structure (there
are games you can play to make it fit, but I think it is worthwhile).  The
obvious way add block commitments to a new tx field is via the witness
reserved value mechanism present in BIP 141.  At this point I think there
will be some leeway to adjust the discount on the weight of this new
aggregated signature tx field so that even a single input taproot using the
aggregated signature system (here an aggregation of 1 signature) ends up no
more expensive than a single input segwit P2WPKH.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180127/d64b250e/attachment.html>

From lf-lists at mattcorallo.com  Sat Jan 27 17:23:12 2018
From: lf-lists at mattcorallo.com (Matt Corallo)
Date: Sat, 27 Jan 2018 17:23:12 +0000
Subject: [bitcoin-dev] Taproot: Privacy preserving switchable scripting
In-Reply-To: <CAMZUoKmfcmfgErhvAZUQgi8R7bzYCMotT7MMpqQrePej09NBmw@mail.gmail.com>
References: <CAAS2fgTXg5kk6TyUM9dS=tf5N0_Z-GKVmzMLwTW1HxUgrqdo+Q@mail.gmail.com>
	<20180123064419.GA1296@erisian.com.au>
	<CAMZUoKmfcmfgErhvAZUQgi8R7bzYCMotT7MMpqQrePej09NBmw@mail.gmail.com>
Message-ID: <B8A34614-FCF3-427B-B05F-2A5F7F7AADFB@mattcorallo.com>

Gah, please no. I see no material reason why cross-input signature aggregation shouldn't have the signatures in the first n-1 inputs replaced with something like a single-byte push where a signature is required to indicate aggregation, and the combined signature in the last input at whatever position the signature is required.

On January 27, 2018 5:07:25 PM UTC, Russell O'Connor via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
-snip-
>Cross-input signature aggregation probably requires a new field to be
>added
>to the P2P transaction structure to hold the aggregated signature,
>since
>there isn't really a good place to put it in the existing structure
>(there
>are games you can play to make it fit, but I think it is worthwhile). 
>The
>obvious way add block commitments to a new tx field is via the witness
>reserved value mechanism present in BIP 141.  At this point I think
>there
>will be some leeway to adjust the discount on the weight of this new
>aggregated signature tx field so that even a single input taproot using
>the
>aggregated signature system (here an aggregation of 1 signature) ends
>up no
>more expensive than a single input segwit P2WPKH.

From icesby24 at gmail.com  Sat Jan 27 08:45:10 2018
From: icesby24 at gmail.com (Nathan Parker)
Date: Sat, 27 Jan 2018 09:45:10 +0100
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
Message-ID: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>

Miners can fill their blocks with transactions paying very high fees at no
cost because they get the fees back to themselves. They can do this for
different purposes, like trying to increase the recommended fee. Here I
propose a backwards-compatible solution to this problem.

The solution would be to reward the fees of the current block to the miner
of the next block (or X blocks after the current one). That way, if a miner
floods its own block with very high fee transactions, those fees are no
longer given back to itself, but to the miner of future blocks which could
potentially be anyone. Flooding blocks with fake txs is now discouraged.
However, filling blocks with real transactions paying real fees is still
encouraged because you could be the one to mine the block that would claim
this reward.

The way to implement this in a backwards-compatible fashion would be to
enforce miners to set an anyone-can-spend output in the coinbase
transaction of the block (by adding this as a rule for verifying new
blocks). The miner of 100 blocks after the current one can add a secondary
transaction spending this block's anyone-can-spend coinbase transaction
(due to the coinbase needing 100 blocks to mature) and thus claiming the
funds. This way, the block reward of a block X is always transferred to the
miner of block X+100.

Implementing this would require a soft-fork. Since that secondary
transaction needs no signature whatsoever, the overhead caused by that
extra transaction is negligible.

Possible Downside: When the fork is activated, the miners won?t get any
reward for mining blocks for a period of 100 blocks. They could choose to
power off the mining equipment for maintenance or to save power over that
period, so the hashrate could drop temporarily. However, if the hashrate
drops too much, blocks would take much longer to mine, and miners wouldn?t
want that either since they want to go through those 100 reward-less blocks
as soon as possible so they can start getting rewards from mining again.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180127/70e96d79/attachment.html>

From greg at xiph.org  Sat Jan 27 19:06:41 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Sat, 27 Jan 2018 19:06:41 +0000
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
Message-ID: <CAAS2fgSzx_beEQqPOdoRJRVMSk0JNT6LGk0fHTktVSCU7sH1cA@mail.gmail.com>

Not incentive compatible. Miners would prefer to include transactions
paying fees via alternative mechanisms (anyone can spend outputs,
direct pay to miner outputs, or completely out of band), if they even
paid attention to internal fees at all they would give a lot more
weight to direct payment fees. Users would accordingly pay much lower
fees if they used these alternatives instead of directly, so the
equlibrium state is almost everyone bypassing.   Bypass fee mechenisms
have been supported by miners since 2011 too, so it isn't just
conjecture.

On Sat, Jan 27, 2018 at 8:45 AM, Nathan Parker via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> Miners can fill their blocks with transactions paying very high fees at no
> cost because they get the fees back to themselves. They can do this for
> different purposes, like trying to increase the recommended fee. Here I
> propose a backwards-compatible solution to this problem.
>
> The solution would be to reward the fees of the current block to the miner
> of the next block (or X blocks after the current one). That way, if a miner
> floods its own block with very high fee transactions, those fees are no
> longer given back to itself, but to the miner of future blocks which could
> potentially be anyone. Flooding blocks with fake txs is now discouraged.
> However, filling blocks with real transactions paying real fees is still
> encouraged because you could be the one to mine the block that would claim
> this reward.
>
> The way to implement this in a backwards-compatible fashion would be to
> enforce miners to set an anyone-can-spend output in the coinbase transaction
> of the block (by adding this as a rule for verifying new blocks). The miner
> of 100 blocks after the current one can add a secondary transaction spending
> this block's anyone-can-spend coinbase transaction (due to the coinbase
> needing 100 blocks to mature) and thus claiming the funds. This way, the
> block reward of a block X is always transferred to the miner of block X+100.
>
> Implementing this would require a soft-fork. Since that secondary
> transaction needs no signature whatsoever, the overhead caused by that extra
> transaction is negligible.
>
> Possible Downside: When the fork is activated, the miners won?t get any
> reward for mining blocks for a period of 100 blocks. They could choose to
> power off the mining equipment for maintenance or to save power over that
> period, so the hashrate could drop temporarily. However, if the hashrate
> drops too much, blocks would take much longer to mine, and miners wouldn?t
> want that either since they want to go through those 100 reward-less blocks
> as soon as possible so they can start getting rewards from mining again.
>
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>

From eric at voskuil.org  Sat Jan 27 23:48:10 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Sat, 27 Jan 2018 15:48:10 -0800
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAAS2fgSzx_beEQqPOdoRJRVMSk0JNT6LGk0fHTktVSCU7sH1cA@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAAS2fgSzx_beEQqPOdoRJRVMSk0JNT6LGk0fHTktVSCU7sH1cA@mail.gmail.com>
Message-ID: <65742e8e-ee27-40b9-f8ad-37f22916002d@voskuil.org>

The OP premise is flawed:

https://github.com/libbitcoin/libbitcoin/wiki/Fee-Recovery-Fallacy

as is the idea that side fees are incentive incompatible:

https://github.com/libbitcoin/libbitcoin/wiki/Side-Fee-Fallacy

e

On 01/27/2018 11:06 AM, Gregory Maxwell via bitcoin-dev wrote:
> Not incentive compatible. Miners would prefer to include transactions
> paying fees via alternative mechanisms (anyone can spend outputs,
> direct pay to miner outputs, or completely out of band), if they even
> paid attention to internal fees at all they would give a lot more
> weight to direct payment fees. Users would accordingly pay much lower
> fees if they used these alternatives instead of directly, so the
> equlibrium state is almost everyone bypassing.   Bypass fee mechenisms
> have been supported by miners since 2011 too, so it isn't just
> conjecture.
> 
> On Sat, Jan 27, 2018 at 8:45 AM, Nathan Parker via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> Miners can fill their blocks with transactions paying very high fees at no
>> cost because they get the fees back to themselves. They can do this for
>> different purposes, like trying to increase the recommended fee. Here I
>> propose a backwards-compatible solution to this problem.
>>
>> The solution would be to reward the fees of the current block to the miner
>> of the next block (or X blocks after the current one). That way, if a miner
>> floods its own block with very high fee transactions, those fees are no
>> longer given back to itself, but to the miner of future blocks which could
>> potentially be anyone. Flooding blocks with fake txs is now discouraged.
>> However, filling blocks with real transactions paying real fees is still
>> encouraged because you could be the one to mine the block that would claim
>> this reward.
>>
>> The way to implement this in a backwards-compatible fashion would be to
>> enforce miners to set an anyone-can-spend output in the coinbase transaction
>> of the block (by adding this as a rule for verifying new blocks). The miner
>> of 100 blocks after the current one can add a secondary transaction spending
>> this block's anyone-can-spend coinbase transaction (due to the coinbase
>> needing 100 blocks to mature) and thus claiming the funds. This way, the
>> block reward of a block X is always transferred to the miner of block X+100.
>>
>> Implementing this would require a soft-fork. Since that secondary
>> transaction needs no signature whatsoever, the overhead caused by that extra
>> transaction is negligible.
>>
>> Possible Downside: When the fork is activated, the miners won?t get any
>> reward for mining blocks for a period of 100 blocks. They could choose to
>> power off the mining equipment for maintenance or to save power over that
>> period, so the hashrate could drop temporarily. However, if the hashrate
>> drops too much, blocks would take much longer to mine, and miners wouldn?t
>> want that either since they want to go through those 100 reward-less blocks
>> as soon as possible so they can start getting rewards from mining again.
>>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180127/f4627e13/attachment.sig>

From willtech at live.com.au  Sun Jan 28 11:05:59 2018
From: willtech at live.com.au (Damian Williamson)
Date: Sun, 28 Jan 2018 11:05:59 +0000
Subject: [bitcoin-dev] Does Lightning require millisatoshi unit?
Message-ID: <PS2P216MB0179FB489FB8BA4D9CBAEAF89DE60@PS2P216MB0179.KORP216.PROD.OUTLOOK.COM>

It seems in a document that I was referenced with this very question that the unit for creating invoices on Lightning is millisatoshi. Do we really need to invoice for 1000 millisatoshi for a 1 sat transaction?


https://github.com/ElementsProject/lightning/blob/master/README.md#sending-and-receiving-payments

[https://avatars2.githubusercontent.com/u/12729539?s=400&v=4]<https://github.com/ElementsProject/lightning/blob/master/README.md#sending-and-receiving-payments>

lightning/README.md at master ? ElementsProject/lightning ...<https://github.com/ElementsProject/lightning/blob/master/README.md#sending-and-receiving-payments>
github.com
c-lightning is a standard compliant implementation of the Lightning Network protocol. The Lightning Network is a scalability solution for Bitcoin, enabling secure and ...


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/e0ffdc17/attachment-0001.html>

From sjors at sprovoost.nl  Sun Jan 28 16:43:34 2018
From: sjors at sprovoost.nl (Sjors Provoost)
Date: Sun, 28 Jan 2018 17:43:34 +0100
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <PdUSy7mO1QTH-sAU_gBRjZOhLi1FoZRPUhNZt80kPL8d0lOgsCfMeNzf52Ae7_wrcTBy7d-tROvRLqBuHMMtmduzAskGuzPlwxI2yG4yY64=@protonmail.com>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
	<20180124074453.GC12767@savin.petertodd.org>
	<CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>
	<PdUSy7mO1QTH-sAU_gBRjZOhLi1FoZRPUhNZt80kPL8d0lOgsCfMeNzf52Ae7_wrcTBy7d-tROvRLqBuHMMtmduzAskGuzPlwxI2yG4yY64=@protonmail.com>
Message-ID: <36682FF4-5C68-4610-9E82-FCE6F93E050F@sprovoost.nl>

I can see how merging after the fact could be more practical than appending existing transactions.

I think what Moral Agent suggested is the same as your original proposal, namely dropping rule 3. Only fee per weight unit increase from rule 4 would matter.

The minimum per WU increase could be far higher than the minimum relay fee. The few times I?ve used RBF in practice I increased the fee by at least 50%. Rule 4 could be made more strict. I don?t know what number, if any, would address concerns about relay spam?

This wouldn?t be backward compatible. Does that matter as long as there?s enough nodes that follow the new rules? Is there a punishment for relaying transactions that violate rule 3? Could a recipient using the older rules be mislead (in a way that?s worse than the fact that RBF allows the sender to replace the transaction with anything they want anyway)?

Peter Todd wrote:
> You'd also be able to push others' txs out of the mempool.
Can you elaborate on this issue?

And wrote:
> payment service for instance where a large number of deposits are aggregated into a smaller number of payments

So this would involve wallets (of users who deposit coins) cooperating with an exchange API to consolidate in-mempool transactions?

And wrote:

> In fact I considered only requiring an increase in fee rate, based on the
theory that if absolute fee went down, the transaction must be smaller and thus
miners could overall earn more from the additional transactions they could fit
into their block. But to do that properly requires considering whether or not
that's actually true in the particular state the mempool as a whole happens to
be in, so I ditched that idea early on for the much simpler criteria of both a
feerate and absolute fee increase.

Why would you need to consider the whole mempool? Let?s say a miner is considering to replace transaction A and B with transaction C, where C pays a higher fee per byte than both A and B. This creates space for ~ one additional transaction in the block. It seems to me the miner only needs to check that the lowest fee per weight transaction > min_fee(A,B). At least in first approximation.

Sjors

> Op 24 jan. 2018, om 17:05 heeft Rhavar via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> het volgende geschreven:
> 
> 
>> I'm confused, the mempool only sees 1 transaction at a time, first A, then later B. "the original transactions", plural, should not exist in the mempool.
>> 
>> B's fee and rate needs to be larger than A's, but B will be greater than or equal to A anyway. So, just increasing the fee rate will cause a larger fee anyway.
>> 
>> Am I missing something?
> 
> Kind of. The first case is that you do the "smarter" type of merging, where you get an original transaction and then say add an additional output(s) to it.
> 
> The issue with this, is from a practical perspective is _very_ complex. Because you really need to do a lot of tracking to see which of the two transactions actually confirm. And if you are promising fast payments, you can be stuck in a weird limbo state where you're waiting for the original one to "safely" confirm before it's safe to make a re-payment (even a non-malicious will likely contain the replacement).
> 
> bip125 already supports this use-case, but I will suggest that the logic to deploy this is sufficiently complex that no one is going to attempt any time in the near future.
> 
> 
> But "retroactive transaction merging" is actually pretty approachable problem for a service to implement. You just get N valid transactions you've made, merge them into one. Strip extraneous inputs[1], and combine and alter the change amount.
> 
> The reason this is so appealing to implement, is there is very little complexity. If the "retroactive transaction merge" fails, or doesn't get confirmed, it actually has no impact. If it does get confirmed, that's just pure cost-savings.
> 
> However, the rules of bip125 currently make it (unnecessarily?) unappealing, because I can never lower the absolute amount of fees I pay. Hence I think it'd be pretty sweet if they could be relaxed to support this if it can be done in a pretty risk free way.
> 
> 
> 
> [1] Need to be very careful with that, if you're ever merging a merged transaction.
> 
> 
>> 
>> 
>> On Wed, Jan 24, 2018 at 3:44 AM, Peter Todd via bitcoin-dev <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>> On Tue, Jan 23, 2018 at 10:49:34PM +0000, Gregory Maxwell via bitcoin-dev wrote:
>>>> On Tue, Jan 23, 2018 at 10:19 PM, Rhavar via bitcoin-dev
>>>> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>>>>> Interesting. I didn't think about this before, but it seems like bip125 is
>>>>> rather incentive incompatible right now? If we're assuming a competitive
>>>>> mempool, it really doesn't seem generally rational to accept a replacement
>>>>> transaction of a lower fee rate.
>>>> 
>>>> BIP125 replacement requires that the fee rate increases.  The text of
>>>> the BIP document is written in a confusing way that doesn't make this
>>>> clear.
>>> 
>>> In fact I considered only requiring an increase in fee rate, based on the
>>> theory that if absolute fee went down, the transaction must be smaller and thus
>>> miners could overall earn more from the additional transactions they could fit
>>> into their block. But to do that properly requires considering whether or not
>>> that's actually true in the particular state the mempool as a whole happens to
>>> be in, so I ditched that idea early on for the much simpler criteria of both a
>>> feerate and absolute fee increase.
>>> 
>>> --
>>> https://petertodd.org 'peter'[:-1]@petertodd.org
>>> 


From lvella at gmail.com  Sun Jan 28 16:54:36 2018
From: lvella at gmail.com (Lucas Clemente Vella)
Date: Sun, 28 Jan 2018 14:54:36 -0200
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
Message-ID: <CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>

If the miner wants to force fees up, why would he fill up a block with
placeholder high fee transactions, instead of simply cutting off
transactions paying less fee than he is willing to take? Is there any
evidence someone is doing such a thing for whatever reason?

2018-01-27 6:45 GMT-02:00 Nathan Parker via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org>:

> Miners can fill their blocks with transactions paying very high fees at no
> cost because they get the fees back to themselves. They can do this for
> different purposes, like trying to increase the recommended fee. Here I
> propose a backwards-compatible solution to this problem.
>
> The solution would be to reward the fees of the current block to the miner
> of the next block (or X blocks after the current one). That way, if a miner
> floods its own block with very high fee transactions, those fees are no
> longer given back to itself, but to the miner of future blocks which could
> potentially be anyone. Flooding blocks with fake txs is now discouraged.
> However, filling blocks with real transactions paying real fees is still
> encouraged because you could be the one to mine the block that would claim
> this reward.
>
> The way to implement this in a backwards-compatible fashion would be to
> enforce miners to set an anyone-can-spend output in the coinbase
> transaction of the block (by adding this as a rule for verifying new
> blocks). The miner of 100 blocks after the current one can add a secondary
> transaction spending this block's anyone-can-spend coinbase transaction
> (due to the coinbase needing 100 blocks to mature) and thus claiming the
> funds. This way, the block reward of a block X is always transferred to the
> miner of block X+100.
>
> Implementing this would require a soft-fork. Since that secondary
> transaction needs no signature whatsoever, the overhead caused by that
> extra transaction is negligible.
>
> Possible Downside: When the fork is activated, the miners won?t get any
> reward for mining blocks for a period of 100 blocks. They could choose to
> power off the mining equipment for maintenance or to save power over that
> period, so the hashrate could drop temporarily. However, if the hashrate
> drops too much, blocks would take much longer to mine, and miners wouldn?t
> want that either since they want to go through those 100 reward-less blocks
> as soon as possible so they can start getting rewards from mining again.
>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>


-- 
Lucas Clemente Vella
lvella at gmail.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/712c01bf/attachment.html>

From dave at dtrt.org  Sun Jan 28 17:29:48 2018
From: dave at dtrt.org (David A. Harding)
Date: Sun, 28 Jan 2018 12:29:48 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <36682FF4-5C68-4610-9E82-FCE6F93E050F@sprovoost.nl>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
	<20180124074453.GC12767@savin.petertodd.org>
	<CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>
	<PdUSy7mO1QTH-sAU_gBRjZOhLi1FoZRPUhNZt80kPL8d0lOgsCfMeNzf52Ae7_wrcTBy7d-tROvRLqBuHMMtmduzAskGuzPlwxI2yG4yY64=@protonmail.com>
	<36682FF4-5C68-4610-9E82-FCE6F93E050F@sprovoost.nl>
Message-ID: <20180128172948.5y32cc6rvf3saolj@fedora-23-dvm>

On Sun, Jan 28, 2018 at 05:43:34PM +0100, Sjors Provoost via bitcoin-dev wrote:
> Peter Todd wrote:
> > In fact I considered only requiring an increase in fee rate, based on the
> > theory that if absolute fee went down, the transaction must be smaller and thus
> > miners could overall earn more from the additional transactions they could fit
> > into their block. But to do that properly requires considering whether or not
> > that's actually true in the particular state the mempool as a whole happens to
> > be in, so I ditched that idea early on for the much simpler criteria of both a
> > feerate and absolute fee increase.
> 
> Why would you need to consider the whole mempool? 

Imagine a miner is only concerned with creating the next block and his
mempool currently only has 750,000 vbytes in it.  If two 250-vbyte
transactions each paying a feerate of 100 nanobitcoins per vbyte (50k
total) are replaced with one 325-vbyte transaction paying a feerate of
120 nBTC (39k total), the miner's potential income from mining the next
block is reduced by 11k nBTC.

Moving away from this easily worked example, the problem can still exist
even if a miner has enough transactions to fill the next block.  For
replacement consideration only by increased feerate to be guaranteed
more profitable, one has to assume the mempool contains an effectively
continuous distribution of feerates.  That may one day be true of the
mempool (it would be good, because it helps keep block production
regular sans subsidy) but it's often not the case these days.

-Dave
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 819 bytes
Desc: not available
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/f2431b67/attachment.sig>

From rhavar at protonmail.com  Sun Jan 28 17:58:11 2018
From: rhavar at protonmail.com (Rhavar)
Date: Sun, 28 Jan 2018 12:58:11 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <20180128172948.5y32cc6rvf3saolj@fedora-23-dvm>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
	<20180124074453.GC12767@savin.petertodd.org>
	<CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>
	<PdUSy7mO1QTH-sAU_gBRjZOhLi1FoZRPUhNZt80kPL8d0lOgsCfMeNzf52Ae7_wrcTBy7d-tROvRLqBuHMMtmduzAskGuzPlwxI2yG4yY64=@protonmail.com>
	<36682FF4-5C68-4610-9E82-FCE6F93E050F@sprovoost.nl>
	<20180128172948.5y32cc6rvf3saolj@fedora-23-dvm>
Message-ID: <TRUCAZT1uSDAJVGt0kSdULxKcJXcijO-HosPBaDvib9OVLmMO_2qD4YaEwEf34SCi7xBNr5dPv6IK8dYkja4oZcK0xhZWgju3P2S4SfJ4ZA=@protonmail.com>

I don't think this is a realistic concern. The incentive compatibility _already_ exists (just in reverse: miners are refusing transactions that would increase their total fees in the next block), and as the mempool is already generally competitive enough it's actually worse the way it is.

But I don't think it makes sense to take a zealous approach on "incentive compatibility". Bitcoin is already built on a whole bunch of incentive incompatible behaviors, even things as simple as "change outputs" (you'd be better off privately giving your transaction to trusted miners without change, who deduct the min fee they would've needed and refund the rest OOB). Not to mention, we expect miners to avoid reorgs and stuff even if it's in their short-term interest.

At least personally, I think DoS risks are the real concern.

-Ryan

-------- Original Message --------
On January 28, 2018 12:29 PM, David A. Harding <dave at dtrt.org> wrote:

> On Sun, Jan 28, 2018 at 05:43:34PM +0100, Sjors Provoost via bitcoin-dev wrote:
>
>> Peter Todd wrote:
>>
>>> In fact I considered only requiring an increase in fee rate, based on the
>>> theory that if absolute fee went down, the transaction must be smaller and thus
>>> miners could overall earn more from the additional transactions they could fit
>>> into their block. But to do that properly requires considering whether or not
>>> that's actually true in the particular state the mempool as a whole happens to
>>> be in, so I ditched that idea early on for the much simpler criteria of both a
>>> feerate and absolute fee increase.
>>
>> Why would you need to consider the whole mempool?
>
> Imagine a miner is only concerned with creating the next block and his
> mempool currently only has 750,000 vbytes in it. If two 250-vbyte
> transactions each paying a feerate of 100 nanobitcoins per vbyte (50k
> total) are replaced with one 325-vbyte transaction paying a feerate of
> 120 nBTC (39k total), the miner's potential income from mining the next
> block is reduced by 11k nBTC.
>
> Moving away from this easily worked example, the problem can still exist
> even if a miner has enough transactions to fill the next block. For
> replacement consideration only by increased feerate to be guaranteed
> more profitable, one has to assume the mempool contains an effectively
> continuous distribution of feerates. That may one day be true of the
> mempool (it would be good, because it helps keep block production
> regular sans subsidy) but it's often not the case these days.
>
> -Dave
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/bc4e57d3/attachment-0001.html>

From ethan.scruples at gmail.com  Sun Jan 28 18:08:33 2018
From: ethan.scruples at gmail.com (Moral Agent)
Date: Sun, 28 Jan 2018 13:08:33 -0500
Subject: [bitcoin-dev] Transaction Merging (bip125 relaxation)
In-Reply-To: <20180128172948.5y32cc6rvf3saolj@fedora-23-dvm>
References: <M8yPGuNmrXfNNwrYDDLpTVb__BhGysVW060Cq_tMc-AC6F7pKd1Vvb4wWbpmhhEvfoQ7fn-EcgfxRwJSVkFAZ5x57hg9XxpdZlDPi2IBJZg=@protonmail.com>
	<20180122200023.GA1055@savin.petertodd.org>
	<7yyS0mCgC8UWMYR_Jf1hB_GkkGj6Iu8tnIO7TeXWWyCrg9j4RZ7ziprCPZcv2xsFZdUzcFuHyeMU2-RBujzlSXdUAWlqdricuL2abaX0PWE=@protonmail.com>
	<CACiOHGw=XUe6Fxmh8JkNPZWK1d3hWaaVPsNy1dPNoU1qULckrA@mail.gmail.com>
	<oY5fxEk2FEJwHTtN9hKit2Unfu9C6CpSKLOVr0Tu99W_ctym_TNtEPLjgSg77e_RePgWHLBF7sNZoXa11aDgm6ClDxT33Jz2M-q3HZC1n40=@protonmail.com>
	<CAAS2fgQBMSOhDBUZ6d9cG7fHg4tRr8o+E0j3ZXhdHkxv4kTwUA@mail.gmail.com>
	<20180124074453.GC12767@savin.petertodd.org>
	<CALPhJayjSopa6qPDAo=8-FVCz5+SjXneGMmoYF2Yi2p3FrCb0g@mail.gmail.com>
	<PdUSy7mO1QTH-sAU_gBRjZOhLi1FoZRPUhNZt80kPL8d0lOgsCfMeNzf52Ae7_wrcTBy7d-tROvRLqBuHMMtmduzAskGuzPlwxI2yG4yY64=@protonmail.com>
	<36682FF4-5C68-4610-9E82-FCE6F93E050F@sprovoost.nl>
	<20180128172948.5y32cc6rvf3saolj@fedora-23-dvm>
Message-ID: <CACiOHGyB-+zEW87af8GsHZAMks4-DjFmZO3Q9=ZjY2LBC8Lr0Q@mail.gmail.com>

As you point out, depending on the mempool, sometimes a miner makes more
fee by including A and B, while other times a miner makes more fee by
including C (the replacement for A and B) and D (a hypothetical transaction
that cannot be fit into a block that contains A and B but can be fit into a
block with C.

So what are we to make of this? Is it better to relay C or better to not
relay C?

Clearly it is better for the miner if they know about C, because knowing
about C costs them nothing, but not knowing about C will sometimes result
in them earning less fees.

Clearly it is better for the people who are creating C for those
transactions to be mined instead of the more expensive A and B transactions.

Everyone else is better off in that more transactions would get included in
blocks.

A concern about burdening full nodes with extra transactions to relay that
may not be more profitable to mine than the transactions they replace is
still rational -- though intuitively it seems like there would be a limit
on how many times an attacker could cheaply reorganize transactions into
something with a higher fee rate.

Perhaps there are also concerns with reconstruction of blocks from compact
blocks, given that miners would have more decisions to make about which tx
to include?



On Sun, Jan 28, 2018 at 12:29 PM, David A. Harding via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Sun, Jan 28, 2018 at 05:43:34PM +0100, Sjors Provoost via bitcoin-dev
> wrote:
> > Peter Todd wrote:
> > > In fact I considered only requiring an increase in fee rate, based on
> the
> > > theory that if absolute fee went down, the transaction must be smaller
> and thus
> > > miners could overall earn more from the additional transactions they
> could fit
> > > into their block. But to do that properly requires considering whether
> or not
> > > that's actually true in the particular state the mempool as a whole
> happens to
> > > be in, so I ditched that idea early on for the much simpler criteria
> of both a
> > > feerate and absolute fee increase.
> >
> > Why would you need to consider the whole mempool?
>
> Imagine a miner is only concerned with creating the next block and his
> mempool currently only has 750,000 vbytes in it.  If two 250-vbyte
> transactions each paying a feerate of 100 nanobitcoins per vbyte (50k
> total) are replaced with one 325-vbyte transaction paying a feerate of
> 120 nBTC (39k total), the miner's potential income from mining the next
> block is reduced by 11k nBTC.
>
> Moving away from this easily worked example, the problem can still exist
> even if a miner has enough transactions to fill the next block.  For
> replacement consideration only by increased feerate to be guaranteed
> more profitable, one has to assume the mempool contains an effectively
> continuous distribution of feerates.  That may one day be true of the
> mempool (it would be good, because it helps keep block production
> regular sans subsidy) but it's often not the case these days.
>
> -Dave
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/3c990f38/attachment.html>

From cannon at cannon-ciota.info  Mon Jan 29 00:40:32 2018
From: cannon at cannon-ciota.info (CANNON)
Date: Mon, 29 Jan 2018 00:40:32 +0000
Subject: [bitcoin-dev] NIST 8202 Blockchain Technology Overview
Message-ID: <6d24833d-f127-04ea-d180-c69409de16a5@cannon-ciota.info>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

January 20 2018

(I am also forwarding this message to the bitcoin mailing list just in case there
are other technological errors that could use correction in this draft paper or
anything that should be added with my comments.)

To the authors of this paper,
I am commenting on Draft NISTIR 8202 Blockchain Technology Overview located at
https://csrc.nist.gov/CSRC/media/Publications/nistir/8202/draft/documents/nistir8202-draft.pdf

Just in case that document is modified or removed I have also downloaded
it to redistribute this error ridden draft at a later point if neccesary,
and I also had the Internet Archive save a copy here for sake of archival reasons
to give context to this message.

https://web.archive.org/web/20180124170359/https://csrc.nist.gov/CSRC/media/Publications/nistir/8202/draft/documents/nistir8202-draft.pdf

There are a couple things I would like to contribute on regarding some
corrections needed in this paper. I must say, the content in this paper is
making me doubt the credibility of the NIST. I am starting to wonder if the
NIST is also incompetent with lack of credibility just like with most other
government institutions. Falsified information published as truth such as this
only expose their ignorance and incompetence and also propagate such ignorance
to other institutions and people whom rely on NIST for information or research.
The information presented in this paper is technologically invalid and contains
false information. I understand that mistakes happen, but this specific section
regarding "8.1.2 Bitcoin Cash (BCC)" is obviously written without prior research.
Even if research was done no citation is included to back these claims.
I ask you to please conduct research and validate information before publishing it,
especially when the credibility of the NIST is at stake.

I will proceed to outline some corrections.

1. Bitcoin Cash uses the ticker BCH, BCC is the ticker for BitConnectCoin

2. "When SegWit was activated, it caused a hard fork"
This is incorrect information. Segwit was not a hardfork. Rather segwit was
a softfork meaning that it is backwards compatible with unupgraded nodes and
miners. With it being a softfork it actually prevents a fork in the blockchain
by still being valid to unupgraded nodes and miners. Because segregated witness
is not a hardfork its use is optional.

3. "and all the mining nodes and users who did not want to change started
calling the original Bitcoin blockchain Bitcoin Cash (BCC)"
The original bitcoin blockchain is still called Bitcoin. Segwit did not create
any fork in the blockchain. Bitcoin Cash however was a hard fork that resulted
in a forked blockchain and new altcoin.
Bitcoin is Bitcoin,
Bitcoin Cash is Bitcoin Cash.

4. "Technically, Bitcoin is a fork and Bitcoin Cash is the original
blockchain."
Technically, that statement is not truth.

Bitcoin Cash was forked from the original Bitcoin blockchain to create
the altcoin "Bitcoin Cash" (BCH) by people whom believe that the blocksize
should be large enough to accomodate all individual transactions on the main
chain. Without going into any of my personal opinions of which one is better
(bitcoin vs. "bitcoin cash") technically Bitcoin Cash was a hardfork and is
not the original chain but a forked one. It is a hardfork as the blocks
generated by BCH are incompatible with BTC nodes. Because of this lack of
backwards compatibility, and the resulting fork in blockchain is why BCH is
technically a hardfork.

This is just one section of this paper I have read thus far. It makes me
wonder how many other fallacies are throughout this paper. I also wonder how
many other NIST papers exist out of draft form that contain errors. Even
the smallest amount of research could have prevented this in the case of
this paper, unless you are intentionally pushing false information.

I hope these comments are of benefit to the improvement of this paper.

Cannon
PGP Fingerprint: 2BB5 15CD 66E7 4E28 45DC 6494 A5A2 2879 3F06 E832 
Email: cannon at cannon-ciota.info

NOTICE: ALL EMAIL CORRESPONDENCE NOT SIGNED/ENCRYPTED WITH PGP SHOULD 
BE CONSIDERED POTENTIALLY FORGED, AND NOT PRIVATE.

-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJabmySAAoJEAYDai9lH2mwVPcP/ika01NHFMBbxVU9OKc4Ibrd
12MpWW2sgvB14dm8NIuh/xQeFpxGjKvkwWCzqj0pSOE+WClVdK573MJcZF1hqnR4
iPNIr3noR632Hyl9V3Cst5hg5BiUmwETpsyDXG7q7Oj/bX3QAR+psjahk2H2gA6v
i4m1BP4052eRymznJ8aRQc1ak23C4ylLvjC3RRfNmXozG77N4w+tQvFXq45yQam+
nh/8EIck5D9vNTOtVgzgjVqQwfDgUsxgClqHGLNiUOSSievCQLhz1WynDZZSlKmf
Y1Gd70fBpHdrhLBe/SOLglZXPU2BTlicUoN/t9P+5i4qzPfNxfMW9eRi/Urd4sJX
INUuEUMJ2m5EspFjv3rMT19ELts8WhGskBq/4OCT8Wlb9arzhvrDySzLdX5ij75V
DhIX1r3CMDVN4HNb1V4M+Je4Wgle7oh+LS2QDjBnw3IMfjF37j+3OXiRDrlAkE30
GNg0SooANGBvMIMdjnc8fwIV/TxeNh0vEj8M2a4VjbthiDT4L1a4CzxOqT3eWbvB
YHUdz+hwSnydkj5EhyC2e0XN3zqvgSNYoE8HTvKG78ik49bZpxkssEuMWC5N+KM8
j2pgzbVdJXu08mwxrgf2wylUpR630WAEXkcVg3rOw+irPl1U0VxzNL8eNFZehMe6
nuUyXL4VMlApOgesmrCI
=RQoE
-----END PGP SIGNATURE-----

From eric at voskuil.org  Mon Jan 29 00:46:51 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 28 Jan 2018 16:46:51 -0800
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
Message-ID: <807a2661-b83e-1fc7-3db0-35ee120745bd@voskuil.org>

Miners accept less than the optimal (i.e. highest net fee) set of
transactions all the time. The reason is that it takes too much time to
compute the optimal set. All other things being equal, the miner who is
more efficient at computing a set is more profitable.

Intentionally not accepting the most optimal set possible is a cost, not
a source of increased returns. Miners can raise the historical fee level
by paying this real cost, just as can any other person (by submitting a
competitive-fee transaction). They cannot "recover" this cost. They have
no place of advantage in terms of competing for block space.

Finally, historical prices do not determine future prices. Current
competition for block space determines future prices.

e

On 01/28/2018 08:54 AM, Lucas Clemente Vella via bitcoin-dev wrote:
> If the miner wants to force fees up, why would he fill up a block with
> placeholder high fee transactions, instead of simply cutting off
> transactions paying less fee than he is willing to take? Is there any
> evidence someone is doing such a thing for whatever reason?
>
> 2018-01-27 6:45 GMT-02:00 Nathan Parker via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>>:
> 
>     Miners can fill their blocks with transactions paying very high fees
>     at no cost because they get the fees back to themselves. They can do
>     this for different purposes, like trying to increase the recommended
>     fee. Here I propose a backwards-compatible solution to this problem.
> 
>     The solution would be to reward the fees of the current block to the
>     miner of the next block (or X blocks after the current one). That
>     way, if a miner floods its own block with very high fee
>     transactions, those fees are no longer given back to itself, but to
>     the miner of future blocks which could potentially be anyone.
>     Flooding blocks with fake txs is now discouraged. However, filling
>     blocks with real transactions paying real fees is still encouraged
>     because you could be the one to mine the block that would claim this
>     reward.
> 
>     The way to implement this in a backwards-compatible fashion would be
>     to enforce miners to set an anyone-can-spend output in the coinbase
>     transaction of the block (by adding this as a rule for verifying new
>     blocks). The miner of 100 blocks after the current one can add a
>     secondary transaction spending this block's anyone-can-spend
>     coinbase transaction (due to the coinbase needing 100 blocks to
>     mature) and thus claiming the funds. This way, the block reward of a
>     block X is always transferred to the miner of block X+100.
> 
>     Implementing this would require a soft-fork. Since that secondary
>     transaction needs no signature whatsoever, the overhead caused by
>     that extra transaction is negligible.
> 
>     Possible Downside: When the fork is activated, the miners won?t get
>     any reward for mining blocks for a period of 100 blocks. They could
>     choose to power off the mining equipment for maintenance or to save
>     power over that period, so the hashrate could drop temporarily.
>     However, if the hashrate drops too much, blocks would take much
>     longer to mine, and miners wouldn?t want that either since they want
>     to go through those 100 reward-less blocks as soon as possible so
>     they can start getting rewards from mining again.
> 
> 
> 
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 
> 
> 
> -- 
> Lucas Clemente Vella
> lvella at gmail.com <mailto:lvella at gmail.com>
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/5e6da2a0/attachment.sig>

From cannon at cannon-ciota.info  Mon Jan 29 01:08:24 2018
From: cannon at cannon-ciota.info (CANNON)
Date: Mon, 29 Jan 2018 01:08:24 +0000
Subject: [bitcoin-dev] NIST 8202 Blockchain Technology Overview
In-Reply-To: <cad6fbdf-b826-41e8-f8ff-c37ec72193e9@cannon-ciota.info>
References: <cad6fbdf-b826-41e8-f8ff-c37ec72193e9@cannon-ciota.info>
Message-ID: <5965665b-0db1-6a1d-572b-61b750b514b7@cannon-ciota.info>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Slight correction to email I just posted titled "NIST 8202 Blockchain Technology Overview"
The date in top of email states Jan 20, corrected date is Jan 28th which can be validated
also by verifying my signature (gpg includes timestamp when signing).

I also sent email with corrected date to NIST comments email address.
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJabnPNAAoJEAYDai9lH2mwzywP/Rr5qlkfihE6SkUZrMRp2G1R
jANSEOMgH3yj7UmNKO2Xqzw93ZyNxNIVAL7z2ru2A6D0ziPgMOUKzyTXbDDpqtJR
mvnI0pe50UpDIbpBMx18X6pGw97LlnEYR81UKeEUPJWDzE1auJiuBr+teHMqVA5O
DjGqYVQM/3LEK2yeKfYcTtxBqnHE3jwGnqV7AviHT6KqxmKuLQe18Rs+wNR9wmWO
RYSsp3lD0sIYAC/snZx1c3NrwnB5kbwTbISzYLF5wK6WOcguoUPTFnZ7x1uEHImt
pbDdgDKnkuUusHTGQJEz+0xYjugcYImP12nx73qrUUJBq17g9BdfhdBGlRXabIzu
STRDw3gwnoqfXcJLeJ8/3ICauA8TCkugp8vXXbQ+Gk5G/DXMYokR/DvxmTzWmvky
58vhrKOEFvVz9FBd6OALVbghQFVC8vtqvXB+AoM5bzHASlN+yOpt7wC4EOROla6f
qSusq3xvp3aybui5tmlTOQtvMV4kxxoqA/HFmJ/Wdxm3/oQdGCHw5qrlMtjILuM5
B5l+7UDbIiw6Vvi/ouGP7OekzJkTZo1tYY/95yXfg3I9cjv6wgEaRzHrVjF3o/FP
FQL4GN/Fnjz7E8VQ/w0ttJ+sRyoIMvd16FcRRIC0LzpsczlWuhpBfdxuSry80Loi
gztvxP9+MJVhJ5kZ27BJ
=BxwT
-----END PGP SIGNATURE-----

From gbalch714 at gmail.com  Mon Jan 29 01:44:08 2018
From: gbalch714 at gmail.com (George Balch)
Date: Sun, 28 Jan 2018 17:44:08 -0800
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
Message-ID: <CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>

If miners leave transactions out of a block they do pay a cost by not being
rewarded those fees.  If they include their own spam transactions to get
back the fee they gain nothing.  Since blocks can have fees resulting in
hundreds of thousands of dollars, it would seem unlikely that miners incur
a huge cost for not including transactions.

On Sun, Jan 28, 2018 at 8:54 AM, Lucas Clemente Vella via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> If the miner wants to force fees up, why would he fill up a block with
> placeholder high fee transactions, instead of simply cutting off
> transactions paying less fee than he is willing to take? Is there any
> evidence someone is doing such a thing for whatever reason?
>
> 2018-01-27 6:45 GMT-02:00 Nathan Parker via bitcoin-dev <
> bitcoin-dev at lists.linuxfoundation.org>:
>
>> Miners can fill their blocks with transactions paying very high fees at
>> no cost because they get the fees back to themselves. They can do this for
>> different purposes, like trying to increase the recommended fee. Here I
>> propose a backwards-compatible solution to this problem.
>>
>> The solution would be to reward the fees of the current block to the
>> miner of the next block (or X blocks after the current one). That way, if a
>> miner floods its own block with very high fee transactions, those fees are
>> no longer given back to itself, but to the miner of future blocks which
>> could potentially be anyone. Flooding blocks with fake txs is now
>> discouraged. However, filling blocks with real transactions paying real
>> fees is still encouraged because you could be the one to mine the block
>> that would claim this reward.
>>
>> The way to implement this in a backwards-compatible fashion would be to
>> enforce miners to set an anyone-can-spend output in the coinbase
>> transaction of the block (by adding this as a rule for verifying new
>> blocks). The miner of 100 blocks after the current one can add a secondary
>> transaction spending this block's anyone-can-spend coinbase transaction
>> (due to the coinbase needing 100 blocks to mature) and thus claiming the
>> funds. This way, the block reward of a block X is always transferred to the
>> miner of block X+100.
>>
>> Implementing this would require a soft-fork. Since that secondary
>> transaction needs no signature whatsoever, the overhead caused by that
>> extra transaction is negligible.
>>
>> Possible Downside: When the fork is activated, the miners won?t get any
>> reward for mining blocks for a period of 100 blocks. They could choose to
>> power off the mining equipment for maintenance or to save power over that
>> period, so the hashrate could drop temporarily. However, if the hashrate
>> drops too much, blocks would take much longer to mine, and miners wouldn?t
>> want that either since they want to go through those 100 reward-less blocks
>> as soon as possible so they can start getting rewards from mining again.
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
>
> --
> Lucas Clemente Vella
> lvella at gmail.com
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/dc779353/attachment.html>

From neiman.mail at gmail.com  Mon Jan 29 13:34:20 2018
From: neiman.mail at gmail.com (Neiman)
Date: Mon, 29 Jan 2018 14:34:20 +0100
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
Message-ID: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>

First time posting here, please be gentle.

I'm doing a research project about blockchain timestamping. There are many
such projects, including the fantastic OpenTimestamps.

All of the projects essentially save some data in a block, and rely on the
block timestamp as a proof that this data existed at some specific time.

But how accurate are Bitcoins timestamps?

I didn't find any discussion or research regarding Bitcoin timestamp
accuracy (also not in the history of this mailing list). I share here a
simple analysis of timestamp accuracy, and a suggestion how to improve it.

Basic observations and questions:
-------------------------------------------
*1.* It seems to me that the timestamp is not the time that the block was
created. Ideally, it's the time that the miner started to try to mine the
block. However, as timestamps may also be used as a source of variety for
hashes, the exact meaning of its value is unclear.

If this is true, then there's a strange phenomena to observe in
blockchain.info and blockexplorer.com: the timestamps of blocks equals the
receiving times.

Am I wrong in my understanding, or is there a mistake in those websites?

*2.* Timestamps are not necessary to avoid double-spending. A simple
ordering of blocks is sufficient, so exchanging timestamps with enumeration
would work double-spending wise. Permissioned consensus protocols, such as
hyperledger, indeed have no timestamps (in version 1.0).

As far as I could tell, timestamps are included in Bitcoin's protocol
*only* to adjust the difficulty of PoW.

Direct control of timestamp accuracy:
-----------------------------------------------
The only element in the protocol that I found to control timestamp accuracy
is based on the network time concept.

The Bitcoin protocol defines ?network time? for each node. The network time
is the median time of the other clients, but only if
    1. there are at least 5 connected, and
    2. the difference between the median time and the nodes own system time
is less than 70 minutes.

Then new blocks are accepted by the peers if their timestamps is
    1. less than the network time plus 2 hours, and
    2. greater than the median timestamp of previous 11 blocks.

The first rule supplies a 2 hour upper bound for timestamp accuracy.

However, the second rule doesn't give a tight lower bound. Actually, no
lower bound is given at all if no assumption is made about the median. If
we assume the median to be accurate enough at some timepoint, then we're
only assured that any future timestamp is no bigger than this specific
median, which is not much information.

Further analysis can be made under different assumptions. For example,
what's the accuracy if holders of 51% of the computational power create
honest timestamps? But unfortunately, I don't see any good reason to work
under such an assumptions.

The second rule cannot be strengthened to be similar to the first one
(i.e., nodes don't accept blocks less than network time minus 2 hours). The
reason is that nodes cannot differentiate if it's a new block with
dishonest timestamp, an old block with an old timestamps (with many other
blocks coming) or simply a new block that took a long time to mine.

Indirect control of timestamps accuracy:
--------------------------------------------------
If we assume that miners have no motive to increase difficulty
artificially, then the PoW adjusting algorithm yields a second mechanism of
accuracy control.

The adjustment rules are given in pow.cpp (bitcoin-core source, version
0.15.1), in the function 'CalculateNextWorkRequired', by the formula (with
some additional adjustments which I omit):

    (old_target* (time_of_last_block_in_2016_blocks_interval -
time_of_first_block_in_2016_blocks_interval) )/time_of_two_weeks

It uses a simple average of block time in the last 2016 blocks. But such
averages ignore any values besides the first and last one in the interval.
Hence, if the difficulty is constant, the following sequence is valid from
both the protocol and the miners incentives point of views:

    1, 2, 3,?., 2015, 1209600 (time of two weeks), 2017, 2018, 2019,?.,
4031, 1209600*2, 4033, 4044, ?

If we want to be pedantic, the best lower bound for a block timestamp is
the timestamp of the block that closes the adjustment interval in which it
resides.

Possible improvement:
-----------------------------
We may consider exchanging average with standard deviation in the
difficulty adjustment formula. It both better mirrors changes in the hash
power along the interval, and disables the option to manipulate timestamps
without affecting the difficulty.

I'm aware that this change requires a hardfork, and won't happen any time
soon. But does it make sense to add it to a potential future hard fork?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/66a8d265/attachment.html>

From eric at voskuil.org  Mon Jan 29 04:49:10 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Sun, 28 Jan 2018 20:49:10 -0800
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
	<CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>
Message-ID: <261a9388-64fe-a664-85f0-4b0e8ca9ec1e@voskuil.org>

Your statements contradict each other.

This is not a question of whether it is a "huge" cost, but whether there
is an problem of incentive compatibility, which there is not. Miners
incur the opportunity cost of the space that they mine that does not
include the most optimal fees, which is equal in value to those forgone
fees.

If miners exclude available higher-fee transactions, or mine empty
space, or mine their own "recovery" transactions, they are merely
purchasing block space at market rates, just like everyone else.

The only difference is that they are getting nothing in return, while
everyone else is presumably getting a useful monetary transfer. In other
words, they are losing value to do this. Therefore the incentive is to
not do so. But again, the option to do so is perfectly incentive compatible.

I'm not sure who cooked up this myth about miners gaining advantage over
those who buy block space by mining empty space, rejecting higher-fee
transactions, and/or mining "recovery" transactions, but the idea is
complete nonsense.

e

On 01/28/2018 05:44 PM, George Balch via bitcoin-dev wrote:
> If miners leave transactions out of a block they do pay a cost by not
> being rewarded those fees.? If they include their own spam transactions
> to get back the fee they gain nothing.? Since blocks can have fees
> resulting in hundreds of thousands of dollars, it would seem unlikely
> that miners incur a huge cost for not including transactions.
> 
> On Sun, Jan 28, 2018 at 8:54 AM, Lucas Clemente Vella via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org
> <mailto:bitcoin-dev at lists.linuxfoundation.org>> wrote:
> 
>     If the miner wants to force fees up, why would he fill up a block
>     with placeholder high fee transactions, instead of simply cutting
>     off transactions paying less fee than he is willing to take? Is
>     there any evidence someone is doing such a thing for whatever reason?
> 
>     2018-01-27 6:45 GMT-02:00 Nathan Parker via bitcoin-dev
>     <bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>>:
> 
>         Miners can fill their blocks with transactions paying very high
>         fees at no cost because they get the fees back to themselves.
>         They can do this for different purposes, like trying to increase
>         the recommended fee. Here I propose a backwards-compatible
>         solution to this problem.
> 
>         The solution would be to reward the fees of the current block to
>         the miner of the next block (or X blocks after the current one).
>         That way, if a miner floods its own block with very high fee
>         transactions, those fees are no longer given back to itself, but
>         to the miner of future blocks which could potentially be anyone.
>         Flooding blocks with fake txs is now discouraged. However,
>         filling blocks with real transactions paying real fees is still
>         encouraged because you could be the one to mine the block that
>         would claim this reward.
> 
>         The way to implement this in a backwards-compatible fashion
>         would be to enforce miners to set an anyone-can-spend output in
>         the coinbase transaction of the block (by adding this as a rule
>         for verifying new blocks). The miner of 100 blocks after the
>         current one can add a secondary transaction spending this
>         block's anyone-can-spend coinbase transaction (due to the
>         coinbase needing 100 blocks to mature) and thus claiming the
>         funds. This way, the block reward of a block X is always
>         transferred to the miner of block X+100.
> 
>         Implementing this would require a soft-fork. Since that
>         secondary transaction needs no signature whatsoever, the
>         overhead caused by that extra transaction is negligible.
> 
>         Possible Downside: When the fork is activated, the miners won?t
>         get any reward for mining blocks for a period of 100 blocks.
>         They could choose to power off the mining equipment for
>         maintenance or to save power over that period, so the hashrate
>         could drop temporarily. However, if the hashrate drops too much,
>         blocks would take much longer to mine, and miners wouldn?t want
>         that either since they want to go through those 100 reward-less
>         blocks as soon as possible so they can start getting rewards
>         from mining again.
> 
> 
> 
>         _______________________________________________
>         bitcoin-dev mailing list
>         bitcoin-dev at lists.linuxfoundation.org
>         <mailto:bitcoin-dev at lists.linuxfoundation.org>
>         https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>         <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 
> 
> 
>     -- 
>     Lucas Clemente Vella
>     lvella at gmail.com <mailto:lvella at gmail.com>
> 
>     _______________________________________________
>     bitcoin-dev mailing list
>     bitcoin-dev at lists.linuxfoundation.org
>     <mailto:bitcoin-dev at lists.linuxfoundation.org>
>     https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>     <https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev>
> 
> 
> 
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180128/bec08c2b/attachment-0001.sig>

From greg at xiph.org  Mon Jan 29 21:22:25 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 29 Jan 2018 21:22:25 +0000
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <261a9388-64fe-a664-85f0-4b0e8ca9ec1e@voskuil.org>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
	<CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>
	<261a9388-64fe-a664-85f0-4b0e8ca9ec1e@voskuil.org>
Message-ID: <CAAS2fgQcMr231G4hF0rdp0M-rxOzLm07VHEdUuQ2BMnLa3A26g@mail.gmail.com>

On Mon, Jan 29, 2018 at 4:49 AM, Eric Voskuil via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> I'm not sure who cooked up this myth about miners gaining advantage over
> those who buy block space by mining empty space, rejecting higher-fee
> transactions, and/or mining "recovery" transactions, but the idea is
> complete nonsense.

I agree.

Steel-manning it, I guess I could argue that empty blocks are slightly
more conspicuous and might invite retaliation especially given the
high levels of mining centralization creates retaliation exposure. ...
but dummy transactions are hardly less conspicuous, many nodes log now
when blocks show up containing txn that they've never seen before.
Moreover, inexplicably underfilled blocks are produced (e.g. by
bitmain's antpool) and no retaliation seems to be forthcoming.

From tier.nolan at gmail.com  Mon Jan 29 21:40:44 2018
From: tier.nolan at gmail.com (Tier Nolan)
Date: Mon, 29 Jan 2018 21:40:44 +0000
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
Message-ID: <CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>

On Mon, Jan 29, 2018 at 1:34 PM, Neiman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> *2.* Timestamps are not necessary to avoid double-spending. A simple
> ordering of blocks is sufficient, so exchanging timestamps with enumeration
> would work double-spending wise. Permissioned consensus protocols, such as
> hyperledger, indeed have no timestamps (in version 1.0).
>

The timestamps simply needs to be reasonably accurate.  Their main purpose
is to allow difficulty updates.

They can also be used to check that the node has caught up.


> It uses a simple average of block time in the last 2016 blocks. But such
> averages ignore any values besides the first and last one in the interval.
> Hence, if the difficulty is constant, the following sequence is valid from
> both the protocol and the miners incentives point of views:
>
>     1, 2, 3,?., 2015, 1209600 (time of two weeks), 2017, 2018, 2019,?.,
> 4031, 1209600*2, 4033, 4044, ?
>

Much of Bitcoin operates on the assumption that a majority of miners are
honest.  If 50%+ of miners set their timestamp reasonably accurately (say
within 10 mins), then the actual timestamp will move forward at the same
rate as real time.

Dishonest miners could set their timestamp as low as possible, but the
median would move foward if more than half of the timestamps move forward.


> If we want to be pedantic, the best lower bound for a block timestamp is
> the timestamp of the block that closes the adjustment interval in which it
> resides.
>

If you are assuming that the miners are majority dishonest, then they can
set the limit to anything as long as they don't move it more than 2 hours
into the future.

The miners could set their timestamps so that they increase 1 week fake
time every 2 weeks real time and reject any blocks more than 2 hours ahead
of their fake time.  The difficulty would settle so that one block occurs
every 20 mins.


>
> Possible improvement:
> -----------------------------
> We may consider exchanging average with standard deviation in the
> difficulty adjustment formula. It both better mirrors changes in the hash
> power along the interval, and disables the option to manipulate timestamps
> without affecting the difficulty.
>
> I'm aware that this change requires a hardfork, and won't happen any time
> soon. But does it make sense to add it to a potential future hard fork?
>

For check locktime, the median of the last 11 blocks is used as an improved
indicator of what the actual real time is.  Again, it assumes that a
majority of the miners are honest.

>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/0d61ce0b/attachment.html>

From greg at xiph.org  Mon Jan 29 21:54:23 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Mon, 29 Jan 2018 21:54:23 +0000
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
	<CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>
Message-ID: <CAAS2fgRLMnpu5JHTxxJJvEQc8rj2Ox=cKCWcsvVdY06G0kKXJw@mail.gmail.com>

On Mon, Jan 29, 2018 at 9:40 PM, Tier Nolan via bitcoin-dev
<bitcoin-dev at lists.linuxfoundation.org> wrote:
> For check locktime, the median of the last 11 blocks is used as an improved
> indicator of what the actual real time is.  Again, it assumes that a
> majority of the miners are honest.

It would be more accurate to say that the median is not used for
improved accuracy but to mitigate a consensus incompatibility:

If the block's own timestamp were used for nlocktime and time based
nlocks were common on the network each miner would maximize their fee
income by setting the value as high as they could get away with.  What
concerned us wasn't so much that this would make the times less
accurate (though it would) but rather that it would create an
incentive for a runaway situation that could harm network stability
(e.g. with all miners cranking times against the 2hr window, then
creating pressure for miners to accept further and further in the
future; each responding to his own local incentives).

This incentive incompatibility could have been addressed e.g. by using
the prior block's time, but since the protocol doesn't require times
to be monotone (and for good reason!) the simple implementation of
that wouldn't have been a soft-fork.  The 11 block MTP worked out
nicely because the protocol already required new times to be larger
than that.

The timestamps in Bitcoin aren't intended to be particularly accurate.
They're used only for controlling the difficulty, and the adjustment
window is large enough that there isn't much distortion that can be
accomplished there.  It's not clear to me that much better can really
be done... if there were tighter time requirements in the protocol
miners would address them by running NTP which as an _astounding_ lack
of security in terms of how it is commonly deployed.  As far as I
know, I'm the only person whos ever mined blocks with their own
stratum 1 time source.

If times need to be accurate Bitcoin would need to use a rather
different design (e.g. each block would commit to the observation time
of the prior N blocks, and an iterative algorithm would solve for each
blocks time and each miners local offset).

IIRC open-timestamp calendar servers provide more precise
time-stamping under the assumption that the calendar server is
behaving correctly.

From kanzure at gmail.com  Mon Jan 29 22:23:46 2018
From: kanzure at gmail.com (Bryan Bishop)
Date: Mon, 29 Jan 2018 16:23:46 -0600
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
Message-ID: <CABaSBayXjU-Vyc0pn9hye8fdnk7ikAKCD=yxiP45VocsGc1nrQ@mail.gmail.com>

On Mon, Jan 29, 2018 at 7:34 AM, Neiman via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:
>
> But how accurate are Bitcoins timestamps?
>

A perspective on block timestamp and opentimestamps can be found here:
https://lists.w3.org/Archives/Public/public-blockchain/2016Sep/0076.html

- Bryan
http://heybryan.org/
1 512 203 0507
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/ff2b1170/attachment.html>

From gbalch714 at gmail.com  Mon Jan 29 21:53:06 2018
From: gbalch714 at gmail.com (George Balch)
Date: Mon, 29 Jan 2018 13:53:06 -0800
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
Message-ID: <CAC94VgDR7pXLtk5ZbQS9cO=NVLh-p7kMtAU8x+uT0ndCbjZrOA@mail.gmail.com>

The terms "simple ordering of blocks" and timestamp are essentially the
same thing.

On Jan 29, 2018 1:16 PM, "Neiman via bitcoin-dev" <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> First time posting here, please be gentle.
>
> I'm doing a research project about blockchain timestamping. There are many
> such projects, including the fantastic OpenTimestamps.
>
> All of the projects essentially save some data in a block, and rely on the
> block timestamp as a proof that this data existed at some specific time.
>
> But how accurate are Bitcoins timestamps?
>
> I didn't find any discussion or research regarding Bitcoin timestamp
> accuracy (also not in the history of this mailing list). I share here a
> simple analysis of timestamp accuracy, and a suggestion how to improve it.
>
> Basic observations and questions:
> -------------------------------------------
> *1.* It seems to me that the timestamp is not the time that the block was
> created. Ideally, it's the time that the miner started to try to mine the
> block. However, as timestamps may also be used as a source of variety for
> hashes, the exact meaning of its value is unclear.
>
> If this is true, then there's a strange phenomena to observe in
> blockchain.info and blockexplorer.com: the timestamps of blocks equals
> the receiving times.
>
> Am I wrong in my understanding, or is there a mistake in those websites?
>
> *2.* Timestamps are not necessary to avoid double-spending. A simple
> ordering of blocks is sufficient, so exchanging timestamps with enumeration
> would work double-spending wise. Permissioned consensus protocols, such as
> hyperledger, indeed have no timestamps (in version 1.0).
>
> As far as I could tell, timestamps are included in Bitcoin's protocol
> *only* to adjust the difficulty of PoW.
>
> Direct control of timestamp accuracy:
> -----------------------------------------------
> The only element in the protocol that I found to control timestamp
> accuracy is based on the network time concept.
>
> The Bitcoin protocol defines ?network time? for each node. The network
> time is the median time of the other clients, but only if
>     1. there are at least 5 connected, and
>     2. the difference between the median time and the nodes own system
> time is less than 70 minutes.
>
> Then new blocks are accepted by the peers if their timestamps is
>     1. less than the network time plus 2 hours, and
>     2. greater than the median timestamp of previous 11 blocks.
>
> The first rule supplies a 2 hour upper bound for timestamp accuracy.
>
> However, the second rule doesn't give a tight lower bound. Actually, no
> lower bound is given at all if no assumption is made about the median. If
> we assume the median to be accurate enough at some timepoint, then we're
> only assured that any future timestamp is no bigger than this specific
> median, which is not much information.
>
> Further analysis can be made under different assumptions. For example,
> what's the accuracy if holders of 51% of the computational power create
> honest timestamps? But unfortunately, I don't see any good reason to work
> under such an assumptions.
>
> The second rule cannot be strengthened to be similar to the first one
> (i.e., nodes don't accept blocks less than network time minus 2 hours). The
> reason is that nodes cannot differentiate if it's a new block with
> dishonest timestamp, an old block with an old timestamps (with many other
> blocks coming) or simply a new block that took a long time to mine.
>
> Indirect control of timestamps accuracy:
> --------------------------------------------------
> If we assume that miners have no motive to increase difficulty
> artificially, then the PoW adjusting algorithm yields a second mechanism of
> accuracy control.
>
> The adjustment rules are given in pow.cpp (bitcoin-core source, version
> 0.15.1), in the function 'CalculateNextWorkRequired', by the formula (with
> some additional adjustments which I omit):
>
>     (old_target* (time_of_last_block_in_2016_blocks_interval -
> time_of_first_block_in_2016_blocks_interval) )/time_of_two_weeks
>
> It uses a simple average of block time in the last 2016 blocks. But such
> averages ignore any values besides the first and last one in the interval.
> Hence, if the difficulty is constant, the following sequence is valid from
> both the protocol and the miners incentives point of views:
>
>     1, 2, 3,?., 2015, 1209600 (time of two weeks), 2017, 2018, 2019,?.,
> 4031, 1209600*2, 4033, 4044, ?
>
> If we want to be pedantic, the best lower bound for a block timestamp is
> the timestamp of the block that closes the adjustment interval in which it
> resides.
>
> Possible improvement:
> -----------------------------
> We may consider exchanging average with standard deviation in the
> difficulty adjustment formula. It both better mirrors changes in the hash
> power along the interval, and disables the option to manipulate timestamps
> without affecting the difficulty.
>
> I'm aware that this change requires a hardfork, and won't happen any time
> soon. But does it make sense to add it to a potential future hard fork?
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/71830c72/attachment-0001.html>

From eric at voskuil.org  Mon Jan 29 23:21:48 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 29 Jan 2018 15:21:48 -0800
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAAS2fgQcMr231G4hF0rdp0M-rxOzLm07VHEdUuQ2BMnLa3A26g@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
	<CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>
	<261a9388-64fe-a664-85f0-4b0e8ca9ec1e@voskuil.org>
	<CAAS2fgQcMr231G4hF0rdp0M-rxOzLm07VHEdUuQ2BMnLa3A26g@mail.gmail.com>
Message-ID: <7ecea1c8-bc60-223e-6e7b-48b390363794@voskuil.org>

On 01/29/2018 01:22 PM, Gregory Maxwell wrote:
> On Mon, Jan 29, 2018 at 4:49 AM, Eric Voskuil via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>> I'm not sure who cooked up this myth about miners gaining advantage over
>> those who buy block space by mining empty space, rejecting higher-fee
>> transactions, and/or mining "recovery" transactions, but the idea is
>> complete nonsense.
> 
> I agree.
> 
> Steel-manning it, I guess I could argue that empty blocks are slightly
> more conspicuous and might invite retaliation especially given the
> high levels of mining centralization creates retaliation exposure. ...
> but dummy transactions are hardly less conspicuous, many nodes log now
> when blocks show up containing txn that they've never seen before.
> Moreover, inexplicably underfilled blocks are produced (e.g. by
> bitmain's antpool) and no retaliation seems to be forthcoming.

It's not clear to me what would be the reason for retaliation, given
there is no more harm in a miner purchasing a block than Coinbase
submitting enough transactions to fill a block. Both pay the market rate
for the space. But since the former results in a loss, a financial
consequence ("retaliation") is inherent.

If a farmer destroys his/her own apple crop he loses money. It may be
very conspicuous, but nobody would retaliate as only the farmer's own
property was affected. Customers would just get their apples elsewhere.
Block space created by a miner is property that belongs to the miner, it
can be sold or not sold.

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/3c12d82b/attachment.sig>

From greg at xiph.org  Tue Jan 30 01:59:48 2018
From: greg at xiph.org (Gregory Maxwell)
Date: Tue, 30 Jan 2018 01:59:48 +0000
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <7ecea1c8-bc60-223e-6e7b-48b390363794@voskuil.org>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
	<CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>
	<261a9388-64fe-a664-85f0-4b0e8ca9ec1e@voskuil.org>
	<CAAS2fgQcMr231G4hF0rdp0M-rxOzLm07VHEdUuQ2BMnLa3A26g@mail.gmail.com>
	<7ecea1c8-bc60-223e-6e7b-48b390363794@voskuil.org>
Message-ID: <CAAS2fgRcaRF5-8k94rL+fOjK2RJf0cjj+uqD+-db_VNZu9t8Xw@mail.gmail.com>

On Mon, Jan 29, 2018 at 11:21 PM, Eric Voskuil <eric at voskuil.org> wrote:
> Block space created by a miner is property that belongs to the miner, it
> can be sold or not sold.

That case would be stronger when there is no more subsidy, but we
collectively the uses of Bitcoin are currently paying miners around
$130k USD per block in the form of inflation for the job of honestly
complying with the Bitcoin protocol.

I don't think you can argue that they have any more right to do that
than any of us have a right to run software that invalidates their
coinbase outputs when they do; which would be the sort of retaliation
they might get targeted with.

From cannon at cannon-ciota.info  Tue Jan 30 01:43:22 2018
From: cannon at cannon-ciota.info (CANNON)
Date: Tue, 30 Jan 2018 01:43:22 +0000
Subject: [bitcoin-dev] NIST 8202 Blockchain Technology Overview
In-Reply-To: <6d24833d-f127-04ea-d180-c69409de16a5@cannon-ciota.info>
References: <6d24833d-f127-04ea-d180-c69409de16a5@cannon-ciota.info>
Message-ID: <6d92d8da-052d-f997-f441-0713acd72e85@cannon-ciota.info>



-------- Forwarded Message --------
Subject: RE: NIST 8202 Blockchain Technology Overview
Date: Mon, 29 Jan 2018 12:25:05 +0000
From: Yaga, Dylan (Fed) <dylan.yaga at nist.gov>
To: CANNON <cannon at cannon-ciota.info>

Thank you for your comments.
You, along with many others, expressed concern on section 8.1.2.
To help foster a full transparency approach on the editing of this section, I am sending the revised section to you for further comment. 

8.1.2	Bitcoin Cash (BCH)
In 2017, Bitcoin users adopted an improvement proposal for Segregated Witness (known as SegWit, where transactions are split into two segments: transactional data, and signature data) through a soft fork. SegWit made it possible to store transactional data in a more compact form while maintaining backwards compatibility.  However, a group of users had different opinions on how Bitcoin should evolve ? and developed a hard fork of the Bitcoin blockchain titled Bitcoin Cash. Rather than implementing the SegWit changes, the developers of Bitcoin Cash decided to simply increase the blocksize. When the hard fork occurred, people had access to the same amount of coins on Bitcoin and Bitcoin Cash.


From a at colourful.land  Tue Jan 30 01:23:13 2018
From: a at colourful.land (Weiwu Zhang)
Date: Tue, 30 Jan 2018 09:23:13 +0800 (+08)
Subject: [bitcoin-dev] 2 step confirmation system
Message-ID: <alpine.DEB.2.20.1801300801330.27227@notCBApc>


On Wed, 24 Jan 2018, rmcc4444 via bitcoin-dev wrote:

> I know from speaking to my friends not involved with Bitcoin that two of
> their major concerns are as follows:?
> 1. They are afraid if they fat finger the address there is nothing they can
> do about it and not get their Bitcoin back.

I can empathize with this. A friend of mine, an artificial intelligence
expert of the biggest bank in our country with a degree in math and IQ
of 150, copied his merchant's Bitcoin address as his and sent to a
colleague to ask for a repayment. As a result, the merchant got paid
twice. That was back a few years ago when Bitcoin could be used for
purchasing goods.

There are a few ways to address this issue.

For starter, the beneficiary's wallet can generate a signed payment
request instead of just an address. The AI expert, in his case,
wouldn't be able to generate a payment request for the merchant
because he doesn't have the merchant's key. The payment request can
have a timestamp for the sender to spot the reuse of old request. There
are advanced methods to go down this route, e.g. in the cases where
there is an invoice, or buyer's public key is known, these can be
associated with the payment request or be used in some homomorphic
magic to generate very special addresses to receive the money.

Then, there is the option of sending the transaction (in a private
channel) to the beneficiary instead of broadcasting the
transaction. The beneficiary, we trust, will not broadcast the
transaction if he would not receive money as a result of it or he sees
the transaction wasn't constructed correctly to his wish. In fact, he
may not be able to even see the transaction without the right private
key to generate a decoding session key. This method solves another
use-case: deniable payment. It's not unusual for a WeChat user to deny
another WeChat user's Red Packt ("I don't take bribes, sir!"). If it is
with Bitcoin, the beneficiary certainly does not want to pay the
transaction fee again just to nullify the previous payment to him. In
a more illustrative example, I like to give away free Bitcoins after
my lectures, but many of the students won't redeem their share because
money isn't the only motivation for their studies. I admit that money
is my motivation after all and I wish to reclaim the money that was
not redeemed by students. (I stopped this practise when giving away
Bitcoin costs more than the amount given.)

Finally, there is multi-sig. I'll cover that in answering the 2nd
section of your email.

> 2. They would like to at least have the option to use some sort of 2 step
> confirmation system when dealing ith people they do not know. For example,
> after sending the Bitcoin to a seller they would like to be able to do a
> final approval of the tm transaction. If the 2 people involved in the
> transaction approve of it within X hours, the coin returns to the original
> person. This system would basically act as an escrow.

There is the case of escrow with an arbitrator and escrow without an
arbitrator. We know that the beneficiary can always send the money
back by looking up the input address. Given that he alone has this
power, whether or not the other person agrees, to reimburse, it is a
moot point to require two people to co-sign anything. Therefore, the
case without arbitrageur is usually depended on time or revealing an x
to a known hash. This can go complicated so I'll turn around
and talk about the case with arbitrageur.

The case with an arbitrator was explained by Rhavar. It can be
elaborately built in a sheltered model, where a compromised arbitrator
can only revert transactions, not to steal. You can build fine-tuned
features with Rhavar's model, like setting a 90-day grace period where
the beneficiary cannot claim the money, in order to leave ample time
for the arbitrator to revert the transaction should he need to do so.

As Rhavar pointed out, it's too costly to be practical for daily
transactions. Back in 2012 when I learned about multi-sig, I hopped
multi-sig grew popular before the blockchain gets full so that people
have the opportunity to witness the power of Bitcoin. It unfortunately
didn't happen.

All of the methods I mentioned does not require any change to the
Bitcoin network or Bitcoin Blockchain. The wallet is the weakest link
in this chain. A wallet developer can go ahead and implement all these
without negotiating with Bitcoin developers.

P.S. I remark that I consistently use the word beneficiary because the
other choices like "receiver" or "recipient" are often meant for the
receiving of messages (e.g. in a private channel), who doesn't have to
be the beneficiary (e.g. an arbitrator receives a lot of
messages).

I check mail lists weekly so, sorry for the late reply.

From cannon at cannon-ciota.info  Tue Jan 30 03:30:21 2018
From: cannon at cannon-ciota.info (CANNON)
Date: Tue, 30 Jan 2018 03:30:21 +0000
Subject: [bitcoin-dev] NIST 8202 Blockchain Technology Overview
In-Reply-To: <6d92d8da-052d-f997-f441-0713acd72e85@cannon-ciota.info>
References: <6d24833d-f127-04ea-d180-c69409de16a5@cannon-ciota.info>
	<6d92d8da-052d-f997-f441-0713acd72e85@cannon-ciota.info>
Message-ID: <166a1118-6924-bef1-09bd-4db4d86ccb93@cannon-ciota.info>

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

On 01/30/2018 01:43 AM, CANNON via bitcoin-dev wrote:
> 
> 
> -------- Forwarded Message --------
> Subject: RE: NIST 8202 Blockchain Technology Overview
> Date: Mon, 29 Jan 2018 12:25:05 +0000
> From: Yaga, Dylan (Fed) <dylan.yaga at nist.gov>
> To: CANNON <cannon at cannon-ciota.info>
> 
> Thank you for your comments.
> You, along with many others, expressed concern on section 8.1.2.
> To help foster a full transparency approach on the editing of this section, I am sending the revised section to you for further comment. 
> 
> 8.1.2	Bitcoin Cash (BCH)
> In 2017, Bitcoin users adopted an improvement proposal for Segregated Witness (known as SegWit, where transactions are split into two segments: transactional data, and signature data) through a soft fork. SegWit made it possible to store transactional data in a more compact form while maintaining backwards compatibility.  However, a group of users had different opinions on how Bitcoin should evolve  and developed a hard fork of the Bitcoin blockchain titled Bitcoin Cash. Rather than implementing the SegWit changes, the developers of Bitcoin Cash decided to simply increase the blocksize. When the hard fork occurred, people had access to the same amount of coins on Bitcoin and Bitcoin Cash.
> 
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> 

This is much better than the original. My question, the part where it says segwit makes transactions more compact, I thought that transactions are not more compact but rather they just take advantage of extra blockspace beyond that of 1 MB? Yes they would appear to be more compact to un-upgraded nodes due to the witness being stripped, but the transactions are not actually more compact right?
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJab+afAAoJEAYDai9lH2mwCDAP/RRpExXmnPzlvxuhhJ+8gSlc
QRZHVa0nJ2SETTZnQSa+0t8dBO9ROYSnDHuMEqz/ba8o00Rce8icxQvCGOO29OSK
Cru7/UJzYTwnt5mK2ljpUB1Fsx96fAPxfg4QMeDCRe+O5LLkH1als1GGVOwlFnLu
BAV0MoCljWzBxokf0ax8+ZHHYEaKe+Fj9PKby7CZrqQKoL9PkI/n7EvqICUdTCu5
tAz9SNIBVtUxgGx/ZY96hvBx0zorV1IQEWchQ50oh/V+TgmnOW4njQOKc4TcSgfp
TKpRFs8Zd7TzeIS/85GX0APGypchxdjlBaV0EORTO9GYFo7nKlzHkIGOF9Er+E6q
II4qjbKLc5d/wwCIA8MHFW0Vxwv2+0ztApaWAFW42+LeHERaPCzi4NEy5quqvmsE
IiTaGebl2XbTd0I+aB6WWsScTUmfXrt+NL05kwE0KDylY/mSwYMgYjP95X1Mci7X
rcJRf6/pP607EiHlq3MmDlyt4TrYBp9FVVjdjvM+sD8wz72FhWeYJQdyF8t1ToOD
U/ItNsxl5Jx9JvCkBXoX+6MMZ91W7D2x04Ur3OMRmy/lOoztOYAdlKy0tMyRqfCi
L81apfjvmTaR2OTWhCawgZGLXGJcfOG5ECuXC90B6il5Jsts/XwyFMN2Fa1iZB50
cZwF3ySKxoVtpsf/vTW7
=feRa
-----END PGP SIGNATURE-----

From eric at voskuil.org  Tue Jan 30 03:52:21 2018
From: eric at voskuil.org (Eric Voskuil)
Date: Mon, 29 Jan 2018 19:52:21 -0800
Subject: [bitcoin-dev] Proposal: rewarding fees to next block miner
In-Reply-To: <CAAS2fgRcaRF5-8k94rL+fOjK2RJf0cjj+uqD+-db_VNZu9t8Xw@mail.gmail.com>
References: <CAPzrG5bFTbRERHQsmyFeZwiuakgSW5UCC8EtYfAm4j9EDtcLeg@mail.gmail.com>
	<CAGCathyVqQcBCKORQebicWq+OQfKZVLXb0g_9QHBu2e-jqYBgg@mail.gmail.com>
	<CAC94VgAoZFwu4TC8CdNP9cbxUiFgQP4bOsXykJyb4+8y-eSY1Q@mail.gmail.com>
	<261a9388-64fe-a664-85f0-4b0e8ca9ec1e@voskuil.org>
	<CAAS2fgQcMr231G4hF0rdp0M-rxOzLm07VHEdUuQ2BMnLa3A26g@mail.gmail.com>
	<7ecea1c8-bc60-223e-6e7b-48b390363794@voskuil.org>
	<CAAS2fgRcaRF5-8k94rL+fOjK2RJf0cjj+uqD+-db_VNZu9t8Xw@mail.gmail.com>
Message-ID: <d920046d-fee5-0f05-068a-87441e332382@voskuil.org>

On 01/29/2018 05:59 PM, Gregory Maxwell wrote:
> On Mon, Jan 29, 2018 at 11:21 PM, Eric Voskuil <eric at voskuil.org> wrote:
>> Block space created by a miner is property that belongs to the miner, it
>> can be sold or not sold.
> 
> That case would be stronger when there is no more subsidy, but we
> collectively the uses of Bitcoin are currently paying miners around
> $130k USD per block in the form of inflation for the job of honestly
> complying with the Bitcoin protocol.

The miner who creates a block owns the block, he/she has selected the
transactions and directs the reward. The case for this could hardly be
stronger.

The fact that there is subsidy implies that *part* of the cost of
creating the block is offset. But by not accepting the highest fee
transactions the miner is still accepting a net loss by purchasing the
space for himself. The hash power generated by the miner to create the
block contributes to confirmation security to a greater degree than for
which he has been rewarded.

You seem to be implying that there is dishonesty involved in purchasing
block space, or that it is somehow possible to earn reward while not
complying with the protocol. There is no honest or dishonest compliance
with a protocol, there is just compliance or non-compliance.

> I don't think you can argue that they have any more right to do that
> than any of us have a right to run software that invalidates their
> coinbase outputs when they do; which would be the sort of retaliation
> they might get targeted with.

Everyone can do whatever they want with their own machines, and I
haven't argued otherwise. As far as "rights" go, Bitcoin doesn't care.
I'm not one who has regularly raised hard fork fears while at the same
time threatening them. My objective is to dispel flawed reasoning, not
to negotiate for the rights of some group over another.

Some economic theories that get thrown around are baffling, this idea of
"retaliation" among them. Presumably the objective is to reduce
transaction confirmation costs. The theory would be that mining empty
blocks or mining own transactions is "unfairly" increasing revenue to
miners. Despite the incorrectness of this theory, the proposed cure
attempts to reduce returns to miners. However the consequence of
reducing returns to miners is simply a reduction of hash power (as the
least efficient miners become insolvent). Miners will continue to earn
the same rate of return on their capital as always. And the cost of
transactions will remain the same...

The presumed mechanism of the proposed retaliation is also baffling. A
miner (or anyone) can always create transactions, pay fees, and send
them out to the network. Given that we presume transactions without
identity, it is not possible (or desirable) to detect the source of
transactions. Maybe the assumption is that sending such transactions out
to the network would not satisfy the miner's objective, since the fees
cannot be "recovered". But this is the original flaw. Fees spent to
one's self cannot be recovered either! So if a miner wants to blow money
by filling up blocks with market fee transactions, they will be able to
do so at the same cost no matter how one tries to "retaliate".

e

-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 490 bytes
Desc: OpenPGP digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/33843370/attachment.sig>

From pete at petertodd.org  Tue Jan 30 07:22:55 2018
From: pete at petertodd.org (Peter Todd)
Date: Tue, 30 Jan 2018 02:22:55 -0500
Subject: [bitcoin-dev] NIST 8202 Blockchain Technology Overview
In-Reply-To: <166a1118-6924-bef1-09bd-4db4d86ccb93@cannon-ciota.info>
References: <6d24833d-f127-04ea-d180-c69409de16a5@cannon-ciota.info>
	<6d92d8da-052d-f997-f441-0713acd72e85@cannon-ciota.info>
	<166a1118-6924-bef1-09bd-4db4d86ccb93@cannon-ciota.info>
Message-ID: <20180130072255.GA1095@fedora-23-dvm>

On Tue, Jan 30, 2018 at 03:30:21AM +0000, CANNON via bitcoin-dev wrote:
> On 01/30/2018 01:43 AM, CANNON via bitcoin-dev wrote:
> > 
> > 
> > -------- Forwarded Message --------
> > Subject: RE: NIST 8202 Blockchain Technology Overview
> > Date: Mon, 29 Jan 2018 12:25:05 +0000
> > From: Yaga, Dylan (Fed) <dylan.yaga at nist.gov>
> > To: CANNON <cannon at cannon-ciota.info>
> > 
> > Thank you for your comments.
> > You, along with many others, expressed concern on section 8.1.2.
> > To help foster a full transparency approach on the editing of this section, I am sending the revised section to you for further comment. 
> > 
> > 8.1.2	Bitcoin Cash (BCH)
> > In 2017, Bitcoin users adopted an improvement proposal for Segregated Witness (known as SegWit, where transactions are split into two segments: transactional data, and signature data) through a soft fork. SegWit made it possible to store transactional data in a more compact form while maintaining backwards compatibility.  However, a group of users had different opinions on how Bitcoin should evolve  and developed a hard fork of the Bitcoin blockchain titled Bitcoin Cash. Rather than implementing the SegWit changes, the developers of Bitcoin Cash decided to simply increase the blocksize. When the hard fork occurred, people had access to the same amount of coins on Bitcoin and Bitcoin Cash.
> > 
> > _______________________________________________
> > bitcoin-dev mailing list
> > bitcoin-dev at lists.linuxfoundation.org
> > https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
> > 
> 
> This is much better than the original. My question, the part where it says segwit makes transactions more compact, I thought that transactions are not more compact but rather they just take advantage of extra blockspace beyond that of 1 MB? Yes they would appear to be more compact to un-upgraded nodes due to the witness being stripped, but the transactions are not actually more compact right?

That's absolutely right; this is why segwit is a blocksize increase first and
foremost rather than some kind of transaction size optimization.

It'd be good to get that corrected as well.

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/2bacacf2/attachment.sig>

From pete at petertodd.org  Tue Jan 30 07:27:16 2018
From: pete at petertodd.org (Peter Todd)
Date: Tue, 30 Jan 2018 02:27:16 -0500
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CAAS2fgRLMnpu5JHTxxJJvEQc8rj2Ox=cKCWcsvVdY06G0kKXJw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
	<CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>
	<CAAS2fgRLMnpu5JHTxxJJvEQc8rj2Ox=cKCWcsvVdY06G0kKXJw@mail.gmail.com>
Message-ID: <20180130072716.GB1095@fedora-23-dvm>

On Mon, Jan 29, 2018 at 09:54:23PM +0000, Gregory Maxwell via bitcoin-dev wrote:
> If times need to be accurate Bitcoin would need to use a rather
> different design (e.g. each block would commit to the observation time
> of the prior N blocks, and an iterative algorithm would solve for each
> blocks time and each miners local offset).
> 
> IIRC open-timestamp calendar servers provide more precise
> time-stamping under the assumption that the calendar server is
> behaving correctly.

That is incorrect. The OpenTimestamps servers are specifically designed not to
be trusted, and thus do not make any cryptographically verifiable attestations
as to when timestamps were created.

In the future I expect to add a trusted timestamping scheme via disposable keys
to the OpenTimestamps protocol, but that work isn't yet complete:

https://lists.opentimestamps.org/pipermail/ots-dev/2017-May/000001.html

-- 
https://petertodd.org 'peter'[:-1]@petertodd.org
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 488 bytes
Desc: Digital signature
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/ebd74375/attachment.sig>

From neiman.mail at gmail.com  Tue Jan 30 10:52:21 2018
From: neiman.mail at gmail.com (Neiman)
Date: Tue, 30 Jan 2018 11:52:21 +0100
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
	<CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>
Message-ID: <CACRYg-7dzUr++6yJVHnFvGuzXP6-hMEecfM-ttamqqoPkg52rw@mail.gmail.com>

On Mon, Jan 29, 2018 at 10:40 PM, Tier Nolan via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

>
> Much of Bitcoin operates on the assumption that a majority of miners are
> honest.  If 50%+ of miners set their timestamp reasonably accurately (say
> within 10 mins), then the actual timestamp will move forward at the same
> rate as real time.
>

Thank you for replying. I agree that under the 50%+ assumption, timestamps
are reasonably accurately, but I fail to see a reason to make this
assumption.

I'm comfortable with the 50%+ assumption regarding ledger manipulation
(double-spending, deletion of transactions etc.). I'm much less comfortable
with it regarding timestamps manipulation.

Consider the following situation:
(1) miners are selfish,
(2) miners have a financial incentive to be dishonest.

(1) is a common state on how miners function nowadays. (2) is the case that
interests us when coming to do this analysis.

In the case of ledger manipulation, the 50%+ assumption is not because we
assume that miners are good-hearted (this violates (1)). It is there due to
an assumption that the financial damage to a miner would be bigger than the
gain in (2). This happens since a ledge manipulation may cause miners to
lose block rewards, and certainly will devaluate Bitcoin, an asset which
they possess.

In the case of timestamps manipulation, I don't see any financial damage
caused to miners. Timestamps manipulation (besides the 2016*n blocks) won't
harm the function of Bitcoin, and may even go undetected (it seems to me
that the main blockchain explorers don't track it). I don't see a
justification for the 50%+ assumption here.


>
> Dishonest miners could set their timestamp as low as possible, but the
> median would move foward if more than half of the timestamps move forward.
>
>
>> If we want to be pedantic, the best lower bound for a block timestamp is
>> the timestamp of the block that closes the adjustment interval in which it
>> resides.
>>
>
> If you are assuming that the miners are majority dishonest, then they can
> set the limit to anything as long as they don't move it more than 2 hours
> into the future.
>
> The miners could set their timestamps so that they increase 1 week fake
> time every 2 weeks real time and reject any blocks more than 2 hours ahead
> of their fake time.  The difficulty would settle so that one block occurs
> every 20 mins.
>
>
>>
>> Possible improvement:
>> -----------------------------
>> We may consider exchanging average with standard deviation in the
>> difficulty adjustment formula. It both better mirrors changes in the hash
>> power along the interval, and disables the option to manipulate timestamps
>> without affecting the difficulty.
>>
>> I'm aware that this change requires a hardfork, and won't happen any time
>> soon. But does it make sense to add it to a potential future hard fork?
>>
>
> For check locktime, the median of the last 11 blocks is used as an
> improved indicator of what the actual real time is.  Again, it assumes that
> a majority of the miners are honest.
>
>>
>>
>> _______________________________________________
>> bitcoin-dev mailing list
>> bitcoin-dev at lists.linuxfoundation.org
>> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>>
>>
>
> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/dcc2af82/attachment-0001.html>

From neiman.mail at gmail.com  Tue Jan 30 10:53:41 2018
From: neiman.mail at gmail.com (Neiman)
Date: Tue, 30 Jan 2018 11:53:41 +0100
Subject: [bitcoin-dev] How accurate are the Bitcoin timestamps?
In-Reply-To: <CAAS2fgRLMnpu5JHTxxJJvEQc8rj2Ox=cKCWcsvVdY06G0kKXJw@mail.gmail.com>
References: <CACRYg-4ho-XGK3xUdQW-ny2BFs2O91BuendrxuVYBni4wHrRqw@mail.gmail.com>
	<CAE-z3OXX7Axf23oCDFmQYCth0tOQw9PEzLwvQO9Pk0wy7t1pYw@mail.gmail.com>
	<CAAS2fgRLMnpu5JHTxxJJvEQc8rj2Ox=cKCWcsvVdY06G0kKXJw@mail.gmail.com>
Message-ID: <CACRYg-6_Zaw8aQ_mJarMiGJ184EYcYvAbVptAznoP1FQngFakg@mail.gmail.com>

On Mon, Jan 29, 2018 at 10:54 PM, Gregory Maxwell via bitcoin-dev <
bitcoin-dev at lists.linuxfoundation.org> wrote:

> On Mon, Jan 29, 2018 at 9:40 PM, Tier Nolan via bitcoin-dev
> <bitcoin-dev at lists.linuxfoundation.org> wrote:
>
>  if there were tighter time requirements in the protocol
> miners would address them by running NTP which as an _astounding_ lack
> of security in terms of how it is commonly deployed.
>

Could you say a few more words about this lack of security? Or share a link
if you have one. I know very little about NTPs.


> _______________________________________________
> bitcoin-dev mailing list
> bitcoin-dev at lists.linuxfoundation.org
> https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/75a5c9a7/attachment.html>

From ZmnSCPxj at protonmail.com  Tue Jan 30 05:32:58 2018
From: ZmnSCPxj at protonmail.com (ZmnSCPxj)
Date: Tue, 30 Jan 2018 00:32:58 -0500
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
	(Chaofan Li)
In-Reply-To: <CANZDnNo29+9jezspt8sRaq8WpUjLghkQ0Ubvxb6=_2nuOs-frw@mail.gmail.com>
References: <CANZDnNoGnab6HYESA0oOL-8Q8HtR1Ns0AfP3KNEmwU6KN5W5pA@mail.gmail.com>
	<16b2ea77-3ff5-81b1-d3d7-a7107f4b37fc@voskuil.org>
	<CANZDnNo29+9jezspt8sRaq8WpUjLghkQ0Ubvxb6=_2nuOs-frw@mail.gmail.com>
Message-ID: <TPisDO8RJhPB6N8hdXNKMdJvWTw3nLycrGPRXPN32Fj9FqqMJ9mEgtiHmqYX5vK9kvCYFtwNkrMGqB2QcuK16CL6Tz8Xb1DcyaNmsJIOSF0=@protonmail.com>

Good Morning Chaofan Li,

> The human perception of difference will be eliminated.
> Will your bank tell you whether your balance means coins or paper money?
> If wallets and exchanges only show the total amount of btc rather than btc.0 and btc.1, there is no human perception difference.

This returns my initial question.

What ensures that a paper money with "10 Dollar" on it, is same as 10 coins each with "1 Dollar" on it?

This is the principle of fungibility, and means I can exchange a paper with "10 Dollar" on it for 10 coins with "1 Dollar" on it, because by government fiat, such an exchange is valid for all cases.

What ensures that btc.0 and btc.1 are indistinguishable from a human perception?

> Also note that one valid address is automatically valid on the other chain, which means you can send money through any one chain. As long as one has the private key, he/she can get the money anyway. So there is no difference between number of merchants. The merchant ?s address is valid on both chains.
>
> The exchange cost would be trivial. People don?t need to exchange two same thing.

You are talking about sidechains.  In every sidechain proposal, there is always some mechanism (SPV proof-of-work, drivechain proof-of-voting, proof-of-mainstake...) that ensures that a sidechain coin is exchangeable for a mainchain coin, and from there, that every sidechain coin is exchangeable for every other sidechain coin.  I.e. that a smart contract with "1 BTC" on it is exchangeable for a mainchain UTXO of value "1 BTC".

A mere split is not enough.  As I brought up, what makes your proposal different from 2X, BCash, etc.?

Regards,
ZmnSCPxj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/faa9616f/attachment.html>

From li3939108 at gmail.com  Tue Jan 30 06:20:35 2018
From: li3939108 at gmail.com (Chaofan Li)
Date: Mon, 29 Jan 2018 22:20:35 -0800
Subject: [bitcoin-dev] Blockchain Voluntary Fork (Split) Proposal
	(Chaofan Li)
In-Reply-To: <TPisDO8RJhPB6N8hdXNKMdJvWTw3nLycrGPRXPN32Fj9FqqMJ9mEgtiHmqYX5vK9kvCYFtwNkrMGqB2QcuK16CL6Tz8Xb1DcyaNmsJIOSF0=@protonmail.com>
References: <CANZDnNoGnab6HYESA0oOL-8Q8HtR1Ns0AfP3KNEmwU6KN5W5pA@mail.gmail.com>
	<16b2ea77-3ff5-81b1-d3d7-a7107f4b37fc@voskuil.org>
	<CANZDnNo29+9jezspt8sRaq8WpUjLghkQ0Ubvxb6=_2nuOs-frw@mail.gmail.com>
	<TPisDO8RJhPB6N8hdXNKMdJvWTw3nLycrGPRXPN32Fj9FqqMJ9mEgtiHmqYX5vK9kvCYFtwNkrMGqB2QcuK16CL6Tz8Xb1DcyaNmsJIOSF0=@protonmail.com>
Message-ID: <CANZDnNrQ2K5gMKLNDVoWJZptyVz-kgN-d+LO8fGi1rxw9no9Zg@mail.gmail.com>

Hi ZmnSCPxj,


On Mon, Jan 29, 2018 at 9:32 PM, ZmnSCPxj wrote:
>What ensures that a paper money with "10 Dollar" on it, is same as 10
coins each with "1 Dollar" on it?
>This is the principle of fungibility, and means I can exchange a paper
with "10 Dollar" on it for 10 coins with "1 Dollar" on it, because by
government fiat, such an exchange is valid for all cases.
>What ensures that btc.0 and btc.1 are indistinguishable from a human
perception?

This is a good question. Does anyone think about why the bitcoins generated
from different blocks have the same value? Some of them are still
distinguishable ( if they are not combined with others sent out).  Would
the bitcoins that can be traced back to the block where it was generated
be worth different from others ?   If one day Satoshi released
his/her/their bitcoins  , would the bitcoins from the first several blocks
mined by Satoshi be worth more?

I think for fungibility, it is not like either it has fungibility or it has
no fungibility. There should be a value of fungibility (e.g. from 0 to 1)
that can be measured or evaluated.

Chaofan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180129/2db54fc6/attachment.html>

From roconnor at blockstream.io  Tue Jan 30 19:12:31 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 30 Jan 2018 14:12:31 -0500
Subject: [bitcoin-dev] Design approaches for Signature Aggregation
Message-ID: <CAMZUoK=A0CXVw81TeKhRSwPOp39qwqwyQ0_zoKLq8kONko14Ng@mail.gmail.com>

On Sat, Jan 27, 2018 at 12:23 PM, Matt Corallo <lf-lists at mattcorallo.com>
wrote:

> Gah, please no. I see no material reason why cross-input signature
> aggregation shouldn't have the signatures in the first n-1 inputs replaced
> with something like a single-byte push where a signature is required to
> indicate aggregation, and the combined signature in the last input at
> whatever position the signature is required.
>

That would be the expedient approach.

I want to preface what I'm about to write by first stating that I think the
cross-input signature aggregation is the most important forthcoming
development for Bitcoin and I would be very happy to have any solution for
it deployed in any workable form.  Also, it is difficult to discuss pros
and cons of various designs without concrete proposals, but perhaps we can
try to say some things about various design approaches while still saying
something useful.

I think there are some issues with the expedient proposal for signature
aggregation.  The problems begin with the arbitrary choice of which input
witness will be the canonical choice for holding the aggregated signature.
We want to strictly define which input is the canonical choice for holding
the aggregated signature because we wish to avoid introducing new witness
malleability vectors.  However, the definition of the canonical input is
somewhat complicated.  Because not all inputs are necessarily participating
the aggregation, the canonical choice of input necessarily depends on the
run-time behavior of all the other input Scripts in the transaction.  This
complicates the specification and makes the implementation somewhat
error-prone.

Furthermore designing the canonical choice of input for the aggregated
signature to support future extensions of new script versions or new
opcodes that may want to participate in signature aggregation (for example,
adding CHECKSIGFROMSTACK later) is going to be extraordinarily difficult, I
think.  I don't know how it could even be done.

On the other hand, the extended-transaction approach supports a clean model
of script semantics whereby the signature aggregation is supported via a
new writer (aka logging) side-effect for Script[1].  In this model, rather
than the semantics of Script returning only failure or success, Script
instead results in either failure or conditional success plus a log of
additional constraints that need to be satisfied for the transaction to be
valid.  In the case of signature aggregation, these constraints are of the
form "I require cryptographic evidence that there is a signature on message
M from public key P".  The aggregated signature in the extension of the
transaction provides a witness that demonstrates all the constraints
emitted by all the scripts are satisfied.

Even in the extended-transaction approach, supporting future extensions of
new script versions or new opcodes that may want to participate in
signature aggregation is going to be very difficult.  However, I do have
some half-baked ideas (that you will probably like even less) on how we
could support new script versions and new opcodes based on this idea of a
writer side-effect model of Script semantics.  I hope that designing
support for extendable signature aggregation isn't infeasible.

I think that the cleaner semantic model of the extended-transaction
approach is by itself enough reason to prefer it over the expedient
approach, but reasonable people can disagree about this.  However, there
are even larger issues lurking which appear when we start looking for
unintended semantic consequences of the expedient design.  This is a common
problem with expedient approaches.  It is hard enough to come up with a
design that enables a new feature, but it is even harder to come up with a
design that enables a new feature without enabling other, unintended
"features".  I worry that people do not pay enough attention to the later,
after achieving the former. This sort of thing happened with OP_EVAL in bip
12.  In that situation, the goal was to create a design that enabled pay to
script hash, and OP_EVAL does achieve that in a very straightforward way.
However, the unintended semantic consequences was that bip 12 also enable
unbounded recursion[2] and extended the class of functions definable by
script all the way to the entire class of all computable functions.

We can find unintended semantic consequences of the expedient approach to
signature aggregation by looking at the ways it fails to fit into the
writer side-effect model for signature aggregation.

A. Firstly, we notice that scripts can determine whether or not they are in
canonical position or not by checking the length of their signature data.
This is an effect that goes beyond the abilities of just allowing signature
aggregation.  We can build scripts that can only be redeemed when they are,
or aren't the ones holding the aggregated signature.

B. In the presence of sufficient computation power[3], I expect that
scripts can recover the public keys and signed message data of the
aggregated data, using the same methods used in Enchancing Bitcoin
Transactions with Covenants
<http://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf>. With this
ability, the script in canonical position can determine what messages are
being signed by other inputs, and which public keys they have chosen to
use.  Perhaps a script could enforce a whitelist or blacklist of
approved/disapproved public keys that it is willing or unwilling to be
aggregated with, etc.

C. Scripts can subvert the use the public keys being aggregated themselves
for the purpose of communicate arbitrary data to other script inputs.  With
aggregated CHECKSIGFROMSTACK, scripts can directly use signed messages for
this communication.

I'm not trying to say that the above are good or bad things, after all
signature aggregation is an interactive process so it is expected that
users could decide which keys they are willing to aggregate with.  What I'm
trying to say is that the expedient proposal has a host of unintended
semantic consequences and the above list is only the ones that I can think
of off the top of my head.  I do not even know the full extent of what we
will be enabling with this design but it seems to include adding a
subversive unidirectional cross-input communication channel for Script. Is
that really a feature we want to be bundling with a signature aggregation
proposal?

I believe that the extended-transaction design is the conservative design.
I conjecture that one can build a reduction from scripts supporting
signature aggregation in the extended-transaction design to scripts that
don't support signature aggregation, while preserving the same security
properties. (The proposed reduction would "simply" replace every aggregated
signature call with a non-aggregated signature call.)  If this conjecture
holds, that means we can prove that the extended-transaction design is only
an optimization and doesn't have any further unintended semantic
consequences.  In particular, we see that the expedient approach doesn't
have such a reduction proof because scripts that are using the expedient
design for cross-input communication cannot be modeled by scripts that
don't have the signature aggregation ability.

I would be disappointed if we end up taking the expedient approach to
signature aggregation (but still very happy that we get signature
aggregation), and there are probably other designs for signature
aggregation beyond the two designs I'm discussing here.

-- 
Russell

[1]For those familiar with using monads to model side-effects, we can model
the output of Script as a (M Bool) value where M is a writer monad over the
monoid of a set of formal constraints, or some other small variant of this
model.  I know that the word monad makes some people's eyes glaze over, but
I'm not trying to use jargon here to exclude people; I'm trying to use
jargon here to be precise about what it means to formally model
computational side-effects for those who are familiar how to do that sort
of thing.

[2]Due to an attempt at a gas limit, OP_EVAL wasn't not intended to enable
unbounded computation in practice.  However when talking about the formal
expressiveness of a programming language we usually discard these sorts of
limits, such as stack size limits, gas limits etc.  Those limits are there
to prevent denial of service attacks against Bitcoin consensus.  The limits
are not designed to enforce language and security properties through the
restriction of computational expressiveness.

[3]Here sufficient computation power means that we have access to functions
like CHECKSIGFROMSTACK and/or basic operations on elliptic curves and hash
functions.  These are all pure functions that can be defined by logical
gates. Since bitcoin script has boolean logic operations, they technically
fall into scope of what is ostensibly definable by script.  Nevertheless,
these sorts of functions could reasonably appear in a Bitcoin Script 2.0 as
they would make a host of new protocols practical.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/0d07d20c/attachment-0001.html>

From roconnor at blockstream.io  Tue Jan 30 23:25:55 2018
From: roconnor at blockstream.io (Russell O'Connor)
Date: Tue, 30 Jan 2018 18:25:55 -0500
Subject: [bitcoin-dev] Design approaches for Signature Aggregation
In-Reply-To: <CAMZUoK=A0CXVw81TeKhRSwPOp39qwqwyQ0_zoKLq8kONko14Ng@mail.gmail.com>
References: <CAMZUoK=A0CXVw81TeKhRSwPOp39qwqwyQ0_zoKLq8kONko14Ng@mail.gmail.com>
Message-ID: <CAMZUoKk4n_2=GZE1rsRPtGFg6FMpvSbxNhj8o5tLVDcOWmoGCw@mail.gmail.com>

On Tue, Jan 30, 2018 at 2:12 PM, Russell O'Connor <roconnor at blockstream.io>
wrote:

>
> and there are probably other designs for signature aggregation beyond the
> two designs I'm discussing here.
>

For example, in private communication Pieter suggested putting the
aggregate signature data into the top of the first segwit v1+ input witness
(and pop it off before evaluation of the input script) whether or not that
input is participating in the aggregation or not.  This makes this
canonical choice of position independent of the runtime behaviour of other
scripts and also prevents the script from accessing the aggregate signature
data itself, while still fitting it into the existing witness data
structure. (It doesn't let us toy with the weights of aggregated signature,
but I hope people will still be motivated to use taproot solely over P2WPKH
based on having the option to perform aggregation.)

Being able to allow aggregation to be compatible with future script or
opcode upgrades is still very difficult to design.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.linuxfoundation.org/pipermail/bitcoin-dev/attachments/20180130/f2aaff7d/attachment.html>

